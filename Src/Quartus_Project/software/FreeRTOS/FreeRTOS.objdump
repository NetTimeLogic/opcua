
FreeRTOS.elf:     file format elf32-littlenios2
FreeRTOS.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01800424

Program Header:
    LOAD off    0x00001020 vaddr 0x02010020 paddr 0x01800000 align 2**12
         filesz 0x00000424 memsz 0x00000424 flags r-x
    LOAD off    0x00002424 vaddr 0x01800424 paddr 0x01800424 align 2**12
         filesz 0x00043b0c memsz 0x00043b0c flags r-x
    LOAD off    0x00045f30 vaddr 0x01843f30 paddr 0x01845dc8 align 2**12
         filesz 0x00001e98 memsz 0x00001e98 flags rw-
    LOAD off    0x00048c60 vaddr 0x01847c60 paddr 0x01847c60 align 2**12
         filesz 0x00000000 memsz 0x00022ea4 flags rw-
    LOAD off    0x00048000 vaddr 0x02010000 paddr 0x02010000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02010000  02010000  00048000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000424  02010020  01800000  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00040a44  01800424  01800424  00002424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000030c8  01840e68  01840e68  00042e68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001e98  01843f30  01845dc8  00045f30  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00022ea4  01847c60  01847c60  00048c60  2**2
                  ALLOC, SMALL_DATA
  6 .tse_descriptor_memory_0 00000000  00000000  00000000  00048020  2**0
                  CONTENTS
  7 .sdram_controller_0 00000000  0186ab04  0186ab04  00048020  2**0
                  CONTENTS
  8 .mem_0        00000000  02010444  02010444  00048020  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00048020  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001660  00000000  00000000  00048048  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0004af82  00000000  00000000  000496a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000f726  00000000  00000000  0009462a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00017bd6  00000000  00000000  000a3d50  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000081f4  00000000  00000000  000bb928  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000a9b3  00000000  00000000  000c3b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001cc6c  00000000  00000000  000ce4cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  000eb13c  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001bc0  00000000  00000000  000eb190  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000008  00000000  00000000  000f6396  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  000f639e  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  000f63a3  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  000f63a4  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000006  00000000  00000000  000f63a5  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000006  00000000  00000000  000f63ab  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000006  00000000  00000000  000f63b1  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000004  00000000  00000000  000f63b7  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001c  00000000  00000000  000f63bb  2**0
                  CONTENTS, READONLY
 28 .jdi          0000495a  00000000  00000000  000f63d7  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0009c7a0  00000000  00000000  000fad31  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02010000 l    d  .entry	00000000 .entry
02010020 l    d  .exceptions	00000000 .exceptions
01800424 l    d  .text	00000000 .text
01840e68 l    d  .rodata	00000000 .rodata
01843f30 l    d  .rwdata	00000000 .rwdata
01847c60 l    d  .bss	00000000 .bss
00000000 l    d  .tse_descriptor_memory_0	00000000 .tse_descriptor_memory_0
0186ab04 l    d  .sdram_controller_0	00000000 .sdram_controller_0
02010444 l    d  .mem_0	00000000 .mem_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../FreeRTOS_bsp//obj/HAL/src/crt0.o
0180045c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
02010020 l       .exceptions	00000000 save_context
020100a8 l       .exceptions	00000000 save_sp_to_pxCurrentTCB
020100c0 l       .exceptions	00000000 hw_irq_test
02010344 l       .exceptions	00000000 soft_exceptions
020100d4 l       .exceptions	00000000 hw_irq_handler
020100f0 l       .exceptions	00000000 restore_context
02010360 l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
01847c60 l     O .bss	00000004 nw_ready
01847c64 l     O .bss	00000004 main_thread_handle
018004b8 l     F .text	000000b0 StatusCallback
01800568 l     F .text	00000044 LinkCallback
018005f4 l     F .text	000001d0 WaitOnPHY
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 vfprintf.c
018413b6 l     O .rodata	00000010 zeroes.4404
01802e68 l     F .text	000000bc __sbprintf
018413c6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
01803078 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
01804ba8 l     F .text	00000008 __fp_unlock
01804bbc l     F .text	0000019c __sinit.part.1
01804d58 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
01843f30 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 locale.c
01844374 l     O .rwdata	00000020 lc_ctype_charset
01844354 l     O .rwdata	00000020 lc_message_charset
01844394 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mprec.c
018413f8 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
01807670 l     F .text	000000fc __sprint_r.part.0
0184152c l     O .rodata	00000010 blanks.4348
0184151c l     O .rodata	00000010 zeroes.4349
01808bfc l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 queue.c
0180d7ac l     F .text	00000090 prvInitialiseNewQueue
0180d83c l     F .text	00000060 prvInitialiseMutex
0180e7a4 l     F .text	0000018c prvCopyDataToQueue
0180eb88 l     F .text	00000068 prvIsQueueFull
0180e9cc l     F .text	00000114 prvUnlockQueue
0180e930 l     F .text	0000009c prvCopyDataFromQueue
0180eae0 l     F .text	00000060 prvIsQueueEmpty
0180e754 l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 tasks.c
01847dfc l     O .bss	00000064 pxReadyTasksLists
01847e60 l     O .bss	00000014 xDelayedTaskList1
01847e74 l     O .bss	00000014 xDelayedTaskList2
01847ca0 l     O .bss	00000004 pxDelayedTaskList
01847ca4 l     O .bss	00000004 pxOverflowDelayedTaskList
01847e88 l     O .bss	00000014 xPendingReadyList
01847e9c l     O .bss	00000014 xTasksWaitingTermination
01847ca8 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
01847eb0 l     O .bss	00000014 xSuspendedTaskList
01847cac l     O .bss	00000004 uxCurrentNumberOfTasks
01847cb0 l     O .bss	00000004 xTickCount
01847cb4 l     O .bss	00000004 uxTopReadyPriority
01847cb8 l     O .bss	00000004 xSchedulerRunning
01847cbc l     O .bss	00000004 xPendedTicks
01847cc0 l     O .bss	00000004 xYieldPending
01847cc4 l     O .bss	00000004 xNumOfOverflows
01847cc8 l     O .bss	00000004 uxTaskNumber
01847ccc l     O .bss	00000004 xNextTaskUnblockTime
01847cd0 l     O .bss	00000004 xIdleTaskHandle
01847cd4 l     O .bss	00000004 uxSchedulerSuspended
0180ede8 l     F .text	000001e4 prvInitialiseNewTask
0180efcc l     F .text	00000118 prvAddNewTaskToReadyList
0181072c l     F .text	000000b8 prvInitialiseTaskLists
01810bb4 l     F .text	00000044 prvDeleteTCB
01810bf8 l     F .text	00000054 prvResetNextTaskUnblockTime
01811910 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
0180f7cc l     F .text	0000006c prvTaskIsTaskSuspended
01810710 l     F .text	0000001c prvIdleTask
018109cc l     F .text	00000128 prvListTasksWithinSingleList
018107e4 l     F .text	00000090 prvCheckTasksWaitingTermination
01810af4 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
01847ec4 l     O .bss	00000014 xActiveTimerList1
01847ed8 l     O .bss	00000014 xActiveTimerList2
01847cd8 l     O .bss	00000004 pxCurrentTimerList
01847cdc l     O .bss	00000004 pxOverflowTimerList
01847ce0 l     O .bss	00000004 xTimerQueue
01847ce4 l     O .bss	00000004 xTimerTaskHandle
018124c0 l     F .text	0000008c prvCheckForValidListAndQueue
01811ee8 l     F .text	0000003c prvTimerTask
01811ad8 l     F .text	000000a4 prvInitialiseNewTimer
01811e10 l     F .text	000000d8 prvProcessExpiredTimer
018120b8 l     F .text	000000dc prvInsertTimerInActiveList
01811fec l     F .text	00000068 prvGetNextExpireTime
01811f24 l     F .text	000000c8 prvProcessTimerOrBlockTask
01812194 l     F .text	00000218 prvProcessReceivedCommands
01812054 l     F .text	00000064 prvSampleTimeNow
01847ce8 l     O .bss	00000004 xLastTime.2917
018123ac l     F .text	00000114 prvSwitchTimerLists
00000000 l    df *ABS*	00000000 alt_dev.c
018126cc l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_fstat.c
018127b8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_io_redirect.c
018128a4 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_isatty.c
018129e4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
01812ac4 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
01812bb0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_open.c
01812cc0 l     F .text	0000003c alt_get_errno
01812cfc l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
01845d7c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_lwip_close.c
00000000 l    df *ABS*	00000000 alt_lwip_read.c
00000000 l    df *ABS*	00000000 alt_lwip_write.c
00000000 l    df *ABS*	00000000 altera_tse_ethernetif.c
018133d8 l     F .text	00000074 low_level_init
0181344c l     F .text	00000154 low_level_input
00000000 l    df *ABS*	00000000 lwip_main.c
01847cf0 l     O .bss	00000004 status_callback
01847cf4 l     O .bss	00000004 link_callback
018139ec l     F .text	0000025c lwip_handle_interfaces
01813fe0 l     F .text	00000040 lwip_status_callback
01813e58 l     F .text	000000d0 lwip_handle_ethernet_input
01813da4 l     F .text	000000b4 lwip_check_link_status
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 sys_arch.c
00000000 l    df *ABS*	00000000 dhcp.c
01815718 l     F .text	00000058 dhcp_clear_assignment
01815770 l     F .text	00000054 dhcp_handle_nak
01817384 l     F .text	0000005c dhcp_set_state
01816898 l     F .text	000001a0 dhcp_discover
018157c4 l     F .text	000000a0 dhcp_check
01815864 l     F .text	000000ec dhcp_handle_offer
01815950 l     F .text	00000260 dhcp_select
0181835c l     F .text	00000584 dhcp_create_msg
018173e0 l     F .text	0000009c dhcp_option
018174dc l     F .text	00000098 dhcp_option_short
01817574 l     F .text	0000010c dhcp_option_long
0181747c l     F .text	00000060 dhcp_option_byte
01817680 l     F .text	000000dc dhcp_option_hostname
01818964 l     F .text	000000fc dhcp_option_trailer
018188e0 l     F .text	00000084 dhcp_delete_msg
01815f24 l     F .text	0000007c dhcp_t2_timeout
01815ea8 l     F .text	0000007c dhcp_t1_timeout
01815d10 l     F .text	00000198 dhcp_timeout
01816a38 l     F .text	0000028c dhcp_bind
01816e28 l     F .text	0000015c dhcp_rebind
01816f84 l     F .text	000001a4 dhcp_reboot
01815fa0 l     F .text	00000218 dhcp_handle_ack
01818004 l     F .text	00000358 dhcp_recv
01816734 l     F .text	00000164 dhcp_decline
0181775c l     F .text	000008a8 dhcp_parse_reply
01845d80 l     O .rwdata	00000004 xid.3993
00000000 l    df *ABS*	00000000 ip_addr.c
01847eec l     O .bss	00000010 str.3409
00000000 l    df *ABS*	00000000 mem.c
01847d08 l     O .bss	00000004 ram
01847d0c l     O .bss	00000004 ram_end
01847d10 l     O .bss	00000004 lfree
01847d14 l     O .bss	00000004 mem_mutex
018191fc l     F .text	00000128 plug_holes
00000000 l    df *ABS*	00000000 netif.c
01847d18 l     O .bss	00000001 netif_num
00000000 l    df *ABS*	00000000 pbuf.c
0181a398 l     F .text	00000088 pbuf_free_ooseq
0181a420 l     F .text	00000030 pbuf_free_ooseq_callback
0181a450 l     F .text	00000098 pbuf_pool_is_empty
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 tcp.c
01845d8c l     O .rwdata	00000002 tcp_port
01847d28 l     O .bss	00000001 tcp_timer
01847d29 l     O .bss	00000001 tcp_timer_ctr
0181baf8 l     F .text	0000034c tcp_close_shutdown
0181c728 l     F .text	000000d8 tcp_new_port
0181c2f8 l     F .text	00000030 tcp_accept_null
0181d6e4 l     F .text	000000d8 tcp_kill_prio
0181d7bc l     F .text	00000094 tcp_kill_timewait
01845d98 l     O .rwdata	00000004 iss.4104
00000000 l    df *ABS*	00000000 tcp_out.c
0181df3c l     F .text	000003e8 tcp_output_alloc_header
0181e46c l     F .text	000003a0 tcp_create_segment
0181e80c l     F .text	00000120 tcp_pbuf_prealloc
0181e92c l     F .text	000000b8 tcp_seg_add_chksum
0181e9e4 l     F .text	00000124 tcp_write_checks
01820368 l     F .text	00000600 tcp_output_segment
00000000 l    df *ABS*	00000000 timers.c
01847d44 l     O .bss	00000004 next_timeout
01847d48 l     O .bss	00000004 tcpip_tcp_timer_active
01821634 l     F .text	0000005c tcpip_tcp_timer
018216ec l     F .text	00000044 ip_reass_timer
01821730 l     F .text	00000044 arp_timer
01821774 l     F .text	00000044 dhcp_timer_coarse
018217b8 l     F .text	00000044 dhcp_timer_fine
00000000 l    df *ABS*	00000000 udp.c
01845d9c l     O .rwdata	00000002 udp_port
01821c18 l     F .text	0000009c udp_new_port
00000000 l    df *ABS*	00000000 etharp.c
01847efc l     O .bss	000001f4 arp_table
01822cb0 l     F .text	00000068 free_etharp_q
01822d18 l     F .text	0000009c etharp_free_entry
01822f30 l     F .text	00000318 etharp_find_entry
01823248 l     F .text	000000a4 etharp_send_ip
018232ec l     F .text	000001c8 etharp_update_arp_entry
01823618 l     F .text	000000e8 etharp_ip_input
01823700 l     F .text	0000038c etharp_arp_input
01823a8c l     F .text	0000010c etharp_output_to_arp_index
01824238 l     F .text	0000024c etharp_raw
00000000 l    df *ABS*	00000000 ping.c
01847d50 l     O .bss	00000002 ping_seq_num
01847d54 l     O .bss	00000004 ping_time
00000000 l    df *ABS*	00000000 alt_sys_init.c
01824cc8 l     F .text	00000034 alt_dev_reg
0184497c l     O .rwdata	00001068 jtag_uart_0
018459e4 l     O .rwdata	00000030 sgdma_tse_rx_0
01845a14 l     O .rwdata	00000030 sgdma_tse_tx_0
01845a44 l     O .rwdata	000000cc uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0182508c l     F .text	0000020c altera_avalon_jtag_uart_irq
01825298 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
01825948 l     F .text	0000003c alt_get_errno
01826578 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
018266dc l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
01826a3c l     F .text	0000009c altera_avalon_uart_irq
01826ad8 l     F .text	000000e4 altera_avalon_uart_rxirq
01826bbc l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
01826d58 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
01826fac l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
00000000 l    df *ABS*	00000000 heap_3.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
01827594 l     F .text	0000002c prvReadGp
01847d5c l     O .bss	00000004 lastContext
00000000 l    df *ABS*	00000000 tse_ethernet_phys.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
01827a48 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
01827b9c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_gettod.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
018283bc l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_write.c
018286c8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 sockets.c
018480f0 l     O .bss	000003f0 sockets
01847d7c l     O .bss	00000004 select_cb_list
01847d80 l     O .bss	00000004 select_cb_ctr
01841d84 l     O .rodata	00000040 err_to_errno_table
01828840 l     F .text	00000078 get_socket
018288b8 l     F .text	00000080 tryget_socket
01828938 l     F .text	000001a0 alloc_socket
01828ad8 l     F .text	00000098 free_socket
0182a57c l     F .text	000003ac event_callback
01829d1c l     F .text	00000380 lwip_selscan
0182aa9c l     F .text	00000114 lwip_getaddrname
0182aefc l     F .text	000003fc lwip_getsockopt_internal
0182b58c l     F .text	00000338 lwip_setsockopt_internal
00000000 l    df *ABS*	00000000 tcpip.c
01847d84 l     O .bss	00000004 tcpip_init_done
01847d88 l     O .bss	00000004 tcpip_init_done_arg
01847d8c l     O .bss	00000004 mbox
0182baac l     F .text	000001c0 tcpip_thread
0182c0e4 l     F .text	0000003c pbuf_free_int
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
01847d92 l     O .bss	00000001 tse_system_count.4134
01847d93 l     O .bss	00000001 is_init.4216
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 icmp.c
0183184c l     F .text	000001e0 icmp_send_response
00000000 l    df *ABS*	00000000 inet_chksum.c
01831a2c l     F .text	00000234 lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
01847d94 l     O .bss	00000002 ip_id
00000000 l    df *ABS*	00000000 ip_frag.c
01847da8 l     O .bss	00000004 reassdatagrams
01847dac l     O .bss	00000002 ip_reass_pbufcount
018330dc l     F .text	00000190 ip_reass_free_complete_datagram
018334d8 l     F .text	00000068 ip_reass_dequeue_datagram
0183326c l     F .text	00000190 ip_reass_remove_oldest_datagram
018333fc l     F .text	000000dc ip_reass_enqueue_new_datagram
01833540 l     F .text	00000700 ip_reass_chain_frag_into_datagram_and_validate
0183424c l     F .text	0000002c ip_frag_alloc_pbuf_custom_ref
01834278 l     F .text	00000038 ip_frag_free_pbuf_custom_ref
018342b0 l     F .text	00000058 ipfrag_free_pbuf_custom
00000000 l    df *ABS*	00000000 memp.c
018484e0 l     O .bss	0000003c memp_tab
01843a5c l     O .rodata	0000001e memp_sizes
01843a7a l     O .rodata	0000001e memp_num
0184851c l     O .bss	0001a16f memp_memory
00000000 l    df *ABS*	00000000 raw.c
01847db0 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 sys.c
00000000 l    df *ABS*	00000000 tcp_in.c
0186268c l     O .bss	00000014 inseg
01847db4 l     O .bss	00000004 tcphdr
01847db8 l     O .bss	00000004 iphdr
01847dbc l     O .bss	00000004 seqno
01847dc0 l     O .bss	00000004 ackno
01847dc4 l     O .bss	00000001 flags
01847dc6 l     O .bss	00000002 tcplen
01847dc8 l     O .bss	00000001 recv_flags
01847dcc l     O .bss	00000004 recv_data
018362c8 l     F .text	0000013c tcp_timewait_input
01835fe0 l     F .text	000002e8 tcp_listen_input
01836404 l     F .text	00000ab4 tcp_process
0183914c l     F .text	00000228 tcp_parseopt
01837158 l     F .text	00001ff4 tcp_receive
01836eb8 l     F .text	000002a0 tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 api_lib.c
01839b8c l     F .text	00000294 netconn_recv_data
0183a3a8 l     F .text	000000cc netconn_close_shutdown
00000000 l    df *ABS*	00000000 api_msg.c
0183a514 l     F .text	00000170 recv_raw
0183a684 l     F .text	0000012c recv_udp
0183a7b0 l     F .text	00000140 recv_tcp
0183a8f0 l     F .text	000000fc poll_tcp
0183c2c0 l     F .text	0000030c do_writemore
0183b388 l     F .text	00000290 do_close_internal
0183a9ec l     F .text	000000fc sent_tcp
0183aae8 l     F .text	000001b4 err_tcp
0183ac9c l     F .text	00000088 setup_tcp
0183ad24 l     F .text	00000168 accept_function
0183ae8c l     F .text	000001a4 pcb_new
0183b20c l     F .text	0000017c netconn_drain
0183b95c l     F .text	00000154 do_connected
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 vfprintf.c
01843ef0 l     O .rodata	00000010 zeroes.4389
01843f00 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintf.c
01843f20 l     O .rodata	00000010 blanks.4332
01843f10 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_exit.c
01828820 g     F .text	00000020 lwip_socket_init
0183b7ec g     F .text	00000170 do_bind
01847d98 g     O .bss	00000004 current_iphdr_src
01832098 g     F .text	00000044 inet_chksum
01834d38 g     F .text	00000048 raw_bind
01807180 g     F .text	00000074 _mprec_log10
01833c40 g     F .text	0000060c ip_reass
0182d410 g     F .text	000000d8 alt_tse_get_mac_info
0181a994 g     F .text	00000160 pbuf_realloc
0180726c g     F .text	0000008c __any_on
01809654 g     F .text	00000054 _isatty_r
01841404 g     O .rodata	00000028 __mprec_tinytens
0180d474 g     F .text	000000d8 alt_main
0183d4cc g     F .text	00000090 strcpy
0181de44 g     F .text	00000030 tcp_next_iss
0183d23c g     F .text	000000c0 _puts_r
0186a9c4 g     O .bss	00000100 alt_irq
0181c590 g     F .text	000000f0 tcp_update_rcv_ann_wnd
018096a8 g     F .text	00000060 _lseek_r
020100d8 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
01810250 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
01847d1c g     O .bss	00000004 netif_list
01816204 g     F .text	00000050 dhcp_cleanup
0183100c g     F .text	000000f0 marvell_cfg_rgmii
01845dc8 g       *ABS*	00000000 __flash_rwdata_start
01827610 g     F .text	0000003c enh_alt_irq_enable_all
01813f28 g     F .text	000000b8 print_ipad
0180bf60 g     F .text	00000088 .hidden __eqdf2
01820968 g     F .text	000003cc tcp_rst
0181b900 g     F .text	000000c8 pbuf_memfind
01824740 g     F .text	00000224 ping_send
0182e600 g     F .text	00000210 alt_tse_phy_print_profile
0186ab04 g       *ABS*	00000000 __alt_heap_start
01830dac g     F .text	00000098 marvell_phy_cfg
0180f448 g     F .text	00000068 uxTaskPriorityGet
01811a60 g     F .text	00000078 xTimerCreate
01824484 g     F .text	00000074 etharp_request
01822288 g     F .text	00000074 udp_send_chksum
0183b1bc g     F .text	00000050 netconn_free
01800c18 g     F .text	0000003c printf
01816254 g     F .text	000001ec dhcp_start
01825aa8 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
01809f80 g     F .text	0000009c _wcrtomb_r
018350f8 g     F .text	0000006c sys_msleep
0181db18 g     F .text	00000034 tcp_err
01845d84 g     O .rwdata	00000004 ip_addr_any
01831c60 g     F .text	00000200 inet_chksum_pseudo
018165ec g     F .text	000000a8 dhcp_network_changed
01807498 g     F .text	0000005c __sseek
01822bb8 g     F .text	000000a0 udp_remove
01804ef8 g     F .text	00000010 __sinit
01810874 g     F .text	00000158 vTaskGetInfo
01809e28 g     F .text	00000140 __swbuf_r
0180ec40 g     F .text	000000c8 vQueueWaitForMessageRestricted
0183286c g     F .text	0000064c ip_output_if
01805504 g     F .text	0000007c _setlocale_r
01804d60 g     F .text	00000068 __sfmoreglue
01834b24 g     F .text	000000e8 memp_free
0180d5ac g     F .text	00000044 __malloc_unlock
01813cfc g     F .text	00000034 lwip_set_status_callback
0181aca4 g     F .text	00000144 pbuf_free
0181dab0 g     F .text	00000034 tcp_recv
0183b618 g     F .text	000001d4 do_delconn
0182d654 g     F .text	00000a7c getPHYSpeed
0181ae98 g     F .text	000000d4 pbuf_cat
0180097c g     F .text	000000b8 get_ip_addr
018261c0 g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
018292e0 g     F .text	000004d8 lwip_recvfrom
01809708 g     F .text	0000015c memmove
01832eb8 g     F .text	000000b4 ip_output
018234b4 g     F .text	000000a4 etharp_cleanup_netif
01824b88 g     F .text	00000140 lwip_ping_target_data
018222fc g     F .text	00000058 udp_sendto
0181103c g     F .text	00000048 vTaskEnterCritical
01813960 g     F .text	0000008c lwip_wait_for_an
01804ee0 g     F .text	00000018 _cleanup
0183d3e8 g     F .text	000000e4 snprintf
0180dc60 g     F .text	000000f4 xQueueGenericSendFromISR
0180fce0 g     F .text	00000040 pcTaskGetName
018062fc g     F .text	000000a8 _Balloc
01818bf0 g     F .text	00000044 ipaddr_addr
018211b8 g     F .text	00000194 tcp_keepalive
01822db4 g     F .text	0000017c etharp_tmr
01830010 g     F .text	000001c4 alt_tse_phy_set_adv_1000
0183ca5c g     F .text	00000074 netbuf_delete
01845dc4 g     O .rwdata	00000001 max_mac_system
0181d850 g     F .text	00000200 tcp_alloc
0182c6c4 g     F .text	000009fc alt_tse_system_add_sys
0180bfe8 g     F .text	000000dc .hidden __gtdf2
018287fc g     F .text	00000024 altera_nios2_gen2_irq_init
0183cfe8 g     F .text	00000010 __errno
0183cad0 g     F .text	000000c8 netbuf_alloc
0182bf84 g     F .text	00000070 tcpip_callbackmsg_new
0182240c g     F .text	00000060 udp_sendto_if
02010000 g     F .entry	0000001c __reset
0180d8f8 g     F .text	00000090 xQueueGiveMutexRecursive
0183a4a8 g     F .text	0000006c netconn_shutdown
0181da7c g     F .text	00000034 tcp_arg
01847c9c g     O .bss	00000004 pxCurrentTCB
018217fc g     F .text	00000078 sys_timeouts_init
01847d2a g     O .bss	00000001 tcp_active_pcbs_changed
01813d64  w    F .text	00000040 lwip_is_interface_up
018152ec g     F .text	00000058 sys_mutex_free
01847d2c g     O .bss	00000004 tcp_active_pcbs
01825d10 g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
0181a35c g     F .text	0000003c netif_set_link_callback
01800000 g       *ABS*	00000000 __flash_exceptions_start
01847d4c g     O .bss	00000004 udp_pcbs
0180913c g     F .text	0000005c _fstat_r
01845b10 g     O .rwdata	00000240 tse_mac_device
01847c88 g     O .bss	00000004 errno
018244f8 g     F .text	00000248 ethernet_input
0181bea0 g     F .text	000000f0 tcp_shutdown
01807414 g     F .text	00000008 __seofread
0183a03c g     F .text	00000080 netconn_recved
0183fb9c g     F .text	0000123c ___svfiprintf_internal_r
018308f8 g     F .text	000004b4 alt_tse_phy_set_common_speed
0181ae34 g     F .text	00000064 pbuf_ref
0180d434  w    F .text	00000020 pre_constructors
0186aac4 g     O .bss	00000020 pmac_groups
0181a02c g     F .text	00000048 netif_set_netmask
018154d4 g     F .text	00000060 sys_mbox_trypost
01847c90 g     O .bss	00000004 alt_argv
0184dd50 g       *ABS*	00000000 _gp
0181d668 g     F .text	0000007c tcp_recv_null
01813290 g     F .text	00000030 usleep
01847d9c g     O .bss	00000004 current_netif
0183a474 g     F .text	00000034 netconn_close
0181f438 g     F .text	000002e8 tcp_enqueue_flags
0183c9e8 g     F .text	00000074 netbuf_new
0180f4fc g     F .text	000001b4 vTaskPrioritySet
01847c98 g     O .bss	00000004 alt_heapsem
01810530 g     F .text	0000003c vTaskInternalSetTimeOutState
0181be44 g     F .text	0000005c tcp_close
0181c680 g     F .text	000000a8 tcp_recved
01828698 g     F .text	00000030 alt_uncached_malloc
0181dbc8 g     F .text	00000170 tcp_pcb_purge
0182c1c8 g     F .text	00000060 tse_mac_initTransInfo2
0181384c g     F .text	00000114 lwip_initialize
018447fc g     O .rwdata	00000180 alt_fd_list
0183980c g     F .text	000000bc netconn_disconnect
0181902c g     F .text	0000003c ipaddr_ntoa
01800a6c g     F .text	00000048 get_iface_name
01845d8e g     O .rwdata	00000007 tcp_persist_backoff
0182773c g     F .text	0000002c xPortStartScheduler
01811888 g     F .text	00000088 ulTaskNotifyValueClear
0180fa84 g     F .text	00000034 vTaskEndScheduler
01827c7c g     F .text	00000090 alt_find_dev
0180608c g     F .text	00000148 memcpy
018193dc g     F .text	0000010c mem_free
0182c43c g     F .text	00000054 tse_mac_setMIImode
01810200 g     F .text	00000050 vTaskPlaceOnEventList
0181b624 g     F .text	0000010c pbuf_fill_chksum
0181040c g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
01847d30 g     O .bss	00000004 tcp_ticks
01847d34 g     O .bss	00000004 tcp_listen_pcbs
0182e0d0 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
0182246c g     F .text	00000454 udp_sendto_if_chksum
01820d34 g     F .text	000000b4 tcp_rexmit_rto
01804bb0 g     F .text	0000000c _cleanup_r
0180d24c g     F .text	000000dc .hidden __floatsidf
0182c228 g     F .text	000000e4 tse_mac_sTxWrite
01812968 g     F .text	0000007c alt_io_redirect
0181da50 g     F .text	0000002c tcp_new
0180c0c4 g     F .text	000000f4 .hidden __ltdf2
0180e52c g     F .text	0000007c xQueuePeekFromISR
01822b24 g     F .text	00000050 udp_disconnect
0181b2a8 g     F .text	0000019c pbuf_copy_partial
01814ec4 g     F .text	00000020 sys_init
01815074 g     F .text	00000048 sys_sem_signal
01840e68 g       *ABS*	00000000 __DTOR_END__
0180d454  w    F .text	00000020 post_constructors
01827a84 g     F .text	000000d0 alt_close
01821874 g     F .text	0000017c sys_timeout
0183d2fc g     F .text	00000014 puts
018272c0 g     F .text	00000044 vPortFree
01811de0 g     F .text	00000030 pcTimerGetName
01817128 g     F .text	000001a4 dhcp_release
018072f8 g     F .text	00000074 __fpclassifyd
01841b34 g     O .rodata	0000002c tcp_state_str
018070dc g     F .text	000000a4 __ratio
01834f94 g     F .text	00000044 raw_send
018320dc g     F .text	0000010c inet_chksum_pbuf
01808be0 g     F .text	0000001c __vfiprintf_internal
0181b444 g     F .text	00000154 pbuf_take
0180e008 g     F .text	00000260 xQueueSemaphoreTake
01825e08 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0180e6d0 g     F .text	00000028 uxQueueGetQueueNumber
01825490 g     F .text	00000258 altera_avalon_jtag_uart_read
0183d030 g     F .text	00000014 malloc
01800be8 g     F .text	00000030 _printf_r
01847da0 g     O .bss	00000004 current_iphdr_dest
0180ad10 g     F .text	00000064 .hidden __udivsi3
018626e4 g     O .bss	00000024 tse
01812a20 g     F .text	000000a4 isatty
0182d0c0 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
018311c0 g     F .text	000005fc icmp_input
01841454 g     O .rodata	000000c8 __mprec_tens
0182d390 g     F .text	00000080 alt_tse_get_mac_info_index
01810b58 g     F .text	0000005c uxTaskGetStackHighWaterMark
01819bb8 g     F .text	000000f0 netif_add
01805580 g     F .text	0000000c __locale_charset
0182c02c g     F .text	00000044 tcpip_trycallback
01847d60 g     O .bss	00000008 alt_timezone
01815198 g     F .text	000000c0 sys_mutex_new
0181d518 g     F .text	00000054 tcp_segs_free
01827398 g     F .text	0000008c vListInsertEnd
01839374 g     F .text	00000090 alt_icache_flush
01829854 g     F .text	00000144 lwip_send
01847c84 g     O .bss	00000004 __malloc_top_pad
01847cec g     O .bss	00000004 alt_fd_list_lock
01847c68 g     O .bss	00000004 PingIp
01845d58 g     O .rwdata	00000004 __mb_cur_max
018055b0 g     F .text	0000000c _localeconv_r
0182bff4 g     F .text	00000038 tcpip_callbackmsg_delete
01832f6c g     F .text	000000d0 ip_output_hinted
01819ebc g     F .text	00000128 netif_set_ipaddr
01809198 g     F .text	000004bc __sfvwrite_r
01806708 g     F .text	0000003c __i2b
01825f40 g     F .text	0000005c alt_avalon_sgdma_stop
0182e170 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0180736c g     F .text	00000054 _sbrk_r
0182e810 g     F .text	000006a4 alt_tse_mac_group_init
0181eb08 g     F .text	00000930 tcp_write
01814210 g     F .text	0000084c tse_mac_init
0180f914 g     F .text	000000e0 xTaskResumeFromISR
01823558 g     F .text	000000c0 etharp_find_addr
01815534 g     F .text	00000100 sys_arch_mbox_fetch
0182a928 g     F .text	00000174 lwip_shutdown
01813cb4 g     F .text	00000048 get_netif
01809864 g     F .text	00000060 _read_r
0182736c g     F .text	0000002c vListInitialiseItem
01827b54 g     F .text	00000028 alt_dcache_flush
01845d78 g     O .rwdata	00000004 alt_max_fd
01827788 g     F .text	0000003c vPortSysTickHandler
01808e30 g     F .text	000000f0 _fclose_r
0180de30 g     F .text	000001d8 xQueueReceive
0181c128 g     F .text	000001d0 tcp_bind
01804b78 g     F .text	00000030 fflush
01847c80 g     O .bss	00000004 __malloc_max_sbrked_mem
01831804 g     F .text	00000048 icmp_time_exceeded
0181c0f0 g     F .text	00000038 tcp_abort
0180f4b0 g     F .text	0000004c uxTaskPriorityGetFromISR
01839994 g     F .text	000001f8 netconn_accept
01834308 g     F .text	0000048c ip_frag
0180adcc g     F .text	000008ac .hidden __adddf3
018291d0 g     F .text	00000110 lwip_listen
01811d38 g     F .text	00000070 uxTimerGetReloadMode
01806e84 g     F .text	0000010c __b2d
0180a6e0 g     F .text	00000538 .hidden __umoddi3
01812bec g     F .text	000000d4 lseek
01834e0c g     F .text	00000188 raw_sendto
0182e364 g     F .text	0000029c alt_tse_phy_add_profile_default
0182fa7c g     F .text	00000594 alt_tse_phy_get_cap
01800000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
01811c78 g     F .text	00000030 xTimerGetPeriod
01845d50 g     O .rwdata	00000004 _global_impure_ptr
0183c8b8 g     F .text	00000130 do_close
018283f8 g     F .text	000000fc alt_read
018098c4 g     F .text	00000564 _realloc_r
0186ab04 g       *ABS*	00000000 __bss_end
018282cc g     F .text	000000f0 alt_iic_isr_register
01825984 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
01828590 g     F .text	00000108 alt_tick
01828e74 g     F .text	00000154 lwip_bind
0180a168 g     F .text	00000578 .hidden __udivdi3
018172cc g     F .text	000000b8 dhcp_stop
01809098 g     F .text	00000024 _fputwc_r
0182f91c g     F .text	00000160 alt_tse_phy_check_link
0184142c g     O .rodata	00000028 __mprec_bigtens
018064ec g     F .text	00000104 __s2b
0182abb0 g     F .text	00000044 lwip_getpeername
0180d328 g     F .text	000000a8 .hidden __floatunsidf
01830f28 g     F .text	000000e4 marvell_cfg_sgmii
0181b04c g     F .text	0000025c pbuf_copy
0182f760 g     F .text	000001bc alt_tse_phy_restart_an
01820de8 g     F .text	000002a8 tcp_rexmit
01806bc4 g     F .text	00000060 __mcmp
01827274 g     F .text	0000004c pvPortMalloc
018268e0 g     F .text	0000015c altera_avalon_uart_init
0183cddc g     F .text	000000f4 netbuf_data
01824a74 g     F .text	00000114 lwip_ping_target
01804f18 g     F .text	00000018 __fp_lock_all
01839520 g     F .text	0000013c netconn_getaddr
01828280 g     F .text	0000004c alt_ic_irq_enabled
0186aae4 g     O .bss	00000020 pphy_profiles
0180e694 g     F .text	0000003c vQueueDelete
01827768 g     F .text	00000020 vPortEndScheduler
0181a0a0 g     F .text	000000b0 netif_set_up
01827304 g     F .text	00000068 vListInitialise
018284f4 g     F .text	0000009c alt_alarm_stop
01813d30 g     F .text	00000034 lwip_set_link_callback
01847d70 g     O .bss	00000004 alt_irq_active
01829b90 g     F .text	00000148 lwip_socket
01841b70 g     O .rodata	00000010 tcp_pcb_lists
0182c070 g     F .text	00000074 tcpip_init
02010378 g     F .exceptions	000000cc alt_irq_handler
018447d4 g     O .rwdata	00000028 alt_dev_null
0180fc4c g     F .text	00000048 xTaskGetTickCount
0180da7c g     F .text	000001e4 xQueueGenericSend
01800ab4 g     F .text	00000024 is_interface_active
01818b2c g     F .text	000000c4 ip4_addr_netmask_valid
01847d38 g     O .bss	00000004 tcp_tmp_pcb
01839734 g     F .text	000000d8 netconn_connect
0182f648 g     F .text	00000118 alt_tse_phy_init
01825f9c g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
00000000 g       .debug_aranges	00000000 alt_exception_muldiv
0183a0bc g     F .text	00000080 netconn_sendto
01827b7c g     F .text	00000020 alt_dcache_flush_all
018065f0 g     F .text	00000068 __hi0bits
0180fd20 g     F .text	00000188 uxTaskGetSystemState
01814b94 g     F .text	00000160 tse_mac_raw_send
0180d1cc g     F .text	00000080 .hidden __fixdfsi
01814b00 g     F .text	00000094 tse_sgdma_rx_isr
01810e00 g     F .text	000000fc xTaskPriorityDisinherit
01819324 g     F .text	000000b8 mem_init
01828704 g     F .text	000000f8 alt_write
01829054 g     F .text	0000017c lwip_connect
0181e324 g     F .text	00000148 tcp_send_fin
01845dc8 g       *ABS*	00000000 __ram_rwdata_end
0181f8bc g     F .text	00000aac tcp_output
01847cf8 g     O .bss	00000004 tx_counter
01845d70 g     O .rwdata	00000008 alt_dev_list
018194e8 g     F .text	00000308 mem_trim
01813374 g     F .text	00000064 write
018260e0 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0183d0d4 g     F .text	000000a0 _putc_r
01810318 g     F .text	000000f4 xTaskRemoveFromEventList
01800460 g     F .text	00000028 vApplicationMallocFailedHook
01843f30 g       *ABS*	00000000 __ram_rodata_end
0183cb98 g     F .text	0000008c netbuf_free
018127f4 g     F .text	000000b0 fstat
018398c8 g     F .text	000000cc netconn_listen_with_backlog
01847dd0 g     O .bss	00000004 tcp_input_pcb
01834c0c g     F .text	0000012c raw_input
0180c0c4 g     F .text	000000f4 .hidden __ledf2
018310fc g     F .text	00000078 DP83848C_link_status_read
0181f720 g     F .text	0000019c tcp_send_empty_ack
0180e268 g     F .text	000001e0 xQueuePeek
01821090 g     F .text	00000128 tcp_rexmit_fast
01814f38 g     F .text	000000e4 sys_sem_new
0180693c g     F .text	00000140 __pow5mult
01807784 g     F .text	0000145c ___vfiprintf_internal_r
01847c78 g     O .bss	00000004 __nlocale_changed
0182be88 g     F .text	0000008c tcpip_untimeout
0180ad74 g     F .text	00000058 .hidden __umodsi3
01818c34 g     F .text	000003f8 ipaddr_aton
01818a60 g     F .text	000000cc ip4_addr_isbroadcast
0181a074 g     F .text	0000002c netif_set_default
01822b74 g     F .text	00000044 udp_recv
01825d88 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
01825e94 g     F .text	00000054 alt_avalon_sgdma_register_callback
0186ab04 g       *ABS*	00000000 end
0180f0e4 g     F .text	000000f8 vTaskDelete
01821ae4 g     F .text	00000114 sys_timeouts_mbox_fetch
0181a150 g     F .text	00000094 netif_set_down
01847cfc g     O .bss	00000004 rx_counter
01824964 g     F .text	00000110 ping_recv
0181a4e8 g     F .text	0000036c pbuf_alloc
0181a220 g     F .text	000000c4 netif_set_link_up
01815414 g     F .text	00000070 sys_mbox_free
01826fe8 g     F .text	000001e8 altera_avalon_uart_write
0182c4e0 g     F .text	000001e4 alt_tse_phy_add_profile
01824f44 g     F .text	00000148 altera_avalon_jtag_uart_init
01811124 g     F .text	00000038 pvTaskIncrementMutexHeldCount
01840e68 g       *ABS*	00000000 __CTOR_LIST__
02000000 g       *ABS*	00000000 __alt_stack_pointer
018394c0 g     F .text	00000060 netconn_delete
01826160 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
01826754 g     F .text	0000007c alt_avalon_timer_sc_init
01826830 g     F .text	00000060 altera_avalon_uart_write_fd
0180d3d0 g     F .text	00000064 .hidden __clzsi2
0183d310 g     F .text	000000d8 _snprintf_r
01826890 g     F .text	00000050 altera_avalon_uart_close_fd
0183ced0 g     F .text	0000009c netbuf_next
018256e8 g     F .text	00000260 altera_avalon_jtag_uart_write
01825bb8 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0183cf6c g     F .text	00000068 netbuf_first
01804f08 g     F .text	00000004 __sfp_lock_acquire
01805fa8 g     F .text	000000e4 memchr
01845d88 g     O .rwdata	00000004 ip_addr_broadcast
01800c54 g     F .text	000021f8 ___vfprintf_internal_r
01829998 g     F .text	000001f8 lwip_sendto
0183303c g     F .text	000000a0 ip_reass_tmr
0181056c g     F .text	000000f0 xTaskCheckForTimeOut
01825cb0 g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
0180506c g     F .text	00000310 _free_r
01812f14 g     F .text	0000022c alt_printf
01810cc0 g     F .text	00000140 xTaskPriorityInherit
01812670 g     F .text	00000028 uxTimerGetTimerNumber
0180558c g     F .text	00000010 __locale_mb_cur_max
01822a1c g     F .text	00000108 udp_connect
0183f84c g     F .text	00000180 __call_exitprocs
0183b090 g     F .text	0000012c netconn_alloc
01847da4 g     O .bss	00000004 current_header
0182a09c g     F .text	000004e0 lwip_select
018297b8 g     F .text	0000004c lwip_read
01847d04 g     O .bss	00000004 rx_faulty_packets
01847c74 g     O .bss	00000004 __mlocale_changed
01814cf4 g     F .text	000001d0 tse_mac_rcv
0181115c g     F .text	000000d0 ulTaskNotifyTake
01819ca8 g     F .text	0000005c netif_set_addr
01816694 g     F .text	000000a0 dhcp_arp_reply
01845d5c g     O .rwdata	00000004 __malloc_sbrk_base
01800424 g     F .text	0000003c _start
01847d74 g     O .bss	00000004 _alt_tick_rate
0180fab8 g     F .text	0000002c vTaskSuspendAll
0180f328 g     F .text	00000120 eTaskGetState
0181b9c8 g     F .text	000000a4 pbuf_strstr
01826000 g     F .text	00000054 alt_avalon_sgdma_open
0180fc94 g     F .text	0000002c xTaskGetTickCountFromISR
01800860 g     F .text	0000011c get_mac_addr
01834958 g     F .text	000001cc memp_malloc
01806a7c g     F .text	00000148 __lshift
0182134c g     F .text	000002e8 tcp_zero_window_probe
01847d78 g     O .bss	00000004 _alt_nticks
0182e298 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
01813308 g     F .text	0000006c read
0183c5cc g     F .text	00000114 do_write
01824d34 g     F .text	000000ac alt_sys_init
0183f9cc g     F .text	000001d0 __ssprint_r
01815c58 g     F .text	000000b8 dhcp_fine_tmr
01862708 g     O .bss	0000000a dhcp_rx_options_given
018274fc g     F .text	00000098 uxListRemove
0183f734 g     F .text	00000118 __register_exitproc
01847d90 g     O .bss	00000001 phy_profile_count
0182d31c g     F .text	00000074 alt_tse_get_mac_group_index
01819068 g     F .text	00000194 ipaddr_ntoa_r
01806744 g     F .text	000001f8 __multiply
01825338 g     F .text	00000068 altera_avalon_jtag_uart_close
01843f30 g       *ABS*	00000000 __ram_rwdata_start
01840e68 g       *ABS*	00000000 __ram_rodata_start
01847dd4 g     O .bss	00000028 __malloc_current_mallinfo
01811800 g     F .text	00000088 xTaskNotifyStateClear
01847d3c g     O .bss	00000004 tcp_bound_pcbs
0180f838 g     F .text	000000dc vTaskResume
01806f90 g     F .text	0000014c __d2b
0181501c g     F .text	00000058 sys_sem_free
0181d56c g     F .text	0000005c tcp_seg_free
018100a4 g     F .text	0000015c vTaskSwitchContext
0181b7e0 g     F .text	00000120 pbuf_memcmp
01811ca8 g     F .text	00000090 vTimerSetReloadMode
0182c15c g     F .text	0000003c mem_free_callback
0182e118 g     F .text	00000058 alt_tse_phy_wr_mdio_addr
01824de0 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
01827e14 g     F .text	000000e0 alt_get_fd
018102b4 g     F .text	00000064 vTaskPlaceOnEventListRestricted
0183c6e0 g     F .text	000001d8 do_getaddr
018278f0 g     F .text	00000158 alt_busy_sleep
0183cd1c g     F .text	000000c0 netbuf_chain
0181ba8c g     F .text	00000020 tcp_init
0181c800 g     F .text	00000398 tcp_connect
01831e60 g     F .text	00000238 inet_chksum_pseudo_partial
01808d18 g     F .text	00000054 _close_r
018197f0 g     F .text	00000330 mem_malloc
0181122c g     F .text	00000114 xTaskNotifyWait
018305d0 g     F .text	00000328 alt_tse_phy_get_common_speed
0183d058 g     F .text	0000007c memcmp
01824ea0 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0186ab04 g       *ABS*	00000000 __alt_stack_base
01824ef0 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
01847d91 g     O .bss	00000001 mac_group_count
0181a2e4 g     F .text	00000078 netif_set_link_down
01816cc4 g     F .text	00000164 dhcp_renew
01811b7c g     F .text	000000dc xTimerGenericCommand
018106cc g     F .text	00000044 vTaskSetTaskNumber
0183bcfc g     F .text	00000084 do_disconnect
01802f24 g     F .text	00000154 __swsetup_r
01800488 g     F .text	00000030 vApplicationStackOverflowHook
01814a5c g     F .text	000000a4 tse_sgdma_read_init
0180f6b0 g     F .text	0000011c vTaskSuspend
0180b678 g     F .text	000008e8 .hidden __divdf3
01804dc8 g     F .text	00000118 __sfp
0180fea8 g     F .text	0000004c xTaskCatchUpTicks
018071f4 g     F .text	00000078 __copybits
0180fcc0 g     F .text	00000020 uxTaskGetNumberOfTasks
0181de74 g     F .text	0000008c tcp_eff_send_mss
018443cc g     O .rwdata	00000408 __malloc_av_
01804f14 g     F .text	00000004 __sinit_lock_release
0180c1b8 g     F .text	00000718 .hidden __muldf3
018626a0 g     O .bss	00000044 eth_tse
018073c0 g     F .text	00000054 __sread
0182eeb4 g     F .text	00000424 alt_tse_mac_get_phy
01827d0c g     F .text	00000108 alt_find_file
0182b2f8 g     F .text	00000294 lwip_setsockopt
01827bd8 g     F .text	000000a4 alt_dev_llist_insert
0180d54c g     F .text	00000060 __malloc_lock
018131e0 g     F .text	000000b0 sbrk
0183d55c g     F .text	000021d8 ___svfprintf_internal_r
0180d988 g     F .text	0000009c xQueueTakeMutexRecursive
01825ee8 g     F .text	00000058 alt_avalon_sgdma_start
01816440 g     F .text	000001ac dhcp_inform
0182bdec g     F .text	0000009c tcpip_timeout
01804b1c g     F .text	0000005c _fflush_r
0182d5c8 g     F .text	0000008c alt_tse_mac_set_duplex
01808d6c g     F .text	000000c4 _calloc_r
01834d80 g     F .text	00000048 raw_connect
01839e20 g     F .text	00000074 netconn_recv_tcp_pbuf
01811340 g     F .text	000001bc xTaskGenericNotify
01827ef4 g     F .text	000001f4 gettimeofday
01815344 g     F .text	000000d0 sys_mbox_new
01814020 g     F .text	000001f0 lwip_initialize_phys
01847c60 g       *ABS*	00000000 __bss_start
01810684 g     F .text	00000048 uxTaskGetTaskNumber
018061d4 g     F .text	00000128 memset
01800ad8 g     F .text	00000040 main
01847c94 g     O .bss	00000004 alt_envp
01847c7c g     O .bss	00000004 __malloc_max_total_mem
01824e40 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
01809f68 g     F .text	00000018 __swbuf
01827424 g     F .text	000000d8 vListInsert
018317bc g     F .text	00000048 icmp_dest_unreach
01845dac g     O .rwdata	00000008 alt_sgdma_list
0181dae4 g     F .text	00000034 tcp_sent
018074f4 g     F .text	00000008 __sclose
0181b730 g     F .text	000000b0 pbuf_get_at
02000000 g       *ABS*	00000000 __alt_heap_limit
02010000 g       *ABS*	00000000 __alt_mem_mem_0
01808f20 g     F .text	00000014 fclose
018119f8 g     F .text	00000068 xTimerCreateTimerTask
01803278 g     F .text	00001688 _dtoa_r
01835078 g     F .text	00000080 raw_new
0180579c g     F .text	0000080c _malloc_r
0182c3b4 g     F .text	00000088 tse_mac_SwReset
0180a0dc g     F .text	00000030 __ascii_wctomb
0182abf4 g     F .text	00000044 lwip_getsockname
0180e72c g     F .text	00000028 ucQueueGetQueueType
018135a0 g     F .text	000000fc ethernetif_input
01845db4 g     O .rwdata	00000004 alt_errno
0180f1dc g     F .text	000000f0 vTaskDelayUntil
0182c120 g     F .text	0000003c pbuf_free_callback
01827230 g     F .text	00000044 __env_unlock
0181a1e4 g     F .text	0000003c netif_set_status_callback
0180537c g     F .text	000000c4 _fwalk
0183a13c g     F .text	000000c8 netconn_send
0180e448 g     F .text	000000e4 xQueueReceiveFromISR
01839404 g     F .text	000000bc netconn_new_with_proto_and_callback
01810c4c g     F .text	00000028 xTaskGetCurrentTaskHandle
0183a204 g     F .text	000001a4 netconn_write_partly
0183d174 g     F .text	000000c8 putc
0180ac18 g     F .text	00000084 .hidden __divsi3
0182d268 g     F .text	00000048 alt_tse_mac_set_common_speed
01834fd8 g     F .text	000000a0 raw_remove
0180d714 g     F .text	00000098 xQueueGenericCreate
01804f48 g     F .text	00000124 _malloc_trim_r
01840e68 g       *ABS*	00000000 __CTOR_END__
01813c68 g     F .text	0000004c get_mac_base
01847d24 g     O .bss	00000001 pbuf_free_ooseq_pending
018228c0 g     F .text	0000015c udp_bind
0181baac g     F .text	0000004c tcp_tmr
01823e84 g     F .text	000003b4 etharp_query
018074fc g     F .text	000000dc strcmp
01831174 g     F .text	0000004c lwip_init
0180da24 g     F .text	00000058 xQueueCreateCountingSemaphore
01840e68 g       *ABS*	00000000 __flash_rodata_start
0181569c g     F .text	0000007c sys_thread_new
01840e68 g       *ABS*	00000000 __DTOR_LIST__
01823b98 g     F .text	000002ec etharp_output
01822354 g     F .text	000000b8 udp_sendto_chksum
018114fc g     F .text	000001e4 xTaskGenericNotifyFromISR
0180bf60 g     F .text	00000088 .hidden __nedf2
0180e6f8 g     F .text	00000034 vQueueSetQueueNumber
01824cfc g     F .text	00000038 alt_irq_init
0182d228 g     F .text	00000040 alt_tse_mac_get_common_speed
0181317c g     F .text	00000064 alt_release_fd
0180fae4 g     F .text	00000168 xTaskResumeAll
0182bf14 g     F .text	00000070 tcpip_apimsg
0181a854 g     F .text	00000140 pbuf_alloced_custom
0180e5f8 g     F .text	00000064 uxQueueSpacesAvailable
01819fe4 g     F .text	00000048 netif_set_gw
0184153c g     O .rodata	00000100 .hidden __clz_tab
0180f9f4 g     F .text	00000090 vTaskStartScheduler
0181ade8 g     F .text	0000004c pbuf_clen
01847c70 g     O .bss	00000004 _PathLocale
0183cfd4 g     F .text	00000014 atexit
01813c48 g     F .text	00000020 get_mac_count
01808cb8 g     F .text	00000060 _write_r
0181d5c8 g     F .text	00000038 tcp_setprio
01822234 g     F .text	00000054 udp_send
0182ac38 g     F .text	000002c4 lwip_getsockopt
018055bc g     F .text	00000018 setlocale
0180ebf0 g     F .text	00000050 xQueueIsQueueFullFromISR
0181b598 g     F .text	0000008c pbuf_coalesce
01834dc8 g     F .text	00000044 raw_recv
018125bc g     F .text	00000058 pvTimerGetTimerID
018152a4 g     F .text	00000048 sys_mutex_unlock
01800b18 g     F .text	000000d0 main_thread
01819d04 g     F .text	000000d8 netif_remove
01815258 g     F .text	0000004c sys_mutex_lock
018150bc g     F .text	000000dc sys_arch_sem_wait
01845d54 g     O .rwdata	00000004 _impure_ptr
01847c8c g     O .bss	00000004 alt_argc
0181cb98 g     F .text	00000738 tcp_slowtmr
01811da8 g     F .text	00000038 xTimerGetExpiryTime
01804900 g     F .text	0000021c __sflush_r
01812758 g     F .text	00000060 _do_dtors
018055a8 g     F .text	00000008 __locale_cjk_lang
01806e20 g     F .text	00000064 __ulp
0181db4c g     F .text	00000034 tcp_accept
01804f30 g     F .text	00000018 __fp_unlock_all
0183bd80 g     F .text	00000200 do_listen
0181065c g     F .text	00000028 vTaskMissedYield
0181369c g     F .text	000001b0 ethernetif_init
01845d68 g     O .rwdata	00000008 alt_fs_list
0180e5a8 g     F .text	00000050 uxQueueMessagesWaiting
01847d68 g     O .bss	00000008 alt_resettime
0180fef4 g     F .text	000001b0 xTaskIncrementTick
02010020 g       *ABS*	00000000 __ram_exceptions_start
018055d4 g     F .text	0000000c localeconv
0182bc6c g     F .text	000000b0 tcpip_input
01847d40 g     O .bss	00000004 tcp_tw_pcbs
01830428 g     F .text	000001a8 alt_tse_phy_set_adv_10
018005ac g     F .text	00000048 InitNetwork
0182811c g     F .text	00000050 alt_ic_isr_register
01814ee4 g     F .text	00000054 sys_now
01821cb4 g     F .text	00000580 udp_input
0180d5f0 g     F .text	00000124 xQueueGenericReset
01812614 g     F .text	0000005c vTimerSetTimerID
01845dc8 g       *ABS*	00000000 _edata
018267d0 g     F .text	00000060 altera_avalon_uart_read_fd
0186ab04 g       *ABS*	00000000 _end
0182f2d8 g     F .text	00000248 alt_tse_mac_associate_phy
01819b98 g     F .text	00000020 netif_init
01808f34 g     F .text	00000164 __fputwc
02010444 g       *ABS*	00000000 __ram_exceptions_end
018253a0 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
01832240 g     F .text	000000f0 ip_route
0181c328 g     F .text	00000268 tcp_listen_with_backlog
0186a750 g     O .bss	00000274 lwip_stats
0180ed08 g     F .text	000000e0 xTaskCreate
0183c1c4 g     F .text	000000fc do_recv
0181aaf4 g     F .text	000001b0 pbuf_header
0181254c g     F .text	00000070 xTimerIsTimerActive
01847d20 g     O .bss	00000004 netif_default
018281f4 g     F .text	0000008c alt_ic_irq_disable
0181dd38 g     F .text	0000010c tcp_pcb_remove
01847c6c g     O .bss	00000004 lwipStaticIp
01847d00 g     O .bss	00000004 rx_missed_packets
01826054 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
0180741c g     F .text	0000007c __swrite
018321e8 g     F .text	00000058 lwip_chksum_copy
01845d60 g     O .rwdata	00000004 __malloc_trim_threshold
0181af6c g     F .text	00000044 pbuf_chain
0180559c g     F .text	0000000c __locale_msgcharset
0181bf90 g     F .text	00000160 tcp_abandon
0183cff8 g     F .text	00000038 exit
0181df00 g     F .text	0000003c tcp_debug_state_str
01821690 g     F .text	0000005c tcp_timer_needed
01805440 g     F .text	000000c4 _fwalk_reent
01834794 g     F .text	000001c4 memp_init
018161b8 g     F .text	0000004c dhcp_set_struct
01819b20 g     F .text	00000078 mem_calloc
01806c24 g     F .text	000001fc __mdiff
0181d2d0 g     F .text	000000f8 tcp_fasttmr
0180ac9c g     F .text	00000074 .hidden __modsi3
0181d3c8 g     F .text	00000150 tcp_process_refused_data
0182c490 g     F .text	00000050 tse_mac_setGMIImode
0180f2cc g     F .text	0000005c vTaskDelay
01830e44 g     F .text	000000e4 marvell_cfg_gmii
02000000 g       *ABS*	00000000 __alt_data_end
01804f0c g     F .text	00000004 __sfp_lock_release
0183965c g     F .text	000000d8 netconn_bind
01829cd8 g     F .text	00000044 lwip_write
0182f520 g     F .text	00000128 alt_tse_phy_cfg_pcs
01862714 g     O .bss	00000028 dhcp_rx_options_val
00000000 g       *ABS*	00000000 __alt_mem_tse_descriptor_memory_0
01810c74 g     F .text	0000004c xTaskGetSchedulerState
01829804 g     F .text	00000050 lwip_recv
01810efc g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
01826d04 g     F .text	00000054 altera_avalon_uart_close
0182b8c4 g     F .text	000000e4 lwip_ioctl
01840e38 g     F .text	00000030 _exit
01815bb0 g     F .text	000000a8 dhcp_coarse_tmr
018277c4 g     F .text	0000012c alt_alarm_start
0181d600 g     F .text	00000068 tcp_seg_copy
01840dd8 g     F .text	00000060 .hidden __muldi3
018055e0 g     F .text	000001bc __smakebuf_r
01811084 g     F .text	0000005c vTaskExitCritical
0181db80 g     F .text	00000048 tcp_poll
018075d8 g     F .text	00000098 strlen
0182764c g     F .text	000000f0 pxPortInitialiseStack
0182b9a8 g     F .text	00000104 lwip_fcntl
01812dc0 g     F .text	00000154 open
01821bf8 g     F .text	00000020 udp_init
0186273c g     O .bss	00008014 ram_heap
0180bfe8 g     F .text	000000dc .hidden __gedf2
01822c58 g     F .text	00000058 udp_new
01813140 g     F .text	0000003c alt_putchar
01845d64 g     O .rwdata	00000004 __wctomb
01828fc8 g     F .text	0000008c lwip_close
018275c0 g     F .text	00000050 enh_alt_irq_disable_all
0180776c g     F .text	00000018 __sprint_r
0182c30c g     F .text	000000a8 tse_mac_aRxRead
018280e8 g     F .text	00000034 alt_icache_flush_all
0183cc24 g     F .text	000000f8 netbuf_ref
01845d9e g     O .rwdata	00000006 ethbroadcast
018104d4 g     F .text	0000005c vTaskSetTimeOutState
01811c58 g     F .text	00000020 xTimerGetTimerDaemonTaskHandle
01841b60 g     O .rodata	0000000d tcp_backoff
01812698 g     F .text	00000034 vTimerSetTimerNumber
01845db8 g     O .rwdata	00000004 alt_priority_mask
01815634 g     F .text	00000068 sys_arch_mbox_tryfetch
0182816c g     F .text	00000088 alt_ic_irq_enable
01802e4c g     F .text	0000001c __vfprintf_internal
01828b70 g     F .text	00000304 lwip_accept
01826d94 g     F .text	00000218 altera_avalon_uart_read
0180e65c g     F .text	00000038 uxQueueMessagesWaitingFromISR
0180a10c g     F .text	0000005c _wctomb_r
018271d0 g     F .text	00000060 __env_lock
01839e94 g     F .text	000001a8 netconn_recv
0180eb40 g     F .text	00000048 xQueueIsQueueEmptyFromISR
0183b030 g     F .text	00000060 do_newconn
0182d4e8 g     F .text	000000e0 alt_tse_mac_set_speed
01815484 g     F .text	00000050 sys_mbox_post
01825c2c g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0180c8d0 g     F .text	000008fc .hidden __subdf3
01806658 g     F .text	000000b0 __lo0bits
0183bab0 g     F .text	0000024c do_connect
01845dbc g     O .rwdata	00000008 alt_alarm_list
018126f8 g     F .text	00000060 _do_ctors
018301d4 g     F .text	00000254 alt_tse_phy_set_adv_100
018110e0 g     F .text	00000044 uxTaskResetEventItemValue
018219f0 g     F .text	000000f4 sys_untimeout
0180a01c g     F .text	000000c0 wcrtomb
01835164 g     F .text	00000e7c tcp_input
0180d89c g     F .text	0000005c xQueueCreateMutex
018132c0 g     F .text	00000048 close
01847d58 g     O .bss	00000004 alt_envsem
01832330 g     F .text	0000053c ip_input
018116e0 g     F .text	00000120 vTaskNotifyGiveFromISR
01800a34 g     F .text	00000038 get_hostname
0183bf80 g     F .text	00000244 do_send
01812b2c g     F .text	00000084 alt_load
01845da4 g     O .rwdata	00000006 ethzero
0181ba6c g     F .text	00000020 stats_init
0182d2b0 g     F .text	0000006c alt_tse_get_system_index
01826634 g     F .text	000000a8 alt_avalon_sgdma_init
0180dd54 g     F .text	000000dc xQueueGiveFromISR
018090bc g     F .text	00000080 fputwc
0183d044 g     F .text	00000014 free
01819ddc g     F .text	000000e0 netif_find
01804f10 g     F .text	00000004 __sinit_lock_acquire
018007c4 g     F .text	0000009c xEthernetRun
018063cc g     F .text	00000120 __multadd
0182bd1c g     F .text	000000d0 tcpip_callback_with_block
018063a4 g     F .text	00000028 _Bfree
0182c198 g     F .text	00000030 no_printf
0181afb0 g     F .text	0000009c pbuf_dechain



Disassembly of section .entry:

02010000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2010000:	00900014 	movui	r2,16384
#endif

0:
    initi r2
 2010004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2010008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 201000c:	00bffd16 	blt	zero,r2,2010004 <__ram_exceptions_end+0xfffffbc0>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2010010:	00406034 	movhi	at,384
    ori r1, r1, %lo(_start)
 2010014:	08410914 	ori	at,at,1060
    jmp r1
 2010018:	0800683a 	jmp	at
 201001c:	00000000 	call	0 <__alt_mem_tse_descriptor_memory_0>

Disassembly of section .exceptions:

02010020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 2010020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -120		# Create space on the stack.
 2010024:	deffe204 	addi	sp,sp,-120
	stw		ra, 0(sp)
 2010028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 201002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 2010030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 2010034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 2010038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 201003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 2010040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 2010044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 2010048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 201004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 2010050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 2010054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 2010058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 201005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 2010060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 2010064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 2010068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 201006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 2010070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 2010074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 2010078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 201007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 2010080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 2010084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 2010088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 201008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 2010090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 2010094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 2010098:	df001c15 	stw	fp,112(sp)

	# preserve the errno
	call	__errno				# get the errno pointer
 201009c:	183cfe80 	call	183cfe8 <__errno>
	ldw		r3, 0(r2)			# load the errno in r3
 20100a0:	10c00017 	ldw	r3,0(r2)
	stw		r3, 116(sp)			# store the errno on the stack
 20100a4:	d8c01d15 	stw	r3,116(sp)

020100a8 <save_sp_to_pxCurrentTCB>:

save_sp_to_pxCurrentTCB:
	call	xTaskGetSchedulerState			# Only save the stack if scheduler has been started
 20100a8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
    beq		r2,	zero,	hw_irq_test			# If xTaskGetSchedulerState returns 0 it has not been started yet
 20100ac:	10000426 	beq	r2,zero,20100c0 <hw_irq_test>
 20100b0:	06006134 	movhi	et,388

	movia	et, pxCurrentTCB				# Load the address of the pxCurrentTCB pointer
 20100b4:	c61f2704 	addi	et,et,31900
	ldw		et, (et)						# Load the value of the pxCurrentTCB pointer
 20100b8:	c6000017 	ldw	et,0(et)
	stw		sp, (et)						# Store the stack pointer into the top of the TCB
 20100bc:	c6c00015 	stw	sp,0(et)

020100c0 <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending					# Load the Pending Interrupts indication
 20100c0:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 					# Load the eStatus (enabled interrupts).
 20100c4:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1						# Are interrupts enabled globally.
 20100c8:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 20100cc:	10009d26 	beq	r2,zero,2010344 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 20100d0:	20009c26 	beq	r4,zero,2010344 <soft_exceptions>

020100d4 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 20100d4:	20103780 	call	2010378 <alt_irq_handler>

020100d8 <restore_sp_from_pxCurrentTCB>:

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:

	call	xTaskGetSchedulerState			# Only restore stack if scheduler has been started
 20100d8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
    beq		r2,	zero,	restore_context		# If xTaskGetSchedulerState returns 0 it has not been started yet
 20100dc:	10000426 	beq	r2,zero,20100f0 <restore_context>
 20100e0:	06006134 	movhi	et,388

	movia	et, pxCurrentTCB				# Load the address of the pxCurrentTCB pointer
 20100e4:	c61f2704 	addi	et,et,31900
	ldw		et, (et)						# Load the value of the pxCurrentTCB pointer
 20100e8:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)						# Load the stack pointer with the top value of the TCB
 20100ec:	c6c00017 	ldw	sp,0(et)

020100f0 <restore_context>:

restore_context:
	# preserve the errno
	call	__errno			# get the errno pointer
 20100f0:	183cfe80 	call	183cfe8 <__errno>
	ldw		r3, 116(sp)		# get errno from the stack
 20100f4:	d8c01d17 	ldw	r3,116(sp)
	stw		r3, 0(r2)		# restore the global errno for this task
 20100f8:	10c00015 	stw	r3,0(r2)

	ldw		ra, 0(sp)		# Restore the registers.
 20100fc:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 2010100:	d8400217 	ldw	at,8(sp)

	ldw		r2, 12(sp)		# now restore r2 from the stack
 2010104:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 2010108:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 201010c:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 2010110:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 2010114:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 2010118:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 201011c:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 2010120:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 2010124:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 2010128:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 201012c:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 2010130:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 2010134:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 2010138:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 201013c:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 2010140:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 2010144:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 2010148:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 201014c:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 2010150:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 2010154:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 2010158:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 201015c:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 2010160:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 2010164:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 2010168:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 201016c:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 120		# Release stack space
 2010170:	dec01e04 	addi	sp,sp,120

    eret					# Return to address ea, loading eStatus into Status.
 2010174:	ef80083a 	eret
        /*
         * Split the instruction into its fields.  We need 4*A, 4*B, and 4*C as
         * offsets to the stack pointer for access to the stored register values.
         */
                             /* r2 = AAAAA,BBBBB,IIIIIIIIIIIIIIII,PPPPPP    */
        roli  r3, r2, 7      /* r3 = BBB,IIIIIIIIIIIIIIII,PPPPPP,AAAAA,BB   */
 2010178:	100611fa 	roli	r3,r2,7
        roli  r4, r3, 3      /* r4 = IIIIIIIIIIIIIIII,PPPPPP,AAAAA,BBBBB    */
 201017c:	180810fa 	roli	r4,r3,3
        roli  r6, r4, 2      /* r6 = IIIIIIIIIIIIII,PPPPPP,AAAAA,BBBBB,II   */
 2010180:	200c10ba 	roli	r6,r4,2
        srai  r4, r4, 16     /* r4 = (sign-extended) IMM16                  */
 2010184:	2009d43a 	srai	r4,r4,16
        xori  r6, r6, 0x42   /* r6 = CCC,XXXXXX,NNNNN,PPPPPP,AAAAA,bBBBB,cC */
 2010188:	3180109c 	xori	r6,r6,66
        roli  r7, r6, 5      /* r7 = XXXX,NNNNN,PPPPPP,AAAAA,bBBBB,cCCCC,XX */
 201018c:	300e117a 	roli	r7,r6,5
        andi  r5, r2, 0x3f   /* r5 = 00000000000000000000000000,PPPPPP      */
 2010190:	11400fcc 	andi	r5,r2,63
        xori  r3, r3, 0x40
 2010194:	18c0101c 	xori	r3,r3,64
        andi  r3, r3, 0x7c   /* r3 = 0000000000000000000000000,aAAAA,00     */
 2010198:	18c01f0c 	andi	r3,r3,124
        andi  r6, r6, 0x7c   /* r6 = 0000000000000000000000000,bBBBB,00     */
 201019c:	31801f0c 	andi	r6,r6,124
        andi  r7, r7, 0x7c   /* r7 = 0000000000000000000000000,cCCCC,00     */
 20101a0:	39c01f0c 	andi	r7,r7,124
         * Save everything on the stack to make it easy for the emulation routines
         * to retrieve the source register operands.  The exception entry code has
         * already saved some of this so we don't need to do it all again.
         */

        addi  sp, sp, -60
 20101a4:	defff104 	addi	sp,sp,-60
        stw   zero, 64(sp)   /* Save zero on stack to avoid special case for r0. */
 20101a8:	d8001015 	stw	zero,64(sp)
                             /* Register at and r2-r15 have already been saved.  */

        stw   r16,  0(sp)
 20101ac:	dc000015 	stw	r16,0(sp)
        stw   r17,  4(sp)
 20101b0:	dc400115 	stw	r17,4(sp)
        stw   r18,  8(sp)
 20101b4:	dc800215 	stw	r18,8(sp)
        stw   r19, 12(sp)
 20101b8:	dcc00315 	stw	r19,12(sp)
        stw   r20, 16(sp)
 20101bc:	dd000415 	stw	r20,16(sp)
        stw   r21, 20(sp)
 20101c0:	dd400515 	stw	r21,20(sp)
        stw   r22, 24(sp)
 20101c4:	dd800615 	stw	r22,24(sp)
        stw   r23, 28(sp)
 20101c8:	ddc00715 	stw	r23,28(sp)
                            /* et @ 32 - Has already been changed.*/
                            /* bt @ 36 - Usually isn't an operand.   */
        stw   gp,  40(sp)
 20101cc:	de800a15 	stw	gp,40(sp)
        stw   sp,  44(sp)
 20101d0:	dec00b15 	stw	sp,44(sp)
        stw   fp,  48(sp)
 20101d4:	df000c15 	stw	fp,48(sp)

        /*
         *  Prepare for either multiplication or division loop.
         *  They both loop 32 times.
         */
        movi   r14, 32
 20101d8:	03800804 	movi	r14,32
         * Get the operands.
         *
         * It is necessary to check for muli because it uses an I-type instruction
         * format, while the other instructions are have an R-type format.
         */
        add    r3, r3, sp     /* r3 = address of A-operand. */
 20101dc:	1ec7883a 	add	r3,r3,sp
        ldw    r3, 0(r3)      /* r3 = A-operand. */
 20101e0:	18c00017 	ldw	r3,0(r3)
        movi   r15, 0x24      /* muli opcode (I-type instruction format) */
 20101e4:	03c00904 	movi	r15,36
        beq    r5, r15, .Lmul_immed /* muli doesn't use the B register as a source */
 20101e8:	2bc02726 	beq	r5,r15,2010288 <restore_context+0x198>

        add    r6, r6, sp     /* r6 = address of B-operand.               */
 20101ec:	36cd883a 	add	r6,r6,sp
        ldw    r6, 0(r6)      /* r6 = B-operand.                          */
 20101f0:	31800017 	ldw	r6,0(r6)
                              /* r4 = SSSSSSSSSSSSSSSS,-----IMM16------   */
                              /* IMM16 not needed, align OPX portion      */
                              /* r4 = SSSSSSSSSSSSSSSS,CCCCC,-OPX--,00000 */
        srli   r4, r4, 5      /* r4 = 00000,SSSSSSSSSSSSSSSS,CCCCC,-OPX-- */
 20101f4:	2008d17a 	srli	r4,r4,5
        andi   r4, r4, 0x3f   /* r4 = 00000000000000000000000000,-OPX--   */
 20101f8:	21000fcc 	andi	r4,r4,63
         *
         *  This code assumes that OP is not muli (because muli was tested above).
         *  All other multiplies and divides are legal.  Anything else is illegal.
         */

        movi  r8, 0x3a                        /* OP for R-type mul* and div* */
 20101fc:	02000e84 	movi	r8,58
        bne   r5, r8, .Lnot_muldiv
 2010200:	2a004f1e 	bne	r5,r8,2010340 <restore_context+0x250>

        /* r15 already is 0x24 */            /* OPX of divu */
        beq   r4, r15, .Ldivide
 2010204:	23c00a26 	beq	r4,r15,2010230 <restore_context+0x140>

        movi  r15,0x27                        /* OPX of mul */
 2010208:	03c009c4 	movi	r15,39
        beq   r4, r15, .Lmultiply
 201020c:	23c02126 	beq	r4,r15,2010294 <restore_context+0x1a4>

        movi  r15,0x07                        /* OPX of mulxuu */
 2010210:	03c001c4 	movi	r15,7
        beq   r4, r15, .Lmultiply
 2010214:	23c01f26 	beq	r4,r15,2010294 <restore_context+0x1a4>

        movi  r15,0x17                        /* OPX of mulxsu */
 2010218:	03c005c4 	movi	r15,23
        beq   r4, r15, .Lmultiply
 201021c:	23c01d26 	beq	r4,r15,2010294 <restore_context+0x1a4>

        movi  r15,0x1f                        /* OPX of mulxss */
 2010220:	03c007c4 	movi	r15,31
        beq   r4, r15, .Lmultiply
 2010224:	23c01b26 	beq	r4,r15,2010294 <restore_context+0x1a4>

        movi  r15,0x25                        /* OPX of div */
 2010228:	03c00944 	movi	r15,37
        bne   r4, r15, .Lnot_muldiv
 201022c:	23c0441e 	bne	r4,r15,2010340 <restore_context+0x250>
.Ldivide:
        /*
         *  Prepare for division by assuming the result
         *  is unsigned, and storing its "sign" as 0.
         */
        movi   r17, 0
 2010230:	04400004 	movi	r17,0


        /* Which division opcode? */
        xori   r15, r4, 0x25         /* OPX of div */
 2010234:	23c0095c 	xori	r15,r4,37
        bne    r15, zero, .Lunsigned_division
 2010238:	7800051e 	bne	r15,zero,2010250 <restore_context+0x160>

        /*
         *  OPX is div.  Determine and store the sign of the quotient.
         *  Then take the absolute value of both operands.
         */
        xor   r17, r3, r6      /* MSB contains sign of quotient */
 201023c:	19a2f03a 	xor	r17,r3,r6
        bge   r3, zero, 0f
 2010240:	1800010e 	bge	r3,zero,2010248 <restore_context+0x158>
        sub   r3, zero, r3     /* -r3 */
 2010244:	00c7c83a 	sub	r3,zero,r3
0:
        bge   r6, zero, 0f
 2010248:	3000010e 	bge	r6,zero,2010250 <restore_context+0x160>
        sub   r6, zero, r6     /* -r6 */
 201024c:	018dc83a 	sub	r6,zero,r6
0:


.Lunsigned_division:
        /* Initialize the unsigned-division loop. */
        movi  r13, 0          /* remainder = 0 */
 2010250:	03400004 	movi	r13,0
        /*
        *       Division:
        *
        *       (remainder:dividend:quotient) <<= 1;
        */
        slli  r13, r13, 1
 2010254:	681a907a 	slli	r13,r13,1
        cmplt r15, r3, zero        /* r15 = MSB of r3 */
 2010258:	181e803a 	cmplt	r15,r3,zero
        or    r13, r13, r15
 201025c:	6bdab03a 	or	r13,r13,r15
        slli  r3, r3, 1
 2010260:	1806907a 	slli	r3,r3,1
        *       {
        *           set LSB of quotient
        *           remainder -= divisor;
        *       }
        */
        bltu  r13, r6, .Ldiv_skip
 2010264:	69800236 	bltu	r13,r6,2010270 <restore_context+0x180>
        ori   r3, r3, 1
 2010268:	18c00054 	ori	r3,r3,1
        sub   r13, r13, r6
 201026c:	699bc83a 	sub	r13,r13,r6
.Ldiv_skip:

        /*
        *   }
        */
        subi  r14, r14, 1
 2010270:	73bfffc4 	addi	r14,r14,-1
        bne   r14, zero, .Ldivide_loop
 2010274:	703ff71e 	bne	r14,zero,2010254 <__ram_exceptions_end+0xfffffe10>

        mov   r9, r3
 2010278:	1813883a 	mov	r9,r3
    
        /*
        *  Conditionally negate signed quotient.  If quotient is unsigned,
        *  the sign already is initialized to 0.
        */
        bge   r17, zero, .Lstore_result
 201027c:	8800230e 	bge	r17,zero,201030c <restore_context+0x21c>
        sub   r9, zero, r9     /* -r9 */
 2010280:	0253c83a 	sub	r9,zero,r9

        br    .Lstore_result
 2010284:	00002106 	br	201030c <restore_context+0x21c>
        *
        */

.Lmul_immed:
        /* Opcode is muli.  Change it into mul for remainder of algorithm. */
        mov   r7, r6         /* Field B is dest register, not field C. */
 2010288:	300f883a 	mov	r7,r6
        mov   r6, r4         /* Field IMM16 is src2, not field B. */
 201028c:	200d883a 	mov	r6,r4
        movi  r4, 0x27       /* OPX of mul is 0x27 */
 2010290:	010009c4 	movi	r4,39

.Lmultiply:
        /* Initialize the multiplication loop. */
        movi  r9, 0          /* mul_product    = 0 */
 2010294:	02400004 	movi	r9,0
        movi  r10, 0         /* mulxuu_product = 0 */
 2010298:	02800004 	movi	r10,0
        mov   r11, r6        /* save original multiplier for mulxsu and mulxss */
 201029c:	3017883a 	mov	r11,r6
        mov   r12, r6        /* mulxuu_multiplier (will be shifted) */
 20102a0:	3019883a 	mov	r12,r6
        movi  r16, 1         /* used to create "rori B,A,1" from "ror B,A,r16" */
 20102a4:	04000044 	movi	r16,1

        /*
        *       mul_product <<= 1;
        *       lsb = multiplier & 1;
        */
        slli   r9, r9, 1
 20102a8:	4812907a 	slli	r9,r9,1
        andi   r15, r12, 1
 20102ac:	63c0004c 	andi	r15,r12,1
        *       if (lsb == 1)
        *       {
        *           mulxuu_product += multiplicand;
        *       }
        */
        beq   r15, zero, .Lmulx_skip
 20102b0:	78000326 	beq	r15,zero,20102c0 <restore_context+0x1d0>
        add   r10, r10, r3
 20102b4:	50d5883a 	add	r10,r10,r3
        cmpltu r15, r10, r3  /* Save the carry from the MSB of mulxuu_product. */
 20102b8:	50df803a 	cmpltu	r15,r10,r3
        ror   r15, r15, r16  /* r15 = 0x80000000 on carry, or else 0x00000000 */
 20102bc:	7c1e583a 	ror	r15,r15,r16
        *       if (MSB of mul_multiplier == 1)
        *       {
        *           mul_product += multiplicand;
        *       }
        */
        bge   r6, zero, .Lmul_skip
 20102c0:	3000010e 	bge	r6,zero,20102c8 <restore_context+0x1d8>
        add   r9, r9, r3
 20102c4:	48d3883a 	add	r9,r9,r3
        /*
        *       mulxuu_product >>= 1;           logical shift
        *       mul_multiplier <<= 1;           done with MSB
        *       mulx_multiplier >>= 1;          done with LSB
        */
        srli   r10, r10, 1
 20102c8:	5014d07a 	srli	r10,r10,1
        or     r10, r10, r15           /* OR in the saved carry bit. */
 20102cc:	53d4b03a 	or	r10,r10,r15
        slli   r6, r6, 1
 20102d0:	300c907a 	slli	r6,r6,1
        srli   r12, r12, 1
 20102d4:	6018d07a 	srli	r12,r12,1


        /*
        *   }
        */
        subi   r14, r14, 1
 20102d8:	73bfffc4 	addi	r14,r14,-1
        bne    r14, zero, .Lmultiply_loop
 20102dc:	703ff21e 	bne	r14,zero,20102a8 <__ram_exceptions_end+0xfffffe64>
        *  Select/compute the result based on OPX.
        */


        /* OPX == mul?  Then store. */
        xori  r15, r4, 0x27
 20102e0:	23c009dc 	xori	r15,r4,39
        beq   r15, zero, .Lstore_result
 20102e4:	78000926 	beq	r15,zero,201030c <restore_context+0x21c>

        /* It's one of the mulx.. opcodes.  Move over the result. */
        mov   r9, r10
 20102e8:	5013883a 	mov	r9,r10

        /* OPX == mulxuu?  Then store. */
        xori  r15, r4, 0x07
 20102ec:	23c001dc 	xori	r15,r4,7
        beq   r15, zero, .Lstore_result
 20102f0:	78000626 	beq	r15,zero,201030c <restore_context+0x21c>

        /* Compute mulxsu
         *
         * mulxsu = mulxuu - ((rA < 0) ? rB : 0);
         */
        bge   r3, zero, .Lmulxsu_skip
 20102f4:	1800010e 	bge	r3,zero,20102fc <restore_context+0x20c>
        sub   r9, r9, r11
 20102f8:	4ad3c83a 	sub	r9,r9,r11
.Lmulxsu_skip:

        /* OPX == mulxsu?  Then store. */
        xori  r15, r4, 0x17
 20102fc:	23c005dc 	xori	r15,r4,23
        beq   r15, zero, .Lstore_result
 2010300:	78000226 	beq	r15,zero,201030c <restore_context+0x21c>

        /* Compute mulxss
         *
         * mulxss = mulxsu - ((rB < 0) ? rA : 0);
         */
        bge   r11, zero, .Lmulxss_skip
 2010304:	5800010e 	bge	r11,zero,201030c <restore_context+0x21c>
        sub   r9, r9, r3
 2010308:	48d3c83a 	sub	r9,r9,r3
.Lmulxss_skip:
        /* At this point, assume that OPX is mulxss, so store */


.Lstore_result:
        add   r7, r7, sp
 201030c:	3ecf883a 	add	r7,r7,sp
        stw   r9, 0(r7)
 2010310:	3a400015 	stw	r9,0(r7)

        ldw   r16,  0(sp)
 2010314:	dc000017 	ldw	r16,0(sp)
        ldw   r17,  4(sp)
 2010318:	dc400117 	ldw	r17,4(sp)
        ldw   r18,  8(sp)
 201031c:	dc800217 	ldw	r18,8(sp)
        ldw   r19, 12(sp)
 2010320:	dcc00317 	ldw	r19,12(sp)
        ldw   r20, 16(sp)
 2010324:	dd000417 	ldw	r20,16(sp)
        ldw   r21, 20(sp)
 2010328:	dd400517 	ldw	r21,20(sp)
        ldw   r22, 24(sp)
 201032c:	dd800617 	ldw	r22,24(sp)
        ldw   r23, 28(sp)
 2010330:	ddc00717 	ldw	r23,28(sp)

                            /* bt @ 32 - Breakpoint register usually isn't an operand. */
                            /* et @ 36 - Don't corrupt et. */
                            /* gp @ 40 - Don't corrupt gp. */
                            /* sp @ 44 - Don't corrupt sp. */
        ldw   fp,  48(sp)
 2010334:	df000c17 	ldw	fp,48(sp)
                            /* ea @ 52 - Don't corrupt ea. */
                            /* ba @ 56 - Breakpoint register usually isn't an operand. */

        addi  sp, sp, 60
 2010338:	dec00f04 	addi	sp,sp,60

        br    .Lexception_exit
 201033c:	00000e06 	br	2010378 <alt_irq_handler>


.Lnot_muldiv:

        addi  sp, sp, 60
 2010340:	dec00f04 	addi	sp,sp,60

02010344 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 2010344:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 2010348:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 201034c:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 2010350:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 2010354:	c0000226 	beq	et,zero,2010360 <call_scheduler>
#ifdef ALT_INCLUDE_INSTRUCTION_RELATED_EXCEPTION_API
  	mov		r4, ea									# load the PC of the exception into r4
  	call	alt_instruction_exception_entry			# call the invalid instruction parser and bring up the instruction in the callback
#else
  	break							# This is an un-implemented instruction or muldiv problem.
 2010358:	003da03a 	break	0
#endif
  	br		restore_context			# its something else
 201035c:	003f6406 	br	20100f0 <__ram_exceptions_end+0xfffffcac>

02010360 <call_scheduler>:

call_scheduler:

	call	xTaskGetSchedulerState			# Only restore stack if scheduler has been started
 2010360:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
    beq		r2,	zero,	restore_context		# If xTaskGetSchedulerState returns 0 it has not been started yet
 2010364:	103f6226 	beq	r2,zero,20100f0 <__ram_exceptions_end+0xfffffcac>

	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 2010368:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 201036c:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 2010370:	18100a40 	call	18100a4 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore.
 2010374:	003f5806 	br	20100d8 <__ram_exceptions_end+0xfffffc94>

02010378 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 2010378:	defff904 	addi	sp,sp,-28
 201037c:	dfc00615 	stw	ra,24(sp)
 2010380:	df000515 	stw	fp,20(sp)
 2010384:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2010388:	0005313a 	rdctl	r2,ipending
 201038c:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2010390:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 2010394:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 2010398:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 201039c:	00800044 	movi	r2,1
 20103a0:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 20103a4:	e0fffb17 	ldw	r3,-20(fp)
 20103a8:	e0bffc17 	ldw	r2,-16(fp)
 20103ac:	1884703a 	and	r2,r3,r2
 20103b0:	10001426 	beq	r2,zero,2010404 <alt_irq_handler+0x8c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 20103b4:	008061f4 	movhi	r2,391
 20103b8:	10aa7104 	addi	r2,r2,-22076
 20103bc:	e0fffd17 	ldw	r3,-12(fp)
 20103c0:	180690fa 	slli	r3,r3,3
 20103c4:	10c5883a 	add	r2,r2,r3
 20103c8:	10c00017 	ldw	r3,0(r2)
 20103cc:	008061f4 	movhi	r2,391
 20103d0:	10aa7104 	addi	r2,r2,-22076
 20103d4:	e13ffd17 	ldw	r4,-12(fp)
 20103d8:	200890fa 	slli	r4,r4,3
 20103dc:	1105883a 	add	r2,r2,r4
 20103e0:	10800104 	addi	r2,r2,4
 20103e4:	10800017 	ldw	r2,0(r2)
 20103e8:	1009883a 	mov	r4,r2
 20103ec:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 20103f0:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 20103f4:	0005313a 	rdctl	r2,ipending
 20103f8:	e0bfff15 	stw	r2,-4(fp)

  return active;
 20103fc:	e0bfff17 	ldw	r2,-4(fp)
 2010400:	00000706 	br	2010420 <alt_irq_handler+0xa8>
      }
      mask <<= 1;
 2010404:	e0bffc17 	ldw	r2,-16(fp)
 2010408:	1085883a 	add	r2,r2,r2
 201040c:	e0bffc15 	stw	r2,-16(fp)
      i++;
 2010410:	e0bffd17 	ldw	r2,-12(fp)
 2010414:	10800044 	addi	r2,r2,1
 2010418:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 201041c:	003fe106 	br	20103a4 <__ram_exceptions_end+0xffffff60>

    active = alt_irq_pending ();
 2010420:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 2010424:	e0bffb17 	ldw	r2,-20(fp)
 2010428:	103fdb1e 	bne	r2,zero,2010398 <__ram_exceptions_end+0xffffff54>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 201042c:	0001883a 	nop
 2010430:	e037883a 	mov	sp,fp
 2010434:	dfc00117 	ldw	ra,4(sp)
 2010438:	df000017 	ldw	fp,0(sp)
 201043c:	dec00204 	addi	sp,sp,8
 2010440:	f800283a 	ret

Disassembly of section .text:

01800424 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1800424:	06c08034 	movhi	sp,512
    ori sp, sp, %lo(__alt_stack_pointer)
 1800428:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 180042c:	06806134 	movhi	gp,388
    ori gp, gp, %lo(_gp)
 1800430:	d6b75414 	ori	gp,gp,56656
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1800434:	00806134 	movhi	r2,388
    ori r2, r2, %lo(__bss_start)
 1800438:	109f1814 	ori	r2,r2,31840

    movhi r3, %hi(__bss_end)
 180043c:	00c061b4 	movhi	r3,390
    ori r3, r3, %lo(__bss_end)
 1800440:	18eac114 	ori	r3,r3,43780

    beq r2, r3, 1f
 1800444:	10c00326 	beq	r2,r3,1800454 <_start+0x30>

0:
    stw zero, (r2)
 1800448:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 180044c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 1800450:	10fffd36 	bltu	r2,r3,1800448 <__ram_exceptions_end+0xff7f0004>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 1800454:	1812b2c0 	call	1812b2c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1800458:	180d4740 	call	180d474 <alt_main>

0180045c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 180045c:	003fff06 	br	180045c <__ram_exceptions_end+0xff7f0018>

01800460 <vApplicationMallocFailedHook>:

static int nw_ready;
static sys_thread_t main_thread_handle;

// hook functions
void vApplicationMallocFailedHook(){
 1800460:	defffe04 	addi	sp,sp,-8
 1800464:	dfc00115 	stw	ra,4(sp)
 1800468:	df000015 	stw	fp,0(sp)
 180046c:	d839883a 	mov	fp,sp
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 1800470:	0100fa04 	movi	r4,1000
 1800474:	180f2cc0 	call	180f2cc <vTaskDelay>
        alt_printf("vApplicationMallocFailedHook \r\n");
 1800478:	01006134 	movhi	r4,388
 180047c:	21039a04 	addi	r4,r4,3688
 1800480:	1812f140 	call	1812f14 <alt_printf>
    }
 1800484:	003ffa06 	br	1800470 <__ram_exceptions_end+0xff7f002c>

01800488 <vApplicationStackOverflowHook>:
}

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ){
 1800488:	defffc04 	addi	sp,sp,-16
 180048c:	dfc00315 	stw	ra,12(sp)
 1800490:	df000215 	stw	fp,8(sp)
 1800494:	df000204 	addi	fp,sp,8
 1800498:	e13ffe15 	stw	r4,-8(fp)
 180049c:	e17fff15 	stw	r5,-4(fp)
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 18004a0:	0100fa04 	movi	r4,1000
 18004a4:	180f2cc0 	call	180f2cc <vTaskDelay>
        alt_printf("vApplicationStackOverflowHook \r\n");
 18004a8:	01006134 	movhi	r4,388
 18004ac:	2103a204 	addi	r4,r4,3720
 18004b0:	1812f140 	call	1812f14 <alt_printf>
    }
 18004b4:	003ffa06 	br	18004a0 <__ram_exceptions_end+0xff7f005c>

018004b8 <StatusCallback>:
}

// callback function for when the DHCP subsystem acquires an IP address.
static void StatusCallback(struct netif* netif)
{
 18004b8:	deffbd04 	addi	sp,sp,-268
 18004bc:	dfc04215 	stw	ra,264(sp)
 18004c0:	df004115 	stw	fp,260(sp)
 18004c4:	df004104 	addi	fp,sp,260
 18004c8:	e13fff15 	stw	r4,-4(fp)
	// get IP and stuff
	printf("[ethernet] Acquired IP address via DHCP client for interface: %s\n", netif->name);
 18004cc:	e0bfff17 	ldw	r2,-4(fp)
 18004d0:	10800e84 	addi	r2,r2,58
 18004d4:	100b883a 	mov	r5,r2
 18004d8:	01006134 	movhi	r4,388
 18004dc:	2103ab04 	addi	r4,r4,3756
 18004e0:	1800c180 	call	1800c18 <printf>

	char buf[255];

	print_ipad(netif->ip_addr.addr, buf);
 18004e4:	e0bfff17 	ldw	r2,-4(fp)
 18004e8:	10800117 	ldw	r2,4(r2)
 18004ec:	e17fbf04 	addi	r5,fp,-260
 18004f0:	1009883a 	mov	r4,r2
 18004f4:	1813f280 	call	1813f28 <print_ipad>
	printf("[ethernet] IP address : %s\n", buf);
 18004f8:	e17fbf04 	addi	r5,fp,-260
 18004fc:	01006134 	movhi	r4,388
 1800500:	2103bc04 	addi	r4,r4,3824
 1800504:	1800c180 	call	1800c18 <printf>

	print_ipad(netif->netmask.addr, buf);
 1800508:	e0bfff17 	ldw	r2,-4(fp)
 180050c:	10800217 	ldw	r2,8(r2)
 1800510:	e17fbf04 	addi	r5,fp,-260
 1800514:	1009883a 	mov	r4,r2
 1800518:	1813f280 	call	1813f28 <print_ipad>
	printf("[ethernet] Subnet     : %s\n", buf);
 180051c:	e17fbf04 	addi	r5,fp,-260
 1800520:	01006134 	movhi	r4,388
 1800524:	2103c304 	addi	r4,r4,3852
 1800528:	1800c180 	call	1800c18 <printf>

    print_ipad(netif->gw.addr, buf);
 180052c:	e0bfff17 	ldw	r2,-4(fp)
 1800530:	10800317 	ldw	r2,12(r2)
 1800534:	e17fbf04 	addi	r5,fp,-260
 1800538:	1009883a 	mov	r4,r2
 180053c:	1813f280 	call	1813f28 <print_ipad>
	printf("[ethernet] Gateway    : %s\n", buf);
 1800540:	e17fbf04 	addi	r5,fp,-260
 1800544:	01006134 	movhi	r4,388
 1800548:	2103ca04 	addi	r4,r4,3880
 180054c:	1800c180 	call	1800c18 <printf>
}
 1800550:	0001883a 	nop
 1800554:	e037883a 	mov	sp,fp
 1800558:	dfc00117 	ldw	ra,4(sp)
 180055c:	df000017 	ldw	fp,0(sp)
 1800560:	dec00204 	addi	sp,sp,8
 1800564:	f800283a 	ret

01800568 <LinkCallback>:

static void LinkCallback(struct netif* netif)
{
 1800568:	defffd04 	addi	sp,sp,-12
 180056c:	dfc00215 	stw	ra,8(sp)
 1800570:	df000115 	stw	fp,4(sp)
 1800574:	df000104 	addi	fp,sp,4
 1800578:	e13fff15 	stw	r4,-4(fp)
	// link change callback
	// TODO release semaphore
	// TODO switch context

	alt_printf("[ethernet] Link Callback for interface: %s\n", netif->name);
 180057c:	e0bfff17 	ldw	r2,-4(fp)
 1800580:	10800e84 	addi	r2,r2,58
 1800584:	100b883a 	mov	r5,r2
 1800588:	01006134 	movhi	r4,388
 180058c:	2103d104 	addi	r4,r4,3908
 1800590:	1812f140 	call	1812f14 <alt_printf>
}
 1800594:	0001883a 	nop
 1800598:	e037883a 	mov	sp,fp
 180059c:	dfc00117 	ldw	ra,4(sp)
 18005a0:	df000017 	ldw	fp,0(sp)
 18005a4:	dec00204 	addi	sp,sp,8
 18005a8:	f800283a 	ret

018005ac <InitNetwork>:

int InitNetwork(void)
{
 18005ac:	defffe04 	addi	sp,sp,-8
 18005b0:	dfc00115 	stw	ra,4(sp)
 18005b4:	df000015 	stw	fp,0(sp)
 18005b8:	d839883a 	mov	fp,sp
	// register new DHCP "IP attained" callback function.
	// if DHCP is acquired, ws_ipset will be called instead of dhc_main_ipset().
	lwip_set_status_callback(StatusCallback);
 18005bc:	01006034 	movhi	r4,384
 18005c0:	21012e04 	addi	r4,r4,1208
 18005c4:	1813cfc0 	call	1813cfc <lwip_set_status_callback>
	lwip_set_link_callback(LinkCallback);
 18005c8:	01006034 	movhi	r4,384
 18005cc:	21015a04 	addi	r4,r4,1384
 18005d0:	1813d300 	call	1813d30 <lwip_set_link_callback>

	// Initialize LwIP TCP/IP stack.
	// This function is blocking till the the interface is up.
	lwip_initialize(1);
 18005d4:	01000044 	movi	r4,1
 18005d8:	181384c0 	call	181384c <lwip_initialize>

	return EXIT_SUCCESS;
 18005dc:	0005883a 	mov	r2,zero
}
 18005e0:	e037883a 	mov	sp,fp
 18005e4:	dfc00117 	ldw	ra,4(sp)
 18005e8:	df000017 	ldw	fp,0(sp)
 18005ec:	dec00204 	addi	sp,sp,8
 18005f0:	f800283a 	ret

018005f4 <WaitOnPHY>:

static int WaitOnPHY(void)
{
 18005f4:	defff904 	addi	sp,sp,-28
 18005f8:	dfc00615 	stw	ra,24(sp)
 18005fc:	df000515 	stw	fp,20(sp)
 1800600:	df000504 	addi	fp,sp,20
	int phyadd;
	int phyid;
	int phyid2 = 0;
 1800604:	e03ffd15 	stw	zero,-12(fp)

	np_tse_mac* pmac;
	bool bInitialized = false;
 1800608:	e03fff05 	stb	zero,-4(fp)

	while (!bInitialized) {
 180060c:	00003606 	br	18006e8 <WaitOnPHY+0xf4>
		alt_printf("[ethernet] PHY INFO: Interface: %d Waiting for PHY\n", 0);
 1800610:	000b883a 	mov	r5,zero
 1800614:	01006134 	movhi	r4,388
 1800618:	2103dc04 	addi	r4,r4,3952
 180061c:	1812f140 	call	1812f14 <alt_printf>

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;
 1800620:	00880004 	movi	r2,8192
 1800624:	e0bffe15 	stw	r2,-8(fp)


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 1800628:	e03ffb15 	stw	zero,-20(fp)
 180062c:	00001a06 	br	1800698 <WaitOnPHY+0xa4>
			IOWR(&pmac->MDIO_ADDR0, 0, phyadd);
 1800630:	e0bffe17 	ldw	r2,-8(fp)
 1800634:	10800f04 	addi	r2,r2,60
 1800638:	e0fffb17 	ldw	r3,-20(fp)
 180063c:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->MDIO_IFACE.PHY_ID1, 0);
 1800640:	e0bffe17 	ldw	r2,-8(fp)
 1800644:	1080a204 	addi	r2,r2,648
 1800648:	10800037 	ldwio	r2,0(r2)
 180064c:	e0bffc15 	stw	r2,-16(fp)
			phyid2 = IORD(&pmac->MDIO_IFACE.PHY_ID2, 0);
 1800650:	e0bffe17 	ldw	r2,-8(fp)
 1800654:	1080a304 	addi	r2,r2,652
 1800658:	10800037 	ldwio	r2,0(r2)
 180065c:	e0bffd15 	stw	r2,-12(fp)

			if (phyid != phyid2) {
 1800660:	e0fffc17 	ldw	r3,-16(fp)
 1800664:	e0bffd17 	ldw	r2,-12(fp)
 1800668:	18800826 	beq	r3,r2,180068c <WaitOnPHY+0x98>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
 180066c:	e1fffd17 	ldw	r7,-12(fp)
 1800670:	e1bffc17 	ldw	r6,-16(fp)
 1800674:	e17ffb17 	ldw	r5,-20(fp)
 1800678:	01006134 	movhi	r4,388
 180067c:	2103e904 	addi	r4,r4,4004
 1800680:	1812f140 	call	1812f14 <alt_printf>
				phyadd = 0xff;
 1800684:	00803fc4 	movi	r2,255
 1800688:	e0bffb15 	stw	r2,-20(fp)

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 180068c:	e0bffb17 	ldw	r2,-20(fp)
 1800690:	10800044 	addi	r2,r2,1
 1800694:	e0bffb15 	stw	r2,-20(fp)
 1800698:	e0bffb17 	ldw	r2,-20(fp)
 180069c:	10803fd0 	cmplti	r2,r2,255
 18006a0:	103fe31e 	bne	r2,zero,1800630 <__ram_exceptions_end+0xff7f01ec>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
 18006a4:	e0bffb17 	ldw	r2,-20(fp)
 18006a8:	10803fd8 	cmpnei	r2,r2,255
 18006ac:	10000c1e 	bne	r2,zero,18006e0 <WaitOnPHY+0xec>
 18006b0:	e0fffc17 	ldw	r3,-16(fp)
 18006b4:	e0bffd17 	ldw	r2,-12(fp)
 18006b8:	1880091e 	bne	r3,r2,18006e0 <WaitOnPHY+0xec>
			alt_printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
 18006bc:	01006134 	movhi	r4,388
 18006c0:	2103f404 	addi	r4,r4,4048
 18006c4:	1812f140 	call	1812f14 <alt_printf>
			bInitialized = true;
 18006c8:	00800044 	movi	r2,1
 18006cc:	e0bfff05 	stb	r2,-4(fp)
			mssleep(1000);
 18006d0:	010003f4 	movhi	r4,15
 18006d4:	21109004 	addi	r4,r4,16960
 18006d8:	18132900 	call	1813290 <usleep>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
 18006dc:	00000206 	br	18006e8 <WaitOnPHY+0xf4>
			alt_printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
			bInitialized = true;
			mssleep(1000);
		}
		else
			bInitialized = true;
 18006e0:	00800044 	movi	r2,1
 18006e4:	e0bfff05 	stb	r2,-4(fp)
	int phyid2 = 0;

	np_tse_mac* pmac;
	bool bInitialized = false;

	while (!bInitialized) {
 18006e8:	e0bfff03 	ldbu	r2,-4(fp)
 18006ec:	1080005c 	xori	r2,r2,1
 18006f0:	10803fcc 	andi	r2,r2,255
 18006f4:	103fc61e 	bne	r2,zero,1800610 <__ram_exceptions_end+0xff7f01cc>
		else
			bInitialized = true;
	}

	// issue a PHY reset.
	IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 18006f8:	e0bffe17 	ldw	r2,-8(fp)
 18006fc:	1080a004 	addi	r2,r2,640
 1800700:	00e40014 	movui	r3,36864
 1800704:	10c00035 	stwio	r3,0(r2)
	if (((IORD(&pmac->MDIO_IFACE.CONTROL, 0) & PCS_CTL_rx_slpbk) != 0) || ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)) {
 1800708:	e0bffe17 	ldw	r2,-8(fp)
 180070c:	1080a004 	addi	r2,r2,640
 1800710:	10800037 	ldwio	r2,0(r2)
 1800714:	1090000c 	andi	r2,r2,16384
 1800718:	1000051e 	bne	r2,zero,1800730 <WaitOnPHY+0x13c>
 180071c:	e0bffe17 	ldw	r2,-8(fp)
 1800720:	1080a104 	addi	r2,r2,644
 1800724:	10800037 	ldwio	r2,0(r2)
 1800728:	1080080c 	andi	r2,r2,32
 180072c:	1000071e 	bne	r2,zero,180074c <WaitOnPHY+0x158>
		IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 1800730:	e0bffe17 	ldw	r2,-8(fp)
 1800734:	1080a004 	addi	r2,r2,640
 1800738:	00e40014 	movui	r3,36864
 180073c:	10c00035 	stwio	r3,0(r2)
		alt_printf("[ethernet] PHY INFO: Issuing PHY Reset\n");
 1800740:	01006134 	movhi	r4,388
 1800744:	21040204 	addi	r4,r4,4104
 1800748:	1812f140 	call	1812f14 <alt_printf>
	}

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
 180074c:	e0bffe17 	ldw	r2,-8(fp)
 1800750:	1080a104 	addi	r2,r2,644
 1800754:	10800037 	ldwio	r2,0(r2)
 1800758:	1080080c 	andi	r2,r2,32
 180075c:	1000111e 	bne	r2,zero,18007a4 <WaitOnPHY+0x1b0>
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");
 1800760:	01006134 	movhi	r4,388
 1800764:	21040c04 	addi	r4,r4,4144
 1800768:	1812f140 	call	1812f14 <alt_printf>

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 180076c:	00000206 	br	1800778 <WaitOnPHY+0x184>
			mssleep(10);
 1800770:	0109c404 	movi	r4,10000
 1800774:	18132900 	call	1813290 <usleep>

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 1800778:	e0bffe17 	ldw	r2,-8(fp)
 180077c:	1080a104 	addi	r2,r2,644
 1800780:	10800037 	ldwio	r2,0(r2)
 1800784:	1080080c 	andi	r2,r2,32
 1800788:	103ff926 	beq	r2,zero,1800770 <__ram_exceptions_end+0xff7f032c>
			mssleep(10);

		alt_printf("[ethernet] PHY INFO: PHY link detected, allowing network to start.\n");
 180078c:	01006134 	movhi	r4,388
 1800790:	21041804 	addi	r4,r4,4192
 1800794:	1812f140 	call	1812f14 <alt_printf>
		
		mssleep(1000);
 1800798:	010003f4 	movhi	r4,15
 180079c:	21109004 	addi	r4,r4,16960
 18007a0:	18132900 	call	1813290 <usleep>
	}

	mssleep(10);
 18007a4:	0109c404 	movi	r4,10000
 18007a8:	18132900 	call	1813290 <usleep>

	return 0;
 18007ac:	0005883a 	mov	r2,zero
}
 18007b0:	e037883a 	mov	sp,fp
 18007b4:	dfc00117 	ldw	ra,4(sp)
 18007b8:	df000017 	ldw	fp,0(sp)
 18007bc:	dec00204 	addi	sp,sp,8
 18007c0:	f800283a 	ret

018007c4 <xEthernetRun>:


void xEthernetRun()
{
 18007c4:	defffe04 	addi	sp,sp,-8
 18007c8:	dfc00115 	stw	ra,4(sp)
 18007cc:	df000015 	stw	fp,0(sp)
 18007d0:	d839883a 	mov	fp,sp
    alt_printf("--------- Init Network ---------\r\n");
 18007d4:	01006134 	movhi	r4,388
 18007d8:	21042904 	addi	r4,r4,4260
 18007dc:	1812f140 	call	1812f14 <alt_printf>

	// initialize PHY
	WaitOnPHY();
 18007e0:	18005f40 	call	18005f4 <WaitOnPHY>

	if (InitNetwork() != EXIT_SUCCESS) {
 18007e4:	18005ac0 	call	18005ac <InitNetwork>
 18007e8:	10000326 	beq	r2,zero,18007f8 <xEthernetRun+0x34>
		// the network initialization has failed.
		alt_printf("[ethernet] Network initialize failed!\n");
 18007ec:	01006134 	movhi	r4,388
 18007f0:	21043204 	addi	r4,r4,4296
 18007f4:	1812f140 	call	1812f14 <alt_printf>
	}

    nw_ready = 1;
 18007f8:	00800044 	movi	r2,1
 18007fc:	d0a7c415 	stw	r2,-24816(gp)
	alt_printf("--------- Init Done ---------\r\n");
 1800800:	01006134 	movhi	r4,388
 1800804:	21043c04 	addi	r4,r4,4336
 1800808:	1812f140 	call	1812f14 <alt_printf>
    // starting the network thread
    /*sys_thread_new("ping", PingThread, NULL,
    		THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);*/

	IP4_ADDR(&PingIp, 192, 168, 1, 100);
 180080c:	009900b4 	movhi	r2,25602
 1800810:	10aa3004 	addi	r2,r2,-22336
 1800814:	d0a7c615 	stw	r2,-24808(gp)
	for (;;) {

        lwip_ping_target(PingIp.addr, 1, 0, 100);
 1800818:	d0a7c617 	ldw	r2,-24808(gp)
 180081c:	01c01904 	movi	r7,100
 1800820:	000d883a 	mov	r6,zero
 1800824:	01400044 	movi	r5,1
 1800828:	1009883a 	mov	r4,r2
 180082c:	1824a740 	call	1824a74 <lwip_ping_target>
		// sleep for 1 second
		//lwip_ping_target(PingIp.addr, 10, 0, 100);
		alt_printf("Rx Count: %d \r\n", ethernetif_input((struct netif*)get_netif(0)));
 1800830:	0009883a 	mov	r4,zero
 1800834:	1813cb40 	call	1813cb4 <get_netif>
 1800838:	1009883a 	mov	r4,r2
 180083c:	18135a00 	call	18135a0 <ethernetif_input>
 1800840:	100b883a 	mov	r5,r2
 1800844:	01006134 	movhi	r4,388
 1800848:	21044404 	addi	r4,r4,4368
 180084c:	1812f140 	call	1812f14 <alt_printf>

        mssleep(1000);
 1800850:	010003f4 	movhi	r4,15
 1800854:	21109004 	addi	r4,r4,16960
 1800858:	18132900 	call	1813290 <usleep>
	}
 180085c:	003fee06 	br	1800818 <__ram_exceptions_end+0xff7f03d4>

01800860 <get_mac_addr>:
    //vTaskDelete(NULL);
}

// callback wrapper for lwip to get the interface configurations
int get_mac_addr(int iface, struct netif* ethif, unsigned char mac_addr[6])
{
 1800860:	defff704 	addi	sp,sp,-36
 1800864:	dfc00815 	stw	ra,32(sp)
 1800868:	df000715 	stw	fp,28(sp)
 180086c:	df000704 	addi	fp,sp,28
 1800870:	e13ffd15 	stw	r4,-12(fp)
 1800874:	e17ffe15 	stw	r5,-8(fp)
 1800878:	e1bfff15 	stw	r6,-4(fp)
	mac_addr[0] = 0x12;
 180087c:	e0bfff17 	ldw	r2,-4(fp)
 1800880:	00c00484 	movi	r3,18
 1800884:	10c00005 	stb	r3,0(r2)
	mac_addr[1] = 0x23;
 1800888:	e0bfff17 	ldw	r2,-4(fp)
 180088c:	10800044 	addi	r2,r2,1
 1800890:	00c008c4 	movi	r3,35
 1800894:	10c00005 	stb	r3,0(r2)
	mac_addr[2] = 0x45;
 1800898:	e0bfff17 	ldw	r2,-4(fp)
 180089c:	10800084 	addi	r2,r2,2
 18008a0:	00c01144 	movi	r3,69
 18008a4:	10c00005 	stb	r3,0(r2)
	mac_addr[3] = 0xFF;
 18008a8:	e0bfff17 	ldw	r2,-4(fp)
 18008ac:	108000c4 	addi	r2,r2,3
 18008b0:	00ffffc4 	movi	r3,-1
 18008b4:	10c00005 	stb	r3,0(r2)
	mac_addr[4] = 0xFF;
 18008b8:	e0bfff17 	ldw	r2,-4(fp)
 18008bc:	10800104 	addi	r2,r2,4
 18008c0:	00ffffc4 	movi	r3,-1
 18008c4:	10c00005 	stb	r3,0(r2)
	mac_addr[5] = 0xF0 + iface;
 18008c8:	e0bfff17 	ldw	r2,-4(fp)
 18008cc:	10800144 	addi	r2,r2,5
 18008d0:	e0fffd17 	ldw	r3,-12(fp)
 18008d4:	18fffc04 	addi	r3,r3,-16
 18008d8:	10c00005 	stb	r3,0(r2)

	// only show info if net is not NULL
	if (ethif)
 18008dc:	e0bffe17 	ldw	r2,-8(fp)
 18008e0:	10002026 	beq	r2,zero,1800964 <get_mac_addr+0x104>
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 18008e4:	e0bfff17 	ldw	r2,-4(fp)
 18008e8:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 18008ec:	12003fcc 	andi	r8,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 18008f0:	e0bfff17 	ldw	r2,-4(fp)
 18008f4:	10800044 	addi	r2,r2,1
 18008f8:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 18008fc:	11803fcc 	andi	r6,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 1800900:	e0bfff17 	ldw	r2,-4(fp)
 1800904:	10800084 	addi	r2,r2,2
 1800908:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 180090c:	11c03fcc 	andi	r7,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 1800910:	e0bfff17 	ldw	r2,-4(fp)
 1800914:	108000c4 	addi	r2,r2,3
 1800918:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 180091c:	10803fcc 	andi	r2,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 1800920:	e0ffff17 	ldw	r3,-4(fp)
 1800924:	18c00104 	addi	r3,r3,4
 1800928:	18c00003 	ldbu	r3,0(r3)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 180092c:	18c03fcc 	andi	r3,r3,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 1800930:	e13fff17 	ldw	r4,-4(fp)
 1800934:	21000144 	addi	r4,r4,5
 1800938:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 180093c:	21003fcc 	andi	r4,r4,255
 1800940:	e17ffd17 	ldw	r5,-12(fp)
 1800944:	d9400315 	stw	r5,12(sp)
 1800948:	d9000215 	stw	r4,8(sp)
 180094c:	d8c00115 	stw	r3,4(sp)
 1800950:	d8800015 	stw	r2,0(sp)
 1800954:	400b883a 	mov	r5,r8
 1800958:	01006134 	movhi	r4,388
 180095c:	21044804 	addi	r4,r4,4384
 1800960:	1800c180 	call	1800c18 <printf>
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);

	return EXIT_SUCCESS;
 1800964:	0005883a 	mov	r2,zero
}
 1800968:	e037883a 	mov	sp,fp
 180096c:	dfc00117 	ldw	ra,4(sp)
 1800970:	df000017 	ldw	fp,0(sp)
 1800974:	dec00204 	addi	sp,sp,8
 1800978:	f800283a 	ret

0180097c <get_ip_addr>:

// callback wrapper for lwip to get the IP configurations
int get_ip_addr(int iface, ip_addr_t* ipaddr, ip_addr_t* netmask, ip_addr_t* gw, int* use_dhcp)
{
 180097c:	deffba04 	addi	sp,sp,-280
 1800980:	dfc04515 	stw	ra,276(sp)
 1800984:	df004415 	stw	fp,272(sp)
 1800988:	df004404 	addi	fp,sp,272
 180098c:	e13ffc15 	stw	r4,-16(fp)
 1800990:	e17ffd15 	stw	r5,-12(fp)
 1800994:	e1bffe15 	stw	r6,-8(fp)
 1800998:	e1ffff15 	stw	r7,-4(fp)
	// set configuration
	IP4_ADDR(ipaddr, 192, 168, 1, 218);
 180099c:	e0fffd17 	ldw	r3,-12(fp)
 18009a0:	00b680b4 	movhi	r2,55810
 18009a4:	10aa3004 	addi	r2,r2,-22336
 18009a8:	18800015 	stw	r2,0(r3)
	IP4_ADDR(netmask, 255, 255, 255, 0);
 18009ac:	e0fffe17 	ldw	r3,-8(fp)
 18009b0:	00804034 	movhi	r2,256
 18009b4:	10bfffc4 	addi	r2,r2,-1
 18009b8:	18800015 	stw	r2,0(r3)
	IP4_ADDR(gw, 192, 168, 1, 1);
 18009bc:	e0ffff17 	ldw	r3,-4(fp)
 18009c0:	008040b4 	movhi	r2,258
 18009c4:	10aa3004 	addi	r2,r2,-22336
 18009c8:	18800015 	stw	r2,0(r3)
	*use_dhcp = 0;
 18009cc:	e0800217 	ldw	r2,8(fp)
 18009d0:	10000015 	stw	zero,0(r2)

	if (*use_dhcp == 0){
 18009d4:	e0800217 	ldw	r2,8(fp)
 18009d8:	10800017 	ldw	r2,0(r2)
 18009dc:	10000b1e 	bne	r2,zero,1800a0c <get_ip_addr+0x90>
		char buf[255];
		print_ipad(ipaddr->addr, buf);
 18009e0:	e0bffd17 	ldw	r2,-12(fp)
 18009e4:	10800017 	ldw	r2,0(r2)
 18009e8:	e17fbc04 	addi	r5,fp,-272
 18009ec:	1009883a 	mov	r4,r2
 18009f0:	1813f280 	call	1813f28 <print_ipad>
		printf("[ethernet] Static IP Address for interface %d %s\n", iface, buf);
 18009f4:	e1bfbc04 	addi	r6,fp,-272
 18009f8:	e17ffc17 	ldw	r5,-16(fp)
 18009fc:	01006134 	movhi	r4,388
 1800a00:	21045e04 	addi	r4,r4,4472
 1800a04:	1800c180 	call	1800c18 <printf>
 1800a08:	00000406 	br	1800a1c <get_ip_addr+0xa0>
	}
	else
		printf("[ethernet] Starting get IP via DHCP for interface %d\n", iface);
 1800a0c:	e17ffc17 	ldw	r5,-16(fp)
 1800a10:	01006134 	movhi	r4,388
 1800a14:	21046b04 	addi	r4,r4,4524
 1800a18:	1800c180 	call	1800c18 <printf>

	return EXIT_SUCCESS;
 1800a1c:	0005883a 	mov	r2,zero
}
 1800a20:	e037883a 	mov	sp,fp
 1800a24:	dfc00117 	ldw	ra,4(sp)
 1800a28:	df000017 	ldw	fp,0(sp)
 1800a2c:	dec00204 	addi	sp,sp,8
 1800a30:	f800283a 	ret

01800a34 <get_hostname>:

int get_hostname(int iface, const char **hostname)
{
 1800a34:	defffd04 	addi	sp,sp,-12
 1800a38:	df000215 	stw	fp,8(sp)
 1800a3c:	df000204 	addi	fp,sp,8
 1800a40:	e13ffe15 	stw	r4,-8(fp)
 1800a44:	e17fff15 	stw	r5,-4(fp)
	*hostname = "LwIP";
 1800a48:	e0ffff17 	ldw	r3,-4(fp)
 1800a4c:	00806134 	movhi	r2,388
 1800a50:	10847904 	addi	r2,r2,4580
 1800a54:	18800015 	stw	r2,0(r3)

	return ERR_OK;
 1800a58:	0005883a 	mov	r2,zero
}
 1800a5c:	e037883a 	mov	sp,fp
 1800a60:	df000017 	ldw	fp,0(sp)
 1800a64:	dec00104 	addi	sp,sp,4
 1800a68:	f800283a 	ret

01800a6c <get_iface_name>:

int get_iface_name(int iface, char name[ETH_IFACE_NAME_LENGTH])
{
 1800a6c:	defffd04 	addi	sp,sp,-12
 1800a70:	df000215 	stw	fp,8(sp)
 1800a74:	df000204 	addi	fp,sp,8
 1800a78:	e13ffe15 	stw	r4,-8(fp)
 1800a7c:	e17fff15 	stw	r5,-4(fp)
	name[0] = 'e';
 1800a80:	e0bfff17 	ldw	r2,-4(fp)
 1800a84:	00c01944 	movi	r3,101
 1800a88:	10c00005 	stb	r3,0(r2)
	name[1] = (iface + 0x30);
 1800a8c:	e0bfff17 	ldw	r2,-4(fp)
 1800a90:	10800044 	addi	r2,r2,1
 1800a94:	e0fffe17 	ldw	r3,-8(fp)
 1800a98:	18c00c04 	addi	r3,r3,48
 1800a9c:	10c00005 	stb	r3,0(r2)

	return ERR_OK;
 1800aa0:	0005883a 	mov	r2,zero
}
 1800aa4:	e037883a 	mov	sp,fp
 1800aa8:	df000017 	ldw	fp,0(sp)
 1800aac:	dec00104 	addi	sp,sp,4
 1800ab0:	f800283a 	ret

01800ab4 <is_interface_active>:

int is_interface_active(int iface)
{
 1800ab4:	defffe04 	addi	sp,sp,-8
 1800ab8:	df000115 	stw	fp,4(sp)
 1800abc:	df000104 	addi	fp,sp,4
 1800ac0:	e13fff15 	stw	r4,-4(fp)
	return 1;
 1800ac4:	00800044 	movi	r2,1
}
 1800ac8:	e037883a 	mov	sp,fp
 1800acc:	df000017 	ldw	fp,0(sp)
 1800ad0:	dec00104 	addi	sp,sp,4
 1800ad4:	f800283a 	ret

01800ad8 <main>:


int main(){
 1800ad8:	defffd04 	addi	sp,sp,-12
 1800adc:	dfc00215 	stw	ra,8(sp)
 1800ae0:	df000115 	stw	fp,4(sp)
 1800ae4:	df000104 	addi	fp,sp,4
    main_thread_handle = sys_thread_new("main_thrd", (void(*)(void*))main_thread, 0,
 1800ae8:	008000c4 	movi	r2,3
 1800aec:	d8800015 	stw	r2,0(sp)
 1800af0:	01c40004 	movi	r7,4096
 1800af4:	000d883a 	mov	r6,zero
 1800af8:	01406034 	movhi	r5,384
 1800afc:	2942c604 	addi	r5,r5,2840
 1800b00:	01006134 	movhi	r4,388
 1800b04:	21047b04 	addi	r4,r4,4588
 1800b08:	181569c0 	call	181569c <sys_thread_new>
 1800b0c:	d0a7c515 	stw	r2,-24812(gp)
                    THREAD_STACKSIZE,
					DEFAULT_THREAD_PRIO);
    vTaskStartScheduler();
 1800b10:	180f9f40 	call	180f9f4 <vTaskStartScheduler>
    while(1);
 1800b14:	003fff06 	br	1800b14 <__ram_exceptions_end+0xff7f06d0>

01800b18 <main_thread>:
    return 0;
}


int main_thread(){
 1800b18:	defffc04 	addi	sp,sp,-16
 1800b1c:	dfc00315 	stw	ra,12(sp)
 1800b20:	df000215 	stw	fp,8(sp)
 1800b24:	df000204 	addi	fp,sp,8
	alt_printf("------------------------------------------------------\r\n");
 1800b28:	01006134 	movhi	r4,388
 1800b2c:	21047e04 	addi	r4,r4,4600
 1800b30:	1812f140 	call	1812f14 <alt_printf>
	alt_printf("--------- Starting OPC UA Server application ---------\r\n");
 1800b34:	01006134 	movhi	r4,388
 1800b38:	21048d04 	addi	r4,r4,4660
 1800b3c:	1812f140 	call	1812f14 <alt_printf>
	alt_printf("------------------------------------------------------\r\n");
 1800b40:	01006134 	movhi	r4,388
 1800b44:	21047e04 	addi	r4,r4,4600
 1800b48:	1812f140 	call	1812f14 <alt_printf>
	alt_printf("--------- open62541 example created for a    ---------\r\n");
 1800b4c:	01006134 	movhi	r4,388
 1800b50:	21049c04 	addi	r4,r4,4720
 1800b54:	1812f140 	call	1812f14 <alt_printf>
    alt_printf("--------- MicroBlaze design on a Artix7 FPGA ---------\r\n");
 1800b58:	01006134 	movhi	r4,388
 1800b5c:	2104ab04 	addi	r4,r4,4780
 1800b60:	1812f140 	call	1812f14 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 1800b64:	01006134 	movhi	r4,388
 1800b68:	21047e04 	addi	r4,r4,4600
 1800b6c:	1812f140 	call	1812f14 <alt_printf>
    alt_printf("--------- NetTImeLogic GmbH, Switzerland     ---------\r\n");
 1800b70:	01006134 	movhi	r4,388
 1800b74:	2104ba04 	addi	r4,r4,4840
 1800b78:	1812f140 	call	1812f14 <alt_printf>
    alt_printf("--------- contact@nettimelogic.com           ---------\r\n");
 1800b7c:	01006134 	movhi	r4,388
 1800b80:	2104c904 	addi	r4,r4,4900
 1800b84:	1812f140 	call	1812f14 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 1800b88:	01006134 	movhi	r4,388
 1800b8c:	21047e04 	addi	r4,r4,4600
 1800b90:	1812f140 	call	1812f14 <alt_printf>

	xTaskCreate(xEthernetRun, "eth0", KB(4), NULL, tskIDLE_PRIORITY + 2, NULL);
 1800b94:	d8000115 	stw	zero,4(sp)
 1800b98:	00800084 	movi	r2,2
 1800b9c:	d8800015 	stw	r2,0(sp)
 1800ba0:	000f883a 	mov	r7,zero
 1800ba4:	01840004 	movi	r6,4096
 1800ba8:	01406134 	movhi	r5,388
 1800bac:	2944d804 	addi	r5,r5,4960
 1800bb0:	01006034 	movhi	r4,384
 1800bb4:	2101f104 	addi	r4,r4,1988
 1800bb8:	180ed080 	call	180ed08 <xTaskCreate>

	sys_thread_new("NetworkInit", xEthernetRun, NULL,
 1800bbc:	008000c4 	movi	r2,3
 1800bc0:	d8800015 	stw	r2,0(sp)
 1800bc4:	01c40004 	movi	r7,4096
 1800bc8:	000d883a 	mov	r6,zero
 1800bcc:	01406034 	movhi	r5,384
 1800bd0:	2941f104 	addi	r5,r5,1988
 1800bd4:	01006134 	movhi	r4,388
 1800bd8:	2104da04 	addi	r4,r4,4968
 1800bdc:	181569c0 	call	181569c <sys_thread_new>
    		THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);



    vTaskStartScheduler();
 1800be0:	180f9f40 	call	180f9f4 <vTaskStartScheduler>
    while(1);
 1800be4:	003fff06 	br	1800be4 <__ram_exceptions_end+0xff7f07a0>

01800be8 <_printf_r>:
 1800be8:	defffd04 	addi	sp,sp,-12
 1800bec:	2805883a 	mov	r2,r5
 1800bf0:	dfc00015 	stw	ra,0(sp)
 1800bf4:	d9800115 	stw	r6,4(sp)
 1800bf8:	d9c00215 	stw	r7,8(sp)
 1800bfc:	21400217 	ldw	r5,8(r4)
 1800c00:	d9c00104 	addi	r7,sp,4
 1800c04:	100d883a 	mov	r6,r2
 1800c08:	1800c540 	call	1800c54 <___vfprintf_internal_r>
 1800c0c:	dfc00017 	ldw	ra,0(sp)
 1800c10:	dec00304 	addi	sp,sp,12
 1800c14:	f800283a 	ret

01800c18 <printf>:
 1800c18:	defffc04 	addi	sp,sp,-16
 1800c1c:	dfc00015 	stw	ra,0(sp)
 1800c20:	d9400115 	stw	r5,4(sp)
 1800c24:	d9800215 	stw	r6,8(sp)
 1800c28:	d9c00315 	stw	r7,12(sp)
 1800c2c:	00806134 	movhi	r2,388
 1800c30:	10975504 	addi	r2,r2,23892
 1800c34:	10800017 	ldw	r2,0(r2)
 1800c38:	200b883a 	mov	r5,r4
 1800c3c:	d9800104 	addi	r6,sp,4
 1800c40:	11000217 	ldw	r4,8(r2)
 1800c44:	1802e4c0 	call	1802e4c <__vfprintf_internal>
 1800c48:	dfc00017 	ldw	ra,0(sp)
 1800c4c:	dec00404 	addi	sp,sp,16
 1800c50:	f800283a 	ret

01800c54 <___vfprintf_internal_r>:
 1800c54:	deffb804 	addi	sp,sp,-288
 1800c58:	dfc04715 	stw	ra,284(sp)
 1800c5c:	ddc04515 	stw	r23,276(sp)
 1800c60:	dd404315 	stw	r21,268(sp)
 1800c64:	d9002c15 	stw	r4,176(sp)
 1800c68:	282f883a 	mov	r23,r5
 1800c6c:	302b883a 	mov	r21,r6
 1800c70:	d9c02d15 	stw	r7,180(sp)
 1800c74:	df004615 	stw	fp,280(sp)
 1800c78:	dd804415 	stw	r22,272(sp)
 1800c7c:	dd004215 	stw	r20,264(sp)
 1800c80:	dcc04115 	stw	r19,260(sp)
 1800c84:	dc804015 	stw	r18,256(sp)
 1800c88:	dc403f15 	stw	r17,252(sp)
 1800c8c:	dc003e15 	stw	r16,248(sp)
 1800c90:	18055b00 	call	18055b0 <_localeconv_r>
 1800c94:	10800017 	ldw	r2,0(r2)
 1800c98:	1009883a 	mov	r4,r2
 1800c9c:	d8803415 	stw	r2,208(sp)
 1800ca0:	18075d80 	call	18075d8 <strlen>
 1800ca4:	d8803715 	stw	r2,220(sp)
 1800ca8:	d8802c17 	ldw	r2,176(sp)
 1800cac:	10000226 	beq	r2,zero,1800cb8 <___vfprintf_internal_r+0x64>
 1800cb0:	10800e17 	ldw	r2,56(r2)
 1800cb4:	1000f926 	beq	r2,zero,180109c <___vfprintf_internal_r+0x448>
 1800cb8:	b880030b 	ldhu	r2,12(r23)
 1800cbc:	10c8000c 	andi	r3,r2,8192
 1800cc0:	1800061e 	bne	r3,zero,1800cdc <___vfprintf_internal_r+0x88>
 1800cc4:	b9001917 	ldw	r4,100(r23)
 1800cc8:	00f7ffc4 	movi	r3,-8193
 1800ccc:	10880014 	ori	r2,r2,8192
 1800cd0:	20c6703a 	and	r3,r4,r3
 1800cd4:	b880030d 	sth	r2,12(r23)
 1800cd8:	b8c01915 	stw	r3,100(r23)
 1800cdc:	10c0020c 	andi	r3,r2,8
 1800ce0:	1800c126 	beq	r3,zero,1800fe8 <___vfprintf_internal_r+0x394>
 1800ce4:	b8c00417 	ldw	r3,16(r23)
 1800ce8:	1800bf26 	beq	r3,zero,1800fe8 <___vfprintf_internal_r+0x394>
 1800cec:	1080068c 	andi	r2,r2,26
 1800cf0:	00c00284 	movi	r3,10
 1800cf4:	10c0c426 	beq	r2,r3,1801008 <___vfprintf_internal_r+0x3b4>
 1800cf8:	d8c00404 	addi	r3,sp,16
 1800cfc:	05006134 	movhi	r20,388
 1800d00:	d9001e04 	addi	r4,sp,120
 1800d04:	a504ed84 	addi	r20,r20,5046
 1800d08:	d8c01e15 	stw	r3,120(sp)
 1800d0c:	d8002015 	stw	zero,128(sp)
 1800d10:	d8001f15 	stw	zero,124(sp)
 1800d14:	d8003315 	stw	zero,204(sp)
 1800d18:	d8003615 	stw	zero,216(sp)
 1800d1c:	d8003815 	stw	zero,224(sp)
 1800d20:	1811883a 	mov	r8,r3
 1800d24:	d8003915 	stw	zero,228(sp)
 1800d28:	d8003a15 	stw	zero,232(sp)
 1800d2c:	d8002f15 	stw	zero,188(sp)
 1800d30:	d9002815 	stw	r4,160(sp)
 1800d34:	a8800007 	ldb	r2,0(r21)
 1800d38:	10027b26 	beq	r2,zero,1801728 <___vfprintf_internal_r+0xad4>
 1800d3c:	00c00944 	movi	r3,37
 1800d40:	a821883a 	mov	r16,r21
 1800d44:	10c0021e 	bne	r2,r3,1800d50 <___vfprintf_internal_r+0xfc>
 1800d48:	00001406 	br	1800d9c <___vfprintf_internal_r+0x148>
 1800d4c:	10c00326 	beq	r2,r3,1800d5c <___vfprintf_internal_r+0x108>
 1800d50:	84000044 	addi	r16,r16,1
 1800d54:	80800007 	ldb	r2,0(r16)
 1800d58:	103ffc1e 	bne	r2,zero,1800d4c <__ram_exceptions_end+0xff7f0908>
 1800d5c:	8563c83a 	sub	r17,r16,r21
 1800d60:	88000e26 	beq	r17,zero,1800d9c <___vfprintf_internal_r+0x148>
 1800d64:	d8c02017 	ldw	r3,128(sp)
 1800d68:	d8801f17 	ldw	r2,124(sp)
 1800d6c:	45400015 	stw	r21,0(r8)
 1800d70:	1c47883a 	add	r3,r3,r17
 1800d74:	10800044 	addi	r2,r2,1
 1800d78:	d8c02015 	stw	r3,128(sp)
 1800d7c:	44400115 	stw	r17,4(r8)
 1800d80:	d8801f15 	stw	r2,124(sp)
 1800d84:	00c001c4 	movi	r3,7
 1800d88:	1880a716 	blt	r3,r2,1801028 <___vfprintf_internal_r+0x3d4>
 1800d8c:	42000204 	addi	r8,r8,8
 1800d90:	d9402f17 	ldw	r5,188(sp)
 1800d94:	2c4b883a 	add	r5,r5,r17
 1800d98:	d9402f15 	stw	r5,188(sp)
 1800d9c:	80800007 	ldb	r2,0(r16)
 1800da0:	1000a826 	beq	r2,zero,1801044 <___vfprintf_internal_r+0x3f0>
 1800da4:	84400047 	ldb	r17,1(r16)
 1800da8:	00bfffc4 	movi	r2,-1
 1800dac:	85400044 	addi	r21,r16,1
 1800db0:	d8002785 	stb	zero,158(sp)
 1800db4:	0007883a 	mov	r3,zero
 1800db8:	000f883a 	mov	r7,zero
 1800dbc:	d8802915 	stw	r2,164(sp)
 1800dc0:	d8003115 	stw	zero,196(sp)
 1800dc4:	0025883a 	mov	r18,zero
 1800dc8:	01401604 	movi	r5,88
 1800dcc:	01800244 	movi	r6,9
 1800dd0:	02800a84 	movi	r10,42
 1800dd4:	02401b04 	movi	r9,108
 1800dd8:	ad400044 	addi	r21,r21,1
 1800ddc:	88bff804 	addi	r2,r17,-32
 1800de0:	28830436 	bltu	r5,r2,18019f4 <___vfprintf_internal_r+0xda0>
 1800de4:	100490ba 	slli	r2,r2,2
 1800de8:	01006034 	movhi	r4,384
 1800dec:	21037f04 	addi	r4,r4,3580
 1800df0:	1105883a 	add	r2,r2,r4
 1800df4:	10800017 	ldw	r2,0(r2)
 1800df8:	1000683a 	jmp	r2
 1800dfc:	01801914 	movui	r6,100
 1800e00:	018019f4 	movhi	r6,103
 1800e04:	018019f4 	movhi	r6,103
 1800e08:	01801934 	movhi	r6,100
 1800e0c:	018019f4 	movhi	r6,103
 1800e10:	018019f4 	movhi	r6,103
 1800e14:	018019f4 	movhi	r6,103
 1800e18:	018019f4 	movhi	r6,103
 1800e1c:	018019f4 	movhi	r6,103
 1800e20:	018019f4 	movhi	r6,103
 1800e24:	018010a8 	cmpgeui	r6,zero,66
 1800e28:	01801850 	cmplti	r6,zero,97
 1800e2c:	018019f4 	movhi	r6,103
 1800e30:	01800f70 	cmpltui	r6,zero,61
 1800e34:	018010d0 	cmplti	r6,zero,67
 1800e38:	018019f4 	movhi	r6,103
 1800e3c:	01801110 	cmplti	r6,zero,68
 1800e40:	0180111c 	xori	r6,zero,68
 1800e44:	0180111c 	xori	r6,zero,68
 1800e48:	0180111c 	xori	r6,zero,68
 1800e4c:	0180111c 	xori	r6,zero,68
 1800e50:	0180111c 	xori	r6,zero,68
 1800e54:	0180111c 	xori	r6,zero,68
 1800e58:	0180111c 	xori	r6,zero,68
 1800e5c:	0180111c 	xori	r6,zero,68
 1800e60:	0180111c 	xori	r6,zero,68
 1800e64:	018019f4 	movhi	r6,103
 1800e68:	018019f4 	movhi	r6,103
 1800e6c:	018019f4 	movhi	r6,103
 1800e70:	018019f4 	movhi	r6,103
 1800e74:	018019f4 	movhi	r6,103
 1800e78:	018019f4 	movhi	r6,103
 1800e7c:	018019f4 	movhi	r6,103
 1800e80:	018019f4 	movhi	r6,103
 1800e84:	018019f4 	movhi	r6,103
 1800e88:	018019f4 	movhi	r6,103
 1800e8c:	01801150 	cmplti	r6,zero,69
 1800e90:	0180120c 	andi	r6,zero,72
 1800e94:	018019f4 	movhi	r6,103
 1800e98:	0180120c 	andi	r6,zero,72
 1800e9c:	018019f4 	movhi	r6,103
 1800ea0:	018019f4 	movhi	r6,103
 1800ea4:	018019f4 	movhi	r6,103
 1800ea8:	018019f4 	movhi	r6,103
 1800eac:	018012ac 	andhi	r6,zero,74
 1800eb0:	018019f4 	movhi	r6,103
 1800eb4:	018019f4 	movhi	r6,103
 1800eb8:	018012b8 	rdprs	r6,zero,74
 1800ebc:	018019f4 	movhi	r6,103
 1800ec0:	018019f4 	movhi	r6,103
 1800ec4:	018019f4 	movhi	r6,103
 1800ec8:	018019f4 	movhi	r6,103
 1800ecc:	018019f4 	movhi	r6,103
 1800ed0:	01801730 	cmpltui	r6,zero,92
 1800ed4:	018019f4 	movhi	r6,103
 1800ed8:	018019f4 	movhi	r6,103
 1800edc:	01801790 	cmplti	r6,zero,94
 1800ee0:	018019f4 	movhi	r6,103
 1800ee4:	018019f4 	movhi	r6,103
 1800ee8:	018019f4 	movhi	r6,103
 1800eec:	018019f4 	movhi	r6,103
 1800ef0:	018019f4 	movhi	r6,103
 1800ef4:	018019f4 	movhi	r6,103
 1800ef8:	018019f4 	movhi	r6,103
 1800efc:	018019f4 	movhi	r6,103
 1800f00:	018019f4 	movhi	r6,103
 1800f04:	018019f4 	movhi	r6,103
 1800f08:	018019a0 	cmpeqi	r6,zero,102
 1800f0c:	01801940 	call	180194 <__alt_mem_tse_descriptor_memory_0+0x180194>
 1800f10:	0180120c 	andi	r6,zero,72
 1800f14:	0180120c 	andi	r6,zero,72
 1800f18:	0180120c 	andi	r6,zero,72
 1800f1c:	01801950 	cmplti	r6,zero,101
 1800f20:	01801940 	call	180194 <__alt_mem_tse_descriptor_memory_0+0x180194>
 1800f24:	018019f4 	movhi	r6,103
 1800f28:	018019f4 	movhi	r6,103
 1800f2c:	0180195c 	xori	r6,zero,101
 1800f30:	018019f4 	movhi	r6,103
 1800f34:	0180196c 	andhi	r6,zero,101
 1800f38:	01801840 	call	180184 <__alt_mem_tse_descriptor_memory_0+0x180184>
 1800f3c:	01800f7c 	xorhi	r6,zero,61
 1800f40:	01801860 	cmpeqi	r6,zero,97
 1800f44:	018019f4 	movhi	r6,103
 1800f48:	0180186c 	andhi	r6,zero,97
 1800f4c:	018019f4 	movhi	r6,103
 1800f50:	018018c8 	cmpgei	r6,zero,99
 1800f54:	018019f4 	movhi	r6,103
 1800f58:	018019f4 	movhi	r6,103
 1800f5c:	018018d8 	cmpnei	r6,zero,99
 1800f60:	d9003117 	ldw	r4,196(sp)
 1800f64:	d8802d15 	stw	r2,180(sp)
 1800f68:	0109c83a 	sub	r4,zero,r4
 1800f6c:	d9003115 	stw	r4,196(sp)
 1800f70:	94800114 	ori	r18,r18,4
 1800f74:	ac400007 	ldb	r17,0(r21)
 1800f78:	003f9706 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1800f7c:	00800c04 	movi	r2,48
 1800f80:	d9002d17 	ldw	r4,180(sp)
 1800f84:	d9402917 	ldw	r5,164(sp)
 1800f88:	d8802705 	stb	r2,156(sp)
 1800f8c:	00801e04 	movi	r2,120
 1800f90:	d8802745 	stb	r2,157(sp)
 1800f94:	d8002785 	stb	zero,158(sp)
 1800f98:	20c00104 	addi	r3,r4,4
 1800f9c:	24c00017 	ldw	r19,0(r4)
 1800fa0:	002d883a 	mov	r22,zero
 1800fa4:	90800094 	ori	r2,r18,2
 1800fa8:	28029a16 	blt	r5,zero,1801a14 <___vfprintf_internal_r+0xdc0>
 1800fac:	00bfdfc4 	movi	r2,-129
 1800fb0:	90a4703a 	and	r18,r18,r2
 1800fb4:	d8c02d15 	stw	r3,180(sp)
 1800fb8:	94800094 	ori	r18,r18,2
 1800fbc:	9802871e 	bne	r19,zero,18019dc <___vfprintf_internal_r+0xd88>
 1800fc0:	00806134 	movhi	r2,388
 1800fc4:	1084e604 	addi	r2,r2,5016
 1800fc8:	d8803915 	stw	r2,228(sp)
 1800fcc:	04401e04 	movi	r17,120
 1800fd0:	d8802917 	ldw	r2,164(sp)
 1800fd4:	0039883a 	mov	fp,zero
 1800fd8:	1001e926 	beq	r2,zero,1801780 <___vfprintf_internal_r+0xb2c>
 1800fdc:	0027883a 	mov	r19,zero
 1800fe0:	002d883a 	mov	r22,zero
 1800fe4:	00020506 	br	18017fc <___vfprintf_internal_r+0xba8>
 1800fe8:	d9002c17 	ldw	r4,176(sp)
 1800fec:	b80b883a 	mov	r5,r23
 1800ff0:	1802f240 	call	1802f24 <__swsetup_r>
 1800ff4:	1005ac1e 	bne	r2,zero,18026a8 <___vfprintf_internal_r+0x1a54>
 1800ff8:	b880030b 	ldhu	r2,12(r23)
 1800ffc:	00c00284 	movi	r3,10
 1801000:	1080068c 	andi	r2,r2,26
 1801004:	10ff3c1e 	bne	r2,r3,1800cf8 <__ram_exceptions_end+0xff7f08b4>
 1801008:	b880038f 	ldh	r2,14(r23)
 180100c:	103f3a16 	blt	r2,zero,1800cf8 <__ram_exceptions_end+0xff7f08b4>
 1801010:	d9c02d17 	ldw	r7,180(sp)
 1801014:	d9002c17 	ldw	r4,176(sp)
 1801018:	a80d883a 	mov	r6,r21
 180101c:	b80b883a 	mov	r5,r23
 1801020:	1802e680 	call	1802e68 <__sbprintf>
 1801024:	00001106 	br	180106c <___vfprintf_internal_r+0x418>
 1801028:	d9002c17 	ldw	r4,176(sp)
 180102c:	d9801e04 	addi	r6,sp,120
 1801030:	b80b883a 	mov	r5,r23
 1801034:	180776c0 	call	180776c <__sprint_r>
 1801038:	1000081e 	bne	r2,zero,180105c <___vfprintf_internal_r+0x408>
 180103c:	da000404 	addi	r8,sp,16
 1801040:	003f5306 	br	1800d90 <__ram_exceptions_end+0xff7f094c>
 1801044:	d8802017 	ldw	r2,128(sp)
 1801048:	10000426 	beq	r2,zero,180105c <___vfprintf_internal_r+0x408>
 180104c:	d9002c17 	ldw	r4,176(sp)
 1801050:	d9801e04 	addi	r6,sp,120
 1801054:	b80b883a 	mov	r5,r23
 1801058:	180776c0 	call	180776c <__sprint_r>
 180105c:	b880030b 	ldhu	r2,12(r23)
 1801060:	1080100c 	andi	r2,r2,64
 1801064:	1005901e 	bne	r2,zero,18026a8 <___vfprintf_internal_r+0x1a54>
 1801068:	d8802f17 	ldw	r2,188(sp)
 180106c:	dfc04717 	ldw	ra,284(sp)
 1801070:	df004617 	ldw	fp,280(sp)
 1801074:	ddc04517 	ldw	r23,276(sp)
 1801078:	dd804417 	ldw	r22,272(sp)
 180107c:	dd404317 	ldw	r21,268(sp)
 1801080:	dd004217 	ldw	r20,264(sp)
 1801084:	dcc04117 	ldw	r19,260(sp)
 1801088:	dc804017 	ldw	r18,256(sp)
 180108c:	dc403f17 	ldw	r17,252(sp)
 1801090:	dc003e17 	ldw	r16,248(sp)
 1801094:	dec04804 	addi	sp,sp,288
 1801098:	f800283a 	ret
 180109c:	d9002c17 	ldw	r4,176(sp)
 18010a0:	1804ef80 	call	1804ef8 <__sinit>
 18010a4:	003f0406 	br	1800cb8 <__ram_exceptions_end+0xff7f0874>
 18010a8:	d8802d17 	ldw	r2,180(sp)
 18010ac:	d9002d17 	ldw	r4,180(sp)
 18010b0:	10800017 	ldw	r2,0(r2)
 18010b4:	d8803115 	stw	r2,196(sp)
 18010b8:	20800104 	addi	r2,r4,4
 18010bc:	d9003117 	ldw	r4,196(sp)
 18010c0:	203fa716 	blt	r4,zero,1800f60 <__ram_exceptions_end+0xff7f0b1c>
 18010c4:	d8802d15 	stw	r2,180(sp)
 18010c8:	ac400007 	ldb	r17,0(r21)
 18010cc:	003f4206 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 18010d0:	ac400007 	ldb	r17,0(r21)
 18010d4:	aac00044 	addi	r11,r21,1
 18010d8:	8a872826 	beq	r17,r10,1802d7c <___vfprintf_internal_r+0x2128>
 18010dc:	88bff404 	addi	r2,r17,-48
 18010e0:	0009883a 	mov	r4,zero
 18010e4:	30867d36 	bltu	r6,r2,1802adc <___vfprintf_internal_r+0x1e88>
 18010e8:	5c400007 	ldb	r17,0(r11)
 18010ec:	210002a4 	muli	r4,r4,10
 18010f0:	5d400044 	addi	r21,r11,1
 18010f4:	a817883a 	mov	r11,r21
 18010f8:	2089883a 	add	r4,r4,r2
 18010fc:	88bff404 	addi	r2,r17,-48
 1801100:	30bff92e 	bgeu	r6,r2,18010e8 <__ram_exceptions_end+0xff7f0ca4>
 1801104:	2005c916 	blt	r4,zero,180282c <___vfprintf_internal_r+0x1bd8>
 1801108:	d9002915 	stw	r4,164(sp)
 180110c:	003f3306 	br	1800ddc <__ram_exceptions_end+0xff7f0998>
 1801110:	94802014 	ori	r18,r18,128
 1801114:	ac400007 	ldb	r17,0(r21)
 1801118:	003f2f06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 180111c:	a809883a 	mov	r4,r21
 1801120:	d8003115 	stw	zero,196(sp)
 1801124:	88bff404 	addi	r2,r17,-48
 1801128:	0017883a 	mov	r11,zero
 180112c:	24400007 	ldb	r17,0(r4)
 1801130:	5ac002a4 	muli	r11,r11,10
 1801134:	ad400044 	addi	r21,r21,1
 1801138:	a809883a 	mov	r4,r21
 180113c:	12d7883a 	add	r11,r2,r11
 1801140:	88bff404 	addi	r2,r17,-48
 1801144:	30bff92e 	bgeu	r6,r2,180112c <__ram_exceptions_end+0xff7f0ce8>
 1801148:	dac03115 	stw	r11,196(sp)
 180114c:	003f2306 	br	1800ddc <__ram_exceptions_end+0xff7f0998>
 1801150:	18c03fcc 	andi	r3,r3,255
 1801154:	18072b1e 	bne	r3,zero,1802e04 <___vfprintf_internal_r+0x21b0>
 1801158:	94800414 	ori	r18,r18,16
 180115c:	9080080c 	andi	r2,r18,32
 1801160:	10037b26 	beq	r2,zero,1801f50 <___vfprintf_internal_r+0x12fc>
 1801164:	d9402d17 	ldw	r5,180(sp)
 1801168:	28800117 	ldw	r2,4(r5)
 180116c:	2cc00017 	ldw	r19,0(r5)
 1801170:	29400204 	addi	r5,r5,8
 1801174:	d9402d15 	stw	r5,180(sp)
 1801178:	102d883a 	mov	r22,r2
 180117c:	10044b16 	blt	r2,zero,18022ac <___vfprintf_internal_r+0x1658>
 1801180:	d9402917 	ldw	r5,164(sp)
 1801184:	df002783 	ldbu	fp,158(sp)
 1801188:	2803bc16 	blt	r5,zero,180207c <___vfprintf_internal_r+0x1428>
 180118c:	00ffdfc4 	movi	r3,-129
 1801190:	9d84b03a 	or	r2,r19,r22
 1801194:	90e4703a 	and	r18,r18,r3
 1801198:	10017726 	beq	r2,zero,1801778 <___vfprintf_internal_r+0xb24>
 180119c:	b0038326 	beq	r22,zero,1801fac <___vfprintf_internal_r+0x1358>
 18011a0:	dc402a15 	stw	r17,168(sp)
 18011a4:	dc001e04 	addi	r16,sp,120
 18011a8:	b023883a 	mov	r17,r22
 18011ac:	402d883a 	mov	r22,r8
 18011b0:	9809883a 	mov	r4,r19
 18011b4:	880b883a 	mov	r5,r17
 18011b8:	01800284 	movi	r6,10
 18011bc:	000f883a 	mov	r7,zero
 18011c0:	180a6e00 	call	180a6e0 <__umoddi3>
 18011c4:	10800c04 	addi	r2,r2,48
 18011c8:	843fffc4 	addi	r16,r16,-1
 18011cc:	9809883a 	mov	r4,r19
 18011d0:	880b883a 	mov	r5,r17
 18011d4:	80800005 	stb	r2,0(r16)
 18011d8:	01800284 	movi	r6,10
 18011dc:	000f883a 	mov	r7,zero
 18011e0:	180a1680 	call	180a168 <__udivdi3>
 18011e4:	1027883a 	mov	r19,r2
 18011e8:	10c4b03a 	or	r2,r2,r3
 18011ec:	1823883a 	mov	r17,r3
 18011f0:	103fef1e 	bne	r2,zero,18011b0 <__ram_exceptions_end+0xff7f0d6c>
 18011f4:	d8c02817 	ldw	r3,160(sp)
 18011f8:	dc402a17 	ldw	r17,168(sp)
 18011fc:	b011883a 	mov	r8,r22
 1801200:	1c07c83a 	sub	r3,r3,r16
 1801204:	d8c02e15 	stw	r3,184(sp)
 1801208:	00005906 	br	1801370 <___vfprintf_internal_r+0x71c>
 180120c:	18c03fcc 	andi	r3,r3,255
 1801210:	1806fa1e 	bne	r3,zero,1802dfc <___vfprintf_internal_r+0x21a8>
 1801214:	9080020c 	andi	r2,r18,8
 1801218:	10048a26 	beq	r2,zero,1802444 <___vfprintf_internal_r+0x17f0>
 180121c:	d8c02d17 	ldw	r3,180(sp)
 1801220:	d9002d17 	ldw	r4,180(sp)
 1801224:	d9402d17 	ldw	r5,180(sp)
 1801228:	18c00017 	ldw	r3,0(r3)
 180122c:	21000117 	ldw	r4,4(r4)
 1801230:	29400204 	addi	r5,r5,8
 1801234:	d8c03615 	stw	r3,216(sp)
 1801238:	d9003815 	stw	r4,224(sp)
 180123c:	d9402d15 	stw	r5,180(sp)
 1801240:	d9003617 	ldw	r4,216(sp)
 1801244:	d9403817 	ldw	r5,224(sp)
 1801248:	da003d15 	stw	r8,244(sp)
 180124c:	04000044 	movi	r16,1
 1801250:	18072f80 	call	18072f8 <__fpclassifyd>
 1801254:	da003d17 	ldw	r8,244(sp)
 1801258:	14041f1e 	bne	r2,r16,18022d8 <___vfprintf_internal_r+0x1684>
 180125c:	d9003617 	ldw	r4,216(sp)
 1801260:	d9403817 	ldw	r5,224(sp)
 1801264:	000d883a 	mov	r6,zero
 1801268:	000f883a 	mov	r7,zero
 180126c:	180c0c40 	call	180c0c4 <__ledf2>
 1801270:	da003d17 	ldw	r8,244(sp)
 1801274:	1005be16 	blt	r2,zero,1802970 <___vfprintf_internal_r+0x1d1c>
 1801278:	df002783 	ldbu	fp,158(sp)
 180127c:	008011c4 	movi	r2,71
 1801280:	1445330e 	bge	r2,r17,1802750 <___vfprintf_internal_r+0x1afc>
 1801284:	04006134 	movhi	r16,388
 1801288:	8404de04 	addi	r16,r16,4984
 180128c:	00c000c4 	movi	r3,3
 1801290:	00bfdfc4 	movi	r2,-129
 1801294:	d8c02a15 	stw	r3,168(sp)
 1801298:	90a4703a 	and	r18,r18,r2
 180129c:	d8c02e15 	stw	r3,184(sp)
 18012a0:	d8002915 	stw	zero,164(sp)
 18012a4:	d8003215 	stw	zero,200(sp)
 18012a8:	00003706 	br	1801388 <___vfprintf_internal_r+0x734>
 18012ac:	94800214 	ori	r18,r18,8
 18012b0:	ac400007 	ldb	r17,0(r21)
 18012b4:	003ec806 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 18012b8:	18c03fcc 	andi	r3,r3,255
 18012bc:	1806db1e 	bne	r3,zero,1802e2c <___vfprintf_internal_r+0x21d8>
 18012c0:	94800414 	ori	r18,r18,16
 18012c4:	9080080c 	andi	r2,r18,32
 18012c8:	1002d826 	beq	r2,zero,1801e2c <___vfprintf_internal_r+0x11d8>
 18012cc:	d9402d17 	ldw	r5,180(sp)
 18012d0:	d8c02917 	ldw	r3,164(sp)
 18012d4:	d8002785 	stb	zero,158(sp)
 18012d8:	28800204 	addi	r2,r5,8
 18012dc:	2cc00017 	ldw	r19,0(r5)
 18012e0:	2d800117 	ldw	r22,4(r5)
 18012e4:	18048f16 	blt	r3,zero,1802524 <___vfprintf_internal_r+0x18d0>
 18012e8:	013fdfc4 	movi	r4,-129
 18012ec:	9d86b03a 	or	r3,r19,r22
 18012f0:	d8802d15 	stw	r2,180(sp)
 18012f4:	9124703a 	and	r18,r18,r4
 18012f8:	1802d91e 	bne	r3,zero,1801e60 <___vfprintf_internal_r+0x120c>
 18012fc:	d8c02917 	ldw	r3,164(sp)
 1801300:	0039883a 	mov	fp,zero
 1801304:	1805c326 	beq	r3,zero,1802a14 <___vfprintf_internal_r+0x1dc0>
 1801308:	0027883a 	mov	r19,zero
 180130c:	002d883a 	mov	r22,zero
 1801310:	dc001e04 	addi	r16,sp,120
 1801314:	9806d0fa 	srli	r3,r19,3
 1801318:	b008977a 	slli	r4,r22,29
 180131c:	b02cd0fa 	srli	r22,r22,3
 1801320:	9cc001cc 	andi	r19,r19,7
 1801324:	98800c04 	addi	r2,r19,48
 1801328:	843fffc4 	addi	r16,r16,-1
 180132c:	20e6b03a 	or	r19,r4,r3
 1801330:	80800005 	stb	r2,0(r16)
 1801334:	9d86b03a 	or	r3,r19,r22
 1801338:	183ff61e 	bne	r3,zero,1801314 <__ram_exceptions_end+0xff7f0ed0>
 180133c:	90c0004c 	andi	r3,r18,1
 1801340:	18013b26 	beq	r3,zero,1801830 <___vfprintf_internal_r+0xbdc>
 1801344:	10803fcc 	andi	r2,r2,255
 1801348:	1080201c 	xori	r2,r2,128
 180134c:	10bfe004 	addi	r2,r2,-128
 1801350:	00c00c04 	movi	r3,48
 1801354:	10c13626 	beq	r2,r3,1801830 <___vfprintf_internal_r+0xbdc>
 1801358:	80ffffc5 	stb	r3,-1(r16)
 180135c:	d8c02817 	ldw	r3,160(sp)
 1801360:	80bfffc4 	addi	r2,r16,-1
 1801364:	1021883a 	mov	r16,r2
 1801368:	1887c83a 	sub	r3,r3,r2
 180136c:	d8c02e15 	stw	r3,184(sp)
 1801370:	d8802e17 	ldw	r2,184(sp)
 1801374:	d9002917 	ldw	r4,164(sp)
 1801378:	1100010e 	bge	r2,r4,1801380 <___vfprintf_internal_r+0x72c>
 180137c:	2005883a 	mov	r2,r4
 1801380:	d8802a15 	stw	r2,168(sp)
 1801384:	d8003215 	stw	zero,200(sp)
 1801388:	e7003fcc 	andi	fp,fp,255
 180138c:	e700201c 	xori	fp,fp,128
 1801390:	e73fe004 	addi	fp,fp,-128
 1801394:	e0000326 	beq	fp,zero,18013a4 <___vfprintf_internal_r+0x750>
 1801398:	d8c02a17 	ldw	r3,168(sp)
 180139c:	18c00044 	addi	r3,r3,1
 18013a0:	d8c02a15 	stw	r3,168(sp)
 18013a4:	90c0008c 	andi	r3,r18,2
 18013a8:	d8c02b15 	stw	r3,172(sp)
 18013ac:	18000326 	beq	r3,zero,18013bc <___vfprintf_internal_r+0x768>
 18013b0:	d8c02a17 	ldw	r3,168(sp)
 18013b4:	18c00084 	addi	r3,r3,2
 18013b8:	d8c02a15 	stw	r3,168(sp)
 18013bc:	90c0210c 	andi	r3,r18,132
 18013c0:	d8c03015 	stw	r3,192(sp)
 18013c4:	1801a31e 	bne	r3,zero,1801a54 <___vfprintf_internal_r+0xe00>
 18013c8:	d9003117 	ldw	r4,196(sp)
 18013cc:	d8c02a17 	ldw	r3,168(sp)
 18013d0:	20e7c83a 	sub	r19,r4,r3
 18013d4:	04c19f0e 	bge	zero,r19,1801a54 <___vfprintf_internal_r+0xe00>
 18013d8:	02400404 	movi	r9,16
 18013dc:	d8c02017 	ldw	r3,128(sp)
 18013e0:	d8801f17 	ldw	r2,124(sp)
 18013e4:	4cc50d0e 	bge	r9,r19,180281c <___vfprintf_internal_r+0x1bc8>
 18013e8:	01406134 	movhi	r5,388
 18013ec:	2944f184 	addi	r5,r5,5062
 18013f0:	dc403b15 	stw	r17,236(sp)
 18013f4:	d9403515 	stw	r5,212(sp)
 18013f8:	9823883a 	mov	r17,r19
 18013fc:	482d883a 	mov	r22,r9
 1801400:	9027883a 	mov	r19,r18
 1801404:	070001c4 	movi	fp,7
 1801408:	8025883a 	mov	r18,r16
 180140c:	dc002c17 	ldw	r16,176(sp)
 1801410:	00000306 	br	1801420 <___vfprintf_internal_r+0x7cc>
 1801414:	8c7ffc04 	addi	r17,r17,-16
 1801418:	42000204 	addi	r8,r8,8
 180141c:	b440130e 	bge	r22,r17,180146c <___vfprintf_internal_r+0x818>
 1801420:	01006134 	movhi	r4,388
 1801424:	18c00404 	addi	r3,r3,16
 1801428:	10800044 	addi	r2,r2,1
 180142c:	2104f184 	addi	r4,r4,5062
 1801430:	41000015 	stw	r4,0(r8)
 1801434:	45800115 	stw	r22,4(r8)
 1801438:	d8c02015 	stw	r3,128(sp)
 180143c:	d8801f15 	stw	r2,124(sp)
 1801440:	e0bff40e 	bge	fp,r2,1801414 <__ram_exceptions_end+0xff7f0fd0>
 1801444:	d9801e04 	addi	r6,sp,120
 1801448:	b80b883a 	mov	r5,r23
 180144c:	8009883a 	mov	r4,r16
 1801450:	180776c0 	call	180776c <__sprint_r>
 1801454:	103f011e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801458:	8c7ffc04 	addi	r17,r17,-16
 180145c:	d8c02017 	ldw	r3,128(sp)
 1801460:	d8801f17 	ldw	r2,124(sp)
 1801464:	da000404 	addi	r8,sp,16
 1801468:	b47fed16 	blt	r22,r17,1801420 <__ram_exceptions_end+0xff7f0fdc>
 180146c:	9021883a 	mov	r16,r18
 1801470:	9825883a 	mov	r18,r19
 1801474:	8827883a 	mov	r19,r17
 1801478:	dc403b17 	ldw	r17,236(sp)
 180147c:	d9403517 	ldw	r5,212(sp)
 1801480:	98c7883a 	add	r3,r19,r3
 1801484:	10800044 	addi	r2,r2,1
 1801488:	41400015 	stw	r5,0(r8)
 180148c:	44c00115 	stw	r19,4(r8)
 1801490:	d8c02015 	stw	r3,128(sp)
 1801494:	d8801f15 	stw	r2,124(sp)
 1801498:	010001c4 	movi	r4,7
 180149c:	2082a316 	blt	r4,r2,1801f2c <___vfprintf_internal_r+0x12d8>
 18014a0:	df002787 	ldb	fp,158(sp)
 18014a4:	42000204 	addi	r8,r8,8
 18014a8:	e0000c26 	beq	fp,zero,18014dc <___vfprintf_internal_r+0x888>
 18014ac:	d8801f17 	ldw	r2,124(sp)
 18014b0:	d9002784 	addi	r4,sp,158
 18014b4:	18c00044 	addi	r3,r3,1
 18014b8:	10800044 	addi	r2,r2,1
 18014bc:	41000015 	stw	r4,0(r8)
 18014c0:	01000044 	movi	r4,1
 18014c4:	41000115 	stw	r4,4(r8)
 18014c8:	d8c02015 	stw	r3,128(sp)
 18014cc:	d8801f15 	stw	r2,124(sp)
 18014d0:	010001c4 	movi	r4,7
 18014d4:	20823c16 	blt	r4,r2,1801dc8 <___vfprintf_internal_r+0x1174>
 18014d8:	42000204 	addi	r8,r8,8
 18014dc:	d8802b17 	ldw	r2,172(sp)
 18014e0:	10000c26 	beq	r2,zero,1801514 <___vfprintf_internal_r+0x8c0>
 18014e4:	d8801f17 	ldw	r2,124(sp)
 18014e8:	d9002704 	addi	r4,sp,156
 18014ec:	18c00084 	addi	r3,r3,2
 18014f0:	10800044 	addi	r2,r2,1
 18014f4:	41000015 	stw	r4,0(r8)
 18014f8:	01000084 	movi	r4,2
 18014fc:	41000115 	stw	r4,4(r8)
 1801500:	d8c02015 	stw	r3,128(sp)
 1801504:	d8801f15 	stw	r2,124(sp)
 1801508:	010001c4 	movi	r4,7
 180150c:	20823616 	blt	r4,r2,1801de8 <___vfprintf_internal_r+0x1194>
 1801510:	42000204 	addi	r8,r8,8
 1801514:	d9003017 	ldw	r4,192(sp)
 1801518:	00802004 	movi	r2,128
 180151c:	20819926 	beq	r4,r2,1801b84 <___vfprintf_internal_r+0xf30>
 1801520:	d9402917 	ldw	r5,164(sp)
 1801524:	d8802e17 	ldw	r2,184(sp)
 1801528:	28adc83a 	sub	r22,r5,r2
 180152c:	0580310e 	bge	zero,r22,18015f4 <___vfprintf_internal_r+0x9a0>
 1801530:	07000404 	movi	fp,16
 1801534:	d8801f17 	ldw	r2,124(sp)
 1801538:	e584140e 	bge	fp,r22,180258c <___vfprintf_internal_r+0x1938>
 180153c:	01406134 	movhi	r5,388
 1801540:	2944ed84 	addi	r5,r5,5046
 1801544:	dc402915 	stw	r17,164(sp)
 1801548:	d9402b15 	stw	r5,172(sp)
 180154c:	b023883a 	mov	r17,r22
 1801550:	04c001c4 	movi	r19,7
 1801554:	a82d883a 	mov	r22,r21
 1801558:	902b883a 	mov	r21,r18
 180155c:	8025883a 	mov	r18,r16
 1801560:	dc002c17 	ldw	r16,176(sp)
 1801564:	00000306 	br	1801574 <___vfprintf_internal_r+0x920>
 1801568:	8c7ffc04 	addi	r17,r17,-16
 180156c:	42000204 	addi	r8,r8,8
 1801570:	e440110e 	bge	fp,r17,18015b8 <___vfprintf_internal_r+0x964>
 1801574:	18c00404 	addi	r3,r3,16
 1801578:	10800044 	addi	r2,r2,1
 180157c:	45000015 	stw	r20,0(r8)
 1801580:	47000115 	stw	fp,4(r8)
 1801584:	d8c02015 	stw	r3,128(sp)
 1801588:	d8801f15 	stw	r2,124(sp)
 180158c:	98bff60e 	bge	r19,r2,1801568 <__ram_exceptions_end+0xff7f1124>
 1801590:	d9801e04 	addi	r6,sp,120
 1801594:	b80b883a 	mov	r5,r23
 1801598:	8009883a 	mov	r4,r16
 180159c:	180776c0 	call	180776c <__sprint_r>
 18015a0:	103eae1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18015a4:	8c7ffc04 	addi	r17,r17,-16
 18015a8:	d8c02017 	ldw	r3,128(sp)
 18015ac:	d8801f17 	ldw	r2,124(sp)
 18015b0:	da000404 	addi	r8,sp,16
 18015b4:	e47fef16 	blt	fp,r17,1801574 <__ram_exceptions_end+0xff7f1130>
 18015b8:	9021883a 	mov	r16,r18
 18015bc:	a825883a 	mov	r18,r21
 18015c0:	b02b883a 	mov	r21,r22
 18015c4:	882d883a 	mov	r22,r17
 18015c8:	dc402917 	ldw	r17,164(sp)
 18015cc:	d9002b17 	ldw	r4,172(sp)
 18015d0:	1d87883a 	add	r3,r3,r22
 18015d4:	10800044 	addi	r2,r2,1
 18015d8:	41000015 	stw	r4,0(r8)
 18015dc:	45800115 	stw	r22,4(r8)
 18015e0:	d8c02015 	stw	r3,128(sp)
 18015e4:	d8801f15 	stw	r2,124(sp)
 18015e8:	010001c4 	movi	r4,7
 18015ec:	2081ee16 	blt	r4,r2,1801da8 <___vfprintf_internal_r+0x1154>
 18015f0:	42000204 	addi	r8,r8,8
 18015f4:	9080400c 	andi	r2,r18,256
 18015f8:	1001181e 	bne	r2,zero,1801a5c <___vfprintf_internal_r+0xe08>
 18015fc:	d9402e17 	ldw	r5,184(sp)
 1801600:	d8801f17 	ldw	r2,124(sp)
 1801604:	44000015 	stw	r16,0(r8)
 1801608:	1947883a 	add	r3,r3,r5
 180160c:	10800044 	addi	r2,r2,1
 1801610:	41400115 	stw	r5,4(r8)
 1801614:	d8c02015 	stw	r3,128(sp)
 1801618:	d8801f15 	stw	r2,124(sp)
 180161c:	010001c4 	movi	r4,7
 1801620:	2081d316 	blt	r4,r2,1801d70 <___vfprintf_internal_r+0x111c>
 1801624:	42000204 	addi	r8,r8,8
 1801628:	9480010c 	andi	r18,r18,4
 180162c:	90003226 	beq	r18,zero,18016f8 <___vfprintf_internal_r+0xaa4>
 1801630:	d9403117 	ldw	r5,196(sp)
 1801634:	d8802a17 	ldw	r2,168(sp)
 1801638:	28a1c83a 	sub	r16,r5,r2
 180163c:	04002e0e 	bge	zero,r16,18016f8 <___vfprintf_internal_r+0xaa4>
 1801640:	04400404 	movi	r17,16
 1801644:	d8801f17 	ldw	r2,124(sp)
 1801648:	8c04a20e 	bge	r17,r16,18028d4 <___vfprintf_internal_r+0x1c80>
 180164c:	01406134 	movhi	r5,388
 1801650:	2944f184 	addi	r5,r5,5062
 1801654:	d9403515 	stw	r5,212(sp)
 1801658:	048001c4 	movi	r18,7
 180165c:	dcc02c17 	ldw	r19,176(sp)
 1801660:	00000306 	br	1801670 <___vfprintf_internal_r+0xa1c>
 1801664:	843ffc04 	addi	r16,r16,-16
 1801668:	42000204 	addi	r8,r8,8
 180166c:	8c00130e 	bge	r17,r16,18016bc <___vfprintf_internal_r+0xa68>
 1801670:	01006134 	movhi	r4,388
 1801674:	18c00404 	addi	r3,r3,16
 1801678:	10800044 	addi	r2,r2,1
 180167c:	2104f184 	addi	r4,r4,5062
 1801680:	41000015 	stw	r4,0(r8)
 1801684:	44400115 	stw	r17,4(r8)
 1801688:	d8c02015 	stw	r3,128(sp)
 180168c:	d8801f15 	stw	r2,124(sp)
 1801690:	90bff40e 	bge	r18,r2,1801664 <__ram_exceptions_end+0xff7f1220>
 1801694:	d9801e04 	addi	r6,sp,120
 1801698:	b80b883a 	mov	r5,r23
 180169c:	9809883a 	mov	r4,r19
 18016a0:	180776c0 	call	180776c <__sprint_r>
 18016a4:	103e6d1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18016a8:	843ffc04 	addi	r16,r16,-16
 18016ac:	d8c02017 	ldw	r3,128(sp)
 18016b0:	d8801f17 	ldw	r2,124(sp)
 18016b4:	da000404 	addi	r8,sp,16
 18016b8:	8c3fed16 	blt	r17,r16,1801670 <__ram_exceptions_end+0xff7f122c>
 18016bc:	d9403517 	ldw	r5,212(sp)
 18016c0:	1c07883a 	add	r3,r3,r16
 18016c4:	10800044 	addi	r2,r2,1
 18016c8:	41400015 	stw	r5,0(r8)
 18016cc:	44000115 	stw	r16,4(r8)
 18016d0:	d8c02015 	stw	r3,128(sp)
 18016d4:	d8801f15 	stw	r2,124(sp)
 18016d8:	010001c4 	movi	r4,7
 18016dc:	2080060e 	bge	r4,r2,18016f8 <___vfprintf_internal_r+0xaa4>
 18016e0:	d9002c17 	ldw	r4,176(sp)
 18016e4:	d9801e04 	addi	r6,sp,120
 18016e8:	b80b883a 	mov	r5,r23
 18016ec:	180776c0 	call	180776c <__sprint_r>
 18016f0:	103e5a1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18016f4:	d8c02017 	ldw	r3,128(sp)
 18016f8:	d8803117 	ldw	r2,196(sp)
 18016fc:	d9002a17 	ldw	r4,168(sp)
 1801700:	1100010e 	bge	r2,r4,1801708 <___vfprintf_internal_r+0xab4>
 1801704:	2005883a 	mov	r2,r4
 1801708:	d9402f17 	ldw	r5,188(sp)
 180170c:	288b883a 	add	r5,r5,r2
 1801710:	d9402f15 	stw	r5,188(sp)
 1801714:	18019e1e 	bne	r3,zero,1801d90 <___vfprintf_internal_r+0x113c>
 1801718:	a8800007 	ldb	r2,0(r21)
 180171c:	d8001f15 	stw	zero,124(sp)
 1801720:	da000404 	addi	r8,sp,16
 1801724:	103d851e 	bne	r2,zero,1800d3c <__ram_exceptions_end+0xff7f08f8>
 1801728:	a821883a 	mov	r16,r21
 180172c:	003d9b06 	br	1800d9c <__ram_exceptions_end+0xff7f0958>
 1801730:	18c03fcc 	andi	r3,r3,255
 1801734:	1805c11e 	bne	r3,zero,1802e3c <___vfprintf_internal_r+0x21e8>
 1801738:	94800414 	ori	r18,r18,16
 180173c:	9080080c 	andi	r2,r18,32
 1801740:	10020c26 	beq	r2,zero,1801f74 <___vfprintf_internal_r+0x1320>
 1801744:	d8802d17 	ldw	r2,180(sp)
 1801748:	d9002917 	ldw	r4,164(sp)
 180174c:	d8002785 	stb	zero,158(sp)
 1801750:	10c00204 	addi	r3,r2,8
 1801754:	14c00017 	ldw	r19,0(r2)
 1801758:	15800117 	ldw	r22,4(r2)
 180175c:	20040f16 	blt	r4,zero,180279c <___vfprintf_internal_r+0x1b48>
 1801760:	013fdfc4 	movi	r4,-129
 1801764:	9d84b03a 	or	r2,r19,r22
 1801768:	d8c02d15 	stw	r3,180(sp)
 180176c:	9124703a 	and	r18,r18,r4
 1801770:	0039883a 	mov	fp,zero
 1801774:	103e891e 	bne	r2,zero,180119c <__ram_exceptions_end+0xff7f0d58>
 1801778:	d9002917 	ldw	r4,164(sp)
 180177c:	2002c11e 	bne	r4,zero,1802284 <___vfprintf_internal_r+0x1630>
 1801780:	d8002915 	stw	zero,164(sp)
 1801784:	d8002e15 	stw	zero,184(sp)
 1801788:	dc001e04 	addi	r16,sp,120
 180178c:	003ef806 	br	1801370 <__ram_exceptions_end+0xff7f0f2c>
 1801790:	18c03fcc 	andi	r3,r3,255
 1801794:	18059d1e 	bne	r3,zero,1802e0c <___vfprintf_internal_r+0x21b8>
 1801798:	01406134 	movhi	r5,388
 180179c:	2944e104 	addi	r5,r5,4996
 18017a0:	d9403915 	stw	r5,228(sp)
 18017a4:	9080080c 	andi	r2,r18,32
 18017a8:	10005226 	beq	r2,zero,18018f4 <___vfprintf_internal_r+0xca0>
 18017ac:	d8802d17 	ldw	r2,180(sp)
 18017b0:	14c00017 	ldw	r19,0(r2)
 18017b4:	15800117 	ldw	r22,4(r2)
 18017b8:	10800204 	addi	r2,r2,8
 18017bc:	d8802d15 	stw	r2,180(sp)
 18017c0:	9080004c 	andi	r2,r18,1
 18017c4:	10019026 	beq	r2,zero,1801e08 <___vfprintf_internal_r+0x11b4>
 18017c8:	9d84b03a 	or	r2,r19,r22
 18017cc:	10036926 	beq	r2,zero,1802574 <___vfprintf_internal_r+0x1920>
 18017d0:	d8c02917 	ldw	r3,164(sp)
 18017d4:	00800c04 	movi	r2,48
 18017d8:	d8802705 	stb	r2,156(sp)
 18017dc:	dc402745 	stb	r17,157(sp)
 18017e0:	d8002785 	stb	zero,158(sp)
 18017e4:	90800094 	ori	r2,r18,2
 18017e8:	18045d16 	blt	r3,zero,1802960 <___vfprintf_internal_r+0x1d0c>
 18017ec:	00bfdfc4 	movi	r2,-129
 18017f0:	90a4703a 	and	r18,r18,r2
 18017f4:	94800094 	ori	r18,r18,2
 18017f8:	0039883a 	mov	fp,zero
 18017fc:	d9003917 	ldw	r4,228(sp)
 1801800:	dc001e04 	addi	r16,sp,120
 1801804:	988003cc 	andi	r2,r19,15
 1801808:	b006973a 	slli	r3,r22,28
 180180c:	2085883a 	add	r2,r4,r2
 1801810:	9826d13a 	srli	r19,r19,4
 1801814:	10800003 	ldbu	r2,0(r2)
 1801818:	b02cd13a 	srli	r22,r22,4
 180181c:	843fffc4 	addi	r16,r16,-1
 1801820:	1ce6b03a 	or	r19,r3,r19
 1801824:	80800005 	stb	r2,0(r16)
 1801828:	9d84b03a 	or	r2,r19,r22
 180182c:	103ff51e 	bne	r2,zero,1801804 <__ram_exceptions_end+0xff7f13c0>
 1801830:	d8c02817 	ldw	r3,160(sp)
 1801834:	1c07c83a 	sub	r3,r3,r16
 1801838:	d8c02e15 	stw	r3,184(sp)
 180183c:	003ecc06 	br	1801370 <__ram_exceptions_end+0xff7f0f2c>
 1801840:	18c03fcc 	andi	r3,r3,255
 1801844:	183e9f26 	beq	r3,zero,18012c4 <__ram_exceptions_end+0xff7f0e80>
 1801848:	d9c02785 	stb	r7,158(sp)
 180184c:	003e9d06 	br	18012c4 <__ram_exceptions_end+0xff7f0e80>
 1801850:	00c00044 	movi	r3,1
 1801854:	01c00ac4 	movi	r7,43
 1801858:	ac400007 	ldb	r17,0(r21)
 180185c:	003d5e06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1801860:	94800814 	ori	r18,r18,32
 1801864:	ac400007 	ldb	r17,0(r21)
 1801868:	003d5b06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 180186c:	d8c02d17 	ldw	r3,180(sp)
 1801870:	d8002785 	stb	zero,158(sp)
 1801874:	1c000017 	ldw	r16,0(r3)
 1801878:	1cc00104 	addi	r19,r3,4
 180187c:	80041926 	beq	r16,zero,18028e4 <___vfprintf_internal_r+0x1c90>
 1801880:	d9002917 	ldw	r4,164(sp)
 1801884:	2003d016 	blt	r4,zero,18027c8 <___vfprintf_internal_r+0x1b74>
 1801888:	200d883a 	mov	r6,r4
 180188c:	000b883a 	mov	r5,zero
 1801890:	8009883a 	mov	r4,r16
 1801894:	da003d15 	stw	r8,244(sp)
 1801898:	1805fa80 	call	1805fa8 <memchr>
 180189c:	da003d17 	ldw	r8,244(sp)
 18018a0:	10045426 	beq	r2,zero,18029f4 <___vfprintf_internal_r+0x1da0>
 18018a4:	1405c83a 	sub	r2,r2,r16
 18018a8:	d8802e15 	stw	r2,184(sp)
 18018ac:	1003cc16 	blt	r2,zero,18027e0 <___vfprintf_internal_r+0x1b8c>
 18018b0:	df002783 	ldbu	fp,158(sp)
 18018b4:	d8802a15 	stw	r2,168(sp)
 18018b8:	dcc02d15 	stw	r19,180(sp)
 18018bc:	d8002915 	stw	zero,164(sp)
 18018c0:	d8003215 	stw	zero,200(sp)
 18018c4:	003eb006 	br	1801388 <__ram_exceptions_end+0xff7f0f44>
 18018c8:	18c03fcc 	andi	r3,r3,255
 18018cc:	183f9b26 	beq	r3,zero,180173c <__ram_exceptions_end+0xff7f12f8>
 18018d0:	d9c02785 	stb	r7,158(sp)
 18018d4:	003f9906 	br	180173c <__ram_exceptions_end+0xff7f12f8>
 18018d8:	18c03fcc 	andi	r3,r3,255
 18018dc:	1805551e 	bne	r3,zero,1802e34 <___vfprintf_internal_r+0x21e0>
 18018e0:	01406134 	movhi	r5,388
 18018e4:	2944e604 	addi	r5,r5,5016
 18018e8:	d9403915 	stw	r5,228(sp)
 18018ec:	9080080c 	andi	r2,r18,32
 18018f0:	103fae1e 	bne	r2,zero,18017ac <__ram_exceptions_end+0xff7f1368>
 18018f4:	9080040c 	andi	r2,r18,16
 18018f8:	1002de26 	beq	r2,zero,1802474 <___vfprintf_internal_r+0x1820>
 18018fc:	d8c02d17 	ldw	r3,180(sp)
 1801900:	002d883a 	mov	r22,zero
 1801904:	1cc00017 	ldw	r19,0(r3)
 1801908:	18c00104 	addi	r3,r3,4
 180190c:	d8c02d15 	stw	r3,180(sp)
 1801910:	003fab06 	br	18017c0 <__ram_exceptions_end+0xff7f137c>
 1801914:	38803fcc 	andi	r2,r7,255
 1801918:	1080201c 	xori	r2,r2,128
 180191c:	10bfe004 	addi	r2,r2,-128
 1801920:	1002d21e 	bne	r2,zero,180246c <___vfprintf_internal_r+0x1818>
 1801924:	00c00044 	movi	r3,1
 1801928:	01c00804 	movi	r7,32
 180192c:	ac400007 	ldb	r17,0(r21)
 1801930:	003d2906 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1801934:	94800054 	ori	r18,r18,1
 1801938:	ac400007 	ldb	r17,0(r21)
 180193c:	003d2606 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1801940:	18c03fcc 	andi	r3,r3,255
 1801944:	183e0526 	beq	r3,zero,180115c <__ram_exceptions_end+0xff7f0d18>
 1801948:	d9c02785 	stb	r7,158(sp)
 180194c:	003e0306 	br	180115c <__ram_exceptions_end+0xff7f0d18>
 1801950:	94801014 	ori	r18,r18,64
 1801954:	ac400007 	ldb	r17,0(r21)
 1801958:	003d1f06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 180195c:	ac400007 	ldb	r17,0(r21)
 1801960:	8a438726 	beq	r17,r9,1802780 <___vfprintf_internal_r+0x1b2c>
 1801964:	94800414 	ori	r18,r18,16
 1801968:	003d1b06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 180196c:	18c03fcc 	andi	r3,r3,255
 1801970:	1805341e 	bne	r3,zero,1802e44 <___vfprintf_internal_r+0x21f0>
 1801974:	9080080c 	andi	r2,r18,32
 1801978:	1002cd26 	beq	r2,zero,18024b0 <___vfprintf_internal_r+0x185c>
 180197c:	d9402d17 	ldw	r5,180(sp)
 1801980:	d9002f17 	ldw	r4,188(sp)
 1801984:	28800017 	ldw	r2,0(r5)
 1801988:	2007d7fa 	srai	r3,r4,31
 180198c:	29400104 	addi	r5,r5,4
 1801990:	d9402d15 	stw	r5,180(sp)
 1801994:	11000015 	stw	r4,0(r2)
 1801998:	10c00115 	stw	r3,4(r2)
 180199c:	003ce506 	br	1800d34 <__ram_exceptions_end+0xff7f08f0>
 18019a0:	d8c02d17 	ldw	r3,180(sp)
 18019a4:	d9002d17 	ldw	r4,180(sp)
 18019a8:	d8002785 	stb	zero,158(sp)
 18019ac:	18800017 	ldw	r2,0(r3)
 18019b0:	21000104 	addi	r4,r4,4
 18019b4:	00c00044 	movi	r3,1
 18019b8:	d8c02a15 	stw	r3,168(sp)
 18019bc:	d8801405 	stb	r2,80(sp)
 18019c0:	d9002d15 	stw	r4,180(sp)
 18019c4:	d8c02e15 	stw	r3,184(sp)
 18019c8:	d8002915 	stw	zero,164(sp)
 18019cc:	d8003215 	stw	zero,200(sp)
 18019d0:	dc001404 	addi	r16,sp,80
 18019d4:	0039883a 	mov	fp,zero
 18019d8:	003e7206 	br	18013a4 <__ram_exceptions_end+0xff7f0f60>
 18019dc:	01006134 	movhi	r4,388
 18019e0:	2104e604 	addi	r4,r4,5016
 18019e4:	0039883a 	mov	fp,zero
 18019e8:	d9003915 	stw	r4,228(sp)
 18019ec:	04401e04 	movi	r17,120
 18019f0:	003f8206 	br	18017fc <__ram_exceptions_end+0xff7f13b8>
 18019f4:	18c03fcc 	andi	r3,r3,255
 18019f8:	1805061e 	bne	r3,zero,1802e14 <___vfprintf_internal_r+0x21c0>
 18019fc:	883d9126 	beq	r17,zero,1801044 <__ram_exceptions_end+0xff7f0c00>
 1801a00:	00c00044 	movi	r3,1
 1801a04:	d8c02a15 	stw	r3,168(sp)
 1801a08:	dc401405 	stb	r17,80(sp)
 1801a0c:	d8002785 	stb	zero,158(sp)
 1801a10:	003fec06 	br	18019c4 <__ram_exceptions_end+0xff7f1580>
 1801a14:	01406134 	movhi	r5,388
 1801a18:	2944e604 	addi	r5,r5,5016
 1801a1c:	d9403915 	stw	r5,228(sp)
 1801a20:	d8c02d15 	stw	r3,180(sp)
 1801a24:	1025883a 	mov	r18,r2
 1801a28:	04401e04 	movi	r17,120
 1801a2c:	9d84b03a 	or	r2,r19,r22
 1801a30:	1000fc1e 	bne	r2,zero,1801e24 <___vfprintf_internal_r+0x11d0>
 1801a34:	0039883a 	mov	fp,zero
 1801a38:	00800084 	movi	r2,2
 1801a3c:	10803fcc 	andi	r2,r2,255
 1801a40:	00c00044 	movi	r3,1
 1801a44:	10c20f26 	beq	r2,r3,1802284 <___vfprintf_internal_r+0x1630>
 1801a48:	00c00084 	movi	r3,2
 1801a4c:	10fd6326 	beq	r2,r3,1800fdc <__ram_exceptions_end+0xff7f0b98>
 1801a50:	003e2d06 	br	1801308 <__ram_exceptions_end+0xff7f0ec4>
 1801a54:	d8c02017 	ldw	r3,128(sp)
 1801a58:	003e9306 	br	18014a8 <__ram_exceptions_end+0xff7f1064>
 1801a5c:	00801944 	movi	r2,101
 1801a60:	14407e0e 	bge	r2,r17,1801c5c <___vfprintf_internal_r+0x1008>
 1801a64:	d9003617 	ldw	r4,216(sp)
 1801a68:	d9403817 	ldw	r5,224(sp)
 1801a6c:	000d883a 	mov	r6,zero
 1801a70:	000f883a 	mov	r7,zero
 1801a74:	d8c03c15 	stw	r3,240(sp)
 1801a78:	da003d15 	stw	r8,244(sp)
 1801a7c:	180bf600 	call	180bf60 <__eqdf2>
 1801a80:	d8c03c17 	ldw	r3,240(sp)
 1801a84:	da003d17 	ldw	r8,244(sp)
 1801a88:	1000f71e 	bne	r2,zero,1801e68 <___vfprintf_internal_r+0x1214>
 1801a8c:	d8801f17 	ldw	r2,124(sp)
 1801a90:	01006134 	movhi	r4,388
 1801a94:	2104ed04 	addi	r4,r4,5044
 1801a98:	18c00044 	addi	r3,r3,1
 1801a9c:	10800044 	addi	r2,r2,1
 1801aa0:	41000015 	stw	r4,0(r8)
 1801aa4:	01000044 	movi	r4,1
 1801aa8:	41000115 	stw	r4,4(r8)
 1801aac:	d8c02015 	stw	r3,128(sp)
 1801ab0:	d8801f15 	stw	r2,124(sp)
 1801ab4:	010001c4 	movi	r4,7
 1801ab8:	2082b816 	blt	r4,r2,180259c <___vfprintf_internal_r+0x1948>
 1801abc:	42000204 	addi	r8,r8,8
 1801ac0:	d8802617 	ldw	r2,152(sp)
 1801ac4:	d9403317 	ldw	r5,204(sp)
 1801ac8:	11400216 	blt	r2,r5,1801ad4 <___vfprintf_internal_r+0xe80>
 1801acc:	9080004c 	andi	r2,r18,1
 1801ad0:	103ed526 	beq	r2,zero,1801628 <__ram_exceptions_end+0xff7f11e4>
 1801ad4:	d8803717 	ldw	r2,220(sp)
 1801ad8:	d9003417 	ldw	r4,208(sp)
 1801adc:	d9403717 	ldw	r5,220(sp)
 1801ae0:	1887883a 	add	r3,r3,r2
 1801ae4:	d8801f17 	ldw	r2,124(sp)
 1801ae8:	41000015 	stw	r4,0(r8)
 1801aec:	41400115 	stw	r5,4(r8)
 1801af0:	10800044 	addi	r2,r2,1
 1801af4:	d8c02015 	stw	r3,128(sp)
 1801af8:	d8801f15 	stw	r2,124(sp)
 1801afc:	010001c4 	movi	r4,7
 1801b00:	20832916 	blt	r4,r2,18027a8 <___vfprintf_internal_r+0x1b54>
 1801b04:	42000204 	addi	r8,r8,8
 1801b08:	d8803317 	ldw	r2,204(sp)
 1801b0c:	143fffc4 	addi	r16,r2,-1
 1801b10:	043ec50e 	bge	zero,r16,1801628 <__ram_exceptions_end+0xff7f11e4>
 1801b14:	04400404 	movi	r17,16
 1801b18:	d8801f17 	ldw	r2,124(sp)
 1801b1c:	8c00880e 	bge	r17,r16,1801d40 <___vfprintf_internal_r+0x10ec>
 1801b20:	01406134 	movhi	r5,388
 1801b24:	2944ed84 	addi	r5,r5,5046
 1801b28:	d9402b15 	stw	r5,172(sp)
 1801b2c:	058001c4 	movi	r22,7
 1801b30:	dcc02c17 	ldw	r19,176(sp)
 1801b34:	00000306 	br	1801b44 <___vfprintf_internal_r+0xef0>
 1801b38:	42000204 	addi	r8,r8,8
 1801b3c:	843ffc04 	addi	r16,r16,-16
 1801b40:	8c00820e 	bge	r17,r16,1801d4c <___vfprintf_internal_r+0x10f8>
 1801b44:	18c00404 	addi	r3,r3,16
 1801b48:	10800044 	addi	r2,r2,1
 1801b4c:	45000015 	stw	r20,0(r8)
 1801b50:	44400115 	stw	r17,4(r8)
 1801b54:	d8c02015 	stw	r3,128(sp)
 1801b58:	d8801f15 	stw	r2,124(sp)
 1801b5c:	b0bff60e 	bge	r22,r2,1801b38 <__ram_exceptions_end+0xff7f16f4>
 1801b60:	d9801e04 	addi	r6,sp,120
 1801b64:	b80b883a 	mov	r5,r23
 1801b68:	9809883a 	mov	r4,r19
 1801b6c:	180776c0 	call	180776c <__sprint_r>
 1801b70:	103d3a1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801b74:	d8c02017 	ldw	r3,128(sp)
 1801b78:	d8801f17 	ldw	r2,124(sp)
 1801b7c:	da000404 	addi	r8,sp,16
 1801b80:	003fee06 	br	1801b3c <__ram_exceptions_end+0xff7f16f8>
 1801b84:	d9403117 	ldw	r5,196(sp)
 1801b88:	d8802a17 	ldw	r2,168(sp)
 1801b8c:	28adc83a 	sub	r22,r5,r2
 1801b90:	05be630e 	bge	zero,r22,1801520 <__ram_exceptions_end+0xff7f10dc>
 1801b94:	07000404 	movi	fp,16
 1801b98:	d8801f17 	ldw	r2,124(sp)
 1801b9c:	e5838f0e 	bge	fp,r22,18029dc <___vfprintf_internal_r+0x1d88>
 1801ba0:	01406134 	movhi	r5,388
 1801ba4:	2944ed84 	addi	r5,r5,5046
 1801ba8:	dc403015 	stw	r17,192(sp)
 1801bac:	d9402b15 	stw	r5,172(sp)
 1801bb0:	b023883a 	mov	r17,r22
 1801bb4:	04c001c4 	movi	r19,7
 1801bb8:	a82d883a 	mov	r22,r21
 1801bbc:	902b883a 	mov	r21,r18
 1801bc0:	8025883a 	mov	r18,r16
 1801bc4:	dc002c17 	ldw	r16,176(sp)
 1801bc8:	00000306 	br	1801bd8 <___vfprintf_internal_r+0xf84>
 1801bcc:	8c7ffc04 	addi	r17,r17,-16
 1801bd0:	42000204 	addi	r8,r8,8
 1801bd4:	e440110e 	bge	fp,r17,1801c1c <___vfprintf_internal_r+0xfc8>
 1801bd8:	18c00404 	addi	r3,r3,16
 1801bdc:	10800044 	addi	r2,r2,1
 1801be0:	45000015 	stw	r20,0(r8)
 1801be4:	47000115 	stw	fp,4(r8)
 1801be8:	d8c02015 	stw	r3,128(sp)
 1801bec:	d8801f15 	stw	r2,124(sp)
 1801bf0:	98bff60e 	bge	r19,r2,1801bcc <__ram_exceptions_end+0xff7f1788>
 1801bf4:	d9801e04 	addi	r6,sp,120
 1801bf8:	b80b883a 	mov	r5,r23
 1801bfc:	8009883a 	mov	r4,r16
 1801c00:	180776c0 	call	180776c <__sprint_r>
 1801c04:	103d151e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801c08:	8c7ffc04 	addi	r17,r17,-16
 1801c0c:	d8c02017 	ldw	r3,128(sp)
 1801c10:	d8801f17 	ldw	r2,124(sp)
 1801c14:	da000404 	addi	r8,sp,16
 1801c18:	e47fef16 	blt	fp,r17,1801bd8 <__ram_exceptions_end+0xff7f1794>
 1801c1c:	9021883a 	mov	r16,r18
 1801c20:	a825883a 	mov	r18,r21
 1801c24:	b02b883a 	mov	r21,r22
 1801c28:	882d883a 	mov	r22,r17
 1801c2c:	dc403017 	ldw	r17,192(sp)
 1801c30:	d9002b17 	ldw	r4,172(sp)
 1801c34:	1d87883a 	add	r3,r3,r22
 1801c38:	10800044 	addi	r2,r2,1
 1801c3c:	41000015 	stw	r4,0(r8)
 1801c40:	45800115 	stw	r22,4(r8)
 1801c44:	d8c02015 	stw	r3,128(sp)
 1801c48:	d8801f15 	stw	r2,124(sp)
 1801c4c:	010001c4 	movi	r4,7
 1801c50:	20818e16 	blt	r4,r2,180228c <___vfprintf_internal_r+0x1638>
 1801c54:	42000204 	addi	r8,r8,8
 1801c58:	003e3106 	br	1801520 <__ram_exceptions_end+0xff7f10dc>
 1801c5c:	d9403317 	ldw	r5,204(sp)
 1801c60:	00800044 	movi	r2,1
 1801c64:	18c00044 	addi	r3,r3,1
 1801c68:	1141530e 	bge	r2,r5,18021b8 <___vfprintf_internal_r+0x1564>
 1801c6c:	dc401f17 	ldw	r17,124(sp)
 1801c70:	00800044 	movi	r2,1
 1801c74:	40800115 	stw	r2,4(r8)
 1801c78:	8c400044 	addi	r17,r17,1
 1801c7c:	44000015 	stw	r16,0(r8)
 1801c80:	d8c02015 	stw	r3,128(sp)
 1801c84:	dc401f15 	stw	r17,124(sp)
 1801c88:	008001c4 	movi	r2,7
 1801c8c:	14416b16 	blt	r2,r17,180223c <___vfprintf_internal_r+0x15e8>
 1801c90:	42000204 	addi	r8,r8,8
 1801c94:	d8803717 	ldw	r2,220(sp)
 1801c98:	d9003417 	ldw	r4,208(sp)
 1801c9c:	8c400044 	addi	r17,r17,1
 1801ca0:	10c7883a 	add	r3,r2,r3
 1801ca4:	40800115 	stw	r2,4(r8)
 1801ca8:	41000015 	stw	r4,0(r8)
 1801cac:	d8c02015 	stw	r3,128(sp)
 1801cb0:	dc401f15 	stw	r17,124(sp)
 1801cb4:	008001c4 	movi	r2,7
 1801cb8:	14416916 	blt	r2,r17,1802260 <___vfprintf_internal_r+0x160c>
 1801cbc:	45800204 	addi	r22,r8,8
 1801cc0:	d9003617 	ldw	r4,216(sp)
 1801cc4:	d9403817 	ldw	r5,224(sp)
 1801cc8:	000d883a 	mov	r6,zero
 1801ccc:	000f883a 	mov	r7,zero
 1801cd0:	d8c03c15 	stw	r3,240(sp)
 1801cd4:	180bf600 	call	180bf60 <__eqdf2>
 1801cd8:	d8c03c17 	ldw	r3,240(sp)
 1801cdc:	1000bc26 	beq	r2,zero,1801fd0 <___vfprintf_internal_r+0x137c>
 1801ce0:	d9403317 	ldw	r5,204(sp)
 1801ce4:	84000044 	addi	r16,r16,1
 1801ce8:	8c400044 	addi	r17,r17,1
 1801cec:	28bfffc4 	addi	r2,r5,-1
 1801cf0:	1887883a 	add	r3,r3,r2
 1801cf4:	b0800115 	stw	r2,4(r22)
 1801cf8:	b4000015 	stw	r16,0(r22)
 1801cfc:	d8c02015 	stw	r3,128(sp)
 1801d00:	dc401f15 	stw	r17,124(sp)
 1801d04:	008001c4 	movi	r2,7
 1801d08:	14414316 	blt	r2,r17,1802218 <___vfprintf_internal_r+0x15c4>
 1801d0c:	b5800204 	addi	r22,r22,8
 1801d10:	d9003a17 	ldw	r4,232(sp)
 1801d14:	df0022c4 	addi	fp,sp,139
 1801d18:	8c400044 	addi	r17,r17,1
 1801d1c:	20c7883a 	add	r3,r4,r3
 1801d20:	b7000015 	stw	fp,0(r22)
 1801d24:	b1000115 	stw	r4,4(r22)
 1801d28:	d8c02015 	stw	r3,128(sp)
 1801d2c:	dc401f15 	stw	r17,124(sp)
 1801d30:	008001c4 	movi	r2,7
 1801d34:	14400e16 	blt	r2,r17,1801d70 <___vfprintf_internal_r+0x111c>
 1801d38:	b2000204 	addi	r8,r22,8
 1801d3c:	003e3a06 	br	1801628 <__ram_exceptions_end+0xff7f11e4>
 1801d40:	01006134 	movhi	r4,388
 1801d44:	2104ed84 	addi	r4,r4,5046
 1801d48:	d9002b15 	stw	r4,172(sp)
 1801d4c:	d9002b17 	ldw	r4,172(sp)
 1801d50:	1c07883a 	add	r3,r3,r16
 1801d54:	44000115 	stw	r16,4(r8)
 1801d58:	41000015 	stw	r4,0(r8)
 1801d5c:	10800044 	addi	r2,r2,1
 1801d60:	d8c02015 	stw	r3,128(sp)
 1801d64:	d8801f15 	stw	r2,124(sp)
 1801d68:	010001c4 	movi	r4,7
 1801d6c:	20be2d0e 	bge	r4,r2,1801624 <__ram_exceptions_end+0xff7f11e0>
 1801d70:	d9002c17 	ldw	r4,176(sp)
 1801d74:	d9801e04 	addi	r6,sp,120
 1801d78:	b80b883a 	mov	r5,r23
 1801d7c:	180776c0 	call	180776c <__sprint_r>
 1801d80:	103cb61e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801d84:	d8c02017 	ldw	r3,128(sp)
 1801d88:	da000404 	addi	r8,sp,16
 1801d8c:	003e2606 	br	1801628 <__ram_exceptions_end+0xff7f11e4>
 1801d90:	d9002c17 	ldw	r4,176(sp)
 1801d94:	d9801e04 	addi	r6,sp,120
 1801d98:	b80b883a 	mov	r5,r23
 1801d9c:	180776c0 	call	180776c <__sprint_r>
 1801da0:	103e5d26 	beq	r2,zero,1801718 <__ram_exceptions_end+0xff7f12d4>
 1801da4:	003cad06 	br	180105c <__ram_exceptions_end+0xff7f0c18>
 1801da8:	d9002c17 	ldw	r4,176(sp)
 1801dac:	d9801e04 	addi	r6,sp,120
 1801db0:	b80b883a 	mov	r5,r23
 1801db4:	180776c0 	call	180776c <__sprint_r>
 1801db8:	103ca81e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801dbc:	d8c02017 	ldw	r3,128(sp)
 1801dc0:	da000404 	addi	r8,sp,16
 1801dc4:	003e0b06 	br	18015f4 <__ram_exceptions_end+0xff7f11b0>
 1801dc8:	d9002c17 	ldw	r4,176(sp)
 1801dcc:	d9801e04 	addi	r6,sp,120
 1801dd0:	b80b883a 	mov	r5,r23
 1801dd4:	180776c0 	call	180776c <__sprint_r>
 1801dd8:	103ca01e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801ddc:	d8c02017 	ldw	r3,128(sp)
 1801de0:	da000404 	addi	r8,sp,16
 1801de4:	003dbd06 	br	18014dc <__ram_exceptions_end+0xff7f1098>
 1801de8:	d9002c17 	ldw	r4,176(sp)
 1801dec:	d9801e04 	addi	r6,sp,120
 1801df0:	b80b883a 	mov	r5,r23
 1801df4:	180776c0 	call	180776c <__sprint_r>
 1801df8:	103c981e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801dfc:	d8c02017 	ldw	r3,128(sp)
 1801e00:	da000404 	addi	r8,sp,16
 1801e04:	003dc306 	br	1801514 <__ram_exceptions_end+0xff7f10d0>
 1801e08:	d8802917 	ldw	r2,164(sp)
 1801e0c:	d8002785 	stb	zero,158(sp)
 1801e10:	103f0616 	blt	r2,zero,1801a2c <__ram_exceptions_end+0xff7f15e8>
 1801e14:	00ffdfc4 	movi	r3,-129
 1801e18:	9d84b03a 	or	r2,r19,r22
 1801e1c:	90e4703a 	and	r18,r18,r3
 1801e20:	103c6b26 	beq	r2,zero,1800fd0 <__ram_exceptions_end+0xff7f0b8c>
 1801e24:	0039883a 	mov	fp,zero
 1801e28:	003e7406 	br	18017fc <__ram_exceptions_end+0xff7f13b8>
 1801e2c:	9080040c 	andi	r2,r18,16
 1801e30:	1001b326 	beq	r2,zero,1802500 <___vfprintf_internal_r+0x18ac>
 1801e34:	d9002d17 	ldw	r4,180(sp)
 1801e38:	d9402917 	ldw	r5,164(sp)
 1801e3c:	d8002785 	stb	zero,158(sp)
 1801e40:	20800104 	addi	r2,r4,4
 1801e44:	24c00017 	ldw	r19,0(r4)
 1801e48:	002d883a 	mov	r22,zero
 1801e4c:	2801b516 	blt	r5,zero,1802524 <___vfprintf_internal_r+0x18d0>
 1801e50:	00ffdfc4 	movi	r3,-129
 1801e54:	d8802d15 	stw	r2,180(sp)
 1801e58:	90e4703a 	and	r18,r18,r3
 1801e5c:	983d2726 	beq	r19,zero,18012fc <__ram_exceptions_end+0xff7f0eb8>
 1801e60:	0039883a 	mov	fp,zero
 1801e64:	003d2a06 	br	1801310 <__ram_exceptions_end+0xff7f0ecc>
 1801e68:	dc402617 	ldw	r17,152(sp)
 1801e6c:	0441d30e 	bge	zero,r17,18025bc <___vfprintf_internal_r+0x1968>
 1801e70:	dc403217 	ldw	r17,200(sp)
 1801e74:	d8803317 	ldw	r2,204(sp)
 1801e78:	1440010e 	bge	r2,r17,1801e80 <___vfprintf_internal_r+0x122c>
 1801e7c:	1023883a 	mov	r17,r2
 1801e80:	04400a0e 	bge	zero,r17,1801eac <___vfprintf_internal_r+0x1258>
 1801e84:	d8801f17 	ldw	r2,124(sp)
 1801e88:	1c47883a 	add	r3,r3,r17
 1801e8c:	44000015 	stw	r16,0(r8)
 1801e90:	10800044 	addi	r2,r2,1
 1801e94:	44400115 	stw	r17,4(r8)
 1801e98:	d8c02015 	stw	r3,128(sp)
 1801e9c:	d8801f15 	stw	r2,124(sp)
 1801ea0:	010001c4 	movi	r4,7
 1801ea4:	20826516 	blt	r4,r2,180283c <___vfprintf_internal_r+0x1be8>
 1801ea8:	42000204 	addi	r8,r8,8
 1801eac:	88026116 	blt	r17,zero,1802834 <___vfprintf_internal_r+0x1be0>
 1801eb0:	d9003217 	ldw	r4,200(sp)
 1801eb4:	2463c83a 	sub	r17,r4,r17
 1801eb8:	04407b0e 	bge	zero,r17,18020a8 <___vfprintf_internal_r+0x1454>
 1801ebc:	05800404 	movi	r22,16
 1801ec0:	d8801f17 	ldw	r2,124(sp)
 1801ec4:	b4419d0e 	bge	r22,r17,180253c <___vfprintf_internal_r+0x18e8>
 1801ec8:	01006134 	movhi	r4,388
 1801ecc:	2104ed84 	addi	r4,r4,5046
 1801ed0:	d9002b15 	stw	r4,172(sp)
 1801ed4:	070001c4 	movi	fp,7
 1801ed8:	dcc02c17 	ldw	r19,176(sp)
 1801edc:	00000306 	br	1801eec <___vfprintf_internal_r+0x1298>
 1801ee0:	42000204 	addi	r8,r8,8
 1801ee4:	8c7ffc04 	addi	r17,r17,-16
 1801ee8:	b441970e 	bge	r22,r17,1802548 <___vfprintf_internal_r+0x18f4>
 1801eec:	18c00404 	addi	r3,r3,16
 1801ef0:	10800044 	addi	r2,r2,1
 1801ef4:	45000015 	stw	r20,0(r8)
 1801ef8:	45800115 	stw	r22,4(r8)
 1801efc:	d8c02015 	stw	r3,128(sp)
 1801f00:	d8801f15 	stw	r2,124(sp)
 1801f04:	e0bff60e 	bge	fp,r2,1801ee0 <__ram_exceptions_end+0xff7f1a9c>
 1801f08:	d9801e04 	addi	r6,sp,120
 1801f0c:	b80b883a 	mov	r5,r23
 1801f10:	9809883a 	mov	r4,r19
 1801f14:	180776c0 	call	180776c <__sprint_r>
 1801f18:	103c501e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801f1c:	d8c02017 	ldw	r3,128(sp)
 1801f20:	d8801f17 	ldw	r2,124(sp)
 1801f24:	da000404 	addi	r8,sp,16
 1801f28:	003fee06 	br	1801ee4 <__ram_exceptions_end+0xff7f1aa0>
 1801f2c:	d9002c17 	ldw	r4,176(sp)
 1801f30:	d9801e04 	addi	r6,sp,120
 1801f34:	b80b883a 	mov	r5,r23
 1801f38:	180776c0 	call	180776c <__sprint_r>
 1801f3c:	103c471e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1801f40:	d8c02017 	ldw	r3,128(sp)
 1801f44:	df002787 	ldb	fp,158(sp)
 1801f48:	da000404 	addi	r8,sp,16
 1801f4c:	003d5606 	br	18014a8 <__ram_exceptions_end+0xff7f1064>
 1801f50:	9080040c 	andi	r2,r18,16
 1801f54:	10016126 	beq	r2,zero,18024dc <___vfprintf_internal_r+0x1888>
 1801f58:	d8802d17 	ldw	r2,180(sp)
 1801f5c:	14c00017 	ldw	r19,0(r2)
 1801f60:	10800104 	addi	r2,r2,4
 1801f64:	d8802d15 	stw	r2,180(sp)
 1801f68:	982dd7fa 	srai	r22,r19,31
 1801f6c:	b005883a 	mov	r2,r22
 1801f70:	003c8206 	br	180117c <__ram_exceptions_end+0xff7f0d38>
 1801f74:	9080040c 	andi	r2,r18,16
 1801f78:	10003526 	beq	r2,zero,1802050 <___vfprintf_internal_r+0x13fc>
 1801f7c:	d9402d17 	ldw	r5,180(sp)
 1801f80:	d8c02917 	ldw	r3,164(sp)
 1801f84:	d8002785 	stb	zero,158(sp)
 1801f88:	28800104 	addi	r2,r5,4
 1801f8c:	2cc00017 	ldw	r19,0(r5)
 1801f90:	002d883a 	mov	r22,zero
 1801f94:	18003716 	blt	r3,zero,1802074 <___vfprintf_internal_r+0x1420>
 1801f98:	00ffdfc4 	movi	r3,-129
 1801f9c:	d8802d15 	stw	r2,180(sp)
 1801fa0:	90e4703a 	and	r18,r18,r3
 1801fa4:	0039883a 	mov	fp,zero
 1801fa8:	983df326 	beq	r19,zero,1801778 <__ram_exceptions_end+0xff7f1334>
 1801fac:	00800244 	movi	r2,9
 1801fb0:	14fc7b36 	bltu	r2,r19,18011a0 <__ram_exceptions_end+0xff7f0d5c>
 1801fb4:	d8c02817 	ldw	r3,160(sp)
 1801fb8:	dc001dc4 	addi	r16,sp,119
 1801fbc:	9cc00c04 	addi	r19,r19,48
 1801fc0:	1c07c83a 	sub	r3,r3,r16
 1801fc4:	dcc01dc5 	stb	r19,119(sp)
 1801fc8:	d8c02e15 	stw	r3,184(sp)
 1801fcc:	003ce806 	br	1801370 <__ram_exceptions_end+0xff7f0f2c>
 1801fd0:	d8803317 	ldw	r2,204(sp)
 1801fd4:	143fffc4 	addi	r16,r2,-1
 1801fd8:	043f4d0e 	bge	zero,r16,1801d10 <__ram_exceptions_end+0xff7f18cc>
 1801fdc:	07000404 	movi	fp,16
 1801fe0:	e400810e 	bge	fp,r16,18021e8 <___vfprintf_internal_r+0x1594>
 1801fe4:	01406134 	movhi	r5,388
 1801fe8:	2944ed84 	addi	r5,r5,5046
 1801fec:	d9402b15 	stw	r5,172(sp)
 1801ff0:	01c001c4 	movi	r7,7
 1801ff4:	dcc02c17 	ldw	r19,176(sp)
 1801ff8:	00000306 	br	1802008 <___vfprintf_internal_r+0x13b4>
 1801ffc:	b5800204 	addi	r22,r22,8
 1802000:	843ffc04 	addi	r16,r16,-16
 1802004:	e4007b0e 	bge	fp,r16,18021f4 <___vfprintf_internal_r+0x15a0>
 1802008:	18c00404 	addi	r3,r3,16
 180200c:	8c400044 	addi	r17,r17,1
 1802010:	b5000015 	stw	r20,0(r22)
 1802014:	b7000115 	stw	fp,4(r22)
 1802018:	d8c02015 	stw	r3,128(sp)
 180201c:	dc401f15 	stw	r17,124(sp)
 1802020:	3c7ff60e 	bge	r7,r17,1801ffc <__ram_exceptions_end+0xff7f1bb8>
 1802024:	d9801e04 	addi	r6,sp,120
 1802028:	b80b883a 	mov	r5,r23
 180202c:	9809883a 	mov	r4,r19
 1802030:	d9c03c15 	stw	r7,240(sp)
 1802034:	180776c0 	call	180776c <__sprint_r>
 1802038:	d9c03c17 	ldw	r7,240(sp)
 180203c:	103c071e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802040:	d8c02017 	ldw	r3,128(sp)
 1802044:	dc401f17 	ldw	r17,124(sp)
 1802048:	dd800404 	addi	r22,sp,16
 180204c:	003fec06 	br	1802000 <__ram_exceptions_end+0xff7f1bbc>
 1802050:	9080100c 	andi	r2,r18,64
 1802054:	d8002785 	stb	zero,158(sp)
 1802058:	10010e26 	beq	r2,zero,1802494 <___vfprintf_internal_r+0x1840>
 180205c:	d9002d17 	ldw	r4,180(sp)
 1802060:	d9402917 	ldw	r5,164(sp)
 1802064:	002d883a 	mov	r22,zero
 1802068:	20800104 	addi	r2,r4,4
 180206c:	24c0000b 	ldhu	r19,0(r4)
 1802070:	283fc90e 	bge	r5,zero,1801f98 <__ram_exceptions_end+0xff7f1b54>
 1802074:	d8802d15 	stw	r2,180(sp)
 1802078:	0039883a 	mov	fp,zero
 180207c:	9d84b03a 	or	r2,r19,r22
 1802080:	103c461e 	bne	r2,zero,180119c <__ram_exceptions_end+0xff7f0d58>
 1802084:	00800044 	movi	r2,1
 1802088:	003e6c06 	br	1801a3c <__ram_exceptions_end+0xff7f15f8>
 180208c:	d9002c17 	ldw	r4,176(sp)
 1802090:	d9801e04 	addi	r6,sp,120
 1802094:	b80b883a 	mov	r5,r23
 1802098:	180776c0 	call	180776c <__sprint_r>
 180209c:	103bef1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18020a0:	d8c02017 	ldw	r3,128(sp)
 18020a4:	da000404 	addi	r8,sp,16
 18020a8:	d9003217 	ldw	r4,200(sp)
 18020ac:	d8802617 	ldw	r2,152(sp)
 18020b0:	d9403317 	ldw	r5,204(sp)
 18020b4:	8123883a 	add	r17,r16,r4
 18020b8:	11400216 	blt	r2,r5,18020c4 <___vfprintf_internal_r+0x1470>
 18020bc:	9100004c 	andi	r4,r18,1
 18020c0:	20000d26 	beq	r4,zero,18020f8 <___vfprintf_internal_r+0x14a4>
 18020c4:	d9003717 	ldw	r4,220(sp)
 18020c8:	d9403417 	ldw	r5,208(sp)
 18020cc:	1907883a 	add	r3,r3,r4
 18020d0:	d9001f17 	ldw	r4,124(sp)
 18020d4:	41400015 	stw	r5,0(r8)
 18020d8:	d9403717 	ldw	r5,220(sp)
 18020dc:	21000044 	addi	r4,r4,1
 18020e0:	d8c02015 	stw	r3,128(sp)
 18020e4:	41400115 	stw	r5,4(r8)
 18020e8:	d9001f15 	stw	r4,124(sp)
 18020ec:	014001c4 	movi	r5,7
 18020f0:	2901e816 	blt	r5,r4,1802894 <___vfprintf_internal_r+0x1c40>
 18020f4:	42000204 	addi	r8,r8,8
 18020f8:	d9003317 	ldw	r4,204(sp)
 18020fc:	8121883a 	add	r16,r16,r4
 1802100:	2085c83a 	sub	r2,r4,r2
 1802104:	8461c83a 	sub	r16,r16,r17
 1802108:	1400010e 	bge	r2,r16,1802110 <___vfprintf_internal_r+0x14bc>
 180210c:	1021883a 	mov	r16,r2
 1802110:	04000a0e 	bge	zero,r16,180213c <___vfprintf_internal_r+0x14e8>
 1802114:	d9001f17 	ldw	r4,124(sp)
 1802118:	1c07883a 	add	r3,r3,r16
 180211c:	44400015 	stw	r17,0(r8)
 1802120:	21000044 	addi	r4,r4,1
 1802124:	44000115 	stw	r16,4(r8)
 1802128:	d8c02015 	stw	r3,128(sp)
 180212c:	d9001f15 	stw	r4,124(sp)
 1802130:	014001c4 	movi	r5,7
 1802134:	2901fb16 	blt	r5,r4,1802924 <___vfprintf_internal_r+0x1cd0>
 1802138:	42000204 	addi	r8,r8,8
 180213c:	8001f716 	blt	r16,zero,180291c <___vfprintf_internal_r+0x1cc8>
 1802140:	1421c83a 	sub	r16,r2,r16
 1802144:	043d380e 	bge	zero,r16,1801628 <__ram_exceptions_end+0xff7f11e4>
 1802148:	04400404 	movi	r17,16
 180214c:	d8801f17 	ldw	r2,124(sp)
 1802150:	8c3efb0e 	bge	r17,r16,1801d40 <__ram_exceptions_end+0xff7f18fc>
 1802154:	01406134 	movhi	r5,388
 1802158:	2944ed84 	addi	r5,r5,5046
 180215c:	d9402b15 	stw	r5,172(sp)
 1802160:	058001c4 	movi	r22,7
 1802164:	dcc02c17 	ldw	r19,176(sp)
 1802168:	00000306 	br	1802178 <___vfprintf_internal_r+0x1524>
 180216c:	42000204 	addi	r8,r8,8
 1802170:	843ffc04 	addi	r16,r16,-16
 1802174:	8c3ef50e 	bge	r17,r16,1801d4c <__ram_exceptions_end+0xff7f1908>
 1802178:	18c00404 	addi	r3,r3,16
 180217c:	10800044 	addi	r2,r2,1
 1802180:	45000015 	stw	r20,0(r8)
 1802184:	44400115 	stw	r17,4(r8)
 1802188:	d8c02015 	stw	r3,128(sp)
 180218c:	d8801f15 	stw	r2,124(sp)
 1802190:	b0bff60e 	bge	r22,r2,180216c <__ram_exceptions_end+0xff7f1d28>
 1802194:	d9801e04 	addi	r6,sp,120
 1802198:	b80b883a 	mov	r5,r23
 180219c:	9809883a 	mov	r4,r19
 18021a0:	180776c0 	call	180776c <__sprint_r>
 18021a4:	103bad1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18021a8:	d8c02017 	ldw	r3,128(sp)
 18021ac:	d8801f17 	ldw	r2,124(sp)
 18021b0:	da000404 	addi	r8,sp,16
 18021b4:	003fee06 	br	1802170 <__ram_exceptions_end+0xff7f1d2c>
 18021b8:	9088703a 	and	r4,r18,r2
 18021bc:	203eab1e 	bne	r4,zero,1801c6c <__ram_exceptions_end+0xff7f1828>
 18021c0:	dc401f17 	ldw	r17,124(sp)
 18021c4:	40800115 	stw	r2,4(r8)
 18021c8:	44000015 	stw	r16,0(r8)
 18021cc:	8c400044 	addi	r17,r17,1
 18021d0:	d8c02015 	stw	r3,128(sp)
 18021d4:	dc401f15 	stw	r17,124(sp)
 18021d8:	008001c4 	movi	r2,7
 18021dc:	14400e16 	blt	r2,r17,1802218 <___vfprintf_internal_r+0x15c4>
 18021e0:	45800204 	addi	r22,r8,8
 18021e4:	003eca06 	br	1801d10 <__ram_exceptions_end+0xff7f18cc>
 18021e8:	01006134 	movhi	r4,388
 18021ec:	2104ed84 	addi	r4,r4,5046
 18021f0:	d9002b15 	stw	r4,172(sp)
 18021f4:	d8802b17 	ldw	r2,172(sp)
 18021f8:	1c07883a 	add	r3,r3,r16
 18021fc:	8c400044 	addi	r17,r17,1
 1802200:	b0800015 	stw	r2,0(r22)
 1802204:	b4000115 	stw	r16,4(r22)
 1802208:	d8c02015 	stw	r3,128(sp)
 180220c:	dc401f15 	stw	r17,124(sp)
 1802210:	008001c4 	movi	r2,7
 1802214:	147ebd0e 	bge	r2,r17,1801d0c <__ram_exceptions_end+0xff7f18c8>
 1802218:	d9002c17 	ldw	r4,176(sp)
 180221c:	d9801e04 	addi	r6,sp,120
 1802220:	b80b883a 	mov	r5,r23
 1802224:	180776c0 	call	180776c <__sprint_r>
 1802228:	103b8c1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 180222c:	d8c02017 	ldw	r3,128(sp)
 1802230:	dc401f17 	ldw	r17,124(sp)
 1802234:	dd800404 	addi	r22,sp,16
 1802238:	003eb506 	br	1801d10 <__ram_exceptions_end+0xff7f18cc>
 180223c:	d9002c17 	ldw	r4,176(sp)
 1802240:	d9801e04 	addi	r6,sp,120
 1802244:	b80b883a 	mov	r5,r23
 1802248:	180776c0 	call	180776c <__sprint_r>
 180224c:	103b831e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802250:	d8c02017 	ldw	r3,128(sp)
 1802254:	dc401f17 	ldw	r17,124(sp)
 1802258:	da000404 	addi	r8,sp,16
 180225c:	003e8d06 	br	1801c94 <__ram_exceptions_end+0xff7f1850>
 1802260:	d9002c17 	ldw	r4,176(sp)
 1802264:	d9801e04 	addi	r6,sp,120
 1802268:	b80b883a 	mov	r5,r23
 180226c:	180776c0 	call	180776c <__sprint_r>
 1802270:	103b7a1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802274:	d8c02017 	ldw	r3,128(sp)
 1802278:	dc401f17 	ldw	r17,124(sp)
 180227c:	dd800404 	addi	r22,sp,16
 1802280:	003e8f06 	br	1801cc0 <__ram_exceptions_end+0xff7f187c>
 1802284:	0027883a 	mov	r19,zero
 1802288:	003f4a06 	br	1801fb4 <__ram_exceptions_end+0xff7f1b70>
 180228c:	d9002c17 	ldw	r4,176(sp)
 1802290:	d9801e04 	addi	r6,sp,120
 1802294:	b80b883a 	mov	r5,r23
 1802298:	180776c0 	call	180776c <__sprint_r>
 180229c:	103b6f1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18022a0:	d8c02017 	ldw	r3,128(sp)
 18022a4:	da000404 	addi	r8,sp,16
 18022a8:	003c9d06 	br	1801520 <__ram_exceptions_end+0xff7f10dc>
 18022ac:	04e7c83a 	sub	r19,zero,r19
 18022b0:	9804c03a 	cmpne	r2,r19,zero
 18022b4:	05adc83a 	sub	r22,zero,r22
 18022b8:	b0adc83a 	sub	r22,r22,r2
 18022bc:	d8802917 	ldw	r2,164(sp)
 18022c0:	07000b44 	movi	fp,45
 18022c4:	df002785 	stb	fp,158(sp)
 18022c8:	10017b16 	blt	r2,zero,18028b8 <___vfprintf_internal_r+0x1c64>
 18022cc:	00bfdfc4 	movi	r2,-129
 18022d0:	90a4703a 	and	r18,r18,r2
 18022d4:	003bb106 	br	180119c <__ram_exceptions_end+0xff7f0d58>
 18022d8:	d9003617 	ldw	r4,216(sp)
 18022dc:	d9403817 	ldw	r5,224(sp)
 18022e0:	da003d15 	stw	r8,244(sp)
 18022e4:	18072f80 	call	18072f8 <__fpclassifyd>
 18022e8:	da003d17 	ldw	r8,244(sp)
 18022ec:	1000f026 	beq	r2,zero,18026b0 <___vfprintf_internal_r+0x1a5c>
 18022f0:	d9002917 	ldw	r4,164(sp)
 18022f4:	05bff7c4 	movi	r22,-33
 18022f8:	00bfffc4 	movi	r2,-1
 18022fc:	8dac703a 	and	r22,r17,r22
 1802300:	20820026 	beq	r4,r2,1802b04 <___vfprintf_internal_r+0x1eb0>
 1802304:	008011c4 	movi	r2,71
 1802308:	b081f726 	beq	r22,r2,1802ae8 <___vfprintf_internal_r+0x1e94>
 180230c:	d9003817 	ldw	r4,224(sp)
 1802310:	90c04014 	ori	r3,r18,256
 1802314:	d8c02b15 	stw	r3,172(sp)
 1802318:	20021516 	blt	r4,zero,1802b70 <___vfprintf_internal_r+0x1f1c>
 180231c:	dcc03817 	ldw	r19,224(sp)
 1802320:	d8002a05 	stb	zero,168(sp)
 1802324:	00801984 	movi	r2,102
 1802328:	8881f926 	beq	r17,r2,1802b10 <___vfprintf_internal_r+0x1ebc>
 180232c:	00801184 	movi	r2,70
 1802330:	88821c26 	beq	r17,r2,1802ba4 <___vfprintf_internal_r+0x1f50>
 1802334:	00801144 	movi	r2,69
 1802338:	b081ef26 	beq	r22,r2,1802af8 <___vfprintf_internal_r+0x1ea4>
 180233c:	d8c02917 	ldw	r3,164(sp)
 1802340:	d8802104 	addi	r2,sp,132
 1802344:	d8800315 	stw	r2,12(sp)
 1802348:	d9403617 	ldw	r5,216(sp)
 180234c:	d8802504 	addi	r2,sp,148
 1802350:	d9002c17 	ldw	r4,176(sp)
 1802354:	d8800215 	stw	r2,8(sp)
 1802358:	d8802604 	addi	r2,sp,152
 180235c:	d8c00015 	stw	r3,0(sp)
 1802360:	d8800115 	stw	r2,4(sp)
 1802364:	01c00084 	movi	r7,2
 1802368:	980d883a 	mov	r6,r19
 180236c:	d8c03c15 	stw	r3,240(sp)
 1802370:	da003d15 	stw	r8,244(sp)
 1802374:	18032780 	call	1803278 <_dtoa_r>
 1802378:	1021883a 	mov	r16,r2
 180237c:	008019c4 	movi	r2,103
 1802380:	d8c03c17 	ldw	r3,240(sp)
 1802384:	da003d17 	ldw	r8,244(sp)
 1802388:	88817126 	beq	r17,r2,1802950 <___vfprintf_internal_r+0x1cfc>
 180238c:	008011c4 	movi	r2,71
 1802390:	88829226 	beq	r17,r2,1802ddc <___vfprintf_internal_r+0x2188>
 1802394:	80f9883a 	add	fp,r16,r3
 1802398:	d9003617 	ldw	r4,216(sp)
 180239c:	000d883a 	mov	r6,zero
 18023a0:	000f883a 	mov	r7,zero
 18023a4:	980b883a 	mov	r5,r19
 18023a8:	da003d15 	stw	r8,244(sp)
 18023ac:	180bf600 	call	180bf60 <__eqdf2>
 18023b0:	da003d17 	ldw	r8,244(sp)
 18023b4:	10018d26 	beq	r2,zero,18029ec <___vfprintf_internal_r+0x1d98>
 18023b8:	d8802117 	ldw	r2,132(sp)
 18023bc:	1700062e 	bgeu	r2,fp,18023d8 <___vfprintf_internal_r+0x1784>
 18023c0:	01000c04 	movi	r4,48
 18023c4:	10c00044 	addi	r3,r2,1
 18023c8:	d8c02115 	stw	r3,132(sp)
 18023cc:	11000005 	stb	r4,0(r2)
 18023d0:	d8802117 	ldw	r2,132(sp)
 18023d4:	173ffb36 	bltu	r2,fp,18023c4 <__ram_exceptions_end+0xff7f1f80>
 18023d8:	1405c83a 	sub	r2,r2,r16
 18023dc:	d8803315 	stw	r2,204(sp)
 18023e0:	008011c4 	movi	r2,71
 18023e4:	b0817626 	beq	r22,r2,18029c0 <___vfprintf_internal_r+0x1d6c>
 18023e8:	00801944 	movi	r2,101
 18023ec:	1442810e 	bge	r2,r17,1802df4 <___vfprintf_internal_r+0x21a0>
 18023f0:	d8c02617 	ldw	r3,152(sp)
 18023f4:	00801984 	movi	r2,102
 18023f8:	d8c03215 	stw	r3,200(sp)
 18023fc:	8881fe26 	beq	r17,r2,1802bf8 <___vfprintf_internal_r+0x1fa4>
 1802400:	d8c03217 	ldw	r3,200(sp)
 1802404:	d9003317 	ldw	r4,204(sp)
 1802408:	1901dd16 	blt	r3,r4,1802b80 <___vfprintf_internal_r+0x1f2c>
 180240c:	9480004c 	andi	r18,r18,1
 1802410:	90022b1e 	bne	r18,zero,1802cc0 <___vfprintf_internal_r+0x206c>
 1802414:	1805883a 	mov	r2,r3
 1802418:	18028016 	blt	r3,zero,1802e1c <___vfprintf_internal_r+0x21c8>
 180241c:	d8c03217 	ldw	r3,200(sp)
 1802420:	044019c4 	movi	r17,103
 1802424:	d8c02e15 	stw	r3,184(sp)
 1802428:	df002a07 	ldb	fp,168(sp)
 180242c:	e001531e 	bne	fp,zero,180297c <___vfprintf_internal_r+0x1d28>
 1802430:	df002783 	ldbu	fp,158(sp)
 1802434:	d8802a15 	stw	r2,168(sp)
 1802438:	dc802b17 	ldw	r18,172(sp)
 180243c:	d8002915 	stw	zero,164(sp)
 1802440:	003bd106 	br	1801388 <__ram_exceptions_end+0xff7f0f44>
 1802444:	d8802d17 	ldw	r2,180(sp)
 1802448:	d8c02d17 	ldw	r3,180(sp)
 180244c:	d9002d17 	ldw	r4,180(sp)
 1802450:	10800017 	ldw	r2,0(r2)
 1802454:	18c00117 	ldw	r3,4(r3)
 1802458:	21000204 	addi	r4,r4,8
 180245c:	d8803615 	stw	r2,216(sp)
 1802460:	d8c03815 	stw	r3,224(sp)
 1802464:	d9002d15 	stw	r4,180(sp)
 1802468:	003b7506 	br	1801240 <__ram_exceptions_end+0xff7f0dfc>
 180246c:	ac400007 	ldb	r17,0(r21)
 1802470:	003a5906 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1802474:	9080100c 	andi	r2,r18,64
 1802478:	1000a826 	beq	r2,zero,180271c <___vfprintf_internal_r+0x1ac8>
 180247c:	d9002d17 	ldw	r4,180(sp)
 1802480:	002d883a 	mov	r22,zero
 1802484:	24c0000b 	ldhu	r19,0(r4)
 1802488:	21000104 	addi	r4,r4,4
 180248c:	d9002d15 	stw	r4,180(sp)
 1802490:	003ccb06 	br	18017c0 <__ram_exceptions_end+0xff7f137c>
 1802494:	d8c02d17 	ldw	r3,180(sp)
 1802498:	d9002917 	ldw	r4,164(sp)
 180249c:	002d883a 	mov	r22,zero
 18024a0:	18800104 	addi	r2,r3,4
 18024a4:	1cc00017 	ldw	r19,0(r3)
 18024a8:	203ebb0e 	bge	r4,zero,1801f98 <__ram_exceptions_end+0xff7f1b54>
 18024ac:	003ef106 	br	1802074 <__ram_exceptions_end+0xff7f1c30>
 18024b0:	9080040c 	andi	r2,r18,16
 18024b4:	1000921e 	bne	r2,zero,1802700 <___vfprintf_internal_r+0x1aac>
 18024b8:	9480100c 	andi	r18,r18,64
 18024bc:	90013926 	beq	r18,zero,18029a4 <___vfprintf_internal_r+0x1d50>
 18024c0:	d9002d17 	ldw	r4,180(sp)
 18024c4:	d9402f17 	ldw	r5,188(sp)
 18024c8:	20800017 	ldw	r2,0(r4)
 18024cc:	21000104 	addi	r4,r4,4
 18024d0:	d9002d15 	stw	r4,180(sp)
 18024d4:	1140000d 	sth	r5,0(r2)
 18024d8:	003a1606 	br	1800d34 <__ram_exceptions_end+0xff7f08f0>
 18024dc:	9080100c 	andi	r2,r18,64
 18024e0:	10008026 	beq	r2,zero,18026e4 <___vfprintf_internal_r+0x1a90>
 18024e4:	d8c02d17 	ldw	r3,180(sp)
 18024e8:	1cc0000f 	ldh	r19,0(r3)
 18024ec:	18c00104 	addi	r3,r3,4
 18024f0:	d8c02d15 	stw	r3,180(sp)
 18024f4:	982dd7fa 	srai	r22,r19,31
 18024f8:	b005883a 	mov	r2,r22
 18024fc:	003b1f06 	br	180117c <__ram_exceptions_end+0xff7f0d38>
 1802500:	9080100c 	andi	r2,r18,64
 1802504:	d8002785 	stb	zero,158(sp)
 1802508:	10008a1e 	bne	r2,zero,1802734 <___vfprintf_internal_r+0x1ae0>
 180250c:	d9402d17 	ldw	r5,180(sp)
 1802510:	d8c02917 	ldw	r3,164(sp)
 1802514:	002d883a 	mov	r22,zero
 1802518:	28800104 	addi	r2,r5,4
 180251c:	2cc00017 	ldw	r19,0(r5)
 1802520:	183e4b0e 	bge	r3,zero,1801e50 <__ram_exceptions_end+0xff7f1a0c>
 1802524:	9d86b03a 	or	r3,r19,r22
 1802528:	d8802d15 	stw	r2,180(sp)
 180252c:	183e4c1e 	bne	r3,zero,1801e60 <__ram_exceptions_end+0xff7f1a1c>
 1802530:	0039883a 	mov	fp,zero
 1802534:	0005883a 	mov	r2,zero
 1802538:	003d4006 	br	1801a3c <__ram_exceptions_end+0xff7f15f8>
 180253c:	01406134 	movhi	r5,388
 1802540:	2944ed84 	addi	r5,r5,5046
 1802544:	d9402b15 	stw	r5,172(sp)
 1802548:	d9402b17 	ldw	r5,172(sp)
 180254c:	1c47883a 	add	r3,r3,r17
 1802550:	10800044 	addi	r2,r2,1
 1802554:	41400015 	stw	r5,0(r8)
 1802558:	44400115 	stw	r17,4(r8)
 180255c:	d8c02015 	stw	r3,128(sp)
 1802560:	d8801f15 	stw	r2,124(sp)
 1802564:	010001c4 	movi	r4,7
 1802568:	20bec816 	blt	r4,r2,180208c <__ram_exceptions_end+0xff7f1c48>
 180256c:	42000204 	addi	r8,r8,8
 1802570:	003ecd06 	br	18020a8 <__ram_exceptions_end+0xff7f1c64>
 1802574:	d9002917 	ldw	r4,164(sp)
 1802578:	d8002785 	stb	zero,158(sp)
 180257c:	203d2d16 	blt	r4,zero,1801a34 <__ram_exceptions_end+0xff7f15f0>
 1802580:	00bfdfc4 	movi	r2,-129
 1802584:	90a4703a 	and	r18,r18,r2
 1802588:	003a9106 	br	1800fd0 <__ram_exceptions_end+0xff7f0b8c>
 180258c:	01006134 	movhi	r4,388
 1802590:	2104ed84 	addi	r4,r4,5046
 1802594:	d9002b15 	stw	r4,172(sp)
 1802598:	003c0c06 	br	18015cc <__ram_exceptions_end+0xff7f1188>
 180259c:	d9002c17 	ldw	r4,176(sp)
 18025a0:	d9801e04 	addi	r6,sp,120
 18025a4:	b80b883a 	mov	r5,r23
 18025a8:	180776c0 	call	180776c <__sprint_r>
 18025ac:	103aab1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18025b0:	d8c02017 	ldw	r3,128(sp)
 18025b4:	da000404 	addi	r8,sp,16
 18025b8:	003d4106 	br	1801ac0 <__ram_exceptions_end+0xff7f167c>
 18025bc:	d8801f17 	ldw	r2,124(sp)
 18025c0:	01406134 	movhi	r5,388
 18025c4:	01000044 	movi	r4,1
 18025c8:	18c00044 	addi	r3,r3,1
 18025cc:	10800044 	addi	r2,r2,1
 18025d0:	2944ed04 	addi	r5,r5,5044
 18025d4:	41000115 	stw	r4,4(r8)
 18025d8:	41400015 	stw	r5,0(r8)
 18025dc:	d8c02015 	stw	r3,128(sp)
 18025e0:	d8801f15 	stw	r2,124(sp)
 18025e4:	010001c4 	movi	r4,7
 18025e8:	20805c16 	blt	r4,r2,180275c <___vfprintf_internal_r+0x1b08>
 18025ec:	42000204 	addi	r8,r8,8
 18025f0:	8800041e 	bne	r17,zero,1802604 <___vfprintf_internal_r+0x19b0>
 18025f4:	d8803317 	ldw	r2,204(sp)
 18025f8:	1000021e 	bne	r2,zero,1802604 <___vfprintf_internal_r+0x19b0>
 18025fc:	9080004c 	andi	r2,r18,1
 1802600:	103c0926 	beq	r2,zero,1801628 <__ram_exceptions_end+0xff7f11e4>
 1802604:	d9003717 	ldw	r4,220(sp)
 1802608:	d8801f17 	ldw	r2,124(sp)
 180260c:	d9403417 	ldw	r5,208(sp)
 1802610:	20c7883a 	add	r3,r4,r3
 1802614:	10800044 	addi	r2,r2,1
 1802618:	41000115 	stw	r4,4(r8)
 180261c:	41400015 	stw	r5,0(r8)
 1802620:	d8c02015 	stw	r3,128(sp)
 1802624:	d8801f15 	stw	r2,124(sp)
 1802628:	010001c4 	movi	r4,7
 180262c:	20812116 	blt	r4,r2,1802ab4 <___vfprintf_internal_r+0x1e60>
 1802630:	42000204 	addi	r8,r8,8
 1802634:	0463c83a 	sub	r17,zero,r17
 1802638:	0440730e 	bge	zero,r17,1802808 <___vfprintf_internal_r+0x1bb4>
 180263c:	05800404 	movi	r22,16
 1802640:	b440860e 	bge	r22,r17,180285c <___vfprintf_internal_r+0x1c08>
 1802644:	01406134 	movhi	r5,388
 1802648:	2944ed84 	addi	r5,r5,5046
 180264c:	d9402b15 	stw	r5,172(sp)
 1802650:	070001c4 	movi	fp,7
 1802654:	dcc02c17 	ldw	r19,176(sp)
 1802658:	00000306 	br	1802668 <___vfprintf_internal_r+0x1a14>
 180265c:	42000204 	addi	r8,r8,8
 1802660:	8c7ffc04 	addi	r17,r17,-16
 1802664:	b440800e 	bge	r22,r17,1802868 <___vfprintf_internal_r+0x1c14>
 1802668:	18c00404 	addi	r3,r3,16
 180266c:	10800044 	addi	r2,r2,1
 1802670:	45000015 	stw	r20,0(r8)
 1802674:	45800115 	stw	r22,4(r8)
 1802678:	d8c02015 	stw	r3,128(sp)
 180267c:	d8801f15 	stw	r2,124(sp)
 1802680:	e0bff60e 	bge	fp,r2,180265c <__ram_exceptions_end+0xff7f2218>
 1802684:	d9801e04 	addi	r6,sp,120
 1802688:	b80b883a 	mov	r5,r23
 180268c:	9809883a 	mov	r4,r19
 1802690:	180776c0 	call	180776c <__sprint_r>
 1802694:	103a711e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802698:	d8c02017 	ldw	r3,128(sp)
 180269c:	d8801f17 	ldw	r2,124(sp)
 18026a0:	da000404 	addi	r8,sp,16
 18026a4:	003fee06 	br	1802660 <__ram_exceptions_end+0xff7f221c>
 18026a8:	00bfffc4 	movi	r2,-1
 18026ac:	003a6f06 	br	180106c <__ram_exceptions_end+0xff7f0c28>
 18026b0:	008011c4 	movi	r2,71
 18026b4:	1440b816 	blt	r2,r17,1802998 <___vfprintf_internal_r+0x1d44>
 18026b8:	04006134 	movhi	r16,388
 18026bc:	8404df04 	addi	r16,r16,4988
 18026c0:	00c000c4 	movi	r3,3
 18026c4:	00bfdfc4 	movi	r2,-129
 18026c8:	d8c02a15 	stw	r3,168(sp)
 18026cc:	90a4703a 	and	r18,r18,r2
 18026d0:	df002783 	ldbu	fp,158(sp)
 18026d4:	d8c02e15 	stw	r3,184(sp)
 18026d8:	d8002915 	stw	zero,164(sp)
 18026dc:	d8003215 	stw	zero,200(sp)
 18026e0:	003b2906 	br	1801388 <__ram_exceptions_end+0xff7f0f44>
 18026e4:	d9002d17 	ldw	r4,180(sp)
 18026e8:	24c00017 	ldw	r19,0(r4)
 18026ec:	21000104 	addi	r4,r4,4
 18026f0:	d9002d15 	stw	r4,180(sp)
 18026f4:	982dd7fa 	srai	r22,r19,31
 18026f8:	b005883a 	mov	r2,r22
 18026fc:	003a9f06 	br	180117c <__ram_exceptions_end+0xff7f0d38>
 1802700:	d9402d17 	ldw	r5,180(sp)
 1802704:	d8c02f17 	ldw	r3,188(sp)
 1802708:	28800017 	ldw	r2,0(r5)
 180270c:	29400104 	addi	r5,r5,4
 1802710:	d9402d15 	stw	r5,180(sp)
 1802714:	10c00015 	stw	r3,0(r2)
 1802718:	00398606 	br	1800d34 <__ram_exceptions_end+0xff7f08f0>
 180271c:	d9402d17 	ldw	r5,180(sp)
 1802720:	002d883a 	mov	r22,zero
 1802724:	2cc00017 	ldw	r19,0(r5)
 1802728:	29400104 	addi	r5,r5,4
 180272c:	d9402d15 	stw	r5,180(sp)
 1802730:	003c2306 	br	18017c0 <__ram_exceptions_end+0xff7f137c>
 1802734:	d8c02d17 	ldw	r3,180(sp)
 1802738:	d9002917 	ldw	r4,164(sp)
 180273c:	002d883a 	mov	r22,zero
 1802740:	18800104 	addi	r2,r3,4
 1802744:	1cc0000b 	ldhu	r19,0(r3)
 1802748:	203dc10e 	bge	r4,zero,1801e50 <__ram_exceptions_end+0xff7f1a0c>
 180274c:	003f7506 	br	1802524 <__ram_exceptions_end+0xff7f20e0>
 1802750:	04006134 	movhi	r16,388
 1802754:	8404dd04 	addi	r16,r16,4980
 1802758:	003acc06 	br	180128c <__ram_exceptions_end+0xff7f0e48>
 180275c:	d9002c17 	ldw	r4,176(sp)
 1802760:	d9801e04 	addi	r6,sp,120
 1802764:	b80b883a 	mov	r5,r23
 1802768:	180776c0 	call	180776c <__sprint_r>
 180276c:	103a3b1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802770:	dc402617 	ldw	r17,152(sp)
 1802774:	d8c02017 	ldw	r3,128(sp)
 1802778:	da000404 	addi	r8,sp,16
 180277c:	003f9c06 	br	18025f0 <__ram_exceptions_end+0xff7f21ac>
 1802780:	ac400043 	ldbu	r17,1(r21)
 1802784:	94800814 	ori	r18,r18,32
 1802788:	ad400044 	addi	r21,r21,1
 180278c:	8c403fcc 	andi	r17,r17,255
 1802790:	8c40201c 	xori	r17,r17,128
 1802794:	8c7fe004 	addi	r17,r17,-128
 1802798:	00398f06 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 180279c:	d8c02d15 	stw	r3,180(sp)
 18027a0:	0039883a 	mov	fp,zero
 18027a4:	003e3506 	br	180207c <__ram_exceptions_end+0xff7f1c38>
 18027a8:	d9002c17 	ldw	r4,176(sp)
 18027ac:	d9801e04 	addi	r6,sp,120
 18027b0:	b80b883a 	mov	r5,r23
 18027b4:	180776c0 	call	180776c <__sprint_r>
 18027b8:	103a281e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18027bc:	d8c02017 	ldw	r3,128(sp)
 18027c0:	da000404 	addi	r8,sp,16
 18027c4:	003cd006 	br	1801b08 <__ram_exceptions_end+0xff7f16c4>
 18027c8:	8009883a 	mov	r4,r16
 18027cc:	da003d15 	stw	r8,244(sp)
 18027d0:	18075d80 	call	18075d8 <strlen>
 18027d4:	d8802e15 	stw	r2,184(sp)
 18027d8:	da003d17 	ldw	r8,244(sp)
 18027dc:	103c340e 	bge	r2,zero,18018b0 <__ram_exceptions_end+0xff7f146c>
 18027e0:	0005883a 	mov	r2,zero
 18027e4:	003c3206 	br	18018b0 <__ram_exceptions_end+0xff7f146c>
 18027e8:	d9002c17 	ldw	r4,176(sp)
 18027ec:	d9801e04 	addi	r6,sp,120
 18027f0:	b80b883a 	mov	r5,r23
 18027f4:	180776c0 	call	180776c <__sprint_r>
 18027f8:	103a181e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18027fc:	d8c02017 	ldw	r3,128(sp)
 1802800:	d8801f17 	ldw	r2,124(sp)
 1802804:	da000404 	addi	r8,sp,16
 1802808:	d9403317 	ldw	r5,204(sp)
 180280c:	10800044 	addi	r2,r2,1
 1802810:	44000015 	stw	r16,0(r8)
 1802814:	28c7883a 	add	r3,r5,r3
 1802818:	003b7d06 	br	1801610 <__ram_exceptions_end+0xff7f11cc>
 180281c:	01006134 	movhi	r4,388
 1802820:	2104f184 	addi	r4,r4,5062
 1802824:	d9003515 	stw	r4,212(sp)
 1802828:	003b1406 	br	180147c <__ram_exceptions_end+0xff7f1038>
 180282c:	013fffc4 	movi	r4,-1
 1802830:	003a3506 	br	1801108 <__ram_exceptions_end+0xff7f0cc4>
 1802834:	0023883a 	mov	r17,zero
 1802838:	003d9d06 	br	1801eb0 <__ram_exceptions_end+0xff7f1a6c>
 180283c:	d9002c17 	ldw	r4,176(sp)
 1802840:	d9801e04 	addi	r6,sp,120
 1802844:	b80b883a 	mov	r5,r23
 1802848:	180776c0 	call	180776c <__sprint_r>
 180284c:	103a031e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802850:	d8c02017 	ldw	r3,128(sp)
 1802854:	da000404 	addi	r8,sp,16
 1802858:	003d9406 	br	1801eac <__ram_exceptions_end+0xff7f1a68>
 180285c:	01006134 	movhi	r4,388
 1802860:	2104ed84 	addi	r4,r4,5046
 1802864:	d9002b15 	stw	r4,172(sp)
 1802868:	d9002b17 	ldw	r4,172(sp)
 180286c:	1c47883a 	add	r3,r3,r17
 1802870:	10800044 	addi	r2,r2,1
 1802874:	41000015 	stw	r4,0(r8)
 1802878:	44400115 	stw	r17,4(r8)
 180287c:	d8c02015 	stw	r3,128(sp)
 1802880:	d8801f15 	stw	r2,124(sp)
 1802884:	010001c4 	movi	r4,7
 1802888:	20bfd716 	blt	r4,r2,18027e8 <__ram_exceptions_end+0xff7f23a4>
 180288c:	42000204 	addi	r8,r8,8
 1802890:	003fdd06 	br	1802808 <__ram_exceptions_end+0xff7f23c4>
 1802894:	d9002c17 	ldw	r4,176(sp)
 1802898:	d9801e04 	addi	r6,sp,120
 180289c:	b80b883a 	mov	r5,r23
 18028a0:	180776c0 	call	180776c <__sprint_r>
 18028a4:	1039ed1e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 18028a8:	d8802617 	ldw	r2,152(sp)
 18028ac:	d8c02017 	ldw	r3,128(sp)
 18028b0:	da000404 	addi	r8,sp,16
 18028b4:	003e1006 	br	18020f8 <__ram_exceptions_end+0xff7f1cb4>
 18028b8:	00800044 	movi	r2,1
 18028bc:	10803fcc 	andi	r2,r2,255
 18028c0:	00c00044 	movi	r3,1
 18028c4:	10fa3526 	beq	r2,r3,180119c <__ram_exceptions_end+0xff7f0d58>
 18028c8:	00c00084 	movi	r3,2
 18028cc:	10fbcb26 	beq	r2,r3,18017fc <__ram_exceptions_end+0xff7f13b8>
 18028d0:	003a8f06 	br	1801310 <__ram_exceptions_end+0xff7f0ecc>
 18028d4:	01006134 	movhi	r4,388
 18028d8:	2104f184 	addi	r4,r4,5062
 18028dc:	d9003515 	stw	r4,212(sp)
 18028e0:	003b7606 	br	18016bc <__ram_exceptions_end+0xff7f1278>
 18028e4:	d8802917 	ldw	r2,164(sp)
 18028e8:	00c00184 	movi	r3,6
 18028ec:	1880012e 	bgeu	r3,r2,18028f4 <___vfprintf_internal_r+0x1ca0>
 18028f0:	1805883a 	mov	r2,r3
 18028f4:	d8802e15 	stw	r2,184(sp)
 18028f8:	1000ef16 	blt	r2,zero,1802cb8 <___vfprintf_internal_r+0x2064>
 18028fc:	04006134 	movhi	r16,388
 1802900:	d8802a15 	stw	r2,168(sp)
 1802904:	dcc02d15 	stw	r19,180(sp)
 1802908:	d8002915 	stw	zero,164(sp)
 180290c:	d8003215 	stw	zero,200(sp)
 1802910:	8404eb04 	addi	r16,r16,5036
 1802914:	0039883a 	mov	fp,zero
 1802918:	003aa206 	br	18013a4 <__ram_exceptions_end+0xff7f0f60>
 180291c:	0021883a 	mov	r16,zero
 1802920:	003e0706 	br	1802140 <__ram_exceptions_end+0xff7f1cfc>
 1802924:	d9002c17 	ldw	r4,176(sp)
 1802928:	d9801e04 	addi	r6,sp,120
 180292c:	b80b883a 	mov	r5,r23
 1802930:	180776c0 	call	180776c <__sprint_r>
 1802934:	1039c91e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802938:	d8802617 	ldw	r2,152(sp)
 180293c:	d9403317 	ldw	r5,204(sp)
 1802940:	d8c02017 	ldw	r3,128(sp)
 1802944:	da000404 	addi	r8,sp,16
 1802948:	2885c83a 	sub	r2,r5,r2
 180294c:	003dfb06 	br	180213c <__ram_exceptions_end+0xff7f1cf8>
 1802950:	9080004c 	andi	r2,r18,1
 1802954:	103e8f1e 	bne	r2,zero,1802394 <__ram_exceptions_end+0xff7f1f50>
 1802958:	d8802117 	ldw	r2,132(sp)
 180295c:	003e9e06 	br	18023d8 <__ram_exceptions_end+0xff7f1f94>
 1802960:	1025883a 	mov	r18,r2
 1802964:	0039883a 	mov	fp,zero
 1802968:	00800084 	movi	r2,2
 180296c:	003fd306 	br	18028bc <__ram_exceptions_end+0xff7f2478>
 1802970:	07000b44 	movi	fp,45
 1802974:	df002785 	stb	fp,158(sp)
 1802978:	003a4006 	br	180127c <__ram_exceptions_end+0xff7f0e38>
 180297c:	00c00b44 	movi	r3,45
 1802980:	d8c02785 	stb	r3,158(sp)
 1802984:	d8802a15 	stw	r2,168(sp)
 1802988:	dc802b17 	ldw	r18,172(sp)
 180298c:	d8002915 	stw	zero,164(sp)
 1802990:	07000b44 	movi	fp,45
 1802994:	003a8006 	br	1801398 <__ram_exceptions_end+0xff7f0f54>
 1802998:	04006134 	movhi	r16,388
 180299c:	8404e004 	addi	r16,r16,4992
 18029a0:	003f4706 	br	18026c0 <__ram_exceptions_end+0xff7f227c>
 18029a4:	d8c02d17 	ldw	r3,180(sp)
 18029a8:	d9002f17 	ldw	r4,188(sp)
 18029ac:	18800017 	ldw	r2,0(r3)
 18029b0:	18c00104 	addi	r3,r3,4
 18029b4:	d8c02d15 	stw	r3,180(sp)
 18029b8:	11000015 	stw	r4,0(r2)
 18029bc:	0038dd06 	br	1800d34 <__ram_exceptions_end+0xff7f08f0>
 18029c0:	dd802617 	ldw	r22,152(sp)
 18029c4:	00bfff44 	movi	r2,-3
 18029c8:	b0801c16 	blt	r22,r2,1802a3c <___vfprintf_internal_r+0x1de8>
 18029cc:	d9402917 	ldw	r5,164(sp)
 18029d0:	2d801a16 	blt	r5,r22,1802a3c <___vfprintf_internal_r+0x1de8>
 18029d4:	dd803215 	stw	r22,200(sp)
 18029d8:	003e8906 	br	1802400 <__ram_exceptions_end+0xff7f1fbc>
 18029dc:	01006134 	movhi	r4,388
 18029e0:	2104ed84 	addi	r4,r4,5046
 18029e4:	d9002b15 	stw	r4,172(sp)
 18029e8:	003c9106 	br	1801c30 <__ram_exceptions_end+0xff7f17ec>
 18029ec:	e005883a 	mov	r2,fp
 18029f0:	003e7906 	br	18023d8 <__ram_exceptions_end+0xff7f1f94>
 18029f4:	d9402917 	ldw	r5,164(sp)
 18029f8:	df002783 	ldbu	fp,158(sp)
 18029fc:	dcc02d15 	stw	r19,180(sp)
 1802a00:	d9402a15 	stw	r5,168(sp)
 1802a04:	d9402e15 	stw	r5,184(sp)
 1802a08:	d8002915 	stw	zero,164(sp)
 1802a0c:	d8003215 	stw	zero,200(sp)
 1802a10:	003a5d06 	br	1801388 <__ram_exceptions_end+0xff7f0f44>
 1802a14:	9080004c 	andi	r2,r18,1
 1802a18:	0039883a 	mov	fp,zero
 1802a1c:	10000426 	beq	r2,zero,1802a30 <___vfprintf_internal_r+0x1ddc>
 1802a20:	00800c04 	movi	r2,48
 1802a24:	dc001dc4 	addi	r16,sp,119
 1802a28:	d8801dc5 	stb	r2,119(sp)
 1802a2c:	003b8006 	br	1801830 <__ram_exceptions_end+0xff7f13ec>
 1802a30:	d8002e15 	stw	zero,184(sp)
 1802a34:	dc001e04 	addi	r16,sp,120
 1802a38:	003a4d06 	br	1801370 <__ram_exceptions_end+0xff7f0f2c>
 1802a3c:	8c7fff84 	addi	r17,r17,-2
 1802a40:	b5bfffc4 	addi	r22,r22,-1
 1802a44:	dd802615 	stw	r22,152(sp)
 1802a48:	dc4022c5 	stb	r17,139(sp)
 1802a4c:	b000bf16 	blt	r22,zero,1802d4c <___vfprintf_internal_r+0x20f8>
 1802a50:	00800ac4 	movi	r2,43
 1802a54:	d8802305 	stb	r2,140(sp)
 1802a58:	00800244 	movi	r2,9
 1802a5c:	15807016 	blt	r2,r22,1802c20 <___vfprintf_internal_r+0x1fcc>
 1802a60:	00800c04 	movi	r2,48
 1802a64:	b5800c04 	addi	r22,r22,48
 1802a68:	d8802345 	stb	r2,141(sp)
 1802a6c:	dd802385 	stb	r22,142(sp)
 1802a70:	d88023c4 	addi	r2,sp,143
 1802a74:	df0022c4 	addi	fp,sp,139
 1802a78:	d8c03317 	ldw	r3,204(sp)
 1802a7c:	1739c83a 	sub	fp,r2,fp
 1802a80:	d9003317 	ldw	r4,204(sp)
 1802a84:	e0c7883a 	add	r3,fp,r3
 1802a88:	df003a15 	stw	fp,232(sp)
 1802a8c:	d8c02e15 	stw	r3,184(sp)
 1802a90:	00800044 	movi	r2,1
 1802a94:	1100b30e 	bge	r2,r4,1802d64 <___vfprintf_internal_r+0x2110>
 1802a98:	d8c02e17 	ldw	r3,184(sp)
 1802a9c:	18c00044 	addi	r3,r3,1
 1802aa0:	d8c02e15 	stw	r3,184(sp)
 1802aa4:	1805883a 	mov	r2,r3
 1802aa8:	1800ac16 	blt	r3,zero,1802d5c <___vfprintf_internal_r+0x2108>
 1802aac:	d8003215 	stw	zero,200(sp)
 1802ab0:	003e5d06 	br	1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802ab4:	d9002c17 	ldw	r4,176(sp)
 1802ab8:	d9801e04 	addi	r6,sp,120
 1802abc:	b80b883a 	mov	r5,r23
 1802ac0:	180776c0 	call	180776c <__sprint_r>
 1802ac4:	1039651e 	bne	r2,zero,180105c <__ram_exceptions_end+0xff7f0c18>
 1802ac8:	dc402617 	ldw	r17,152(sp)
 1802acc:	d8c02017 	ldw	r3,128(sp)
 1802ad0:	d8801f17 	ldw	r2,124(sp)
 1802ad4:	da000404 	addi	r8,sp,16
 1802ad8:	003ed606 	br	1802634 <__ram_exceptions_end+0xff7f21f0>
 1802adc:	582b883a 	mov	r21,r11
 1802ae0:	d8002915 	stw	zero,164(sp)
 1802ae4:	0038bd06 	br	1800ddc <__ram_exceptions_end+0xff7f0998>
 1802ae8:	d8802917 	ldw	r2,164(sp)
 1802aec:	103e071e 	bne	r2,zero,180230c <__ram_exceptions_end+0xff7f1ec8>
 1802af0:	dc002915 	stw	r16,164(sp)
 1802af4:	003e0506 	br	180230c <__ram_exceptions_end+0xff7f1ec8>
 1802af8:	d9002917 	ldw	r4,164(sp)
 1802afc:	20c00044 	addi	r3,r4,1
 1802b00:	003e0f06 	br	1802340 <__ram_exceptions_end+0xff7f1efc>
 1802b04:	01400184 	movi	r5,6
 1802b08:	d9402915 	stw	r5,164(sp)
 1802b0c:	003dff06 	br	180230c <__ram_exceptions_end+0xff7f1ec8>
 1802b10:	d8802104 	addi	r2,sp,132
 1802b14:	d8800315 	stw	r2,12(sp)
 1802b18:	d8802504 	addi	r2,sp,148
 1802b1c:	d8800215 	stw	r2,8(sp)
 1802b20:	d8802604 	addi	r2,sp,152
 1802b24:	d8800115 	stw	r2,4(sp)
 1802b28:	d8802917 	ldw	r2,164(sp)
 1802b2c:	d9403617 	ldw	r5,216(sp)
 1802b30:	d9002c17 	ldw	r4,176(sp)
 1802b34:	d8800015 	stw	r2,0(sp)
 1802b38:	01c000c4 	movi	r7,3
 1802b3c:	980d883a 	mov	r6,r19
 1802b40:	da003d15 	stw	r8,244(sp)
 1802b44:	18032780 	call	1803278 <_dtoa_r>
 1802b48:	d8c02917 	ldw	r3,164(sp)
 1802b4c:	da003d17 	ldw	r8,244(sp)
 1802b50:	1021883a 	mov	r16,r2
 1802b54:	10f9883a 	add	fp,r2,r3
 1802b58:	81000007 	ldb	r4,0(r16)
 1802b5c:	00800c04 	movi	r2,48
 1802b60:	20805e26 	beq	r4,r2,1802cdc <___vfprintf_internal_r+0x2088>
 1802b64:	d8c02617 	ldw	r3,152(sp)
 1802b68:	e0f9883a 	add	fp,fp,r3
 1802b6c:	003e0a06 	br	1802398 <__ram_exceptions_end+0xff7f1f54>
 1802b70:	00c00b44 	movi	r3,45
 1802b74:	24e0003c 	xorhi	r19,r4,32768
 1802b78:	d8c02a05 	stb	r3,168(sp)
 1802b7c:	003de906 	br	1802324 <__ram_exceptions_end+0xff7f1ee0>
 1802b80:	d8c03217 	ldw	r3,200(sp)
 1802b84:	00c07a0e 	bge	zero,r3,1802d70 <___vfprintf_internal_r+0x211c>
 1802b88:	00800044 	movi	r2,1
 1802b8c:	d9003317 	ldw	r4,204(sp)
 1802b90:	1105883a 	add	r2,r2,r4
 1802b94:	d8802e15 	stw	r2,184(sp)
 1802b98:	10004e16 	blt	r2,zero,1802cd4 <___vfprintf_internal_r+0x2080>
 1802b9c:	044019c4 	movi	r17,103
 1802ba0:	003e2106 	br	1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802ba4:	d9002917 	ldw	r4,164(sp)
 1802ba8:	d8802104 	addi	r2,sp,132
 1802bac:	d8800315 	stw	r2,12(sp)
 1802bb0:	d9000015 	stw	r4,0(sp)
 1802bb4:	d8802504 	addi	r2,sp,148
 1802bb8:	d9403617 	ldw	r5,216(sp)
 1802bbc:	d9002c17 	ldw	r4,176(sp)
 1802bc0:	d8800215 	stw	r2,8(sp)
 1802bc4:	d8802604 	addi	r2,sp,152
 1802bc8:	d8800115 	stw	r2,4(sp)
 1802bcc:	01c000c4 	movi	r7,3
 1802bd0:	980d883a 	mov	r6,r19
 1802bd4:	da003d15 	stw	r8,244(sp)
 1802bd8:	18032780 	call	1803278 <_dtoa_r>
 1802bdc:	d8c02917 	ldw	r3,164(sp)
 1802be0:	da003d17 	ldw	r8,244(sp)
 1802be4:	1021883a 	mov	r16,r2
 1802be8:	00801184 	movi	r2,70
 1802bec:	80f9883a 	add	fp,r16,r3
 1802bf0:	88bfd926 	beq	r17,r2,1802b58 <__ram_exceptions_end+0xff7f2714>
 1802bf4:	003de806 	br	1802398 <__ram_exceptions_end+0xff7f1f54>
 1802bf8:	d9002917 	ldw	r4,164(sp)
 1802bfc:	00c04d0e 	bge	zero,r3,1802d34 <___vfprintf_internal_r+0x20e0>
 1802c00:	2000441e 	bne	r4,zero,1802d14 <___vfprintf_internal_r+0x20c0>
 1802c04:	9480004c 	andi	r18,r18,1
 1802c08:	9000421e 	bne	r18,zero,1802d14 <___vfprintf_internal_r+0x20c0>
 1802c0c:	1805883a 	mov	r2,r3
 1802c10:	18007016 	blt	r3,zero,1802dd4 <___vfprintf_internal_r+0x2180>
 1802c14:	d8c03217 	ldw	r3,200(sp)
 1802c18:	d8c02e15 	stw	r3,184(sp)
 1802c1c:	003e0206 	br	1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802c20:	df0022c4 	addi	fp,sp,139
 1802c24:	dc002915 	stw	r16,164(sp)
 1802c28:	4027883a 	mov	r19,r8
 1802c2c:	e021883a 	mov	r16,fp
 1802c30:	b009883a 	mov	r4,r22
 1802c34:	01400284 	movi	r5,10
 1802c38:	180ac9c0 	call	180ac9c <__modsi3>
 1802c3c:	10800c04 	addi	r2,r2,48
 1802c40:	843fffc4 	addi	r16,r16,-1
 1802c44:	b009883a 	mov	r4,r22
 1802c48:	01400284 	movi	r5,10
 1802c4c:	80800005 	stb	r2,0(r16)
 1802c50:	180ac180 	call	180ac18 <__divsi3>
 1802c54:	102d883a 	mov	r22,r2
 1802c58:	00800244 	movi	r2,9
 1802c5c:	15bff416 	blt	r2,r22,1802c30 <__ram_exceptions_end+0xff7f27ec>
 1802c60:	9811883a 	mov	r8,r19
 1802c64:	b0800c04 	addi	r2,r22,48
 1802c68:	8027883a 	mov	r19,r16
 1802c6c:	997fffc4 	addi	r5,r19,-1
 1802c70:	98bfffc5 	stb	r2,-1(r19)
 1802c74:	dc002917 	ldw	r16,164(sp)
 1802c78:	2f006a2e 	bgeu	r5,fp,1802e24 <___vfprintf_internal_r+0x21d0>
 1802c7c:	d9c02384 	addi	r7,sp,142
 1802c80:	3ccfc83a 	sub	r7,r7,r19
 1802c84:	d9002344 	addi	r4,sp,141
 1802c88:	e1cf883a 	add	r7,fp,r7
 1802c8c:	00000106 	br	1802c94 <___vfprintf_internal_r+0x2040>
 1802c90:	28800003 	ldbu	r2,0(r5)
 1802c94:	20800005 	stb	r2,0(r4)
 1802c98:	21000044 	addi	r4,r4,1
 1802c9c:	29400044 	addi	r5,r5,1
 1802ca0:	393ffb1e 	bne	r7,r4,1802c90 <__ram_exceptions_end+0xff7f284c>
 1802ca4:	d8802304 	addi	r2,sp,140
 1802ca8:	14c5c83a 	sub	r2,r2,r19
 1802cac:	d8c02344 	addi	r3,sp,141
 1802cb0:	1885883a 	add	r2,r3,r2
 1802cb4:	003f7006 	br	1802a78 <__ram_exceptions_end+0xff7f2634>
 1802cb8:	0005883a 	mov	r2,zero
 1802cbc:	003f0f06 	br	18028fc <__ram_exceptions_end+0xff7f24b8>
 1802cc0:	d8c03217 	ldw	r3,200(sp)
 1802cc4:	18c00044 	addi	r3,r3,1
 1802cc8:	d8c02e15 	stw	r3,184(sp)
 1802ccc:	1805883a 	mov	r2,r3
 1802cd0:	183fb20e 	bge	r3,zero,1802b9c <__ram_exceptions_end+0xff7f2758>
 1802cd4:	0005883a 	mov	r2,zero
 1802cd8:	003fb006 	br	1802b9c <__ram_exceptions_end+0xff7f2758>
 1802cdc:	d9003617 	ldw	r4,216(sp)
 1802ce0:	000d883a 	mov	r6,zero
 1802ce4:	000f883a 	mov	r7,zero
 1802ce8:	980b883a 	mov	r5,r19
 1802cec:	d8c03c15 	stw	r3,240(sp)
 1802cf0:	da003d15 	stw	r8,244(sp)
 1802cf4:	180bf600 	call	180bf60 <__eqdf2>
 1802cf8:	d8c03c17 	ldw	r3,240(sp)
 1802cfc:	da003d17 	ldw	r8,244(sp)
 1802d00:	103f9826 	beq	r2,zero,1802b64 <__ram_exceptions_end+0xff7f2720>
 1802d04:	00800044 	movi	r2,1
 1802d08:	10c7c83a 	sub	r3,r2,r3
 1802d0c:	d8c02615 	stw	r3,152(sp)
 1802d10:	003f9506 	br	1802b68 <__ram_exceptions_end+0xff7f2724>
 1802d14:	d9002917 	ldw	r4,164(sp)
 1802d18:	d8c03217 	ldw	r3,200(sp)
 1802d1c:	20800044 	addi	r2,r4,1
 1802d20:	1885883a 	add	r2,r3,r2
 1802d24:	d8802e15 	stw	r2,184(sp)
 1802d28:	103dbf0e 	bge	r2,zero,1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802d2c:	0005883a 	mov	r2,zero
 1802d30:	003dbd06 	br	1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802d34:	2000211e 	bne	r4,zero,1802dbc <___vfprintf_internal_r+0x2168>
 1802d38:	9480004c 	andi	r18,r18,1
 1802d3c:	90001f1e 	bne	r18,zero,1802dbc <___vfprintf_internal_r+0x2168>
 1802d40:	00800044 	movi	r2,1
 1802d44:	d8802e15 	stw	r2,184(sp)
 1802d48:	003db706 	br	1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802d4c:	00800b44 	movi	r2,45
 1802d50:	05adc83a 	sub	r22,zero,r22
 1802d54:	d8802305 	stb	r2,140(sp)
 1802d58:	003f3f06 	br	1802a58 <__ram_exceptions_end+0xff7f2614>
 1802d5c:	0005883a 	mov	r2,zero
 1802d60:	003f5206 	br	1802aac <__ram_exceptions_end+0xff7f2668>
 1802d64:	90a4703a 	and	r18,r18,r2
 1802d68:	903f4e26 	beq	r18,zero,1802aa4 <__ram_exceptions_end+0xff7f2660>
 1802d6c:	003f4a06 	br	1802a98 <__ram_exceptions_end+0xff7f2654>
 1802d70:	00800084 	movi	r2,2
 1802d74:	10c5c83a 	sub	r2,r2,r3
 1802d78:	003f8406 	br	1802b8c <__ram_exceptions_end+0xff7f2748>
 1802d7c:	d8802d17 	ldw	r2,180(sp)
 1802d80:	d9002d17 	ldw	r4,180(sp)
 1802d84:	ac400043 	ldbu	r17,1(r21)
 1802d88:	10800017 	ldw	r2,0(r2)
 1802d8c:	582b883a 	mov	r21,r11
 1802d90:	d8802915 	stw	r2,164(sp)
 1802d94:	20800104 	addi	r2,r4,4
 1802d98:	d9002917 	ldw	r4,164(sp)
 1802d9c:	d8802d15 	stw	r2,180(sp)
 1802da0:	203e7a0e 	bge	r4,zero,180278c <__ram_exceptions_end+0xff7f2348>
 1802da4:	8c403fcc 	andi	r17,r17,255
 1802da8:	00bfffc4 	movi	r2,-1
 1802dac:	8c40201c 	xori	r17,r17,128
 1802db0:	d8802915 	stw	r2,164(sp)
 1802db4:	8c7fe004 	addi	r17,r17,-128
 1802db8:	00380706 	br	1800dd8 <__ram_exceptions_end+0xff7f0994>
 1802dbc:	d8c02917 	ldw	r3,164(sp)
 1802dc0:	18c00084 	addi	r3,r3,2
 1802dc4:	d8c02e15 	stw	r3,184(sp)
 1802dc8:	1805883a 	mov	r2,r3
 1802dcc:	183d960e 	bge	r3,zero,1802428 <__ram_exceptions_end+0xff7f1fe4>
 1802dd0:	003fd606 	br	1802d2c <__ram_exceptions_end+0xff7f28e8>
 1802dd4:	0005883a 	mov	r2,zero
 1802dd8:	003f8e06 	br	1802c14 <__ram_exceptions_end+0xff7f27d0>
 1802ddc:	9080004c 	andi	r2,r18,1
 1802de0:	103f811e 	bne	r2,zero,1802be8 <__ram_exceptions_end+0xff7f27a4>
 1802de4:	d8802117 	ldw	r2,132(sp)
 1802de8:	1405c83a 	sub	r2,r2,r16
 1802dec:	d8803315 	stw	r2,204(sp)
 1802df0:	b47ef326 	beq	r22,r17,18029c0 <__ram_exceptions_end+0xff7f257c>
 1802df4:	dd802617 	ldw	r22,152(sp)
 1802df8:	003f1106 	br	1802a40 <__ram_exceptions_end+0xff7f25fc>
 1802dfc:	d9c02785 	stb	r7,158(sp)
 1802e00:	00390406 	br	1801214 <__ram_exceptions_end+0xff7f0dd0>
 1802e04:	d9c02785 	stb	r7,158(sp)
 1802e08:	0038d306 	br	1801158 <__ram_exceptions_end+0xff7f0d14>
 1802e0c:	d9c02785 	stb	r7,158(sp)
 1802e10:	003a6106 	br	1801798 <__ram_exceptions_end+0xff7f1354>
 1802e14:	d9c02785 	stb	r7,158(sp)
 1802e18:	003af806 	br	18019fc <__ram_exceptions_end+0xff7f15b8>
 1802e1c:	0005883a 	mov	r2,zero
 1802e20:	003d7e06 	br	180241c <__ram_exceptions_end+0xff7f1fd8>
 1802e24:	d8802344 	addi	r2,sp,141
 1802e28:	003f1306 	br	1802a78 <__ram_exceptions_end+0xff7f2634>
 1802e2c:	d9c02785 	stb	r7,158(sp)
 1802e30:	00392306 	br	18012c0 <__ram_exceptions_end+0xff7f0e7c>
 1802e34:	d9c02785 	stb	r7,158(sp)
 1802e38:	003aa906 	br	18018e0 <__ram_exceptions_end+0xff7f149c>
 1802e3c:	d9c02785 	stb	r7,158(sp)
 1802e40:	003a3d06 	br	1801738 <__ram_exceptions_end+0xff7f12f4>
 1802e44:	d9c02785 	stb	r7,158(sp)
 1802e48:	003aca06 	br	1801974 <__ram_exceptions_end+0xff7f1530>

01802e4c <__vfprintf_internal>:
 1802e4c:	00806134 	movhi	r2,388
 1802e50:	10975504 	addi	r2,r2,23892
 1802e54:	300f883a 	mov	r7,r6
 1802e58:	280d883a 	mov	r6,r5
 1802e5c:	200b883a 	mov	r5,r4
 1802e60:	11000017 	ldw	r4,0(r2)
 1802e64:	1800c541 	jmpi	1800c54 <___vfprintf_internal_r>

01802e68 <__sbprintf>:
 1802e68:	2880030b 	ldhu	r2,12(r5)
 1802e6c:	2ac01917 	ldw	r11,100(r5)
 1802e70:	2a80038b 	ldhu	r10,14(r5)
 1802e74:	2a400717 	ldw	r9,28(r5)
 1802e78:	2a000917 	ldw	r8,36(r5)
 1802e7c:	defee204 	addi	sp,sp,-1144
 1802e80:	00c10004 	movi	r3,1024
 1802e84:	dc011a15 	stw	r16,1128(sp)
 1802e88:	10bfff4c 	andi	r2,r2,65533
 1802e8c:	2821883a 	mov	r16,r5
 1802e90:	d8cb883a 	add	r5,sp,r3
 1802e94:	dc811c15 	stw	r18,1136(sp)
 1802e98:	dc411b15 	stw	r17,1132(sp)
 1802e9c:	dfc11d15 	stw	ra,1140(sp)
 1802ea0:	2025883a 	mov	r18,r4
 1802ea4:	d881030d 	sth	r2,1036(sp)
 1802ea8:	dac11915 	stw	r11,1124(sp)
 1802eac:	da81038d 	sth	r10,1038(sp)
 1802eb0:	da410715 	stw	r9,1052(sp)
 1802eb4:	da010915 	stw	r8,1060(sp)
 1802eb8:	dec10015 	stw	sp,1024(sp)
 1802ebc:	dec10415 	stw	sp,1040(sp)
 1802ec0:	d8c10215 	stw	r3,1032(sp)
 1802ec4:	d8c10515 	stw	r3,1044(sp)
 1802ec8:	d8010615 	stw	zero,1048(sp)
 1802ecc:	1800c540 	call	1800c54 <___vfprintf_internal_r>
 1802ed0:	1023883a 	mov	r17,r2
 1802ed4:	10000416 	blt	r2,zero,1802ee8 <__sbprintf+0x80>
 1802ed8:	d9410004 	addi	r5,sp,1024
 1802edc:	9009883a 	mov	r4,r18
 1802ee0:	1804b1c0 	call	1804b1c <_fflush_r>
 1802ee4:	10000d1e 	bne	r2,zero,1802f1c <__sbprintf+0xb4>
 1802ee8:	d881030b 	ldhu	r2,1036(sp)
 1802eec:	1080100c 	andi	r2,r2,64
 1802ef0:	10000326 	beq	r2,zero,1802f00 <__sbprintf+0x98>
 1802ef4:	8080030b 	ldhu	r2,12(r16)
 1802ef8:	10801014 	ori	r2,r2,64
 1802efc:	8080030d 	sth	r2,12(r16)
 1802f00:	8805883a 	mov	r2,r17
 1802f04:	dfc11d17 	ldw	ra,1140(sp)
 1802f08:	dc811c17 	ldw	r18,1136(sp)
 1802f0c:	dc411b17 	ldw	r17,1132(sp)
 1802f10:	dc011a17 	ldw	r16,1128(sp)
 1802f14:	dec11e04 	addi	sp,sp,1144
 1802f18:	f800283a 	ret
 1802f1c:	047fffc4 	movi	r17,-1
 1802f20:	003ff106 	br	1802ee8 <__ram_exceptions_end+0xff7f2aa4>

01802f24 <__swsetup_r>:
 1802f24:	00806134 	movhi	r2,388
 1802f28:	defffd04 	addi	sp,sp,-12
 1802f2c:	10975504 	addi	r2,r2,23892
 1802f30:	dc400115 	stw	r17,4(sp)
 1802f34:	2023883a 	mov	r17,r4
 1802f38:	11000017 	ldw	r4,0(r2)
 1802f3c:	dc000015 	stw	r16,0(sp)
 1802f40:	dfc00215 	stw	ra,8(sp)
 1802f44:	2821883a 	mov	r16,r5
 1802f48:	20000226 	beq	r4,zero,1802f54 <__swsetup_r+0x30>
 1802f4c:	20800e17 	ldw	r2,56(r4)
 1802f50:	10003126 	beq	r2,zero,1803018 <__swsetup_r+0xf4>
 1802f54:	8080030b 	ldhu	r2,12(r16)
 1802f58:	10c0020c 	andi	r3,r2,8
 1802f5c:	1009883a 	mov	r4,r2
 1802f60:	18000f26 	beq	r3,zero,1802fa0 <__swsetup_r+0x7c>
 1802f64:	80c00417 	ldw	r3,16(r16)
 1802f68:	18001526 	beq	r3,zero,1802fc0 <__swsetup_r+0x9c>
 1802f6c:	1100004c 	andi	r4,r2,1
 1802f70:	20001c1e 	bne	r4,zero,1802fe4 <__swsetup_r+0xc0>
 1802f74:	1080008c 	andi	r2,r2,2
 1802f78:	1000291e 	bne	r2,zero,1803020 <__swsetup_r+0xfc>
 1802f7c:	80800517 	ldw	r2,20(r16)
 1802f80:	80800215 	stw	r2,8(r16)
 1802f84:	18001c26 	beq	r3,zero,1802ff8 <__swsetup_r+0xd4>
 1802f88:	0005883a 	mov	r2,zero
 1802f8c:	dfc00217 	ldw	ra,8(sp)
 1802f90:	dc400117 	ldw	r17,4(sp)
 1802f94:	dc000017 	ldw	r16,0(sp)
 1802f98:	dec00304 	addi	sp,sp,12
 1802f9c:	f800283a 	ret
 1802fa0:	2080040c 	andi	r2,r4,16
 1802fa4:	10002e26 	beq	r2,zero,1803060 <__swsetup_r+0x13c>
 1802fa8:	2080010c 	andi	r2,r4,4
 1802fac:	10001e1e 	bne	r2,zero,1803028 <__swsetup_r+0x104>
 1802fb0:	80c00417 	ldw	r3,16(r16)
 1802fb4:	20800214 	ori	r2,r4,8
 1802fb8:	8080030d 	sth	r2,12(r16)
 1802fbc:	183feb1e 	bne	r3,zero,1802f6c <__ram_exceptions_end+0xff7f2b28>
 1802fc0:	1100a00c 	andi	r4,r2,640
 1802fc4:	01408004 	movi	r5,512
 1802fc8:	217fe826 	beq	r4,r5,1802f6c <__ram_exceptions_end+0xff7f2b28>
 1802fcc:	800b883a 	mov	r5,r16
 1802fd0:	8809883a 	mov	r4,r17
 1802fd4:	18055e00 	call	18055e0 <__smakebuf_r>
 1802fd8:	8080030b 	ldhu	r2,12(r16)
 1802fdc:	80c00417 	ldw	r3,16(r16)
 1802fe0:	003fe206 	br	1802f6c <__ram_exceptions_end+0xff7f2b28>
 1802fe4:	80800517 	ldw	r2,20(r16)
 1802fe8:	80000215 	stw	zero,8(r16)
 1802fec:	0085c83a 	sub	r2,zero,r2
 1802ff0:	80800615 	stw	r2,24(r16)
 1802ff4:	183fe41e 	bne	r3,zero,1802f88 <__ram_exceptions_end+0xff7f2b44>
 1802ff8:	80c0030b 	ldhu	r3,12(r16)
 1802ffc:	0005883a 	mov	r2,zero
 1803000:	1900200c 	andi	r4,r3,128
 1803004:	203fe126 	beq	r4,zero,1802f8c <__ram_exceptions_end+0xff7f2b48>
 1803008:	18c01014 	ori	r3,r3,64
 180300c:	80c0030d 	sth	r3,12(r16)
 1803010:	00bfffc4 	movi	r2,-1
 1803014:	003fdd06 	br	1802f8c <__ram_exceptions_end+0xff7f2b48>
 1803018:	1804ef80 	call	1804ef8 <__sinit>
 180301c:	003fcd06 	br	1802f54 <__ram_exceptions_end+0xff7f2b10>
 1803020:	0005883a 	mov	r2,zero
 1803024:	003fd606 	br	1802f80 <__ram_exceptions_end+0xff7f2b3c>
 1803028:	81400c17 	ldw	r5,48(r16)
 180302c:	28000626 	beq	r5,zero,1803048 <__swsetup_r+0x124>
 1803030:	80801004 	addi	r2,r16,64
 1803034:	28800326 	beq	r5,r2,1803044 <__swsetup_r+0x120>
 1803038:	8809883a 	mov	r4,r17
 180303c:	180506c0 	call	180506c <_free_r>
 1803040:	8100030b 	ldhu	r4,12(r16)
 1803044:	80000c15 	stw	zero,48(r16)
 1803048:	80c00417 	ldw	r3,16(r16)
 180304c:	00bff6c4 	movi	r2,-37
 1803050:	1108703a 	and	r4,r2,r4
 1803054:	80000115 	stw	zero,4(r16)
 1803058:	80c00015 	stw	r3,0(r16)
 180305c:	003fd506 	br	1802fb4 <__ram_exceptions_end+0xff7f2b70>
 1803060:	00800244 	movi	r2,9
 1803064:	88800015 	stw	r2,0(r17)
 1803068:	20801014 	ori	r2,r4,64
 180306c:	8080030d 	sth	r2,12(r16)
 1803070:	00bfffc4 	movi	r2,-1
 1803074:	003fc506 	br	1802f8c <__ram_exceptions_end+0xff7f2b48>

01803078 <quorem>:
 1803078:	defff704 	addi	sp,sp,-36
 180307c:	dc800215 	stw	r18,8(sp)
 1803080:	20800417 	ldw	r2,16(r4)
 1803084:	2c800417 	ldw	r18,16(r5)
 1803088:	dfc00815 	stw	ra,32(sp)
 180308c:	ddc00715 	stw	r23,28(sp)
 1803090:	dd800615 	stw	r22,24(sp)
 1803094:	dd400515 	stw	r21,20(sp)
 1803098:	dd000415 	stw	r20,16(sp)
 180309c:	dcc00315 	stw	r19,12(sp)
 18030a0:	dc400115 	stw	r17,4(sp)
 18030a4:	dc000015 	stw	r16,0(sp)
 18030a8:	14807116 	blt	r2,r18,1803270 <quorem+0x1f8>
 18030ac:	94bfffc4 	addi	r18,r18,-1
 18030b0:	94ad883a 	add	r22,r18,r18
 18030b4:	b5ad883a 	add	r22,r22,r22
 18030b8:	2c400504 	addi	r17,r5,20
 18030bc:	8da9883a 	add	r20,r17,r22
 18030c0:	25400504 	addi	r21,r4,20
 18030c4:	282f883a 	mov	r23,r5
 18030c8:	adad883a 	add	r22,r21,r22
 18030cc:	a1400017 	ldw	r5,0(r20)
 18030d0:	2021883a 	mov	r16,r4
 18030d4:	b1000017 	ldw	r4,0(r22)
 18030d8:	29400044 	addi	r5,r5,1
 18030dc:	180ad100 	call	180ad10 <__udivsi3>
 18030e0:	1027883a 	mov	r19,r2
 18030e4:	10002c26 	beq	r2,zero,1803198 <quorem+0x120>
 18030e8:	a813883a 	mov	r9,r21
 18030ec:	880b883a 	mov	r5,r17
 18030f0:	0009883a 	mov	r4,zero
 18030f4:	000d883a 	mov	r6,zero
 18030f8:	2a000017 	ldw	r8,0(r5)
 18030fc:	49c00017 	ldw	r7,0(r9)
 1803100:	29400104 	addi	r5,r5,4
 1803104:	40bfffcc 	andi	r2,r8,65535
 1803108:	14c5383a 	mul	r2,r2,r19
 180310c:	4010d43a 	srli	r8,r8,16
 1803110:	38ffffcc 	andi	r3,r7,65535
 1803114:	1105883a 	add	r2,r2,r4
 1803118:	1008d43a 	srli	r4,r2,16
 180311c:	44d1383a 	mul	r8,r8,r19
 1803120:	198d883a 	add	r6,r3,r6
 1803124:	10ffffcc 	andi	r3,r2,65535
 1803128:	30c7c83a 	sub	r3,r6,r3
 180312c:	380ed43a 	srli	r7,r7,16
 1803130:	4105883a 	add	r2,r8,r4
 1803134:	180dd43a 	srai	r6,r3,16
 1803138:	113fffcc 	andi	r4,r2,65535
 180313c:	390fc83a 	sub	r7,r7,r4
 1803140:	398d883a 	add	r6,r7,r6
 1803144:	300e943a 	slli	r7,r6,16
 1803148:	18ffffcc 	andi	r3,r3,65535
 180314c:	1008d43a 	srli	r4,r2,16
 1803150:	38ceb03a 	or	r7,r7,r3
 1803154:	49c00015 	stw	r7,0(r9)
 1803158:	300dd43a 	srai	r6,r6,16
 180315c:	4a400104 	addi	r9,r9,4
 1803160:	a17fe52e 	bgeu	r20,r5,18030f8 <__ram_exceptions_end+0xff7f2cb4>
 1803164:	b0800017 	ldw	r2,0(r22)
 1803168:	10000b1e 	bne	r2,zero,1803198 <quorem+0x120>
 180316c:	b0bfff04 	addi	r2,r22,-4
 1803170:	a880082e 	bgeu	r21,r2,1803194 <quorem+0x11c>
 1803174:	b0ffff17 	ldw	r3,-4(r22)
 1803178:	18000326 	beq	r3,zero,1803188 <quorem+0x110>
 180317c:	00000506 	br	1803194 <quorem+0x11c>
 1803180:	10c00017 	ldw	r3,0(r2)
 1803184:	1800031e 	bne	r3,zero,1803194 <quorem+0x11c>
 1803188:	10bfff04 	addi	r2,r2,-4
 180318c:	94bfffc4 	addi	r18,r18,-1
 1803190:	a8bffb36 	bltu	r21,r2,1803180 <__ram_exceptions_end+0xff7f2d3c>
 1803194:	84800415 	stw	r18,16(r16)
 1803198:	b80b883a 	mov	r5,r23
 180319c:	8009883a 	mov	r4,r16
 18031a0:	1806bc40 	call	1806bc4 <__mcmp>
 18031a4:	10002616 	blt	r2,zero,1803240 <quorem+0x1c8>
 18031a8:	9cc00044 	addi	r19,r19,1
 18031ac:	a805883a 	mov	r2,r21
 18031b0:	000b883a 	mov	r5,zero
 18031b4:	11000017 	ldw	r4,0(r2)
 18031b8:	89800017 	ldw	r6,0(r17)
 18031bc:	10800104 	addi	r2,r2,4
 18031c0:	20ffffcc 	andi	r3,r4,65535
 18031c4:	194b883a 	add	r5,r3,r5
 18031c8:	30ffffcc 	andi	r3,r6,65535
 18031cc:	28c7c83a 	sub	r3,r5,r3
 18031d0:	300cd43a 	srli	r6,r6,16
 18031d4:	2008d43a 	srli	r4,r4,16
 18031d8:	180bd43a 	srai	r5,r3,16
 18031dc:	18ffffcc 	andi	r3,r3,65535
 18031e0:	2189c83a 	sub	r4,r4,r6
 18031e4:	2149883a 	add	r4,r4,r5
 18031e8:	200c943a 	slli	r6,r4,16
 18031ec:	8c400104 	addi	r17,r17,4
 18031f0:	200bd43a 	srai	r5,r4,16
 18031f4:	30c6b03a 	or	r3,r6,r3
 18031f8:	10ffff15 	stw	r3,-4(r2)
 18031fc:	a47fed2e 	bgeu	r20,r17,18031b4 <__ram_exceptions_end+0xff7f2d70>
 1803200:	9485883a 	add	r2,r18,r18
 1803204:	1085883a 	add	r2,r2,r2
 1803208:	a887883a 	add	r3,r21,r2
 180320c:	18800017 	ldw	r2,0(r3)
 1803210:	10000b1e 	bne	r2,zero,1803240 <quorem+0x1c8>
 1803214:	18bfff04 	addi	r2,r3,-4
 1803218:	a880082e 	bgeu	r21,r2,180323c <quorem+0x1c4>
 180321c:	18ffff17 	ldw	r3,-4(r3)
 1803220:	18000326 	beq	r3,zero,1803230 <quorem+0x1b8>
 1803224:	00000506 	br	180323c <quorem+0x1c4>
 1803228:	10c00017 	ldw	r3,0(r2)
 180322c:	1800031e 	bne	r3,zero,180323c <quorem+0x1c4>
 1803230:	10bfff04 	addi	r2,r2,-4
 1803234:	94bfffc4 	addi	r18,r18,-1
 1803238:	a8bffb36 	bltu	r21,r2,1803228 <__ram_exceptions_end+0xff7f2de4>
 180323c:	84800415 	stw	r18,16(r16)
 1803240:	9805883a 	mov	r2,r19
 1803244:	dfc00817 	ldw	ra,32(sp)
 1803248:	ddc00717 	ldw	r23,28(sp)
 180324c:	dd800617 	ldw	r22,24(sp)
 1803250:	dd400517 	ldw	r21,20(sp)
 1803254:	dd000417 	ldw	r20,16(sp)
 1803258:	dcc00317 	ldw	r19,12(sp)
 180325c:	dc800217 	ldw	r18,8(sp)
 1803260:	dc400117 	ldw	r17,4(sp)
 1803264:	dc000017 	ldw	r16,0(sp)
 1803268:	dec00904 	addi	sp,sp,36
 180326c:	f800283a 	ret
 1803270:	0005883a 	mov	r2,zero
 1803274:	003ff306 	br	1803244 <__ram_exceptions_end+0xff7f2e00>

01803278 <_dtoa_r>:
 1803278:	20801017 	ldw	r2,64(r4)
 180327c:	deffde04 	addi	sp,sp,-136
 1803280:	df002015 	stw	fp,128(sp)
 1803284:	dcc01b15 	stw	r19,108(sp)
 1803288:	dc801a15 	stw	r18,104(sp)
 180328c:	dc401915 	stw	r17,100(sp)
 1803290:	dc001815 	stw	r16,96(sp)
 1803294:	dfc02115 	stw	ra,132(sp)
 1803298:	ddc01f15 	stw	r23,124(sp)
 180329c:	dd801e15 	stw	r22,120(sp)
 18032a0:	dd401d15 	stw	r21,116(sp)
 18032a4:	dd001c15 	stw	r20,112(sp)
 18032a8:	d9c00315 	stw	r7,12(sp)
 18032ac:	2039883a 	mov	fp,r4
 18032b0:	3023883a 	mov	r17,r6
 18032b4:	2825883a 	mov	r18,r5
 18032b8:	dc002417 	ldw	r16,144(sp)
 18032bc:	3027883a 	mov	r19,r6
 18032c0:	10000826 	beq	r2,zero,18032e4 <_dtoa_r+0x6c>
 18032c4:	21801117 	ldw	r6,68(r4)
 18032c8:	00c00044 	movi	r3,1
 18032cc:	100b883a 	mov	r5,r2
 18032d0:	1986983a 	sll	r3,r3,r6
 18032d4:	11800115 	stw	r6,4(r2)
 18032d8:	10c00215 	stw	r3,8(r2)
 18032dc:	18063a40 	call	18063a4 <_Bfree>
 18032e0:	e0001015 	stw	zero,64(fp)
 18032e4:	88002e16 	blt	r17,zero,18033a0 <_dtoa_r+0x128>
 18032e8:	80000015 	stw	zero,0(r16)
 18032ec:	889ffc2c 	andhi	r2,r17,32752
 18032f0:	00dffc34 	movhi	r3,32752
 18032f4:	10c01c26 	beq	r2,r3,1803368 <_dtoa_r+0xf0>
 18032f8:	000d883a 	mov	r6,zero
 18032fc:	000f883a 	mov	r7,zero
 1803300:	9009883a 	mov	r4,r18
 1803304:	980b883a 	mov	r5,r19
 1803308:	180bf600 	call	180bf60 <__eqdf2>
 180330c:	10002b1e 	bne	r2,zero,18033bc <_dtoa_r+0x144>
 1803310:	d9c02317 	ldw	r7,140(sp)
 1803314:	00800044 	movi	r2,1
 1803318:	38800015 	stw	r2,0(r7)
 180331c:	d8802517 	ldw	r2,148(sp)
 1803320:	10019e26 	beq	r2,zero,180399c <_dtoa_r+0x724>
 1803324:	d8c02517 	ldw	r3,148(sp)
 1803328:	00806134 	movhi	r2,388
 180332c:	1084ed44 	addi	r2,r2,5045
 1803330:	18800015 	stw	r2,0(r3)
 1803334:	10bfffc4 	addi	r2,r2,-1
 1803338:	dfc02117 	ldw	ra,132(sp)
 180333c:	df002017 	ldw	fp,128(sp)
 1803340:	ddc01f17 	ldw	r23,124(sp)
 1803344:	dd801e17 	ldw	r22,120(sp)
 1803348:	dd401d17 	ldw	r21,116(sp)
 180334c:	dd001c17 	ldw	r20,112(sp)
 1803350:	dcc01b17 	ldw	r19,108(sp)
 1803354:	dc801a17 	ldw	r18,104(sp)
 1803358:	dc401917 	ldw	r17,100(sp)
 180335c:	dc001817 	ldw	r16,96(sp)
 1803360:	dec02204 	addi	sp,sp,136
 1803364:	f800283a 	ret
 1803368:	d8c02317 	ldw	r3,140(sp)
 180336c:	0089c3c4 	movi	r2,9999
 1803370:	18800015 	stw	r2,0(r3)
 1803374:	90017726 	beq	r18,zero,1803954 <_dtoa_r+0x6dc>
 1803378:	00806134 	movhi	r2,388
 180337c:	1084f904 	addi	r2,r2,5092
 1803380:	d9002517 	ldw	r4,148(sp)
 1803384:	203fec26 	beq	r4,zero,1803338 <__ram_exceptions_end+0xff7f2ef4>
 1803388:	10c000c7 	ldb	r3,3(r2)
 180338c:	1801781e 	bne	r3,zero,1803970 <_dtoa_r+0x6f8>
 1803390:	10c000c4 	addi	r3,r2,3
 1803394:	d9802517 	ldw	r6,148(sp)
 1803398:	30c00015 	stw	r3,0(r6)
 180339c:	003fe606 	br	1803338 <__ram_exceptions_end+0xff7f2ef4>
 18033a0:	04e00034 	movhi	r19,32768
 18033a4:	9cffffc4 	addi	r19,r19,-1
 18033a8:	00800044 	movi	r2,1
 18033ac:	8ce6703a 	and	r19,r17,r19
 18033b0:	80800015 	stw	r2,0(r16)
 18033b4:	9823883a 	mov	r17,r19
 18033b8:	003fcc06 	br	18032ec <__ram_exceptions_end+0xff7f2ea8>
 18033bc:	d8800204 	addi	r2,sp,8
 18033c0:	d8800015 	stw	r2,0(sp)
 18033c4:	d9c00104 	addi	r7,sp,4
 18033c8:	900b883a 	mov	r5,r18
 18033cc:	980d883a 	mov	r6,r19
 18033d0:	e009883a 	mov	r4,fp
 18033d4:	8820d53a 	srli	r16,r17,20
 18033d8:	1806f900 	call	1806f90 <__d2b>
 18033dc:	d8800915 	stw	r2,36(sp)
 18033e0:	8001651e 	bne	r16,zero,1803978 <_dtoa_r+0x700>
 18033e4:	dd800217 	ldw	r22,8(sp)
 18033e8:	dc000117 	ldw	r16,4(sp)
 18033ec:	00800804 	movi	r2,32
 18033f0:	b421883a 	add	r16,r22,r16
 18033f4:	80c10c84 	addi	r3,r16,1074
 18033f8:	10c2d10e 	bge	r2,r3,1803f40 <_dtoa_r+0xcc8>
 18033fc:	00801004 	movi	r2,64
 1803400:	81010484 	addi	r4,r16,1042
 1803404:	10c7c83a 	sub	r3,r2,r3
 1803408:	9108d83a 	srl	r4,r18,r4
 180340c:	88e2983a 	sll	r17,r17,r3
 1803410:	2448b03a 	or	r4,r4,r17
 1803414:	180d3280 	call	180d328 <__floatunsidf>
 1803418:	017f8434 	movhi	r5,65040
 180341c:	01800044 	movi	r6,1
 1803420:	1009883a 	mov	r4,r2
 1803424:	194b883a 	add	r5,r3,r5
 1803428:	843fffc4 	addi	r16,r16,-1
 180342c:	d9801115 	stw	r6,68(sp)
 1803430:	000d883a 	mov	r6,zero
 1803434:	01cffe34 	movhi	r7,16376
 1803438:	180c8d00 	call	180c8d0 <__subdf3>
 180343c:	0198dbf4 	movhi	r6,25455
 1803440:	01cff4f4 	movhi	r7,16339
 1803444:	3190d844 	addi	r6,r6,17249
 1803448:	39e1e9c4 	addi	r7,r7,-30809
 180344c:	1009883a 	mov	r4,r2
 1803450:	180b883a 	mov	r5,r3
 1803454:	180c1b80 	call	180c1b8 <__muldf3>
 1803458:	01a2d874 	movhi	r6,35681
 180345c:	01cff1f4 	movhi	r7,16327
 1803460:	31b22cc4 	addi	r6,r6,-14157
 1803464:	39e28a04 	addi	r7,r7,-30168
 1803468:	180b883a 	mov	r5,r3
 180346c:	1009883a 	mov	r4,r2
 1803470:	180adcc0 	call	180adcc <__adddf3>
 1803474:	8009883a 	mov	r4,r16
 1803478:	1029883a 	mov	r20,r2
 180347c:	1823883a 	mov	r17,r3
 1803480:	180d24c0 	call	180d24c <__floatsidf>
 1803484:	019427f4 	movhi	r6,20639
 1803488:	01cff4f4 	movhi	r7,16339
 180348c:	319e7ec4 	addi	r6,r6,31227
 1803490:	39d104c4 	addi	r7,r7,17427
 1803494:	1009883a 	mov	r4,r2
 1803498:	180b883a 	mov	r5,r3
 180349c:	180c1b80 	call	180c1b8 <__muldf3>
 18034a0:	100d883a 	mov	r6,r2
 18034a4:	180f883a 	mov	r7,r3
 18034a8:	a009883a 	mov	r4,r20
 18034ac:	880b883a 	mov	r5,r17
 18034b0:	180adcc0 	call	180adcc <__adddf3>
 18034b4:	1009883a 	mov	r4,r2
 18034b8:	180b883a 	mov	r5,r3
 18034bc:	1029883a 	mov	r20,r2
 18034c0:	1823883a 	mov	r17,r3
 18034c4:	180d1cc0 	call	180d1cc <__fixdfsi>
 18034c8:	000d883a 	mov	r6,zero
 18034cc:	000f883a 	mov	r7,zero
 18034d0:	a009883a 	mov	r4,r20
 18034d4:	880b883a 	mov	r5,r17
 18034d8:	d8800515 	stw	r2,20(sp)
 18034dc:	180c0c40 	call	180c0c4 <__ledf2>
 18034e0:	10028716 	blt	r2,zero,1803f00 <_dtoa_r+0xc88>
 18034e4:	d8c00517 	ldw	r3,20(sp)
 18034e8:	00800584 	movi	r2,22
 18034ec:	10c27536 	bltu	r2,r3,1803ec4 <_dtoa_r+0xc4c>
 18034f0:	180490fa 	slli	r2,r3,3
 18034f4:	00c06134 	movhi	r3,388
 18034f8:	18c51504 	addi	r3,r3,5204
 18034fc:	1885883a 	add	r2,r3,r2
 1803500:	11000017 	ldw	r4,0(r2)
 1803504:	11400117 	ldw	r5,4(r2)
 1803508:	900d883a 	mov	r6,r18
 180350c:	980f883a 	mov	r7,r19
 1803510:	180bfe80 	call	180bfe8 <__gedf2>
 1803514:	00828d0e 	bge	zero,r2,1803f4c <_dtoa_r+0xcd4>
 1803518:	d9000517 	ldw	r4,20(sp)
 180351c:	d8000e15 	stw	zero,56(sp)
 1803520:	213fffc4 	addi	r4,r4,-1
 1803524:	d9000515 	stw	r4,20(sp)
 1803528:	b42dc83a 	sub	r22,r22,r16
 180352c:	b5bfffc4 	addi	r22,r22,-1
 1803530:	b0026f16 	blt	r22,zero,1803ef0 <_dtoa_r+0xc78>
 1803534:	d8000815 	stw	zero,32(sp)
 1803538:	d9c00517 	ldw	r7,20(sp)
 180353c:	38026416 	blt	r7,zero,1803ed0 <_dtoa_r+0xc58>
 1803540:	b1ed883a 	add	r22,r22,r7
 1803544:	d9c00d15 	stw	r7,52(sp)
 1803548:	d8000a15 	stw	zero,40(sp)
 180354c:	d9800317 	ldw	r6,12(sp)
 1803550:	00800244 	movi	r2,9
 1803554:	11811436 	bltu	r2,r6,18039a8 <_dtoa_r+0x730>
 1803558:	00800144 	movi	r2,5
 180355c:	1184e10e 	bge	r2,r6,18048e4 <_dtoa_r+0x166c>
 1803560:	31bfff04 	addi	r6,r6,-4
 1803564:	d9800315 	stw	r6,12(sp)
 1803568:	0023883a 	mov	r17,zero
 180356c:	d9800317 	ldw	r6,12(sp)
 1803570:	008000c4 	movi	r2,3
 1803574:	30836726 	beq	r6,r2,1804314 <_dtoa_r+0x109c>
 1803578:	1183410e 	bge	r2,r6,1804280 <_dtoa_r+0x1008>
 180357c:	d9c00317 	ldw	r7,12(sp)
 1803580:	00800104 	movi	r2,4
 1803584:	38827c26 	beq	r7,r2,1803f78 <_dtoa_r+0xd00>
 1803588:	00800144 	movi	r2,5
 180358c:	3884c41e 	bne	r7,r2,18048a0 <_dtoa_r+0x1628>
 1803590:	00800044 	movi	r2,1
 1803594:	d8800b15 	stw	r2,44(sp)
 1803598:	d8c00517 	ldw	r3,20(sp)
 180359c:	d9002217 	ldw	r4,136(sp)
 18035a0:	1907883a 	add	r3,r3,r4
 18035a4:	19800044 	addi	r6,r3,1
 18035a8:	d8c00c15 	stw	r3,48(sp)
 18035ac:	d9800615 	stw	r6,24(sp)
 18035b0:	0183a40e 	bge	zero,r6,1804444 <_dtoa_r+0x11cc>
 18035b4:	d9800617 	ldw	r6,24(sp)
 18035b8:	3021883a 	mov	r16,r6
 18035bc:	e0001115 	stw	zero,68(fp)
 18035c0:	008005c4 	movi	r2,23
 18035c4:	1184c92e 	bgeu	r2,r6,18048ec <_dtoa_r+0x1674>
 18035c8:	00c00044 	movi	r3,1
 18035cc:	00800104 	movi	r2,4
 18035d0:	1085883a 	add	r2,r2,r2
 18035d4:	11000504 	addi	r4,r2,20
 18035d8:	180b883a 	mov	r5,r3
 18035dc:	18c00044 	addi	r3,r3,1
 18035e0:	313ffb2e 	bgeu	r6,r4,18035d0 <__ram_exceptions_end+0xff7f318c>
 18035e4:	e1401115 	stw	r5,68(fp)
 18035e8:	e009883a 	mov	r4,fp
 18035ec:	18062fc0 	call	18062fc <_Balloc>
 18035f0:	d8800715 	stw	r2,28(sp)
 18035f4:	e0801015 	stw	r2,64(fp)
 18035f8:	00800384 	movi	r2,14
 18035fc:	1400f736 	bltu	r2,r16,18039dc <_dtoa_r+0x764>
 1803600:	8800f626 	beq	r17,zero,18039dc <_dtoa_r+0x764>
 1803604:	d9c00517 	ldw	r7,20(sp)
 1803608:	01c39a0e 	bge	zero,r7,1804474 <_dtoa_r+0x11fc>
 180360c:	388003cc 	andi	r2,r7,15
 1803610:	100490fa 	slli	r2,r2,3
 1803614:	382bd13a 	srai	r21,r7,4
 1803618:	00c06134 	movhi	r3,388
 180361c:	18c51504 	addi	r3,r3,5204
 1803620:	1885883a 	add	r2,r3,r2
 1803624:	a8c0040c 	andi	r3,r21,16
 1803628:	12400017 	ldw	r9,0(r2)
 180362c:	12000117 	ldw	r8,4(r2)
 1803630:	18037926 	beq	r3,zero,1804418 <_dtoa_r+0x11a0>
 1803634:	00806134 	movhi	r2,388
 1803638:	10850b04 	addi	r2,r2,5164
 180363c:	11800817 	ldw	r6,32(r2)
 1803640:	11c00917 	ldw	r7,36(r2)
 1803644:	9009883a 	mov	r4,r18
 1803648:	980b883a 	mov	r5,r19
 180364c:	da001715 	stw	r8,92(sp)
 1803650:	da401615 	stw	r9,88(sp)
 1803654:	180b6780 	call	180b678 <__divdf3>
 1803658:	da001717 	ldw	r8,92(sp)
 180365c:	da401617 	ldw	r9,88(sp)
 1803660:	ad4003cc 	andi	r21,r21,15
 1803664:	040000c4 	movi	r16,3
 1803668:	1023883a 	mov	r17,r2
 180366c:	1829883a 	mov	r20,r3
 1803670:	a8001126 	beq	r21,zero,18036b8 <_dtoa_r+0x440>
 1803674:	05c06134 	movhi	r23,388
 1803678:	bdc50b04 	addi	r23,r23,5164
 180367c:	4805883a 	mov	r2,r9
 1803680:	4007883a 	mov	r3,r8
 1803684:	a980004c 	andi	r6,r21,1
 1803688:	1009883a 	mov	r4,r2
 180368c:	a82bd07a 	srai	r21,r21,1
 1803690:	180b883a 	mov	r5,r3
 1803694:	30000426 	beq	r6,zero,18036a8 <_dtoa_r+0x430>
 1803698:	b9800017 	ldw	r6,0(r23)
 180369c:	b9c00117 	ldw	r7,4(r23)
 18036a0:	84000044 	addi	r16,r16,1
 18036a4:	180c1b80 	call	180c1b8 <__muldf3>
 18036a8:	bdc00204 	addi	r23,r23,8
 18036ac:	a83ff51e 	bne	r21,zero,1803684 <__ram_exceptions_end+0xff7f3240>
 18036b0:	1013883a 	mov	r9,r2
 18036b4:	1811883a 	mov	r8,r3
 18036b8:	480d883a 	mov	r6,r9
 18036bc:	400f883a 	mov	r7,r8
 18036c0:	8809883a 	mov	r4,r17
 18036c4:	a00b883a 	mov	r5,r20
 18036c8:	180b6780 	call	180b678 <__divdf3>
 18036cc:	d8800f15 	stw	r2,60(sp)
 18036d0:	d8c01015 	stw	r3,64(sp)
 18036d4:	d8c00e17 	ldw	r3,56(sp)
 18036d8:	18000626 	beq	r3,zero,18036f4 <_dtoa_r+0x47c>
 18036dc:	d9000f17 	ldw	r4,60(sp)
 18036e0:	d9401017 	ldw	r5,64(sp)
 18036e4:	000d883a 	mov	r6,zero
 18036e8:	01cffc34 	movhi	r7,16368
 18036ec:	180c0c40 	call	180c0c4 <__ledf2>
 18036f0:	10040b16 	blt	r2,zero,1804720 <_dtoa_r+0x14a8>
 18036f4:	8009883a 	mov	r4,r16
 18036f8:	180d24c0 	call	180d24c <__floatsidf>
 18036fc:	d9800f17 	ldw	r6,60(sp)
 1803700:	d9c01017 	ldw	r7,64(sp)
 1803704:	1009883a 	mov	r4,r2
 1803708:	180b883a 	mov	r5,r3
 180370c:	180c1b80 	call	180c1b8 <__muldf3>
 1803710:	000d883a 	mov	r6,zero
 1803714:	01d00734 	movhi	r7,16412
 1803718:	1009883a 	mov	r4,r2
 180371c:	180b883a 	mov	r5,r3
 1803720:	180adcc0 	call	180adcc <__adddf3>
 1803724:	1021883a 	mov	r16,r2
 1803728:	d8800617 	ldw	r2,24(sp)
 180372c:	047f3034 	movhi	r17,64704
 1803730:	1c63883a 	add	r17,r3,r17
 1803734:	10031826 	beq	r2,zero,1804398 <_dtoa_r+0x1120>
 1803738:	d8c00517 	ldw	r3,20(sp)
 180373c:	db000617 	ldw	r12,24(sp)
 1803740:	d8c01315 	stw	r3,76(sp)
 1803744:	d9000b17 	ldw	r4,44(sp)
 1803748:	20038f26 	beq	r4,zero,1804588 <_dtoa_r+0x1310>
 180374c:	60bfffc4 	addi	r2,r12,-1
 1803750:	100490fa 	slli	r2,r2,3
 1803754:	00c06134 	movhi	r3,388
 1803758:	18c51504 	addi	r3,r3,5204
 180375c:	1885883a 	add	r2,r3,r2
 1803760:	11800017 	ldw	r6,0(r2)
 1803764:	11c00117 	ldw	r7,4(r2)
 1803768:	d8800717 	ldw	r2,28(sp)
 180376c:	0009883a 	mov	r4,zero
 1803770:	014ff834 	movhi	r5,16352
 1803774:	db001615 	stw	r12,88(sp)
 1803778:	15c00044 	addi	r23,r2,1
 180377c:	180b6780 	call	180b678 <__divdf3>
 1803780:	800d883a 	mov	r6,r16
 1803784:	880f883a 	mov	r7,r17
 1803788:	1009883a 	mov	r4,r2
 180378c:	180b883a 	mov	r5,r3
 1803790:	180c8d00 	call	180c8d0 <__subdf3>
 1803794:	d9401017 	ldw	r5,64(sp)
 1803798:	d9000f17 	ldw	r4,60(sp)
 180379c:	102b883a 	mov	r21,r2
 18037a0:	d8c01215 	stw	r3,72(sp)
 18037a4:	180d1cc0 	call	180d1cc <__fixdfsi>
 18037a8:	1009883a 	mov	r4,r2
 18037ac:	1029883a 	mov	r20,r2
 18037b0:	180d24c0 	call	180d24c <__floatsidf>
 18037b4:	d9000f17 	ldw	r4,60(sp)
 18037b8:	d9401017 	ldw	r5,64(sp)
 18037bc:	100d883a 	mov	r6,r2
 18037c0:	180f883a 	mov	r7,r3
 18037c4:	180c8d00 	call	180c8d0 <__subdf3>
 18037c8:	1823883a 	mov	r17,r3
 18037cc:	d8c00717 	ldw	r3,28(sp)
 18037d0:	d9401217 	ldw	r5,72(sp)
 18037d4:	a2000c04 	addi	r8,r20,48
 18037d8:	1021883a 	mov	r16,r2
 18037dc:	1a000005 	stb	r8,0(r3)
 18037e0:	800d883a 	mov	r6,r16
 18037e4:	880f883a 	mov	r7,r17
 18037e8:	a809883a 	mov	r4,r21
 18037ec:	4029883a 	mov	r20,r8
 18037f0:	180bfe80 	call	180bfe8 <__gedf2>
 18037f4:	00841d16 	blt	zero,r2,180486c <_dtoa_r+0x15f4>
 18037f8:	800d883a 	mov	r6,r16
 18037fc:	880f883a 	mov	r7,r17
 1803800:	0009883a 	mov	r4,zero
 1803804:	014ffc34 	movhi	r5,16368
 1803808:	180c8d00 	call	180c8d0 <__subdf3>
 180380c:	d9401217 	ldw	r5,72(sp)
 1803810:	100d883a 	mov	r6,r2
 1803814:	180f883a 	mov	r7,r3
 1803818:	a809883a 	mov	r4,r21
 180381c:	180bfe80 	call	180bfe8 <__gedf2>
 1803820:	db001617 	ldw	r12,88(sp)
 1803824:	00840e16 	blt	zero,r2,1804860 <_dtoa_r+0x15e8>
 1803828:	00800044 	movi	r2,1
 180382c:	13006b0e 	bge	r2,r12,18039dc <_dtoa_r+0x764>
 1803830:	d9000717 	ldw	r4,28(sp)
 1803834:	dd800f15 	stw	r22,60(sp)
 1803838:	dcc01015 	stw	r19,64(sp)
 180383c:	2319883a 	add	r12,r4,r12
 1803840:	dcc01217 	ldw	r19,72(sp)
 1803844:	602d883a 	mov	r22,r12
 1803848:	dc801215 	stw	r18,72(sp)
 180384c:	b825883a 	mov	r18,r23
 1803850:	00000906 	br	1803878 <_dtoa_r+0x600>
 1803854:	180c8d00 	call	180c8d0 <__subdf3>
 1803858:	a80d883a 	mov	r6,r21
 180385c:	980f883a 	mov	r7,r19
 1803860:	1009883a 	mov	r4,r2
 1803864:	180b883a 	mov	r5,r3
 1803868:	180c0c40 	call	180c0c4 <__ledf2>
 180386c:	1003e816 	blt	r2,zero,1804810 <_dtoa_r+0x1598>
 1803870:	b825883a 	mov	r18,r23
 1803874:	bd83e926 	beq	r23,r22,180481c <_dtoa_r+0x15a4>
 1803878:	a809883a 	mov	r4,r21
 180387c:	980b883a 	mov	r5,r19
 1803880:	000d883a 	mov	r6,zero
 1803884:	01d00934 	movhi	r7,16420
 1803888:	180c1b80 	call	180c1b8 <__muldf3>
 180388c:	000d883a 	mov	r6,zero
 1803890:	01d00934 	movhi	r7,16420
 1803894:	8009883a 	mov	r4,r16
 1803898:	880b883a 	mov	r5,r17
 180389c:	102b883a 	mov	r21,r2
 18038a0:	1827883a 	mov	r19,r3
 18038a4:	180c1b80 	call	180c1b8 <__muldf3>
 18038a8:	180b883a 	mov	r5,r3
 18038ac:	1009883a 	mov	r4,r2
 18038b0:	1821883a 	mov	r16,r3
 18038b4:	1023883a 	mov	r17,r2
 18038b8:	180d1cc0 	call	180d1cc <__fixdfsi>
 18038bc:	1009883a 	mov	r4,r2
 18038c0:	1029883a 	mov	r20,r2
 18038c4:	180d24c0 	call	180d24c <__floatsidf>
 18038c8:	8809883a 	mov	r4,r17
 18038cc:	800b883a 	mov	r5,r16
 18038d0:	100d883a 	mov	r6,r2
 18038d4:	180f883a 	mov	r7,r3
 18038d8:	180c8d00 	call	180c8d0 <__subdf3>
 18038dc:	a5000c04 	addi	r20,r20,48
 18038e0:	a80d883a 	mov	r6,r21
 18038e4:	980f883a 	mov	r7,r19
 18038e8:	1009883a 	mov	r4,r2
 18038ec:	180b883a 	mov	r5,r3
 18038f0:	95000005 	stb	r20,0(r18)
 18038f4:	1021883a 	mov	r16,r2
 18038f8:	1823883a 	mov	r17,r3
 18038fc:	180c0c40 	call	180c0c4 <__ledf2>
 1803900:	bdc00044 	addi	r23,r23,1
 1803904:	800d883a 	mov	r6,r16
 1803908:	880f883a 	mov	r7,r17
 180390c:	0009883a 	mov	r4,zero
 1803910:	014ffc34 	movhi	r5,16368
 1803914:	103fcf0e 	bge	r2,zero,1803854 <__ram_exceptions_end+0xff7f3410>
 1803918:	d8c01317 	ldw	r3,76(sp)
 180391c:	d8c00515 	stw	r3,20(sp)
 1803920:	d9400917 	ldw	r5,36(sp)
 1803924:	e009883a 	mov	r4,fp
 1803928:	18063a40 	call	18063a4 <_Bfree>
 180392c:	d9000517 	ldw	r4,20(sp)
 1803930:	d9802317 	ldw	r6,140(sp)
 1803934:	d9c02517 	ldw	r7,148(sp)
 1803938:	b8000005 	stb	zero,0(r23)
 180393c:	20800044 	addi	r2,r4,1
 1803940:	30800015 	stw	r2,0(r6)
 1803944:	3802aa26 	beq	r7,zero,18043f0 <_dtoa_r+0x1178>
 1803948:	3dc00015 	stw	r23,0(r7)
 180394c:	d8800717 	ldw	r2,28(sp)
 1803950:	003e7906 	br	1803338 <__ram_exceptions_end+0xff7f2ef4>
 1803954:	00800434 	movhi	r2,16
 1803958:	10bfffc4 	addi	r2,r2,-1
 180395c:	88a2703a 	and	r17,r17,r2
 1803960:	883e851e 	bne	r17,zero,1803378 <__ram_exceptions_end+0xff7f2f34>
 1803964:	00806134 	movhi	r2,388
 1803968:	1084f604 	addi	r2,r2,5080
 180396c:	003e8406 	br	1803380 <__ram_exceptions_end+0xff7f2f3c>
 1803970:	10c00204 	addi	r3,r2,8
 1803974:	003e8706 	br	1803394 <__ram_exceptions_end+0xff7f2f50>
 1803978:	01400434 	movhi	r5,16
 180397c:	297fffc4 	addi	r5,r5,-1
 1803980:	994a703a 	and	r5,r19,r5
 1803984:	9009883a 	mov	r4,r18
 1803988:	843f0044 	addi	r16,r16,-1023
 180398c:	294ffc34 	orhi	r5,r5,16368
 1803990:	dd800217 	ldw	r22,8(sp)
 1803994:	d8001115 	stw	zero,68(sp)
 1803998:	003ea506 	br	1803430 <__ram_exceptions_end+0xff7f2fec>
 180399c:	00806134 	movhi	r2,388
 18039a0:	1084ed04 	addi	r2,r2,5044
 18039a4:	003e6406 	br	1803338 <__ram_exceptions_end+0xff7f2ef4>
 18039a8:	e0001115 	stw	zero,68(fp)
 18039ac:	000b883a 	mov	r5,zero
 18039b0:	e009883a 	mov	r4,fp
 18039b4:	18062fc0 	call	18062fc <_Balloc>
 18039b8:	01bfffc4 	movi	r6,-1
 18039bc:	01c00044 	movi	r7,1
 18039c0:	d8800715 	stw	r2,28(sp)
 18039c4:	d9800c15 	stw	r6,48(sp)
 18039c8:	e0801015 	stw	r2,64(fp)
 18039cc:	d8000315 	stw	zero,12(sp)
 18039d0:	d9c00b15 	stw	r7,44(sp)
 18039d4:	d9800615 	stw	r6,24(sp)
 18039d8:	d8002215 	stw	zero,136(sp)
 18039dc:	d8800117 	ldw	r2,4(sp)
 18039e0:	10008916 	blt	r2,zero,1803c08 <_dtoa_r+0x990>
 18039e4:	d9000517 	ldw	r4,20(sp)
 18039e8:	00c00384 	movi	r3,14
 18039ec:	19008616 	blt	r3,r4,1803c08 <_dtoa_r+0x990>
 18039f0:	200490fa 	slli	r2,r4,3
 18039f4:	00c06134 	movhi	r3,388
 18039f8:	d9802217 	ldw	r6,136(sp)
 18039fc:	18c51504 	addi	r3,r3,5204
 1803a00:	1885883a 	add	r2,r3,r2
 1803a04:	14000017 	ldw	r16,0(r2)
 1803a08:	14400117 	ldw	r17,4(r2)
 1803a0c:	30016316 	blt	r6,zero,1803f9c <_dtoa_r+0xd24>
 1803a10:	800d883a 	mov	r6,r16
 1803a14:	880f883a 	mov	r7,r17
 1803a18:	9009883a 	mov	r4,r18
 1803a1c:	980b883a 	mov	r5,r19
 1803a20:	180b6780 	call	180b678 <__divdf3>
 1803a24:	180b883a 	mov	r5,r3
 1803a28:	1009883a 	mov	r4,r2
 1803a2c:	180d1cc0 	call	180d1cc <__fixdfsi>
 1803a30:	1009883a 	mov	r4,r2
 1803a34:	102b883a 	mov	r21,r2
 1803a38:	180d24c0 	call	180d24c <__floatsidf>
 1803a3c:	800d883a 	mov	r6,r16
 1803a40:	880f883a 	mov	r7,r17
 1803a44:	1009883a 	mov	r4,r2
 1803a48:	180b883a 	mov	r5,r3
 1803a4c:	180c1b80 	call	180c1b8 <__muldf3>
 1803a50:	100d883a 	mov	r6,r2
 1803a54:	180f883a 	mov	r7,r3
 1803a58:	9009883a 	mov	r4,r18
 1803a5c:	980b883a 	mov	r5,r19
 1803a60:	180c8d00 	call	180c8d0 <__subdf3>
 1803a64:	d9c00717 	ldw	r7,28(sp)
 1803a68:	1009883a 	mov	r4,r2
 1803a6c:	a8800c04 	addi	r2,r21,48
 1803a70:	38800005 	stb	r2,0(r7)
 1803a74:	3dc00044 	addi	r23,r7,1
 1803a78:	d9c00617 	ldw	r7,24(sp)
 1803a7c:	01800044 	movi	r6,1
 1803a80:	180b883a 	mov	r5,r3
 1803a84:	2005883a 	mov	r2,r4
 1803a88:	39803826 	beq	r7,r6,1803b6c <_dtoa_r+0x8f4>
 1803a8c:	000d883a 	mov	r6,zero
 1803a90:	01d00934 	movhi	r7,16420
 1803a94:	180c1b80 	call	180c1b8 <__muldf3>
 1803a98:	000d883a 	mov	r6,zero
 1803a9c:	000f883a 	mov	r7,zero
 1803aa0:	1009883a 	mov	r4,r2
 1803aa4:	180b883a 	mov	r5,r3
 1803aa8:	1025883a 	mov	r18,r2
 1803aac:	1827883a 	mov	r19,r3
 1803ab0:	180bf600 	call	180bf60 <__eqdf2>
 1803ab4:	103f9a26 	beq	r2,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803ab8:	d9c00617 	ldw	r7,24(sp)
 1803abc:	d8c00717 	ldw	r3,28(sp)
 1803ac0:	b829883a 	mov	r20,r23
 1803ac4:	38bfffc4 	addi	r2,r7,-1
 1803ac8:	18ad883a 	add	r22,r3,r2
 1803acc:	00000a06 	br	1803af8 <_dtoa_r+0x880>
 1803ad0:	180c1b80 	call	180c1b8 <__muldf3>
 1803ad4:	000d883a 	mov	r6,zero
 1803ad8:	000f883a 	mov	r7,zero
 1803adc:	1009883a 	mov	r4,r2
 1803ae0:	180b883a 	mov	r5,r3
 1803ae4:	1025883a 	mov	r18,r2
 1803ae8:	1827883a 	mov	r19,r3
 1803aec:	b829883a 	mov	r20,r23
 1803af0:	180bf600 	call	180bf60 <__eqdf2>
 1803af4:	103f8a26 	beq	r2,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803af8:	800d883a 	mov	r6,r16
 1803afc:	880f883a 	mov	r7,r17
 1803b00:	9009883a 	mov	r4,r18
 1803b04:	980b883a 	mov	r5,r19
 1803b08:	180b6780 	call	180b678 <__divdf3>
 1803b0c:	180b883a 	mov	r5,r3
 1803b10:	1009883a 	mov	r4,r2
 1803b14:	180d1cc0 	call	180d1cc <__fixdfsi>
 1803b18:	1009883a 	mov	r4,r2
 1803b1c:	102b883a 	mov	r21,r2
 1803b20:	180d24c0 	call	180d24c <__floatsidf>
 1803b24:	800d883a 	mov	r6,r16
 1803b28:	880f883a 	mov	r7,r17
 1803b2c:	1009883a 	mov	r4,r2
 1803b30:	180b883a 	mov	r5,r3
 1803b34:	180c1b80 	call	180c1b8 <__muldf3>
 1803b38:	100d883a 	mov	r6,r2
 1803b3c:	180f883a 	mov	r7,r3
 1803b40:	9009883a 	mov	r4,r18
 1803b44:	980b883a 	mov	r5,r19
 1803b48:	180c8d00 	call	180c8d0 <__subdf3>
 1803b4c:	aa000c04 	addi	r8,r21,48
 1803b50:	a2000005 	stb	r8,0(r20)
 1803b54:	000d883a 	mov	r6,zero
 1803b58:	01d00934 	movhi	r7,16420
 1803b5c:	1009883a 	mov	r4,r2
 1803b60:	180b883a 	mov	r5,r3
 1803b64:	a5c00044 	addi	r23,r20,1
 1803b68:	b53fd91e 	bne	r22,r20,1803ad0 <__ram_exceptions_end+0xff7f368c>
 1803b6c:	100d883a 	mov	r6,r2
 1803b70:	180f883a 	mov	r7,r3
 1803b74:	1009883a 	mov	r4,r2
 1803b78:	180b883a 	mov	r5,r3
 1803b7c:	180adcc0 	call	180adcc <__adddf3>
 1803b80:	100d883a 	mov	r6,r2
 1803b84:	180f883a 	mov	r7,r3
 1803b88:	8009883a 	mov	r4,r16
 1803b8c:	880b883a 	mov	r5,r17
 1803b90:	1027883a 	mov	r19,r2
 1803b94:	1825883a 	mov	r18,r3
 1803b98:	180c0c40 	call	180c0c4 <__ledf2>
 1803b9c:	10000816 	blt	r2,zero,1803bc0 <_dtoa_r+0x948>
 1803ba0:	980d883a 	mov	r6,r19
 1803ba4:	900f883a 	mov	r7,r18
 1803ba8:	8009883a 	mov	r4,r16
 1803bac:	880b883a 	mov	r5,r17
 1803bb0:	180bf600 	call	180bf60 <__eqdf2>
 1803bb4:	103f5a1e 	bne	r2,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803bb8:	ad40004c 	andi	r21,r21,1
 1803bbc:	a83f5826 	beq	r21,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803bc0:	bd3fffc3 	ldbu	r20,-1(r23)
 1803bc4:	b8bfffc4 	addi	r2,r23,-1
 1803bc8:	1007883a 	mov	r3,r2
 1803bcc:	01400e44 	movi	r5,57
 1803bd0:	d9800717 	ldw	r6,28(sp)
 1803bd4:	00000506 	br	1803bec <_dtoa_r+0x974>
 1803bd8:	18ffffc4 	addi	r3,r3,-1
 1803bdc:	11824726 	beq	r2,r6,18044fc <_dtoa_r+0x1284>
 1803be0:	1d000003 	ldbu	r20,0(r3)
 1803be4:	102f883a 	mov	r23,r2
 1803be8:	10bfffc4 	addi	r2,r2,-1
 1803bec:	a1003fcc 	andi	r4,r20,255
 1803bf0:	2100201c 	xori	r4,r4,128
 1803bf4:	213fe004 	addi	r4,r4,-128
 1803bf8:	217ff726 	beq	r4,r5,1803bd8 <__ram_exceptions_end+0xff7f3794>
 1803bfc:	a2000044 	addi	r8,r20,1
 1803c00:	12000005 	stb	r8,0(r2)
 1803c04:	003f4606 	br	1803920 <__ram_exceptions_end+0xff7f34dc>
 1803c08:	d9000b17 	ldw	r4,44(sp)
 1803c0c:	2000c826 	beq	r4,zero,1803f30 <_dtoa_r+0xcb8>
 1803c10:	d9800317 	ldw	r6,12(sp)
 1803c14:	00c00044 	movi	r3,1
 1803c18:	1980f90e 	bge	r3,r6,1804000 <_dtoa_r+0xd88>
 1803c1c:	d8800617 	ldw	r2,24(sp)
 1803c20:	d8c00a17 	ldw	r3,40(sp)
 1803c24:	157fffc4 	addi	r21,r2,-1
 1803c28:	1d41f316 	blt	r3,r21,18043f8 <_dtoa_r+0x1180>
 1803c2c:	1d6bc83a 	sub	r21,r3,r21
 1803c30:	d9c00617 	ldw	r7,24(sp)
 1803c34:	3802aa16 	blt	r7,zero,18046e0 <_dtoa_r+0x1468>
 1803c38:	dd000817 	ldw	r20,32(sp)
 1803c3c:	d8800617 	ldw	r2,24(sp)
 1803c40:	d8c00817 	ldw	r3,32(sp)
 1803c44:	01400044 	movi	r5,1
 1803c48:	e009883a 	mov	r4,fp
 1803c4c:	1887883a 	add	r3,r3,r2
 1803c50:	d8c00815 	stw	r3,32(sp)
 1803c54:	b0ad883a 	add	r22,r22,r2
 1803c58:	18067080 	call	1806708 <__i2b>
 1803c5c:	1023883a 	mov	r17,r2
 1803c60:	a0000826 	beq	r20,zero,1803c84 <_dtoa_r+0xa0c>
 1803c64:	0580070e 	bge	zero,r22,1803c84 <_dtoa_r+0xa0c>
 1803c68:	a005883a 	mov	r2,r20
 1803c6c:	b500b916 	blt	r22,r20,1803f54 <_dtoa_r+0xcdc>
 1803c70:	d9000817 	ldw	r4,32(sp)
 1803c74:	a0a9c83a 	sub	r20,r20,r2
 1803c78:	b0adc83a 	sub	r22,r22,r2
 1803c7c:	2089c83a 	sub	r4,r4,r2
 1803c80:	d9000815 	stw	r4,32(sp)
 1803c84:	d9800a17 	ldw	r6,40(sp)
 1803c88:	0181810e 	bge	zero,r6,1804290 <_dtoa_r+0x1018>
 1803c8c:	d9c00b17 	ldw	r7,44(sp)
 1803c90:	3800b326 	beq	r7,zero,1803f60 <_dtoa_r+0xce8>
 1803c94:	a800b226 	beq	r21,zero,1803f60 <_dtoa_r+0xce8>
 1803c98:	880b883a 	mov	r5,r17
 1803c9c:	a80d883a 	mov	r6,r21
 1803ca0:	e009883a 	mov	r4,fp
 1803ca4:	180693c0 	call	180693c <__pow5mult>
 1803ca8:	d9800917 	ldw	r6,36(sp)
 1803cac:	100b883a 	mov	r5,r2
 1803cb0:	e009883a 	mov	r4,fp
 1803cb4:	1023883a 	mov	r17,r2
 1803cb8:	18067440 	call	1806744 <__multiply>
 1803cbc:	1021883a 	mov	r16,r2
 1803cc0:	d8800a17 	ldw	r2,40(sp)
 1803cc4:	d9400917 	ldw	r5,36(sp)
 1803cc8:	e009883a 	mov	r4,fp
 1803ccc:	1545c83a 	sub	r2,r2,r21
 1803cd0:	d8800a15 	stw	r2,40(sp)
 1803cd4:	18063a40 	call	18063a4 <_Bfree>
 1803cd8:	d8c00a17 	ldw	r3,40(sp)
 1803cdc:	18009f1e 	bne	r3,zero,1803f5c <_dtoa_r+0xce4>
 1803ce0:	05c00044 	movi	r23,1
 1803ce4:	e009883a 	mov	r4,fp
 1803ce8:	b80b883a 	mov	r5,r23
 1803cec:	18067080 	call	1806708 <__i2b>
 1803cf0:	d9000d17 	ldw	r4,52(sp)
 1803cf4:	102b883a 	mov	r21,r2
 1803cf8:	2000ce26 	beq	r4,zero,1804034 <_dtoa_r+0xdbc>
 1803cfc:	200d883a 	mov	r6,r4
 1803d00:	100b883a 	mov	r5,r2
 1803d04:	e009883a 	mov	r4,fp
 1803d08:	180693c0 	call	180693c <__pow5mult>
 1803d0c:	d9800317 	ldw	r6,12(sp)
 1803d10:	102b883a 	mov	r21,r2
 1803d14:	b981810e 	bge	r23,r6,180431c <_dtoa_r+0x10a4>
 1803d18:	0027883a 	mov	r19,zero
 1803d1c:	a8800417 	ldw	r2,16(r21)
 1803d20:	05c00804 	movi	r23,32
 1803d24:	10800104 	addi	r2,r2,4
 1803d28:	1085883a 	add	r2,r2,r2
 1803d2c:	1085883a 	add	r2,r2,r2
 1803d30:	a885883a 	add	r2,r21,r2
 1803d34:	11000017 	ldw	r4,0(r2)
 1803d38:	18065f00 	call	18065f0 <__hi0bits>
 1803d3c:	b885c83a 	sub	r2,r23,r2
 1803d40:	1585883a 	add	r2,r2,r22
 1803d44:	108007cc 	andi	r2,r2,31
 1803d48:	1000b326 	beq	r2,zero,1804018 <_dtoa_r+0xda0>
 1803d4c:	00c00804 	movi	r3,32
 1803d50:	1887c83a 	sub	r3,r3,r2
 1803d54:	01000104 	movi	r4,4
 1803d58:	20c2cd0e 	bge	r4,r3,1804890 <_dtoa_r+0x1618>
 1803d5c:	00c00704 	movi	r3,28
 1803d60:	1885c83a 	sub	r2,r3,r2
 1803d64:	d8c00817 	ldw	r3,32(sp)
 1803d68:	a0a9883a 	add	r20,r20,r2
 1803d6c:	b0ad883a 	add	r22,r22,r2
 1803d70:	1887883a 	add	r3,r3,r2
 1803d74:	d8c00815 	stw	r3,32(sp)
 1803d78:	d9800817 	ldw	r6,32(sp)
 1803d7c:	0180040e 	bge	zero,r6,1803d90 <_dtoa_r+0xb18>
 1803d80:	800b883a 	mov	r5,r16
 1803d84:	e009883a 	mov	r4,fp
 1803d88:	1806a7c0 	call	1806a7c <__lshift>
 1803d8c:	1021883a 	mov	r16,r2
 1803d90:	0580050e 	bge	zero,r22,1803da8 <_dtoa_r+0xb30>
 1803d94:	a80b883a 	mov	r5,r21
 1803d98:	b00d883a 	mov	r6,r22
 1803d9c:	e009883a 	mov	r4,fp
 1803da0:	1806a7c0 	call	1806a7c <__lshift>
 1803da4:	102b883a 	mov	r21,r2
 1803da8:	d9c00e17 	ldw	r7,56(sp)
 1803dac:	3801211e 	bne	r7,zero,1804234 <_dtoa_r+0xfbc>
 1803db0:	d9800617 	ldw	r6,24(sp)
 1803db4:	0181380e 	bge	zero,r6,1804298 <_dtoa_r+0x1020>
 1803db8:	d8c00b17 	ldw	r3,44(sp)
 1803dbc:	1800ab1e 	bne	r3,zero,180406c <_dtoa_r+0xdf4>
 1803dc0:	dc800717 	ldw	r18,28(sp)
 1803dc4:	dcc00617 	ldw	r19,24(sp)
 1803dc8:	9029883a 	mov	r20,r18
 1803dcc:	00000206 	br	1803dd8 <_dtoa_r+0xb60>
 1803dd0:	18063cc0 	call	18063cc <__multadd>
 1803dd4:	1021883a 	mov	r16,r2
 1803dd8:	a80b883a 	mov	r5,r21
 1803ddc:	8009883a 	mov	r4,r16
 1803de0:	18030780 	call	1803078 <quorem>
 1803de4:	10800c04 	addi	r2,r2,48
 1803de8:	90800005 	stb	r2,0(r18)
 1803dec:	94800044 	addi	r18,r18,1
 1803df0:	9507c83a 	sub	r3,r18,r20
 1803df4:	000f883a 	mov	r7,zero
 1803df8:	01800284 	movi	r6,10
 1803dfc:	800b883a 	mov	r5,r16
 1803e00:	e009883a 	mov	r4,fp
 1803e04:	1cfff216 	blt	r3,r19,1803dd0 <__ram_exceptions_end+0xff7f398c>
 1803e08:	1011883a 	mov	r8,r2
 1803e0c:	d8800617 	ldw	r2,24(sp)
 1803e10:	0082370e 	bge	zero,r2,18046f0 <_dtoa_r+0x1478>
 1803e14:	d9000717 	ldw	r4,28(sp)
 1803e18:	0025883a 	mov	r18,zero
 1803e1c:	20af883a 	add	r23,r4,r2
 1803e20:	01800044 	movi	r6,1
 1803e24:	800b883a 	mov	r5,r16
 1803e28:	e009883a 	mov	r4,fp
 1803e2c:	da001715 	stw	r8,92(sp)
 1803e30:	1806a7c0 	call	1806a7c <__lshift>
 1803e34:	a80b883a 	mov	r5,r21
 1803e38:	1009883a 	mov	r4,r2
 1803e3c:	d8800915 	stw	r2,36(sp)
 1803e40:	1806bc40 	call	1806bc4 <__mcmp>
 1803e44:	da001717 	ldw	r8,92(sp)
 1803e48:	0081800e 	bge	zero,r2,180444c <_dtoa_r+0x11d4>
 1803e4c:	b93fffc3 	ldbu	r4,-1(r23)
 1803e50:	b8bfffc4 	addi	r2,r23,-1
 1803e54:	1007883a 	mov	r3,r2
 1803e58:	01800e44 	movi	r6,57
 1803e5c:	d9c00717 	ldw	r7,28(sp)
 1803e60:	00000506 	br	1803e78 <_dtoa_r+0xc00>
 1803e64:	18ffffc4 	addi	r3,r3,-1
 1803e68:	11c12326 	beq	r2,r7,18042f8 <_dtoa_r+0x1080>
 1803e6c:	19000003 	ldbu	r4,0(r3)
 1803e70:	102f883a 	mov	r23,r2
 1803e74:	10bfffc4 	addi	r2,r2,-1
 1803e78:	21403fcc 	andi	r5,r4,255
 1803e7c:	2940201c 	xori	r5,r5,128
 1803e80:	297fe004 	addi	r5,r5,-128
 1803e84:	29bff726 	beq	r5,r6,1803e64 <__ram_exceptions_end+0xff7f3a20>
 1803e88:	21000044 	addi	r4,r4,1
 1803e8c:	11000005 	stb	r4,0(r2)
 1803e90:	a80b883a 	mov	r5,r21
 1803e94:	e009883a 	mov	r4,fp
 1803e98:	18063a40 	call	18063a4 <_Bfree>
 1803e9c:	883ea026 	beq	r17,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803ea0:	90000426 	beq	r18,zero,1803eb4 <_dtoa_r+0xc3c>
 1803ea4:	94400326 	beq	r18,r17,1803eb4 <_dtoa_r+0xc3c>
 1803ea8:	900b883a 	mov	r5,r18
 1803eac:	e009883a 	mov	r4,fp
 1803eb0:	18063a40 	call	18063a4 <_Bfree>
 1803eb4:	880b883a 	mov	r5,r17
 1803eb8:	e009883a 	mov	r4,fp
 1803ebc:	18063a40 	call	18063a4 <_Bfree>
 1803ec0:	003e9706 	br	1803920 <__ram_exceptions_end+0xff7f34dc>
 1803ec4:	01800044 	movi	r6,1
 1803ec8:	d9800e15 	stw	r6,56(sp)
 1803ecc:	003d9606 	br	1803528 <__ram_exceptions_end+0xff7f30e4>
 1803ed0:	d8800817 	ldw	r2,32(sp)
 1803ed4:	d8c00517 	ldw	r3,20(sp)
 1803ed8:	d8000d15 	stw	zero,52(sp)
 1803edc:	10c5c83a 	sub	r2,r2,r3
 1803ee0:	00c9c83a 	sub	r4,zero,r3
 1803ee4:	d8800815 	stw	r2,32(sp)
 1803ee8:	d9000a15 	stw	r4,40(sp)
 1803eec:	003d9706 	br	180354c <__ram_exceptions_end+0xff7f3108>
 1803ef0:	05adc83a 	sub	r22,zero,r22
 1803ef4:	dd800815 	stw	r22,32(sp)
 1803ef8:	002d883a 	mov	r22,zero
 1803efc:	003d8e06 	br	1803538 <__ram_exceptions_end+0xff7f30f4>
 1803f00:	d9000517 	ldw	r4,20(sp)
 1803f04:	180d24c0 	call	180d24c <__floatsidf>
 1803f08:	100d883a 	mov	r6,r2
 1803f0c:	180f883a 	mov	r7,r3
 1803f10:	a009883a 	mov	r4,r20
 1803f14:	880b883a 	mov	r5,r17
 1803f18:	180bf600 	call	180bf60 <__eqdf2>
 1803f1c:	103d7126 	beq	r2,zero,18034e4 <__ram_exceptions_end+0xff7f30a0>
 1803f20:	d9c00517 	ldw	r7,20(sp)
 1803f24:	39ffffc4 	addi	r7,r7,-1
 1803f28:	d9c00515 	stw	r7,20(sp)
 1803f2c:	003d6d06 	br	18034e4 <__ram_exceptions_end+0xff7f30a0>
 1803f30:	dd400a17 	ldw	r21,40(sp)
 1803f34:	dd000817 	ldw	r20,32(sp)
 1803f38:	0023883a 	mov	r17,zero
 1803f3c:	003f4806 	br	1803c60 <__ram_exceptions_end+0xff7f381c>
 1803f40:	10e3c83a 	sub	r17,r2,r3
 1803f44:	9448983a 	sll	r4,r18,r17
 1803f48:	003d3206 	br	1803414 <__ram_exceptions_end+0xff7f2fd0>
 1803f4c:	d8000e15 	stw	zero,56(sp)
 1803f50:	003d7506 	br	1803528 <__ram_exceptions_end+0xff7f30e4>
 1803f54:	b005883a 	mov	r2,r22
 1803f58:	003f4506 	br	1803c70 <__ram_exceptions_end+0xff7f382c>
 1803f5c:	dc000915 	stw	r16,36(sp)
 1803f60:	d9800a17 	ldw	r6,40(sp)
 1803f64:	d9400917 	ldw	r5,36(sp)
 1803f68:	e009883a 	mov	r4,fp
 1803f6c:	180693c0 	call	180693c <__pow5mult>
 1803f70:	1021883a 	mov	r16,r2
 1803f74:	003f5a06 	br	1803ce0 <__ram_exceptions_end+0xff7f389c>
 1803f78:	01c00044 	movi	r7,1
 1803f7c:	d9c00b15 	stw	r7,44(sp)
 1803f80:	d8802217 	ldw	r2,136(sp)
 1803f84:	0081280e 	bge	zero,r2,1804428 <_dtoa_r+0x11b0>
 1803f88:	100d883a 	mov	r6,r2
 1803f8c:	1021883a 	mov	r16,r2
 1803f90:	d8800c15 	stw	r2,48(sp)
 1803f94:	d8800615 	stw	r2,24(sp)
 1803f98:	003d8806 	br	18035bc <__ram_exceptions_end+0xff7f3178>
 1803f9c:	d8800617 	ldw	r2,24(sp)
 1803fa0:	00be9b16 	blt	zero,r2,1803a10 <__ram_exceptions_end+0xff7f35cc>
 1803fa4:	10010f1e 	bne	r2,zero,18043e4 <_dtoa_r+0x116c>
 1803fa8:	880b883a 	mov	r5,r17
 1803fac:	000d883a 	mov	r6,zero
 1803fb0:	01d00534 	movhi	r7,16404
 1803fb4:	8009883a 	mov	r4,r16
 1803fb8:	180c1b80 	call	180c1b8 <__muldf3>
 1803fbc:	900d883a 	mov	r6,r18
 1803fc0:	980f883a 	mov	r7,r19
 1803fc4:	1009883a 	mov	r4,r2
 1803fc8:	180b883a 	mov	r5,r3
 1803fcc:	180bfe80 	call	180bfe8 <__gedf2>
 1803fd0:	002b883a 	mov	r21,zero
 1803fd4:	0023883a 	mov	r17,zero
 1803fd8:	1000bf16 	blt	r2,zero,18042d8 <_dtoa_r+0x1060>
 1803fdc:	d9802217 	ldw	r6,136(sp)
 1803fe0:	ddc00717 	ldw	r23,28(sp)
 1803fe4:	018c303a 	nor	r6,zero,r6
 1803fe8:	d9800515 	stw	r6,20(sp)
 1803fec:	a80b883a 	mov	r5,r21
 1803ff0:	e009883a 	mov	r4,fp
 1803ff4:	18063a40 	call	18063a4 <_Bfree>
 1803ff8:	883e4926 	beq	r17,zero,1803920 <__ram_exceptions_end+0xff7f34dc>
 1803ffc:	003fad06 	br	1803eb4 <__ram_exceptions_end+0xff7f3a70>
 1804000:	d9c01117 	ldw	r7,68(sp)
 1804004:	3801bc26 	beq	r7,zero,18046f8 <_dtoa_r+0x1480>
 1804008:	10810cc4 	addi	r2,r2,1075
 180400c:	dd400a17 	ldw	r21,40(sp)
 1804010:	dd000817 	ldw	r20,32(sp)
 1804014:	003f0a06 	br	1803c40 <__ram_exceptions_end+0xff7f37fc>
 1804018:	00800704 	movi	r2,28
 180401c:	d9000817 	ldw	r4,32(sp)
 1804020:	a0a9883a 	add	r20,r20,r2
 1804024:	b0ad883a 	add	r22,r22,r2
 1804028:	2089883a 	add	r4,r4,r2
 180402c:	d9000815 	stw	r4,32(sp)
 1804030:	003f5106 	br	1803d78 <__ram_exceptions_end+0xff7f3934>
 1804034:	d8c00317 	ldw	r3,12(sp)
 1804038:	b8c1fc0e 	bge	r23,r3,180482c <_dtoa_r+0x15b4>
 180403c:	0027883a 	mov	r19,zero
 1804040:	b805883a 	mov	r2,r23
 1804044:	003f3e06 	br	1803d40 <__ram_exceptions_end+0xff7f38fc>
 1804048:	880b883a 	mov	r5,r17
 180404c:	e009883a 	mov	r4,fp
 1804050:	000f883a 	mov	r7,zero
 1804054:	01800284 	movi	r6,10
 1804058:	18063cc0 	call	18063cc <__multadd>
 180405c:	d9000c17 	ldw	r4,48(sp)
 1804060:	1023883a 	mov	r17,r2
 1804064:	0102040e 	bge	zero,r4,1804878 <_dtoa_r+0x1600>
 1804068:	d9000615 	stw	r4,24(sp)
 180406c:	0500050e 	bge	zero,r20,1804084 <_dtoa_r+0xe0c>
 1804070:	880b883a 	mov	r5,r17
 1804074:	a00d883a 	mov	r6,r20
 1804078:	e009883a 	mov	r4,fp
 180407c:	1806a7c0 	call	1806a7c <__lshift>
 1804080:	1023883a 	mov	r17,r2
 1804084:	9801241e 	bne	r19,zero,1804518 <_dtoa_r+0x12a0>
 1804088:	8829883a 	mov	r20,r17
 180408c:	d9000617 	ldw	r4,24(sp)
 1804090:	dcc00717 	ldw	r19,28(sp)
 1804094:	9480004c 	andi	r18,r18,1
 1804098:	20bfffc4 	addi	r2,r4,-1
 180409c:	9885883a 	add	r2,r19,r2
 18040a0:	d8800415 	stw	r2,16(sp)
 18040a4:	dc800615 	stw	r18,24(sp)
 18040a8:	a80b883a 	mov	r5,r21
 18040ac:	8009883a 	mov	r4,r16
 18040b0:	18030780 	call	1803078 <quorem>
 18040b4:	880b883a 	mov	r5,r17
 18040b8:	8009883a 	mov	r4,r16
 18040bc:	102f883a 	mov	r23,r2
 18040c0:	1806bc40 	call	1806bc4 <__mcmp>
 18040c4:	a80b883a 	mov	r5,r21
 18040c8:	a00d883a 	mov	r6,r20
 18040cc:	e009883a 	mov	r4,fp
 18040d0:	102d883a 	mov	r22,r2
 18040d4:	1806c240 	call	1806c24 <__mdiff>
 18040d8:	1007883a 	mov	r3,r2
 18040dc:	10800317 	ldw	r2,12(r2)
 18040e0:	bc800c04 	addi	r18,r23,48
 18040e4:	180b883a 	mov	r5,r3
 18040e8:	10004e1e 	bne	r2,zero,1804224 <_dtoa_r+0xfac>
 18040ec:	8009883a 	mov	r4,r16
 18040f0:	d8c01615 	stw	r3,88(sp)
 18040f4:	1806bc40 	call	1806bc4 <__mcmp>
 18040f8:	d8c01617 	ldw	r3,88(sp)
 18040fc:	e009883a 	mov	r4,fp
 1804100:	d8801615 	stw	r2,88(sp)
 1804104:	180b883a 	mov	r5,r3
 1804108:	18063a40 	call	18063a4 <_Bfree>
 180410c:	d8801617 	ldw	r2,88(sp)
 1804110:	1000041e 	bne	r2,zero,1804124 <_dtoa_r+0xeac>
 1804114:	d9800317 	ldw	r6,12(sp)
 1804118:	3000021e 	bne	r6,zero,1804124 <_dtoa_r+0xeac>
 180411c:	d8c00617 	ldw	r3,24(sp)
 1804120:	18003726 	beq	r3,zero,1804200 <_dtoa_r+0xf88>
 1804124:	b0002016 	blt	r22,zero,18041a8 <_dtoa_r+0xf30>
 1804128:	b000041e 	bne	r22,zero,180413c <_dtoa_r+0xec4>
 180412c:	d9000317 	ldw	r4,12(sp)
 1804130:	2000021e 	bne	r4,zero,180413c <_dtoa_r+0xec4>
 1804134:	d8c00617 	ldw	r3,24(sp)
 1804138:	18001b26 	beq	r3,zero,18041a8 <_dtoa_r+0xf30>
 180413c:	00810716 	blt	zero,r2,180455c <_dtoa_r+0x12e4>
 1804140:	d8c00417 	ldw	r3,16(sp)
 1804144:	9d800044 	addi	r22,r19,1
 1804148:	9c800005 	stb	r18,0(r19)
 180414c:	b02f883a 	mov	r23,r22
 1804150:	98c10626 	beq	r19,r3,180456c <_dtoa_r+0x12f4>
 1804154:	800b883a 	mov	r5,r16
 1804158:	000f883a 	mov	r7,zero
 180415c:	01800284 	movi	r6,10
 1804160:	e009883a 	mov	r4,fp
 1804164:	18063cc0 	call	18063cc <__multadd>
 1804168:	1021883a 	mov	r16,r2
 180416c:	000f883a 	mov	r7,zero
 1804170:	01800284 	movi	r6,10
 1804174:	880b883a 	mov	r5,r17
 1804178:	e009883a 	mov	r4,fp
 180417c:	8d002526 	beq	r17,r20,1804214 <_dtoa_r+0xf9c>
 1804180:	18063cc0 	call	18063cc <__multadd>
 1804184:	a00b883a 	mov	r5,r20
 1804188:	000f883a 	mov	r7,zero
 180418c:	01800284 	movi	r6,10
 1804190:	e009883a 	mov	r4,fp
 1804194:	1023883a 	mov	r17,r2
 1804198:	18063cc0 	call	18063cc <__multadd>
 180419c:	1029883a 	mov	r20,r2
 18041a0:	b027883a 	mov	r19,r22
 18041a4:	003fc006 	br	18040a8 <__ram_exceptions_end+0xff7f3c64>
 18041a8:	9011883a 	mov	r8,r18
 18041ac:	00800e0e 	bge	zero,r2,18041e8 <_dtoa_r+0xf70>
 18041b0:	800b883a 	mov	r5,r16
 18041b4:	01800044 	movi	r6,1
 18041b8:	e009883a 	mov	r4,fp
 18041bc:	da001715 	stw	r8,92(sp)
 18041c0:	1806a7c0 	call	1806a7c <__lshift>
 18041c4:	a80b883a 	mov	r5,r21
 18041c8:	1009883a 	mov	r4,r2
 18041cc:	1021883a 	mov	r16,r2
 18041d0:	1806bc40 	call	1806bc4 <__mcmp>
 18041d4:	da001717 	ldw	r8,92(sp)
 18041d8:	0081960e 	bge	zero,r2,1804834 <_dtoa_r+0x15bc>
 18041dc:	00800e44 	movi	r2,57
 18041e0:	40817026 	beq	r8,r2,18047a4 <_dtoa_r+0x152c>
 18041e4:	ba000c44 	addi	r8,r23,49
 18041e8:	8825883a 	mov	r18,r17
 18041ec:	9dc00044 	addi	r23,r19,1
 18041f0:	9a000005 	stb	r8,0(r19)
 18041f4:	a023883a 	mov	r17,r20
 18041f8:	dc000915 	stw	r16,36(sp)
 18041fc:	003f2406 	br	1803e90 <__ram_exceptions_end+0xff7f3a4c>
 1804200:	00800e44 	movi	r2,57
 1804204:	9011883a 	mov	r8,r18
 1804208:	90816626 	beq	r18,r2,18047a4 <_dtoa_r+0x152c>
 180420c:	05bff516 	blt	zero,r22,18041e4 <__ram_exceptions_end+0xff7f3da0>
 1804210:	003ff506 	br	18041e8 <__ram_exceptions_end+0xff7f3da4>
 1804214:	18063cc0 	call	18063cc <__multadd>
 1804218:	1023883a 	mov	r17,r2
 180421c:	1029883a 	mov	r20,r2
 1804220:	003fdf06 	br	18041a0 <__ram_exceptions_end+0xff7f3d5c>
 1804224:	e009883a 	mov	r4,fp
 1804228:	18063a40 	call	18063a4 <_Bfree>
 180422c:	00800044 	movi	r2,1
 1804230:	003fbc06 	br	1804124 <__ram_exceptions_end+0xff7f3ce0>
 1804234:	a80b883a 	mov	r5,r21
 1804238:	8009883a 	mov	r4,r16
 180423c:	1806bc40 	call	1806bc4 <__mcmp>
 1804240:	103edb0e 	bge	r2,zero,1803db0 <__ram_exceptions_end+0xff7f396c>
 1804244:	800b883a 	mov	r5,r16
 1804248:	000f883a 	mov	r7,zero
 180424c:	01800284 	movi	r6,10
 1804250:	e009883a 	mov	r4,fp
 1804254:	18063cc0 	call	18063cc <__multadd>
 1804258:	1021883a 	mov	r16,r2
 180425c:	d8800517 	ldw	r2,20(sp)
 1804260:	d8c00b17 	ldw	r3,44(sp)
 1804264:	10bfffc4 	addi	r2,r2,-1
 1804268:	d8800515 	stw	r2,20(sp)
 180426c:	183f761e 	bne	r3,zero,1804048 <__ram_exceptions_end+0xff7f3c04>
 1804270:	d9000c17 	ldw	r4,48(sp)
 1804274:	0101730e 	bge	zero,r4,1804844 <_dtoa_r+0x15cc>
 1804278:	d9000615 	stw	r4,24(sp)
 180427c:	003ed006 	br	1803dc0 <__ram_exceptions_end+0xff7f397c>
 1804280:	00800084 	movi	r2,2
 1804284:	3081861e 	bne	r6,r2,18048a0 <_dtoa_r+0x1628>
 1804288:	d8000b15 	stw	zero,44(sp)
 180428c:	003f3c06 	br	1803f80 <__ram_exceptions_end+0xff7f3b3c>
 1804290:	dc000917 	ldw	r16,36(sp)
 1804294:	003e9206 	br	1803ce0 <__ram_exceptions_end+0xff7f389c>
 1804298:	d9c00317 	ldw	r7,12(sp)
 180429c:	00800084 	movi	r2,2
 18042a0:	11fec50e 	bge	r2,r7,1803db8 <__ram_exceptions_end+0xff7f3974>
 18042a4:	d9000617 	ldw	r4,24(sp)
 18042a8:	20013c1e 	bne	r4,zero,180479c <_dtoa_r+0x1524>
 18042ac:	a80b883a 	mov	r5,r21
 18042b0:	000f883a 	mov	r7,zero
 18042b4:	01800144 	movi	r6,5
 18042b8:	e009883a 	mov	r4,fp
 18042bc:	18063cc0 	call	18063cc <__multadd>
 18042c0:	100b883a 	mov	r5,r2
 18042c4:	8009883a 	mov	r4,r16
 18042c8:	102b883a 	mov	r21,r2
 18042cc:	1806bc40 	call	1806bc4 <__mcmp>
 18042d0:	dc000915 	stw	r16,36(sp)
 18042d4:	00bf410e 	bge	zero,r2,1803fdc <__ram_exceptions_end+0xff7f3b98>
 18042d8:	d9c00717 	ldw	r7,28(sp)
 18042dc:	00800c44 	movi	r2,49
 18042e0:	38800005 	stb	r2,0(r7)
 18042e4:	d8800517 	ldw	r2,20(sp)
 18042e8:	3dc00044 	addi	r23,r7,1
 18042ec:	10800044 	addi	r2,r2,1
 18042f0:	d8800515 	stw	r2,20(sp)
 18042f4:	003f3d06 	br	1803fec <__ram_exceptions_end+0xff7f3ba8>
 18042f8:	d9800517 	ldw	r6,20(sp)
 18042fc:	d9c00717 	ldw	r7,28(sp)
 1804300:	00800c44 	movi	r2,49
 1804304:	31800044 	addi	r6,r6,1
 1804308:	d9800515 	stw	r6,20(sp)
 180430c:	38800005 	stb	r2,0(r7)
 1804310:	003edf06 	br	1803e90 <__ram_exceptions_end+0xff7f3a4c>
 1804314:	d8000b15 	stw	zero,44(sp)
 1804318:	003c9f06 	br	1803598 <__ram_exceptions_end+0xff7f3154>
 180431c:	903e7e1e 	bne	r18,zero,1803d18 <__ram_exceptions_end+0xff7f38d4>
 1804320:	00800434 	movhi	r2,16
 1804324:	10bfffc4 	addi	r2,r2,-1
 1804328:	9884703a 	and	r2,r19,r2
 180432c:	1000ea1e 	bne	r2,zero,18046d8 <_dtoa_r+0x1460>
 1804330:	9cdffc2c 	andhi	r19,r19,32752
 1804334:	9800e826 	beq	r19,zero,18046d8 <_dtoa_r+0x1460>
 1804338:	d9c00817 	ldw	r7,32(sp)
 180433c:	b5800044 	addi	r22,r22,1
 1804340:	04c00044 	movi	r19,1
 1804344:	39c00044 	addi	r7,r7,1
 1804348:	d9c00815 	stw	r7,32(sp)
 180434c:	d8800d17 	ldw	r2,52(sp)
 1804350:	103e721e 	bne	r2,zero,1803d1c <__ram_exceptions_end+0xff7f38d8>
 1804354:	00800044 	movi	r2,1
 1804358:	003e7906 	br	1803d40 <__ram_exceptions_end+0xff7f38fc>
 180435c:	8009883a 	mov	r4,r16
 1804360:	180d24c0 	call	180d24c <__floatsidf>
 1804364:	d9800f17 	ldw	r6,60(sp)
 1804368:	d9c01017 	ldw	r7,64(sp)
 180436c:	1009883a 	mov	r4,r2
 1804370:	180b883a 	mov	r5,r3
 1804374:	180c1b80 	call	180c1b8 <__muldf3>
 1804378:	000d883a 	mov	r6,zero
 180437c:	01d00734 	movhi	r7,16412
 1804380:	1009883a 	mov	r4,r2
 1804384:	180b883a 	mov	r5,r3
 1804388:	180adcc0 	call	180adcc <__adddf3>
 180438c:	047f3034 	movhi	r17,64704
 1804390:	1021883a 	mov	r16,r2
 1804394:	1c63883a 	add	r17,r3,r17
 1804398:	d9000f17 	ldw	r4,60(sp)
 180439c:	d9401017 	ldw	r5,64(sp)
 18043a0:	000d883a 	mov	r6,zero
 18043a4:	01d00534 	movhi	r7,16404
 18043a8:	180c8d00 	call	180c8d0 <__subdf3>
 18043ac:	800d883a 	mov	r6,r16
 18043b0:	880f883a 	mov	r7,r17
 18043b4:	1009883a 	mov	r4,r2
 18043b8:	180b883a 	mov	r5,r3
 18043bc:	102b883a 	mov	r21,r2
 18043c0:	1829883a 	mov	r20,r3
 18043c4:	180bfe80 	call	180bfe8 <__gedf2>
 18043c8:	00806c16 	blt	zero,r2,180457c <_dtoa_r+0x1304>
 18043cc:	89e0003c 	xorhi	r7,r17,32768
 18043d0:	800d883a 	mov	r6,r16
 18043d4:	a809883a 	mov	r4,r21
 18043d8:	a00b883a 	mov	r5,r20
 18043dc:	180c0c40 	call	180c0c4 <__ledf2>
 18043e0:	103d7e0e 	bge	r2,zero,18039dc <__ram_exceptions_end+0xff7f3598>
 18043e4:	002b883a 	mov	r21,zero
 18043e8:	0023883a 	mov	r17,zero
 18043ec:	003efb06 	br	1803fdc <__ram_exceptions_end+0xff7f3b98>
 18043f0:	d8800717 	ldw	r2,28(sp)
 18043f4:	003bd006 	br	1803338 <__ram_exceptions_end+0xff7f2ef4>
 18043f8:	d9000a17 	ldw	r4,40(sp)
 18043fc:	d9800d17 	ldw	r6,52(sp)
 1804400:	dd400a15 	stw	r21,40(sp)
 1804404:	a905c83a 	sub	r2,r21,r4
 1804408:	308d883a 	add	r6,r6,r2
 180440c:	d9800d15 	stw	r6,52(sp)
 1804410:	002b883a 	mov	r21,zero
 1804414:	003e0606 	br	1803c30 <__ram_exceptions_end+0xff7f37ec>
 1804418:	9023883a 	mov	r17,r18
 180441c:	9829883a 	mov	r20,r19
 1804420:	04000084 	movi	r16,2
 1804424:	003c9206 	br	1803670 <__ram_exceptions_end+0xff7f322c>
 1804428:	04000044 	movi	r16,1
 180442c:	dc000c15 	stw	r16,48(sp)
 1804430:	dc000615 	stw	r16,24(sp)
 1804434:	dc002215 	stw	r16,136(sp)
 1804438:	e0001115 	stw	zero,68(fp)
 180443c:	000b883a 	mov	r5,zero
 1804440:	003c6906 	br	18035e8 <__ram_exceptions_end+0xff7f31a4>
 1804444:	3021883a 	mov	r16,r6
 1804448:	003ffb06 	br	1804438 <__ram_exceptions_end+0xff7f3ff4>
 180444c:	1000021e 	bne	r2,zero,1804458 <_dtoa_r+0x11e0>
 1804450:	4200004c 	andi	r8,r8,1
 1804454:	403e7d1e 	bne	r8,zero,1803e4c <__ram_exceptions_end+0xff7f3a08>
 1804458:	01000c04 	movi	r4,48
 180445c:	00000106 	br	1804464 <_dtoa_r+0x11ec>
 1804460:	102f883a 	mov	r23,r2
 1804464:	b8bfffc4 	addi	r2,r23,-1
 1804468:	10c00007 	ldb	r3,0(r2)
 180446c:	193ffc26 	beq	r3,r4,1804460 <__ram_exceptions_end+0xff7f401c>
 1804470:	003e8706 	br	1803e90 <__ram_exceptions_end+0xff7f3a4c>
 1804474:	d8800517 	ldw	r2,20(sp)
 1804478:	00a3c83a 	sub	r17,zero,r2
 180447c:	8800a426 	beq	r17,zero,1804710 <_dtoa_r+0x1498>
 1804480:	888003cc 	andi	r2,r17,15
 1804484:	100490fa 	slli	r2,r2,3
 1804488:	00c06134 	movhi	r3,388
 180448c:	18c51504 	addi	r3,r3,5204
 1804490:	1885883a 	add	r2,r3,r2
 1804494:	11800017 	ldw	r6,0(r2)
 1804498:	11c00117 	ldw	r7,4(r2)
 180449c:	9009883a 	mov	r4,r18
 18044a0:	980b883a 	mov	r5,r19
 18044a4:	8823d13a 	srai	r17,r17,4
 18044a8:	180c1b80 	call	180c1b8 <__muldf3>
 18044ac:	d8800f15 	stw	r2,60(sp)
 18044b0:	d8c01015 	stw	r3,64(sp)
 18044b4:	8800e826 	beq	r17,zero,1804858 <_dtoa_r+0x15e0>
 18044b8:	05006134 	movhi	r20,388
 18044bc:	a5050b04 	addi	r20,r20,5164
 18044c0:	04000084 	movi	r16,2
 18044c4:	8980004c 	andi	r6,r17,1
 18044c8:	1009883a 	mov	r4,r2
 18044cc:	8823d07a 	srai	r17,r17,1
 18044d0:	180b883a 	mov	r5,r3
 18044d4:	30000426 	beq	r6,zero,18044e8 <_dtoa_r+0x1270>
 18044d8:	a1800017 	ldw	r6,0(r20)
 18044dc:	a1c00117 	ldw	r7,4(r20)
 18044e0:	84000044 	addi	r16,r16,1
 18044e4:	180c1b80 	call	180c1b8 <__muldf3>
 18044e8:	a5000204 	addi	r20,r20,8
 18044ec:	883ff51e 	bne	r17,zero,18044c4 <__ram_exceptions_end+0xff7f4080>
 18044f0:	d8800f15 	stw	r2,60(sp)
 18044f4:	d8c01015 	stw	r3,64(sp)
 18044f8:	003c7606 	br	18036d4 <__ram_exceptions_end+0xff7f3290>
 18044fc:	00c00c04 	movi	r3,48
 1804500:	10c00005 	stb	r3,0(r2)
 1804504:	d8c00517 	ldw	r3,20(sp)
 1804508:	bd3fffc3 	ldbu	r20,-1(r23)
 180450c:	18c00044 	addi	r3,r3,1
 1804510:	d8c00515 	stw	r3,20(sp)
 1804514:	003db906 	br	1803bfc <__ram_exceptions_end+0xff7f37b8>
 1804518:	89400117 	ldw	r5,4(r17)
 180451c:	e009883a 	mov	r4,fp
 1804520:	18062fc0 	call	18062fc <_Balloc>
 1804524:	89800417 	ldw	r6,16(r17)
 1804528:	89400304 	addi	r5,r17,12
 180452c:	11000304 	addi	r4,r2,12
 1804530:	31800084 	addi	r6,r6,2
 1804534:	318d883a 	add	r6,r6,r6
 1804538:	318d883a 	add	r6,r6,r6
 180453c:	1027883a 	mov	r19,r2
 1804540:	180608c0 	call	180608c <memcpy>
 1804544:	01800044 	movi	r6,1
 1804548:	980b883a 	mov	r5,r19
 180454c:	e009883a 	mov	r4,fp
 1804550:	1806a7c0 	call	1806a7c <__lshift>
 1804554:	1029883a 	mov	r20,r2
 1804558:	003ecc06 	br	180408c <__ram_exceptions_end+0xff7f3c48>
 180455c:	00800e44 	movi	r2,57
 1804560:	90809026 	beq	r18,r2,18047a4 <_dtoa_r+0x152c>
 1804564:	92000044 	addi	r8,r18,1
 1804568:	003f1f06 	br	18041e8 <__ram_exceptions_end+0xff7f3da4>
 180456c:	9011883a 	mov	r8,r18
 1804570:	8825883a 	mov	r18,r17
 1804574:	a023883a 	mov	r17,r20
 1804578:	003e2906 	br	1803e20 <__ram_exceptions_end+0xff7f39dc>
 180457c:	002b883a 	mov	r21,zero
 1804580:	0023883a 	mov	r17,zero
 1804584:	003f5406 	br	18042d8 <__ram_exceptions_end+0xff7f3e94>
 1804588:	61bfffc4 	addi	r6,r12,-1
 180458c:	300490fa 	slli	r2,r6,3
 1804590:	00c06134 	movhi	r3,388
 1804594:	18c51504 	addi	r3,r3,5204
 1804598:	1885883a 	add	r2,r3,r2
 180459c:	11000017 	ldw	r4,0(r2)
 18045a0:	11400117 	ldw	r5,4(r2)
 18045a4:	d8800717 	ldw	r2,28(sp)
 18045a8:	880f883a 	mov	r7,r17
 18045ac:	d9801215 	stw	r6,72(sp)
 18045b0:	800d883a 	mov	r6,r16
 18045b4:	db001615 	stw	r12,88(sp)
 18045b8:	15c00044 	addi	r23,r2,1
 18045bc:	180c1b80 	call	180c1b8 <__muldf3>
 18045c0:	d9401017 	ldw	r5,64(sp)
 18045c4:	d9000f17 	ldw	r4,60(sp)
 18045c8:	d8c01515 	stw	r3,84(sp)
 18045cc:	d8801415 	stw	r2,80(sp)
 18045d0:	180d1cc0 	call	180d1cc <__fixdfsi>
 18045d4:	1009883a 	mov	r4,r2
 18045d8:	1021883a 	mov	r16,r2
 18045dc:	180d24c0 	call	180d24c <__floatsidf>
 18045e0:	d9000f17 	ldw	r4,60(sp)
 18045e4:	d9401017 	ldw	r5,64(sp)
 18045e8:	100d883a 	mov	r6,r2
 18045ec:	180f883a 	mov	r7,r3
 18045f0:	180c8d00 	call	180c8d0 <__subdf3>
 18045f4:	1829883a 	mov	r20,r3
 18045f8:	d8c00717 	ldw	r3,28(sp)
 18045fc:	84000c04 	addi	r16,r16,48
 1804600:	1023883a 	mov	r17,r2
 1804604:	1c000005 	stb	r16,0(r3)
 1804608:	db001617 	ldw	r12,88(sp)
 180460c:	00800044 	movi	r2,1
 1804610:	60802226 	beq	r12,r2,180469c <_dtoa_r+0x1424>
 1804614:	d9c00717 	ldw	r7,28(sp)
 1804618:	8805883a 	mov	r2,r17
 180461c:	b82b883a 	mov	r21,r23
 1804620:	3b19883a 	add	r12,r7,r12
 1804624:	6023883a 	mov	r17,r12
 1804628:	a007883a 	mov	r3,r20
 180462c:	dc800f15 	stw	r18,60(sp)
 1804630:	000d883a 	mov	r6,zero
 1804634:	01d00934 	movhi	r7,16420
 1804638:	1009883a 	mov	r4,r2
 180463c:	180b883a 	mov	r5,r3
 1804640:	180c1b80 	call	180c1b8 <__muldf3>
 1804644:	180b883a 	mov	r5,r3
 1804648:	1009883a 	mov	r4,r2
 180464c:	1829883a 	mov	r20,r3
 1804650:	1025883a 	mov	r18,r2
 1804654:	180d1cc0 	call	180d1cc <__fixdfsi>
 1804658:	1009883a 	mov	r4,r2
 180465c:	1021883a 	mov	r16,r2
 1804660:	180d24c0 	call	180d24c <__floatsidf>
 1804664:	100d883a 	mov	r6,r2
 1804668:	180f883a 	mov	r7,r3
 180466c:	9009883a 	mov	r4,r18
 1804670:	a00b883a 	mov	r5,r20
 1804674:	84000c04 	addi	r16,r16,48
 1804678:	180c8d00 	call	180c8d0 <__subdf3>
 180467c:	ad400044 	addi	r21,r21,1
 1804680:	ac3fffc5 	stb	r16,-1(r21)
 1804684:	ac7fea1e 	bne	r21,r17,1804630 <__ram_exceptions_end+0xff7f41ec>
 1804688:	1023883a 	mov	r17,r2
 180468c:	d8801217 	ldw	r2,72(sp)
 1804690:	dc800f17 	ldw	r18,60(sp)
 1804694:	1829883a 	mov	r20,r3
 1804698:	b8af883a 	add	r23,r23,r2
 180469c:	d9001417 	ldw	r4,80(sp)
 18046a0:	d9401517 	ldw	r5,84(sp)
 18046a4:	000d883a 	mov	r6,zero
 18046a8:	01cff834 	movhi	r7,16352
 18046ac:	180adcc0 	call	180adcc <__adddf3>
 18046b0:	880d883a 	mov	r6,r17
 18046b4:	a00f883a 	mov	r7,r20
 18046b8:	1009883a 	mov	r4,r2
 18046bc:	180b883a 	mov	r5,r3
 18046c0:	180c0c40 	call	180c0c4 <__ledf2>
 18046c4:	10003e0e 	bge	r2,zero,18047c0 <_dtoa_r+0x1548>
 18046c8:	d9001317 	ldw	r4,76(sp)
 18046cc:	bd3fffc3 	ldbu	r20,-1(r23)
 18046d0:	d9000515 	stw	r4,20(sp)
 18046d4:	003d3b06 	br	1803bc4 <__ram_exceptions_end+0xff7f3780>
 18046d8:	0027883a 	mov	r19,zero
 18046dc:	003f1b06 	br	180434c <__ram_exceptions_end+0xff7f3f08>
 18046e0:	d8800817 	ldw	r2,32(sp)
 18046e4:	11e9c83a 	sub	r20,r2,r7
 18046e8:	0005883a 	mov	r2,zero
 18046ec:	003d5406 	br	1803c40 <__ram_exceptions_end+0xff7f37fc>
 18046f0:	00800044 	movi	r2,1
 18046f4:	003dc706 	br	1803e14 <__ram_exceptions_end+0xff7f39d0>
 18046f8:	d8c00217 	ldw	r3,8(sp)
 18046fc:	00800d84 	movi	r2,54
 1804700:	dd400a17 	ldw	r21,40(sp)
 1804704:	10c5c83a 	sub	r2,r2,r3
 1804708:	dd000817 	ldw	r20,32(sp)
 180470c:	003d4c06 	br	1803c40 <__ram_exceptions_end+0xff7f37fc>
 1804710:	dc800f15 	stw	r18,60(sp)
 1804714:	dcc01015 	stw	r19,64(sp)
 1804718:	04000084 	movi	r16,2
 180471c:	003bed06 	br	18036d4 <__ram_exceptions_end+0xff7f3290>
 1804720:	d9000617 	ldw	r4,24(sp)
 1804724:	203f0d26 	beq	r4,zero,180435c <__ram_exceptions_end+0xff7f3f18>
 1804728:	d9800c17 	ldw	r6,48(sp)
 180472c:	01bcab0e 	bge	zero,r6,18039dc <__ram_exceptions_end+0xff7f3598>
 1804730:	d9401017 	ldw	r5,64(sp)
 1804734:	d9000f17 	ldw	r4,60(sp)
 1804738:	000d883a 	mov	r6,zero
 180473c:	01d00934 	movhi	r7,16420
 1804740:	180c1b80 	call	180c1b8 <__muldf3>
 1804744:	81000044 	addi	r4,r16,1
 1804748:	d8800f15 	stw	r2,60(sp)
 180474c:	d8c01015 	stw	r3,64(sp)
 1804750:	180d24c0 	call	180d24c <__floatsidf>
 1804754:	d9800f17 	ldw	r6,60(sp)
 1804758:	d9c01017 	ldw	r7,64(sp)
 180475c:	1009883a 	mov	r4,r2
 1804760:	180b883a 	mov	r5,r3
 1804764:	180c1b80 	call	180c1b8 <__muldf3>
 1804768:	01d00734 	movhi	r7,16412
 180476c:	000d883a 	mov	r6,zero
 1804770:	1009883a 	mov	r4,r2
 1804774:	180b883a 	mov	r5,r3
 1804778:	180adcc0 	call	180adcc <__adddf3>
 180477c:	d9c00517 	ldw	r7,20(sp)
 1804780:	047f3034 	movhi	r17,64704
 1804784:	1021883a 	mov	r16,r2
 1804788:	39ffffc4 	addi	r7,r7,-1
 180478c:	d9c01315 	stw	r7,76(sp)
 1804790:	1c63883a 	add	r17,r3,r17
 1804794:	db000c17 	ldw	r12,48(sp)
 1804798:	003bea06 	br	1803744 <__ram_exceptions_end+0xff7f3300>
 180479c:	dc000915 	stw	r16,36(sp)
 18047a0:	003e0e06 	br	1803fdc <__ram_exceptions_end+0xff7f3b98>
 18047a4:	01000e44 	movi	r4,57
 18047a8:	8825883a 	mov	r18,r17
 18047ac:	9dc00044 	addi	r23,r19,1
 18047b0:	99000005 	stb	r4,0(r19)
 18047b4:	a023883a 	mov	r17,r20
 18047b8:	dc000915 	stw	r16,36(sp)
 18047bc:	003da406 	br	1803e50 <__ram_exceptions_end+0xff7f3a0c>
 18047c0:	d9801417 	ldw	r6,80(sp)
 18047c4:	d9c01517 	ldw	r7,84(sp)
 18047c8:	0009883a 	mov	r4,zero
 18047cc:	014ff834 	movhi	r5,16352
 18047d0:	180c8d00 	call	180c8d0 <__subdf3>
 18047d4:	880d883a 	mov	r6,r17
 18047d8:	a00f883a 	mov	r7,r20
 18047dc:	1009883a 	mov	r4,r2
 18047e0:	180b883a 	mov	r5,r3
 18047e4:	180bfe80 	call	180bfe8 <__gedf2>
 18047e8:	00bc7c0e 	bge	zero,r2,18039dc <__ram_exceptions_end+0xff7f3598>
 18047ec:	01000c04 	movi	r4,48
 18047f0:	00000106 	br	18047f8 <_dtoa_r+0x1580>
 18047f4:	102f883a 	mov	r23,r2
 18047f8:	b8bfffc4 	addi	r2,r23,-1
 18047fc:	10c00007 	ldb	r3,0(r2)
 1804800:	193ffc26 	beq	r3,r4,18047f4 <__ram_exceptions_end+0xff7f43b0>
 1804804:	d9801317 	ldw	r6,76(sp)
 1804808:	d9800515 	stw	r6,20(sp)
 180480c:	003c4406 	br	1803920 <__ram_exceptions_end+0xff7f34dc>
 1804810:	d9801317 	ldw	r6,76(sp)
 1804814:	d9800515 	stw	r6,20(sp)
 1804818:	003cea06 	br	1803bc4 <__ram_exceptions_end+0xff7f3780>
 180481c:	dd800f17 	ldw	r22,60(sp)
 1804820:	dcc01017 	ldw	r19,64(sp)
 1804824:	dc801217 	ldw	r18,72(sp)
 1804828:	003c6c06 	br	18039dc <__ram_exceptions_end+0xff7f3598>
 180482c:	903e031e 	bne	r18,zero,180403c <__ram_exceptions_end+0xff7f3bf8>
 1804830:	003ebb06 	br	1804320 <__ram_exceptions_end+0xff7f3edc>
 1804834:	103e6c1e 	bne	r2,zero,18041e8 <__ram_exceptions_end+0xff7f3da4>
 1804838:	4080004c 	andi	r2,r8,1
 180483c:	103e6a26 	beq	r2,zero,18041e8 <__ram_exceptions_end+0xff7f3da4>
 1804840:	003e6606 	br	18041dc <__ram_exceptions_end+0xff7f3d98>
 1804844:	d8c00317 	ldw	r3,12(sp)
 1804848:	00800084 	movi	r2,2
 180484c:	10c02916 	blt	r2,r3,18048f4 <_dtoa_r+0x167c>
 1804850:	d9000c17 	ldw	r4,48(sp)
 1804854:	003e8806 	br	1804278 <__ram_exceptions_end+0xff7f3e34>
 1804858:	04000084 	movi	r16,2
 180485c:	003b9d06 	br	18036d4 <__ram_exceptions_end+0xff7f3290>
 1804860:	d9001317 	ldw	r4,76(sp)
 1804864:	d9000515 	stw	r4,20(sp)
 1804868:	003cd606 	br	1803bc4 <__ram_exceptions_end+0xff7f3780>
 180486c:	d8801317 	ldw	r2,76(sp)
 1804870:	d8800515 	stw	r2,20(sp)
 1804874:	003c2a06 	br	1803920 <__ram_exceptions_end+0xff7f34dc>
 1804878:	d9800317 	ldw	r6,12(sp)
 180487c:	00800084 	movi	r2,2
 1804880:	11801516 	blt	r2,r6,18048d8 <_dtoa_r+0x1660>
 1804884:	d9c00c17 	ldw	r7,48(sp)
 1804888:	d9c00615 	stw	r7,24(sp)
 180488c:	003df706 	br	180406c <__ram_exceptions_end+0xff7f3c28>
 1804890:	193d3926 	beq	r3,r4,1803d78 <__ram_exceptions_end+0xff7f3934>
 1804894:	00c00f04 	movi	r3,60
 1804898:	1885c83a 	sub	r2,r3,r2
 180489c:	003ddf06 	br	180401c <__ram_exceptions_end+0xff7f3bd8>
 18048a0:	e009883a 	mov	r4,fp
 18048a4:	e0001115 	stw	zero,68(fp)
 18048a8:	000b883a 	mov	r5,zero
 18048ac:	18062fc0 	call	18062fc <_Balloc>
 18048b0:	d8800715 	stw	r2,28(sp)
 18048b4:	d8c00717 	ldw	r3,28(sp)
 18048b8:	00bfffc4 	movi	r2,-1
 18048bc:	01000044 	movi	r4,1
 18048c0:	d8800c15 	stw	r2,48(sp)
 18048c4:	e0c01015 	stw	r3,64(fp)
 18048c8:	d9000b15 	stw	r4,44(sp)
 18048cc:	d8800615 	stw	r2,24(sp)
 18048d0:	d8002215 	stw	zero,136(sp)
 18048d4:	003c4106 	br	18039dc <__ram_exceptions_end+0xff7f3598>
 18048d8:	d8c00c17 	ldw	r3,48(sp)
 18048dc:	d8c00615 	stw	r3,24(sp)
 18048e0:	003e7006 	br	18042a4 <__ram_exceptions_end+0xff7f3e60>
 18048e4:	04400044 	movi	r17,1
 18048e8:	003b2006 	br	180356c <__ram_exceptions_end+0xff7f3128>
 18048ec:	000b883a 	mov	r5,zero
 18048f0:	003b3d06 	br	18035e8 <__ram_exceptions_end+0xff7f31a4>
 18048f4:	d8800c17 	ldw	r2,48(sp)
 18048f8:	d8800615 	stw	r2,24(sp)
 18048fc:	003e6906 	br	18042a4 <__ram_exceptions_end+0xff7f3e60>

01804900 <__sflush_r>:
 1804900:	2880030b 	ldhu	r2,12(r5)
 1804904:	defffb04 	addi	sp,sp,-20
 1804908:	dcc00315 	stw	r19,12(sp)
 180490c:	dc400115 	stw	r17,4(sp)
 1804910:	dfc00415 	stw	ra,16(sp)
 1804914:	dc800215 	stw	r18,8(sp)
 1804918:	dc000015 	stw	r16,0(sp)
 180491c:	10c0020c 	andi	r3,r2,8
 1804920:	2823883a 	mov	r17,r5
 1804924:	2027883a 	mov	r19,r4
 1804928:	1800311e 	bne	r3,zero,18049f0 <__sflush_r+0xf0>
 180492c:	28c00117 	ldw	r3,4(r5)
 1804930:	10820014 	ori	r2,r2,2048
 1804934:	2880030d 	sth	r2,12(r5)
 1804938:	00c04b0e 	bge	zero,r3,1804a68 <__sflush_r+0x168>
 180493c:	8a000a17 	ldw	r8,40(r17)
 1804940:	40002326 	beq	r8,zero,18049d0 <__sflush_r+0xd0>
 1804944:	9c000017 	ldw	r16,0(r19)
 1804948:	10c4000c 	andi	r3,r2,4096
 180494c:	98000015 	stw	zero,0(r19)
 1804950:	18004826 	beq	r3,zero,1804a74 <__sflush_r+0x174>
 1804954:	89801417 	ldw	r6,80(r17)
 1804958:	10c0010c 	andi	r3,r2,4
 180495c:	18000626 	beq	r3,zero,1804978 <__sflush_r+0x78>
 1804960:	88c00117 	ldw	r3,4(r17)
 1804964:	88800c17 	ldw	r2,48(r17)
 1804968:	30cdc83a 	sub	r6,r6,r3
 180496c:	10000226 	beq	r2,zero,1804978 <__sflush_r+0x78>
 1804970:	88800f17 	ldw	r2,60(r17)
 1804974:	308dc83a 	sub	r6,r6,r2
 1804978:	89400717 	ldw	r5,28(r17)
 180497c:	000f883a 	mov	r7,zero
 1804980:	9809883a 	mov	r4,r19
 1804984:	403ee83a 	callr	r8
 1804988:	00ffffc4 	movi	r3,-1
 180498c:	10c04426 	beq	r2,r3,1804aa0 <__sflush_r+0x1a0>
 1804990:	88c0030b 	ldhu	r3,12(r17)
 1804994:	89000417 	ldw	r4,16(r17)
 1804998:	88000115 	stw	zero,4(r17)
 180499c:	197dffcc 	andi	r5,r3,63487
 18049a0:	8940030d 	sth	r5,12(r17)
 18049a4:	89000015 	stw	r4,0(r17)
 18049a8:	18c4000c 	andi	r3,r3,4096
 18049ac:	18002c1e 	bne	r3,zero,1804a60 <__sflush_r+0x160>
 18049b0:	89400c17 	ldw	r5,48(r17)
 18049b4:	9c000015 	stw	r16,0(r19)
 18049b8:	28000526 	beq	r5,zero,18049d0 <__sflush_r+0xd0>
 18049bc:	88801004 	addi	r2,r17,64
 18049c0:	28800226 	beq	r5,r2,18049cc <__sflush_r+0xcc>
 18049c4:	9809883a 	mov	r4,r19
 18049c8:	180506c0 	call	180506c <_free_r>
 18049cc:	88000c15 	stw	zero,48(r17)
 18049d0:	0005883a 	mov	r2,zero
 18049d4:	dfc00417 	ldw	ra,16(sp)
 18049d8:	dcc00317 	ldw	r19,12(sp)
 18049dc:	dc800217 	ldw	r18,8(sp)
 18049e0:	dc400117 	ldw	r17,4(sp)
 18049e4:	dc000017 	ldw	r16,0(sp)
 18049e8:	dec00504 	addi	sp,sp,20
 18049ec:	f800283a 	ret
 18049f0:	2c800417 	ldw	r18,16(r5)
 18049f4:	903ff626 	beq	r18,zero,18049d0 <__ram_exceptions_end+0xff7f458c>
 18049f8:	2c000017 	ldw	r16,0(r5)
 18049fc:	108000cc 	andi	r2,r2,3
 1804a00:	2c800015 	stw	r18,0(r5)
 1804a04:	84a1c83a 	sub	r16,r16,r18
 1804a08:	1000131e 	bne	r2,zero,1804a58 <__sflush_r+0x158>
 1804a0c:	28800517 	ldw	r2,20(r5)
 1804a10:	88800215 	stw	r2,8(r17)
 1804a14:	04000316 	blt	zero,r16,1804a24 <__sflush_r+0x124>
 1804a18:	003fed06 	br	18049d0 <__ram_exceptions_end+0xff7f458c>
 1804a1c:	90a5883a 	add	r18,r18,r2
 1804a20:	043feb0e 	bge	zero,r16,18049d0 <__ram_exceptions_end+0xff7f458c>
 1804a24:	88800917 	ldw	r2,36(r17)
 1804a28:	89400717 	ldw	r5,28(r17)
 1804a2c:	800f883a 	mov	r7,r16
 1804a30:	900d883a 	mov	r6,r18
 1804a34:	9809883a 	mov	r4,r19
 1804a38:	103ee83a 	callr	r2
 1804a3c:	80a1c83a 	sub	r16,r16,r2
 1804a40:	00bff616 	blt	zero,r2,1804a1c <__ram_exceptions_end+0xff7f45d8>
 1804a44:	88c0030b 	ldhu	r3,12(r17)
 1804a48:	00bfffc4 	movi	r2,-1
 1804a4c:	18c01014 	ori	r3,r3,64
 1804a50:	88c0030d 	sth	r3,12(r17)
 1804a54:	003fdf06 	br	18049d4 <__ram_exceptions_end+0xff7f4590>
 1804a58:	0005883a 	mov	r2,zero
 1804a5c:	003fec06 	br	1804a10 <__ram_exceptions_end+0xff7f45cc>
 1804a60:	88801415 	stw	r2,80(r17)
 1804a64:	003fd206 	br	18049b0 <__ram_exceptions_end+0xff7f456c>
 1804a68:	28c00f17 	ldw	r3,60(r5)
 1804a6c:	00ffb316 	blt	zero,r3,180493c <__ram_exceptions_end+0xff7f44f8>
 1804a70:	003fd706 	br	18049d0 <__ram_exceptions_end+0xff7f458c>
 1804a74:	89400717 	ldw	r5,28(r17)
 1804a78:	000d883a 	mov	r6,zero
 1804a7c:	01c00044 	movi	r7,1
 1804a80:	9809883a 	mov	r4,r19
 1804a84:	403ee83a 	callr	r8
 1804a88:	100d883a 	mov	r6,r2
 1804a8c:	00bfffc4 	movi	r2,-1
 1804a90:	30801426 	beq	r6,r2,1804ae4 <__sflush_r+0x1e4>
 1804a94:	8880030b 	ldhu	r2,12(r17)
 1804a98:	8a000a17 	ldw	r8,40(r17)
 1804a9c:	003fae06 	br	1804958 <__ram_exceptions_end+0xff7f4514>
 1804aa0:	98c00017 	ldw	r3,0(r19)
 1804aa4:	183fba26 	beq	r3,zero,1804990 <__ram_exceptions_end+0xff7f454c>
 1804aa8:	01000744 	movi	r4,29
 1804aac:	19000626 	beq	r3,r4,1804ac8 <__sflush_r+0x1c8>
 1804ab0:	01000584 	movi	r4,22
 1804ab4:	19000426 	beq	r3,r4,1804ac8 <__sflush_r+0x1c8>
 1804ab8:	88c0030b 	ldhu	r3,12(r17)
 1804abc:	18c01014 	ori	r3,r3,64
 1804ac0:	88c0030d 	sth	r3,12(r17)
 1804ac4:	003fc306 	br	18049d4 <__ram_exceptions_end+0xff7f4590>
 1804ac8:	8880030b 	ldhu	r2,12(r17)
 1804acc:	88c00417 	ldw	r3,16(r17)
 1804ad0:	88000115 	stw	zero,4(r17)
 1804ad4:	10bdffcc 	andi	r2,r2,63487
 1804ad8:	8880030d 	sth	r2,12(r17)
 1804adc:	88c00015 	stw	r3,0(r17)
 1804ae0:	003fb306 	br	18049b0 <__ram_exceptions_end+0xff7f456c>
 1804ae4:	98800017 	ldw	r2,0(r19)
 1804ae8:	103fea26 	beq	r2,zero,1804a94 <__ram_exceptions_end+0xff7f4650>
 1804aec:	00c00744 	movi	r3,29
 1804af0:	10c00226 	beq	r2,r3,1804afc <__sflush_r+0x1fc>
 1804af4:	00c00584 	movi	r3,22
 1804af8:	10c0031e 	bne	r2,r3,1804b08 <__sflush_r+0x208>
 1804afc:	9c000015 	stw	r16,0(r19)
 1804b00:	0005883a 	mov	r2,zero
 1804b04:	003fb306 	br	18049d4 <__ram_exceptions_end+0xff7f4590>
 1804b08:	88c0030b 	ldhu	r3,12(r17)
 1804b0c:	3005883a 	mov	r2,r6
 1804b10:	18c01014 	ori	r3,r3,64
 1804b14:	88c0030d 	sth	r3,12(r17)
 1804b18:	003fae06 	br	18049d4 <__ram_exceptions_end+0xff7f4590>

01804b1c <_fflush_r>:
 1804b1c:	defffd04 	addi	sp,sp,-12
 1804b20:	dc000115 	stw	r16,4(sp)
 1804b24:	dfc00215 	stw	ra,8(sp)
 1804b28:	2021883a 	mov	r16,r4
 1804b2c:	20000226 	beq	r4,zero,1804b38 <_fflush_r+0x1c>
 1804b30:	20800e17 	ldw	r2,56(r4)
 1804b34:	10000c26 	beq	r2,zero,1804b68 <_fflush_r+0x4c>
 1804b38:	2880030f 	ldh	r2,12(r5)
 1804b3c:	1000051e 	bne	r2,zero,1804b54 <_fflush_r+0x38>
 1804b40:	0005883a 	mov	r2,zero
 1804b44:	dfc00217 	ldw	ra,8(sp)
 1804b48:	dc000117 	ldw	r16,4(sp)
 1804b4c:	dec00304 	addi	sp,sp,12
 1804b50:	f800283a 	ret
 1804b54:	8009883a 	mov	r4,r16
 1804b58:	dfc00217 	ldw	ra,8(sp)
 1804b5c:	dc000117 	ldw	r16,4(sp)
 1804b60:	dec00304 	addi	sp,sp,12
 1804b64:	18049001 	jmpi	1804900 <__sflush_r>
 1804b68:	d9400015 	stw	r5,0(sp)
 1804b6c:	1804ef80 	call	1804ef8 <__sinit>
 1804b70:	d9400017 	ldw	r5,0(sp)
 1804b74:	003ff006 	br	1804b38 <__ram_exceptions_end+0xff7f46f4>

01804b78 <fflush>:
 1804b78:	20000526 	beq	r4,zero,1804b90 <fflush+0x18>
 1804b7c:	00806134 	movhi	r2,388
 1804b80:	10975504 	addi	r2,r2,23892
 1804b84:	200b883a 	mov	r5,r4
 1804b88:	11000017 	ldw	r4,0(r2)
 1804b8c:	1804b1c1 	jmpi	1804b1c <_fflush_r>
 1804b90:	00806134 	movhi	r2,388
 1804b94:	10975404 	addi	r2,r2,23888
 1804b98:	11000017 	ldw	r4,0(r2)
 1804b9c:	01406034 	movhi	r5,384
 1804ba0:	2952c704 	addi	r5,r5,19228
 1804ba4:	18054401 	jmpi	1805440 <_fwalk_reent>

01804ba8 <__fp_unlock>:
 1804ba8:	0005883a 	mov	r2,zero
 1804bac:	f800283a 	ret

01804bb0 <_cleanup_r>:
 1804bb0:	01406074 	movhi	r5,385
 1804bb4:	29638c04 	addi	r5,r5,-29136
 1804bb8:	18054401 	jmpi	1805440 <_fwalk_reent>

01804bbc <__sinit.part.1>:
 1804bbc:	defff704 	addi	sp,sp,-36
 1804bc0:	00c06034 	movhi	r3,384
 1804bc4:	dfc00815 	stw	ra,32(sp)
 1804bc8:	ddc00715 	stw	r23,28(sp)
 1804bcc:	dd800615 	stw	r22,24(sp)
 1804bd0:	dd400515 	stw	r21,20(sp)
 1804bd4:	dd000415 	stw	r20,16(sp)
 1804bd8:	dcc00315 	stw	r19,12(sp)
 1804bdc:	dc800215 	stw	r18,8(sp)
 1804be0:	dc400115 	stw	r17,4(sp)
 1804be4:	dc000015 	stw	r16,0(sp)
 1804be8:	18d2ec04 	addi	r3,r3,19376
 1804bec:	24000117 	ldw	r16,4(r4)
 1804bf0:	20c00f15 	stw	r3,60(r4)
 1804bf4:	2080bb04 	addi	r2,r4,748
 1804bf8:	00c000c4 	movi	r3,3
 1804bfc:	20c0b915 	stw	r3,740(r4)
 1804c00:	2080ba15 	stw	r2,744(r4)
 1804c04:	2000b815 	stw	zero,736(r4)
 1804c08:	05c00204 	movi	r23,8
 1804c0c:	00800104 	movi	r2,4
 1804c10:	2025883a 	mov	r18,r4
 1804c14:	b80d883a 	mov	r6,r23
 1804c18:	81001704 	addi	r4,r16,92
 1804c1c:	000b883a 	mov	r5,zero
 1804c20:	80000015 	stw	zero,0(r16)
 1804c24:	80000115 	stw	zero,4(r16)
 1804c28:	80000215 	stw	zero,8(r16)
 1804c2c:	8080030d 	sth	r2,12(r16)
 1804c30:	80001915 	stw	zero,100(r16)
 1804c34:	8000038d 	sth	zero,14(r16)
 1804c38:	80000415 	stw	zero,16(r16)
 1804c3c:	80000515 	stw	zero,20(r16)
 1804c40:	80000615 	stw	zero,24(r16)
 1804c44:	18061d40 	call	18061d4 <memset>
 1804c48:	05806034 	movhi	r22,384
 1804c4c:	94400217 	ldw	r17,8(r18)
 1804c50:	05406034 	movhi	r21,384
 1804c54:	05006034 	movhi	r20,384
 1804c58:	04c06034 	movhi	r19,384
 1804c5c:	b59cf004 	addi	r22,r22,29632
 1804c60:	ad5d0704 	addi	r21,r21,29724
 1804c64:	a51d2604 	addi	r20,r20,29848
 1804c68:	9cdd3d04 	addi	r19,r19,29940
 1804c6c:	85800815 	stw	r22,32(r16)
 1804c70:	85400915 	stw	r21,36(r16)
 1804c74:	85000a15 	stw	r20,40(r16)
 1804c78:	84c00b15 	stw	r19,44(r16)
 1804c7c:	84000715 	stw	r16,28(r16)
 1804c80:	00800284 	movi	r2,10
 1804c84:	8880030d 	sth	r2,12(r17)
 1804c88:	00800044 	movi	r2,1
 1804c8c:	b80d883a 	mov	r6,r23
 1804c90:	89001704 	addi	r4,r17,92
 1804c94:	000b883a 	mov	r5,zero
 1804c98:	88000015 	stw	zero,0(r17)
 1804c9c:	88000115 	stw	zero,4(r17)
 1804ca0:	88000215 	stw	zero,8(r17)
 1804ca4:	88001915 	stw	zero,100(r17)
 1804ca8:	8880038d 	sth	r2,14(r17)
 1804cac:	88000415 	stw	zero,16(r17)
 1804cb0:	88000515 	stw	zero,20(r17)
 1804cb4:	88000615 	stw	zero,24(r17)
 1804cb8:	18061d40 	call	18061d4 <memset>
 1804cbc:	94000317 	ldw	r16,12(r18)
 1804cc0:	00800484 	movi	r2,18
 1804cc4:	8c400715 	stw	r17,28(r17)
 1804cc8:	8d800815 	stw	r22,32(r17)
 1804ccc:	8d400915 	stw	r21,36(r17)
 1804cd0:	8d000a15 	stw	r20,40(r17)
 1804cd4:	8cc00b15 	stw	r19,44(r17)
 1804cd8:	8080030d 	sth	r2,12(r16)
 1804cdc:	00800084 	movi	r2,2
 1804ce0:	80000015 	stw	zero,0(r16)
 1804ce4:	80000115 	stw	zero,4(r16)
 1804ce8:	80000215 	stw	zero,8(r16)
 1804cec:	80001915 	stw	zero,100(r16)
 1804cf0:	8080038d 	sth	r2,14(r16)
 1804cf4:	80000415 	stw	zero,16(r16)
 1804cf8:	80000515 	stw	zero,20(r16)
 1804cfc:	80000615 	stw	zero,24(r16)
 1804d00:	b80d883a 	mov	r6,r23
 1804d04:	000b883a 	mov	r5,zero
 1804d08:	81001704 	addi	r4,r16,92
 1804d0c:	18061d40 	call	18061d4 <memset>
 1804d10:	00800044 	movi	r2,1
 1804d14:	84000715 	stw	r16,28(r16)
 1804d18:	85800815 	stw	r22,32(r16)
 1804d1c:	85400915 	stw	r21,36(r16)
 1804d20:	85000a15 	stw	r20,40(r16)
 1804d24:	84c00b15 	stw	r19,44(r16)
 1804d28:	90800e15 	stw	r2,56(r18)
 1804d2c:	dfc00817 	ldw	ra,32(sp)
 1804d30:	ddc00717 	ldw	r23,28(sp)
 1804d34:	dd800617 	ldw	r22,24(sp)
 1804d38:	dd400517 	ldw	r21,20(sp)
 1804d3c:	dd000417 	ldw	r20,16(sp)
 1804d40:	dcc00317 	ldw	r19,12(sp)
 1804d44:	dc800217 	ldw	r18,8(sp)
 1804d48:	dc400117 	ldw	r17,4(sp)
 1804d4c:	dc000017 	ldw	r16,0(sp)
 1804d50:	dec00904 	addi	sp,sp,36
 1804d54:	f800283a 	ret

01804d58 <__fp_lock>:
 1804d58:	0005883a 	mov	r2,zero
 1804d5c:	f800283a 	ret

01804d60 <__sfmoreglue>:
 1804d60:	defffc04 	addi	sp,sp,-16
 1804d64:	dc400115 	stw	r17,4(sp)
 1804d68:	2c7fffc4 	addi	r17,r5,-1
 1804d6c:	8c401a24 	muli	r17,r17,104
 1804d70:	dc800215 	stw	r18,8(sp)
 1804d74:	2825883a 	mov	r18,r5
 1804d78:	89401d04 	addi	r5,r17,116
 1804d7c:	dc000015 	stw	r16,0(sp)
 1804d80:	dfc00315 	stw	ra,12(sp)
 1804d84:	180579c0 	call	180579c <_malloc_r>
 1804d88:	1021883a 	mov	r16,r2
 1804d8c:	10000726 	beq	r2,zero,1804dac <__sfmoreglue+0x4c>
 1804d90:	11000304 	addi	r4,r2,12
 1804d94:	10000015 	stw	zero,0(r2)
 1804d98:	14800115 	stw	r18,4(r2)
 1804d9c:	11000215 	stw	r4,8(r2)
 1804da0:	89801a04 	addi	r6,r17,104
 1804da4:	000b883a 	mov	r5,zero
 1804da8:	18061d40 	call	18061d4 <memset>
 1804dac:	8005883a 	mov	r2,r16
 1804db0:	dfc00317 	ldw	ra,12(sp)
 1804db4:	dc800217 	ldw	r18,8(sp)
 1804db8:	dc400117 	ldw	r17,4(sp)
 1804dbc:	dc000017 	ldw	r16,0(sp)
 1804dc0:	dec00404 	addi	sp,sp,16
 1804dc4:	f800283a 	ret

01804dc8 <__sfp>:
 1804dc8:	defffb04 	addi	sp,sp,-20
 1804dcc:	dc000015 	stw	r16,0(sp)
 1804dd0:	04006134 	movhi	r16,388
 1804dd4:	84175404 	addi	r16,r16,23888
 1804dd8:	dcc00315 	stw	r19,12(sp)
 1804ddc:	2027883a 	mov	r19,r4
 1804de0:	81000017 	ldw	r4,0(r16)
 1804de4:	dfc00415 	stw	ra,16(sp)
 1804de8:	dc800215 	stw	r18,8(sp)
 1804dec:	20800e17 	ldw	r2,56(r4)
 1804df0:	dc400115 	stw	r17,4(sp)
 1804df4:	1000021e 	bne	r2,zero,1804e00 <__sfp+0x38>
 1804df8:	1804bbc0 	call	1804bbc <__sinit.part.1>
 1804dfc:	81000017 	ldw	r4,0(r16)
 1804e00:	2480b804 	addi	r18,r4,736
 1804e04:	047fffc4 	movi	r17,-1
 1804e08:	91000117 	ldw	r4,4(r18)
 1804e0c:	94000217 	ldw	r16,8(r18)
 1804e10:	213fffc4 	addi	r4,r4,-1
 1804e14:	20000a16 	blt	r4,zero,1804e40 <__sfp+0x78>
 1804e18:	8080030f 	ldh	r2,12(r16)
 1804e1c:	10000c26 	beq	r2,zero,1804e50 <__sfp+0x88>
 1804e20:	80c01d04 	addi	r3,r16,116
 1804e24:	00000206 	br	1804e30 <__sfp+0x68>
 1804e28:	18bfe60f 	ldh	r2,-104(r3)
 1804e2c:	10000826 	beq	r2,zero,1804e50 <__sfp+0x88>
 1804e30:	213fffc4 	addi	r4,r4,-1
 1804e34:	1c3ffd04 	addi	r16,r3,-12
 1804e38:	18c01a04 	addi	r3,r3,104
 1804e3c:	247ffa1e 	bne	r4,r17,1804e28 <__ram_exceptions_end+0xff7f49e4>
 1804e40:	90800017 	ldw	r2,0(r18)
 1804e44:	10001d26 	beq	r2,zero,1804ebc <__sfp+0xf4>
 1804e48:	1025883a 	mov	r18,r2
 1804e4c:	003fee06 	br	1804e08 <__ram_exceptions_end+0xff7f49c4>
 1804e50:	00bfffc4 	movi	r2,-1
 1804e54:	8080038d 	sth	r2,14(r16)
 1804e58:	00800044 	movi	r2,1
 1804e5c:	8080030d 	sth	r2,12(r16)
 1804e60:	80001915 	stw	zero,100(r16)
 1804e64:	80000015 	stw	zero,0(r16)
 1804e68:	80000215 	stw	zero,8(r16)
 1804e6c:	80000115 	stw	zero,4(r16)
 1804e70:	80000415 	stw	zero,16(r16)
 1804e74:	80000515 	stw	zero,20(r16)
 1804e78:	80000615 	stw	zero,24(r16)
 1804e7c:	01800204 	movi	r6,8
 1804e80:	000b883a 	mov	r5,zero
 1804e84:	81001704 	addi	r4,r16,92
 1804e88:	18061d40 	call	18061d4 <memset>
 1804e8c:	8005883a 	mov	r2,r16
 1804e90:	80000c15 	stw	zero,48(r16)
 1804e94:	80000d15 	stw	zero,52(r16)
 1804e98:	80001115 	stw	zero,68(r16)
 1804e9c:	80001215 	stw	zero,72(r16)
 1804ea0:	dfc00417 	ldw	ra,16(sp)
 1804ea4:	dcc00317 	ldw	r19,12(sp)
 1804ea8:	dc800217 	ldw	r18,8(sp)
 1804eac:	dc400117 	ldw	r17,4(sp)
 1804eb0:	dc000017 	ldw	r16,0(sp)
 1804eb4:	dec00504 	addi	sp,sp,20
 1804eb8:	f800283a 	ret
 1804ebc:	01400104 	movi	r5,4
 1804ec0:	9809883a 	mov	r4,r19
 1804ec4:	1804d600 	call	1804d60 <__sfmoreglue>
 1804ec8:	90800015 	stw	r2,0(r18)
 1804ecc:	103fde1e 	bne	r2,zero,1804e48 <__ram_exceptions_end+0xff7f4a04>
 1804ed0:	00800304 	movi	r2,12
 1804ed4:	98800015 	stw	r2,0(r19)
 1804ed8:	0005883a 	mov	r2,zero
 1804edc:	003ff006 	br	1804ea0 <__ram_exceptions_end+0xff7f4a5c>

01804ee0 <_cleanup>:
 1804ee0:	00806134 	movhi	r2,388
 1804ee4:	10975404 	addi	r2,r2,23888
 1804ee8:	11000017 	ldw	r4,0(r2)
 1804eec:	01406074 	movhi	r5,385
 1804ef0:	29638c04 	addi	r5,r5,-29136
 1804ef4:	18054401 	jmpi	1805440 <_fwalk_reent>

01804ef8 <__sinit>:
 1804ef8:	20800e17 	ldw	r2,56(r4)
 1804efc:	10000126 	beq	r2,zero,1804f04 <__sinit+0xc>
 1804f00:	f800283a 	ret
 1804f04:	1804bbc1 	jmpi	1804bbc <__sinit.part.1>

01804f08 <__sfp_lock_acquire>:
 1804f08:	f800283a 	ret

01804f0c <__sfp_lock_release>:
 1804f0c:	f800283a 	ret

01804f10 <__sinit_lock_acquire>:
 1804f10:	f800283a 	ret

01804f14 <__sinit_lock_release>:
 1804f14:	f800283a 	ret

01804f18 <__fp_lock_all>:
 1804f18:	00806134 	movhi	r2,388
 1804f1c:	10975504 	addi	r2,r2,23892
 1804f20:	11000017 	ldw	r4,0(r2)
 1804f24:	01406034 	movhi	r5,384
 1804f28:	29535604 	addi	r5,r5,19800
 1804f2c:	180537c1 	jmpi	180537c <_fwalk>

01804f30 <__fp_unlock_all>:
 1804f30:	00806134 	movhi	r2,388
 1804f34:	10975504 	addi	r2,r2,23892
 1804f38:	11000017 	ldw	r4,0(r2)
 1804f3c:	01406034 	movhi	r5,384
 1804f40:	2952ea04 	addi	r5,r5,19368
 1804f44:	180537c1 	jmpi	180537c <_fwalk>

01804f48 <_malloc_trim_r>:
 1804f48:	defffb04 	addi	sp,sp,-20
 1804f4c:	dcc00315 	stw	r19,12(sp)
 1804f50:	04c06134 	movhi	r19,388
 1804f54:	dc800215 	stw	r18,8(sp)
 1804f58:	dc400115 	stw	r17,4(sp)
 1804f5c:	dc000015 	stw	r16,0(sp)
 1804f60:	dfc00415 	stw	ra,16(sp)
 1804f64:	2821883a 	mov	r16,r5
 1804f68:	9cd0f304 	addi	r19,r19,17356
 1804f6c:	2025883a 	mov	r18,r4
 1804f70:	180d54c0 	call	180d54c <__malloc_lock>
 1804f74:	98800217 	ldw	r2,8(r19)
 1804f78:	14400117 	ldw	r17,4(r2)
 1804f7c:	00bfff04 	movi	r2,-4
 1804f80:	88a2703a 	and	r17,r17,r2
 1804f84:	8c21c83a 	sub	r16,r17,r16
 1804f88:	8403fbc4 	addi	r16,r16,4079
 1804f8c:	8020d33a 	srli	r16,r16,12
 1804f90:	0083ffc4 	movi	r2,4095
 1804f94:	843fffc4 	addi	r16,r16,-1
 1804f98:	8020933a 	slli	r16,r16,12
 1804f9c:	1400060e 	bge	r2,r16,1804fb8 <_malloc_trim_r+0x70>
 1804fa0:	000b883a 	mov	r5,zero
 1804fa4:	9009883a 	mov	r4,r18
 1804fa8:	180736c0 	call	180736c <_sbrk_r>
 1804fac:	98c00217 	ldw	r3,8(r19)
 1804fb0:	1c47883a 	add	r3,r3,r17
 1804fb4:	10c00a26 	beq	r2,r3,1804fe0 <_malloc_trim_r+0x98>
 1804fb8:	9009883a 	mov	r4,r18
 1804fbc:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1804fc0:	0005883a 	mov	r2,zero
 1804fc4:	dfc00417 	ldw	ra,16(sp)
 1804fc8:	dcc00317 	ldw	r19,12(sp)
 1804fcc:	dc800217 	ldw	r18,8(sp)
 1804fd0:	dc400117 	ldw	r17,4(sp)
 1804fd4:	dc000017 	ldw	r16,0(sp)
 1804fd8:	dec00504 	addi	sp,sp,20
 1804fdc:	f800283a 	ret
 1804fe0:	040bc83a 	sub	r5,zero,r16
 1804fe4:	9009883a 	mov	r4,r18
 1804fe8:	180736c0 	call	180736c <_sbrk_r>
 1804fec:	00ffffc4 	movi	r3,-1
 1804ff0:	10c00d26 	beq	r2,r3,1805028 <_malloc_trim_r+0xe0>
 1804ff4:	00c06134 	movhi	r3,388
 1804ff8:	18df7504 	addi	r3,r3,32212
 1804ffc:	18800017 	ldw	r2,0(r3)
 1805000:	99000217 	ldw	r4,8(r19)
 1805004:	8c23c83a 	sub	r17,r17,r16
 1805008:	8c400054 	ori	r17,r17,1
 180500c:	1421c83a 	sub	r16,r2,r16
 1805010:	24400115 	stw	r17,4(r4)
 1805014:	9009883a 	mov	r4,r18
 1805018:	1c000015 	stw	r16,0(r3)
 180501c:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805020:	00800044 	movi	r2,1
 1805024:	003fe706 	br	1804fc4 <__ram_exceptions_end+0xff7f4b80>
 1805028:	000b883a 	mov	r5,zero
 180502c:	9009883a 	mov	r4,r18
 1805030:	180736c0 	call	180736c <_sbrk_r>
 1805034:	99000217 	ldw	r4,8(r19)
 1805038:	014003c4 	movi	r5,15
 180503c:	1107c83a 	sub	r3,r2,r4
 1805040:	28ffdd0e 	bge	r5,r3,1804fb8 <__ram_exceptions_end+0xff7f4b74>
 1805044:	01406134 	movhi	r5,388
 1805048:	29575704 	addi	r5,r5,23900
 180504c:	29400017 	ldw	r5,0(r5)
 1805050:	18c00054 	ori	r3,r3,1
 1805054:	20c00115 	stw	r3,4(r4)
 1805058:	00c06134 	movhi	r3,388
 180505c:	1145c83a 	sub	r2,r2,r5
 1805060:	18df7504 	addi	r3,r3,32212
 1805064:	18800015 	stw	r2,0(r3)
 1805068:	003fd306 	br	1804fb8 <__ram_exceptions_end+0xff7f4b74>

0180506c <_free_r>:
 180506c:	28004126 	beq	r5,zero,1805174 <_free_r+0x108>
 1805070:	defffd04 	addi	sp,sp,-12
 1805074:	dc400115 	stw	r17,4(sp)
 1805078:	dc000015 	stw	r16,0(sp)
 180507c:	2023883a 	mov	r17,r4
 1805080:	2821883a 	mov	r16,r5
 1805084:	dfc00215 	stw	ra,8(sp)
 1805088:	180d54c0 	call	180d54c <__malloc_lock>
 180508c:	81ffff17 	ldw	r7,-4(r16)
 1805090:	00bfff84 	movi	r2,-2
 1805094:	01006134 	movhi	r4,388
 1805098:	81bffe04 	addi	r6,r16,-8
 180509c:	3884703a 	and	r2,r7,r2
 18050a0:	2110f304 	addi	r4,r4,17356
 18050a4:	308b883a 	add	r5,r6,r2
 18050a8:	2a400117 	ldw	r9,4(r5)
 18050ac:	22000217 	ldw	r8,8(r4)
 18050b0:	00ffff04 	movi	r3,-4
 18050b4:	48c6703a 	and	r3,r9,r3
 18050b8:	2a005726 	beq	r5,r8,1805218 <_free_r+0x1ac>
 18050bc:	28c00115 	stw	r3,4(r5)
 18050c0:	39c0004c 	andi	r7,r7,1
 18050c4:	3800091e 	bne	r7,zero,18050ec <_free_r+0x80>
 18050c8:	823ffe17 	ldw	r8,-8(r16)
 18050cc:	22400204 	addi	r9,r4,8
 18050d0:	320dc83a 	sub	r6,r6,r8
 18050d4:	31c00217 	ldw	r7,8(r6)
 18050d8:	1205883a 	add	r2,r2,r8
 18050dc:	3a406526 	beq	r7,r9,1805274 <_free_r+0x208>
 18050e0:	32000317 	ldw	r8,12(r6)
 18050e4:	3a000315 	stw	r8,12(r7)
 18050e8:	41c00215 	stw	r7,8(r8)
 18050ec:	28cf883a 	add	r7,r5,r3
 18050f0:	39c00117 	ldw	r7,4(r7)
 18050f4:	39c0004c 	andi	r7,r7,1
 18050f8:	38003a26 	beq	r7,zero,18051e4 <_free_r+0x178>
 18050fc:	10c00054 	ori	r3,r2,1
 1805100:	30c00115 	stw	r3,4(r6)
 1805104:	3087883a 	add	r3,r6,r2
 1805108:	18800015 	stw	r2,0(r3)
 180510c:	00c07fc4 	movi	r3,511
 1805110:	18801936 	bltu	r3,r2,1805178 <_free_r+0x10c>
 1805114:	1004d0fa 	srli	r2,r2,3
 1805118:	01c00044 	movi	r7,1
 180511c:	21400117 	ldw	r5,4(r4)
 1805120:	10c00044 	addi	r3,r2,1
 1805124:	18c7883a 	add	r3,r3,r3
 1805128:	1005d0ba 	srai	r2,r2,2
 180512c:	18c7883a 	add	r3,r3,r3
 1805130:	18c7883a 	add	r3,r3,r3
 1805134:	1907883a 	add	r3,r3,r4
 1805138:	3884983a 	sll	r2,r7,r2
 180513c:	19c00017 	ldw	r7,0(r3)
 1805140:	1a3ffe04 	addi	r8,r3,-8
 1805144:	1144b03a 	or	r2,r2,r5
 1805148:	32000315 	stw	r8,12(r6)
 180514c:	31c00215 	stw	r7,8(r6)
 1805150:	20800115 	stw	r2,4(r4)
 1805154:	19800015 	stw	r6,0(r3)
 1805158:	39800315 	stw	r6,12(r7)
 180515c:	8809883a 	mov	r4,r17
 1805160:	dfc00217 	ldw	ra,8(sp)
 1805164:	dc400117 	ldw	r17,4(sp)
 1805168:	dc000017 	ldw	r16,0(sp)
 180516c:	dec00304 	addi	sp,sp,12
 1805170:	180d5ac1 	jmpi	180d5ac <__malloc_unlock>
 1805174:	f800283a 	ret
 1805178:	100ad27a 	srli	r5,r2,9
 180517c:	00c00104 	movi	r3,4
 1805180:	19404a36 	bltu	r3,r5,18052ac <_free_r+0x240>
 1805184:	100ad1ba 	srli	r5,r2,6
 1805188:	28c00e44 	addi	r3,r5,57
 180518c:	18c7883a 	add	r3,r3,r3
 1805190:	29400e04 	addi	r5,r5,56
 1805194:	18c7883a 	add	r3,r3,r3
 1805198:	18c7883a 	add	r3,r3,r3
 180519c:	1909883a 	add	r4,r3,r4
 18051a0:	20c00017 	ldw	r3,0(r4)
 18051a4:	01c06134 	movhi	r7,388
 18051a8:	213ffe04 	addi	r4,r4,-8
 18051ac:	39d0f304 	addi	r7,r7,17356
 18051b0:	20c04426 	beq	r4,r3,18052c4 <_free_r+0x258>
 18051b4:	01ffff04 	movi	r7,-4
 18051b8:	19400117 	ldw	r5,4(r3)
 18051bc:	29ca703a 	and	r5,r5,r7
 18051c0:	1140022e 	bgeu	r2,r5,18051cc <_free_r+0x160>
 18051c4:	18c00217 	ldw	r3,8(r3)
 18051c8:	20fffb1e 	bne	r4,r3,18051b8 <__ram_exceptions_end+0xff7f4d74>
 18051cc:	19000317 	ldw	r4,12(r3)
 18051d0:	31000315 	stw	r4,12(r6)
 18051d4:	30c00215 	stw	r3,8(r6)
 18051d8:	21800215 	stw	r6,8(r4)
 18051dc:	19800315 	stw	r6,12(r3)
 18051e0:	003fde06 	br	180515c <__ram_exceptions_end+0xff7f4d18>
 18051e4:	29c00217 	ldw	r7,8(r5)
 18051e8:	10c5883a 	add	r2,r2,r3
 18051ec:	00c06134 	movhi	r3,388
 18051f0:	18d0f504 	addi	r3,r3,17364
 18051f4:	38c03b26 	beq	r7,r3,18052e4 <_free_r+0x278>
 18051f8:	2a000317 	ldw	r8,12(r5)
 18051fc:	11400054 	ori	r5,r2,1
 1805200:	3087883a 	add	r3,r6,r2
 1805204:	3a000315 	stw	r8,12(r7)
 1805208:	41c00215 	stw	r7,8(r8)
 180520c:	31400115 	stw	r5,4(r6)
 1805210:	18800015 	stw	r2,0(r3)
 1805214:	003fbd06 	br	180510c <__ram_exceptions_end+0xff7f4cc8>
 1805218:	39c0004c 	andi	r7,r7,1
 180521c:	10c5883a 	add	r2,r2,r3
 1805220:	3800071e 	bne	r7,zero,1805240 <_free_r+0x1d4>
 1805224:	81fffe17 	ldw	r7,-8(r16)
 1805228:	31cdc83a 	sub	r6,r6,r7
 180522c:	30c00317 	ldw	r3,12(r6)
 1805230:	31400217 	ldw	r5,8(r6)
 1805234:	11c5883a 	add	r2,r2,r7
 1805238:	28c00315 	stw	r3,12(r5)
 180523c:	19400215 	stw	r5,8(r3)
 1805240:	10c00054 	ori	r3,r2,1
 1805244:	30c00115 	stw	r3,4(r6)
 1805248:	00c06134 	movhi	r3,388
 180524c:	18d75804 	addi	r3,r3,23904
 1805250:	18c00017 	ldw	r3,0(r3)
 1805254:	21800215 	stw	r6,8(r4)
 1805258:	10ffc036 	bltu	r2,r3,180515c <__ram_exceptions_end+0xff7f4d18>
 180525c:	00806134 	movhi	r2,388
 1805260:	109f2104 	addi	r2,r2,31876
 1805264:	11400017 	ldw	r5,0(r2)
 1805268:	8809883a 	mov	r4,r17
 180526c:	1804f480 	call	1804f48 <_malloc_trim_r>
 1805270:	003fba06 	br	180515c <__ram_exceptions_end+0xff7f4d18>
 1805274:	28c9883a 	add	r4,r5,r3
 1805278:	21000117 	ldw	r4,4(r4)
 180527c:	2100004c 	andi	r4,r4,1
 1805280:	2000391e 	bne	r4,zero,1805368 <_free_r+0x2fc>
 1805284:	29c00217 	ldw	r7,8(r5)
 1805288:	29000317 	ldw	r4,12(r5)
 180528c:	1885883a 	add	r2,r3,r2
 1805290:	10c00054 	ori	r3,r2,1
 1805294:	39000315 	stw	r4,12(r7)
 1805298:	21c00215 	stw	r7,8(r4)
 180529c:	30c00115 	stw	r3,4(r6)
 18052a0:	308d883a 	add	r6,r6,r2
 18052a4:	30800015 	stw	r2,0(r6)
 18052a8:	003fac06 	br	180515c <__ram_exceptions_end+0xff7f4d18>
 18052ac:	00c00504 	movi	r3,20
 18052b0:	19401536 	bltu	r3,r5,1805308 <_free_r+0x29c>
 18052b4:	28c01704 	addi	r3,r5,92
 18052b8:	18c7883a 	add	r3,r3,r3
 18052bc:	294016c4 	addi	r5,r5,91
 18052c0:	003fb406 	br	1805194 <__ram_exceptions_end+0xff7f4d50>
 18052c4:	280bd0ba 	srai	r5,r5,2
 18052c8:	00c00044 	movi	r3,1
 18052cc:	38800117 	ldw	r2,4(r7)
 18052d0:	194a983a 	sll	r5,r3,r5
 18052d4:	2007883a 	mov	r3,r4
 18052d8:	2884b03a 	or	r2,r5,r2
 18052dc:	38800115 	stw	r2,4(r7)
 18052e0:	003fbb06 	br	18051d0 <__ram_exceptions_end+0xff7f4d8c>
 18052e4:	21800515 	stw	r6,20(r4)
 18052e8:	21800415 	stw	r6,16(r4)
 18052ec:	10c00054 	ori	r3,r2,1
 18052f0:	31c00315 	stw	r7,12(r6)
 18052f4:	31c00215 	stw	r7,8(r6)
 18052f8:	30c00115 	stw	r3,4(r6)
 18052fc:	308d883a 	add	r6,r6,r2
 1805300:	30800015 	stw	r2,0(r6)
 1805304:	003f9506 	br	180515c <__ram_exceptions_end+0xff7f4d18>
 1805308:	00c01504 	movi	r3,84
 180530c:	19400536 	bltu	r3,r5,1805324 <_free_r+0x2b8>
 1805310:	100ad33a 	srli	r5,r2,12
 1805314:	28c01bc4 	addi	r3,r5,111
 1805318:	18c7883a 	add	r3,r3,r3
 180531c:	29401b84 	addi	r5,r5,110
 1805320:	003f9c06 	br	1805194 <__ram_exceptions_end+0xff7f4d50>
 1805324:	00c05504 	movi	r3,340
 1805328:	19400536 	bltu	r3,r5,1805340 <_free_r+0x2d4>
 180532c:	100ad3fa 	srli	r5,r2,15
 1805330:	28c01e04 	addi	r3,r5,120
 1805334:	18c7883a 	add	r3,r3,r3
 1805338:	29401dc4 	addi	r5,r5,119
 180533c:	003f9506 	br	1805194 <__ram_exceptions_end+0xff7f4d50>
 1805340:	00c15504 	movi	r3,1364
 1805344:	19400536 	bltu	r3,r5,180535c <_free_r+0x2f0>
 1805348:	100ad4ba 	srli	r5,r2,18
 180534c:	28c01f44 	addi	r3,r5,125
 1805350:	18c7883a 	add	r3,r3,r3
 1805354:	29401f04 	addi	r5,r5,124
 1805358:	003f8e06 	br	1805194 <__ram_exceptions_end+0xff7f4d50>
 180535c:	00c03f84 	movi	r3,254
 1805360:	01401f84 	movi	r5,126
 1805364:	003f8b06 	br	1805194 <__ram_exceptions_end+0xff7f4d50>
 1805368:	10c00054 	ori	r3,r2,1
 180536c:	30c00115 	stw	r3,4(r6)
 1805370:	308d883a 	add	r6,r6,r2
 1805374:	30800015 	stw	r2,0(r6)
 1805378:	003f7806 	br	180515c <__ram_exceptions_end+0xff7f4d18>

0180537c <_fwalk>:
 180537c:	defff704 	addi	sp,sp,-36
 1805380:	dd000415 	stw	r20,16(sp)
 1805384:	dfc00815 	stw	ra,32(sp)
 1805388:	ddc00715 	stw	r23,28(sp)
 180538c:	dd800615 	stw	r22,24(sp)
 1805390:	dd400515 	stw	r21,20(sp)
 1805394:	dcc00315 	stw	r19,12(sp)
 1805398:	dc800215 	stw	r18,8(sp)
 180539c:	dc400115 	stw	r17,4(sp)
 18053a0:	dc000015 	stw	r16,0(sp)
 18053a4:	2500b804 	addi	r20,r4,736
 18053a8:	a0002326 	beq	r20,zero,1805438 <_fwalk+0xbc>
 18053ac:	282b883a 	mov	r21,r5
 18053b0:	002f883a 	mov	r23,zero
 18053b4:	05800044 	movi	r22,1
 18053b8:	04ffffc4 	movi	r19,-1
 18053bc:	a4400117 	ldw	r17,4(r20)
 18053c0:	a4800217 	ldw	r18,8(r20)
 18053c4:	8c7fffc4 	addi	r17,r17,-1
 18053c8:	88000d16 	blt	r17,zero,1805400 <_fwalk+0x84>
 18053cc:	94000304 	addi	r16,r18,12
 18053d0:	94800384 	addi	r18,r18,14
 18053d4:	8080000b 	ldhu	r2,0(r16)
 18053d8:	8c7fffc4 	addi	r17,r17,-1
 18053dc:	813ffd04 	addi	r4,r16,-12
 18053e0:	b080042e 	bgeu	r22,r2,18053f4 <_fwalk+0x78>
 18053e4:	9080000f 	ldh	r2,0(r18)
 18053e8:	14c00226 	beq	r2,r19,18053f4 <_fwalk+0x78>
 18053ec:	a83ee83a 	callr	r21
 18053f0:	b8aeb03a 	or	r23,r23,r2
 18053f4:	84001a04 	addi	r16,r16,104
 18053f8:	94801a04 	addi	r18,r18,104
 18053fc:	8cfff51e 	bne	r17,r19,18053d4 <__ram_exceptions_end+0xff7f4f90>
 1805400:	a5000017 	ldw	r20,0(r20)
 1805404:	a03fed1e 	bne	r20,zero,18053bc <__ram_exceptions_end+0xff7f4f78>
 1805408:	b805883a 	mov	r2,r23
 180540c:	dfc00817 	ldw	ra,32(sp)
 1805410:	ddc00717 	ldw	r23,28(sp)
 1805414:	dd800617 	ldw	r22,24(sp)
 1805418:	dd400517 	ldw	r21,20(sp)
 180541c:	dd000417 	ldw	r20,16(sp)
 1805420:	dcc00317 	ldw	r19,12(sp)
 1805424:	dc800217 	ldw	r18,8(sp)
 1805428:	dc400117 	ldw	r17,4(sp)
 180542c:	dc000017 	ldw	r16,0(sp)
 1805430:	dec00904 	addi	sp,sp,36
 1805434:	f800283a 	ret
 1805438:	002f883a 	mov	r23,zero
 180543c:	003ff206 	br	1805408 <__ram_exceptions_end+0xff7f4fc4>

01805440 <_fwalk_reent>:
 1805440:	defff704 	addi	sp,sp,-36
 1805444:	dd000415 	stw	r20,16(sp)
 1805448:	dfc00815 	stw	ra,32(sp)
 180544c:	ddc00715 	stw	r23,28(sp)
 1805450:	dd800615 	stw	r22,24(sp)
 1805454:	dd400515 	stw	r21,20(sp)
 1805458:	dcc00315 	stw	r19,12(sp)
 180545c:	dc800215 	stw	r18,8(sp)
 1805460:	dc400115 	stw	r17,4(sp)
 1805464:	dc000015 	stw	r16,0(sp)
 1805468:	2500b804 	addi	r20,r4,736
 180546c:	a0002326 	beq	r20,zero,18054fc <_fwalk_reent+0xbc>
 1805470:	282b883a 	mov	r21,r5
 1805474:	2027883a 	mov	r19,r4
 1805478:	002f883a 	mov	r23,zero
 180547c:	05800044 	movi	r22,1
 1805480:	04bfffc4 	movi	r18,-1
 1805484:	a4400117 	ldw	r17,4(r20)
 1805488:	a4000217 	ldw	r16,8(r20)
 180548c:	8c7fffc4 	addi	r17,r17,-1
 1805490:	88000c16 	blt	r17,zero,18054c4 <_fwalk_reent+0x84>
 1805494:	84000304 	addi	r16,r16,12
 1805498:	8080000b 	ldhu	r2,0(r16)
 180549c:	8c7fffc4 	addi	r17,r17,-1
 18054a0:	817ffd04 	addi	r5,r16,-12
 18054a4:	b080052e 	bgeu	r22,r2,18054bc <_fwalk_reent+0x7c>
 18054a8:	8080008f 	ldh	r2,2(r16)
 18054ac:	9809883a 	mov	r4,r19
 18054b0:	14800226 	beq	r2,r18,18054bc <_fwalk_reent+0x7c>
 18054b4:	a83ee83a 	callr	r21
 18054b8:	b8aeb03a 	or	r23,r23,r2
 18054bc:	84001a04 	addi	r16,r16,104
 18054c0:	8cbff51e 	bne	r17,r18,1805498 <__ram_exceptions_end+0xff7f5054>
 18054c4:	a5000017 	ldw	r20,0(r20)
 18054c8:	a03fee1e 	bne	r20,zero,1805484 <__ram_exceptions_end+0xff7f5040>
 18054cc:	b805883a 	mov	r2,r23
 18054d0:	dfc00817 	ldw	ra,32(sp)
 18054d4:	ddc00717 	ldw	r23,28(sp)
 18054d8:	dd800617 	ldw	r22,24(sp)
 18054dc:	dd400517 	ldw	r21,20(sp)
 18054e0:	dd000417 	ldw	r20,16(sp)
 18054e4:	dcc00317 	ldw	r19,12(sp)
 18054e8:	dc800217 	ldw	r18,8(sp)
 18054ec:	dc400117 	ldw	r17,4(sp)
 18054f0:	dc000017 	ldw	r16,0(sp)
 18054f4:	dec00904 	addi	sp,sp,36
 18054f8:	f800283a 	ret
 18054fc:	002f883a 	mov	r23,zero
 1805500:	003ff206 	br	18054cc <__ram_exceptions_end+0xff7f5088>

01805504 <_setlocale_r>:
 1805504:	30001b26 	beq	r6,zero,1805574 <_setlocale_r+0x70>
 1805508:	01406134 	movhi	r5,388
 180550c:	defffe04 	addi	sp,sp,-8
 1805510:	2944fb04 	addi	r5,r5,5100
 1805514:	3009883a 	mov	r4,r6
 1805518:	dc000015 	stw	r16,0(sp)
 180551c:	dfc00115 	stw	ra,4(sp)
 1805520:	3021883a 	mov	r16,r6
 1805524:	18074fc0 	call	18074fc <strcmp>
 1805528:	1000061e 	bne	r2,zero,1805544 <_setlocale_r+0x40>
 180552c:	00806134 	movhi	r2,388
 1805530:	1084fa04 	addi	r2,r2,5096
 1805534:	dfc00117 	ldw	ra,4(sp)
 1805538:	dc000017 	ldw	r16,0(sp)
 180553c:	dec00204 	addi	sp,sp,8
 1805540:	f800283a 	ret
 1805544:	01406134 	movhi	r5,388
 1805548:	2944fa04 	addi	r5,r5,5096
 180554c:	8009883a 	mov	r4,r16
 1805550:	18074fc0 	call	18074fc <strcmp>
 1805554:	103ff526 	beq	r2,zero,180552c <__ram_exceptions_end+0xff7f50e8>
 1805558:	01406134 	movhi	r5,388
 180555c:	2944e504 	addi	r5,r5,5012
 1805560:	8009883a 	mov	r4,r16
 1805564:	18074fc0 	call	18074fc <strcmp>
 1805568:	103ff026 	beq	r2,zero,180552c <__ram_exceptions_end+0xff7f50e8>
 180556c:	0005883a 	mov	r2,zero
 1805570:	003ff006 	br	1805534 <__ram_exceptions_end+0xff7f50f0>
 1805574:	00806134 	movhi	r2,388
 1805578:	1084fa04 	addi	r2,r2,5096
 180557c:	f800283a 	ret

01805580 <__locale_charset>:
 1805580:	00806134 	movhi	r2,388
 1805584:	1090dd04 	addi	r2,r2,17268
 1805588:	f800283a 	ret

0180558c <__locale_mb_cur_max>:
 180558c:	00806134 	movhi	r2,388
 1805590:	10975604 	addi	r2,r2,23896
 1805594:	10800017 	ldw	r2,0(r2)
 1805598:	f800283a 	ret

0180559c <__locale_msgcharset>:
 180559c:	00806134 	movhi	r2,388
 18055a0:	1090d504 	addi	r2,r2,17236
 18055a4:	f800283a 	ret

018055a8 <__locale_cjk_lang>:
 18055a8:	0005883a 	mov	r2,zero
 18055ac:	f800283a 	ret

018055b0 <_localeconv_r>:
 18055b0:	00806134 	movhi	r2,388
 18055b4:	1090e504 	addi	r2,r2,17300
 18055b8:	f800283a 	ret

018055bc <setlocale>:
 18055bc:	00806134 	movhi	r2,388
 18055c0:	10975504 	addi	r2,r2,23892
 18055c4:	280d883a 	mov	r6,r5
 18055c8:	200b883a 	mov	r5,r4
 18055cc:	11000017 	ldw	r4,0(r2)
 18055d0:	18055041 	jmpi	1805504 <_setlocale_r>

018055d4 <localeconv>:
 18055d4:	00806134 	movhi	r2,388
 18055d8:	1090e504 	addi	r2,r2,17300
 18055dc:	f800283a 	ret

018055e0 <__smakebuf_r>:
 18055e0:	2880030b 	ldhu	r2,12(r5)
 18055e4:	10c0008c 	andi	r3,r2,2
 18055e8:	1800411e 	bne	r3,zero,18056f0 <__smakebuf_r+0x110>
 18055ec:	deffec04 	addi	sp,sp,-80
 18055f0:	dc000f15 	stw	r16,60(sp)
 18055f4:	2821883a 	mov	r16,r5
 18055f8:	2940038f 	ldh	r5,14(r5)
 18055fc:	dc401015 	stw	r17,64(sp)
 1805600:	dfc01315 	stw	ra,76(sp)
 1805604:	dcc01215 	stw	r19,72(sp)
 1805608:	dc801115 	stw	r18,68(sp)
 180560c:	2023883a 	mov	r17,r4
 1805610:	28001c16 	blt	r5,zero,1805684 <__smakebuf_r+0xa4>
 1805614:	d80d883a 	mov	r6,sp
 1805618:	180913c0 	call	180913c <_fstat_r>
 180561c:	10001816 	blt	r2,zero,1805680 <__smakebuf_r+0xa0>
 1805620:	d8800117 	ldw	r2,4(sp)
 1805624:	00e00014 	movui	r3,32768
 1805628:	10bc000c 	andi	r2,r2,61440
 180562c:	14c80020 	cmpeqi	r19,r2,8192
 1805630:	10c03726 	beq	r2,r3,1805710 <__smakebuf_r+0x130>
 1805634:	80c0030b 	ldhu	r3,12(r16)
 1805638:	18c20014 	ori	r3,r3,2048
 180563c:	80c0030d 	sth	r3,12(r16)
 1805640:	00c80004 	movi	r3,8192
 1805644:	10c0521e 	bne	r2,r3,1805790 <__smakebuf_r+0x1b0>
 1805648:	8140038f 	ldh	r5,14(r16)
 180564c:	8809883a 	mov	r4,r17
 1805650:	18096540 	call	1809654 <_isatty_r>
 1805654:	10004c26 	beq	r2,zero,1805788 <__smakebuf_r+0x1a8>
 1805658:	8080030b 	ldhu	r2,12(r16)
 180565c:	80c010c4 	addi	r3,r16,67
 1805660:	80c00015 	stw	r3,0(r16)
 1805664:	10800054 	ori	r2,r2,1
 1805668:	8080030d 	sth	r2,12(r16)
 180566c:	00800044 	movi	r2,1
 1805670:	80c00415 	stw	r3,16(r16)
 1805674:	80800515 	stw	r2,20(r16)
 1805678:	04810004 	movi	r18,1024
 180567c:	00000706 	br	180569c <__smakebuf_r+0xbc>
 1805680:	8080030b 	ldhu	r2,12(r16)
 1805684:	10c0200c 	andi	r3,r2,128
 1805688:	18001f1e 	bne	r3,zero,1805708 <__smakebuf_r+0x128>
 180568c:	04810004 	movi	r18,1024
 1805690:	10820014 	ori	r2,r2,2048
 1805694:	8080030d 	sth	r2,12(r16)
 1805698:	0027883a 	mov	r19,zero
 180569c:	900b883a 	mov	r5,r18
 18056a0:	8809883a 	mov	r4,r17
 18056a4:	180579c0 	call	180579c <_malloc_r>
 18056a8:	10002c26 	beq	r2,zero,180575c <__smakebuf_r+0x17c>
 18056ac:	80c0030b 	ldhu	r3,12(r16)
 18056b0:	01006034 	movhi	r4,384
 18056b4:	2112ec04 	addi	r4,r4,19376
 18056b8:	89000f15 	stw	r4,60(r17)
 18056bc:	18c02014 	ori	r3,r3,128
 18056c0:	80c0030d 	sth	r3,12(r16)
 18056c4:	80800015 	stw	r2,0(r16)
 18056c8:	80800415 	stw	r2,16(r16)
 18056cc:	84800515 	stw	r18,20(r16)
 18056d0:	98001a1e 	bne	r19,zero,180573c <__smakebuf_r+0x15c>
 18056d4:	dfc01317 	ldw	ra,76(sp)
 18056d8:	dcc01217 	ldw	r19,72(sp)
 18056dc:	dc801117 	ldw	r18,68(sp)
 18056e0:	dc401017 	ldw	r17,64(sp)
 18056e4:	dc000f17 	ldw	r16,60(sp)
 18056e8:	dec01404 	addi	sp,sp,80
 18056ec:	f800283a 	ret
 18056f0:	288010c4 	addi	r2,r5,67
 18056f4:	28800015 	stw	r2,0(r5)
 18056f8:	28800415 	stw	r2,16(r5)
 18056fc:	00800044 	movi	r2,1
 1805700:	28800515 	stw	r2,20(r5)
 1805704:	f800283a 	ret
 1805708:	04801004 	movi	r18,64
 180570c:	003fe006 	br	1805690 <__ram_exceptions_end+0xff7f524c>
 1805710:	81000a17 	ldw	r4,40(r16)
 1805714:	00c06034 	movhi	r3,384
 1805718:	18dd2604 	addi	r3,r3,29848
 180571c:	20ffc51e 	bne	r4,r3,1805634 <__ram_exceptions_end+0xff7f51f0>
 1805720:	8080030b 	ldhu	r2,12(r16)
 1805724:	04810004 	movi	r18,1024
 1805728:	84801315 	stw	r18,76(r16)
 180572c:	1484b03a 	or	r2,r2,r18
 1805730:	8080030d 	sth	r2,12(r16)
 1805734:	0027883a 	mov	r19,zero
 1805738:	003fd806 	br	180569c <__ram_exceptions_end+0xff7f5258>
 180573c:	8140038f 	ldh	r5,14(r16)
 1805740:	8809883a 	mov	r4,r17
 1805744:	18096540 	call	1809654 <_isatty_r>
 1805748:	103fe226 	beq	r2,zero,18056d4 <__ram_exceptions_end+0xff7f5290>
 180574c:	8080030b 	ldhu	r2,12(r16)
 1805750:	10800054 	ori	r2,r2,1
 1805754:	8080030d 	sth	r2,12(r16)
 1805758:	003fde06 	br	18056d4 <__ram_exceptions_end+0xff7f5290>
 180575c:	8080030b 	ldhu	r2,12(r16)
 1805760:	10c0800c 	andi	r3,r2,512
 1805764:	183fdb1e 	bne	r3,zero,18056d4 <__ram_exceptions_end+0xff7f5290>
 1805768:	10800094 	ori	r2,r2,2
 180576c:	80c010c4 	addi	r3,r16,67
 1805770:	8080030d 	sth	r2,12(r16)
 1805774:	00800044 	movi	r2,1
 1805778:	80c00015 	stw	r3,0(r16)
 180577c:	80c00415 	stw	r3,16(r16)
 1805780:	80800515 	stw	r2,20(r16)
 1805784:	003fd306 	br	18056d4 <__ram_exceptions_end+0xff7f5290>
 1805788:	04810004 	movi	r18,1024
 180578c:	003fc306 	br	180569c <__ram_exceptions_end+0xff7f5258>
 1805790:	0027883a 	mov	r19,zero
 1805794:	04810004 	movi	r18,1024
 1805798:	003fc006 	br	180569c <__ram_exceptions_end+0xff7f5258>

0180579c <_malloc_r>:
 180579c:	defff504 	addi	sp,sp,-44
 18057a0:	dc800315 	stw	r18,12(sp)
 18057a4:	dfc00a15 	stw	ra,40(sp)
 18057a8:	df000915 	stw	fp,36(sp)
 18057ac:	ddc00815 	stw	r23,32(sp)
 18057b0:	dd800715 	stw	r22,28(sp)
 18057b4:	dd400615 	stw	r21,24(sp)
 18057b8:	dd000515 	stw	r20,20(sp)
 18057bc:	dcc00415 	stw	r19,16(sp)
 18057c0:	dc400215 	stw	r17,8(sp)
 18057c4:	dc000115 	stw	r16,4(sp)
 18057c8:	288002c4 	addi	r2,r5,11
 18057cc:	00c00584 	movi	r3,22
 18057d0:	2025883a 	mov	r18,r4
 18057d4:	18807f2e 	bgeu	r3,r2,18059d4 <_malloc_r+0x238>
 18057d8:	047ffe04 	movi	r17,-8
 18057dc:	1462703a 	and	r17,r2,r17
 18057e0:	8800a316 	blt	r17,zero,1805a70 <_malloc_r+0x2d4>
 18057e4:	8940a236 	bltu	r17,r5,1805a70 <_malloc_r+0x2d4>
 18057e8:	180d54c0 	call	180d54c <__malloc_lock>
 18057ec:	00807dc4 	movi	r2,503
 18057f0:	1441e92e 	bgeu	r2,r17,1805f98 <_malloc_r+0x7fc>
 18057f4:	8804d27a 	srli	r2,r17,9
 18057f8:	1000a126 	beq	r2,zero,1805a80 <_malloc_r+0x2e4>
 18057fc:	00c00104 	movi	r3,4
 1805800:	18811e36 	bltu	r3,r2,1805c7c <_malloc_r+0x4e0>
 1805804:	8804d1ba 	srli	r2,r17,6
 1805808:	12000e44 	addi	r8,r2,57
 180580c:	11c00e04 	addi	r7,r2,56
 1805810:	4209883a 	add	r4,r8,r8
 1805814:	04c06134 	movhi	r19,388
 1805818:	2109883a 	add	r4,r4,r4
 180581c:	9cd0f304 	addi	r19,r19,17356
 1805820:	2109883a 	add	r4,r4,r4
 1805824:	9909883a 	add	r4,r19,r4
 1805828:	24000117 	ldw	r16,4(r4)
 180582c:	213ffe04 	addi	r4,r4,-8
 1805830:	24009726 	beq	r4,r16,1805a90 <_malloc_r+0x2f4>
 1805834:	80800117 	ldw	r2,4(r16)
 1805838:	01bfff04 	movi	r6,-4
 180583c:	014003c4 	movi	r5,15
 1805840:	1184703a 	and	r2,r2,r6
 1805844:	1447c83a 	sub	r3,r2,r17
 1805848:	28c00716 	blt	r5,r3,1805868 <_malloc_r+0xcc>
 180584c:	1800920e 	bge	r3,zero,1805a98 <_malloc_r+0x2fc>
 1805850:	84000317 	ldw	r16,12(r16)
 1805854:	24008e26 	beq	r4,r16,1805a90 <_malloc_r+0x2f4>
 1805858:	80800117 	ldw	r2,4(r16)
 180585c:	1184703a 	and	r2,r2,r6
 1805860:	1447c83a 	sub	r3,r2,r17
 1805864:	28fff90e 	bge	r5,r3,180584c <__ram_exceptions_end+0xff7f5408>
 1805868:	3809883a 	mov	r4,r7
 180586c:	01806134 	movhi	r6,388
 1805870:	9c000417 	ldw	r16,16(r19)
 1805874:	3190f304 	addi	r6,r6,17356
 1805878:	32000204 	addi	r8,r6,8
 180587c:	82013426 	beq	r16,r8,1805d50 <_malloc_r+0x5b4>
 1805880:	80c00117 	ldw	r3,4(r16)
 1805884:	00bfff04 	movi	r2,-4
 1805888:	188e703a 	and	r7,r3,r2
 180588c:	3c45c83a 	sub	r2,r7,r17
 1805890:	00c003c4 	movi	r3,15
 1805894:	18811f16 	blt	r3,r2,1805d14 <_malloc_r+0x578>
 1805898:	32000515 	stw	r8,20(r6)
 180589c:	32000415 	stw	r8,16(r6)
 18058a0:	10007f0e 	bge	r2,zero,1805aa0 <_malloc_r+0x304>
 18058a4:	00807fc4 	movi	r2,511
 18058a8:	11c0fd36 	bltu	r2,r7,1805ca0 <_malloc_r+0x504>
 18058ac:	3806d0fa 	srli	r3,r7,3
 18058b0:	01c00044 	movi	r7,1
 18058b4:	30800117 	ldw	r2,4(r6)
 18058b8:	19400044 	addi	r5,r3,1
 18058bc:	294b883a 	add	r5,r5,r5
 18058c0:	1807d0ba 	srai	r3,r3,2
 18058c4:	294b883a 	add	r5,r5,r5
 18058c8:	294b883a 	add	r5,r5,r5
 18058cc:	298b883a 	add	r5,r5,r6
 18058d0:	38c6983a 	sll	r3,r7,r3
 18058d4:	29c00017 	ldw	r7,0(r5)
 18058d8:	2a7ffe04 	addi	r9,r5,-8
 18058dc:	1886b03a 	or	r3,r3,r2
 18058e0:	82400315 	stw	r9,12(r16)
 18058e4:	81c00215 	stw	r7,8(r16)
 18058e8:	30c00115 	stw	r3,4(r6)
 18058ec:	2c000015 	stw	r16,0(r5)
 18058f0:	3c000315 	stw	r16,12(r7)
 18058f4:	2005d0ba 	srai	r2,r4,2
 18058f8:	01400044 	movi	r5,1
 18058fc:	288a983a 	sll	r5,r5,r2
 1805900:	19406f36 	bltu	r3,r5,1805ac0 <_malloc_r+0x324>
 1805904:	28c4703a 	and	r2,r5,r3
 1805908:	10000a1e 	bne	r2,zero,1805934 <_malloc_r+0x198>
 180590c:	00bfff04 	movi	r2,-4
 1805910:	294b883a 	add	r5,r5,r5
 1805914:	2088703a 	and	r4,r4,r2
 1805918:	28c4703a 	and	r2,r5,r3
 180591c:	21000104 	addi	r4,r4,4
 1805920:	1000041e 	bne	r2,zero,1805934 <_malloc_r+0x198>
 1805924:	294b883a 	add	r5,r5,r5
 1805928:	28c4703a 	and	r2,r5,r3
 180592c:	21000104 	addi	r4,r4,4
 1805930:	103ffc26 	beq	r2,zero,1805924 <__ram_exceptions_end+0xff7f54e0>
 1805934:	02bfff04 	movi	r10,-4
 1805938:	024003c4 	movi	r9,15
 180593c:	21800044 	addi	r6,r4,1
 1805940:	318d883a 	add	r6,r6,r6
 1805944:	318d883a 	add	r6,r6,r6
 1805948:	318d883a 	add	r6,r6,r6
 180594c:	998d883a 	add	r6,r19,r6
 1805950:	333ffe04 	addi	r12,r6,-8
 1805954:	2017883a 	mov	r11,r4
 1805958:	31800104 	addi	r6,r6,4
 180595c:	34000017 	ldw	r16,0(r6)
 1805960:	31fffd04 	addi	r7,r6,-12
 1805964:	81c0041e 	bne	r16,r7,1805978 <_malloc_r+0x1dc>
 1805968:	0000fb06 	br	1805d58 <_malloc_r+0x5bc>
 180596c:	1801030e 	bge	r3,zero,1805d7c <_malloc_r+0x5e0>
 1805970:	84000317 	ldw	r16,12(r16)
 1805974:	81c0f826 	beq	r16,r7,1805d58 <_malloc_r+0x5bc>
 1805978:	80800117 	ldw	r2,4(r16)
 180597c:	1284703a 	and	r2,r2,r10
 1805980:	1447c83a 	sub	r3,r2,r17
 1805984:	48fff90e 	bge	r9,r3,180596c <__ram_exceptions_end+0xff7f5528>
 1805988:	80800317 	ldw	r2,12(r16)
 180598c:	81000217 	ldw	r4,8(r16)
 1805990:	89400054 	ori	r5,r17,1
 1805994:	81400115 	stw	r5,4(r16)
 1805998:	20800315 	stw	r2,12(r4)
 180599c:	11000215 	stw	r4,8(r2)
 18059a0:	8463883a 	add	r17,r16,r17
 18059a4:	9c400515 	stw	r17,20(r19)
 18059a8:	9c400415 	stw	r17,16(r19)
 18059ac:	18800054 	ori	r2,r3,1
 18059b0:	88800115 	stw	r2,4(r17)
 18059b4:	8a000315 	stw	r8,12(r17)
 18059b8:	8a000215 	stw	r8,8(r17)
 18059bc:	88e3883a 	add	r17,r17,r3
 18059c0:	88c00015 	stw	r3,0(r17)
 18059c4:	9009883a 	mov	r4,r18
 18059c8:	180d5ac0 	call	180d5ac <__malloc_unlock>
 18059cc:	80800204 	addi	r2,r16,8
 18059d0:	00001b06 	br	1805a40 <_malloc_r+0x2a4>
 18059d4:	04400404 	movi	r17,16
 18059d8:	89402536 	bltu	r17,r5,1805a70 <_malloc_r+0x2d4>
 18059dc:	180d54c0 	call	180d54c <__malloc_lock>
 18059e0:	00800184 	movi	r2,6
 18059e4:	01000084 	movi	r4,2
 18059e8:	04c06134 	movhi	r19,388
 18059ec:	1085883a 	add	r2,r2,r2
 18059f0:	9cd0f304 	addi	r19,r19,17356
 18059f4:	1085883a 	add	r2,r2,r2
 18059f8:	9885883a 	add	r2,r19,r2
 18059fc:	14000117 	ldw	r16,4(r2)
 1805a00:	10fffe04 	addi	r3,r2,-8
 1805a04:	80c0d926 	beq	r16,r3,1805d6c <_malloc_r+0x5d0>
 1805a08:	80c00117 	ldw	r3,4(r16)
 1805a0c:	81000317 	ldw	r4,12(r16)
 1805a10:	00bfff04 	movi	r2,-4
 1805a14:	1884703a 	and	r2,r3,r2
 1805a18:	81400217 	ldw	r5,8(r16)
 1805a1c:	8085883a 	add	r2,r16,r2
 1805a20:	10c00117 	ldw	r3,4(r2)
 1805a24:	29000315 	stw	r4,12(r5)
 1805a28:	21400215 	stw	r5,8(r4)
 1805a2c:	18c00054 	ori	r3,r3,1
 1805a30:	10c00115 	stw	r3,4(r2)
 1805a34:	9009883a 	mov	r4,r18
 1805a38:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805a3c:	80800204 	addi	r2,r16,8
 1805a40:	dfc00a17 	ldw	ra,40(sp)
 1805a44:	df000917 	ldw	fp,36(sp)
 1805a48:	ddc00817 	ldw	r23,32(sp)
 1805a4c:	dd800717 	ldw	r22,28(sp)
 1805a50:	dd400617 	ldw	r21,24(sp)
 1805a54:	dd000517 	ldw	r20,20(sp)
 1805a58:	dcc00417 	ldw	r19,16(sp)
 1805a5c:	dc800317 	ldw	r18,12(sp)
 1805a60:	dc400217 	ldw	r17,8(sp)
 1805a64:	dc000117 	ldw	r16,4(sp)
 1805a68:	dec00b04 	addi	sp,sp,44
 1805a6c:	f800283a 	ret
 1805a70:	00800304 	movi	r2,12
 1805a74:	90800015 	stw	r2,0(r18)
 1805a78:	0005883a 	mov	r2,zero
 1805a7c:	003ff006 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805a80:	01002004 	movi	r4,128
 1805a84:	02001004 	movi	r8,64
 1805a88:	01c00fc4 	movi	r7,63
 1805a8c:	003f6106 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805a90:	4009883a 	mov	r4,r8
 1805a94:	003f7506 	br	180586c <__ram_exceptions_end+0xff7f5428>
 1805a98:	81000317 	ldw	r4,12(r16)
 1805a9c:	003fde06 	br	1805a18 <__ram_exceptions_end+0xff7f55d4>
 1805aa0:	81c5883a 	add	r2,r16,r7
 1805aa4:	11400117 	ldw	r5,4(r2)
 1805aa8:	9009883a 	mov	r4,r18
 1805aac:	29400054 	ori	r5,r5,1
 1805ab0:	11400115 	stw	r5,4(r2)
 1805ab4:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805ab8:	80800204 	addi	r2,r16,8
 1805abc:	003fe006 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805ac0:	9c000217 	ldw	r16,8(r19)
 1805ac4:	00bfff04 	movi	r2,-4
 1805ac8:	85800117 	ldw	r22,4(r16)
 1805acc:	b0ac703a 	and	r22,r22,r2
 1805ad0:	b4400336 	bltu	r22,r17,1805ae0 <_malloc_r+0x344>
 1805ad4:	b445c83a 	sub	r2,r22,r17
 1805ad8:	00c003c4 	movi	r3,15
 1805adc:	18805d16 	blt	r3,r2,1805c54 <_malloc_r+0x4b8>
 1805ae0:	05c06134 	movhi	r23,388
 1805ae4:	00806134 	movhi	r2,388
 1805ae8:	109f2104 	addi	r2,r2,31876
 1805aec:	bdd75704 	addi	r23,r23,23900
 1805af0:	15400017 	ldw	r21,0(r2)
 1805af4:	b8c00017 	ldw	r3,0(r23)
 1805af8:	00bfffc4 	movi	r2,-1
 1805afc:	858d883a 	add	r6,r16,r22
 1805b00:	8d6b883a 	add	r21,r17,r21
 1805b04:	1880ea26 	beq	r3,r2,1805eb0 <_malloc_r+0x714>
 1805b08:	ad4403c4 	addi	r21,r21,4111
 1805b0c:	00bc0004 	movi	r2,-4096
 1805b10:	a8aa703a 	and	r21,r21,r2
 1805b14:	a80b883a 	mov	r5,r21
 1805b18:	9009883a 	mov	r4,r18
 1805b1c:	d9800015 	stw	r6,0(sp)
 1805b20:	180736c0 	call	180736c <_sbrk_r>
 1805b24:	1029883a 	mov	r20,r2
 1805b28:	00bfffc4 	movi	r2,-1
 1805b2c:	d9800017 	ldw	r6,0(sp)
 1805b30:	a080e826 	beq	r20,r2,1805ed4 <_malloc_r+0x738>
 1805b34:	a180a636 	bltu	r20,r6,1805dd0 <_malloc_r+0x634>
 1805b38:	07006134 	movhi	fp,388
 1805b3c:	e71f7504 	addi	fp,fp,32212
 1805b40:	e0800017 	ldw	r2,0(fp)
 1805b44:	a887883a 	add	r3,r21,r2
 1805b48:	e0c00015 	stw	r3,0(fp)
 1805b4c:	3500e626 	beq	r6,r20,1805ee8 <_malloc_r+0x74c>
 1805b50:	b9000017 	ldw	r4,0(r23)
 1805b54:	00bfffc4 	movi	r2,-1
 1805b58:	2080ee26 	beq	r4,r2,1805f14 <_malloc_r+0x778>
 1805b5c:	a185c83a 	sub	r2,r20,r6
 1805b60:	10c5883a 	add	r2,r2,r3
 1805b64:	e0800015 	stw	r2,0(fp)
 1805b68:	a0c001cc 	andi	r3,r20,7
 1805b6c:	1800bc26 	beq	r3,zero,1805e60 <_malloc_r+0x6c4>
 1805b70:	a0e9c83a 	sub	r20,r20,r3
 1805b74:	00840204 	movi	r2,4104
 1805b78:	a5000204 	addi	r20,r20,8
 1805b7c:	10c7c83a 	sub	r3,r2,r3
 1805b80:	a545883a 	add	r2,r20,r21
 1805b84:	1083ffcc 	andi	r2,r2,4095
 1805b88:	18abc83a 	sub	r21,r3,r2
 1805b8c:	a80b883a 	mov	r5,r21
 1805b90:	9009883a 	mov	r4,r18
 1805b94:	180736c0 	call	180736c <_sbrk_r>
 1805b98:	00ffffc4 	movi	r3,-1
 1805b9c:	10c0e126 	beq	r2,r3,1805f24 <_malloc_r+0x788>
 1805ba0:	1505c83a 	sub	r2,r2,r20
 1805ba4:	1545883a 	add	r2,r2,r21
 1805ba8:	10800054 	ori	r2,r2,1
 1805bac:	e0c00017 	ldw	r3,0(fp)
 1805bb0:	9d000215 	stw	r20,8(r19)
 1805bb4:	a0800115 	stw	r2,4(r20)
 1805bb8:	a8c7883a 	add	r3,r21,r3
 1805bbc:	e0c00015 	stw	r3,0(fp)
 1805bc0:	84c00e26 	beq	r16,r19,1805bfc <_malloc_r+0x460>
 1805bc4:	018003c4 	movi	r6,15
 1805bc8:	3580a72e 	bgeu	r6,r22,1805e68 <_malloc_r+0x6cc>
 1805bcc:	81400117 	ldw	r5,4(r16)
 1805bd0:	013ffe04 	movi	r4,-8
 1805bd4:	b0bffd04 	addi	r2,r22,-12
 1805bd8:	1104703a 	and	r2,r2,r4
 1805bdc:	2900004c 	andi	r4,r5,1
 1805be0:	2088b03a 	or	r4,r4,r2
 1805be4:	81000115 	stw	r4,4(r16)
 1805be8:	01400144 	movi	r5,5
 1805bec:	8089883a 	add	r4,r16,r2
 1805bf0:	21400115 	stw	r5,4(r4)
 1805bf4:	21400215 	stw	r5,8(r4)
 1805bf8:	3080cd36 	bltu	r6,r2,1805f30 <_malloc_r+0x794>
 1805bfc:	00806134 	movhi	r2,388
 1805c00:	109f2004 	addi	r2,r2,31872
 1805c04:	11000017 	ldw	r4,0(r2)
 1805c08:	20c0012e 	bgeu	r4,r3,1805c10 <_malloc_r+0x474>
 1805c0c:	10c00015 	stw	r3,0(r2)
 1805c10:	00806134 	movhi	r2,388
 1805c14:	109f1f04 	addi	r2,r2,31868
 1805c18:	11000017 	ldw	r4,0(r2)
 1805c1c:	9c000217 	ldw	r16,8(r19)
 1805c20:	20c0012e 	bgeu	r4,r3,1805c28 <_malloc_r+0x48c>
 1805c24:	10c00015 	stw	r3,0(r2)
 1805c28:	80c00117 	ldw	r3,4(r16)
 1805c2c:	00bfff04 	movi	r2,-4
 1805c30:	1886703a 	and	r3,r3,r2
 1805c34:	1c45c83a 	sub	r2,r3,r17
 1805c38:	1c400236 	bltu	r3,r17,1805c44 <_malloc_r+0x4a8>
 1805c3c:	00c003c4 	movi	r3,15
 1805c40:	18800416 	blt	r3,r2,1805c54 <_malloc_r+0x4b8>
 1805c44:	9009883a 	mov	r4,r18
 1805c48:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805c4c:	0005883a 	mov	r2,zero
 1805c50:	003f7b06 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805c54:	88c00054 	ori	r3,r17,1
 1805c58:	80c00115 	stw	r3,4(r16)
 1805c5c:	8463883a 	add	r17,r16,r17
 1805c60:	10800054 	ori	r2,r2,1
 1805c64:	9c400215 	stw	r17,8(r19)
 1805c68:	88800115 	stw	r2,4(r17)
 1805c6c:	9009883a 	mov	r4,r18
 1805c70:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805c74:	80800204 	addi	r2,r16,8
 1805c78:	003f7106 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805c7c:	00c00504 	movi	r3,20
 1805c80:	18804a2e 	bgeu	r3,r2,1805dac <_malloc_r+0x610>
 1805c84:	00c01504 	movi	r3,84
 1805c88:	18806e36 	bltu	r3,r2,1805e44 <_malloc_r+0x6a8>
 1805c8c:	8804d33a 	srli	r2,r17,12
 1805c90:	12001bc4 	addi	r8,r2,111
 1805c94:	11c01b84 	addi	r7,r2,110
 1805c98:	4209883a 	add	r4,r8,r8
 1805c9c:	003edd06 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805ca0:	3804d27a 	srli	r2,r7,9
 1805ca4:	00c00104 	movi	r3,4
 1805ca8:	1880442e 	bgeu	r3,r2,1805dbc <_malloc_r+0x620>
 1805cac:	00c00504 	movi	r3,20
 1805cb0:	18808136 	bltu	r3,r2,1805eb8 <_malloc_r+0x71c>
 1805cb4:	11401704 	addi	r5,r2,92
 1805cb8:	10c016c4 	addi	r3,r2,91
 1805cbc:	294b883a 	add	r5,r5,r5
 1805cc0:	294b883a 	add	r5,r5,r5
 1805cc4:	294b883a 	add	r5,r5,r5
 1805cc8:	994b883a 	add	r5,r19,r5
 1805ccc:	28800017 	ldw	r2,0(r5)
 1805cd0:	01806134 	movhi	r6,388
 1805cd4:	297ffe04 	addi	r5,r5,-8
 1805cd8:	3190f304 	addi	r6,r6,17356
 1805cdc:	28806526 	beq	r5,r2,1805e74 <_malloc_r+0x6d8>
 1805ce0:	01bfff04 	movi	r6,-4
 1805ce4:	10c00117 	ldw	r3,4(r2)
 1805ce8:	1986703a 	and	r3,r3,r6
 1805cec:	38c0022e 	bgeu	r7,r3,1805cf8 <_malloc_r+0x55c>
 1805cf0:	10800217 	ldw	r2,8(r2)
 1805cf4:	28bffb1e 	bne	r5,r2,1805ce4 <__ram_exceptions_end+0xff7f58a0>
 1805cf8:	11400317 	ldw	r5,12(r2)
 1805cfc:	98c00117 	ldw	r3,4(r19)
 1805d00:	81400315 	stw	r5,12(r16)
 1805d04:	80800215 	stw	r2,8(r16)
 1805d08:	2c000215 	stw	r16,8(r5)
 1805d0c:	14000315 	stw	r16,12(r2)
 1805d10:	003ef806 	br	18058f4 <__ram_exceptions_end+0xff7f54b0>
 1805d14:	88c00054 	ori	r3,r17,1
 1805d18:	80c00115 	stw	r3,4(r16)
 1805d1c:	8463883a 	add	r17,r16,r17
 1805d20:	34400515 	stw	r17,20(r6)
 1805d24:	34400415 	stw	r17,16(r6)
 1805d28:	10c00054 	ori	r3,r2,1
 1805d2c:	8a000315 	stw	r8,12(r17)
 1805d30:	8a000215 	stw	r8,8(r17)
 1805d34:	88c00115 	stw	r3,4(r17)
 1805d38:	88a3883a 	add	r17,r17,r2
 1805d3c:	88800015 	stw	r2,0(r17)
 1805d40:	9009883a 	mov	r4,r18
 1805d44:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805d48:	80800204 	addi	r2,r16,8
 1805d4c:	003f3c06 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805d50:	30c00117 	ldw	r3,4(r6)
 1805d54:	003ee706 	br	18058f4 <__ram_exceptions_end+0xff7f54b0>
 1805d58:	5ac00044 	addi	r11,r11,1
 1805d5c:	588000cc 	andi	r2,r11,3
 1805d60:	31800204 	addi	r6,r6,8
 1805d64:	103efd1e 	bne	r2,zero,180595c <__ram_exceptions_end+0xff7f5518>
 1805d68:	00002406 	br	1805dfc <_malloc_r+0x660>
 1805d6c:	14000317 	ldw	r16,12(r2)
 1805d70:	143f251e 	bne	r2,r16,1805a08 <__ram_exceptions_end+0xff7f55c4>
 1805d74:	21000084 	addi	r4,r4,2
 1805d78:	003ebc06 	br	180586c <__ram_exceptions_end+0xff7f5428>
 1805d7c:	8085883a 	add	r2,r16,r2
 1805d80:	10c00117 	ldw	r3,4(r2)
 1805d84:	81000317 	ldw	r4,12(r16)
 1805d88:	81400217 	ldw	r5,8(r16)
 1805d8c:	18c00054 	ori	r3,r3,1
 1805d90:	10c00115 	stw	r3,4(r2)
 1805d94:	29000315 	stw	r4,12(r5)
 1805d98:	21400215 	stw	r5,8(r4)
 1805d9c:	9009883a 	mov	r4,r18
 1805da0:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1805da4:	80800204 	addi	r2,r16,8
 1805da8:	003f2506 	br	1805a40 <__ram_exceptions_end+0xff7f55fc>
 1805dac:	12001704 	addi	r8,r2,92
 1805db0:	11c016c4 	addi	r7,r2,91
 1805db4:	4209883a 	add	r4,r8,r8
 1805db8:	003e9606 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805dbc:	3804d1ba 	srli	r2,r7,6
 1805dc0:	11400e44 	addi	r5,r2,57
 1805dc4:	10c00e04 	addi	r3,r2,56
 1805dc8:	294b883a 	add	r5,r5,r5
 1805dcc:	003fbc06 	br	1805cc0 <__ram_exceptions_end+0xff7f587c>
 1805dd0:	84ff5926 	beq	r16,r19,1805b38 <__ram_exceptions_end+0xff7f56f4>
 1805dd4:	00806134 	movhi	r2,388
 1805dd8:	1090f304 	addi	r2,r2,17356
 1805ddc:	14000217 	ldw	r16,8(r2)
 1805de0:	00bfff04 	movi	r2,-4
 1805de4:	80c00117 	ldw	r3,4(r16)
 1805de8:	1886703a 	and	r3,r3,r2
 1805dec:	003f9106 	br	1805c34 <__ram_exceptions_end+0xff7f57f0>
 1805df0:	60800217 	ldw	r2,8(r12)
 1805df4:	213fffc4 	addi	r4,r4,-1
 1805df8:	1300651e 	bne	r2,r12,1805f90 <_malloc_r+0x7f4>
 1805dfc:	208000cc 	andi	r2,r4,3
 1805e00:	633ffe04 	addi	r12,r12,-8
 1805e04:	103ffa1e 	bne	r2,zero,1805df0 <__ram_exceptions_end+0xff7f59ac>
 1805e08:	98800117 	ldw	r2,4(r19)
 1805e0c:	0146303a 	nor	r3,zero,r5
 1805e10:	1884703a 	and	r2,r3,r2
 1805e14:	98800115 	stw	r2,4(r19)
 1805e18:	294b883a 	add	r5,r5,r5
 1805e1c:	117f2836 	bltu	r2,r5,1805ac0 <__ram_exceptions_end+0xff7f567c>
 1805e20:	283f2726 	beq	r5,zero,1805ac0 <__ram_exceptions_end+0xff7f567c>
 1805e24:	2886703a 	and	r3,r5,r2
 1805e28:	5809883a 	mov	r4,r11
 1805e2c:	183ec31e 	bne	r3,zero,180593c <__ram_exceptions_end+0xff7f54f8>
 1805e30:	294b883a 	add	r5,r5,r5
 1805e34:	2886703a 	and	r3,r5,r2
 1805e38:	21000104 	addi	r4,r4,4
 1805e3c:	183ffc26 	beq	r3,zero,1805e30 <__ram_exceptions_end+0xff7f59ec>
 1805e40:	003ebe06 	br	180593c <__ram_exceptions_end+0xff7f54f8>
 1805e44:	00c05504 	movi	r3,340
 1805e48:	18801236 	bltu	r3,r2,1805e94 <_malloc_r+0x6f8>
 1805e4c:	8804d3fa 	srli	r2,r17,15
 1805e50:	12001e04 	addi	r8,r2,120
 1805e54:	11c01dc4 	addi	r7,r2,119
 1805e58:	4209883a 	add	r4,r8,r8
 1805e5c:	003e6d06 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805e60:	00c40004 	movi	r3,4096
 1805e64:	003f4606 	br	1805b80 <__ram_exceptions_end+0xff7f573c>
 1805e68:	00800044 	movi	r2,1
 1805e6c:	a0800115 	stw	r2,4(r20)
 1805e70:	003f7406 	br	1805c44 <__ram_exceptions_end+0xff7f5800>
 1805e74:	1805d0ba 	srai	r2,r3,2
 1805e78:	01c00044 	movi	r7,1
 1805e7c:	30c00117 	ldw	r3,4(r6)
 1805e80:	388e983a 	sll	r7,r7,r2
 1805e84:	2805883a 	mov	r2,r5
 1805e88:	38c6b03a 	or	r3,r7,r3
 1805e8c:	30c00115 	stw	r3,4(r6)
 1805e90:	003f9b06 	br	1805d00 <__ram_exceptions_end+0xff7f58bc>
 1805e94:	00c15504 	movi	r3,1364
 1805e98:	18801a36 	bltu	r3,r2,1805f04 <_malloc_r+0x768>
 1805e9c:	8804d4ba 	srli	r2,r17,18
 1805ea0:	12001f44 	addi	r8,r2,125
 1805ea4:	11c01f04 	addi	r7,r2,124
 1805ea8:	4209883a 	add	r4,r8,r8
 1805eac:	003e5906 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805eb0:	ad400404 	addi	r21,r21,16
 1805eb4:	003f1706 	br	1805b14 <__ram_exceptions_end+0xff7f56d0>
 1805eb8:	00c01504 	movi	r3,84
 1805ebc:	18802336 	bltu	r3,r2,1805f4c <_malloc_r+0x7b0>
 1805ec0:	3804d33a 	srli	r2,r7,12
 1805ec4:	11401bc4 	addi	r5,r2,111
 1805ec8:	10c01b84 	addi	r3,r2,110
 1805ecc:	294b883a 	add	r5,r5,r5
 1805ed0:	003f7b06 	br	1805cc0 <__ram_exceptions_end+0xff7f587c>
 1805ed4:	9c000217 	ldw	r16,8(r19)
 1805ed8:	00bfff04 	movi	r2,-4
 1805edc:	80c00117 	ldw	r3,4(r16)
 1805ee0:	1886703a 	and	r3,r3,r2
 1805ee4:	003f5306 	br	1805c34 <__ram_exceptions_end+0xff7f57f0>
 1805ee8:	3083ffcc 	andi	r2,r6,4095
 1805eec:	103f181e 	bne	r2,zero,1805b50 <__ram_exceptions_end+0xff7f570c>
 1805ef0:	99000217 	ldw	r4,8(r19)
 1805ef4:	b545883a 	add	r2,r22,r21
 1805ef8:	10800054 	ori	r2,r2,1
 1805efc:	20800115 	stw	r2,4(r4)
 1805f00:	003f3e06 	br	1805bfc <__ram_exceptions_end+0xff7f57b8>
 1805f04:	01003f84 	movi	r4,254
 1805f08:	02001fc4 	movi	r8,127
 1805f0c:	01c01f84 	movi	r7,126
 1805f10:	003e4006 	br	1805814 <__ram_exceptions_end+0xff7f53d0>
 1805f14:	00806134 	movhi	r2,388
 1805f18:	10975704 	addi	r2,r2,23900
 1805f1c:	15000015 	stw	r20,0(r2)
 1805f20:	003f1106 	br	1805b68 <__ram_exceptions_end+0xff7f5724>
 1805f24:	00800044 	movi	r2,1
 1805f28:	002b883a 	mov	r21,zero
 1805f2c:	003f1f06 	br	1805bac <__ram_exceptions_end+0xff7f5768>
 1805f30:	81400204 	addi	r5,r16,8
 1805f34:	9009883a 	mov	r4,r18
 1805f38:	180506c0 	call	180506c <_free_r>
 1805f3c:	00806134 	movhi	r2,388
 1805f40:	109f7504 	addi	r2,r2,32212
 1805f44:	10c00017 	ldw	r3,0(r2)
 1805f48:	003f2c06 	br	1805bfc <__ram_exceptions_end+0xff7f57b8>
 1805f4c:	00c05504 	movi	r3,340
 1805f50:	18800536 	bltu	r3,r2,1805f68 <_malloc_r+0x7cc>
 1805f54:	3804d3fa 	srli	r2,r7,15
 1805f58:	11401e04 	addi	r5,r2,120
 1805f5c:	10c01dc4 	addi	r3,r2,119
 1805f60:	294b883a 	add	r5,r5,r5
 1805f64:	003f5606 	br	1805cc0 <__ram_exceptions_end+0xff7f587c>
 1805f68:	00c15504 	movi	r3,1364
 1805f6c:	18800536 	bltu	r3,r2,1805f84 <_malloc_r+0x7e8>
 1805f70:	3804d4ba 	srli	r2,r7,18
 1805f74:	11401f44 	addi	r5,r2,125
 1805f78:	10c01f04 	addi	r3,r2,124
 1805f7c:	294b883a 	add	r5,r5,r5
 1805f80:	003f4f06 	br	1805cc0 <__ram_exceptions_end+0xff7f587c>
 1805f84:	01403f84 	movi	r5,254
 1805f88:	00c01f84 	movi	r3,126
 1805f8c:	003f4c06 	br	1805cc0 <__ram_exceptions_end+0xff7f587c>
 1805f90:	98800117 	ldw	r2,4(r19)
 1805f94:	003fa006 	br	1805e18 <__ram_exceptions_end+0xff7f59d4>
 1805f98:	8808d0fa 	srli	r4,r17,3
 1805f9c:	20800044 	addi	r2,r4,1
 1805fa0:	1085883a 	add	r2,r2,r2
 1805fa4:	003e9006 	br	18059e8 <__ram_exceptions_end+0xff7f55a4>

01805fa8 <memchr>:
 1805fa8:	208000cc 	andi	r2,r4,3
 1805fac:	280f883a 	mov	r7,r5
 1805fb0:	10003426 	beq	r2,zero,1806084 <memchr+0xdc>
 1805fb4:	30bfffc4 	addi	r2,r6,-1
 1805fb8:	30001a26 	beq	r6,zero,1806024 <memchr+0x7c>
 1805fbc:	20c00003 	ldbu	r3,0(r4)
 1805fc0:	29803fcc 	andi	r6,r5,255
 1805fc4:	30c0051e 	bne	r6,r3,1805fdc <memchr+0x34>
 1805fc8:	00001806 	br	180602c <memchr+0x84>
 1805fcc:	10001526 	beq	r2,zero,1806024 <memchr+0x7c>
 1805fd0:	20c00003 	ldbu	r3,0(r4)
 1805fd4:	10bfffc4 	addi	r2,r2,-1
 1805fd8:	30c01426 	beq	r6,r3,180602c <memchr+0x84>
 1805fdc:	21000044 	addi	r4,r4,1
 1805fe0:	20c000cc 	andi	r3,r4,3
 1805fe4:	183ff91e 	bne	r3,zero,1805fcc <__ram_exceptions_end+0xff7f5b88>
 1805fe8:	020000c4 	movi	r8,3
 1805fec:	40801136 	bltu	r8,r2,1806034 <memchr+0x8c>
 1805ff0:	10000c26 	beq	r2,zero,1806024 <memchr+0x7c>
 1805ff4:	20c00003 	ldbu	r3,0(r4)
 1805ff8:	29403fcc 	andi	r5,r5,255
 1805ffc:	28c00b26 	beq	r5,r3,180602c <memchr+0x84>
 1806000:	20c00044 	addi	r3,r4,1
 1806004:	39803fcc 	andi	r6,r7,255
 1806008:	2089883a 	add	r4,r4,r2
 180600c:	00000306 	br	180601c <memchr+0x74>
 1806010:	18c00044 	addi	r3,r3,1
 1806014:	197fffc3 	ldbu	r5,-1(r3)
 1806018:	31400526 	beq	r6,r5,1806030 <memchr+0x88>
 180601c:	1805883a 	mov	r2,r3
 1806020:	20fffb1e 	bne	r4,r3,1806010 <__ram_exceptions_end+0xff7f5bcc>
 1806024:	0005883a 	mov	r2,zero
 1806028:	f800283a 	ret
 180602c:	2005883a 	mov	r2,r4
 1806030:	f800283a 	ret
 1806034:	28c03fcc 	andi	r3,r5,255
 1806038:	1812923a 	slli	r9,r3,8
 180603c:	02ffbff4 	movhi	r11,65279
 1806040:	02a02074 	movhi	r10,32897
 1806044:	48d2b03a 	or	r9,r9,r3
 1806048:	4806943a 	slli	r3,r9,16
 180604c:	5affbfc4 	addi	r11,r11,-257
 1806050:	52a02004 	addi	r10,r10,-32640
 1806054:	48d2b03a 	or	r9,r9,r3
 1806058:	20c00017 	ldw	r3,0(r4)
 180605c:	48c6f03a 	xor	r3,r9,r3
 1806060:	1acd883a 	add	r6,r3,r11
 1806064:	00c6303a 	nor	r3,zero,r3
 1806068:	30c6703a 	and	r3,r6,r3
 180606c:	1a86703a 	and	r3,r3,r10
 1806070:	183fe01e 	bne	r3,zero,1805ff4 <__ram_exceptions_end+0xff7f5bb0>
 1806074:	10bfff04 	addi	r2,r2,-4
 1806078:	21000104 	addi	r4,r4,4
 180607c:	40bff636 	bltu	r8,r2,1806058 <__ram_exceptions_end+0xff7f5c14>
 1806080:	003fdb06 	br	1805ff0 <__ram_exceptions_end+0xff7f5bac>
 1806084:	3005883a 	mov	r2,r6
 1806088:	003fd706 	br	1805fe8 <__ram_exceptions_end+0xff7f5ba4>

0180608c <memcpy>:
 180608c:	defffd04 	addi	sp,sp,-12
 1806090:	dfc00215 	stw	ra,8(sp)
 1806094:	dc400115 	stw	r17,4(sp)
 1806098:	dc000015 	stw	r16,0(sp)
 180609c:	00c003c4 	movi	r3,15
 18060a0:	2005883a 	mov	r2,r4
 18060a4:	1980452e 	bgeu	r3,r6,18061bc <memcpy+0x130>
 18060a8:	2906b03a 	or	r3,r5,r4
 18060ac:	18c000cc 	andi	r3,r3,3
 18060b0:	1800441e 	bne	r3,zero,18061c4 <memcpy+0x138>
 18060b4:	347ffc04 	addi	r17,r6,-16
 18060b8:	8822d13a 	srli	r17,r17,4
 18060bc:	28c00104 	addi	r3,r5,4
 18060c0:	23400104 	addi	r13,r4,4
 18060c4:	8820913a 	slli	r16,r17,4
 18060c8:	2b000204 	addi	r12,r5,8
 18060cc:	22c00204 	addi	r11,r4,8
 18060d0:	84000504 	addi	r16,r16,20
 18060d4:	2a800304 	addi	r10,r5,12
 18060d8:	22400304 	addi	r9,r4,12
 18060dc:	2c21883a 	add	r16,r5,r16
 18060e0:	2811883a 	mov	r8,r5
 18060e4:	200f883a 	mov	r7,r4
 18060e8:	41000017 	ldw	r4,0(r8)
 18060ec:	1fc00017 	ldw	ra,0(r3)
 18060f0:	63c00017 	ldw	r15,0(r12)
 18060f4:	39000015 	stw	r4,0(r7)
 18060f8:	53800017 	ldw	r14,0(r10)
 18060fc:	6fc00015 	stw	ra,0(r13)
 1806100:	5bc00015 	stw	r15,0(r11)
 1806104:	4b800015 	stw	r14,0(r9)
 1806108:	18c00404 	addi	r3,r3,16
 180610c:	39c00404 	addi	r7,r7,16
 1806110:	42000404 	addi	r8,r8,16
 1806114:	6b400404 	addi	r13,r13,16
 1806118:	63000404 	addi	r12,r12,16
 180611c:	5ac00404 	addi	r11,r11,16
 1806120:	52800404 	addi	r10,r10,16
 1806124:	4a400404 	addi	r9,r9,16
 1806128:	1c3fef1e 	bne	r3,r16,18060e8 <__ram_exceptions_end+0xff7f5ca4>
 180612c:	89c00044 	addi	r7,r17,1
 1806130:	380e913a 	slli	r7,r7,4
 1806134:	310003cc 	andi	r4,r6,15
 1806138:	02c000c4 	movi	r11,3
 180613c:	11c7883a 	add	r3,r2,r7
 1806140:	29cb883a 	add	r5,r5,r7
 1806144:	5900212e 	bgeu	r11,r4,18061cc <memcpy+0x140>
 1806148:	1813883a 	mov	r9,r3
 180614c:	2811883a 	mov	r8,r5
 1806150:	200f883a 	mov	r7,r4
 1806154:	42800017 	ldw	r10,0(r8)
 1806158:	4a400104 	addi	r9,r9,4
 180615c:	39ffff04 	addi	r7,r7,-4
 1806160:	4abfff15 	stw	r10,-4(r9)
 1806164:	42000104 	addi	r8,r8,4
 1806168:	59fffa36 	bltu	r11,r7,1806154 <__ram_exceptions_end+0xff7f5d10>
 180616c:	213fff04 	addi	r4,r4,-4
 1806170:	2008d0ba 	srli	r4,r4,2
 1806174:	318000cc 	andi	r6,r6,3
 1806178:	21000044 	addi	r4,r4,1
 180617c:	2109883a 	add	r4,r4,r4
 1806180:	2109883a 	add	r4,r4,r4
 1806184:	1907883a 	add	r3,r3,r4
 1806188:	290b883a 	add	r5,r5,r4
 180618c:	30000626 	beq	r6,zero,18061a8 <memcpy+0x11c>
 1806190:	198d883a 	add	r6,r3,r6
 1806194:	29c00003 	ldbu	r7,0(r5)
 1806198:	18c00044 	addi	r3,r3,1
 180619c:	29400044 	addi	r5,r5,1
 18061a0:	19ffffc5 	stb	r7,-1(r3)
 18061a4:	19bffb1e 	bne	r3,r6,1806194 <__ram_exceptions_end+0xff7f5d50>
 18061a8:	dfc00217 	ldw	ra,8(sp)
 18061ac:	dc400117 	ldw	r17,4(sp)
 18061b0:	dc000017 	ldw	r16,0(sp)
 18061b4:	dec00304 	addi	sp,sp,12
 18061b8:	f800283a 	ret
 18061bc:	2007883a 	mov	r3,r4
 18061c0:	003ff206 	br	180618c <__ram_exceptions_end+0xff7f5d48>
 18061c4:	2007883a 	mov	r3,r4
 18061c8:	003ff106 	br	1806190 <__ram_exceptions_end+0xff7f5d4c>
 18061cc:	200d883a 	mov	r6,r4
 18061d0:	003fee06 	br	180618c <__ram_exceptions_end+0xff7f5d48>

018061d4 <memset>:
 18061d4:	20c000cc 	andi	r3,r4,3
 18061d8:	2005883a 	mov	r2,r4
 18061dc:	18004426 	beq	r3,zero,18062f0 <memset+0x11c>
 18061e0:	31ffffc4 	addi	r7,r6,-1
 18061e4:	30004026 	beq	r6,zero,18062e8 <memset+0x114>
 18061e8:	2813883a 	mov	r9,r5
 18061ec:	200d883a 	mov	r6,r4
 18061f0:	2007883a 	mov	r3,r4
 18061f4:	00000406 	br	1806208 <memset+0x34>
 18061f8:	3a3fffc4 	addi	r8,r7,-1
 18061fc:	31800044 	addi	r6,r6,1
 1806200:	38003926 	beq	r7,zero,18062e8 <memset+0x114>
 1806204:	400f883a 	mov	r7,r8
 1806208:	18c00044 	addi	r3,r3,1
 180620c:	32400005 	stb	r9,0(r6)
 1806210:	1a0000cc 	andi	r8,r3,3
 1806214:	403ff81e 	bne	r8,zero,18061f8 <__ram_exceptions_end+0xff7f5db4>
 1806218:	010000c4 	movi	r4,3
 180621c:	21c02d2e 	bgeu	r4,r7,18062d4 <memset+0x100>
 1806220:	29003fcc 	andi	r4,r5,255
 1806224:	200c923a 	slli	r6,r4,8
 1806228:	3108b03a 	or	r4,r6,r4
 180622c:	200c943a 	slli	r6,r4,16
 1806230:	218cb03a 	or	r6,r4,r6
 1806234:	010003c4 	movi	r4,15
 1806238:	21c0182e 	bgeu	r4,r7,180629c <memset+0xc8>
 180623c:	3b3ffc04 	addi	r12,r7,-16
 1806240:	6018d13a 	srli	r12,r12,4
 1806244:	1a000104 	addi	r8,r3,4
 1806248:	1ac00204 	addi	r11,r3,8
 180624c:	6008913a 	slli	r4,r12,4
 1806250:	1a800304 	addi	r10,r3,12
 1806254:	1813883a 	mov	r9,r3
 1806258:	21000504 	addi	r4,r4,20
 180625c:	1909883a 	add	r4,r3,r4
 1806260:	49800015 	stw	r6,0(r9)
 1806264:	41800015 	stw	r6,0(r8)
 1806268:	59800015 	stw	r6,0(r11)
 180626c:	51800015 	stw	r6,0(r10)
 1806270:	42000404 	addi	r8,r8,16
 1806274:	4a400404 	addi	r9,r9,16
 1806278:	5ac00404 	addi	r11,r11,16
 180627c:	52800404 	addi	r10,r10,16
 1806280:	413ff71e 	bne	r8,r4,1806260 <__ram_exceptions_end+0xff7f5e1c>
 1806284:	63000044 	addi	r12,r12,1
 1806288:	6018913a 	slli	r12,r12,4
 180628c:	39c003cc 	andi	r7,r7,15
 1806290:	010000c4 	movi	r4,3
 1806294:	1b07883a 	add	r3,r3,r12
 1806298:	21c00e2e 	bgeu	r4,r7,18062d4 <memset+0x100>
 180629c:	1813883a 	mov	r9,r3
 18062a0:	3811883a 	mov	r8,r7
 18062a4:	010000c4 	movi	r4,3
 18062a8:	49800015 	stw	r6,0(r9)
 18062ac:	423fff04 	addi	r8,r8,-4
 18062b0:	4a400104 	addi	r9,r9,4
 18062b4:	223ffc36 	bltu	r4,r8,18062a8 <__ram_exceptions_end+0xff7f5e64>
 18062b8:	393fff04 	addi	r4,r7,-4
 18062bc:	2008d0ba 	srli	r4,r4,2
 18062c0:	39c000cc 	andi	r7,r7,3
 18062c4:	21000044 	addi	r4,r4,1
 18062c8:	2109883a 	add	r4,r4,r4
 18062cc:	2109883a 	add	r4,r4,r4
 18062d0:	1907883a 	add	r3,r3,r4
 18062d4:	38000526 	beq	r7,zero,18062ec <memset+0x118>
 18062d8:	19cf883a 	add	r7,r3,r7
 18062dc:	19400005 	stb	r5,0(r3)
 18062e0:	18c00044 	addi	r3,r3,1
 18062e4:	38fffd1e 	bne	r7,r3,18062dc <__ram_exceptions_end+0xff7f5e98>
 18062e8:	f800283a 	ret
 18062ec:	f800283a 	ret
 18062f0:	2007883a 	mov	r3,r4
 18062f4:	300f883a 	mov	r7,r6
 18062f8:	003fc706 	br	1806218 <__ram_exceptions_end+0xff7f5dd4>

018062fc <_Balloc>:
 18062fc:	20801317 	ldw	r2,76(r4)
 1806300:	defffc04 	addi	sp,sp,-16
 1806304:	dc400115 	stw	r17,4(sp)
 1806308:	dc000015 	stw	r16,0(sp)
 180630c:	dfc00315 	stw	ra,12(sp)
 1806310:	dc800215 	stw	r18,8(sp)
 1806314:	2023883a 	mov	r17,r4
 1806318:	2821883a 	mov	r16,r5
 180631c:	10000f26 	beq	r2,zero,180635c <_Balloc+0x60>
 1806320:	8407883a 	add	r3,r16,r16
 1806324:	18c7883a 	add	r3,r3,r3
 1806328:	10c7883a 	add	r3,r2,r3
 180632c:	18800017 	ldw	r2,0(r3)
 1806330:	10001126 	beq	r2,zero,1806378 <_Balloc+0x7c>
 1806334:	11000017 	ldw	r4,0(r2)
 1806338:	19000015 	stw	r4,0(r3)
 180633c:	10000415 	stw	zero,16(r2)
 1806340:	10000315 	stw	zero,12(r2)
 1806344:	dfc00317 	ldw	ra,12(sp)
 1806348:	dc800217 	ldw	r18,8(sp)
 180634c:	dc400117 	ldw	r17,4(sp)
 1806350:	dc000017 	ldw	r16,0(sp)
 1806354:	dec00404 	addi	sp,sp,16
 1806358:	f800283a 	ret
 180635c:	01800844 	movi	r6,33
 1806360:	01400104 	movi	r5,4
 1806364:	1808d6c0 	call	1808d6c <_calloc_r>
 1806368:	88801315 	stw	r2,76(r17)
 180636c:	103fec1e 	bne	r2,zero,1806320 <__ram_exceptions_end+0xff7f5edc>
 1806370:	0005883a 	mov	r2,zero
 1806374:	003ff306 	br	1806344 <__ram_exceptions_end+0xff7f5f00>
 1806378:	01400044 	movi	r5,1
 180637c:	2c24983a 	sll	r18,r5,r16
 1806380:	8809883a 	mov	r4,r17
 1806384:	91800144 	addi	r6,r18,5
 1806388:	318d883a 	add	r6,r6,r6
 180638c:	318d883a 	add	r6,r6,r6
 1806390:	1808d6c0 	call	1808d6c <_calloc_r>
 1806394:	103ff626 	beq	r2,zero,1806370 <__ram_exceptions_end+0xff7f5f2c>
 1806398:	14000115 	stw	r16,4(r2)
 180639c:	14800215 	stw	r18,8(r2)
 18063a0:	003fe606 	br	180633c <__ram_exceptions_end+0xff7f5ef8>

018063a4 <_Bfree>:
 18063a4:	28000826 	beq	r5,zero,18063c8 <_Bfree+0x24>
 18063a8:	28c00117 	ldw	r3,4(r5)
 18063ac:	20801317 	ldw	r2,76(r4)
 18063b0:	18c7883a 	add	r3,r3,r3
 18063b4:	18c7883a 	add	r3,r3,r3
 18063b8:	10c5883a 	add	r2,r2,r3
 18063bc:	10c00017 	ldw	r3,0(r2)
 18063c0:	28c00015 	stw	r3,0(r5)
 18063c4:	11400015 	stw	r5,0(r2)
 18063c8:	f800283a 	ret

018063cc <__multadd>:
 18063cc:	defffa04 	addi	sp,sp,-24
 18063d0:	dc800315 	stw	r18,12(sp)
 18063d4:	dc400215 	stw	r17,8(sp)
 18063d8:	dc000115 	stw	r16,4(sp)
 18063dc:	2823883a 	mov	r17,r5
 18063e0:	2c000417 	ldw	r16,16(r5)
 18063e4:	dfc00515 	stw	ra,20(sp)
 18063e8:	dcc00415 	stw	r19,16(sp)
 18063ec:	2025883a 	mov	r18,r4
 18063f0:	29400504 	addi	r5,r5,20
 18063f4:	0011883a 	mov	r8,zero
 18063f8:	28c00017 	ldw	r3,0(r5)
 18063fc:	29400104 	addi	r5,r5,4
 1806400:	42000044 	addi	r8,r8,1
 1806404:	18bfffcc 	andi	r2,r3,65535
 1806408:	1185383a 	mul	r2,r2,r6
 180640c:	1806d43a 	srli	r3,r3,16
 1806410:	11cf883a 	add	r7,r2,r7
 1806414:	3808d43a 	srli	r4,r7,16
 1806418:	1987383a 	mul	r3,r3,r6
 180641c:	38bfffcc 	andi	r2,r7,65535
 1806420:	1907883a 	add	r3,r3,r4
 1806424:	1808943a 	slli	r4,r3,16
 1806428:	180ed43a 	srli	r7,r3,16
 180642c:	2085883a 	add	r2,r4,r2
 1806430:	28bfff15 	stw	r2,-4(r5)
 1806434:	443ff016 	blt	r8,r16,18063f8 <__ram_exceptions_end+0xff7f5fb4>
 1806438:	38000926 	beq	r7,zero,1806460 <__multadd+0x94>
 180643c:	88800217 	ldw	r2,8(r17)
 1806440:	80800f0e 	bge	r16,r2,1806480 <__multadd+0xb4>
 1806444:	80800144 	addi	r2,r16,5
 1806448:	1085883a 	add	r2,r2,r2
 180644c:	1085883a 	add	r2,r2,r2
 1806450:	8885883a 	add	r2,r17,r2
 1806454:	11c00015 	stw	r7,0(r2)
 1806458:	84000044 	addi	r16,r16,1
 180645c:	8c000415 	stw	r16,16(r17)
 1806460:	8805883a 	mov	r2,r17
 1806464:	dfc00517 	ldw	ra,20(sp)
 1806468:	dcc00417 	ldw	r19,16(sp)
 180646c:	dc800317 	ldw	r18,12(sp)
 1806470:	dc400217 	ldw	r17,8(sp)
 1806474:	dc000117 	ldw	r16,4(sp)
 1806478:	dec00604 	addi	sp,sp,24
 180647c:	f800283a 	ret
 1806480:	89400117 	ldw	r5,4(r17)
 1806484:	9009883a 	mov	r4,r18
 1806488:	d9c00015 	stw	r7,0(sp)
 180648c:	29400044 	addi	r5,r5,1
 1806490:	18062fc0 	call	18062fc <_Balloc>
 1806494:	89800417 	ldw	r6,16(r17)
 1806498:	89400304 	addi	r5,r17,12
 180649c:	11000304 	addi	r4,r2,12
 18064a0:	31800084 	addi	r6,r6,2
 18064a4:	318d883a 	add	r6,r6,r6
 18064a8:	318d883a 	add	r6,r6,r6
 18064ac:	1027883a 	mov	r19,r2
 18064b0:	180608c0 	call	180608c <memcpy>
 18064b4:	d9c00017 	ldw	r7,0(sp)
 18064b8:	88000a26 	beq	r17,zero,18064e4 <__multadd+0x118>
 18064bc:	88c00117 	ldw	r3,4(r17)
 18064c0:	90801317 	ldw	r2,76(r18)
 18064c4:	18c7883a 	add	r3,r3,r3
 18064c8:	18c7883a 	add	r3,r3,r3
 18064cc:	10c5883a 	add	r2,r2,r3
 18064d0:	10c00017 	ldw	r3,0(r2)
 18064d4:	88c00015 	stw	r3,0(r17)
 18064d8:	14400015 	stw	r17,0(r2)
 18064dc:	9823883a 	mov	r17,r19
 18064e0:	003fd806 	br	1806444 <__ram_exceptions_end+0xff7f6000>
 18064e4:	9823883a 	mov	r17,r19
 18064e8:	003fd606 	br	1806444 <__ram_exceptions_end+0xff7f6000>

018064ec <__s2b>:
 18064ec:	defff904 	addi	sp,sp,-28
 18064f0:	dc400115 	stw	r17,4(sp)
 18064f4:	dc000015 	stw	r16,0(sp)
 18064f8:	2023883a 	mov	r17,r4
 18064fc:	2821883a 	mov	r16,r5
 1806500:	39000204 	addi	r4,r7,8
 1806504:	01400244 	movi	r5,9
 1806508:	dcc00315 	stw	r19,12(sp)
 180650c:	dc800215 	stw	r18,8(sp)
 1806510:	dfc00615 	stw	ra,24(sp)
 1806514:	dd400515 	stw	r21,20(sp)
 1806518:	dd000415 	stw	r20,16(sp)
 180651c:	3825883a 	mov	r18,r7
 1806520:	3027883a 	mov	r19,r6
 1806524:	180ac180 	call	180ac18 <__divsi3>
 1806528:	00c00044 	movi	r3,1
 180652c:	000b883a 	mov	r5,zero
 1806530:	1880030e 	bge	r3,r2,1806540 <__s2b+0x54>
 1806534:	18c7883a 	add	r3,r3,r3
 1806538:	29400044 	addi	r5,r5,1
 180653c:	18bffd16 	blt	r3,r2,1806534 <__ram_exceptions_end+0xff7f60f0>
 1806540:	8809883a 	mov	r4,r17
 1806544:	18062fc0 	call	18062fc <_Balloc>
 1806548:	d8c00717 	ldw	r3,28(sp)
 180654c:	10c00515 	stw	r3,20(r2)
 1806550:	00c00044 	movi	r3,1
 1806554:	10c00415 	stw	r3,16(r2)
 1806558:	00c00244 	movi	r3,9
 180655c:	1cc0210e 	bge	r3,r19,18065e4 <__s2b+0xf8>
 1806560:	80eb883a 	add	r21,r16,r3
 1806564:	a829883a 	mov	r20,r21
 1806568:	84e1883a 	add	r16,r16,r19
 180656c:	a1c00007 	ldb	r7,0(r20)
 1806570:	01800284 	movi	r6,10
 1806574:	a5000044 	addi	r20,r20,1
 1806578:	100b883a 	mov	r5,r2
 180657c:	39fff404 	addi	r7,r7,-48
 1806580:	8809883a 	mov	r4,r17
 1806584:	18063cc0 	call	18063cc <__multadd>
 1806588:	a43ff81e 	bne	r20,r16,180656c <__ram_exceptions_end+0xff7f6128>
 180658c:	ace1883a 	add	r16,r21,r19
 1806590:	843ffe04 	addi	r16,r16,-8
 1806594:	9c800a0e 	bge	r19,r18,18065c0 <__s2b+0xd4>
 1806598:	94e5c83a 	sub	r18,r18,r19
 180659c:	84a5883a 	add	r18,r16,r18
 18065a0:	81c00007 	ldb	r7,0(r16)
 18065a4:	01800284 	movi	r6,10
 18065a8:	84000044 	addi	r16,r16,1
 18065ac:	100b883a 	mov	r5,r2
 18065b0:	39fff404 	addi	r7,r7,-48
 18065b4:	8809883a 	mov	r4,r17
 18065b8:	18063cc0 	call	18063cc <__multadd>
 18065bc:	84bff81e 	bne	r16,r18,18065a0 <__ram_exceptions_end+0xff7f615c>
 18065c0:	dfc00617 	ldw	ra,24(sp)
 18065c4:	dd400517 	ldw	r21,20(sp)
 18065c8:	dd000417 	ldw	r20,16(sp)
 18065cc:	dcc00317 	ldw	r19,12(sp)
 18065d0:	dc800217 	ldw	r18,8(sp)
 18065d4:	dc400117 	ldw	r17,4(sp)
 18065d8:	dc000017 	ldw	r16,0(sp)
 18065dc:	dec00704 	addi	sp,sp,28
 18065e0:	f800283a 	ret
 18065e4:	84000284 	addi	r16,r16,10
 18065e8:	1827883a 	mov	r19,r3
 18065ec:	003fe906 	br	1806594 <__ram_exceptions_end+0xff7f6150>

018065f0 <__hi0bits>:
 18065f0:	20bfffec 	andhi	r2,r4,65535
 18065f4:	1000141e 	bne	r2,zero,1806648 <__hi0bits+0x58>
 18065f8:	2008943a 	slli	r4,r4,16
 18065fc:	00800404 	movi	r2,16
 1806600:	20ffc02c 	andhi	r3,r4,65280
 1806604:	1800021e 	bne	r3,zero,1806610 <__hi0bits+0x20>
 1806608:	2008923a 	slli	r4,r4,8
 180660c:	10800204 	addi	r2,r2,8
 1806610:	20fc002c 	andhi	r3,r4,61440
 1806614:	1800021e 	bne	r3,zero,1806620 <__hi0bits+0x30>
 1806618:	2008913a 	slli	r4,r4,4
 180661c:	10800104 	addi	r2,r2,4
 1806620:	20f0002c 	andhi	r3,r4,49152
 1806624:	1800031e 	bne	r3,zero,1806634 <__hi0bits+0x44>
 1806628:	2109883a 	add	r4,r4,r4
 180662c:	10800084 	addi	r2,r2,2
 1806630:	2109883a 	add	r4,r4,r4
 1806634:	20000316 	blt	r4,zero,1806644 <__hi0bits+0x54>
 1806638:	2110002c 	andhi	r4,r4,16384
 180663c:	2000041e 	bne	r4,zero,1806650 <__hi0bits+0x60>
 1806640:	00800804 	movi	r2,32
 1806644:	f800283a 	ret
 1806648:	0005883a 	mov	r2,zero
 180664c:	003fec06 	br	1806600 <__ram_exceptions_end+0xff7f61bc>
 1806650:	10800044 	addi	r2,r2,1
 1806654:	f800283a 	ret

01806658 <__lo0bits>:
 1806658:	20c00017 	ldw	r3,0(r4)
 180665c:	188001cc 	andi	r2,r3,7
 1806660:	10000826 	beq	r2,zero,1806684 <__lo0bits+0x2c>
 1806664:	1880004c 	andi	r2,r3,1
 1806668:	1000211e 	bne	r2,zero,18066f0 <__lo0bits+0x98>
 180666c:	1880008c 	andi	r2,r3,2
 1806670:	1000211e 	bne	r2,zero,18066f8 <__lo0bits+0xa0>
 1806674:	1806d0ba 	srli	r3,r3,2
 1806678:	00800084 	movi	r2,2
 180667c:	20c00015 	stw	r3,0(r4)
 1806680:	f800283a 	ret
 1806684:	18bfffcc 	andi	r2,r3,65535
 1806688:	10001326 	beq	r2,zero,18066d8 <__lo0bits+0x80>
 180668c:	0005883a 	mov	r2,zero
 1806690:	19403fcc 	andi	r5,r3,255
 1806694:	2800021e 	bne	r5,zero,18066a0 <__lo0bits+0x48>
 1806698:	1806d23a 	srli	r3,r3,8
 180669c:	10800204 	addi	r2,r2,8
 18066a0:	194003cc 	andi	r5,r3,15
 18066a4:	2800021e 	bne	r5,zero,18066b0 <__lo0bits+0x58>
 18066a8:	1806d13a 	srli	r3,r3,4
 18066ac:	10800104 	addi	r2,r2,4
 18066b0:	194000cc 	andi	r5,r3,3
 18066b4:	2800021e 	bne	r5,zero,18066c0 <__lo0bits+0x68>
 18066b8:	1806d0ba 	srli	r3,r3,2
 18066bc:	10800084 	addi	r2,r2,2
 18066c0:	1940004c 	andi	r5,r3,1
 18066c4:	2800081e 	bne	r5,zero,18066e8 <__lo0bits+0x90>
 18066c8:	1806d07a 	srli	r3,r3,1
 18066cc:	1800051e 	bne	r3,zero,18066e4 <__lo0bits+0x8c>
 18066d0:	00800804 	movi	r2,32
 18066d4:	f800283a 	ret
 18066d8:	1806d43a 	srli	r3,r3,16
 18066dc:	00800404 	movi	r2,16
 18066e0:	003feb06 	br	1806690 <__ram_exceptions_end+0xff7f624c>
 18066e4:	10800044 	addi	r2,r2,1
 18066e8:	20c00015 	stw	r3,0(r4)
 18066ec:	f800283a 	ret
 18066f0:	0005883a 	mov	r2,zero
 18066f4:	f800283a 	ret
 18066f8:	1806d07a 	srli	r3,r3,1
 18066fc:	00800044 	movi	r2,1
 1806700:	20c00015 	stw	r3,0(r4)
 1806704:	f800283a 	ret

01806708 <__i2b>:
 1806708:	defffd04 	addi	sp,sp,-12
 180670c:	dc000015 	stw	r16,0(sp)
 1806710:	04000044 	movi	r16,1
 1806714:	dc400115 	stw	r17,4(sp)
 1806718:	2823883a 	mov	r17,r5
 180671c:	800b883a 	mov	r5,r16
 1806720:	dfc00215 	stw	ra,8(sp)
 1806724:	18062fc0 	call	18062fc <_Balloc>
 1806728:	14400515 	stw	r17,20(r2)
 180672c:	14000415 	stw	r16,16(r2)
 1806730:	dfc00217 	ldw	ra,8(sp)
 1806734:	dc400117 	ldw	r17,4(sp)
 1806738:	dc000017 	ldw	r16,0(sp)
 180673c:	dec00304 	addi	sp,sp,12
 1806740:	f800283a 	ret

01806744 <__multiply>:
 1806744:	defffa04 	addi	sp,sp,-24
 1806748:	dcc00315 	stw	r19,12(sp)
 180674c:	dc800215 	stw	r18,8(sp)
 1806750:	34c00417 	ldw	r19,16(r6)
 1806754:	2c800417 	ldw	r18,16(r5)
 1806758:	dd000415 	stw	r20,16(sp)
 180675c:	dc400115 	stw	r17,4(sp)
 1806760:	dfc00515 	stw	ra,20(sp)
 1806764:	dc000015 	stw	r16,0(sp)
 1806768:	2829883a 	mov	r20,r5
 180676c:	3023883a 	mov	r17,r6
 1806770:	94c0050e 	bge	r18,r19,1806788 <__multiply+0x44>
 1806774:	9007883a 	mov	r3,r18
 1806778:	3029883a 	mov	r20,r6
 180677c:	9825883a 	mov	r18,r19
 1806780:	2823883a 	mov	r17,r5
 1806784:	1827883a 	mov	r19,r3
 1806788:	a0800217 	ldw	r2,8(r20)
 180678c:	94e1883a 	add	r16,r18,r19
 1806790:	a1400117 	ldw	r5,4(r20)
 1806794:	1400010e 	bge	r2,r16,180679c <__multiply+0x58>
 1806798:	29400044 	addi	r5,r5,1
 180679c:	18062fc0 	call	18062fc <_Balloc>
 18067a0:	8415883a 	add	r10,r16,r16
 18067a4:	12c00504 	addi	r11,r2,20
 18067a8:	5295883a 	add	r10,r10,r10
 18067ac:	5a95883a 	add	r10,r11,r10
 18067b0:	5807883a 	mov	r3,r11
 18067b4:	5a80032e 	bgeu	r11,r10,18067c4 <__multiply+0x80>
 18067b8:	18000015 	stw	zero,0(r3)
 18067bc:	18c00104 	addi	r3,r3,4
 18067c0:	1abffd36 	bltu	r3,r10,18067b8 <__ram_exceptions_end+0xff7f6374>
 18067c4:	9ce7883a 	add	r19,r19,r19
 18067c8:	94a5883a 	add	r18,r18,r18
 18067cc:	89800504 	addi	r6,r17,20
 18067d0:	9ce7883a 	add	r19,r19,r19
 18067d4:	a3400504 	addi	r13,r20,20
 18067d8:	94a5883a 	add	r18,r18,r18
 18067dc:	34d9883a 	add	r12,r6,r19
 18067e0:	6c93883a 	add	r9,r13,r18
 18067e4:	3300422e 	bgeu	r6,r12,18068f0 <__multiply+0x1ac>
 18067e8:	37c00017 	ldw	ra,0(r6)
 18067ec:	fbffffcc 	andi	r15,ra,65535
 18067f0:	78001b26 	beq	r15,zero,1806860 <__multiply+0x11c>
 18067f4:	5811883a 	mov	r8,r11
 18067f8:	681d883a 	mov	r14,r13
 18067fc:	000f883a 	mov	r7,zero
 1806800:	71000017 	ldw	r4,0(r14)
 1806804:	40c00017 	ldw	r3,0(r8)
 1806808:	73800104 	addi	r14,r14,4
 180680c:	217fffcc 	andi	r5,r4,65535
 1806810:	2bcb383a 	mul	r5,r5,r15
 1806814:	2008d43a 	srli	r4,r4,16
 1806818:	1c7fffcc 	andi	r17,r3,65535
 180681c:	2c4b883a 	add	r5,r5,r17
 1806820:	29cb883a 	add	r5,r5,r7
 1806824:	23c9383a 	mul	r4,r4,r15
 1806828:	1806d43a 	srli	r3,r3,16
 180682c:	280ed43a 	srli	r7,r5,16
 1806830:	297fffcc 	andi	r5,r5,65535
 1806834:	20c7883a 	add	r3,r4,r3
 1806838:	19c7883a 	add	r3,r3,r7
 180683c:	1808943a 	slli	r4,r3,16
 1806840:	4023883a 	mov	r17,r8
 1806844:	180ed43a 	srli	r7,r3,16
 1806848:	214ab03a 	or	r5,r4,r5
 180684c:	41400015 	stw	r5,0(r8)
 1806850:	42000104 	addi	r8,r8,4
 1806854:	727fea36 	bltu	r14,r9,1806800 <__ram_exceptions_end+0xff7f63bc>
 1806858:	89c00115 	stw	r7,4(r17)
 180685c:	37c00017 	ldw	ra,0(r6)
 1806860:	f83ed43a 	srli	ra,ra,16
 1806864:	f8001f26 	beq	ra,zero,18068e4 <__multiply+0x1a0>
 1806868:	58c00017 	ldw	r3,0(r11)
 180686c:	681d883a 	mov	r14,r13
 1806870:	581f883a 	mov	r15,r11
 1806874:	1811883a 	mov	r8,r3
 1806878:	5825883a 	mov	r18,r11
 180687c:	000f883a 	mov	r7,zero
 1806880:	00000106 	br	1806888 <__multiply+0x144>
 1806884:	8825883a 	mov	r18,r17
 1806888:	7140000b 	ldhu	r5,0(r14)
 180688c:	4010d43a 	srli	r8,r8,16
 1806890:	193fffcc 	andi	r4,r3,65535
 1806894:	2fcb383a 	mul	r5,r5,ra
 1806898:	7bc00104 	addi	r15,r15,4
 180689c:	73800104 	addi	r14,r14,4
 18068a0:	2a0b883a 	add	r5,r5,r8
 18068a4:	29cb883a 	add	r5,r5,r7
 18068a8:	2806943a 	slli	r3,r5,16
 18068ac:	94400104 	addi	r17,r18,4
 18068b0:	280ad43a 	srli	r5,r5,16
 18068b4:	1908b03a 	or	r4,r3,r4
 18068b8:	793fff15 	stw	r4,-4(r15)
 18068bc:	70ffff17 	ldw	r3,-4(r14)
 18068c0:	8a000017 	ldw	r8,0(r17)
 18068c4:	1806d43a 	srli	r3,r3,16
 18068c8:	413fffcc 	andi	r4,r8,65535
 18068cc:	1fc7383a 	mul	r3,r3,ra
 18068d0:	1907883a 	add	r3,r3,r4
 18068d4:	1947883a 	add	r3,r3,r5
 18068d8:	180ed43a 	srli	r7,r3,16
 18068dc:	727fe936 	bltu	r14,r9,1806884 <__ram_exceptions_end+0xff7f6440>
 18068e0:	90c00115 	stw	r3,4(r18)
 18068e4:	31800104 	addi	r6,r6,4
 18068e8:	5ac00104 	addi	r11,r11,4
 18068ec:	333fbe36 	bltu	r6,r12,18067e8 <__ram_exceptions_end+0xff7f63a4>
 18068f0:	0400090e 	bge	zero,r16,1806918 <__multiply+0x1d4>
 18068f4:	50ffff17 	ldw	r3,-4(r10)
 18068f8:	52bfff04 	addi	r10,r10,-4
 18068fc:	18000326 	beq	r3,zero,180690c <__multiply+0x1c8>
 1806900:	00000506 	br	1806918 <__multiply+0x1d4>
 1806904:	50c00017 	ldw	r3,0(r10)
 1806908:	1800031e 	bne	r3,zero,1806918 <__multiply+0x1d4>
 180690c:	843fffc4 	addi	r16,r16,-1
 1806910:	52bfff04 	addi	r10,r10,-4
 1806914:	803ffb1e 	bne	r16,zero,1806904 <__ram_exceptions_end+0xff7f64c0>
 1806918:	14000415 	stw	r16,16(r2)
 180691c:	dfc00517 	ldw	ra,20(sp)
 1806920:	dd000417 	ldw	r20,16(sp)
 1806924:	dcc00317 	ldw	r19,12(sp)
 1806928:	dc800217 	ldw	r18,8(sp)
 180692c:	dc400117 	ldw	r17,4(sp)
 1806930:	dc000017 	ldw	r16,0(sp)
 1806934:	dec00604 	addi	sp,sp,24
 1806938:	f800283a 	ret

0180693c <__pow5mult>:
 180693c:	defffa04 	addi	sp,sp,-24
 1806940:	dcc00315 	stw	r19,12(sp)
 1806944:	dc000015 	stw	r16,0(sp)
 1806948:	dfc00515 	stw	ra,20(sp)
 180694c:	dd000415 	stw	r20,16(sp)
 1806950:	dc800215 	stw	r18,8(sp)
 1806954:	dc400115 	stw	r17,4(sp)
 1806958:	308000cc 	andi	r2,r6,3
 180695c:	3021883a 	mov	r16,r6
 1806960:	2027883a 	mov	r19,r4
 1806964:	10002f1e 	bne	r2,zero,1806a24 <__pow5mult+0xe8>
 1806968:	2825883a 	mov	r18,r5
 180696c:	8021d0ba 	srai	r16,r16,2
 1806970:	80001a26 	beq	r16,zero,18069dc <__pow5mult+0xa0>
 1806974:	9c401217 	ldw	r17,72(r19)
 1806978:	8800061e 	bne	r17,zero,1806994 <__pow5mult+0x58>
 180697c:	00003406 	br	1806a50 <__pow5mult+0x114>
 1806980:	8021d07a 	srai	r16,r16,1
 1806984:	80001526 	beq	r16,zero,18069dc <__pow5mult+0xa0>
 1806988:	88800017 	ldw	r2,0(r17)
 180698c:	10001c26 	beq	r2,zero,1806a00 <__pow5mult+0xc4>
 1806990:	1023883a 	mov	r17,r2
 1806994:	8080004c 	andi	r2,r16,1
 1806998:	103ff926 	beq	r2,zero,1806980 <__ram_exceptions_end+0xff7f653c>
 180699c:	880d883a 	mov	r6,r17
 18069a0:	900b883a 	mov	r5,r18
 18069a4:	9809883a 	mov	r4,r19
 18069a8:	18067440 	call	1806744 <__multiply>
 18069ac:	90001b26 	beq	r18,zero,1806a1c <__pow5mult+0xe0>
 18069b0:	91000117 	ldw	r4,4(r18)
 18069b4:	98c01317 	ldw	r3,76(r19)
 18069b8:	8021d07a 	srai	r16,r16,1
 18069bc:	2109883a 	add	r4,r4,r4
 18069c0:	2109883a 	add	r4,r4,r4
 18069c4:	1907883a 	add	r3,r3,r4
 18069c8:	19000017 	ldw	r4,0(r3)
 18069cc:	91000015 	stw	r4,0(r18)
 18069d0:	1c800015 	stw	r18,0(r3)
 18069d4:	1025883a 	mov	r18,r2
 18069d8:	803feb1e 	bne	r16,zero,1806988 <__ram_exceptions_end+0xff7f6544>
 18069dc:	9005883a 	mov	r2,r18
 18069e0:	dfc00517 	ldw	ra,20(sp)
 18069e4:	dd000417 	ldw	r20,16(sp)
 18069e8:	dcc00317 	ldw	r19,12(sp)
 18069ec:	dc800217 	ldw	r18,8(sp)
 18069f0:	dc400117 	ldw	r17,4(sp)
 18069f4:	dc000017 	ldw	r16,0(sp)
 18069f8:	dec00604 	addi	sp,sp,24
 18069fc:	f800283a 	ret
 1806a00:	880d883a 	mov	r6,r17
 1806a04:	880b883a 	mov	r5,r17
 1806a08:	9809883a 	mov	r4,r19
 1806a0c:	18067440 	call	1806744 <__multiply>
 1806a10:	88800015 	stw	r2,0(r17)
 1806a14:	10000015 	stw	zero,0(r2)
 1806a18:	003fdd06 	br	1806990 <__ram_exceptions_end+0xff7f654c>
 1806a1c:	1025883a 	mov	r18,r2
 1806a20:	003fd706 	br	1806980 <__ram_exceptions_end+0xff7f653c>
 1806a24:	10bfffc4 	addi	r2,r2,-1
 1806a28:	1085883a 	add	r2,r2,r2
 1806a2c:	00c06134 	movhi	r3,388
 1806a30:	18c4fe04 	addi	r3,r3,5112
 1806a34:	1085883a 	add	r2,r2,r2
 1806a38:	1885883a 	add	r2,r3,r2
 1806a3c:	11800017 	ldw	r6,0(r2)
 1806a40:	000f883a 	mov	r7,zero
 1806a44:	18063cc0 	call	18063cc <__multadd>
 1806a48:	1025883a 	mov	r18,r2
 1806a4c:	003fc706 	br	180696c <__ram_exceptions_end+0xff7f6528>
 1806a50:	05000044 	movi	r20,1
 1806a54:	a00b883a 	mov	r5,r20
 1806a58:	9809883a 	mov	r4,r19
 1806a5c:	18062fc0 	call	18062fc <_Balloc>
 1806a60:	1023883a 	mov	r17,r2
 1806a64:	00809c44 	movi	r2,625
 1806a68:	88800515 	stw	r2,20(r17)
 1806a6c:	8d000415 	stw	r20,16(r17)
 1806a70:	9c401215 	stw	r17,72(r19)
 1806a74:	88000015 	stw	zero,0(r17)
 1806a78:	003fc606 	br	1806994 <__ram_exceptions_end+0xff7f6550>

01806a7c <__lshift>:
 1806a7c:	defff904 	addi	sp,sp,-28
 1806a80:	dd400515 	stw	r21,20(sp)
 1806a84:	dcc00315 	stw	r19,12(sp)
 1806a88:	302bd17a 	srai	r21,r6,5
 1806a8c:	2cc00417 	ldw	r19,16(r5)
 1806a90:	28800217 	ldw	r2,8(r5)
 1806a94:	dd000415 	stw	r20,16(sp)
 1806a98:	ace7883a 	add	r19,r21,r19
 1806a9c:	dc800215 	stw	r18,8(sp)
 1806aa0:	dc400115 	stw	r17,4(sp)
 1806aa4:	dc000015 	stw	r16,0(sp)
 1806aa8:	dfc00615 	stw	ra,24(sp)
 1806aac:	9c000044 	addi	r16,r19,1
 1806ab0:	2823883a 	mov	r17,r5
 1806ab4:	3029883a 	mov	r20,r6
 1806ab8:	2025883a 	mov	r18,r4
 1806abc:	29400117 	ldw	r5,4(r5)
 1806ac0:	1400030e 	bge	r2,r16,1806ad0 <__lshift+0x54>
 1806ac4:	1085883a 	add	r2,r2,r2
 1806ac8:	29400044 	addi	r5,r5,1
 1806acc:	143ffd16 	blt	r2,r16,1806ac4 <__ram_exceptions_end+0xff7f6680>
 1806ad0:	9009883a 	mov	r4,r18
 1806ad4:	18062fc0 	call	18062fc <_Balloc>
 1806ad8:	10c00504 	addi	r3,r2,20
 1806adc:	0540070e 	bge	zero,r21,1806afc <__lshift+0x80>
 1806ae0:	ad6b883a 	add	r21,r21,r21
 1806ae4:	ad6b883a 	add	r21,r21,r21
 1806ae8:	1809883a 	mov	r4,r3
 1806aec:	1d47883a 	add	r3,r3,r21
 1806af0:	20000015 	stw	zero,0(r4)
 1806af4:	21000104 	addi	r4,r4,4
 1806af8:	193ffd1e 	bne	r3,r4,1806af0 <__ram_exceptions_end+0xff7f66ac>
 1806afc:	8a000417 	ldw	r8,16(r17)
 1806b00:	89000504 	addi	r4,r17,20
 1806b04:	a18007cc 	andi	r6,r20,31
 1806b08:	4211883a 	add	r8,r8,r8
 1806b0c:	4211883a 	add	r8,r8,r8
 1806b10:	2211883a 	add	r8,r4,r8
 1806b14:	30002326 	beq	r6,zero,1806ba4 <__lshift+0x128>
 1806b18:	02400804 	movi	r9,32
 1806b1c:	4993c83a 	sub	r9,r9,r6
 1806b20:	000b883a 	mov	r5,zero
 1806b24:	21c00017 	ldw	r7,0(r4)
 1806b28:	1815883a 	mov	r10,r3
 1806b2c:	18c00104 	addi	r3,r3,4
 1806b30:	398e983a 	sll	r7,r7,r6
 1806b34:	21000104 	addi	r4,r4,4
 1806b38:	394ab03a 	or	r5,r7,r5
 1806b3c:	197fff15 	stw	r5,-4(r3)
 1806b40:	217fff17 	ldw	r5,-4(r4)
 1806b44:	2a4ad83a 	srl	r5,r5,r9
 1806b48:	223ff636 	bltu	r4,r8,1806b24 <__ram_exceptions_end+0xff7f66e0>
 1806b4c:	51400115 	stw	r5,4(r10)
 1806b50:	28001a1e 	bne	r5,zero,1806bbc <__lshift+0x140>
 1806b54:	843fffc4 	addi	r16,r16,-1
 1806b58:	14000415 	stw	r16,16(r2)
 1806b5c:	88000826 	beq	r17,zero,1806b80 <__lshift+0x104>
 1806b60:	89000117 	ldw	r4,4(r17)
 1806b64:	90c01317 	ldw	r3,76(r18)
 1806b68:	2109883a 	add	r4,r4,r4
 1806b6c:	2109883a 	add	r4,r4,r4
 1806b70:	1907883a 	add	r3,r3,r4
 1806b74:	19000017 	ldw	r4,0(r3)
 1806b78:	89000015 	stw	r4,0(r17)
 1806b7c:	1c400015 	stw	r17,0(r3)
 1806b80:	dfc00617 	ldw	ra,24(sp)
 1806b84:	dd400517 	ldw	r21,20(sp)
 1806b88:	dd000417 	ldw	r20,16(sp)
 1806b8c:	dcc00317 	ldw	r19,12(sp)
 1806b90:	dc800217 	ldw	r18,8(sp)
 1806b94:	dc400117 	ldw	r17,4(sp)
 1806b98:	dc000017 	ldw	r16,0(sp)
 1806b9c:	dec00704 	addi	sp,sp,28
 1806ba0:	f800283a 	ret
 1806ba4:	21400017 	ldw	r5,0(r4)
 1806ba8:	18c00104 	addi	r3,r3,4
 1806bac:	21000104 	addi	r4,r4,4
 1806bb0:	197fff15 	stw	r5,-4(r3)
 1806bb4:	223ffb36 	bltu	r4,r8,1806ba4 <__ram_exceptions_end+0xff7f6760>
 1806bb8:	003fe606 	br	1806b54 <__ram_exceptions_end+0xff7f6710>
 1806bbc:	9c000084 	addi	r16,r19,2
 1806bc0:	003fe406 	br	1806b54 <__ram_exceptions_end+0xff7f6710>

01806bc4 <__mcmp>:
 1806bc4:	20800417 	ldw	r2,16(r4)
 1806bc8:	28c00417 	ldw	r3,16(r5)
 1806bcc:	10c5c83a 	sub	r2,r2,r3
 1806bd0:	1000111e 	bne	r2,zero,1806c18 <__mcmp+0x54>
 1806bd4:	18c7883a 	add	r3,r3,r3
 1806bd8:	18c7883a 	add	r3,r3,r3
 1806bdc:	21000504 	addi	r4,r4,20
 1806be0:	29400504 	addi	r5,r5,20
 1806be4:	20c5883a 	add	r2,r4,r3
 1806be8:	28cb883a 	add	r5,r5,r3
 1806bec:	00000106 	br	1806bf4 <__mcmp+0x30>
 1806bf0:	20800a2e 	bgeu	r4,r2,1806c1c <__mcmp+0x58>
 1806bf4:	10bfff04 	addi	r2,r2,-4
 1806bf8:	297fff04 	addi	r5,r5,-4
 1806bfc:	11800017 	ldw	r6,0(r2)
 1806c00:	28c00017 	ldw	r3,0(r5)
 1806c04:	30fffa26 	beq	r6,r3,1806bf0 <__ram_exceptions_end+0xff7f67ac>
 1806c08:	30c00236 	bltu	r6,r3,1806c14 <__mcmp+0x50>
 1806c0c:	00800044 	movi	r2,1
 1806c10:	f800283a 	ret
 1806c14:	00bfffc4 	movi	r2,-1
 1806c18:	f800283a 	ret
 1806c1c:	0005883a 	mov	r2,zero
 1806c20:	f800283a 	ret

01806c24 <__mdiff>:
 1806c24:	28c00417 	ldw	r3,16(r5)
 1806c28:	30800417 	ldw	r2,16(r6)
 1806c2c:	defffa04 	addi	sp,sp,-24
 1806c30:	dcc00315 	stw	r19,12(sp)
 1806c34:	dc800215 	stw	r18,8(sp)
 1806c38:	dfc00515 	stw	ra,20(sp)
 1806c3c:	dd000415 	stw	r20,16(sp)
 1806c40:	dc400115 	stw	r17,4(sp)
 1806c44:	dc000015 	stw	r16,0(sp)
 1806c48:	1887c83a 	sub	r3,r3,r2
 1806c4c:	2825883a 	mov	r18,r5
 1806c50:	3027883a 	mov	r19,r6
 1806c54:	1800141e 	bne	r3,zero,1806ca8 <__mdiff+0x84>
 1806c58:	1085883a 	add	r2,r2,r2
 1806c5c:	1085883a 	add	r2,r2,r2
 1806c60:	2a000504 	addi	r8,r5,20
 1806c64:	34000504 	addi	r16,r6,20
 1806c68:	4087883a 	add	r3,r8,r2
 1806c6c:	8085883a 	add	r2,r16,r2
 1806c70:	00000106 	br	1806c78 <__mdiff+0x54>
 1806c74:	40c0592e 	bgeu	r8,r3,1806ddc <__mdiff+0x1b8>
 1806c78:	18ffff04 	addi	r3,r3,-4
 1806c7c:	10bfff04 	addi	r2,r2,-4
 1806c80:	19c00017 	ldw	r7,0(r3)
 1806c84:	11400017 	ldw	r5,0(r2)
 1806c88:	397ffa26 	beq	r7,r5,1806c74 <__ram_exceptions_end+0xff7f6830>
 1806c8c:	3940592e 	bgeu	r7,r5,1806df4 <__mdiff+0x1d0>
 1806c90:	9005883a 	mov	r2,r18
 1806c94:	4023883a 	mov	r17,r8
 1806c98:	9825883a 	mov	r18,r19
 1806c9c:	05000044 	movi	r20,1
 1806ca0:	1027883a 	mov	r19,r2
 1806ca4:	00000406 	br	1806cb8 <__mdiff+0x94>
 1806ca8:	18005616 	blt	r3,zero,1806e04 <__mdiff+0x1e0>
 1806cac:	34400504 	addi	r17,r6,20
 1806cb0:	2c000504 	addi	r16,r5,20
 1806cb4:	0029883a 	mov	r20,zero
 1806cb8:	91400117 	ldw	r5,4(r18)
 1806cbc:	18062fc0 	call	18062fc <_Balloc>
 1806cc0:	92400417 	ldw	r9,16(r18)
 1806cc4:	9b000417 	ldw	r12,16(r19)
 1806cc8:	12c00504 	addi	r11,r2,20
 1806ccc:	4a51883a 	add	r8,r9,r9
 1806cd0:	6319883a 	add	r12,r12,r12
 1806cd4:	4211883a 	add	r8,r8,r8
 1806cd8:	6319883a 	add	r12,r12,r12
 1806cdc:	15000315 	stw	r20,12(r2)
 1806ce0:	8211883a 	add	r8,r16,r8
 1806ce4:	8b19883a 	add	r12,r17,r12
 1806ce8:	0007883a 	mov	r3,zero
 1806cec:	81400017 	ldw	r5,0(r16)
 1806cf0:	89c00017 	ldw	r7,0(r17)
 1806cf4:	59800104 	addi	r6,r11,4
 1806cf8:	293fffcc 	andi	r4,r5,65535
 1806cfc:	20c7883a 	add	r3,r4,r3
 1806d00:	393fffcc 	andi	r4,r7,65535
 1806d04:	1909c83a 	sub	r4,r3,r4
 1806d08:	280ad43a 	srli	r5,r5,16
 1806d0c:	380ed43a 	srli	r7,r7,16
 1806d10:	2007d43a 	srai	r3,r4,16
 1806d14:	213fffcc 	andi	r4,r4,65535
 1806d18:	29cbc83a 	sub	r5,r5,r7
 1806d1c:	28c7883a 	add	r3,r5,r3
 1806d20:	180a943a 	slli	r5,r3,16
 1806d24:	8c400104 	addi	r17,r17,4
 1806d28:	84000104 	addi	r16,r16,4
 1806d2c:	2908b03a 	or	r4,r5,r4
 1806d30:	59000015 	stw	r4,0(r11)
 1806d34:	1807d43a 	srai	r3,r3,16
 1806d38:	3015883a 	mov	r10,r6
 1806d3c:	3017883a 	mov	r11,r6
 1806d40:	8b3fea36 	bltu	r17,r12,1806cec <__ram_exceptions_end+0xff7f68a8>
 1806d44:	8200162e 	bgeu	r16,r8,1806da0 <__mdiff+0x17c>
 1806d48:	8017883a 	mov	r11,r16
 1806d4c:	59400017 	ldw	r5,0(r11)
 1806d50:	31800104 	addi	r6,r6,4
 1806d54:	5ac00104 	addi	r11,r11,4
 1806d58:	293fffcc 	andi	r4,r5,65535
 1806d5c:	20c7883a 	add	r3,r4,r3
 1806d60:	280ed43a 	srli	r7,r5,16
 1806d64:	180bd43a 	srai	r5,r3,16
 1806d68:	193fffcc 	andi	r4,r3,65535
 1806d6c:	3947883a 	add	r3,r7,r5
 1806d70:	180a943a 	slli	r5,r3,16
 1806d74:	1807d43a 	srai	r3,r3,16
 1806d78:	2908b03a 	or	r4,r5,r4
 1806d7c:	313fff15 	stw	r4,-4(r6)
 1806d80:	5a3ff236 	bltu	r11,r8,1806d4c <__ram_exceptions_end+0xff7f6908>
 1806d84:	0406303a 	nor	r3,zero,r16
 1806d88:	1a07883a 	add	r3,r3,r8
 1806d8c:	1806d0ba 	srli	r3,r3,2
 1806d90:	18c00044 	addi	r3,r3,1
 1806d94:	18c7883a 	add	r3,r3,r3
 1806d98:	18c7883a 	add	r3,r3,r3
 1806d9c:	50d5883a 	add	r10,r10,r3
 1806da0:	50ffff04 	addi	r3,r10,-4
 1806da4:	2000041e 	bne	r4,zero,1806db8 <__mdiff+0x194>
 1806da8:	18ffff04 	addi	r3,r3,-4
 1806dac:	19000017 	ldw	r4,0(r3)
 1806db0:	4a7fffc4 	addi	r9,r9,-1
 1806db4:	203ffc26 	beq	r4,zero,1806da8 <__ram_exceptions_end+0xff7f6964>
 1806db8:	12400415 	stw	r9,16(r2)
 1806dbc:	dfc00517 	ldw	ra,20(sp)
 1806dc0:	dd000417 	ldw	r20,16(sp)
 1806dc4:	dcc00317 	ldw	r19,12(sp)
 1806dc8:	dc800217 	ldw	r18,8(sp)
 1806dcc:	dc400117 	ldw	r17,4(sp)
 1806dd0:	dc000017 	ldw	r16,0(sp)
 1806dd4:	dec00604 	addi	sp,sp,24
 1806dd8:	f800283a 	ret
 1806ddc:	000b883a 	mov	r5,zero
 1806de0:	18062fc0 	call	18062fc <_Balloc>
 1806de4:	00c00044 	movi	r3,1
 1806de8:	10c00415 	stw	r3,16(r2)
 1806dec:	10000515 	stw	zero,20(r2)
 1806df0:	003ff206 	br	1806dbc <__ram_exceptions_end+0xff7f6978>
 1806df4:	8023883a 	mov	r17,r16
 1806df8:	0029883a 	mov	r20,zero
 1806dfc:	4021883a 	mov	r16,r8
 1806e00:	003fad06 	br	1806cb8 <__ram_exceptions_end+0xff7f6874>
 1806e04:	9005883a 	mov	r2,r18
 1806e08:	94400504 	addi	r17,r18,20
 1806e0c:	9c000504 	addi	r16,r19,20
 1806e10:	9825883a 	mov	r18,r19
 1806e14:	05000044 	movi	r20,1
 1806e18:	1027883a 	mov	r19,r2
 1806e1c:	003fa606 	br	1806cb8 <__ram_exceptions_end+0xff7f6874>

01806e20 <__ulp>:
 1806e20:	295ffc2c 	andhi	r5,r5,32752
 1806e24:	00bf3034 	movhi	r2,64704
 1806e28:	2887883a 	add	r3,r5,r2
 1806e2c:	00c0020e 	bge	zero,r3,1806e38 <__ulp+0x18>
 1806e30:	0005883a 	mov	r2,zero
 1806e34:	f800283a 	ret
 1806e38:	00c7c83a 	sub	r3,zero,r3
 1806e3c:	1807d53a 	srai	r3,r3,20
 1806e40:	008004c4 	movi	r2,19
 1806e44:	10c00b0e 	bge	r2,r3,1806e74 <__ulp+0x54>
 1806e48:	18bffb04 	addi	r2,r3,-20
 1806e4c:	01000784 	movi	r4,30
 1806e50:	0007883a 	mov	r3,zero
 1806e54:	20800516 	blt	r4,r2,1806e6c <__ulp+0x4c>
 1806e58:	010007c4 	movi	r4,31
 1806e5c:	2089c83a 	sub	r4,r4,r2
 1806e60:	00800044 	movi	r2,1
 1806e64:	1104983a 	sll	r2,r2,r4
 1806e68:	f800283a 	ret
 1806e6c:	00800044 	movi	r2,1
 1806e70:	f800283a 	ret
 1806e74:	01400234 	movhi	r5,8
 1806e78:	28c7d83a 	sra	r3,r5,r3
 1806e7c:	0005883a 	mov	r2,zero
 1806e80:	f800283a 	ret

01806e84 <__b2d>:
 1806e84:	defffa04 	addi	sp,sp,-24
 1806e88:	dc000015 	stw	r16,0(sp)
 1806e8c:	24000417 	ldw	r16,16(r4)
 1806e90:	dc400115 	stw	r17,4(sp)
 1806e94:	24400504 	addi	r17,r4,20
 1806e98:	8421883a 	add	r16,r16,r16
 1806e9c:	8421883a 	add	r16,r16,r16
 1806ea0:	8c21883a 	add	r16,r17,r16
 1806ea4:	dc800215 	stw	r18,8(sp)
 1806ea8:	84bfff17 	ldw	r18,-4(r16)
 1806eac:	dd000415 	stw	r20,16(sp)
 1806eb0:	dcc00315 	stw	r19,12(sp)
 1806eb4:	9009883a 	mov	r4,r18
 1806eb8:	2829883a 	mov	r20,r5
 1806ebc:	dfc00515 	stw	ra,20(sp)
 1806ec0:	18065f00 	call	18065f0 <__hi0bits>
 1806ec4:	00c00804 	movi	r3,32
 1806ec8:	1889c83a 	sub	r4,r3,r2
 1806ecc:	a1000015 	stw	r4,0(r20)
 1806ed0:	01000284 	movi	r4,10
 1806ed4:	84ffff04 	addi	r19,r16,-4
 1806ed8:	20801216 	blt	r4,r2,1806f24 <__b2d+0xa0>
 1806edc:	018002c4 	movi	r6,11
 1806ee0:	308dc83a 	sub	r6,r6,r2
 1806ee4:	9186d83a 	srl	r3,r18,r6
 1806ee8:	18cffc34 	orhi	r3,r3,16368
 1806eec:	8cc0212e 	bgeu	r17,r19,1806f74 <__b2d+0xf0>
 1806ef0:	813ffe17 	ldw	r4,-8(r16)
 1806ef4:	218cd83a 	srl	r6,r4,r6
 1806ef8:	10800544 	addi	r2,r2,21
 1806efc:	9084983a 	sll	r2,r18,r2
 1806f00:	1184b03a 	or	r2,r2,r6
 1806f04:	dfc00517 	ldw	ra,20(sp)
 1806f08:	dd000417 	ldw	r20,16(sp)
 1806f0c:	dcc00317 	ldw	r19,12(sp)
 1806f10:	dc800217 	ldw	r18,8(sp)
 1806f14:	dc400117 	ldw	r17,4(sp)
 1806f18:	dc000017 	ldw	r16,0(sp)
 1806f1c:	dec00604 	addi	sp,sp,24
 1806f20:	f800283a 	ret
 1806f24:	8cc00f2e 	bgeu	r17,r19,1806f64 <__b2d+0xe0>
 1806f28:	117ffd44 	addi	r5,r2,-11
 1806f2c:	80bffe17 	ldw	r2,-8(r16)
 1806f30:	28000e26 	beq	r5,zero,1806f6c <__b2d+0xe8>
 1806f34:	1949c83a 	sub	r4,r3,r5
 1806f38:	9164983a 	sll	r18,r18,r5
 1806f3c:	1106d83a 	srl	r3,r2,r4
 1806f40:	81bffe04 	addi	r6,r16,-8
 1806f44:	948ffc34 	orhi	r18,r18,16368
 1806f48:	90c6b03a 	or	r3,r18,r3
 1806f4c:	89800e2e 	bgeu	r17,r6,1806f88 <__b2d+0x104>
 1806f50:	81bffd17 	ldw	r6,-12(r16)
 1806f54:	1144983a 	sll	r2,r2,r5
 1806f58:	310ad83a 	srl	r5,r6,r4
 1806f5c:	2884b03a 	or	r2,r5,r2
 1806f60:	003fe806 	br	1806f04 <__ram_exceptions_end+0xff7f6ac0>
 1806f64:	10bffd44 	addi	r2,r2,-11
 1806f68:	1000041e 	bne	r2,zero,1806f7c <__b2d+0xf8>
 1806f6c:	90cffc34 	orhi	r3,r18,16368
 1806f70:	003fe406 	br	1806f04 <__ram_exceptions_end+0xff7f6ac0>
 1806f74:	000d883a 	mov	r6,zero
 1806f78:	003fdf06 	br	1806ef8 <__ram_exceptions_end+0xff7f6ab4>
 1806f7c:	90a4983a 	sll	r18,r18,r2
 1806f80:	0005883a 	mov	r2,zero
 1806f84:	003ff906 	br	1806f6c <__ram_exceptions_end+0xff7f6b28>
 1806f88:	1144983a 	sll	r2,r2,r5
 1806f8c:	003fdd06 	br	1806f04 <__ram_exceptions_end+0xff7f6ac0>

01806f90 <__d2b>:
 1806f90:	defff804 	addi	sp,sp,-32
 1806f94:	dc000215 	stw	r16,8(sp)
 1806f98:	3021883a 	mov	r16,r6
 1806f9c:	dc400315 	stw	r17,12(sp)
 1806fa0:	8022907a 	slli	r17,r16,1
 1806fa4:	dd000615 	stw	r20,24(sp)
 1806fa8:	2829883a 	mov	r20,r5
 1806fac:	01400044 	movi	r5,1
 1806fb0:	dcc00515 	stw	r19,20(sp)
 1806fb4:	dc800415 	stw	r18,16(sp)
 1806fb8:	dfc00715 	stw	ra,28(sp)
 1806fbc:	3825883a 	mov	r18,r7
 1806fc0:	8822d57a 	srli	r17,r17,21
 1806fc4:	18062fc0 	call	18062fc <_Balloc>
 1806fc8:	1027883a 	mov	r19,r2
 1806fcc:	00800434 	movhi	r2,16
 1806fd0:	10bfffc4 	addi	r2,r2,-1
 1806fd4:	808c703a 	and	r6,r16,r2
 1806fd8:	88000126 	beq	r17,zero,1806fe0 <__d2b+0x50>
 1806fdc:	31800434 	orhi	r6,r6,16
 1806fe0:	d9800015 	stw	r6,0(sp)
 1806fe4:	a0002426 	beq	r20,zero,1807078 <__d2b+0xe8>
 1806fe8:	d9000104 	addi	r4,sp,4
 1806fec:	dd000115 	stw	r20,4(sp)
 1806ff0:	18066580 	call	1806658 <__lo0bits>
 1806ff4:	d8c00017 	ldw	r3,0(sp)
 1806ff8:	10002f1e 	bne	r2,zero,18070b8 <__d2b+0x128>
 1806ffc:	d9000117 	ldw	r4,4(sp)
 1807000:	99000515 	stw	r4,20(r19)
 1807004:	1821003a 	cmpeq	r16,r3,zero
 1807008:	01000084 	movi	r4,2
 180700c:	2421c83a 	sub	r16,r4,r16
 1807010:	98c00615 	stw	r3,24(r19)
 1807014:	9c000415 	stw	r16,16(r19)
 1807018:	88001f1e 	bne	r17,zero,1807098 <__d2b+0x108>
 180701c:	10bef384 	addi	r2,r2,-1074
 1807020:	90800015 	stw	r2,0(r18)
 1807024:	00900034 	movhi	r2,16384
 1807028:	10bfffc4 	addi	r2,r2,-1
 180702c:	8085883a 	add	r2,r16,r2
 1807030:	1085883a 	add	r2,r2,r2
 1807034:	1085883a 	add	r2,r2,r2
 1807038:	9885883a 	add	r2,r19,r2
 180703c:	11000517 	ldw	r4,20(r2)
 1807040:	8020917a 	slli	r16,r16,5
 1807044:	18065f00 	call	18065f0 <__hi0bits>
 1807048:	d8c00817 	ldw	r3,32(sp)
 180704c:	8085c83a 	sub	r2,r16,r2
 1807050:	18800015 	stw	r2,0(r3)
 1807054:	9805883a 	mov	r2,r19
 1807058:	dfc00717 	ldw	ra,28(sp)
 180705c:	dd000617 	ldw	r20,24(sp)
 1807060:	dcc00517 	ldw	r19,20(sp)
 1807064:	dc800417 	ldw	r18,16(sp)
 1807068:	dc400317 	ldw	r17,12(sp)
 180706c:	dc000217 	ldw	r16,8(sp)
 1807070:	dec00804 	addi	sp,sp,32
 1807074:	f800283a 	ret
 1807078:	d809883a 	mov	r4,sp
 180707c:	18066580 	call	1806658 <__lo0bits>
 1807080:	d8c00017 	ldw	r3,0(sp)
 1807084:	04000044 	movi	r16,1
 1807088:	9c000415 	stw	r16,16(r19)
 180708c:	98c00515 	stw	r3,20(r19)
 1807090:	10800804 	addi	r2,r2,32
 1807094:	883fe126 	beq	r17,zero,180701c <__ram_exceptions_end+0xff7f6bd8>
 1807098:	00c00d44 	movi	r3,53
 180709c:	8c7ef344 	addi	r17,r17,-1075
 18070a0:	88a3883a 	add	r17,r17,r2
 18070a4:	1885c83a 	sub	r2,r3,r2
 18070a8:	d8c00817 	ldw	r3,32(sp)
 18070ac:	94400015 	stw	r17,0(r18)
 18070b0:	18800015 	stw	r2,0(r3)
 18070b4:	003fe706 	br	1807054 <__ram_exceptions_end+0xff7f6c10>
 18070b8:	01000804 	movi	r4,32
 18070bc:	2089c83a 	sub	r4,r4,r2
 18070c0:	1908983a 	sll	r4,r3,r4
 18070c4:	d9400117 	ldw	r5,4(sp)
 18070c8:	1886d83a 	srl	r3,r3,r2
 18070cc:	2148b03a 	or	r4,r4,r5
 18070d0:	99000515 	stw	r4,20(r19)
 18070d4:	d8c00015 	stw	r3,0(sp)
 18070d8:	003fca06 	br	1807004 <__ram_exceptions_end+0xff7f6bc0>

018070dc <__ratio>:
 18070dc:	defff904 	addi	sp,sp,-28
 18070e0:	dc400315 	stw	r17,12(sp)
 18070e4:	2823883a 	mov	r17,r5
 18070e8:	d9400104 	addi	r5,sp,4
 18070ec:	dfc00615 	stw	ra,24(sp)
 18070f0:	dcc00515 	stw	r19,20(sp)
 18070f4:	dc800415 	stw	r18,16(sp)
 18070f8:	2027883a 	mov	r19,r4
 18070fc:	dc000215 	stw	r16,8(sp)
 1807100:	1806e840 	call	1806e84 <__b2d>
 1807104:	d80b883a 	mov	r5,sp
 1807108:	8809883a 	mov	r4,r17
 180710c:	1025883a 	mov	r18,r2
 1807110:	1821883a 	mov	r16,r3
 1807114:	1806e840 	call	1806e84 <__b2d>
 1807118:	8a000417 	ldw	r8,16(r17)
 180711c:	99000417 	ldw	r4,16(r19)
 1807120:	d9400117 	ldw	r5,4(sp)
 1807124:	2209c83a 	sub	r4,r4,r8
 1807128:	2010917a 	slli	r8,r4,5
 180712c:	d9000017 	ldw	r4,0(sp)
 1807130:	2909c83a 	sub	r4,r5,r4
 1807134:	4109883a 	add	r4,r8,r4
 1807138:	01000e0e 	bge	zero,r4,1807174 <__ratio+0x98>
 180713c:	2008953a 	slli	r4,r4,20
 1807140:	2421883a 	add	r16,r4,r16
 1807144:	100d883a 	mov	r6,r2
 1807148:	180f883a 	mov	r7,r3
 180714c:	9009883a 	mov	r4,r18
 1807150:	800b883a 	mov	r5,r16
 1807154:	180b6780 	call	180b678 <__divdf3>
 1807158:	dfc00617 	ldw	ra,24(sp)
 180715c:	dcc00517 	ldw	r19,20(sp)
 1807160:	dc800417 	ldw	r18,16(sp)
 1807164:	dc400317 	ldw	r17,12(sp)
 1807168:	dc000217 	ldw	r16,8(sp)
 180716c:	dec00704 	addi	sp,sp,28
 1807170:	f800283a 	ret
 1807174:	2008953a 	slli	r4,r4,20
 1807178:	1907c83a 	sub	r3,r3,r4
 180717c:	003ff106 	br	1807144 <__ram_exceptions_end+0xff7f6d00>

01807180 <_mprec_log10>:
 1807180:	defffe04 	addi	sp,sp,-8
 1807184:	dc000015 	stw	r16,0(sp)
 1807188:	dfc00115 	stw	ra,4(sp)
 180718c:	008005c4 	movi	r2,23
 1807190:	2021883a 	mov	r16,r4
 1807194:	11000d0e 	bge	r2,r4,18071cc <_mprec_log10+0x4c>
 1807198:	0005883a 	mov	r2,zero
 180719c:	00cffc34 	movhi	r3,16368
 18071a0:	843fffc4 	addi	r16,r16,-1
 18071a4:	000d883a 	mov	r6,zero
 18071a8:	01d00934 	movhi	r7,16420
 18071ac:	1009883a 	mov	r4,r2
 18071b0:	180b883a 	mov	r5,r3
 18071b4:	180c1b80 	call	180c1b8 <__muldf3>
 18071b8:	803ff91e 	bne	r16,zero,18071a0 <__ram_exceptions_end+0xff7f6d5c>
 18071bc:	dfc00117 	ldw	ra,4(sp)
 18071c0:	dc000017 	ldw	r16,0(sp)
 18071c4:	dec00204 	addi	sp,sp,8
 18071c8:	f800283a 	ret
 18071cc:	202090fa 	slli	r16,r4,3
 18071d0:	00806134 	movhi	r2,388
 18071d4:	10851504 	addi	r2,r2,5204
 18071d8:	1421883a 	add	r16,r2,r16
 18071dc:	80800017 	ldw	r2,0(r16)
 18071e0:	80c00117 	ldw	r3,4(r16)
 18071e4:	dfc00117 	ldw	ra,4(sp)
 18071e8:	dc000017 	ldw	r16,0(sp)
 18071ec:	dec00204 	addi	sp,sp,8
 18071f0:	f800283a 	ret

018071f4 <__copybits>:
 18071f4:	297fffc4 	addi	r5,r5,-1
 18071f8:	280fd17a 	srai	r7,r5,5
 18071fc:	30c00417 	ldw	r3,16(r6)
 1807200:	30800504 	addi	r2,r6,20
 1807204:	39c00044 	addi	r7,r7,1
 1807208:	18c7883a 	add	r3,r3,r3
 180720c:	39cf883a 	add	r7,r7,r7
 1807210:	18c7883a 	add	r3,r3,r3
 1807214:	39cf883a 	add	r7,r7,r7
 1807218:	10c7883a 	add	r3,r2,r3
 180721c:	21cf883a 	add	r7,r4,r7
 1807220:	10c00d2e 	bgeu	r2,r3,1807258 <__copybits+0x64>
 1807224:	200b883a 	mov	r5,r4
 1807228:	12000017 	ldw	r8,0(r2)
 180722c:	29400104 	addi	r5,r5,4
 1807230:	10800104 	addi	r2,r2,4
 1807234:	2a3fff15 	stw	r8,-4(r5)
 1807238:	10fffb36 	bltu	r2,r3,1807228 <__ram_exceptions_end+0xff7f6de4>
 180723c:	1985c83a 	sub	r2,r3,r6
 1807240:	10bffac4 	addi	r2,r2,-21
 1807244:	1004d0ba 	srli	r2,r2,2
 1807248:	10800044 	addi	r2,r2,1
 180724c:	1085883a 	add	r2,r2,r2
 1807250:	1085883a 	add	r2,r2,r2
 1807254:	2089883a 	add	r4,r4,r2
 1807258:	21c0032e 	bgeu	r4,r7,1807268 <__copybits+0x74>
 180725c:	20000015 	stw	zero,0(r4)
 1807260:	21000104 	addi	r4,r4,4
 1807264:	21fffd36 	bltu	r4,r7,180725c <__ram_exceptions_end+0xff7f6e18>
 1807268:	f800283a 	ret

0180726c <__any_on>:
 180726c:	20c00417 	ldw	r3,16(r4)
 1807270:	2805d17a 	srai	r2,r5,5
 1807274:	21000504 	addi	r4,r4,20
 1807278:	18800d0e 	bge	r3,r2,18072b0 <__any_on+0x44>
 180727c:	18c7883a 	add	r3,r3,r3
 1807280:	18c7883a 	add	r3,r3,r3
 1807284:	20c7883a 	add	r3,r4,r3
 1807288:	20c0192e 	bgeu	r4,r3,18072f0 <__any_on+0x84>
 180728c:	18bfff17 	ldw	r2,-4(r3)
 1807290:	18ffff04 	addi	r3,r3,-4
 1807294:	1000041e 	bne	r2,zero,18072a8 <__any_on+0x3c>
 1807298:	20c0142e 	bgeu	r4,r3,18072ec <__any_on+0x80>
 180729c:	18ffff04 	addi	r3,r3,-4
 18072a0:	19400017 	ldw	r5,0(r3)
 18072a4:	283ffc26 	beq	r5,zero,1807298 <__ram_exceptions_end+0xff7f6e54>
 18072a8:	00800044 	movi	r2,1
 18072ac:	f800283a 	ret
 18072b0:	10c00a0e 	bge	r2,r3,18072dc <__any_on+0x70>
 18072b4:	1085883a 	add	r2,r2,r2
 18072b8:	1085883a 	add	r2,r2,r2
 18072bc:	294007cc 	andi	r5,r5,31
 18072c0:	2087883a 	add	r3,r4,r2
 18072c4:	283ff026 	beq	r5,zero,1807288 <__ram_exceptions_end+0xff7f6e44>
 18072c8:	19800017 	ldw	r6,0(r3)
 18072cc:	3144d83a 	srl	r2,r6,r5
 18072d0:	114a983a 	sll	r5,r2,r5
 18072d4:	317ff41e 	bne	r6,r5,18072a8 <__ram_exceptions_end+0xff7f6e64>
 18072d8:	003feb06 	br	1807288 <__ram_exceptions_end+0xff7f6e44>
 18072dc:	1085883a 	add	r2,r2,r2
 18072e0:	1085883a 	add	r2,r2,r2
 18072e4:	2087883a 	add	r3,r4,r2
 18072e8:	003fe706 	br	1807288 <__ram_exceptions_end+0xff7f6e44>
 18072ec:	f800283a 	ret
 18072f0:	0005883a 	mov	r2,zero
 18072f4:	f800283a 	ret

018072f8 <__fpclassifyd>:
 18072f8:	00a00034 	movhi	r2,32768
 18072fc:	10bfffc4 	addi	r2,r2,-1
 1807300:	2884703a 	and	r2,r5,r2
 1807304:	10000726 	beq	r2,zero,1807324 <__fpclassifyd+0x2c>
 1807308:	00fffc34 	movhi	r3,65520
 180730c:	019ff834 	movhi	r6,32736
 1807310:	28c7883a 	add	r3,r5,r3
 1807314:	31bfffc4 	addi	r6,r6,-1
 1807318:	30c00536 	bltu	r6,r3,1807330 <__fpclassifyd+0x38>
 180731c:	00800104 	movi	r2,4
 1807320:	f800283a 	ret
 1807324:	2000021e 	bne	r4,zero,1807330 <__fpclassifyd+0x38>
 1807328:	00800084 	movi	r2,2
 180732c:	f800283a 	ret
 1807330:	00dffc34 	movhi	r3,32752
 1807334:	019ff834 	movhi	r6,32736
 1807338:	28cb883a 	add	r5,r5,r3
 180733c:	31bfffc4 	addi	r6,r6,-1
 1807340:	317ff62e 	bgeu	r6,r5,180731c <__ram_exceptions_end+0xff7f6ed8>
 1807344:	01400434 	movhi	r5,16
 1807348:	297fffc4 	addi	r5,r5,-1
 180734c:	28800236 	bltu	r5,r2,1807358 <__fpclassifyd+0x60>
 1807350:	008000c4 	movi	r2,3
 1807354:	f800283a 	ret
 1807358:	10c00226 	beq	r2,r3,1807364 <__fpclassifyd+0x6c>
 180735c:	0005883a 	mov	r2,zero
 1807360:	f800283a 	ret
 1807364:	2005003a 	cmpeq	r2,r4,zero
 1807368:	f800283a 	ret

0180736c <_sbrk_r>:
 180736c:	defffd04 	addi	sp,sp,-12
 1807370:	dc000015 	stw	r16,0(sp)
 1807374:	04006134 	movhi	r16,388
 1807378:	dc400115 	stw	r17,4(sp)
 180737c:	841f2204 	addi	r16,r16,31880
 1807380:	2023883a 	mov	r17,r4
 1807384:	2809883a 	mov	r4,r5
 1807388:	dfc00215 	stw	ra,8(sp)
 180738c:	80000015 	stw	zero,0(r16)
 1807390:	18131e00 	call	18131e0 <sbrk>
 1807394:	00ffffc4 	movi	r3,-1
 1807398:	10c00526 	beq	r2,r3,18073b0 <_sbrk_r+0x44>
 180739c:	dfc00217 	ldw	ra,8(sp)
 18073a0:	dc400117 	ldw	r17,4(sp)
 18073a4:	dc000017 	ldw	r16,0(sp)
 18073a8:	dec00304 	addi	sp,sp,12
 18073ac:	f800283a 	ret
 18073b0:	80c00017 	ldw	r3,0(r16)
 18073b4:	183ff926 	beq	r3,zero,180739c <__ram_exceptions_end+0xff7f6f58>
 18073b8:	88c00015 	stw	r3,0(r17)
 18073bc:	003ff706 	br	180739c <__ram_exceptions_end+0xff7f6f58>

018073c0 <__sread>:
 18073c0:	defffe04 	addi	sp,sp,-8
 18073c4:	dc000015 	stw	r16,0(sp)
 18073c8:	2821883a 	mov	r16,r5
 18073cc:	2940038f 	ldh	r5,14(r5)
 18073d0:	dfc00115 	stw	ra,4(sp)
 18073d4:	18098640 	call	1809864 <_read_r>
 18073d8:	10000716 	blt	r2,zero,18073f8 <__sread+0x38>
 18073dc:	80c01417 	ldw	r3,80(r16)
 18073e0:	1887883a 	add	r3,r3,r2
 18073e4:	80c01415 	stw	r3,80(r16)
 18073e8:	dfc00117 	ldw	ra,4(sp)
 18073ec:	dc000017 	ldw	r16,0(sp)
 18073f0:	dec00204 	addi	sp,sp,8
 18073f4:	f800283a 	ret
 18073f8:	80c0030b 	ldhu	r3,12(r16)
 18073fc:	18fbffcc 	andi	r3,r3,61439
 1807400:	80c0030d 	sth	r3,12(r16)
 1807404:	dfc00117 	ldw	ra,4(sp)
 1807408:	dc000017 	ldw	r16,0(sp)
 180740c:	dec00204 	addi	sp,sp,8
 1807410:	f800283a 	ret

01807414 <__seofread>:
 1807414:	0005883a 	mov	r2,zero
 1807418:	f800283a 	ret

0180741c <__swrite>:
 180741c:	2880030b 	ldhu	r2,12(r5)
 1807420:	defffb04 	addi	sp,sp,-20
 1807424:	dcc00315 	stw	r19,12(sp)
 1807428:	dc800215 	stw	r18,8(sp)
 180742c:	dc400115 	stw	r17,4(sp)
 1807430:	dc000015 	stw	r16,0(sp)
 1807434:	dfc00415 	stw	ra,16(sp)
 1807438:	10c0400c 	andi	r3,r2,256
 180743c:	2821883a 	mov	r16,r5
 1807440:	2023883a 	mov	r17,r4
 1807444:	3025883a 	mov	r18,r6
 1807448:	3827883a 	mov	r19,r7
 180744c:	18000526 	beq	r3,zero,1807464 <__swrite+0x48>
 1807450:	2940038f 	ldh	r5,14(r5)
 1807454:	01c00084 	movi	r7,2
 1807458:	000d883a 	mov	r6,zero
 180745c:	18096a80 	call	18096a8 <_lseek_r>
 1807460:	8080030b 	ldhu	r2,12(r16)
 1807464:	8140038f 	ldh	r5,14(r16)
 1807468:	10bbffcc 	andi	r2,r2,61439
 180746c:	980f883a 	mov	r7,r19
 1807470:	900d883a 	mov	r6,r18
 1807474:	8809883a 	mov	r4,r17
 1807478:	8080030d 	sth	r2,12(r16)
 180747c:	dfc00417 	ldw	ra,16(sp)
 1807480:	dcc00317 	ldw	r19,12(sp)
 1807484:	dc800217 	ldw	r18,8(sp)
 1807488:	dc400117 	ldw	r17,4(sp)
 180748c:	dc000017 	ldw	r16,0(sp)
 1807490:	dec00504 	addi	sp,sp,20
 1807494:	1808cb81 	jmpi	1808cb8 <_write_r>

01807498 <__sseek>:
 1807498:	defffe04 	addi	sp,sp,-8
 180749c:	dc000015 	stw	r16,0(sp)
 18074a0:	2821883a 	mov	r16,r5
 18074a4:	2940038f 	ldh	r5,14(r5)
 18074a8:	dfc00115 	stw	ra,4(sp)
 18074ac:	18096a80 	call	18096a8 <_lseek_r>
 18074b0:	00ffffc4 	movi	r3,-1
 18074b4:	10c00826 	beq	r2,r3,18074d8 <__sseek+0x40>
 18074b8:	80c0030b 	ldhu	r3,12(r16)
 18074bc:	80801415 	stw	r2,80(r16)
 18074c0:	18c40014 	ori	r3,r3,4096
 18074c4:	80c0030d 	sth	r3,12(r16)
 18074c8:	dfc00117 	ldw	ra,4(sp)
 18074cc:	dc000017 	ldw	r16,0(sp)
 18074d0:	dec00204 	addi	sp,sp,8
 18074d4:	f800283a 	ret
 18074d8:	80c0030b 	ldhu	r3,12(r16)
 18074dc:	18fbffcc 	andi	r3,r3,61439
 18074e0:	80c0030d 	sth	r3,12(r16)
 18074e4:	dfc00117 	ldw	ra,4(sp)
 18074e8:	dc000017 	ldw	r16,0(sp)
 18074ec:	dec00204 	addi	sp,sp,8
 18074f0:	f800283a 	ret

018074f4 <__sclose>:
 18074f4:	2940038f 	ldh	r5,14(r5)
 18074f8:	1808d181 	jmpi	1808d18 <_close_r>

018074fc <strcmp>:
 18074fc:	2144b03a 	or	r2,r4,r5
 1807500:	108000cc 	andi	r2,r2,3
 1807504:	1000171e 	bne	r2,zero,1807564 <strcmp+0x68>
 1807508:	20800017 	ldw	r2,0(r4)
 180750c:	28c00017 	ldw	r3,0(r5)
 1807510:	10c0141e 	bne	r2,r3,1807564 <strcmp+0x68>
 1807514:	027fbff4 	movhi	r9,65279
 1807518:	4a7fbfc4 	addi	r9,r9,-257
 180751c:	0086303a 	nor	r3,zero,r2
 1807520:	02202074 	movhi	r8,32897
 1807524:	1245883a 	add	r2,r2,r9
 1807528:	42202004 	addi	r8,r8,-32640
 180752c:	10c4703a 	and	r2,r2,r3
 1807530:	1204703a 	and	r2,r2,r8
 1807534:	10000226 	beq	r2,zero,1807540 <strcmp+0x44>
 1807538:	00002306 	br	18075c8 <strcmp+0xcc>
 180753c:	1000221e 	bne	r2,zero,18075c8 <strcmp+0xcc>
 1807540:	21000104 	addi	r4,r4,4
 1807544:	20c00017 	ldw	r3,0(r4)
 1807548:	29400104 	addi	r5,r5,4
 180754c:	29800017 	ldw	r6,0(r5)
 1807550:	1a4f883a 	add	r7,r3,r9
 1807554:	00c4303a 	nor	r2,zero,r3
 1807558:	3884703a 	and	r2,r7,r2
 180755c:	1204703a 	and	r2,r2,r8
 1807560:	19bff626 	beq	r3,r6,180753c <__ram_exceptions_end+0xff7f70f8>
 1807564:	20800003 	ldbu	r2,0(r4)
 1807568:	10c03fcc 	andi	r3,r2,255
 180756c:	18c0201c 	xori	r3,r3,128
 1807570:	18ffe004 	addi	r3,r3,-128
 1807574:	18000c26 	beq	r3,zero,18075a8 <strcmp+0xac>
 1807578:	29800007 	ldb	r6,0(r5)
 180757c:	19800326 	beq	r3,r6,180758c <strcmp+0x90>
 1807580:	00001306 	br	18075d0 <strcmp+0xd4>
 1807584:	29800007 	ldb	r6,0(r5)
 1807588:	11800b1e 	bne	r2,r6,18075b8 <strcmp+0xbc>
 180758c:	21000044 	addi	r4,r4,1
 1807590:	20c00003 	ldbu	r3,0(r4)
 1807594:	29400044 	addi	r5,r5,1
 1807598:	18803fcc 	andi	r2,r3,255
 180759c:	1080201c 	xori	r2,r2,128
 18075a0:	10bfe004 	addi	r2,r2,-128
 18075a4:	103ff71e 	bne	r2,zero,1807584 <__ram_exceptions_end+0xff7f7140>
 18075a8:	0007883a 	mov	r3,zero
 18075ac:	28800003 	ldbu	r2,0(r5)
 18075b0:	1885c83a 	sub	r2,r3,r2
 18075b4:	f800283a 	ret
 18075b8:	28800003 	ldbu	r2,0(r5)
 18075bc:	18c03fcc 	andi	r3,r3,255
 18075c0:	1885c83a 	sub	r2,r3,r2
 18075c4:	f800283a 	ret
 18075c8:	0005883a 	mov	r2,zero
 18075cc:	f800283a 	ret
 18075d0:	10c03fcc 	andi	r3,r2,255
 18075d4:	003ff506 	br	18075ac <__ram_exceptions_end+0xff7f7168>

018075d8 <strlen>:
 18075d8:	208000cc 	andi	r2,r4,3
 18075dc:	10002026 	beq	r2,zero,1807660 <strlen+0x88>
 18075e0:	20800007 	ldb	r2,0(r4)
 18075e4:	10002026 	beq	r2,zero,1807668 <strlen+0x90>
 18075e8:	2005883a 	mov	r2,r4
 18075ec:	00000206 	br	18075f8 <strlen+0x20>
 18075f0:	10c00007 	ldb	r3,0(r2)
 18075f4:	18001826 	beq	r3,zero,1807658 <strlen+0x80>
 18075f8:	10800044 	addi	r2,r2,1
 18075fc:	10c000cc 	andi	r3,r2,3
 1807600:	183ffb1e 	bne	r3,zero,18075f0 <__ram_exceptions_end+0xff7f71ac>
 1807604:	10c00017 	ldw	r3,0(r2)
 1807608:	01ffbff4 	movhi	r7,65279
 180760c:	39ffbfc4 	addi	r7,r7,-257
 1807610:	00ca303a 	nor	r5,zero,r3
 1807614:	01a02074 	movhi	r6,32897
 1807618:	19c7883a 	add	r3,r3,r7
 180761c:	31a02004 	addi	r6,r6,-32640
 1807620:	1946703a 	and	r3,r3,r5
 1807624:	1986703a 	and	r3,r3,r6
 1807628:	1800091e 	bne	r3,zero,1807650 <strlen+0x78>
 180762c:	10800104 	addi	r2,r2,4
 1807630:	10c00017 	ldw	r3,0(r2)
 1807634:	19cb883a 	add	r5,r3,r7
 1807638:	00c6303a 	nor	r3,zero,r3
 180763c:	28c6703a 	and	r3,r5,r3
 1807640:	1986703a 	and	r3,r3,r6
 1807644:	183ff926 	beq	r3,zero,180762c <__ram_exceptions_end+0xff7f71e8>
 1807648:	00000106 	br	1807650 <strlen+0x78>
 180764c:	10800044 	addi	r2,r2,1
 1807650:	10c00007 	ldb	r3,0(r2)
 1807654:	183ffd1e 	bne	r3,zero,180764c <__ram_exceptions_end+0xff7f7208>
 1807658:	1105c83a 	sub	r2,r2,r4
 180765c:	f800283a 	ret
 1807660:	2005883a 	mov	r2,r4
 1807664:	003fe706 	br	1807604 <__ram_exceptions_end+0xff7f71c0>
 1807668:	0005883a 	mov	r2,zero
 180766c:	f800283a 	ret

01807670 <__sprint_r.part.0>:
 1807670:	28801917 	ldw	r2,100(r5)
 1807674:	defff604 	addi	sp,sp,-40
 1807678:	dd400515 	stw	r21,20(sp)
 180767c:	dfc00915 	stw	ra,36(sp)
 1807680:	df000815 	stw	fp,32(sp)
 1807684:	ddc00715 	stw	r23,28(sp)
 1807688:	dd800615 	stw	r22,24(sp)
 180768c:	dd000415 	stw	r20,16(sp)
 1807690:	dcc00315 	stw	r19,12(sp)
 1807694:	dc800215 	stw	r18,8(sp)
 1807698:	dc400115 	stw	r17,4(sp)
 180769c:	dc000015 	stw	r16,0(sp)
 18076a0:	1088000c 	andi	r2,r2,8192
 18076a4:	302b883a 	mov	r21,r6
 18076a8:	10002e26 	beq	r2,zero,1807764 <__sprint_r.part.0+0xf4>
 18076ac:	30800217 	ldw	r2,8(r6)
 18076b0:	35800017 	ldw	r22,0(r6)
 18076b4:	10002926 	beq	r2,zero,180775c <__sprint_r.part.0+0xec>
 18076b8:	2827883a 	mov	r19,r5
 18076bc:	2029883a 	mov	r20,r4
 18076c0:	b5c00104 	addi	r23,r22,4
 18076c4:	04bfffc4 	movi	r18,-1
 18076c8:	bc400017 	ldw	r17,0(r23)
 18076cc:	b4000017 	ldw	r16,0(r22)
 18076d0:	0039883a 	mov	fp,zero
 18076d4:	8822d0ba 	srli	r17,r17,2
 18076d8:	8800031e 	bne	r17,zero,18076e8 <__sprint_r.part.0+0x78>
 18076dc:	00001806 	br	1807740 <__sprint_r.part.0+0xd0>
 18076e0:	84000104 	addi	r16,r16,4
 18076e4:	8f001526 	beq	r17,fp,180773c <__sprint_r.part.0+0xcc>
 18076e8:	81400017 	ldw	r5,0(r16)
 18076ec:	980d883a 	mov	r6,r19
 18076f0:	a009883a 	mov	r4,r20
 18076f4:	18090980 	call	1809098 <_fputwc_r>
 18076f8:	e7000044 	addi	fp,fp,1
 18076fc:	14bff81e 	bne	r2,r18,18076e0 <__ram_exceptions_end+0xff7f729c>
 1807700:	9005883a 	mov	r2,r18
 1807704:	a8000215 	stw	zero,8(r21)
 1807708:	a8000115 	stw	zero,4(r21)
 180770c:	dfc00917 	ldw	ra,36(sp)
 1807710:	df000817 	ldw	fp,32(sp)
 1807714:	ddc00717 	ldw	r23,28(sp)
 1807718:	dd800617 	ldw	r22,24(sp)
 180771c:	dd400517 	ldw	r21,20(sp)
 1807720:	dd000417 	ldw	r20,16(sp)
 1807724:	dcc00317 	ldw	r19,12(sp)
 1807728:	dc800217 	ldw	r18,8(sp)
 180772c:	dc400117 	ldw	r17,4(sp)
 1807730:	dc000017 	ldw	r16,0(sp)
 1807734:	dec00a04 	addi	sp,sp,40
 1807738:	f800283a 	ret
 180773c:	a8800217 	ldw	r2,8(r21)
 1807740:	8c63883a 	add	r17,r17,r17
 1807744:	8c63883a 	add	r17,r17,r17
 1807748:	1445c83a 	sub	r2,r2,r17
 180774c:	a8800215 	stw	r2,8(r21)
 1807750:	b5800204 	addi	r22,r22,8
 1807754:	bdc00204 	addi	r23,r23,8
 1807758:	103fdb1e 	bne	r2,zero,18076c8 <__ram_exceptions_end+0xff7f7284>
 180775c:	0005883a 	mov	r2,zero
 1807760:	003fe806 	br	1807704 <__ram_exceptions_end+0xff7f72c0>
 1807764:	18091980 	call	1809198 <__sfvwrite_r>
 1807768:	003fe606 	br	1807704 <__ram_exceptions_end+0xff7f72c0>

0180776c <__sprint_r>:
 180776c:	30c00217 	ldw	r3,8(r6)
 1807770:	18000126 	beq	r3,zero,1807778 <__sprint_r+0xc>
 1807774:	18076701 	jmpi	1807670 <__sprint_r.part.0>
 1807778:	30000115 	stw	zero,4(r6)
 180777c:	0005883a 	mov	r2,zero
 1807780:	f800283a 	ret

01807784 <___vfiprintf_internal_r>:
 1807784:	deffc904 	addi	sp,sp,-220
 1807788:	df003515 	stw	fp,212(sp)
 180778c:	dd003115 	stw	r20,196(sp)
 1807790:	dfc03615 	stw	ra,216(sp)
 1807794:	ddc03415 	stw	r23,208(sp)
 1807798:	dd803315 	stw	r22,204(sp)
 180779c:	dd403215 	stw	r21,200(sp)
 18077a0:	dcc03015 	stw	r19,192(sp)
 18077a4:	dc802f15 	stw	r18,188(sp)
 18077a8:	dc402e15 	stw	r17,184(sp)
 18077ac:	dc002d15 	stw	r16,180(sp)
 18077b0:	d9002015 	stw	r4,128(sp)
 18077b4:	d9c02215 	stw	r7,136(sp)
 18077b8:	2829883a 	mov	r20,r5
 18077bc:	3039883a 	mov	fp,r6
 18077c0:	20000226 	beq	r4,zero,18077cc <___vfiprintf_internal_r+0x48>
 18077c4:	20800e17 	ldw	r2,56(r4)
 18077c8:	1000cf26 	beq	r2,zero,1807b08 <___vfiprintf_internal_r+0x384>
 18077cc:	a080030b 	ldhu	r2,12(r20)
 18077d0:	10c8000c 	andi	r3,r2,8192
 18077d4:	1800061e 	bne	r3,zero,18077f0 <___vfiprintf_internal_r+0x6c>
 18077d8:	a1001917 	ldw	r4,100(r20)
 18077dc:	00f7ffc4 	movi	r3,-8193
 18077e0:	10880014 	ori	r2,r2,8192
 18077e4:	20c6703a 	and	r3,r4,r3
 18077e8:	a080030d 	sth	r2,12(r20)
 18077ec:	a0c01915 	stw	r3,100(r20)
 18077f0:	10c0020c 	andi	r3,r2,8
 18077f4:	1800a926 	beq	r3,zero,1807a9c <___vfiprintf_internal_r+0x318>
 18077f8:	a0c00417 	ldw	r3,16(r20)
 18077fc:	1800a726 	beq	r3,zero,1807a9c <___vfiprintf_internal_r+0x318>
 1807800:	1080068c 	andi	r2,r2,26
 1807804:	00c00284 	movi	r3,10
 1807808:	10c0ac26 	beq	r2,r3,1807abc <___vfiprintf_internal_r+0x338>
 180780c:	da801a04 	addi	r10,sp,104
 1807810:	da801e15 	stw	r10,120(sp)
 1807814:	d8801e17 	ldw	r2,120(sp)
 1807818:	da8019c4 	addi	r10,sp,103
 180781c:	05806134 	movhi	r22,388
 1807820:	05c06134 	movhi	r23,388
 1807824:	da801f15 	stw	r10,124(sp)
 1807828:	1295c83a 	sub	r10,r2,r10
 180782c:	b5854b04 	addi	r22,r22,5420
 1807830:	bdc54704 	addi	r23,r23,5404
 1807834:	dec01a15 	stw	sp,104(sp)
 1807838:	d8001c15 	stw	zero,112(sp)
 180783c:	d8001b15 	stw	zero,108(sp)
 1807840:	d8002615 	stw	zero,152(sp)
 1807844:	d8002315 	stw	zero,140(sp)
 1807848:	da802715 	stw	r10,156(sp)
 180784c:	d811883a 	mov	r8,sp
 1807850:	dd002115 	stw	r20,132(sp)
 1807854:	e021883a 	mov	r16,fp
 1807858:	80800007 	ldb	r2,0(r16)
 180785c:	1003ea26 	beq	r2,zero,1808808 <___vfiprintf_internal_r+0x1084>
 1807860:	00c00944 	movi	r3,37
 1807864:	8025883a 	mov	r18,r16
 1807868:	10c0021e 	bne	r2,r3,1807874 <___vfiprintf_internal_r+0xf0>
 180786c:	00001606 	br	18078c8 <___vfiprintf_internal_r+0x144>
 1807870:	10c00326 	beq	r2,r3,1807880 <___vfiprintf_internal_r+0xfc>
 1807874:	94800044 	addi	r18,r18,1
 1807878:	90800007 	ldb	r2,0(r18)
 180787c:	103ffc1e 	bne	r2,zero,1807870 <__ram_exceptions_end+0xff7f742c>
 1807880:	9423c83a 	sub	r17,r18,r16
 1807884:	88001026 	beq	r17,zero,18078c8 <___vfiprintf_internal_r+0x144>
 1807888:	d8c01c17 	ldw	r3,112(sp)
 180788c:	d8801b17 	ldw	r2,108(sp)
 1807890:	44000015 	stw	r16,0(r8)
 1807894:	88c7883a 	add	r3,r17,r3
 1807898:	10800044 	addi	r2,r2,1
 180789c:	44400115 	stw	r17,4(r8)
 18078a0:	d8c01c15 	stw	r3,112(sp)
 18078a4:	d8801b15 	stw	r2,108(sp)
 18078a8:	010001c4 	movi	r4,7
 18078ac:	2080760e 	bge	r4,r2,1807a88 <___vfiprintf_internal_r+0x304>
 18078b0:	1803821e 	bne	r3,zero,18086bc <___vfiprintf_internal_r+0xf38>
 18078b4:	da802317 	ldw	r10,140(sp)
 18078b8:	d8001b15 	stw	zero,108(sp)
 18078bc:	d811883a 	mov	r8,sp
 18078c0:	5455883a 	add	r10,r10,r17
 18078c4:	da802315 	stw	r10,140(sp)
 18078c8:	90800007 	ldb	r2,0(r18)
 18078cc:	10044626 	beq	r2,zero,18089e8 <___vfiprintf_internal_r+0x1264>
 18078d0:	90c00047 	ldb	r3,1(r18)
 18078d4:	94000044 	addi	r16,r18,1
 18078d8:	d8001d85 	stb	zero,118(sp)
 18078dc:	0009883a 	mov	r4,zero
 18078e0:	000f883a 	mov	r7,zero
 18078e4:	027fffc4 	movi	r9,-1
 18078e8:	0023883a 	mov	r17,zero
 18078ec:	0029883a 	mov	r20,zero
 18078f0:	01401604 	movi	r5,88
 18078f4:	01800244 	movi	r6,9
 18078f8:	03400a84 	movi	r13,42
 18078fc:	03001b04 	movi	r12,108
 1807900:	84000044 	addi	r16,r16,1
 1807904:	18bff804 	addi	r2,r3,-32
 1807908:	28827336 	bltu	r5,r2,18082d8 <___vfiprintf_internal_r+0xb54>
 180790c:	100490ba 	slli	r2,r2,2
 1807910:	02806034 	movhi	r10,384
 1807914:	529e4904 	addi	r10,r10,31012
 1807918:	1285883a 	add	r2,r2,r10
 180791c:	10800017 	ldw	r2,0(r2)
 1807920:	1000683a 	jmp	r2
 1807924:	0180800c 	andi	r6,zero,512
 1807928:	018082d8 	cmpnei	r6,zero,523
 180792c:	018082d8 	cmpnei	r6,zero,523
 1807930:	0180802c 	andhi	r6,zero,512
 1807934:	018082d8 	cmpnei	r6,zero,523
 1807938:	018082d8 	cmpnei	r6,zero,523
 180793c:	018082d8 	cmpnei	r6,zero,523
 1807940:	018082d8 	cmpnei	r6,zero,523
 1807944:	018082d8 	cmpnei	r6,zero,523
 1807948:	018082d8 	cmpnei	r6,zero,523
 180794c:	01808214 	movui	r6,520
 1807950:	01808230 	cmpltui	r6,zero,520
 1807954:	018082d8 	cmpnei	r6,zero,523
 1807958:	01807b18 	cmpnei	r6,zero,492
 180795c:	01808240 	call	180824 <__alt_mem_tse_descriptor_memory_0+0x180824>
 1807960:	018082d8 	cmpnei	r6,zero,523
 1807964:	01808038 	rdprs	r6,zero,512
 1807968:	01808044 	movi	r6,513
 180796c:	01808044 	movi	r6,513
 1807970:	01808044 	movi	r6,513
 1807974:	01808044 	movi	r6,513
 1807978:	01808044 	movi	r6,513
 180797c:	01808044 	movi	r6,513
 1807980:	01808044 	movi	r6,513
 1807984:	01808044 	movi	r6,513
 1807988:	01808044 	movi	r6,513
 180798c:	018082d8 	cmpnei	r6,zero,523
 1807990:	018082d8 	cmpnei	r6,zero,523
 1807994:	018082d8 	cmpnei	r6,zero,523
 1807998:	018082d8 	cmpnei	r6,zero,523
 180799c:	018082d8 	cmpnei	r6,zero,523
 18079a0:	018082d8 	cmpnei	r6,zero,523
 18079a4:	018082d8 	cmpnei	r6,zero,523
 18079a8:	018082d8 	cmpnei	r6,zero,523
 18079ac:	018082d8 	cmpnei	r6,zero,523
 18079b0:	018082d8 	cmpnei	r6,zero,523
 18079b4:	01808070 	cmpltui	r6,zero,513
 18079b8:	018082d8 	cmpnei	r6,zero,523
 18079bc:	018082d8 	cmpnei	r6,zero,523
 18079c0:	018082d8 	cmpnei	r6,zero,523
 18079c4:	018082d8 	cmpnei	r6,zero,523
 18079c8:	018082d8 	cmpnei	r6,zero,523
 18079cc:	018082d8 	cmpnei	r6,zero,523
 18079d0:	018082d8 	cmpnei	r6,zero,523
 18079d4:	018082d8 	cmpnei	r6,zero,523
 18079d8:	018082d8 	cmpnei	r6,zero,523
 18079dc:	018082d8 	cmpnei	r6,zero,523
 18079e0:	018080a8 	cmpgeui	r6,zero,514
 18079e4:	018082d8 	cmpnei	r6,zero,523
 18079e8:	018082d8 	cmpnei	r6,zero,523
 18079ec:	018082d8 	cmpnei	r6,zero,523
 18079f0:	018082d8 	cmpnei	r6,zero,523
 18079f4:	018082d8 	cmpnei	r6,zero,523
 18079f8:	01808100 	call	180810 <__alt_mem_tse_descriptor_memory_0+0x180810>
 18079fc:	018082d8 	cmpnei	r6,zero,523
 1807a00:	018082d8 	cmpnei	r6,zero,523
 1807a04:	01808170 	cmpltui	r6,zero,517
 1807a08:	018082d8 	cmpnei	r6,zero,523
 1807a0c:	018082d8 	cmpnei	r6,zero,523
 1807a10:	018082d8 	cmpnei	r6,zero,523
 1807a14:	018082d8 	cmpnei	r6,zero,523
 1807a18:	018082d8 	cmpnei	r6,zero,523
 1807a1c:	018082d8 	cmpnei	r6,zero,523
 1807a20:	018082d8 	cmpnei	r6,zero,523
 1807a24:	018082d8 	cmpnei	r6,zero,523
 1807a28:	018082d8 	cmpnei	r6,zero,523
 1807a2c:	018082d8 	cmpnei	r6,zero,523
 1807a30:	01807f1c 	xori	r6,zero,508
 1807a34:	01807f48 	cmpgei	r6,zero,509
 1807a38:	018082d8 	cmpnei	r6,zero,523
 1807a3c:	018082d8 	cmpnei	r6,zero,523
 1807a40:	018082d8 	cmpnei	r6,zero,523
 1807a44:	01808280 	call	180828 <__alt_mem_tse_descriptor_memory_0+0x180828>
 1807a48:	01807f48 	cmpgei	r6,zero,509
 1807a4c:	018082d8 	cmpnei	r6,zero,523
 1807a50:	018082d8 	cmpnei	r6,zero,523
 1807a54:	01807ddc 	xori	r6,zero,503
 1807a58:	018082d8 	cmpnei	r6,zero,523
 1807a5c:	01807dec 	andhi	r6,zero,503
 1807a60:	01807e28 	cmpgeui	r6,zero,504
 1807a64:	01807b24 	muli	r6,zero,492
 1807a68:	01807dd0 	cmplti	r6,zero,503
 1807a6c:	018082d8 	cmpnei	r6,zero,523
 1807a70:	018081ac 	andhi	r6,zero,518
 1807a74:	018082d8 	cmpnei	r6,zero,523
 1807a78:	01808204 	movi	r6,520
 1807a7c:	018082d8 	cmpnei	r6,zero,523
 1807a80:	018082d8 	cmpnei	r6,zero,523
 1807a84:	01807ec8 	cmpgei	r6,zero,507
 1807a88:	42000204 	addi	r8,r8,8
 1807a8c:	da802317 	ldw	r10,140(sp)
 1807a90:	5455883a 	add	r10,r10,r17
 1807a94:	da802315 	stw	r10,140(sp)
 1807a98:	003f8b06 	br	18078c8 <__ram_exceptions_end+0xff7f7484>
 1807a9c:	d9002017 	ldw	r4,128(sp)
 1807aa0:	a00b883a 	mov	r5,r20
 1807aa4:	1802f240 	call	1802f24 <__swsetup_r>
 1807aa8:	1003b11e 	bne	r2,zero,1808970 <___vfiprintf_internal_r+0x11ec>
 1807aac:	a080030b 	ldhu	r2,12(r20)
 1807ab0:	00c00284 	movi	r3,10
 1807ab4:	1080068c 	andi	r2,r2,26
 1807ab8:	10ff541e 	bne	r2,r3,180780c <__ram_exceptions_end+0xff7f73c8>
 1807abc:	a080038f 	ldh	r2,14(r20)
 1807ac0:	103f5216 	blt	r2,zero,180780c <__ram_exceptions_end+0xff7f73c8>
 1807ac4:	d9c02217 	ldw	r7,136(sp)
 1807ac8:	d9002017 	ldw	r4,128(sp)
 1807acc:	e00d883a 	mov	r6,fp
 1807ad0:	a00b883a 	mov	r5,r20
 1807ad4:	1808bfc0 	call	1808bfc <__sbprintf>
 1807ad8:	dfc03617 	ldw	ra,216(sp)
 1807adc:	df003517 	ldw	fp,212(sp)
 1807ae0:	ddc03417 	ldw	r23,208(sp)
 1807ae4:	dd803317 	ldw	r22,204(sp)
 1807ae8:	dd403217 	ldw	r21,200(sp)
 1807aec:	dd003117 	ldw	r20,196(sp)
 1807af0:	dcc03017 	ldw	r19,192(sp)
 1807af4:	dc802f17 	ldw	r18,188(sp)
 1807af8:	dc402e17 	ldw	r17,184(sp)
 1807afc:	dc002d17 	ldw	r16,180(sp)
 1807b00:	dec03704 	addi	sp,sp,220
 1807b04:	f800283a 	ret
 1807b08:	1804ef80 	call	1804ef8 <__sinit>
 1807b0c:	003f2f06 	br	18077cc <__ram_exceptions_end+0xff7f7388>
 1807b10:	0463c83a 	sub	r17,zero,r17
 1807b14:	d8802215 	stw	r2,136(sp)
 1807b18:	a5000114 	ori	r20,r20,4
 1807b1c:	80c00007 	ldb	r3,0(r16)
 1807b20:	003f7706 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1807b24:	00800c04 	movi	r2,48
 1807b28:	da802217 	ldw	r10,136(sp)
 1807b2c:	d8801d05 	stb	r2,116(sp)
 1807b30:	00801e04 	movi	r2,120
 1807b34:	d8801d45 	stb	r2,117(sp)
 1807b38:	d8001d85 	stb	zero,118(sp)
 1807b3c:	50c00104 	addi	r3,r10,4
 1807b40:	54800017 	ldw	r18,0(r10)
 1807b44:	0027883a 	mov	r19,zero
 1807b48:	a0800094 	ori	r2,r20,2
 1807b4c:	48030b16 	blt	r9,zero,180877c <___vfiprintf_internal_r+0xff8>
 1807b50:	00bfdfc4 	movi	r2,-129
 1807b54:	a096703a 	and	r11,r20,r2
 1807b58:	d8c02215 	stw	r3,136(sp)
 1807b5c:	5d000094 	ori	r20,r11,2
 1807b60:	90032b1e 	bne	r18,zero,1808810 <___vfiprintf_internal_r+0x108c>
 1807b64:	00806134 	movhi	r2,388
 1807b68:	1084e604 	addi	r2,r2,5016
 1807b6c:	d8802615 	stw	r2,152(sp)
 1807b70:	0039883a 	mov	fp,zero
 1807b74:	48017b1e 	bne	r9,zero,1808164 <___vfiprintf_internal_r+0x9e0>
 1807b78:	0013883a 	mov	r9,zero
 1807b7c:	0027883a 	mov	r19,zero
 1807b80:	dd401a04 	addi	r21,sp,104
 1807b84:	4825883a 	mov	r18,r9
 1807b88:	4cc0010e 	bge	r9,r19,1807b90 <___vfiprintf_internal_r+0x40c>
 1807b8c:	9825883a 	mov	r18,r19
 1807b90:	e7003fcc 	andi	fp,fp,255
 1807b94:	e700201c 	xori	fp,fp,128
 1807b98:	e73fe004 	addi	fp,fp,-128
 1807b9c:	e0000126 	beq	fp,zero,1807ba4 <___vfiprintf_internal_r+0x420>
 1807ba0:	94800044 	addi	r18,r18,1
 1807ba4:	a380008c 	andi	r14,r20,2
 1807ba8:	70000126 	beq	r14,zero,1807bb0 <___vfiprintf_internal_r+0x42c>
 1807bac:	94800084 	addi	r18,r18,2
 1807bb0:	a700210c 	andi	fp,r20,132
 1807bb4:	e001df1e 	bne	fp,zero,1808334 <___vfiprintf_internal_r+0xbb0>
 1807bb8:	8c87c83a 	sub	r3,r17,r18
 1807bbc:	00c1dd0e 	bge	zero,r3,1808334 <___vfiprintf_internal_r+0xbb0>
 1807bc0:	01c00404 	movi	r7,16
 1807bc4:	d8801c17 	ldw	r2,112(sp)
 1807bc8:	38c3ad0e 	bge	r7,r3,1808a80 <___vfiprintf_internal_r+0x12fc>
 1807bcc:	02806134 	movhi	r10,388
 1807bd0:	52854b04 	addi	r10,r10,5420
 1807bd4:	dc002915 	stw	r16,164(sp)
 1807bd8:	d9801b17 	ldw	r6,108(sp)
 1807bdc:	da802415 	stw	r10,144(sp)
 1807be0:	03c001c4 	movi	r15,7
 1807be4:	da402515 	stw	r9,148(sp)
 1807be8:	db802815 	stw	r14,160(sp)
 1807bec:	1821883a 	mov	r16,r3
 1807bf0:	00000506 	br	1807c08 <___vfiprintf_internal_r+0x484>
 1807bf4:	31400084 	addi	r5,r6,2
 1807bf8:	42000204 	addi	r8,r8,8
 1807bfc:	200d883a 	mov	r6,r4
 1807c00:	843ffc04 	addi	r16,r16,-16
 1807c04:	3c000d0e 	bge	r7,r16,1807c3c <___vfiprintf_internal_r+0x4b8>
 1807c08:	10800404 	addi	r2,r2,16
 1807c0c:	31000044 	addi	r4,r6,1
 1807c10:	45800015 	stw	r22,0(r8)
 1807c14:	41c00115 	stw	r7,4(r8)
 1807c18:	d8801c15 	stw	r2,112(sp)
 1807c1c:	d9001b15 	stw	r4,108(sp)
 1807c20:	793ff40e 	bge	r15,r4,1807bf4 <__ram_exceptions_end+0xff7f77b0>
 1807c24:	1001b51e 	bne	r2,zero,18082fc <___vfiprintf_internal_r+0xb78>
 1807c28:	843ffc04 	addi	r16,r16,-16
 1807c2c:	000d883a 	mov	r6,zero
 1807c30:	01400044 	movi	r5,1
 1807c34:	d811883a 	mov	r8,sp
 1807c38:	3c3ff316 	blt	r7,r16,1807c08 <__ram_exceptions_end+0xff7f77c4>
 1807c3c:	8007883a 	mov	r3,r16
 1807c40:	da402517 	ldw	r9,148(sp)
 1807c44:	db802817 	ldw	r14,160(sp)
 1807c48:	dc002917 	ldw	r16,164(sp)
 1807c4c:	da802417 	ldw	r10,144(sp)
 1807c50:	1885883a 	add	r2,r3,r2
 1807c54:	40c00115 	stw	r3,4(r8)
 1807c58:	42800015 	stw	r10,0(r8)
 1807c5c:	d8801c15 	stw	r2,112(sp)
 1807c60:	d9401b15 	stw	r5,108(sp)
 1807c64:	00c001c4 	movi	r3,7
 1807c68:	19426016 	blt	r3,r5,18085ec <___vfiprintf_internal_r+0xe68>
 1807c6c:	d8c01d87 	ldb	r3,118(sp)
 1807c70:	42000204 	addi	r8,r8,8
 1807c74:	29000044 	addi	r4,r5,1
 1807c78:	1801b31e 	bne	r3,zero,1808348 <___vfiprintf_internal_r+0xbc4>
 1807c7c:	7001c026 	beq	r14,zero,1808380 <___vfiprintf_internal_r+0xbfc>
 1807c80:	d8c01d04 	addi	r3,sp,116
 1807c84:	10800084 	addi	r2,r2,2
 1807c88:	40c00015 	stw	r3,0(r8)
 1807c8c:	00c00084 	movi	r3,2
 1807c90:	40c00115 	stw	r3,4(r8)
 1807c94:	d8801c15 	stw	r2,112(sp)
 1807c98:	d9001b15 	stw	r4,108(sp)
 1807c9c:	00c001c4 	movi	r3,7
 1807ca0:	1902650e 	bge	r3,r4,1808638 <___vfiprintf_internal_r+0xeb4>
 1807ca4:	10029a1e 	bne	r2,zero,1808710 <___vfiprintf_internal_r+0xf8c>
 1807ca8:	00c02004 	movi	r3,128
 1807cac:	01000044 	movi	r4,1
 1807cb0:	000b883a 	mov	r5,zero
 1807cb4:	d811883a 	mov	r8,sp
 1807cb8:	e0c1b31e 	bne	fp,r3,1808388 <___vfiprintf_internal_r+0xc04>
 1807cbc:	8cb9c83a 	sub	fp,r17,r18
 1807cc0:	0701b10e 	bge	zero,fp,1808388 <___vfiprintf_internal_r+0xc04>
 1807cc4:	01c00404 	movi	r7,16
 1807cc8:	3f03890e 	bge	r7,fp,1808af0 <___vfiprintf_internal_r+0x136c>
 1807ccc:	00c06134 	movhi	r3,388
 1807cd0:	18c54704 	addi	r3,r3,5404
 1807cd4:	d8c02415 	stw	r3,144(sp)
 1807cd8:	8007883a 	mov	r3,r16
 1807cdc:	034001c4 	movi	r13,7
 1807ce0:	e021883a 	mov	r16,fp
 1807ce4:	da402515 	stw	r9,148(sp)
 1807ce8:	1839883a 	mov	fp,r3
 1807cec:	00000506 	br	1807d04 <___vfiprintf_internal_r+0x580>
 1807cf0:	29800084 	addi	r6,r5,2
 1807cf4:	42000204 	addi	r8,r8,8
 1807cf8:	180b883a 	mov	r5,r3
 1807cfc:	843ffc04 	addi	r16,r16,-16
 1807d00:	3c000d0e 	bge	r7,r16,1807d38 <___vfiprintf_internal_r+0x5b4>
 1807d04:	10800404 	addi	r2,r2,16
 1807d08:	28c00044 	addi	r3,r5,1
 1807d0c:	45c00015 	stw	r23,0(r8)
 1807d10:	41c00115 	stw	r7,4(r8)
 1807d14:	d8801c15 	stw	r2,112(sp)
 1807d18:	d8c01b15 	stw	r3,108(sp)
 1807d1c:	68fff40e 	bge	r13,r3,1807cf0 <__ram_exceptions_end+0xff7f78ac>
 1807d20:	1002241e 	bne	r2,zero,18085b4 <___vfiprintf_internal_r+0xe30>
 1807d24:	843ffc04 	addi	r16,r16,-16
 1807d28:	01800044 	movi	r6,1
 1807d2c:	000b883a 	mov	r5,zero
 1807d30:	d811883a 	mov	r8,sp
 1807d34:	3c3ff316 	blt	r7,r16,1807d04 <__ram_exceptions_end+0xff7f78c0>
 1807d38:	da402517 	ldw	r9,148(sp)
 1807d3c:	e007883a 	mov	r3,fp
 1807d40:	8039883a 	mov	fp,r16
 1807d44:	1821883a 	mov	r16,r3
 1807d48:	d8c02417 	ldw	r3,144(sp)
 1807d4c:	1705883a 	add	r2,r2,fp
 1807d50:	47000115 	stw	fp,4(r8)
 1807d54:	40c00015 	stw	r3,0(r8)
 1807d58:	d8801c15 	stw	r2,112(sp)
 1807d5c:	d9801b15 	stw	r6,108(sp)
 1807d60:	00c001c4 	movi	r3,7
 1807d64:	19827616 	blt	r3,r6,1808740 <___vfiprintf_internal_r+0xfbc>
 1807d68:	4cf9c83a 	sub	fp,r9,r19
 1807d6c:	42000204 	addi	r8,r8,8
 1807d70:	31000044 	addi	r4,r6,1
 1807d74:	300b883a 	mov	r5,r6
 1807d78:	07018516 	blt	zero,fp,1808390 <___vfiprintf_internal_r+0xc0c>
 1807d7c:	9885883a 	add	r2,r19,r2
 1807d80:	45400015 	stw	r21,0(r8)
 1807d84:	44c00115 	stw	r19,4(r8)
 1807d88:	d8801c15 	stw	r2,112(sp)
 1807d8c:	d9001b15 	stw	r4,108(sp)
 1807d90:	00c001c4 	movi	r3,7
 1807d94:	1901dd0e 	bge	r3,r4,180850c <___vfiprintf_internal_r+0xd88>
 1807d98:	1002401e 	bne	r2,zero,180869c <___vfiprintf_internal_r+0xf18>
 1807d9c:	d8001b15 	stw	zero,108(sp)
 1807da0:	a2c0010c 	andi	r11,r20,4
 1807da4:	58000226 	beq	r11,zero,1807db0 <___vfiprintf_internal_r+0x62c>
 1807da8:	8ca7c83a 	sub	r19,r17,r18
 1807dac:	04c2f216 	blt	zero,r19,1808978 <___vfiprintf_internal_r+0x11f4>
 1807db0:	8c80010e 	bge	r17,r18,1807db8 <___vfiprintf_internal_r+0x634>
 1807db4:	9023883a 	mov	r17,r18
 1807db8:	da802317 	ldw	r10,140(sp)
 1807dbc:	5455883a 	add	r10,r10,r17
 1807dc0:	da802315 	stw	r10,140(sp)
 1807dc4:	d8001b15 	stw	zero,108(sp)
 1807dc8:	d811883a 	mov	r8,sp
 1807dcc:	003ea206 	br	1807858 <__ram_exceptions_end+0xff7f7414>
 1807dd0:	a5000814 	ori	r20,r20,32
 1807dd4:	80c00007 	ldb	r3,0(r16)
 1807dd8:	003ec906 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1807ddc:	80c00007 	ldb	r3,0(r16)
 1807de0:	1b030926 	beq	r3,r12,1808a08 <___vfiprintf_internal_r+0x1284>
 1807de4:	a5000414 	ori	r20,r20,16
 1807de8:	003ec506 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1807dec:	21003fcc 	andi	r4,r4,255
 1807df0:	20035e1e 	bne	r4,zero,1808b6c <___vfiprintf_internal_r+0x13e8>
 1807df4:	a080080c 	andi	r2,r20,32
 1807df8:	1002a526 	beq	r2,zero,1808890 <___vfiprintf_internal_r+0x110c>
 1807dfc:	da802217 	ldw	r10,136(sp)
 1807e00:	50800017 	ldw	r2,0(r10)
 1807e04:	da802317 	ldw	r10,140(sp)
 1807e08:	5007d7fa 	srai	r3,r10,31
 1807e0c:	da802217 	ldw	r10,136(sp)
 1807e10:	10c00115 	stw	r3,4(r2)
 1807e14:	52800104 	addi	r10,r10,4
 1807e18:	da802215 	stw	r10,136(sp)
 1807e1c:	da802317 	ldw	r10,140(sp)
 1807e20:	12800015 	stw	r10,0(r2)
 1807e24:	003e8c06 	br	1807858 <__ram_exceptions_end+0xff7f7414>
 1807e28:	21003fcc 	andi	r4,r4,255
 1807e2c:	2003511e 	bne	r4,zero,1808b74 <___vfiprintf_internal_r+0x13f0>
 1807e30:	a080080c 	andi	r2,r20,32
 1807e34:	1000a126 	beq	r2,zero,18080bc <___vfiprintf_internal_r+0x938>
 1807e38:	da802217 	ldw	r10,136(sp)
 1807e3c:	d8001d85 	stb	zero,118(sp)
 1807e40:	50800204 	addi	r2,r10,8
 1807e44:	54800017 	ldw	r18,0(r10)
 1807e48:	54c00117 	ldw	r19,4(r10)
 1807e4c:	4802b416 	blt	r9,zero,1808920 <___vfiprintf_internal_r+0x119c>
 1807e50:	013fdfc4 	movi	r4,-129
 1807e54:	94c6b03a 	or	r3,r18,r19
 1807e58:	d8802215 	stw	r2,136(sp)
 1807e5c:	a128703a 	and	r20,r20,r4
 1807e60:	1800a226 	beq	r3,zero,18080ec <___vfiprintf_internal_r+0x968>
 1807e64:	0039883a 	mov	fp,zero
 1807e68:	dd401a04 	addi	r21,sp,104
 1807e6c:	9006d0fa 	srli	r3,r18,3
 1807e70:	9808977a 	slli	r4,r19,29
 1807e74:	9826d0fa 	srli	r19,r19,3
 1807e78:	948001cc 	andi	r18,r18,7
 1807e7c:	90800c04 	addi	r2,r18,48
 1807e80:	ad7fffc4 	addi	r21,r21,-1
 1807e84:	20e4b03a 	or	r18,r4,r3
 1807e88:	a8800005 	stb	r2,0(r21)
 1807e8c:	94c6b03a 	or	r3,r18,r19
 1807e90:	183ff61e 	bne	r3,zero,1807e6c <__ram_exceptions_end+0xff7f7a28>
 1807e94:	a0c0004c 	andi	r3,r20,1
 1807e98:	18005926 	beq	r3,zero,1808000 <___vfiprintf_internal_r+0x87c>
 1807e9c:	10803fcc 	andi	r2,r2,255
 1807ea0:	1080201c 	xori	r2,r2,128
 1807ea4:	10bfe004 	addi	r2,r2,-128
 1807ea8:	00c00c04 	movi	r3,48
 1807eac:	10c05426 	beq	r2,r3,1808000 <___vfiprintf_internal_r+0x87c>
 1807eb0:	da801e17 	ldw	r10,120(sp)
 1807eb4:	a8bfffc4 	addi	r2,r21,-1
 1807eb8:	a8ffffc5 	stb	r3,-1(r21)
 1807ebc:	50a7c83a 	sub	r19,r10,r2
 1807ec0:	102b883a 	mov	r21,r2
 1807ec4:	003f2f06 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1807ec8:	21003fcc 	andi	r4,r4,255
 1807ecc:	2003421e 	bne	r4,zero,1808bd8 <___vfiprintf_internal_r+0x1454>
 1807ed0:	00806134 	movhi	r2,388
 1807ed4:	1084e604 	addi	r2,r2,5016
 1807ed8:	d8802615 	stw	r2,152(sp)
 1807edc:	a080080c 	andi	r2,r20,32
 1807ee0:	1000aa26 	beq	r2,zero,180818c <___vfiprintf_internal_r+0xa08>
 1807ee4:	da802217 	ldw	r10,136(sp)
 1807ee8:	54800017 	ldw	r18,0(r10)
 1807eec:	54c00117 	ldw	r19,4(r10)
 1807ef0:	52800204 	addi	r10,r10,8
 1807ef4:	da802215 	stw	r10,136(sp)
 1807ef8:	a080004c 	andi	r2,r20,1
 1807efc:	1001d226 	beq	r2,zero,1808648 <___vfiprintf_internal_r+0xec4>
 1807f00:	94c4b03a 	or	r2,r18,r19
 1807f04:	1002351e 	bne	r2,zero,18087dc <___vfiprintf_internal_r+0x1058>
 1807f08:	d8001d85 	stb	zero,118(sp)
 1807f0c:	48022216 	blt	r9,zero,1808798 <___vfiprintf_internal_r+0x1014>
 1807f10:	00bfdfc4 	movi	r2,-129
 1807f14:	a0a8703a 	and	r20,r20,r2
 1807f18:	003f1506 	br	1807b70 <__ram_exceptions_end+0xff7f772c>
 1807f1c:	da802217 	ldw	r10,136(sp)
 1807f20:	04800044 	movi	r18,1
 1807f24:	d8001d85 	stb	zero,118(sp)
 1807f28:	50800017 	ldw	r2,0(r10)
 1807f2c:	52800104 	addi	r10,r10,4
 1807f30:	da802215 	stw	r10,136(sp)
 1807f34:	d8801005 	stb	r2,64(sp)
 1807f38:	9027883a 	mov	r19,r18
 1807f3c:	dd401004 	addi	r21,sp,64
 1807f40:	0013883a 	mov	r9,zero
 1807f44:	003f1706 	br	1807ba4 <__ram_exceptions_end+0xff7f7760>
 1807f48:	21003fcc 	andi	r4,r4,255
 1807f4c:	2003201e 	bne	r4,zero,1808bd0 <___vfiprintf_internal_r+0x144c>
 1807f50:	a080080c 	andi	r2,r20,32
 1807f54:	10004b26 	beq	r2,zero,1808084 <___vfiprintf_internal_r+0x900>
 1807f58:	da802217 	ldw	r10,136(sp)
 1807f5c:	50800117 	ldw	r2,4(r10)
 1807f60:	54800017 	ldw	r18,0(r10)
 1807f64:	52800204 	addi	r10,r10,8
 1807f68:	da802215 	stw	r10,136(sp)
 1807f6c:	1027883a 	mov	r19,r2
 1807f70:	10022c16 	blt	r2,zero,1808824 <___vfiprintf_internal_r+0x10a0>
 1807f74:	df001d83 	ldbu	fp,118(sp)
 1807f78:	48007216 	blt	r9,zero,1808144 <___vfiprintf_internal_r+0x9c0>
 1807f7c:	00ffdfc4 	movi	r3,-129
 1807f80:	94c4b03a 	or	r2,r18,r19
 1807f84:	a0e8703a 	and	r20,r20,r3
 1807f88:	1000cc26 	beq	r2,zero,18082bc <___vfiprintf_internal_r+0xb38>
 1807f8c:	98021026 	beq	r19,zero,18087d0 <___vfiprintf_internal_r+0x104c>
 1807f90:	dc402415 	stw	r17,144(sp)
 1807f94:	dc002515 	stw	r16,148(sp)
 1807f98:	9823883a 	mov	r17,r19
 1807f9c:	9021883a 	mov	r16,r18
 1807fa0:	dd401a04 	addi	r21,sp,104
 1807fa4:	4825883a 	mov	r18,r9
 1807fa8:	4027883a 	mov	r19,r8
 1807fac:	8009883a 	mov	r4,r16
 1807fb0:	880b883a 	mov	r5,r17
 1807fb4:	01800284 	movi	r6,10
 1807fb8:	000f883a 	mov	r7,zero
 1807fbc:	180a6e00 	call	180a6e0 <__umoddi3>
 1807fc0:	10800c04 	addi	r2,r2,48
 1807fc4:	ad7fffc4 	addi	r21,r21,-1
 1807fc8:	8009883a 	mov	r4,r16
 1807fcc:	880b883a 	mov	r5,r17
 1807fd0:	a8800005 	stb	r2,0(r21)
 1807fd4:	01800284 	movi	r6,10
 1807fd8:	000f883a 	mov	r7,zero
 1807fdc:	180a1680 	call	180a168 <__udivdi3>
 1807fe0:	1021883a 	mov	r16,r2
 1807fe4:	10c4b03a 	or	r2,r2,r3
 1807fe8:	1823883a 	mov	r17,r3
 1807fec:	103fef1e 	bne	r2,zero,1807fac <__ram_exceptions_end+0xff7f7b68>
 1807ff0:	dc402417 	ldw	r17,144(sp)
 1807ff4:	dc002517 	ldw	r16,148(sp)
 1807ff8:	9013883a 	mov	r9,r18
 1807ffc:	9811883a 	mov	r8,r19
 1808000:	da801e17 	ldw	r10,120(sp)
 1808004:	5567c83a 	sub	r19,r10,r21
 1808008:	003ede06 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 180800c:	38803fcc 	andi	r2,r7,255
 1808010:	1080201c 	xori	r2,r2,128
 1808014:	10bfe004 	addi	r2,r2,-128
 1808018:	1002371e 	bne	r2,zero,18088f8 <___vfiprintf_internal_r+0x1174>
 180801c:	01000044 	movi	r4,1
 1808020:	01c00804 	movi	r7,32
 1808024:	80c00007 	ldb	r3,0(r16)
 1808028:	003e3506 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 180802c:	a5000054 	ori	r20,r20,1
 1808030:	80c00007 	ldb	r3,0(r16)
 1808034:	003e3206 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808038:	a5002014 	ori	r20,r20,128
 180803c:	80c00007 	ldb	r3,0(r16)
 1808040:	003e2f06 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808044:	8015883a 	mov	r10,r16
 1808048:	0023883a 	mov	r17,zero
 180804c:	18bff404 	addi	r2,r3,-48
 1808050:	50c00007 	ldb	r3,0(r10)
 1808054:	8c4002a4 	muli	r17,r17,10
 1808058:	84000044 	addi	r16,r16,1
 180805c:	8015883a 	mov	r10,r16
 1808060:	1463883a 	add	r17,r2,r17
 1808064:	18bff404 	addi	r2,r3,-48
 1808068:	30bff92e 	bgeu	r6,r2,1808050 <__ram_exceptions_end+0xff7f7c0c>
 180806c:	003e2506 	br	1807904 <__ram_exceptions_end+0xff7f74c0>
 1808070:	21003fcc 	andi	r4,r4,255
 1808074:	2002d41e 	bne	r4,zero,1808bc8 <___vfiprintf_internal_r+0x1444>
 1808078:	a5000414 	ori	r20,r20,16
 180807c:	a080080c 	andi	r2,r20,32
 1808080:	103fb51e 	bne	r2,zero,1807f58 <__ram_exceptions_end+0xff7f7b14>
 1808084:	a080040c 	andi	r2,r20,16
 1808088:	1001f826 	beq	r2,zero,180886c <___vfiprintf_internal_r+0x10e8>
 180808c:	da802217 	ldw	r10,136(sp)
 1808090:	54800017 	ldw	r18,0(r10)
 1808094:	52800104 	addi	r10,r10,4
 1808098:	da802215 	stw	r10,136(sp)
 180809c:	9027d7fa 	srai	r19,r18,31
 18080a0:	9805883a 	mov	r2,r19
 18080a4:	003fb206 	br	1807f70 <__ram_exceptions_end+0xff7f7b2c>
 18080a8:	21003fcc 	andi	r4,r4,255
 18080ac:	2002c41e 	bne	r4,zero,1808bc0 <___vfiprintf_internal_r+0x143c>
 18080b0:	a5000414 	ori	r20,r20,16
 18080b4:	a080080c 	andi	r2,r20,32
 18080b8:	103f5f1e 	bne	r2,zero,1807e38 <__ram_exceptions_end+0xff7f79f4>
 18080bc:	a080040c 	andi	r2,r20,16
 18080c0:	10020f26 	beq	r2,zero,1808900 <___vfiprintf_internal_r+0x117c>
 18080c4:	da802217 	ldw	r10,136(sp)
 18080c8:	d8001d85 	stb	zero,118(sp)
 18080cc:	0027883a 	mov	r19,zero
 18080d0:	50800104 	addi	r2,r10,4
 18080d4:	54800017 	ldw	r18,0(r10)
 18080d8:	48021116 	blt	r9,zero,1808920 <___vfiprintf_internal_r+0x119c>
 18080dc:	00ffdfc4 	movi	r3,-129
 18080e0:	d8802215 	stw	r2,136(sp)
 18080e4:	a0e8703a 	and	r20,r20,r3
 18080e8:	903f5e1e 	bne	r18,zero,1807e64 <__ram_exceptions_end+0xff7f7a20>
 18080ec:	0039883a 	mov	fp,zero
 18080f0:	4802a626 	beq	r9,zero,1808b8c <___vfiprintf_internal_r+0x1408>
 18080f4:	0025883a 	mov	r18,zero
 18080f8:	0027883a 	mov	r19,zero
 18080fc:	003f5a06 	br	1807e68 <__ram_exceptions_end+0xff7f7a24>
 1808100:	21003fcc 	andi	r4,r4,255
 1808104:	20029f1e 	bne	r4,zero,1808b84 <___vfiprintf_internal_r+0x1400>
 1808108:	a5000414 	ori	r20,r20,16
 180810c:	a080080c 	andi	r2,r20,32
 1808110:	10005e1e 	bne	r2,zero,180828c <___vfiprintf_internal_r+0xb08>
 1808114:	a080040c 	andi	r2,r20,16
 1808118:	1001a21e 	bne	r2,zero,18087a4 <___vfiprintf_internal_r+0x1020>
 180811c:	a080100c 	andi	r2,r20,64
 1808120:	d8001d85 	stb	zero,118(sp)
 1808124:	da802217 	ldw	r10,136(sp)
 1808128:	1002231e 	bne	r2,zero,18089b8 <___vfiprintf_internal_r+0x1234>
 180812c:	50800104 	addi	r2,r10,4
 1808130:	54800017 	ldw	r18,0(r10)
 1808134:	0027883a 	mov	r19,zero
 1808138:	4801a00e 	bge	r9,zero,18087bc <___vfiprintf_internal_r+0x1038>
 180813c:	d8802215 	stw	r2,136(sp)
 1808140:	0039883a 	mov	fp,zero
 1808144:	94c4b03a 	or	r2,r18,r19
 1808148:	103f901e 	bne	r2,zero,1807f8c <__ram_exceptions_end+0xff7f7b48>
 180814c:	00800044 	movi	r2,1
 1808150:	10803fcc 	andi	r2,r2,255
 1808154:	00c00044 	movi	r3,1
 1808158:	10c05926 	beq	r2,r3,18082c0 <___vfiprintf_internal_r+0xb3c>
 180815c:	00c00084 	movi	r3,2
 1808160:	10ffe41e 	bne	r2,r3,18080f4 <__ram_exceptions_end+0xff7f7cb0>
 1808164:	0025883a 	mov	r18,zero
 1808168:	0027883a 	mov	r19,zero
 180816c:	00013d06 	br	1808664 <___vfiprintf_internal_r+0xee0>
 1808170:	21003fcc 	andi	r4,r4,255
 1808174:	2002811e 	bne	r4,zero,1808b7c <___vfiprintf_internal_r+0x13f8>
 1808178:	00806134 	movhi	r2,388
 180817c:	1084e104 	addi	r2,r2,4996
 1808180:	d8802615 	stw	r2,152(sp)
 1808184:	a080080c 	andi	r2,r20,32
 1808188:	103f561e 	bne	r2,zero,1807ee4 <__ram_exceptions_end+0xff7f7aa0>
 180818c:	a080040c 	andi	r2,r20,16
 1808190:	1001d126 	beq	r2,zero,18088d8 <___vfiprintf_internal_r+0x1154>
 1808194:	da802217 	ldw	r10,136(sp)
 1808198:	0027883a 	mov	r19,zero
 180819c:	54800017 	ldw	r18,0(r10)
 18081a0:	52800104 	addi	r10,r10,4
 18081a4:	da802215 	stw	r10,136(sp)
 18081a8:	003f5306 	br	1807ef8 <__ram_exceptions_end+0xff7f7ab4>
 18081ac:	da802217 	ldw	r10,136(sp)
 18081b0:	d8001d85 	stb	zero,118(sp)
 18081b4:	55400017 	ldw	r21,0(r10)
 18081b8:	50c00104 	addi	r3,r10,4
 18081bc:	a8024226 	beq	r21,zero,1808ac8 <___vfiprintf_internal_r+0x1344>
 18081c0:	48021816 	blt	r9,zero,1808a24 <___vfiprintf_internal_r+0x12a0>
 18081c4:	480d883a 	mov	r6,r9
 18081c8:	000b883a 	mov	r5,zero
 18081cc:	a809883a 	mov	r4,r21
 18081d0:	d8c02a15 	stw	r3,168(sp)
 18081d4:	da002b15 	stw	r8,172(sp)
 18081d8:	da402c15 	stw	r9,176(sp)
 18081dc:	1805fa80 	call	1805fa8 <memchr>
 18081e0:	d8c02a17 	ldw	r3,168(sp)
 18081e4:	da002b17 	ldw	r8,172(sp)
 18081e8:	da402c17 	ldw	r9,176(sp)
 18081ec:	10024826 	beq	r2,zero,1808b10 <___vfiprintf_internal_r+0x138c>
 18081f0:	1567c83a 	sub	r19,r2,r21
 18081f4:	df001d83 	ldbu	fp,118(sp)
 18081f8:	d8c02215 	stw	r3,136(sp)
 18081fc:	0013883a 	mov	r9,zero
 1808200:	003e6006 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1808204:	21003fcc 	andi	r4,r4,255
 1808208:	203fc026 	beq	r4,zero,180810c <__ram_exceptions_end+0xff7f7cc8>
 180820c:	d9c01d85 	stb	r7,118(sp)
 1808210:	003fbe06 	br	180810c <__ram_exceptions_end+0xff7f7cc8>
 1808214:	da802217 	ldw	r10,136(sp)
 1808218:	54400017 	ldw	r17,0(r10)
 180821c:	50800104 	addi	r2,r10,4
 1808220:	883e3b16 	blt	r17,zero,1807b10 <__ram_exceptions_end+0xff7f76cc>
 1808224:	d8802215 	stw	r2,136(sp)
 1808228:	80c00007 	ldb	r3,0(r16)
 180822c:	003db406 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808230:	01000044 	movi	r4,1
 1808234:	01c00ac4 	movi	r7,43
 1808238:	80c00007 	ldb	r3,0(r16)
 180823c:	003db006 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808240:	80c00007 	ldb	r3,0(r16)
 1808244:	82800044 	addi	r10,r16,1
 1808248:	1b423c26 	beq	r3,r13,1808b3c <___vfiprintf_internal_r+0x13b8>
 180824c:	18bff404 	addi	r2,r3,-48
 1808250:	0013883a 	mov	r9,zero
 1808254:	30822b36 	bltu	r6,r2,1808b04 <___vfiprintf_internal_r+0x1380>
 1808258:	50c00007 	ldb	r3,0(r10)
 180825c:	4a4002a4 	muli	r9,r9,10
 1808260:	54000044 	addi	r16,r10,1
 1808264:	8015883a 	mov	r10,r16
 1808268:	4893883a 	add	r9,r9,r2
 180826c:	18bff404 	addi	r2,r3,-48
 1808270:	30bff92e 	bgeu	r6,r2,1808258 <__ram_exceptions_end+0xff7f7e14>
 1808274:	483da30e 	bge	r9,zero,1807904 <__ram_exceptions_end+0xff7f74c0>
 1808278:	027fffc4 	movi	r9,-1
 180827c:	003da106 	br	1807904 <__ram_exceptions_end+0xff7f74c0>
 1808280:	a5001014 	ori	r20,r20,64
 1808284:	80c00007 	ldb	r3,0(r16)
 1808288:	003d9d06 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 180828c:	da802217 	ldw	r10,136(sp)
 1808290:	d8001d85 	stb	zero,118(sp)
 1808294:	50c00204 	addi	r3,r10,8
 1808298:	54800017 	ldw	r18,0(r10)
 180829c:	54c00117 	ldw	r19,4(r10)
 18082a0:	4801ca16 	blt	r9,zero,18089cc <___vfiprintf_internal_r+0x1248>
 18082a4:	013fdfc4 	movi	r4,-129
 18082a8:	94c4b03a 	or	r2,r18,r19
 18082ac:	d8c02215 	stw	r3,136(sp)
 18082b0:	a128703a 	and	r20,r20,r4
 18082b4:	0039883a 	mov	fp,zero
 18082b8:	103f341e 	bne	r2,zero,1807f8c <__ram_exceptions_end+0xff7f7b48>
 18082bc:	483e2e26 	beq	r9,zero,1807b78 <__ram_exceptions_end+0xff7f7734>
 18082c0:	0025883a 	mov	r18,zero
 18082c4:	94800c04 	addi	r18,r18,48
 18082c8:	dc8019c5 	stb	r18,103(sp)
 18082cc:	dcc02717 	ldw	r19,156(sp)
 18082d0:	dd4019c4 	addi	r21,sp,103
 18082d4:	003e2b06 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 18082d8:	21003fcc 	andi	r4,r4,255
 18082dc:	2002361e 	bne	r4,zero,1808bb8 <___vfiprintf_internal_r+0x1434>
 18082e0:	1801c126 	beq	r3,zero,18089e8 <___vfiprintf_internal_r+0x1264>
 18082e4:	04800044 	movi	r18,1
 18082e8:	d8c01005 	stb	r3,64(sp)
 18082ec:	d8001d85 	stb	zero,118(sp)
 18082f0:	9027883a 	mov	r19,r18
 18082f4:	dd401004 	addi	r21,sp,64
 18082f8:	003f1106 	br	1807f40 <__ram_exceptions_end+0xff7f7afc>
 18082fc:	d9402117 	ldw	r5,132(sp)
 1808300:	d9002017 	ldw	r4,128(sp)
 1808304:	d9801a04 	addi	r6,sp,104
 1808308:	d9c02b15 	stw	r7,172(sp)
 180830c:	dbc02a15 	stw	r15,168(sp)
 1808310:	18076700 	call	1807670 <__sprint_r.part.0>
 1808314:	d9c02b17 	ldw	r7,172(sp)
 1808318:	dbc02a17 	ldw	r15,168(sp)
 180831c:	10006d1e 	bne	r2,zero,18084d4 <___vfiprintf_internal_r+0xd50>
 1808320:	d9801b17 	ldw	r6,108(sp)
 1808324:	d8801c17 	ldw	r2,112(sp)
 1808328:	d811883a 	mov	r8,sp
 180832c:	31400044 	addi	r5,r6,1
 1808330:	003e3306 	br	1807c00 <__ram_exceptions_end+0xff7f77bc>
 1808334:	d9401b17 	ldw	r5,108(sp)
 1808338:	d8801c17 	ldw	r2,112(sp)
 180833c:	29000044 	addi	r4,r5,1
 1808340:	d8c01d87 	ldb	r3,118(sp)
 1808344:	183e4d26 	beq	r3,zero,1807c7c <__ram_exceptions_end+0xff7f7838>
 1808348:	00c00044 	movi	r3,1
 180834c:	d9401d84 	addi	r5,sp,118
 1808350:	10c5883a 	add	r2,r2,r3
 1808354:	41400015 	stw	r5,0(r8)
 1808358:	40c00115 	stw	r3,4(r8)
 180835c:	d8801c15 	stw	r2,112(sp)
 1808360:	d9001b15 	stw	r4,108(sp)
 1808364:	014001c4 	movi	r5,7
 1808368:	2900a90e 	bge	r5,r4,1808610 <___vfiprintf_internal_r+0xe8c>
 180836c:	1000da1e 	bne	r2,zero,18086d8 <___vfiprintf_internal_r+0xf54>
 1808370:	7000ab1e 	bne	r14,zero,1808620 <___vfiprintf_internal_r+0xe9c>
 1808374:	000b883a 	mov	r5,zero
 1808378:	1809883a 	mov	r4,r3
 180837c:	d811883a 	mov	r8,sp
 1808380:	00c02004 	movi	r3,128
 1808384:	e0fe4d26 	beq	fp,r3,1807cbc <__ram_exceptions_end+0xff7f7878>
 1808388:	4cf9c83a 	sub	fp,r9,r19
 180838c:	073e7b0e 	bge	zero,fp,1807d7c <__ram_exceptions_end+0xff7f7938>
 1808390:	01c00404 	movi	r7,16
 1808394:	3f01900e 	bge	r7,fp,18089d8 <___vfiprintf_internal_r+0x1254>
 1808398:	00c06134 	movhi	r3,388
 180839c:	18c54704 	addi	r3,r3,5404
 18083a0:	d8c02415 	stw	r3,144(sp)
 18083a4:	034001c4 	movi	r13,7
 18083a8:	00000506 	br	18083c0 <___vfiprintf_internal_r+0xc3c>
 18083ac:	29000084 	addi	r4,r5,2
 18083b0:	42000204 	addi	r8,r8,8
 18083b4:	180b883a 	mov	r5,r3
 18083b8:	e73ffc04 	addi	fp,fp,-16
 18083bc:	3f000d0e 	bge	r7,fp,18083f4 <___vfiprintf_internal_r+0xc70>
 18083c0:	10800404 	addi	r2,r2,16
 18083c4:	28c00044 	addi	r3,r5,1
 18083c8:	45c00015 	stw	r23,0(r8)
 18083cc:	41c00115 	stw	r7,4(r8)
 18083d0:	d8801c15 	stw	r2,112(sp)
 18083d4:	d8c01b15 	stw	r3,108(sp)
 18083d8:	68fff40e 	bge	r13,r3,18083ac <__ram_exceptions_end+0xff7f7f68>
 18083dc:	1000101e 	bne	r2,zero,1808420 <___vfiprintf_internal_r+0xc9c>
 18083e0:	e73ffc04 	addi	fp,fp,-16
 18083e4:	01000044 	movi	r4,1
 18083e8:	000b883a 	mov	r5,zero
 18083ec:	d811883a 	mov	r8,sp
 18083f0:	3f3ff316 	blt	r7,fp,18083c0 <__ram_exceptions_end+0xff7f7f7c>
 18083f4:	da802417 	ldw	r10,144(sp)
 18083f8:	1705883a 	add	r2,r2,fp
 18083fc:	47000115 	stw	fp,4(r8)
 1808400:	42800015 	stw	r10,0(r8)
 1808404:	d8801c15 	stw	r2,112(sp)
 1808408:	d9001b15 	stw	r4,108(sp)
 180840c:	00c001c4 	movi	r3,7
 1808410:	19003616 	blt	r3,r4,18084ec <___vfiprintf_internal_r+0xd68>
 1808414:	42000204 	addi	r8,r8,8
 1808418:	21000044 	addi	r4,r4,1
 180841c:	003e5706 	br	1807d7c <__ram_exceptions_end+0xff7f7938>
 1808420:	d9402117 	ldw	r5,132(sp)
 1808424:	d9002017 	ldw	r4,128(sp)
 1808428:	d9801a04 	addi	r6,sp,104
 180842c:	d9c02b15 	stw	r7,172(sp)
 1808430:	db402a15 	stw	r13,168(sp)
 1808434:	18076700 	call	1807670 <__sprint_r.part.0>
 1808438:	d9c02b17 	ldw	r7,172(sp)
 180843c:	db402a17 	ldw	r13,168(sp)
 1808440:	1000241e 	bne	r2,zero,18084d4 <___vfiprintf_internal_r+0xd50>
 1808444:	d9401b17 	ldw	r5,108(sp)
 1808448:	d8801c17 	ldw	r2,112(sp)
 180844c:	d811883a 	mov	r8,sp
 1808450:	29000044 	addi	r4,r5,1
 1808454:	003fd806 	br	18083b8 <__ram_exceptions_end+0xff7f7f74>
 1808458:	d9401b17 	ldw	r5,108(sp)
 180845c:	00c06134 	movhi	r3,388
 1808460:	18c54b04 	addi	r3,r3,5420
 1808464:	d8c02415 	stw	r3,144(sp)
 1808468:	29400044 	addi	r5,r5,1
 180846c:	d8c02417 	ldw	r3,144(sp)
 1808470:	14c5883a 	add	r2,r2,r19
 1808474:	44c00115 	stw	r19,4(r8)
 1808478:	40c00015 	stw	r3,0(r8)
 180847c:	d8801c15 	stw	r2,112(sp)
 1808480:	d9401b15 	stw	r5,108(sp)
 1808484:	00c001c4 	movi	r3,7
 1808488:	1940070e 	bge	r3,r5,18084a8 <___vfiprintf_internal_r+0xd24>
 180848c:	103e4826 	beq	r2,zero,1807db0 <__ram_exceptions_end+0xff7f796c>
 1808490:	d9402117 	ldw	r5,132(sp)
 1808494:	d9002017 	ldw	r4,128(sp)
 1808498:	d9801a04 	addi	r6,sp,104
 180849c:	18076700 	call	1807670 <__sprint_r.part.0>
 18084a0:	10000c1e 	bne	r2,zero,18084d4 <___vfiprintf_internal_r+0xd50>
 18084a4:	d8801c17 	ldw	r2,112(sp)
 18084a8:	8c80010e 	bge	r17,r18,18084b0 <___vfiprintf_internal_r+0xd2c>
 18084ac:	9023883a 	mov	r17,r18
 18084b0:	da802317 	ldw	r10,140(sp)
 18084b4:	5455883a 	add	r10,r10,r17
 18084b8:	da802315 	stw	r10,140(sp)
 18084bc:	103e4126 	beq	r2,zero,1807dc4 <__ram_exceptions_end+0xff7f7980>
 18084c0:	d9402117 	ldw	r5,132(sp)
 18084c4:	d9002017 	ldw	r4,128(sp)
 18084c8:	d9801a04 	addi	r6,sp,104
 18084cc:	18076700 	call	1807670 <__sprint_r.part.0>
 18084d0:	103e3c26 	beq	r2,zero,1807dc4 <__ram_exceptions_end+0xff7f7980>
 18084d4:	dd002117 	ldw	r20,132(sp)
 18084d8:	a080030b 	ldhu	r2,12(r20)
 18084dc:	1080100c 	andi	r2,r2,64
 18084e0:	1001231e 	bne	r2,zero,1808970 <___vfiprintf_internal_r+0x11ec>
 18084e4:	d8802317 	ldw	r2,140(sp)
 18084e8:	003d7b06 	br	1807ad8 <__ram_exceptions_end+0xff7f7694>
 18084ec:	1000991e 	bne	r2,zero,1808754 <___vfiprintf_internal_r+0xfd0>
 18084f0:	00c00044 	movi	r3,1
 18084f4:	9805883a 	mov	r2,r19
 18084f8:	dd400015 	stw	r21,0(sp)
 18084fc:	dcc00115 	stw	r19,4(sp)
 1808500:	dcc01c15 	stw	r19,112(sp)
 1808504:	d8c01b15 	stw	r3,108(sp)
 1808508:	d811883a 	mov	r8,sp
 180850c:	42000204 	addi	r8,r8,8
 1808510:	a2c0010c 	andi	r11,r20,4
 1808514:	583fe426 	beq	r11,zero,18084a8 <__ram_exceptions_end+0xff7f8064>
 1808518:	8ca7c83a 	sub	r19,r17,r18
 180851c:	04ffe20e 	bge	zero,r19,18084a8 <__ram_exceptions_end+0xff7f8064>
 1808520:	01c00404 	movi	r7,16
 1808524:	3cffcc0e 	bge	r7,r19,1808458 <__ram_exceptions_end+0xff7f8014>
 1808528:	02806134 	movhi	r10,388
 180852c:	52854b04 	addi	r10,r10,5420
 1808530:	d9001b17 	ldw	r4,108(sp)
 1808534:	da802415 	stw	r10,144(sp)
 1808538:	382b883a 	mov	r21,r7
 180853c:	050001c4 	movi	r20,7
 1808540:	df002017 	ldw	fp,128(sp)
 1808544:	00000506 	br	180855c <___vfiprintf_internal_r+0xdd8>
 1808548:	21400084 	addi	r5,r4,2
 180854c:	42000204 	addi	r8,r8,8
 1808550:	1809883a 	mov	r4,r3
 1808554:	9cfffc04 	addi	r19,r19,-16
 1808558:	acffc40e 	bge	r21,r19,180846c <__ram_exceptions_end+0xff7f8028>
 180855c:	10800404 	addi	r2,r2,16
 1808560:	20c00044 	addi	r3,r4,1
 1808564:	45800015 	stw	r22,0(r8)
 1808568:	45400115 	stw	r21,4(r8)
 180856c:	d8801c15 	stw	r2,112(sp)
 1808570:	d8c01b15 	stw	r3,108(sp)
 1808574:	a0fff40e 	bge	r20,r3,1808548 <__ram_exceptions_end+0xff7f8104>
 1808578:	1000041e 	bne	r2,zero,180858c <___vfiprintf_internal_r+0xe08>
 180857c:	01400044 	movi	r5,1
 1808580:	0009883a 	mov	r4,zero
 1808584:	d811883a 	mov	r8,sp
 1808588:	003ff206 	br	1808554 <__ram_exceptions_end+0xff7f8110>
 180858c:	d9402117 	ldw	r5,132(sp)
 1808590:	d9801a04 	addi	r6,sp,104
 1808594:	e009883a 	mov	r4,fp
 1808598:	18076700 	call	1807670 <__sprint_r.part.0>
 180859c:	103fcd1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 18085a0:	d9001b17 	ldw	r4,108(sp)
 18085a4:	d8801c17 	ldw	r2,112(sp)
 18085a8:	d811883a 	mov	r8,sp
 18085ac:	21400044 	addi	r5,r4,1
 18085b0:	003fe806 	br	1808554 <__ram_exceptions_end+0xff7f8110>
 18085b4:	d9402117 	ldw	r5,132(sp)
 18085b8:	d9002017 	ldw	r4,128(sp)
 18085bc:	d9801a04 	addi	r6,sp,104
 18085c0:	d9c02b15 	stw	r7,172(sp)
 18085c4:	db402a15 	stw	r13,168(sp)
 18085c8:	18076700 	call	1807670 <__sprint_r.part.0>
 18085cc:	d9c02b17 	ldw	r7,172(sp)
 18085d0:	db402a17 	ldw	r13,168(sp)
 18085d4:	103fbf1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 18085d8:	d9401b17 	ldw	r5,108(sp)
 18085dc:	d8801c17 	ldw	r2,112(sp)
 18085e0:	d811883a 	mov	r8,sp
 18085e4:	29800044 	addi	r6,r5,1
 18085e8:	003dc406 	br	1807cfc <__ram_exceptions_end+0xff7f78b8>
 18085ec:	1000d21e 	bne	r2,zero,1808938 <___vfiprintf_internal_r+0x11b4>
 18085f0:	d8c01d87 	ldb	r3,118(sp)
 18085f4:	18009526 	beq	r3,zero,180884c <___vfiprintf_internal_r+0x10c8>
 18085f8:	00800044 	movi	r2,1
 18085fc:	d8c01d84 	addi	r3,sp,118
 1808600:	1009883a 	mov	r4,r2
 1808604:	d8c00015 	stw	r3,0(sp)
 1808608:	d8800115 	stw	r2,4(sp)
 180860c:	d811883a 	mov	r8,sp
 1808610:	200b883a 	mov	r5,r4
 1808614:	42000204 	addi	r8,r8,8
 1808618:	21000044 	addi	r4,r4,1
 180861c:	003d9706 	br	1807c7c <__ram_exceptions_end+0xff7f7838>
 1808620:	d9001d04 	addi	r4,sp,116
 1808624:	00800084 	movi	r2,2
 1808628:	d9000015 	stw	r4,0(sp)
 180862c:	d8800115 	stw	r2,4(sp)
 1808630:	1809883a 	mov	r4,r3
 1808634:	d811883a 	mov	r8,sp
 1808638:	200b883a 	mov	r5,r4
 180863c:	42000204 	addi	r8,r8,8
 1808640:	21000044 	addi	r4,r4,1
 1808644:	003f4e06 	br	1808380 <__ram_exceptions_end+0xff7f7f3c>
 1808648:	d8001d85 	stb	zero,118(sp)
 180864c:	48005016 	blt	r9,zero,1808790 <___vfiprintf_internal_r+0x100c>
 1808650:	00ffdfc4 	movi	r3,-129
 1808654:	94c4b03a 	or	r2,r18,r19
 1808658:	a0e8703a 	and	r20,r20,r3
 180865c:	103d4426 	beq	r2,zero,1807b70 <__ram_exceptions_end+0xff7f772c>
 1808660:	0039883a 	mov	fp,zero
 1808664:	d9002617 	ldw	r4,152(sp)
 1808668:	dd401a04 	addi	r21,sp,104
 180866c:	908003cc 	andi	r2,r18,15
 1808670:	9806973a 	slli	r3,r19,28
 1808674:	2085883a 	add	r2,r4,r2
 1808678:	9024d13a 	srli	r18,r18,4
 180867c:	10800003 	ldbu	r2,0(r2)
 1808680:	9826d13a 	srli	r19,r19,4
 1808684:	ad7fffc4 	addi	r21,r21,-1
 1808688:	1ca4b03a 	or	r18,r3,r18
 180868c:	a8800005 	stb	r2,0(r21)
 1808690:	94c4b03a 	or	r2,r18,r19
 1808694:	103ff51e 	bne	r2,zero,180866c <__ram_exceptions_end+0xff7f8228>
 1808698:	003e5906 	br	1808000 <__ram_exceptions_end+0xff7f7bbc>
 180869c:	d9402117 	ldw	r5,132(sp)
 18086a0:	d9002017 	ldw	r4,128(sp)
 18086a4:	d9801a04 	addi	r6,sp,104
 18086a8:	18076700 	call	1807670 <__sprint_r.part.0>
 18086ac:	103f891e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 18086b0:	d8801c17 	ldw	r2,112(sp)
 18086b4:	d811883a 	mov	r8,sp
 18086b8:	003f9506 	br	1808510 <__ram_exceptions_end+0xff7f80cc>
 18086bc:	d9402117 	ldw	r5,132(sp)
 18086c0:	d9002017 	ldw	r4,128(sp)
 18086c4:	d9801a04 	addi	r6,sp,104
 18086c8:	18076700 	call	1807670 <__sprint_r.part.0>
 18086cc:	103f811e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 18086d0:	d811883a 	mov	r8,sp
 18086d4:	003ced06 	br	1807a8c <__ram_exceptions_end+0xff7f7648>
 18086d8:	d9402117 	ldw	r5,132(sp)
 18086dc:	d9002017 	ldw	r4,128(sp)
 18086e0:	d9801a04 	addi	r6,sp,104
 18086e4:	da402c15 	stw	r9,176(sp)
 18086e8:	db802a15 	stw	r14,168(sp)
 18086ec:	18076700 	call	1807670 <__sprint_r.part.0>
 18086f0:	da402c17 	ldw	r9,176(sp)
 18086f4:	db802a17 	ldw	r14,168(sp)
 18086f8:	103f761e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 18086fc:	d9401b17 	ldw	r5,108(sp)
 1808700:	d8801c17 	ldw	r2,112(sp)
 1808704:	d811883a 	mov	r8,sp
 1808708:	29000044 	addi	r4,r5,1
 180870c:	003d5b06 	br	1807c7c <__ram_exceptions_end+0xff7f7838>
 1808710:	d9402117 	ldw	r5,132(sp)
 1808714:	d9002017 	ldw	r4,128(sp)
 1808718:	d9801a04 	addi	r6,sp,104
 180871c:	da402c15 	stw	r9,176(sp)
 1808720:	18076700 	call	1807670 <__sprint_r.part.0>
 1808724:	da402c17 	ldw	r9,176(sp)
 1808728:	103f6a1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 180872c:	d9401b17 	ldw	r5,108(sp)
 1808730:	d8801c17 	ldw	r2,112(sp)
 1808734:	d811883a 	mov	r8,sp
 1808738:	29000044 	addi	r4,r5,1
 180873c:	003f1006 	br	1808380 <__ram_exceptions_end+0xff7f7f3c>
 1808740:	1000c31e 	bne	r2,zero,1808a50 <___vfiprintf_internal_r+0x12cc>
 1808744:	01000044 	movi	r4,1
 1808748:	000b883a 	mov	r5,zero
 180874c:	d811883a 	mov	r8,sp
 1808750:	003f0d06 	br	1808388 <__ram_exceptions_end+0xff7f7f44>
 1808754:	d9402117 	ldw	r5,132(sp)
 1808758:	d9002017 	ldw	r4,128(sp)
 180875c:	d9801a04 	addi	r6,sp,104
 1808760:	18076700 	call	1807670 <__sprint_r.part.0>
 1808764:	103f5b1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 1808768:	d9001b17 	ldw	r4,108(sp)
 180876c:	d8801c17 	ldw	r2,112(sp)
 1808770:	d811883a 	mov	r8,sp
 1808774:	21000044 	addi	r4,r4,1
 1808778:	003d8006 	br	1807d7c <__ram_exceptions_end+0xff7f7938>
 180877c:	01006134 	movhi	r4,388
 1808780:	2104e604 	addi	r4,r4,5016
 1808784:	d9002615 	stw	r4,152(sp)
 1808788:	d8c02215 	stw	r3,136(sp)
 180878c:	1029883a 	mov	r20,r2
 1808790:	94c4b03a 	or	r2,r18,r19
 1808794:	103fb21e 	bne	r2,zero,1808660 <__ram_exceptions_end+0xff7f821c>
 1808798:	0039883a 	mov	fp,zero
 180879c:	00800084 	movi	r2,2
 18087a0:	003e6b06 	br	1808150 <__ram_exceptions_end+0xff7f7d0c>
 18087a4:	da802217 	ldw	r10,136(sp)
 18087a8:	d8001d85 	stb	zero,118(sp)
 18087ac:	0027883a 	mov	r19,zero
 18087b0:	50800104 	addi	r2,r10,4
 18087b4:	54800017 	ldw	r18,0(r10)
 18087b8:	483e6016 	blt	r9,zero,180813c <__ram_exceptions_end+0xff7f7cf8>
 18087bc:	00ffdfc4 	movi	r3,-129
 18087c0:	d8802215 	stw	r2,136(sp)
 18087c4:	a0e8703a 	and	r20,r20,r3
 18087c8:	0039883a 	mov	fp,zero
 18087cc:	903ebb26 	beq	r18,zero,18082bc <__ram_exceptions_end+0xff7f7e78>
 18087d0:	00800244 	movi	r2,9
 18087d4:	14bdee36 	bltu	r2,r18,1807f90 <__ram_exceptions_end+0xff7f7b4c>
 18087d8:	003eba06 	br	18082c4 <__ram_exceptions_end+0xff7f7e80>
 18087dc:	00800c04 	movi	r2,48
 18087e0:	d8c01d45 	stb	r3,117(sp)
 18087e4:	d8801d05 	stb	r2,116(sp)
 18087e8:	d8001d85 	stb	zero,118(sp)
 18087ec:	a0c00094 	ori	r3,r20,2
 18087f0:	4800a916 	blt	r9,zero,1808a98 <___vfiprintf_internal_r+0x1314>
 18087f4:	00bfdfc4 	movi	r2,-129
 18087f8:	a096703a 	and	r11,r20,r2
 18087fc:	5d000094 	ori	r20,r11,2
 1808800:	0039883a 	mov	fp,zero
 1808804:	003f9706 	br	1808664 <__ram_exceptions_end+0xff7f8220>
 1808808:	8025883a 	mov	r18,r16
 180880c:	003c2e06 	br	18078c8 <__ram_exceptions_end+0xff7f7484>
 1808810:	00806134 	movhi	r2,388
 1808814:	1084e604 	addi	r2,r2,5016
 1808818:	0039883a 	mov	fp,zero
 180881c:	d8802615 	stw	r2,152(sp)
 1808820:	003f9006 	br	1808664 <__ram_exceptions_end+0xff7f8220>
 1808824:	04a5c83a 	sub	r18,zero,r18
 1808828:	07000b44 	movi	fp,45
 180882c:	9004c03a 	cmpne	r2,r18,zero
 1808830:	04e7c83a 	sub	r19,zero,r19
 1808834:	df001d85 	stb	fp,118(sp)
 1808838:	98a7c83a 	sub	r19,r19,r2
 180883c:	48009f16 	blt	r9,zero,1808abc <___vfiprintf_internal_r+0x1338>
 1808840:	00bfdfc4 	movi	r2,-129
 1808844:	a0a8703a 	and	r20,r20,r2
 1808848:	003dd006 	br	1807f8c <__ram_exceptions_end+0xff7f7b48>
 180884c:	70004c26 	beq	r14,zero,1808980 <___vfiprintf_internal_r+0x11fc>
 1808850:	00800084 	movi	r2,2
 1808854:	d8c01d04 	addi	r3,sp,116
 1808858:	d8c00015 	stw	r3,0(sp)
 180885c:	d8800115 	stw	r2,4(sp)
 1808860:	01000044 	movi	r4,1
 1808864:	d811883a 	mov	r8,sp
 1808868:	003f7306 	br	1808638 <__ram_exceptions_end+0xff7f81f4>
 180886c:	a080100c 	andi	r2,r20,64
 1808870:	da802217 	ldw	r10,136(sp)
 1808874:	103e0626 	beq	r2,zero,1808090 <__ram_exceptions_end+0xff7f7c4c>
 1808878:	5480000f 	ldh	r18,0(r10)
 180887c:	52800104 	addi	r10,r10,4
 1808880:	da802215 	stw	r10,136(sp)
 1808884:	9027d7fa 	srai	r19,r18,31
 1808888:	9805883a 	mov	r2,r19
 180888c:	003db806 	br	1807f70 <__ram_exceptions_end+0xff7f7b2c>
 1808890:	a080040c 	andi	r2,r20,16
 1808894:	1000091e 	bne	r2,zero,18088bc <___vfiprintf_internal_r+0x1138>
 1808898:	a2c0100c 	andi	r11,r20,64
 180889c:	58000726 	beq	r11,zero,18088bc <___vfiprintf_internal_r+0x1138>
 18088a0:	da802217 	ldw	r10,136(sp)
 18088a4:	50800017 	ldw	r2,0(r10)
 18088a8:	52800104 	addi	r10,r10,4
 18088ac:	da802215 	stw	r10,136(sp)
 18088b0:	da802317 	ldw	r10,140(sp)
 18088b4:	1280000d 	sth	r10,0(r2)
 18088b8:	003be706 	br	1807858 <__ram_exceptions_end+0xff7f7414>
 18088bc:	da802217 	ldw	r10,136(sp)
 18088c0:	50800017 	ldw	r2,0(r10)
 18088c4:	52800104 	addi	r10,r10,4
 18088c8:	da802215 	stw	r10,136(sp)
 18088cc:	da802317 	ldw	r10,140(sp)
 18088d0:	12800015 	stw	r10,0(r2)
 18088d4:	003be006 	br	1807858 <__ram_exceptions_end+0xff7f7414>
 18088d8:	a080100c 	andi	r2,r20,64
 18088dc:	da802217 	ldw	r10,136(sp)
 18088e0:	10003026 	beq	r2,zero,18089a4 <___vfiprintf_internal_r+0x1220>
 18088e4:	5480000b 	ldhu	r18,0(r10)
 18088e8:	52800104 	addi	r10,r10,4
 18088ec:	0027883a 	mov	r19,zero
 18088f0:	da802215 	stw	r10,136(sp)
 18088f4:	003d8006 	br	1807ef8 <__ram_exceptions_end+0xff7f7ab4>
 18088f8:	80c00007 	ldb	r3,0(r16)
 18088fc:	003c0006 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808900:	a080100c 	andi	r2,r20,64
 1808904:	d8001d85 	stb	zero,118(sp)
 1808908:	da802217 	ldw	r10,136(sp)
 180890c:	1000201e 	bne	r2,zero,1808990 <___vfiprintf_internal_r+0x120c>
 1808910:	50800104 	addi	r2,r10,4
 1808914:	54800017 	ldw	r18,0(r10)
 1808918:	0027883a 	mov	r19,zero
 180891c:	483def0e 	bge	r9,zero,18080dc <__ram_exceptions_end+0xff7f7c98>
 1808920:	94c6b03a 	or	r3,r18,r19
 1808924:	d8802215 	stw	r2,136(sp)
 1808928:	183d4e1e 	bne	r3,zero,1807e64 <__ram_exceptions_end+0xff7f7a20>
 180892c:	0039883a 	mov	fp,zero
 1808930:	0005883a 	mov	r2,zero
 1808934:	003e0606 	br	1808150 <__ram_exceptions_end+0xff7f7d0c>
 1808938:	d9402117 	ldw	r5,132(sp)
 180893c:	d9002017 	ldw	r4,128(sp)
 1808940:	d9801a04 	addi	r6,sp,104
 1808944:	da402c15 	stw	r9,176(sp)
 1808948:	db802a15 	stw	r14,168(sp)
 180894c:	18076700 	call	1807670 <__sprint_r.part.0>
 1808950:	da402c17 	ldw	r9,176(sp)
 1808954:	db802a17 	ldw	r14,168(sp)
 1808958:	103ede1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 180895c:	d9401b17 	ldw	r5,108(sp)
 1808960:	d8801c17 	ldw	r2,112(sp)
 1808964:	d811883a 	mov	r8,sp
 1808968:	29000044 	addi	r4,r5,1
 180896c:	003e7406 	br	1808340 <__ram_exceptions_end+0xff7f7efc>
 1808970:	00bfffc4 	movi	r2,-1
 1808974:	003c5806 	br	1807ad8 <__ram_exceptions_end+0xff7f7694>
 1808978:	d811883a 	mov	r8,sp
 180897c:	003ee806 	br	1808520 <__ram_exceptions_end+0xff7f80dc>
 1808980:	000b883a 	mov	r5,zero
 1808984:	01000044 	movi	r4,1
 1808988:	d811883a 	mov	r8,sp
 180898c:	003e7c06 	br	1808380 <__ram_exceptions_end+0xff7f7f3c>
 1808990:	50800104 	addi	r2,r10,4
 1808994:	5480000b 	ldhu	r18,0(r10)
 1808998:	0027883a 	mov	r19,zero
 180899c:	483dcf0e 	bge	r9,zero,18080dc <__ram_exceptions_end+0xff7f7c98>
 18089a0:	003fdf06 	br	1808920 <__ram_exceptions_end+0xff7f84dc>
 18089a4:	54800017 	ldw	r18,0(r10)
 18089a8:	52800104 	addi	r10,r10,4
 18089ac:	0027883a 	mov	r19,zero
 18089b0:	da802215 	stw	r10,136(sp)
 18089b4:	003d5006 	br	1807ef8 <__ram_exceptions_end+0xff7f7ab4>
 18089b8:	50800104 	addi	r2,r10,4
 18089bc:	5480000b 	ldhu	r18,0(r10)
 18089c0:	0027883a 	mov	r19,zero
 18089c4:	483f7d0e 	bge	r9,zero,18087bc <__ram_exceptions_end+0xff7f8378>
 18089c8:	003ddc06 	br	180813c <__ram_exceptions_end+0xff7f7cf8>
 18089cc:	d8c02215 	stw	r3,136(sp)
 18089d0:	0039883a 	mov	fp,zero
 18089d4:	003ddb06 	br	1808144 <__ram_exceptions_end+0xff7f7d00>
 18089d8:	02806134 	movhi	r10,388
 18089dc:	52854704 	addi	r10,r10,5404
 18089e0:	da802415 	stw	r10,144(sp)
 18089e4:	003e8306 	br	18083f4 <__ram_exceptions_end+0xff7f7fb0>
 18089e8:	d8801c17 	ldw	r2,112(sp)
 18089ec:	dd002117 	ldw	r20,132(sp)
 18089f0:	103eb926 	beq	r2,zero,18084d8 <__ram_exceptions_end+0xff7f8094>
 18089f4:	d9002017 	ldw	r4,128(sp)
 18089f8:	d9801a04 	addi	r6,sp,104
 18089fc:	a00b883a 	mov	r5,r20
 1808a00:	18076700 	call	1807670 <__sprint_r.part.0>
 1808a04:	003eb406 	br	18084d8 <__ram_exceptions_end+0xff7f8094>
 1808a08:	80c00043 	ldbu	r3,1(r16)
 1808a0c:	a5000814 	ori	r20,r20,32
 1808a10:	84000044 	addi	r16,r16,1
 1808a14:	18c03fcc 	andi	r3,r3,255
 1808a18:	18c0201c 	xori	r3,r3,128
 1808a1c:	18ffe004 	addi	r3,r3,-128
 1808a20:	003bb706 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808a24:	a809883a 	mov	r4,r21
 1808a28:	d8c02a15 	stw	r3,168(sp)
 1808a2c:	da002b15 	stw	r8,172(sp)
 1808a30:	18075d80 	call	18075d8 <strlen>
 1808a34:	d8c02a17 	ldw	r3,168(sp)
 1808a38:	1027883a 	mov	r19,r2
 1808a3c:	df001d83 	ldbu	fp,118(sp)
 1808a40:	d8c02215 	stw	r3,136(sp)
 1808a44:	0013883a 	mov	r9,zero
 1808a48:	da002b17 	ldw	r8,172(sp)
 1808a4c:	003c4d06 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1808a50:	d9402117 	ldw	r5,132(sp)
 1808a54:	d9002017 	ldw	r4,128(sp)
 1808a58:	d9801a04 	addi	r6,sp,104
 1808a5c:	da402c15 	stw	r9,176(sp)
 1808a60:	18076700 	call	1807670 <__sprint_r.part.0>
 1808a64:	da402c17 	ldw	r9,176(sp)
 1808a68:	103e9a1e 	bne	r2,zero,18084d4 <__ram_exceptions_end+0xff7f8090>
 1808a6c:	d9401b17 	ldw	r5,108(sp)
 1808a70:	d8801c17 	ldw	r2,112(sp)
 1808a74:	d811883a 	mov	r8,sp
 1808a78:	29000044 	addi	r4,r5,1
 1808a7c:	003e4206 	br	1808388 <__ram_exceptions_end+0xff7f7f44>
 1808a80:	d9401b17 	ldw	r5,108(sp)
 1808a84:	01006134 	movhi	r4,388
 1808a88:	21054b04 	addi	r4,r4,5420
 1808a8c:	d9002415 	stw	r4,144(sp)
 1808a90:	29400044 	addi	r5,r5,1
 1808a94:	003c6d06 	br	1807c4c <__ram_exceptions_end+0xff7f7808>
 1808a98:	0039883a 	mov	fp,zero
 1808a9c:	00800084 	movi	r2,2
 1808aa0:	10803fcc 	andi	r2,r2,255
 1808aa4:	01000044 	movi	r4,1
 1808aa8:	11001e26 	beq	r2,r4,1808b24 <___vfiprintf_internal_r+0x13a0>
 1808aac:	01000084 	movi	r4,2
 1808ab0:	11001e1e 	bne	r2,r4,1808b2c <___vfiprintf_internal_r+0x13a8>
 1808ab4:	1829883a 	mov	r20,r3
 1808ab8:	003eea06 	br	1808664 <__ram_exceptions_end+0xff7f8220>
 1808abc:	a007883a 	mov	r3,r20
 1808ac0:	00800044 	movi	r2,1
 1808ac4:	003ff606 	br	1808aa0 <__ram_exceptions_end+0xff7f865c>
 1808ac8:	00800184 	movi	r2,6
 1808acc:	1240012e 	bgeu	r2,r9,1808ad4 <___vfiprintf_internal_r+0x1350>
 1808ad0:	1013883a 	mov	r9,r2
 1808ad4:	4827883a 	mov	r19,r9
 1808ad8:	4825883a 	mov	r18,r9
 1808adc:	48001516 	blt	r9,zero,1808b34 <___vfiprintf_internal_r+0x13b0>
 1808ae0:	05406134 	movhi	r21,388
 1808ae4:	d8c02215 	stw	r3,136(sp)
 1808ae8:	ad44eb04 	addi	r21,r21,5036
 1808aec:	003d1406 	br	1807f40 <__ram_exceptions_end+0xff7f7afc>
 1808af0:	02806134 	movhi	r10,388
 1808af4:	52854704 	addi	r10,r10,5404
 1808af8:	da802415 	stw	r10,144(sp)
 1808afc:	200d883a 	mov	r6,r4
 1808b00:	003c9106 	br	1807d48 <__ram_exceptions_end+0xff7f7904>
 1808b04:	5021883a 	mov	r16,r10
 1808b08:	0013883a 	mov	r9,zero
 1808b0c:	003b7d06 	br	1807904 <__ram_exceptions_end+0xff7f74c0>
 1808b10:	4827883a 	mov	r19,r9
 1808b14:	df001d83 	ldbu	fp,118(sp)
 1808b18:	d8c02215 	stw	r3,136(sp)
 1808b1c:	0013883a 	mov	r9,zero
 1808b20:	003c1806 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1808b24:	1829883a 	mov	r20,r3
 1808b28:	003d1806 	br	1807f8c <__ram_exceptions_end+0xff7f7b48>
 1808b2c:	1829883a 	mov	r20,r3
 1808b30:	003ccd06 	br	1807e68 <__ram_exceptions_end+0xff7f7a24>
 1808b34:	0025883a 	mov	r18,zero
 1808b38:	003fe906 	br	1808ae0 <__ram_exceptions_end+0xff7f869c>
 1808b3c:	d8802217 	ldw	r2,136(sp)
 1808b40:	80c00043 	ldbu	r3,1(r16)
 1808b44:	5021883a 	mov	r16,r10
 1808b48:	12400017 	ldw	r9,0(r2)
 1808b4c:	10800104 	addi	r2,r2,4
 1808b50:	d8802215 	stw	r2,136(sp)
 1808b54:	483faf0e 	bge	r9,zero,1808a14 <__ram_exceptions_end+0xff7f85d0>
 1808b58:	18c03fcc 	andi	r3,r3,255
 1808b5c:	18c0201c 	xori	r3,r3,128
 1808b60:	027fffc4 	movi	r9,-1
 1808b64:	18ffe004 	addi	r3,r3,-128
 1808b68:	003b6506 	br	1807900 <__ram_exceptions_end+0xff7f74bc>
 1808b6c:	d9c01d85 	stb	r7,118(sp)
 1808b70:	003ca006 	br	1807df4 <__ram_exceptions_end+0xff7f79b0>
 1808b74:	d9c01d85 	stb	r7,118(sp)
 1808b78:	003cad06 	br	1807e30 <__ram_exceptions_end+0xff7f79ec>
 1808b7c:	d9c01d85 	stb	r7,118(sp)
 1808b80:	003d7d06 	br	1808178 <__ram_exceptions_end+0xff7f7d34>
 1808b84:	d9c01d85 	stb	r7,118(sp)
 1808b88:	003d5f06 	br	1808108 <__ram_exceptions_end+0xff7f7cc4>
 1808b8c:	a080004c 	andi	r2,r20,1
 1808b90:	0039883a 	mov	fp,zero
 1808b94:	10000526 	beq	r2,zero,1808bac <___vfiprintf_internal_r+0x1428>
 1808b98:	00800c04 	movi	r2,48
 1808b9c:	d88019c5 	stb	r2,103(sp)
 1808ba0:	dcc02717 	ldw	r19,156(sp)
 1808ba4:	dd4019c4 	addi	r21,sp,103
 1808ba8:	003bf606 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1808bac:	0027883a 	mov	r19,zero
 1808bb0:	dd401a04 	addi	r21,sp,104
 1808bb4:	003bf306 	br	1807b84 <__ram_exceptions_end+0xff7f7740>
 1808bb8:	d9c01d85 	stb	r7,118(sp)
 1808bbc:	003dc806 	br	18082e0 <__ram_exceptions_end+0xff7f7e9c>
 1808bc0:	d9c01d85 	stb	r7,118(sp)
 1808bc4:	003d3a06 	br	18080b0 <__ram_exceptions_end+0xff7f7c6c>
 1808bc8:	d9c01d85 	stb	r7,118(sp)
 1808bcc:	003d2a06 	br	1808078 <__ram_exceptions_end+0xff7f7c34>
 1808bd0:	d9c01d85 	stb	r7,118(sp)
 1808bd4:	003cde06 	br	1807f50 <__ram_exceptions_end+0xff7f7b0c>
 1808bd8:	d9c01d85 	stb	r7,118(sp)
 1808bdc:	003cbc06 	br	1807ed0 <__ram_exceptions_end+0xff7f7a8c>

01808be0 <__vfiprintf_internal>:
 1808be0:	00806134 	movhi	r2,388
 1808be4:	10975504 	addi	r2,r2,23892
 1808be8:	300f883a 	mov	r7,r6
 1808bec:	280d883a 	mov	r6,r5
 1808bf0:	200b883a 	mov	r5,r4
 1808bf4:	11000017 	ldw	r4,0(r2)
 1808bf8:	18077841 	jmpi	1807784 <___vfiprintf_internal_r>

01808bfc <__sbprintf>:
 1808bfc:	2880030b 	ldhu	r2,12(r5)
 1808c00:	2ac01917 	ldw	r11,100(r5)
 1808c04:	2a80038b 	ldhu	r10,14(r5)
 1808c08:	2a400717 	ldw	r9,28(r5)
 1808c0c:	2a000917 	ldw	r8,36(r5)
 1808c10:	defee204 	addi	sp,sp,-1144
 1808c14:	00c10004 	movi	r3,1024
 1808c18:	dc011a15 	stw	r16,1128(sp)
 1808c1c:	10bfff4c 	andi	r2,r2,65533
 1808c20:	2821883a 	mov	r16,r5
 1808c24:	d8cb883a 	add	r5,sp,r3
 1808c28:	dc811c15 	stw	r18,1136(sp)
 1808c2c:	dc411b15 	stw	r17,1132(sp)
 1808c30:	dfc11d15 	stw	ra,1140(sp)
 1808c34:	2025883a 	mov	r18,r4
 1808c38:	d881030d 	sth	r2,1036(sp)
 1808c3c:	dac11915 	stw	r11,1124(sp)
 1808c40:	da81038d 	sth	r10,1038(sp)
 1808c44:	da410715 	stw	r9,1052(sp)
 1808c48:	da010915 	stw	r8,1060(sp)
 1808c4c:	dec10015 	stw	sp,1024(sp)
 1808c50:	dec10415 	stw	sp,1040(sp)
 1808c54:	d8c10215 	stw	r3,1032(sp)
 1808c58:	d8c10515 	stw	r3,1044(sp)
 1808c5c:	d8010615 	stw	zero,1048(sp)
 1808c60:	18077840 	call	1807784 <___vfiprintf_internal_r>
 1808c64:	1023883a 	mov	r17,r2
 1808c68:	10000416 	blt	r2,zero,1808c7c <__sbprintf+0x80>
 1808c6c:	d9410004 	addi	r5,sp,1024
 1808c70:	9009883a 	mov	r4,r18
 1808c74:	1804b1c0 	call	1804b1c <_fflush_r>
 1808c78:	10000d1e 	bne	r2,zero,1808cb0 <__sbprintf+0xb4>
 1808c7c:	d881030b 	ldhu	r2,1036(sp)
 1808c80:	1080100c 	andi	r2,r2,64
 1808c84:	10000326 	beq	r2,zero,1808c94 <__sbprintf+0x98>
 1808c88:	8080030b 	ldhu	r2,12(r16)
 1808c8c:	10801014 	ori	r2,r2,64
 1808c90:	8080030d 	sth	r2,12(r16)
 1808c94:	8805883a 	mov	r2,r17
 1808c98:	dfc11d17 	ldw	ra,1140(sp)
 1808c9c:	dc811c17 	ldw	r18,1136(sp)
 1808ca0:	dc411b17 	ldw	r17,1132(sp)
 1808ca4:	dc011a17 	ldw	r16,1128(sp)
 1808ca8:	dec11e04 	addi	sp,sp,1144
 1808cac:	f800283a 	ret
 1808cb0:	047fffc4 	movi	r17,-1
 1808cb4:	003ff106 	br	1808c7c <__ram_exceptions_end+0xff7f8838>

01808cb8 <_write_r>:
 1808cb8:	defffd04 	addi	sp,sp,-12
 1808cbc:	2805883a 	mov	r2,r5
 1808cc0:	dc000015 	stw	r16,0(sp)
 1808cc4:	04006134 	movhi	r16,388
 1808cc8:	dc400115 	stw	r17,4(sp)
 1808ccc:	300b883a 	mov	r5,r6
 1808cd0:	841f2204 	addi	r16,r16,31880
 1808cd4:	2023883a 	mov	r17,r4
 1808cd8:	380d883a 	mov	r6,r7
 1808cdc:	1009883a 	mov	r4,r2
 1808ce0:	dfc00215 	stw	ra,8(sp)
 1808ce4:	80000015 	stw	zero,0(r16)
 1808ce8:	18133740 	call	1813374 <write>
 1808cec:	00ffffc4 	movi	r3,-1
 1808cf0:	10c00526 	beq	r2,r3,1808d08 <_write_r+0x50>
 1808cf4:	dfc00217 	ldw	ra,8(sp)
 1808cf8:	dc400117 	ldw	r17,4(sp)
 1808cfc:	dc000017 	ldw	r16,0(sp)
 1808d00:	dec00304 	addi	sp,sp,12
 1808d04:	f800283a 	ret
 1808d08:	80c00017 	ldw	r3,0(r16)
 1808d0c:	183ff926 	beq	r3,zero,1808cf4 <__ram_exceptions_end+0xff7f88b0>
 1808d10:	88c00015 	stw	r3,0(r17)
 1808d14:	003ff706 	br	1808cf4 <__ram_exceptions_end+0xff7f88b0>

01808d18 <_close_r>:
 1808d18:	defffd04 	addi	sp,sp,-12
 1808d1c:	dc000015 	stw	r16,0(sp)
 1808d20:	04006134 	movhi	r16,388
 1808d24:	dc400115 	stw	r17,4(sp)
 1808d28:	841f2204 	addi	r16,r16,31880
 1808d2c:	2023883a 	mov	r17,r4
 1808d30:	2809883a 	mov	r4,r5
 1808d34:	dfc00215 	stw	ra,8(sp)
 1808d38:	80000015 	stw	zero,0(r16)
 1808d3c:	18132c00 	call	18132c0 <close>
 1808d40:	00ffffc4 	movi	r3,-1
 1808d44:	10c00526 	beq	r2,r3,1808d5c <_close_r+0x44>
 1808d48:	dfc00217 	ldw	ra,8(sp)
 1808d4c:	dc400117 	ldw	r17,4(sp)
 1808d50:	dc000017 	ldw	r16,0(sp)
 1808d54:	dec00304 	addi	sp,sp,12
 1808d58:	f800283a 	ret
 1808d5c:	80c00017 	ldw	r3,0(r16)
 1808d60:	183ff926 	beq	r3,zero,1808d48 <__ram_exceptions_end+0xff7f8904>
 1808d64:	88c00015 	stw	r3,0(r17)
 1808d68:	003ff706 	br	1808d48 <__ram_exceptions_end+0xff7f8904>

01808d6c <_calloc_r>:
 1808d6c:	298b383a 	mul	r5,r5,r6
 1808d70:	defffe04 	addi	sp,sp,-8
 1808d74:	dfc00115 	stw	ra,4(sp)
 1808d78:	dc000015 	stw	r16,0(sp)
 1808d7c:	180579c0 	call	180579c <_malloc_r>
 1808d80:	10002926 	beq	r2,zero,1808e28 <_calloc_r+0xbc>
 1808d84:	11bfff17 	ldw	r6,-4(r2)
 1808d88:	1021883a 	mov	r16,r2
 1808d8c:	00bfff04 	movi	r2,-4
 1808d90:	308c703a 	and	r6,r6,r2
 1808d94:	00c00904 	movi	r3,36
 1808d98:	308d883a 	add	r6,r6,r2
 1808d9c:	19801636 	bltu	r3,r6,1808df8 <_calloc_r+0x8c>
 1808da0:	008004c4 	movi	r2,19
 1808da4:	11800b2e 	bgeu	r2,r6,1808dd4 <_calloc_r+0x68>
 1808da8:	80000015 	stw	zero,0(r16)
 1808dac:	80000115 	stw	zero,4(r16)
 1808db0:	008006c4 	movi	r2,27
 1808db4:	11801a2e 	bgeu	r2,r6,1808e20 <_calloc_r+0xb4>
 1808db8:	80000215 	stw	zero,8(r16)
 1808dbc:	80000315 	stw	zero,12(r16)
 1808dc0:	30c0151e 	bne	r6,r3,1808e18 <_calloc_r+0xac>
 1808dc4:	80000415 	stw	zero,16(r16)
 1808dc8:	80800604 	addi	r2,r16,24
 1808dcc:	80000515 	stw	zero,20(r16)
 1808dd0:	00000106 	br	1808dd8 <_calloc_r+0x6c>
 1808dd4:	8005883a 	mov	r2,r16
 1808dd8:	10000015 	stw	zero,0(r2)
 1808ddc:	10000115 	stw	zero,4(r2)
 1808de0:	10000215 	stw	zero,8(r2)
 1808de4:	8005883a 	mov	r2,r16
 1808de8:	dfc00117 	ldw	ra,4(sp)
 1808dec:	dc000017 	ldw	r16,0(sp)
 1808df0:	dec00204 	addi	sp,sp,8
 1808df4:	f800283a 	ret
 1808df8:	000b883a 	mov	r5,zero
 1808dfc:	8009883a 	mov	r4,r16
 1808e00:	18061d40 	call	18061d4 <memset>
 1808e04:	8005883a 	mov	r2,r16
 1808e08:	dfc00117 	ldw	ra,4(sp)
 1808e0c:	dc000017 	ldw	r16,0(sp)
 1808e10:	dec00204 	addi	sp,sp,8
 1808e14:	f800283a 	ret
 1808e18:	80800404 	addi	r2,r16,16
 1808e1c:	003fee06 	br	1808dd8 <__ram_exceptions_end+0xff7f8994>
 1808e20:	80800204 	addi	r2,r16,8
 1808e24:	003fec06 	br	1808dd8 <__ram_exceptions_end+0xff7f8994>
 1808e28:	0005883a 	mov	r2,zero
 1808e2c:	003fee06 	br	1808de8 <__ram_exceptions_end+0xff7f89a4>

01808e30 <_fclose_r>:
 1808e30:	28003926 	beq	r5,zero,1808f18 <_fclose_r+0xe8>
 1808e34:	defffc04 	addi	sp,sp,-16
 1808e38:	dc400115 	stw	r17,4(sp)
 1808e3c:	dc000015 	stw	r16,0(sp)
 1808e40:	dfc00315 	stw	ra,12(sp)
 1808e44:	dc800215 	stw	r18,8(sp)
 1808e48:	2023883a 	mov	r17,r4
 1808e4c:	2821883a 	mov	r16,r5
 1808e50:	20000226 	beq	r4,zero,1808e5c <_fclose_r+0x2c>
 1808e54:	20800e17 	ldw	r2,56(r4)
 1808e58:	10002726 	beq	r2,zero,1808ef8 <_fclose_r+0xc8>
 1808e5c:	8080030f 	ldh	r2,12(r16)
 1808e60:	1000071e 	bne	r2,zero,1808e80 <_fclose_r+0x50>
 1808e64:	0005883a 	mov	r2,zero
 1808e68:	dfc00317 	ldw	ra,12(sp)
 1808e6c:	dc800217 	ldw	r18,8(sp)
 1808e70:	dc400117 	ldw	r17,4(sp)
 1808e74:	dc000017 	ldw	r16,0(sp)
 1808e78:	dec00404 	addi	sp,sp,16
 1808e7c:	f800283a 	ret
 1808e80:	800b883a 	mov	r5,r16
 1808e84:	8809883a 	mov	r4,r17
 1808e88:	18049000 	call	1804900 <__sflush_r>
 1808e8c:	1025883a 	mov	r18,r2
 1808e90:	80800b17 	ldw	r2,44(r16)
 1808e94:	10000426 	beq	r2,zero,1808ea8 <_fclose_r+0x78>
 1808e98:	81400717 	ldw	r5,28(r16)
 1808e9c:	8809883a 	mov	r4,r17
 1808ea0:	103ee83a 	callr	r2
 1808ea4:	10001616 	blt	r2,zero,1808f00 <_fclose_r+0xd0>
 1808ea8:	8080030b 	ldhu	r2,12(r16)
 1808eac:	1080200c 	andi	r2,r2,128
 1808eb0:	1000151e 	bne	r2,zero,1808f08 <_fclose_r+0xd8>
 1808eb4:	81400c17 	ldw	r5,48(r16)
 1808eb8:	28000526 	beq	r5,zero,1808ed0 <_fclose_r+0xa0>
 1808ebc:	80801004 	addi	r2,r16,64
 1808ec0:	28800226 	beq	r5,r2,1808ecc <_fclose_r+0x9c>
 1808ec4:	8809883a 	mov	r4,r17
 1808ec8:	180506c0 	call	180506c <_free_r>
 1808ecc:	80000c15 	stw	zero,48(r16)
 1808ed0:	81401117 	ldw	r5,68(r16)
 1808ed4:	28000326 	beq	r5,zero,1808ee4 <_fclose_r+0xb4>
 1808ed8:	8809883a 	mov	r4,r17
 1808edc:	180506c0 	call	180506c <_free_r>
 1808ee0:	80001115 	stw	zero,68(r16)
 1808ee4:	1804f080 	call	1804f08 <__sfp_lock_acquire>
 1808ee8:	8000030d 	sth	zero,12(r16)
 1808eec:	1804f0c0 	call	1804f0c <__sfp_lock_release>
 1808ef0:	9005883a 	mov	r2,r18
 1808ef4:	003fdc06 	br	1808e68 <__ram_exceptions_end+0xff7f8a24>
 1808ef8:	1804ef80 	call	1804ef8 <__sinit>
 1808efc:	003fd706 	br	1808e5c <__ram_exceptions_end+0xff7f8a18>
 1808f00:	04bfffc4 	movi	r18,-1
 1808f04:	003fe806 	br	1808ea8 <__ram_exceptions_end+0xff7f8a64>
 1808f08:	81400417 	ldw	r5,16(r16)
 1808f0c:	8809883a 	mov	r4,r17
 1808f10:	180506c0 	call	180506c <_free_r>
 1808f14:	003fe706 	br	1808eb4 <__ram_exceptions_end+0xff7f8a70>
 1808f18:	0005883a 	mov	r2,zero
 1808f1c:	f800283a 	ret

01808f20 <fclose>:
 1808f20:	00806134 	movhi	r2,388
 1808f24:	10975504 	addi	r2,r2,23892
 1808f28:	200b883a 	mov	r5,r4
 1808f2c:	11000017 	ldw	r4,0(r2)
 1808f30:	1808e301 	jmpi	1808e30 <_fclose_r>

01808f34 <__fputwc>:
 1808f34:	defff804 	addi	sp,sp,-32
 1808f38:	dcc00415 	stw	r19,16(sp)
 1808f3c:	dc800315 	stw	r18,12(sp)
 1808f40:	dc000115 	stw	r16,4(sp)
 1808f44:	dfc00715 	stw	ra,28(sp)
 1808f48:	dd400615 	stw	r21,24(sp)
 1808f4c:	dd000515 	stw	r20,20(sp)
 1808f50:	dc400215 	stw	r17,8(sp)
 1808f54:	2027883a 	mov	r19,r4
 1808f58:	2825883a 	mov	r18,r5
 1808f5c:	3021883a 	mov	r16,r6
 1808f60:	180558c0 	call	180558c <__locale_mb_cur_max>
 1808f64:	00c00044 	movi	r3,1
 1808f68:	10c03e26 	beq	r2,r3,1809064 <__fputwc+0x130>
 1808f6c:	81c01704 	addi	r7,r16,92
 1808f70:	900d883a 	mov	r6,r18
 1808f74:	d80b883a 	mov	r5,sp
 1808f78:	9809883a 	mov	r4,r19
 1808f7c:	1809f800 	call	1809f80 <_wcrtomb_r>
 1808f80:	1029883a 	mov	r20,r2
 1808f84:	00bfffc4 	movi	r2,-1
 1808f88:	a0802026 	beq	r20,r2,180900c <__fputwc+0xd8>
 1808f8c:	d9400003 	ldbu	r5,0(sp)
 1808f90:	a0001c26 	beq	r20,zero,1809004 <__fputwc+0xd0>
 1808f94:	0023883a 	mov	r17,zero
 1808f98:	05400284 	movi	r21,10
 1808f9c:	00000906 	br	1808fc4 <__fputwc+0x90>
 1808fa0:	80800017 	ldw	r2,0(r16)
 1808fa4:	11400005 	stb	r5,0(r2)
 1808fa8:	80c00017 	ldw	r3,0(r16)
 1808fac:	18c00044 	addi	r3,r3,1
 1808fb0:	80c00015 	stw	r3,0(r16)
 1808fb4:	8c400044 	addi	r17,r17,1
 1808fb8:	dc45883a 	add	r2,sp,r17
 1808fbc:	8d00112e 	bgeu	r17,r20,1809004 <__fputwc+0xd0>
 1808fc0:	11400003 	ldbu	r5,0(r2)
 1808fc4:	80c00217 	ldw	r3,8(r16)
 1808fc8:	18ffffc4 	addi	r3,r3,-1
 1808fcc:	80c00215 	stw	r3,8(r16)
 1808fd0:	183ff30e 	bge	r3,zero,1808fa0 <__ram_exceptions_end+0xff7f8b5c>
 1808fd4:	80800617 	ldw	r2,24(r16)
 1808fd8:	18801916 	blt	r3,r2,1809040 <__fputwc+0x10c>
 1808fdc:	80800017 	ldw	r2,0(r16)
 1808fe0:	11400005 	stb	r5,0(r2)
 1808fe4:	80800017 	ldw	r2,0(r16)
 1808fe8:	10c00003 	ldbu	r3,0(r2)
 1808fec:	10800044 	addi	r2,r2,1
 1808ff0:	1d402326 	beq	r3,r21,1809080 <__fputwc+0x14c>
 1808ff4:	80800015 	stw	r2,0(r16)
 1808ff8:	8c400044 	addi	r17,r17,1
 1808ffc:	dc45883a 	add	r2,sp,r17
 1809000:	8d3fef36 	bltu	r17,r20,1808fc0 <__ram_exceptions_end+0xff7f8b7c>
 1809004:	9005883a 	mov	r2,r18
 1809008:	00000406 	br	180901c <__fputwc+0xe8>
 180900c:	80c0030b 	ldhu	r3,12(r16)
 1809010:	a005883a 	mov	r2,r20
 1809014:	18c01014 	ori	r3,r3,64
 1809018:	80c0030d 	sth	r3,12(r16)
 180901c:	dfc00717 	ldw	ra,28(sp)
 1809020:	dd400617 	ldw	r21,24(sp)
 1809024:	dd000517 	ldw	r20,20(sp)
 1809028:	dcc00417 	ldw	r19,16(sp)
 180902c:	dc800317 	ldw	r18,12(sp)
 1809030:	dc400217 	ldw	r17,8(sp)
 1809034:	dc000117 	ldw	r16,4(sp)
 1809038:	dec00804 	addi	sp,sp,32
 180903c:	f800283a 	ret
 1809040:	800d883a 	mov	r6,r16
 1809044:	29403fcc 	andi	r5,r5,255
 1809048:	9809883a 	mov	r4,r19
 180904c:	1809e280 	call	1809e28 <__swbuf_r>
 1809050:	10bfffe0 	cmpeqi	r2,r2,-1
 1809054:	10803fcc 	andi	r2,r2,255
 1809058:	103fd626 	beq	r2,zero,1808fb4 <__ram_exceptions_end+0xff7f8b70>
 180905c:	00bfffc4 	movi	r2,-1
 1809060:	003fee06 	br	180901c <__ram_exceptions_end+0xff7f8bd8>
 1809064:	90ffffc4 	addi	r3,r18,-1
 1809068:	01003f84 	movi	r4,254
 180906c:	20ffbf36 	bltu	r4,r3,1808f6c <__ram_exceptions_end+0xff7f8b28>
 1809070:	900b883a 	mov	r5,r18
 1809074:	dc800005 	stb	r18,0(sp)
 1809078:	1029883a 	mov	r20,r2
 180907c:	003fc506 	br	1808f94 <__ram_exceptions_end+0xff7f8b50>
 1809080:	800d883a 	mov	r6,r16
 1809084:	a80b883a 	mov	r5,r21
 1809088:	9809883a 	mov	r4,r19
 180908c:	1809e280 	call	1809e28 <__swbuf_r>
 1809090:	10bfffe0 	cmpeqi	r2,r2,-1
 1809094:	003fef06 	br	1809054 <__ram_exceptions_end+0xff7f8c10>

01809098 <_fputwc_r>:
 1809098:	3080030b 	ldhu	r2,12(r6)
 180909c:	10c8000c 	andi	r3,r2,8192
 18090a0:	1800051e 	bne	r3,zero,18090b8 <_fputwc_r+0x20>
 18090a4:	30c01917 	ldw	r3,100(r6)
 18090a8:	10880014 	ori	r2,r2,8192
 18090ac:	3080030d 	sth	r2,12(r6)
 18090b0:	18880014 	ori	r2,r3,8192
 18090b4:	30801915 	stw	r2,100(r6)
 18090b8:	1808f341 	jmpi	1808f34 <__fputwc>

018090bc <fputwc>:
 18090bc:	00806134 	movhi	r2,388
 18090c0:	defffc04 	addi	sp,sp,-16
 18090c4:	10975504 	addi	r2,r2,23892
 18090c8:	dc000115 	stw	r16,4(sp)
 18090cc:	14000017 	ldw	r16,0(r2)
 18090d0:	dc400215 	stw	r17,8(sp)
 18090d4:	dfc00315 	stw	ra,12(sp)
 18090d8:	2023883a 	mov	r17,r4
 18090dc:	80000226 	beq	r16,zero,18090e8 <fputwc+0x2c>
 18090e0:	80800e17 	ldw	r2,56(r16)
 18090e4:	10001026 	beq	r2,zero,1809128 <fputwc+0x6c>
 18090e8:	2880030b 	ldhu	r2,12(r5)
 18090ec:	10c8000c 	andi	r3,r2,8192
 18090f0:	1800051e 	bne	r3,zero,1809108 <fputwc+0x4c>
 18090f4:	28c01917 	ldw	r3,100(r5)
 18090f8:	10880014 	ori	r2,r2,8192
 18090fc:	2880030d 	sth	r2,12(r5)
 1809100:	18880014 	ori	r2,r3,8192
 1809104:	28801915 	stw	r2,100(r5)
 1809108:	280d883a 	mov	r6,r5
 180910c:	8009883a 	mov	r4,r16
 1809110:	880b883a 	mov	r5,r17
 1809114:	dfc00317 	ldw	ra,12(sp)
 1809118:	dc400217 	ldw	r17,8(sp)
 180911c:	dc000117 	ldw	r16,4(sp)
 1809120:	dec00404 	addi	sp,sp,16
 1809124:	1808f341 	jmpi	1808f34 <__fputwc>
 1809128:	8009883a 	mov	r4,r16
 180912c:	d9400015 	stw	r5,0(sp)
 1809130:	1804ef80 	call	1804ef8 <__sinit>
 1809134:	d9400017 	ldw	r5,0(sp)
 1809138:	003feb06 	br	18090e8 <__ram_exceptions_end+0xff7f8ca4>

0180913c <_fstat_r>:
 180913c:	defffd04 	addi	sp,sp,-12
 1809140:	2805883a 	mov	r2,r5
 1809144:	dc000015 	stw	r16,0(sp)
 1809148:	04006134 	movhi	r16,388
 180914c:	dc400115 	stw	r17,4(sp)
 1809150:	841f2204 	addi	r16,r16,31880
 1809154:	2023883a 	mov	r17,r4
 1809158:	300b883a 	mov	r5,r6
 180915c:	1009883a 	mov	r4,r2
 1809160:	dfc00215 	stw	ra,8(sp)
 1809164:	80000015 	stw	zero,0(r16)
 1809168:	18127f40 	call	18127f4 <fstat>
 180916c:	00ffffc4 	movi	r3,-1
 1809170:	10c00526 	beq	r2,r3,1809188 <_fstat_r+0x4c>
 1809174:	dfc00217 	ldw	ra,8(sp)
 1809178:	dc400117 	ldw	r17,4(sp)
 180917c:	dc000017 	ldw	r16,0(sp)
 1809180:	dec00304 	addi	sp,sp,12
 1809184:	f800283a 	ret
 1809188:	80c00017 	ldw	r3,0(r16)
 180918c:	183ff926 	beq	r3,zero,1809174 <__ram_exceptions_end+0xff7f8d30>
 1809190:	88c00015 	stw	r3,0(r17)
 1809194:	003ff706 	br	1809174 <__ram_exceptions_end+0xff7f8d30>

01809198 <__sfvwrite_r>:
 1809198:	30800217 	ldw	r2,8(r6)
 180919c:	10006726 	beq	r2,zero,180933c <__sfvwrite_r+0x1a4>
 18091a0:	28c0030b 	ldhu	r3,12(r5)
 18091a4:	defff404 	addi	sp,sp,-48
 18091a8:	dd400715 	stw	r21,28(sp)
 18091ac:	dd000615 	stw	r20,24(sp)
 18091b0:	dc000215 	stw	r16,8(sp)
 18091b4:	dfc00b15 	stw	ra,44(sp)
 18091b8:	df000a15 	stw	fp,40(sp)
 18091bc:	ddc00915 	stw	r23,36(sp)
 18091c0:	dd800815 	stw	r22,32(sp)
 18091c4:	dcc00515 	stw	r19,20(sp)
 18091c8:	dc800415 	stw	r18,16(sp)
 18091cc:	dc400315 	stw	r17,12(sp)
 18091d0:	1880020c 	andi	r2,r3,8
 18091d4:	2821883a 	mov	r16,r5
 18091d8:	202b883a 	mov	r21,r4
 18091dc:	3029883a 	mov	r20,r6
 18091e0:	10002726 	beq	r2,zero,1809280 <__sfvwrite_r+0xe8>
 18091e4:	28800417 	ldw	r2,16(r5)
 18091e8:	10002526 	beq	r2,zero,1809280 <__sfvwrite_r+0xe8>
 18091ec:	1880008c 	andi	r2,r3,2
 18091f0:	a4400017 	ldw	r17,0(r20)
 18091f4:	10002a26 	beq	r2,zero,18092a0 <__sfvwrite_r+0x108>
 18091f8:	05a00034 	movhi	r22,32768
 18091fc:	0027883a 	mov	r19,zero
 1809200:	0025883a 	mov	r18,zero
 1809204:	b5bf0004 	addi	r22,r22,-1024
 1809208:	980d883a 	mov	r6,r19
 180920c:	a809883a 	mov	r4,r21
 1809210:	90004626 	beq	r18,zero,180932c <__sfvwrite_r+0x194>
 1809214:	900f883a 	mov	r7,r18
 1809218:	b480022e 	bgeu	r22,r18,1809224 <__sfvwrite_r+0x8c>
 180921c:	01e00034 	movhi	r7,32768
 1809220:	39ff0004 	addi	r7,r7,-1024
 1809224:	80800917 	ldw	r2,36(r16)
 1809228:	81400717 	ldw	r5,28(r16)
 180922c:	103ee83a 	callr	r2
 1809230:	0080570e 	bge	zero,r2,1809390 <__sfvwrite_r+0x1f8>
 1809234:	a0c00217 	ldw	r3,8(r20)
 1809238:	98a7883a 	add	r19,r19,r2
 180923c:	90a5c83a 	sub	r18,r18,r2
 1809240:	1885c83a 	sub	r2,r3,r2
 1809244:	a0800215 	stw	r2,8(r20)
 1809248:	103fef1e 	bne	r2,zero,1809208 <__ram_exceptions_end+0xff7f8dc4>
 180924c:	0005883a 	mov	r2,zero
 1809250:	dfc00b17 	ldw	ra,44(sp)
 1809254:	df000a17 	ldw	fp,40(sp)
 1809258:	ddc00917 	ldw	r23,36(sp)
 180925c:	dd800817 	ldw	r22,32(sp)
 1809260:	dd400717 	ldw	r21,28(sp)
 1809264:	dd000617 	ldw	r20,24(sp)
 1809268:	dcc00517 	ldw	r19,20(sp)
 180926c:	dc800417 	ldw	r18,16(sp)
 1809270:	dc400317 	ldw	r17,12(sp)
 1809274:	dc000217 	ldw	r16,8(sp)
 1809278:	dec00c04 	addi	sp,sp,48
 180927c:	f800283a 	ret
 1809280:	800b883a 	mov	r5,r16
 1809284:	a809883a 	mov	r4,r21
 1809288:	1802f240 	call	1802f24 <__swsetup_r>
 180928c:	1000eb1e 	bne	r2,zero,180963c <__sfvwrite_r+0x4a4>
 1809290:	80c0030b 	ldhu	r3,12(r16)
 1809294:	a4400017 	ldw	r17,0(r20)
 1809298:	1880008c 	andi	r2,r3,2
 180929c:	103fd61e 	bne	r2,zero,18091f8 <__ram_exceptions_end+0xff7f8db4>
 18092a0:	1880004c 	andi	r2,r3,1
 18092a4:	10003f1e 	bne	r2,zero,18093a4 <__sfvwrite_r+0x20c>
 18092a8:	0039883a 	mov	fp,zero
 18092ac:	0025883a 	mov	r18,zero
 18092b0:	90001a26 	beq	r18,zero,180931c <__sfvwrite_r+0x184>
 18092b4:	1880800c 	andi	r2,r3,512
 18092b8:	84c00217 	ldw	r19,8(r16)
 18092bc:	10002126 	beq	r2,zero,1809344 <__sfvwrite_r+0x1ac>
 18092c0:	982f883a 	mov	r23,r19
 18092c4:	94c09336 	bltu	r18,r19,1809514 <__sfvwrite_r+0x37c>
 18092c8:	1881200c 	andi	r2,r3,1152
 18092cc:	10009e1e 	bne	r2,zero,1809548 <__sfvwrite_r+0x3b0>
 18092d0:	81000017 	ldw	r4,0(r16)
 18092d4:	b80d883a 	mov	r6,r23
 18092d8:	e00b883a 	mov	r5,fp
 18092dc:	18097080 	call	1809708 <memmove>
 18092e0:	80c00217 	ldw	r3,8(r16)
 18092e4:	81000017 	ldw	r4,0(r16)
 18092e8:	9005883a 	mov	r2,r18
 18092ec:	1ce7c83a 	sub	r19,r3,r19
 18092f0:	25cf883a 	add	r7,r4,r23
 18092f4:	84c00215 	stw	r19,8(r16)
 18092f8:	81c00015 	stw	r7,0(r16)
 18092fc:	a0c00217 	ldw	r3,8(r20)
 1809300:	e0b9883a 	add	fp,fp,r2
 1809304:	90a5c83a 	sub	r18,r18,r2
 1809308:	18a7c83a 	sub	r19,r3,r2
 180930c:	a4c00215 	stw	r19,8(r20)
 1809310:	983fce26 	beq	r19,zero,180924c <__ram_exceptions_end+0xff7f8e08>
 1809314:	80c0030b 	ldhu	r3,12(r16)
 1809318:	903fe61e 	bne	r18,zero,18092b4 <__ram_exceptions_end+0xff7f8e70>
 180931c:	8f000017 	ldw	fp,0(r17)
 1809320:	8c800117 	ldw	r18,4(r17)
 1809324:	8c400204 	addi	r17,r17,8
 1809328:	003fe106 	br	18092b0 <__ram_exceptions_end+0xff7f8e6c>
 180932c:	8cc00017 	ldw	r19,0(r17)
 1809330:	8c800117 	ldw	r18,4(r17)
 1809334:	8c400204 	addi	r17,r17,8
 1809338:	003fb306 	br	1809208 <__ram_exceptions_end+0xff7f8dc4>
 180933c:	0005883a 	mov	r2,zero
 1809340:	f800283a 	ret
 1809344:	81000017 	ldw	r4,0(r16)
 1809348:	80800417 	ldw	r2,16(r16)
 180934c:	11005736 	bltu	r2,r4,18094ac <__sfvwrite_r+0x314>
 1809350:	85c00517 	ldw	r23,20(r16)
 1809354:	95c05536 	bltu	r18,r23,18094ac <__sfvwrite_r+0x314>
 1809358:	00a00034 	movhi	r2,32768
 180935c:	10bfffc4 	addi	r2,r2,-1
 1809360:	9009883a 	mov	r4,r18
 1809364:	1480012e 	bgeu	r2,r18,180936c <__sfvwrite_r+0x1d4>
 1809368:	1009883a 	mov	r4,r2
 180936c:	b80b883a 	mov	r5,r23
 1809370:	180ac180 	call	180ac18 <__divsi3>
 1809374:	15cf383a 	mul	r7,r2,r23
 1809378:	81400717 	ldw	r5,28(r16)
 180937c:	80800917 	ldw	r2,36(r16)
 1809380:	e00d883a 	mov	r6,fp
 1809384:	a809883a 	mov	r4,r21
 1809388:	103ee83a 	callr	r2
 180938c:	00bfdb16 	blt	zero,r2,18092fc <__ram_exceptions_end+0xff7f8eb8>
 1809390:	8080030b 	ldhu	r2,12(r16)
 1809394:	10801014 	ori	r2,r2,64
 1809398:	8080030d 	sth	r2,12(r16)
 180939c:	00bfffc4 	movi	r2,-1
 18093a0:	003fab06 	br	1809250 <__ram_exceptions_end+0xff7f8e0c>
 18093a4:	0027883a 	mov	r19,zero
 18093a8:	0011883a 	mov	r8,zero
 18093ac:	0039883a 	mov	fp,zero
 18093b0:	0025883a 	mov	r18,zero
 18093b4:	90001f26 	beq	r18,zero,1809434 <__sfvwrite_r+0x29c>
 18093b8:	40005a26 	beq	r8,zero,1809524 <__sfvwrite_r+0x38c>
 18093bc:	982d883a 	mov	r22,r19
 18093c0:	94c0012e 	bgeu	r18,r19,18093c8 <__sfvwrite_r+0x230>
 18093c4:	902d883a 	mov	r22,r18
 18093c8:	81000017 	ldw	r4,0(r16)
 18093cc:	80800417 	ldw	r2,16(r16)
 18093d0:	b02f883a 	mov	r23,r22
 18093d4:	81c00517 	ldw	r7,20(r16)
 18093d8:	1100032e 	bgeu	r2,r4,18093e8 <__sfvwrite_r+0x250>
 18093dc:	80c00217 	ldw	r3,8(r16)
 18093e0:	38c7883a 	add	r3,r7,r3
 18093e4:	1d801816 	blt	r3,r22,1809448 <__sfvwrite_r+0x2b0>
 18093e8:	b1c03e16 	blt	r22,r7,18094e4 <__sfvwrite_r+0x34c>
 18093ec:	80800917 	ldw	r2,36(r16)
 18093f0:	81400717 	ldw	r5,28(r16)
 18093f4:	e00d883a 	mov	r6,fp
 18093f8:	da000115 	stw	r8,4(sp)
 18093fc:	a809883a 	mov	r4,r21
 1809400:	103ee83a 	callr	r2
 1809404:	102f883a 	mov	r23,r2
 1809408:	da000117 	ldw	r8,4(sp)
 180940c:	00bfe00e 	bge	zero,r2,1809390 <__ram_exceptions_end+0xff7f8f4c>
 1809410:	9de7c83a 	sub	r19,r19,r23
 1809414:	98001f26 	beq	r19,zero,1809494 <__sfvwrite_r+0x2fc>
 1809418:	a0800217 	ldw	r2,8(r20)
 180941c:	e5f9883a 	add	fp,fp,r23
 1809420:	95e5c83a 	sub	r18,r18,r23
 1809424:	15efc83a 	sub	r23,r2,r23
 1809428:	a5c00215 	stw	r23,8(r20)
 180942c:	b83f8726 	beq	r23,zero,180924c <__ram_exceptions_end+0xff7f8e08>
 1809430:	903fe11e 	bne	r18,zero,18093b8 <__ram_exceptions_end+0xff7f8f74>
 1809434:	8f000017 	ldw	fp,0(r17)
 1809438:	8c800117 	ldw	r18,4(r17)
 180943c:	0011883a 	mov	r8,zero
 1809440:	8c400204 	addi	r17,r17,8
 1809444:	003fdb06 	br	18093b4 <__ram_exceptions_end+0xff7f8f70>
 1809448:	180d883a 	mov	r6,r3
 180944c:	e00b883a 	mov	r5,fp
 1809450:	da000115 	stw	r8,4(sp)
 1809454:	d8c00015 	stw	r3,0(sp)
 1809458:	18097080 	call	1809708 <memmove>
 180945c:	d8c00017 	ldw	r3,0(sp)
 1809460:	80800017 	ldw	r2,0(r16)
 1809464:	800b883a 	mov	r5,r16
 1809468:	a809883a 	mov	r4,r21
 180946c:	10c5883a 	add	r2,r2,r3
 1809470:	80800015 	stw	r2,0(r16)
 1809474:	d8c00015 	stw	r3,0(sp)
 1809478:	1804b1c0 	call	1804b1c <_fflush_r>
 180947c:	d8c00017 	ldw	r3,0(sp)
 1809480:	da000117 	ldw	r8,4(sp)
 1809484:	103fc21e 	bne	r2,zero,1809390 <__ram_exceptions_end+0xff7f8f4c>
 1809488:	182f883a 	mov	r23,r3
 180948c:	9de7c83a 	sub	r19,r19,r23
 1809490:	983fe11e 	bne	r19,zero,1809418 <__ram_exceptions_end+0xff7f8fd4>
 1809494:	800b883a 	mov	r5,r16
 1809498:	a809883a 	mov	r4,r21
 180949c:	1804b1c0 	call	1804b1c <_fflush_r>
 18094a0:	103fbb1e 	bne	r2,zero,1809390 <__ram_exceptions_end+0xff7f8f4c>
 18094a4:	0011883a 	mov	r8,zero
 18094a8:	003fdb06 	br	1809418 <__ram_exceptions_end+0xff7f8fd4>
 18094ac:	94c0012e 	bgeu	r18,r19,18094b4 <__sfvwrite_r+0x31c>
 18094b0:	9027883a 	mov	r19,r18
 18094b4:	980d883a 	mov	r6,r19
 18094b8:	e00b883a 	mov	r5,fp
 18094bc:	18097080 	call	1809708 <memmove>
 18094c0:	80800217 	ldw	r2,8(r16)
 18094c4:	80c00017 	ldw	r3,0(r16)
 18094c8:	14c5c83a 	sub	r2,r2,r19
 18094cc:	1cc7883a 	add	r3,r3,r19
 18094d0:	80800215 	stw	r2,8(r16)
 18094d4:	80c00015 	stw	r3,0(r16)
 18094d8:	10004326 	beq	r2,zero,18095e8 <__sfvwrite_r+0x450>
 18094dc:	9805883a 	mov	r2,r19
 18094e0:	003f8606 	br	18092fc <__ram_exceptions_end+0xff7f8eb8>
 18094e4:	b00d883a 	mov	r6,r22
 18094e8:	e00b883a 	mov	r5,fp
 18094ec:	da000115 	stw	r8,4(sp)
 18094f0:	18097080 	call	1809708 <memmove>
 18094f4:	80800217 	ldw	r2,8(r16)
 18094f8:	80c00017 	ldw	r3,0(r16)
 18094fc:	da000117 	ldw	r8,4(sp)
 1809500:	1585c83a 	sub	r2,r2,r22
 1809504:	1dad883a 	add	r22,r3,r22
 1809508:	80800215 	stw	r2,8(r16)
 180950c:	85800015 	stw	r22,0(r16)
 1809510:	003fbf06 	br	1809410 <__ram_exceptions_end+0xff7f8fcc>
 1809514:	81000017 	ldw	r4,0(r16)
 1809518:	9027883a 	mov	r19,r18
 180951c:	902f883a 	mov	r23,r18
 1809520:	003f6c06 	br	18092d4 <__ram_exceptions_end+0xff7f8e90>
 1809524:	900d883a 	mov	r6,r18
 1809528:	01400284 	movi	r5,10
 180952c:	e009883a 	mov	r4,fp
 1809530:	1805fa80 	call	1805fa8 <memchr>
 1809534:	10003e26 	beq	r2,zero,1809630 <__sfvwrite_r+0x498>
 1809538:	10800044 	addi	r2,r2,1
 180953c:	1727c83a 	sub	r19,r2,fp
 1809540:	02000044 	movi	r8,1
 1809544:	003f9d06 	br	18093bc <__ram_exceptions_end+0xff7f8f78>
 1809548:	80800517 	ldw	r2,20(r16)
 180954c:	81400417 	ldw	r5,16(r16)
 1809550:	81c00017 	ldw	r7,0(r16)
 1809554:	10a7883a 	add	r19,r2,r2
 1809558:	9885883a 	add	r2,r19,r2
 180955c:	1026d7fa 	srli	r19,r2,31
 1809560:	396dc83a 	sub	r22,r7,r5
 1809564:	b1000044 	addi	r4,r22,1
 1809568:	9885883a 	add	r2,r19,r2
 180956c:	1027d07a 	srai	r19,r2,1
 1809570:	2485883a 	add	r2,r4,r18
 1809574:	980d883a 	mov	r6,r19
 1809578:	9880022e 	bgeu	r19,r2,1809584 <__sfvwrite_r+0x3ec>
 180957c:	1027883a 	mov	r19,r2
 1809580:	100d883a 	mov	r6,r2
 1809584:	18c1000c 	andi	r3,r3,1024
 1809588:	18001c26 	beq	r3,zero,18095fc <__sfvwrite_r+0x464>
 180958c:	300b883a 	mov	r5,r6
 1809590:	a809883a 	mov	r4,r21
 1809594:	180579c0 	call	180579c <_malloc_r>
 1809598:	102f883a 	mov	r23,r2
 180959c:	10002926 	beq	r2,zero,1809644 <__sfvwrite_r+0x4ac>
 18095a0:	81400417 	ldw	r5,16(r16)
 18095a4:	b00d883a 	mov	r6,r22
 18095a8:	1009883a 	mov	r4,r2
 18095ac:	180608c0 	call	180608c <memcpy>
 18095b0:	8080030b 	ldhu	r2,12(r16)
 18095b4:	00fedfc4 	movi	r3,-1153
 18095b8:	10c4703a 	and	r2,r2,r3
 18095bc:	10802014 	ori	r2,r2,128
 18095c0:	8080030d 	sth	r2,12(r16)
 18095c4:	bd89883a 	add	r4,r23,r22
 18095c8:	9d8fc83a 	sub	r7,r19,r22
 18095cc:	85c00415 	stw	r23,16(r16)
 18095d0:	84c00515 	stw	r19,20(r16)
 18095d4:	81000015 	stw	r4,0(r16)
 18095d8:	9027883a 	mov	r19,r18
 18095dc:	81c00215 	stw	r7,8(r16)
 18095e0:	902f883a 	mov	r23,r18
 18095e4:	003f3b06 	br	18092d4 <__ram_exceptions_end+0xff7f8e90>
 18095e8:	800b883a 	mov	r5,r16
 18095ec:	a809883a 	mov	r4,r21
 18095f0:	1804b1c0 	call	1804b1c <_fflush_r>
 18095f4:	103fb926 	beq	r2,zero,18094dc <__ram_exceptions_end+0xff7f9098>
 18095f8:	003f6506 	br	1809390 <__ram_exceptions_end+0xff7f8f4c>
 18095fc:	a809883a 	mov	r4,r21
 1809600:	18098c40 	call	18098c4 <_realloc_r>
 1809604:	102f883a 	mov	r23,r2
 1809608:	103fee1e 	bne	r2,zero,18095c4 <__ram_exceptions_end+0xff7f9180>
 180960c:	81400417 	ldw	r5,16(r16)
 1809610:	a809883a 	mov	r4,r21
 1809614:	180506c0 	call	180506c <_free_r>
 1809618:	8080030b 	ldhu	r2,12(r16)
 180961c:	00ffdfc4 	movi	r3,-129
 1809620:	1884703a 	and	r2,r3,r2
 1809624:	00c00304 	movi	r3,12
 1809628:	a8c00015 	stw	r3,0(r21)
 180962c:	003f5906 	br	1809394 <__ram_exceptions_end+0xff7f8f50>
 1809630:	94c00044 	addi	r19,r18,1
 1809634:	02000044 	movi	r8,1
 1809638:	003f6006 	br	18093bc <__ram_exceptions_end+0xff7f8f78>
 180963c:	00bfffc4 	movi	r2,-1
 1809640:	003f0306 	br	1809250 <__ram_exceptions_end+0xff7f8e0c>
 1809644:	00800304 	movi	r2,12
 1809648:	a8800015 	stw	r2,0(r21)
 180964c:	8080030b 	ldhu	r2,12(r16)
 1809650:	003f5006 	br	1809394 <__ram_exceptions_end+0xff7f8f50>

01809654 <_isatty_r>:
 1809654:	defffd04 	addi	sp,sp,-12
 1809658:	dc000015 	stw	r16,0(sp)
 180965c:	04006134 	movhi	r16,388
 1809660:	dc400115 	stw	r17,4(sp)
 1809664:	841f2204 	addi	r16,r16,31880
 1809668:	2023883a 	mov	r17,r4
 180966c:	2809883a 	mov	r4,r5
 1809670:	dfc00215 	stw	ra,8(sp)
 1809674:	80000015 	stw	zero,0(r16)
 1809678:	1812a200 	call	1812a20 <isatty>
 180967c:	00ffffc4 	movi	r3,-1
 1809680:	10c00526 	beq	r2,r3,1809698 <_isatty_r+0x44>
 1809684:	dfc00217 	ldw	ra,8(sp)
 1809688:	dc400117 	ldw	r17,4(sp)
 180968c:	dc000017 	ldw	r16,0(sp)
 1809690:	dec00304 	addi	sp,sp,12
 1809694:	f800283a 	ret
 1809698:	80c00017 	ldw	r3,0(r16)
 180969c:	183ff926 	beq	r3,zero,1809684 <__ram_exceptions_end+0xff7f9240>
 18096a0:	88c00015 	stw	r3,0(r17)
 18096a4:	003ff706 	br	1809684 <__ram_exceptions_end+0xff7f9240>

018096a8 <_lseek_r>:
 18096a8:	defffd04 	addi	sp,sp,-12
 18096ac:	2805883a 	mov	r2,r5
 18096b0:	dc000015 	stw	r16,0(sp)
 18096b4:	04006134 	movhi	r16,388
 18096b8:	dc400115 	stw	r17,4(sp)
 18096bc:	300b883a 	mov	r5,r6
 18096c0:	841f2204 	addi	r16,r16,31880
 18096c4:	2023883a 	mov	r17,r4
 18096c8:	380d883a 	mov	r6,r7
 18096cc:	1009883a 	mov	r4,r2
 18096d0:	dfc00215 	stw	ra,8(sp)
 18096d4:	80000015 	stw	zero,0(r16)
 18096d8:	1812bec0 	call	1812bec <lseek>
 18096dc:	00ffffc4 	movi	r3,-1
 18096e0:	10c00526 	beq	r2,r3,18096f8 <_lseek_r+0x50>
 18096e4:	dfc00217 	ldw	ra,8(sp)
 18096e8:	dc400117 	ldw	r17,4(sp)
 18096ec:	dc000017 	ldw	r16,0(sp)
 18096f0:	dec00304 	addi	sp,sp,12
 18096f4:	f800283a 	ret
 18096f8:	80c00017 	ldw	r3,0(r16)
 18096fc:	183ff926 	beq	r3,zero,18096e4 <__ram_exceptions_end+0xff7f92a0>
 1809700:	88c00015 	stw	r3,0(r17)
 1809704:	003ff706 	br	18096e4 <__ram_exceptions_end+0xff7f92a0>

01809708 <memmove>:
 1809708:	2005883a 	mov	r2,r4
 180970c:	29000b2e 	bgeu	r5,r4,180973c <memmove+0x34>
 1809710:	298f883a 	add	r7,r5,r6
 1809714:	21c0092e 	bgeu	r4,r7,180973c <memmove+0x34>
 1809718:	2187883a 	add	r3,r4,r6
 180971c:	198bc83a 	sub	r5,r3,r6
 1809720:	30004826 	beq	r6,zero,1809844 <memmove+0x13c>
 1809724:	39ffffc4 	addi	r7,r7,-1
 1809728:	39000003 	ldbu	r4,0(r7)
 180972c:	18ffffc4 	addi	r3,r3,-1
 1809730:	19000005 	stb	r4,0(r3)
 1809734:	28fffb1e 	bne	r5,r3,1809724 <__ram_exceptions_end+0xff7f92e0>
 1809738:	f800283a 	ret
 180973c:	00c003c4 	movi	r3,15
 1809740:	1980412e 	bgeu	r3,r6,1809848 <memmove+0x140>
 1809744:	2886b03a 	or	r3,r5,r2
 1809748:	18c000cc 	andi	r3,r3,3
 180974c:	1800401e 	bne	r3,zero,1809850 <memmove+0x148>
 1809750:	33fffc04 	addi	r15,r6,-16
 1809754:	781ed13a 	srli	r15,r15,4
 1809758:	28c00104 	addi	r3,r5,4
 180975c:	13400104 	addi	r13,r2,4
 1809760:	781c913a 	slli	r14,r15,4
 1809764:	2b000204 	addi	r12,r5,8
 1809768:	12c00204 	addi	r11,r2,8
 180976c:	73800504 	addi	r14,r14,20
 1809770:	2a800304 	addi	r10,r5,12
 1809774:	12400304 	addi	r9,r2,12
 1809778:	2b9d883a 	add	r14,r5,r14
 180977c:	2811883a 	mov	r8,r5
 1809780:	100f883a 	mov	r7,r2
 1809784:	41000017 	ldw	r4,0(r8)
 1809788:	39c00404 	addi	r7,r7,16
 180978c:	18c00404 	addi	r3,r3,16
 1809790:	393ffc15 	stw	r4,-16(r7)
 1809794:	193ffc17 	ldw	r4,-16(r3)
 1809798:	6b400404 	addi	r13,r13,16
 180979c:	5ac00404 	addi	r11,r11,16
 18097a0:	693ffc15 	stw	r4,-16(r13)
 18097a4:	61000017 	ldw	r4,0(r12)
 18097a8:	4a400404 	addi	r9,r9,16
 18097ac:	42000404 	addi	r8,r8,16
 18097b0:	593ffc15 	stw	r4,-16(r11)
 18097b4:	51000017 	ldw	r4,0(r10)
 18097b8:	63000404 	addi	r12,r12,16
 18097bc:	52800404 	addi	r10,r10,16
 18097c0:	493ffc15 	stw	r4,-16(r9)
 18097c4:	1bbfef1e 	bne	r3,r14,1809784 <__ram_exceptions_end+0xff7f9340>
 18097c8:	79000044 	addi	r4,r15,1
 18097cc:	2008913a 	slli	r4,r4,4
 18097d0:	328003cc 	andi	r10,r6,15
 18097d4:	02c000c4 	movi	r11,3
 18097d8:	1107883a 	add	r3,r2,r4
 18097dc:	290b883a 	add	r5,r5,r4
 18097e0:	5a801e2e 	bgeu	r11,r10,180985c <memmove+0x154>
 18097e4:	1813883a 	mov	r9,r3
 18097e8:	2811883a 	mov	r8,r5
 18097ec:	500f883a 	mov	r7,r10
 18097f0:	41000017 	ldw	r4,0(r8)
 18097f4:	4a400104 	addi	r9,r9,4
 18097f8:	39ffff04 	addi	r7,r7,-4
 18097fc:	493fff15 	stw	r4,-4(r9)
 1809800:	42000104 	addi	r8,r8,4
 1809804:	59fffa36 	bltu	r11,r7,18097f0 <__ram_exceptions_end+0xff7f93ac>
 1809808:	513fff04 	addi	r4,r10,-4
 180980c:	2008d0ba 	srli	r4,r4,2
 1809810:	318000cc 	andi	r6,r6,3
 1809814:	21000044 	addi	r4,r4,1
 1809818:	2109883a 	add	r4,r4,r4
 180981c:	2109883a 	add	r4,r4,r4
 1809820:	1907883a 	add	r3,r3,r4
 1809824:	290b883a 	add	r5,r5,r4
 1809828:	30000b26 	beq	r6,zero,1809858 <memmove+0x150>
 180982c:	198d883a 	add	r6,r3,r6
 1809830:	29c00003 	ldbu	r7,0(r5)
 1809834:	18c00044 	addi	r3,r3,1
 1809838:	29400044 	addi	r5,r5,1
 180983c:	19ffffc5 	stb	r7,-1(r3)
 1809840:	19bffb1e 	bne	r3,r6,1809830 <__ram_exceptions_end+0xff7f93ec>
 1809844:	f800283a 	ret
 1809848:	1007883a 	mov	r3,r2
 180984c:	003ff606 	br	1809828 <__ram_exceptions_end+0xff7f93e4>
 1809850:	1007883a 	mov	r3,r2
 1809854:	003ff506 	br	180982c <__ram_exceptions_end+0xff7f93e8>
 1809858:	f800283a 	ret
 180985c:	500d883a 	mov	r6,r10
 1809860:	003ff106 	br	1809828 <__ram_exceptions_end+0xff7f93e4>

01809864 <_read_r>:
 1809864:	defffd04 	addi	sp,sp,-12
 1809868:	2805883a 	mov	r2,r5
 180986c:	dc000015 	stw	r16,0(sp)
 1809870:	04006134 	movhi	r16,388
 1809874:	dc400115 	stw	r17,4(sp)
 1809878:	300b883a 	mov	r5,r6
 180987c:	841f2204 	addi	r16,r16,31880
 1809880:	2023883a 	mov	r17,r4
 1809884:	380d883a 	mov	r6,r7
 1809888:	1009883a 	mov	r4,r2
 180988c:	dfc00215 	stw	ra,8(sp)
 1809890:	80000015 	stw	zero,0(r16)
 1809894:	18133080 	call	1813308 <read>
 1809898:	00ffffc4 	movi	r3,-1
 180989c:	10c00526 	beq	r2,r3,18098b4 <_read_r+0x50>
 18098a0:	dfc00217 	ldw	ra,8(sp)
 18098a4:	dc400117 	ldw	r17,4(sp)
 18098a8:	dc000017 	ldw	r16,0(sp)
 18098ac:	dec00304 	addi	sp,sp,12
 18098b0:	f800283a 	ret
 18098b4:	80c00017 	ldw	r3,0(r16)
 18098b8:	183ff926 	beq	r3,zero,18098a0 <__ram_exceptions_end+0xff7f945c>
 18098bc:	88c00015 	stw	r3,0(r17)
 18098c0:	003ff706 	br	18098a0 <__ram_exceptions_end+0xff7f945c>

018098c4 <_realloc_r>:
 18098c4:	defff604 	addi	sp,sp,-40
 18098c8:	dc800215 	stw	r18,8(sp)
 18098cc:	dfc00915 	stw	ra,36(sp)
 18098d0:	df000815 	stw	fp,32(sp)
 18098d4:	ddc00715 	stw	r23,28(sp)
 18098d8:	dd800615 	stw	r22,24(sp)
 18098dc:	dd400515 	stw	r21,20(sp)
 18098e0:	dd000415 	stw	r20,16(sp)
 18098e4:	dcc00315 	stw	r19,12(sp)
 18098e8:	dc400115 	stw	r17,4(sp)
 18098ec:	dc000015 	stw	r16,0(sp)
 18098f0:	3025883a 	mov	r18,r6
 18098f4:	2800b726 	beq	r5,zero,1809bd4 <_realloc_r+0x310>
 18098f8:	282b883a 	mov	r21,r5
 18098fc:	2029883a 	mov	r20,r4
 1809900:	180d54c0 	call	180d54c <__malloc_lock>
 1809904:	a8bfff17 	ldw	r2,-4(r21)
 1809908:	043fff04 	movi	r16,-4
 180990c:	90c002c4 	addi	r3,r18,11
 1809910:	01000584 	movi	r4,22
 1809914:	acfffe04 	addi	r19,r21,-8
 1809918:	1420703a 	and	r16,r2,r16
 180991c:	20c0332e 	bgeu	r4,r3,18099ec <_realloc_r+0x128>
 1809920:	047ffe04 	movi	r17,-8
 1809924:	1c62703a 	and	r17,r3,r17
 1809928:	8807883a 	mov	r3,r17
 180992c:	88005816 	blt	r17,zero,1809a90 <_realloc_r+0x1cc>
 1809930:	8c805736 	bltu	r17,r18,1809a90 <_realloc_r+0x1cc>
 1809934:	80c0300e 	bge	r16,r3,18099f8 <_realloc_r+0x134>
 1809938:	07006134 	movhi	fp,388
 180993c:	e710f304 	addi	fp,fp,17356
 1809940:	e1c00217 	ldw	r7,8(fp)
 1809944:	9c09883a 	add	r4,r19,r16
 1809948:	22000117 	ldw	r8,4(r4)
 180994c:	21c06326 	beq	r4,r7,1809adc <_realloc_r+0x218>
 1809950:	017fff84 	movi	r5,-2
 1809954:	414a703a 	and	r5,r8,r5
 1809958:	214b883a 	add	r5,r4,r5
 180995c:	29800117 	ldw	r6,4(r5)
 1809960:	3180004c 	andi	r6,r6,1
 1809964:	30003f26 	beq	r6,zero,1809a64 <_realloc_r+0x1a0>
 1809968:	1080004c 	andi	r2,r2,1
 180996c:	10008326 	beq	r2,zero,1809b7c <_realloc_r+0x2b8>
 1809970:	900b883a 	mov	r5,r18
 1809974:	a009883a 	mov	r4,r20
 1809978:	180579c0 	call	180579c <_malloc_r>
 180997c:	1025883a 	mov	r18,r2
 1809980:	10011e26 	beq	r2,zero,1809dfc <_realloc_r+0x538>
 1809984:	a93fff17 	ldw	r4,-4(r21)
 1809988:	10fffe04 	addi	r3,r2,-8
 180998c:	00bfff84 	movi	r2,-2
 1809990:	2084703a 	and	r2,r4,r2
 1809994:	9885883a 	add	r2,r19,r2
 1809998:	1880ee26 	beq	r3,r2,1809d54 <_realloc_r+0x490>
 180999c:	81bfff04 	addi	r6,r16,-4
 18099a0:	00800904 	movi	r2,36
 18099a4:	1180b836 	bltu	r2,r6,1809c88 <_realloc_r+0x3c4>
 18099a8:	00c004c4 	movi	r3,19
 18099ac:	19809636 	bltu	r3,r6,1809c08 <_realloc_r+0x344>
 18099b0:	9005883a 	mov	r2,r18
 18099b4:	a807883a 	mov	r3,r21
 18099b8:	19000017 	ldw	r4,0(r3)
 18099bc:	11000015 	stw	r4,0(r2)
 18099c0:	19000117 	ldw	r4,4(r3)
 18099c4:	11000115 	stw	r4,4(r2)
 18099c8:	18c00217 	ldw	r3,8(r3)
 18099cc:	10c00215 	stw	r3,8(r2)
 18099d0:	a80b883a 	mov	r5,r21
 18099d4:	a009883a 	mov	r4,r20
 18099d8:	180506c0 	call	180506c <_free_r>
 18099dc:	a009883a 	mov	r4,r20
 18099e0:	180d5ac0 	call	180d5ac <__malloc_unlock>
 18099e4:	9005883a 	mov	r2,r18
 18099e8:	00001206 	br	1809a34 <_realloc_r+0x170>
 18099ec:	00c00404 	movi	r3,16
 18099f0:	1823883a 	mov	r17,r3
 18099f4:	003fce06 	br	1809930 <__ram_exceptions_end+0xff7f94ec>
 18099f8:	a825883a 	mov	r18,r21
 18099fc:	8445c83a 	sub	r2,r16,r17
 1809a00:	00c003c4 	movi	r3,15
 1809a04:	18802636 	bltu	r3,r2,1809aa0 <_realloc_r+0x1dc>
 1809a08:	99800117 	ldw	r6,4(r19)
 1809a0c:	9c07883a 	add	r3,r19,r16
 1809a10:	3180004c 	andi	r6,r6,1
 1809a14:	3420b03a 	or	r16,r6,r16
 1809a18:	9c000115 	stw	r16,4(r19)
 1809a1c:	18800117 	ldw	r2,4(r3)
 1809a20:	10800054 	ori	r2,r2,1
 1809a24:	18800115 	stw	r2,4(r3)
 1809a28:	a009883a 	mov	r4,r20
 1809a2c:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1809a30:	9005883a 	mov	r2,r18
 1809a34:	dfc00917 	ldw	ra,36(sp)
 1809a38:	df000817 	ldw	fp,32(sp)
 1809a3c:	ddc00717 	ldw	r23,28(sp)
 1809a40:	dd800617 	ldw	r22,24(sp)
 1809a44:	dd400517 	ldw	r21,20(sp)
 1809a48:	dd000417 	ldw	r20,16(sp)
 1809a4c:	dcc00317 	ldw	r19,12(sp)
 1809a50:	dc800217 	ldw	r18,8(sp)
 1809a54:	dc400117 	ldw	r17,4(sp)
 1809a58:	dc000017 	ldw	r16,0(sp)
 1809a5c:	dec00a04 	addi	sp,sp,40
 1809a60:	f800283a 	ret
 1809a64:	017fff04 	movi	r5,-4
 1809a68:	414a703a 	and	r5,r8,r5
 1809a6c:	814d883a 	add	r6,r16,r5
 1809a70:	30c01f16 	blt	r6,r3,1809af0 <_realloc_r+0x22c>
 1809a74:	20800317 	ldw	r2,12(r4)
 1809a78:	20c00217 	ldw	r3,8(r4)
 1809a7c:	a825883a 	mov	r18,r21
 1809a80:	3021883a 	mov	r16,r6
 1809a84:	18800315 	stw	r2,12(r3)
 1809a88:	10c00215 	stw	r3,8(r2)
 1809a8c:	003fdb06 	br	18099fc <__ram_exceptions_end+0xff7f95b8>
 1809a90:	00800304 	movi	r2,12
 1809a94:	a0800015 	stw	r2,0(r20)
 1809a98:	0005883a 	mov	r2,zero
 1809a9c:	003fe506 	br	1809a34 <__ram_exceptions_end+0xff7f95f0>
 1809aa0:	98c00117 	ldw	r3,4(r19)
 1809aa4:	9c4b883a 	add	r5,r19,r17
 1809aa8:	11000054 	ori	r4,r2,1
 1809aac:	18c0004c 	andi	r3,r3,1
 1809ab0:	1c62b03a 	or	r17,r3,r17
 1809ab4:	9c400115 	stw	r17,4(r19)
 1809ab8:	29000115 	stw	r4,4(r5)
 1809abc:	2885883a 	add	r2,r5,r2
 1809ac0:	10c00117 	ldw	r3,4(r2)
 1809ac4:	29400204 	addi	r5,r5,8
 1809ac8:	a009883a 	mov	r4,r20
 1809acc:	18c00054 	ori	r3,r3,1
 1809ad0:	10c00115 	stw	r3,4(r2)
 1809ad4:	180506c0 	call	180506c <_free_r>
 1809ad8:	003fd306 	br	1809a28 <__ram_exceptions_end+0xff7f95e4>
 1809adc:	017fff04 	movi	r5,-4
 1809ae0:	414a703a 	and	r5,r8,r5
 1809ae4:	89800404 	addi	r6,r17,16
 1809ae8:	8151883a 	add	r8,r16,r5
 1809aec:	4180590e 	bge	r8,r6,1809c54 <_realloc_r+0x390>
 1809af0:	1080004c 	andi	r2,r2,1
 1809af4:	103f9e1e 	bne	r2,zero,1809970 <__ram_exceptions_end+0xff7f952c>
 1809af8:	adbffe17 	ldw	r22,-8(r21)
 1809afc:	00bfff04 	movi	r2,-4
 1809b00:	9dadc83a 	sub	r22,r19,r22
 1809b04:	b1800117 	ldw	r6,4(r22)
 1809b08:	3084703a 	and	r2,r6,r2
 1809b0c:	20002026 	beq	r4,zero,1809b90 <_realloc_r+0x2cc>
 1809b10:	80af883a 	add	r23,r16,r2
 1809b14:	b96f883a 	add	r23,r23,r5
 1809b18:	21c05f26 	beq	r4,r7,1809c98 <_realloc_r+0x3d4>
 1809b1c:	b8c01c16 	blt	r23,r3,1809b90 <_realloc_r+0x2cc>
 1809b20:	20800317 	ldw	r2,12(r4)
 1809b24:	20c00217 	ldw	r3,8(r4)
 1809b28:	81bfff04 	addi	r6,r16,-4
 1809b2c:	01000904 	movi	r4,36
 1809b30:	18800315 	stw	r2,12(r3)
 1809b34:	10c00215 	stw	r3,8(r2)
 1809b38:	b0c00217 	ldw	r3,8(r22)
 1809b3c:	b0800317 	ldw	r2,12(r22)
 1809b40:	b4800204 	addi	r18,r22,8
 1809b44:	18800315 	stw	r2,12(r3)
 1809b48:	10c00215 	stw	r3,8(r2)
 1809b4c:	21801b36 	bltu	r4,r6,1809bbc <_realloc_r+0x2f8>
 1809b50:	008004c4 	movi	r2,19
 1809b54:	1180352e 	bgeu	r2,r6,1809c2c <_realloc_r+0x368>
 1809b58:	a8800017 	ldw	r2,0(r21)
 1809b5c:	b0800215 	stw	r2,8(r22)
 1809b60:	a8800117 	ldw	r2,4(r21)
 1809b64:	b0800315 	stw	r2,12(r22)
 1809b68:	008006c4 	movi	r2,27
 1809b6c:	11807f36 	bltu	r2,r6,1809d6c <_realloc_r+0x4a8>
 1809b70:	b0800404 	addi	r2,r22,16
 1809b74:	ad400204 	addi	r21,r21,8
 1809b78:	00002d06 	br	1809c30 <_realloc_r+0x36c>
 1809b7c:	adbffe17 	ldw	r22,-8(r21)
 1809b80:	00bfff04 	movi	r2,-4
 1809b84:	9dadc83a 	sub	r22,r19,r22
 1809b88:	b1000117 	ldw	r4,4(r22)
 1809b8c:	2084703a 	and	r2,r4,r2
 1809b90:	b03f7726 	beq	r22,zero,1809970 <__ram_exceptions_end+0xff7f952c>
 1809b94:	80af883a 	add	r23,r16,r2
 1809b98:	b8ff7516 	blt	r23,r3,1809970 <__ram_exceptions_end+0xff7f952c>
 1809b9c:	b0800317 	ldw	r2,12(r22)
 1809ba0:	b0c00217 	ldw	r3,8(r22)
 1809ba4:	81bfff04 	addi	r6,r16,-4
 1809ba8:	01000904 	movi	r4,36
 1809bac:	18800315 	stw	r2,12(r3)
 1809bb0:	10c00215 	stw	r3,8(r2)
 1809bb4:	b4800204 	addi	r18,r22,8
 1809bb8:	21bfe52e 	bgeu	r4,r6,1809b50 <__ram_exceptions_end+0xff7f970c>
 1809bbc:	a80b883a 	mov	r5,r21
 1809bc0:	9009883a 	mov	r4,r18
 1809bc4:	18097080 	call	1809708 <memmove>
 1809bc8:	b821883a 	mov	r16,r23
 1809bcc:	b027883a 	mov	r19,r22
 1809bd0:	003f8a06 	br	18099fc <__ram_exceptions_end+0xff7f95b8>
 1809bd4:	300b883a 	mov	r5,r6
 1809bd8:	dfc00917 	ldw	ra,36(sp)
 1809bdc:	df000817 	ldw	fp,32(sp)
 1809be0:	ddc00717 	ldw	r23,28(sp)
 1809be4:	dd800617 	ldw	r22,24(sp)
 1809be8:	dd400517 	ldw	r21,20(sp)
 1809bec:	dd000417 	ldw	r20,16(sp)
 1809bf0:	dcc00317 	ldw	r19,12(sp)
 1809bf4:	dc800217 	ldw	r18,8(sp)
 1809bf8:	dc400117 	ldw	r17,4(sp)
 1809bfc:	dc000017 	ldw	r16,0(sp)
 1809c00:	dec00a04 	addi	sp,sp,40
 1809c04:	180579c1 	jmpi	180579c <_malloc_r>
 1809c08:	a8c00017 	ldw	r3,0(r21)
 1809c0c:	90c00015 	stw	r3,0(r18)
 1809c10:	a8c00117 	ldw	r3,4(r21)
 1809c14:	90c00115 	stw	r3,4(r18)
 1809c18:	00c006c4 	movi	r3,27
 1809c1c:	19804536 	bltu	r3,r6,1809d34 <_realloc_r+0x470>
 1809c20:	90800204 	addi	r2,r18,8
 1809c24:	a8c00204 	addi	r3,r21,8
 1809c28:	003f6306 	br	18099b8 <__ram_exceptions_end+0xff7f9574>
 1809c2c:	9005883a 	mov	r2,r18
 1809c30:	a8c00017 	ldw	r3,0(r21)
 1809c34:	b821883a 	mov	r16,r23
 1809c38:	b027883a 	mov	r19,r22
 1809c3c:	10c00015 	stw	r3,0(r2)
 1809c40:	a8c00117 	ldw	r3,4(r21)
 1809c44:	10c00115 	stw	r3,4(r2)
 1809c48:	a8c00217 	ldw	r3,8(r21)
 1809c4c:	10c00215 	stw	r3,8(r2)
 1809c50:	003f6a06 	br	18099fc <__ram_exceptions_end+0xff7f95b8>
 1809c54:	9c67883a 	add	r19,r19,r17
 1809c58:	4445c83a 	sub	r2,r8,r17
 1809c5c:	e4c00215 	stw	r19,8(fp)
 1809c60:	10800054 	ori	r2,r2,1
 1809c64:	98800115 	stw	r2,4(r19)
 1809c68:	a8bfff17 	ldw	r2,-4(r21)
 1809c6c:	a009883a 	mov	r4,r20
 1809c70:	1080004c 	andi	r2,r2,1
 1809c74:	1462b03a 	or	r17,r2,r17
 1809c78:	ac7fff15 	stw	r17,-4(r21)
 1809c7c:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1809c80:	a805883a 	mov	r2,r21
 1809c84:	003f6b06 	br	1809a34 <__ram_exceptions_end+0xff7f95f0>
 1809c88:	a80b883a 	mov	r5,r21
 1809c8c:	9009883a 	mov	r4,r18
 1809c90:	18097080 	call	1809708 <memmove>
 1809c94:	003f4e06 	br	18099d0 <__ram_exceptions_end+0xff7f958c>
 1809c98:	89000404 	addi	r4,r17,16
 1809c9c:	b93fbc16 	blt	r23,r4,1809b90 <__ram_exceptions_end+0xff7f974c>
 1809ca0:	b0800317 	ldw	r2,12(r22)
 1809ca4:	b0c00217 	ldw	r3,8(r22)
 1809ca8:	81bfff04 	addi	r6,r16,-4
 1809cac:	01000904 	movi	r4,36
 1809cb0:	18800315 	stw	r2,12(r3)
 1809cb4:	10c00215 	stw	r3,8(r2)
 1809cb8:	b4800204 	addi	r18,r22,8
 1809cbc:	21804336 	bltu	r4,r6,1809dcc <_realloc_r+0x508>
 1809cc0:	008004c4 	movi	r2,19
 1809cc4:	11803f2e 	bgeu	r2,r6,1809dc4 <_realloc_r+0x500>
 1809cc8:	a8800017 	ldw	r2,0(r21)
 1809ccc:	b0800215 	stw	r2,8(r22)
 1809cd0:	a8800117 	ldw	r2,4(r21)
 1809cd4:	b0800315 	stw	r2,12(r22)
 1809cd8:	008006c4 	movi	r2,27
 1809cdc:	11803f36 	bltu	r2,r6,1809ddc <_realloc_r+0x518>
 1809ce0:	b0800404 	addi	r2,r22,16
 1809ce4:	ad400204 	addi	r21,r21,8
 1809ce8:	a8c00017 	ldw	r3,0(r21)
 1809cec:	10c00015 	stw	r3,0(r2)
 1809cf0:	a8c00117 	ldw	r3,4(r21)
 1809cf4:	10c00115 	stw	r3,4(r2)
 1809cf8:	a8c00217 	ldw	r3,8(r21)
 1809cfc:	10c00215 	stw	r3,8(r2)
 1809d00:	b447883a 	add	r3,r22,r17
 1809d04:	bc45c83a 	sub	r2,r23,r17
 1809d08:	e0c00215 	stw	r3,8(fp)
 1809d0c:	10800054 	ori	r2,r2,1
 1809d10:	18800115 	stw	r2,4(r3)
 1809d14:	b0800117 	ldw	r2,4(r22)
 1809d18:	a009883a 	mov	r4,r20
 1809d1c:	1080004c 	andi	r2,r2,1
 1809d20:	1462b03a 	or	r17,r2,r17
 1809d24:	b4400115 	stw	r17,4(r22)
 1809d28:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1809d2c:	9005883a 	mov	r2,r18
 1809d30:	003f4006 	br	1809a34 <__ram_exceptions_end+0xff7f95f0>
 1809d34:	a8c00217 	ldw	r3,8(r21)
 1809d38:	90c00215 	stw	r3,8(r18)
 1809d3c:	a8c00317 	ldw	r3,12(r21)
 1809d40:	90c00315 	stw	r3,12(r18)
 1809d44:	30801126 	beq	r6,r2,1809d8c <_realloc_r+0x4c8>
 1809d48:	90800404 	addi	r2,r18,16
 1809d4c:	a8c00404 	addi	r3,r21,16
 1809d50:	003f1906 	br	18099b8 <__ram_exceptions_end+0xff7f9574>
 1809d54:	90ffff17 	ldw	r3,-4(r18)
 1809d58:	00bfff04 	movi	r2,-4
 1809d5c:	a825883a 	mov	r18,r21
 1809d60:	1884703a 	and	r2,r3,r2
 1809d64:	80a1883a 	add	r16,r16,r2
 1809d68:	003f2406 	br	18099fc <__ram_exceptions_end+0xff7f95b8>
 1809d6c:	a8800217 	ldw	r2,8(r21)
 1809d70:	b0800415 	stw	r2,16(r22)
 1809d74:	a8800317 	ldw	r2,12(r21)
 1809d78:	b0800515 	stw	r2,20(r22)
 1809d7c:	31000a26 	beq	r6,r4,1809da8 <_realloc_r+0x4e4>
 1809d80:	b0800604 	addi	r2,r22,24
 1809d84:	ad400404 	addi	r21,r21,16
 1809d88:	003fa906 	br	1809c30 <__ram_exceptions_end+0xff7f97ec>
 1809d8c:	a9000417 	ldw	r4,16(r21)
 1809d90:	90800604 	addi	r2,r18,24
 1809d94:	a8c00604 	addi	r3,r21,24
 1809d98:	91000415 	stw	r4,16(r18)
 1809d9c:	a9000517 	ldw	r4,20(r21)
 1809da0:	91000515 	stw	r4,20(r18)
 1809da4:	003f0406 	br	18099b8 <__ram_exceptions_end+0xff7f9574>
 1809da8:	a8c00417 	ldw	r3,16(r21)
 1809dac:	ad400604 	addi	r21,r21,24
 1809db0:	b0800804 	addi	r2,r22,32
 1809db4:	b0c00615 	stw	r3,24(r22)
 1809db8:	a8ffff17 	ldw	r3,-4(r21)
 1809dbc:	b0c00715 	stw	r3,28(r22)
 1809dc0:	003f9b06 	br	1809c30 <__ram_exceptions_end+0xff7f97ec>
 1809dc4:	9005883a 	mov	r2,r18
 1809dc8:	003fc706 	br	1809ce8 <__ram_exceptions_end+0xff7f98a4>
 1809dcc:	a80b883a 	mov	r5,r21
 1809dd0:	9009883a 	mov	r4,r18
 1809dd4:	18097080 	call	1809708 <memmove>
 1809dd8:	003fc906 	br	1809d00 <__ram_exceptions_end+0xff7f98bc>
 1809ddc:	a8800217 	ldw	r2,8(r21)
 1809de0:	b0800415 	stw	r2,16(r22)
 1809de4:	a8800317 	ldw	r2,12(r21)
 1809de8:	b0800515 	stw	r2,20(r22)
 1809dec:	31000726 	beq	r6,r4,1809e0c <_realloc_r+0x548>
 1809df0:	b0800604 	addi	r2,r22,24
 1809df4:	ad400404 	addi	r21,r21,16
 1809df8:	003fbb06 	br	1809ce8 <__ram_exceptions_end+0xff7f98a4>
 1809dfc:	a009883a 	mov	r4,r20
 1809e00:	180d5ac0 	call	180d5ac <__malloc_unlock>
 1809e04:	0005883a 	mov	r2,zero
 1809e08:	003f0a06 	br	1809a34 <__ram_exceptions_end+0xff7f95f0>
 1809e0c:	a8c00417 	ldw	r3,16(r21)
 1809e10:	ad400604 	addi	r21,r21,24
 1809e14:	b0800804 	addi	r2,r22,32
 1809e18:	b0c00615 	stw	r3,24(r22)
 1809e1c:	a8ffff17 	ldw	r3,-4(r21)
 1809e20:	b0c00715 	stw	r3,28(r22)
 1809e24:	003fb006 	br	1809ce8 <__ram_exceptions_end+0xff7f98a4>

01809e28 <__swbuf_r>:
 1809e28:	defffb04 	addi	sp,sp,-20
 1809e2c:	dcc00315 	stw	r19,12(sp)
 1809e30:	dc800215 	stw	r18,8(sp)
 1809e34:	dc000015 	stw	r16,0(sp)
 1809e38:	dfc00415 	stw	ra,16(sp)
 1809e3c:	dc400115 	stw	r17,4(sp)
 1809e40:	2025883a 	mov	r18,r4
 1809e44:	2827883a 	mov	r19,r5
 1809e48:	3021883a 	mov	r16,r6
 1809e4c:	20000226 	beq	r4,zero,1809e58 <__swbuf_r+0x30>
 1809e50:	20800e17 	ldw	r2,56(r4)
 1809e54:	10004226 	beq	r2,zero,1809f60 <__swbuf_r+0x138>
 1809e58:	80800617 	ldw	r2,24(r16)
 1809e5c:	8100030b 	ldhu	r4,12(r16)
 1809e60:	80800215 	stw	r2,8(r16)
 1809e64:	2080020c 	andi	r2,r4,8
 1809e68:	10003626 	beq	r2,zero,1809f44 <__swbuf_r+0x11c>
 1809e6c:	80c00417 	ldw	r3,16(r16)
 1809e70:	18003426 	beq	r3,zero,1809f44 <__swbuf_r+0x11c>
 1809e74:	2088000c 	andi	r2,r4,8192
 1809e78:	9c403fcc 	andi	r17,r19,255
 1809e7c:	10001a26 	beq	r2,zero,1809ee8 <__swbuf_r+0xc0>
 1809e80:	80800017 	ldw	r2,0(r16)
 1809e84:	81000517 	ldw	r4,20(r16)
 1809e88:	10c7c83a 	sub	r3,r2,r3
 1809e8c:	1900200e 	bge	r3,r4,1809f10 <__swbuf_r+0xe8>
 1809e90:	18c00044 	addi	r3,r3,1
 1809e94:	81000217 	ldw	r4,8(r16)
 1809e98:	11400044 	addi	r5,r2,1
 1809e9c:	81400015 	stw	r5,0(r16)
 1809ea0:	213fffc4 	addi	r4,r4,-1
 1809ea4:	81000215 	stw	r4,8(r16)
 1809ea8:	14c00005 	stb	r19,0(r2)
 1809eac:	80800517 	ldw	r2,20(r16)
 1809eb0:	10c01e26 	beq	r2,r3,1809f2c <__swbuf_r+0x104>
 1809eb4:	8080030b 	ldhu	r2,12(r16)
 1809eb8:	1080004c 	andi	r2,r2,1
 1809ebc:	10000226 	beq	r2,zero,1809ec8 <__swbuf_r+0xa0>
 1809ec0:	00800284 	movi	r2,10
 1809ec4:	88801926 	beq	r17,r2,1809f2c <__swbuf_r+0x104>
 1809ec8:	8805883a 	mov	r2,r17
 1809ecc:	dfc00417 	ldw	ra,16(sp)
 1809ed0:	dcc00317 	ldw	r19,12(sp)
 1809ed4:	dc800217 	ldw	r18,8(sp)
 1809ed8:	dc400117 	ldw	r17,4(sp)
 1809edc:	dc000017 	ldw	r16,0(sp)
 1809ee0:	dec00504 	addi	sp,sp,20
 1809ee4:	f800283a 	ret
 1809ee8:	81401917 	ldw	r5,100(r16)
 1809eec:	00b7ffc4 	movi	r2,-8193
 1809ef0:	21080014 	ori	r4,r4,8192
 1809ef4:	2884703a 	and	r2,r5,r2
 1809ef8:	80801915 	stw	r2,100(r16)
 1809efc:	80800017 	ldw	r2,0(r16)
 1809f00:	8100030d 	sth	r4,12(r16)
 1809f04:	81000517 	ldw	r4,20(r16)
 1809f08:	10c7c83a 	sub	r3,r2,r3
 1809f0c:	193fe016 	blt	r3,r4,1809e90 <__ram_exceptions_end+0xff7f9a4c>
 1809f10:	800b883a 	mov	r5,r16
 1809f14:	9009883a 	mov	r4,r18
 1809f18:	1804b1c0 	call	1804b1c <_fflush_r>
 1809f1c:	1000071e 	bne	r2,zero,1809f3c <__swbuf_r+0x114>
 1809f20:	80800017 	ldw	r2,0(r16)
 1809f24:	00c00044 	movi	r3,1
 1809f28:	003fda06 	br	1809e94 <__ram_exceptions_end+0xff7f9a50>
 1809f2c:	800b883a 	mov	r5,r16
 1809f30:	9009883a 	mov	r4,r18
 1809f34:	1804b1c0 	call	1804b1c <_fflush_r>
 1809f38:	103fe326 	beq	r2,zero,1809ec8 <__ram_exceptions_end+0xff7f9a84>
 1809f3c:	00bfffc4 	movi	r2,-1
 1809f40:	003fe206 	br	1809ecc <__ram_exceptions_end+0xff7f9a88>
 1809f44:	800b883a 	mov	r5,r16
 1809f48:	9009883a 	mov	r4,r18
 1809f4c:	1802f240 	call	1802f24 <__swsetup_r>
 1809f50:	103ffa1e 	bne	r2,zero,1809f3c <__ram_exceptions_end+0xff7f9af8>
 1809f54:	8100030b 	ldhu	r4,12(r16)
 1809f58:	80c00417 	ldw	r3,16(r16)
 1809f5c:	003fc506 	br	1809e74 <__ram_exceptions_end+0xff7f9a30>
 1809f60:	1804ef80 	call	1804ef8 <__sinit>
 1809f64:	003fbc06 	br	1809e58 <__ram_exceptions_end+0xff7f9a14>

01809f68 <__swbuf>:
 1809f68:	00806134 	movhi	r2,388
 1809f6c:	10975504 	addi	r2,r2,23892
 1809f70:	280d883a 	mov	r6,r5
 1809f74:	200b883a 	mov	r5,r4
 1809f78:	11000017 	ldw	r4,0(r2)
 1809f7c:	1809e281 	jmpi	1809e28 <__swbuf_r>

01809f80 <_wcrtomb_r>:
 1809f80:	defff604 	addi	sp,sp,-40
 1809f84:	00806134 	movhi	r2,388
 1809f88:	dc800815 	stw	r18,32(sp)
 1809f8c:	dc400715 	stw	r17,28(sp)
 1809f90:	dc000615 	stw	r16,24(sp)
 1809f94:	10975904 	addi	r2,r2,23908
 1809f98:	dfc00915 	stw	ra,36(sp)
 1809f9c:	2021883a 	mov	r16,r4
 1809fa0:	3823883a 	mov	r17,r7
 1809fa4:	14800017 	ldw	r18,0(r2)
 1809fa8:	28001426 	beq	r5,zero,1809ffc <_wcrtomb_r+0x7c>
 1809fac:	d9400415 	stw	r5,16(sp)
 1809fb0:	d9800515 	stw	r6,20(sp)
 1809fb4:	18055800 	call	1805580 <__locale_charset>
 1809fb8:	d9800517 	ldw	r6,20(sp)
 1809fbc:	d9400417 	ldw	r5,16(sp)
 1809fc0:	100f883a 	mov	r7,r2
 1809fc4:	dc400015 	stw	r17,0(sp)
 1809fc8:	8009883a 	mov	r4,r16
 1809fcc:	903ee83a 	callr	r18
 1809fd0:	00ffffc4 	movi	r3,-1
 1809fd4:	10c0031e 	bne	r2,r3,1809fe4 <_wcrtomb_r+0x64>
 1809fd8:	88000015 	stw	zero,0(r17)
 1809fdc:	00c02284 	movi	r3,138
 1809fe0:	80c00015 	stw	r3,0(r16)
 1809fe4:	dfc00917 	ldw	ra,36(sp)
 1809fe8:	dc800817 	ldw	r18,32(sp)
 1809fec:	dc400717 	ldw	r17,28(sp)
 1809ff0:	dc000617 	ldw	r16,24(sp)
 1809ff4:	dec00a04 	addi	sp,sp,40
 1809ff8:	f800283a 	ret
 1809ffc:	18055800 	call	1805580 <__locale_charset>
 180a000:	100f883a 	mov	r7,r2
 180a004:	dc400015 	stw	r17,0(sp)
 180a008:	000d883a 	mov	r6,zero
 180a00c:	d9400104 	addi	r5,sp,4
 180a010:	8009883a 	mov	r4,r16
 180a014:	903ee83a 	callr	r18
 180a018:	003fed06 	br	1809fd0 <__ram_exceptions_end+0xff7f9b8c>

0180a01c <wcrtomb>:
 180a01c:	defff604 	addi	sp,sp,-40
 180a020:	00806134 	movhi	r2,388
 180a024:	dc800615 	stw	r18,24(sp)
 180a028:	dc400515 	stw	r17,20(sp)
 180a02c:	10975504 	addi	r2,r2,23892
 180a030:	dfc00915 	stw	ra,36(sp)
 180a034:	dd000815 	stw	r20,32(sp)
 180a038:	dcc00715 	stw	r19,28(sp)
 180a03c:	dc000415 	stw	r16,16(sp)
 180a040:	3025883a 	mov	r18,r6
 180a044:	14400017 	ldw	r17,0(r2)
 180a048:	20001926 	beq	r4,zero,180a0b0 <wcrtomb+0x94>
 180a04c:	00806134 	movhi	r2,388
 180a050:	10975904 	addi	r2,r2,23908
 180a054:	15000017 	ldw	r20,0(r2)
 180a058:	2021883a 	mov	r16,r4
 180a05c:	2827883a 	mov	r19,r5
 180a060:	18055800 	call	1805580 <__locale_charset>
 180a064:	100f883a 	mov	r7,r2
 180a068:	dc800015 	stw	r18,0(sp)
 180a06c:	980d883a 	mov	r6,r19
 180a070:	800b883a 	mov	r5,r16
 180a074:	8809883a 	mov	r4,r17
 180a078:	a03ee83a 	callr	r20
 180a07c:	00ffffc4 	movi	r3,-1
 180a080:	10c0031e 	bne	r2,r3,180a090 <wcrtomb+0x74>
 180a084:	90000015 	stw	zero,0(r18)
 180a088:	00c02284 	movi	r3,138
 180a08c:	88c00015 	stw	r3,0(r17)
 180a090:	dfc00917 	ldw	ra,36(sp)
 180a094:	dd000817 	ldw	r20,32(sp)
 180a098:	dcc00717 	ldw	r19,28(sp)
 180a09c:	dc800617 	ldw	r18,24(sp)
 180a0a0:	dc400517 	ldw	r17,20(sp)
 180a0a4:	dc000417 	ldw	r16,16(sp)
 180a0a8:	dec00a04 	addi	sp,sp,40
 180a0ac:	f800283a 	ret
 180a0b0:	00806134 	movhi	r2,388
 180a0b4:	10975904 	addi	r2,r2,23908
 180a0b8:	14000017 	ldw	r16,0(r2)
 180a0bc:	18055800 	call	1805580 <__locale_charset>
 180a0c0:	100f883a 	mov	r7,r2
 180a0c4:	dc800015 	stw	r18,0(sp)
 180a0c8:	000d883a 	mov	r6,zero
 180a0cc:	d9400104 	addi	r5,sp,4
 180a0d0:	8809883a 	mov	r4,r17
 180a0d4:	803ee83a 	callr	r16
 180a0d8:	003fe806 	br	180a07c <__ram_exceptions_end+0xff7f9c38>

0180a0dc <__ascii_wctomb>:
 180a0dc:	28000526 	beq	r5,zero,180a0f4 <__ascii_wctomb+0x18>
 180a0e0:	00803fc4 	movi	r2,255
 180a0e4:	11800536 	bltu	r2,r6,180a0fc <__ascii_wctomb+0x20>
 180a0e8:	29800005 	stb	r6,0(r5)
 180a0ec:	00800044 	movi	r2,1
 180a0f0:	f800283a 	ret
 180a0f4:	0005883a 	mov	r2,zero
 180a0f8:	f800283a 	ret
 180a0fc:	00802284 	movi	r2,138
 180a100:	20800015 	stw	r2,0(r4)
 180a104:	00bfffc4 	movi	r2,-1
 180a108:	f800283a 	ret

0180a10c <_wctomb_r>:
 180a10c:	00806134 	movhi	r2,388
 180a110:	defff904 	addi	sp,sp,-28
 180a114:	10975904 	addi	r2,r2,23908
 180a118:	dfc00615 	stw	ra,24(sp)
 180a11c:	dc400515 	stw	r17,20(sp)
 180a120:	dc000415 	stw	r16,16(sp)
 180a124:	3823883a 	mov	r17,r7
 180a128:	14000017 	ldw	r16,0(r2)
 180a12c:	d9000115 	stw	r4,4(sp)
 180a130:	d9400215 	stw	r5,8(sp)
 180a134:	d9800315 	stw	r6,12(sp)
 180a138:	18055800 	call	1805580 <__locale_charset>
 180a13c:	d9800317 	ldw	r6,12(sp)
 180a140:	d9400217 	ldw	r5,8(sp)
 180a144:	d9000117 	ldw	r4,4(sp)
 180a148:	100f883a 	mov	r7,r2
 180a14c:	dc400015 	stw	r17,0(sp)
 180a150:	803ee83a 	callr	r16
 180a154:	dfc00617 	ldw	ra,24(sp)
 180a158:	dc400517 	ldw	r17,20(sp)
 180a15c:	dc000417 	ldw	r16,16(sp)
 180a160:	dec00704 	addi	sp,sp,28
 180a164:	f800283a 	ret

0180a168 <__udivdi3>:
 180a168:	defff504 	addi	sp,sp,-44
 180a16c:	dcc00415 	stw	r19,16(sp)
 180a170:	dc000115 	stw	r16,4(sp)
 180a174:	dfc00a15 	stw	ra,40(sp)
 180a178:	df000915 	stw	fp,36(sp)
 180a17c:	ddc00815 	stw	r23,32(sp)
 180a180:	dd800715 	stw	r22,28(sp)
 180a184:	dd400615 	stw	r21,24(sp)
 180a188:	dd000515 	stw	r20,20(sp)
 180a18c:	dc800315 	stw	r18,12(sp)
 180a190:	dc400215 	stw	r17,8(sp)
 180a194:	2027883a 	mov	r19,r4
 180a198:	2821883a 	mov	r16,r5
 180a19c:	3800411e 	bne	r7,zero,180a2a4 <__udivdi3+0x13c>
 180a1a0:	3023883a 	mov	r17,r6
 180a1a4:	2025883a 	mov	r18,r4
 180a1a8:	2980522e 	bgeu	r5,r6,180a2f4 <__udivdi3+0x18c>
 180a1ac:	00bfffd4 	movui	r2,65535
 180a1b0:	282d883a 	mov	r22,r5
 180a1b4:	1180a836 	bltu	r2,r6,180a458 <__udivdi3+0x2f0>
 180a1b8:	00803fc4 	movi	r2,255
 180a1bc:	1185803a 	cmpltu	r2,r2,r6
 180a1c0:	100490fa 	slli	r2,r2,3
 180a1c4:	3086d83a 	srl	r3,r6,r2
 180a1c8:	01006134 	movhi	r4,388
 180a1cc:	21054f04 	addi	r4,r4,5436
 180a1d0:	20c7883a 	add	r3,r4,r3
 180a1d4:	18c00003 	ldbu	r3,0(r3)
 180a1d8:	1885883a 	add	r2,r3,r2
 180a1dc:	00c00804 	movi	r3,32
 180a1e0:	1887c83a 	sub	r3,r3,r2
 180a1e4:	18000526 	beq	r3,zero,180a1fc <__udivdi3+0x94>
 180a1e8:	80e0983a 	sll	r16,r16,r3
 180a1ec:	9884d83a 	srl	r2,r19,r2
 180a1f0:	30e2983a 	sll	r17,r6,r3
 180a1f4:	98e4983a 	sll	r18,r19,r3
 180a1f8:	142cb03a 	or	r22,r2,r16
 180a1fc:	882ad43a 	srli	r21,r17,16
 180a200:	b009883a 	mov	r4,r22
 180a204:	8d3fffcc 	andi	r20,r17,65535
 180a208:	a80b883a 	mov	r5,r21
 180a20c:	180ad740 	call	180ad74 <__umodsi3>
 180a210:	b009883a 	mov	r4,r22
 180a214:	a80b883a 	mov	r5,r21
 180a218:	1027883a 	mov	r19,r2
 180a21c:	180ad100 	call	180ad10 <__udivsi3>
 180a220:	102d883a 	mov	r22,r2
 180a224:	9826943a 	slli	r19,r19,16
 180a228:	9004d43a 	srli	r2,r18,16
 180a22c:	a5a1383a 	mul	r16,r20,r22
 180a230:	14c4b03a 	or	r2,r2,r19
 180a234:	1400052e 	bgeu	r2,r16,180a24c <__udivdi3+0xe4>
 180a238:	1445883a 	add	r2,r2,r17
 180a23c:	b0ffffc4 	addi	r3,r22,-1
 180a240:	14400136 	bltu	r2,r17,180a248 <__udivdi3+0xe0>
 180a244:	14012336 	bltu	r2,r16,180a6d4 <__udivdi3+0x56c>
 180a248:	182d883a 	mov	r22,r3
 180a24c:	1421c83a 	sub	r16,r2,r16
 180a250:	a80b883a 	mov	r5,r21
 180a254:	8009883a 	mov	r4,r16
 180a258:	180ad740 	call	180ad74 <__umodsi3>
 180a25c:	1027883a 	mov	r19,r2
 180a260:	a80b883a 	mov	r5,r21
 180a264:	8009883a 	mov	r4,r16
 180a268:	180ad100 	call	180ad10 <__udivsi3>
 180a26c:	9826943a 	slli	r19,r19,16
 180a270:	a0a9383a 	mul	r20,r20,r2
 180a274:	94bfffcc 	andi	r18,r18,65535
 180a278:	94e4b03a 	or	r18,r18,r19
 180a27c:	9500052e 	bgeu	r18,r20,180a294 <__udivdi3+0x12c>
 180a280:	8ca5883a 	add	r18,r17,r18
 180a284:	10ffffc4 	addi	r3,r2,-1
 180a288:	9440f136 	bltu	r18,r17,180a650 <__udivdi3+0x4e8>
 180a28c:	9500f02e 	bgeu	r18,r20,180a650 <__udivdi3+0x4e8>
 180a290:	10bfff84 	addi	r2,r2,-2
 180a294:	b00c943a 	slli	r6,r22,16
 180a298:	0007883a 	mov	r3,zero
 180a29c:	3084b03a 	or	r2,r6,r2
 180a2a0:	00005906 	br	180a408 <__udivdi3+0x2a0>
 180a2a4:	29c05636 	bltu	r5,r7,180a400 <__udivdi3+0x298>
 180a2a8:	00bfffd4 	movui	r2,65535
 180a2ac:	11c0622e 	bgeu	r2,r7,180a438 <__udivdi3+0x2d0>
 180a2b0:	00804034 	movhi	r2,256
 180a2b4:	10bfffc4 	addi	r2,r2,-1
 180a2b8:	11c0ee36 	bltu	r2,r7,180a674 <__udivdi3+0x50c>
 180a2bc:	00800404 	movi	r2,16
 180a2c0:	3886d83a 	srl	r3,r7,r2
 180a2c4:	01006134 	movhi	r4,388
 180a2c8:	21054f04 	addi	r4,r4,5436
 180a2cc:	20c7883a 	add	r3,r4,r3
 180a2d0:	18c00003 	ldbu	r3,0(r3)
 180a2d4:	05400804 	movi	r21,32
 180a2d8:	1885883a 	add	r2,r3,r2
 180a2dc:	a8abc83a 	sub	r21,r21,r2
 180a2e0:	a800621e 	bne	r21,zero,180a46c <__udivdi3+0x304>
 180a2e4:	3c00e936 	bltu	r7,r16,180a68c <__udivdi3+0x524>
 180a2e8:	9985403a 	cmpgeu	r2,r19,r6
 180a2ec:	0007883a 	mov	r3,zero
 180a2f0:	00004506 	br	180a408 <__udivdi3+0x2a0>
 180a2f4:	3000041e 	bne	r6,zero,180a308 <__udivdi3+0x1a0>
 180a2f8:	000b883a 	mov	r5,zero
 180a2fc:	01000044 	movi	r4,1
 180a300:	180ad100 	call	180ad10 <__udivsi3>
 180a304:	1023883a 	mov	r17,r2
 180a308:	00bfffd4 	movui	r2,65535
 180a30c:	14404e2e 	bgeu	r2,r17,180a448 <__udivdi3+0x2e0>
 180a310:	00804034 	movhi	r2,256
 180a314:	10bfffc4 	addi	r2,r2,-1
 180a318:	1440d836 	bltu	r2,r17,180a67c <__udivdi3+0x514>
 180a31c:	00800404 	movi	r2,16
 180a320:	8886d83a 	srl	r3,r17,r2
 180a324:	01006134 	movhi	r4,388
 180a328:	21054f04 	addi	r4,r4,5436
 180a32c:	20c7883a 	add	r3,r4,r3
 180a330:	18c00003 	ldbu	r3,0(r3)
 180a334:	1885883a 	add	r2,r3,r2
 180a338:	00c00804 	movi	r3,32
 180a33c:	1887c83a 	sub	r3,r3,r2
 180a340:	18008f1e 	bne	r3,zero,180a580 <__udivdi3+0x418>
 180a344:	882ad43a 	srli	r21,r17,16
 180a348:	8461c83a 	sub	r16,r16,r17
 180a34c:	8d3fffcc 	andi	r20,r17,65535
 180a350:	00c00044 	movi	r3,1
 180a354:	8009883a 	mov	r4,r16
 180a358:	a80b883a 	mov	r5,r21
 180a35c:	d8c00015 	stw	r3,0(sp)
 180a360:	180ad740 	call	180ad74 <__umodsi3>
 180a364:	8009883a 	mov	r4,r16
 180a368:	a80b883a 	mov	r5,r21
 180a36c:	1027883a 	mov	r19,r2
 180a370:	180ad100 	call	180ad10 <__udivsi3>
 180a374:	9826943a 	slli	r19,r19,16
 180a378:	9008d43a 	srli	r4,r18,16
 180a37c:	1521383a 	mul	r16,r2,r20
 180a380:	102d883a 	mov	r22,r2
 180a384:	24c8b03a 	or	r4,r4,r19
 180a388:	d8c00017 	ldw	r3,0(sp)
 180a38c:	2400052e 	bgeu	r4,r16,180a3a4 <__udivdi3+0x23c>
 180a390:	2449883a 	add	r4,r4,r17
 180a394:	b0bfffc4 	addi	r2,r22,-1
 180a398:	24400136 	bltu	r4,r17,180a3a0 <__udivdi3+0x238>
 180a39c:	2400ca36 	bltu	r4,r16,180a6c8 <__udivdi3+0x560>
 180a3a0:	102d883a 	mov	r22,r2
 180a3a4:	2421c83a 	sub	r16,r4,r16
 180a3a8:	a80b883a 	mov	r5,r21
 180a3ac:	8009883a 	mov	r4,r16
 180a3b0:	d8c00015 	stw	r3,0(sp)
 180a3b4:	180ad740 	call	180ad74 <__umodsi3>
 180a3b8:	1027883a 	mov	r19,r2
 180a3bc:	a80b883a 	mov	r5,r21
 180a3c0:	8009883a 	mov	r4,r16
 180a3c4:	180ad100 	call	180ad10 <__udivsi3>
 180a3c8:	9826943a 	slli	r19,r19,16
 180a3cc:	1529383a 	mul	r20,r2,r20
 180a3d0:	94bfffcc 	andi	r18,r18,65535
 180a3d4:	94e4b03a 	or	r18,r18,r19
 180a3d8:	d8c00017 	ldw	r3,0(sp)
 180a3dc:	9500052e 	bgeu	r18,r20,180a3f4 <__udivdi3+0x28c>
 180a3e0:	8ca5883a 	add	r18,r17,r18
 180a3e4:	113fffc4 	addi	r4,r2,-1
 180a3e8:	94409736 	bltu	r18,r17,180a648 <__udivdi3+0x4e0>
 180a3ec:	9500962e 	bgeu	r18,r20,180a648 <__udivdi3+0x4e0>
 180a3f0:	10bfff84 	addi	r2,r2,-2
 180a3f4:	b00c943a 	slli	r6,r22,16
 180a3f8:	3084b03a 	or	r2,r6,r2
 180a3fc:	00000206 	br	180a408 <__udivdi3+0x2a0>
 180a400:	0007883a 	mov	r3,zero
 180a404:	0005883a 	mov	r2,zero
 180a408:	dfc00a17 	ldw	ra,40(sp)
 180a40c:	df000917 	ldw	fp,36(sp)
 180a410:	ddc00817 	ldw	r23,32(sp)
 180a414:	dd800717 	ldw	r22,28(sp)
 180a418:	dd400617 	ldw	r21,24(sp)
 180a41c:	dd000517 	ldw	r20,20(sp)
 180a420:	dcc00417 	ldw	r19,16(sp)
 180a424:	dc800317 	ldw	r18,12(sp)
 180a428:	dc400217 	ldw	r17,8(sp)
 180a42c:	dc000117 	ldw	r16,4(sp)
 180a430:	dec00b04 	addi	sp,sp,44
 180a434:	f800283a 	ret
 180a438:	00803fc4 	movi	r2,255
 180a43c:	11c5803a 	cmpltu	r2,r2,r7
 180a440:	100490fa 	slli	r2,r2,3
 180a444:	003f9e06 	br	180a2c0 <__ram_exceptions_end+0xff7f9e7c>
 180a448:	00803fc4 	movi	r2,255
 180a44c:	1445803a 	cmpltu	r2,r2,r17
 180a450:	100490fa 	slli	r2,r2,3
 180a454:	003fb206 	br	180a320 <__ram_exceptions_end+0xff7f9edc>
 180a458:	00804034 	movhi	r2,256
 180a45c:	10bfffc4 	addi	r2,r2,-1
 180a460:	11808836 	bltu	r2,r6,180a684 <__udivdi3+0x51c>
 180a464:	00800404 	movi	r2,16
 180a468:	003f5606 	br	180a1c4 <__ram_exceptions_end+0xff7f9d80>
 180a46c:	30aed83a 	srl	r23,r6,r2
 180a470:	3d4e983a 	sll	r7,r7,r21
 180a474:	80acd83a 	srl	r22,r16,r2
 180a478:	9884d83a 	srl	r2,r19,r2
 180a47c:	3deeb03a 	or	r23,r7,r23
 180a480:	b824d43a 	srli	r18,r23,16
 180a484:	8560983a 	sll	r16,r16,r21
 180a488:	b009883a 	mov	r4,r22
 180a48c:	900b883a 	mov	r5,r18
 180a490:	3568983a 	sll	r20,r6,r21
 180a494:	1420b03a 	or	r16,r2,r16
 180a498:	180ad740 	call	180ad74 <__umodsi3>
 180a49c:	b009883a 	mov	r4,r22
 180a4a0:	900b883a 	mov	r5,r18
 180a4a4:	1023883a 	mov	r17,r2
 180a4a8:	180ad100 	call	180ad10 <__udivsi3>
 180a4ac:	8808943a 	slli	r4,r17,16
 180a4b0:	bf3fffcc 	andi	fp,r23,65535
 180a4b4:	8006d43a 	srli	r3,r16,16
 180a4b8:	e0a3383a 	mul	r17,fp,r2
 180a4bc:	100d883a 	mov	r6,r2
 180a4c0:	1906b03a 	or	r3,r3,r4
 180a4c4:	1c40042e 	bgeu	r3,r17,180a4d8 <__udivdi3+0x370>
 180a4c8:	1dc7883a 	add	r3,r3,r23
 180a4cc:	10bfffc4 	addi	r2,r2,-1
 180a4d0:	1dc0752e 	bgeu	r3,r23,180a6a8 <__udivdi3+0x540>
 180a4d4:	100d883a 	mov	r6,r2
 180a4d8:	1c63c83a 	sub	r17,r3,r17
 180a4dc:	900b883a 	mov	r5,r18
 180a4e0:	8809883a 	mov	r4,r17
 180a4e4:	d9800015 	stw	r6,0(sp)
 180a4e8:	180ad740 	call	180ad74 <__umodsi3>
 180a4ec:	102d883a 	mov	r22,r2
 180a4f0:	8809883a 	mov	r4,r17
 180a4f4:	900b883a 	mov	r5,r18
 180a4f8:	180ad100 	call	180ad10 <__udivsi3>
 180a4fc:	b02c943a 	slli	r22,r22,16
 180a500:	e089383a 	mul	r4,fp,r2
 180a504:	843fffcc 	andi	r16,r16,65535
 180a508:	85a0b03a 	or	r16,r16,r22
 180a50c:	d9800017 	ldw	r6,0(sp)
 180a510:	8100042e 	bgeu	r16,r4,180a524 <__udivdi3+0x3bc>
 180a514:	85e1883a 	add	r16,r16,r23
 180a518:	10ffffc4 	addi	r3,r2,-1
 180a51c:	85c05e2e 	bgeu	r16,r23,180a698 <__udivdi3+0x530>
 180a520:	1805883a 	mov	r2,r3
 180a524:	300c943a 	slli	r6,r6,16
 180a528:	a17fffcc 	andi	r5,r20,65535
 180a52c:	a028d43a 	srli	r20,r20,16
 180a530:	3084b03a 	or	r2,r6,r2
 180a534:	10ffffcc 	andi	r3,r2,65535
 180a538:	100cd43a 	srli	r6,r2,16
 180a53c:	194f383a 	mul	r7,r3,r5
 180a540:	1d07383a 	mul	r3,r3,r20
 180a544:	314b383a 	mul	r5,r6,r5
 180a548:	3810d43a 	srli	r8,r7,16
 180a54c:	8121c83a 	sub	r16,r16,r4
 180a550:	1947883a 	add	r3,r3,r5
 180a554:	40c7883a 	add	r3,r8,r3
 180a558:	350d383a 	mul	r6,r6,r20
 180a55c:	1940022e 	bgeu	r3,r5,180a568 <__udivdi3+0x400>
 180a560:	01000074 	movhi	r4,1
 180a564:	310d883a 	add	r6,r6,r4
 180a568:	1828d43a 	srli	r20,r3,16
 180a56c:	a18d883a 	add	r6,r20,r6
 180a570:	81803e36 	bltu	r16,r6,180a66c <__udivdi3+0x504>
 180a574:	81803826 	beq	r16,r6,180a658 <__udivdi3+0x4f0>
 180a578:	0007883a 	mov	r3,zero
 180a57c:	003fa206 	br	180a408 <__ram_exceptions_end+0xff7f9fc4>
 180a580:	88e2983a 	sll	r17,r17,r3
 180a584:	80a8d83a 	srl	r20,r16,r2
 180a588:	80e0983a 	sll	r16,r16,r3
 180a58c:	882ad43a 	srli	r21,r17,16
 180a590:	9884d83a 	srl	r2,r19,r2
 180a594:	a009883a 	mov	r4,r20
 180a598:	a80b883a 	mov	r5,r21
 180a59c:	142eb03a 	or	r23,r2,r16
 180a5a0:	98e4983a 	sll	r18,r19,r3
 180a5a4:	180ad740 	call	180ad74 <__umodsi3>
 180a5a8:	a009883a 	mov	r4,r20
 180a5ac:	a80b883a 	mov	r5,r21
 180a5b0:	1021883a 	mov	r16,r2
 180a5b4:	180ad100 	call	180ad10 <__udivsi3>
 180a5b8:	1039883a 	mov	fp,r2
 180a5bc:	8d3fffcc 	andi	r20,r17,65535
 180a5c0:	8020943a 	slli	r16,r16,16
 180a5c4:	b804d43a 	srli	r2,r23,16
 180a5c8:	a72d383a 	mul	r22,r20,fp
 180a5cc:	1404b03a 	or	r2,r2,r16
 180a5d0:	1580062e 	bgeu	r2,r22,180a5ec <__udivdi3+0x484>
 180a5d4:	1445883a 	add	r2,r2,r17
 180a5d8:	e0ffffc4 	addi	r3,fp,-1
 180a5dc:	14403836 	bltu	r2,r17,180a6c0 <__udivdi3+0x558>
 180a5e0:	1580372e 	bgeu	r2,r22,180a6c0 <__udivdi3+0x558>
 180a5e4:	e73fff84 	addi	fp,fp,-2
 180a5e8:	1445883a 	add	r2,r2,r17
 180a5ec:	15adc83a 	sub	r22,r2,r22
 180a5f0:	a80b883a 	mov	r5,r21
 180a5f4:	b009883a 	mov	r4,r22
 180a5f8:	180ad740 	call	180ad74 <__umodsi3>
 180a5fc:	1027883a 	mov	r19,r2
 180a600:	b009883a 	mov	r4,r22
 180a604:	a80b883a 	mov	r5,r21
 180a608:	180ad100 	call	180ad10 <__udivsi3>
 180a60c:	9826943a 	slli	r19,r19,16
 180a610:	a0a1383a 	mul	r16,r20,r2
 180a614:	b93fffcc 	andi	r4,r23,65535
 180a618:	24c8b03a 	or	r4,r4,r19
 180a61c:	2400062e 	bgeu	r4,r16,180a638 <__udivdi3+0x4d0>
 180a620:	2449883a 	add	r4,r4,r17
 180a624:	10ffffc4 	addi	r3,r2,-1
 180a628:	24402336 	bltu	r4,r17,180a6b8 <__udivdi3+0x550>
 180a62c:	2400222e 	bgeu	r4,r16,180a6b8 <__udivdi3+0x550>
 180a630:	10bfff84 	addi	r2,r2,-2
 180a634:	2449883a 	add	r4,r4,r17
 180a638:	e038943a 	slli	fp,fp,16
 180a63c:	2421c83a 	sub	r16,r4,r16
 180a640:	e086b03a 	or	r3,fp,r2
 180a644:	003f4306 	br	180a354 <__ram_exceptions_end+0xff7f9f10>
 180a648:	2005883a 	mov	r2,r4
 180a64c:	003f6906 	br	180a3f4 <__ram_exceptions_end+0xff7f9fb0>
 180a650:	1805883a 	mov	r2,r3
 180a654:	003f0f06 	br	180a294 <__ram_exceptions_end+0xff7f9e50>
 180a658:	1806943a 	slli	r3,r3,16
 180a65c:	9d66983a 	sll	r19,r19,r21
 180a660:	39ffffcc 	andi	r7,r7,65535
 180a664:	19c7883a 	add	r3,r3,r7
 180a668:	98ffc32e 	bgeu	r19,r3,180a578 <__ram_exceptions_end+0xff7fa134>
 180a66c:	10bfffc4 	addi	r2,r2,-1
 180a670:	003fc106 	br	180a578 <__ram_exceptions_end+0xff7fa134>
 180a674:	00800604 	movi	r2,24
 180a678:	003f1106 	br	180a2c0 <__ram_exceptions_end+0xff7f9e7c>
 180a67c:	00800604 	movi	r2,24
 180a680:	003f2706 	br	180a320 <__ram_exceptions_end+0xff7f9edc>
 180a684:	00800604 	movi	r2,24
 180a688:	003ece06 	br	180a1c4 <__ram_exceptions_end+0xff7f9d80>
 180a68c:	0007883a 	mov	r3,zero
 180a690:	00800044 	movi	r2,1
 180a694:	003f5c06 	br	180a408 <__ram_exceptions_end+0xff7f9fc4>
 180a698:	813fa12e 	bgeu	r16,r4,180a520 <__ram_exceptions_end+0xff7fa0dc>
 180a69c:	10bfff84 	addi	r2,r2,-2
 180a6a0:	85e1883a 	add	r16,r16,r23
 180a6a4:	003f9f06 	br	180a524 <__ram_exceptions_end+0xff7fa0e0>
 180a6a8:	1c7f8a2e 	bgeu	r3,r17,180a4d4 <__ram_exceptions_end+0xff7fa090>
 180a6ac:	31bfff84 	addi	r6,r6,-2
 180a6b0:	1dc7883a 	add	r3,r3,r23
 180a6b4:	003f8806 	br	180a4d8 <__ram_exceptions_end+0xff7fa094>
 180a6b8:	1805883a 	mov	r2,r3
 180a6bc:	003fde06 	br	180a638 <__ram_exceptions_end+0xff7fa1f4>
 180a6c0:	1839883a 	mov	fp,r3
 180a6c4:	003fc906 	br	180a5ec <__ram_exceptions_end+0xff7fa1a8>
 180a6c8:	b5bfff84 	addi	r22,r22,-2
 180a6cc:	2449883a 	add	r4,r4,r17
 180a6d0:	003f3406 	br	180a3a4 <__ram_exceptions_end+0xff7f9f60>
 180a6d4:	b5bfff84 	addi	r22,r22,-2
 180a6d8:	1445883a 	add	r2,r2,r17
 180a6dc:	003edb06 	br	180a24c <__ram_exceptions_end+0xff7f9e08>

0180a6e0 <__umoddi3>:
 180a6e0:	defff404 	addi	sp,sp,-48
 180a6e4:	df000a15 	stw	fp,40(sp)
 180a6e8:	dc400315 	stw	r17,12(sp)
 180a6ec:	dc000215 	stw	r16,8(sp)
 180a6f0:	dfc00b15 	stw	ra,44(sp)
 180a6f4:	ddc00915 	stw	r23,36(sp)
 180a6f8:	dd800815 	stw	r22,32(sp)
 180a6fc:	dd400715 	stw	r21,28(sp)
 180a700:	dd000615 	stw	r20,24(sp)
 180a704:	dcc00515 	stw	r19,20(sp)
 180a708:	dc800415 	stw	r18,16(sp)
 180a70c:	2021883a 	mov	r16,r4
 180a710:	2823883a 	mov	r17,r5
 180a714:	2839883a 	mov	fp,r5
 180a718:	38003c1e 	bne	r7,zero,180a80c <__umoddi3+0x12c>
 180a71c:	3027883a 	mov	r19,r6
 180a720:	2029883a 	mov	r20,r4
 180a724:	2980512e 	bgeu	r5,r6,180a86c <__umoddi3+0x18c>
 180a728:	00bfffd4 	movui	r2,65535
 180a72c:	11809a36 	bltu	r2,r6,180a998 <__umoddi3+0x2b8>
 180a730:	01003fc4 	movi	r4,255
 180a734:	2189803a 	cmpltu	r4,r4,r6
 180a738:	200890fa 	slli	r4,r4,3
 180a73c:	3104d83a 	srl	r2,r6,r4
 180a740:	00c06134 	movhi	r3,388
 180a744:	18c54f04 	addi	r3,r3,5436
 180a748:	1885883a 	add	r2,r3,r2
 180a74c:	10c00003 	ldbu	r3,0(r2)
 180a750:	00800804 	movi	r2,32
 180a754:	1909883a 	add	r4,r3,r4
 180a758:	1125c83a 	sub	r18,r2,r4
 180a75c:	90000526 	beq	r18,zero,180a774 <__umoddi3+0x94>
 180a760:	8ca2983a 	sll	r17,r17,r18
 180a764:	8108d83a 	srl	r4,r16,r4
 180a768:	34a6983a 	sll	r19,r6,r18
 180a76c:	84a8983a 	sll	r20,r16,r18
 180a770:	2478b03a 	or	fp,r4,r17
 180a774:	982ed43a 	srli	r23,r19,16
 180a778:	e009883a 	mov	r4,fp
 180a77c:	9dbfffcc 	andi	r22,r19,65535
 180a780:	b80b883a 	mov	r5,r23
 180a784:	180ad740 	call	180ad74 <__umodsi3>
 180a788:	e009883a 	mov	r4,fp
 180a78c:	b80b883a 	mov	r5,r23
 180a790:	102b883a 	mov	r21,r2
 180a794:	180ad100 	call	180ad10 <__udivsi3>
 180a798:	a806943a 	slli	r3,r21,16
 180a79c:	a008d43a 	srli	r4,r20,16
 180a7a0:	b085383a 	mul	r2,r22,r2
 180a7a4:	20c8b03a 	or	r4,r4,r3
 180a7a8:	2080032e 	bgeu	r4,r2,180a7b8 <__umoddi3+0xd8>
 180a7ac:	24c9883a 	add	r4,r4,r19
 180a7b0:	24c00136 	bltu	r4,r19,180a7b8 <__umoddi3+0xd8>
 180a7b4:	20811036 	bltu	r4,r2,180abf8 <__umoddi3+0x518>
 180a7b8:	20abc83a 	sub	r21,r4,r2
 180a7bc:	b80b883a 	mov	r5,r23
 180a7c0:	a809883a 	mov	r4,r21
 180a7c4:	180ad740 	call	180ad74 <__umodsi3>
 180a7c8:	1023883a 	mov	r17,r2
 180a7cc:	b80b883a 	mov	r5,r23
 180a7d0:	a809883a 	mov	r4,r21
 180a7d4:	180ad100 	call	180ad10 <__udivsi3>
 180a7d8:	8822943a 	slli	r17,r17,16
 180a7dc:	b085383a 	mul	r2,r22,r2
 180a7e0:	a0ffffcc 	andi	r3,r20,65535
 180a7e4:	1c46b03a 	or	r3,r3,r17
 180a7e8:	1880042e 	bgeu	r3,r2,180a7fc <__umoddi3+0x11c>
 180a7ec:	1cc7883a 	add	r3,r3,r19
 180a7f0:	1cc00236 	bltu	r3,r19,180a7fc <__umoddi3+0x11c>
 180a7f4:	1880012e 	bgeu	r3,r2,180a7fc <__umoddi3+0x11c>
 180a7f8:	1cc7883a 	add	r3,r3,r19
 180a7fc:	1885c83a 	sub	r2,r3,r2
 180a800:	1484d83a 	srl	r2,r2,r18
 180a804:	0007883a 	mov	r3,zero
 180a808:	00004f06 	br	180a948 <__umoddi3+0x268>
 180a80c:	29c04c36 	bltu	r5,r7,180a940 <__umoddi3+0x260>
 180a810:	00bfffd4 	movui	r2,65535
 180a814:	11c0582e 	bgeu	r2,r7,180a978 <__umoddi3+0x298>
 180a818:	00804034 	movhi	r2,256
 180a81c:	10bfffc4 	addi	r2,r2,-1
 180a820:	11c0e736 	bltu	r2,r7,180abc0 <__umoddi3+0x4e0>
 180a824:	01000404 	movi	r4,16
 180a828:	3904d83a 	srl	r2,r7,r4
 180a82c:	00c06134 	movhi	r3,388
 180a830:	18c54f04 	addi	r3,r3,5436
 180a834:	1885883a 	add	r2,r3,r2
 180a838:	14c00003 	ldbu	r19,0(r2)
 180a83c:	00c00804 	movi	r3,32
 180a840:	9927883a 	add	r19,r19,r4
 180a844:	1ce9c83a 	sub	r20,r3,r19
 180a848:	a000581e 	bne	r20,zero,180a9ac <__umoddi3+0x2cc>
 180a84c:	3c400136 	bltu	r7,r17,180a854 <__umoddi3+0x174>
 180a850:	8180eb36 	bltu	r16,r6,180ac00 <__umoddi3+0x520>
 180a854:	8185c83a 	sub	r2,r16,r6
 180a858:	89e3c83a 	sub	r17,r17,r7
 180a85c:	8089803a 	cmpltu	r4,r16,r2
 180a860:	8939c83a 	sub	fp,r17,r4
 180a864:	e007883a 	mov	r3,fp
 180a868:	00003706 	br	180a948 <__umoddi3+0x268>
 180a86c:	3000041e 	bne	r6,zero,180a880 <__umoddi3+0x1a0>
 180a870:	000b883a 	mov	r5,zero
 180a874:	01000044 	movi	r4,1
 180a878:	180ad100 	call	180ad10 <__udivsi3>
 180a87c:	1027883a 	mov	r19,r2
 180a880:	00bfffd4 	movui	r2,65535
 180a884:	14c0402e 	bgeu	r2,r19,180a988 <__umoddi3+0x2a8>
 180a888:	00804034 	movhi	r2,256
 180a88c:	10bfffc4 	addi	r2,r2,-1
 180a890:	14c0cd36 	bltu	r2,r19,180abc8 <__umoddi3+0x4e8>
 180a894:	00800404 	movi	r2,16
 180a898:	9886d83a 	srl	r3,r19,r2
 180a89c:	01006134 	movhi	r4,388
 180a8a0:	21054f04 	addi	r4,r4,5436
 180a8a4:	20c7883a 	add	r3,r4,r3
 180a8a8:	18c00003 	ldbu	r3,0(r3)
 180a8ac:	1887883a 	add	r3,r3,r2
 180a8b0:	00800804 	movi	r2,32
 180a8b4:	10e5c83a 	sub	r18,r2,r3
 180a8b8:	9000901e 	bne	r18,zero,180aafc <__umoddi3+0x41c>
 180a8bc:	982cd43a 	srli	r22,r19,16
 180a8c0:	8ce3c83a 	sub	r17,r17,r19
 180a8c4:	9d7fffcc 	andi	r21,r19,65535
 180a8c8:	b00b883a 	mov	r5,r22
 180a8cc:	8809883a 	mov	r4,r17
 180a8d0:	180ad740 	call	180ad74 <__umodsi3>
 180a8d4:	8809883a 	mov	r4,r17
 180a8d8:	b00b883a 	mov	r5,r22
 180a8dc:	1021883a 	mov	r16,r2
 180a8e0:	180ad100 	call	180ad10 <__udivsi3>
 180a8e4:	8006943a 	slli	r3,r16,16
 180a8e8:	a008d43a 	srli	r4,r20,16
 180a8ec:	1545383a 	mul	r2,r2,r21
 180a8f0:	20c8b03a 	or	r4,r4,r3
 180a8f4:	2080042e 	bgeu	r4,r2,180a908 <__umoddi3+0x228>
 180a8f8:	24c9883a 	add	r4,r4,r19
 180a8fc:	24c00236 	bltu	r4,r19,180a908 <__umoddi3+0x228>
 180a900:	2080012e 	bgeu	r4,r2,180a908 <__umoddi3+0x228>
 180a904:	24c9883a 	add	r4,r4,r19
 180a908:	20a1c83a 	sub	r16,r4,r2
 180a90c:	b00b883a 	mov	r5,r22
 180a910:	8009883a 	mov	r4,r16
 180a914:	180ad740 	call	180ad74 <__umodsi3>
 180a918:	1023883a 	mov	r17,r2
 180a91c:	b00b883a 	mov	r5,r22
 180a920:	8009883a 	mov	r4,r16
 180a924:	180ad100 	call	180ad10 <__udivsi3>
 180a928:	8822943a 	slli	r17,r17,16
 180a92c:	1545383a 	mul	r2,r2,r21
 180a930:	a53fffcc 	andi	r20,r20,65535
 180a934:	a446b03a 	or	r3,r20,r17
 180a938:	18bfb02e 	bgeu	r3,r2,180a7fc <__ram_exceptions_end+0xff7fa3b8>
 180a93c:	003fab06 	br	180a7ec <__ram_exceptions_end+0xff7fa3a8>
 180a940:	2005883a 	mov	r2,r4
 180a944:	2807883a 	mov	r3,r5
 180a948:	dfc00b17 	ldw	ra,44(sp)
 180a94c:	df000a17 	ldw	fp,40(sp)
 180a950:	ddc00917 	ldw	r23,36(sp)
 180a954:	dd800817 	ldw	r22,32(sp)
 180a958:	dd400717 	ldw	r21,28(sp)
 180a95c:	dd000617 	ldw	r20,24(sp)
 180a960:	dcc00517 	ldw	r19,20(sp)
 180a964:	dc800417 	ldw	r18,16(sp)
 180a968:	dc400317 	ldw	r17,12(sp)
 180a96c:	dc000217 	ldw	r16,8(sp)
 180a970:	dec00c04 	addi	sp,sp,48
 180a974:	f800283a 	ret
 180a978:	04c03fc4 	movi	r19,255
 180a97c:	99c9803a 	cmpltu	r4,r19,r7
 180a980:	200890fa 	slli	r4,r4,3
 180a984:	003fa806 	br	180a828 <__ram_exceptions_end+0xff7fa3e4>
 180a988:	00803fc4 	movi	r2,255
 180a98c:	14c5803a 	cmpltu	r2,r2,r19
 180a990:	100490fa 	slli	r2,r2,3
 180a994:	003fc006 	br	180a898 <__ram_exceptions_end+0xff7fa454>
 180a998:	00804034 	movhi	r2,256
 180a99c:	10bfffc4 	addi	r2,r2,-1
 180a9a0:	11808b36 	bltu	r2,r6,180abd0 <__umoddi3+0x4f0>
 180a9a4:	01000404 	movi	r4,16
 180a9a8:	003f6406 	br	180a73c <__ram_exceptions_end+0xff7fa2f8>
 180a9ac:	34c4d83a 	srl	r2,r6,r19
 180a9b0:	3d0e983a 	sll	r7,r7,r20
 180a9b4:	8cf8d83a 	srl	fp,r17,r19
 180a9b8:	8d10983a 	sll	r8,r17,r20
 180a9bc:	38aab03a 	or	r21,r7,r2
 180a9c0:	a82cd43a 	srli	r22,r21,16
 180a9c4:	84e2d83a 	srl	r17,r16,r19
 180a9c8:	e009883a 	mov	r4,fp
 180a9cc:	b00b883a 	mov	r5,r22
 180a9d0:	8a22b03a 	or	r17,r17,r8
 180a9d4:	3524983a 	sll	r18,r6,r20
 180a9d8:	180ad740 	call	180ad74 <__umodsi3>
 180a9dc:	e009883a 	mov	r4,fp
 180a9e0:	b00b883a 	mov	r5,r22
 180a9e4:	102f883a 	mov	r23,r2
 180a9e8:	180ad100 	call	180ad10 <__udivsi3>
 180a9ec:	100d883a 	mov	r6,r2
 180a9f0:	b808943a 	slli	r4,r23,16
 180a9f4:	aa3fffcc 	andi	r8,r21,65535
 180a9f8:	8804d43a 	srli	r2,r17,16
 180a9fc:	41af383a 	mul	r23,r8,r6
 180aa00:	8520983a 	sll	r16,r16,r20
 180aa04:	1104b03a 	or	r2,r2,r4
 180aa08:	15c0042e 	bgeu	r2,r23,180aa1c <__umoddi3+0x33c>
 180aa0c:	1545883a 	add	r2,r2,r21
 180aa10:	30ffffc4 	addi	r3,r6,-1
 180aa14:	1540742e 	bgeu	r2,r21,180abe8 <__umoddi3+0x508>
 180aa18:	180d883a 	mov	r6,r3
 180aa1c:	15efc83a 	sub	r23,r2,r23
 180aa20:	b00b883a 	mov	r5,r22
 180aa24:	b809883a 	mov	r4,r23
 180aa28:	d9800115 	stw	r6,4(sp)
 180aa2c:	da000015 	stw	r8,0(sp)
 180aa30:	180ad740 	call	180ad74 <__umodsi3>
 180aa34:	b00b883a 	mov	r5,r22
 180aa38:	b809883a 	mov	r4,r23
 180aa3c:	1039883a 	mov	fp,r2
 180aa40:	180ad100 	call	180ad10 <__udivsi3>
 180aa44:	da000017 	ldw	r8,0(sp)
 180aa48:	e038943a 	slli	fp,fp,16
 180aa4c:	100b883a 	mov	r5,r2
 180aa50:	4089383a 	mul	r4,r8,r2
 180aa54:	8a3fffcc 	andi	r8,r17,65535
 180aa58:	4710b03a 	or	r8,r8,fp
 180aa5c:	d9800117 	ldw	r6,4(sp)
 180aa60:	4100042e 	bgeu	r8,r4,180aa74 <__umoddi3+0x394>
 180aa64:	4551883a 	add	r8,r8,r21
 180aa68:	10bfffc4 	addi	r2,r2,-1
 180aa6c:	45405a2e 	bgeu	r8,r21,180abd8 <__umoddi3+0x4f8>
 180aa70:	100b883a 	mov	r5,r2
 180aa74:	300c943a 	slli	r6,r6,16
 180aa78:	91ffffcc 	andi	r7,r18,65535
 180aa7c:	9004d43a 	srli	r2,r18,16
 180aa80:	314cb03a 	or	r6,r6,r5
 180aa84:	317fffcc 	andi	r5,r6,65535
 180aa88:	300cd43a 	srli	r6,r6,16
 180aa8c:	29d3383a 	mul	r9,r5,r7
 180aa90:	288b383a 	mul	r5,r5,r2
 180aa94:	31cf383a 	mul	r7,r6,r7
 180aa98:	4806d43a 	srli	r3,r9,16
 180aa9c:	4111c83a 	sub	r8,r8,r4
 180aaa0:	29cb883a 	add	r5,r5,r7
 180aaa4:	194b883a 	add	r5,r3,r5
 180aaa8:	3085383a 	mul	r2,r6,r2
 180aaac:	29c0022e 	bgeu	r5,r7,180aab8 <__umoddi3+0x3d8>
 180aab0:	00c00074 	movhi	r3,1
 180aab4:	10c5883a 	add	r2,r2,r3
 180aab8:	2808d43a 	srli	r4,r5,16
 180aabc:	280a943a 	slli	r5,r5,16
 180aac0:	4a7fffcc 	andi	r9,r9,65535
 180aac4:	2085883a 	add	r2,r4,r2
 180aac8:	2a4b883a 	add	r5,r5,r9
 180aacc:	40803636 	bltu	r8,r2,180aba8 <__umoddi3+0x4c8>
 180aad0:	40804d26 	beq	r8,r2,180ac08 <__umoddi3+0x528>
 180aad4:	4089c83a 	sub	r4,r8,r2
 180aad8:	280f883a 	mov	r7,r5
 180aadc:	81cfc83a 	sub	r7,r16,r7
 180aae0:	81c7803a 	cmpltu	r3,r16,r7
 180aae4:	20c7c83a 	sub	r3,r4,r3
 180aae8:	1cc4983a 	sll	r2,r3,r19
 180aaec:	3d0ed83a 	srl	r7,r7,r20
 180aaf0:	1d06d83a 	srl	r3,r3,r20
 180aaf4:	11c4b03a 	or	r2,r2,r7
 180aaf8:	003f9306 	br	180a948 <__ram_exceptions_end+0xff7fa504>
 180aafc:	9ca6983a 	sll	r19,r19,r18
 180ab00:	88e8d83a 	srl	r20,r17,r3
 180ab04:	80c4d83a 	srl	r2,r16,r3
 180ab08:	982cd43a 	srli	r22,r19,16
 180ab0c:	8ca2983a 	sll	r17,r17,r18
 180ab10:	a009883a 	mov	r4,r20
 180ab14:	b00b883a 	mov	r5,r22
 180ab18:	1478b03a 	or	fp,r2,r17
 180ab1c:	180ad740 	call	180ad74 <__umodsi3>
 180ab20:	a009883a 	mov	r4,r20
 180ab24:	b00b883a 	mov	r5,r22
 180ab28:	1023883a 	mov	r17,r2
 180ab2c:	180ad100 	call	180ad10 <__udivsi3>
 180ab30:	9d7fffcc 	andi	r21,r19,65535
 180ab34:	880a943a 	slli	r5,r17,16
 180ab38:	e008d43a 	srli	r4,fp,16
 180ab3c:	a885383a 	mul	r2,r21,r2
 180ab40:	84a8983a 	sll	r20,r16,r18
 180ab44:	2148b03a 	or	r4,r4,r5
 180ab48:	2080042e 	bgeu	r4,r2,180ab5c <__umoddi3+0x47c>
 180ab4c:	24c9883a 	add	r4,r4,r19
 180ab50:	24c00236 	bltu	r4,r19,180ab5c <__umoddi3+0x47c>
 180ab54:	2080012e 	bgeu	r4,r2,180ab5c <__umoddi3+0x47c>
 180ab58:	24c9883a 	add	r4,r4,r19
 180ab5c:	20a3c83a 	sub	r17,r4,r2
 180ab60:	b00b883a 	mov	r5,r22
 180ab64:	8809883a 	mov	r4,r17
 180ab68:	180ad740 	call	180ad74 <__umodsi3>
 180ab6c:	102f883a 	mov	r23,r2
 180ab70:	8809883a 	mov	r4,r17
 180ab74:	b00b883a 	mov	r5,r22
 180ab78:	180ad100 	call	180ad10 <__udivsi3>
 180ab7c:	b82e943a 	slli	r23,r23,16
 180ab80:	a885383a 	mul	r2,r21,r2
 180ab84:	e13fffcc 	andi	r4,fp,65535
 180ab88:	25c8b03a 	or	r4,r4,r23
 180ab8c:	2080042e 	bgeu	r4,r2,180aba0 <__umoddi3+0x4c0>
 180ab90:	24c9883a 	add	r4,r4,r19
 180ab94:	24c00236 	bltu	r4,r19,180aba0 <__umoddi3+0x4c0>
 180ab98:	2080012e 	bgeu	r4,r2,180aba0 <__umoddi3+0x4c0>
 180ab9c:	24c9883a 	add	r4,r4,r19
 180aba0:	20a3c83a 	sub	r17,r4,r2
 180aba4:	003f4806 	br	180a8c8 <__ram_exceptions_end+0xff7fa484>
 180aba8:	2c8fc83a 	sub	r7,r5,r18
 180abac:	1545c83a 	sub	r2,r2,r21
 180abb0:	29cb803a 	cmpltu	r5,r5,r7
 180abb4:	1145c83a 	sub	r2,r2,r5
 180abb8:	4089c83a 	sub	r4,r8,r2
 180abbc:	003fc706 	br	180aadc <__ram_exceptions_end+0xff7fa698>
 180abc0:	01000604 	movi	r4,24
 180abc4:	003f1806 	br	180a828 <__ram_exceptions_end+0xff7fa3e4>
 180abc8:	00800604 	movi	r2,24
 180abcc:	003f3206 	br	180a898 <__ram_exceptions_end+0xff7fa454>
 180abd0:	01000604 	movi	r4,24
 180abd4:	003ed906 	br	180a73c <__ram_exceptions_end+0xff7fa2f8>
 180abd8:	413fa52e 	bgeu	r8,r4,180aa70 <__ram_exceptions_end+0xff7fa62c>
 180abdc:	297fff84 	addi	r5,r5,-2
 180abe0:	4551883a 	add	r8,r8,r21
 180abe4:	003fa306 	br	180aa74 <__ram_exceptions_end+0xff7fa630>
 180abe8:	15ff8b2e 	bgeu	r2,r23,180aa18 <__ram_exceptions_end+0xff7fa5d4>
 180abec:	31bfff84 	addi	r6,r6,-2
 180abf0:	1545883a 	add	r2,r2,r21
 180abf4:	003f8906 	br	180aa1c <__ram_exceptions_end+0xff7fa5d8>
 180abf8:	24c9883a 	add	r4,r4,r19
 180abfc:	003eee06 	br	180a7b8 <__ram_exceptions_end+0xff7fa374>
 180ac00:	8005883a 	mov	r2,r16
 180ac04:	003f1706 	br	180a864 <__ram_exceptions_end+0xff7fa420>
 180ac08:	817fe736 	bltu	r16,r5,180aba8 <__ram_exceptions_end+0xff7fa764>
 180ac0c:	280f883a 	mov	r7,r5
 180ac10:	0009883a 	mov	r4,zero
 180ac14:	003fb106 	br	180aadc <__ram_exceptions_end+0xff7fa698>

0180ac18 <__divsi3>:
 180ac18:	20001b16 	blt	r4,zero,180ac88 <__divsi3+0x70>
 180ac1c:	000f883a 	mov	r7,zero
 180ac20:	28001616 	blt	r5,zero,180ac7c <__divsi3+0x64>
 180ac24:	200d883a 	mov	r6,r4
 180ac28:	29001a2e 	bgeu	r5,r4,180ac94 <__divsi3+0x7c>
 180ac2c:	00800804 	movi	r2,32
 180ac30:	00c00044 	movi	r3,1
 180ac34:	00000106 	br	180ac3c <__divsi3+0x24>
 180ac38:	10000d26 	beq	r2,zero,180ac70 <__divsi3+0x58>
 180ac3c:	294b883a 	add	r5,r5,r5
 180ac40:	10bfffc4 	addi	r2,r2,-1
 180ac44:	18c7883a 	add	r3,r3,r3
 180ac48:	293ffb36 	bltu	r5,r4,180ac38 <__ram_exceptions_end+0xff7fa7f4>
 180ac4c:	0005883a 	mov	r2,zero
 180ac50:	18000726 	beq	r3,zero,180ac70 <__divsi3+0x58>
 180ac54:	0005883a 	mov	r2,zero
 180ac58:	31400236 	bltu	r6,r5,180ac64 <__divsi3+0x4c>
 180ac5c:	314dc83a 	sub	r6,r6,r5
 180ac60:	10c4b03a 	or	r2,r2,r3
 180ac64:	1806d07a 	srli	r3,r3,1
 180ac68:	280ad07a 	srli	r5,r5,1
 180ac6c:	183ffa1e 	bne	r3,zero,180ac58 <__ram_exceptions_end+0xff7fa814>
 180ac70:	38000126 	beq	r7,zero,180ac78 <__divsi3+0x60>
 180ac74:	0085c83a 	sub	r2,zero,r2
 180ac78:	f800283a 	ret
 180ac7c:	014bc83a 	sub	r5,zero,r5
 180ac80:	39c0005c 	xori	r7,r7,1
 180ac84:	003fe706 	br	180ac24 <__ram_exceptions_end+0xff7fa7e0>
 180ac88:	0109c83a 	sub	r4,zero,r4
 180ac8c:	01c00044 	movi	r7,1
 180ac90:	003fe306 	br	180ac20 <__ram_exceptions_end+0xff7fa7dc>
 180ac94:	00c00044 	movi	r3,1
 180ac98:	003fee06 	br	180ac54 <__ram_exceptions_end+0xff7fa810>

0180ac9c <__modsi3>:
 180ac9c:	20001716 	blt	r4,zero,180acfc <__modsi3+0x60>
 180aca0:	000f883a 	mov	r7,zero
 180aca4:	2005883a 	mov	r2,r4
 180aca8:	28001216 	blt	r5,zero,180acf4 <__modsi3+0x58>
 180acac:	2900162e 	bgeu	r5,r4,180ad08 <__modsi3+0x6c>
 180acb0:	01800804 	movi	r6,32
 180acb4:	00c00044 	movi	r3,1
 180acb8:	00000106 	br	180acc0 <__modsi3+0x24>
 180acbc:	30000a26 	beq	r6,zero,180ace8 <__modsi3+0x4c>
 180acc0:	294b883a 	add	r5,r5,r5
 180acc4:	31bfffc4 	addi	r6,r6,-1
 180acc8:	18c7883a 	add	r3,r3,r3
 180accc:	293ffb36 	bltu	r5,r4,180acbc <__ram_exceptions_end+0xff7fa878>
 180acd0:	18000526 	beq	r3,zero,180ace8 <__modsi3+0x4c>
 180acd4:	1806d07a 	srli	r3,r3,1
 180acd8:	11400136 	bltu	r2,r5,180ace0 <__modsi3+0x44>
 180acdc:	1145c83a 	sub	r2,r2,r5
 180ace0:	280ad07a 	srli	r5,r5,1
 180ace4:	183ffb1e 	bne	r3,zero,180acd4 <__ram_exceptions_end+0xff7fa890>
 180ace8:	38000126 	beq	r7,zero,180acf0 <__modsi3+0x54>
 180acec:	0085c83a 	sub	r2,zero,r2
 180acf0:	f800283a 	ret
 180acf4:	014bc83a 	sub	r5,zero,r5
 180acf8:	003fec06 	br	180acac <__ram_exceptions_end+0xff7fa868>
 180acfc:	0109c83a 	sub	r4,zero,r4
 180ad00:	01c00044 	movi	r7,1
 180ad04:	003fe706 	br	180aca4 <__ram_exceptions_end+0xff7fa860>
 180ad08:	00c00044 	movi	r3,1
 180ad0c:	003ff106 	br	180acd4 <__ram_exceptions_end+0xff7fa890>

0180ad10 <__udivsi3>:
 180ad10:	200d883a 	mov	r6,r4
 180ad14:	2900152e 	bgeu	r5,r4,180ad6c <__udivsi3+0x5c>
 180ad18:	28001416 	blt	r5,zero,180ad6c <__udivsi3+0x5c>
 180ad1c:	00800804 	movi	r2,32
 180ad20:	00c00044 	movi	r3,1
 180ad24:	00000206 	br	180ad30 <__udivsi3+0x20>
 180ad28:	10000e26 	beq	r2,zero,180ad64 <__udivsi3+0x54>
 180ad2c:	28000516 	blt	r5,zero,180ad44 <__udivsi3+0x34>
 180ad30:	294b883a 	add	r5,r5,r5
 180ad34:	10bfffc4 	addi	r2,r2,-1
 180ad38:	18c7883a 	add	r3,r3,r3
 180ad3c:	293ffa36 	bltu	r5,r4,180ad28 <__ram_exceptions_end+0xff7fa8e4>
 180ad40:	18000826 	beq	r3,zero,180ad64 <__udivsi3+0x54>
 180ad44:	0005883a 	mov	r2,zero
 180ad48:	31400236 	bltu	r6,r5,180ad54 <__udivsi3+0x44>
 180ad4c:	314dc83a 	sub	r6,r6,r5
 180ad50:	10c4b03a 	or	r2,r2,r3
 180ad54:	1806d07a 	srli	r3,r3,1
 180ad58:	280ad07a 	srli	r5,r5,1
 180ad5c:	183ffa1e 	bne	r3,zero,180ad48 <__ram_exceptions_end+0xff7fa904>
 180ad60:	f800283a 	ret
 180ad64:	0005883a 	mov	r2,zero
 180ad68:	f800283a 	ret
 180ad6c:	00c00044 	movi	r3,1
 180ad70:	003ff406 	br	180ad44 <__ram_exceptions_end+0xff7fa900>

0180ad74 <__umodsi3>:
 180ad74:	2005883a 	mov	r2,r4
 180ad78:	2900122e 	bgeu	r5,r4,180adc4 <__umodsi3+0x50>
 180ad7c:	28001116 	blt	r5,zero,180adc4 <__umodsi3+0x50>
 180ad80:	01800804 	movi	r6,32
 180ad84:	00c00044 	movi	r3,1
 180ad88:	00000206 	br	180ad94 <__umodsi3+0x20>
 180ad8c:	30000c26 	beq	r6,zero,180adc0 <__umodsi3+0x4c>
 180ad90:	28000516 	blt	r5,zero,180ada8 <__umodsi3+0x34>
 180ad94:	294b883a 	add	r5,r5,r5
 180ad98:	31bfffc4 	addi	r6,r6,-1
 180ad9c:	18c7883a 	add	r3,r3,r3
 180ada0:	293ffa36 	bltu	r5,r4,180ad8c <__ram_exceptions_end+0xff7fa948>
 180ada4:	18000626 	beq	r3,zero,180adc0 <__umodsi3+0x4c>
 180ada8:	1806d07a 	srli	r3,r3,1
 180adac:	11400136 	bltu	r2,r5,180adb4 <__umodsi3+0x40>
 180adb0:	1145c83a 	sub	r2,r2,r5
 180adb4:	280ad07a 	srli	r5,r5,1
 180adb8:	183ffb1e 	bne	r3,zero,180ada8 <__ram_exceptions_end+0xff7fa964>
 180adbc:	f800283a 	ret
 180adc0:	f800283a 	ret
 180adc4:	00c00044 	movi	r3,1
 180adc8:	003ff706 	br	180ada8 <__ram_exceptions_end+0xff7fa964>

0180adcc <__adddf3>:
 180adcc:	02c00434 	movhi	r11,16
 180add0:	5affffc4 	addi	r11,r11,-1
 180add4:	2806d7fa 	srli	r3,r5,31
 180add8:	2ad4703a 	and	r10,r5,r11
 180addc:	3ad2703a 	and	r9,r7,r11
 180ade0:	3804d53a 	srli	r2,r7,20
 180ade4:	3018d77a 	srli	r12,r6,29
 180ade8:	280ad53a 	srli	r5,r5,20
 180adec:	501490fa 	slli	r10,r10,3
 180adf0:	2010d77a 	srli	r8,r4,29
 180adf4:	481290fa 	slli	r9,r9,3
 180adf8:	380ed7fa 	srli	r7,r7,31
 180adfc:	defffb04 	addi	sp,sp,-20
 180ae00:	dc800215 	stw	r18,8(sp)
 180ae04:	dc400115 	stw	r17,4(sp)
 180ae08:	dc000015 	stw	r16,0(sp)
 180ae0c:	dfc00415 	stw	ra,16(sp)
 180ae10:	dcc00315 	stw	r19,12(sp)
 180ae14:	1c803fcc 	andi	r18,r3,255
 180ae18:	2c01ffcc 	andi	r16,r5,2047
 180ae1c:	5210b03a 	or	r8,r10,r8
 180ae20:	202290fa 	slli	r17,r4,3
 180ae24:	1081ffcc 	andi	r2,r2,2047
 180ae28:	4b12b03a 	or	r9,r9,r12
 180ae2c:	300c90fa 	slli	r6,r6,3
 180ae30:	91c07526 	beq	r18,r7,180b008 <__adddf3+0x23c>
 180ae34:	8087c83a 	sub	r3,r16,r2
 180ae38:	00c0ab0e 	bge	zero,r3,180b0e8 <__adddf3+0x31c>
 180ae3c:	10002a1e 	bne	r2,zero,180aee8 <__adddf3+0x11c>
 180ae40:	4984b03a 	or	r2,r9,r6
 180ae44:	1000961e 	bne	r2,zero,180b0a0 <__adddf3+0x2d4>
 180ae48:	888001cc 	andi	r2,r17,7
 180ae4c:	10000726 	beq	r2,zero,180ae6c <__adddf3+0xa0>
 180ae50:	888003cc 	andi	r2,r17,15
 180ae54:	00c00104 	movi	r3,4
 180ae58:	10c00426 	beq	r2,r3,180ae6c <__adddf3+0xa0>
 180ae5c:	88c7883a 	add	r3,r17,r3
 180ae60:	1c63803a 	cmpltu	r17,r3,r17
 180ae64:	4451883a 	add	r8,r8,r17
 180ae68:	1823883a 	mov	r17,r3
 180ae6c:	4080202c 	andhi	r2,r8,128
 180ae70:	10005926 	beq	r2,zero,180afd8 <__adddf3+0x20c>
 180ae74:	84000044 	addi	r16,r16,1
 180ae78:	0081ffc4 	movi	r2,2047
 180ae7c:	8080ba26 	beq	r16,r2,180b168 <__adddf3+0x39c>
 180ae80:	00bfe034 	movhi	r2,65408
 180ae84:	10bfffc4 	addi	r2,r2,-1
 180ae88:	4090703a 	and	r8,r8,r2
 180ae8c:	4004977a 	slli	r2,r8,29
 180ae90:	4010927a 	slli	r8,r8,9
 180ae94:	8822d0fa 	srli	r17,r17,3
 180ae98:	8401ffcc 	andi	r16,r16,2047
 180ae9c:	4010d33a 	srli	r8,r8,12
 180aea0:	9007883a 	mov	r3,r18
 180aea4:	1444b03a 	or	r2,r2,r17
 180aea8:	8401ffcc 	andi	r16,r16,2047
 180aeac:	8020953a 	slli	r16,r16,20
 180aeb0:	18c03fcc 	andi	r3,r3,255
 180aeb4:	01000434 	movhi	r4,16
 180aeb8:	213fffc4 	addi	r4,r4,-1
 180aebc:	180697fa 	slli	r3,r3,31
 180aec0:	4110703a 	and	r8,r8,r4
 180aec4:	4410b03a 	or	r8,r8,r16
 180aec8:	40c6b03a 	or	r3,r8,r3
 180aecc:	dfc00417 	ldw	ra,16(sp)
 180aed0:	dcc00317 	ldw	r19,12(sp)
 180aed4:	dc800217 	ldw	r18,8(sp)
 180aed8:	dc400117 	ldw	r17,4(sp)
 180aedc:	dc000017 	ldw	r16,0(sp)
 180aee0:	dec00504 	addi	sp,sp,20
 180aee4:	f800283a 	ret
 180aee8:	0081ffc4 	movi	r2,2047
 180aeec:	80bfd626 	beq	r16,r2,180ae48 <__ram_exceptions_end+0xff7faa04>
 180aef0:	4a402034 	orhi	r9,r9,128
 180aef4:	00800e04 	movi	r2,56
 180aef8:	10c09f16 	blt	r2,r3,180b178 <__adddf3+0x3ac>
 180aefc:	008007c4 	movi	r2,31
 180af00:	10c0c216 	blt	r2,r3,180b20c <__adddf3+0x440>
 180af04:	00800804 	movi	r2,32
 180af08:	10c5c83a 	sub	r2,r2,r3
 180af0c:	488a983a 	sll	r5,r9,r2
 180af10:	30c8d83a 	srl	r4,r6,r3
 180af14:	3084983a 	sll	r2,r6,r2
 180af18:	48c6d83a 	srl	r3,r9,r3
 180af1c:	290cb03a 	or	r6,r5,r4
 180af20:	1004c03a 	cmpne	r2,r2,zero
 180af24:	308cb03a 	or	r6,r6,r2
 180af28:	898dc83a 	sub	r6,r17,r6
 180af2c:	89a3803a 	cmpltu	r17,r17,r6
 180af30:	40d1c83a 	sub	r8,r8,r3
 180af34:	4451c83a 	sub	r8,r8,r17
 180af38:	3023883a 	mov	r17,r6
 180af3c:	4080202c 	andhi	r2,r8,128
 180af40:	10002326 	beq	r2,zero,180afd0 <__adddf3+0x204>
 180af44:	04c02034 	movhi	r19,128
 180af48:	9cffffc4 	addi	r19,r19,-1
 180af4c:	44e6703a 	and	r19,r8,r19
 180af50:	98007626 	beq	r19,zero,180b12c <__adddf3+0x360>
 180af54:	9809883a 	mov	r4,r19
 180af58:	180d3d00 	call	180d3d0 <__clzsi2>
 180af5c:	10fffe04 	addi	r3,r2,-8
 180af60:	010007c4 	movi	r4,31
 180af64:	20c07716 	blt	r4,r3,180b144 <__adddf3+0x378>
 180af68:	00800804 	movi	r2,32
 180af6c:	10c5c83a 	sub	r2,r2,r3
 180af70:	8884d83a 	srl	r2,r17,r2
 180af74:	98d0983a 	sll	r8,r19,r3
 180af78:	88e2983a 	sll	r17,r17,r3
 180af7c:	1204b03a 	or	r2,r2,r8
 180af80:	1c007416 	blt	r3,r16,180b154 <__adddf3+0x388>
 180af84:	1c21c83a 	sub	r16,r3,r16
 180af88:	82000044 	addi	r8,r16,1
 180af8c:	00c007c4 	movi	r3,31
 180af90:	1a009116 	blt	r3,r8,180b1d8 <__adddf3+0x40c>
 180af94:	00c00804 	movi	r3,32
 180af98:	1a07c83a 	sub	r3,r3,r8
 180af9c:	8a08d83a 	srl	r4,r17,r8
 180afa0:	88e2983a 	sll	r17,r17,r3
 180afa4:	10c6983a 	sll	r3,r2,r3
 180afa8:	1210d83a 	srl	r8,r2,r8
 180afac:	8804c03a 	cmpne	r2,r17,zero
 180afb0:	1906b03a 	or	r3,r3,r4
 180afb4:	18a2b03a 	or	r17,r3,r2
 180afb8:	0021883a 	mov	r16,zero
 180afbc:	003fa206 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180afc0:	1890b03a 	or	r8,r3,r2
 180afc4:	40017d26 	beq	r8,zero,180b5bc <__adddf3+0x7f0>
 180afc8:	1011883a 	mov	r8,r2
 180afcc:	1823883a 	mov	r17,r3
 180afd0:	888001cc 	andi	r2,r17,7
 180afd4:	103f9e1e 	bne	r2,zero,180ae50 <__ram_exceptions_end+0xff7faa0c>
 180afd8:	4004977a 	slli	r2,r8,29
 180afdc:	8822d0fa 	srli	r17,r17,3
 180afe0:	4010d0fa 	srli	r8,r8,3
 180afe4:	9007883a 	mov	r3,r18
 180afe8:	1444b03a 	or	r2,r2,r17
 180afec:	0101ffc4 	movi	r4,2047
 180aff0:	81002426 	beq	r16,r4,180b084 <__adddf3+0x2b8>
 180aff4:	8120703a 	and	r16,r16,r4
 180aff8:	01000434 	movhi	r4,16
 180affc:	213fffc4 	addi	r4,r4,-1
 180b000:	4110703a 	and	r8,r8,r4
 180b004:	003fa806 	br	180aea8 <__ram_exceptions_end+0xff7faa64>
 180b008:	8089c83a 	sub	r4,r16,r2
 180b00c:	01005e0e 	bge	zero,r4,180b188 <__adddf3+0x3bc>
 180b010:	10002b26 	beq	r2,zero,180b0c0 <__adddf3+0x2f4>
 180b014:	0081ffc4 	movi	r2,2047
 180b018:	80bf8b26 	beq	r16,r2,180ae48 <__ram_exceptions_end+0xff7faa04>
 180b01c:	4a402034 	orhi	r9,r9,128
 180b020:	00800e04 	movi	r2,56
 180b024:	1100a40e 	bge	r2,r4,180b2b8 <__adddf3+0x4ec>
 180b028:	498cb03a 	or	r6,r9,r6
 180b02c:	300ac03a 	cmpne	r5,r6,zero
 180b030:	0013883a 	mov	r9,zero
 180b034:	2c4b883a 	add	r5,r5,r17
 180b038:	2c63803a 	cmpltu	r17,r5,r17
 180b03c:	4a11883a 	add	r8,r9,r8
 180b040:	8a11883a 	add	r8,r17,r8
 180b044:	2823883a 	mov	r17,r5
 180b048:	4080202c 	andhi	r2,r8,128
 180b04c:	103fe026 	beq	r2,zero,180afd0 <__ram_exceptions_end+0xff7fab8c>
 180b050:	84000044 	addi	r16,r16,1
 180b054:	0081ffc4 	movi	r2,2047
 180b058:	8080d226 	beq	r16,r2,180b3a4 <__adddf3+0x5d8>
 180b05c:	00bfe034 	movhi	r2,65408
 180b060:	10bfffc4 	addi	r2,r2,-1
 180b064:	4090703a 	and	r8,r8,r2
 180b068:	880ad07a 	srli	r5,r17,1
 180b06c:	400897fa 	slli	r4,r8,31
 180b070:	88c0004c 	andi	r3,r17,1
 180b074:	28e2b03a 	or	r17,r5,r3
 180b078:	4010d07a 	srli	r8,r8,1
 180b07c:	2462b03a 	or	r17,r4,r17
 180b080:	003f7106 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b084:	4088b03a 	or	r4,r8,r2
 180b088:	20014526 	beq	r4,zero,180b5a0 <__adddf3+0x7d4>
 180b08c:	01000434 	movhi	r4,16
 180b090:	42000234 	orhi	r8,r8,8
 180b094:	213fffc4 	addi	r4,r4,-1
 180b098:	4110703a 	and	r8,r8,r4
 180b09c:	003f8206 	br	180aea8 <__ram_exceptions_end+0xff7faa64>
 180b0a0:	18ffffc4 	addi	r3,r3,-1
 180b0a4:	1800491e 	bne	r3,zero,180b1cc <__adddf3+0x400>
 180b0a8:	898bc83a 	sub	r5,r17,r6
 180b0ac:	8963803a 	cmpltu	r17,r17,r5
 180b0b0:	4251c83a 	sub	r8,r8,r9
 180b0b4:	4451c83a 	sub	r8,r8,r17
 180b0b8:	2823883a 	mov	r17,r5
 180b0bc:	003f9f06 	br	180af3c <__ram_exceptions_end+0xff7faaf8>
 180b0c0:	4984b03a 	or	r2,r9,r6
 180b0c4:	103f6026 	beq	r2,zero,180ae48 <__ram_exceptions_end+0xff7faa04>
 180b0c8:	213fffc4 	addi	r4,r4,-1
 180b0cc:	2000931e 	bne	r4,zero,180b31c <__adddf3+0x550>
 180b0d0:	898d883a 	add	r6,r17,r6
 180b0d4:	3463803a 	cmpltu	r17,r6,r17
 180b0d8:	4251883a 	add	r8,r8,r9
 180b0dc:	8a11883a 	add	r8,r17,r8
 180b0e0:	3023883a 	mov	r17,r6
 180b0e4:	003fd806 	br	180b048 <__ram_exceptions_end+0xff7fac04>
 180b0e8:	1800541e 	bne	r3,zero,180b23c <__adddf3+0x470>
 180b0ec:	80800044 	addi	r2,r16,1
 180b0f0:	1081ffcc 	andi	r2,r2,2047
 180b0f4:	00c00044 	movi	r3,1
 180b0f8:	1880a00e 	bge	r3,r2,180b37c <__adddf3+0x5b0>
 180b0fc:	8989c83a 	sub	r4,r17,r6
 180b100:	8905803a 	cmpltu	r2,r17,r4
 180b104:	4267c83a 	sub	r19,r8,r9
 180b108:	98a7c83a 	sub	r19,r19,r2
 180b10c:	9880202c 	andhi	r2,r19,128
 180b110:	10006326 	beq	r2,zero,180b2a0 <__adddf3+0x4d4>
 180b114:	3463c83a 	sub	r17,r6,r17
 180b118:	4a07c83a 	sub	r3,r9,r8
 180b11c:	344d803a 	cmpltu	r6,r6,r17
 180b120:	19a7c83a 	sub	r19,r3,r6
 180b124:	3825883a 	mov	r18,r7
 180b128:	983f8a1e 	bne	r19,zero,180af54 <__ram_exceptions_end+0xff7fab10>
 180b12c:	8809883a 	mov	r4,r17
 180b130:	180d3d00 	call	180d3d0 <__clzsi2>
 180b134:	10800804 	addi	r2,r2,32
 180b138:	10fffe04 	addi	r3,r2,-8
 180b13c:	010007c4 	movi	r4,31
 180b140:	20ff890e 	bge	r4,r3,180af68 <__ram_exceptions_end+0xff7fab24>
 180b144:	10bff604 	addi	r2,r2,-40
 180b148:	8884983a 	sll	r2,r17,r2
 180b14c:	0023883a 	mov	r17,zero
 180b150:	1c3f8c0e 	bge	r3,r16,180af84 <__ram_exceptions_end+0xff7fab40>
 180b154:	023fe034 	movhi	r8,65408
 180b158:	423fffc4 	addi	r8,r8,-1
 180b15c:	80e1c83a 	sub	r16,r16,r3
 180b160:	1210703a 	and	r8,r2,r8
 180b164:	003f3806 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b168:	9007883a 	mov	r3,r18
 180b16c:	0011883a 	mov	r8,zero
 180b170:	0005883a 	mov	r2,zero
 180b174:	003f4c06 	br	180aea8 <__ram_exceptions_end+0xff7faa64>
 180b178:	498cb03a 	or	r6,r9,r6
 180b17c:	300cc03a 	cmpne	r6,r6,zero
 180b180:	0007883a 	mov	r3,zero
 180b184:	003f6806 	br	180af28 <__ram_exceptions_end+0xff7faae4>
 180b188:	20009c1e 	bne	r4,zero,180b3fc <__adddf3+0x630>
 180b18c:	80800044 	addi	r2,r16,1
 180b190:	1141ffcc 	andi	r5,r2,2047
 180b194:	01000044 	movi	r4,1
 180b198:	2140670e 	bge	r4,r5,180b338 <__adddf3+0x56c>
 180b19c:	0101ffc4 	movi	r4,2047
 180b1a0:	11007f26 	beq	r2,r4,180b3a0 <__adddf3+0x5d4>
 180b1a4:	898d883a 	add	r6,r17,r6
 180b1a8:	4247883a 	add	r3,r8,r9
 180b1ac:	3451803a 	cmpltu	r8,r6,r17
 180b1b0:	40d1883a 	add	r8,r8,r3
 180b1b4:	402297fa 	slli	r17,r8,31
 180b1b8:	300cd07a 	srli	r6,r6,1
 180b1bc:	4010d07a 	srli	r8,r8,1
 180b1c0:	1021883a 	mov	r16,r2
 180b1c4:	89a2b03a 	or	r17,r17,r6
 180b1c8:	003f1f06 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b1cc:	0081ffc4 	movi	r2,2047
 180b1d0:	80bf481e 	bne	r16,r2,180aef4 <__ram_exceptions_end+0xff7faab0>
 180b1d4:	003f1c06 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b1d8:	843ff844 	addi	r16,r16,-31
 180b1dc:	01000804 	movi	r4,32
 180b1e0:	1406d83a 	srl	r3,r2,r16
 180b1e4:	41005026 	beq	r8,r4,180b328 <__adddf3+0x55c>
 180b1e8:	01001004 	movi	r4,64
 180b1ec:	2211c83a 	sub	r8,r4,r8
 180b1f0:	1204983a 	sll	r2,r2,r8
 180b1f4:	88a2b03a 	or	r17,r17,r2
 180b1f8:	8822c03a 	cmpne	r17,r17,zero
 180b1fc:	1c62b03a 	or	r17,r3,r17
 180b200:	0011883a 	mov	r8,zero
 180b204:	0021883a 	mov	r16,zero
 180b208:	003f7106 	br	180afd0 <__ram_exceptions_end+0xff7fab8c>
 180b20c:	193ff804 	addi	r4,r3,-32
 180b210:	00800804 	movi	r2,32
 180b214:	4908d83a 	srl	r4,r9,r4
 180b218:	18804526 	beq	r3,r2,180b330 <__adddf3+0x564>
 180b21c:	00801004 	movi	r2,64
 180b220:	10c5c83a 	sub	r2,r2,r3
 180b224:	4886983a 	sll	r3,r9,r2
 180b228:	198cb03a 	or	r6,r3,r6
 180b22c:	300cc03a 	cmpne	r6,r6,zero
 180b230:	218cb03a 	or	r6,r4,r6
 180b234:	0007883a 	mov	r3,zero
 180b238:	003f3b06 	br	180af28 <__ram_exceptions_end+0xff7faae4>
 180b23c:	80002a26 	beq	r16,zero,180b2e8 <__adddf3+0x51c>
 180b240:	0101ffc4 	movi	r4,2047
 180b244:	11006826 	beq	r2,r4,180b3e8 <__adddf3+0x61c>
 180b248:	00c7c83a 	sub	r3,zero,r3
 180b24c:	42002034 	orhi	r8,r8,128
 180b250:	01000e04 	movi	r4,56
 180b254:	20c07c16 	blt	r4,r3,180b448 <__adddf3+0x67c>
 180b258:	010007c4 	movi	r4,31
 180b25c:	20c0da16 	blt	r4,r3,180b5c8 <__adddf3+0x7fc>
 180b260:	01000804 	movi	r4,32
 180b264:	20c9c83a 	sub	r4,r4,r3
 180b268:	4114983a 	sll	r10,r8,r4
 180b26c:	88cad83a 	srl	r5,r17,r3
 180b270:	8908983a 	sll	r4,r17,r4
 180b274:	40c6d83a 	srl	r3,r8,r3
 180b278:	5162b03a 	or	r17,r10,r5
 180b27c:	2008c03a 	cmpne	r4,r4,zero
 180b280:	8922b03a 	or	r17,r17,r4
 180b284:	3463c83a 	sub	r17,r6,r17
 180b288:	48c7c83a 	sub	r3,r9,r3
 180b28c:	344d803a 	cmpltu	r6,r6,r17
 180b290:	1991c83a 	sub	r8,r3,r6
 180b294:	1021883a 	mov	r16,r2
 180b298:	3825883a 	mov	r18,r7
 180b29c:	003f2706 	br	180af3c <__ram_exceptions_end+0xff7faaf8>
 180b2a0:	24d0b03a 	or	r8,r4,r19
 180b2a4:	40001b1e 	bne	r8,zero,180b314 <__adddf3+0x548>
 180b2a8:	0005883a 	mov	r2,zero
 180b2ac:	0007883a 	mov	r3,zero
 180b2b0:	0021883a 	mov	r16,zero
 180b2b4:	003f4d06 	br	180afec <__ram_exceptions_end+0xff7faba8>
 180b2b8:	008007c4 	movi	r2,31
 180b2bc:	11003c16 	blt	r2,r4,180b3b0 <__adddf3+0x5e4>
 180b2c0:	00800804 	movi	r2,32
 180b2c4:	1105c83a 	sub	r2,r2,r4
 180b2c8:	488e983a 	sll	r7,r9,r2
 180b2cc:	310ad83a 	srl	r5,r6,r4
 180b2d0:	3084983a 	sll	r2,r6,r2
 180b2d4:	4912d83a 	srl	r9,r9,r4
 180b2d8:	394ab03a 	or	r5,r7,r5
 180b2dc:	1004c03a 	cmpne	r2,r2,zero
 180b2e0:	288ab03a 	or	r5,r5,r2
 180b2e4:	003f5306 	br	180b034 <__ram_exceptions_end+0xff7fabf0>
 180b2e8:	4448b03a 	or	r4,r8,r17
 180b2ec:	20003e26 	beq	r4,zero,180b3e8 <__adddf3+0x61c>
 180b2f0:	00c6303a 	nor	r3,zero,r3
 180b2f4:	18003a1e 	bne	r3,zero,180b3e0 <__adddf3+0x614>
 180b2f8:	3463c83a 	sub	r17,r6,r17
 180b2fc:	4a07c83a 	sub	r3,r9,r8
 180b300:	344d803a 	cmpltu	r6,r6,r17
 180b304:	1991c83a 	sub	r8,r3,r6
 180b308:	1021883a 	mov	r16,r2
 180b30c:	3825883a 	mov	r18,r7
 180b310:	003f0a06 	br	180af3c <__ram_exceptions_end+0xff7faaf8>
 180b314:	2023883a 	mov	r17,r4
 180b318:	003f0d06 	br	180af50 <__ram_exceptions_end+0xff7fab0c>
 180b31c:	0081ffc4 	movi	r2,2047
 180b320:	80bf3f1e 	bne	r16,r2,180b020 <__ram_exceptions_end+0xff7fabdc>
 180b324:	003ec806 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b328:	0005883a 	mov	r2,zero
 180b32c:	003fb106 	br	180b1f4 <__ram_exceptions_end+0xff7fadb0>
 180b330:	0007883a 	mov	r3,zero
 180b334:	003fbc06 	br	180b228 <__ram_exceptions_end+0xff7fade4>
 180b338:	4444b03a 	or	r2,r8,r17
 180b33c:	8000871e 	bne	r16,zero,180b55c <__adddf3+0x790>
 180b340:	1000ba26 	beq	r2,zero,180b62c <__adddf3+0x860>
 180b344:	4984b03a 	or	r2,r9,r6
 180b348:	103ebf26 	beq	r2,zero,180ae48 <__ram_exceptions_end+0xff7faa04>
 180b34c:	8985883a 	add	r2,r17,r6
 180b350:	4247883a 	add	r3,r8,r9
 180b354:	1451803a 	cmpltu	r8,r2,r17
 180b358:	40d1883a 	add	r8,r8,r3
 180b35c:	40c0202c 	andhi	r3,r8,128
 180b360:	1023883a 	mov	r17,r2
 180b364:	183f1a26 	beq	r3,zero,180afd0 <__ram_exceptions_end+0xff7fab8c>
 180b368:	00bfe034 	movhi	r2,65408
 180b36c:	10bfffc4 	addi	r2,r2,-1
 180b370:	2021883a 	mov	r16,r4
 180b374:	4090703a 	and	r8,r8,r2
 180b378:	003eb306 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b37c:	4444b03a 	or	r2,r8,r17
 180b380:	8000291e 	bne	r16,zero,180b428 <__adddf3+0x65c>
 180b384:	10004b1e 	bne	r2,zero,180b4b4 <__adddf3+0x6e8>
 180b388:	4990b03a 	or	r8,r9,r6
 180b38c:	40008b26 	beq	r8,zero,180b5bc <__adddf3+0x7f0>
 180b390:	4811883a 	mov	r8,r9
 180b394:	3023883a 	mov	r17,r6
 180b398:	3825883a 	mov	r18,r7
 180b39c:	003eaa06 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b3a0:	1021883a 	mov	r16,r2
 180b3a4:	0011883a 	mov	r8,zero
 180b3a8:	0005883a 	mov	r2,zero
 180b3ac:	003f0f06 	br	180afec <__ram_exceptions_end+0xff7faba8>
 180b3b0:	217ff804 	addi	r5,r4,-32
 180b3b4:	00800804 	movi	r2,32
 180b3b8:	494ad83a 	srl	r5,r9,r5
 180b3bc:	20807d26 	beq	r4,r2,180b5b4 <__adddf3+0x7e8>
 180b3c0:	00801004 	movi	r2,64
 180b3c4:	1109c83a 	sub	r4,r2,r4
 180b3c8:	4912983a 	sll	r9,r9,r4
 180b3cc:	498cb03a 	or	r6,r9,r6
 180b3d0:	300cc03a 	cmpne	r6,r6,zero
 180b3d4:	298ab03a 	or	r5,r5,r6
 180b3d8:	0013883a 	mov	r9,zero
 180b3dc:	003f1506 	br	180b034 <__ram_exceptions_end+0xff7fabf0>
 180b3e0:	0101ffc4 	movi	r4,2047
 180b3e4:	113f9a1e 	bne	r2,r4,180b250 <__ram_exceptions_end+0xff7fae0c>
 180b3e8:	4811883a 	mov	r8,r9
 180b3ec:	3023883a 	mov	r17,r6
 180b3f0:	1021883a 	mov	r16,r2
 180b3f4:	3825883a 	mov	r18,r7
 180b3f8:	003e9306 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b3fc:	8000161e 	bne	r16,zero,180b458 <__adddf3+0x68c>
 180b400:	444ab03a 	or	r5,r8,r17
 180b404:	28005126 	beq	r5,zero,180b54c <__adddf3+0x780>
 180b408:	0108303a 	nor	r4,zero,r4
 180b40c:	20004d1e 	bne	r4,zero,180b544 <__adddf3+0x778>
 180b410:	89a3883a 	add	r17,r17,r6
 180b414:	4253883a 	add	r9,r8,r9
 180b418:	898d803a 	cmpltu	r6,r17,r6
 180b41c:	3251883a 	add	r8,r6,r9
 180b420:	1021883a 	mov	r16,r2
 180b424:	003f0806 	br	180b048 <__ram_exceptions_end+0xff7fac04>
 180b428:	1000301e 	bne	r2,zero,180b4ec <__adddf3+0x720>
 180b42c:	4984b03a 	or	r2,r9,r6
 180b430:	10007126 	beq	r2,zero,180b5f8 <__adddf3+0x82c>
 180b434:	4811883a 	mov	r8,r9
 180b438:	3023883a 	mov	r17,r6
 180b43c:	3825883a 	mov	r18,r7
 180b440:	0401ffc4 	movi	r16,2047
 180b444:	003e8006 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b448:	4462b03a 	or	r17,r8,r17
 180b44c:	8822c03a 	cmpne	r17,r17,zero
 180b450:	0007883a 	mov	r3,zero
 180b454:	003f8b06 	br	180b284 <__ram_exceptions_end+0xff7fae40>
 180b458:	0141ffc4 	movi	r5,2047
 180b45c:	11403b26 	beq	r2,r5,180b54c <__adddf3+0x780>
 180b460:	0109c83a 	sub	r4,zero,r4
 180b464:	42002034 	orhi	r8,r8,128
 180b468:	01400e04 	movi	r5,56
 180b46c:	29006716 	blt	r5,r4,180b60c <__adddf3+0x840>
 180b470:	014007c4 	movi	r5,31
 180b474:	29007016 	blt	r5,r4,180b638 <__adddf3+0x86c>
 180b478:	01400804 	movi	r5,32
 180b47c:	290bc83a 	sub	r5,r5,r4
 180b480:	4154983a 	sll	r10,r8,r5
 180b484:	890ed83a 	srl	r7,r17,r4
 180b488:	894a983a 	sll	r5,r17,r5
 180b48c:	4108d83a 	srl	r4,r8,r4
 180b490:	51e2b03a 	or	r17,r10,r7
 180b494:	280ac03a 	cmpne	r5,r5,zero
 180b498:	8962b03a 	or	r17,r17,r5
 180b49c:	89a3883a 	add	r17,r17,r6
 180b4a0:	2253883a 	add	r9,r4,r9
 180b4a4:	898d803a 	cmpltu	r6,r17,r6
 180b4a8:	3251883a 	add	r8,r6,r9
 180b4ac:	1021883a 	mov	r16,r2
 180b4b0:	003ee506 	br	180b048 <__ram_exceptions_end+0xff7fac04>
 180b4b4:	4984b03a 	or	r2,r9,r6
 180b4b8:	103e6326 	beq	r2,zero,180ae48 <__ram_exceptions_end+0xff7faa04>
 180b4bc:	8987c83a 	sub	r3,r17,r6
 180b4c0:	88c9803a 	cmpltu	r4,r17,r3
 180b4c4:	4245c83a 	sub	r2,r8,r9
 180b4c8:	1105c83a 	sub	r2,r2,r4
 180b4cc:	1100202c 	andhi	r4,r2,128
 180b4d0:	203ebb26 	beq	r4,zero,180afc0 <__ram_exceptions_end+0xff7fab7c>
 180b4d4:	3463c83a 	sub	r17,r6,r17
 180b4d8:	4a07c83a 	sub	r3,r9,r8
 180b4dc:	344d803a 	cmpltu	r6,r6,r17
 180b4e0:	1991c83a 	sub	r8,r3,r6
 180b4e4:	3825883a 	mov	r18,r7
 180b4e8:	003e5706 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b4ec:	4984b03a 	or	r2,r9,r6
 180b4f0:	10002e26 	beq	r2,zero,180b5ac <__adddf3+0x7e0>
 180b4f4:	4004d0fa 	srli	r2,r8,3
 180b4f8:	8822d0fa 	srli	r17,r17,3
 180b4fc:	4010977a 	slli	r8,r8,29
 180b500:	10c0022c 	andhi	r3,r2,8
 180b504:	4462b03a 	or	r17,r8,r17
 180b508:	18000826 	beq	r3,zero,180b52c <__adddf3+0x760>
 180b50c:	4808d0fa 	srli	r4,r9,3
 180b510:	20c0022c 	andhi	r3,r4,8
 180b514:	1800051e 	bne	r3,zero,180b52c <__adddf3+0x760>
 180b518:	300cd0fa 	srli	r6,r6,3
 180b51c:	4806977a 	slli	r3,r9,29
 180b520:	2005883a 	mov	r2,r4
 180b524:	3825883a 	mov	r18,r7
 180b528:	19a2b03a 	or	r17,r3,r6
 180b52c:	8810d77a 	srli	r8,r17,29
 180b530:	100490fa 	slli	r2,r2,3
 180b534:	882290fa 	slli	r17,r17,3
 180b538:	0401ffc4 	movi	r16,2047
 180b53c:	4090b03a 	or	r8,r8,r2
 180b540:	003e4106 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b544:	0141ffc4 	movi	r5,2047
 180b548:	117fc71e 	bne	r2,r5,180b468 <__ram_exceptions_end+0xff7fb024>
 180b54c:	4811883a 	mov	r8,r9
 180b550:	3023883a 	mov	r17,r6
 180b554:	1021883a 	mov	r16,r2
 180b558:	003e3b06 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b55c:	10002f26 	beq	r2,zero,180b61c <__adddf3+0x850>
 180b560:	4984b03a 	or	r2,r9,r6
 180b564:	10001126 	beq	r2,zero,180b5ac <__adddf3+0x7e0>
 180b568:	4004d0fa 	srli	r2,r8,3
 180b56c:	8822d0fa 	srli	r17,r17,3
 180b570:	4010977a 	slli	r8,r8,29
 180b574:	10c0022c 	andhi	r3,r2,8
 180b578:	4462b03a 	or	r17,r8,r17
 180b57c:	183feb26 	beq	r3,zero,180b52c <__ram_exceptions_end+0xff7fb0e8>
 180b580:	4808d0fa 	srli	r4,r9,3
 180b584:	20c0022c 	andhi	r3,r4,8
 180b588:	183fe81e 	bne	r3,zero,180b52c <__ram_exceptions_end+0xff7fb0e8>
 180b58c:	300cd0fa 	srli	r6,r6,3
 180b590:	4806977a 	slli	r3,r9,29
 180b594:	2005883a 	mov	r2,r4
 180b598:	19a2b03a 	or	r17,r3,r6
 180b59c:	003fe306 	br	180b52c <__ram_exceptions_end+0xff7fb0e8>
 180b5a0:	0011883a 	mov	r8,zero
 180b5a4:	0005883a 	mov	r2,zero
 180b5a8:	003e3f06 	br	180aea8 <__ram_exceptions_end+0xff7faa64>
 180b5ac:	0401ffc4 	movi	r16,2047
 180b5b0:	003e2506 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b5b4:	0013883a 	mov	r9,zero
 180b5b8:	003f8406 	br	180b3cc <__ram_exceptions_end+0xff7faf88>
 180b5bc:	0005883a 	mov	r2,zero
 180b5c0:	0007883a 	mov	r3,zero
 180b5c4:	003e8906 	br	180afec <__ram_exceptions_end+0xff7faba8>
 180b5c8:	197ff804 	addi	r5,r3,-32
 180b5cc:	01000804 	movi	r4,32
 180b5d0:	414ad83a 	srl	r5,r8,r5
 180b5d4:	19002426 	beq	r3,r4,180b668 <__adddf3+0x89c>
 180b5d8:	01001004 	movi	r4,64
 180b5dc:	20c7c83a 	sub	r3,r4,r3
 180b5e0:	40c6983a 	sll	r3,r8,r3
 180b5e4:	1c46b03a 	or	r3,r3,r17
 180b5e8:	1806c03a 	cmpne	r3,r3,zero
 180b5ec:	28e2b03a 	or	r17,r5,r3
 180b5f0:	0007883a 	mov	r3,zero
 180b5f4:	003f2306 	br	180b284 <__ram_exceptions_end+0xff7fae40>
 180b5f8:	0007883a 	mov	r3,zero
 180b5fc:	5811883a 	mov	r8,r11
 180b600:	00bfffc4 	movi	r2,-1
 180b604:	0401ffc4 	movi	r16,2047
 180b608:	003e7806 	br	180afec <__ram_exceptions_end+0xff7faba8>
 180b60c:	4462b03a 	or	r17,r8,r17
 180b610:	8822c03a 	cmpne	r17,r17,zero
 180b614:	0009883a 	mov	r4,zero
 180b618:	003fa006 	br	180b49c <__ram_exceptions_end+0xff7fb058>
 180b61c:	4811883a 	mov	r8,r9
 180b620:	3023883a 	mov	r17,r6
 180b624:	0401ffc4 	movi	r16,2047
 180b628:	003e0706 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b62c:	4811883a 	mov	r8,r9
 180b630:	3023883a 	mov	r17,r6
 180b634:	003e0406 	br	180ae48 <__ram_exceptions_end+0xff7faa04>
 180b638:	21fff804 	addi	r7,r4,-32
 180b63c:	01400804 	movi	r5,32
 180b640:	41ced83a 	srl	r7,r8,r7
 180b644:	21400a26 	beq	r4,r5,180b670 <__adddf3+0x8a4>
 180b648:	01401004 	movi	r5,64
 180b64c:	2909c83a 	sub	r4,r5,r4
 180b650:	4108983a 	sll	r4,r8,r4
 180b654:	2448b03a 	or	r4,r4,r17
 180b658:	2008c03a 	cmpne	r4,r4,zero
 180b65c:	3922b03a 	or	r17,r7,r4
 180b660:	0009883a 	mov	r4,zero
 180b664:	003f8d06 	br	180b49c <__ram_exceptions_end+0xff7fb058>
 180b668:	0007883a 	mov	r3,zero
 180b66c:	003fdd06 	br	180b5e4 <__ram_exceptions_end+0xff7fb1a0>
 180b670:	0009883a 	mov	r4,zero
 180b674:	003ff706 	br	180b654 <__ram_exceptions_end+0xff7fb210>

0180b678 <__divdf3>:
 180b678:	defff204 	addi	sp,sp,-56
 180b67c:	dd400915 	stw	r21,36(sp)
 180b680:	282ad53a 	srli	r21,r5,20
 180b684:	dd000815 	stw	r20,32(sp)
 180b688:	2828d7fa 	srli	r20,r5,31
 180b68c:	dc000415 	stw	r16,16(sp)
 180b690:	04000434 	movhi	r16,16
 180b694:	df000c15 	stw	fp,48(sp)
 180b698:	843fffc4 	addi	r16,r16,-1
 180b69c:	dfc00d15 	stw	ra,52(sp)
 180b6a0:	ddc00b15 	stw	r23,44(sp)
 180b6a4:	dd800a15 	stw	r22,40(sp)
 180b6a8:	dcc00715 	stw	r19,28(sp)
 180b6ac:	dc800615 	stw	r18,24(sp)
 180b6b0:	dc400515 	stw	r17,20(sp)
 180b6b4:	ad41ffcc 	andi	r21,r21,2047
 180b6b8:	2c20703a 	and	r16,r5,r16
 180b6bc:	a7003fcc 	andi	fp,r20,255
 180b6c0:	a8006126 	beq	r21,zero,180b848 <__divdf3+0x1d0>
 180b6c4:	0081ffc4 	movi	r2,2047
 180b6c8:	2025883a 	mov	r18,r4
 180b6cc:	a8803726 	beq	r21,r2,180b7ac <__divdf3+0x134>
 180b6d0:	80800434 	orhi	r2,r16,16
 180b6d4:	100490fa 	slli	r2,r2,3
 180b6d8:	2020d77a 	srli	r16,r4,29
 180b6dc:	202490fa 	slli	r18,r4,3
 180b6e0:	ad7f0044 	addi	r21,r21,-1023
 180b6e4:	80a0b03a 	or	r16,r16,r2
 180b6e8:	0027883a 	mov	r19,zero
 180b6ec:	0013883a 	mov	r9,zero
 180b6f0:	3804d53a 	srli	r2,r7,20
 180b6f4:	382cd7fa 	srli	r22,r7,31
 180b6f8:	04400434 	movhi	r17,16
 180b6fc:	8c7fffc4 	addi	r17,r17,-1
 180b700:	1081ffcc 	andi	r2,r2,2047
 180b704:	3011883a 	mov	r8,r6
 180b708:	3c62703a 	and	r17,r7,r17
 180b70c:	b5c03fcc 	andi	r23,r22,255
 180b710:	10006c26 	beq	r2,zero,180b8c4 <__divdf3+0x24c>
 180b714:	00c1ffc4 	movi	r3,2047
 180b718:	10c06426 	beq	r2,r3,180b8ac <__divdf3+0x234>
 180b71c:	88c00434 	orhi	r3,r17,16
 180b720:	180690fa 	slli	r3,r3,3
 180b724:	3022d77a 	srli	r17,r6,29
 180b728:	301090fa 	slli	r8,r6,3
 180b72c:	10bf0044 	addi	r2,r2,-1023
 180b730:	88e2b03a 	or	r17,r17,r3
 180b734:	000f883a 	mov	r7,zero
 180b738:	a58cf03a 	xor	r6,r20,r22
 180b73c:	3cc8b03a 	or	r4,r7,r19
 180b740:	a8abc83a 	sub	r21,r21,r2
 180b744:	008003c4 	movi	r2,15
 180b748:	3007883a 	mov	r3,r6
 180b74c:	34c03fcc 	andi	r19,r6,255
 180b750:	11009036 	bltu	r2,r4,180b994 <__divdf3+0x31c>
 180b754:	200890ba 	slli	r4,r4,2
 180b758:	00806074 	movhi	r2,385
 180b75c:	10addb04 	addi	r2,r2,-18580
 180b760:	2089883a 	add	r4,r4,r2
 180b764:	20800017 	ldw	r2,0(r4)
 180b768:	1000683a 	jmp	r2
 180b76c:	0180b994 	movui	r6,742
 180b770:	0180b7e4 	muli	r6,zero,735
 180b774:	0180b984 	movi	r6,742
 180b778:	0180b7d8 	cmpnei	r6,zero,735
 180b77c:	0180b984 	movi	r6,742
 180b780:	0180b958 	cmpnei	r6,zero,741
 180b784:	0180b984 	movi	r6,742
 180b788:	0180b7d8 	cmpnei	r6,zero,735
 180b78c:	0180b7e4 	muli	r6,zero,735
 180b790:	0180b7e4 	muli	r6,zero,735
 180b794:	0180b958 	cmpnei	r6,zero,741
 180b798:	0180b7d8 	cmpnei	r6,zero,735
 180b79c:	0180b7c8 	cmpgei	r6,zero,735
 180b7a0:	0180b7c8 	cmpgei	r6,zero,735
 180b7a4:	0180b7c8 	cmpgei	r6,zero,735
 180b7a8:	0180bc78 	rdprs	r6,zero,753
 180b7ac:	2404b03a 	or	r2,r4,r16
 180b7b0:	1000661e 	bne	r2,zero,180b94c <__divdf3+0x2d4>
 180b7b4:	04c00204 	movi	r19,8
 180b7b8:	0021883a 	mov	r16,zero
 180b7bc:	0025883a 	mov	r18,zero
 180b7c0:	02400084 	movi	r9,2
 180b7c4:	003fca06 	br	180b6f0 <__ram_exceptions_end+0xff7fb2ac>
 180b7c8:	8023883a 	mov	r17,r16
 180b7cc:	9011883a 	mov	r8,r18
 180b7d0:	e02f883a 	mov	r23,fp
 180b7d4:	480f883a 	mov	r7,r9
 180b7d8:	00800084 	movi	r2,2
 180b7dc:	3881311e 	bne	r7,r2,180bca4 <__divdf3+0x62c>
 180b7e0:	b827883a 	mov	r19,r23
 180b7e4:	98c0004c 	andi	r3,r19,1
 180b7e8:	0081ffc4 	movi	r2,2047
 180b7ec:	000b883a 	mov	r5,zero
 180b7f0:	0025883a 	mov	r18,zero
 180b7f4:	1004953a 	slli	r2,r2,20
 180b7f8:	18c03fcc 	andi	r3,r3,255
 180b7fc:	04400434 	movhi	r17,16
 180b800:	8c7fffc4 	addi	r17,r17,-1
 180b804:	180697fa 	slli	r3,r3,31
 180b808:	2c4a703a 	and	r5,r5,r17
 180b80c:	288ab03a 	or	r5,r5,r2
 180b810:	28c6b03a 	or	r3,r5,r3
 180b814:	9005883a 	mov	r2,r18
 180b818:	dfc00d17 	ldw	ra,52(sp)
 180b81c:	df000c17 	ldw	fp,48(sp)
 180b820:	ddc00b17 	ldw	r23,44(sp)
 180b824:	dd800a17 	ldw	r22,40(sp)
 180b828:	dd400917 	ldw	r21,36(sp)
 180b82c:	dd000817 	ldw	r20,32(sp)
 180b830:	dcc00717 	ldw	r19,28(sp)
 180b834:	dc800617 	ldw	r18,24(sp)
 180b838:	dc400517 	ldw	r17,20(sp)
 180b83c:	dc000417 	ldw	r16,16(sp)
 180b840:	dec00e04 	addi	sp,sp,56
 180b844:	f800283a 	ret
 180b848:	2404b03a 	or	r2,r4,r16
 180b84c:	2027883a 	mov	r19,r4
 180b850:	10003926 	beq	r2,zero,180b938 <__divdf3+0x2c0>
 180b854:	80012e26 	beq	r16,zero,180bd10 <__divdf3+0x698>
 180b858:	8009883a 	mov	r4,r16
 180b85c:	d9800315 	stw	r6,12(sp)
 180b860:	d9c00215 	stw	r7,8(sp)
 180b864:	180d3d00 	call	180d3d0 <__clzsi2>
 180b868:	d9800317 	ldw	r6,12(sp)
 180b86c:	d9c00217 	ldw	r7,8(sp)
 180b870:	113ffd44 	addi	r4,r2,-11
 180b874:	00c00704 	movi	r3,28
 180b878:	19012116 	blt	r3,r4,180bd00 <__divdf3+0x688>
 180b87c:	00c00744 	movi	r3,29
 180b880:	147ffe04 	addi	r17,r2,-8
 180b884:	1907c83a 	sub	r3,r3,r4
 180b888:	8460983a 	sll	r16,r16,r17
 180b88c:	98c6d83a 	srl	r3,r19,r3
 180b890:	9c64983a 	sll	r18,r19,r17
 180b894:	1c20b03a 	or	r16,r3,r16
 180b898:	1080fcc4 	addi	r2,r2,1011
 180b89c:	00abc83a 	sub	r21,zero,r2
 180b8a0:	0027883a 	mov	r19,zero
 180b8a4:	0013883a 	mov	r9,zero
 180b8a8:	003f9106 	br	180b6f0 <__ram_exceptions_end+0xff7fb2ac>
 180b8ac:	3446b03a 	or	r3,r6,r17
 180b8b0:	18001f1e 	bne	r3,zero,180b930 <__divdf3+0x2b8>
 180b8b4:	0023883a 	mov	r17,zero
 180b8b8:	0011883a 	mov	r8,zero
 180b8bc:	01c00084 	movi	r7,2
 180b8c0:	003f9d06 	br	180b738 <__ram_exceptions_end+0xff7fb2f4>
 180b8c4:	3446b03a 	or	r3,r6,r17
 180b8c8:	18001526 	beq	r3,zero,180b920 <__divdf3+0x2a8>
 180b8cc:	88011b26 	beq	r17,zero,180bd3c <__divdf3+0x6c4>
 180b8d0:	8809883a 	mov	r4,r17
 180b8d4:	d9800315 	stw	r6,12(sp)
 180b8d8:	da400115 	stw	r9,4(sp)
 180b8dc:	180d3d00 	call	180d3d0 <__clzsi2>
 180b8e0:	d9800317 	ldw	r6,12(sp)
 180b8e4:	da400117 	ldw	r9,4(sp)
 180b8e8:	113ffd44 	addi	r4,r2,-11
 180b8ec:	00c00704 	movi	r3,28
 180b8f0:	19010e16 	blt	r3,r4,180bd2c <__divdf3+0x6b4>
 180b8f4:	00c00744 	movi	r3,29
 180b8f8:	123ffe04 	addi	r8,r2,-8
 180b8fc:	1907c83a 	sub	r3,r3,r4
 180b900:	8a22983a 	sll	r17,r17,r8
 180b904:	30c6d83a 	srl	r3,r6,r3
 180b908:	3210983a 	sll	r8,r6,r8
 180b90c:	1c62b03a 	or	r17,r3,r17
 180b910:	1080fcc4 	addi	r2,r2,1011
 180b914:	0085c83a 	sub	r2,zero,r2
 180b918:	000f883a 	mov	r7,zero
 180b91c:	003f8606 	br	180b738 <__ram_exceptions_end+0xff7fb2f4>
 180b920:	0023883a 	mov	r17,zero
 180b924:	0011883a 	mov	r8,zero
 180b928:	01c00044 	movi	r7,1
 180b92c:	003f8206 	br	180b738 <__ram_exceptions_end+0xff7fb2f4>
 180b930:	01c000c4 	movi	r7,3
 180b934:	003f8006 	br	180b738 <__ram_exceptions_end+0xff7fb2f4>
 180b938:	04c00104 	movi	r19,4
 180b93c:	0021883a 	mov	r16,zero
 180b940:	0025883a 	mov	r18,zero
 180b944:	02400044 	movi	r9,1
 180b948:	003f6906 	br	180b6f0 <__ram_exceptions_end+0xff7fb2ac>
 180b94c:	04c00304 	movi	r19,12
 180b950:	024000c4 	movi	r9,3
 180b954:	003f6606 	br	180b6f0 <__ram_exceptions_end+0xff7fb2ac>
 180b958:	01400434 	movhi	r5,16
 180b95c:	0007883a 	mov	r3,zero
 180b960:	297fffc4 	addi	r5,r5,-1
 180b964:	04bfffc4 	movi	r18,-1
 180b968:	0081ffc4 	movi	r2,2047
 180b96c:	003fa106 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180b970:	00c00044 	movi	r3,1
 180b974:	1887c83a 	sub	r3,r3,r2
 180b978:	01000e04 	movi	r4,56
 180b97c:	20c1210e 	bge	r4,r3,180be04 <__divdf3+0x78c>
 180b980:	98c0004c 	andi	r3,r19,1
 180b984:	0005883a 	mov	r2,zero
 180b988:	000b883a 	mov	r5,zero
 180b98c:	0025883a 	mov	r18,zero
 180b990:	003f9806 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180b994:	8c00fd36 	bltu	r17,r16,180bd8c <__divdf3+0x714>
 180b998:	8440fb26 	beq	r16,r17,180bd88 <__divdf3+0x710>
 180b99c:	8007883a 	mov	r3,r16
 180b9a0:	ad7fffc4 	addi	r21,r21,-1
 180b9a4:	0021883a 	mov	r16,zero
 180b9a8:	4004d63a 	srli	r2,r8,24
 180b9ac:	8822923a 	slli	r17,r17,8
 180b9b0:	1809883a 	mov	r4,r3
 180b9b4:	402c923a 	slli	r22,r8,8
 180b9b8:	88b8b03a 	or	fp,r17,r2
 180b9bc:	e028d43a 	srli	r20,fp,16
 180b9c0:	d8c00015 	stw	r3,0(sp)
 180b9c4:	e5ffffcc 	andi	r23,fp,65535
 180b9c8:	a00b883a 	mov	r5,r20
 180b9cc:	180ad100 	call	180ad10 <__udivsi3>
 180b9d0:	d8c00017 	ldw	r3,0(sp)
 180b9d4:	a00b883a 	mov	r5,r20
 180b9d8:	d8800315 	stw	r2,12(sp)
 180b9dc:	1809883a 	mov	r4,r3
 180b9e0:	180ad740 	call	180ad74 <__umodsi3>
 180b9e4:	d9800317 	ldw	r6,12(sp)
 180b9e8:	1006943a 	slli	r3,r2,16
 180b9ec:	9004d43a 	srli	r2,r18,16
 180b9f0:	b9a3383a 	mul	r17,r23,r6
 180b9f4:	10c4b03a 	or	r2,r2,r3
 180b9f8:	1440062e 	bgeu	r2,r17,180ba14 <__divdf3+0x39c>
 180b9fc:	1705883a 	add	r2,r2,fp
 180ba00:	30ffffc4 	addi	r3,r6,-1
 180ba04:	1700ee36 	bltu	r2,fp,180bdc0 <__divdf3+0x748>
 180ba08:	1440ed2e 	bgeu	r2,r17,180bdc0 <__divdf3+0x748>
 180ba0c:	31bfff84 	addi	r6,r6,-2
 180ba10:	1705883a 	add	r2,r2,fp
 180ba14:	1463c83a 	sub	r17,r2,r17
 180ba18:	a00b883a 	mov	r5,r20
 180ba1c:	8809883a 	mov	r4,r17
 180ba20:	d9800315 	stw	r6,12(sp)
 180ba24:	180ad100 	call	180ad10 <__udivsi3>
 180ba28:	a00b883a 	mov	r5,r20
 180ba2c:	8809883a 	mov	r4,r17
 180ba30:	d8800215 	stw	r2,8(sp)
 180ba34:	180ad740 	call	180ad74 <__umodsi3>
 180ba38:	d9c00217 	ldw	r7,8(sp)
 180ba3c:	1004943a 	slli	r2,r2,16
 180ba40:	94bfffcc 	andi	r18,r18,65535
 180ba44:	b9d1383a 	mul	r8,r23,r7
 180ba48:	90a4b03a 	or	r18,r18,r2
 180ba4c:	d9800317 	ldw	r6,12(sp)
 180ba50:	9200062e 	bgeu	r18,r8,180ba6c <__divdf3+0x3f4>
 180ba54:	9725883a 	add	r18,r18,fp
 180ba58:	38bfffc4 	addi	r2,r7,-1
 180ba5c:	9700d636 	bltu	r18,fp,180bdb8 <__divdf3+0x740>
 180ba60:	9200d52e 	bgeu	r18,r8,180bdb8 <__divdf3+0x740>
 180ba64:	39ffff84 	addi	r7,r7,-2
 180ba68:	9725883a 	add	r18,r18,fp
 180ba6c:	3004943a 	slli	r2,r6,16
 180ba70:	b012d43a 	srli	r9,r22,16
 180ba74:	b1bfffcc 	andi	r6,r22,65535
 180ba78:	11e2b03a 	or	r17,r2,r7
 180ba7c:	8806d43a 	srli	r3,r17,16
 180ba80:	893fffcc 	andi	r4,r17,65535
 180ba84:	218b383a 	mul	r5,r4,r6
 180ba88:	30c5383a 	mul	r2,r6,r3
 180ba8c:	2249383a 	mul	r4,r4,r9
 180ba90:	280ed43a 	srli	r7,r5,16
 180ba94:	9225c83a 	sub	r18,r18,r8
 180ba98:	2089883a 	add	r4,r4,r2
 180ba9c:	3909883a 	add	r4,r7,r4
 180baa0:	1a47383a 	mul	r3,r3,r9
 180baa4:	2080022e 	bgeu	r4,r2,180bab0 <__divdf3+0x438>
 180baa8:	00800074 	movhi	r2,1
 180baac:	1887883a 	add	r3,r3,r2
 180bab0:	2004d43a 	srli	r2,r4,16
 180bab4:	2008943a 	slli	r4,r4,16
 180bab8:	297fffcc 	andi	r5,r5,65535
 180babc:	10c7883a 	add	r3,r2,r3
 180bac0:	2149883a 	add	r4,r4,r5
 180bac4:	90c0a536 	bltu	r18,r3,180bd5c <__divdf3+0x6e4>
 180bac8:	90c0bf26 	beq	r18,r3,180bdc8 <__divdf3+0x750>
 180bacc:	90c7c83a 	sub	r3,r18,r3
 180bad0:	810fc83a 	sub	r7,r16,r4
 180bad4:	81e5803a 	cmpltu	r18,r16,r7
 180bad8:	1ca5c83a 	sub	r18,r3,r18
 180badc:	e480c126 	beq	fp,r18,180bde4 <__divdf3+0x76c>
 180bae0:	a00b883a 	mov	r5,r20
 180bae4:	9009883a 	mov	r4,r18
 180bae8:	d9800315 	stw	r6,12(sp)
 180baec:	d9c00215 	stw	r7,8(sp)
 180baf0:	da400115 	stw	r9,4(sp)
 180baf4:	180ad100 	call	180ad10 <__udivsi3>
 180baf8:	a00b883a 	mov	r5,r20
 180bafc:	9009883a 	mov	r4,r18
 180bb00:	d8800015 	stw	r2,0(sp)
 180bb04:	180ad740 	call	180ad74 <__umodsi3>
 180bb08:	d9c00217 	ldw	r7,8(sp)
 180bb0c:	da000017 	ldw	r8,0(sp)
 180bb10:	1006943a 	slli	r3,r2,16
 180bb14:	3804d43a 	srli	r2,r7,16
 180bb18:	ba21383a 	mul	r16,r23,r8
 180bb1c:	d9800317 	ldw	r6,12(sp)
 180bb20:	10c4b03a 	or	r2,r2,r3
 180bb24:	da400117 	ldw	r9,4(sp)
 180bb28:	1400062e 	bgeu	r2,r16,180bb44 <__divdf3+0x4cc>
 180bb2c:	1705883a 	add	r2,r2,fp
 180bb30:	40ffffc4 	addi	r3,r8,-1
 180bb34:	1700ad36 	bltu	r2,fp,180bdec <__divdf3+0x774>
 180bb38:	1400ac2e 	bgeu	r2,r16,180bdec <__divdf3+0x774>
 180bb3c:	423fff84 	addi	r8,r8,-2
 180bb40:	1705883a 	add	r2,r2,fp
 180bb44:	1421c83a 	sub	r16,r2,r16
 180bb48:	a00b883a 	mov	r5,r20
 180bb4c:	8009883a 	mov	r4,r16
 180bb50:	d9800315 	stw	r6,12(sp)
 180bb54:	d9c00215 	stw	r7,8(sp)
 180bb58:	da000015 	stw	r8,0(sp)
 180bb5c:	da400115 	stw	r9,4(sp)
 180bb60:	180ad100 	call	180ad10 <__udivsi3>
 180bb64:	8009883a 	mov	r4,r16
 180bb68:	a00b883a 	mov	r5,r20
 180bb6c:	1025883a 	mov	r18,r2
 180bb70:	180ad740 	call	180ad74 <__umodsi3>
 180bb74:	d9c00217 	ldw	r7,8(sp)
 180bb78:	1004943a 	slli	r2,r2,16
 180bb7c:	bcaf383a 	mul	r23,r23,r18
 180bb80:	393fffcc 	andi	r4,r7,65535
 180bb84:	2088b03a 	or	r4,r4,r2
 180bb88:	d9800317 	ldw	r6,12(sp)
 180bb8c:	da000017 	ldw	r8,0(sp)
 180bb90:	da400117 	ldw	r9,4(sp)
 180bb94:	25c0062e 	bgeu	r4,r23,180bbb0 <__divdf3+0x538>
 180bb98:	2709883a 	add	r4,r4,fp
 180bb9c:	90bfffc4 	addi	r2,r18,-1
 180bba0:	27009436 	bltu	r4,fp,180bdf4 <__divdf3+0x77c>
 180bba4:	25c0932e 	bgeu	r4,r23,180bdf4 <__divdf3+0x77c>
 180bba8:	94bfff84 	addi	r18,r18,-2
 180bbac:	2709883a 	add	r4,r4,fp
 180bbb0:	4004943a 	slli	r2,r8,16
 180bbb4:	25efc83a 	sub	r23,r4,r23
 180bbb8:	1490b03a 	or	r8,r2,r18
 180bbbc:	4008d43a 	srli	r4,r8,16
 180bbc0:	40ffffcc 	andi	r3,r8,65535
 180bbc4:	30c5383a 	mul	r2,r6,r3
 180bbc8:	1a47383a 	mul	r3,r3,r9
 180bbcc:	310d383a 	mul	r6,r6,r4
 180bbd0:	100ad43a 	srli	r5,r2,16
 180bbd4:	4913383a 	mul	r9,r9,r4
 180bbd8:	1987883a 	add	r3,r3,r6
 180bbdc:	28c7883a 	add	r3,r5,r3
 180bbe0:	1980022e 	bgeu	r3,r6,180bbec <__divdf3+0x574>
 180bbe4:	01000074 	movhi	r4,1
 180bbe8:	4913883a 	add	r9,r9,r4
 180bbec:	1808d43a 	srli	r4,r3,16
 180bbf0:	1806943a 	slli	r3,r3,16
 180bbf4:	10bfffcc 	andi	r2,r2,65535
 180bbf8:	2253883a 	add	r9,r4,r9
 180bbfc:	1887883a 	add	r3,r3,r2
 180bc00:	ba403836 	bltu	r23,r9,180bce4 <__divdf3+0x66c>
 180bc04:	ba403626 	beq	r23,r9,180bce0 <__divdf3+0x668>
 180bc08:	42000054 	ori	r8,r8,1
 180bc0c:	a880ffc4 	addi	r2,r21,1023
 180bc10:	00bf570e 	bge	zero,r2,180b970 <__ram_exceptions_end+0xff7fb52c>
 180bc14:	40c001cc 	andi	r3,r8,7
 180bc18:	18000726 	beq	r3,zero,180bc38 <__divdf3+0x5c0>
 180bc1c:	40c003cc 	andi	r3,r8,15
 180bc20:	01000104 	movi	r4,4
 180bc24:	19000426 	beq	r3,r4,180bc38 <__divdf3+0x5c0>
 180bc28:	4107883a 	add	r3,r8,r4
 180bc2c:	1a11803a 	cmpltu	r8,r3,r8
 180bc30:	8a23883a 	add	r17,r17,r8
 180bc34:	1811883a 	mov	r8,r3
 180bc38:	88c0402c 	andhi	r3,r17,256
 180bc3c:	18000426 	beq	r3,zero,180bc50 <__divdf3+0x5d8>
 180bc40:	00ffc034 	movhi	r3,65280
 180bc44:	18ffffc4 	addi	r3,r3,-1
 180bc48:	a8810004 	addi	r2,r21,1024
 180bc4c:	88e2703a 	and	r17,r17,r3
 180bc50:	00c1ff84 	movi	r3,2046
 180bc54:	18bee316 	blt	r3,r2,180b7e4 <__ram_exceptions_end+0xff7fb3a0>
 180bc58:	8824977a 	slli	r18,r17,29
 180bc5c:	4010d0fa 	srli	r8,r8,3
 180bc60:	8822927a 	slli	r17,r17,9
 180bc64:	1081ffcc 	andi	r2,r2,2047
 180bc68:	9224b03a 	or	r18,r18,r8
 180bc6c:	880ad33a 	srli	r5,r17,12
 180bc70:	98c0004c 	andi	r3,r19,1
 180bc74:	003edf06 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180bc78:	8080022c 	andhi	r2,r16,8
 180bc7c:	10001226 	beq	r2,zero,180bcc8 <__divdf3+0x650>
 180bc80:	8880022c 	andhi	r2,r17,8
 180bc84:	1000101e 	bne	r2,zero,180bcc8 <__divdf3+0x650>
 180bc88:	00800434 	movhi	r2,16
 180bc8c:	89400234 	orhi	r5,r17,8
 180bc90:	10bfffc4 	addi	r2,r2,-1
 180bc94:	b007883a 	mov	r3,r22
 180bc98:	288a703a 	and	r5,r5,r2
 180bc9c:	4025883a 	mov	r18,r8
 180bca0:	003f3106 	br	180b968 <__ram_exceptions_end+0xff7fb524>
 180bca4:	008000c4 	movi	r2,3
 180bca8:	3880a626 	beq	r7,r2,180bf44 <__divdf3+0x8cc>
 180bcac:	00800044 	movi	r2,1
 180bcb0:	3880521e 	bne	r7,r2,180bdfc <__divdf3+0x784>
 180bcb4:	b807883a 	mov	r3,r23
 180bcb8:	0005883a 	mov	r2,zero
 180bcbc:	000b883a 	mov	r5,zero
 180bcc0:	0025883a 	mov	r18,zero
 180bcc4:	003ecb06 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180bcc8:	00800434 	movhi	r2,16
 180bccc:	81400234 	orhi	r5,r16,8
 180bcd0:	10bfffc4 	addi	r2,r2,-1
 180bcd4:	a007883a 	mov	r3,r20
 180bcd8:	288a703a 	and	r5,r5,r2
 180bcdc:	003f2206 	br	180b968 <__ram_exceptions_end+0xff7fb524>
 180bce0:	183fca26 	beq	r3,zero,180bc0c <__ram_exceptions_end+0xff7fb7c8>
 180bce4:	e5ef883a 	add	r23,fp,r23
 180bce8:	40bfffc4 	addi	r2,r8,-1
 180bcec:	bf00392e 	bgeu	r23,fp,180bdd4 <__divdf3+0x75c>
 180bcf0:	1011883a 	mov	r8,r2
 180bcf4:	ba7fc41e 	bne	r23,r9,180bc08 <__ram_exceptions_end+0xff7fb7c4>
 180bcf8:	b0ffc31e 	bne	r22,r3,180bc08 <__ram_exceptions_end+0xff7fb7c4>
 180bcfc:	003fc306 	br	180bc0c <__ram_exceptions_end+0xff7fb7c8>
 180bd00:	143ff604 	addi	r16,r2,-40
 180bd04:	9c20983a 	sll	r16,r19,r16
 180bd08:	0025883a 	mov	r18,zero
 180bd0c:	003ee206 	br	180b898 <__ram_exceptions_end+0xff7fb454>
 180bd10:	d9800315 	stw	r6,12(sp)
 180bd14:	d9c00215 	stw	r7,8(sp)
 180bd18:	180d3d00 	call	180d3d0 <__clzsi2>
 180bd1c:	10800804 	addi	r2,r2,32
 180bd20:	d9c00217 	ldw	r7,8(sp)
 180bd24:	d9800317 	ldw	r6,12(sp)
 180bd28:	003ed106 	br	180b870 <__ram_exceptions_end+0xff7fb42c>
 180bd2c:	147ff604 	addi	r17,r2,-40
 180bd30:	3462983a 	sll	r17,r6,r17
 180bd34:	0011883a 	mov	r8,zero
 180bd38:	003ef506 	br	180b910 <__ram_exceptions_end+0xff7fb4cc>
 180bd3c:	3009883a 	mov	r4,r6
 180bd40:	d9800315 	stw	r6,12(sp)
 180bd44:	da400115 	stw	r9,4(sp)
 180bd48:	180d3d00 	call	180d3d0 <__clzsi2>
 180bd4c:	10800804 	addi	r2,r2,32
 180bd50:	da400117 	ldw	r9,4(sp)
 180bd54:	d9800317 	ldw	r6,12(sp)
 180bd58:	003ee306 	br	180b8e8 <__ram_exceptions_end+0xff7fb4a4>
 180bd5c:	85a1883a 	add	r16,r16,r22
 180bd60:	8585803a 	cmpltu	r2,r16,r22
 180bd64:	1705883a 	add	r2,r2,fp
 180bd68:	14a5883a 	add	r18,r2,r18
 180bd6c:	88bfffc4 	addi	r2,r17,-1
 180bd70:	e4800c2e 	bgeu	fp,r18,180bda4 <__divdf3+0x72c>
 180bd74:	90c03e36 	bltu	r18,r3,180be70 <__divdf3+0x7f8>
 180bd78:	1c806926 	beq	r3,r18,180bf20 <__divdf3+0x8a8>
 180bd7c:	90c7c83a 	sub	r3,r18,r3
 180bd80:	1023883a 	mov	r17,r2
 180bd84:	003f5206 	br	180bad0 <__ram_exceptions_end+0xff7fb68c>
 180bd88:	923f0436 	bltu	r18,r8,180b99c <__ram_exceptions_end+0xff7fb558>
 180bd8c:	800897fa 	slli	r4,r16,31
 180bd90:	9004d07a 	srli	r2,r18,1
 180bd94:	8006d07a 	srli	r3,r16,1
 180bd98:	902097fa 	slli	r16,r18,31
 180bd9c:	20a4b03a 	or	r18,r4,r2
 180bda0:	003f0106 	br	180b9a8 <__ram_exceptions_end+0xff7fb564>
 180bda4:	e4bff51e 	bne	fp,r18,180bd7c <__ram_exceptions_end+0xff7fb938>
 180bda8:	85bff22e 	bgeu	r16,r22,180bd74 <__ram_exceptions_end+0xff7fb930>
 180bdac:	e0c7c83a 	sub	r3,fp,r3
 180bdb0:	1023883a 	mov	r17,r2
 180bdb4:	003f4606 	br	180bad0 <__ram_exceptions_end+0xff7fb68c>
 180bdb8:	100f883a 	mov	r7,r2
 180bdbc:	003f2b06 	br	180ba6c <__ram_exceptions_end+0xff7fb628>
 180bdc0:	180d883a 	mov	r6,r3
 180bdc4:	003f1306 	br	180ba14 <__ram_exceptions_end+0xff7fb5d0>
 180bdc8:	813fe436 	bltu	r16,r4,180bd5c <__ram_exceptions_end+0xff7fb918>
 180bdcc:	0007883a 	mov	r3,zero
 180bdd0:	003f3f06 	br	180bad0 <__ram_exceptions_end+0xff7fb68c>
 180bdd4:	ba402c36 	bltu	r23,r9,180be88 <__divdf3+0x810>
 180bdd8:	4dc05426 	beq	r9,r23,180bf2c <__divdf3+0x8b4>
 180bddc:	1011883a 	mov	r8,r2
 180bde0:	003f8906 	br	180bc08 <__ram_exceptions_end+0xff7fb7c4>
 180bde4:	023fffc4 	movi	r8,-1
 180bde8:	003f8806 	br	180bc0c <__ram_exceptions_end+0xff7fb7c8>
 180bdec:	1811883a 	mov	r8,r3
 180bdf0:	003f5406 	br	180bb44 <__ram_exceptions_end+0xff7fb700>
 180bdf4:	1025883a 	mov	r18,r2
 180bdf8:	003f6d06 	br	180bbb0 <__ram_exceptions_end+0xff7fb76c>
 180bdfc:	b827883a 	mov	r19,r23
 180be00:	003f8206 	br	180bc0c <__ram_exceptions_end+0xff7fb7c8>
 180be04:	010007c4 	movi	r4,31
 180be08:	20c02616 	blt	r4,r3,180bea4 <__divdf3+0x82c>
 180be0c:	00800804 	movi	r2,32
 180be10:	10c5c83a 	sub	r2,r2,r3
 180be14:	888a983a 	sll	r5,r17,r2
 180be18:	40c8d83a 	srl	r4,r8,r3
 180be1c:	4084983a 	sll	r2,r8,r2
 180be20:	88e2d83a 	srl	r17,r17,r3
 180be24:	2906b03a 	or	r3,r5,r4
 180be28:	1004c03a 	cmpne	r2,r2,zero
 180be2c:	1886b03a 	or	r3,r3,r2
 180be30:	188001cc 	andi	r2,r3,7
 180be34:	10000726 	beq	r2,zero,180be54 <__divdf3+0x7dc>
 180be38:	188003cc 	andi	r2,r3,15
 180be3c:	01000104 	movi	r4,4
 180be40:	11000426 	beq	r2,r4,180be54 <__divdf3+0x7dc>
 180be44:	1805883a 	mov	r2,r3
 180be48:	10c00104 	addi	r3,r2,4
 180be4c:	1885803a 	cmpltu	r2,r3,r2
 180be50:	88a3883a 	add	r17,r17,r2
 180be54:	8880202c 	andhi	r2,r17,128
 180be58:	10002726 	beq	r2,zero,180bef8 <__divdf3+0x880>
 180be5c:	98c0004c 	andi	r3,r19,1
 180be60:	00800044 	movi	r2,1
 180be64:	000b883a 	mov	r5,zero
 180be68:	0025883a 	mov	r18,zero
 180be6c:	003e6106 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180be70:	85a1883a 	add	r16,r16,r22
 180be74:	8585803a 	cmpltu	r2,r16,r22
 180be78:	1705883a 	add	r2,r2,fp
 180be7c:	14a5883a 	add	r18,r2,r18
 180be80:	8c7fff84 	addi	r17,r17,-2
 180be84:	003f1106 	br	180bacc <__ram_exceptions_end+0xff7fb688>
 180be88:	b589883a 	add	r4,r22,r22
 180be8c:	25ad803a 	cmpltu	r22,r4,r22
 180be90:	b739883a 	add	fp,r22,fp
 180be94:	40bfff84 	addi	r2,r8,-2
 180be98:	bf2f883a 	add	r23,r23,fp
 180be9c:	202d883a 	mov	r22,r4
 180bea0:	003f9306 	br	180bcf0 <__ram_exceptions_end+0xff7fb8ac>
 180bea4:	013ff844 	movi	r4,-31
 180bea8:	2085c83a 	sub	r2,r4,r2
 180beac:	8888d83a 	srl	r4,r17,r2
 180beb0:	00800804 	movi	r2,32
 180beb4:	18802126 	beq	r3,r2,180bf3c <__divdf3+0x8c4>
 180beb8:	00801004 	movi	r2,64
 180bebc:	10c5c83a 	sub	r2,r2,r3
 180bec0:	8884983a 	sll	r2,r17,r2
 180bec4:	1204b03a 	or	r2,r2,r8
 180bec8:	1004c03a 	cmpne	r2,r2,zero
 180becc:	2084b03a 	or	r2,r4,r2
 180bed0:	144001cc 	andi	r17,r2,7
 180bed4:	88000d1e 	bne	r17,zero,180bf0c <__divdf3+0x894>
 180bed8:	000b883a 	mov	r5,zero
 180bedc:	1024d0fa 	srli	r18,r2,3
 180bee0:	98c0004c 	andi	r3,r19,1
 180bee4:	0005883a 	mov	r2,zero
 180bee8:	9464b03a 	or	r18,r18,r17
 180beec:	003e4106 	br	180b7f4 <__ram_exceptions_end+0xff7fb3b0>
 180bef0:	1007883a 	mov	r3,r2
 180bef4:	0023883a 	mov	r17,zero
 180bef8:	880a927a 	slli	r5,r17,9
 180befc:	1805883a 	mov	r2,r3
 180bf00:	8822977a 	slli	r17,r17,29
 180bf04:	280ad33a 	srli	r5,r5,12
 180bf08:	003ff406 	br	180bedc <__ram_exceptions_end+0xff7fba98>
 180bf0c:	10c003cc 	andi	r3,r2,15
 180bf10:	01000104 	movi	r4,4
 180bf14:	193ff626 	beq	r3,r4,180bef0 <__ram_exceptions_end+0xff7fbaac>
 180bf18:	0023883a 	mov	r17,zero
 180bf1c:	003fca06 	br	180be48 <__ram_exceptions_end+0xff7fba04>
 180bf20:	813fd336 	bltu	r16,r4,180be70 <__ram_exceptions_end+0xff7fba2c>
 180bf24:	1023883a 	mov	r17,r2
 180bf28:	003fa806 	br	180bdcc <__ram_exceptions_end+0xff7fb988>
 180bf2c:	b0ffd636 	bltu	r22,r3,180be88 <__ram_exceptions_end+0xff7fba44>
 180bf30:	1011883a 	mov	r8,r2
 180bf34:	b0ff341e 	bne	r22,r3,180bc08 <__ram_exceptions_end+0xff7fb7c4>
 180bf38:	003f3406 	br	180bc0c <__ram_exceptions_end+0xff7fb7c8>
 180bf3c:	0005883a 	mov	r2,zero
 180bf40:	003fe006 	br	180bec4 <__ram_exceptions_end+0xff7fba80>
 180bf44:	00800434 	movhi	r2,16
 180bf48:	89400234 	orhi	r5,r17,8
 180bf4c:	10bfffc4 	addi	r2,r2,-1
 180bf50:	b807883a 	mov	r3,r23
 180bf54:	288a703a 	and	r5,r5,r2
 180bf58:	4025883a 	mov	r18,r8
 180bf5c:	003e8206 	br	180b968 <__ram_exceptions_end+0xff7fb524>

0180bf60 <__eqdf2>:
 180bf60:	2804d53a 	srli	r2,r5,20
 180bf64:	3806d53a 	srli	r3,r7,20
 180bf68:	02000434 	movhi	r8,16
 180bf6c:	423fffc4 	addi	r8,r8,-1
 180bf70:	1081ffcc 	andi	r2,r2,2047
 180bf74:	0281ffc4 	movi	r10,2047
 180bf78:	2a12703a 	and	r9,r5,r8
 180bf7c:	18c1ffcc 	andi	r3,r3,2047
 180bf80:	3a10703a 	and	r8,r7,r8
 180bf84:	280ad7fa 	srli	r5,r5,31
 180bf88:	380ed7fa 	srli	r7,r7,31
 180bf8c:	12801026 	beq	r2,r10,180bfd0 <__eqdf2+0x70>
 180bf90:	0281ffc4 	movi	r10,2047
 180bf94:	1a800a26 	beq	r3,r10,180bfc0 <__eqdf2+0x60>
 180bf98:	10c00226 	beq	r2,r3,180bfa4 <__eqdf2+0x44>
 180bf9c:	00800044 	movi	r2,1
 180bfa0:	f800283a 	ret
 180bfa4:	4a3ffd1e 	bne	r9,r8,180bf9c <__ram_exceptions_end+0xff7fbb58>
 180bfa8:	21bffc1e 	bne	r4,r6,180bf9c <__ram_exceptions_end+0xff7fbb58>
 180bfac:	29c00c26 	beq	r5,r7,180bfe0 <__eqdf2+0x80>
 180bfb0:	103ffa1e 	bne	r2,zero,180bf9c <__ram_exceptions_end+0xff7fbb58>
 180bfb4:	2244b03a 	or	r2,r4,r9
 180bfb8:	1004c03a 	cmpne	r2,r2,zero
 180bfbc:	f800283a 	ret
 180bfc0:	3214b03a 	or	r10,r6,r8
 180bfc4:	503ff426 	beq	r10,zero,180bf98 <__ram_exceptions_end+0xff7fbb54>
 180bfc8:	00800044 	movi	r2,1
 180bfcc:	f800283a 	ret
 180bfd0:	2254b03a 	or	r10,r4,r9
 180bfd4:	503fee26 	beq	r10,zero,180bf90 <__ram_exceptions_end+0xff7fbb4c>
 180bfd8:	00800044 	movi	r2,1
 180bfdc:	f800283a 	ret
 180bfe0:	0005883a 	mov	r2,zero
 180bfe4:	f800283a 	ret

0180bfe8 <__gedf2>:
 180bfe8:	2804d53a 	srli	r2,r5,20
 180bfec:	3806d53a 	srli	r3,r7,20
 180bff0:	02000434 	movhi	r8,16
 180bff4:	423fffc4 	addi	r8,r8,-1
 180bff8:	1081ffcc 	andi	r2,r2,2047
 180bffc:	0241ffc4 	movi	r9,2047
 180c000:	2a14703a 	and	r10,r5,r8
 180c004:	18c1ffcc 	andi	r3,r3,2047
 180c008:	3a10703a 	and	r8,r7,r8
 180c00c:	280ad7fa 	srli	r5,r5,31
 180c010:	380ed7fa 	srli	r7,r7,31
 180c014:	12401d26 	beq	r2,r9,180c08c <__gedf2+0xa4>
 180c018:	0241ffc4 	movi	r9,2047
 180c01c:	1a401226 	beq	r3,r9,180c068 <__gedf2+0x80>
 180c020:	1000081e 	bne	r2,zero,180c044 <__gedf2+0x5c>
 180c024:	2296b03a 	or	r11,r4,r10
 180c028:	5813003a 	cmpeq	r9,r11,zero
 180c02c:	1800091e 	bne	r3,zero,180c054 <__gedf2+0x6c>
 180c030:	3218b03a 	or	r12,r6,r8
 180c034:	6000071e 	bne	r12,zero,180c054 <__gedf2+0x6c>
 180c038:	0005883a 	mov	r2,zero
 180c03c:	5800101e 	bne	r11,zero,180c080 <__gedf2+0x98>
 180c040:	f800283a 	ret
 180c044:	18000c1e 	bne	r3,zero,180c078 <__gedf2+0x90>
 180c048:	3212b03a 	or	r9,r6,r8
 180c04c:	48000c26 	beq	r9,zero,180c080 <__gedf2+0x98>
 180c050:	0013883a 	mov	r9,zero
 180c054:	39c03fcc 	andi	r7,r7,255
 180c058:	48000826 	beq	r9,zero,180c07c <__gedf2+0x94>
 180c05c:	38000926 	beq	r7,zero,180c084 <__gedf2+0x9c>
 180c060:	00800044 	movi	r2,1
 180c064:	f800283a 	ret
 180c068:	3212b03a 	or	r9,r6,r8
 180c06c:	483fec26 	beq	r9,zero,180c020 <__ram_exceptions_end+0xff7fbbdc>
 180c070:	00bfff84 	movi	r2,-2
 180c074:	f800283a 	ret
 180c078:	39c03fcc 	andi	r7,r7,255
 180c07c:	29c00626 	beq	r5,r7,180c098 <__gedf2+0xb0>
 180c080:	283ff726 	beq	r5,zero,180c060 <__ram_exceptions_end+0xff7fbc1c>
 180c084:	00bfffc4 	movi	r2,-1
 180c088:	f800283a 	ret
 180c08c:	2292b03a 	or	r9,r4,r10
 180c090:	483fe126 	beq	r9,zero,180c018 <__ram_exceptions_end+0xff7fbbd4>
 180c094:	003ff606 	br	180c070 <__ram_exceptions_end+0xff7fbc2c>
 180c098:	18bff916 	blt	r3,r2,180c080 <__ram_exceptions_end+0xff7fbc3c>
 180c09c:	10c00316 	blt	r2,r3,180c0ac <__gedf2+0xc4>
 180c0a0:	42bff736 	bltu	r8,r10,180c080 <__ram_exceptions_end+0xff7fbc3c>
 180c0a4:	52000326 	beq	r10,r8,180c0b4 <__gedf2+0xcc>
 180c0a8:	5200042e 	bgeu	r10,r8,180c0bc <__gedf2+0xd4>
 180c0ac:	283fec1e 	bne	r5,zero,180c060 <__ram_exceptions_end+0xff7fbc1c>
 180c0b0:	003ff406 	br	180c084 <__ram_exceptions_end+0xff7fbc40>
 180c0b4:	313ff236 	bltu	r6,r4,180c080 <__ram_exceptions_end+0xff7fbc3c>
 180c0b8:	21bffc36 	bltu	r4,r6,180c0ac <__ram_exceptions_end+0xff7fbc68>
 180c0bc:	0005883a 	mov	r2,zero
 180c0c0:	f800283a 	ret

0180c0c4 <__ledf2>:
 180c0c4:	2804d53a 	srli	r2,r5,20
 180c0c8:	3810d53a 	srli	r8,r7,20
 180c0cc:	00c00434 	movhi	r3,16
 180c0d0:	18ffffc4 	addi	r3,r3,-1
 180c0d4:	1081ffcc 	andi	r2,r2,2047
 180c0d8:	0241ffc4 	movi	r9,2047
 180c0dc:	28d4703a 	and	r10,r5,r3
 180c0e0:	4201ffcc 	andi	r8,r8,2047
 180c0e4:	38c6703a 	and	r3,r7,r3
 180c0e8:	280ad7fa 	srli	r5,r5,31
 180c0ec:	380ed7fa 	srli	r7,r7,31
 180c0f0:	12401f26 	beq	r2,r9,180c170 <__ledf2+0xac>
 180c0f4:	0241ffc4 	movi	r9,2047
 180c0f8:	42401426 	beq	r8,r9,180c14c <__ledf2+0x88>
 180c0fc:	1000091e 	bne	r2,zero,180c124 <__ledf2+0x60>
 180c100:	2296b03a 	or	r11,r4,r10
 180c104:	5813003a 	cmpeq	r9,r11,zero
 180c108:	29403fcc 	andi	r5,r5,255
 180c10c:	40000a1e 	bne	r8,zero,180c138 <__ledf2+0x74>
 180c110:	30d8b03a 	or	r12,r6,r3
 180c114:	6000081e 	bne	r12,zero,180c138 <__ledf2+0x74>
 180c118:	0005883a 	mov	r2,zero
 180c11c:	5800111e 	bne	r11,zero,180c164 <__ledf2+0xa0>
 180c120:	f800283a 	ret
 180c124:	29403fcc 	andi	r5,r5,255
 180c128:	40000c1e 	bne	r8,zero,180c15c <__ledf2+0x98>
 180c12c:	30d2b03a 	or	r9,r6,r3
 180c130:	48000c26 	beq	r9,zero,180c164 <__ledf2+0xa0>
 180c134:	0013883a 	mov	r9,zero
 180c138:	39c03fcc 	andi	r7,r7,255
 180c13c:	48000826 	beq	r9,zero,180c160 <__ledf2+0x9c>
 180c140:	38001126 	beq	r7,zero,180c188 <__ledf2+0xc4>
 180c144:	00800044 	movi	r2,1
 180c148:	f800283a 	ret
 180c14c:	30d2b03a 	or	r9,r6,r3
 180c150:	483fea26 	beq	r9,zero,180c0fc <__ram_exceptions_end+0xff7fbcb8>
 180c154:	00800084 	movi	r2,2
 180c158:	f800283a 	ret
 180c15c:	39c03fcc 	andi	r7,r7,255
 180c160:	39400726 	beq	r7,r5,180c180 <__ledf2+0xbc>
 180c164:	2800081e 	bne	r5,zero,180c188 <__ledf2+0xc4>
 180c168:	00800044 	movi	r2,1
 180c16c:	f800283a 	ret
 180c170:	2292b03a 	or	r9,r4,r10
 180c174:	483fdf26 	beq	r9,zero,180c0f4 <__ram_exceptions_end+0xff7fbcb0>
 180c178:	00800084 	movi	r2,2
 180c17c:	f800283a 	ret
 180c180:	4080030e 	bge	r8,r2,180c190 <__ledf2+0xcc>
 180c184:	383fef26 	beq	r7,zero,180c144 <__ram_exceptions_end+0xff7fbd00>
 180c188:	00bfffc4 	movi	r2,-1
 180c18c:	f800283a 	ret
 180c190:	123feb16 	blt	r2,r8,180c140 <__ram_exceptions_end+0xff7fbcfc>
 180c194:	1abff336 	bltu	r3,r10,180c164 <__ram_exceptions_end+0xff7fbd20>
 180c198:	50c00326 	beq	r10,r3,180c1a8 <__ledf2+0xe4>
 180c19c:	50c0042e 	bgeu	r10,r3,180c1b0 <__ledf2+0xec>
 180c1a0:	283fe81e 	bne	r5,zero,180c144 <__ram_exceptions_end+0xff7fbd00>
 180c1a4:	003ff806 	br	180c188 <__ram_exceptions_end+0xff7fbd44>
 180c1a8:	313fee36 	bltu	r6,r4,180c164 <__ram_exceptions_end+0xff7fbd20>
 180c1ac:	21bffc36 	bltu	r4,r6,180c1a0 <__ram_exceptions_end+0xff7fbd5c>
 180c1b0:	0005883a 	mov	r2,zero
 180c1b4:	f800283a 	ret

0180c1b8 <__muldf3>:
 180c1b8:	defff304 	addi	sp,sp,-52
 180c1bc:	2804d53a 	srli	r2,r5,20
 180c1c0:	dd800915 	stw	r22,36(sp)
 180c1c4:	282cd7fa 	srli	r22,r5,31
 180c1c8:	dc000315 	stw	r16,12(sp)
 180c1cc:	04000434 	movhi	r16,16
 180c1d0:	dd400815 	stw	r21,32(sp)
 180c1d4:	dc800515 	stw	r18,20(sp)
 180c1d8:	843fffc4 	addi	r16,r16,-1
 180c1dc:	dfc00c15 	stw	ra,48(sp)
 180c1e0:	df000b15 	stw	fp,44(sp)
 180c1e4:	ddc00a15 	stw	r23,40(sp)
 180c1e8:	dd000715 	stw	r20,28(sp)
 180c1ec:	dcc00615 	stw	r19,24(sp)
 180c1f0:	dc400415 	stw	r17,16(sp)
 180c1f4:	1481ffcc 	andi	r18,r2,2047
 180c1f8:	2c20703a 	and	r16,r5,r16
 180c1fc:	b02b883a 	mov	r21,r22
 180c200:	b2403fcc 	andi	r9,r22,255
 180c204:	90006026 	beq	r18,zero,180c388 <__muldf3+0x1d0>
 180c208:	0081ffc4 	movi	r2,2047
 180c20c:	2029883a 	mov	r20,r4
 180c210:	90803626 	beq	r18,r2,180c2ec <__muldf3+0x134>
 180c214:	80800434 	orhi	r2,r16,16
 180c218:	100490fa 	slli	r2,r2,3
 180c21c:	2020d77a 	srli	r16,r4,29
 180c220:	202890fa 	slli	r20,r4,3
 180c224:	94bf0044 	addi	r18,r18,-1023
 180c228:	80a0b03a 	or	r16,r16,r2
 180c22c:	0027883a 	mov	r19,zero
 180c230:	0039883a 	mov	fp,zero
 180c234:	3804d53a 	srli	r2,r7,20
 180c238:	382ed7fa 	srli	r23,r7,31
 180c23c:	04400434 	movhi	r17,16
 180c240:	8c7fffc4 	addi	r17,r17,-1
 180c244:	1081ffcc 	andi	r2,r2,2047
 180c248:	3011883a 	mov	r8,r6
 180c24c:	3c62703a 	and	r17,r7,r17
 180c250:	ba803fcc 	andi	r10,r23,255
 180c254:	10006d26 	beq	r2,zero,180c40c <__muldf3+0x254>
 180c258:	00c1ffc4 	movi	r3,2047
 180c25c:	10c06526 	beq	r2,r3,180c3f4 <__muldf3+0x23c>
 180c260:	88c00434 	orhi	r3,r17,16
 180c264:	180690fa 	slli	r3,r3,3
 180c268:	3022d77a 	srli	r17,r6,29
 180c26c:	301090fa 	slli	r8,r6,3
 180c270:	10bf0044 	addi	r2,r2,-1023
 180c274:	88e2b03a 	or	r17,r17,r3
 180c278:	000b883a 	mov	r5,zero
 180c27c:	9085883a 	add	r2,r18,r2
 180c280:	2cc8b03a 	or	r4,r5,r19
 180c284:	00c003c4 	movi	r3,15
 180c288:	bdacf03a 	xor	r22,r23,r22
 180c28c:	12c00044 	addi	r11,r2,1
 180c290:	19009936 	bltu	r3,r4,180c4f8 <__muldf3+0x340>
 180c294:	200890ba 	slli	r4,r4,2
 180c298:	00c06074 	movhi	r3,385
 180c29c:	18f0ab04 	addi	r3,r3,-15700
 180c2a0:	20c9883a 	add	r4,r4,r3
 180c2a4:	20c00017 	ldw	r3,0(r4)
 180c2a8:	1800683a 	jmp	r3
 180c2ac:	0180c4f8 	rdprs	r6,zero,787
 180c2b0:	0180c30c 	andi	r6,zero,780
 180c2b4:	0180c30c 	andi	r6,zero,780
 180c2b8:	0180c308 	cmpgei	r6,zero,780
 180c2bc:	0180c4d4 	movui	r6,787
 180c2c0:	0180c4d4 	movui	r6,787
 180c2c4:	0180c4bc 	xorhi	r6,zero,786
 180c2c8:	0180c308 	cmpgei	r6,zero,780
 180c2cc:	0180c4d4 	movui	r6,787
 180c2d0:	0180c4bc 	xorhi	r6,zero,786
 180c2d4:	0180c4d4 	movui	r6,787
 180c2d8:	0180c308 	cmpgei	r6,zero,780
 180c2dc:	0180c4e4 	muli	r6,zero,787
 180c2e0:	0180c4e4 	muli	r6,zero,787
 180c2e4:	0180c4e4 	muli	r6,zero,787
 180c2e8:	0180c700 	call	180c70 <__alt_mem_tse_descriptor_memory_0+0x180c70>
 180c2ec:	2404b03a 	or	r2,r4,r16
 180c2f0:	10006f1e 	bne	r2,zero,180c4b0 <__muldf3+0x2f8>
 180c2f4:	04c00204 	movi	r19,8
 180c2f8:	0021883a 	mov	r16,zero
 180c2fc:	0029883a 	mov	r20,zero
 180c300:	07000084 	movi	fp,2
 180c304:	003fcb06 	br	180c234 <__ram_exceptions_end+0xff7fbdf0>
 180c308:	502d883a 	mov	r22,r10
 180c30c:	00800084 	movi	r2,2
 180c310:	28805726 	beq	r5,r2,180c470 <__muldf3+0x2b8>
 180c314:	008000c4 	movi	r2,3
 180c318:	28816626 	beq	r5,r2,180c8b4 <__muldf3+0x6fc>
 180c31c:	00800044 	movi	r2,1
 180c320:	2881411e 	bne	r5,r2,180c828 <__muldf3+0x670>
 180c324:	b02b883a 	mov	r21,r22
 180c328:	0005883a 	mov	r2,zero
 180c32c:	000b883a 	mov	r5,zero
 180c330:	0029883a 	mov	r20,zero
 180c334:	1004953a 	slli	r2,r2,20
 180c338:	a8c03fcc 	andi	r3,r21,255
 180c33c:	04400434 	movhi	r17,16
 180c340:	8c7fffc4 	addi	r17,r17,-1
 180c344:	180697fa 	slli	r3,r3,31
 180c348:	2c4a703a 	and	r5,r5,r17
 180c34c:	288ab03a 	or	r5,r5,r2
 180c350:	28c6b03a 	or	r3,r5,r3
 180c354:	a005883a 	mov	r2,r20
 180c358:	dfc00c17 	ldw	ra,48(sp)
 180c35c:	df000b17 	ldw	fp,44(sp)
 180c360:	ddc00a17 	ldw	r23,40(sp)
 180c364:	dd800917 	ldw	r22,36(sp)
 180c368:	dd400817 	ldw	r21,32(sp)
 180c36c:	dd000717 	ldw	r20,28(sp)
 180c370:	dcc00617 	ldw	r19,24(sp)
 180c374:	dc800517 	ldw	r18,20(sp)
 180c378:	dc400417 	ldw	r17,16(sp)
 180c37c:	dc000317 	ldw	r16,12(sp)
 180c380:	dec00d04 	addi	sp,sp,52
 180c384:	f800283a 	ret
 180c388:	2404b03a 	or	r2,r4,r16
 180c38c:	2027883a 	mov	r19,r4
 180c390:	10004226 	beq	r2,zero,180c49c <__muldf3+0x2e4>
 180c394:	8000fc26 	beq	r16,zero,180c788 <__muldf3+0x5d0>
 180c398:	8009883a 	mov	r4,r16
 180c39c:	d9800215 	stw	r6,8(sp)
 180c3a0:	d9c00015 	stw	r7,0(sp)
 180c3a4:	da400115 	stw	r9,4(sp)
 180c3a8:	180d3d00 	call	180d3d0 <__clzsi2>
 180c3ac:	d9800217 	ldw	r6,8(sp)
 180c3b0:	d9c00017 	ldw	r7,0(sp)
 180c3b4:	da400117 	ldw	r9,4(sp)
 180c3b8:	113ffd44 	addi	r4,r2,-11
 180c3bc:	00c00704 	movi	r3,28
 180c3c0:	1900ed16 	blt	r3,r4,180c778 <__muldf3+0x5c0>
 180c3c4:	00c00744 	movi	r3,29
 180c3c8:	147ffe04 	addi	r17,r2,-8
 180c3cc:	1907c83a 	sub	r3,r3,r4
 180c3d0:	8460983a 	sll	r16,r16,r17
 180c3d4:	98c6d83a 	srl	r3,r19,r3
 180c3d8:	9c68983a 	sll	r20,r19,r17
 180c3dc:	1c20b03a 	or	r16,r3,r16
 180c3e0:	1080fcc4 	addi	r2,r2,1011
 180c3e4:	00a5c83a 	sub	r18,zero,r2
 180c3e8:	0027883a 	mov	r19,zero
 180c3ec:	0039883a 	mov	fp,zero
 180c3f0:	003f9006 	br	180c234 <__ram_exceptions_end+0xff7fbdf0>
 180c3f4:	3446b03a 	or	r3,r6,r17
 180c3f8:	1800261e 	bne	r3,zero,180c494 <__muldf3+0x2dc>
 180c3fc:	0023883a 	mov	r17,zero
 180c400:	0011883a 	mov	r8,zero
 180c404:	01400084 	movi	r5,2
 180c408:	003f9c06 	br	180c27c <__ram_exceptions_end+0xff7fbe38>
 180c40c:	3446b03a 	or	r3,r6,r17
 180c410:	18001c26 	beq	r3,zero,180c484 <__muldf3+0x2cc>
 180c414:	8800ce26 	beq	r17,zero,180c750 <__muldf3+0x598>
 180c418:	8809883a 	mov	r4,r17
 180c41c:	d9800215 	stw	r6,8(sp)
 180c420:	da400115 	stw	r9,4(sp)
 180c424:	da800015 	stw	r10,0(sp)
 180c428:	180d3d00 	call	180d3d0 <__clzsi2>
 180c42c:	d9800217 	ldw	r6,8(sp)
 180c430:	da400117 	ldw	r9,4(sp)
 180c434:	da800017 	ldw	r10,0(sp)
 180c438:	113ffd44 	addi	r4,r2,-11
 180c43c:	00c00704 	movi	r3,28
 180c440:	1900bf16 	blt	r3,r4,180c740 <__muldf3+0x588>
 180c444:	00c00744 	movi	r3,29
 180c448:	123ffe04 	addi	r8,r2,-8
 180c44c:	1907c83a 	sub	r3,r3,r4
 180c450:	8a22983a 	sll	r17,r17,r8
 180c454:	30c6d83a 	srl	r3,r6,r3
 180c458:	3210983a 	sll	r8,r6,r8
 180c45c:	1c62b03a 	or	r17,r3,r17
 180c460:	1080fcc4 	addi	r2,r2,1011
 180c464:	0085c83a 	sub	r2,zero,r2
 180c468:	000b883a 	mov	r5,zero
 180c46c:	003f8306 	br	180c27c <__ram_exceptions_end+0xff7fbe38>
 180c470:	b02b883a 	mov	r21,r22
 180c474:	0081ffc4 	movi	r2,2047
 180c478:	000b883a 	mov	r5,zero
 180c47c:	0029883a 	mov	r20,zero
 180c480:	003fac06 	br	180c334 <__ram_exceptions_end+0xff7fbef0>
 180c484:	0023883a 	mov	r17,zero
 180c488:	0011883a 	mov	r8,zero
 180c48c:	01400044 	movi	r5,1
 180c490:	003f7a06 	br	180c27c <__ram_exceptions_end+0xff7fbe38>
 180c494:	014000c4 	movi	r5,3
 180c498:	003f7806 	br	180c27c <__ram_exceptions_end+0xff7fbe38>
 180c49c:	04c00104 	movi	r19,4
 180c4a0:	0021883a 	mov	r16,zero
 180c4a4:	0029883a 	mov	r20,zero
 180c4a8:	07000044 	movi	fp,1
 180c4ac:	003f6106 	br	180c234 <__ram_exceptions_end+0xff7fbdf0>
 180c4b0:	04c00304 	movi	r19,12
 180c4b4:	070000c4 	movi	fp,3
 180c4b8:	003f5e06 	br	180c234 <__ram_exceptions_end+0xff7fbdf0>
 180c4bc:	01400434 	movhi	r5,16
 180c4c0:	002b883a 	mov	r21,zero
 180c4c4:	297fffc4 	addi	r5,r5,-1
 180c4c8:	053fffc4 	movi	r20,-1
 180c4cc:	0081ffc4 	movi	r2,2047
 180c4d0:	003f9806 	br	180c334 <__ram_exceptions_end+0xff7fbef0>
 180c4d4:	8023883a 	mov	r17,r16
 180c4d8:	a011883a 	mov	r8,r20
 180c4dc:	e00b883a 	mov	r5,fp
 180c4e0:	003f8a06 	br	180c30c <__ram_exceptions_end+0xff7fbec8>
 180c4e4:	8023883a 	mov	r17,r16
 180c4e8:	a011883a 	mov	r8,r20
 180c4ec:	482d883a 	mov	r22,r9
 180c4f0:	e00b883a 	mov	r5,fp
 180c4f4:	003f8506 	br	180c30c <__ram_exceptions_end+0xff7fbec8>
 180c4f8:	a00ad43a 	srli	r5,r20,16
 180c4fc:	401ad43a 	srli	r13,r8,16
 180c500:	a53fffcc 	andi	r20,r20,65535
 180c504:	423fffcc 	andi	r8,r8,65535
 180c508:	4519383a 	mul	r12,r8,r20
 180c50c:	4147383a 	mul	r3,r8,r5
 180c510:	6d09383a 	mul	r4,r13,r20
 180c514:	600cd43a 	srli	r6,r12,16
 180c518:	2b5d383a 	mul	r14,r5,r13
 180c51c:	20c9883a 	add	r4,r4,r3
 180c520:	310d883a 	add	r6,r6,r4
 180c524:	30c0022e 	bgeu	r6,r3,180c530 <__muldf3+0x378>
 180c528:	00c00074 	movhi	r3,1
 180c52c:	70dd883a 	add	r14,r14,r3
 180c530:	8826d43a 	srli	r19,r17,16
 180c534:	8bffffcc 	andi	r15,r17,65535
 180c538:	7d23383a 	mul	r17,r15,r20
 180c53c:	7949383a 	mul	r4,r15,r5
 180c540:	9d29383a 	mul	r20,r19,r20
 180c544:	8814d43a 	srli	r10,r17,16
 180c548:	3012943a 	slli	r9,r6,16
 180c54c:	a129883a 	add	r20,r20,r4
 180c550:	633fffcc 	andi	r12,r12,65535
 180c554:	5515883a 	add	r10,r10,r20
 180c558:	3006d43a 	srli	r3,r6,16
 180c55c:	4b13883a 	add	r9,r9,r12
 180c560:	2ccb383a 	mul	r5,r5,r19
 180c564:	5100022e 	bgeu	r10,r4,180c570 <__muldf3+0x3b8>
 180c568:	01000074 	movhi	r4,1
 180c56c:	290b883a 	add	r5,r5,r4
 180c570:	802ad43a 	srli	r21,r16,16
 180c574:	843fffcc 	andi	r16,r16,65535
 180c578:	440d383a 	mul	r6,r8,r16
 180c57c:	4565383a 	mul	r18,r8,r21
 180c580:	8349383a 	mul	r4,r16,r13
 180c584:	500e943a 	slli	r7,r10,16
 180c588:	3010d43a 	srli	r8,r6,16
 180c58c:	5028d43a 	srli	r20,r10,16
 180c590:	2489883a 	add	r4,r4,r18
 180c594:	8abfffcc 	andi	r10,r17,65535
 180c598:	3a95883a 	add	r10,r7,r10
 180c59c:	4119883a 	add	r12,r8,r4
 180c5a0:	a169883a 	add	r20,r20,r5
 180c5a4:	1a87883a 	add	r3,r3,r10
 180c5a8:	6d5b383a 	mul	r13,r13,r21
 180c5ac:	6480022e 	bgeu	r12,r18,180c5b8 <__muldf3+0x400>
 180c5b0:	01000074 	movhi	r4,1
 180c5b4:	691b883a 	add	r13,r13,r4
 180c5b8:	7c25383a 	mul	r18,r15,r16
 180c5bc:	7d4b383a 	mul	r5,r15,r21
 180c5c0:	84cf383a 	mul	r7,r16,r19
 180c5c4:	901ed43a 	srli	r15,r18,16
 180c5c8:	6008d43a 	srli	r4,r12,16
 180c5cc:	6010943a 	slli	r8,r12,16
 180c5d0:	394f883a 	add	r7,r7,r5
 180c5d4:	333fffcc 	andi	r12,r6,65535
 180c5d8:	79df883a 	add	r15,r15,r7
 180c5dc:	235b883a 	add	r13,r4,r13
 180c5e0:	9d63383a 	mul	r17,r19,r21
 180c5e4:	4309883a 	add	r4,r8,r12
 180c5e8:	7940022e 	bgeu	r15,r5,180c5f4 <__muldf3+0x43c>
 180c5ec:	01400074 	movhi	r5,1
 180c5f0:	8963883a 	add	r17,r17,r5
 180c5f4:	780a943a 	slli	r5,r15,16
 180c5f8:	91bfffcc 	andi	r6,r18,65535
 180c5fc:	70c7883a 	add	r3,r14,r3
 180c600:	298d883a 	add	r6,r5,r6
 180c604:	1a8f803a 	cmpltu	r7,r3,r10
 180c608:	350b883a 	add	r5,r6,r20
 180c60c:	20c7883a 	add	r3,r4,r3
 180c610:	3955883a 	add	r10,r7,r5
 180c614:	1909803a 	cmpltu	r4,r3,r4
 180c618:	6a91883a 	add	r8,r13,r10
 180c61c:	780cd43a 	srli	r6,r15,16
 180c620:	2219883a 	add	r12,r4,r8
 180c624:	2d0b803a 	cmpltu	r5,r5,r20
 180c628:	51cf803a 	cmpltu	r7,r10,r7
 180c62c:	29ceb03a 	or	r7,r5,r7
 180c630:	4351803a 	cmpltu	r8,r8,r13
 180c634:	610b803a 	cmpltu	r5,r12,r4
 180c638:	4148b03a 	or	r4,r8,r5
 180c63c:	398f883a 	add	r7,r7,r6
 180c640:	3909883a 	add	r4,r7,r4
 180c644:	1810927a 	slli	r8,r3,9
 180c648:	2449883a 	add	r4,r4,r17
 180c64c:	2008927a 	slli	r4,r4,9
 180c650:	6022d5fa 	srli	r17,r12,23
 180c654:	1806d5fa 	srli	r3,r3,23
 180c658:	4252b03a 	or	r9,r8,r9
 180c65c:	600a927a 	slli	r5,r12,9
 180c660:	4810c03a 	cmpne	r8,r9,zero
 180c664:	2462b03a 	or	r17,r4,r17
 180c668:	40c6b03a 	or	r3,r8,r3
 180c66c:	8900402c 	andhi	r4,r17,256
 180c670:	1950b03a 	or	r8,r3,r5
 180c674:	20000726 	beq	r4,zero,180c694 <__muldf3+0x4dc>
 180c678:	4006d07a 	srli	r3,r8,1
 180c67c:	880497fa 	slli	r2,r17,31
 180c680:	4200004c 	andi	r8,r8,1
 180c684:	8822d07a 	srli	r17,r17,1
 180c688:	1a10b03a 	or	r8,r3,r8
 180c68c:	1210b03a 	or	r8,r2,r8
 180c690:	5805883a 	mov	r2,r11
 180c694:	1140ffc4 	addi	r5,r2,1023
 180c698:	0140440e 	bge	zero,r5,180c7ac <__muldf3+0x5f4>
 180c69c:	40c001cc 	andi	r3,r8,7
 180c6a0:	18000726 	beq	r3,zero,180c6c0 <__muldf3+0x508>
 180c6a4:	40c003cc 	andi	r3,r8,15
 180c6a8:	01000104 	movi	r4,4
 180c6ac:	19000426 	beq	r3,r4,180c6c0 <__muldf3+0x508>
 180c6b0:	4107883a 	add	r3,r8,r4
 180c6b4:	1a11803a 	cmpltu	r8,r3,r8
 180c6b8:	8a23883a 	add	r17,r17,r8
 180c6bc:	1811883a 	mov	r8,r3
 180c6c0:	88c0402c 	andhi	r3,r17,256
 180c6c4:	18000426 	beq	r3,zero,180c6d8 <__muldf3+0x520>
 180c6c8:	11410004 	addi	r5,r2,1024
 180c6cc:	00bfc034 	movhi	r2,65280
 180c6d0:	10bfffc4 	addi	r2,r2,-1
 180c6d4:	88a2703a 	and	r17,r17,r2
 180c6d8:	0081ff84 	movi	r2,2046
 180c6dc:	117f6416 	blt	r2,r5,180c470 <__ram_exceptions_end+0xff7fc02c>
 180c6e0:	8828977a 	slli	r20,r17,29
 180c6e4:	4010d0fa 	srli	r8,r8,3
 180c6e8:	8822927a 	slli	r17,r17,9
 180c6ec:	2881ffcc 	andi	r2,r5,2047
 180c6f0:	a228b03a 	or	r20,r20,r8
 180c6f4:	880ad33a 	srli	r5,r17,12
 180c6f8:	b02b883a 	mov	r21,r22
 180c6fc:	003f0d06 	br	180c334 <__ram_exceptions_end+0xff7fbef0>
 180c700:	8080022c 	andhi	r2,r16,8
 180c704:	10000926 	beq	r2,zero,180c72c <__muldf3+0x574>
 180c708:	8880022c 	andhi	r2,r17,8
 180c70c:	1000071e 	bne	r2,zero,180c72c <__muldf3+0x574>
 180c710:	00800434 	movhi	r2,16
 180c714:	89400234 	orhi	r5,r17,8
 180c718:	10bfffc4 	addi	r2,r2,-1
 180c71c:	b82b883a 	mov	r21,r23
 180c720:	288a703a 	and	r5,r5,r2
 180c724:	4029883a 	mov	r20,r8
 180c728:	003f6806 	br	180c4cc <__ram_exceptions_end+0xff7fc088>
 180c72c:	00800434 	movhi	r2,16
 180c730:	81400234 	orhi	r5,r16,8
 180c734:	10bfffc4 	addi	r2,r2,-1
 180c738:	288a703a 	and	r5,r5,r2
 180c73c:	003f6306 	br	180c4cc <__ram_exceptions_end+0xff7fc088>
 180c740:	147ff604 	addi	r17,r2,-40
 180c744:	3462983a 	sll	r17,r6,r17
 180c748:	0011883a 	mov	r8,zero
 180c74c:	003f4406 	br	180c460 <__ram_exceptions_end+0xff7fc01c>
 180c750:	3009883a 	mov	r4,r6
 180c754:	d9800215 	stw	r6,8(sp)
 180c758:	da400115 	stw	r9,4(sp)
 180c75c:	da800015 	stw	r10,0(sp)
 180c760:	180d3d00 	call	180d3d0 <__clzsi2>
 180c764:	10800804 	addi	r2,r2,32
 180c768:	da800017 	ldw	r10,0(sp)
 180c76c:	da400117 	ldw	r9,4(sp)
 180c770:	d9800217 	ldw	r6,8(sp)
 180c774:	003f3006 	br	180c438 <__ram_exceptions_end+0xff7fbff4>
 180c778:	143ff604 	addi	r16,r2,-40
 180c77c:	9c20983a 	sll	r16,r19,r16
 180c780:	0029883a 	mov	r20,zero
 180c784:	003f1606 	br	180c3e0 <__ram_exceptions_end+0xff7fbf9c>
 180c788:	d9800215 	stw	r6,8(sp)
 180c78c:	d9c00015 	stw	r7,0(sp)
 180c790:	da400115 	stw	r9,4(sp)
 180c794:	180d3d00 	call	180d3d0 <__clzsi2>
 180c798:	10800804 	addi	r2,r2,32
 180c79c:	da400117 	ldw	r9,4(sp)
 180c7a0:	d9c00017 	ldw	r7,0(sp)
 180c7a4:	d9800217 	ldw	r6,8(sp)
 180c7a8:	003f0306 	br	180c3b8 <__ram_exceptions_end+0xff7fbf74>
 180c7ac:	00c00044 	movi	r3,1
 180c7b0:	1947c83a 	sub	r3,r3,r5
 180c7b4:	00800e04 	movi	r2,56
 180c7b8:	10feda16 	blt	r2,r3,180c324 <__ram_exceptions_end+0xff7fbee0>
 180c7bc:	008007c4 	movi	r2,31
 180c7c0:	10c01b16 	blt	r2,r3,180c830 <__muldf3+0x678>
 180c7c4:	00800804 	movi	r2,32
 180c7c8:	10c5c83a 	sub	r2,r2,r3
 180c7cc:	888a983a 	sll	r5,r17,r2
 180c7d0:	40c8d83a 	srl	r4,r8,r3
 180c7d4:	4084983a 	sll	r2,r8,r2
 180c7d8:	88e2d83a 	srl	r17,r17,r3
 180c7dc:	2906b03a 	or	r3,r5,r4
 180c7e0:	1004c03a 	cmpne	r2,r2,zero
 180c7e4:	1886b03a 	or	r3,r3,r2
 180c7e8:	188001cc 	andi	r2,r3,7
 180c7ec:	10000726 	beq	r2,zero,180c80c <__muldf3+0x654>
 180c7f0:	188003cc 	andi	r2,r3,15
 180c7f4:	01000104 	movi	r4,4
 180c7f8:	11000426 	beq	r2,r4,180c80c <__muldf3+0x654>
 180c7fc:	1805883a 	mov	r2,r3
 180c800:	10c00104 	addi	r3,r2,4
 180c804:	1885803a 	cmpltu	r2,r3,r2
 180c808:	88a3883a 	add	r17,r17,r2
 180c80c:	8880202c 	andhi	r2,r17,128
 180c810:	10001c26 	beq	r2,zero,180c884 <__muldf3+0x6cc>
 180c814:	b02b883a 	mov	r21,r22
 180c818:	00800044 	movi	r2,1
 180c81c:	000b883a 	mov	r5,zero
 180c820:	0029883a 	mov	r20,zero
 180c824:	003ec306 	br	180c334 <__ram_exceptions_end+0xff7fbef0>
 180c828:	5805883a 	mov	r2,r11
 180c82c:	003f9906 	br	180c694 <__ram_exceptions_end+0xff7fc250>
 180c830:	00bff844 	movi	r2,-31
 180c834:	1145c83a 	sub	r2,r2,r5
 180c838:	8888d83a 	srl	r4,r17,r2
 180c83c:	00800804 	movi	r2,32
 180c840:	18801a26 	beq	r3,r2,180c8ac <__muldf3+0x6f4>
 180c844:	00801004 	movi	r2,64
 180c848:	10c5c83a 	sub	r2,r2,r3
 180c84c:	8884983a 	sll	r2,r17,r2
 180c850:	1204b03a 	or	r2,r2,r8
 180c854:	1004c03a 	cmpne	r2,r2,zero
 180c858:	2084b03a 	or	r2,r4,r2
 180c85c:	144001cc 	andi	r17,r2,7
 180c860:	88000d1e 	bne	r17,zero,180c898 <__muldf3+0x6e0>
 180c864:	000b883a 	mov	r5,zero
 180c868:	1028d0fa 	srli	r20,r2,3
 180c86c:	b02b883a 	mov	r21,r22
 180c870:	0005883a 	mov	r2,zero
 180c874:	a468b03a 	or	r20,r20,r17
 180c878:	003eae06 	br	180c334 <__ram_exceptions_end+0xff7fbef0>
 180c87c:	1007883a 	mov	r3,r2
 180c880:	0023883a 	mov	r17,zero
 180c884:	880a927a 	slli	r5,r17,9
 180c888:	1805883a 	mov	r2,r3
 180c88c:	8822977a 	slli	r17,r17,29
 180c890:	280ad33a 	srli	r5,r5,12
 180c894:	003ff406 	br	180c868 <__ram_exceptions_end+0xff7fc424>
 180c898:	10c003cc 	andi	r3,r2,15
 180c89c:	01000104 	movi	r4,4
 180c8a0:	193ff626 	beq	r3,r4,180c87c <__ram_exceptions_end+0xff7fc438>
 180c8a4:	0023883a 	mov	r17,zero
 180c8a8:	003fd506 	br	180c800 <__ram_exceptions_end+0xff7fc3bc>
 180c8ac:	0005883a 	mov	r2,zero
 180c8b0:	003fe706 	br	180c850 <__ram_exceptions_end+0xff7fc40c>
 180c8b4:	00800434 	movhi	r2,16
 180c8b8:	89400234 	orhi	r5,r17,8
 180c8bc:	10bfffc4 	addi	r2,r2,-1
 180c8c0:	b02b883a 	mov	r21,r22
 180c8c4:	288a703a 	and	r5,r5,r2
 180c8c8:	4029883a 	mov	r20,r8
 180c8cc:	003eff06 	br	180c4cc <__ram_exceptions_end+0xff7fc088>

0180c8d0 <__subdf3>:
 180c8d0:	02000434 	movhi	r8,16
 180c8d4:	423fffc4 	addi	r8,r8,-1
 180c8d8:	defffb04 	addi	sp,sp,-20
 180c8dc:	2a14703a 	and	r10,r5,r8
 180c8e0:	3812d53a 	srli	r9,r7,20
 180c8e4:	3a10703a 	and	r8,r7,r8
 180c8e8:	2006d77a 	srli	r3,r4,29
 180c8ec:	3004d77a 	srli	r2,r6,29
 180c8f0:	dc000015 	stw	r16,0(sp)
 180c8f4:	501490fa 	slli	r10,r10,3
 180c8f8:	2820d53a 	srli	r16,r5,20
 180c8fc:	401090fa 	slli	r8,r8,3
 180c900:	dc800215 	stw	r18,8(sp)
 180c904:	dc400115 	stw	r17,4(sp)
 180c908:	dfc00415 	stw	ra,16(sp)
 180c90c:	202290fa 	slli	r17,r4,3
 180c910:	dcc00315 	stw	r19,12(sp)
 180c914:	4a41ffcc 	andi	r9,r9,2047
 180c918:	0101ffc4 	movi	r4,2047
 180c91c:	2824d7fa 	srli	r18,r5,31
 180c920:	8401ffcc 	andi	r16,r16,2047
 180c924:	50c6b03a 	or	r3,r10,r3
 180c928:	380ed7fa 	srli	r7,r7,31
 180c92c:	408ab03a 	or	r5,r8,r2
 180c930:	300c90fa 	slli	r6,r6,3
 180c934:	49009626 	beq	r9,r4,180cb90 <__subdf3+0x2c0>
 180c938:	39c0005c 	xori	r7,r7,1
 180c93c:	8245c83a 	sub	r2,r16,r9
 180c940:	3c807426 	beq	r7,r18,180cb14 <__subdf3+0x244>
 180c944:	0080af0e 	bge	zero,r2,180cc04 <__subdf3+0x334>
 180c948:	48002a1e 	bne	r9,zero,180c9f4 <__subdf3+0x124>
 180c94c:	2988b03a 	or	r4,r5,r6
 180c950:	20009a1e 	bne	r4,zero,180cbbc <__subdf3+0x2ec>
 180c954:	888001cc 	andi	r2,r17,7
 180c958:	10000726 	beq	r2,zero,180c978 <__subdf3+0xa8>
 180c95c:	888003cc 	andi	r2,r17,15
 180c960:	01000104 	movi	r4,4
 180c964:	11000426 	beq	r2,r4,180c978 <__subdf3+0xa8>
 180c968:	890b883a 	add	r5,r17,r4
 180c96c:	2c63803a 	cmpltu	r17,r5,r17
 180c970:	1c47883a 	add	r3,r3,r17
 180c974:	2823883a 	mov	r17,r5
 180c978:	1880202c 	andhi	r2,r3,128
 180c97c:	10005926 	beq	r2,zero,180cae4 <__subdf3+0x214>
 180c980:	84000044 	addi	r16,r16,1
 180c984:	0081ffc4 	movi	r2,2047
 180c988:	8080be26 	beq	r16,r2,180cc84 <__subdf3+0x3b4>
 180c98c:	017fe034 	movhi	r5,65408
 180c990:	297fffc4 	addi	r5,r5,-1
 180c994:	1946703a 	and	r3,r3,r5
 180c998:	1804977a 	slli	r2,r3,29
 180c99c:	1806927a 	slli	r3,r3,9
 180c9a0:	8822d0fa 	srli	r17,r17,3
 180c9a4:	8401ffcc 	andi	r16,r16,2047
 180c9a8:	180ad33a 	srli	r5,r3,12
 180c9ac:	9100004c 	andi	r4,r18,1
 180c9b0:	1444b03a 	or	r2,r2,r17
 180c9b4:	80c1ffcc 	andi	r3,r16,2047
 180c9b8:	1820953a 	slli	r16,r3,20
 180c9bc:	20c03fcc 	andi	r3,r4,255
 180c9c0:	180897fa 	slli	r4,r3,31
 180c9c4:	00c00434 	movhi	r3,16
 180c9c8:	18ffffc4 	addi	r3,r3,-1
 180c9cc:	28c6703a 	and	r3,r5,r3
 180c9d0:	1c06b03a 	or	r3,r3,r16
 180c9d4:	1906b03a 	or	r3,r3,r4
 180c9d8:	dfc00417 	ldw	ra,16(sp)
 180c9dc:	dcc00317 	ldw	r19,12(sp)
 180c9e0:	dc800217 	ldw	r18,8(sp)
 180c9e4:	dc400117 	ldw	r17,4(sp)
 180c9e8:	dc000017 	ldw	r16,0(sp)
 180c9ec:	dec00504 	addi	sp,sp,20
 180c9f0:	f800283a 	ret
 180c9f4:	0101ffc4 	movi	r4,2047
 180c9f8:	813fd626 	beq	r16,r4,180c954 <__ram_exceptions_end+0xff7fc510>
 180c9fc:	29402034 	orhi	r5,r5,128
 180ca00:	01000e04 	movi	r4,56
 180ca04:	2080a316 	blt	r4,r2,180cc94 <__subdf3+0x3c4>
 180ca08:	010007c4 	movi	r4,31
 180ca0c:	2080c616 	blt	r4,r2,180cd28 <__subdf3+0x458>
 180ca10:	01000804 	movi	r4,32
 180ca14:	2089c83a 	sub	r4,r4,r2
 180ca18:	2910983a 	sll	r8,r5,r4
 180ca1c:	308ed83a 	srl	r7,r6,r2
 180ca20:	3108983a 	sll	r4,r6,r4
 180ca24:	2884d83a 	srl	r2,r5,r2
 180ca28:	41ccb03a 	or	r6,r8,r7
 180ca2c:	2008c03a 	cmpne	r4,r4,zero
 180ca30:	310cb03a 	or	r6,r6,r4
 180ca34:	898dc83a 	sub	r6,r17,r6
 180ca38:	89a3803a 	cmpltu	r17,r17,r6
 180ca3c:	1887c83a 	sub	r3,r3,r2
 180ca40:	1c47c83a 	sub	r3,r3,r17
 180ca44:	3023883a 	mov	r17,r6
 180ca48:	1880202c 	andhi	r2,r3,128
 180ca4c:	10002326 	beq	r2,zero,180cadc <__subdf3+0x20c>
 180ca50:	04c02034 	movhi	r19,128
 180ca54:	9cffffc4 	addi	r19,r19,-1
 180ca58:	1ce6703a 	and	r19,r3,r19
 180ca5c:	98007a26 	beq	r19,zero,180cc48 <__subdf3+0x378>
 180ca60:	9809883a 	mov	r4,r19
 180ca64:	180d3d00 	call	180d3d0 <__clzsi2>
 180ca68:	113ffe04 	addi	r4,r2,-8
 180ca6c:	00c007c4 	movi	r3,31
 180ca70:	19007b16 	blt	r3,r4,180cc60 <__subdf3+0x390>
 180ca74:	00800804 	movi	r2,32
 180ca78:	1105c83a 	sub	r2,r2,r4
 180ca7c:	8884d83a 	srl	r2,r17,r2
 180ca80:	9906983a 	sll	r3,r19,r4
 180ca84:	8922983a 	sll	r17,r17,r4
 180ca88:	10c4b03a 	or	r2,r2,r3
 180ca8c:	24007816 	blt	r4,r16,180cc70 <__subdf3+0x3a0>
 180ca90:	2421c83a 	sub	r16,r4,r16
 180ca94:	80c00044 	addi	r3,r16,1
 180ca98:	010007c4 	movi	r4,31
 180ca9c:	20c09516 	blt	r4,r3,180ccf4 <__subdf3+0x424>
 180caa0:	01400804 	movi	r5,32
 180caa4:	28cbc83a 	sub	r5,r5,r3
 180caa8:	88c8d83a 	srl	r4,r17,r3
 180caac:	8962983a 	sll	r17,r17,r5
 180cab0:	114a983a 	sll	r5,r2,r5
 180cab4:	10c6d83a 	srl	r3,r2,r3
 180cab8:	8804c03a 	cmpne	r2,r17,zero
 180cabc:	290ab03a 	or	r5,r5,r4
 180cac0:	28a2b03a 	or	r17,r5,r2
 180cac4:	0021883a 	mov	r16,zero
 180cac8:	003fa206 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cacc:	2090b03a 	or	r8,r4,r2
 180cad0:	40018e26 	beq	r8,zero,180d10c <__subdf3+0x83c>
 180cad4:	1007883a 	mov	r3,r2
 180cad8:	2023883a 	mov	r17,r4
 180cadc:	888001cc 	andi	r2,r17,7
 180cae0:	103f9e1e 	bne	r2,zero,180c95c <__ram_exceptions_end+0xff7fc518>
 180cae4:	1804977a 	slli	r2,r3,29
 180cae8:	8822d0fa 	srli	r17,r17,3
 180caec:	1810d0fa 	srli	r8,r3,3
 180caf0:	9100004c 	andi	r4,r18,1
 180caf4:	1444b03a 	or	r2,r2,r17
 180caf8:	00c1ffc4 	movi	r3,2047
 180cafc:	80c02826 	beq	r16,r3,180cba0 <__subdf3+0x2d0>
 180cb00:	01400434 	movhi	r5,16
 180cb04:	297fffc4 	addi	r5,r5,-1
 180cb08:	80e0703a 	and	r16,r16,r3
 180cb0c:	414a703a 	and	r5,r8,r5
 180cb10:	003fa806 	br	180c9b4 <__ram_exceptions_end+0xff7fc570>
 180cb14:	0080630e 	bge	zero,r2,180cca4 <__subdf3+0x3d4>
 180cb18:	48003026 	beq	r9,zero,180cbdc <__subdf3+0x30c>
 180cb1c:	0101ffc4 	movi	r4,2047
 180cb20:	813f8c26 	beq	r16,r4,180c954 <__ram_exceptions_end+0xff7fc510>
 180cb24:	29402034 	orhi	r5,r5,128
 180cb28:	01000e04 	movi	r4,56
 180cb2c:	2080a90e 	bge	r4,r2,180cdd4 <__subdf3+0x504>
 180cb30:	298cb03a 	or	r6,r5,r6
 180cb34:	3012c03a 	cmpne	r9,r6,zero
 180cb38:	0005883a 	mov	r2,zero
 180cb3c:	4c53883a 	add	r9,r9,r17
 180cb40:	4c63803a 	cmpltu	r17,r9,r17
 180cb44:	10c7883a 	add	r3,r2,r3
 180cb48:	88c7883a 	add	r3,r17,r3
 180cb4c:	4823883a 	mov	r17,r9
 180cb50:	1880202c 	andhi	r2,r3,128
 180cb54:	1000d026 	beq	r2,zero,180ce98 <__subdf3+0x5c8>
 180cb58:	84000044 	addi	r16,r16,1
 180cb5c:	0081ffc4 	movi	r2,2047
 180cb60:	8080fe26 	beq	r16,r2,180cf5c <__subdf3+0x68c>
 180cb64:	00bfe034 	movhi	r2,65408
 180cb68:	10bfffc4 	addi	r2,r2,-1
 180cb6c:	1886703a 	and	r3,r3,r2
 180cb70:	880ad07a 	srli	r5,r17,1
 180cb74:	180497fa 	slli	r2,r3,31
 180cb78:	8900004c 	andi	r4,r17,1
 180cb7c:	2922b03a 	or	r17,r5,r4
 180cb80:	1806d07a 	srli	r3,r3,1
 180cb84:	1462b03a 	or	r17,r2,r17
 180cb88:	3825883a 	mov	r18,r7
 180cb8c:	003f7106 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cb90:	2984b03a 	or	r2,r5,r6
 180cb94:	103f6826 	beq	r2,zero,180c938 <__ram_exceptions_end+0xff7fc4f4>
 180cb98:	39c03fcc 	andi	r7,r7,255
 180cb9c:	003f6706 	br	180c93c <__ram_exceptions_end+0xff7fc4f8>
 180cba0:	4086b03a 	or	r3,r8,r2
 180cba4:	18015226 	beq	r3,zero,180d0f0 <__subdf3+0x820>
 180cba8:	00c00434 	movhi	r3,16
 180cbac:	41400234 	orhi	r5,r8,8
 180cbb0:	18ffffc4 	addi	r3,r3,-1
 180cbb4:	28ca703a 	and	r5,r5,r3
 180cbb8:	003f7e06 	br	180c9b4 <__ram_exceptions_end+0xff7fc570>
 180cbbc:	10bfffc4 	addi	r2,r2,-1
 180cbc0:	1000491e 	bne	r2,zero,180cce8 <__subdf3+0x418>
 180cbc4:	898fc83a 	sub	r7,r17,r6
 180cbc8:	89e3803a 	cmpltu	r17,r17,r7
 180cbcc:	1947c83a 	sub	r3,r3,r5
 180cbd0:	1c47c83a 	sub	r3,r3,r17
 180cbd4:	3823883a 	mov	r17,r7
 180cbd8:	003f9b06 	br	180ca48 <__ram_exceptions_end+0xff7fc604>
 180cbdc:	2988b03a 	or	r4,r5,r6
 180cbe0:	203f5c26 	beq	r4,zero,180c954 <__ram_exceptions_end+0xff7fc510>
 180cbe4:	10bfffc4 	addi	r2,r2,-1
 180cbe8:	1000931e 	bne	r2,zero,180ce38 <__subdf3+0x568>
 180cbec:	898d883a 	add	r6,r17,r6
 180cbf0:	3463803a 	cmpltu	r17,r6,r17
 180cbf4:	1947883a 	add	r3,r3,r5
 180cbf8:	88c7883a 	add	r3,r17,r3
 180cbfc:	3023883a 	mov	r17,r6
 180cc00:	003fd306 	br	180cb50 <__ram_exceptions_end+0xff7fc70c>
 180cc04:	1000541e 	bne	r2,zero,180cd58 <__subdf3+0x488>
 180cc08:	80800044 	addi	r2,r16,1
 180cc0c:	1081ffcc 	andi	r2,r2,2047
 180cc10:	01000044 	movi	r4,1
 180cc14:	2080a20e 	bge	r4,r2,180cea0 <__subdf3+0x5d0>
 180cc18:	8989c83a 	sub	r4,r17,r6
 180cc1c:	8905803a 	cmpltu	r2,r17,r4
 180cc20:	1967c83a 	sub	r19,r3,r5
 180cc24:	98a7c83a 	sub	r19,r19,r2
 180cc28:	9880202c 	andhi	r2,r19,128
 180cc2c:	10006326 	beq	r2,zero,180cdbc <__subdf3+0x4ec>
 180cc30:	3463c83a 	sub	r17,r6,r17
 180cc34:	28c7c83a 	sub	r3,r5,r3
 180cc38:	344d803a 	cmpltu	r6,r6,r17
 180cc3c:	19a7c83a 	sub	r19,r3,r6
 180cc40:	3825883a 	mov	r18,r7
 180cc44:	983f861e 	bne	r19,zero,180ca60 <__ram_exceptions_end+0xff7fc61c>
 180cc48:	8809883a 	mov	r4,r17
 180cc4c:	180d3d00 	call	180d3d0 <__clzsi2>
 180cc50:	10800804 	addi	r2,r2,32
 180cc54:	113ffe04 	addi	r4,r2,-8
 180cc58:	00c007c4 	movi	r3,31
 180cc5c:	193f850e 	bge	r3,r4,180ca74 <__ram_exceptions_end+0xff7fc630>
 180cc60:	10bff604 	addi	r2,r2,-40
 180cc64:	8884983a 	sll	r2,r17,r2
 180cc68:	0023883a 	mov	r17,zero
 180cc6c:	243f880e 	bge	r4,r16,180ca90 <__ram_exceptions_end+0xff7fc64c>
 180cc70:	00ffe034 	movhi	r3,65408
 180cc74:	18ffffc4 	addi	r3,r3,-1
 180cc78:	8121c83a 	sub	r16,r16,r4
 180cc7c:	10c6703a 	and	r3,r2,r3
 180cc80:	003f3406 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cc84:	9100004c 	andi	r4,r18,1
 180cc88:	000b883a 	mov	r5,zero
 180cc8c:	0005883a 	mov	r2,zero
 180cc90:	003f4806 	br	180c9b4 <__ram_exceptions_end+0xff7fc570>
 180cc94:	298cb03a 	or	r6,r5,r6
 180cc98:	300cc03a 	cmpne	r6,r6,zero
 180cc9c:	0005883a 	mov	r2,zero
 180cca0:	003f6406 	br	180ca34 <__ram_exceptions_end+0xff7fc5f0>
 180cca4:	10009a1e 	bne	r2,zero,180cf10 <__subdf3+0x640>
 180cca8:	82400044 	addi	r9,r16,1
 180ccac:	4881ffcc 	andi	r2,r9,2047
 180ccb0:	02800044 	movi	r10,1
 180ccb4:	5080670e 	bge	r10,r2,180ce54 <__subdf3+0x584>
 180ccb8:	0081ffc4 	movi	r2,2047
 180ccbc:	4880af26 	beq	r9,r2,180cf7c <__subdf3+0x6ac>
 180ccc0:	898d883a 	add	r6,r17,r6
 180ccc4:	1945883a 	add	r2,r3,r5
 180ccc8:	3447803a 	cmpltu	r3,r6,r17
 180cccc:	1887883a 	add	r3,r3,r2
 180ccd0:	182297fa 	slli	r17,r3,31
 180ccd4:	300cd07a 	srli	r6,r6,1
 180ccd8:	1806d07a 	srli	r3,r3,1
 180ccdc:	4821883a 	mov	r16,r9
 180cce0:	89a2b03a 	or	r17,r17,r6
 180cce4:	003f1b06 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cce8:	0101ffc4 	movi	r4,2047
 180ccec:	813f441e 	bne	r16,r4,180ca00 <__ram_exceptions_end+0xff7fc5bc>
 180ccf0:	003f1806 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180ccf4:	843ff844 	addi	r16,r16,-31
 180ccf8:	01400804 	movi	r5,32
 180ccfc:	1408d83a 	srl	r4,r2,r16
 180cd00:	19405026 	beq	r3,r5,180ce44 <__subdf3+0x574>
 180cd04:	01401004 	movi	r5,64
 180cd08:	28c7c83a 	sub	r3,r5,r3
 180cd0c:	10c4983a 	sll	r2,r2,r3
 180cd10:	88a2b03a 	or	r17,r17,r2
 180cd14:	8822c03a 	cmpne	r17,r17,zero
 180cd18:	2462b03a 	or	r17,r4,r17
 180cd1c:	0007883a 	mov	r3,zero
 180cd20:	0021883a 	mov	r16,zero
 180cd24:	003f6d06 	br	180cadc <__ram_exceptions_end+0xff7fc698>
 180cd28:	11fff804 	addi	r7,r2,-32
 180cd2c:	01000804 	movi	r4,32
 180cd30:	29ced83a 	srl	r7,r5,r7
 180cd34:	11004526 	beq	r2,r4,180ce4c <__subdf3+0x57c>
 180cd38:	01001004 	movi	r4,64
 180cd3c:	2089c83a 	sub	r4,r4,r2
 180cd40:	2904983a 	sll	r2,r5,r4
 180cd44:	118cb03a 	or	r6,r2,r6
 180cd48:	300cc03a 	cmpne	r6,r6,zero
 180cd4c:	398cb03a 	or	r6,r7,r6
 180cd50:	0005883a 	mov	r2,zero
 180cd54:	003f3706 	br	180ca34 <__ram_exceptions_end+0xff7fc5f0>
 180cd58:	80002a26 	beq	r16,zero,180ce04 <__subdf3+0x534>
 180cd5c:	0101ffc4 	movi	r4,2047
 180cd60:	49006626 	beq	r9,r4,180cefc <__subdf3+0x62c>
 180cd64:	0085c83a 	sub	r2,zero,r2
 180cd68:	18c02034 	orhi	r3,r3,128
 180cd6c:	01000e04 	movi	r4,56
 180cd70:	20807e16 	blt	r4,r2,180cf6c <__subdf3+0x69c>
 180cd74:	010007c4 	movi	r4,31
 180cd78:	2080e716 	blt	r4,r2,180d118 <__subdf3+0x848>
 180cd7c:	01000804 	movi	r4,32
 180cd80:	2089c83a 	sub	r4,r4,r2
 180cd84:	1914983a 	sll	r10,r3,r4
 180cd88:	8890d83a 	srl	r8,r17,r2
 180cd8c:	8908983a 	sll	r4,r17,r4
 180cd90:	1884d83a 	srl	r2,r3,r2
 180cd94:	5222b03a 	or	r17,r10,r8
 180cd98:	2006c03a 	cmpne	r3,r4,zero
 180cd9c:	88e2b03a 	or	r17,r17,r3
 180cda0:	3463c83a 	sub	r17,r6,r17
 180cda4:	2885c83a 	sub	r2,r5,r2
 180cda8:	344d803a 	cmpltu	r6,r6,r17
 180cdac:	1187c83a 	sub	r3,r2,r6
 180cdb0:	4821883a 	mov	r16,r9
 180cdb4:	3825883a 	mov	r18,r7
 180cdb8:	003f2306 	br	180ca48 <__ram_exceptions_end+0xff7fc604>
 180cdbc:	24d0b03a 	or	r8,r4,r19
 180cdc0:	40001b1e 	bne	r8,zero,180ce30 <__subdf3+0x560>
 180cdc4:	0005883a 	mov	r2,zero
 180cdc8:	0009883a 	mov	r4,zero
 180cdcc:	0021883a 	mov	r16,zero
 180cdd0:	003f4906 	br	180caf8 <__ram_exceptions_end+0xff7fc6b4>
 180cdd4:	010007c4 	movi	r4,31
 180cdd8:	20803a16 	blt	r4,r2,180cec4 <__subdf3+0x5f4>
 180cddc:	01000804 	movi	r4,32
 180cde0:	2089c83a 	sub	r4,r4,r2
 180cde4:	2912983a 	sll	r9,r5,r4
 180cde8:	3090d83a 	srl	r8,r6,r2
 180cdec:	3108983a 	sll	r4,r6,r4
 180cdf0:	2884d83a 	srl	r2,r5,r2
 180cdf4:	4a12b03a 	or	r9,r9,r8
 180cdf8:	2008c03a 	cmpne	r4,r4,zero
 180cdfc:	4912b03a 	or	r9,r9,r4
 180ce00:	003f4e06 	br	180cb3c <__ram_exceptions_end+0xff7fc6f8>
 180ce04:	1c48b03a 	or	r4,r3,r17
 180ce08:	20003c26 	beq	r4,zero,180cefc <__subdf3+0x62c>
 180ce0c:	0084303a 	nor	r2,zero,r2
 180ce10:	1000381e 	bne	r2,zero,180cef4 <__subdf3+0x624>
 180ce14:	3463c83a 	sub	r17,r6,r17
 180ce18:	28c5c83a 	sub	r2,r5,r3
 180ce1c:	344d803a 	cmpltu	r6,r6,r17
 180ce20:	1187c83a 	sub	r3,r2,r6
 180ce24:	4821883a 	mov	r16,r9
 180ce28:	3825883a 	mov	r18,r7
 180ce2c:	003f0606 	br	180ca48 <__ram_exceptions_end+0xff7fc604>
 180ce30:	2023883a 	mov	r17,r4
 180ce34:	003f0906 	br	180ca5c <__ram_exceptions_end+0xff7fc618>
 180ce38:	0101ffc4 	movi	r4,2047
 180ce3c:	813f3a1e 	bne	r16,r4,180cb28 <__ram_exceptions_end+0xff7fc6e4>
 180ce40:	003ec406 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180ce44:	0005883a 	mov	r2,zero
 180ce48:	003fb106 	br	180cd10 <__ram_exceptions_end+0xff7fc8cc>
 180ce4c:	0005883a 	mov	r2,zero
 180ce50:	003fbc06 	br	180cd44 <__ram_exceptions_end+0xff7fc900>
 180ce54:	1c44b03a 	or	r2,r3,r17
 180ce58:	80008e1e 	bne	r16,zero,180d094 <__subdf3+0x7c4>
 180ce5c:	1000c826 	beq	r2,zero,180d180 <__subdf3+0x8b0>
 180ce60:	2984b03a 	or	r2,r5,r6
 180ce64:	103ebb26 	beq	r2,zero,180c954 <__ram_exceptions_end+0xff7fc510>
 180ce68:	8989883a 	add	r4,r17,r6
 180ce6c:	1945883a 	add	r2,r3,r5
 180ce70:	2447803a 	cmpltu	r3,r4,r17
 180ce74:	1887883a 	add	r3,r3,r2
 180ce78:	1880202c 	andhi	r2,r3,128
 180ce7c:	2023883a 	mov	r17,r4
 180ce80:	103f1626 	beq	r2,zero,180cadc <__ram_exceptions_end+0xff7fc698>
 180ce84:	00bfe034 	movhi	r2,65408
 180ce88:	10bfffc4 	addi	r2,r2,-1
 180ce8c:	5021883a 	mov	r16,r10
 180ce90:	1886703a 	and	r3,r3,r2
 180ce94:	003eaf06 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180ce98:	3825883a 	mov	r18,r7
 180ce9c:	003f0f06 	br	180cadc <__ram_exceptions_end+0xff7fc698>
 180cea0:	1c44b03a 	or	r2,r3,r17
 180cea4:	8000251e 	bne	r16,zero,180cf3c <__subdf3+0x66c>
 180cea8:	1000661e 	bne	r2,zero,180d044 <__subdf3+0x774>
 180ceac:	2990b03a 	or	r8,r5,r6
 180ceb0:	40009626 	beq	r8,zero,180d10c <__subdf3+0x83c>
 180ceb4:	2807883a 	mov	r3,r5
 180ceb8:	3023883a 	mov	r17,r6
 180cebc:	3825883a 	mov	r18,r7
 180cec0:	003ea406 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cec4:	127ff804 	addi	r9,r2,-32
 180cec8:	01000804 	movi	r4,32
 180cecc:	2a52d83a 	srl	r9,r5,r9
 180ced0:	11008c26 	beq	r2,r4,180d104 <__subdf3+0x834>
 180ced4:	01001004 	movi	r4,64
 180ced8:	2085c83a 	sub	r2,r4,r2
 180cedc:	2884983a 	sll	r2,r5,r2
 180cee0:	118cb03a 	or	r6,r2,r6
 180cee4:	300cc03a 	cmpne	r6,r6,zero
 180cee8:	4992b03a 	or	r9,r9,r6
 180ceec:	0005883a 	mov	r2,zero
 180cef0:	003f1206 	br	180cb3c <__ram_exceptions_end+0xff7fc6f8>
 180cef4:	0101ffc4 	movi	r4,2047
 180cef8:	493f9c1e 	bne	r9,r4,180cd6c <__ram_exceptions_end+0xff7fc928>
 180cefc:	2807883a 	mov	r3,r5
 180cf00:	3023883a 	mov	r17,r6
 180cf04:	4821883a 	mov	r16,r9
 180cf08:	3825883a 	mov	r18,r7
 180cf0c:	003e9106 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cf10:	80001f1e 	bne	r16,zero,180cf90 <__subdf3+0x6c0>
 180cf14:	1c48b03a 	or	r4,r3,r17
 180cf18:	20005a26 	beq	r4,zero,180d084 <__subdf3+0x7b4>
 180cf1c:	0084303a 	nor	r2,zero,r2
 180cf20:	1000561e 	bne	r2,zero,180d07c <__subdf3+0x7ac>
 180cf24:	89a3883a 	add	r17,r17,r6
 180cf28:	1945883a 	add	r2,r3,r5
 180cf2c:	898d803a 	cmpltu	r6,r17,r6
 180cf30:	3087883a 	add	r3,r6,r2
 180cf34:	4821883a 	mov	r16,r9
 180cf38:	003f0506 	br	180cb50 <__ram_exceptions_end+0xff7fc70c>
 180cf3c:	10002b1e 	bne	r2,zero,180cfec <__subdf3+0x71c>
 180cf40:	2984b03a 	or	r2,r5,r6
 180cf44:	10008026 	beq	r2,zero,180d148 <__subdf3+0x878>
 180cf48:	2807883a 	mov	r3,r5
 180cf4c:	3023883a 	mov	r17,r6
 180cf50:	3825883a 	mov	r18,r7
 180cf54:	0401ffc4 	movi	r16,2047
 180cf58:	003e7e06 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180cf5c:	3809883a 	mov	r4,r7
 180cf60:	0011883a 	mov	r8,zero
 180cf64:	0005883a 	mov	r2,zero
 180cf68:	003ee306 	br	180caf8 <__ram_exceptions_end+0xff7fc6b4>
 180cf6c:	1c62b03a 	or	r17,r3,r17
 180cf70:	8822c03a 	cmpne	r17,r17,zero
 180cf74:	0005883a 	mov	r2,zero
 180cf78:	003f8906 	br	180cda0 <__ram_exceptions_end+0xff7fc95c>
 180cf7c:	3809883a 	mov	r4,r7
 180cf80:	4821883a 	mov	r16,r9
 180cf84:	0011883a 	mov	r8,zero
 180cf88:	0005883a 	mov	r2,zero
 180cf8c:	003eda06 	br	180caf8 <__ram_exceptions_end+0xff7fc6b4>
 180cf90:	0101ffc4 	movi	r4,2047
 180cf94:	49003b26 	beq	r9,r4,180d084 <__subdf3+0x7b4>
 180cf98:	0085c83a 	sub	r2,zero,r2
 180cf9c:	18c02034 	orhi	r3,r3,128
 180cfa0:	01000e04 	movi	r4,56
 180cfa4:	20806e16 	blt	r4,r2,180d160 <__subdf3+0x890>
 180cfa8:	010007c4 	movi	r4,31
 180cfac:	20807716 	blt	r4,r2,180d18c <__subdf3+0x8bc>
 180cfb0:	01000804 	movi	r4,32
 180cfb4:	2089c83a 	sub	r4,r4,r2
 180cfb8:	1914983a 	sll	r10,r3,r4
 180cfbc:	8890d83a 	srl	r8,r17,r2
 180cfc0:	8908983a 	sll	r4,r17,r4
 180cfc4:	1884d83a 	srl	r2,r3,r2
 180cfc8:	5222b03a 	or	r17,r10,r8
 180cfcc:	2006c03a 	cmpne	r3,r4,zero
 180cfd0:	88e2b03a 	or	r17,r17,r3
 180cfd4:	89a3883a 	add	r17,r17,r6
 180cfd8:	1145883a 	add	r2,r2,r5
 180cfdc:	898d803a 	cmpltu	r6,r17,r6
 180cfe0:	3087883a 	add	r3,r6,r2
 180cfe4:	4821883a 	mov	r16,r9
 180cfe8:	003ed906 	br	180cb50 <__ram_exceptions_end+0xff7fc70c>
 180cfec:	2984b03a 	or	r2,r5,r6
 180cff0:	10004226 	beq	r2,zero,180d0fc <__subdf3+0x82c>
 180cff4:	1808d0fa 	srli	r4,r3,3
 180cff8:	8822d0fa 	srli	r17,r17,3
 180cffc:	1806977a 	slli	r3,r3,29
 180d000:	2080022c 	andhi	r2,r4,8
 180d004:	1c62b03a 	or	r17,r3,r17
 180d008:	10000826 	beq	r2,zero,180d02c <__subdf3+0x75c>
 180d00c:	2812d0fa 	srli	r9,r5,3
 180d010:	4880022c 	andhi	r2,r9,8
 180d014:	1000051e 	bne	r2,zero,180d02c <__subdf3+0x75c>
 180d018:	300cd0fa 	srli	r6,r6,3
 180d01c:	2804977a 	slli	r2,r5,29
 180d020:	4809883a 	mov	r4,r9
 180d024:	3825883a 	mov	r18,r7
 180d028:	11a2b03a 	or	r17,r2,r6
 180d02c:	8806d77a 	srli	r3,r17,29
 180d030:	200890fa 	slli	r4,r4,3
 180d034:	882290fa 	slli	r17,r17,3
 180d038:	0401ffc4 	movi	r16,2047
 180d03c:	1906b03a 	or	r3,r3,r4
 180d040:	003e4406 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d044:	2984b03a 	or	r2,r5,r6
 180d048:	103e4226 	beq	r2,zero,180c954 <__ram_exceptions_end+0xff7fc510>
 180d04c:	8989c83a 	sub	r4,r17,r6
 180d050:	8911803a 	cmpltu	r8,r17,r4
 180d054:	1945c83a 	sub	r2,r3,r5
 180d058:	1205c83a 	sub	r2,r2,r8
 180d05c:	1200202c 	andhi	r8,r2,128
 180d060:	403e9a26 	beq	r8,zero,180cacc <__ram_exceptions_end+0xff7fc688>
 180d064:	3463c83a 	sub	r17,r6,r17
 180d068:	28c5c83a 	sub	r2,r5,r3
 180d06c:	344d803a 	cmpltu	r6,r6,r17
 180d070:	1187c83a 	sub	r3,r2,r6
 180d074:	3825883a 	mov	r18,r7
 180d078:	003e3606 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d07c:	0101ffc4 	movi	r4,2047
 180d080:	493fc71e 	bne	r9,r4,180cfa0 <__ram_exceptions_end+0xff7fcb5c>
 180d084:	2807883a 	mov	r3,r5
 180d088:	3023883a 	mov	r17,r6
 180d08c:	4821883a 	mov	r16,r9
 180d090:	003e3006 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d094:	10003626 	beq	r2,zero,180d170 <__subdf3+0x8a0>
 180d098:	2984b03a 	or	r2,r5,r6
 180d09c:	10001726 	beq	r2,zero,180d0fc <__subdf3+0x82c>
 180d0a0:	1808d0fa 	srli	r4,r3,3
 180d0a4:	8822d0fa 	srli	r17,r17,3
 180d0a8:	1806977a 	slli	r3,r3,29
 180d0ac:	2080022c 	andhi	r2,r4,8
 180d0b0:	1c62b03a 	or	r17,r3,r17
 180d0b4:	10000726 	beq	r2,zero,180d0d4 <__subdf3+0x804>
 180d0b8:	2812d0fa 	srli	r9,r5,3
 180d0bc:	4880022c 	andhi	r2,r9,8
 180d0c0:	1000041e 	bne	r2,zero,180d0d4 <__subdf3+0x804>
 180d0c4:	300cd0fa 	srli	r6,r6,3
 180d0c8:	2804977a 	slli	r2,r5,29
 180d0cc:	4809883a 	mov	r4,r9
 180d0d0:	11a2b03a 	or	r17,r2,r6
 180d0d4:	8806d77a 	srli	r3,r17,29
 180d0d8:	200890fa 	slli	r4,r4,3
 180d0dc:	882290fa 	slli	r17,r17,3
 180d0e0:	3825883a 	mov	r18,r7
 180d0e4:	1906b03a 	or	r3,r3,r4
 180d0e8:	0401ffc4 	movi	r16,2047
 180d0ec:	003e1906 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d0f0:	000b883a 	mov	r5,zero
 180d0f4:	0005883a 	mov	r2,zero
 180d0f8:	003e2e06 	br	180c9b4 <__ram_exceptions_end+0xff7fc570>
 180d0fc:	0401ffc4 	movi	r16,2047
 180d100:	003e1406 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d104:	0005883a 	mov	r2,zero
 180d108:	003f7506 	br	180cee0 <__ram_exceptions_end+0xff7fca9c>
 180d10c:	0005883a 	mov	r2,zero
 180d110:	0009883a 	mov	r4,zero
 180d114:	003e7806 	br	180caf8 <__ram_exceptions_end+0xff7fc6b4>
 180d118:	123ff804 	addi	r8,r2,-32
 180d11c:	01000804 	movi	r4,32
 180d120:	1a10d83a 	srl	r8,r3,r8
 180d124:	11002526 	beq	r2,r4,180d1bc <__subdf3+0x8ec>
 180d128:	01001004 	movi	r4,64
 180d12c:	2085c83a 	sub	r2,r4,r2
 180d130:	1884983a 	sll	r2,r3,r2
 180d134:	1444b03a 	or	r2,r2,r17
 180d138:	1004c03a 	cmpne	r2,r2,zero
 180d13c:	40a2b03a 	or	r17,r8,r2
 180d140:	0005883a 	mov	r2,zero
 180d144:	003f1606 	br	180cda0 <__ram_exceptions_end+0xff7fc95c>
 180d148:	02000434 	movhi	r8,16
 180d14c:	0009883a 	mov	r4,zero
 180d150:	423fffc4 	addi	r8,r8,-1
 180d154:	00bfffc4 	movi	r2,-1
 180d158:	0401ffc4 	movi	r16,2047
 180d15c:	003e6606 	br	180caf8 <__ram_exceptions_end+0xff7fc6b4>
 180d160:	1c62b03a 	or	r17,r3,r17
 180d164:	8822c03a 	cmpne	r17,r17,zero
 180d168:	0005883a 	mov	r2,zero
 180d16c:	003f9906 	br	180cfd4 <__ram_exceptions_end+0xff7fcb90>
 180d170:	2807883a 	mov	r3,r5
 180d174:	3023883a 	mov	r17,r6
 180d178:	0401ffc4 	movi	r16,2047
 180d17c:	003df506 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d180:	2807883a 	mov	r3,r5
 180d184:	3023883a 	mov	r17,r6
 180d188:	003df206 	br	180c954 <__ram_exceptions_end+0xff7fc510>
 180d18c:	123ff804 	addi	r8,r2,-32
 180d190:	01000804 	movi	r4,32
 180d194:	1a10d83a 	srl	r8,r3,r8
 180d198:	11000a26 	beq	r2,r4,180d1c4 <__subdf3+0x8f4>
 180d19c:	01001004 	movi	r4,64
 180d1a0:	2085c83a 	sub	r2,r4,r2
 180d1a4:	1884983a 	sll	r2,r3,r2
 180d1a8:	1444b03a 	or	r2,r2,r17
 180d1ac:	1004c03a 	cmpne	r2,r2,zero
 180d1b0:	40a2b03a 	or	r17,r8,r2
 180d1b4:	0005883a 	mov	r2,zero
 180d1b8:	003f8606 	br	180cfd4 <__ram_exceptions_end+0xff7fcb90>
 180d1bc:	0005883a 	mov	r2,zero
 180d1c0:	003fdc06 	br	180d134 <__ram_exceptions_end+0xff7fccf0>
 180d1c4:	0005883a 	mov	r2,zero
 180d1c8:	003ff706 	br	180d1a8 <__ram_exceptions_end+0xff7fcd64>

0180d1cc <__fixdfsi>:
 180d1cc:	280cd53a 	srli	r6,r5,20
 180d1d0:	00c00434 	movhi	r3,16
 180d1d4:	18ffffc4 	addi	r3,r3,-1
 180d1d8:	3181ffcc 	andi	r6,r6,2047
 180d1dc:	01c0ff84 	movi	r7,1022
 180d1e0:	28c6703a 	and	r3,r5,r3
 180d1e4:	280ad7fa 	srli	r5,r5,31
 180d1e8:	3980120e 	bge	r7,r6,180d234 <__fixdfsi+0x68>
 180d1ec:	00810744 	movi	r2,1053
 180d1f0:	11800c16 	blt	r2,r6,180d224 <__fixdfsi+0x58>
 180d1f4:	00810cc4 	movi	r2,1075
 180d1f8:	1185c83a 	sub	r2,r2,r6
 180d1fc:	01c007c4 	movi	r7,31
 180d200:	18c00434 	orhi	r3,r3,16
 180d204:	38800d16 	blt	r7,r2,180d23c <__fixdfsi+0x70>
 180d208:	31befb44 	addi	r6,r6,-1043
 180d20c:	2084d83a 	srl	r2,r4,r2
 180d210:	1986983a 	sll	r3,r3,r6
 180d214:	1884b03a 	or	r2,r3,r2
 180d218:	28000726 	beq	r5,zero,180d238 <__fixdfsi+0x6c>
 180d21c:	0085c83a 	sub	r2,zero,r2
 180d220:	f800283a 	ret
 180d224:	00a00034 	movhi	r2,32768
 180d228:	10bfffc4 	addi	r2,r2,-1
 180d22c:	2885883a 	add	r2,r5,r2
 180d230:	f800283a 	ret
 180d234:	0005883a 	mov	r2,zero
 180d238:	f800283a 	ret
 180d23c:	008104c4 	movi	r2,1043
 180d240:	1185c83a 	sub	r2,r2,r6
 180d244:	1884d83a 	srl	r2,r3,r2
 180d248:	003ff306 	br	180d218 <__ram_exceptions_end+0xff7fcdd4>

0180d24c <__floatsidf>:
 180d24c:	defffd04 	addi	sp,sp,-12
 180d250:	dfc00215 	stw	ra,8(sp)
 180d254:	dc400115 	stw	r17,4(sp)
 180d258:	dc000015 	stw	r16,0(sp)
 180d25c:	20002b26 	beq	r4,zero,180d30c <__floatsidf+0xc0>
 180d260:	2023883a 	mov	r17,r4
 180d264:	2020d7fa 	srli	r16,r4,31
 180d268:	20002d16 	blt	r4,zero,180d320 <__floatsidf+0xd4>
 180d26c:	8809883a 	mov	r4,r17
 180d270:	180d3d00 	call	180d3d0 <__clzsi2>
 180d274:	01410784 	movi	r5,1054
 180d278:	288bc83a 	sub	r5,r5,r2
 180d27c:	01010cc4 	movi	r4,1075
 180d280:	2149c83a 	sub	r4,r4,r5
 180d284:	00c007c4 	movi	r3,31
 180d288:	1900160e 	bge	r3,r4,180d2e4 <__floatsidf+0x98>
 180d28c:	00c104c4 	movi	r3,1043
 180d290:	1947c83a 	sub	r3,r3,r5
 180d294:	88c6983a 	sll	r3,r17,r3
 180d298:	00800434 	movhi	r2,16
 180d29c:	10bfffc4 	addi	r2,r2,-1
 180d2a0:	1886703a 	and	r3,r3,r2
 180d2a4:	2941ffcc 	andi	r5,r5,2047
 180d2a8:	800d883a 	mov	r6,r16
 180d2ac:	0005883a 	mov	r2,zero
 180d2b0:	280a953a 	slli	r5,r5,20
 180d2b4:	31803fcc 	andi	r6,r6,255
 180d2b8:	01000434 	movhi	r4,16
 180d2bc:	300c97fa 	slli	r6,r6,31
 180d2c0:	213fffc4 	addi	r4,r4,-1
 180d2c4:	1906703a 	and	r3,r3,r4
 180d2c8:	1946b03a 	or	r3,r3,r5
 180d2cc:	1986b03a 	or	r3,r3,r6
 180d2d0:	dfc00217 	ldw	ra,8(sp)
 180d2d4:	dc400117 	ldw	r17,4(sp)
 180d2d8:	dc000017 	ldw	r16,0(sp)
 180d2dc:	dec00304 	addi	sp,sp,12
 180d2e0:	f800283a 	ret
 180d2e4:	00c002c4 	movi	r3,11
 180d2e8:	1887c83a 	sub	r3,r3,r2
 180d2ec:	88c6d83a 	srl	r3,r17,r3
 180d2f0:	8904983a 	sll	r2,r17,r4
 180d2f4:	01000434 	movhi	r4,16
 180d2f8:	213fffc4 	addi	r4,r4,-1
 180d2fc:	2941ffcc 	andi	r5,r5,2047
 180d300:	1906703a 	and	r3,r3,r4
 180d304:	800d883a 	mov	r6,r16
 180d308:	003fe906 	br	180d2b0 <__ram_exceptions_end+0xff7fce6c>
 180d30c:	000d883a 	mov	r6,zero
 180d310:	000b883a 	mov	r5,zero
 180d314:	0007883a 	mov	r3,zero
 180d318:	0005883a 	mov	r2,zero
 180d31c:	003fe406 	br	180d2b0 <__ram_exceptions_end+0xff7fce6c>
 180d320:	0123c83a 	sub	r17,zero,r4
 180d324:	003fd106 	br	180d26c <__ram_exceptions_end+0xff7fce28>

0180d328 <__floatunsidf>:
 180d328:	defffe04 	addi	sp,sp,-8
 180d32c:	dc000015 	stw	r16,0(sp)
 180d330:	dfc00115 	stw	ra,4(sp)
 180d334:	2021883a 	mov	r16,r4
 180d338:	20002226 	beq	r4,zero,180d3c4 <__floatunsidf+0x9c>
 180d33c:	180d3d00 	call	180d3d0 <__clzsi2>
 180d340:	01010784 	movi	r4,1054
 180d344:	2089c83a 	sub	r4,r4,r2
 180d348:	01810cc4 	movi	r6,1075
 180d34c:	310dc83a 	sub	r6,r6,r4
 180d350:	00c007c4 	movi	r3,31
 180d354:	1980120e 	bge	r3,r6,180d3a0 <__floatunsidf+0x78>
 180d358:	00c104c4 	movi	r3,1043
 180d35c:	1907c83a 	sub	r3,r3,r4
 180d360:	80ca983a 	sll	r5,r16,r3
 180d364:	00800434 	movhi	r2,16
 180d368:	10bfffc4 	addi	r2,r2,-1
 180d36c:	2101ffcc 	andi	r4,r4,2047
 180d370:	0021883a 	mov	r16,zero
 180d374:	288a703a 	and	r5,r5,r2
 180d378:	2008953a 	slli	r4,r4,20
 180d37c:	00c00434 	movhi	r3,16
 180d380:	18ffffc4 	addi	r3,r3,-1
 180d384:	28c6703a 	and	r3,r5,r3
 180d388:	8005883a 	mov	r2,r16
 180d38c:	1906b03a 	or	r3,r3,r4
 180d390:	dfc00117 	ldw	ra,4(sp)
 180d394:	dc000017 	ldw	r16,0(sp)
 180d398:	dec00204 	addi	sp,sp,8
 180d39c:	f800283a 	ret
 180d3a0:	00c002c4 	movi	r3,11
 180d3a4:	188bc83a 	sub	r5,r3,r2
 180d3a8:	814ad83a 	srl	r5,r16,r5
 180d3ac:	00c00434 	movhi	r3,16
 180d3b0:	18ffffc4 	addi	r3,r3,-1
 180d3b4:	81a0983a 	sll	r16,r16,r6
 180d3b8:	2101ffcc 	andi	r4,r4,2047
 180d3bc:	28ca703a 	and	r5,r5,r3
 180d3c0:	003fed06 	br	180d378 <__ram_exceptions_end+0xff7fcf34>
 180d3c4:	0009883a 	mov	r4,zero
 180d3c8:	000b883a 	mov	r5,zero
 180d3cc:	003fea06 	br	180d378 <__ram_exceptions_end+0xff7fcf34>

0180d3d0 <__clzsi2>:
 180d3d0:	00bfffd4 	movui	r2,65535
 180d3d4:	11000536 	bltu	r2,r4,180d3ec <__clzsi2+0x1c>
 180d3d8:	00803fc4 	movi	r2,255
 180d3dc:	11000f36 	bltu	r2,r4,180d41c <__clzsi2+0x4c>
 180d3e0:	00800804 	movi	r2,32
 180d3e4:	0007883a 	mov	r3,zero
 180d3e8:	00000506 	br	180d400 <__clzsi2+0x30>
 180d3ec:	00804034 	movhi	r2,256
 180d3f0:	10bfffc4 	addi	r2,r2,-1
 180d3f4:	11000c2e 	bgeu	r2,r4,180d428 <__clzsi2+0x58>
 180d3f8:	00800204 	movi	r2,8
 180d3fc:	00c00604 	movi	r3,24
 180d400:	20c8d83a 	srl	r4,r4,r3
 180d404:	00c06134 	movhi	r3,388
 180d408:	18c54f04 	addi	r3,r3,5436
 180d40c:	1909883a 	add	r4,r3,r4
 180d410:	20c00003 	ldbu	r3,0(r4)
 180d414:	10c5c83a 	sub	r2,r2,r3
 180d418:	f800283a 	ret
 180d41c:	00800604 	movi	r2,24
 180d420:	00c00204 	movi	r3,8
 180d424:	003ff606 	br	180d400 <__ram_exceptions_end+0xff7fcfbc>
 180d428:	00800404 	movi	r2,16
 180d42c:	1007883a 	mov	r3,r2
 180d430:	003ff306 	br	180d400 <__ram_exceptions_end+0xff7fcfbc>

0180d434 <pre_constructors>:
/*
 * We want this pre_constructors and post_constructors functions to be called when it is defined by the user, if the user didn't define it
 * we don't want a link error, just call this empty function
 */
void __attribute__((weak)) pre_constructors()
{
 180d434:	deffff04 	addi	sp,sp,-4
 180d438:	df000015 	stw	fp,0(sp)
 180d43c:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 180d440:	0001883a 	nop
 180d444:	e037883a 	mov	sp,fp
 180d448:	df000017 	ldw	fp,0(sp)
 180d44c:	dec00104 	addi	sp,sp,4
 180d450:	f800283a 	ret

0180d454 <post_constructors>:

void __attribute__((weak)) post_constructors()
{
 180d454:	deffff04 	addi	sp,sp,-4
 180d458:	df000015 	stw	fp,0(sp)
 180d45c:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 180d460:	0001883a 	nop
 180d464:	e037883a 	mov	sp,fp
 180d468:	df000017 	ldw	fp,0(sp)
 180d46c:	dec00104 	addi	sp,sp,4
 180d470:	f800283a 	ret

0180d474 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 180d474:	defff904 	addi	sp,sp,-28
 180d478:	dfc00615 	stw	ra,24(sp)
 180d47c:	df000515 	stw	fp,20(sp)
 180d480:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 180d484:	0009883a 	mov	r4,zero
 180d488:	1824cfc0 	call	1824cfc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 180d48c:	01000104 	movi	r4,4
 180d490:	180d89c0 	call	180d89c <xQueueCreateMutex>
 180d494:	d0a7d215 	stw	r2,-24760(gp)
 180d498:	01000104 	movi	r4,4
 180d49c:	180d89c0 	call	180d89c <xQueueCreateMutex>
 180d4a0:	d0a80215 	stw	r2,-24568(gp)
 180d4a4:	d0a7e704 	addi	r2,gp,-24676
 180d4a8:	e0bffc15 	stw	r2,-16(fp)
 180d4ac:	00800044 	movi	r2,1
 180d4b0:	e0bffd0d 	sth	r2,-12(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 180d4b4:	e0bffd0b 	ldhu	r2,-12(fp)
 180d4b8:	10000226 	beq	r2,zero,180d4c4 <alt_main+0x50>
 180d4bc:	e0bffd0b 	ldhu	r2,-12(fp)
 180d4c0:	00000106 	br	180d4c8 <alt_main+0x54>
 180d4c4:	00800044 	movi	r2,1
 180d4c8:	e0fffd0b 	ldhu	r3,-12(fp)
 180d4cc:	180b883a 	mov	r5,r3
 180d4d0:	1009883a 	mov	r4,r2
 180d4d4:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 180d4d8:	1007883a 	mov	r3,r2
 180d4dc:	e0bffc17 	ldw	r2,-16(fp)
 180d4e0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 180d4e4:	1824d340 	call	1824d34 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 180d4e8:	01806134 	movhi	r6,388
 180d4ec:	31858f04 	addi	r6,r6,5692
 180d4f0:	01406134 	movhi	r5,388
 180d4f4:	29458f04 	addi	r5,r5,5692
 180d4f8:	01006134 	movhi	r4,388
 180d4fc:	21058f04 	addi	r4,r4,5692
 180d500:	18129680 	call	1812968 <alt_io_redirect>
#endif

  /*
   * Call the pre_constructors function
   */
  pre_constructors();
 180d504:	180d4340 	call	180d434 <pre_constructors>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 180d508:	18126f80 	call	18126f8 <_do_ctors>
#endif /* ALT_NO_C_PLUS_PLUS */

  /*
   * Call the post_constructors function
   */
  post_constructors();
 180d50c:	180d4540 	call	180d454 <post_constructors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 180d510:	01006074 	movhi	r4,385
 180d514:	2109d604 	addi	r4,r4,10072
 180d518:	183cfd40 	call	183cfd4 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 180d51c:	d0a7cf17 	ldw	r2,-24772(gp)
 180d520:	d0e7d017 	ldw	r3,-24768(gp)
 180d524:	d127d117 	ldw	r4,-24764(gp)
 180d528:	200d883a 	mov	r6,r4
 180d52c:	180b883a 	mov	r5,r3
 180d530:	1009883a 	mov	r4,r2
 180d534:	1800ad80 	call	1800ad8 <main>
 180d538:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 180d53c:	01000044 	movi	r4,1
 180d540:	18132c00 	call	18132c0 <close>
  exit (result);
 180d544:	e13ffb17 	ldw	r4,-20(fp)
 180d548:	183cff80 	call	183cff8 <exit>

0180d54c <__malloc_lock>:
xSemaphoreHandle alt_heapsem;

/* __malloc_lock needs to provide recursive mutex locking */

void __malloc_lock ( struct _reent *_r )
{
 180d54c:	defffd04 	addi	sp,sp,-12
 180d550:	dfc00215 	stw	ra,8(sp)
 180d554:	df000115 	stw	fp,4(sp)
 180d558:	df000104 	addi	fp,sp,4
 180d55c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 180d560:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180d564:	10000b26 	beq	r2,zero,180d594 <__malloc_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 180d568:	00000206 	br	180d574 <__malloc_lock+0x28>
		vTaskDelay(1);
 180d56c:	01000044 	movi	r4,1
 180d570:	180f2cc0 	call	180f2cc <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 180d574:	d0a7d217 	ldw	r2,-24760(gp)
 180d578:	01400284 	movi	r5,10
 180d57c:	1009883a 	mov	r4,r2
 180d580:	180d9880 	call	180d988 <xQueueTakeMutexRecursive>
 180d584:	10800058 	cmpnei	r2,r2,1
 180d588:	103ff81e 	bne	r2,zero,180d56c <__ram_exceptions_end+0xff7fd128>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 180d58c:	0001883a 	nop
 180d590:	00000106 	br	180d598 <__malloc_lock+0x4c>

void __malloc_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 180d594:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 180d598:	e037883a 	mov	sp,fp
 180d59c:	dfc00117 	ldw	ra,4(sp)
 180d5a0:	df000017 	ldw	fp,0(sp)
 180d5a4:	dec00204 	addi	sp,sp,8
 180d5a8:	f800283a 	ret

0180d5ac <__malloc_unlock>:

/* __malloc_unlock needs to provide recursive mutex unlocking */

void __malloc_unlock ( struct _reent *_r )
{
 180d5ac:	defffd04 	addi	sp,sp,-12
 180d5b0:	dfc00215 	stw	ra,8(sp)
 180d5b4:	df000115 	stw	fp,4(sp)
 180d5b8:	df000104 	addi	fp,sp,4
 180d5bc:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 180d5c0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180d5c4:	10000426 	beq	r2,zero,180d5d8 <__malloc_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_heapsem);
 180d5c8:	d0a7d217 	ldw	r2,-24760(gp)
 180d5cc:	1009883a 	mov	r4,r2
 180d5d0:	180d8f80 	call	180d8f8 <xQueueGiveMutexRecursive>
 180d5d4:	00000106 	br	180d5dc <__malloc_unlock+0x30>

void __malloc_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 180d5d8:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_heapsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 180d5dc:	e037883a 	mov	sp,fp
 180d5e0:	dfc00117 	ldw	ra,4(sp)
 180d5e4:	df000017 	ldw	fp,0(sp)
 180d5e8:	dec00204 	addi	sp,sp,8
 180d5ec:	f800283a 	ret

0180d5f0 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 180d5f0:	defffb04 	addi	sp,sp,-20
 180d5f4:	dfc00415 	stw	ra,16(sp)
 180d5f8:	df000315 	stw	fp,12(sp)
 180d5fc:	df000304 	addi	fp,sp,12
 180d600:	e13ffe15 	stw	r4,-8(fp)
 180d604:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
 180d608:	e0bffe17 	ldw	r2,-8(fp)
 180d60c:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 180d610:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180d614:	10000126 	beq	r2,zero,180d61c <xQueueGenericReset+0x2c>
 180d618:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 180d61c:	e0bffd17 	ldw	r2,-12(fp)
 180d620:	10c00017 	ldw	r3,0(r2)
 180d624:	e0bffd17 	ldw	r2,-12(fp)
 180d628:	11000f17 	ldw	r4,60(r2)
 180d62c:	e0bffd17 	ldw	r2,-12(fp)
 180d630:	10801017 	ldw	r2,64(r2)
 180d634:	2085383a 	mul	r2,r4,r2
 180d638:	1887883a 	add	r3,r3,r2
 180d63c:	e0bffd17 	ldw	r2,-12(fp)
 180d640:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 180d644:	e0bffd17 	ldw	r2,-12(fp)
 180d648:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 180d64c:	e0bffd17 	ldw	r2,-12(fp)
 180d650:	10c00017 	ldw	r3,0(r2)
 180d654:	e0bffd17 	ldw	r2,-12(fp)
 180d658:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 180d65c:	e0bffd17 	ldw	r2,-12(fp)
 180d660:	10c00017 	ldw	r3,0(r2)
 180d664:	e0bffd17 	ldw	r2,-12(fp)
 180d668:	10800f17 	ldw	r2,60(r2)
 180d66c:	113fffc4 	addi	r4,r2,-1
 180d670:	e0bffd17 	ldw	r2,-12(fp)
 180d674:	10801017 	ldw	r2,64(r2)
 180d678:	2085383a 	mul	r2,r4,r2
 180d67c:	1887883a 	add	r3,r3,r2
 180d680:	e0bffd17 	ldw	r2,-12(fp)
 180d684:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 180d688:	e0bffd17 	ldw	r2,-12(fp)
 180d68c:	00ffffc4 	movi	r3,-1
 180d690:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 180d694:	e0bffd17 	ldw	r2,-12(fp)
 180d698:	00ffffc4 	movi	r3,-1
 180d69c:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 180d6a0:	e0bfff17 	ldw	r2,-4(fp)
 180d6a4:	10000a1e 	bne	r2,zero,180d6d0 <xQueueGenericReset+0xe0>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 180d6a8:	e0bffd17 	ldw	r2,-12(fp)
 180d6ac:	10800417 	ldw	r2,16(r2)
 180d6b0:	10000f26 	beq	r2,zero,180d6f0 <xQueueGenericReset+0x100>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 180d6b4:	e0bffd17 	ldw	r2,-12(fp)
 180d6b8:	10800404 	addi	r2,r2,16
 180d6bc:	1009883a 	mov	r4,r2
 180d6c0:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180d6c4:	10000a26 	beq	r2,zero,180d6f0 <xQueueGenericReset+0x100>
				{
					queueYIELD_IF_USING_PREEMPTION();
 180d6c8:	003b683a 	trap	0
 180d6cc:	00000806 	br	180d6f0 <xQueueGenericReset+0x100>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 180d6d0:	e0bffd17 	ldw	r2,-12(fp)
 180d6d4:	10800404 	addi	r2,r2,16
 180d6d8:	1009883a 	mov	r4,r2
 180d6dc:	18273040 	call	1827304 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 180d6e0:	e0bffd17 	ldw	r2,-12(fp)
 180d6e4:	10800904 	addi	r2,r2,36
 180d6e8:	1009883a 	mov	r4,r2
 180d6ec:	18273040 	call	1827304 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 180d6f0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180d6f4:	10000126 	beq	r2,zero,180d6fc <xQueueGenericReset+0x10c>
 180d6f8:	18110840 	call	1811084 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 180d6fc:	00800044 	movi	r2,1
}
 180d700:	e037883a 	mov	sp,fp
 180d704:	dfc00117 	ldw	ra,4(sp)
 180d708:	df000017 	ldw	fp,0(sp)
 180d70c:	dec00204 	addi	sp,sp,8
 180d710:	f800283a 	ret

0180d714 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 180d714:	defff704 	addi	sp,sp,-36
 180d718:	dfc00815 	stw	ra,32(sp)
 180d71c:	df000715 	stw	fp,28(sp)
 180d720:	df000704 	addi	fp,sp,28
 180d724:	e13ffd15 	stw	r4,-12(fp)
 180d728:	e17ffe15 	stw	r5,-8(fp)
 180d72c:	3005883a 	mov	r2,r6
 180d730:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 180d734:	e0fffd17 	ldw	r3,-12(fp)
 180d738:	e0bffe17 	ldw	r2,-8(fp)
 180d73c:	1885383a 	mul	r2,r3,r2
 180d740:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 180d744:	e0bffa17 	ldw	r2,-24(fp)
 180d748:	10801404 	addi	r2,r2,80
 180d74c:	1009883a 	mov	r4,r2
 180d750:	18272740 	call	1827274 <pvPortMalloc>
 180d754:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 180d758:	e0bffb17 	ldw	r2,-20(fp)
 180d75c:	10000d26 	beq	r2,zero,180d794 <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 180d760:	e0bffb17 	ldw	r2,-20(fp)
 180d764:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 180d768:	e0bffc17 	ldw	r2,-16(fp)
 180d76c:	10801404 	addi	r2,r2,80
 180d770:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 180d774:	e0ffff03 	ldbu	r3,-4(fp)
 180d778:	e0bffb17 	ldw	r2,-20(fp)
 180d77c:	d8800015 	stw	r2,0(sp)
 180d780:	180f883a 	mov	r7,r3
 180d784:	e1bffc17 	ldw	r6,-16(fp)
 180d788:	e17ffe17 	ldw	r5,-8(fp)
 180d78c:	e13ffd17 	ldw	r4,-12(fp)
 180d790:	180d7ac0 	call	180d7ac <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 180d794:	e0bffb17 	ldw	r2,-20(fp)
	}
 180d798:	e037883a 	mov	sp,fp
 180d79c:	dfc00117 	ldw	ra,4(sp)
 180d7a0:	df000017 	ldw	fp,0(sp)
 180d7a4:	dec00204 	addi	sp,sp,8
 180d7a8:	f800283a 	ret

0180d7ac <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 180d7ac:	defffa04 	addi	sp,sp,-24
 180d7b0:	dfc00515 	stw	ra,20(sp)
 180d7b4:	df000415 	stw	fp,16(sp)
 180d7b8:	df000404 	addi	fp,sp,16
 180d7bc:	e13ffc15 	stw	r4,-16(fp)
 180d7c0:	e17ffd15 	stw	r5,-12(fp)
 180d7c4:	e1bffe15 	stw	r6,-8(fp)
 180d7c8:	3805883a 	mov	r2,r7
 180d7cc:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 180d7d0:	e0bffd17 	ldw	r2,-12(fp)
 180d7d4:	1000041e 	bne	r2,zero,180d7e8 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 180d7d8:	e0800217 	ldw	r2,8(fp)
 180d7dc:	e0c00217 	ldw	r3,8(fp)
 180d7e0:	10c00015 	stw	r3,0(r2)
 180d7e4:	00000306 	br	180d7f4 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 180d7e8:	e0800217 	ldw	r2,8(fp)
 180d7ec:	e0fffe17 	ldw	r3,-8(fp)
 180d7f0:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 180d7f4:	e0800217 	ldw	r2,8(fp)
 180d7f8:	e0fffc17 	ldw	r3,-16(fp)
 180d7fc:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 180d800:	e0800217 	ldw	r2,8(fp)
 180d804:	e0fffd17 	ldw	r3,-12(fp)
 180d808:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 180d80c:	01400044 	movi	r5,1
 180d810:	e1000217 	ldw	r4,8(fp)
 180d814:	180d5f00 	call	180d5f0 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 180d818:	e0800217 	ldw	r2,8(fp)
 180d81c:	e0ffff03 	ldbu	r3,-4(fp)
 180d820:	10c01305 	stb	r3,76(r2)
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 180d824:	0001883a 	nop
 180d828:	e037883a 	mov	sp,fp
 180d82c:	dfc00117 	ldw	ra,4(sp)
 180d830:	df000017 	ldw	fp,0(sp)
 180d834:	dec00204 	addi	sp,sp,8
 180d838:	f800283a 	ret

0180d83c <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 180d83c:	defffd04 	addi	sp,sp,-12
 180d840:	dfc00215 	stw	ra,8(sp)
 180d844:	df000115 	stw	fp,4(sp)
 180d848:	df000104 	addi	fp,sp,4
 180d84c:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 180d850:	e0bfff17 	ldw	r2,-4(fp)
 180d854:	10000b26 	beq	r2,zero,180d884 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 180d858:	e0bfff17 	ldw	r2,-4(fp)
 180d85c:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 180d860:	e0bfff17 	ldw	r2,-4(fp)
 180d864:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 180d868:	e0bfff17 	ldw	r2,-4(fp)
 180d86c:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 180d870:	000f883a 	mov	r7,zero
 180d874:	000d883a 	mov	r6,zero
 180d878:	000b883a 	mov	r5,zero
 180d87c:	e13fff17 	ldw	r4,-4(fp)
 180d880:	180da7c0 	call	180da7c <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 180d884:	0001883a 	nop
 180d888:	e037883a 	mov	sp,fp
 180d88c:	dfc00117 	ldw	ra,4(sp)
 180d890:	df000017 	ldw	fp,0(sp)
 180d894:	dec00204 	addi	sp,sp,8
 180d898:	f800283a 	ret

0180d89c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 180d89c:	defffa04 	addi	sp,sp,-24
 180d8a0:	dfc00515 	stw	ra,20(sp)
 180d8a4:	df000415 	stw	fp,16(sp)
 180d8a8:	df000404 	addi	fp,sp,16
 180d8ac:	2005883a 	mov	r2,r4
 180d8b0:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 180d8b4:	00800044 	movi	r2,1
 180d8b8:	e0bffc15 	stw	r2,-16(fp)
 180d8bc:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 180d8c0:	e0bfff03 	ldbu	r2,-4(fp)
 180d8c4:	100d883a 	mov	r6,r2
 180d8c8:	e17ffd17 	ldw	r5,-12(fp)
 180d8cc:	e13ffc17 	ldw	r4,-16(fp)
 180d8d0:	180d7140 	call	180d714 <xQueueGenericCreate>
 180d8d4:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 180d8d8:	e13ffe17 	ldw	r4,-8(fp)
 180d8dc:	180d83c0 	call	180d83c <prvInitialiseMutex>

		return xNewQueue;
 180d8e0:	e0bffe17 	ldw	r2,-8(fp)
	}
 180d8e4:	e037883a 	mov	sp,fp
 180d8e8:	dfc00117 	ldw	ra,4(sp)
 180d8ec:	df000017 	ldw	fp,0(sp)
 180d8f0:	dec00204 	addi	sp,sp,8
 180d8f4:	f800283a 	ret

0180d8f8 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 180d8f8:	defffa04 	addi	sp,sp,-24
 180d8fc:	dfc00515 	stw	ra,20(sp)
 180d900:	df000415 	stw	fp,16(sp)
 180d904:	dc000315 	stw	r16,12(sp)
 180d908:	df000404 	addi	fp,sp,16
 180d90c:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 180d910:	e0bffe17 	ldw	r2,-8(fp)
 180d914:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 180d918:	e0bffd17 	ldw	r2,-12(fp)
 180d91c:	14000217 	ldw	r16,8(r2)
 180d920:	1810c4c0 	call	1810c4c <xTaskGetCurrentTaskHandle>
 180d924:	8080101e 	bne	r16,r2,180d968 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 180d928:	e0bffd17 	ldw	r2,-12(fp)
 180d92c:	10800317 	ldw	r2,12(r2)
 180d930:	10ffffc4 	addi	r3,r2,-1
 180d934:	e0bffd17 	ldw	r2,-12(fp)
 180d938:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 180d93c:	e0bffd17 	ldw	r2,-12(fp)
 180d940:	10800317 	ldw	r2,12(r2)
 180d944:	1000051e 	bne	r2,zero,180d95c <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 180d948:	000f883a 	mov	r7,zero
 180d94c:	000d883a 	mov	r6,zero
 180d950:	000b883a 	mov	r5,zero
 180d954:	e13ffd17 	ldw	r4,-12(fp)
 180d958:	180da7c0 	call	180da7c <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 180d95c:	00800044 	movi	r2,1
 180d960:	e0bffc15 	stw	r2,-16(fp)
 180d964:	00000106 	br	180d96c <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 180d968:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 180d96c:	e0bffc17 	ldw	r2,-16(fp)
	}
 180d970:	e6ffff04 	addi	sp,fp,-4
 180d974:	dfc00217 	ldw	ra,8(sp)
 180d978:	df000117 	ldw	fp,4(sp)
 180d97c:	dc000017 	ldw	r16,0(sp)
 180d980:	dec00304 	addi	sp,sp,12
 180d984:	f800283a 	ret

0180d988 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 180d988:	defff904 	addi	sp,sp,-28
 180d98c:	dfc00615 	stw	ra,24(sp)
 180d990:	df000515 	stw	fp,20(sp)
 180d994:	dc000415 	stw	r16,16(sp)
 180d998:	df000504 	addi	fp,sp,20
 180d99c:	e13ffd15 	stw	r4,-12(fp)
 180d9a0:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 180d9a4:	e0bffd17 	ldw	r2,-12(fp)
 180d9a8:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 180d9ac:	e0bffc17 	ldw	r2,-16(fp)
 180d9b0:	14000217 	ldw	r16,8(r2)
 180d9b4:	1810c4c0 	call	1810c4c <xTaskGetCurrentTaskHandle>
 180d9b8:	8080081e 	bne	r16,r2,180d9dc <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 180d9bc:	e0bffc17 	ldw	r2,-16(fp)
 180d9c0:	10800317 	ldw	r2,12(r2)
 180d9c4:	10c00044 	addi	r3,r2,1
 180d9c8:	e0bffc17 	ldw	r2,-16(fp)
 180d9cc:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 180d9d0:	00800044 	movi	r2,1
 180d9d4:	e0bffb15 	stw	r2,-20(fp)
 180d9d8:	00000b06 	br	180da08 <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 180d9dc:	e17ffe17 	ldw	r5,-8(fp)
 180d9e0:	e13ffc17 	ldw	r4,-16(fp)
 180d9e4:	180e0080 	call	180e008 <xQueueSemaphoreTake>
 180d9e8:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 180d9ec:	e0bffb17 	ldw	r2,-20(fp)
 180d9f0:	10000526 	beq	r2,zero,180da08 <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 180d9f4:	e0bffc17 	ldw	r2,-16(fp)
 180d9f8:	10800317 	ldw	r2,12(r2)
 180d9fc:	10c00044 	addi	r3,r2,1
 180da00:	e0bffc17 	ldw	r2,-16(fp)
 180da04:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 180da08:	e0bffb17 	ldw	r2,-20(fp)
	}
 180da0c:	e6ffff04 	addi	sp,fp,-4
 180da10:	dfc00217 	ldw	ra,8(sp)
 180da14:	df000117 	ldw	fp,4(sp)
 180da18:	dc000017 	ldw	r16,0(sp)
 180da1c:	dec00304 	addi	sp,sp,12
 180da20:	f800283a 	ret

0180da24 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 180da24:	defffb04 	addi	sp,sp,-20
 180da28:	dfc00415 	stw	ra,16(sp)
 180da2c:	df000315 	stw	fp,12(sp)
 180da30:	df000304 	addi	fp,sp,12
 180da34:	e13ffe15 	stw	r4,-8(fp)
 180da38:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 180da3c:	01800084 	movi	r6,2
 180da40:	000b883a 	mov	r5,zero
 180da44:	e13ffe17 	ldw	r4,-8(fp)
 180da48:	180d7140 	call	180d714 <xQueueGenericCreate>
 180da4c:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 180da50:	e0bffd17 	ldw	r2,-12(fp)
 180da54:	10000326 	beq	r2,zero,180da64 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 180da58:	e0bffd17 	ldw	r2,-12(fp)
 180da5c:	e0ffff17 	ldw	r3,-4(fp)
 180da60:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 180da64:	e0bffd17 	ldw	r2,-12(fp)
	}
 180da68:	e037883a 	mov	sp,fp
 180da6c:	dfc00117 	ldw	ra,4(sp)
 180da70:	df000017 	ldw	fp,0(sp)
 180da74:	dec00204 	addi	sp,sp,8
 180da78:	f800283a 	ret

0180da7c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 180da7c:	defff504 	addi	sp,sp,-44
 180da80:	dfc00a15 	stw	ra,40(sp)
 180da84:	df000915 	stw	fp,36(sp)
 180da88:	df000904 	addi	fp,sp,36
 180da8c:	e13ffc15 	stw	r4,-16(fp)
 180da90:	e17ffd15 	stw	r5,-12(fp)
 180da94:	e1bffe15 	stw	r6,-8(fp)
 180da98:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 180da9c:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 180daa0:	e0bffc17 	ldw	r2,-16(fp)
 180daa4:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 180daa8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180daac:	10000126 	beq	r2,zero,180dab4 <xQueueGenericSend+0x38>
 180dab0:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 180dab4:	e0bff817 	ldw	r2,-32(fp)
 180dab8:	10c00e17 	ldw	r3,56(r2)
 180dabc:	e0bff817 	ldw	r2,-32(fp)
 180dac0:	10800f17 	ldw	r2,60(r2)
 180dac4:	18800336 	bltu	r3,r2,180dad4 <xQueueGenericSend+0x58>
 180dac8:	e0bfff17 	ldw	r2,-4(fp)
 180dacc:	10800098 	cmpnei	r2,r2,2
 180dad0:	1000171e 	bne	r2,zero,180db30 <xQueueGenericSend+0xb4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 180dad4:	e1bfff17 	ldw	r6,-4(fp)
 180dad8:	e17ffd17 	ldw	r5,-12(fp)
 180dadc:	e13ff817 	ldw	r4,-32(fp)
 180dae0:	180e7a40 	call	180e7a4 <prvCopyDataToQueue>
 180dae4:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 180dae8:	e0bff817 	ldw	r2,-32(fp)
 180daec:	10800917 	ldw	r2,36(r2)
 180daf0:	10000726 	beq	r2,zero,180db10 <xQueueGenericSend+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 180daf4:	e0bff817 	ldw	r2,-32(fp)
 180daf8:	10800904 	addi	r2,r2,36
 180dafc:	1009883a 	mov	r4,r2
 180db00:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180db04:	10000526 	beq	r2,zero,180db1c <xQueueGenericSend+0xa0>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 180db08:	003b683a 	trap	0
 180db0c:	00000306 	br	180db1c <xQueueGenericSend+0xa0>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 180db10:	e0bff917 	ldw	r2,-28(fp)
 180db14:	10000126 	beq	r2,zero,180db1c <xQueueGenericSend+0xa0>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 180db18:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 180db1c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180db20:	10000126 	beq	r2,zero,180db28 <xQueueGenericSend+0xac>
 180db24:	18110840 	call	1811084 <vTaskExitCritical>
				return pdPASS;
 180db28:	00800044 	movi	r2,1
 180db2c:	00004706 	br	180dc4c <xQueueGenericSend+0x1d0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 180db30:	e0bffe17 	ldw	r2,-8(fp)
 180db34:	1000051e 	bne	r2,zero,180db4c <xQueueGenericSend+0xd0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 180db38:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180db3c:	10000126 	beq	r2,zero,180db44 <xQueueGenericSend+0xc8>
 180db40:	18110840 	call	1811084 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 180db44:	0005883a 	mov	r2,zero
 180db48:	00004006 	br	180dc4c <xQueueGenericSend+0x1d0>
				}
				else if( xEntryTimeSet == pdFALSE )
 180db4c:	e0bff717 	ldw	r2,-36(fp)
 180db50:	1000051e 	bne	r2,zero,180db68 <xQueueGenericSend+0xec>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 180db54:	e0bffa04 	addi	r2,fp,-24
 180db58:	1009883a 	mov	r4,r2
 180db5c:	18105300 	call	1810530 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 180db60:	00800044 	movi	r2,1
 180db64:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 180db68:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180db6c:	10000126 	beq	r2,zero,180db74 <xQueueGenericSend+0xf8>
 180db70:	18110840 	call	1811084 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 180db74:	180fab80 	call	180fab8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 180db78:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180db7c:	10000126 	beq	r2,zero,180db84 <xQueueGenericSend+0x108>
 180db80:	181103c0 	call	181103c <vTaskEnterCritical>
 180db84:	e0bff817 	ldw	r2,-32(fp)
 180db88:	10801103 	ldbu	r2,68(r2)
 180db8c:	10803fcc 	andi	r2,r2,255
 180db90:	1080201c 	xori	r2,r2,128
 180db94:	10bfe004 	addi	r2,r2,-128
 180db98:	10bfffd8 	cmpnei	r2,r2,-1
 180db9c:	1000021e 	bne	r2,zero,180dba8 <xQueueGenericSend+0x12c>
 180dba0:	e0bff817 	ldw	r2,-32(fp)
 180dba4:	10001105 	stb	zero,68(r2)
 180dba8:	e0bff817 	ldw	r2,-32(fp)
 180dbac:	10801143 	ldbu	r2,69(r2)
 180dbb0:	10803fcc 	andi	r2,r2,255
 180dbb4:	1080201c 	xori	r2,r2,128
 180dbb8:	10bfe004 	addi	r2,r2,-128
 180dbbc:	10bfffd8 	cmpnei	r2,r2,-1
 180dbc0:	1000021e 	bne	r2,zero,180dbcc <xQueueGenericSend+0x150>
 180dbc4:	e0bff817 	ldw	r2,-32(fp)
 180dbc8:	10001145 	stb	zero,69(r2)
 180dbcc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180dbd0:	10000126 	beq	r2,zero,180dbd8 <xQueueGenericSend+0x15c>
 180dbd4:	18110840 	call	1811084 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 180dbd8:	e0fffe04 	addi	r3,fp,-8
 180dbdc:	e0bffa04 	addi	r2,fp,-24
 180dbe0:	180b883a 	mov	r5,r3
 180dbe4:	1009883a 	mov	r4,r2
 180dbe8:	181056c0 	call	181056c <xTaskCheckForTimeOut>
 180dbec:	1000131e 	bne	r2,zero,180dc3c <xQueueGenericSend+0x1c0>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 180dbf0:	e13ff817 	ldw	r4,-32(fp)
 180dbf4:	180eb880 	call	180eb88 <prvIsQueueFull>
 180dbf8:	10000c26 	beq	r2,zero,180dc2c <xQueueGenericSend+0x1b0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 180dbfc:	e0bff817 	ldw	r2,-32(fp)
 180dc00:	10800404 	addi	r2,r2,16
 180dc04:	e0fffe17 	ldw	r3,-8(fp)
 180dc08:	180b883a 	mov	r5,r3
 180dc0c:	1009883a 	mov	r4,r2
 180dc10:	18102000 	call	1810200 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 180dc14:	e13ff817 	ldw	r4,-32(fp)
 180dc18:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 180dc1c:	180fae40 	call	180fae4 <xTaskResumeAll>
 180dc20:	103fa11e 	bne	r2,zero,180daa8 <__ram_exceptions_end+0xff7fd664>
				{
					portYIELD_WITHIN_API();
 180dc24:	003b683a 	trap	0
 180dc28:	003f9f06 	br	180daa8 <__ram_exceptions_end+0xff7fd664>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 180dc2c:	e13ff817 	ldw	r4,-32(fp)
 180dc30:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
 180dc34:	180fae40 	call	180fae4 <xTaskResumeAll>
 180dc38:	003f9b06 	br	180daa8 <__ram_exceptions_end+0xff7fd664>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 180dc3c:	e13ff817 	ldw	r4,-32(fp)
 180dc40:	180e9cc0 	call	180e9cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
 180dc44:	180fae40 	call	180fae4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 180dc48:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
 180dc4c:	e037883a 	mov	sp,fp
 180dc50:	dfc00117 	ldw	ra,4(sp)
 180dc54:	df000017 	ldw	fp,0(sp)
 180dc58:	dec00204 	addi	sp,sp,8
 180dc5c:	f800283a 	ret

0180dc60 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 180dc60:	defff504 	addi	sp,sp,-44
 180dc64:	dfc00a15 	stw	ra,40(sp)
 180dc68:	df000915 	stw	fp,36(sp)
 180dc6c:	df000904 	addi	fp,sp,36
 180dc70:	e13ffc15 	stw	r4,-16(fp)
 180dc74:	e17ffd15 	stw	r5,-12(fp)
 180dc78:	e1bffe15 	stw	r6,-8(fp)
 180dc7c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 180dc80:	e0bffc17 	ldw	r2,-16(fp)
 180dc84:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 180dc88:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 180dc8c:	e0bff817 	ldw	r2,-32(fp)
 180dc90:	10c00e17 	ldw	r3,56(r2)
 180dc94:	e0bff817 	ldw	r2,-32(fp)
 180dc98:	10800f17 	ldw	r2,60(r2)
 180dc9c:	18800336 	bltu	r3,r2,180dcac <xQueueGenericSendFromISR+0x4c>
 180dca0:	e0bfff17 	ldw	r2,-4(fp)
 180dca4:	10800098 	cmpnei	r2,r2,2
 180dca8:	1000231e 	bne	r2,zero,180dd38 <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 180dcac:	e0bff817 	ldw	r2,-32(fp)
 180dcb0:	10801143 	ldbu	r2,69(r2)
 180dcb4:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 180dcb8:	e0bff817 	ldw	r2,-32(fp)
 180dcbc:	10800e17 	ldw	r2,56(r2)
 180dcc0:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 180dcc4:	e1bfff17 	ldw	r6,-4(fp)
 180dcc8:	e17ffd17 	ldw	r5,-12(fp)
 180dccc:	e13ff817 	ldw	r4,-32(fp)
 180dcd0:	180e7a40 	call	180e7a4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 180dcd4:	e0bffa07 	ldb	r2,-24(fp)
 180dcd8:	10bfffd8 	cmpnei	r2,r2,-1
 180dcdc:	10000e1e 	bne	r2,zero,180dd18 <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 180dce0:	e0bff817 	ldw	r2,-32(fp)
 180dce4:	10800917 	ldw	r2,36(r2)
 180dce8:	10001026 	beq	r2,zero,180dd2c <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 180dcec:	e0bff817 	ldw	r2,-32(fp)
 180dcf0:	10800904 	addi	r2,r2,36
 180dcf4:	1009883a 	mov	r4,r2
 180dcf8:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180dcfc:	10000b26 	beq	r2,zero,180dd2c <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 180dd00:	e0bffe17 	ldw	r2,-8(fp)
 180dd04:	10000926 	beq	r2,zero,180dd2c <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 180dd08:	e0bffe17 	ldw	r2,-8(fp)
 180dd0c:	00c00044 	movi	r3,1
 180dd10:	10c00015 	stw	r3,0(r2)
 180dd14:	00000506 	br	180dd2c <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 180dd18:	e0bffa03 	ldbu	r2,-24(fp)
 180dd1c:	10800044 	addi	r2,r2,1
 180dd20:	1007883a 	mov	r3,r2
 180dd24:	e0bff817 	ldw	r2,-32(fp)
 180dd28:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 180dd2c:	00800044 	movi	r2,1
 180dd30:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 180dd34:	00000106 	br	180dd3c <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 180dd38:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 180dd3c:	e0bff717 	ldw	r2,-36(fp)
}
 180dd40:	e037883a 	mov	sp,fp
 180dd44:	dfc00117 	ldw	ra,4(sp)
 180dd48:	df000017 	ldw	fp,0(sp)
 180dd4c:	dec00204 	addi	sp,sp,8
 180dd50:	f800283a 	ret

0180dd54 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 180dd54:	defff704 	addi	sp,sp,-36
 180dd58:	dfc00815 	stw	ra,32(sp)
 180dd5c:	df000715 	stw	fp,28(sp)
 180dd60:	df000704 	addi	fp,sp,28
 180dd64:	e13ffe15 	stw	r4,-8(fp)
 180dd68:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 180dd6c:	e0bffe17 	ldw	r2,-8(fp)
 180dd70:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 180dd74:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 180dd78:	e0bffa17 	ldw	r2,-24(fp)
 180dd7c:	10800e17 	ldw	r2,56(r2)
 180dd80:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 180dd84:	e0bffa17 	ldw	r2,-24(fp)
 180dd88:	10800f17 	ldw	r2,60(r2)
 180dd8c:	e0fffc17 	ldw	r3,-16(fp)
 180dd90:	1880202e 	bgeu	r3,r2,180de14 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 180dd94:	e0bffa17 	ldw	r2,-24(fp)
 180dd98:	10801143 	ldbu	r2,69(r2)
 180dd9c:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 180dda0:	e0bffc17 	ldw	r2,-16(fp)
 180dda4:	10c00044 	addi	r3,r2,1
 180dda8:	e0bffa17 	ldw	r2,-24(fp)
 180ddac:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 180ddb0:	e0bffd07 	ldb	r2,-12(fp)
 180ddb4:	10bfffd8 	cmpnei	r2,r2,-1
 180ddb8:	10000e1e 	bne	r2,zero,180ddf4 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 180ddbc:	e0bffa17 	ldw	r2,-24(fp)
 180ddc0:	10800917 	ldw	r2,36(r2)
 180ddc4:	10001026 	beq	r2,zero,180de08 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 180ddc8:	e0bffa17 	ldw	r2,-24(fp)
 180ddcc:	10800904 	addi	r2,r2,36
 180ddd0:	1009883a 	mov	r4,r2
 180ddd4:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180ddd8:	10000b26 	beq	r2,zero,180de08 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 180dddc:	e0bfff17 	ldw	r2,-4(fp)
 180dde0:	10000926 	beq	r2,zero,180de08 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 180dde4:	e0bfff17 	ldw	r2,-4(fp)
 180dde8:	00c00044 	movi	r3,1
 180ddec:	10c00015 	stw	r3,0(r2)
 180ddf0:	00000506 	br	180de08 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 180ddf4:	e0bffd03 	ldbu	r2,-12(fp)
 180ddf8:	10800044 	addi	r2,r2,1
 180ddfc:	1007883a 	mov	r3,r2
 180de00:	e0bffa17 	ldw	r2,-24(fp)
 180de04:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 180de08:	00800044 	movi	r2,1
 180de0c:	e0bff915 	stw	r2,-28(fp)
 180de10:	00000106 	br	180de18 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 180de14:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 180de18:	e0bff917 	ldw	r2,-28(fp)
}
 180de1c:	e037883a 	mov	sp,fp
 180de20:	dfc00117 	ldw	ra,4(sp)
 180de24:	df000017 	ldw	fp,0(sp)
 180de28:	dec00204 	addi	sp,sp,8
 180de2c:	f800283a 	ret

0180de30 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 180de30:	defff604 	addi	sp,sp,-40
 180de34:	dfc00915 	stw	ra,36(sp)
 180de38:	df000815 	stw	fp,32(sp)
 180de3c:	df000804 	addi	fp,sp,32
 180de40:	e13ffd15 	stw	r4,-12(fp)
 180de44:	e17ffe15 	stw	r5,-8(fp)
 180de48:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 180de4c:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 180de50:	e0bffd17 	ldw	r2,-12(fp)
 180de54:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 180de58:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180de5c:	10000126 	beq	r2,zero,180de64 <xQueueReceive+0x34>
 180de60:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 180de64:	e0bff917 	ldw	r2,-28(fp)
 180de68:	10800e17 	ldw	r2,56(r2)
 180de6c:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 180de70:	e0bffa17 	ldw	r2,-24(fp)
 180de74:	10001526 	beq	r2,zero,180decc <xQueueReceive+0x9c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 180de78:	e17ffe17 	ldw	r5,-8(fp)
 180de7c:	e13ff917 	ldw	r4,-28(fp)
 180de80:	180e9300 	call	180e930 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 180de84:	e0bffa17 	ldw	r2,-24(fp)
 180de88:	10ffffc4 	addi	r3,r2,-1
 180de8c:	e0bff917 	ldw	r2,-28(fp)
 180de90:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 180de94:	e0bff917 	ldw	r2,-28(fp)
 180de98:	10800417 	ldw	r2,16(r2)
 180de9c:	10000626 	beq	r2,zero,180deb8 <xQueueReceive+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 180dea0:	e0bff917 	ldw	r2,-28(fp)
 180dea4:	10800404 	addi	r2,r2,16
 180dea8:	1009883a 	mov	r4,r2
 180deac:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180deb0:	10000126 	beq	r2,zero,180deb8 <xQueueReceive+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
 180deb4:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 180deb8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180debc:	10000126 	beq	r2,zero,180dec4 <xQueueReceive+0x94>
 180dec0:	18110840 	call	1811084 <vTaskExitCritical>
				return pdPASS;
 180dec4:	00800044 	movi	r2,1
 180dec8:	00004a06 	br	180dff4 <xQueueReceive+0x1c4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 180decc:	e0bfff17 	ldw	r2,-4(fp)
 180ded0:	1000051e 	bne	r2,zero,180dee8 <xQueueReceive+0xb8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 180ded4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ded8:	10000126 	beq	r2,zero,180dee0 <xQueueReceive+0xb0>
 180dedc:	18110840 	call	1811084 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 180dee0:	0005883a 	mov	r2,zero
 180dee4:	00004306 	br	180dff4 <xQueueReceive+0x1c4>
				}
				else if( xEntryTimeSet == pdFALSE )
 180dee8:	e0bff817 	ldw	r2,-32(fp)
 180deec:	1000051e 	bne	r2,zero,180df04 <xQueueReceive+0xd4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 180def0:	e0bffb04 	addi	r2,fp,-20
 180def4:	1009883a 	mov	r4,r2
 180def8:	18105300 	call	1810530 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 180defc:	00800044 	movi	r2,1
 180df00:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 180df04:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180df08:	10000126 	beq	r2,zero,180df10 <xQueueReceive+0xe0>
 180df0c:	18110840 	call	1811084 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 180df10:	180fab80 	call	180fab8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 180df14:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180df18:	10000126 	beq	r2,zero,180df20 <xQueueReceive+0xf0>
 180df1c:	181103c0 	call	181103c <vTaskEnterCritical>
 180df20:	e0bff917 	ldw	r2,-28(fp)
 180df24:	10801103 	ldbu	r2,68(r2)
 180df28:	10803fcc 	andi	r2,r2,255
 180df2c:	1080201c 	xori	r2,r2,128
 180df30:	10bfe004 	addi	r2,r2,-128
 180df34:	10bfffd8 	cmpnei	r2,r2,-1
 180df38:	1000021e 	bne	r2,zero,180df44 <xQueueReceive+0x114>
 180df3c:	e0bff917 	ldw	r2,-28(fp)
 180df40:	10001105 	stb	zero,68(r2)
 180df44:	e0bff917 	ldw	r2,-28(fp)
 180df48:	10801143 	ldbu	r2,69(r2)
 180df4c:	10803fcc 	andi	r2,r2,255
 180df50:	1080201c 	xori	r2,r2,128
 180df54:	10bfe004 	addi	r2,r2,-128
 180df58:	10bfffd8 	cmpnei	r2,r2,-1
 180df5c:	1000021e 	bne	r2,zero,180df68 <xQueueReceive+0x138>
 180df60:	e0bff917 	ldw	r2,-28(fp)
 180df64:	10001145 	stb	zero,69(r2)
 180df68:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180df6c:	10000126 	beq	r2,zero,180df74 <xQueueReceive+0x144>
 180df70:	18110840 	call	1811084 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 180df74:	e0ffff04 	addi	r3,fp,-4
 180df78:	e0bffb04 	addi	r2,fp,-20
 180df7c:	180b883a 	mov	r5,r3
 180df80:	1009883a 	mov	r4,r2
 180df84:	181056c0 	call	181056c <xTaskCheckForTimeOut>
 180df88:	1000131e 	bne	r2,zero,180dfd8 <xQueueReceive+0x1a8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180df8c:	e13ff917 	ldw	r4,-28(fp)
 180df90:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180df94:	10000c26 	beq	r2,zero,180dfc8 <xQueueReceive+0x198>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 180df98:	e0bff917 	ldw	r2,-28(fp)
 180df9c:	10800904 	addi	r2,r2,36
 180dfa0:	e0ffff17 	ldw	r3,-4(fp)
 180dfa4:	180b883a 	mov	r5,r3
 180dfa8:	1009883a 	mov	r4,r2
 180dfac:	18102000 	call	1810200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 180dfb0:	e13ff917 	ldw	r4,-28(fp)
 180dfb4:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 180dfb8:	180fae40 	call	180fae4 <xTaskResumeAll>
 180dfbc:	103fa61e 	bne	r2,zero,180de58 <__ram_exceptions_end+0xff7fda14>
				{
					portYIELD_WITHIN_API();
 180dfc0:	003b683a 	trap	0
 180dfc4:	003fa406 	br	180de58 <__ram_exceptions_end+0xff7fda14>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 180dfc8:	e13ff917 	ldw	r4,-28(fp)
 180dfcc:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
 180dfd0:	180fae40 	call	180fae4 <xTaskResumeAll>
 180dfd4:	003fa006 	br	180de58 <__ram_exceptions_end+0xff7fda14>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 180dfd8:	e13ff917 	ldw	r4,-28(fp)
 180dfdc:	180e9cc0 	call	180e9cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
 180dfe0:	180fae40 	call	180fae4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180dfe4:	e13ff917 	ldw	r4,-28(fp)
 180dfe8:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180dfec:	103f9a26 	beq	r2,zero,180de58 <__ram_exceptions_end+0xff7fda14>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 180dff0:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 180dff4:	e037883a 	mov	sp,fp
 180dff8:	dfc00117 	ldw	ra,4(sp)
 180dffc:	df000017 	ldw	fp,0(sp)
 180e000:	dec00204 	addi	sp,sp,8
 180e004:	f800283a 	ret

0180e008 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 180e008:	defff504 	addi	sp,sp,-44
 180e00c:	dfc00a15 	stw	ra,40(sp)
 180e010:	df000915 	stw	fp,36(sp)
 180e014:	df000904 	addi	fp,sp,36
 180e018:	e13ffe15 	stw	r4,-8(fp)
 180e01c:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 180e020:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 180e024:	e0bffe17 	ldw	r2,-8(fp)
 180e028:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 180e02c:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 180e030:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e034:	10000126 	beq	r2,zero,180e03c <xQueueSemaphoreTake+0x34>
 180e038:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 180e03c:	e0bff917 	ldw	r2,-28(fp)
 180e040:	10800e17 	ldw	r2,56(r2)
 180e044:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 180e048:	e0bffa17 	ldw	r2,-24(fp)
 180e04c:	10001926 	beq	r2,zero,180e0b4 <xQueueSemaphoreTake+0xac>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 180e050:	e0bffa17 	ldw	r2,-24(fp)
 180e054:	10ffffc4 	addi	r3,r2,-1
 180e058:	e0bff917 	ldw	r2,-28(fp)
 180e05c:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 180e060:	e0bff917 	ldw	r2,-28(fp)
 180e064:	10800017 	ldw	r2,0(r2)
 180e068:	1000041e 	bne	r2,zero,180e07c <xQueueSemaphoreTake+0x74>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 180e06c:	18111240 	call	1811124 <pvTaskIncrementMutexHeldCount>
 180e070:	1007883a 	mov	r3,r2
 180e074:	e0bff917 	ldw	r2,-28(fp)
 180e078:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 180e07c:	e0bff917 	ldw	r2,-28(fp)
 180e080:	10800417 	ldw	r2,16(r2)
 180e084:	10000626 	beq	r2,zero,180e0a0 <xQueueSemaphoreTake+0x98>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 180e088:	e0bff917 	ldw	r2,-28(fp)
 180e08c:	10800404 	addi	r2,r2,16
 180e090:	1009883a 	mov	r4,r2
 180e094:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180e098:	10000126 	beq	r2,zero,180e0a0 <xQueueSemaphoreTake+0x98>
					{
						queueYIELD_IF_USING_PREEMPTION();
 180e09c:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 180e0a0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e0a4:	10000126 	beq	r2,zero,180e0ac <xQueueSemaphoreTake+0xa4>
 180e0a8:	18110840 	call	1811084 <vTaskExitCritical>
				return pdPASS;
 180e0ac:	00800044 	movi	r2,1
 180e0b0:	00006806 	br	180e254 <xQueueSemaphoreTake+0x24c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 180e0b4:	e0bfff17 	ldw	r2,-4(fp)
 180e0b8:	1000051e 	bne	r2,zero,180e0d0 <xQueueSemaphoreTake+0xc8>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 180e0bc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e0c0:	10000126 	beq	r2,zero,180e0c8 <xQueueSemaphoreTake+0xc0>
 180e0c4:	18110840 	call	1811084 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 180e0c8:	0005883a 	mov	r2,zero
 180e0cc:	00006106 	br	180e254 <xQueueSemaphoreTake+0x24c>
				}
				else if( xEntryTimeSet == pdFALSE )
 180e0d0:	e0bff717 	ldw	r2,-36(fp)
 180e0d4:	1000051e 	bne	r2,zero,180e0ec <xQueueSemaphoreTake+0xe4>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 180e0d8:	e0bffc04 	addi	r2,fp,-16
 180e0dc:	1009883a 	mov	r4,r2
 180e0e0:	18105300 	call	1810530 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 180e0e4:	00800044 	movi	r2,1
 180e0e8:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 180e0ec:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e0f0:	10000126 	beq	r2,zero,180e0f8 <xQueueSemaphoreTake+0xf0>
 180e0f4:	18110840 	call	1811084 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 180e0f8:	180fab80 	call	180fab8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 180e0fc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e100:	10000126 	beq	r2,zero,180e108 <xQueueSemaphoreTake+0x100>
 180e104:	181103c0 	call	181103c <vTaskEnterCritical>
 180e108:	e0bff917 	ldw	r2,-28(fp)
 180e10c:	10801103 	ldbu	r2,68(r2)
 180e110:	10803fcc 	andi	r2,r2,255
 180e114:	1080201c 	xori	r2,r2,128
 180e118:	10bfe004 	addi	r2,r2,-128
 180e11c:	10bfffd8 	cmpnei	r2,r2,-1
 180e120:	1000021e 	bne	r2,zero,180e12c <xQueueSemaphoreTake+0x124>
 180e124:	e0bff917 	ldw	r2,-28(fp)
 180e128:	10001105 	stb	zero,68(r2)
 180e12c:	e0bff917 	ldw	r2,-28(fp)
 180e130:	10801143 	ldbu	r2,69(r2)
 180e134:	10803fcc 	andi	r2,r2,255
 180e138:	1080201c 	xori	r2,r2,128
 180e13c:	10bfe004 	addi	r2,r2,-128
 180e140:	10bfffd8 	cmpnei	r2,r2,-1
 180e144:	1000021e 	bne	r2,zero,180e150 <xQueueSemaphoreTake+0x148>
 180e148:	e0bff917 	ldw	r2,-28(fp)
 180e14c:	10001145 	stb	zero,69(r2)
 180e150:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e154:	10000126 	beq	r2,zero,180e15c <xQueueSemaphoreTake+0x154>
 180e158:	18110840 	call	1811084 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 180e15c:	e0ffff04 	addi	r3,fp,-4
 180e160:	e0bffc04 	addi	r2,fp,-16
 180e164:	180b883a 	mov	r5,r3
 180e168:	1009883a 	mov	r4,r2
 180e16c:	181056c0 	call	181056c <xTaskCheckForTimeOut>
 180e170:	1000211e 	bne	r2,zero,180e1f8 <xQueueSemaphoreTake+0x1f0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180e174:	e13ff917 	ldw	r4,-28(fp)
 180e178:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180e17c:	10001a26 	beq	r2,zero,180e1e8 <xQueueSemaphoreTake+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 180e180:	e0bff917 	ldw	r2,-28(fp)
 180e184:	10800017 	ldw	r2,0(r2)
 180e188:	10000b1e 	bne	r2,zero,180e1b8 <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
 180e18c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e190:	10000126 	beq	r2,zero,180e198 <xQueueSemaphoreTake+0x190>
 180e194:	181103c0 	call	181103c <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 180e198:	e0bff917 	ldw	r2,-28(fp)
 180e19c:	10800217 	ldw	r2,8(r2)
 180e1a0:	1009883a 	mov	r4,r2
 180e1a4:	1810cc00 	call	1810cc0 <xTaskPriorityInherit>
 180e1a8:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
 180e1ac:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e1b0:	10000126 	beq	r2,zero,180e1b8 <xQueueSemaphoreTake+0x1b0>
 180e1b4:	18110840 	call	1811084 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 180e1b8:	e0bff917 	ldw	r2,-28(fp)
 180e1bc:	10800904 	addi	r2,r2,36
 180e1c0:	e0ffff17 	ldw	r3,-4(fp)
 180e1c4:	180b883a 	mov	r5,r3
 180e1c8:	1009883a 	mov	r4,r2
 180e1cc:	18102000 	call	1810200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 180e1d0:	e13ff917 	ldw	r4,-28(fp)
 180e1d4:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 180e1d8:	180fae40 	call	180fae4 <xTaskResumeAll>
 180e1dc:	103f941e 	bne	r2,zero,180e030 <__ram_exceptions_end+0xff7fdbec>
				{
					portYIELD_WITHIN_API();
 180e1e0:	003b683a 	trap	0
 180e1e4:	003f9206 	br	180e030 <__ram_exceptions_end+0xff7fdbec>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 180e1e8:	e13ff917 	ldw	r4,-28(fp)
 180e1ec:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
 180e1f0:	180fae40 	call	180fae4 <xTaskResumeAll>
 180e1f4:	003f8e06 	br	180e030 <__ram_exceptions_end+0xff7fdbec>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 180e1f8:	e13ff917 	ldw	r4,-28(fp)
 180e1fc:	180e9cc0 	call	180e9cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
 180e200:	180fae40 	call	180fae4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180e204:	e13ff917 	ldw	r4,-28(fp)
 180e208:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180e20c:	103f8826 	beq	r2,zero,180e030 <__ram_exceptions_end+0xff7fdbec>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 180e210:	e0bff817 	ldw	r2,-32(fp)
 180e214:	10000e26 	beq	r2,zero,180e250 <xQueueSemaphoreTake+0x248>
					{
						taskENTER_CRITICAL();
 180e218:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e21c:	10000126 	beq	r2,zero,180e224 <xQueueSemaphoreTake+0x21c>
 180e220:	181103c0 	call	181103c <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 180e224:	e13ff917 	ldw	r4,-28(fp)
 180e228:	180e7540 	call	180e754 <prvGetDisinheritPriorityAfterTimeout>
 180e22c:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 180e230:	e0bff917 	ldw	r2,-28(fp)
 180e234:	10800217 	ldw	r2,8(r2)
 180e238:	e17ffb17 	ldw	r5,-20(fp)
 180e23c:	1009883a 	mov	r4,r2
 180e240:	1810efc0 	call	1810efc <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 180e244:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e248:	10000126 	beq	r2,zero,180e250 <xQueueSemaphoreTake+0x248>
 180e24c:	18110840 	call	1811084 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 180e250:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 180e254:	e037883a 	mov	sp,fp
 180e258:	dfc00117 	ldw	ra,4(sp)
 180e25c:	df000017 	ldw	fp,0(sp)
 180e260:	dec00204 	addi	sp,sp,8
 180e264:	f800283a 	ret

0180e268 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 180e268:	defff504 	addi	sp,sp,-44
 180e26c:	dfc00a15 	stw	ra,40(sp)
 180e270:	df000915 	stw	fp,36(sp)
 180e274:	df000904 	addi	fp,sp,36
 180e278:	e13ffd15 	stw	r4,-12(fp)
 180e27c:	e17ffe15 	stw	r5,-8(fp)
 180e280:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 180e284:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 180e288:	e0bffd17 	ldw	r2,-12(fp)
 180e28c:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 180e290:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e294:	10000126 	beq	r2,zero,180e29c <xQueuePeek+0x34>
 180e298:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 180e29c:	e0bff817 	ldw	r2,-32(fp)
 180e2a0:	10800e17 	ldw	r2,56(r2)
 180e2a4:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 180e2a8:	e0bff917 	ldw	r2,-28(fp)
 180e2ac:	10001726 	beq	r2,zero,180e30c <xQueuePeek+0xa4>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 180e2b0:	e0bff817 	ldw	r2,-32(fp)
 180e2b4:	10800317 	ldw	r2,12(r2)
 180e2b8:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 180e2bc:	e17ffe17 	ldw	r5,-8(fp)
 180e2c0:	e13ff817 	ldw	r4,-32(fp)
 180e2c4:	180e9300 	call	180e930 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 180e2c8:	e0bff817 	ldw	r2,-32(fp)
 180e2cc:	e0fffa17 	ldw	r3,-24(fp)
 180e2d0:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 180e2d4:	e0bff817 	ldw	r2,-32(fp)
 180e2d8:	10800917 	ldw	r2,36(r2)
 180e2dc:	10000626 	beq	r2,zero,180e2f8 <xQueuePeek+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 180e2e0:	e0bff817 	ldw	r2,-32(fp)
 180e2e4:	10800904 	addi	r2,r2,36
 180e2e8:	1009883a 	mov	r4,r2
 180e2ec:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180e2f0:	10000126 	beq	r2,zero,180e2f8 <xQueuePeek+0x90>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
 180e2f4:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 180e2f8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e2fc:	10000126 	beq	r2,zero,180e304 <xQueuePeek+0x9c>
 180e300:	18110840 	call	1811084 <vTaskExitCritical>
				return pdPASS;
 180e304:	00800044 	movi	r2,1
 180e308:	00004a06 	br	180e434 <xQueuePeek+0x1cc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 180e30c:	e0bfff17 	ldw	r2,-4(fp)
 180e310:	1000051e 	bne	r2,zero,180e328 <xQueuePeek+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 180e314:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e318:	10000126 	beq	r2,zero,180e320 <xQueuePeek+0xb8>
 180e31c:	18110840 	call	1811084 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 180e320:	0005883a 	mov	r2,zero
 180e324:	00004306 	br	180e434 <xQueuePeek+0x1cc>
				}
				else if( xEntryTimeSet == pdFALSE )
 180e328:	e0bff717 	ldw	r2,-36(fp)
 180e32c:	1000051e 	bne	r2,zero,180e344 <xQueuePeek+0xdc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 180e330:	e0bffb04 	addi	r2,fp,-20
 180e334:	1009883a 	mov	r4,r2
 180e338:	18105300 	call	1810530 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 180e33c:	00800044 	movi	r2,1
 180e340:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 180e344:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e348:	10000126 	beq	r2,zero,180e350 <xQueuePeek+0xe8>
 180e34c:	18110840 	call	1811084 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 180e350:	180fab80 	call	180fab8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 180e354:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e358:	10000126 	beq	r2,zero,180e360 <xQueuePeek+0xf8>
 180e35c:	181103c0 	call	181103c <vTaskEnterCritical>
 180e360:	e0bff817 	ldw	r2,-32(fp)
 180e364:	10801103 	ldbu	r2,68(r2)
 180e368:	10803fcc 	andi	r2,r2,255
 180e36c:	1080201c 	xori	r2,r2,128
 180e370:	10bfe004 	addi	r2,r2,-128
 180e374:	10bfffd8 	cmpnei	r2,r2,-1
 180e378:	1000021e 	bne	r2,zero,180e384 <xQueuePeek+0x11c>
 180e37c:	e0bff817 	ldw	r2,-32(fp)
 180e380:	10001105 	stb	zero,68(r2)
 180e384:	e0bff817 	ldw	r2,-32(fp)
 180e388:	10801143 	ldbu	r2,69(r2)
 180e38c:	10803fcc 	andi	r2,r2,255
 180e390:	1080201c 	xori	r2,r2,128
 180e394:	10bfe004 	addi	r2,r2,-128
 180e398:	10bfffd8 	cmpnei	r2,r2,-1
 180e39c:	1000021e 	bne	r2,zero,180e3a8 <xQueuePeek+0x140>
 180e3a0:	e0bff817 	ldw	r2,-32(fp)
 180e3a4:	10001145 	stb	zero,69(r2)
 180e3a8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e3ac:	10000126 	beq	r2,zero,180e3b4 <xQueuePeek+0x14c>
 180e3b0:	18110840 	call	1811084 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 180e3b4:	e0ffff04 	addi	r3,fp,-4
 180e3b8:	e0bffb04 	addi	r2,fp,-20
 180e3bc:	180b883a 	mov	r5,r3
 180e3c0:	1009883a 	mov	r4,r2
 180e3c4:	181056c0 	call	181056c <xTaskCheckForTimeOut>
 180e3c8:	1000131e 	bne	r2,zero,180e418 <xQueuePeek+0x1b0>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180e3cc:	e13ff817 	ldw	r4,-32(fp)
 180e3d0:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180e3d4:	10000c26 	beq	r2,zero,180e408 <xQueuePeek+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 180e3d8:	e0bff817 	ldw	r2,-32(fp)
 180e3dc:	10800904 	addi	r2,r2,36
 180e3e0:	e0ffff17 	ldw	r3,-4(fp)
 180e3e4:	180b883a 	mov	r5,r3
 180e3e8:	1009883a 	mov	r4,r2
 180e3ec:	18102000 	call	1810200 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 180e3f0:	e13ff817 	ldw	r4,-32(fp)
 180e3f4:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 180e3f8:	180fae40 	call	180fae4 <xTaskResumeAll>
 180e3fc:	103fa41e 	bne	r2,zero,180e290 <__ram_exceptions_end+0xff7fde4c>
				{
					portYIELD_WITHIN_API();
 180e400:	003b683a 	trap	0
 180e404:	003fa206 	br	180e290 <__ram_exceptions_end+0xff7fde4c>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
 180e408:	e13ff817 	ldw	r4,-32(fp)
 180e40c:	180e9cc0 	call	180e9cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
 180e410:	180fae40 	call	180fae4 <xTaskResumeAll>
 180e414:	003f9e06 	br	180e290 <__ram_exceptions_end+0xff7fde4c>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
 180e418:	e13ff817 	ldw	r4,-32(fp)
 180e41c:	180e9cc0 	call	180e9cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
 180e420:	180fae40 	call	180fae4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 180e424:	e13ff817 	ldw	r4,-32(fp)
 180e428:	180eae00 	call	180eae0 <prvIsQueueEmpty>
 180e42c:	103f9826 	beq	r2,zero,180e290 <__ram_exceptions_end+0xff7fde4c>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 180e430:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 180e434:	e037883a 	mov	sp,fp
 180e438:	dfc00117 	ldw	ra,4(sp)
 180e43c:	df000017 	ldw	fp,0(sp)
 180e440:	dec00204 	addi	sp,sp,8
 180e444:	f800283a 	ret

0180e448 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 180e448:	defff604 	addi	sp,sp,-40
 180e44c:	dfc00915 	stw	ra,36(sp)
 180e450:	df000815 	stw	fp,32(sp)
 180e454:	df000804 	addi	fp,sp,32
 180e458:	e13ffd15 	stw	r4,-12(fp)
 180e45c:	e17ffe15 	stw	r5,-8(fp)
 180e460:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 180e464:	e0bffd17 	ldw	r2,-12(fp)
 180e468:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 180e46c:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 180e470:	e0bff917 	ldw	r2,-28(fp)
 180e474:	10800e17 	ldw	r2,56(r2)
 180e478:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 180e47c:	e0bffb17 	ldw	r2,-20(fp)
 180e480:	10002326 	beq	r2,zero,180e510 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 180e484:	e0bff917 	ldw	r2,-28(fp)
 180e488:	10801103 	ldbu	r2,68(r2)
 180e48c:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 180e490:	e17ffe17 	ldw	r5,-8(fp)
 180e494:	e13ff917 	ldw	r4,-28(fp)
 180e498:	180e9300 	call	180e930 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 180e49c:	e0bffb17 	ldw	r2,-20(fp)
 180e4a0:	10ffffc4 	addi	r3,r2,-1
 180e4a4:	e0bff917 	ldw	r2,-28(fp)
 180e4a8:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 180e4ac:	e0bffc07 	ldb	r2,-16(fp)
 180e4b0:	10bfffd8 	cmpnei	r2,r2,-1
 180e4b4:	10000e1e 	bne	r2,zero,180e4f0 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 180e4b8:	e0bff917 	ldw	r2,-28(fp)
 180e4bc:	10800417 	ldw	r2,16(r2)
 180e4c0:	10001026 	beq	r2,zero,180e504 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 180e4c4:	e0bff917 	ldw	r2,-28(fp)
 180e4c8:	10800404 	addi	r2,r2,16
 180e4cc:	1009883a 	mov	r4,r2
 180e4d0:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180e4d4:	10000b26 	beq	r2,zero,180e504 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 180e4d8:	e0bfff17 	ldw	r2,-4(fp)
 180e4dc:	10000926 	beq	r2,zero,180e504 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 180e4e0:	e0bfff17 	ldw	r2,-4(fp)
 180e4e4:	00c00044 	movi	r3,1
 180e4e8:	10c00015 	stw	r3,0(r2)
 180e4ec:	00000506 	br	180e504 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 180e4f0:	e0bffc03 	ldbu	r2,-16(fp)
 180e4f4:	10800044 	addi	r2,r2,1
 180e4f8:	1007883a 	mov	r3,r2
 180e4fc:	e0bff917 	ldw	r2,-28(fp)
 180e500:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 180e504:	00800044 	movi	r2,1
 180e508:	e0bff815 	stw	r2,-32(fp)
 180e50c:	00000106 	br	180e514 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 180e510:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 180e514:	e0bff817 	ldw	r2,-32(fp)
}
 180e518:	e037883a 	mov	sp,fp
 180e51c:	dfc00117 	ldw	ra,4(sp)
 180e520:	df000017 	ldw	fp,0(sp)
 180e524:	dec00204 	addi	sp,sp,8
 180e528:	f800283a 	ret

0180e52c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 180e52c:	defff804 	addi	sp,sp,-32
 180e530:	dfc00715 	stw	ra,28(sp)
 180e534:	df000615 	stw	fp,24(sp)
 180e538:	df000604 	addi	fp,sp,24
 180e53c:	e13ffe15 	stw	r4,-8(fp)
 180e540:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 180e544:	e0bffe17 	ldw	r2,-8(fp)
 180e548:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 180e54c:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 180e550:	e0bffb17 	ldw	r2,-20(fp)
 180e554:	10800e17 	ldw	r2,56(r2)
 180e558:	10000c26 	beq	r2,zero,180e58c <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 180e55c:	e0bffb17 	ldw	r2,-20(fp)
 180e560:	10800317 	ldw	r2,12(r2)
 180e564:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 180e568:	e17fff17 	ldw	r5,-4(fp)
 180e56c:	e13ffb17 	ldw	r4,-20(fp)
 180e570:	180e9300 	call	180e930 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 180e574:	e0bffb17 	ldw	r2,-20(fp)
 180e578:	e0fffd17 	ldw	r3,-12(fp)
 180e57c:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 180e580:	00800044 	movi	r2,1
 180e584:	e0bffa15 	stw	r2,-24(fp)
 180e588:	00000106 	br	180e590 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 180e58c:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 180e590:	e0bffa17 	ldw	r2,-24(fp)
}
 180e594:	e037883a 	mov	sp,fp
 180e598:	dfc00117 	ldw	ra,4(sp)
 180e59c:	df000017 	ldw	fp,0(sp)
 180e5a0:	dec00204 	addi	sp,sp,8
 180e5a4:	f800283a 	ret

0180e5a8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 180e5a8:	defffc04 	addi	sp,sp,-16
 180e5ac:	dfc00315 	stw	ra,12(sp)
 180e5b0:	df000215 	stw	fp,8(sp)
 180e5b4:	df000204 	addi	fp,sp,8
 180e5b8:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 180e5bc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e5c0:	10000126 	beq	r2,zero,180e5c8 <uxQueueMessagesWaiting+0x20>
 180e5c4:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 180e5c8:	e0bfff17 	ldw	r2,-4(fp)
 180e5cc:	10800e17 	ldw	r2,56(r2)
 180e5d0:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 180e5d4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e5d8:	10000126 	beq	r2,zero,180e5e0 <uxQueueMessagesWaiting+0x38>
 180e5dc:	18110840 	call	1811084 <vTaskExitCritical>

	return uxReturn;
 180e5e0:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 180e5e4:	e037883a 	mov	sp,fp
 180e5e8:	dfc00117 	ldw	ra,4(sp)
 180e5ec:	df000017 	ldw	fp,0(sp)
 180e5f0:	dec00204 	addi	sp,sp,8
 180e5f4:	f800283a 	ret

0180e5f8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 180e5f8:	defffb04 	addi	sp,sp,-20
 180e5fc:	dfc00415 	stw	ra,16(sp)
 180e600:	df000315 	stw	fp,12(sp)
 180e604:	df000304 	addi	fp,sp,12
 180e608:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 180e60c:	e0bfff17 	ldw	r2,-4(fp)
 180e610:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 180e614:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e618:	10000126 	beq	r2,zero,180e620 <uxQueueSpacesAvailable+0x28>
 180e61c:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 180e620:	e0bffd17 	ldw	r2,-12(fp)
 180e624:	10c00f17 	ldw	r3,60(r2)
 180e628:	e0bffd17 	ldw	r2,-12(fp)
 180e62c:	10800e17 	ldw	r2,56(r2)
 180e630:	1885c83a 	sub	r2,r3,r2
 180e634:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 180e638:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e63c:	10000126 	beq	r2,zero,180e644 <uxQueueSpacesAvailable+0x4c>
 180e640:	18110840 	call	1811084 <vTaskExitCritical>

	return uxReturn;
 180e644:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 180e648:	e037883a 	mov	sp,fp
 180e64c:	dfc00117 	ldw	ra,4(sp)
 180e650:	df000017 	ldw	fp,0(sp)
 180e654:	dec00204 	addi	sp,sp,8
 180e658:	f800283a 	ret

0180e65c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 180e65c:	defffc04 	addi	sp,sp,-16
 180e660:	df000315 	stw	fp,12(sp)
 180e664:	df000304 	addi	fp,sp,12
 180e668:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 180e66c:	e0bfff17 	ldw	r2,-4(fp)
 180e670:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
 180e674:	e0bffd17 	ldw	r2,-12(fp)
 180e678:	10800e17 	ldw	r2,56(r2)
 180e67c:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 180e680:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 180e684:	e037883a 	mov	sp,fp
 180e688:	df000017 	ldw	fp,0(sp)
 180e68c:	dec00104 	addi	sp,sp,4
 180e690:	f800283a 	ret

0180e694 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 180e694:	defffc04 	addi	sp,sp,-16
 180e698:	dfc00315 	stw	ra,12(sp)
 180e69c:	df000215 	stw	fp,8(sp)
 180e6a0:	df000204 	addi	fp,sp,8
 180e6a4:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
 180e6a8:	e0bfff17 	ldw	r2,-4(fp)
 180e6ac:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 180e6b0:	e13ffe17 	ldw	r4,-8(fp)
 180e6b4:	18272c00 	call	18272c0 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 180e6b8:	0001883a 	nop
 180e6bc:	e037883a 	mov	sp,fp
 180e6c0:	dfc00117 	ldw	ra,4(sp)
 180e6c4:	df000017 	ldw	fp,0(sp)
 180e6c8:	dec00204 	addi	sp,sp,8
 180e6cc:	f800283a 	ret

0180e6d0 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
 180e6d0:	defffe04 	addi	sp,sp,-8
 180e6d4:	df000115 	stw	fp,4(sp)
 180e6d8:	df000104 	addi	fp,sp,4
 180e6dc:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 180e6e0:	e0bfff17 	ldw	r2,-4(fp)
 180e6e4:	10801217 	ldw	r2,72(r2)
	}
 180e6e8:	e037883a 	mov	sp,fp
 180e6ec:	df000017 	ldw	fp,0(sp)
 180e6f0:	dec00104 	addi	sp,sp,4
 180e6f4:	f800283a 	ret

0180e6f8 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
 180e6f8:	defffd04 	addi	sp,sp,-12
 180e6fc:	df000215 	stw	fp,8(sp)
 180e700:	df000204 	addi	fp,sp,8
 180e704:	e13ffe15 	stw	r4,-8(fp)
 180e708:	e17fff15 	stw	r5,-4(fp)
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 180e70c:	e0bffe17 	ldw	r2,-8(fp)
 180e710:	e0ffff17 	ldw	r3,-4(fp)
 180e714:	10c01215 	stw	r3,72(r2)
	}
 180e718:	0001883a 	nop
 180e71c:	e037883a 	mov	sp,fp
 180e720:	df000017 	ldw	fp,0(sp)
 180e724:	dec00104 	addi	sp,sp,4
 180e728:	f800283a 	ret

0180e72c <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
 180e72c:	defffe04 	addi	sp,sp,-8
 180e730:	df000115 	stw	fp,4(sp)
 180e734:	df000104 	addi	fp,sp,4
 180e738:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->ucQueueType;
 180e73c:	e0bfff17 	ldw	r2,-4(fp)
 180e740:	10801303 	ldbu	r2,76(r2)
	}
 180e744:	e037883a 	mov	sp,fp
 180e748:	df000017 	ldw	fp,0(sp)
 180e74c:	dec00104 	addi	sp,sp,4
 180e750:	f800283a 	ret

0180e754 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 180e754:	defffd04 	addi	sp,sp,-12
 180e758:	df000215 	stw	fp,8(sp)
 180e75c:	df000204 	addi	fp,sp,8
 180e760:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 180e764:	e0bfff17 	ldw	r2,-4(fp)
 180e768:	10800917 	ldw	r2,36(r2)
 180e76c:	10000726 	beq	r2,zero,180e78c <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 180e770:	e0bfff17 	ldw	r2,-4(fp)
 180e774:	10800c17 	ldw	r2,48(r2)
 180e778:	10800017 	ldw	r2,0(r2)
 180e77c:	00c00144 	movi	r3,5
 180e780:	1885c83a 	sub	r2,r3,r2
 180e784:	e0bffe15 	stw	r2,-8(fp)
 180e788:	00000106 	br	180e790 <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 180e78c:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
 180e790:	e0bffe17 	ldw	r2,-8(fp)
	}
 180e794:	e037883a 	mov	sp,fp
 180e798:	df000017 	ldw	fp,0(sp)
 180e79c:	dec00104 	addi	sp,sp,4
 180e7a0:	f800283a 	ret

0180e7a4 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 180e7a4:	defff904 	addi	sp,sp,-28
 180e7a8:	dfc00615 	stw	ra,24(sp)
 180e7ac:	df000515 	stw	fp,20(sp)
 180e7b0:	df000504 	addi	fp,sp,20
 180e7b4:	e13ffd15 	stw	r4,-12(fp)
 180e7b8:	e17ffe15 	stw	r5,-8(fp)
 180e7bc:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 180e7c0:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 180e7c4:	e0bffd17 	ldw	r2,-12(fp)
 180e7c8:	10800e17 	ldw	r2,56(r2)
 180e7cc:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 180e7d0:	e0bffd17 	ldw	r2,-12(fp)
 180e7d4:	10801017 	ldw	r2,64(r2)
 180e7d8:	10000b1e 	bne	r2,zero,180e808 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 180e7dc:	e0bffd17 	ldw	r2,-12(fp)
 180e7e0:	10800017 	ldw	r2,0(r2)
 180e7e4:	1000481e 	bne	r2,zero,180e908 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 180e7e8:	e0bffd17 	ldw	r2,-12(fp)
 180e7ec:	10800217 	ldw	r2,8(r2)
 180e7f0:	1009883a 	mov	r4,r2
 180e7f4:	1810e000 	call	1810e00 <xTaskPriorityDisinherit>
 180e7f8:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 180e7fc:	e0bffd17 	ldw	r2,-12(fp)
 180e800:	10000215 	stw	zero,8(r2)
 180e804:	00004006 	br	180e908 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 180e808:	e0bfff17 	ldw	r2,-4(fp)
 180e80c:	1000191e 	bne	r2,zero,180e874 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 180e810:	e0bffd17 	ldw	r2,-12(fp)
 180e814:	10c00117 	ldw	r3,4(r2)
 180e818:	e0bffd17 	ldw	r2,-12(fp)
 180e81c:	10801017 	ldw	r2,64(r2)
 180e820:	100d883a 	mov	r6,r2
 180e824:	e17ffe17 	ldw	r5,-8(fp)
 180e828:	1809883a 	mov	r4,r3
 180e82c:	180608c0 	call	180608c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 180e830:	e0bffd17 	ldw	r2,-12(fp)
 180e834:	10c00117 	ldw	r3,4(r2)
 180e838:	e0bffd17 	ldw	r2,-12(fp)
 180e83c:	10801017 	ldw	r2,64(r2)
 180e840:	1887883a 	add	r3,r3,r2
 180e844:	e0bffd17 	ldw	r2,-12(fp)
 180e848:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 180e84c:	e0bffd17 	ldw	r2,-12(fp)
 180e850:	10c00117 	ldw	r3,4(r2)
 180e854:	e0bffd17 	ldw	r2,-12(fp)
 180e858:	10800217 	ldw	r2,8(r2)
 180e85c:	18802a36 	bltu	r3,r2,180e908 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 180e860:	e0bffd17 	ldw	r2,-12(fp)
 180e864:	10c00017 	ldw	r3,0(r2)
 180e868:	e0bffd17 	ldw	r2,-12(fp)
 180e86c:	10c00115 	stw	r3,4(r2)
 180e870:	00002506 	br	180e908 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 180e874:	e0bffd17 	ldw	r2,-12(fp)
 180e878:	10c00317 	ldw	r3,12(r2)
 180e87c:	e0bffd17 	ldw	r2,-12(fp)
 180e880:	10801017 	ldw	r2,64(r2)
 180e884:	100d883a 	mov	r6,r2
 180e888:	e17ffe17 	ldw	r5,-8(fp)
 180e88c:	1809883a 	mov	r4,r3
 180e890:	180608c0 	call	180608c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 180e894:	e0bffd17 	ldw	r2,-12(fp)
 180e898:	10c00317 	ldw	r3,12(r2)
 180e89c:	e0bffd17 	ldw	r2,-12(fp)
 180e8a0:	10801017 	ldw	r2,64(r2)
 180e8a4:	0085c83a 	sub	r2,zero,r2
 180e8a8:	1887883a 	add	r3,r3,r2
 180e8ac:	e0bffd17 	ldw	r2,-12(fp)
 180e8b0:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 180e8b4:	e0bffd17 	ldw	r2,-12(fp)
 180e8b8:	10c00317 	ldw	r3,12(r2)
 180e8bc:	e0bffd17 	ldw	r2,-12(fp)
 180e8c0:	10800017 	ldw	r2,0(r2)
 180e8c4:	1880082e 	bgeu	r3,r2,180e8e8 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 180e8c8:	e0bffd17 	ldw	r2,-12(fp)
 180e8cc:	10c00217 	ldw	r3,8(r2)
 180e8d0:	e0bffd17 	ldw	r2,-12(fp)
 180e8d4:	10801017 	ldw	r2,64(r2)
 180e8d8:	0085c83a 	sub	r2,zero,r2
 180e8dc:	1887883a 	add	r3,r3,r2
 180e8e0:	e0bffd17 	ldw	r2,-12(fp)
 180e8e4:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 180e8e8:	e0bfff17 	ldw	r2,-4(fp)
 180e8ec:	10800098 	cmpnei	r2,r2,2
 180e8f0:	1000051e 	bne	r2,zero,180e908 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 180e8f4:	e0bffc17 	ldw	r2,-16(fp)
 180e8f8:	10000326 	beq	r2,zero,180e908 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 180e8fc:	e0bffc17 	ldw	r2,-16(fp)
 180e900:	10bfffc4 	addi	r2,r2,-1
 180e904:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 180e908:	e0bffc17 	ldw	r2,-16(fp)
 180e90c:	10c00044 	addi	r3,r2,1
 180e910:	e0bffd17 	ldw	r2,-12(fp)
 180e914:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 180e918:	e0bffb17 	ldw	r2,-20(fp)
}
 180e91c:	e037883a 	mov	sp,fp
 180e920:	dfc00117 	ldw	ra,4(sp)
 180e924:	df000017 	ldw	fp,0(sp)
 180e928:	dec00204 	addi	sp,sp,8
 180e92c:	f800283a 	ret

0180e930 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 180e930:	defffc04 	addi	sp,sp,-16
 180e934:	dfc00315 	stw	ra,12(sp)
 180e938:	df000215 	stw	fp,8(sp)
 180e93c:	df000204 	addi	fp,sp,8
 180e940:	e13ffe15 	stw	r4,-8(fp)
 180e944:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 180e948:	e0bffe17 	ldw	r2,-8(fp)
 180e94c:	10801017 	ldw	r2,64(r2)
 180e950:	10001826 	beq	r2,zero,180e9b4 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 180e954:	e0bffe17 	ldw	r2,-8(fp)
 180e958:	10c00317 	ldw	r3,12(r2)
 180e95c:	e0bffe17 	ldw	r2,-8(fp)
 180e960:	10801017 	ldw	r2,64(r2)
 180e964:	1887883a 	add	r3,r3,r2
 180e968:	e0bffe17 	ldw	r2,-8(fp)
 180e96c:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 180e970:	e0bffe17 	ldw	r2,-8(fp)
 180e974:	10c00317 	ldw	r3,12(r2)
 180e978:	e0bffe17 	ldw	r2,-8(fp)
 180e97c:	10800217 	ldw	r2,8(r2)
 180e980:	18800436 	bltu	r3,r2,180e994 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 180e984:	e0bffe17 	ldw	r2,-8(fp)
 180e988:	10c00017 	ldw	r3,0(r2)
 180e98c:	e0bffe17 	ldw	r2,-8(fp)
 180e990:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 180e994:	e0bffe17 	ldw	r2,-8(fp)
 180e998:	10c00317 	ldw	r3,12(r2)
 180e99c:	e0bffe17 	ldw	r2,-8(fp)
 180e9a0:	10801017 	ldw	r2,64(r2)
 180e9a4:	100d883a 	mov	r6,r2
 180e9a8:	180b883a 	mov	r5,r3
 180e9ac:	e13fff17 	ldw	r4,-4(fp)
 180e9b0:	180608c0 	call	180608c <memcpy>
	}
}
 180e9b4:	0001883a 	nop
 180e9b8:	e037883a 	mov	sp,fp
 180e9bc:	dfc00117 	ldw	ra,4(sp)
 180e9c0:	df000017 	ldw	fp,0(sp)
 180e9c4:	dec00204 	addi	sp,sp,8
 180e9c8:	f800283a 	ret

0180e9cc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 180e9cc:	defffc04 	addi	sp,sp,-16
 180e9d0:	dfc00315 	stw	ra,12(sp)
 180e9d4:	df000215 	stw	fp,8(sp)
 180e9d8:	df000204 	addi	fp,sp,8
 180e9dc:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 180e9e0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180e9e4:	10000126 	beq	r2,zero,180e9ec <prvUnlockQueue+0x20>
 180e9e8:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 180e9ec:	e0bfff17 	ldw	r2,-4(fp)
 180e9f0:	10801143 	ldbu	r2,69(r2)
 180e9f4:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 180e9f8:	00000c06 	br	180ea2c <prvUnlockQueue+0x60>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 180e9fc:	e0bfff17 	ldw	r2,-4(fp)
 180ea00:	10800917 	ldw	r2,36(r2)
 180ea04:	10000c26 	beq	r2,zero,180ea38 <prvUnlockQueue+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 180ea08:	e0bfff17 	ldw	r2,-4(fp)
 180ea0c:	10800904 	addi	r2,r2,36
 180ea10:	1009883a 	mov	r4,r2
 180ea14:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180ea18:	10000126 	beq	r2,zero,180ea20 <prvUnlockQueue+0x54>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 180ea1c:	181065c0 	call	181065c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 180ea20:	e0bffe03 	ldbu	r2,-8(fp)
 180ea24:	10bfffc4 	addi	r2,r2,-1
 180ea28:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 180ea2c:	e0bffe07 	ldb	r2,-8(fp)
 180ea30:	00bff216 	blt	zero,r2,180e9fc <__ram_exceptions_end+0xff7fe5b8>
 180ea34:	00000106 	br	180ea3c <prvUnlockQueue+0x70>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 180ea38:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 180ea3c:	e0bfff17 	ldw	r2,-4(fp)
 180ea40:	00ffffc4 	movi	r3,-1
 180ea44:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 180ea48:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ea4c:	10000126 	beq	r2,zero,180ea54 <prvUnlockQueue+0x88>
 180ea50:	18110840 	call	1811084 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 180ea54:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ea58:	10000126 	beq	r2,zero,180ea60 <prvUnlockQueue+0x94>
 180ea5c:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 180ea60:	e0bfff17 	ldw	r2,-4(fp)
 180ea64:	10801103 	ldbu	r2,68(r2)
 180ea68:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 180ea6c:	00000c06 	br	180eaa0 <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 180ea70:	e0bfff17 	ldw	r2,-4(fp)
 180ea74:	10800417 	ldw	r2,16(r2)
 180ea78:	10000c26 	beq	r2,zero,180eaac <prvUnlockQueue+0xe0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 180ea7c:	e0bfff17 	ldw	r2,-4(fp)
 180ea80:	10800404 	addi	r2,r2,16
 180ea84:	1009883a 	mov	r4,r2
 180ea88:	18103180 	call	1810318 <xTaskRemoveFromEventList>
 180ea8c:	10000126 	beq	r2,zero,180ea94 <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
 180ea90:	181065c0 	call	181065c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 180ea94:	e0bffe43 	ldbu	r2,-7(fp)
 180ea98:	10bfffc4 	addi	r2,r2,-1
 180ea9c:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 180eaa0:	e0bffe47 	ldb	r2,-7(fp)
 180eaa4:	00bff216 	blt	zero,r2,180ea70 <__ram_exceptions_end+0xff7fe62c>
 180eaa8:	00000106 	br	180eab0 <prvUnlockQueue+0xe4>

				--cRxLock;
			}
			else
			{
				break;
 180eaac:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 180eab0:	e0bfff17 	ldw	r2,-4(fp)
 180eab4:	00ffffc4 	movi	r3,-1
 180eab8:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 180eabc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180eac0:	10000126 	beq	r2,zero,180eac8 <prvUnlockQueue+0xfc>
 180eac4:	18110840 	call	1811084 <vTaskExitCritical>
}
 180eac8:	0001883a 	nop
 180eacc:	e037883a 	mov	sp,fp
 180ead0:	dfc00117 	ldw	ra,4(sp)
 180ead4:	df000017 	ldw	fp,0(sp)
 180ead8:	dec00204 	addi	sp,sp,8
 180eadc:	f800283a 	ret

0180eae0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 180eae0:	defffc04 	addi	sp,sp,-16
 180eae4:	dfc00315 	stw	ra,12(sp)
 180eae8:	df000215 	stw	fp,8(sp)
 180eaec:	df000204 	addi	fp,sp,8
 180eaf0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 180eaf4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180eaf8:	10000126 	beq	r2,zero,180eb00 <prvIsQueueEmpty+0x20>
 180eafc:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 180eb00:	e0bfff17 	ldw	r2,-4(fp)
 180eb04:	10800e17 	ldw	r2,56(r2)
 180eb08:	1000031e 	bne	r2,zero,180eb18 <prvIsQueueEmpty+0x38>
		{
			xReturn = pdTRUE;
 180eb0c:	00800044 	movi	r2,1
 180eb10:	e0bffe15 	stw	r2,-8(fp)
 180eb14:	00000106 	br	180eb1c <prvIsQueueEmpty+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 180eb18:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 180eb1c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180eb20:	10000126 	beq	r2,zero,180eb28 <prvIsQueueEmpty+0x48>
 180eb24:	18110840 	call	1811084 <vTaskExitCritical>

	return xReturn;
 180eb28:	e0bffe17 	ldw	r2,-8(fp)
}
 180eb2c:	e037883a 	mov	sp,fp
 180eb30:	dfc00117 	ldw	ra,4(sp)
 180eb34:	df000017 	ldw	fp,0(sp)
 180eb38:	dec00204 	addi	sp,sp,8
 180eb3c:	f800283a 	ret

0180eb40 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 180eb40:	defffc04 	addi	sp,sp,-16
 180eb44:	df000315 	stw	fp,12(sp)
 180eb48:	df000304 	addi	fp,sp,12
 180eb4c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 180eb50:	e0bfff17 	ldw	r2,-4(fp)
 180eb54:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 180eb58:	e0bffe17 	ldw	r2,-8(fp)
 180eb5c:	10800e17 	ldw	r2,56(r2)
 180eb60:	1000031e 	bne	r2,zero,180eb70 <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
 180eb64:	00800044 	movi	r2,1
 180eb68:	e0bffd15 	stw	r2,-12(fp)
 180eb6c:	00000106 	br	180eb74 <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 180eb70:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 180eb74:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 180eb78:	e037883a 	mov	sp,fp
 180eb7c:	df000017 	ldw	fp,0(sp)
 180eb80:	dec00104 	addi	sp,sp,4
 180eb84:	f800283a 	ret

0180eb88 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 180eb88:	defffc04 	addi	sp,sp,-16
 180eb8c:	dfc00315 	stw	ra,12(sp)
 180eb90:	df000215 	stw	fp,8(sp)
 180eb94:	df000204 	addi	fp,sp,8
 180eb98:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 180eb9c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180eba0:	10000126 	beq	r2,zero,180eba8 <prvIsQueueFull+0x20>
 180eba4:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 180eba8:	e0bfff17 	ldw	r2,-4(fp)
 180ebac:	10c00e17 	ldw	r3,56(r2)
 180ebb0:	e0bfff17 	ldw	r2,-4(fp)
 180ebb4:	10800f17 	ldw	r2,60(r2)
 180ebb8:	1880031e 	bne	r3,r2,180ebc8 <prvIsQueueFull+0x40>
		{
			xReturn = pdTRUE;
 180ebbc:	00800044 	movi	r2,1
 180ebc0:	e0bffe15 	stw	r2,-8(fp)
 180ebc4:	00000106 	br	180ebcc <prvIsQueueFull+0x44>
		}
		else
		{
			xReturn = pdFALSE;
 180ebc8:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 180ebcc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ebd0:	10000126 	beq	r2,zero,180ebd8 <prvIsQueueFull+0x50>
 180ebd4:	18110840 	call	1811084 <vTaskExitCritical>

	return xReturn;
 180ebd8:	e0bffe17 	ldw	r2,-8(fp)
}
 180ebdc:	e037883a 	mov	sp,fp
 180ebe0:	dfc00117 	ldw	ra,4(sp)
 180ebe4:	df000017 	ldw	fp,0(sp)
 180ebe8:	dec00204 	addi	sp,sp,8
 180ebec:	f800283a 	ret

0180ebf0 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 180ebf0:	defffc04 	addi	sp,sp,-16
 180ebf4:	df000315 	stw	fp,12(sp)
 180ebf8:	df000304 	addi	fp,sp,12
 180ebfc:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 180ec00:	e0bfff17 	ldw	r2,-4(fp)
 180ec04:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 180ec08:	e0bffe17 	ldw	r2,-8(fp)
 180ec0c:	10c00e17 	ldw	r3,56(r2)
 180ec10:	e0bffe17 	ldw	r2,-8(fp)
 180ec14:	10800f17 	ldw	r2,60(r2)
 180ec18:	1880031e 	bne	r3,r2,180ec28 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
 180ec1c:	00800044 	movi	r2,1
 180ec20:	e0bffd15 	stw	r2,-12(fp)
 180ec24:	00000106 	br	180ec2c <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
 180ec28:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 180ec2c:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 180ec30:	e037883a 	mov	sp,fp
 180ec34:	df000017 	ldw	fp,0(sp)
 180ec38:	dec00104 	addi	sp,sp,4
 180ec3c:	f800283a 	ret

0180ec40 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 180ec40:	defffa04 	addi	sp,sp,-24
 180ec44:	dfc00515 	stw	ra,20(sp)
 180ec48:	df000415 	stw	fp,16(sp)
 180ec4c:	df000404 	addi	fp,sp,16
 180ec50:	e13ffd15 	stw	r4,-12(fp)
 180ec54:	e17ffe15 	stw	r5,-8(fp)
 180ec58:	e1bfff15 	stw	r6,-4(fp)
	Queue_t * const pxQueue = xQueue;
 180ec5c:	e0bffd17 	ldw	r2,-12(fp)
 180ec60:	e0bffc15 	stw	r2,-16(fp)
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 180ec64:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ec68:	10000126 	beq	r2,zero,180ec70 <vQueueWaitForMessageRestricted+0x30>
 180ec6c:	181103c0 	call	181103c <vTaskEnterCritical>
 180ec70:	e0bffc17 	ldw	r2,-16(fp)
 180ec74:	10801103 	ldbu	r2,68(r2)
 180ec78:	10803fcc 	andi	r2,r2,255
 180ec7c:	1080201c 	xori	r2,r2,128
 180ec80:	10bfe004 	addi	r2,r2,-128
 180ec84:	10bfffd8 	cmpnei	r2,r2,-1
 180ec88:	1000021e 	bne	r2,zero,180ec94 <vQueueWaitForMessageRestricted+0x54>
 180ec8c:	e0bffc17 	ldw	r2,-16(fp)
 180ec90:	10001105 	stb	zero,68(r2)
 180ec94:	e0bffc17 	ldw	r2,-16(fp)
 180ec98:	10801143 	ldbu	r2,69(r2)
 180ec9c:	10803fcc 	andi	r2,r2,255
 180eca0:	1080201c 	xori	r2,r2,128
 180eca4:	10bfe004 	addi	r2,r2,-128
 180eca8:	10bfffd8 	cmpnei	r2,r2,-1
 180ecac:	1000021e 	bne	r2,zero,180ecb8 <vQueueWaitForMessageRestricted+0x78>
 180ecb0:	e0bffc17 	ldw	r2,-16(fp)
 180ecb4:	10001145 	stb	zero,69(r2)
 180ecb8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180ecbc:	10000126 	beq	r2,zero,180ecc4 <vQueueWaitForMessageRestricted+0x84>
 180ecc0:	18110840 	call	1811084 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 180ecc4:	e0bffc17 	ldw	r2,-16(fp)
 180ecc8:	10800e17 	ldw	r2,56(r2)
 180eccc:	1000061e 	bne	r2,zero,180ece8 <vQueueWaitForMessageRestricted+0xa8>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 180ecd0:	e0bffc17 	ldw	r2,-16(fp)
 180ecd4:	10800904 	addi	r2,r2,36
 180ecd8:	e1bfff17 	ldw	r6,-4(fp)
 180ecdc:	e17ffe17 	ldw	r5,-8(fp)
 180ece0:	1009883a 	mov	r4,r2
 180ece4:	18102b40 	call	18102b4 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 180ece8:	e13ffc17 	ldw	r4,-16(fp)
 180ecec:	180e9cc0 	call	180e9cc <prvUnlockQueue>
	}
 180ecf0:	0001883a 	nop
 180ecf4:	e037883a 	mov	sp,fp
 180ecf8:	dfc00117 	ldw	ra,4(sp)
 180ecfc:	df000017 	ldw	fp,0(sp)
 180ed00:	dec00204 	addi	sp,sp,8
 180ed04:	f800283a 	ret

0180ed08 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 180ed08:	defff304 	addi	sp,sp,-52
 180ed0c:	dfc00c15 	stw	ra,48(sp)
 180ed10:	df000b15 	stw	fp,44(sp)
 180ed14:	df000b04 	addi	fp,sp,44
 180ed18:	e13ffc15 	stw	r4,-16(fp)
 180ed1c:	e17ffd15 	stw	r5,-12(fp)
 180ed20:	e1bffe15 	stw	r6,-8(fp)
 180ed24:	e1ffff15 	stw	r7,-4(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 180ed28:	e0bffe17 	ldw	r2,-8(fp)
 180ed2c:	1085883a 	add	r2,r2,r2
 180ed30:	1085883a 	add	r2,r2,r2
 180ed34:	1009883a 	mov	r4,r2
 180ed38:	18272740 	call	1827274 <pvPortMalloc>
 180ed3c:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 180ed40:	e0bffb17 	ldw	r2,-20(fp)
 180ed44:	10000c26 	beq	r2,zero,180ed78 <xTaskCreate+0x70>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 180ed48:	01001e04 	movi	r4,120
 180ed4c:	18272740 	call	1827274 <pvPortMalloc>
 180ed50:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 180ed54:	e0bff917 	ldw	r2,-28(fp)
 180ed58:	10000426 	beq	r2,zero,180ed6c <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 180ed5c:	e0bff917 	ldw	r2,-28(fp)
 180ed60:	e0fffb17 	ldw	r3,-20(fp)
 180ed64:	10c00c15 	stw	r3,48(r2)
 180ed68:	00000406 	br	180ed7c <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 180ed6c:	e13ffb17 	ldw	r4,-20(fp)
 180ed70:	18272c00 	call	18272c0 <vPortFree>
 180ed74:	00000106 	br	180ed7c <xTaskCreate+0x74>
				}
			}
			else
			{
				pxNewTCB = NULL;
 180ed78:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 180ed7c:	e0bff917 	ldw	r2,-28(fp)
 180ed80:	10001126 	beq	r2,zero,180edc8 <xTaskCreate+0xc0>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 180ed84:	d8000315 	stw	zero,12(sp)
 180ed88:	e0bff917 	ldw	r2,-28(fp)
 180ed8c:	d8800215 	stw	r2,8(sp)
 180ed90:	e0800317 	ldw	r2,12(fp)
 180ed94:	d8800115 	stw	r2,4(sp)
 180ed98:	e0800217 	ldw	r2,8(fp)
 180ed9c:	d8800015 	stw	r2,0(sp)
 180eda0:	e1ffff17 	ldw	r7,-4(fp)
 180eda4:	e1bffe17 	ldw	r6,-8(fp)
 180eda8:	e17ffd17 	ldw	r5,-12(fp)
 180edac:	e13ffc17 	ldw	r4,-16(fp)
 180edb0:	180ede80 	call	180ede8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 180edb4:	e13ff917 	ldw	r4,-28(fp)
 180edb8:	180efcc0 	call	180efcc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 180edbc:	00800044 	movi	r2,1
 180edc0:	e0bffa15 	stw	r2,-24(fp)
 180edc4:	00000206 	br	180edd0 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 180edc8:	00bfffc4 	movi	r2,-1
 180edcc:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 180edd0:	e0bffa17 	ldw	r2,-24(fp)
	}
 180edd4:	e037883a 	mov	sp,fp
 180edd8:	dfc00117 	ldw	ra,4(sp)
 180eddc:	df000017 	ldw	fp,0(sp)
 180ede0:	dec00204 	addi	sp,sp,8
 180ede4:	f800283a 	ret

0180ede8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 180ede8:	defff804 	addi	sp,sp,-32
 180edec:	dfc00715 	stw	ra,28(sp)
 180edf0:	df000615 	stw	fp,24(sp)
 180edf4:	df000604 	addi	fp,sp,24
 180edf8:	e13ffc15 	stw	r4,-16(fp)
 180edfc:	e17ffd15 	stw	r5,-12(fp)
 180ee00:	e1bffe15 	stw	r6,-8(fp)
 180ee04:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 180ee08:	e0800417 	ldw	r2,16(fp)
 180ee0c:	10c00c17 	ldw	r3,48(r2)
 180ee10:	e0bffe17 	ldw	r2,-8(fp)
 180ee14:	1085883a 	add	r2,r2,r2
 180ee18:	1085883a 	add	r2,r2,r2
 180ee1c:	100d883a 	mov	r6,r2
 180ee20:	01402944 	movi	r5,165
 180ee24:	1809883a 	mov	r4,r3
 180ee28:	18061d40 	call	18061d4 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 180ee2c:	e0800417 	ldw	r2,16(fp)
 180ee30:	10c00c17 	ldw	r3,48(r2)
 180ee34:	e13ffe17 	ldw	r4,-8(fp)
 180ee38:	00900034 	movhi	r2,16384
 180ee3c:	10bfffc4 	addi	r2,r2,-1
 180ee40:	2085883a 	add	r2,r4,r2
 180ee44:	1085883a 	add	r2,r2,r2
 180ee48:	1085883a 	add	r2,r2,r2
 180ee4c:	1885883a 	add	r2,r3,r2
 180ee50:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 180ee54:	e0fffb17 	ldw	r3,-20(fp)
 180ee58:	00bfff04 	movi	r2,-4
 180ee5c:	1884703a 	and	r2,r3,r2
 180ee60:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 180ee64:	e0bffd17 	ldw	r2,-12(fp)
 180ee68:	10001e26 	beq	r2,zero,180eee4 <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 180ee6c:	e03ffa15 	stw	zero,-24(fp)
 180ee70:	00001406 	br	180eec4 <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 180ee74:	e0fffd17 	ldw	r3,-12(fp)
 180ee78:	e0bffa17 	ldw	r2,-24(fp)
 180ee7c:	1885883a 	add	r2,r3,r2
 180ee80:	10c00003 	ldbu	r3,0(r2)
 180ee84:	e1000417 	ldw	r4,16(fp)
 180ee88:	e0bffa17 	ldw	r2,-24(fp)
 180ee8c:	2085883a 	add	r2,r4,r2
 180ee90:	10800d04 	addi	r2,r2,52
 180ee94:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 180ee98:	e0fffd17 	ldw	r3,-12(fp)
 180ee9c:	e0bffa17 	ldw	r2,-24(fp)
 180eea0:	1885883a 	add	r2,r3,r2
 180eea4:	10800003 	ldbu	r2,0(r2)
 180eea8:	10803fcc 	andi	r2,r2,255
 180eeac:	1080201c 	xori	r2,r2,128
 180eeb0:	10bfe004 	addi	r2,r2,-128
 180eeb4:	10000726 	beq	r2,zero,180eed4 <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 180eeb8:	e0bffa17 	ldw	r2,-24(fp)
 180eebc:	10800044 	addi	r2,r2,1
 180eec0:	e0bffa15 	stw	r2,-24(fp)
 180eec4:	e0bffa17 	ldw	r2,-24(fp)
 180eec8:	10800a30 	cmpltui	r2,r2,40
 180eecc:	103fe91e 	bne	r2,zero,180ee74 <__ram_exceptions_end+0xff7fea30>
 180eed0:	00000106 	br	180eed8 <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
 180eed4:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 180eed8:	e0800417 	ldw	r2,16(fp)
 180eedc:	100016c5 	stb	zero,91(r2)
 180eee0:	00000206 	br	180eeec <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 180eee4:	e0800417 	ldw	r2,16(fp)
 180eee8:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 180eeec:	e0800217 	ldw	r2,8(fp)
 180eef0:	10800170 	cmpltui	r2,r2,5
 180eef4:	1000021e 	bne	r2,zero,180ef00 <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 180eef8:	00800104 	movi	r2,4
 180eefc:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 180ef00:	e0800417 	ldw	r2,16(fp)
 180ef04:	e0c00217 	ldw	r3,8(fp)
 180ef08:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 180ef0c:	e0800417 	ldw	r2,16(fp)
 180ef10:	e0c00217 	ldw	r3,8(fp)
 180ef14:	10c01a15 	stw	r3,104(r2)
		pxNewTCB->uxMutexesHeld = 0;
 180ef18:	e0800417 	ldw	r2,16(fp)
 180ef1c:	10001b15 	stw	zero,108(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 180ef20:	e0800417 	ldw	r2,16(fp)
 180ef24:	10800104 	addi	r2,r2,4
 180ef28:	1009883a 	mov	r4,r2
 180ef2c:	182736c0 	call	182736c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 180ef30:	e0800417 	ldw	r2,16(fp)
 180ef34:	10800604 	addi	r2,r2,24
 180ef38:	1009883a 	mov	r4,r2
 180ef3c:	182736c0 	call	182736c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 180ef40:	e0800417 	ldw	r2,16(fp)
 180ef44:	e0c00417 	ldw	r3,16(fp)
 180ef48:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 180ef4c:	00c00144 	movi	r3,5
 180ef50:	e0800217 	ldw	r2,8(fp)
 180ef54:	1887c83a 	sub	r3,r3,r2
 180ef58:	e0800417 	ldw	r2,16(fp)
 180ef5c:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 180ef60:	e0800417 	ldw	r2,16(fp)
 180ef64:	e0c00417 	ldw	r3,16(fp)
 180ef68:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 180ef6c:	e0800417 	ldw	r2,16(fp)
 180ef70:	10001715 	stw	zero,92(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 180ef74:	e0800417 	ldw	r2,16(fp)
 180ef78:	10001c15 	stw	zero,112(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 180ef7c:	e0800417 	ldw	r2,16(fp)
 180ef80:	10001d05 	stb	zero,116(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 180ef84:	e1bfff17 	ldw	r6,-4(fp)
 180ef88:	e17ffc17 	ldw	r5,-16(fp)
 180ef8c:	e13ffb17 	ldw	r4,-20(fp)
 180ef90:	182764c0 	call	182764c <pxPortInitialiseStack>
 180ef94:	1007883a 	mov	r3,r2
 180ef98:	e0800417 	ldw	r2,16(fp)
 180ef9c:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 180efa0:	e0800317 	ldw	r2,12(fp)
 180efa4:	10000326 	beq	r2,zero,180efb4 <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 180efa8:	e0800317 	ldw	r2,12(fp)
 180efac:	e0c00417 	ldw	r3,16(fp)
 180efb0:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 180efb4:	0001883a 	nop
 180efb8:	e037883a 	mov	sp,fp
 180efbc:	dfc00117 	ldw	ra,4(sp)
 180efc0:	df000017 	ldw	fp,0(sp)
 180efc4:	dec00204 	addi	sp,sp,8
 180efc8:	f800283a 	ret

0180efcc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 180efcc:	defffd04 	addi	sp,sp,-12
 180efd0:	dfc00215 	stw	ra,8(sp)
 180efd4:	df000115 	stw	fp,4(sp)
 180efd8:	df000104 	addi	fp,sp,4
 180efdc:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 180efe0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180efe4:	10000126 	beq	r2,zero,180efec <prvAddNewTaskToReadyList+0x20>
 180efe8:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 180efec:	d0a7d717 	ldw	r2,-24740(gp)
 180eff0:	10800044 	addi	r2,r2,1
 180eff4:	d0a7d715 	stw	r2,-24740(gp)
		if( pxCurrentTCB == NULL )
 180eff8:	d0a7d317 	ldw	r2,-24756(gp)
 180effc:	1000071e 	bne	r2,zero,180f01c <prvAddNewTaskToReadyList+0x50>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 180f000:	e0bfff17 	ldw	r2,-4(fp)
 180f004:	d0a7d315 	stw	r2,-24756(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 180f008:	d0a7d717 	ldw	r2,-24740(gp)
 180f00c:	10800058 	cmpnei	r2,r2,1
 180f010:	10000b1e 	bne	r2,zero,180f040 <prvAddNewTaskToReadyList+0x74>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 180f014:	181072c0 	call	181072c <prvInitialiseTaskLists>
 180f018:	00000906 	br	180f040 <prvAddNewTaskToReadyList+0x74>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 180f01c:	d0a7da17 	ldw	r2,-24728(gp)
 180f020:	1000071e 	bne	r2,zero,180f040 <prvAddNewTaskToReadyList+0x74>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 180f024:	d0a7d317 	ldw	r2,-24756(gp)
 180f028:	10800b17 	ldw	r2,44(r2)
 180f02c:	e0ffff17 	ldw	r3,-4(fp)
 180f030:	18c00b17 	ldw	r3,44(r3)
 180f034:	18800236 	bltu	r3,r2,180f040 <prvAddNewTaskToReadyList+0x74>
				{
					pxCurrentTCB = pxNewTCB;
 180f038:	e0bfff17 	ldw	r2,-4(fp)
 180f03c:	d0a7d315 	stw	r2,-24756(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 180f040:	d0a7de17 	ldw	r2,-24712(gp)
 180f044:	10800044 	addi	r2,r2,1
 180f048:	d0a7de15 	stw	r2,-24712(gp)

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 180f04c:	d0e7de17 	ldw	r3,-24712(gp)
 180f050:	e0bfff17 	ldw	r2,-4(fp)
 180f054:	10c01815 	stw	r3,96(r2)
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 180f058:	e0bfff17 	ldw	r2,-4(fp)
 180f05c:	10800b17 	ldw	r2,44(r2)
 180f060:	d0e7d917 	ldw	r3,-24732(gp)
 180f064:	1880032e 	bgeu	r3,r2,180f074 <prvAddNewTaskToReadyList+0xa8>
 180f068:	e0bfff17 	ldw	r2,-4(fp)
 180f06c:	10800b17 	ldw	r2,44(r2)
 180f070:	d0a7d915 	stw	r2,-24732(gp)
 180f074:	e0bfff17 	ldw	r2,-4(fp)
 180f078:	10800b17 	ldw	r2,44(r2)
 180f07c:	10c00524 	muli	r3,r2,20
 180f080:	00806134 	movhi	r2,388
 180f084:	109f7f04 	addi	r2,r2,32252
 180f088:	1887883a 	add	r3,r3,r2
 180f08c:	e0bfff17 	ldw	r2,-4(fp)
 180f090:	10800104 	addi	r2,r2,4
 180f094:	100b883a 	mov	r5,r2
 180f098:	1809883a 	mov	r4,r3
 180f09c:	18273980 	call	1827398 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 180f0a0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f0a4:	10000126 	beq	r2,zero,180f0ac <prvAddNewTaskToReadyList+0xe0>
 180f0a8:	18110840 	call	1811084 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 180f0ac:	d0a7da17 	ldw	r2,-24728(gp)
 180f0b0:	10000626 	beq	r2,zero,180f0cc <prvAddNewTaskToReadyList+0x100>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 180f0b4:	d0a7d317 	ldw	r2,-24756(gp)
 180f0b8:	10c00b17 	ldw	r3,44(r2)
 180f0bc:	e0bfff17 	ldw	r2,-4(fp)
 180f0c0:	10800b17 	ldw	r2,44(r2)
 180f0c4:	1880012e 	bgeu	r3,r2,180f0cc <prvAddNewTaskToReadyList+0x100>
		{
			taskYIELD_IF_USING_PREEMPTION();
 180f0c8:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 180f0cc:	0001883a 	nop
 180f0d0:	e037883a 	mov	sp,fp
 180f0d4:	dfc00117 	ldw	ra,4(sp)
 180f0d8:	df000017 	ldw	fp,0(sp)
 180f0dc:	dec00204 	addi	sp,sp,8
 180f0e0:	f800283a 	ret

0180f0e4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 180f0e4:	defffc04 	addi	sp,sp,-16
 180f0e8:	dfc00315 	stw	ra,12(sp)
 180f0ec:	df000215 	stw	fp,8(sp)
 180f0f0:	df000204 	addi	fp,sp,8
 180f0f4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 180f0f8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f0fc:	10000126 	beq	r2,zero,180f104 <vTaskDelete+0x20>
 180f100:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 180f104:	e0bfff17 	ldw	r2,-4(fp)
 180f108:	1000021e 	bne	r2,zero,180f114 <vTaskDelete+0x30>
 180f10c:	d0a7d317 	ldw	r2,-24756(gp)
 180f110:	00000106 	br	180f118 <vTaskDelete+0x34>
 180f114:	e0bfff17 	ldw	r2,-4(fp)
 180f118:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 180f11c:	e0bffe17 	ldw	r2,-8(fp)
 180f120:	10800104 	addi	r2,r2,4
 180f124:	1009883a 	mov	r4,r2
 180f128:	18274fc0 	call	18274fc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 180f12c:	e0bffe17 	ldw	r2,-8(fp)
 180f130:	10800a17 	ldw	r2,40(r2)
 180f134:	10000426 	beq	r2,zero,180f148 <vTaskDelete+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 180f138:	e0bffe17 	ldw	r2,-8(fp)
 180f13c:	10800604 	addi	r2,r2,24
 180f140:	1009883a 	mov	r4,r2
 180f144:	18274fc0 	call	18274fc <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 180f148:	d0a7de17 	ldw	r2,-24712(gp)
 180f14c:	10800044 	addi	r2,r2,1
 180f150:	d0a7de15 	stw	r2,-24712(gp)

			if( pxTCB == pxCurrentTCB )
 180f154:	d0a7d317 	ldw	r2,-24756(gp)
 180f158:	e0fffe17 	ldw	r3,-8(fp)
 180f15c:	18800a1e 	bne	r3,r2,180f188 <vTaskDelete+0xa4>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 180f160:	e0bffe17 	ldw	r2,-8(fp)
 180f164:	10800104 	addi	r2,r2,4
 180f168:	100b883a 	mov	r5,r2
 180f16c:	01006134 	movhi	r4,388
 180f170:	211fa704 	addi	r4,r4,32412
 180f174:	18273980 	call	1827398 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 180f178:	d0a7d617 	ldw	r2,-24744(gp)
 180f17c:	10800044 	addi	r2,r2,1
 180f180:	d0a7d615 	stw	r2,-24744(gp)
 180f184:	00000606 	br	180f1a0 <vTaskDelete+0xbc>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 180f188:	d0a7d717 	ldw	r2,-24740(gp)
 180f18c:	10bfffc4 	addi	r2,r2,-1
 180f190:	d0a7d715 	stw	r2,-24740(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
 180f194:	e13ffe17 	ldw	r4,-8(fp)
 180f198:	1810bb40 	call	1810bb4 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 180f19c:	1810bf80 	call	1810bf8 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
 180f1a0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f1a4:	10000126 	beq	r2,zero,180f1ac <vTaskDelete+0xc8>
 180f1a8:	18110840 	call	1811084 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 180f1ac:	d0a7da17 	ldw	r2,-24728(gp)
 180f1b0:	10000426 	beq	r2,zero,180f1c4 <vTaskDelete+0xe0>
		{
			if( pxTCB == pxCurrentTCB )
 180f1b4:	d0a7d317 	ldw	r2,-24756(gp)
 180f1b8:	e0fffe17 	ldw	r3,-8(fp)
 180f1bc:	1880011e 	bne	r3,r2,180f1c4 <vTaskDelete+0xe0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 180f1c0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 180f1c4:	0001883a 	nop
 180f1c8:	e037883a 	mov	sp,fp
 180f1cc:	dfc00117 	ldw	ra,4(sp)
 180f1d0:	df000017 	ldw	fp,0(sp)
 180f1d4:	dec00204 	addi	sp,sp,8
 180f1d8:	f800283a 	ret

0180f1dc <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 180f1dc:	defff804 	addi	sp,sp,-32
 180f1e0:	dfc00715 	stw	ra,28(sp)
 180f1e4:	df000615 	stw	fp,24(sp)
 180f1e8:	df000604 	addi	fp,sp,24
 180f1ec:	e13ffe15 	stw	r4,-8(fp)
 180f1f0:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 180f1f4:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 180f1f8:	180fab80 	call	180fab8 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 180f1fc:	d0a7d817 	ldw	r2,-24736(gp)
 180f200:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 180f204:	e0bffe17 	ldw	r2,-8(fp)
 180f208:	10c00017 	ldw	r3,0(r2)
 180f20c:	e0bfff17 	ldw	r2,-4(fp)
 180f210:	1885883a 	add	r2,r3,r2
 180f214:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 180f218:	e0bffe17 	ldw	r2,-8(fp)
 180f21c:	10800017 	ldw	r2,0(r2)
 180f220:	e0fffb17 	ldw	r3,-20(fp)
 180f224:	18800a2e 	bgeu	r3,r2,180f250 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 180f228:	e0bffe17 	ldw	r2,-8(fp)
 180f22c:	10800017 	ldw	r2,0(r2)
 180f230:	e0fffc17 	ldw	r3,-16(fp)
 180f234:	18800f2e 	bgeu	r3,r2,180f274 <vTaskDelayUntil+0x98>
 180f238:	e0bffc17 	ldw	r2,-16(fp)
 180f23c:	e0fffb17 	ldw	r3,-20(fp)
 180f240:	18800c2e 	bgeu	r3,r2,180f274 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 180f244:	00800044 	movi	r2,1
 180f248:	e0bffa15 	stw	r2,-24(fp)
 180f24c:	00000906 	br	180f274 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 180f250:	e0bffe17 	ldw	r2,-8(fp)
 180f254:	10800017 	ldw	r2,0(r2)
 180f258:	e0fffc17 	ldw	r3,-16(fp)
 180f25c:	18800336 	bltu	r3,r2,180f26c <vTaskDelayUntil+0x90>
 180f260:	e0bffc17 	ldw	r2,-16(fp)
 180f264:	e0fffb17 	ldw	r3,-20(fp)
 180f268:	1880022e 	bgeu	r3,r2,180f274 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 180f26c:	00800044 	movi	r2,1
 180f270:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 180f274:	e0bffe17 	ldw	r2,-8(fp)
 180f278:	e0fffc17 	ldw	r3,-16(fp)
 180f27c:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 180f280:	e0bffa17 	ldw	r2,-24(fp)
 180f284:	10000626 	beq	r2,zero,180f2a0 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 180f288:	e0fffc17 	ldw	r3,-16(fp)
 180f28c:	e0bffb17 	ldw	r2,-20(fp)
 180f290:	1885c83a 	sub	r2,r3,r2
 180f294:	000b883a 	mov	r5,zero
 180f298:	1009883a 	mov	r4,r2
 180f29c:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 180f2a0:	180fae40 	call	180fae4 <xTaskResumeAll>
 180f2a4:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 180f2a8:	e0bffd17 	ldw	r2,-12(fp)
 180f2ac:	1000011e 	bne	r2,zero,180f2b4 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 180f2b0:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f2b4:	0001883a 	nop
 180f2b8:	e037883a 	mov	sp,fp
 180f2bc:	dfc00117 	ldw	ra,4(sp)
 180f2c0:	df000017 	ldw	fp,0(sp)
 180f2c4:	dec00204 	addi	sp,sp,8
 180f2c8:	f800283a 	ret

0180f2cc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 180f2cc:	defffc04 	addi	sp,sp,-16
 180f2d0:	dfc00315 	stw	ra,12(sp)
 180f2d4:	df000215 	stw	fp,8(sp)
 180f2d8:	df000204 	addi	fp,sp,8
 180f2dc:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 180f2e0:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 180f2e4:	e0bfff17 	ldw	r2,-4(fp)
 180f2e8:	10000626 	beq	r2,zero,180f304 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 180f2ec:	180fab80 	call	180fab8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 180f2f0:	000b883a 	mov	r5,zero
 180f2f4:	e13fff17 	ldw	r4,-4(fp)
 180f2f8:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 180f2fc:	180fae40 	call	180fae4 <xTaskResumeAll>
 180f300:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 180f304:	e0bffe17 	ldw	r2,-8(fp)
 180f308:	1000011e 	bne	r2,zero,180f310 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 180f30c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f310:	0001883a 	nop
 180f314:	e037883a 	mov	sp,fp
 180f318:	dfc00117 	ldw	ra,4(sp)
 180f31c:	df000017 	ldw	fp,0(sp)
 180f320:	dec00204 	addi	sp,sp,8
 180f324:	f800283a 	ret

0180f328 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
 180f328:	defff804 	addi	sp,sp,-32
 180f32c:	dfc00715 	stw	ra,28(sp)
 180f330:	df000615 	stw	fp,24(sp)
 180f334:	df000604 	addi	fp,sp,24
 180f338:	e13fff15 	stw	r4,-4(fp)
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
 180f33c:	e0bfff17 	ldw	r2,-4(fp)
 180f340:	e0bffb15 	stw	r2,-20(fp)

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
 180f344:	d0a7d317 	ldw	r2,-24756(gp)
 180f348:	e0fffb17 	ldw	r3,-20(fp)
 180f34c:	1880021e 	bne	r3,r2,180f358 <eTaskGetState+0x30>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
 180f350:	e03ffa15 	stw	zero,-24(fp)
 180f354:	00003606 	br	180f430 <eTaskGetState+0x108>
		}
		else
		{
			taskENTER_CRITICAL();
 180f358:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f35c:	10000126 	beq	r2,zero,180f364 <eTaskGetState+0x3c>
 180f360:	181103c0 	call	181103c <vTaskEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 180f364:	e0bffb17 	ldw	r2,-20(fp)
 180f368:	10800517 	ldw	r2,20(r2)
 180f36c:	e0bffc15 	stw	r2,-16(fp)
				pxDelayedList = pxDelayedTaskList;
 180f370:	d0a7d417 	ldw	r2,-24752(gp)
 180f374:	e0bffd15 	stw	r2,-12(fp)
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 180f378:	d0a7d517 	ldw	r2,-24748(gp)
 180f37c:	e0bffe15 	stw	r2,-8(fp)
			}
			taskEXIT_CRITICAL();
 180f380:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f384:	10000126 	beq	r2,zero,180f38c <eTaskGetState+0x64>
 180f388:	18110840 	call	1811084 <vTaskExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 180f38c:	e0fffc17 	ldw	r3,-16(fp)
 180f390:	e0bffd17 	ldw	r2,-12(fp)
 180f394:	18800326 	beq	r3,r2,180f3a4 <eTaskGetState+0x7c>
 180f398:	e0fffc17 	ldw	r3,-16(fp)
 180f39c:	e0bffe17 	ldw	r2,-8(fp)
 180f3a0:	1880031e 	bne	r3,r2,180f3b0 <eTaskGetState+0x88>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
 180f3a4:	00800084 	movi	r2,2
 180f3a8:	e0bffa15 	stw	r2,-24(fp)
 180f3ac:	00002006 	br	180f430 <eTaskGetState+0x108>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
 180f3b0:	e0fffc17 	ldw	r3,-16(fp)
 180f3b4:	00806134 	movhi	r2,388
 180f3b8:	109fac04 	addi	r2,r2,32432
 180f3bc:	1880111e 	bne	r3,r2,180f404 <eTaskGetState+0xdc>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 180f3c0:	e0bffb17 	ldw	r2,-20(fp)
 180f3c4:	10800a17 	ldw	r2,40(r2)
 180f3c8:	10000b1e 	bne	r2,zero,180f3f8 <eTaskGetState+0xd0>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 180f3cc:	e0bffb17 	ldw	r2,-20(fp)
 180f3d0:	10801d03 	ldbu	r2,116(r2)
 180f3d4:	10803fcc 	andi	r2,r2,255
 180f3d8:	10800058 	cmpnei	r2,r2,1
 180f3dc:	1000031e 	bne	r2,zero,180f3ec <eTaskGetState+0xc4>
							{
								eReturn = eBlocked;
 180f3e0:	00800084 	movi	r2,2
 180f3e4:	e0bffa15 	stw	r2,-24(fp)
 180f3e8:	00001106 	br	180f430 <eTaskGetState+0x108>
							}
							else
							{
								eReturn = eSuspended;
 180f3ec:	008000c4 	movi	r2,3
 180f3f0:	e0bffa15 	stw	r2,-24(fp)
 180f3f4:	00000e06 	br	180f430 <eTaskGetState+0x108>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
 180f3f8:	00800084 	movi	r2,2
 180f3fc:	e0bffa15 	stw	r2,-24(fp)
 180f400:	00000b06 	br	180f430 <eTaskGetState+0x108>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 180f404:	e0fffc17 	ldw	r3,-16(fp)
 180f408:	00806134 	movhi	r2,388
 180f40c:	109fa704 	addi	r2,r2,32412
 180f410:	18800226 	beq	r3,r2,180f41c <eTaskGetState+0xf4>
 180f414:	e0bffc17 	ldw	r2,-16(fp)
 180f418:	1000031e 	bne	r2,zero,180f428 <eTaskGetState+0x100>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
 180f41c:	00800104 	movi	r2,4
 180f420:	e0bffa15 	stw	r2,-24(fp)
 180f424:	00000206 	br	180f430 <eTaskGetState+0x108>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
 180f428:	00800044 	movi	r2,1
 180f42c:	e0bffa15 	stw	r2,-24(fp)
			}
		}

		return eReturn;
 180f430:	e0bffa17 	ldw	r2,-24(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 180f434:	e037883a 	mov	sp,fp
 180f438:	dfc00117 	ldw	ra,4(sp)
 180f43c:	df000017 	ldw	fp,0(sp)
 180f440:	dec00204 	addi	sp,sp,8
 180f444:	f800283a 	ret

0180f448 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
 180f448:	defffb04 	addi	sp,sp,-20
 180f44c:	dfc00415 	stw	ra,16(sp)
 180f450:	df000315 	stw	fp,12(sp)
 180f454:	df000304 	addi	fp,sp,12
 180f458:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 180f45c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f460:	10000126 	beq	r2,zero,180f468 <uxTaskPriorityGet+0x20>
 180f464:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 180f468:	e0bfff17 	ldw	r2,-4(fp)
 180f46c:	1000021e 	bne	r2,zero,180f478 <uxTaskPriorityGet+0x30>
 180f470:	d0a7d317 	ldw	r2,-24756(gp)
 180f474:	00000106 	br	180f47c <uxTaskPriorityGet+0x34>
 180f478:	e0bfff17 	ldw	r2,-4(fp)
 180f47c:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 180f480:	e0bffd17 	ldw	r2,-12(fp)
 180f484:	10800b17 	ldw	r2,44(r2)
 180f488:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 180f48c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f490:	10000126 	beq	r2,zero,180f498 <uxTaskPriorityGet+0x50>
 180f494:	18110840 	call	1811084 <vTaskExitCritical>

		return uxReturn;
 180f498:	e0bffe17 	ldw	r2,-8(fp)
	}
 180f49c:	e037883a 	mov	sp,fp
 180f4a0:	dfc00117 	ldw	ra,4(sp)
 180f4a4:	df000017 	ldw	fp,0(sp)
 180f4a8:	dec00204 	addi	sp,sp,8
 180f4ac:	f800283a 	ret

0180f4b0 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
 180f4b0:	defffb04 	addi	sp,sp,-20
 180f4b4:	df000415 	stw	fp,16(sp)
 180f4b8:	df000404 	addi	fp,sp,16
 180f4bc:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 180f4c0:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 180f4c4:	e0bfff17 	ldw	r2,-4(fp)
 180f4c8:	1000021e 	bne	r2,zero,180f4d4 <uxTaskPriorityGetFromISR+0x24>
 180f4cc:	d0a7d317 	ldw	r2,-24756(gp)
 180f4d0:	00000106 	br	180f4d8 <uxTaskPriorityGetFromISR+0x28>
 180f4d4:	e0bfff17 	ldw	r2,-4(fp)
 180f4d8:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 180f4dc:	e0bffd17 	ldw	r2,-12(fp)
 180f4e0:	10800b17 	ldw	r2,44(r2)
 180f4e4:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 180f4e8:	e0bffe17 	ldw	r2,-8(fp)
	}
 180f4ec:	e037883a 	mov	sp,fp
 180f4f0:	df000017 	ldw	fp,0(sp)
 180f4f4:	dec00104 	addi	sp,sp,4
 180f4f8:	f800283a 	ret

0180f4fc <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 180f4fc:	defff804 	addi	sp,sp,-32
 180f500:	dfc00715 	stw	ra,28(sp)
 180f504:	df000615 	stw	fp,24(sp)
 180f508:	df000604 	addi	fp,sp,24
 180f50c:	e13ffe15 	stw	r4,-8(fp)
 180f510:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 180f514:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 180f518:	e0bfff17 	ldw	r2,-4(fp)
 180f51c:	10800170 	cmpltui	r2,r2,5
 180f520:	1000021e 	bne	r2,zero,180f52c <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 180f524:	00800104 	movi	r2,4
 180f528:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 180f52c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f530:	10000126 	beq	r2,zero,180f538 <vTaskPrioritySet+0x3c>
 180f534:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 180f538:	e0bffe17 	ldw	r2,-8(fp)
 180f53c:	1000021e 	bne	r2,zero,180f548 <vTaskPrioritySet+0x4c>
 180f540:	d0a7d317 	ldw	r2,-24756(gp)
 180f544:	00000106 	br	180f54c <vTaskPrioritySet+0x50>
 180f548:	e0bffe17 	ldw	r2,-8(fp)
 180f54c:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 180f550:	e0bffb17 	ldw	r2,-20(fp)
 180f554:	10801a17 	ldw	r2,104(r2)
 180f558:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 180f55c:	e0fffc17 	ldw	r3,-16(fp)
 180f560:	e0bfff17 	ldw	r2,-4(fp)
 180f564:	18804926 	beq	r3,r2,180f68c <vTaskPrioritySet+0x190>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 180f568:	e0bfff17 	ldw	r2,-4(fp)
 180f56c:	e0fffc17 	ldw	r3,-16(fp)
 180f570:	18800a2e 	bgeu	r3,r2,180f59c <vTaskPrioritySet+0xa0>
				{
					if( pxTCB != pxCurrentTCB )
 180f574:	d0a7d317 	ldw	r2,-24756(gp)
 180f578:	e0fffb17 	ldw	r3,-20(fp)
 180f57c:	18800c26 	beq	r3,r2,180f5b0 <vTaskPrioritySet+0xb4>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 180f580:	d0a7d317 	ldw	r2,-24756(gp)
 180f584:	10800b17 	ldw	r2,44(r2)
 180f588:	e0ffff17 	ldw	r3,-4(fp)
 180f58c:	18800836 	bltu	r3,r2,180f5b0 <vTaskPrioritySet+0xb4>
						{
							xYieldRequired = pdTRUE;
 180f590:	00800044 	movi	r2,1
 180f594:	e0bffa15 	stw	r2,-24(fp)
 180f598:	00000506 	br	180f5b0 <vTaskPrioritySet+0xb4>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 180f59c:	d0a7d317 	ldw	r2,-24756(gp)
 180f5a0:	e0fffb17 	ldw	r3,-20(fp)
 180f5a4:	1880021e 	bne	r3,r2,180f5b0 <vTaskPrioritySet+0xb4>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 180f5a8:	00800044 	movi	r2,1
 180f5ac:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 180f5b0:	e0bffb17 	ldw	r2,-20(fp)
 180f5b4:	10800b17 	ldw	r2,44(r2)
 180f5b8:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 180f5bc:	e0bffb17 	ldw	r2,-20(fp)
 180f5c0:	10c01a17 	ldw	r3,104(r2)
 180f5c4:	e0bffb17 	ldw	r2,-20(fp)
 180f5c8:	10800b17 	ldw	r2,44(r2)
 180f5cc:	1880031e 	bne	r3,r2,180f5dc <vTaskPrioritySet+0xe0>
					{
						pxTCB->uxPriority = uxNewPriority;
 180f5d0:	e0bffb17 	ldw	r2,-20(fp)
 180f5d4:	e0ffff17 	ldw	r3,-4(fp)
 180f5d8:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 180f5dc:	e0bffb17 	ldw	r2,-20(fp)
 180f5e0:	e0ffff17 	ldw	r3,-4(fp)
 180f5e4:	10c01a15 	stw	r3,104(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 180f5e8:	e0bffb17 	ldw	r2,-20(fp)
 180f5ec:	10800617 	ldw	r2,24(r2)
 180f5f0:	10000516 	blt	r2,zero,180f608 <vTaskPrioritySet+0x10c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 180f5f4:	00c00144 	movi	r3,5
 180f5f8:	e0bfff17 	ldw	r2,-4(fp)
 180f5fc:	1887c83a 	sub	r3,r3,r2
 180f600:	e0bffb17 	ldw	r2,-20(fp)
 180f604:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 180f608:	e0bffb17 	ldw	r2,-20(fp)
 180f60c:	10c00517 	ldw	r3,20(r2)
 180f610:	e0bffd17 	ldw	r2,-12(fp)
 180f614:	11000524 	muli	r4,r2,20
 180f618:	00806134 	movhi	r2,388
 180f61c:	109f7f04 	addi	r2,r2,32252
 180f620:	2085883a 	add	r2,r4,r2
 180f624:	1880161e 	bne	r3,r2,180f680 <vTaskPrioritySet+0x184>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 180f628:	e0bffb17 	ldw	r2,-20(fp)
 180f62c:	10800104 	addi	r2,r2,4
 180f630:	1009883a 	mov	r4,r2
 180f634:	18274fc0 	call	18274fc <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 180f638:	e0bffb17 	ldw	r2,-20(fp)
 180f63c:	10800b17 	ldw	r2,44(r2)
 180f640:	d0e7d917 	ldw	r3,-24732(gp)
 180f644:	1880032e 	bgeu	r3,r2,180f654 <vTaskPrioritySet+0x158>
 180f648:	e0bffb17 	ldw	r2,-20(fp)
 180f64c:	10800b17 	ldw	r2,44(r2)
 180f650:	d0a7d915 	stw	r2,-24732(gp)
 180f654:	e0bffb17 	ldw	r2,-20(fp)
 180f658:	10800b17 	ldw	r2,44(r2)
 180f65c:	10c00524 	muli	r3,r2,20
 180f660:	00806134 	movhi	r2,388
 180f664:	109f7f04 	addi	r2,r2,32252
 180f668:	1887883a 	add	r3,r3,r2
 180f66c:	e0bffb17 	ldw	r2,-20(fp)
 180f670:	10800104 	addi	r2,r2,4
 180f674:	100b883a 	mov	r5,r2
 180f678:	1809883a 	mov	r4,r3
 180f67c:	18273980 	call	1827398 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 180f680:	e0bffa17 	ldw	r2,-24(fp)
 180f684:	10000126 	beq	r2,zero,180f68c <vTaskPrioritySet+0x190>
				{
					taskYIELD_IF_USING_PREEMPTION();
 180f688:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 180f68c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f690:	10000126 	beq	r2,zero,180f698 <vTaskPrioritySet+0x19c>
 180f694:	18110840 	call	1811084 <vTaskExitCritical>
	}
 180f698:	0001883a 	nop
 180f69c:	e037883a 	mov	sp,fp
 180f6a0:	dfc00117 	ldw	ra,4(sp)
 180f6a4:	df000017 	ldw	fp,0(sp)
 180f6a8:	dec00204 	addi	sp,sp,8
 180f6ac:	f800283a 	ret

0180f6b0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 180f6b0:	defffc04 	addi	sp,sp,-16
 180f6b4:	dfc00315 	stw	ra,12(sp)
 180f6b8:	df000215 	stw	fp,8(sp)
 180f6bc:	df000204 	addi	fp,sp,8
 180f6c0:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 180f6c4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f6c8:	10000126 	beq	r2,zero,180f6d0 <vTaskSuspend+0x20>
 180f6cc:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 180f6d0:	e0bfff17 	ldw	r2,-4(fp)
 180f6d4:	1000021e 	bne	r2,zero,180f6e0 <vTaskSuspend+0x30>
 180f6d8:	d0a7d317 	ldw	r2,-24756(gp)
 180f6dc:	00000106 	br	180f6e4 <vTaskSuspend+0x34>
 180f6e0:	e0bfff17 	ldw	r2,-4(fp)
 180f6e4:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 180f6e8:	e0bffe17 	ldw	r2,-8(fp)
 180f6ec:	10800104 	addi	r2,r2,4
 180f6f0:	1009883a 	mov	r4,r2
 180f6f4:	18274fc0 	call	18274fc <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 180f6f8:	e0bffe17 	ldw	r2,-8(fp)
 180f6fc:	10800a17 	ldw	r2,40(r2)
 180f700:	10000426 	beq	r2,zero,180f714 <vTaskSuspend+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 180f704:	e0bffe17 	ldw	r2,-8(fp)
 180f708:	10800604 	addi	r2,r2,24
 180f70c:	1009883a 	mov	r4,r2
 180f710:	18274fc0 	call	18274fc <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 180f714:	e0bffe17 	ldw	r2,-8(fp)
 180f718:	10800104 	addi	r2,r2,4
 180f71c:	100b883a 	mov	r5,r2
 180f720:	01006134 	movhi	r4,388
 180f724:	211fac04 	addi	r4,r4,32432
 180f728:	18273980 	call	1827398 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 180f72c:	e0bffe17 	ldw	r2,-8(fp)
 180f730:	10801d03 	ldbu	r2,116(r2)
 180f734:	10803fcc 	andi	r2,r2,255
 180f738:	10800058 	cmpnei	r2,r2,1
 180f73c:	1000021e 	bne	r2,zero,180f748 <vTaskSuspend+0x98>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 180f740:	e0bffe17 	ldw	r2,-8(fp)
 180f744:	10001d05 	stb	zero,116(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 180f748:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f74c:	10000126 	beq	r2,zero,180f754 <vTaskSuspend+0xa4>
 180f750:	18110840 	call	1811084 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 180f754:	d0a7da17 	ldw	r2,-24728(gp)
 180f758:	10000726 	beq	r2,zero,180f778 <vTaskSuspend+0xc8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 180f75c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f760:	10000126 	beq	r2,zero,180f768 <vTaskSuspend+0xb8>
 180f764:	181103c0 	call	181103c <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 180f768:	1810bf80 	call	1810bf8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 180f76c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f770:	10000126 	beq	r2,zero,180f778 <vTaskSuspend+0xc8>
 180f774:	18110840 	call	1811084 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 180f778:	d0a7d317 	ldw	r2,-24756(gp)
 180f77c:	e0fffe17 	ldw	r3,-8(fp)
 180f780:	18800c1e 	bne	r3,r2,180f7b4 <vTaskSuspend+0x104>
		{
			if( xSchedulerRunning != pdFALSE )
 180f784:	d0a7da17 	ldw	r2,-24728(gp)
 180f788:	10000226 	beq	r2,zero,180f794 <vTaskSuspend+0xe4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 180f78c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f790:	00000806 	br	180f7b4 <vTaskSuspend+0x104>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 180f794:	00806134 	movhi	r2,388
 180f798:	109fac04 	addi	r2,r2,32432
 180f79c:	10c00017 	ldw	r3,0(r2)
 180f7a0:	d0a7d717 	ldw	r2,-24740(gp)
 180f7a4:	1880021e 	bne	r3,r2,180f7b0 <vTaskSuspend+0x100>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 180f7a8:	d027d315 	stw	zero,-24756(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f7ac:	00000106 	br	180f7b4 <vTaskSuspend+0x104>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 180f7b0:	18100a40 	call	18100a4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f7b4:	0001883a 	nop
 180f7b8:	e037883a 	mov	sp,fp
 180f7bc:	dfc00117 	ldw	ra,4(sp)
 180f7c0:	df000017 	ldw	fp,0(sp)
 180f7c4:	dec00204 	addi	sp,sp,8
 180f7c8:	f800283a 	ret

0180f7cc <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 180f7cc:	defffc04 	addi	sp,sp,-16
 180f7d0:	df000315 	stw	fp,12(sp)
 180f7d4:	df000304 	addi	fp,sp,12
 180f7d8:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 180f7dc:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
 180f7e0:	e0bfff17 	ldw	r2,-4(fp)
 180f7e4:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 180f7e8:	e0bffe17 	ldw	r2,-8(fp)
 180f7ec:	10c00517 	ldw	r3,20(r2)
 180f7f0:	00806134 	movhi	r2,388
 180f7f4:	109fac04 	addi	r2,r2,32432
 180f7f8:	18800a1e 	bne	r3,r2,180f824 <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 180f7fc:	e0bffe17 	ldw	r2,-8(fp)
 180f800:	10c00a17 	ldw	r3,40(r2)
 180f804:	00806134 	movhi	r2,388
 180f808:	109fa204 	addi	r2,r2,32392
 180f80c:	18800526 	beq	r3,r2,180f824 <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 180f810:	e0bffe17 	ldw	r2,-8(fp)
 180f814:	10800a17 	ldw	r2,40(r2)
 180f818:	1000021e 	bne	r2,zero,180f824 <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
 180f81c:	00800044 	movi	r2,1
 180f820:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 180f824:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 180f828:	e037883a 	mov	sp,fp
 180f82c:	df000017 	ldw	fp,0(sp)
 180f830:	dec00104 	addi	sp,sp,4
 180f834:	f800283a 	ret

0180f838 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 180f838:	defffc04 	addi	sp,sp,-16
 180f83c:	dfc00315 	stw	ra,12(sp)
 180f840:	df000215 	stw	fp,8(sp)
 180f844:	df000204 	addi	fp,sp,8
 180f848:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
 180f84c:	e0bfff17 	ldw	r2,-4(fp)
 180f850:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 180f854:	d0a7d317 	ldw	r2,-24756(gp)
 180f858:	e0fffe17 	ldw	r3,-8(fp)
 180f85c:	18802726 	beq	r3,r2,180f8fc <vTaskResume+0xc4>
 180f860:	e0bffe17 	ldw	r2,-8(fp)
 180f864:	10002526 	beq	r2,zero,180f8fc <vTaskResume+0xc4>
		{
			taskENTER_CRITICAL();
 180f868:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f86c:	10000126 	beq	r2,zero,180f874 <vTaskResume+0x3c>
 180f870:	181103c0 	call	181103c <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 180f874:	e13ffe17 	ldw	r4,-8(fp)
 180f878:	180f7cc0 	call	180f7cc <prvTaskIsTaskSuspended>
 180f87c:	10001c26 	beq	r2,zero,180f8f0 <vTaskResume+0xb8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 180f880:	e0bffe17 	ldw	r2,-8(fp)
 180f884:	10800104 	addi	r2,r2,4
 180f888:	1009883a 	mov	r4,r2
 180f88c:	18274fc0 	call	18274fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 180f890:	e0bffe17 	ldw	r2,-8(fp)
 180f894:	10800b17 	ldw	r2,44(r2)
 180f898:	d0e7d917 	ldw	r3,-24732(gp)
 180f89c:	1880032e 	bgeu	r3,r2,180f8ac <vTaskResume+0x74>
 180f8a0:	e0bffe17 	ldw	r2,-8(fp)
 180f8a4:	10800b17 	ldw	r2,44(r2)
 180f8a8:	d0a7d915 	stw	r2,-24732(gp)
 180f8ac:	e0bffe17 	ldw	r2,-8(fp)
 180f8b0:	10800b17 	ldw	r2,44(r2)
 180f8b4:	10c00524 	muli	r3,r2,20
 180f8b8:	00806134 	movhi	r2,388
 180f8bc:	109f7f04 	addi	r2,r2,32252
 180f8c0:	1887883a 	add	r3,r3,r2
 180f8c4:	e0bffe17 	ldw	r2,-8(fp)
 180f8c8:	10800104 	addi	r2,r2,4
 180f8cc:	100b883a 	mov	r5,r2
 180f8d0:	1809883a 	mov	r4,r3
 180f8d4:	18273980 	call	1827398 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 180f8d8:	e0bffe17 	ldw	r2,-8(fp)
 180f8dc:	10c00b17 	ldw	r3,44(r2)
 180f8e0:	d0a7d317 	ldw	r2,-24756(gp)
 180f8e4:	10800b17 	ldw	r2,44(r2)
 180f8e8:	18800136 	bltu	r3,r2,180f8f0 <vTaskResume+0xb8>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 180f8ec:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 180f8f0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180f8f4:	10000126 	beq	r2,zero,180f8fc <vTaskResume+0xc4>
 180f8f8:	18110840 	call	1811084 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 180f8fc:	0001883a 	nop
 180f900:	e037883a 	mov	sp,fp
 180f904:	dfc00117 	ldw	ra,4(sp)
 180f908:	df000017 	ldw	fp,0(sp)
 180f90c:	dec00204 	addi	sp,sp,8
 180f910:	f800283a 	ret

0180f914 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 180f914:	defffa04 	addi	sp,sp,-24
 180f918:	dfc00515 	stw	ra,20(sp)
 180f91c:	df000415 	stw	fp,16(sp)
 180f920:	df000404 	addi	fp,sp,16
 180f924:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 180f928:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
 180f92c:	e0bfff17 	ldw	r2,-4(fp)
 180f930:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 180f934:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 180f938:	e13ffd17 	ldw	r4,-12(fp)
 180f93c:	180f7cc0 	call	180f7cc <prvTaskIsTaskSuspended>
 180f940:	10002626 	beq	r2,zero,180f9dc <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 180f944:	d0a7e117 	ldw	r2,-24700(gp)
 180f948:	10001e1e 	bne	r2,zero,180f9c4 <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 180f94c:	e0bffd17 	ldw	r2,-12(fp)
 180f950:	10c00b17 	ldw	r3,44(r2)
 180f954:	d0a7d317 	ldw	r2,-24756(gp)
 180f958:	10800b17 	ldw	r2,44(r2)
 180f95c:	18800236 	bltu	r3,r2,180f968 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 180f960:	00800044 	movi	r2,1
 180f964:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 180f968:	e0bffd17 	ldw	r2,-12(fp)
 180f96c:	10800104 	addi	r2,r2,4
 180f970:	1009883a 	mov	r4,r2
 180f974:	18274fc0 	call	18274fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 180f978:	e0bffd17 	ldw	r2,-12(fp)
 180f97c:	10800b17 	ldw	r2,44(r2)
 180f980:	d0e7d917 	ldw	r3,-24732(gp)
 180f984:	1880032e 	bgeu	r3,r2,180f994 <xTaskResumeFromISR+0x80>
 180f988:	e0bffd17 	ldw	r2,-12(fp)
 180f98c:	10800b17 	ldw	r2,44(r2)
 180f990:	d0a7d915 	stw	r2,-24732(gp)
 180f994:	e0bffd17 	ldw	r2,-12(fp)
 180f998:	10800b17 	ldw	r2,44(r2)
 180f99c:	10c00524 	muli	r3,r2,20
 180f9a0:	00806134 	movhi	r2,388
 180f9a4:	109f7f04 	addi	r2,r2,32252
 180f9a8:	1887883a 	add	r3,r3,r2
 180f9ac:	e0bffd17 	ldw	r2,-12(fp)
 180f9b0:	10800104 	addi	r2,r2,4
 180f9b4:	100b883a 	mov	r5,r2
 180f9b8:	1809883a 	mov	r4,r3
 180f9bc:	18273980 	call	1827398 <vListInsertEnd>
 180f9c0:	00000606 	br	180f9dc <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 180f9c4:	e0bffd17 	ldw	r2,-12(fp)
 180f9c8:	10800604 	addi	r2,r2,24
 180f9cc:	100b883a 	mov	r5,r2
 180f9d0:	01006134 	movhi	r4,388
 180f9d4:	211fa204 	addi	r4,r4,32392
 180f9d8:	18273980 	call	1827398 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 180f9dc:	e0bffc17 	ldw	r2,-16(fp)
	}
 180f9e0:	e037883a 	mov	sp,fp
 180f9e4:	dfc00117 	ldw	ra,4(sp)
 180f9e8:	df000017 	ldw	fp,0(sp)
 180f9ec:	dec00204 	addi	sp,sp,8
 180f9f0:	f800283a 	ret

0180f9f4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 180f9f4:	defffb04 	addi	sp,sp,-20
 180f9f8:	dfc00415 	stw	ra,16(sp)
 180f9fc:	df000315 	stw	fp,12(sp)
 180fa00:	df000304 	addi	fp,sp,12
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 180fa04:	d0a7e004 	addi	r2,gp,-24704
 180fa08:	d8800115 	stw	r2,4(sp)
 180fa0c:	d8000015 	stw	zero,0(sp)
 180fa10:	000f883a 	mov	r7,zero
 180fa14:	01820004 	movi	r6,2048
 180fa18:	01406134 	movhi	r5,388
 180fa1c:	29459204 	addi	r5,r5,5704
 180fa20:	01006074 	movhi	r4,385
 180fa24:	2101c404 	addi	r4,r4,1808
 180fa28:	180ed080 	call	180ed08 <xTaskCreate>
 180fa2c:	e0bfff15 	stw	r2,-4(fp)
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 180fa30:	e0bfff17 	ldw	r2,-4(fp)
 180fa34:	10800058 	cmpnei	r2,r2,1
 180fa38:	1000021e 	bne	r2,zero,180fa44 <vTaskStartScheduler+0x50>
		{
			xReturn = xTimerCreateTimerTask();
 180fa3c:	18119f80 	call	18119f8 <xTimerCreateTimerTask>
 180fa40:	e0bfff15 	stw	r2,-4(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 180fa44:	e0bfff17 	ldw	r2,-4(fp)
 180fa48:	10800058 	cmpnei	r2,r2,1
 180fa4c:	1000071e 	bne	r2,zero,180fa6c <vTaskStartScheduler+0x78>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 180fa50:	18275c00 	call	18275c0 <enh_alt_irq_disable_all>
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 180fa54:	00bfffc4 	movi	r2,-1
 180fa58:	d0a7df15 	stw	r2,-24708(gp)
		xSchedulerRunning = pdTRUE;
 180fa5c:	00800044 	movi	r2,1
 180fa60:	d0a7da15 	stw	r2,-24728(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 180fa64:	d027d815 	stw	zero,-24736(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 180fa68:	182773c0 	call	182773c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 180fa6c:	0001883a 	nop
 180fa70:	e037883a 	mov	sp,fp
 180fa74:	dfc00117 	ldw	ra,4(sp)
 180fa78:	df000017 	ldw	fp,0(sp)
 180fa7c:	dec00204 	addi	sp,sp,8
 180fa80:	f800283a 	ret

0180fa84 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 180fa84:	defffe04 	addi	sp,sp,-8
 180fa88:	dfc00115 	stw	ra,4(sp)
 180fa8c:	df000015 	stw	fp,0(sp)
 180fa90:	d839883a 	mov	fp,sp
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 180fa94:	18275c00 	call	18275c0 <enh_alt_irq_disable_all>
	xSchedulerRunning = pdFALSE;
 180fa98:	d027da15 	stw	zero,-24728(gp)
	vPortEndScheduler();
 180fa9c:	18277680 	call	1827768 <vPortEndScheduler>
}
 180faa0:	0001883a 	nop
 180faa4:	e037883a 	mov	sp,fp
 180faa8:	dfc00117 	ldw	ra,4(sp)
 180faac:	df000017 	ldw	fp,0(sp)
 180fab0:	dec00204 	addi	sp,sp,8
 180fab4:	f800283a 	ret

0180fab8 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 180fab8:	deffff04 	addi	sp,sp,-4
 180fabc:	df000015 	stw	fp,0(sp)
 180fac0:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 180fac4:	d0a7e117 	ldw	r2,-24700(gp)
 180fac8:	10800044 	addi	r2,r2,1
 180facc:	d0a7e115 	stw	r2,-24700(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 180fad0:	0001883a 	nop
 180fad4:	e037883a 	mov	sp,fp
 180fad8:	df000017 	ldw	fp,0(sp)
 180fadc:	dec00104 	addi	sp,sp,4
 180fae0:	f800283a 	ret

0180fae4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 180fae4:	defffb04 	addi	sp,sp,-20
 180fae8:	dfc00415 	stw	ra,16(sp)
 180faec:	df000315 	stw	fp,12(sp)
 180faf0:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 180faf4:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 180faf8:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 180fafc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180fb00:	10000126 	beq	r2,zero,180fb08 <xTaskResumeAll+0x24>
 180fb04:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 180fb08:	d0a7e117 	ldw	r2,-24700(gp)
 180fb0c:	10bfffc4 	addi	r2,r2,-1
 180fb10:	d0a7e115 	stw	r2,-24700(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 180fb14:	d0a7e117 	ldw	r2,-24700(gp)
 180fb18:	1000431e 	bne	r2,zero,180fc28 <xTaskResumeAll+0x144>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 180fb1c:	d0a7d717 	ldw	r2,-24740(gp)
 180fb20:	10004126 	beq	r2,zero,180fc28 <xTaskResumeAll+0x144>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 180fb24:	00002606 	br	180fbc0 <xTaskResumeAll+0xdc>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 180fb28:	00806134 	movhi	r2,388
 180fb2c:	109fa204 	addi	r2,r2,32392
 180fb30:	10800317 	ldw	r2,12(r2)
 180fb34:	10800317 	ldw	r2,12(r2)
 180fb38:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 180fb3c:	e0bffd17 	ldw	r2,-12(fp)
 180fb40:	10800604 	addi	r2,r2,24
 180fb44:	1009883a 	mov	r4,r2
 180fb48:	18274fc0 	call	18274fc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 180fb4c:	e0bffd17 	ldw	r2,-12(fp)
 180fb50:	10800104 	addi	r2,r2,4
 180fb54:	1009883a 	mov	r4,r2
 180fb58:	18274fc0 	call	18274fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 180fb5c:	e0bffd17 	ldw	r2,-12(fp)
 180fb60:	10800b17 	ldw	r2,44(r2)
 180fb64:	d0e7d917 	ldw	r3,-24732(gp)
 180fb68:	1880032e 	bgeu	r3,r2,180fb78 <xTaskResumeAll+0x94>
 180fb6c:	e0bffd17 	ldw	r2,-12(fp)
 180fb70:	10800b17 	ldw	r2,44(r2)
 180fb74:	d0a7d915 	stw	r2,-24732(gp)
 180fb78:	e0bffd17 	ldw	r2,-12(fp)
 180fb7c:	10800b17 	ldw	r2,44(r2)
 180fb80:	10c00524 	muli	r3,r2,20
 180fb84:	00806134 	movhi	r2,388
 180fb88:	109f7f04 	addi	r2,r2,32252
 180fb8c:	1887883a 	add	r3,r3,r2
 180fb90:	e0bffd17 	ldw	r2,-12(fp)
 180fb94:	10800104 	addi	r2,r2,4
 180fb98:	100b883a 	mov	r5,r2
 180fb9c:	1809883a 	mov	r4,r3
 180fba0:	18273980 	call	1827398 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 180fba4:	e0bffd17 	ldw	r2,-12(fp)
 180fba8:	10c00b17 	ldw	r3,44(r2)
 180fbac:	d0a7d317 	ldw	r2,-24756(gp)
 180fbb0:	10800b17 	ldw	r2,44(r2)
 180fbb4:	18800236 	bltu	r3,r2,180fbc0 <xTaskResumeAll+0xdc>
					{
						xYieldPending = pdTRUE;
 180fbb8:	00800044 	movi	r2,1
 180fbbc:	d0a7dc15 	stw	r2,-24720(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 180fbc0:	00806134 	movhi	r2,388
 180fbc4:	109fa204 	addi	r2,r2,32392
 180fbc8:	10800017 	ldw	r2,0(r2)
 180fbcc:	103fd61e 	bne	r2,zero,180fb28 <__ram_exceptions_end+0xff7ff6e4>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 180fbd0:	e0bffd17 	ldw	r2,-12(fp)
 180fbd4:	10000126 	beq	r2,zero,180fbdc <xTaskResumeAll+0xf8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 180fbd8:	1810bf80 	call	1810bf8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 180fbdc:	d0a7db17 	ldw	r2,-24724(gp)
 180fbe0:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
 180fbe4:	e0bfff17 	ldw	r2,-4(fp)
 180fbe8:	10000a26 	beq	r2,zero,180fc14 <xTaskResumeAll+0x130>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 180fbec:	180fef40 	call	180fef4 <xTaskIncrementTick>
 180fbf0:	10000226 	beq	r2,zero,180fbfc <xTaskResumeAll+0x118>
							{
								xYieldPending = pdTRUE;
 180fbf4:	00800044 	movi	r2,1
 180fbf8:	d0a7dc15 	stw	r2,-24720(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 180fbfc:	e0bfff17 	ldw	r2,-4(fp)
 180fc00:	10bfffc4 	addi	r2,r2,-1
 180fc04:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
 180fc08:	e0bfff17 	ldw	r2,-4(fp)
 180fc0c:	103ff71e 	bne	r2,zero,180fbec <__ram_exceptions_end+0xff7ff7a8>

						xPendedTicks = 0;
 180fc10:	d027db15 	stw	zero,-24724(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 180fc14:	d0a7dc17 	ldw	r2,-24720(gp)
 180fc18:	10000326 	beq	r2,zero,180fc28 <xTaskResumeAll+0x144>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 180fc1c:	00800044 	movi	r2,1
 180fc20:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 180fc24:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 180fc28:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180fc2c:	10000126 	beq	r2,zero,180fc34 <xTaskResumeAll+0x150>
 180fc30:	18110840 	call	1811084 <vTaskExitCritical>

	return xAlreadyYielded;
 180fc34:	e0bffe17 	ldw	r2,-8(fp)
}
 180fc38:	e037883a 	mov	sp,fp
 180fc3c:	dfc00117 	ldw	ra,4(sp)
 180fc40:	df000017 	ldw	fp,0(sp)
 180fc44:	dec00204 	addi	sp,sp,8
 180fc48:	f800283a 	ret

0180fc4c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 180fc4c:	defffd04 	addi	sp,sp,-12
 180fc50:	dfc00215 	stw	ra,8(sp)
 180fc54:	df000115 	stw	fp,4(sp)
 180fc58:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
 180fc5c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180fc60:	10000126 	beq	r2,zero,180fc68 <xTaskGetTickCount+0x1c>
 180fc64:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		xTicks = xTickCount;
 180fc68:	d0a7d817 	ldw	r2,-24736(gp)
 180fc6c:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();
 180fc70:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 180fc74:	10000126 	beq	r2,zero,180fc7c <xTaskGetTickCount+0x30>
 180fc78:	18110840 	call	1811084 <vTaskExitCritical>

	return xTicks;
 180fc7c:	e0bfff17 	ldw	r2,-4(fp)
}
 180fc80:	e037883a 	mov	sp,fp
 180fc84:	dfc00117 	ldw	ra,4(sp)
 180fc88:	df000017 	ldw	fp,0(sp)
 180fc8c:	dec00204 	addi	sp,sp,8
 180fc90:	f800283a 	ret

0180fc94 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 180fc94:	defffd04 	addi	sp,sp,-12
 180fc98:	df000215 	stw	fp,8(sp)
 180fc9c:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 180fca0:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 180fca4:	d0a7d817 	ldw	r2,-24736(gp)
 180fca8:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 180fcac:	e0bfff17 	ldw	r2,-4(fp)
}
 180fcb0:	e037883a 	mov	sp,fp
 180fcb4:	df000017 	ldw	fp,0(sp)
 180fcb8:	dec00104 	addi	sp,sp,4
 180fcbc:	f800283a 	ret

0180fcc0 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 180fcc0:	deffff04 	addi	sp,sp,-4
 180fcc4:	df000015 	stw	fp,0(sp)
 180fcc8:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 180fccc:	d0a7d717 	ldw	r2,-24740(gp)
}
 180fcd0:	e037883a 	mov	sp,fp
 180fcd4:	df000017 	ldw	fp,0(sp)
 180fcd8:	dec00104 	addi	sp,sp,4
 180fcdc:	f800283a 	ret

0180fce0 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 180fce0:	defffd04 	addi	sp,sp,-12
 180fce4:	df000215 	stw	fp,8(sp)
 180fce8:	df000204 	addi	fp,sp,8
 180fcec:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 180fcf0:	e0bfff17 	ldw	r2,-4(fp)
 180fcf4:	1000021e 	bne	r2,zero,180fd00 <pcTaskGetName+0x20>
 180fcf8:	d0a7d317 	ldw	r2,-24756(gp)
 180fcfc:	00000106 	br	180fd04 <pcTaskGetName+0x24>
 180fd00:	e0bfff17 	ldw	r2,-4(fp)
 180fd04:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 180fd08:	e0bffe17 	ldw	r2,-8(fp)
 180fd0c:	10800d04 	addi	r2,r2,52
}
 180fd10:	e037883a 	mov	sp,fp
 180fd14:	df000017 	ldw	fp,0(sp)
 180fd18:	dec00104 	addi	sp,sp,4
 180fd1c:	f800283a 	ret

0180fd20 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 180fd20:	defff904 	addi	sp,sp,-28
 180fd24:	dfc00615 	stw	ra,24(sp)
 180fd28:	df000515 	stw	fp,20(sp)
 180fd2c:	df000504 	addi	fp,sp,20
 180fd30:	e13ffd15 	stw	r4,-12(fp)
 180fd34:	e17ffe15 	stw	r5,-8(fp)
 180fd38:	e1bfff15 	stw	r6,-4(fp)
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 180fd3c:	e03ffb15 	stw	zero,-20(fp)
 180fd40:	00800144 	movi	r2,5
 180fd44:	e0bffc15 	stw	r2,-16(fp)

		vTaskSuspendAll();
 180fd48:	180fab80 	call	180fab8 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
 180fd4c:	d0a7d717 	ldw	r2,-24740(gp)
 180fd50:	e0fffe17 	ldw	r3,-8(fp)
 180fd54:	18804d36 	bltu	r3,r2,180fe8c <uxTaskGetSystemState+0x16c>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
 180fd58:	e0bffc17 	ldw	r2,-16(fp)
 180fd5c:	10bfffc4 	addi	r2,r2,-1
 180fd60:	e0bffc15 	stw	r2,-16(fp)
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 180fd64:	e0bffb17 	ldw	r2,-20(fp)
 180fd68:	10800924 	muli	r2,r2,36
 180fd6c:	e0fffd17 	ldw	r3,-12(fp)
 180fd70:	1889883a 	add	r4,r3,r2
 180fd74:	e0bffc17 	ldw	r2,-16(fp)
 180fd78:	10c00524 	muli	r3,r2,20
 180fd7c:	00806134 	movhi	r2,388
 180fd80:	109f7f04 	addi	r2,r2,32252
 180fd84:	1885883a 	add	r2,r3,r2
 180fd88:	01800044 	movi	r6,1
 180fd8c:	100b883a 	mov	r5,r2
 180fd90:	18109cc0 	call	18109cc <prvListTasksWithinSingleList>
 180fd94:	1007883a 	mov	r3,r2
 180fd98:	e0bffb17 	ldw	r2,-20(fp)
 180fd9c:	10c5883a 	add	r2,r2,r3
 180fda0:	e0bffb15 	stw	r2,-20(fp)

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 180fda4:	e0bffc17 	ldw	r2,-16(fp)
 180fda8:	103feb1e 	bne	r2,zero,180fd58 <__ram_exceptions_end+0xff7ff914>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 180fdac:	e0bffb17 	ldw	r2,-20(fp)
 180fdb0:	10800924 	muli	r2,r2,36
 180fdb4:	e0fffd17 	ldw	r3,-12(fp)
 180fdb8:	1885883a 	add	r2,r3,r2
 180fdbc:	d0e7d417 	ldw	r3,-24752(gp)
 180fdc0:	01800084 	movi	r6,2
 180fdc4:	180b883a 	mov	r5,r3
 180fdc8:	1009883a 	mov	r4,r2
 180fdcc:	18109cc0 	call	18109cc <prvListTasksWithinSingleList>
 180fdd0:	1007883a 	mov	r3,r2
 180fdd4:	e0bffb17 	ldw	r2,-20(fp)
 180fdd8:	10c5883a 	add	r2,r2,r3
 180fddc:	e0bffb15 	stw	r2,-20(fp)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 180fde0:	e0bffb17 	ldw	r2,-20(fp)
 180fde4:	10800924 	muli	r2,r2,36
 180fde8:	e0fffd17 	ldw	r3,-12(fp)
 180fdec:	1885883a 	add	r2,r3,r2
 180fdf0:	d0e7d517 	ldw	r3,-24748(gp)
 180fdf4:	01800084 	movi	r6,2
 180fdf8:	180b883a 	mov	r5,r3
 180fdfc:	1009883a 	mov	r4,r2
 180fe00:	18109cc0 	call	18109cc <prvListTasksWithinSingleList>
 180fe04:	1007883a 	mov	r3,r2
 180fe08:	e0bffb17 	ldw	r2,-20(fp)
 180fe0c:	10c5883a 	add	r2,r2,r3
 180fe10:	e0bffb15 	stw	r2,-20(fp)

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 180fe14:	e0bffb17 	ldw	r2,-20(fp)
 180fe18:	10800924 	muli	r2,r2,36
 180fe1c:	e0fffd17 	ldw	r3,-12(fp)
 180fe20:	1885883a 	add	r2,r3,r2
 180fe24:	01800104 	movi	r6,4
 180fe28:	01406134 	movhi	r5,388
 180fe2c:	295fa704 	addi	r5,r5,32412
 180fe30:	1009883a 	mov	r4,r2
 180fe34:	18109cc0 	call	18109cc <prvListTasksWithinSingleList>
 180fe38:	1007883a 	mov	r3,r2
 180fe3c:	e0bffb17 	ldw	r2,-20(fp)
 180fe40:	10c5883a 	add	r2,r2,r3
 180fe44:	e0bffb15 	stw	r2,-20(fp)

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 180fe48:	e0bffb17 	ldw	r2,-20(fp)
 180fe4c:	10800924 	muli	r2,r2,36
 180fe50:	e0fffd17 	ldw	r3,-12(fp)
 180fe54:	1885883a 	add	r2,r3,r2
 180fe58:	018000c4 	movi	r6,3
 180fe5c:	01406134 	movhi	r5,388
 180fe60:	295fac04 	addi	r5,r5,32432
 180fe64:	1009883a 	mov	r4,r2
 180fe68:	18109cc0 	call	18109cc <prvListTasksWithinSingleList>
 180fe6c:	1007883a 	mov	r3,r2
 180fe70:	e0bffb17 	ldw	r2,-20(fp)
 180fe74:	10c5883a 	add	r2,r2,r3
 180fe78:	e0bffb15 	stw	r2,-20(fp)
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
 180fe7c:	e0bfff17 	ldw	r2,-4(fp)
 180fe80:	10000226 	beq	r2,zero,180fe8c <uxTaskGetSystemState+0x16c>
					{
						*pulTotalRunTime = 0;
 180fe84:	e0bfff17 	ldw	r2,-4(fp)
 180fe88:	10000015 	stw	zero,0(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
 180fe8c:	180fae40 	call	180fae4 <xTaskResumeAll>

		return uxTask;
 180fe90:	e0bffb17 	ldw	r2,-20(fp)
	}
 180fe94:	e037883a 	mov	sp,fp
 180fe98:	dfc00117 	ldw	ra,4(sp)
 180fe9c:	df000017 	ldw	fp,0(sp)
 180fea0:	dec00204 	addi	sp,sp,8
 180fea4:	f800283a 	ret

0180fea8 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 180fea8:	defffc04 	addi	sp,sp,-16
 180feac:	dfc00315 	stw	ra,12(sp)
 180feb0:	df000215 	stw	fp,8(sp)
 180feb4:	df000204 	addi	fp,sp,8
 180feb8:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
 180febc:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
 180fec0:	180fab80 	call	180fab8 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
 180fec4:	d0e7db17 	ldw	r3,-24724(gp)
 180fec8:	e0bfff17 	ldw	r2,-4(fp)
 180fecc:	1885883a 	add	r2,r3,r2
 180fed0:	d0a7db15 	stw	r2,-24724(gp)
	xYieldRequired = xTaskResumeAll();
 180fed4:	180fae40 	call	180fae4 <xTaskResumeAll>
 180fed8:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
 180fedc:	e0bffe17 	ldw	r2,-8(fp)
}
 180fee0:	e037883a 	mov	sp,fp
 180fee4:	dfc00117 	ldw	ra,4(sp)
 180fee8:	df000017 	ldw	fp,0(sp)
 180feec:	dec00204 	addi	sp,sp,8
 180fef0:	f800283a 	ret

0180fef4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 180fef4:	defff904 	addi	sp,sp,-28
 180fef8:	dfc00615 	stw	ra,24(sp)
 180fefc:	df000515 	stw	fp,20(sp)
 180ff00:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 180ff04:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 180ff08:	d0a7e117 	ldw	r2,-24700(gp)
 180ff0c:	10005c1e 	bne	r2,zero,1810080 <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 180ff10:	d0a7d817 	ldw	r2,-24736(gp)
 180ff14:	10800044 	addi	r2,r2,1
 180ff18:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 180ff1c:	e0bffc17 	ldw	r2,-16(fp)
 180ff20:	d0a7d815 	stw	r2,-24736(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 180ff24:	e0bffc17 	ldw	r2,-16(fp)
 180ff28:	10000a1e 	bne	r2,zero,180ff54 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 180ff2c:	d0a7d417 	ldw	r2,-24752(gp)
 180ff30:	e0bffd15 	stw	r2,-12(fp)
 180ff34:	d0a7d517 	ldw	r2,-24748(gp)
 180ff38:	d0a7d415 	stw	r2,-24752(gp)
 180ff3c:	e0bffd17 	ldw	r2,-12(fp)
 180ff40:	d0a7d515 	stw	r2,-24748(gp)
 180ff44:	d0a7dd17 	ldw	r2,-24716(gp)
 180ff48:	10800044 	addi	r2,r2,1
 180ff4c:	d0a7dd15 	stw	r2,-24716(gp)
 180ff50:	1810bf80 	call	1810bf8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 180ff54:	d0a7df17 	ldw	r2,-24708(gp)
 180ff58:	e0fffc17 	ldw	r3,-16(fp)
 180ff5c:	18803836 	bltu	r3,r2,1810040 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 180ff60:	d0a7d417 	ldw	r2,-24752(gp)
 180ff64:	10800017 	ldw	r2,0(r2)
 180ff68:	1000031e 	bne	r2,zero,180ff78 <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 180ff6c:	00bfffc4 	movi	r2,-1
 180ff70:	d0a7df15 	stw	r2,-24708(gp)
					break;
 180ff74:	00003206 	br	1810040 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 180ff78:	d0a7d417 	ldw	r2,-24752(gp)
 180ff7c:	10800317 	ldw	r2,12(r2)
 180ff80:	10800317 	ldw	r2,12(r2)
 180ff84:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 180ff88:	e0bffe17 	ldw	r2,-8(fp)
 180ff8c:	10800117 	ldw	r2,4(r2)
 180ff90:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 180ff94:	e0fffc17 	ldw	r3,-16(fp)
 180ff98:	e0bfff17 	ldw	r2,-4(fp)
 180ff9c:	1880032e 	bgeu	r3,r2,180ffac <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 180ffa0:	e0bfff17 	ldw	r2,-4(fp)
 180ffa4:	d0a7df15 	stw	r2,-24708(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 180ffa8:	00002506 	br	1810040 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 180ffac:	e0bffe17 	ldw	r2,-8(fp)
 180ffb0:	10800104 	addi	r2,r2,4
 180ffb4:	1009883a 	mov	r4,r2
 180ffb8:	18274fc0 	call	18274fc <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 180ffbc:	e0bffe17 	ldw	r2,-8(fp)
 180ffc0:	10800a17 	ldw	r2,40(r2)
 180ffc4:	10000426 	beq	r2,zero,180ffd8 <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 180ffc8:	e0bffe17 	ldw	r2,-8(fp)
 180ffcc:	10800604 	addi	r2,r2,24
 180ffd0:	1009883a 	mov	r4,r2
 180ffd4:	18274fc0 	call	18274fc <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 180ffd8:	e0bffe17 	ldw	r2,-8(fp)
 180ffdc:	10800b17 	ldw	r2,44(r2)
 180ffe0:	d0e7d917 	ldw	r3,-24732(gp)
 180ffe4:	1880032e 	bgeu	r3,r2,180fff4 <xTaskIncrementTick+0x100>
 180ffe8:	e0bffe17 	ldw	r2,-8(fp)
 180ffec:	10800b17 	ldw	r2,44(r2)
 180fff0:	d0a7d915 	stw	r2,-24732(gp)
 180fff4:	e0bffe17 	ldw	r2,-8(fp)
 180fff8:	10800b17 	ldw	r2,44(r2)
 180fffc:	10c00524 	muli	r3,r2,20
 1810000:	00806134 	movhi	r2,388
 1810004:	109f7f04 	addi	r2,r2,32252
 1810008:	1887883a 	add	r3,r3,r2
 181000c:	e0bffe17 	ldw	r2,-8(fp)
 1810010:	10800104 	addi	r2,r2,4
 1810014:	100b883a 	mov	r5,r2
 1810018:	1809883a 	mov	r4,r3
 181001c:	18273980 	call	1827398 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1810020:	e0bffe17 	ldw	r2,-8(fp)
 1810024:	10c00b17 	ldw	r3,44(r2)
 1810028:	d0a7d317 	ldw	r2,-24756(gp)
 181002c:	10800b17 	ldw	r2,44(r2)
 1810030:	18bfcb36 	bltu	r3,r2,180ff60 <__ram_exceptions_end+0xff7ffb1c>
						{
							xSwitchRequired = pdTRUE;
 1810034:	00800044 	movi	r2,1
 1810038:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 181003c:	003fc806 	br	180ff60 <__ram_exceptions_end+0xff7ffb1c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 1810040:	d0a7d317 	ldw	r2,-24756(gp)
 1810044:	10c00b17 	ldw	r3,44(r2)
 1810048:	00806134 	movhi	r2,388
 181004c:	109f7f04 	addi	r2,r2,32252
 1810050:	18c00524 	muli	r3,r3,20
 1810054:	10c5883a 	add	r2,r2,r3
 1810058:	10800017 	ldw	r2,0(r2)
 181005c:	108000b0 	cmpltui	r2,r2,2
 1810060:	1000021e 	bne	r2,zero,181006c <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
 1810064:	00800044 	movi	r2,1
 1810068:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 181006c:	d0a7dc17 	ldw	r2,-24720(gp)
 1810070:	10000626 	beq	r2,zero,181008c <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
 1810074:	00800044 	movi	r2,1
 1810078:	e0bffb15 	stw	r2,-20(fp)
 181007c:	00000306 	br	181008c <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 1810080:	d0a7db17 	ldw	r2,-24724(gp)
 1810084:	10800044 	addi	r2,r2,1
 1810088:	d0a7db15 	stw	r2,-24724(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 181008c:	e0bffb17 	ldw	r2,-20(fp)
}
 1810090:	e037883a 	mov	sp,fp
 1810094:	dfc00117 	ldw	ra,4(sp)
 1810098:	df000017 	ldw	fp,0(sp)
 181009c:	dec00204 	addi	sp,sp,8
 18100a0:	f800283a 	ret

018100a4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 18100a4:	defffa04 	addi	sp,sp,-24
 18100a8:	dfc00515 	stw	ra,20(sp)
 18100ac:	df000415 	stw	fp,16(sp)
 18100b0:	df000404 	addi	fp,sp,16
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 18100b4:	d0a7e117 	ldw	r2,-24700(gp)
 18100b8:	10000326 	beq	r2,zero,18100c8 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 18100bc:	00800044 	movi	r2,1
 18100c0:	d0a7dc15 	stw	r2,-24720(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 18100c4:	00004806 	br	18101e8 <vTaskSwitchContext+0x144>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 18100c8:	d027dc15 	stw	zero,-24720(gp)
			ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 18100cc:	d0a7d317 	ldw	r2,-24756(gp)
 18100d0:	10800c17 	ldw	r2,48(r2)
 18100d4:	e0bffd15 	stw	r2,-12(fp)
 18100d8:	00a969b4 	movhi	r2,42406
 18100dc:	10a96944 	addi	r2,r2,-23131
 18100e0:	e0bffe15 	stw	r2,-8(fp)
 18100e4:	e0bffd17 	ldw	r2,-12(fp)
 18100e8:	10c00017 	ldw	r3,0(r2)
 18100ec:	e0bffe17 	ldw	r2,-8(fp)
 18100f0:	18800f1e 	bne	r3,r2,1810130 <vTaskSwitchContext+0x8c>
 18100f4:	e0bffd17 	ldw	r2,-12(fp)
 18100f8:	10800104 	addi	r2,r2,4
 18100fc:	10c00017 	ldw	r3,0(r2)
 1810100:	e0bffe17 	ldw	r2,-8(fp)
 1810104:	18800a1e 	bne	r3,r2,1810130 <vTaskSwitchContext+0x8c>
 1810108:	e0bffd17 	ldw	r2,-12(fp)
 181010c:	10800204 	addi	r2,r2,8
 1810110:	10c00017 	ldw	r3,0(r2)
 1810114:	e0bffe17 	ldw	r2,-8(fp)
 1810118:	1880051e 	bne	r3,r2,1810130 <vTaskSwitchContext+0x8c>
 181011c:	e0bffd17 	ldw	r2,-12(fp)
 1810120:	10800304 	addi	r2,r2,12
 1810124:	10c00017 	ldw	r3,0(r2)
 1810128:	e0bffe17 	ldw	r2,-8(fp)
 181012c:	18800626 	beq	r3,r2,1810148 <vTaskSwitchContext+0xa4>
 1810130:	d0e7d317 	ldw	r3,-24756(gp)
 1810134:	d0a7d317 	ldw	r2,-24756(gp)
 1810138:	10800d04 	addi	r2,r2,52
 181013c:	100b883a 	mov	r5,r2
 1810140:	1809883a 	mov	r4,r3
 1810144:	18004880 	call	1800488 <vApplicationStackOverflowHook>
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1810148:	d0a7d917 	ldw	r2,-24732(gp)
 181014c:	e0bffc15 	stw	r2,-16(fp)
 1810150:	00000306 	br	1810160 <vTaskSwitchContext+0xbc>
 1810154:	e0bffc17 	ldw	r2,-16(fp)
 1810158:	10bfffc4 	addi	r2,r2,-1
 181015c:	e0bffc15 	stw	r2,-16(fp)
 1810160:	00806134 	movhi	r2,388
 1810164:	109f7f04 	addi	r2,r2,32252
 1810168:	e0fffc17 	ldw	r3,-16(fp)
 181016c:	18c00524 	muli	r3,r3,20
 1810170:	10c5883a 	add	r2,r2,r3
 1810174:	10800017 	ldw	r2,0(r2)
 1810178:	103ff626 	beq	r2,zero,1810154 <__ram_exceptions_end+0xff7ffd10>
 181017c:	e0bffc17 	ldw	r2,-16(fp)
 1810180:	10c00524 	muli	r3,r2,20
 1810184:	00806134 	movhi	r2,388
 1810188:	109f7f04 	addi	r2,r2,32252
 181018c:	1885883a 	add	r2,r3,r2
 1810190:	e0bfff15 	stw	r2,-4(fp)
 1810194:	e0bfff17 	ldw	r2,-4(fp)
 1810198:	10800117 	ldw	r2,4(r2)
 181019c:	10c00117 	ldw	r3,4(r2)
 18101a0:	e0bfff17 	ldw	r2,-4(fp)
 18101a4:	10c00115 	stw	r3,4(r2)
 18101a8:	e0bfff17 	ldw	r2,-4(fp)
 18101ac:	10c00117 	ldw	r3,4(r2)
 18101b0:	e0bfff17 	ldw	r2,-4(fp)
 18101b4:	10800204 	addi	r2,r2,8
 18101b8:	1880051e 	bne	r3,r2,18101d0 <vTaskSwitchContext+0x12c>
 18101bc:	e0bfff17 	ldw	r2,-4(fp)
 18101c0:	10800117 	ldw	r2,4(r2)
 18101c4:	10c00117 	ldw	r3,4(r2)
 18101c8:	e0bfff17 	ldw	r2,-4(fp)
 18101cc:	10c00115 	stw	r3,4(r2)
 18101d0:	e0bfff17 	ldw	r2,-4(fp)
 18101d4:	10800117 	ldw	r2,4(r2)
 18101d8:	10800317 	ldw	r2,12(r2)
 18101dc:	d0a7d315 	stw	r2,-24756(gp)
 18101e0:	e0bffc17 	ldw	r2,-16(fp)
 18101e4:	d0a7d915 	stw	r2,-24732(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 18101e8:	0001883a 	nop
 18101ec:	e037883a 	mov	sp,fp
 18101f0:	dfc00117 	ldw	ra,4(sp)
 18101f4:	df000017 	ldw	fp,0(sp)
 18101f8:	dec00204 	addi	sp,sp,8
 18101fc:	f800283a 	ret

01810200 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 1810200:	defffc04 	addi	sp,sp,-16
 1810204:	dfc00315 	stw	ra,12(sp)
 1810208:	df000215 	stw	fp,8(sp)
 181020c:	df000204 	addi	fp,sp,8
 1810210:	e13ffe15 	stw	r4,-8(fp)
 1810214:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1810218:	d0a7d317 	ldw	r2,-24756(gp)
 181021c:	10800604 	addi	r2,r2,24
 1810220:	100b883a 	mov	r5,r2
 1810224:	e13ffe17 	ldw	r4,-8(fp)
 1810228:	18274240 	call	1827424 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 181022c:	01400044 	movi	r5,1
 1810230:	e13fff17 	ldw	r4,-4(fp)
 1810234:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>
}
 1810238:	0001883a 	nop
 181023c:	e037883a 	mov	sp,fp
 1810240:	dfc00117 	ldw	ra,4(sp)
 1810244:	df000017 	ldw	fp,0(sp)
 1810248:	dec00204 	addi	sp,sp,8
 181024c:	f800283a 	ret

01810250 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 1810250:	defffb04 	addi	sp,sp,-20
 1810254:	dfc00415 	stw	ra,16(sp)
 1810258:	df000315 	stw	fp,12(sp)
 181025c:	df000304 	addi	fp,sp,12
 1810260:	e13ffd15 	stw	r4,-12(fp)
 1810264:	e17ffe15 	stw	r5,-8(fp)
 1810268:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 181026c:	d0a7d317 	ldw	r2,-24756(gp)
 1810270:	e0fffe17 	ldw	r3,-8(fp)
 1810274:	18e00034 	orhi	r3,r3,32768
 1810278:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 181027c:	d0a7d317 	ldw	r2,-24756(gp)
 1810280:	10800604 	addi	r2,r2,24
 1810284:	100b883a 	mov	r5,r2
 1810288:	e13ffd17 	ldw	r4,-12(fp)
 181028c:	18273980 	call	1827398 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1810290:	01400044 	movi	r5,1
 1810294:	e13fff17 	ldw	r4,-4(fp)
 1810298:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>
}
 181029c:	0001883a 	nop
 18102a0:	e037883a 	mov	sp,fp
 18102a4:	dfc00117 	ldw	ra,4(sp)
 18102a8:	df000017 	ldw	fp,0(sp)
 18102ac:	dec00204 	addi	sp,sp,8
 18102b0:	f800283a 	ret

018102b4 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 18102b4:	defffb04 	addi	sp,sp,-20
 18102b8:	dfc00415 	stw	ra,16(sp)
 18102bc:	df000315 	stw	fp,12(sp)
 18102c0:	df000304 	addi	fp,sp,12
 18102c4:	e13ffd15 	stw	r4,-12(fp)
 18102c8:	e17ffe15 	stw	r5,-8(fp)
 18102cc:	e1bfff15 	stw	r6,-4(fp)

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 18102d0:	d0a7d317 	ldw	r2,-24756(gp)
 18102d4:	10800604 	addi	r2,r2,24
 18102d8:	100b883a 	mov	r5,r2
 18102dc:	e13ffd17 	ldw	r4,-12(fp)
 18102e0:	18273980 	call	1827398 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 18102e4:	e0bfff17 	ldw	r2,-4(fp)
 18102e8:	10000226 	beq	r2,zero,18102f4 <vTaskPlaceOnEventListRestricted+0x40>
		{
			xTicksToWait = portMAX_DELAY;
 18102ec:	00bfffc4 	movi	r2,-1
 18102f0:	e0bffe15 	stw	r2,-8(fp)
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 18102f4:	e17fff17 	ldw	r5,-4(fp)
 18102f8:	e13ffe17 	ldw	r4,-8(fp)
 18102fc:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>
	}
 1810300:	0001883a 	nop
 1810304:	e037883a 	mov	sp,fp
 1810308:	dfc00117 	ldw	ra,4(sp)
 181030c:	df000017 	ldw	fp,0(sp)
 1810310:	dec00204 	addi	sp,sp,8
 1810314:	f800283a 	ret

01810318 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 1810318:	defffb04 	addi	sp,sp,-20
 181031c:	dfc00415 	stw	ra,16(sp)
 1810320:	df000315 	stw	fp,12(sp)
 1810324:	df000304 	addi	fp,sp,12
 1810328:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 181032c:	e0bfff17 	ldw	r2,-4(fp)
 1810330:	10800317 	ldw	r2,12(r2)
 1810334:	10800317 	ldw	r2,12(r2)
 1810338:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 181033c:	e0bffe17 	ldw	r2,-8(fp)
 1810340:	10800604 	addi	r2,r2,24
 1810344:	1009883a 	mov	r4,r2
 1810348:	18274fc0 	call	18274fc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 181034c:	d0a7e117 	ldw	r2,-24700(gp)
 1810350:	1000171e 	bne	r2,zero,18103b0 <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1810354:	e0bffe17 	ldw	r2,-8(fp)
 1810358:	10800104 	addi	r2,r2,4
 181035c:	1009883a 	mov	r4,r2
 1810360:	18274fc0 	call	18274fc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 1810364:	e0bffe17 	ldw	r2,-8(fp)
 1810368:	10800b17 	ldw	r2,44(r2)
 181036c:	d0e7d917 	ldw	r3,-24732(gp)
 1810370:	1880032e 	bgeu	r3,r2,1810380 <xTaskRemoveFromEventList+0x68>
 1810374:	e0bffe17 	ldw	r2,-8(fp)
 1810378:	10800b17 	ldw	r2,44(r2)
 181037c:	d0a7d915 	stw	r2,-24732(gp)
 1810380:	e0bffe17 	ldw	r2,-8(fp)
 1810384:	10800b17 	ldw	r2,44(r2)
 1810388:	10c00524 	muli	r3,r2,20
 181038c:	00806134 	movhi	r2,388
 1810390:	109f7f04 	addi	r2,r2,32252
 1810394:	1887883a 	add	r3,r3,r2
 1810398:	e0bffe17 	ldw	r2,-8(fp)
 181039c:	10800104 	addi	r2,r2,4
 18103a0:	100b883a 	mov	r5,r2
 18103a4:	1809883a 	mov	r4,r3
 18103a8:	18273980 	call	1827398 <vListInsertEnd>
 18103ac:	00000606 	br	18103c8 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 18103b0:	e0bffe17 	ldw	r2,-8(fp)
 18103b4:	10800604 	addi	r2,r2,24
 18103b8:	100b883a 	mov	r5,r2
 18103bc:	01006134 	movhi	r4,388
 18103c0:	211fa204 	addi	r4,r4,32392
 18103c4:	18273980 	call	1827398 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 18103c8:	e0bffe17 	ldw	r2,-8(fp)
 18103cc:	10800b17 	ldw	r2,44(r2)
 18103d0:	d0e7d317 	ldw	r3,-24756(gp)
 18103d4:	18c00b17 	ldw	r3,44(r3)
 18103d8:	1880052e 	bgeu	r3,r2,18103f0 <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 18103dc:	00800044 	movi	r2,1
 18103e0:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 18103e4:	00800044 	movi	r2,1
 18103e8:	d0a7dc15 	stw	r2,-24720(gp)
 18103ec:	00000106 	br	18103f4 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 18103f0:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 18103f4:	e0bffd17 	ldw	r2,-12(fp)
}
 18103f8:	e037883a 	mov	sp,fp
 18103fc:	dfc00117 	ldw	ra,4(sp)
 1810400:	df000017 	ldw	fp,0(sp)
 1810404:	dec00204 	addi	sp,sp,8
 1810408:	f800283a 	ret

0181040c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 181040c:	defffb04 	addi	sp,sp,-20
 1810410:	dfc00415 	stw	ra,16(sp)
 1810414:	df000315 	stw	fp,12(sp)
 1810418:	df000304 	addi	fp,sp,12
 181041c:	e13ffe15 	stw	r4,-8(fp)
 1810420:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 1810424:	e0bfff17 	ldw	r2,-4(fp)
 1810428:	10e00034 	orhi	r3,r2,32768
 181042c:	e0bffe17 	ldw	r2,-8(fp)
 1810430:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1810434:	e0bffe17 	ldw	r2,-8(fp)
 1810438:	10800317 	ldw	r2,12(r2)
 181043c:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 1810440:	e13ffe17 	ldw	r4,-8(fp)
 1810444:	18274fc0 	call	18274fc <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1810448:	e0bffd17 	ldw	r2,-12(fp)
 181044c:	10800104 	addi	r2,r2,4
 1810450:	1009883a 	mov	r4,r2
 1810454:	18274fc0 	call	18274fc <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 1810458:	e0bffd17 	ldw	r2,-12(fp)
 181045c:	10800b17 	ldw	r2,44(r2)
 1810460:	d0e7d917 	ldw	r3,-24732(gp)
 1810464:	1880032e 	bgeu	r3,r2,1810474 <vTaskRemoveFromUnorderedEventList+0x68>
 1810468:	e0bffd17 	ldw	r2,-12(fp)
 181046c:	10800b17 	ldw	r2,44(r2)
 1810470:	d0a7d915 	stw	r2,-24732(gp)
 1810474:	e0bffd17 	ldw	r2,-12(fp)
 1810478:	10800b17 	ldw	r2,44(r2)
 181047c:	10c00524 	muli	r3,r2,20
 1810480:	00806134 	movhi	r2,388
 1810484:	109f7f04 	addi	r2,r2,32252
 1810488:	1887883a 	add	r3,r3,r2
 181048c:	e0bffd17 	ldw	r2,-12(fp)
 1810490:	10800104 	addi	r2,r2,4
 1810494:	100b883a 	mov	r5,r2
 1810498:	1809883a 	mov	r4,r3
 181049c:	18273980 	call	1827398 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 18104a0:	e0bffd17 	ldw	r2,-12(fp)
 18104a4:	10800b17 	ldw	r2,44(r2)
 18104a8:	d0e7d317 	ldw	r3,-24756(gp)
 18104ac:	18c00b17 	ldw	r3,44(r3)
 18104b0:	1880022e 	bgeu	r3,r2,18104bc <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
 18104b4:	00800044 	movi	r2,1
 18104b8:	d0a7dc15 	stw	r2,-24720(gp)
	}
}
 18104bc:	0001883a 	nop
 18104c0:	e037883a 	mov	sp,fp
 18104c4:	dfc00117 	ldw	ra,4(sp)
 18104c8:	df000017 	ldw	fp,0(sp)
 18104cc:	dec00204 	addi	sp,sp,8
 18104d0:	f800283a 	ret

018104d4 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 18104d4:	defffd04 	addi	sp,sp,-12
 18104d8:	dfc00215 	stw	ra,8(sp)
 18104dc:	df000115 	stw	fp,4(sp)
 18104e0:	df000104 	addi	fp,sp,4
 18104e4:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
 18104e8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18104ec:	10000126 	beq	r2,zero,18104f4 <vTaskSetTimeOutState+0x20>
 18104f0:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 18104f4:	d0e7dd17 	ldw	r3,-24716(gp)
 18104f8:	e0bfff17 	ldw	r2,-4(fp)
 18104fc:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
 1810500:	d0e7d817 	ldw	r3,-24736(gp)
 1810504:	e0bfff17 	ldw	r2,-4(fp)
 1810508:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
 181050c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1810510:	10000126 	beq	r2,zero,1810518 <vTaskSetTimeOutState+0x44>
 1810514:	18110840 	call	1811084 <vTaskExitCritical>
}
 1810518:	0001883a 	nop
 181051c:	e037883a 	mov	sp,fp
 1810520:	dfc00117 	ldw	ra,4(sp)
 1810524:	df000017 	ldw	fp,0(sp)
 1810528:	dec00204 	addi	sp,sp,8
 181052c:	f800283a 	ret

01810530 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 1810530:	defffe04 	addi	sp,sp,-8
 1810534:	df000115 	stw	fp,4(sp)
 1810538:	df000104 	addi	fp,sp,4
 181053c:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 1810540:	d0e7dd17 	ldw	r3,-24716(gp)
 1810544:	e0bfff17 	ldw	r2,-4(fp)
 1810548:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 181054c:	d0e7d817 	ldw	r3,-24736(gp)
 1810550:	e0bfff17 	ldw	r2,-4(fp)
 1810554:	10c00115 	stw	r3,4(r2)
}
 1810558:	0001883a 	nop
 181055c:	e037883a 	mov	sp,fp
 1810560:	df000017 	ldw	fp,0(sp)
 1810564:	dec00104 	addi	sp,sp,4
 1810568:	f800283a 	ret

0181056c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 181056c:	defff904 	addi	sp,sp,-28
 1810570:	dfc00615 	stw	ra,24(sp)
 1810574:	df000515 	stw	fp,20(sp)
 1810578:	df000504 	addi	fp,sp,20
 181057c:	e13ffe15 	stw	r4,-8(fp)
 1810580:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 1810584:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1810588:	10000126 	beq	r2,zero,1810590 <xTaskCheckForTimeOut+0x24>
 181058c:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 1810590:	d0a7d817 	ldw	r2,-24736(gp)
 1810594:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 1810598:	e0bffe17 	ldw	r2,-8(fp)
 181059c:	10800117 	ldw	r2,4(r2)
 18105a0:	e0fffc17 	ldw	r3,-16(fp)
 18105a4:	1885c83a 	sub	r2,r3,r2
 18105a8:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 18105ac:	e0bfff17 	ldw	r2,-4(fp)
 18105b0:	10800017 	ldw	r2,0(r2)
 18105b4:	10bfffd8 	cmpnei	r2,r2,-1
 18105b8:	1000021e 	bne	r2,zero,18105c4 <xTaskCheckForTimeOut+0x58>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 18105bc:	e03ffb15 	stw	zero,-20(fp)
 18105c0:	00001d06 	br	1810638 <xTaskCheckForTimeOut+0xcc>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 18105c4:	e0bffe17 	ldw	r2,-8(fp)
 18105c8:	10c00017 	ldw	r3,0(r2)
 18105cc:	d0a7dd17 	ldw	r2,-24716(gp)
 18105d0:	18800726 	beq	r3,r2,18105f0 <xTaskCheckForTimeOut+0x84>
 18105d4:	e0bffe17 	ldw	r2,-8(fp)
 18105d8:	10800117 	ldw	r2,4(r2)
 18105dc:	e0fffc17 	ldw	r3,-16(fp)
 18105e0:	18800336 	bltu	r3,r2,18105f0 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 18105e4:	00800044 	movi	r2,1
 18105e8:	e0bffb15 	stw	r2,-20(fp)
 18105ec:	00001206 	br	1810638 <xTaskCheckForTimeOut+0xcc>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 18105f0:	e0bfff17 	ldw	r2,-4(fp)
 18105f4:	10800017 	ldw	r2,0(r2)
 18105f8:	e0fffd17 	ldw	r3,-12(fp)
 18105fc:	18800a2e 	bgeu	r3,r2,1810628 <xTaskCheckForTimeOut+0xbc>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 1810600:	e0bfff17 	ldw	r2,-4(fp)
 1810604:	10c00017 	ldw	r3,0(r2)
 1810608:	e0bffd17 	ldw	r2,-12(fp)
 181060c:	1887c83a 	sub	r3,r3,r2
 1810610:	e0bfff17 	ldw	r2,-4(fp)
 1810614:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
 1810618:	e13ffe17 	ldw	r4,-8(fp)
 181061c:	18105300 	call	1810530 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 1810620:	e03ffb15 	stw	zero,-20(fp)
 1810624:	00000406 	br	1810638 <xTaskCheckForTimeOut+0xcc>
		}
		else
		{
			*pxTicksToWait = 0;
 1810628:	e0bfff17 	ldw	r2,-4(fp)
 181062c:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
 1810630:	00800044 	movi	r2,1
 1810634:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
 1810638:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181063c:	10000126 	beq	r2,zero,1810644 <xTaskCheckForTimeOut+0xd8>
 1810640:	18110840 	call	1811084 <vTaskExitCritical>

	return xReturn;
 1810644:	e0bffb17 	ldw	r2,-20(fp)
}
 1810648:	e037883a 	mov	sp,fp
 181064c:	dfc00117 	ldw	ra,4(sp)
 1810650:	df000017 	ldw	fp,0(sp)
 1810654:	dec00204 	addi	sp,sp,8
 1810658:	f800283a 	ret

0181065c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 181065c:	deffff04 	addi	sp,sp,-4
 1810660:	df000015 	stw	fp,0(sp)
 1810664:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 1810668:	00800044 	movi	r2,1
 181066c:	d0a7dc15 	stw	r2,-24720(gp)
}
 1810670:	0001883a 	nop
 1810674:	e037883a 	mov	sp,fp
 1810678:	df000017 	ldw	fp,0(sp)
 181067c:	dec00104 	addi	sp,sp,4
 1810680:	f800283a 	ret

01810684 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
 1810684:	defffc04 	addi	sp,sp,-16
 1810688:	df000315 	stw	fp,12(sp)
 181068c:	df000304 	addi	fp,sp,12
 1810690:	e13fff15 	stw	r4,-4(fp)
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
 1810694:	e0bfff17 	ldw	r2,-4(fp)
 1810698:	10000626 	beq	r2,zero,18106b4 <uxTaskGetTaskNumber+0x30>
		{
			pxTCB = xTask;
 181069c:	e0bfff17 	ldw	r2,-4(fp)
 18106a0:	e0bffe15 	stw	r2,-8(fp)
			uxReturn = pxTCB->uxTaskNumber;
 18106a4:	e0bffe17 	ldw	r2,-8(fp)
 18106a8:	10801917 	ldw	r2,100(r2)
 18106ac:	e0bffd15 	stw	r2,-12(fp)
 18106b0:	00000106 	br	18106b8 <uxTaskGetTaskNumber+0x34>
		}
		else
		{
			uxReturn = 0U;
 18106b4:	e03ffd15 	stw	zero,-12(fp)
		}

		return uxReturn;
 18106b8:	e0bffd17 	ldw	r2,-12(fp)
	}
 18106bc:	e037883a 	mov	sp,fp
 18106c0:	df000017 	ldw	fp,0(sp)
 18106c4:	dec00104 	addi	sp,sp,4
 18106c8:	f800283a 	ret

018106cc <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
 18106cc:	defffc04 	addi	sp,sp,-16
 18106d0:	df000315 	stw	fp,12(sp)
 18106d4:	df000304 	addi	fp,sp,12
 18106d8:	e13ffe15 	stw	r4,-8(fp)
 18106dc:	e17fff15 	stw	r5,-4(fp)
	TCB_t * pxTCB;

		if( xTask != NULL )
 18106e0:	e0bffe17 	ldw	r2,-8(fp)
 18106e4:	10000526 	beq	r2,zero,18106fc <vTaskSetTaskNumber+0x30>
		{
			pxTCB = xTask;
 18106e8:	e0bffe17 	ldw	r2,-8(fp)
 18106ec:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->uxTaskNumber = uxHandle;
 18106f0:	e0bffd17 	ldw	r2,-12(fp)
 18106f4:	e0ffff17 	ldw	r3,-4(fp)
 18106f8:	10c01915 	stw	r3,100(r2)
		}
	}
 18106fc:	0001883a 	nop
 1810700:	e037883a 	mov	sp,fp
 1810704:	df000017 	ldw	fp,0(sp)
 1810708:	dec00104 	addi	sp,sp,4
 181070c:	f800283a 	ret

01810710 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 1810710:	defffd04 	addi	sp,sp,-12
 1810714:	dfc00215 	stw	ra,8(sp)
 1810718:	df000115 	stw	fp,4(sp)
 181071c:	df000104 	addi	fp,sp,4
 1810720:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 1810724:	18107e40 	call	18107e4 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 1810728:	003ffe06 	br	1810724 <__ram_exceptions_end+0xff8002e0>

0181072c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 181072c:	defffd04 	addi	sp,sp,-12
 1810730:	dfc00215 	stw	ra,8(sp)
 1810734:	df000115 	stw	fp,4(sp)
 1810738:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 181073c:	e03fff15 	stw	zero,-4(fp)
 1810740:	00000a06 	br	181076c <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 1810744:	e0bfff17 	ldw	r2,-4(fp)
 1810748:	10c00524 	muli	r3,r2,20
 181074c:	00806134 	movhi	r2,388
 1810750:	109f7f04 	addi	r2,r2,32252
 1810754:	1885883a 	add	r2,r3,r2
 1810758:	1009883a 	mov	r4,r2
 181075c:	18273040 	call	1827304 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 1810760:	e0bfff17 	ldw	r2,-4(fp)
 1810764:	10800044 	addi	r2,r2,1
 1810768:	e0bfff15 	stw	r2,-4(fp)
 181076c:	e0bfff17 	ldw	r2,-4(fp)
 1810770:	10800170 	cmpltui	r2,r2,5
 1810774:	103ff31e 	bne	r2,zero,1810744 <__ram_exceptions_end+0xff800300>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 1810778:	01006134 	movhi	r4,388
 181077c:	211f9804 	addi	r4,r4,32352
 1810780:	18273040 	call	1827304 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 1810784:	01006134 	movhi	r4,388
 1810788:	211f9d04 	addi	r4,r4,32372
 181078c:	18273040 	call	1827304 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 1810790:	01006134 	movhi	r4,388
 1810794:	211fa204 	addi	r4,r4,32392
 1810798:	18273040 	call	1827304 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 181079c:	01006134 	movhi	r4,388
 18107a0:	211fa704 	addi	r4,r4,32412
 18107a4:	18273040 	call	1827304 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 18107a8:	01006134 	movhi	r4,388
 18107ac:	211fac04 	addi	r4,r4,32432
 18107b0:	18273040 	call	1827304 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 18107b4:	00806134 	movhi	r2,388
 18107b8:	109f9804 	addi	r2,r2,32352
 18107bc:	d0a7d415 	stw	r2,-24752(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 18107c0:	00806134 	movhi	r2,388
 18107c4:	109f9d04 	addi	r2,r2,32372
 18107c8:	d0a7d515 	stw	r2,-24748(gp)
}
 18107cc:	0001883a 	nop
 18107d0:	e037883a 	mov	sp,fp
 18107d4:	dfc00117 	ldw	ra,4(sp)
 18107d8:	df000017 	ldw	fp,0(sp)
 18107dc:	dec00204 	addi	sp,sp,8
 18107e0:	f800283a 	ret

018107e4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 18107e4:	defffd04 	addi	sp,sp,-12
 18107e8:	dfc00215 	stw	ra,8(sp)
 18107ec:	df000115 	stw	fp,4(sp)
 18107f0:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 18107f4:	00001706 	br	1810854 <prvCheckTasksWaitingTermination+0x70>
		{
			taskENTER_CRITICAL();
 18107f8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18107fc:	10000126 	beq	r2,zero,1810804 <prvCheckTasksWaitingTermination+0x20>
 1810800:	181103c0 	call	181103c <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1810804:	00806134 	movhi	r2,388
 1810808:	109fa704 	addi	r2,r2,32412
 181080c:	10800317 	ldw	r2,12(r2)
 1810810:	10800317 	ldw	r2,12(r2)
 1810814:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1810818:	e0bfff17 	ldw	r2,-4(fp)
 181081c:	10800104 	addi	r2,r2,4
 1810820:	1009883a 	mov	r4,r2
 1810824:	18274fc0 	call	18274fc <uxListRemove>
				--uxCurrentNumberOfTasks;
 1810828:	d0a7d717 	ldw	r2,-24740(gp)
 181082c:	10bfffc4 	addi	r2,r2,-1
 1810830:	d0a7d715 	stw	r2,-24740(gp)
				--uxDeletedTasksWaitingCleanUp;
 1810834:	d0a7d617 	ldw	r2,-24744(gp)
 1810838:	10bfffc4 	addi	r2,r2,-1
 181083c:	d0a7d615 	stw	r2,-24744(gp)
			}
			taskEXIT_CRITICAL();
 1810840:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1810844:	10000126 	beq	r2,zero,181084c <prvCheckTasksWaitingTermination+0x68>
 1810848:	18110840 	call	1811084 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
 181084c:	e13fff17 	ldw	r4,-4(fp)
 1810850:	1810bb40 	call	1810bb4 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1810854:	d0a7d617 	ldw	r2,-24744(gp)
 1810858:	103fe71e 	bne	r2,zero,18107f8 <__ram_exceptions_end+0xff8003b4>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 181085c:	0001883a 	nop
 1810860:	e037883a 	mov	sp,fp
 1810864:	dfc00117 	ldw	ra,4(sp)
 1810868:	df000017 	ldw	fp,0(sp)
 181086c:	dec00204 	addi	sp,sp,8
 1810870:	f800283a 	ret

01810874 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
 1810874:	defff904 	addi	sp,sp,-28
 1810878:	dfc00615 	stw	ra,24(sp)
 181087c:	df000515 	stw	fp,20(sp)
 1810880:	df000504 	addi	fp,sp,20
 1810884:	e13ffc15 	stw	r4,-16(fp)
 1810888:	e17ffd15 	stw	r5,-12(fp)
 181088c:	e1bffe15 	stw	r6,-8(fp)
 1810890:	e1ffff15 	stw	r7,-4(fp)
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
 1810894:	e0bffc17 	ldw	r2,-16(fp)
 1810898:	1000021e 	bne	r2,zero,18108a4 <vTaskGetInfo+0x30>
 181089c:	d0a7d317 	ldw	r2,-24756(gp)
 18108a0:	00000106 	br	18108a8 <vTaskGetInfo+0x34>
 18108a4:	e0bffc17 	ldw	r2,-16(fp)
 18108a8:	e0bffb15 	stw	r2,-20(fp)

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 18108ac:	e0bffd17 	ldw	r2,-12(fp)
 18108b0:	e0fffb17 	ldw	r3,-20(fp)
 18108b4:	10c00015 	stw	r3,0(r2)
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 18108b8:	e0bffb17 	ldw	r2,-20(fp)
 18108bc:	10c00d04 	addi	r3,r2,52
 18108c0:	e0bffd17 	ldw	r2,-12(fp)
 18108c4:	10c00115 	stw	r3,4(r2)
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 18108c8:	e0bffb17 	ldw	r2,-20(fp)
 18108cc:	10c00b17 	ldw	r3,44(r2)
 18108d0:	e0bffd17 	ldw	r2,-12(fp)
 18108d4:	10c00415 	stw	r3,16(r2)
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 18108d8:	e0bffb17 	ldw	r2,-20(fp)
 18108dc:	10c00c17 	ldw	r3,48(r2)
 18108e0:	e0bffd17 	ldw	r2,-12(fp)
 18108e4:	10c00715 	stw	r3,28(r2)
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 18108e8:	e0bffb17 	ldw	r2,-20(fp)
 18108ec:	10c01817 	ldw	r3,96(r2)
 18108f0:	e0bffd17 	ldw	r2,-12(fp)
 18108f4:	10c00215 	stw	r3,8(r2)

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 18108f8:	e0bffb17 	ldw	r2,-20(fp)
 18108fc:	10c01a17 	ldw	r3,104(r2)
 1810900:	e0bffd17 	ldw	r2,-12(fp)
 1810904:	10c00515 	stw	r3,20(r2)
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
 1810908:	e0bffd17 	ldw	r2,-12(fp)
 181090c:	10000615 	stw	zero,24(r2)
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
 1810910:	e0bfff17 	ldw	r2,-4(fp)
 1810914:	10800160 	cmpeqi	r2,r2,5
 1810918:	1000151e 	bne	r2,zero,1810970 <vTaskGetInfo+0xfc>
		{
			if( pxTCB == pxCurrentTCB )
 181091c:	d0a7d317 	ldw	r2,-24756(gp)
 1810920:	e0fffb17 	ldw	r3,-20(fp)
 1810924:	1880031e 	bne	r3,r2,1810934 <vTaskGetInfo+0xc0>
			{
				pxTaskStatus->eCurrentState = eRunning;
 1810928:	e0bffd17 	ldw	r2,-12(fp)
 181092c:	10000315 	stw	zero,12(r2)
 1810930:	00001406 	br	1810984 <vTaskGetInfo+0x110>
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
 1810934:	e0bffd17 	ldw	r2,-12(fp)
 1810938:	e0ffff17 	ldw	r3,-4(fp)
 181093c:	10c00315 	stw	r3,12(r2)
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
 1810940:	e0bfff17 	ldw	r2,-4(fp)
 1810944:	108000d8 	cmpnei	r2,r2,3
 1810948:	10000e1e 	bne	r2,zero,1810984 <vTaskGetInfo+0x110>
					{
						vTaskSuspendAll();
 181094c:	180fab80 	call	180fab8 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1810950:	e0bffb17 	ldw	r2,-20(fp)
 1810954:	10800a17 	ldw	r2,40(r2)
 1810958:	10000326 	beq	r2,zero,1810968 <vTaskGetInfo+0xf4>
							{
								pxTaskStatus->eCurrentState = eBlocked;
 181095c:	e0bffd17 	ldw	r2,-12(fp)
 1810960:	00c00084 	movi	r3,2
 1810964:	10c00315 	stw	r3,12(r2)
							}
						}
						( void ) xTaskResumeAll();
 1810968:	180fae40 	call	180fae4 <xTaskResumeAll>
 181096c:	00000506 	br	1810984 <vTaskGetInfo+0x110>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 1810970:	e13ffb17 	ldw	r4,-20(fp)
 1810974:	180f3280 	call	180f328 <eTaskGetState>
 1810978:	1007883a 	mov	r3,r2
 181097c:	e0bffd17 	ldw	r2,-12(fp)
 1810980:	10c00315 	stw	r3,12(r2)
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
 1810984:	e0bffe17 	ldw	r2,-8(fp)
 1810988:	10000826 	beq	r2,zero,18109ac <vTaskGetInfo+0x138>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 181098c:	e0bffb17 	ldw	r2,-20(fp)
 1810990:	10800c17 	ldw	r2,48(r2)
 1810994:	1009883a 	mov	r4,r2
 1810998:	1810af40 	call	1810af4 <prvTaskCheckFreeStackSpace>
 181099c:	1007883a 	mov	r3,r2
 18109a0:	e0bffd17 	ldw	r2,-12(fp)
 18109a4:	10c00815 	stw	r3,32(r2)
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
		}
	}
 18109a8:	00000206 	br	18109b4 <vTaskGetInfo+0x140>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
 18109ac:	e0bffd17 	ldw	r2,-12(fp)
 18109b0:	10000815 	stw	zero,32(r2)
		}
	}
 18109b4:	0001883a 	nop
 18109b8:	e037883a 	mov	sp,fp
 18109bc:	dfc00117 	ldw	ra,4(sp)
 18109c0:	df000017 	ldw	fp,0(sp)
 18109c4:	dec00204 	addi	sp,sp,8
 18109c8:	f800283a 	ret

018109cc <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
 18109cc:	defff604 	addi	sp,sp,-40
 18109d0:	dfc00915 	stw	ra,36(sp)
 18109d4:	df000815 	stw	fp,32(sp)
 18109d8:	df000804 	addi	fp,sp,32
 18109dc:	e13ffd15 	stw	r4,-12(fp)
 18109e0:	e17ffe15 	stw	r5,-8(fp)
 18109e4:	e1bfff15 	stw	r6,-4(fp)
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 18109e8:	e03ff815 	stw	zero,-32(fp)

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 18109ec:	e0bffe17 	ldw	r2,-8(fp)
 18109f0:	10800017 	ldw	r2,0(r2)
 18109f4:	10003926 	beq	r2,zero,1810adc <prvListTasksWithinSingleList+0x110>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 18109f8:	e0bffe17 	ldw	r2,-8(fp)
 18109fc:	e0bff915 	stw	r2,-28(fp)
 1810a00:	e0bff917 	ldw	r2,-28(fp)
 1810a04:	10800117 	ldw	r2,4(r2)
 1810a08:	10c00117 	ldw	r3,4(r2)
 1810a0c:	e0bff917 	ldw	r2,-28(fp)
 1810a10:	10c00115 	stw	r3,4(r2)
 1810a14:	e0bff917 	ldw	r2,-28(fp)
 1810a18:	10c00117 	ldw	r3,4(r2)
 1810a1c:	e0bff917 	ldw	r2,-28(fp)
 1810a20:	10800204 	addi	r2,r2,8
 1810a24:	1880051e 	bne	r3,r2,1810a3c <prvListTasksWithinSingleList+0x70>
 1810a28:	e0bff917 	ldw	r2,-28(fp)
 1810a2c:	10800117 	ldw	r2,4(r2)
 1810a30:	10c00117 	ldw	r3,4(r2)
 1810a34:	e0bff917 	ldw	r2,-28(fp)
 1810a38:	10c00115 	stw	r3,4(r2)
 1810a3c:	e0bff917 	ldw	r2,-28(fp)
 1810a40:	10800117 	ldw	r2,4(r2)
 1810a44:	10800317 	ldw	r2,12(r2)
 1810a48:	e0bffa15 	stw	r2,-24(fp)
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1810a4c:	e0bffe17 	ldw	r2,-8(fp)
 1810a50:	e0bffb15 	stw	r2,-20(fp)
 1810a54:	e0bffb17 	ldw	r2,-20(fp)
 1810a58:	10800117 	ldw	r2,4(r2)
 1810a5c:	10c00117 	ldw	r3,4(r2)
 1810a60:	e0bffb17 	ldw	r2,-20(fp)
 1810a64:	10c00115 	stw	r3,4(r2)
 1810a68:	e0bffb17 	ldw	r2,-20(fp)
 1810a6c:	10c00117 	ldw	r3,4(r2)
 1810a70:	e0bffb17 	ldw	r2,-20(fp)
 1810a74:	10800204 	addi	r2,r2,8
 1810a78:	1880051e 	bne	r3,r2,1810a90 <prvListTasksWithinSingleList+0xc4>
 1810a7c:	e0bffb17 	ldw	r2,-20(fp)
 1810a80:	10800117 	ldw	r2,4(r2)
 1810a84:	10c00117 	ldw	r3,4(r2)
 1810a88:	e0bffb17 	ldw	r2,-20(fp)
 1810a8c:	10c00115 	stw	r3,4(r2)
 1810a90:	e0bffb17 	ldw	r2,-20(fp)
 1810a94:	10800117 	ldw	r2,4(r2)
 1810a98:	10800317 	ldw	r2,12(r2)
 1810a9c:	e0bffc15 	stw	r2,-16(fp)
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 1810aa0:	e0bff817 	ldw	r2,-32(fp)
 1810aa4:	10800924 	muli	r2,r2,36
 1810aa8:	e0fffd17 	ldw	r3,-12(fp)
 1810aac:	1885883a 	add	r2,r3,r2
 1810ab0:	e1ffff17 	ldw	r7,-4(fp)
 1810ab4:	01800044 	movi	r6,1
 1810ab8:	100b883a 	mov	r5,r2
 1810abc:	e13ffc17 	ldw	r4,-16(fp)
 1810ac0:	18108740 	call	1810874 <vTaskGetInfo>
				uxTask++;
 1810ac4:	e0bff817 	ldw	r2,-32(fp)
 1810ac8:	10800044 	addi	r2,r2,1
 1810acc:	e0bff815 	stw	r2,-32(fp)
			} while( pxNextTCB != pxFirstTCB );
 1810ad0:	e0fffc17 	ldw	r3,-16(fp)
 1810ad4:	e0bffa17 	ldw	r2,-24(fp)
 1810ad8:	18bfdc1e 	bne	r3,r2,1810a4c <__ram_exceptions_end+0xff800608>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
 1810adc:	e0bff817 	ldw	r2,-32(fp)
	}
 1810ae0:	e037883a 	mov	sp,fp
 1810ae4:	dfc00117 	ldw	ra,4(sp)
 1810ae8:	df000017 	ldw	fp,0(sp)
 1810aec:	dec00204 	addi	sp,sp,8
 1810af0:	f800283a 	ret

01810af4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 1810af4:	defffd04 	addi	sp,sp,-12
 1810af8:	df000215 	stw	fp,8(sp)
 1810afc:	df000204 	addi	fp,sp,8
 1810b00:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 1810b04:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 1810b08:	00000606 	br	1810b24 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 1810b0c:	e0bfff17 	ldw	r2,-4(fp)
 1810b10:	10800044 	addi	r2,r2,1
 1810b14:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 1810b18:	e0bffe17 	ldw	r2,-8(fp)
 1810b1c:	10800044 	addi	r2,r2,1
 1810b20:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 1810b24:	e0bfff17 	ldw	r2,-4(fp)
 1810b28:	10800003 	ldbu	r2,0(r2)
 1810b2c:	10803fcc 	andi	r2,r2,255
 1810b30:	10802960 	cmpeqi	r2,r2,165
 1810b34:	103ff51e 	bne	r2,zero,1810b0c <__ram_exceptions_end+0xff8006c8>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 1810b38:	e0bffe17 	ldw	r2,-8(fp)
 1810b3c:	1004d0ba 	srli	r2,r2,2
 1810b40:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
 1810b44:	e0bffe17 	ldw	r2,-8(fp)
	}
 1810b48:	e037883a 	mov	sp,fp
 1810b4c:	df000017 	ldw	fp,0(sp)
 1810b50:	dec00104 	addi	sp,sp,4
 1810b54:	f800283a 	ret

01810b58 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 1810b58:	defffa04 	addi	sp,sp,-24
 1810b5c:	dfc00515 	stw	ra,20(sp)
 1810b60:	df000415 	stw	fp,16(sp)
 1810b64:	df000404 	addi	fp,sp,16
 1810b68:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 1810b6c:	e0bfff17 	ldw	r2,-4(fp)
 1810b70:	1000021e 	bne	r2,zero,1810b7c <uxTaskGetStackHighWaterMark+0x24>
 1810b74:	d0a7d317 	ldw	r2,-24756(gp)
 1810b78:	00000106 	br	1810b80 <uxTaskGetStackHighWaterMark+0x28>
 1810b7c:	e0bfff17 	ldw	r2,-4(fp)
 1810b80:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 1810b84:	e0bffc17 	ldw	r2,-16(fp)
 1810b88:	10800c17 	ldw	r2,48(r2)
 1810b8c:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 1810b90:	e13ffd17 	ldw	r4,-12(fp)
 1810b94:	1810af40 	call	1810af4 <prvTaskCheckFreeStackSpace>
 1810b98:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 1810b9c:	e0bffe17 	ldw	r2,-8(fp)
	}
 1810ba0:	e037883a 	mov	sp,fp
 1810ba4:	dfc00117 	ldw	ra,4(sp)
 1810ba8:	df000017 	ldw	fp,0(sp)
 1810bac:	dec00204 	addi	sp,sp,8
 1810bb0:	f800283a 	ret

01810bb4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 1810bb4:	defffd04 	addi	sp,sp,-12
 1810bb8:	dfc00215 	stw	ra,8(sp)
 1810bbc:	df000115 	stw	fp,4(sp)
 1810bc0:	df000104 	addi	fp,sp,4
 1810bc4:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 1810bc8:	e0bfff17 	ldw	r2,-4(fp)
 1810bcc:	10800c17 	ldw	r2,48(r2)
 1810bd0:	1009883a 	mov	r4,r2
 1810bd4:	18272c00 	call	18272c0 <vPortFree>
			vPortFree( pxTCB );
 1810bd8:	e13fff17 	ldw	r4,-4(fp)
 1810bdc:	18272c00 	call	18272c0 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 1810be0:	0001883a 	nop
 1810be4:	e037883a 	mov	sp,fp
 1810be8:	dfc00117 	ldw	ra,4(sp)
 1810bec:	df000017 	ldw	fp,0(sp)
 1810bf0:	dec00204 	addi	sp,sp,8
 1810bf4:	f800283a 	ret

01810bf8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 1810bf8:	defffe04 	addi	sp,sp,-8
 1810bfc:	df000115 	stw	fp,4(sp)
 1810c00:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1810c04:	d0a7d417 	ldw	r2,-24752(gp)
 1810c08:	10800017 	ldw	r2,0(r2)
 1810c0c:	1000031e 	bne	r2,zero,1810c1c <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 1810c10:	00bfffc4 	movi	r2,-1
 1810c14:	d0a7df15 	stw	r2,-24708(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 1810c18:	00000706 	br	1810c38 <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1810c1c:	d0a7d417 	ldw	r2,-24752(gp)
 1810c20:	10800317 	ldw	r2,12(r2)
 1810c24:	10800317 	ldw	r2,12(r2)
 1810c28:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 1810c2c:	e0bfff17 	ldw	r2,-4(fp)
 1810c30:	10800117 	ldw	r2,4(r2)
 1810c34:	d0a7df15 	stw	r2,-24708(gp)
	}
}
 1810c38:	0001883a 	nop
 1810c3c:	e037883a 	mov	sp,fp
 1810c40:	df000017 	ldw	fp,0(sp)
 1810c44:	dec00104 	addi	sp,sp,4
 1810c48:	f800283a 	ret

01810c4c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 1810c4c:	defffe04 	addi	sp,sp,-8
 1810c50:	df000115 	stw	fp,4(sp)
 1810c54:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 1810c58:	d0a7d317 	ldw	r2,-24756(gp)
 1810c5c:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 1810c60:	e0bfff17 	ldw	r2,-4(fp)
	}
 1810c64:	e037883a 	mov	sp,fp
 1810c68:	df000017 	ldw	fp,0(sp)
 1810c6c:	dec00104 	addi	sp,sp,4
 1810c70:	f800283a 	ret

01810c74 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 1810c74:	defffe04 	addi	sp,sp,-8
 1810c78:	df000115 	stw	fp,4(sp)
 1810c7c:	df000104 	addi	fp,sp,4
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 1810c80:	d0a7da17 	ldw	r2,-24728(gp)
 1810c84:	1000031e 	bne	r2,zero,1810c94 <xTaskGetSchedulerState+0x20>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 1810c88:	00800044 	movi	r2,1
 1810c8c:	e0bfff15 	stw	r2,-4(fp)
 1810c90:	00000606 	br	1810cac <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1810c94:	d0a7e117 	ldw	r2,-24700(gp)
 1810c98:	1000031e 	bne	r2,zero,1810ca8 <xTaskGetSchedulerState+0x34>
			{
				xReturn = taskSCHEDULER_RUNNING;
 1810c9c:	00800084 	movi	r2,2
 1810ca0:	e0bfff15 	stw	r2,-4(fp)
 1810ca4:	00000106 	br	1810cac <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 1810ca8:	e03fff15 	stw	zero,-4(fp)
			}
		}

		return xReturn;
 1810cac:	e0bfff17 	ldw	r2,-4(fp)
	}
 1810cb0:	e037883a 	mov	sp,fp
 1810cb4:	df000017 	ldw	fp,0(sp)
 1810cb8:	dec00104 	addi	sp,sp,4
 1810cbc:	f800283a 	ret

01810cc0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 1810cc0:	defffb04 	addi	sp,sp,-20
 1810cc4:	dfc00415 	stw	ra,16(sp)
 1810cc8:	df000315 	stw	fp,12(sp)
 1810ccc:	df000304 	addi	fp,sp,12
 1810cd0:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 1810cd4:	e0bfff17 	ldw	r2,-4(fp)
 1810cd8:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1810cdc:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 1810ce0:	e0bfff17 	ldw	r2,-4(fp)
 1810ce4:	10004026 	beq	r2,zero,1810de8 <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 1810ce8:	e0bffe17 	ldw	r2,-8(fp)
 1810cec:	10c00b17 	ldw	r3,44(r2)
 1810cf0:	d0a7d317 	ldw	r2,-24756(gp)
 1810cf4:	10800b17 	ldw	r2,44(r2)
 1810cf8:	1880342e 	bgeu	r3,r2,1810dcc <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1810cfc:	e0bffe17 	ldw	r2,-8(fp)
 1810d00:	10800617 	ldw	r2,24(r2)
 1810d04:	10000616 	blt	r2,zero,1810d20 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1810d08:	d0a7d317 	ldw	r2,-24756(gp)
 1810d0c:	10800b17 	ldw	r2,44(r2)
 1810d10:	00c00144 	movi	r3,5
 1810d14:	1887c83a 	sub	r3,r3,r2
 1810d18:	e0bffe17 	ldw	r2,-8(fp)
 1810d1c:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 1810d20:	e0bffe17 	ldw	r2,-8(fp)
 1810d24:	10c00517 	ldw	r3,20(r2)
 1810d28:	e0bffe17 	ldw	r2,-8(fp)
 1810d2c:	10800b17 	ldw	r2,44(r2)
 1810d30:	11000524 	muli	r4,r2,20
 1810d34:	00806134 	movhi	r2,388
 1810d38:	109f7f04 	addi	r2,r2,32252
 1810d3c:	2085883a 	add	r2,r4,r2
 1810d40:	18801b1e 	bne	r3,r2,1810db0 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1810d44:	e0bffe17 	ldw	r2,-8(fp)
 1810d48:	10800104 	addi	r2,r2,4
 1810d4c:	1009883a 	mov	r4,r2
 1810d50:	18274fc0 	call	18274fc <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 1810d54:	d0a7d317 	ldw	r2,-24756(gp)
 1810d58:	10c00b17 	ldw	r3,44(r2)
 1810d5c:	e0bffe17 	ldw	r2,-8(fp)
 1810d60:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
 1810d64:	e0bffe17 	ldw	r2,-8(fp)
 1810d68:	10800b17 	ldw	r2,44(r2)
 1810d6c:	d0e7d917 	ldw	r3,-24732(gp)
 1810d70:	1880032e 	bgeu	r3,r2,1810d80 <xTaskPriorityInherit+0xc0>
 1810d74:	e0bffe17 	ldw	r2,-8(fp)
 1810d78:	10800b17 	ldw	r2,44(r2)
 1810d7c:	d0a7d915 	stw	r2,-24732(gp)
 1810d80:	e0bffe17 	ldw	r2,-8(fp)
 1810d84:	10800b17 	ldw	r2,44(r2)
 1810d88:	10c00524 	muli	r3,r2,20
 1810d8c:	00806134 	movhi	r2,388
 1810d90:	109f7f04 	addi	r2,r2,32252
 1810d94:	1887883a 	add	r3,r3,r2
 1810d98:	e0bffe17 	ldw	r2,-8(fp)
 1810d9c:	10800104 	addi	r2,r2,4
 1810da0:	100b883a 	mov	r5,r2
 1810da4:	1809883a 	mov	r4,r3
 1810da8:	18273980 	call	1827398 <vListInsertEnd>
 1810dac:	00000406 	br	1810dc0 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 1810db0:	d0a7d317 	ldw	r2,-24756(gp)
 1810db4:	10c00b17 	ldw	r3,44(r2)
 1810db8:	e0bffe17 	ldw	r2,-8(fp)
 1810dbc:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 1810dc0:	00800044 	movi	r2,1
 1810dc4:	e0bffd15 	stw	r2,-12(fp)
 1810dc8:	00000706 	br	1810de8 <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 1810dcc:	e0bffe17 	ldw	r2,-8(fp)
 1810dd0:	10c01a17 	ldw	r3,104(r2)
 1810dd4:	d0a7d317 	ldw	r2,-24756(gp)
 1810dd8:	10800b17 	ldw	r2,44(r2)
 1810ddc:	1880022e 	bgeu	r3,r2,1810de8 <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 1810de0:	00800044 	movi	r2,1
 1810de4:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1810de8:	e0bffd17 	ldw	r2,-12(fp)
	}
 1810dec:	e037883a 	mov	sp,fp
 1810df0:	dfc00117 	ldw	ra,4(sp)
 1810df4:	df000017 	ldw	fp,0(sp)
 1810df8:	dec00204 	addi	sp,sp,8
 1810dfc:	f800283a 	ret

01810e00 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 1810e00:	defffb04 	addi	sp,sp,-20
 1810e04:	dfc00415 	stw	ra,16(sp)
 1810e08:	df000315 	stw	fp,12(sp)
 1810e0c:	df000304 	addi	fp,sp,12
 1810e10:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1810e14:	e0bfff17 	ldw	r2,-4(fp)
 1810e18:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1810e1c:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 1810e20:	e0bfff17 	ldw	r2,-4(fp)
 1810e24:	10002f26 	beq	r2,zero,1810ee4 <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 1810e28:	e0bffe17 	ldw	r2,-8(fp)
 1810e2c:	10801b17 	ldw	r2,108(r2)
 1810e30:	10ffffc4 	addi	r3,r2,-1
 1810e34:	e0bffe17 	ldw	r2,-8(fp)
 1810e38:	10c01b15 	stw	r3,108(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 1810e3c:	e0bffe17 	ldw	r2,-8(fp)
 1810e40:	10c00b17 	ldw	r3,44(r2)
 1810e44:	e0bffe17 	ldw	r2,-8(fp)
 1810e48:	10801a17 	ldw	r2,104(r2)
 1810e4c:	18802526 	beq	r3,r2,1810ee4 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 1810e50:	e0bffe17 	ldw	r2,-8(fp)
 1810e54:	10801b17 	ldw	r2,108(r2)
 1810e58:	1000221e 	bne	r2,zero,1810ee4 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1810e5c:	e0bffe17 	ldw	r2,-8(fp)
 1810e60:	10800104 	addi	r2,r2,4
 1810e64:	1009883a 	mov	r4,r2
 1810e68:	18274fc0 	call	18274fc <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 1810e6c:	e0bffe17 	ldw	r2,-8(fp)
 1810e70:	10c01a17 	ldw	r3,104(r2)
 1810e74:	e0bffe17 	ldw	r2,-8(fp)
 1810e78:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1810e7c:	e0bffe17 	ldw	r2,-8(fp)
 1810e80:	10800b17 	ldw	r2,44(r2)
 1810e84:	00c00144 	movi	r3,5
 1810e88:	1887c83a 	sub	r3,r3,r2
 1810e8c:	e0bffe17 	ldw	r2,-8(fp)
 1810e90:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 1810e94:	e0bffe17 	ldw	r2,-8(fp)
 1810e98:	10800b17 	ldw	r2,44(r2)
 1810e9c:	d0e7d917 	ldw	r3,-24732(gp)
 1810ea0:	1880032e 	bgeu	r3,r2,1810eb0 <xTaskPriorityDisinherit+0xb0>
 1810ea4:	e0bffe17 	ldw	r2,-8(fp)
 1810ea8:	10800b17 	ldw	r2,44(r2)
 1810eac:	d0a7d915 	stw	r2,-24732(gp)
 1810eb0:	e0bffe17 	ldw	r2,-8(fp)
 1810eb4:	10800b17 	ldw	r2,44(r2)
 1810eb8:	10c00524 	muli	r3,r2,20
 1810ebc:	00806134 	movhi	r2,388
 1810ec0:	109f7f04 	addi	r2,r2,32252
 1810ec4:	1887883a 	add	r3,r3,r2
 1810ec8:	e0bffe17 	ldw	r2,-8(fp)
 1810ecc:	10800104 	addi	r2,r2,4
 1810ed0:	100b883a 	mov	r5,r2
 1810ed4:	1809883a 	mov	r4,r3
 1810ed8:	18273980 	call	1827398 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 1810edc:	00800044 	movi	r2,1
 1810ee0:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1810ee4:	e0bffd17 	ldw	r2,-12(fp)
	}
 1810ee8:	e037883a 	mov	sp,fp
 1810eec:	dfc00117 	ldw	ra,4(sp)
 1810ef0:	df000017 	ldw	fp,0(sp)
 1810ef4:	dec00204 	addi	sp,sp,8
 1810ef8:	f800283a 	ret

01810efc <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 1810efc:	defff804 	addi	sp,sp,-32
 1810f00:	dfc00715 	stw	ra,28(sp)
 1810f04:	df000615 	stw	fp,24(sp)
 1810f08:	df000604 	addi	fp,sp,24
 1810f0c:	e13ffe15 	stw	r4,-8(fp)
 1810f10:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 1810f14:	e0bffe17 	ldw	r2,-8(fp)
 1810f18:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 1810f1c:	00800044 	movi	r2,1
 1810f20:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
 1810f24:	e0bffe17 	ldw	r2,-8(fp)
 1810f28:	10003e26 	beq	r2,zero,1811024 <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 1810f2c:	e0bffb17 	ldw	r2,-20(fp)
 1810f30:	10c01a17 	ldw	r3,104(r2)
 1810f34:	e0bfff17 	ldw	r2,-4(fp)
 1810f38:	1880032e 	bgeu	r3,r2,1810f48 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 1810f3c:	e0bfff17 	ldw	r2,-4(fp)
 1810f40:	e0bffa15 	stw	r2,-24(fp)
 1810f44:	00000306 	br	1810f54 <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 1810f48:	e0bffb17 	ldw	r2,-20(fp)
 1810f4c:	10801a17 	ldw	r2,104(r2)
 1810f50:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 1810f54:	e0bffb17 	ldw	r2,-20(fp)
 1810f58:	10c00b17 	ldw	r3,44(r2)
 1810f5c:	e0bffa17 	ldw	r2,-24(fp)
 1810f60:	18803026 	beq	r3,r2,1811024 <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 1810f64:	e0bffb17 	ldw	r2,-20(fp)
 1810f68:	10c01b17 	ldw	r3,108(r2)
 1810f6c:	e0bffc17 	ldw	r2,-16(fp)
 1810f70:	18802c1e 	bne	r3,r2,1811024 <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1810f74:	e0bffb17 	ldw	r2,-20(fp)
 1810f78:	10800b17 	ldw	r2,44(r2)
 1810f7c:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
 1810f80:	e0bffb17 	ldw	r2,-20(fp)
 1810f84:	e0fffa17 	ldw	r3,-24(fp)
 1810f88:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1810f8c:	e0bffb17 	ldw	r2,-20(fp)
 1810f90:	10800617 	ldw	r2,24(r2)
 1810f94:	10000516 	blt	r2,zero,1810fac <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1810f98:	00c00144 	movi	r3,5
 1810f9c:	e0bffa17 	ldw	r2,-24(fp)
 1810fa0:	1887c83a 	sub	r3,r3,r2
 1810fa4:	e0bffb17 	ldw	r2,-20(fp)
 1810fa8:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1810fac:	e0bffb17 	ldw	r2,-20(fp)
 1810fb0:	10c00517 	ldw	r3,20(r2)
 1810fb4:	e0bffd17 	ldw	r2,-12(fp)
 1810fb8:	11000524 	muli	r4,r2,20
 1810fbc:	00806134 	movhi	r2,388
 1810fc0:	109f7f04 	addi	r2,r2,32252
 1810fc4:	2085883a 	add	r2,r4,r2
 1810fc8:	1880161e 	bne	r3,r2,1811024 <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1810fcc:	e0bffb17 	ldw	r2,-20(fp)
 1810fd0:	10800104 	addi	r2,r2,4
 1810fd4:	1009883a 	mov	r4,r2
 1810fd8:	18274fc0 	call	18274fc <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 1810fdc:	e0bffb17 	ldw	r2,-20(fp)
 1810fe0:	10800b17 	ldw	r2,44(r2)
 1810fe4:	d0e7d917 	ldw	r3,-24732(gp)
 1810fe8:	1880032e 	bgeu	r3,r2,1810ff8 <vTaskPriorityDisinheritAfterTimeout+0xfc>
 1810fec:	e0bffb17 	ldw	r2,-20(fp)
 1810ff0:	10800b17 	ldw	r2,44(r2)
 1810ff4:	d0a7d915 	stw	r2,-24732(gp)
 1810ff8:	e0bffb17 	ldw	r2,-20(fp)
 1810ffc:	10800b17 	ldw	r2,44(r2)
 1811000:	10c00524 	muli	r3,r2,20
 1811004:	00806134 	movhi	r2,388
 1811008:	109f7f04 	addi	r2,r2,32252
 181100c:	1887883a 	add	r3,r3,r2
 1811010:	e0bffb17 	ldw	r2,-20(fp)
 1811014:	10800104 	addi	r2,r2,4
 1811018:	100b883a 	mov	r5,r2
 181101c:	1809883a 	mov	r4,r3
 1811020:	18273980 	call	1827398 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1811024:	0001883a 	nop
 1811028:	e037883a 	mov	sp,fp
 181102c:	dfc00117 	ldw	ra,4(sp)
 1811030:	df000017 	ldw	fp,0(sp)
 1811034:	dec00204 	addi	sp,sp,8
 1811038:	f800283a 	ret

0181103c <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 181103c:	defffe04 	addi	sp,sp,-8
 1811040:	dfc00115 	stw	ra,4(sp)
 1811044:	df000015 	stw	fp,0(sp)
 1811048:	d839883a 	mov	fp,sp
		portDISABLE_INTERRUPTS();
 181104c:	18275c00 	call	18275c0 <enh_alt_irq_disable_all>

		if( xSchedulerRunning != pdFALSE )
 1811050:	d0a7da17 	ldw	r2,-24728(gp)
 1811054:	10000526 	beq	r2,zero,181106c <vTaskEnterCritical+0x30>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 1811058:	d0a7d317 	ldw	r2,-24756(gp)
 181105c:	10c01717 	ldw	r3,92(r2)
 1811060:	18c00044 	addi	r3,r3,1
 1811064:	10c01715 	stw	r3,92(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 1811068:	d0a7d317 	ldw	r2,-24756(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 181106c:	0001883a 	nop
 1811070:	e037883a 	mov	sp,fp
 1811074:	dfc00117 	ldw	ra,4(sp)
 1811078:	df000017 	ldw	fp,0(sp)
 181107c:	dec00204 	addi	sp,sp,8
 1811080:	f800283a 	ret

01811084 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 1811084:	defffe04 	addi	sp,sp,-8
 1811088:	dfc00115 	stw	ra,4(sp)
 181108c:	df000015 	stw	fp,0(sp)
 1811090:	d839883a 	mov	fp,sp
		if( xSchedulerRunning != pdFALSE )
 1811094:	d0a7da17 	ldw	r2,-24728(gp)
 1811098:	10000b26 	beq	r2,zero,18110c8 <vTaskExitCritical+0x44>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 181109c:	d0a7d317 	ldw	r2,-24756(gp)
 18110a0:	10801717 	ldw	r2,92(r2)
 18110a4:	10000826 	beq	r2,zero,18110c8 <vTaskExitCritical+0x44>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 18110a8:	d0a7d317 	ldw	r2,-24756(gp)
 18110ac:	10c01717 	ldw	r3,92(r2)
 18110b0:	18ffffc4 	addi	r3,r3,-1
 18110b4:	10c01715 	stw	r3,92(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 18110b8:	d0a7d317 	ldw	r2,-24756(gp)
 18110bc:	10801717 	ldw	r2,92(r2)
 18110c0:	1000011e 	bne	r2,zero,18110c8 <vTaskExitCritical+0x44>
				{
					portENABLE_INTERRUPTS();
 18110c4:	18276100 	call	1827610 <enh_alt_irq_enable_all>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 18110c8:	0001883a 	nop
 18110cc:	e037883a 	mov	sp,fp
 18110d0:	dfc00117 	ldw	ra,4(sp)
 18110d4:	df000017 	ldw	fp,0(sp)
 18110d8:	dec00204 	addi	sp,sp,8
 18110dc:	f800283a 	ret

018110e0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 18110e0:	defffe04 	addi	sp,sp,-8
 18110e4:	df000115 	stw	fp,4(sp)
 18110e8:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 18110ec:	d0a7d317 	ldw	r2,-24756(gp)
 18110f0:	10800617 	ldw	r2,24(r2)
 18110f4:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 18110f8:	d0a7d317 	ldw	r2,-24756(gp)
 18110fc:	d0e7d317 	ldw	r3,-24756(gp)
 1811100:	18c00b17 	ldw	r3,44(r3)
 1811104:	01000144 	movi	r4,5
 1811108:	20c7c83a 	sub	r3,r4,r3
 181110c:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 1811110:	e0bfff17 	ldw	r2,-4(fp)
}
 1811114:	e037883a 	mov	sp,fp
 1811118:	df000017 	ldw	fp,0(sp)
 181111c:	dec00104 	addi	sp,sp,4
 1811120:	f800283a 	ret

01811124 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 1811124:	deffff04 	addi	sp,sp,-4
 1811128:	df000015 	stw	fp,0(sp)
 181112c:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 1811130:	d0a7d317 	ldw	r2,-24756(gp)
 1811134:	10000426 	beq	r2,zero,1811148 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 1811138:	d0a7d317 	ldw	r2,-24756(gp)
 181113c:	10c01b17 	ldw	r3,108(r2)
 1811140:	18c00044 	addi	r3,r3,1
 1811144:	10c01b15 	stw	r3,108(r2)
		}

		return pxCurrentTCB;
 1811148:	d0a7d317 	ldw	r2,-24756(gp)
	}
 181114c:	e037883a 	mov	sp,fp
 1811150:	df000017 	ldw	fp,0(sp)
 1811154:	dec00104 	addi	sp,sp,4
 1811158:	f800283a 	ret

0181115c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 181115c:	defffb04 	addi	sp,sp,-20
 1811160:	dfc00415 	stw	ra,16(sp)
 1811164:	df000315 	stw	fp,12(sp)
 1811168:	df000304 	addi	fp,sp,12
 181116c:	e13ffe15 	stw	r4,-8(fp)
 1811170:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 1811174:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811178:	10000126 	beq	r2,zero,1811180 <ulTaskNotifyTake+0x24>
 181117c:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 1811180:	d0a7d317 	ldw	r2,-24756(gp)
 1811184:	10801c17 	ldw	r2,112(r2)
 1811188:	1000091e 	bne	r2,zero,18111b0 <ulTaskNotifyTake+0x54>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 181118c:	d0a7d317 	ldw	r2,-24756(gp)
 1811190:	00c00044 	movi	r3,1
 1811194:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1811198:	e0bfff17 	ldw	r2,-4(fp)
 181119c:	10000426 	beq	r2,zero,18111b0 <ulTaskNotifyTake+0x54>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 18111a0:	01400044 	movi	r5,1
 18111a4:	e13fff17 	ldw	r4,-4(fp)
 18111a8:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 18111ac:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 18111b0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18111b4:	10000126 	beq	r2,zero,18111bc <ulTaskNotifyTake+0x60>
 18111b8:	18110840 	call	1811084 <vTaskExitCritical>

		taskENTER_CRITICAL();
 18111bc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18111c0:	10000126 	beq	r2,zero,18111c8 <ulTaskNotifyTake+0x6c>
 18111c4:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 18111c8:	d0a7d317 	ldw	r2,-24756(gp)
 18111cc:	10801c17 	ldw	r2,112(r2)
 18111d0:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 18111d4:	e0bffd17 	ldw	r2,-12(fp)
 18111d8:	10000926 	beq	r2,zero,1811200 <ulTaskNotifyTake+0xa4>
			{
				if( xClearCountOnExit != pdFALSE )
 18111dc:	e0bffe17 	ldw	r2,-8(fp)
 18111e0:	10000326 	beq	r2,zero,18111f0 <ulTaskNotifyTake+0x94>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 18111e4:	d0a7d317 	ldw	r2,-24756(gp)
 18111e8:	10001c15 	stw	zero,112(r2)
 18111ec:	00000406 	br	1811200 <ulTaskNotifyTake+0xa4>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 18111f0:	d0a7d317 	ldw	r2,-24756(gp)
 18111f4:	e0fffd17 	ldw	r3,-12(fp)
 18111f8:	18ffffc4 	addi	r3,r3,-1
 18111fc:	10c01c15 	stw	r3,112(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1811200:	d0a7d317 	ldw	r2,-24756(gp)
 1811204:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 1811208:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181120c:	10000126 	beq	r2,zero,1811214 <ulTaskNotifyTake+0xb8>
 1811210:	18110840 	call	1811084 <vTaskExitCritical>

		return ulReturn;
 1811214:	e0bffd17 	ldw	r2,-12(fp)
	}
 1811218:	e037883a 	mov	sp,fp
 181121c:	dfc00117 	ldw	ra,4(sp)
 1811220:	df000017 	ldw	fp,0(sp)
 1811224:	dec00204 	addi	sp,sp,8
 1811228:	f800283a 	ret

0181122c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 181122c:	defff904 	addi	sp,sp,-28
 1811230:	dfc00615 	stw	ra,24(sp)
 1811234:	df000515 	stw	fp,20(sp)
 1811238:	df000504 	addi	fp,sp,20
 181123c:	e13ffc15 	stw	r4,-16(fp)
 1811240:	e17ffd15 	stw	r5,-12(fp)
 1811244:	e1bffe15 	stw	r6,-8(fp)
 1811248:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 181124c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811250:	10000126 	beq	r2,zero,1811258 <xTaskNotifyWait+0x2c>
 1811254:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 1811258:	d0a7d317 	ldw	r2,-24756(gp)
 181125c:	10801d03 	ldbu	r2,116(r2)
 1811260:	10803fcc 	andi	r2,r2,255
 1811264:	108000a0 	cmpeqi	r2,r2,2
 1811268:	10000f1e 	bne	r2,zero,18112a8 <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 181126c:	d0a7d317 	ldw	r2,-24756(gp)
 1811270:	11001c17 	ldw	r4,112(r2)
 1811274:	e0fffc17 	ldw	r3,-16(fp)
 1811278:	00c6303a 	nor	r3,zero,r3
 181127c:	20c6703a 	and	r3,r4,r3
 1811280:	10c01c15 	stw	r3,112(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 1811284:	d0a7d317 	ldw	r2,-24756(gp)
 1811288:	00c00044 	movi	r3,1
 181128c:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1811290:	e0bfff17 	ldw	r2,-4(fp)
 1811294:	10000426 	beq	r2,zero,18112a8 <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1811298:	01400044 	movi	r5,1
 181129c:	e13fff17 	ldw	r4,-4(fp)
 18112a0:	18119100 	call	1811910 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 18112a4:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 18112a8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18112ac:	10000126 	beq	r2,zero,18112b4 <xTaskNotifyWait+0x88>
 18112b0:	18110840 	call	1811084 <vTaskExitCritical>

		taskENTER_CRITICAL();
 18112b4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18112b8:	10000126 	beq	r2,zero,18112c0 <xTaskNotifyWait+0x94>
 18112bc:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 18112c0:	e0bffe17 	ldw	r2,-8(fp)
 18112c4:	10000426 	beq	r2,zero,18112d8 <xTaskNotifyWait+0xac>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 18112c8:	d0a7d317 	ldw	r2,-24756(gp)
 18112cc:	10c01c17 	ldw	r3,112(r2)
 18112d0:	e0bffe17 	ldw	r2,-8(fp)
 18112d4:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 18112d8:	d0a7d317 	ldw	r2,-24756(gp)
 18112dc:	10801d03 	ldbu	r2,116(r2)
 18112e0:	10803fcc 	andi	r2,r2,255
 18112e4:	108000a0 	cmpeqi	r2,r2,2
 18112e8:	1000021e 	bne	r2,zero,18112f4 <xTaskNotifyWait+0xc8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 18112ec:	e03ffb15 	stw	zero,-20(fp)
 18112f0:	00000806 	br	1811314 <xTaskNotifyWait+0xe8>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 18112f4:	d0a7d317 	ldw	r2,-24756(gp)
 18112f8:	11001c17 	ldw	r4,112(r2)
 18112fc:	e0fffd17 	ldw	r3,-12(fp)
 1811300:	00c6303a 	nor	r3,zero,r3
 1811304:	20c6703a 	and	r3,r4,r3
 1811308:	10c01c15 	stw	r3,112(r2)
				xReturn = pdTRUE;
 181130c:	00800044 	movi	r2,1
 1811310:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1811314:	d0a7d317 	ldw	r2,-24756(gp)
 1811318:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 181131c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811320:	10000126 	beq	r2,zero,1811328 <xTaskNotifyWait+0xfc>
 1811324:	18110840 	call	1811084 <vTaskExitCritical>

		return xReturn;
 1811328:	e0bffb17 	ldw	r2,-20(fp)
	}
 181132c:	e037883a 	mov	sp,fp
 1811330:	dfc00117 	ldw	ra,4(sp)
 1811334:	df000017 	ldw	fp,0(sp)
 1811338:	dec00204 	addi	sp,sp,8
 181133c:	f800283a 	ret

01811340 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 1811340:	defff704 	addi	sp,sp,-36
 1811344:	dfc00815 	stw	ra,32(sp)
 1811348:	df000715 	stw	fp,28(sp)
 181134c:	df000704 	addi	fp,sp,28
 1811350:	e13ffc15 	stw	r4,-16(fp)
 1811354:	e17ffd15 	stw	r5,-12(fp)
 1811358:	e1bffe15 	stw	r6,-8(fp)
 181135c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 1811360:	00800044 	movi	r2,1
 1811364:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
 1811368:	e0bffc17 	ldw	r2,-16(fp)
 181136c:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 1811370:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811374:	10000126 	beq	r2,zero,181137c <xTaskGenericNotify+0x3c>
 1811378:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 181137c:	e0bfff17 	ldw	r2,-4(fp)
 1811380:	10000426 	beq	r2,zero,1811394 <xTaskGenericNotify+0x54>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 1811384:	e0bffa17 	ldw	r2,-24(fp)
 1811388:	10c01c17 	ldw	r3,112(r2)
 181138c:	e0bfff17 	ldw	r2,-4(fp)
 1811390:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1811394:	e0bffa17 	ldw	r2,-24(fp)
 1811398:	10801d03 	ldbu	r2,116(r2)
 181139c:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 18113a0:	e0bffa17 	ldw	r2,-24(fp)
 18113a4:	00c00084 	movi	r3,2
 18113a8:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 18113ac:	e0bffe17 	ldw	r2,-8(fp)
 18113b0:	10800168 	cmpgeui	r2,r2,5
 18113b4:	1000261e 	bne	r2,zero,1811450 <xTaskGenericNotify+0x110>
 18113b8:	e0bffe17 	ldw	r2,-8(fp)
 18113bc:	100690ba 	slli	r3,r2,2
 18113c0:	00806074 	movhi	r2,385
 18113c4:	1084f504 	addi	r2,r2,5076
 18113c8:	1885883a 	add	r2,r3,r2
 18113cc:	10800017 	ldw	r2,0(r2)
 18113d0:	1000683a 	jmp	r2
 18113d4:	01811458 	cmpnei	r6,zero,1105
 18113d8:	018113e8 	cmpgeui	r6,zero,1103
 18113dc:	01811404 	movi	r6,1104
 18113e0:	0181141c 	xori	r6,zero,1104
 18113e4:	0181142c 	andhi	r6,zero,1104
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 18113e8:	e0bffa17 	ldw	r2,-24(fp)
 18113ec:	10c01c17 	ldw	r3,112(r2)
 18113f0:	e0bffd17 	ldw	r2,-12(fp)
 18113f4:	1886b03a 	or	r3,r3,r2
 18113f8:	e0bffa17 	ldw	r2,-24(fp)
 18113fc:	10c01c15 	stw	r3,112(r2)
					break;
 1811400:	00001606 	br	181145c <xTaskGenericNotify+0x11c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 1811404:	e0bffa17 	ldw	r2,-24(fp)
 1811408:	10801c17 	ldw	r2,112(r2)
 181140c:	10c00044 	addi	r3,r2,1
 1811410:	e0bffa17 	ldw	r2,-24(fp)
 1811414:	10c01c15 	stw	r3,112(r2)
					break;
 1811418:	00001006 	br	181145c <xTaskGenericNotify+0x11c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 181141c:	e0bffa17 	ldw	r2,-24(fp)
 1811420:	e0fffd17 	ldw	r3,-12(fp)
 1811424:	10c01c15 	stw	r3,112(r2)
					break;
 1811428:	00000c06 	br	181145c <xTaskGenericNotify+0x11c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 181142c:	e0bffb03 	ldbu	r2,-20(fp)
 1811430:	108000a0 	cmpeqi	r2,r2,2
 1811434:	1000041e 	bne	r2,zero,1811448 <xTaskGenericNotify+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
 1811438:	e0bffa17 	ldw	r2,-24(fp)
 181143c:	e0fffd17 	ldw	r3,-12(fp)
 1811440:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 1811444:	00000506 	br	181145c <xTaskGenericNotify+0x11c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 1811448:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 181144c:	00000306 	br	181145c <xTaskGenericNotify+0x11c>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
 1811450:	0001883a 	nop
 1811454:	00000106 	br	181145c <xTaskGenericNotify+0x11c>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 1811458:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 181145c:	e0bffb03 	ldbu	r2,-20(fp)
 1811460:	10800058 	cmpnei	r2,r2,1
 1811464:	10001c1e 	bne	r2,zero,18114d8 <xTaskGenericNotify+0x198>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1811468:	e0bffa17 	ldw	r2,-24(fp)
 181146c:	10800104 	addi	r2,r2,4
 1811470:	1009883a 	mov	r4,r2
 1811474:	18274fc0 	call	18274fc <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 1811478:	e0bffa17 	ldw	r2,-24(fp)
 181147c:	10800b17 	ldw	r2,44(r2)
 1811480:	d0e7d917 	ldw	r3,-24732(gp)
 1811484:	1880032e 	bgeu	r3,r2,1811494 <xTaskGenericNotify+0x154>
 1811488:	e0bffa17 	ldw	r2,-24(fp)
 181148c:	10800b17 	ldw	r2,44(r2)
 1811490:	d0a7d915 	stw	r2,-24732(gp)
 1811494:	e0bffa17 	ldw	r2,-24(fp)
 1811498:	10800b17 	ldw	r2,44(r2)
 181149c:	10c00524 	muli	r3,r2,20
 18114a0:	00806134 	movhi	r2,388
 18114a4:	109f7f04 	addi	r2,r2,32252
 18114a8:	1887883a 	add	r3,r3,r2
 18114ac:	e0bffa17 	ldw	r2,-24(fp)
 18114b0:	10800104 	addi	r2,r2,4
 18114b4:	100b883a 	mov	r5,r2
 18114b8:	1809883a 	mov	r4,r3
 18114bc:	18273980 	call	1827398 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 18114c0:	e0bffa17 	ldw	r2,-24(fp)
 18114c4:	10800b17 	ldw	r2,44(r2)
 18114c8:	d0e7d317 	ldw	r3,-24756(gp)
 18114cc:	18c00b17 	ldw	r3,44(r3)
 18114d0:	1880012e 	bgeu	r3,r2,18114d8 <xTaskGenericNotify+0x198>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 18114d4:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 18114d8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18114dc:	10000126 	beq	r2,zero,18114e4 <xTaskGenericNotify+0x1a4>
 18114e0:	18110840 	call	1811084 <vTaskExitCritical>

		return xReturn;
 18114e4:	e0bff917 	ldw	r2,-28(fp)
	}
 18114e8:	e037883a 	mov	sp,fp
 18114ec:	dfc00117 	ldw	ra,4(sp)
 18114f0:	df000017 	ldw	fp,0(sp)
 18114f4:	dec00204 	addi	sp,sp,8
 18114f8:	f800283a 	ret

018114fc <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 18114fc:	defff604 	addi	sp,sp,-40
 1811500:	dfc00915 	stw	ra,36(sp)
 1811504:	df000815 	stw	fp,32(sp)
 1811508:	df000804 	addi	fp,sp,32
 181150c:	e13ffc15 	stw	r4,-16(fp)
 1811510:	e17ffd15 	stw	r5,-12(fp)
 1811514:	e1bffe15 	stw	r6,-8(fp)
 1811518:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 181151c:	00800044 	movi	r2,1
 1811520:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 1811524:	e0bffc17 	ldw	r2,-16(fp)
 1811528:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 181152c:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 1811530:	e0bfff17 	ldw	r2,-4(fp)
 1811534:	10000426 	beq	r2,zero,1811548 <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 1811538:	e0bff917 	ldw	r2,-28(fp)
 181153c:	10c01c17 	ldw	r3,112(r2)
 1811540:	e0bfff17 	ldw	r2,-4(fp)
 1811544:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1811548:	e0bff917 	ldw	r2,-28(fp)
 181154c:	10801d03 	ldbu	r2,116(r2)
 1811550:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1811554:	e0bff917 	ldw	r2,-28(fp)
 1811558:	00c00084 	movi	r3,2
 181155c:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 1811560:	e0bffe17 	ldw	r2,-8(fp)
 1811564:	10800168 	cmpgeui	r2,r2,5
 1811568:	1000261e 	bne	r2,zero,1811604 <xTaskGenericNotifyFromISR+0x108>
 181156c:	e0bffe17 	ldw	r2,-8(fp)
 1811570:	100690ba 	slli	r3,r2,2
 1811574:	00806074 	movhi	r2,385
 1811578:	10856204 	addi	r2,r2,5512
 181157c:	1885883a 	add	r2,r3,r2
 1811580:	10800017 	ldw	r2,0(r2)
 1811584:	1000683a 	jmp	r2
 1811588:	0181160c 	andi	r6,zero,1112
 181158c:	0181159c 	xori	r6,zero,1110
 1811590:	018115b8 	rdprs	r6,zero,1110
 1811594:	018115d0 	cmplti	r6,zero,1111
 1811598:	018115e0 	cmpeqi	r6,zero,1111
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 181159c:	e0bff917 	ldw	r2,-28(fp)
 18115a0:	10c01c17 	ldw	r3,112(r2)
 18115a4:	e0bffd17 	ldw	r2,-12(fp)
 18115a8:	1886b03a 	or	r3,r3,r2
 18115ac:	e0bff917 	ldw	r2,-28(fp)
 18115b0:	10c01c15 	stw	r3,112(r2)
					break;
 18115b4:	00001606 	br	1811610 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 18115b8:	e0bff917 	ldw	r2,-28(fp)
 18115bc:	10801c17 	ldw	r2,112(r2)
 18115c0:	10c00044 	addi	r3,r2,1
 18115c4:	e0bff917 	ldw	r2,-28(fp)
 18115c8:	10c01c15 	stw	r3,112(r2)
					break;
 18115cc:	00001006 	br	1811610 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 18115d0:	e0bff917 	ldw	r2,-28(fp)
 18115d4:	e0fffd17 	ldw	r3,-12(fp)
 18115d8:	10c01c15 	stw	r3,112(r2)
					break;
 18115dc:	00000c06 	br	1811610 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 18115e0:	e0bffb03 	ldbu	r2,-20(fp)
 18115e4:	108000a0 	cmpeqi	r2,r2,2
 18115e8:	1000041e 	bne	r2,zero,18115fc <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 18115ec:	e0bff917 	ldw	r2,-28(fp)
 18115f0:	e0fffd17 	ldw	r3,-12(fp)
 18115f4:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 18115f8:	00000506 	br	1811610 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 18115fc:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 1811600:	00000306 	br	1811610 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
 1811604:	0001883a 	nop
 1811608:	00000106 	br	1811610 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 181160c:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1811610:	e0bffb03 	ldbu	r2,-20(fp)
 1811614:	10800058 	cmpnei	r2,r2,1
 1811618:	10002b1e 	bne	r2,zero,18116c8 <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 181161c:	d0a7e117 	ldw	r2,-24700(gp)
 1811620:	1000171e 	bne	r2,zero,1811680 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1811624:	e0bff917 	ldw	r2,-28(fp)
 1811628:	10800104 	addi	r2,r2,4
 181162c:	1009883a 	mov	r4,r2
 1811630:	18274fc0 	call	18274fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1811634:	e0bff917 	ldw	r2,-28(fp)
 1811638:	10800b17 	ldw	r2,44(r2)
 181163c:	d0e7d917 	ldw	r3,-24732(gp)
 1811640:	1880032e 	bgeu	r3,r2,1811650 <xTaskGenericNotifyFromISR+0x154>
 1811644:	e0bff917 	ldw	r2,-28(fp)
 1811648:	10800b17 	ldw	r2,44(r2)
 181164c:	d0a7d915 	stw	r2,-24732(gp)
 1811650:	e0bff917 	ldw	r2,-28(fp)
 1811654:	10800b17 	ldw	r2,44(r2)
 1811658:	10c00524 	muli	r3,r2,20
 181165c:	00806134 	movhi	r2,388
 1811660:	109f7f04 	addi	r2,r2,32252
 1811664:	1887883a 	add	r3,r3,r2
 1811668:	e0bff917 	ldw	r2,-28(fp)
 181166c:	10800104 	addi	r2,r2,4
 1811670:	100b883a 	mov	r5,r2
 1811674:	1809883a 	mov	r4,r3
 1811678:	18273980 	call	1827398 <vListInsertEnd>
 181167c:	00000606 	br	1811698 <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1811680:	e0bff917 	ldw	r2,-28(fp)
 1811684:	10800604 	addi	r2,r2,24
 1811688:	100b883a 	mov	r5,r2
 181168c:	01006134 	movhi	r4,388
 1811690:	211fa204 	addi	r4,r4,32392
 1811694:	18273980 	call	1827398 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 1811698:	e0bff917 	ldw	r2,-28(fp)
 181169c:	10800b17 	ldw	r2,44(r2)
 18116a0:	d0e7d317 	ldw	r3,-24756(gp)
 18116a4:	18c00b17 	ldw	r3,44(r3)
 18116a8:	1880072e 	bgeu	r3,r2,18116c8 <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 18116ac:	e0800217 	ldw	r2,8(fp)
 18116b0:	10000326 	beq	r2,zero,18116c0 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 18116b4:	e0800217 	ldw	r2,8(fp)
 18116b8:	00c00044 	movi	r3,1
 18116bc:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 18116c0:	00800044 	movi	r2,1
 18116c4:	d0a7dc15 	stw	r2,-24720(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 18116c8:	e0bff817 	ldw	r2,-32(fp)
	}
 18116cc:	e037883a 	mov	sp,fp
 18116d0:	dfc00117 	ldw	ra,4(sp)
 18116d4:	df000017 	ldw	fp,0(sp)
 18116d8:	dec00204 	addi	sp,sp,8
 18116dc:	f800283a 	ret

018116e0 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 18116e0:	defff904 	addi	sp,sp,-28
 18116e4:	dfc00615 	stw	ra,24(sp)
 18116e8:	df000515 	stw	fp,20(sp)
 18116ec:	df000504 	addi	fp,sp,20
 18116f0:	e13ffe15 	stw	r4,-8(fp)
 18116f4:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 18116f8:	e0bffe17 	ldw	r2,-8(fp)
 18116fc:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1811700:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1811704:	e0bffb17 	ldw	r2,-20(fp)
 1811708:	10801d03 	ldbu	r2,116(r2)
 181170c:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1811710:	e0bffb17 	ldw	r2,-20(fp)
 1811714:	00c00084 	movi	r3,2
 1811718:	10c01d05 	stb	r3,116(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 181171c:	e0bffb17 	ldw	r2,-20(fp)
 1811720:	10801c17 	ldw	r2,112(r2)
 1811724:	10c00044 	addi	r3,r2,1
 1811728:	e0bffb17 	ldw	r2,-20(fp)
 181172c:	10c01c15 	stw	r3,112(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1811730:	e0bffd03 	ldbu	r2,-12(fp)
 1811734:	10800058 	cmpnei	r2,r2,1
 1811738:	10002b1e 	bne	r2,zero,18117e8 <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 181173c:	d0a7e117 	ldw	r2,-24700(gp)
 1811740:	1000171e 	bne	r2,zero,18117a0 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1811744:	e0bffb17 	ldw	r2,-20(fp)
 1811748:	10800104 	addi	r2,r2,4
 181174c:	1009883a 	mov	r4,r2
 1811750:	18274fc0 	call	18274fc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1811754:	e0bffb17 	ldw	r2,-20(fp)
 1811758:	10800b17 	ldw	r2,44(r2)
 181175c:	d0e7d917 	ldw	r3,-24732(gp)
 1811760:	1880032e 	bgeu	r3,r2,1811770 <vTaskNotifyGiveFromISR+0x90>
 1811764:	e0bffb17 	ldw	r2,-20(fp)
 1811768:	10800b17 	ldw	r2,44(r2)
 181176c:	d0a7d915 	stw	r2,-24732(gp)
 1811770:	e0bffb17 	ldw	r2,-20(fp)
 1811774:	10800b17 	ldw	r2,44(r2)
 1811778:	10c00524 	muli	r3,r2,20
 181177c:	00806134 	movhi	r2,388
 1811780:	109f7f04 	addi	r2,r2,32252
 1811784:	1887883a 	add	r3,r3,r2
 1811788:	e0bffb17 	ldw	r2,-20(fp)
 181178c:	10800104 	addi	r2,r2,4
 1811790:	100b883a 	mov	r5,r2
 1811794:	1809883a 	mov	r4,r3
 1811798:	18273980 	call	1827398 <vListInsertEnd>
 181179c:	00000606 	br	18117b8 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 18117a0:	e0bffb17 	ldw	r2,-20(fp)
 18117a4:	10800604 	addi	r2,r2,24
 18117a8:	100b883a 	mov	r5,r2
 18117ac:	01006134 	movhi	r4,388
 18117b0:	211fa204 	addi	r4,r4,32392
 18117b4:	18273980 	call	1827398 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 18117b8:	e0bffb17 	ldw	r2,-20(fp)
 18117bc:	10800b17 	ldw	r2,44(r2)
 18117c0:	d0e7d317 	ldw	r3,-24756(gp)
 18117c4:	18c00b17 	ldw	r3,44(r3)
 18117c8:	1880072e 	bgeu	r3,r2,18117e8 <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 18117cc:	e0bfff17 	ldw	r2,-4(fp)
 18117d0:	10000326 	beq	r2,zero,18117e0 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 18117d4:	e0bfff17 	ldw	r2,-4(fp)
 18117d8:	00c00044 	movi	r3,1
 18117dc:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 18117e0:	00800044 	movi	r2,1
 18117e4:	d0a7dc15 	stw	r2,-24720(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 18117e8:	0001883a 	nop
 18117ec:	e037883a 	mov	sp,fp
 18117f0:	dfc00117 	ldw	ra,4(sp)
 18117f4:	df000017 	ldw	fp,0(sp)
 18117f8:	dec00204 	addi	sp,sp,8
 18117fc:	f800283a 	ret

01811800 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 1811800:	defffb04 	addi	sp,sp,-20
 1811804:	dfc00415 	stw	ra,16(sp)
 1811808:	df000315 	stw	fp,12(sp)
 181180c:	df000304 	addi	fp,sp,12
 1811810:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 1811814:	e0bfff17 	ldw	r2,-4(fp)
 1811818:	1000021e 	bne	r2,zero,1811824 <xTaskNotifyStateClear+0x24>
 181181c:	d0a7d317 	ldw	r2,-24756(gp)
 1811820:	00000106 	br	1811828 <xTaskNotifyStateClear+0x28>
 1811824:	e0bfff17 	ldw	r2,-4(fp)
 1811828:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 181182c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811830:	10000126 	beq	r2,zero,1811838 <xTaskNotifyStateClear+0x38>
 1811834:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 1811838:	e0bffe17 	ldw	r2,-8(fp)
 181183c:	10801d03 	ldbu	r2,116(r2)
 1811840:	10803fcc 	andi	r2,r2,255
 1811844:	10800098 	cmpnei	r2,r2,2
 1811848:	1000051e 	bne	r2,zero,1811860 <xTaskNotifyStateClear+0x60>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 181184c:	e0bffe17 	ldw	r2,-8(fp)
 1811850:	10001d05 	stb	zero,116(r2)
				xReturn = pdPASS;
 1811854:	00800044 	movi	r2,1
 1811858:	e0bffd15 	stw	r2,-12(fp)
 181185c:	00000106 	br	1811864 <xTaskNotifyStateClear+0x64>
			}
			else
			{
				xReturn = pdFAIL;
 1811860:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 1811864:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811868:	10000126 	beq	r2,zero,1811870 <xTaskNotifyStateClear+0x70>
 181186c:	18110840 	call	1811084 <vTaskExitCritical>

		return xReturn;
 1811870:	e0bffd17 	ldw	r2,-12(fp)
	}
 1811874:	e037883a 	mov	sp,fp
 1811878:	dfc00117 	ldw	ra,4(sp)
 181187c:	df000017 	ldw	fp,0(sp)
 1811880:	dec00204 	addi	sp,sp,8
 1811884:	f800283a 	ret

01811888 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
 1811888:	defffa04 	addi	sp,sp,-24
 181188c:	dfc00515 	stw	ra,20(sp)
 1811890:	df000415 	stw	fp,16(sp)
 1811894:	df000404 	addi	fp,sp,16
 1811898:	e13ffe15 	stw	r4,-8(fp)
 181189c:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 18118a0:	e0bffe17 	ldw	r2,-8(fp)
 18118a4:	1000021e 	bne	r2,zero,18118b0 <ulTaskNotifyValueClear+0x28>
 18118a8:	d0a7d317 	ldw	r2,-24756(gp)
 18118ac:	00000106 	br	18118b4 <ulTaskNotifyValueClear+0x2c>
 18118b0:	e0bffe17 	ldw	r2,-8(fp)
 18118b4:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
 18118b8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18118bc:	10000126 	beq	r2,zero,18118c4 <ulTaskNotifyValueClear+0x3c>
 18118c0:	181103c0 	call	181103c <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 18118c4:	d0a7d317 	ldw	r2,-24756(gp)
 18118c8:	10801c17 	ldw	r2,112(r2)
 18118cc:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 18118d0:	e0bffc17 	ldw	r2,-16(fp)
 18118d4:	10c01c17 	ldw	r3,112(r2)
 18118d8:	e0bfff17 	ldw	r2,-4(fp)
 18118dc:	0084303a 	nor	r2,zero,r2
 18118e0:	1886703a 	and	r3,r3,r2
 18118e4:	e0bffc17 	ldw	r2,-16(fp)
 18118e8:	10c01c15 	stw	r3,112(r2)
		}
		taskEXIT_CRITICAL();
 18118ec:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18118f0:	10000126 	beq	r2,zero,18118f8 <ulTaskNotifyValueClear+0x70>
 18118f4:	18110840 	call	1811084 <vTaskExitCritical>

		return ulReturn;
 18118f8:	e0bffd17 	ldw	r2,-12(fp)
	}
 18118fc:	e037883a 	mov	sp,fp
 1811900:	dfc00117 	ldw	ra,4(sp)
 1811904:	df000017 	ldw	fp,0(sp)
 1811908:	dec00204 	addi	sp,sp,8
 181190c:	f800283a 	ret

01811910 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 1811910:	defffa04 	addi	sp,sp,-24
 1811914:	dfc00515 	stw	ra,20(sp)
 1811918:	df000415 	stw	fp,16(sp)
 181191c:	df000404 	addi	fp,sp,16
 1811920:	e13ffe15 	stw	r4,-8(fp)
 1811924:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 1811928:	d0a7d817 	ldw	r2,-24736(gp)
 181192c:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1811930:	d0a7d317 	ldw	r2,-24756(gp)
 1811934:	10800104 	addi	r2,r2,4
 1811938:	1009883a 	mov	r4,r2
 181193c:	18274fc0 	call	18274fc <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 1811940:	e0bffe17 	ldw	r2,-8(fp)
 1811944:	10bfffd8 	cmpnei	r2,r2,-1
 1811948:	1000091e 	bne	r2,zero,1811970 <prvAddCurrentTaskToDelayedList+0x60>
 181194c:	e0bfff17 	ldw	r2,-4(fp)
 1811950:	10000726 	beq	r2,zero,1811970 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1811954:	d0a7d317 	ldw	r2,-24756(gp)
 1811958:	10800104 	addi	r2,r2,4
 181195c:	100b883a 	mov	r5,r2
 1811960:	01006134 	movhi	r4,388
 1811964:	211fac04 	addi	r4,r4,32432
 1811968:	18273980 	call	1827398 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 181196c:	00001c06 	br	18119e0 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 1811970:	e0fffc17 	ldw	r3,-16(fp)
 1811974:	e0bffe17 	ldw	r2,-8(fp)
 1811978:	1885883a 	add	r2,r3,r2
 181197c:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 1811980:	d0a7d317 	ldw	r2,-24756(gp)
 1811984:	e0fffd17 	ldw	r3,-12(fp)
 1811988:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 181198c:	e0fffd17 	ldw	r3,-12(fp)
 1811990:	e0bffc17 	ldw	r2,-16(fp)
 1811994:	1880072e 	bgeu	r3,r2,18119b4 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1811998:	d0e7d517 	ldw	r3,-24748(gp)
 181199c:	d0a7d317 	ldw	r2,-24756(gp)
 18119a0:	10800104 	addi	r2,r2,4
 18119a4:	100b883a 	mov	r5,r2
 18119a8:	1809883a 	mov	r4,r3
 18119ac:	18274240 	call	1827424 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 18119b0:	00000b06 	br	18119e0 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 18119b4:	d0e7d417 	ldw	r3,-24752(gp)
 18119b8:	d0a7d317 	ldw	r2,-24756(gp)
 18119bc:	10800104 	addi	r2,r2,4
 18119c0:	100b883a 	mov	r5,r2
 18119c4:	1809883a 	mov	r4,r3
 18119c8:	18274240 	call	1827424 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 18119cc:	d0a7df17 	ldw	r2,-24708(gp)
 18119d0:	e0fffd17 	ldw	r3,-12(fp)
 18119d4:	1880022e 	bgeu	r3,r2,18119e0 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 18119d8:	e0bffd17 	ldw	r2,-12(fp)
 18119dc:	d0a7df15 	stw	r2,-24708(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 18119e0:	0001883a 	nop
 18119e4:	e037883a 	mov	sp,fp
 18119e8:	dfc00117 	ldw	ra,4(sp)
 18119ec:	df000017 	ldw	fp,0(sp)
 18119f0:	dec00204 	addi	sp,sp,8
 18119f4:	f800283a 	ret

018119f8 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 18119f8:	defffb04 	addi	sp,sp,-20
 18119fc:	dfc00415 	stw	ra,16(sp)
 1811a00:	df000315 	stw	fp,12(sp)
 1811a04:	df000304 	addi	fp,sp,12
BaseType_t xReturn = pdFAIL;
 1811a08:	e03fff15 	stw	zero,-4(fp)

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 1811a0c:	18124c00 	call	18124c0 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 1811a10:	d0a7e417 	ldw	r2,-24688(gp)
 1811a14:	10000c26 	beq	r2,zero,1811a48 <xTimerCreateTimerTask+0x50>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
 1811a18:	d0a7e504 	addi	r2,gp,-24684
 1811a1c:	d8800115 	stw	r2,4(sp)
 1811a20:	00800144 	movi	r2,5
 1811a24:	d8800015 	stw	r2,0(sp)
 1811a28:	000f883a 	mov	r7,zero
 1811a2c:	01820004 	movi	r6,2048
 1811a30:	01406134 	movhi	r5,388
 1811a34:	29459404 	addi	r5,r5,5712
 1811a38:	01006074 	movhi	r4,385
 1811a3c:	2107ba04 	addi	r4,r4,7912
 1811a40:	180ed080 	call	180ed08 <xTaskCreate>
 1811a44:	e0bfff15 	stw	r2,-4(fp)
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
 1811a48:	e0bfff17 	ldw	r2,-4(fp)
}
 1811a4c:	e037883a 	mov	sp,fp
 1811a50:	dfc00117 	ldw	ra,4(sp)
 1811a54:	df000017 	ldw	fp,0(sp)
 1811a58:	dec00204 	addi	sp,sp,8
 1811a5c:	f800283a 	ret

01811a60 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
 1811a60:	defff704 	addi	sp,sp,-36
 1811a64:	dfc00815 	stw	ra,32(sp)
 1811a68:	df000715 	stw	fp,28(sp)
 1811a6c:	df000704 	addi	fp,sp,28
 1811a70:	e13ffc15 	stw	r4,-16(fp)
 1811a74:	e17ffd15 	stw	r5,-12(fp)
 1811a78:	e1bffe15 	stw	r6,-8(fp)
 1811a7c:	e1ffff15 	stw	r7,-4(fp)
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 1811a80:	01000b04 	movi	r4,44
 1811a84:	18272740 	call	1827274 <pvPortMalloc>
 1811a88:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewTimer != NULL )
 1811a8c:	e0bffb17 	ldw	r2,-20(fp)
 1811a90:	10000b26 	beq	r2,zero,1811ac0 <xTimerCreate+0x60>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The auto-reload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
 1811a94:	e0bffb17 	ldw	r2,-20(fp)
 1811a98:	10000a05 	stb	zero,40(r2)
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 1811a9c:	e0bffb17 	ldw	r2,-20(fp)
 1811aa0:	d8800115 	stw	r2,4(sp)
 1811aa4:	e0800217 	ldw	r2,8(fp)
 1811aa8:	d8800015 	stw	r2,0(sp)
 1811aac:	e1ffff17 	ldw	r7,-4(fp)
 1811ab0:	e1bffe17 	ldw	r6,-8(fp)
 1811ab4:	e17ffd17 	ldw	r5,-12(fp)
 1811ab8:	e13ffc17 	ldw	r4,-16(fp)
 1811abc:	1811ad80 	call	1811ad8 <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 1811ac0:	e0bffb17 	ldw	r2,-20(fp)
	}
 1811ac4:	e037883a 	mov	sp,fp
 1811ac8:	dfc00117 	ldw	ra,4(sp)
 1811acc:	df000017 	ldw	fp,0(sp)
 1811ad0:	dec00204 	addi	sp,sp,8
 1811ad4:	f800283a 	ret

01811ad8 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
 1811ad8:	defffa04 	addi	sp,sp,-24
 1811adc:	dfc00515 	stw	ra,20(sp)
 1811ae0:	df000415 	stw	fp,16(sp)
 1811ae4:	df000404 	addi	fp,sp,16
 1811ae8:	e13ffc15 	stw	r4,-16(fp)
 1811aec:	e17ffd15 	stw	r5,-12(fp)
 1811af0:	e1bffe15 	stw	r6,-8(fp)
 1811af4:	e1ffff15 	stw	r7,-4(fp)
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
 1811af8:	e0800317 	ldw	r2,12(fp)
 1811afc:	10001926 	beq	r2,zero,1811b64 <prvInitialiseNewTimer+0x8c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
 1811b00:	18124c00 	call	18124c0 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
 1811b04:	e0800317 	ldw	r2,12(fp)
 1811b08:	e0fffc17 	ldw	r3,-16(fp)
 1811b0c:	10c00015 	stw	r3,0(r2)
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 1811b10:	e0800317 	ldw	r2,12(fp)
 1811b14:	e0fffd17 	ldw	r3,-12(fp)
 1811b18:	10c00615 	stw	r3,24(r2)
		pxNewTimer->pvTimerID = pvTimerID;
 1811b1c:	e0800317 	ldw	r2,12(fp)
 1811b20:	e0ffff17 	ldw	r3,-4(fp)
 1811b24:	10c00715 	stw	r3,28(r2)
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 1811b28:	e0800317 	ldw	r2,12(fp)
 1811b2c:	e0c00217 	ldw	r3,8(fp)
 1811b30:	10c00815 	stw	r3,32(r2)
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 1811b34:	e0800317 	ldw	r2,12(fp)
 1811b38:	10800104 	addi	r2,r2,4
 1811b3c:	1009883a 	mov	r4,r2
 1811b40:	182736c0 	call	182736c <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 1811b44:	e0bffe17 	ldw	r2,-8(fp)
 1811b48:	10000626 	beq	r2,zero,1811b64 <prvInitialiseNewTimer+0x8c>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 1811b4c:	e0800317 	ldw	r2,12(fp)
 1811b50:	10800a03 	ldbu	r2,40(r2)
 1811b54:	10800114 	ori	r2,r2,4
 1811b58:	1007883a 	mov	r3,r2
 1811b5c:	e0800317 	ldw	r2,12(fp)
 1811b60:	10c00a05 	stb	r3,40(r2)
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
 1811b64:	0001883a 	nop
 1811b68:	e037883a 	mov	sp,fp
 1811b6c:	dfc00117 	ldw	ra,4(sp)
 1811b70:	df000017 	ldw	fp,0(sp)
 1811b74:	dec00204 	addi	sp,sp,8
 1811b78:	f800283a 	ret

01811b7c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 1811b7c:	defff604 	addi	sp,sp,-40
 1811b80:	dfc00915 	stw	ra,36(sp)
 1811b84:	df000815 	stw	fp,32(sp)
 1811b88:	df000804 	addi	fp,sp,32
 1811b8c:	e13ffc15 	stw	r4,-16(fp)
 1811b90:	e17ffd15 	stw	r5,-12(fp)
 1811b94:	e1bffe15 	stw	r6,-8(fp)
 1811b98:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn = pdFAIL;
 1811b9c:	e03ff815 	stw	zero,-32(fp)

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 1811ba0:	d0a7e417 	ldw	r2,-24688(gp)
 1811ba4:	10002626 	beq	r2,zero,1811c40 <xTimerGenericCommand+0xc4>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 1811ba8:	e0bffd17 	ldw	r2,-12(fp)
 1811bac:	e0bff915 	stw	r2,-28(fp)
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 1811bb0:	e0bffe17 	ldw	r2,-8(fp)
 1811bb4:	e0bffa15 	stw	r2,-24(fp)
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 1811bb8:	e0bffc17 	ldw	r2,-16(fp)
 1811bbc:	e0bffb15 	stw	r2,-20(fp)

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 1811bc0:	e0bffd17 	ldw	r2,-12(fp)
 1811bc4:	10800188 	cmpgei	r2,r2,6
 1811bc8:	1000151e 	bne	r2,zero,1811c20 <xTimerGenericCommand+0xa4>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 1811bcc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811bd0:	10800098 	cmpnei	r2,r2,2
 1811bd4:	1000091e 	bne	r2,zero,1811bfc <xTimerGenericCommand+0x80>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 1811bd8:	d0a7e417 	ldw	r2,-24688(gp)
 1811bdc:	e0fff904 	addi	r3,fp,-28
 1811be0:	000f883a 	mov	r7,zero
 1811be4:	e1800217 	ldw	r6,8(fp)
 1811be8:	180b883a 	mov	r5,r3
 1811bec:	1009883a 	mov	r4,r2
 1811bf0:	180da7c0 	call	180da7c <xQueueGenericSend>
 1811bf4:	e0bff815 	stw	r2,-32(fp)
 1811bf8:	00001106 	br	1811c40 <xTimerGenericCommand+0xc4>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 1811bfc:	d0a7e417 	ldw	r2,-24688(gp)
 1811c00:	e0fff904 	addi	r3,fp,-28
 1811c04:	000f883a 	mov	r7,zero
 1811c08:	000d883a 	mov	r6,zero
 1811c0c:	180b883a 	mov	r5,r3
 1811c10:	1009883a 	mov	r4,r2
 1811c14:	180da7c0 	call	180da7c <xQueueGenericSend>
 1811c18:	e0bff815 	stw	r2,-32(fp)
 1811c1c:	00000806 	br	1811c40 <xTimerGenericCommand+0xc4>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 1811c20:	d0a7e417 	ldw	r2,-24688(gp)
 1811c24:	e0fff904 	addi	r3,fp,-28
 1811c28:	000f883a 	mov	r7,zero
 1811c2c:	e1bfff17 	ldw	r6,-4(fp)
 1811c30:	180b883a 	mov	r5,r3
 1811c34:	1009883a 	mov	r4,r2
 1811c38:	180dc600 	call	180dc60 <xQueueGenericSendFromISR>
 1811c3c:	e0bff815 	stw	r2,-32(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 1811c40:	e0bff817 	ldw	r2,-32(fp)
}
 1811c44:	e037883a 	mov	sp,fp
 1811c48:	dfc00117 	ldw	ra,4(sp)
 1811c4c:	df000017 	ldw	fp,0(sp)
 1811c50:	dec00204 	addi	sp,sp,8
 1811c54:	f800283a 	ret

01811c58 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
 1811c58:	deffff04 	addi	sp,sp,-4
 1811c5c:	df000015 	stw	fp,0(sp)
 1811c60:	d839883a 	mov	fp,sp
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
	return xTimerTaskHandle;
 1811c64:	d0a7e517 	ldw	r2,-24684(gp)
}
 1811c68:	e037883a 	mov	sp,fp
 1811c6c:	df000017 	ldw	fp,0(sp)
 1811c70:	dec00104 	addi	sp,sp,4
 1811c74:	f800283a 	ret

01811c78 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
 1811c78:	defffd04 	addi	sp,sp,-12
 1811c7c:	df000215 	stw	fp,8(sp)
 1811c80:	df000204 	addi	fp,sp,8
 1811c84:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 1811c88:	e0bfff17 	ldw	r2,-4(fp)
 1811c8c:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->xTimerPeriodInTicks;
 1811c90:	e0bffe17 	ldw	r2,-8(fp)
 1811c94:	10800617 	ldw	r2,24(r2)
}
 1811c98:	e037883a 	mov	sp,fp
 1811c9c:	df000017 	ldw	fp,0(sp)
 1811ca0:	dec00104 	addi	sp,sp,4
 1811ca4:	f800283a 	ret

01811ca8 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
{
 1811ca8:	defffb04 	addi	sp,sp,-20
 1811cac:	dfc00415 	stw	ra,16(sp)
 1811cb0:	df000315 	stw	fp,12(sp)
 1811cb4:	df000304 	addi	fp,sp,12
 1811cb8:	e13ffe15 	stw	r4,-8(fp)
 1811cbc:	e17fff15 	stw	r5,-4(fp)
Timer_t * pxTimer =  xTimer;
 1811cc0:	e0bffe17 	ldw	r2,-8(fp)
 1811cc4:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 1811cc8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811ccc:	10000126 	beq	r2,zero,1811cd4 <vTimerSetReloadMode+0x2c>
 1811cd0:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( uxAutoReload != pdFALSE )
 1811cd4:	e0bfff17 	ldw	r2,-4(fp)
 1811cd8:	10000726 	beq	r2,zero,1811cf8 <vTimerSetReloadMode+0x50>
		{
			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 1811cdc:	e0bffd17 	ldw	r2,-12(fp)
 1811ce0:	10800a03 	ldbu	r2,40(r2)
 1811ce4:	10800114 	ori	r2,r2,4
 1811ce8:	1007883a 	mov	r3,r2
 1811cec:	e0bffd17 	ldw	r2,-12(fp)
 1811cf0:	10c00a05 	stb	r3,40(r2)
 1811cf4:	00000706 	br	1811d14 <vTimerSetReloadMode+0x6c>
		}
		else
		{
			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
 1811cf8:	e0bffd17 	ldw	r2,-12(fp)
 1811cfc:	10c00a03 	ldbu	r3,40(r2)
 1811d00:	00bffec4 	movi	r2,-5
 1811d04:	1884703a 	and	r2,r3,r2
 1811d08:	1007883a 	mov	r3,r2
 1811d0c:	e0bffd17 	ldw	r2,-12(fp)
 1811d10:	10c00a05 	stb	r3,40(r2)
		}
	}
	taskEXIT_CRITICAL();
 1811d14:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811d18:	10000126 	beq	r2,zero,1811d20 <vTimerSetReloadMode+0x78>
 1811d1c:	18110840 	call	1811084 <vTaskExitCritical>
}
 1811d20:	0001883a 	nop
 1811d24:	e037883a 	mov	sp,fp
 1811d28:	dfc00117 	ldw	ra,4(sp)
 1811d2c:	df000017 	ldw	fp,0(sp)
 1811d30:	dec00204 	addi	sp,sp,8
 1811d34:	f800283a 	ret

01811d38 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
{
 1811d38:	defffb04 	addi	sp,sp,-20
 1811d3c:	dfc00415 	stw	ra,16(sp)
 1811d40:	df000315 	stw	fp,12(sp)
 1811d44:	df000304 	addi	fp,sp,12
 1811d48:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 1811d4c:	e0bfff17 	ldw	r2,-4(fp)
 1811d50:	e0bffe15 	stw	r2,-8(fp)
UBaseType_t uxReturn;

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 1811d54:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811d58:	10000126 	beq	r2,zero,1811d60 <uxTimerGetReloadMode+0x28>
 1811d5c:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 1811d60:	e0bffe17 	ldw	r2,-8(fp)
 1811d64:	10800a03 	ldbu	r2,40(r2)
 1811d68:	10803fcc 	andi	r2,r2,255
 1811d6c:	1080010c 	andi	r2,r2,4
 1811d70:	1000021e 	bne	r2,zero,1811d7c <uxTimerGetReloadMode+0x44>
		{
			/* Not an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdFALSE;
 1811d74:	e03ffd15 	stw	zero,-12(fp)
 1811d78:	00000206 	br	1811d84 <uxTimerGetReloadMode+0x4c>
		}
		else
		{
			/* Is an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdTRUE;
 1811d7c:	00800044 	movi	r2,1
 1811d80:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 1811d84:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1811d88:	10000126 	beq	r2,zero,1811d90 <uxTimerGetReloadMode+0x58>
 1811d8c:	18110840 	call	1811084 <vTaskExitCritical>

	return uxReturn;
 1811d90:	e0bffd17 	ldw	r2,-12(fp)
}
 1811d94:	e037883a 	mov	sp,fp
 1811d98:	dfc00117 	ldw	ra,4(sp)
 1811d9c:	df000017 	ldw	fp,0(sp)
 1811da0:	dec00204 	addi	sp,sp,8
 1811da4:	f800283a 	ret

01811da8 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
 1811da8:	defffc04 	addi	sp,sp,-16
 1811dac:	df000315 	stw	fp,12(sp)
 1811db0:	df000304 	addi	fp,sp,12
 1811db4:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 1811db8:	e0bfff17 	ldw	r2,-4(fp)
 1811dbc:	e0bffd15 	stw	r2,-12(fp)
TickType_t xReturn;

	configASSERT( xTimer );
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 1811dc0:	e0bffd17 	ldw	r2,-12(fp)
 1811dc4:	10800117 	ldw	r2,4(r2)
 1811dc8:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
 1811dcc:	e0bffe17 	ldw	r2,-8(fp)
}
 1811dd0:	e037883a 	mov	sp,fp
 1811dd4:	df000017 	ldw	fp,0(sp)
 1811dd8:	dec00104 	addi	sp,sp,4
 1811ddc:	f800283a 	ret

01811de0 <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 1811de0:	defffd04 	addi	sp,sp,-12
 1811de4:	df000215 	stw	fp,8(sp)
 1811de8:	df000204 	addi	fp,sp,8
 1811dec:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 1811df0:	e0bfff17 	ldw	r2,-4(fp)
 1811df4:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->pcTimerName;
 1811df8:	e0bffe17 	ldw	r2,-8(fp)
 1811dfc:	10800017 	ldw	r2,0(r2)
}
 1811e00:	e037883a 	mov	sp,fp
 1811e04:	df000017 	ldw	fp,0(sp)
 1811e08:	dec00104 	addi	sp,sp,4
 1811e0c:	f800283a 	ret

01811e10 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 1811e10:	defff904 	addi	sp,sp,-28
 1811e14:	dfc00615 	stw	ra,24(sp)
 1811e18:	df000515 	stw	fp,20(sp)
 1811e1c:	df000504 	addi	fp,sp,20
 1811e20:	e13ffe15 	stw	r4,-8(fp)
 1811e24:	e17fff15 	stw	r5,-4(fp)
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 1811e28:	d0a7e217 	ldw	r2,-24696(gp)
 1811e2c:	10800317 	ldw	r2,12(r2)
 1811e30:	10800317 	ldw	r2,12(r2)
 1811e34:	e0bffc15 	stw	r2,-16(fp)

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 1811e38:	e0bffc17 	ldw	r2,-16(fp)
 1811e3c:	10800104 	addi	r2,r2,4
 1811e40:	1009883a 	mov	r4,r2
 1811e44:	18274fc0 	call	18274fc <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 1811e48:	e0bffc17 	ldw	r2,-16(fp)
 1811e4c:	10800a03 	ldbu	r2,40(r2)
 1811e50:	10803fcc 	andi	r2,r2,255
 1811e54:	1080010c 	andi	r2,r2,4
 1811e58:	10001226 	beq	r2,zero,1811ea4 <prvProcessExpiredTimer+0x94>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 1811e5c:	e0bffc17 	ldw	r2,-16(fp)
 1811e60:	10c00617 	ldw	r3,24(r2)
 1811e64:	e0bffe17 	ldw	r2,-8(fp)
 1811e68:	1885883a 	add	r2,r3,r2
 1811e6c:	e1fffe17 	ldw	r7,-8(fp)
 1811e70:	e1bfff17 	ldw	r6,-4(fp)
 1811e74:	100b883a 	mov	r5,r2
 1811e78:	e13ffc17 	ldw	r4,-16(fp)
 1811e7c:	18120b80 	call	18120b8 <prvInsertTimerInActiveList>
 1811e80:	10000f26 	beq	r2,zero,1811ec0 <prvProcessExpiredTimer+0xb0>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 1811e84:	d8000015 	stw	zero,0(sp)
 1811e88:	000f883a 	mov	r7,zero
 1811e8c:	e1bffe17 	ldw	r6,-8(fp)
 1811e90:	000b883a 	mov	r5,zero
 1811e94:	e13ffc17 	ldw	r4,-16(fp)
 1811e98:	1811b7c0 	call	1811b7c <xTimerGenericCommand>
 1811e9c:	e0bffd15 	stw	r2,-12(fp)
 1811ea0:	00000706 	br	1811ec0 <prvProcessExpiredTimer+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 1811ea4:	e0bffc17 	ldw	r2,-16(fp)
 1811ea8:	10c00a03 	ldbu	r3,40(r2)
 1811eac:	00bfff84 	movi	r2,-2
 1811eb0:	1884703a 	and	r2,r3,r2
 1811eb4:	1007883a 	mov	r3,r2
 1811eb8:	e0bffc17 	ldw	r2,-16(fp)
 1811ebc:	10c00a05 	stb	r3,40(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 1811ec0:	e0bffc17 	ldw	r2,-16(fp)
 1811ec4:	10800817 	ldw	r2,32(r2)
 1811ec8:	e13ffc17 	ldw	r4,-16(fp)
 1811ecc:	103ee83a 	callr	r2
}
 1811ed0:	0001883a 	nop
 1811ed4:	e037883a 	mov	sp,fp
 1811ed8:	dfc00117 	ldw	ra,4(sp)
 1811edc:	df000017 	ldw	fp,0(sp)
 1811ee0:	dec00204 	addi	sp,sp,8
 1811ee4:	f800283a 	ret

01811ee8 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 1811ee8:	defffb04 	addi	sp,sp,-20
 1811eec:	dfc00415 	stw	ra,16(sp)
 1811ef0:	df000315 	stw	fp,12(sp)
 1811ef4:	df000304 	addi	fp,sp,12
 1811ef8:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 1811efc:	e0bffe04 	addi	r2,fp,-8
 1811f00:	1009883a 	mov	r4,r2
 1811f04:	1811fec0 	call	1811fec <prvGetNextExpireTime>
 1811f08:	e0bffd15 	stw	r2,-12(fp)

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 1811f0c:	e0bffe17 	ldw	r2,-8(fp)
 1811f10:	100b883a 	mov	r5,r2
 1811f14:	e13ffd17 	ldw	r4,-12(fp)
 1811f18:	1811f240 	call	1811f24 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 1811f1c:	18121940 	call	1812194 <prvProcessReceivedCommands>
	}
 1811f20:	003ff606 	br	1811efc <__ram_exceptions_end+0xff801ab8>

01811f24 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 1811f24:	defffa04 	addi	sp,sp,-24
 1811f28:	dfc00515 	stw	ra,20(sp)
 1811f2c:	df000415 	stw	fp,16(sp)
 1811f30:	df000404 	addi	fp,sp,16
 1811f34:	e13ffe15 	stw	r4,-8(fp)
 1811f38:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 1811f3c:	180fab80 	call	180fab8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 1811f40:	e0bffd04 	addi	r2,fp,-12
 1811f44:	1009883a 	mov	r4,r2
 1811f48:	18120540 	call	1812054 <prvSampleTimeNow>
 1811f4c:	e0bffc15 	stw	r2,-16(fp)
		if( xTimerListsWereSwitched == pdFALSE )
 1811f50:	e0bffd17 	ldw	r2,-12(fp)
 1811f54:	10001e1e 	bne	r2,zero,1811fd0 <prvProcessTimerOrBlockTask+0xac>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 1811f58:	e0bfff17 	ldw	r2,-4(fp)
 1811f5c:	1000081e 	bne	r2,zero,1811f80 <prvProcessTimerOrBlockTask+0x5c>
 1811f60:	e0bffe17 	ldw	r2,-8(fp)
 1811f64:	e0fffc17 	ldw	r3,-16(fp)
 1811f68:	18800536 	bltu	r3,r2,1811f80 <prvProcessTimerOrBlockTask+0x5c>
			{
				( void ) xTaskResumeAll();
 1811f6c:	180fae40 	call	180fae4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 1811f70:	e17ffc17 	ldw	r5,-16(fp)
 1811f74:	e13ffe17 	ldw	r4,-8(fp)
 1811f78:	1811e100 	call	1811e10 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 1811f7c:	00001506 	br	1811fd4 <prvProcessTimerOrBlockTask+0xb0>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
 1811f80:	e0bfff17 	ldw	r2,-4(fp)
 1811f84:	10000726 	beq	r2,zero,1811fa4 <prvProcessTimerOrBlockTask+0x80>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 1811f88:	d0a7e317 	ldw	r2,-24692(gp)
 1811f8c:	10800017 	ldw	r2,0(r2)
 1811f90:	1000021e 	bne	r2,zero,1811f9c <prvProcessTimerOrBlockTask+0x78>
 1811f94:	00800044 	movi	r2,1
 1811f98:	00000106 	br	1811fa0 <prvProcessTimerOrBlockTask+0x7c>
 1811f9c:	0005883a 	mov	r2,zero
 1811fa0:	e0bfff15 	stw	r2,-4(fp)
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 1811fa4:	d127e417 	ldw	r4,-24688(gp)
 1811fa8:	e0fffe17 	ldw	r3,-8(fp)
 1811fac:	e0bffc17 	ldw	r2,-16(fp)
 1811fb0:	1885c83a 	sub	r2,r3,r2
 1811fb4:	e1bfff17 	ldw	r6,-4(fp)
 1811fb8:	100b883a 	mov	r5,r2
 1811fbc:	180ec400 	call	180ec40 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 1811fc0:	180fae40 	call	180fae4 <xTaskResumeAll>
 1811fc4:	1000031e 	bne	r2,zero,1811fd4 <prvProcessTimerOrBlockTask+0xb0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
 1811fc8:	003b683a 	trap	0
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 1811fcc:	00000106 	br	1811fd4 <prvProcessTimerOrBlockTask+0xb0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 1811fd0:	180fae40 	call	180fae4 <xTaskResumeAll>
		}
	}
}
 1811fd4:	0001883a 	nop
 1811fd8:	e037883a 	mov	sp,fp
 1811fdc:	dfc00117 	ldw	ra,4(sp)
 1811fe0:	df000017 	ldw	fp,0(sp)
 1811fe4:	dec00204 	addi	sp,sp,8
 1811fe8:	f800283a 	ret

01811fec <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 1811fec:	defffd04 	addi	sp,sp,-12
 1811ff0:	df000215 	stw	fp,8(sp)
 1811ff4:	df000204 	addi	fp,sp,8
 1811ff8:	e13fff15 	stw	r4,-4(fp)
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 1811ffc:	d0a7e217 	ldw	r2,-24696(gp)
 1812000:	10800017 	ldw	r2,0(r2)
 1812004:	1000021e 	bne	r2,zero,1812010 <prvGetNextExpireTime+0x24>
 1812008:	00800044 	movi	r2,1
 181200c:	00000106 	br	1812014 <prvGetNextExpireTime+0x28>
 1812010:	0005883a 	mov	r2,zero
 1812014:	e0ffff17 	ldw	r3,-4(fp)
 1812018:	18800015 	stw	r2,0(r3)
	if( *pxListWasEmpty == pdFALSE )
 181201c:	e0bfff17 	ldw	r2,-4(fp)
 1812020:	10800017 	ldw	r2,0(r2)
 1812024:	1000051e 	bne	r2,zero,181203c <prvGetNextExpireTime+0x50>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 1812028:	d0a7e217 	ldw	r2,-24696(gp)
 181202c:	10800317 	ldw	r2,12(r2)
 1812030:	10800017 	ldw	r2,0(r2)
 1812034:	e0bffe15 	stw	r2,-8(fp)
 1812038:	00000106 	br	1812040 <prvGetNextExpireTime+0x54>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 181203c:	e03ffe15 	stw	zero,-8(fp)
	}

	return xNextExpireTime;
 1812040:	e0bffe17 	ldw	r2,-8(fp)
}
 1812044:	e037883a 	mov	sp,fp
 1812048:	df000017 	ldw	fp,0(sp)
 181204c:	dec00104 	addi	sp,sp,4
 1812050:	f800283a 	ret

01812054 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 1812054:	defffc04 	addi	sp,sp,-16
 1812058:	dfc00315 	stw	ra,12(sp)
 181205c:	df000215 	stw	fp,8(sp)
 1812060:	df000204 	addi	fp,sp,8
 1812064:	e13fff15 	stw	r4,-4(fp)
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 1812068:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 181206c:	e0bffe15 	stw	r2,-8(fp)

	if( xTimeNow < xLastTime )
 1812070:	d0a7e617 	ldw	r2,-24680(gp)
 1812074:	e0fffe17 	ldw	r3,-8(fp)
 1812078:	1880052e 	bgeu	r3,r2,1812090 <prvSampleTimeNow+0x3c>
	{
		prvSwitchTimerLists();
 181207c:	18123ac0 	call	18123ac <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 1812080:	e0bfff17 	ldw	r2,-4(fp)
 1812084:	00c00044 	movi	r3,1
 1812088:	10c00015 	stw	r3,0(r2)
 181208c:	00000206 	br	1812098 <prvSampleTimeNow+0x44>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 1812090:	e0bfff17 	ldw	r2,-4(fp)
 1812094:	10000015 	stw	zero,0(r2)
	}

	xLastTime = xTimeNow;
 1812098:	e0bffe17 	ldw	r2,-8(fp)
 181209c:	d0a7e615 	stw	r2,-24680(gp)

	return xTimeNow;
 18120a0:	e0bffe17 	ldw	r2,-8(fp)
}
 18120a4:	e037883a 	mov	sp,fp
 18120a8:	dfc00117 	ldw	ra,4(sp)
 18120ac:	df000017 	ldw	fp,0(sp)
 18120b0:	dec00204 	addi	sp,sp,8
 18120b4:	f800283a 	ret

018120b8 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 18120b8:	defff904 	addi	sp,sp,-28
 18120bc:	dfc00615 	stw	ra,24(sp)
 18120c0:	df000515 	stw	fp,20(sp)
 18120c4:	df000504 	addi	fp,sp,20
 18120c8:	e13ffc15 	stw	r4,-16(fp)
 18120cc:	e17ffd15 	stw	r5,-12(fp)
 18120d0:	e1bffe15 	stw	r6,-8(fp)
 18120d4:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xProcessTimerNow = pdFALSE;
 18120d8:	e03ffb15 	stw	zero,-20(fp)

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 18120dc:	e0bffc17 	ldw	r2,-16(fp)
 18120e0:	e0fffd17 	ldw	r3,-12(fp)
 18120e4:	10c00115 	stw	r3,4(r2)
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 18120e8:	e0bffc17 	ldw	r2,-16(fp)
 18120ec:	e0fffc17 	ldw	r3,-16(fp)
 18120f0:	10c00415 	stw	r3,16(r2)

	if( xNextExpiryTime <= xTimeNow )
 18120f4:	e0bffd17 	ldw	r2,-12(fp)
 18120f8:	e0fffe17 	ldw	r3,-8(fp)
 18120fc:	18801036 	bltu	r3,r2,1812140 <prvInsertTimerInActiveList+0x88>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1812100:	e0fffe17 	ldw	r3,-8(fp)
 1812104:	e0bfff17 	ldw	r2,-4(fp)
 1812108:	1887c83a 	sub	r3,r3,r2
 181210c:	e0bffc17 	ldw	r2,-16(fp)
 1812110:	10800617 	ldw	r2,24(r2)
 1812114:	18800336 	bltu	r3,r2,1812124 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 1812118:	00800044 	movi	r2,1
 181211c:	e0bffb15 	stw	r2,-20(fp)
 1812120:	00001606 	br	181217c <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 1812124:	d0e7e317 	ldw	r3,-24692(gp)
 1812128:	e0bffc17 	ldw	r2,-16(fp)
 181212c:	10800104 	addi	r2,r2,4
 1812130:	100b883a 	mov	r5,r2
 1812134:	1809883a 	mov	r4,r3
 1812138:	18274240 	call	1827424 <vListInsert>
 181213c:	00000f06 	br	181217c <prvInsertTimerInActiveList+0xc4>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 1812140:	e0fffe17 	ldw	r3,-8(fp)
 1812144:	e0bfff17 	ldw	r2,-4(fp)
 1812148:	1880062e 	bgeu	r3,r2,1812164 <prvInsertTimerInActiveList+0xac>
 181214c:	e0fffd17 	ldw	r3,-12(fp)
 1812150:	e0bfff17 	ldw	r2,-4(fp)
 1812154:	18800336 	bltu	r3,r2,1812164 <prvInsertTimerInActiveList+0xac>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 1812158:	00800044 	movi	r2,1
 181215c:	e0bffb15 	stw	r2,-20(fp)
 1812160:	00000606 	br	181217c <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 1812164:	d0e7e217 	ldw	r3,-24696(gp)
 1812168:	e0bffc17 	ldw	r2,-16(fp)
 181216c:	10800104 	addi	r2,r2,4
 1812170:	100b883a 	mov	r5,r2
 1812174:	1809883a 	mov	r4,r3
 1812178:	18274240 	call	1827424 <vListInsert>
		}
	}

	return xProcessTimerNow;
 181217c:	e0bffb17 	ldw	r2,-20(fp)
}
 1812180:	e037883a 	mov	sp,fp
 1812184:	dfc00117 	ldw	ra,4(sp)
 1812188:	df000017 	ldw	fp,0(sp)
 181218c:	dec00204 	addi	sp,sp,8
 1812190:	f800283a 	ret

01812194 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 1812194:	defff604 	addi	sp,sp,-40
 1812198:	dfc00915 	stw	ra,36(sp)
 181219c:	df000815 	stw	fp,32(sp)
 18121a0:	df000804 	addi	fp,sp,32
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 18121a4:	00007406 	br	1812378 <prvProcessReceivedCommands+0x1e4>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 18121a8:	e0bffc17 	ldw	r2,-16(fp)
 18121ac:	10007216 	blt	r2,zero,1812378 <prvProcessReceivedCommands+0x1e4>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 18121b0:	e0bffe17 	ldw	r2,-8(fp)
 18121b4:	e0bff915 	stw	r2,-28(fp)

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 18121b8:	e0bff917 	ldw	r2,-28(fp)
 18121bc:	10800517 	ldw	r2,20(r2)
 18121c0:	10000426 	beq	r2,zero,18121d4 <prvProcessReceivedCommands+0x40>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 18121c4:	e0bff917 	ldw	r2,-28(fp)
 18121c8:	10800104 	addi	r2,r2,4
 18121cc:	1009883a 	mov	r4,r2
 18121d0:	18274fc0 	call	18274fc <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 18121d4:	e0bfff04 	addi	r2,fp,-4
 18121d8:	1009883a 	mov	r4,r2
 18121dc:	18120540 	call	1812054 <prvSampleTimeNow>
 18121e0:	e0bffa15 	stw	r2,-24(fp)

			switch( xMessage.xMessageID )
 18121e4:	e0bffc17 	ldw	r2,-16(fp)
 18121e8:	10c002a8 	cmpgeui	r3,r2,10
 18121ec:	1800611e 	bne	r3,zero,1812374 <prvProcessReceivedCommands+0x1e0>
 18121f0:	100690ba 	slli	r3,r2,2
 18121f4:	00806074 	movhi	r2,385
 18121f8:	10888204 	addi	r2,r2,8712
 18121fc:	1885883a 	add	r2,r3,r2
 1812200:	10800017 	ldw	r2,0(r2)
 1812204:	1000683a 	jmp	r2
 1812208:	01812230 	cmpltui	r6,zero,1160
 181220c:	01812230 	cmpltui	r6,zero,1160
 1812210:	01812230 	cmpltui	r6,zero,1160
 1812214:	018122c8 	cmpgei	r6,zero,1163
 1812218:	018122e8 	cmpgeui	r6,zero,1163
 181221c:	01812334 	movhi	r6,1164
 1812220:	01812230 	cmpltui	r6,zero,1160
 1812224:	01812230 	cmpltui	r6,zero,1160
 1812228:	018122c8 	cmpgei	r6,zero,1163
 181222c:	018122e8 	cmpgeui	r6,zero,1163
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 1812230:	e0bff917 	ldw	r2,-28(fp)
 1812234:	10800a03 	ldbu	r2,40(r2)
 1812238:	10800054 	ori	r2,r2,1
 181223c:	1007883a 	mov	r3,r2
 1812240:	e0bff917 	ldw	r2,-28(fp)
 1812244:	10c00a05 	stb	r3,40(r2)
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 1812248:	e0fffd17 	ldw	r3,-12(fp)
 181224c:	e0bff917 	ldw	r2,-28(fp)
 1812250:	10800617 	ldw	r2,24(r2)
 1812254:	1885883a 	add	r2,r3,r2
 1812258:	e0fffd17 	ldw	r3,-12(fp)
 181225c:	180f883a 	mov	r7,r3
 1812260:	e1bffa17 	ldw	r6,-24(fp)
 1812264:	100b883a 	mov	r5,r2
 1812268:	e13ff917 	ldw	r4,-28(fp)
 181226c:	18120b80 	call	18120b8 <prvInsertTimerInActiveList>
 1812270:	10004126 	beq	r2,zero,1812378 <prvProcessReceivedCommands+0x1e4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 1812274:	e0bff917 	ldw	r2,-28(fp)
 1812278:	10800817 	ldw	r2,32(r2)
 181227c:	e13ff917 	ldw	r4,-28(fp)
 1812280:	103ee83a 	callr	r2
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 1812284:	e0bff917 	ldw	r2,-28(fp)
 1812288:	10800a03 	ldbu	r2,40(r2)
 181228c:	10803fcc 	andi	r2,r2,255
 1812290:	1080010c 	andi	r2,r2,4
 1812294:	10003826 	beq	r2,zero,1812378 <prvProcessReceivedCommands+0x1e4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 1812298:	e0fffd17 	ldw	r3,-12(fp)
 181229c:	e0bff917 	ldw	r2,-28(fp)
 18122a0:	10800617 	ldw	r2,24(r2)
 18122a4:	1885883a 	add	r2,r3,r2
 18122a8:	d8000015 	stw	zero,0(sp)
 18122ac:	000f883a 	mov	r7,zero
 18122b0:	100d883a 	mov	r6,r2
 18122b4:	000b883a 	mov	r5,zero
 18122b8:	e13ff917 	ldw	r4,-28(fp)
 18122bc:	1811b7c0 	call	1811b7c <xTimerGenericCommand>
 18122c0:	e0bffb15 	stw	r2,-20(fp)
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
 18122c4:	00002c06 	br	1812378 <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 18122c8:	e0bff917 	ldw	r2,-28(fp)
 18122cc:	10c00a03 	ldbu	r3,40(r2)
 18122d0:	00bfff84 	movi	r2,-2
 18122d4:	1884703a 	and	r2,r3,r2
 18122d8:	1007883a 	mov	r3,r2
 18122dc:	e0bff917 	ldw	r2,-28(fp)
 18122e0:	10c00a05 	stb	r3,40(r2)
					break;
 18122e4:	00002406 	br	1812378 <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 18122e8:	e0bff917 	ldw	r2,-28(fp)
 18122ec:	10800a03 	ldbu	r2,40(r2)
 18122f0:	10800054 	ori	r2,r2,1
 18122f4:	1007883a 	mov	r3,r2
 18122f8:	e0bff917 	ldw	r2,-28(fp)
 18122fc:	10c00a05 	stb	r3,40(r2)
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 1812300:	e0fffd17 	ldw	r3,-12(fp)
 1812304:	e0bff917 	ldw	r2,-28(fp)
 1812308:	10c00615 	stw	r3,24(r2)
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 181230c:	e0bff917 	ldw	r2,-28(fp)
 1812310:	10c00617 	ldw	r3,24(r2)
 1812314:	e0bffa17 	ldw	r2,-24(fp)
 1812318:	1885883a 	add	r2,r3,r2
 181231c:	e1fffa17 	ldw	r7,-24(fp)
 1812320:	e1bffa17 	ldw	r6,-24(fp)
 1812324:	100b883a 	mov	r5,r2
 1812328:	e13ff917 	ldw	r4,-28(fp)
 181232c:	18120b80 	call	18120b8 <prvInsertTimerInActiveList>
					break;
 1812330:	00001106 	br	1812378 <prvProcessReceivedCommands+0x1e4>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 1812334:	e0bff917 	ldw	r2,-28(fp)
 1812338:	10800a03 	ldbu	r2,40(r2)
 181233c:	10803fcc 	andi	r2,r2,255
 1812340:	1080008c 	andi	r2,r2,2
 1812344:	1000031e 	bne	r2,zero,1812354 <prvProcessReceivedCommands+0x1c0>
						{
							vPortFree( pxTimer );
 1812348:	e13ff917 	ldw	r4,-28(fp)
 181234c:	18272c00 	call	18272c0 <vPortFree>
 1812350:	00000906 	br	1812378 <prvProcessReceivedCommands+0x1e4>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 1812354:	e0bff917 	ldw	r2,-28(fp)
 1812358:	10c00a03 	ldbu	r3,40(r2)
 181235c:	00bfff84 	movi	r2,-2
 1812360:	1884703a 	and	r2,r3,r2
 1812364:	1007883a 	mov	r3,r2
 1812368:	e0bff917 	ldw	r2,-28(fp)
 181236c:	10c00a05 	stb	r3,40(r2)
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 1812370:	00000106 	br	1812378 <prvProcessReceivedCommands+0x1e4>

				default	:
					/* Don't expect to get here. */
					break;
 1812374:	0001883a 	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 1812378:	d0a7e417 	ldw	r2,-24688(gp)
 181237c:	e0fffc04 	addi	r3,fp,-16
 1812380:	000d883a 	mov	r6,zero
 1812384:	180b883a 	mov	r5,r3
 1812388:	1009883a 	mov	r4,r2
 181238c:	180de300 	call	180de30 <xQueueReceive>
 1812390:	103f851e 	bne	r2,zero,18121a8 <__ram_exceptions_end+0xff801d64>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
 1812394:	0001883a 	nop
 1812398:	e037883a 	mov	sp,fp
 181239c:	dfc00117 	ldw	ra,4(sp)
 18123a0:	df000017 	ldw	fp,0(sp)
 18123a4:	dec00204 	addi	sp,sp,8
 18123a8:	f800283a 	ret

018123ac <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 18123ac:	defff804 	addi	sp,sp,-32
 18123b0:	dfc00715 	stw	ra,28(sp)
 18123b4:	df000615 	stw	fp,24(sp)
 18123b8:	df000604 	addi	fp,sp,24

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 18123bc:	00003106 	br	1812484 <prvSwitchTimerLists+0xd8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 18123c0:	d0a7e217 	ldw	r2,-24696(gp)
 18123c4:	10800317 	ldw	r2,12(r2)
 18123c8:	10800017 	ldw	r2,0(r2)
 18123cc:	e0bffb15 	stw	r2,-20(fp)

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 18123d0:	d0a7e217 	ldw	r2,-24696(gp)
 18123d4:	10800317 	ldw	r2,12(r2)
 18123d8:	10800317 	ldw	r2,12(r2)
 18123dc:	e0bffc15 	stw	r2,-16(fp)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 18123e0:	e0bffc17 	ldw	r2,-16(fp)
 18123e4:	10800104 	addi	r2,r2,4
 18123e8:	1009883a 	mov	r4,r2
 18123ec:	18274fc0 	call	18274fc <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 18123f0:	e0bffc17 	ldw	r2,-16(fp)
 18123f4:	10800817 	ldw	r2,32(r2)
 18123f8:	e13ffc17 	ldw	r4,-16(fp)
 18123fc:	103ee83a 	callr	r2

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 1812400:	e0bffc17 	ldw	r2,-16(fp)
 1812404:	10800a03 	ldbu	r2,40(r2)
 1812408:	10803fcc 	andi	r2,r2,255
 181240c:	1080010c 	andi	r2,r2,4
 1812410:	10001c26 	beq	r2,zero,1812484 <prvSwitchTimerLists+0xd8>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 1812414:	e0bffc17 	ldw	r2,-16(fp)
 1812418:	10c00617 	ldw	r3,24(r2)
 181241c:	e0bffb17 	ldw	r2,-20(fp)
 1812420:	1885883a 	add	r2,r3,r2
 1812424:	e0bffd15 	stw	r2,-12(fp)
			if( xReloadTime > xNextExpireTime )
 1812428:	e0bffd17 	ldw	r2,-12(fp)
 181242c:	e0fffb17 	ldw	r3,-20(fp)
 1812430:	18800d2e 	bgeu	r3,r2,1812468 <prvSwitchTimerLists+0xbc>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 1812434:	e0bffc17 	ldw	r2,-16(fp)
 1812438:	e0fffd17 	ldw	r3,-12(fp)
 181243c:	10c00115 	stw	r3,4(r2)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 1812440:	e0bffc17 	ldw	r2,-16(fp)
 1812444:	e0fffc17 	ldw	r3,-16(fp)
 1812448:	10c00415 	stw	r3,16(r2)
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 181244c:	d0e7e217 	ldw	r3,-24696(gp)
 1812450:	e0bffc17 	ldw	r2,-16(fp)
 1812454:	10800104 	addi	r2,r2,4
 1812458:	100b883a 	mov	r5,r2
 181245c:	1809883a 	mov	r4,r3
 1812460:	18274240 	call	1827424 <vListInsert>
 1812464:	00000706 	br	1812484 <prvSwitchTimerLists+0xd8>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 1812468:	d8000015 	stw	zero,0(sp)
 181246c:	000f883a 	mov	r7,zero
 1812470:	e1bffb17 	ldw	r6,-20(fp)
 1812474:	000b883a 	mov	r5,zero
 1812478:	e13ffc17 	ldw	r4,-16(fp)
 181247c:	1811b7c0 	call	1811b7c <xTimerGenericCommand>
 1812480:	e0bffe15 	stw	r2,-8(fp)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 1812484:	d0a7e217 	ldw	r2,-24696(gp)
 1812488:	10800017 	ldw	r2,0(r2)
 181248c:	103fcc1e 	bne	r2,zero,18123c0 <__ram_exceptions_end+0xff801f7c>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 1812490:	d0a7e217 	ldw	r2,-24696(gp)
 1812494:	e0bfff15 	stw	r2,-4(fp)
	pxCurrentTimerList = pxOverflowTimerList;
 1812498:	d0a7e317 	ldw	r2,-24692(gp)
 181249c:	d0a7e215 	stw	r2,-24696(gp)
	pxOverflowTimerList = pxTemp;
 18124a0:	e0bfff17 	ldw	r2,-4(fp)
 18124a4:	d0a7e315 	stw	r2,-24692(gp)
}
 18124a8:	0001883a 	nop
 18124ac:	e037883a 	mov	sp,fp
 18124b0:	dfc00117 	ldw	ra,4(sp)
 18124b4:	df000017 	ldw	fp,0(sp)
 18124b8:	dec00204 	addi	sp,sp,8
 18124bc:	f800283a 	ret

018124c0 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 18124c0:	defffe04 	addi	sp,sp,-8
 18124c4:	dfc00115 	stw	ra,4(sp)
 18124c8:	df000015 	stw	fp,0(sp)
 18124cc:	d839883a 	mov	fp,sp
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 18124d0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18124d4:	10000126 	beq	r2,zero,18124dc <prvCheckForValidListAndQueue+0x1c>
 18124d8:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
 18124dc:	d0a7e417 	ldw	r2,-24688(gp)
 18124e0:	1000111e 	bne	r2,zero,1812528 <prvCheckForValidListAndQueue+0x68>
		{
			vListInitialise( &xActiveTimerList1 );
 18124e4:	01006134 	movhi	r4,388
 18124e8:	211fb104 	addi	r4,r4,32452
 18124ec:	18273040 	call	1827304 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 18124f0:	01006134 	movhi	r4,388
 18124f4:	211fb604 	addi	r4,r4,32472
 18124f8:	18273040 	call	1827304 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 18124fc:	00806134 	movhi	r2,388
 1812500:	109fb104 	addi	r2,r2,32452
 1812504:	d0a7e215 	stw	r2,-24696(gp)
			pxOverflowTimerList = &xActiveTimerList2;
 1812508:	00806134 	movhi	r2,388
 181250c:	109fb604 	addi	r2,r2,32472
 1812510:	d0a7e315 	stw	r2,-24692(gp)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 1812514:	000d883a 	mov	r6,zero
 1812518:	01400304 	movi	r5,12
 181251c:	01000284 	movi	r4,10
 1812520:	180d7140 	call	180d714 <xQueueGenericCreate>
 1812524:	d0a7e415 	stw	r2,-24688(gp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 1812528:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181252c:	10000126 	beq	r2,zero,1812534 <prvCheckForValidListAndQueue+0x74>
 1812530:	18110840 	call	1811084 <vTaskExitCritical>
}
 1812534:	0001883a 	nop
 1812538:	e037883a 	mov	sp,fp
 181253c:	dfc00117 	ldw	ra,4(sp)
 1812540:	df000017 	ldw	fp,0(sp)
 1812544:	dec00204 	addi	sp,sp,8
 1812548:	f800283a 	ret

0181254c <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
 181254c:	defffb04 	addi	sp,sp,-20
 1812550:	dfc00415 	stw	ra,16(sp)
 1812554:	df000315 	stw	fp,12(sp)
 1812558:	df000304 	addi	fp,sp,12
 181255c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Timer_t *pxTimer = xTimer;
 1812560:	e0bfff17 	ldw	r2,-4(fp)
 1812564:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 1812568:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181256c:	10000126 	beq	r2,zero,1812574 <xTimerIsTimerActive+0x28>
 1812570:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 1812574:	e0bffe17 	ldw	r2,-8(fp)
 1812578:	10800a03 	ldbu	r2,40(r2)
 181257c:	10803fcc 	andi	r2,r2,255
 1812580:	1080004c 	andi	r2,r2,1
 1812584:	1000021e 	bne	r2,zero,1812590 <xTimerIsTimerActive+0x44>
		{
			xReturn = pdFALSE;
 1812588:	e03ffd15 	stw	zero,-12(fp)
 181258c:	00000206 	br	1812598 <xTimerIsTimerActive+0x4c>
		}
		else
		{
			xReturn = pdTRUE;
 1812590:	00800044 	movi	r2,1
 1812594:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 1812598:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181259c:	10000126 	beq	r2,zero,18125a4 <xTimerIsTimerActive+0x58>
 18125a0:	18110840 	call	1811084 <vTaskExitCritical>

	return xReturn;
 18125a4:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 Can't be pointer to const due to the typedef. */
 18125a8:	e037883a 	mov	sp,fp
 18125ac:	dfc00117 	ldw	ra,4(sp)
 18125b0:	df000017 	ldw	fp,0(sp)
 18125b4:	dec00204 	addi	sp,sp,8
 18125b8:	f800283a 	ret

018125bc <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 18125bc:	defffb04 	addi	sp,sp,-20
 18125c0:	dfc00415 	stw	ra,16(sp)
 18125c4:	df000315 	stw	fp,12(sp)
 18125c8:	df000304 	addi	fp,sp,12
 18125cc:	e13fff15 	stw	r4,-4(fp)
Timer_t * const pxTimer = xTimer;
 18125d0:	e0bfff17 	ldw	r2,-4(fp)
 18125d4:	e0bffd15 	stw	r2,-12(fp)
void *pvReturn;

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 18125d8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18125dc:	10000126 	beq	r2,zero,18125e4 <pvTimerGetTimerID+0x28>
 18125e0:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 18125e4:	e0bffd17 	ldw	r2,-12(fp)
 18125e8:	10800717 	ldw	r2,28(r2)
 18125ec:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 18125f0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18125f4:	10000126 	beq	r2,zero,18125fc <pvTimerGetTimerID+0x40>
 18125f8:	18110840 	call	1811084 <vTaskExitCritical>

	return pvReturn;
 18125fc:	e0bffe17 	ldw	r2,-8(fp)
}
 1812600:	e037883a 	mov	sp,fp
 1812604:	dfc00117 	ldw	ra,4(sp)
 1812608:	df000017 	ldw	fp,0(sp)
 181260c:	dec00204 	addi	sp,sp,8
 1812610:	f800283a 	ret

01812614 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 1812614:	defffb04 	addi	sp,sp,-20
 1812618:	dfc00415 	stw	ra,16(sp)
 181261c:	df000315 	stw	fp,12(sp)
 1812620:	df000304 	addi	fp,sp,12
 1812624:	e13ffe15 	stw	r4,-8(fp)
 1812628:	e17fff15 	stw	r5,-4(fp)
Timer_t * const pxTimer = xTimer;
 181262c:	e0bffe17 	ldw	r2,-8(fp)
 1812630:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 1812634:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1812638:	10000126 	beq	r2,zero,1812640 <vTimerSetTimerID+0x2c>
 181263c:	181103c0 	call	181103c <vTaskEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 1812640:	e0bffd17 	ldw	r2,-12(fp)
 1812644:	e0ffff17 	ldw	r3,-4(fp)
 1812648:	10c00715 	stw	r3,28(r2)
	}
	taskEXIT_CRITICAL();
 181264c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1812650:	10000126 	beq	r2,zero,1812658 <vTimerSetTimerID+0x44>
 1812654:	18110840 	call	1811084 <vTaskExitCritical>
}
 1812658:	0001883a 	nop
 181265c:	e037883a 	mov	sp,fp
 1812660:	dfc00117 	ldw	ra,4(sp)
 1812664:	df000017 	ldw	fp,0(sp)
 1812668:	dec00204 	addi	sp,sp,8
 181266c:	f800283a 	ret

01812670 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
 1812670:	defffe04 	addi	sp,sp,-8
 1812674:	df000115 	stw	fp,4(sp)
 1812678:	df000104 	addi	fp,sp,4
 181267c:	e13fff15 	stw	r4,-4(fp)
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
 1812680:	e0bfff17 	ldw	r2,-4(fp)
 1812684:	10800917 	ldw	r2,36(r2)
	}
 1812688:	e037883a 	mov	sp,fp
 181268c:	df000017 	ldw	fp,0(sp)
 1812690:	dec00104 	addi	sp,sp,4
 1812694:	f800283a 	ret

01812698 <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
 1812698:	defffd04 	addi	sp,sp,-12
 181269c:	df000215 	stw	fp,8(sp)
 18126a0:	df000204 	addi	fp,sp,8
 18126a4:	e13ffe15 	stw	r4,-8(fp)
 18126a8:	e17fff15 	stw	r5,-4(fp)
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 18126ac:	e0bffe17 	ldw	r2,-8(fp)
 18126b0:	e0ffff17 	ldw	r3,-4(fp)
 18126b4:	10c00915 	stw	r3,36(r2)
	}
 18126b8:	0001883a 	nop
 18126bc:	e037883a 	mov	sp,fp
 18126c0:	df000017 	ldw	fp,0(sp)
 18126c4:	dec00104 	addi	sp,sp,4
 18126c8:	f800283a 	ret

018126cc <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 18126cc:	defffc04 	addi	sp,sp,-16
 18126d0:	df000315 	stw	fp,12(sp)
 18126d4:	df000304 	addi	fp,sp,12
 18126d8:	e13ffd15 	stw	r4,-12(fp)
 18126dc:	e17ffe15 	stw	r5,-8(fp)
 18126e0:	e1bfff15 	stw	r6,-4(fp)
  return len;
 18126e4:	e0bfff17 	ldw	r2,-4(fp)
}
 18126e8:	e037883a 	mov	sp,fp
 18126ec:	df000017 	ldw	fp,0(sp)
 18126f0:	dec00104 	addi	sp,sp,4
 18126f4:	f800283a 	ret

018126f8 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 18126f8:	defffd04 	addi	sp,sp,-12
 18126fc:	dfc00215 	stw	ra,8(sp)
 1812700:	df000115 	stw	fp,4(sp)
 1812704:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1812708:	00806134 	movhi	r2,388
 181270c:	10839904 	addi	r2,r2,3684
 1812710:	e0bfff15 	stw	r2,-4(fp)
 1812714:	00000606 	br	1812730 <_do_ctors+0x38>
        (*ctor) (); 
 1812718:	e0bfff17 	ldw	r2,-4(fp)
 181271c:	10800017 	ldw	r2,0(r2)
 1812720:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1812724:	e0bfff17 	ldw	r2,-4(fp)
 1812728:	10bfff04 	addi	r2,r2,-4
 181272c:	e0bfff15 	stw	r2,-4(fp)
 1812730:	e0ffff17 	ldw	r3,-4(fp)
 1812734:	00806134 	movhi	r2,388
 1812738:	10839a04 	addi	r2,r2,3688
 181273c:	18bff62e 	bgeu	r3,r2,1812718 <__ram_exceptions_end+0xff8022d4>
        (*ctor) (); 
}
 1812740:	0001883a 	nop
 1812744:	e037883a 	mov	sp,fp
 1812748:	dfc00117 	ldw	ra,4(sp)
 181274c:	df000017 	ldw	fp,0(sp)
 1812750:	dec00204 	addi	sp,sp,8
 1812754:	f800283a 	ret

01812758 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 1812758:	defffd04 	addi	sp,sp,-12
 181275c:	dfc00215 	stw	ra,8(sp)
 1812760:	df000115 	stw	fp,4(sp)
 1812764:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1812768:	00806134 	movhi	r2,388
 181276c:	10839904 	addi	r2,r2,3684
 1812770:	e0bfff15 	stw	r2,-4(fp)
 1812774:	00000606 	br	1812790 <_do_dtors+0x38>
        (*dtor) (); 
 1812778:	e0bfff17 	ldw	r2,-4(fp)
 181277c:	10800017 	ldw	r2,0(r2)
 1812780:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1812784:	e0bfff17 	ldw	r2,-4(fp)
 1812788:	10bfff04 	addi	r2,r2,-4
 181278c:	e0bfff15 	stw	r2,-4(fp)
 1812790:	e0ffff17 	ldw	r3,-4(fp)
 1812794:	00806134 	movhi	r2,388
 1812798:	10839a04 	addi	r2,r2,3688
 181279c:	18bff62e 	bgeu	r3,r2,1812778 <__ram_exceptions_end+0xff802334>
        (*dtor) (); 
}
 18127a0:	0001883a 	nop
 18127a4:	e037883a 	mov	sp,fp
 18127a8:	dfc00117 	ldw	ra,4(sp)
 18127ac:	df000017 	ldw	fp,0(sp)
 18127b0:	dec00204 	addi	sp,sp,8
 18127b4:	f800283a 	ret

018127b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 18127b8:	defffe04 	addi	sp,sp,-8
 18127bc:	dfc00115 	stw	ra,4(sp)
 18127c0:	df000015 	stw	fp,0(sp)
 18127c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 18127c8:	d0a01917 	ldw	r2,-32668(gp)
 18127cc:	10000326 	beq	r2,zero,18127dc <alt_get_errno+0x24>
 18127d0:	d0a01917 	ldw	r2,-32668(gp)
 18127d4:	103ee83a 	callr	r2
 18127d8:	00000106 	br	18127e0 <alt_get_errno+0x28>
 18127dc:	d0a7ce04 	addi	r2,gp,-24776
}
 18127e0:	e037883a 	mov	sp,fp
 18127e4:	dfc00117 	ldw	ra,4(sp)
 18127e8:	df000017 	ldw	fp,0(sp)
 18127ec:	dec00204 	addi	sp,sp,8
 18127f0:	f800283a 	ret

018127f4 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 18127f4:	defffb04 	addi	sp,sp,-20
 18127f8:	dfc00415 	stw	ra,16(sp)
 18127fc:	df000315 	stw	fp,12(sp)
 1812800:	df000304 	addi	fp,sp,12
 1812804:	e13ffe15 	stw	r4,-8(fp)
 1812808:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 181280c:	e0bffe17 	ldw	r2,-8(fp)
 1812810:	10000616 	blt	r2,zero,181282c <fstat+0x38>
 1812814:	e0bffe17 	ldw	r2,-8(fp)
 1812818:	10c00324 	muli	r3,r2,12
 181281c:	00806134 	movhi	r2,388
 1812820:	1091ff04 	addi	r2,r2,18428
 1812824:	1885883a 	add	r2,r3,r2
 1812828:	00000106 	br	1812830 <fstat+0x3c>
 181282c:	0005883a 	mov	r2,zero
 1812830:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 1812834:	e0bffd17 	ldw	r2,-12(fp)
 1812838:	10001026 	beq	r2,zero,181287c <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 181283c:	e0bffd17 	ldw	r2,-12(fp)
 1812840:	10800017 	ldw	r2,0(r2)
 1812844:	10800817 	ldw	r2,32(r2)
 1812848:	10000726 	beq	r2,zero,1812868 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 181284c:	e0bffd17 	ldw	r2,-12(fp)
 1812850:	10800017 	ldw	r2,0(r2)
 1812854:	10800817 	ldw	r2,32(r2)
 1812858:	e17fff17 	ldw	r5,-4(fp)
 181285c:	e13ffd17 	ldw	r4,-12(fp)
 1812860:	103ee83a 	callr	r2
 1812864:	00000a06 	br	1812890 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 1812868:	e0bfff17 	ldw	r2,-4(fp)
 181286c:	00c80004 	movi	r3,8192
 1812870:	10c00115 	stw	r3,4(r2)
      return 0;
 1812874:	0005883a 	mov	r2,zero
 1812878:	00000506 	br	1812890 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 181287c:	18127b80 	call	18127b8 <alt_get_errno>
 1812880:	1007883a 	mov	r3,r2
 1812884:	00801444 	movi	r2,81
 1812888:	18800015 	stw	r2,0(r3)
    return -1;
 181288c:	00bfffc4 	movi	r2,-1
  }
}
 1812890:	e037883a 	mov	sp,fp
 1812894:	dfc00117 	ldw	ra,4(sp)
 1812898:	df000017 	ldw	fp,0(sp)
 181289c:	dec00204 	addi	sp,sp,8
 18128a0:	f800283a 	ret

018128a4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 18128a4:	defff904 	addi	sp,sp,-28
 18128a8:	dfc00615 	stw	ra,24(sp)
 18128ac:	df000515 	stw	fp,20(sp)
 18128b0:	df000504 	addi	fp,sp,20
 18128b4:	e13ffc15 	stw	r4,-16(fp)
 18128b8:	e17ffd15 	stw	r5,-12(fp)
 18128bc:	e1bffe15 	stw	r6,-8(fp)
 18128c0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 18128c4:	e1bfff17 	ldw	r6,-4(fp)
 18128c8:	e17ffe17 	ldw	r5,-8(fp)
 18128cc:	e13ffd17 	ldw	r4,-12(fp)
 18128d0:	1812dc00 	call	1812dc0 <open>
 18128d4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 18128d8:	e0bffb17 	ldw	r2,-20(fp)
 18128dc:	10001c16 	blt	r2,zero,1812950 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 18128e0:	00806134 	movhi	r2,388
 18128e4:	1091ff04 	addi	r2,r2,18428
 18128e8:	e0fffb17 	ldw	r3,-20(fp)
 18128ec:	18c00324 	muli	r3,r3,12
 18128f0:	10c5883a 	add	r2,r2,r3
 18128f4:	10c00017 	ldw	r3,0(r2)
 18128f8:	e0bffc17 	ldw	r2,-16(fp)
 18128fc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 1812900:	00806134 	movhi	r2,388
 1812904:	1091ff04 	addi	r2,r2,18428
 1812908:	e0fffb17 	ldw	r3,-20(fp)
 181290c:	18c00324 	muli	r3,r3,12
 1812910:	10c5883a 	add	r2,r2,r3
 1812914:	10800104 	addi	r2,r2,4
 1812918:	10c00017 	ldw	r3,0(r2)
 181291c:	e0bffc17 	ldw	r2,-16(fp)
 1812920:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 1812924:	00806134 	movhi	r2,388
 1812928:	1091ff04 	addi	r2,r2,18428
 181292c:	e0fffb17 	ldw	r3,-20(fp)
 1812930:	18c00324 	muli	r3,r3,12
 1812934:	10c5883a 	add	r2,r2,r3
 1812938:	10800204 	addi	r2,r2,8
 181293c:	10c00017 	ldw	r3,0(r2)
 1812940:	e0bffc17 	ldw	r2,-16(fp)
 1812944:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 1812948:	e13ffb17 	ldw	r4,-20(fp)
 181294c:	181317c0 	call	181317c <alt_release_fd>
  }
} 
 1812950:	0001883a 	nop
 1812954:	e037883a 	mov	sp,fp
 1812958:	dfc00117 	ldw	ra,4(sp)
 181295c:	df000017 	ldw	fp,0(sp)
 1812960:	dec00204 	addi	sp,sp,8
 1812964:	f800283a 	ret

01812968 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 1812968:	defffb04 	addi	sp,sp,-20
 181296c:	dfc00415 	stw	ra,16(sp)
 1812970:	df000315 	stw	fp,12(sp)
 1812974:	df000304 	addi	fp,sp,12
 1812978:	e13ffd15 	stw	r4,-12(fp)
 181297c:	e17ffe15 	stw	r5,-8(fp)
 1812980:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1812984:	01c07fc4 	movi	r7,511
 1812988:	01800044 	movi	r6,1
 181298c:	e17ffd17 	ldw	r5,-12(fp)
 1812990:	01006134 	movhi	r4,388
 1812994:	21120204 	addi	r4,r4,18440
 1812998:	18128a40 	call	18128a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 181299c:	01c07fc4 	movi	r7,511
 18129a0:	000d883a 	mov	r6,zero
 18129a4:	e17ffe17 	ldw	r5,-8(fp)
 18129a8:	01006134 	movhi	r4,388
 18129ac:	2111ff04 	addi	r4,r4,18428
 18129b0:	18128a40 	call	18128a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 18129b4:	01c07fc4 	movi	r7,511
 18129b8:	01800044 	movi	r6,1
 18129bc:	e17fff17 	ldw	r5,-4(fp)
 18129c0:	01006134 	movhi	r4,388
 18129c4:	21120504 	addi	r4,r4,18452
 18129c8:	18128a40 	call	18128a4 <alt_open_fd>
}  
 18129cc:	0001883a 	nop
 18129d0:	e037883a 	mov	sp,fp
 18129d4:	dfc00117 	ldw	ra,4(sp)
 18129d8:	df000017 	ldw	fp,0(sp)
 18129dc:	dec00204 	addi	sp,sp,8
 18129e0:	f800283a 	ret

018129e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 18129e4:	defffe04 	addi	sp,sp,-8
 18129e8:	dfc00115 	stw	ra,4(sp)
 18129ec:	df000015 	stw	fp,0(sp)
 18129f0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 18129f4:	d0a01917 	ldw	r2,-32668(gp)
 18129f8:	10000326 	beq	r2,zero,1812a08 <alt_get_errno+0x24>
 18129fc:	d0a01917 	ldw	r2,-32668(gp)
 1812a00:	103ee83a 	callr	r2
 1812a04:	00000106 	br	1812a0c <alt_get_errno+0x28>
 1812a08:	d0a7ce04 	addi	r2,gp,-24776
}
 1812a0c:	e037883a 	mov	sp,fp
 1812a10:	dfc00117 	ldw	ra,4(sp)
 1812a14:	df000017 	ldw	fp,0(sp)
 1812a18:	dec00204 	addi	sp,sp,8
 1812a1c:	f800283a 	ret

01812a20 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 1812a20:	deffed04 	addi	sp,sp,-76
 1812a24:	dfc01215 	stw	ra,72(sp)
 1812a28:	df001115 	stw	fp,68(sp)
 1812a2c:	df001104 	addi	fp,sp,68
 1812a30:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1812a34:	e0bfff17 	ldw	r2,-4(fp)
 1812a38:	10000616 	blt	r2,zero,1812a54 <isatty+0x34>
 1812a3c:	e0bfff17 	ldw	r2,-4(fp)
 1812a40:	10c00324 	muli	r3,r2,12
 1812a44:	00806134 	movhi	r2,388
 1812a48:	1091ff04 	addi	r2,r2,18428
 1812a4c:	1885883a 	add	r2,r3,r2
 1812a50:	00000106 	br	1812a58 <isatty+0x38>
 1812a54:	0005883a 	mov	r2,zero
 1812a58:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 1812a5c:	e0bfef17 	ldw	r2,-68(fp)
 1812a60:	10000e26 	beq	r2,zero,1812a9c <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 1812a64:	e0bfef17 	ldw	r2,-68(fp)
 1812a68:	10800017 	ldw	r2,0(r2)
 1812a6c:	10800817 	ldw	r2,32(r2)
 1812a70:	1000021e 	bne	r2,zero,1812a7c <isatty+0x5c>
    {
      return 1;
 1812a74:	00800044 	movi	r2,1
 1812a78:	00000d06 	br	1812ab0 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 1812a7c:	e0bff004 	addi	r2,fp,-64
 1812a80:	100b883a 	mov	r5,r2
 1812a84:	e13fff17 	ldw	r4,-4(fp)
 1812a88:	18127f40 	call	18127f4 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 1812a8c:	e0bff117 	ldw	r2,-60(fp)
 1812a90:	10880020 	cmpeqi	r2,r2,8192
 1812a94:	10803fcc 	andi	r2,r2,255
 1812a98:	00000506 	br	1812ab0 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1812a9c:	18129e40 	call	18129e4 <alt_get_errno>
 1812aa0:	1007883a 	mov	r3,r2
 1812aa4:	00801444 	movi	r2,81
 1812aa8:	18800015 	stw	r2,0(r3)
    return 0;
 1812aac:	0005883a 	mov	r2,zero
  }
}
 1812ab0:	e037883a 	mov	sp,fp
 1812ab4:	dfc00117 	ldw	ra,4(sp)
 1812ab8:	df000017 	ldw	fp,0(sp)
 1812abc:	dec00204 	addi	sp,sp,8
 1812ac0:	f800283a 	ret

01812ac4 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 1812ac4:	defffc04 	addi	sp,sp,-16
 1812ac8:	df000315 	stw	fp,12(sp)
 1812acc:	df000304 	addi	fp,sp,12
 1812ad0:	e13ffd15 	stw	r4,-12(fp)
 1812ad4:	e17ffe15 	stw	r5,-8(fp)
 1812ad8:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 1812adc:	e0fffe17 	ldw	r3,-8(fp)
 1812ae0:	e0bffd17 	ldw	r2,-12(fp)
 1812ae4:	18800c26 	beq	r3,r2,1812b18 <alt_load_section+0x54>
  {
    while( to != end )
 1812ae8:	00000806 	br	1812b0c <alt_load_section+0x48>
    {
      *to++ = *from++;
 1812aec:	e0bffe17 	ldw	r2,-8(fp)
 1812af0:	10c00104 	addi	r3,r2,4
 1812af4:	e0fffe15 	stw	r3,-8(fp)
 1812af8:	e0fffd17 	ldw	r3,-12(fp)
 1812afc:	19000104 	addi	r4,r3,4
 1812b00:	e13ffd15 	stw	r4,-12(fp)
 1812b04:	18c00017 	ldw	r3,0(r3)
 1812b08:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 1812b0c:	e0fffe17 	ldw	r3,-8(fp)
 1812b10:	e0bfff17 	ldw	r2,-4(fp)
 1812b14:	18bff51e 	bne	r3,r2,1812aec <__ram_exceptions_end+0xff8026a8>
    {
      *to++ = *from++;
    }
  }
}
 1812b18:	0001883a 	nop
 1812b1c:	e037883a 	mov	sp,fp
 1812b20:	df000017 	ldw	fp,0(sp)
 1812b24:	dec00104 	addi	sp,sp,4
 1812b28:	f800283a 	ret

01812b2c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 1812b2c:	defffe04 	addi	sp,sp,-8
 1812b30:	dfc00115 	stw	ra,4(sp)
 1812b34:	df000015 	stw	fp,0(sp)
 1812b38:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 1812b3c:	01806134 	movhi	r6,388
 1812b40:	31977204 	addi	r6,r6,24008
 1812b44:	01406134 	movhi	r5,388
 1812b48:	294fcc04 	addi	r5,r5,16176
 1812b4c:	01006134 	movhi	r4,388
 1812b50:	21177204 	addi	r4,r4,24008
 1812b54:	1812ac40 	call	1812ac4 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 1812b58:	01808074 	movhi	r6,513
 1812b5c:	31811104 	addi	r6,r6,1092
 1812b60:	01408074 	movhi	r5,513
 1812b64:	29400804 	addi	r5,r5,32
 1812b68:	01006034 	movhi	r4,384
 1812b6c:	21000004 	addi	r4,r4,0
 1812b70:	1812ac40 	call	1812ac4 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 1812b74:	01806134 	movhi	r6,388
 1812b78:	318fcc04 	addi	r6,r6,16176
 1812b7c:	01406134 	movhi	r5,388
 1812b80:	29439a04 	addi	r5,r5,3688
 1812b84:	01006134 	movhi	r4,388
 1812b88:	21039a04 	addi	r4,r4,3688
 1812b8c:	1812ac40 	call	1812ac4 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 1812b90:	1827b7c0 	call	1827b7c <alt_dcache_flush_all>
  alt_icache_flush_all();
 1812b94:	18280e80 	call	18280e8 <alt_icache_flush_all>
}
 1812b98:	0001883a 	nop
 1812b9c:	e037883a 	mov	sp,fp
 1812ba0:	dfc00117 	ldw	ra,4(sp)
 1812ba4:	df000017 	ldw	fp,0(sp)
 1812ba8:	dec00204 	addi	sp,sp,8
 1812bac:	f800283a 	ret

01812bb0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1812bb0:	defffe04 	addi	sp,sp,-8
 1812bb4:	dfc00115 	stw	ra,4(sp)
 1812bb8:	df000015 	stw	fp,0(sp)
 1812bbc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1812bc0:	d0a01917 	ldw	r2,-32668(gp)
 1812bc4:	10000326 	beq	r2,zero,1812bd4 <alt_get_errno+0x24>
 1812bc8:	d0a01917 	ldw	r2,-32668(gp)
 1812bcc:	103ee83a 	callr	r2
 1812bd0:	00000106 	br	1812bd8 <alt_get_errno+0x28>
 1812bd4:	d0a7ce04 	addi	r2,gp,-24776
}
 1812bd8:	e037883a 	mov	sp,fp
 1812bdc:	dfc00117 	ldw	ra,4(sp)
 1812be0:	df000017 	ldw	fp,0(sp)
 1812be4:	dec00204 	addi	sp,sp,8
 1812be8:	f800283a 	ret

01812bec <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 1812bec:	defff904 	addi	sp,sp,-28
 1812bf0:	dfc00615 	stw	ra,24(sp)
 1812bf4:	df000515 	stw	fp,20(sp)
 1812bf8:	df000504 	addi	fp,sp,20
 1812bfc:	e13ffd15 	stw	r4,-12(fp)
 1812c00:	e17ffe15 	stw	r5,-8(fp)
 1812c04:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 1812c08:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1812c0c:	e0bffd17 	ldw	r2,-12(fp)
 1812c10:	10000616 	blt	r2,zero,1812c2c <lseek+0x40>
 1812c14:	e0bffd17 	ldw	r2,-12(fp)
 1812c18:	10c00324 	muli	r3,r2,12
 1812c1c:	00806134 	movhi	r2,388
 1812c20:	1091ff04 	addi	r2,r2,18428
 1812c24:	1885883a 	add	r2,r3,r2
 1812c28:	00000106 	br	1812c30 <lseek+0x44>
 1812c2c:	0005883a 	mov	r2,zero
 1812c30:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 1812c34:	e0bffc17 	ldw	r2,-16(fp)
 1812c38:	10001026 	beq	r2,zero,1812c7c <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 1812c3c:	e0bffc17 	ldw	r2,-16(fp)
 1812c40:	10800017 	ldw	r2,0(r2)
 1812c44:	10800717 	ldw	r2,28(r2)
 1812c48:	10000926 	beq	r2,zero,1812c70 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 1812c4c:	e0bffc17 	ldw	r2,-16(fp)
 1812c50:	10800017 	ldw	r2,0(r2)
 1812c54:	10800717 	ldw	r2,28(r2)
 1812c58:	e1bfff17 	ldw	r6,-4(fp)
 1812c5c:	e17ffe17 	ldw	r5,-8(fp)
 1812c60:	e13ffc17 	ldw	r4,-16(fp)
 1812c64:	103ee83a 	callr	r2
 1812c68:	e0bffb15 	stw	r2,-20(fp)
 1812c6c:	00000506 	br	1812c84 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 1812c70:	00bfde84 	movi	r2,-134
 1812c74:	e0bffb15 	stw	r2,-20(fp)
 1812c78:	00000206 	br	1812c84 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 1812c7c:	00bfebc4 	movi	r2,-81
 1812c80:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 1812c84:	e0bffb17 	ldw	r2,-20(fp)
 1812c88:	1000070e 	bge	r2,zero,1812ca8 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 1812c8c:	1812bb00 	call	1812bb0 <alt_get_errno>
 1812c90:	1007883a 	mov	r3,r2
 1812c94:	e0bffb17 	ldw	r2,-20(fp)
 1812c98:	0085c83a 	sub	r2,zero,r2
 1812c9c:	18800015 	stw	r2,0(r3)
    rc = -1;
 1812ca0:	00bfffc4 	movi	r2,-1
 1812ca4:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 1812ca8:	e0bffb17 	ldw	r2,-20(fp)
}
 1812cac:	e037883a 	mov	sp,fp
 1812cb0:	dfc00117 	ldw	ra,4(sp)
 1812cb4:	df000017 	ldw	fp,0(sp)
 1812cb8:	dec00204 	addi	sp,sp,8
 1812cbc:	f800283a 	ret

01812cc0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1812cc0:	defffe04 	addi	sp,sp,-8
 1812cc4:	dfc00115 	stw	ra,4(sp)
 1812cc8:	df000015 	stw	fp,0(sp)
 1812ccc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1812cd0:	d0a01917 	ldw	r2,-32668(gp)
 1812cd4:	10000326 	beq	r2,zero,1812ce4 <alt_get_errno+0x24>
 1812cd8:	d0a01917 	ldw	r2,-32668(gp)
 1812cdc:	103ee83a 	callr	r2
 1812ce0:	00000106 	br	1812ce8 <alt_get_errno+0x28>
 1812ce4:	d0a7ce04 	addi	r2,gp,-24776
}
 1812ce8:	e037883a 	mov	sp,fp
 1812cec:	dfc00117 	ldw	ra,4(sp)
 1812cf0:	df000017 	ldw	fp,0(sp)
 1812cf4:	dec00204 	addi	sp,sp,8
 1812cf8:	f800283a 	ret

01812cfc <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 1812cfc:	defffd04 	addi	sp,sp,-12
 1812d00:	df000215 	stw	fp,8(sp)
 1812d04:	df000204 	addi	fp,sp,8
 1812d08:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 1812d0c:	e0bfff17 	ldw	r2,-4(fp)
 1812d10:	10800217 	ldw	r2,8(r2)
 1812d14:	10d00034 	orhi	r3,r2,16384
 1812d18:	e0bfff17 	ldw	r2,-4(fp)
 1812d1c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1812d20:	e03ffe15 	stw	zero,-8(fp)
 1812d24:	00001d06 	br	1812d9c <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1812d28:	00806134 	movhi	r2,388
 1812d2c:	1091ff04 	addi	r2,r2,18428
 1812d30:	e0fffe17 	ldw	r3,-8(fp)
 1812d34:	18c00324 	muli	r3,r3,12
 1812d38:	10c5883a 	add	r2,r2,r3
 1812d3c:	10c00017 	ldw	r3,0(r2)
 1812d40:	e0bfff17 	ldw	r2,-4(fp)
 1812d44:	10800017 	ldw	r2,0(r2)
 1812d48:	1880111e 	bne	r3,r2,1812d90 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1812d4c:	00806134 	movhi	r2,388
 1812d50:	1091ff04 	addi	r2,r2,18428
 1812d54:	e0fffe17 	ldw	r3,-8(fp)
 1812d58:	18c00324 	muli	r3,r3,12
 1812d5c:	10c5883a 	add	r2,r2,r3
 1812d60:	10800204 	addi	r2,r2,8
 1812d64:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1812d68:	1000090e 	bge	r2,zero,1812d90 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 1812d6c:	e0bffe17 	ldw	r2,-8(fp)
 1812d70:	10c00324 	muli	r3,r2,12
 1812d74:	00806134 	movhi	r2,388
 1812d78:	1091ff04 	addi	r2,r2,18428
 1812d7c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1812d80:	e0bfff17 	ldw	r2,-4(fp)
 1812d84:	18800226 	beq	r3,r2,1812d90 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 1812d88:	00bffcc4 	movi	r2,-13
 1812d8c:	00000806 	br	1812db0 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1812d90:	e0bffe17 	ldw	r2,-8(fp)
 1812d94:	10800044 	addi	r2,r2,1
 1812d98:	e0bffe15 	stw	r2,-8(fp)
 1812d9c:	d0a00a17 	ldw	r2,-32728(gp)
 1812da0:	1007883a 	mov	r3,r2
 1812da4:	e0bffe17 	ldw	r2,-8(fp)
 1812da8:	18bfdf2e 	bgeu	r3,r2,1812d28 <__ram_exceptions_end+0xff8028e4>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 1812dac:	0005883a 	mov	r2,zero
}
 1812db0:	e037883a 	mov	sp,fp
 1812db4:	df000017 	ldw	fp,0(sp)
 1812db8:	dec00104 	addi	sp,sp,4
 1812dbc:	f800283a 	ret

01812dc0 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 1812dc0:	defff604 	addi	sp,sp,-40
 1812dc4:	dfc00915 	stw	ra,36(sp)
 1812dc8:	df000815 	stw	fp,32(sp)
 1812dcc:	df000804 	addi	fp,sp,32
 1812dd0:	e13ffd15 	stw	r4,-12(fp)
 1812dd4:	e17ffe15 	stw	r5,-8(fp)
 1812dd8:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 1812ddc:	00bfffc4 	movi	r2,-1
 1812de0:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 1812de4:	00bffb44 	movi	r2,-19
 1812de8:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 1812dec:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 1812df0:	d1600804 	addi	r5,gp,-32736
 1812df4:	e13ffd17 	ldw	r4,-12(fp)
 1812df8:	1827c7c0 	call	1827c7c <alt_find_dev>
 1812dfc:	e0bff815 	stw	r2,-32(fp)
 1812e00:	e0bff817 	ldw	r2,-32(fp)
 1812e04:	1000051e 	bne	r2,zero,1812e1c <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 1812e08:	e13ffd17 	ldw	r4,-12(fp)
 1812e0c:	1827d0c0 	call	1827d0c <alt_find_file>
 1812e10:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 1812e14:	00800044 	movi	r2,1
 1812e18:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 1812e1c:	e0bff817 	ldw	r2,-32(fp)
 1812e20:	10002926 	beq	r2,zero,1812ec8 <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 1812e24:	e13ff817 	ldw	r4,-32(fp)
 1812e28:	1827e140 	call	1827e14 <alt_get_fd>
 1812e2c:	e0bff915 	stw	r2,-28(fp)
 1812e30:	e0bff917 	ldw	r2,-28(fp)
 1812e34:	1000030e 	bge	r2,zero,1812e44 <open+0x84>
    {
      status = index;
 1812e38:	e0bff917 	ldw	r2,-28(fp)
 1812e3c:	e0bffa15 	stw	r2,-24(fp)
 1812e40:	00002306 	br	1812ed0 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 1812e44:	e0bff917 	ldw	r2,-28(fp)
 1812e48:	10c00324 	muli	r3,r2,12
 1812e4c:	00806134 	movhi	r2,388
 1812e50:	1091ff04 	addi	r2,r2,18428
 1812e54:	1885883a 	add	r2,r3,r2
 1812e58:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 1812e5c:	e0fffe17 	ldw	r3,-8(fp)
 1812e60:	00900034 	movhi	r2,16384
 1812e64:	10bfffc4 	addi	r2,r2,-1
 1812e68:	1886703a 	and	r3,r3,r2
 1812e6c:	e0bffc17 	ldw	r2,-16(fp)
 1812e70:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1812e74:	e0bffb17 	ldw	r2,-20(fp)
 1812e78:	1000051e 	bne	r2,zero,1812e90 <open+0xd0>
 1812e7c:	e13ffc17 	ldw	r4,-16(fp)
 1812e80:	1812cfc0 	call	1812cfc <alt_file_locked>
 1812e84:	e0bffa15 	stw	r2,-24(fp)
 1812e88:	e0bffa17 	ldw	r2,-24(fp)
 1812e8c:	10001016 	blt	r2,zero,1812ed0 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1812e90:	e0bff817 	ldw	r2,-32(fp)
 1812e94:	10800317 	ldw	r2,12(r2)
 1812e98:	10000826 	beq	r2,zero,1812ebc <open+0xfc>
 1812e9c:	e0bff817 	ldw	r2,-32(fp)
 1812ea0:	10800317 	ldw	r2,12(r2)
 1812ea4:	e1ffff17 	ldw	r7,-4(fp)
 1812ea8:	e1bffe17 	ldw	r6,-8(fp)
 1812eac:	e17ffd17 	ldw	r5,-12(fp)
 1812eb0:	e13ffc17 	ldw	r4,-16(fp)
 1812eb4:	103ee83a 	callr	r2
 1812eb8:	00000106 	br	1812ec0 <open+0x100>
 1812ebc:	0005883a 	mov	r2,zero
 1812ec0:	e0bffa15 	stw	r2,-24(fp)
 1812ec4:	00000206 	br	1812ed0 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 1812ec8:	00bffb44 	movi	r2,-19
 1812ecc:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 1812ed0:	e0bffa17 	ldw	r2,-24(fp)
 1812ed4:	1000090e 	bge	r2,zero,1812efc <open+0x13c>
  {
    alt_release_fd (index);  
 1812ed8:	e13ff917 	ldw	r4,-28(fp)
 1812edc:	181317c0 	call	181317c <alt_release_fd>
    ALT_ERRNO = -status;
 1812ee0:	1812cc00 	call	1812cc0 <alt_get_errno>
 1812ee4:	1007883a 	mov	r3,r2
 1812ee8:	e0bffa17 	ldw	r2,-24(fp)
 1812eec:	0085c83a 	sub	r2,zero,r2
 1812ef0:	18800015 	stw	r2,0(r3)
    return -1;
 1812ef4:	00bfffc4 	movi	r2,-1
 1812ef8:	00000106 	br	1812f00 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 1812efc:	e0bff917 	ldw	r2,-28(fp)
}
 1812f00:	e037883a 	mov	sp,fp
 1812f04:	dfc00117 	ldw	ra,4(sp)
 1812f08:	df000017 	ldw	fp,0(sp)
 1812f0c:	dec00204 	addi	sp,sp,8
 1812f10:	f800283a 	ret

01812f14 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
 1812f14:	defff204 	addi	sp,sp,-56
 1812f18:	dfc00a15 	stw	ra,40(sp)
 1812f1c:	df000915 	stw	fp,36(sp)
 1812f20:	df000904 	addi	fp,sp,36
 1812f24:	e13fff15 	stw	r4,-4(fp)
 1812f28:	e1400215 	stw	r5,8(fp)
 1812f2c:	e1800315 	stw	r6,12(fp)
 1812f30:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
 1812f34:	e0800204 	addi	r2,fp,8
 1812f38:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
 1812f3c:	e0bfff17 	ldw	r2,-4(fp)
 1812f40:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
 1812f44:	00006f06 	br	1813104 <alt_printf+0x1f0>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 1812f48:	e0bff807 	ldb	r2,-32(fp)
 1812f4c:	10800960 	cmpeqi	r2,r2,37
 1812f50:	1000041e 	bne	r2,zero,1812f64 <alt_printf+0x50>
        {
            alt_putchar(c);
 1812f54:	e0bff807 	ldb	r2,-32(fp)
 1812f58:	1009883a 	mov	r4,r2
 1812f5c:	18131400 	call	1813140 <alt_putchar>
 1812f60:	00006806 	br	1813104 <alt_printf+0x1f0>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
 1812f64:	e0bff717 	ldw	r2,-36(fp)
 1812f68:	10c00044 	addi	r3,r2,1
 1812f6c:	e0fff715 	stw	r3,-36(fp)
 1812f70:	10800003 	ldbu	r2,0(r2)
 1812f74:	e0bff805 	stb	r2,-32(fp)
 1812f78:	e0bff807 	ldb	r2,-32(fp)
 1812f7c:	10006926 	beq	r2,zero,1813124 <alt_printf+0x210>
            {
                if (c == '%')
 1812f80:	e0bff807 	ldb	r2,-32(fp)
 1812f84:	10800958 	cmpnei	r2,r2,37
 1812f88:	1000041e 	bne	r2,zero,1812f9c <alt_printf+0x88>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
 1812f8c:	e0bff807 	ldb	r2,-32(fp)
 1812f90:	1009883a 	mov	r4,r2
 1812f94:	18131400 	call	1813140 <alt_putchar>
 1812f98:	00005a06 	br	1813104 <alt_printf+0x1f0>
                } 
                else if (c == 'c')
 1812f9c:	e0bff807 	ldb	r2,-32(fp)
 1812fa0:	108018d8 	cmpnei	r2,r2,99
 1812fa4:	1000081e 	bne	r2,zero,1812fc8 <alt_printf+0xb4>
                {
                    int v = va_arg(args, int);
 1812fa8:	e0bffe17 	ldw	r2,-8(fp)
 1812fac:	10c00104 	addi	r3,r2,4
 1812fb0:	e0fffe15 	stw	r3,-8(fp)
 1812fb4:	10800017 	ldw	r2,0(r2)
 1812fb8:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
 1812fbc:	e13ffd17 	ldw	r4,-12(fp)
 1812fc0:	18131400 	call	1813140 <alt_putchar>
 1812fc4:	00004f06 	br	1813104 <alt_printf+0x1f0>
                }
                else if (c == 'x')
 1812fc8:	e0bff807 	ldb	r2,-32(fp)
 1812fcc:	10801e18 	cmpnei	r2,r2,120
 1812fd0:	1000341e 	bne	r2,zero,18130a4 <alt_printf+0x190>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
 1812fd4:	e0bffe17 	ldw	r2,-8(fp)
 1812fd8:	10c00104 	addi	r3,r2,4
 1812fdc:	e0fffe15 	stw	r3,-8(fp)
 1812fe0:	10800017 	ldw	r2,0(r2)
 1812fe4:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
 1812fe8:	e0bffb17 	ldw	r2,-20(fp)
 1812fec:	1000031e 	bne	r2,zero,1812ffc <alt_printf+0xe8>
                    {
                        alt_putchar('0');
 1812ff0:	01000c04 	movi	r4,48
 1812ff4:	18131400 	call	1813140 <alt_putchar>
                        continue;
 1812ff8:	00004206 	br	1813104 <alt_printf+0x1f0>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
 1812ffc:	00800704 	movi	r2,28
 1813000:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
 1813004:	00000306 	br	1813014 <alt_printf+0x100>
                        digit_shift -= 4;
 1813008:	e0bff917 	ldw	r2,-28(fp)
 181300c:	10bfff04 	addi	r2,r2,-4
 1813010:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 1813014:	00c003c4 	movi	r3,15
 1813018:	e0bff917 	ldw	r2,-28(fp)
 181301c:	1884983a 	sll	r2,r3,r2
 1813020:	1007883a 	mov	r3,r2
 1813024:	e0bffb17 	ldw	r2,-20(fp)
 1813028:	1884703a 	and	r2,r3,r2
 181302c:	103ff626 	beq	r2,zero,1813008 <__ram_exceptions_end+0xff802bc4>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 1813030:	00001906 	br	1813098 <alt_printf+0x184>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 1813034:	00c003c4 	movi	r3,15
 1813038:	e0bff917 	ldw	r2,-28(fp)
 181303c:	1884983a 	sll	r2,r3,r2
 1813040:	1007883a 	mov	r3,r2
 1813044:	e0bffb17 	ldw	r2,-20(fp)
 1813048:	1886703a 	and	r3,r3,r2
 181304c:	e0bff917 	ldw	r2,-28(fp)
 1813050:	1884d83a 	srl	r2,r3,r2
 1813054:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
 1813058:	e0bffc17 	ldw	r2,-16(fp)
 181305c:	108002a8 	cmpgeui	r2,r2,10
 1813060:	1000041e 	bne	r2,zero,1813074 <alt_printf+0x160>
                            c = '0' + digit;
 1813064:	e0bffc17 	ldw	r2,-16(fp)
 1813068:	10800c04 	addi	r2,r2,48
 181306c:	e0bff805 	stb	r2,-32(fp)
 1813070:	00000306 	br	1813080 <alt_printf+0x16c>
                        else
                            c = 'a' + digit - 10;
 1813074:	e0bffc17 	ldw	r2,-16(fp)
 1813078:	108015c4 	addi	r2,r2,87
 181307c:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
 1813080:	e0bff807 	ldb	r2,-32(fp)
 1813084:	1009883a 	mov	r4,r2
 1813088:	18131400 	call	1813140 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 181308c:	e0bff917 	ldw	r2,-28(fp)
 1813090:	10bfff04 	addi	r2,r2,-4
 1813094:	e0bff915 	stw	r2,-28(fp)
 1813098:	e0bff917 	ldw	r2,-28(fp)
 181309c:	103fe50e 	bge	r2,zero,1813034 <__ram_exceptions_end+0xff802bf0>
 18130a0:	00001806 	br	1813104 <alt_printf+0x1f0>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 18130a4:	e0bff807 	ldb	r2,-32(fp)
 18130a8:	10801cd8 	cmpnei	r2,r2,115
 18130ac:	1000151e 	bne	r2,zero,1813104 <alt_printf+0x1f0>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
 18130b0:	e0bffe17 	ldw	r2,-8(fp)
 18130b4:	10c00104 	addi	r3,r2,4
 18130b8:	e0fffe15 	stw	r3,-8(fp)
 18130bc:	10800017 	ldw	r2,0(r2)
 18130c0:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
 18130c4:	00000906 	br	18130ec <alt_printf+0x1d8>
                      alt_putchar(*s++);
 18130c8:	e0bffa17 	ldw	r2,-24(fp)
 18130cc:	10c00044 	addi	r3,r2,1
 18130d0:	e0fffa15 	stw	r3,-24(fp)
 18130d4:	10800003 	ldbu	r2,0(r2)
 18130d8:	10803fcc 	andi	r2,r2,255
 18130dc:	1080201c 	xori	r2,r2,128
 18130e0:	10bfe004 	addi	r2,r2,-128
 18130e4:	1009883a 	mov	r4,r2
 18130e8:	18131400 	call	1813140 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
 18130ec:	e0bffa17 	ldw	r2,-24(fp)
 18130f0:	10800003 	ldbu	r2,0(r2)
 18130f4:	10803fcc 	andi	r2,r2,255
 18130f8:	1080201c 	xori	r2,r2,128
 18130fc:	10bfe004 	addi	r2,r2,-128
 1813100:	103ff11e 	bne	r2,zero,18130c8 <__ram_exceptions_end+0xff802c84>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 1813104:	e0bff717 	ldw	r2,-36(fp)
 1813108:	10c00044 	addi	r3,r2,1
 181310c:	e0fff715 	stw	r3,-36(fp)
 1813110:	10800003 	ldbu	r2,0(r2)
 1813114:	e0bff805 	stb	r2,-32(fp)
 1813118:	e0bff807 	ldb	r2,-32(fp)
 181311c:	103f8a1e 	bne	r2,zero,1812f48 <__ram_exceptions_end+0xff802b04>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 1813120:	00000106 	br	1813128 <alt_printf+0x214>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
 1813124:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 1813128:	0001883a 	nop
 181312c:	e037883a 	mov	sp,fp
 1813130:	dfc00117 	ldw	ra,4(sp)
 1813134:	df000017 	ldw	fp,0(sp)
 1813138:	dec00504 	addi	sp,sp,20
 181313c:	f800283a 	ret

01813140 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 1813140:	defffd04 	addi	sp,sp,-12
 1813144:	dfc00215 	stw	ra,8(sp)
 1813148:	df000115 	stw	fp,4(sp)
 181314c:	df000104 	addi	fp,sp,4
 1813150:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
 1813154:	d0a00117 	ldw	r2,-32764(gp)
 1813158:	10800217 	ldw	r2,8(r2)
 181315c:	100b883a 	mov	r5,r2
 1813160:	e13fff17 	ldw	r4,-4(fp)
 1813164:	183d1740 	call	183d174 <putc>
#endif
#endif
}
 1813168:	e037883a 	mov	sp,fp
 181316c:	dfc00117 	ldw	ra,4(sp)
 1813170:	df000017 	ldw	fp,0(sp)
 1813174:	dec00204 	addi	sp,sp,8
 1813178:	f800283a 	ret

0181317c <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 181317c:	defffe04 	addi	sp,sp,-8
 1813180:	df000115 	stw	fp,4(sp)
 1813184:	df000104 	addi	fp,sp,4
 1813188:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 181318c:	e0bfff17 	ldw	r2,-4(fp)
 1813190:	108000d0 	cmplti	r2,r2,3
 1813194:	10000d1e 	bne	r2,zero,18131cc <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 1813198:	00806134 	movhi	r2,388
 181319c:	1091ff04 	addi	r2,r2,18428
 18131a0:	e0ffff17 	ldw	r3,-4(fp)
 18131a4:	18c00324 	muli	r3,r3,12
 18131a8:	10c5883a 	add	r2,r2,r3
 18131ac:	10800204 	addi	r2,r2,8
 18131b0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 18131b4:	00806134 	movhi	r2,388
 18131b8:	1091ff04 	addi	r2,r2,18428
 18131bc:	e0ffff17 	ldw	r3,-4(fp)
 18131c0:	18c00324 	muli	r3,r3,12
 18131c4:	10c5883a 	add	r2,r2,r3
 18131c8:	10000015 	stw	zero,0(r2)
  }
}
 18131cc:	0001883a 	nop
 18131d0:	e037883a 	mov	sp,fp
 18131d4:	df000017 	ldw	fp,0(sp)
 18131d8:	dec00104 	addi	sp,sp,4
 18131dc:	f800283a 	ret

018131e0 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 18131e0:	defff904 	addi	sp,sp,-28
 18131e4:	df000615 	stw	fp,24(sp)
 18131e8:	df000604 	addi	fp,sp,24
 18131ec:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18131f0:	0005303a 	rdctl	r2,status
 18131f4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18131f8:	e0fffe17 	ldw	r3,-8(fp)
 18131fc:	00bfff84 	movi	r2,-2
 1813200:	1884703a 	and	r2,r3,r2
 1813204:	1001703a 	wrctl	status,r2
  
  return context;
 1813208:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 181320c:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 1813210:	d0a00b17 	ldw	r2,-32724(gp)
 1813214:	10c000c4 	addi	r3,r2,3
 1813218:	00bfff04 	movi	r2,-4
 181321c:	1884703a 	and	r2,r3,r2
 1813220:	d0a00b15 	stw	r2,-32724(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 1813224:	d0e00b17 	ldw	r3,-32724(gp)
 1813228:	e0bfff17 	ldw	r2,-4(fp)
 181322c:	1887883a 	add	r3,r3,r2
 1813230:	00808034 	movhi	r2,512
 1813234:	10800004 	addi	r2,r2,0
 1813238:	10c0062e 	bgeu	r2,r3,1813254 <sbrk+0x74>
 181323c:	e0bffb17 	ldw	r2,-20(fp)
 1813240:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1813244:	e0bffa17 	ldw	r2,-24(fp)
 1813248:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 181324c:	00bfffc4 	movi	r2,-1
 1813250:	00000b06 	br	1813280 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 1813254:	d0a00b17 	ldw	r2,-32724(gp)
 1813258:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 181325c:	d0e00b17 	ldw	r3,-32724(gp)
 1813260:	e0bfff17 	ldw	r2,-4(fp)
 1813264:	1885883a 	add	r2,r3,r2
 1813268:	d0a00b15 	stw	r2,-32724(gp)
 181326c:	e0bffb17 	ldw	r2,-20(fp)
 1813270:	e0bffc15 	stw	r2,-16(fp)
 1813274:	e0bffc17 	ldw	r2,-16(fp)
 1813278:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 181327c:	e0bffd17 	ldw	r2,-12(fp)
} 
 1813280:	e037883a 	mov	sp,fp
 1813284:	df000017 	ldw	fp,0(sp)
 1813288:	dec00104 	addi	sp,sp,4
 181328c:	f800283a 	ret

01813290 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 1813290:	defffd04 	addi	sp,sp,-12
 1813294:	dfc00215 	stw	ra,8(sp)
 1813298:	df000115 	stw	fp,4(sp)
 181329c:	df000104 	addi	fp,sp,4
 18132a0:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 18132a4:	e13fff17 	ldw	r4,-4(fp)
 18132a8:	18278f00 	call	18278f0 <alt_busy_sleep>
}
 18132ac:	e037883a 	mov	sp,fp
 18132b0:	dfc00117 	ldw	ra,4(sp)
 18132b4:	df000017 	ldw	fp,0(sp)
 18132b8:	dec00204 	addi	sp,sp,8
 18132bc:	f800283a 	ret

018132c0 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 18132c0:	defffd04 	addi	sp,sp,-12
 18132c4:	dfc00215 	stw	ra,8(sp)
 18132c8:	df000115 	stw	fp,4(sp)
 18132cc:	df000104 	addi	fp,sp,4
 18132d0:	e13fff15 	stw	r4,-4(fp)
	if (fd < ALT_MAX_FD)
 18132d4:	e0bfff17 	ldw	r2,-4(fp)
 18132d8:	10800808 	cmpgei	r2,r2,32
 18132dc:	1000031e 	bne	r2,zero,18132ec <close+0x2c>
		return ALT_CLOSE (fd);
 18132e0:	e13fff17 	ldw	r4,-4(fp)
 18132e4:	1827a840 	call	1827a84 <alt_close>
 18132e8:	00000206 	br	18132f4 <close+0x34>
#if LWIP_SOCKET
	else
		return lwip_close((long) fd);
 18132ec:	e13fff17 	ldw	r4,-4(fp)
 18132f0:	1828fc80 	call	1828fc8 <lwip_close>
#else
	else
		return -1;
#endif
}
 18132f4:	e037883a 	mov	sp,fp
 18132f8:	dfc00117 	ldw	ra,4(sp)
 18132fc:	df000017 	ldw	fp,0(sp)
 1813300:	dec00204 	addi	sp,sp,8
 1813304:	f800283a 	ret

01813308 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 1813308:	defff904 	addi	sp,sp,-28
 181330c:	dfc00615 	stw	ra,24(sp)
 1813310:	df000515 	stw	fp,20(sp)
 1813314:	df000504 	addi	fp,sp,20
 1813318:	e13ffd15 	stw	r4,-12(fp)
 181331c:	e17ffe15 	stw	r5,-8(fp)
 1813320:	e1bfff15 	stw	r6,-4(fp)
	if (fd < ALT_MAX_FD)
 1813324:	e0bffd17 	ldw	r2,-12(fp)
 1813328:	10800808 	cmpgei	r2,r2,32
 181332c:	1000051e 	bne	r2,zero,1813344 <read+0x3c>
		return ALT_READ (fd, ptr, len);
 1813330:	e1bfff17 	ldw	r6,-4(fp)
 1813334:	e17ffe17 	ldw	r5,-8(fp)
 1813338:	e13ffd17 	ldw	r4,-12(fp)
 181333c:	18283f80 	call	18283f8 <alt_read>
 1813340:	00000706 	br	1813360 <read+0x58>
#if LWIP_SOCKET
	else
		return recvfrom(fd, ptr, len, 0, NULL, NULL);
 1813344:	d8000115 	stw	zero,4(sp)
 1813348:	d8000015 	stw	zero,0(sp)
 181334c:	000f883a 	mov	r7,zero
 1813350:	e1bfff17 	ldw	r6,-4(fp)
 1813354:	e17ffe17 	ldw	r5,-8(fp)
 1813358:	e13ffd17 	ldw	r4,-12(fp)
 181335c:	18292e00 	call	18292e0 <lwip_recvfrom>
#else
	else
		return -1;
#endif
}
 1813360:	e037883a 	mov	sp,fp
 1813364:	dfc00117 	ldw	ra,4(sp)
 1813368:	df000017 	ldw	fp,0(sp)
 181336c:	dec00204 	addi	sp,sp,8
 1813370:	f800283a 	ret

01813374 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 1813374:	defffb04 	addi	sp,sp,-20
 1813378:	dfc00415 	stw	ra,16(sp)
 181337c:	df000315 	stw	fp,12(sp)
 1813380:	df000304 	addi	fp,sp,12
 1813384:	e13ffd15 	stw	r4,-12(fp)
 1813388:	e17ffe15 	stw	r5,-8(fp)
 181338c:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 1813390:	e0bffd17 	ldw	r2,-12(fp)
 1813394:	10800808 	cmpgei	r2,r2,32
 1813398:	1000051e 	bne	r2,zero,18133b0 <write+0x3c>
    return ALT_WRITE(fd, ptr, len);
 181339c:	e1bfff17 	ldw	r6,-4(fp)
 18133a0:	e17ffe17 	ldw	r5,-8(fp)
 18133a4:	e13ffd17 	ldw	r4,-12(fp)
 18133a8:	18287040 	call	1828704 <alt_write>
 18133ac:	00000506 	br	18133c4 <write+0x50>
#if LWIP_SOCKET
  else
    return send (fd, (void*) ptr, len, 0);
 18133b0:	000f883a 	mov	r7,zero
 18133b4:	e1bfff17 	ldw	r6,-4(fp)
 18133b8:	e17ffe17 	ldw	r5,-8(fp)
 18133bc:	e13ffd17 	ldw	r4,-12(fp)
 18133c0:	18298540 	call	1829854 <lwip_send>
#else
	else
		return -1;
#endif
}
 18133c4:	e037883a 	mov	sp,fp
 18133c8:	dfc00117 	ldw	ra,4(sp)
 18133cc:	df000017 	ldw	fp,0(sp)
 18133d0:	dec00204 	addi	sp,sp,8
 18133d4:	f800283a 	ret

018133d8 <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
 18133d8:	defffc04 	addi	sp,sp,-16
 18133dc:	dfc00315 	stw	ra,12(sp)
 18133e0:	df000215 	stw	fp,8(sp)
 18133e4:	df000204 	addi	fp,sp,8
 18133e8:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 18133ec:	e0bfff17 	ldw	r2,-4(fp)
 18133f0:	10800917 	ldw	r2,36(r2)
 18133f4:	e0bffe15 	stw	r2,-8(fp)

	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
 18133f8:	e0bfff17 	ldw	r2,-4(fp)
 18133fc:	00c00184 	movi	r3,6
 1813400:	10c00c85 	stb	r3,50(r2)

	/* maximum transfer unit */
	netif->mtu = IP_FRAG_MAX_MTU;
 1813404:	e0bfff17 	ldw	r2,-4(fp)
 1813408:	00c17704 	movi	r3,1500
 181340c:	10c00c0d 	sth	r3,48(r2)

	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 1813410:	e0bfff17 	ldw	r2,-4(fp)
 1813414:	00c00c84 	movi	r3,50
 1813418:	10c00e45 	stb	r3,57(r2)

	tse_mac_init(netif->num, ethernetif);
 181341c:	e0bfff17 	ldw	r2,-4(fp)
 1813420:	10800f03 	ldbu	r2,60(r2)
 1813424:	10803fcc 	andi	r2,r2,255
 1813428:	e17ffe17 	ldw	r5,-8(fp)
 181342c:	1009883a 	mov	r4,r2
 1813430:	18142100 	call	1814210 <tse_mac_init>
}
 1813434:	0001883a 	nop
 1813438:	e037883a 	mov	sp,fp
 181343c:	dfc00117 	ldw	ra,4(sp)
 1813440:	df000017 	ldw	fp,0(sp)
 1813444:	dec00204 	addi	sp,sp,8
 1813448:	f800283a 	ret

0181344c <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
 181344c:	defffa04 	addi	sp,sp,-24
 1813450:	dfc00515 	stw	ra,20(sp)
 1813454:	df000415 	stw	fp,16(sp)
 1813458:	df000404 	addi	fp,sp,16
 181345c:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 1813460:	e0bfff17 	ldw	r2,-4(fp)
 1813464:	10800917 	ldw	r2,36(r2)
 1813468:	e0bffd15 	stw	r2,-12(fp)
	struct pbuf *p, *nextPkt;

	if(ethernetif->lwipRxCount <= 0)
 181346c:	e0bffd17 	ldw	r2,-12(fp)
 1813470:	10801517 	ldw	r2,84(r2)
 1813474:	00800216 	blt	zero,r2,1813480 <low_level_input+0x34>
		return NULL;
 1813478:	0005883a 	mov	r2,zero
 181347c:	00004306 	br	181358c <low_level_input+0x140>

	//  Dump current packet if there is no memory for the next packet.
	//  The lwipRxPbuf must contain pointers to pbufs at all times.
	nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
 1813480:	018000c4 	movi	r6,3
 1813484:	01417b04 	movi	r5,1516
 1813488:	010000c4 	movi	r4,3
 181348c:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1813490:	e0bffe15 	stw	r2,-8(fp)
	if(nextPkt == NULL)
 1813494:	e0bffe17 	ldw	r2,-8(fp)
 1813498:	1000101e 	bne	r2,zero,18134dc <low_level_input+0x90>
	{
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("no pbuf available\n"));

		LINK_STATS_INC(link.memerr);
 181349c:	008061f4 	movhi	r2,391
 18134a0:	10a9d404 	addi	r2,r2,-22704
 18134a4:	10800617 	ldw	r2,24(r2)
 18134a8:	10c00044 	addi	r3,r2,1
 18134ac:	008061f4 	movhi	r2,391
 18134b0:	10a9d404 	addi	r2,r2,-22704
 18134b4:	10c00615 	stw	r3,24(r2)
		LINK_STATS_INC(link.drop);
 18134b8:	008061f4 	movhi	r2,391
 18134bc:	10a9d404 	addi	r2,r2,-22704
 18134c0:	10800317 	ldw	r2,12(r2)
 18134c4:	10c00044 	addi	r3,r2,1
 18134c8:	008061f4 	movhi	r2,391
 18134cc:	10a9d404 	addi	r2,r2,-22704
 18134d0:	10c00315 	stw	r3,12(r2)
		return NULL;
 18134d4:	0005883a 	mov	r2,zero
 18134d8:	00002c06 	br	181358c <low_level_input+0x140>
	}

	nextPkt = (void*)(((alt_u32)nextPkt));
	nextPkt->payload = (void*)(((alt_u32)nextPkt->payload));
 18134dc:	e0bffe17 	ldw	r2,-8(fp)
 18134e0:	10c00117 	ldw	r3,4(r2)
 18134e4:	e0bffe17 	ldw	r2,-8(fp)
 18134e8:	10c00115 	stw	r3,4(r2)

	enh_alt_irq_disable_all();
 18134ec:	18275c00 	call	18275c0 <enh_alt_irq_disable_all>

	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex];
 18134f0:	e0bffd17 	ldw	r2,-12(fp)
 18134f4:	10801417 	ldw	r2,80(r2)
 18134f8:	e0fffd17 	ldw	r3,-12(fp)
 18134fc:	108001c4 	addi	r2,r2,7
 1813500:	1085883a 	add	r2,r2,r2
 1813504:	1085883a 	add	r2,r2,r2
 1813508:	1885883a 	add	r2,r3,r2
 181350c:	10800017 	ldw	r2,0(r2)
 1813510:	e0bffc15 	stw	r2,-16(fp)
	ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex] = nextPkt;
 1813514:	e0bffd17 	ldw	r2,-12(fp)
 1813518:	10801417 	ldw	r2,80(r2)
 181351c:	e0fffd17 	ldw	r3,-12(fp)
 1813520:	108001c4 	addi	r2,r2,7
 1813524:	1085883a 	add	r2,r2,r2
 1813528:	1085883a 	add	r2,r2,r2
 181352c:	1885883a 	add	r2,r3,r2
 1813530:	e0fffe17 	ldw	r3,-8(fp)
 1813534:	10c00015 	stw	r3,0(r2)
	if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
 1813538:	e0bffd17 	ldw	r2,-12(fp)
 181353c:	10801417 	ldw	r2,80(r2)
 1813540:	10800044 	addi	r2,r2,1
 1813544:	e0fffd17 	ldw	r3,-12(fp)
 1813548:	18801415 	stw	r2,80(r3)
 181354c:	10800310 	cmplti	r2,r2,12
 1813550:	1000021e 	bne	r2,zero,181355c <low_level_input+0x110>
		ethernetif->lwipRxIndex = 0;
 1813554:	e0bffd17 	ldw	r2,-12(fp)
 1813558:	10001415 	stw	zero,80(r2)

	--ethernetif->lwipRxCount;
 181355c:	e0bffd17 	ldw	r2,-12(fp)
 1813560:	10801517 	ldw	r2,84(r2)
 1813564:	10ffffc4 	addi	r3,r2,-1
 1813568:	e0bffd17 	ldw	r2,-12(fp)
 181356c:	10c01515 	stw	r3,84(r2)

	enh_alt_irq_enable_all();
 1813570:	18276100 	call	1827610 <enh_alt_irq_enable_all>

	LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
	LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );

	if( p->len == 0 )
 1813574:	e0bffc17 	ldw	r2,-16(fp)
 1813578:	1080028b 	ldhu	r2,10(r2)
 181357c:	10bfffcc 	andi	r2,r2,65535
 1813580:	1000011e 	bne	r2,zero,1813588 <low_level_input+0x13c>
		p = NULL;
 1813584:	e03ffc15 	stw	zero,-16(fp)

	return p;
 1813588:	e0bffc17 	ldw	r2,-16(fp)
}
 181358c:	e037883a 	mov	sp,fp
 1813590:	dfc00117 	ldw	ra,4(sp)
 1813594:	df000017 	ldw	fp,0(sp)
 1813598:	dec00204 	addi	sp,sp,8
 181359c:	f800283a 	ret

018135a0 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
int
ethernetif_input(struct netif *netif)
{
 18135a0:	defffa04 	addi	sp,sp,-24
 18135a4:	dfc00515 	stw	ra,20(sp)
 18135a8:	df000415 	stw	fp,16(sp)
 18135ac:	df000404 	addi	fp,sp,16
 18135b0:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;
	struct eth_hdr *ethhdr;
	struct pbuf *p;

	ethernetif = netif->state;
 18135b4:	e0bfff17 	ldw	r2,-4(fp)
 18135b8:	10800917 	ldw	r2,36(r2)
 18135bc:	e0bffc15 	stw	r2,-16(fp)

	/* move received packet into a new pbuf */
	p = low_level_input(netif);
 18135c0:	e13fff17 	ldw	r4,-4(fp)
 18135c4:	181344c0 	call	181344c <low_level_input>
 18135c8:	e0bffd15 	stw	r2,-12(fp)

	/* no packet could be read, silently ignore this */
	if (p == NULL) return -1;
 18135cc:	e0bffd17 	ldw	r2,-12(fp)
 18135d0:	1000021e 	bne	r2,zero,18135dc <ethernetif_input+0x3c>
 18135d4:	00bfffc4 	movi	r2,-1
 18135d8:	00002b06 	br	1813688 <ethernetif_input+0xe8>

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = p->payload;
 18135dc:	e0bffd17 	ldw	r2,-12(fp)
 18135e0:	10800117 	ldw	r2,4(r2)
 18135e4:	e0bffe15 	stw	r2,-8(fp)

	LINK_STATS_INC(link.recv);
 18135e8:	008061f4 	movhi	r2,391
 18135ec:	10a9d404 	addi	r2,r2,-22704
 18135f0:	10800117 	ldw	r2,4(r2)
 18135f4:	10c00044 	addi	r3,r2,1
 18135f8:	008061f4 	movhi	r2,391
 18135fc:	10a9d404 	addi	r2,r2,-22704
 1813600:	10c00115 	stw	r3,4(r2)
		pbuf_free(p);
		p = NULL;
		break;
	}
#else
	switch (htons(ethhdr->type)) {
 1813604:	e0bffe17 	ldw	r2,-8(fp)
 1813608:	10c00383 	ldbu	r3,14(r2)
 181360c:	108003c3 	ldbu	r2,15(r2)
 1813610:	1004923a 	slli	r2,r2,8
 1813614:	10c4b03a 	or	r2,r2,r3
 1813618:	10bfffcc 	andi	r2,r2,65535
 181361c:	1004d23a 	srli	r2,r2,8
 1813620:	10ffffcc 	andi	r3,r2,65535
 1813624:	e0bffe17 	ldw	r2,-8(fp)
 1813628:	11000383 	ldbu	r4,14(r2)
 181362c:	108003c3 	ldbu	r2,15(r2)
 1813630:	1004923a 	slli	r2,r2,8
 1813634:	1104b03a 	or	r2,r2,r4
 1813638:	10bfffcc 	andi	r2,r2,65535
 181363c:	1004923a 	slli	r2,r2,8
 1813640:	10bfffcc 	andi	r2,r2,65535
 1813644:	1884b03a 	or	r2,r3,r2
 1813648:	10c20020 	cmpeqi	r3,r2,2048
 181364c:	1800021e 	bne	r3,zero,1813658 <ethernetif_input+0xb8>
 1813650:	108201a0 	cmpeqi	r2,r2,2054
 1813654:	10000626 	beq	r2,zero,1813670 <ethernetif_input+0xd0>
#if PPPOE_SUPPORT
	/* PPPoE packet? */
	case ETHTYPE_PPPOEDISC:
	case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
		netif->input(p, netif);
 1813658:	e0bfff17 	ldw	r2,-4(fp)
 181365c:	10800417 	ldw	r2,16(r2)
 1813660:	e17fff17 	ldw	r5,-4(fp)
 1813664:	e13ffd17 	ldw	r4,-12(fp)
 1813668:	103ee83a 	callr	r2
		break;
 181366c:	00000406 	br	1813680 <ethernetif_input+0xe0>

	default:
		pbuf_free( p );
 1813670:	e13ffd17 	ldw	r4,-12(fp)
 1813674:	181aca40 	call	181aca4 <pbuf_free>
		p = NULL;
 1813678:	e03ffd15 	stw	zero,-12(fp)
		break;
 181367c:	0001883a 	nop
	}
#endif

	// return the waiting packet count
	return ethernetif->lwipRxCount;
 1813680:	e0bffc17 	ldw	r2,-16(fp)
 1813684:	10801517 	ldw	r2,84(r2)
}
 1813688:	e037883a 	mov	sp,fp
 181368c:	dfc00117 	ldw	ra,4(sp)
 1813690:	df000017 	ldw	fp,0(sp)
 1813694:	dec00204 	addi	sp,sp,8
 1813698:	f800283a 	ret

0181369c <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 181369c:	defff904 	addi	sp,sp,-28
 18136a0:	dfc00615 	stw	ra,24(sp)
 18136a4:	df000515 	stw	fp,20(sp)
 18136a8:	df000504 	addi	fp,sp,20
 18136ac:	e13fff15 	stw	r4,-4(fp)
	err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);
	char *tmpptr;

	LWIP_ASSERT("netif != NULL", (netif != NULL));

	ethernetif = mem_malloc(sizeof(struct ethernetif));
 18136b0:	01001804 	movi	r4,96
 18136b4:	18197f00 	call	18197f0 <mem_malloc>
 18136b8:	e0bffc15 	stw	r2,-16(fp)
	if (ethernetif == NULL) {
 18136bc:	e0bffc17 	ldw	r2,-16(fp)
 18136c0:	1000021e 	bne	r2,zero,18136cc <ethernetif_init+0x30>
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
 18136c4:	00bfffc4 	movi	r2,-1
 18136c8:	00005b06 	br	1813838 <ethernetif_init+0x19c>
	}

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	if (get_hostname(netif->num, (const char**)&tmpptr) == ERR_OK)
 18136cc:	e0bfff17 	ldw	r2,-4(fp)
 18136d0:	10800f03 	ldbu	r2,60(r2)
 18136d4:	10803fcc 	andi	r2,r2,255
 18136d8:	e0fffe04 	addi	r3,fp,-8
 18136dc:	180b883a 	mov	r5,r3
 18136e0:	1009883a 	mov	r4,r2
 18136e4:	1800a340 	call	1800a34 <get_hostname>
 18136e8:	1000041e 	bne	r2,zero,18136fc <ethernetif_init+0x60>
		netif->hostname = tmpptr;
 18136ec:	e0fffe17 	ldw	r3,-8(fp)
 18136f0:	e0bfff17 	ldw	r2,-4(fp)
 18136f4:	10c00b15 	stw	r3,44(r2)
 18136f8:	00000406 	br	181370c <ethernetif_init+0x70>
	else
		netif->hostname = "lwip";
 18136fc:	e0ffff17 	ldw	r3,-4(fp)
 1813700:	00806134 	movhi	r2,388
 1813704:	10859904 	addi	r2,r2,5732
 1813708:	18800b15 	stw	r2,44(r3)
	 * of bits per second.
	 */
	NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

	// pointer abuse, don't worry ;)
	netif->state = ethernetif;
 181370c:	e0bfff17 	ldw	r2,-4(fp)
 1813710:	e0fffc17 	ldw	r3,-16(fp)
 1813714:	10c00915 	stw	r3,36(r2)
	if (get_iface_name(netif->num, (char*)&tmpptr) == ERR_OK) {
 1813718:	e0bfff17 	ldw	r2,-4(fp)
 181371c:	10800f03 	ldbu	r2,60(r2)
 1813720:	10803fcc 	andi	r2,r2,255
 1813724:	e0fffe04 	addi	r3,fp,-8
 1813728:	180b883a 	mov	r5,r3
 181372c:	1009883a 	mov	r4,r2
 1813730:	1800a6c0 	call	1800a6c <get_iface_name>
 1813734:	1000081e 	bne	r2,zero,1813758 <ethernetif_init+0xbc>
		netif->name[0] = ((char*)&tmpptr)[0];
 1813738:	e0bffe04 	addi	r2,fp,-8
 181373c:	10c00003 	ldbu	r3,0(r2)
 1813740:	e0bfff17 	ldw	r2,-4(fp)
 1813744:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = ((char*)&tmpptr)[1];
 1813748:	e0fffe43 	ldbu	r3,-7(fp)
 181374c:	e0bfff17 	ldw	r2,-4(fp)
 1813750:	10c00ec5 	stb	r3,59(r2)
 1813754:	00000606 	br	1813770 <ethernetif_init+0xd4>
	} else {
		netif->name[0] = 'e';
 1813758:	e0bfff17 	ldw	r2,-4(fp)
 181375c:	00c01944 	movi	r3,101
 1813760:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = 't';
 1813764:	e0bfff17 	ldw	r2,-4(fp)
 1813768:	00c01d04 	movi	r3,116
 181376c:	10c00ec5 	stb	r3,59(r2)

	/* We directly use etharp_output() here to save a function call.
	 * You can instead declare your own function an call etharp_output()
	 * from it if you have to do some checks before sending (e.g. if link
	 * is available...) */
	netif->output = etharp_output;
 1813770:	e0ffff17 	ldw	r3,-4(fp)
 1813774:	008060b4 	movhi	r2,386
 1813778:	108ee604 	addi	r2,r2,15256
 181377c:	18800515 	stw	r2,20(r3)
	netif->linkoutput = tse_mac_raw_send;
 1813780:	e0ffff17 	ldw	r3,-4(fp)
 1813784:	00806074 	movhi	r2,385
 1813788:	1092e504 	addi	r2,r2,19348
 181378c:	18800615 	stw	r2,24(r3)

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
 1813790:	e0bfff17 	ldw	r2,-4(fp)
 1813794:	10c00cc4 	addi	r3,r2,51
 1813798:	e0bffc17 	ldw	r2,-16(fp)
 181379c:	10c00015 	stw	r3,0(r2)

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 18137a0:	e03ffb15 	stw	zero,-20(fp)
 18137a4:	00001806 	br	1813808 <ethernetif_init+0x16c>
	{
		p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
 18137a8:	018000c4 	movi	r6,3
 18137ac:	01417b04 	movi	r5,1516
 18137b0:	010000c4 	movi	r4,3
 18137b4:	181a4e80 	call	181a4e8 <pbuf_alloc>
 18137b8:	e0bffd15 	stw	r2,-12(fp)
		if (p == NULL)
 18137bc:	e0bffd17 	ldw	r2,-12(fp)
 18137c0:	1000021e 	bne	r2,zero,18137cc <ethernetif_init+0x130>
			return ERR_MEM;
 18137c4:	00bfffc4 	movi	r2,-1
 18137c8:	00001b06 	br	1813838 <ethernetif_init+0x19c>
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
 18137cc:	e0bffd17 	ldw	r2,-12(fp)
 18137d0:	10c00117 	ldw	r3,4(r2)
 18137d4:	e0bffd17 	ldw	r2,-12(fp)
 18137d8:	10c00115 	stw	r3,4(r2)
		ethernetif->lwipRxPbuf[idx] = p;
 18137dc:	e0fffc17 	ldw	r3,-16(fp)
 18137e0:	e0bffb17 	ldw	r2,-20(fp)
 18137e4:	108001c4 	addi	r2,r2,7
 18137e8:	1085883a 	add	r2,r2,r2
 18137ec:	1085883a 	add	r2,r2,r2
 18137f0:	1885883a 	add	r2,r3,r2
 18137f4:	e0fffd17 	ldw	r3,-12(fp)
 18137f8:	10c00015 	stw	r3,0(r2)
	netif->linkoutput = tse_mac_raw_send;

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 18137fc:	e0bffb17 	ldw	r2,-20(fp)
 1813800:	10800044 	addi	r2,r2,1
 1813804:	e0bffb15 	stw	r2,-20(fp)
 1813808:	e0bffb17 	ldw	r2,-20(fp)
 181380c:	10800310 	cmplti	r2,r2,12
 1813810:	103fe51e 	bne	r2,zero,18137a8 <__ram_exceptions_end+0xff803364>
			return ERR_MEM;
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
		ethernetif->lwipRxPbuf[idx] = p;
	}
	ethernetif->lwipRxCount = 0;
 1813814:	e0bffc17 	ldw	r2,-16(fp)
 1813818:	10001515 	stw	zero,84(r2)
	ethernetif->lwipRxIndex = 0;
 181381c:	e0bffc17 	ldw	r2,-16(fp)
 1813820:	10001415 	stw	zero,80(r2)
	ethernetif->lwipRxIndexIsr = 0;
 1813824:	e0bffc17 	ldw	r2,-16(fp)
 1813828:	10001315 	stw	zero,76(r2)

	/* initialize the low level hardware */
	low_level_init(netif);
 181382c:	e13fff17 	ldw	r4,-4(fp)
 1813830:	18133d80 	call	18133d8 <low_level_init>

	return ERR_OK;
 1813834:	0005883a 	mov	r2,zero
}
 1813838:	e037883a 	mov	sp,fp
 181383c:	dfc00117 	ldw	ra,4(sp)
 1813840:	df000017 	ldw	fp,0(sp)
 1813844:	dec00204 	addi	sp,sp,8
 1813848:	f800283a 	ret

0181384c <lwip_initialize>:
}
#endif

// Function which initializes the LwIP TCP/IP stack
void lwip_initialize(int waitForAll)
{
 181384c:	defffa04 	addi	sp,sp,-24
 1813850:	dfc00515 	stw	ra,20(sp)
 1813854:	df000415 	stw	fp,16(sp)
 1813858:	df000404 	addi	fp,sp,16
 181385c:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int upCount = 0;
 1813860:	e03ffd15 	stw	zero,-12(fp)
	int activeCount = 0;
 1813864:	e03ffe15 	stw	zero,-8(fp)
		return;
	}
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);
 1813868:	000b883a 	mov	r5,zero
 181386c:	01006074 	movhi	r4,385
 1813870:	210e7b04 	addi	r4,r4,14828
 1813874:	182c0700 	call	182c070 <tcpip_init>

	for (idx = 0; idx < PHY_COUNT; ++idx)
 1813878:	e03ffc15 	stw	zero,-16(fp)
 181387c:	00000906 	br	18138a4 <lwip_initialize+0x58>
		if (is_interface_active(idx))
 1813880:	e13ffc17 	ldw	r4,-16(fp)
 1813884:	1800ab40 	call	1800ab4 <is_interface_active>
 1813888:	10000326 	beq	r2,zero,1813898 <lwip_initialize+0x4c>
			++activeCount;
 181388c:	e0bffe17 	ldw	r2,-8(fp)
 1813890:	10800044 	addi	r2,r2,1
 1813894:	e0bffe15 	stw	r2,-8(fp)
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);

	for (idx = 0; idx < PHY_COUNT; ++idx)
 1813898:	e0bffc17 	ldw	r2,-16(fp)
 181389c:	10800044 	addi	r2,r2,1
 18138a0:	e0bffc15 	stw	r2,-16(fp)
 18138a4:	e0bffc17 	ldw	r2,-16(fp)
 18138a8:	00bff50e 	bge	zero,r2,1813880 <__ram_exceptions_end+0xff80343c>
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 18138ac:	00001d06 	br	1813924 <lwip_initialize+0xd8>
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 18138b0:	e03ffc15 	stw	zero,-16(fp)
 18138b4:	00001706 	br	1813914 <lwip_initialize+0xc8>
		{
			if (is_interface_active(idx) && netif_is_up(&eth_tse[idx]))
 18138b8:	e13ffc17 	ldw	r4,-16(fp)
 18138bc:	1800ab40 	call	1800ab4 <is_interface_active>
 18138c0:	10001126 	beq	r2,zero,1813908 <lwip_initialize+0xbc>
 18138c4:	008061b4 	movhi	r2,390
 18138c8:	1089a804 	addi	r2,r2,9888
 18138cc:	e0fffc17 	ldw	r3,-16(fp)
 18138d0:	18c01124 	muli	r3,r3,68
 18138d4:	10c5883a 	add	r2,r2,r3
 18138d8:	10800e44 	addi	r2,r2,57
 18138dc:	10800003 	ldbu	r2,0(r2)
 18138e0:	10803fcc 	andi	r2,r2,255
 18138e4:	1080004c 	andi	r2,r2,1
 18138e8:	10000726 	beq	r2,zero,1813908 <lwip_initialize+0xbc>
			{
				printf("[lwip_eth%d] up\r\n", idx);
 18138ec:	e17ffc17 	ldw	r5,-16(fp)
 18138f0:	01006134 	movhi	r4,388
 18138f4:	21059b04 	addi	r4,r4,5740
 18138f8:	1800c180 	call	1800c18 <printf>
				++upCount;
 18138fc:	e0bffd17 	ldw	r2,-12(fp)
 1813900:	10800044 	addi	r2,r2,1
 1813904:	e0bffd15 	stw	r2,-12(fp)
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 1813908:	e0bffc17 	ldw	r2,-16(fp)
 181390c:	10800044 	addi	r2,r2,1
 1813910:	e0bffc15 	stw	r2,-16(fp)
 1813914:	e0bffc17 	ldw	r2,-16(fp)
 1813918:	00bfe70e 	bge	zero,r2,18138b8 <__ram_exceptions_end+0xff803474>
				printf("[lwip_eth%d] up\r\n", idx);
				++upCount;
			}
		}

		mssleep(10);
 181391c:	0109c404 	movi	r4,10000
 1813920:	18132900 	call	1813290 <usleep>
	for (idx = 0; idx < PHY_COUNT; ++idx)
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 1813924:	e0bfff17 	ldw	r2,-4(fp)
 1813928:	10000326 	beq	r2,zero,1813938 <lwip_initialize+0xec>
 181392c:	e0fffe17 	ldw	r3,-8(fp)
 1813930:	e0bffd17 	ldw	r2,-12(fp)
 1813934:	18bfde1e 	bne	r3,r2,18138b0 <__ram_exceptions_end+0xff80346c>
 1813938:	e0bfff17 	ldw	r2,-4(fp)
 181393c:	1000021e 	bne	r2,zero,1813948 <lwip_initialize+0xfc>
 1813940:	e0bffd17 	ldw	r2,-12(fp)
 1813944:	103fda26 	beq	r2,zero,18138b0 <__ram_exceptions_end+0xff80346c>
			}
		}

		mssleep(10);
	}
}
 1813948:	0001883a 	nop
 181394c:	e037883a 	mov	sp,fp
 1813950:	dfc00117 	ldw	ra,4(sp)
 1813954:	df000017 	ldw	fp,0(sp)
 1813958:	dec00204 	addi	sp,sp,8
 181395c:	f800283a 	ret

01813960 <lwip_wait_for_an>:
#endif

#define MAX_RETRY_COUNT			3

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
 1813960:	defffb04 	addi	sp,sp,-20
 1813964:	dfc00415 	stw	ra,16(sp)
 1813968:	df000315 	stw	fp,12(sp)
 181396c:	df000304 	addi	fp,sp,12
 1813970:	e13ffe15 	stw	r4,-8(fp)
 1813974:	e17fff15 	stw	r5,-4(fp)
	int retryCount = MAX_RETRY_COUNT;
 1813978:	008000c4 	movi	r2,3
 181397c:	e0bffd15 	stw	r2,-12(fp)

	while (ethernetif->link_alive != 1 && --retryCount) {
 1813980:	00000b06 	br	18139b0 <lwip_wait_for_an+0x50>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
 1813984:	00c000c4 	movi	r3,3
 1813988:	e0bffd17 	ldw	r2,-12(fp)
 181398c:	1887c83a 	sub	r3,r3,r2
 1813990:	008000b4 	movhi	r2,2
 1813994:	10a1a804 	addi	r2,r2,-31072
 1813998:	1885383a 	mul	r2,r3,r2
 181399c:	1009883a 	mov	r4,r2
 18139a0:	18132900 	call	1813290 <usleep>
		tse_mac_init(idx, ethernetif);
 18139a4:	e17fff17 	ldw	r5,-4(fp)
 18139a8:	e13ffe17 	ldw	r4,-8(fp)
 18139ac:	18142100 	call	1814210 <tse_mac_init>

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
	int retryCount = MAX_RETRY_COUNT;

	while (ethernetif->link_alive != 1 && --retryCount) {
 18139b0:	e0bfff17 	ldw	r2,-4(fp)
 18139b4:	10800217 	ldw	r2,8(r2)
 18139b8:	10800060 	cmpeqi	r2,r2,1
 18139bc:	1000051e 	bne	r2,zero,18139d4 <lwip_wait_for_an+0x74>
 18139c0:	e0bffd17 	ldw	r2,-12(fp)
 18139c4:	10bfffc4 	addi	r2,r2,-1
 18139c8:	e0bffd15 	stw	r2,-12(fp)
 18139cc:	e0bffd17 	ldw	r2,-12(fp)
 18139d0:	103fec1e 	bne	r2,zero,1813984 <__ram_exceptions_end+0xff803540>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
		tse_mac_init(idx, ethernetif);
	}

	return retryCount;
 18139d4:	e0bffd17 	ldw	r2,-12(fp)
}
 18139d8:	e037883a 	mov	sp,fp
 18139dc:	dfc00117 	ldw	ra,4(sp)
 18139e0:	df000017 	ldw	fp,0(sp)
 18139e4:	dec00204 	addi	sp,sp,8
 18139e8:	f800283a 	ret

018139ec <lwip_handle_interfaces>:

void lwip_handle_interfaces(__unused void *params)
{
 18139ec:	deffe904 	addi	sp,sp,-92
 18139f0:	dfc01615 	stw	ra,88(sp)
 18139f4:	df001515 	stw	fp,84(sp)
 18139f8:	df001504 	addi	fp,sp,84
 18139fc:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int active_macs = 0;
 1813a00:	e03fef15 	stw	zero,-68(fp)
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
 1813a04:	e03ffb15 	stw	zero,-20(fp)
 1813a08:	e03ffc15 	stw	zero,-16(fp)
 1813a0c:	e03ffd15 	stw	zero,-12(fp)
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 1813a10:	e03fee15 	stw	zero,-72(fp)
 1813a14:	00008406 	br	1813c28 <lwip_handle_interfaces+0x23c>
	{
		struct netif *eth = &eth_tse[idx];
 1813a18:	e0bfee17 	ldw	r2,-72(fp)
 1813a1c:	10c01124 	muli	r3,r2,68
 1813a20:	008061b4 	movhi	r2,390
 1813a24:	1089a804 	addi	r2,r2,9888
 1813a28:	1885883a 	add	r2,r3,r2
 1813a2c:	e0bff015 	stw	r2,-64(fp)

		// Load platform specific MAC address into netif
		if (get_mac_addr(idx, eth, eth->hwaddr) != EXIT_SUCCESS)
 1813a30:	e0bff017 	ldw	r2,-64(fp)
 1813a34:	10800cc4 	addi	r2,r2,51
 1813a38:	100d883a 	mov	r6,r2
 1813a3c:	e17ff017 	ldw	r5,-64(fp)
 1813a40:	e13fee17 	ldw	r4,-72(fp)
 1813a44:	18008600 	call	1800860 <get_mac_addr>
 1813a48:	10000326 	beq	r2,zero,1813a58 <lwip_handle_interfaces+0x6c>
			printf("[LwIP] Failed to get MAC address\n");
 1813a4c:	01006134 	movhi	r4,388
 1813a50:	2105a004 	addi	r4,r4,5760
 1813a54:	183d2fc0 	call	183d2fc <puts>

		// Get the requested IP configuration for the given interface
		if (get_ip_addr(idx, &ip, &subnet, &gateway, &dhcp) != EXIT_SUCCESS)
 1813a58:	e17ffd04 	addi	r5,fp,-12
 1813a5c:	e13ffc04 	addi	r4,fp,-16
 1813a60:	e0fffb04 	addi	r3,fp,-20
 1813a64:	e0bffe04 	addi	r2,fp,-8
 1813a68:	d8800015 	stw	r2,0(sp)
 1813a6c:	280f883a 	mov	r7,r5
 1813a70:	200d883a 	mov	r6,r4
 1813a74:	180b883a 	mov	r5,r3
 1813a78:	e13fee17 	ldw	r4,-72(fp)
 1813a7c:	180097c0 	call	180097c <get_ip_addr>
 1813a80:	10000326 	beq	r2,zero,1813a90 <lwip_handle_interfaces+0xa4>
			printf("[LwIP] Failed to get IP config\n");
 1813a84:	01006134 	movhi	r4,388
 1813a88:	2105a904 	addi	r4,r4,5796
 1813a8c:	183d2fc0 	call	183d2fc <puts>

		//  Initialize lwIP, Altera TSE and the ethernetif
#if NO_SYS
		if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, ethernet_input) == NULL)
#else
			if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, tcpip_input) == NULL)
 1813a90:	e0bff017 	ldw	r2,-64(fp)
 1813a94:	10c00917 	ldw	r3,36(r2)
 1813a98:	e1bffd04 	addi	r6,fp,-12
 1813a9c:	e17ffc04 	addi	r5,fp,-16
 1813aa0:	e13ffb04 	addi	r4,fp,-20
 1813aa4:	008060f4 	movhi	r2,387
 1813aa8:	10af1b04 	addi	r2,r2,-17300
 1813aac:	d8800215 	stw	r2,8(sp)
 1813ab0:	00806074 	movhi	r2,385
 1813ab4:	108da704 	addi	r2,r2,13980
 1813ab8:	d8800115 	stw	r2,4(sp)
 1813abc:	d8c00015 	stw	r3,0(sp)
 1813ac0:	300f883a 	mov	r7,r6
 1813ac4:	280d883a 	mov	r6,r5
 1813ac8:	200b883a 	mov	r5,r4
 1813acc:	e13ff017 	ldw	r4,-64(fp)
 1813ad0:	1819bb80 	call	1819bb8 <netif_add>
 1813ad4:	1000051e 	bne	r2,zero,1813aec <lwip_handle_interfaces+0x100>
#endif
			{
				printf("[eth%d] Fatal error initializing...\n", idx);
 1813ad8:	e17fee17 	ldw	r5,-72(fp)
 1813adc:	01006134 	movhi	r4,388
 1813ae0:	2105b104 	addi	r4,r4,5828
 1813ae4:	1800c180 	call	1800c18 <printf>
				for(;;) ;
 1813ae8:	003fff06 	br	1813ae8 <__ram_exceptions_end+0xff8036a4>
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
 1813aec:	e13fee17 	ldw	r4,-72(fp)
 1813af0:	1800ab40 	call	1800ab4 <is_interface_active>
 1813af4:	10004826 	beq	r2,zero,1813c18 <lwip_handle_interfaces+0x22c>
			continue;

		// update the active phy count
		++active_macs;
 1813af8:	e0bfef17 	ldw	r2,-68(fp)
 1813afc:	10800044 	addi	r2,r2,1
 1813b00:	e0bfef15 	stw	r2,-68(fp)

		if (active_macs == 1)
 1813b04:	e0bfef17 	ldw	r2,-68(fp)
 1813b08:	10800058 	cmpnei	r2,r2,1
 1813b0c:	1000021e 	bne	r2,zero,1813b18 <lwip_handle_interfaces+0x12c>
			netif_set_default(eth);
 1813b10:	e13ff017 	ldw	r4,-64(fp)
 1813b14:	181a0740 	call	181a074 <netif_set_default>

		// Set status and link callback (link is not working?)
		netif_set_status_callback(eth, lwip_status_callback);
 1813b18:	01406074 	movhi	r5,385
 1813b1c:	294ff804 	addi	r5,r5,16352
 1813b20:	e13ff017 	ldw	r4,-64(fp)
 1813b24:	181a1e40 	call	181a1e4 <netif_set_status_callback>

		if (link_callback)
 1813b28:	d0a7e917 	ldw	r2,-24668(gp)
 1813b2c:	10000426 	beq	r2,zero,1813b40 <lwip_handle_interfaces+0x154>
			netif_set_link_callback(eth, link_callback);
 1813b30:	d0a7e917 	ldw	r2,-24668(gp)
 1813b34:	100b883a 	mov	r5,r2
 1813b38:	e13ff017 	ldw	r4,-64(fp)
 1813b3c:	181a35c0 	call	181a35c <netif_set_link_callback>

		// Initialize Altera TSE in a loop if waiting for a link
		printf("Waiting for link... ");
 1813b40:	01006134 	movhi	r4,388
 1813b44:	2105bb04 	addi	r4,r4,5868
 1813b48:	1800c180 	call	1800c18 <printf>
		if (lwip_wait_for_an(idx, eth->state) < 0) {
 1813b4c:	e0bff017 	ldw	r2,-64(fp)
 1813b50:	10800917 	ldw	r2,36(r2)
 1813b54:	100b883a 	mov	r5,r2
 1813b58:	e13fee17 	ldw	r4,-72(fp)
 1813b5c:	18139600 	call	1813960 <lwip_wait_for_an>
 1813b60:	1000040e 	bge	r2,zero,1813b74 <lwip_handle_interfaces+0x188>
			printf("FAILED\n");
 1813b64:	01006134 	movhi	r4,388
 1813b68:	2105c104 	addi	r4,r4,5892
 1813b6c:	183d2fc0 	call	183d2fc <puts>
			continue;
 1813b70:	00002a06 	br	1813c1c <lwip_handle_interfaces+0x230>
		}

		printf("OK\n");
 1813b74:	01006134 	movhi	r4,388
 1813b78:	2105c304 	addi	r4,r4,5900
 1813b7c:	183d2fc0 	call	183d2fc <puts>

		// create input output task and start DHCP or static w/e
		snprintf(tmpbuf, OS_MAX_TASK_NAME_LEN, "LwIP %*sih", 2, eth->name);
 1813b80:	e0bff017 	ldw	r2,-64(fp)
 1813b84:	10800e84 	addi	r2,r2,58
 1813b88:	e0fff104 	addi	r3,fp,-60
 1813b8c:	d8800015 	stw	r2,0(sp)
 1813b90:	01c00084 	movi	r7,2
 1813b94:	01806134 	movhi	r6,388
 1813b98:	3185c404 	addi	r6,r6,5904
 1813b9c:	01400a04 	movi	r5,40
 1813ba0:	1809883a 	mov	r4,r3
 1813ba4:	183d3e80 	call	183d3e8 <snprintf>
		tmpbuf[(OS_MAX_TASK_NAME_LEN - 1)] = 0;
 1813ba8:	e03ffac5 	stb	zero,-21(fp)

		// create input task, this must be started before we can do any DHCP request
		if (sys_thread_new(tmpbuf, lwip_handle_ethernet_input, eth, KB(32), TCPIP_THREAD_PRIO) == NULL)
 1813bac:	e0fff104 	addi	r3,fp,-60
 1813bb0:	008000c4 	movi	r2,3
 1813bb4:	d8800015 	stw	r2,0(sp)
 1813bb8:	01e00014 	movui	r7,32768
 1813bbc:	e1bff017 	ldw	r6,-64(fp)
 1813bc0:	01406074 	movhi	r5,385
 1813bc4:	294f9604 	addi	r5,r5,15960
 1813bc8:	1809883a 	mov	r4,r3
 1813bcc:	181569c0 	call	181569c <sys_thread_new>
 1813bd0:	1000031e 	bne	r2,zero,1813be0 <lwip_handle_interfaces+0x1f4>
			printf("LwIP Couldn't create input / output task for ethernet\n");
 1813bd4:	01006134 	movhi	r4,388
 1813bd8:	2105c704 	addi	r4,r4,5916
 1813bdc:	183d2fc0 	call	183d2fc <puts>

		// wait previous DHCP to finish
		if (dhcp) {
 1813be0:	e0bffe17 	ldw	r2,-8(fp)
 1813be4:	10000926 	beq	r2,zero,1813c0c <lwip_handle_interfaces+0x220>
			printf("[LwIP] Start DHCP request...\n");
 1813be8:	01006134 	movhi	r4,388
 1813bec:	2105d504 	addi	r4,r4,5972
 1813bf0:	183d2fc0 	call	183d2fc <puts>

			dhcp_start(eth);
 1813bf4:	e13ff017 	ldw	r4,-64(fp)
 1813bf8:	18162540 	call	1816254 <dhcp_start>

			// wait till we got our address
			printf("[LwIP] Waiting for DHCP IP address...\n");
 1813bfc:	01006134 	movhi	r4,388
 1813c00:	2105dd04 	addi	r4,r4,6004
 1813c04:	183d2fc0 	call	183d2fc <puts>
 1813c08:	00000406 	br	1813c1c <lwip_handle_interfaces+0x230>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
 1813c0c:	e13ff017 	ldw	r4,-64(fp)
 1813c10:	181a0a00 	call	181a0a0 <netif_set_up>
 1813c14:	00000106 	br	1813c1c <lwip_handle_interfaces+0x230>
				for(;;) ;
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 1813c18:	0001883a 	nop
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 1813c1c:	e0bfee17 	ldw	r2,-72(fp)
 1813c20:	10800044 	addi	r2,r2,1
 1813c24:	e0bfee15 	stw	r2,-72(fp)
 1813c28:	e0bfee17 	ldw	r2,-72(fp)
 1813c2c:	00bf7a0e 	bge	zero,r2,1813a18 <__ram_exceptions_end+0xff8035d4>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
		}
	}
}
 1813c30:	0001883a 	nop
 1813c34:	e037883a 	mov	sp,fp
 1813c38:	dfc00117 	ldw	ra,4(sp)
 1813c3c:	df000017 	ldw	fp,0(sp)
 1813c40:	dec00204 	addi	sp,sp,8
 1813c44:	f800283a 	ret

01813c48 <get_mac_count>:
 * \brief Get the number of MAC's available in the NIOS build
 *
 * \returns the number of MAC's in the NIOS build
 */
int get_mac_count(void)
{
 1813c48:	deffff04 	addi	sp,sp,-4
 1813c4c:	df000015 	stw	fp,0(sp)
 1813c50:	d839883a 	mov	fp,sp
	return PHY_COUNT;
 1813c54:	00800044 	movi	r2,1
}
 1813c58:	e037883a 	mov	sp,fp
 1813c5c:	df000017 	ldw	fp,0(sp)
 1813c60:	dec00104 	addi	sp,sp,4
 1813c64:	f800283a 	ret

01813c68 <get_mac_base>:
 * \param [in] idx the index of the MAC
 *
 * \returns the base address of the MAC
 */
volatile np_tse_mac* get_mac_base(int idx)
{
 1813c68:	defffe04 	addi	sp,sp,-8
 1813c6c:	df000115 	stw	fp,4(sp)
 1813c70:	df000104 	addi	fp,sp,4
 1813c74:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 1813c78:	e0bfff17 	ldw	r2,-4(fp)
 1813c7c:	10800090 	cmplti	r2,r2,2
 1813c80:	1000021e 	bne	r2,zero,1813c8c <get_mac_base+0x24>
		return NULL;
 1813c84:	0005883a 	mov	r2,zero
 1813c88:	00000606 	br	1813ca4 <get_mac_base+0x3c>

	return (volatile np_tse_mac*)tse_mac_device[idx].tse_mac_base;
 1813c8c:	00806134 	movhi	r2,388
 1813c90:	1096c404 	addi	r2,r2,23312
 1813c94:	e0ffff17 	ldw	r3,-4(fp)
 1813c98:	18c01224 	muli	r3,r3,72
 1813c9c:	10c5883a 	add	r2,r2,r3
 1813ca0:	10800017 	ldw	r2,0(r2)
}
 1813ca4:	e037883a 	mov	sp,fp
 1813ca8:	df000017 	ldw	fp,0(sp)
 1813cac:	dec00104 	addi	sp,sp,4
 1813cb0:	f800283a 	ret

01813cb4 <get_netif>:
 * \brief Get the netif struct used by LwIP
 *
 * \return the reference to the netif used by LwIP
 */
struct netif* get_netif(int idx)
{
 1813cb4:	defffe04 	addi	sp,sp,-8
 1813cb8:	df000115 	stw	fp,4(sp)
 1813cbc:	df000104 	addi	fp,sp,4
 1813cc0:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 1813cc4:	e0bfff17 	ldw	r2,-4(fp)
 1813cc8:	10800090 	cmplti	r2,r2,2
 1813ccc:	1000021e 	bne	r2,zero,1813cd8 <get_netif+0x24>
		return NULL;
 1813cd0:	0005883a 	mov	r2,zero
 1813cd4:	00000506 	br	1813cec <get_netif+0x38>

	return eth_tse + idx;
 1813cd8:	e0bfff17 	ldw	r2,-4(fp)
 1813cdc:	10c01124 	muli	r3,r2,68
 1813ce0:	008061b4 	movhi	r2,390
 1813ce4:	1089a804 	addi	r2,r2,9888
 1813ce8:	1885883a 	add	r2,r3,r2
}
 1813cec:	e037883a 	mov	sp,fp
 1813cf0:	df000017 	ldw	fp,0(sp)
 1813cf4:	dec00104 	addi	sp,sp,4
 1813cf8:	f800283a 	ret

01813cfc <lwip_set_status_callback>:

netif_status_callback_fn lwip_set_status_callback(netif_status_callback_fn callback)
{
 1813cfc:	defffd04 	addi	sp,sp,-12
 1813d00:	df000215 	stw	fp,8(sp)
 1813d04:	df000204 	addi	fp,sp,8
 1813d08:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = status_callback;
 1813d0c:	d0a7e817 	ldw	r2,-24672(gp)
 1813d10:	e0bffe15 	stw	r2,-8(fp)

	status_callback = callback;
 1813d14:	e0bfff17 	ldw	r2,-4(fp)
 1813d18:	d0a7e815 	stw	r2,-24672(gp)

	return old;
 1813d1c:	e0bffe17 	ldw	r2,-8(fp)
}
 1813d20:	e037883a 	mov	sp,fp
 1813d24:	df000017 	ldw	fp,0(sp)
 1813d28:	dec00104 	addi	sp,sp,4
 1813d2c:	f800283a 	ret

01813d30 <lwip_set_link_callback>:

netif_status_callback_fn lwip_set_link_callback(netif_status_callback_fn callback)
{
 1813d30:	defffd04 	addi	sp,sp,-12
 1813d34:	df000215 	stw	fp,8(sp)
 1813d38:	df000204 	addi	fp,sp,8
 1813d3c:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = link_callback;
 1813d40:	d0a7e917 	ldw	r2,-24668(gp)
 1813d44:	e0bffe15 	stw	r2,-8(fp)

	link_callback = callback;
 1813d48:	e0bfff17 	ldw	r2,-4(fp)
 1813d4c:	d0a7e915 	stw	r2,-24668(gp)

	return old;
 1813d50:	e0bffe17 	ldw	r2,-8(fp)
}
 1813d54:	e037883a 	mov	sp,fp
 1813d58:	df000017 	ldw	fp,0(sp)
 1813d5c:	dec00104 	addi	sp,sp,4
 1813d60:	f800283a 	ret

01813d64 <lwip_is_interface_up>:

#define REG_STATS_LS					(1 << 2)	// Link Status

int __attribute__((weak)) lwip_is_interface_up(__unused np_tse_mac* pmac)
{
 1813d64:	defffd04 	addi	sp,sp,-12
 1813d68:	df000215 	stw	fp,8(sp)
 1813d6c:	df000204 	addi	fp,sp,8
 1813d70:	e13fff15 	stw	r4,-4(fp)
	alt_u16 reg = IORD(&pmac->mdio1.STATUS, 0);
 1813d74:	e0bfff17 	ldw	r2,-4(fp)
 1813d78:	1080a104 	addi	r2,r2,644
 1813d7c:	10800037 	ldwio	r2,0(r2)
 1813d80:	e0bffe0d 	sth	r2,-8(fp)

	return ((reg & (REG_STATS_LS)) == REG_STATS_LS) ? ETH_INTERFACE_UP : ETH_INTERFACE_DOWN;
 1813d84:	e0bffe0b 	ldhu	r2,-8(fp)
 1813d88:	1080010c 	andi	r2,r2,4
 1813d8c:	1004c03a 	cmpne	r2,r2,zero
 1813d90:	10803fcc 	andi	r2,r2,255
}
 1813d94:	e037883a 	mov	sp,fp
 1813d98:	df000017 	ldw	fp,0(sp)
 1813d9c:	dec00104 	addi	sp,sp,4
 1813da0:	f800283a 	ret

01813da4 <lwip_check_link_status>:

static void lwip_check_link_status(struct netif *netif, np_tse_mac* base)
{
 1813da4:	defffa04 	addi	sp,sp,-24
 1813da8:	dfc00515 	stw	ra,20(sp)
 1813dac:	df000415 	stw	fp,16(sp)
 1813db0:	df000404 	addi	fp,sp,16
 1813db4:	e13ffe15 	stw	r4,-8(fp)
 1813db8:	e17fff15 	stw	r5,-4(fp)
	struct ethernetif *ethif = (struct ethernetif*)netif->state;
 1813dbc:	e0bffe17 	ldw	r2,-8(fp)
 1813dc0:	10800917 	ldw	r2,36(r2)
 1813dc4:	e0bffc15 	stw	r2,-16(fp)

	// check if the interface is up
	int cur_status = lwip_is_interface_up(base);
 1813dc8:	e13fff17 	ldw	r4,-4(fp)
 1813dcc:	1813d640 	call	1813d64 <lwip_is_interface_up>
 1813dd0:	e0bffd15 	stw	r2,-12(fp)

	// is there a state change in the ethernet connectivity
	if (cur_status != ethif->current_state)
 1813dd4:	e0bffc17 	ldw	r2,-16(fp)
 1813dd8:	10c01617 	ldw	r3,88(r2)
 1813ddc:	e0bffd17 	ldw	r2,-12(fp)
 1813de0:	18801726 	beq	r3,r2,1813e40 <lwip_check_link_status+0x9c>
	{
		// check if the Auto-Negotiate is successful
		if (cur_status == ETH_INTERFACE_UP)
 1813de4:	e0bffd17 	ldw	r2,-12(fp)
 1813de8:	10800058 	cmpnei	r2,r2,1
 1813dec:	10000d1e 	bne	r2,zero,1813e24 <lwip_check_link_status+0x80>
		{
			// wait for auto-negotiate...
			if (lwip_wait_for_an(netif->num, ethif) > 0)
 1813df0:	e0bffe17 	ldw	r2,-8(fp)
 1813df4:	10800f03 	ldbu	r2,60(r2)
 1813df8:	10803fcc 	andi	r2,r2,255
 1813dfc:	e17ffc17 	ldw	r5,-16(fp)
 1813e00:	1009883a 	mov	r4,r2
 1813e04:	18139600 	call	1813960 <lwip_wait_for_an>
 1813e08:	00800d0e 	bge	zero,r2,1813e40 <lwip_check_link_status+0x9c>
			{
				netif_set_link_up(netif);
 1813e0c:	e13ffe17 	ldw	r4,-8(fp)
 1813e10:	181a2200 	call	181a220 <netif_set_link_up>
				ethif->current_state = cur_status;
 1813e14:	e0bffc17 	ldw	r2,-16(fp)
 1813e18:	e0fffd17 	ldw	r3,-12(fp)
 1813e1c:	10c01615 	stw	r3,88(r2)

			netif_set_link_down(netif);
			ethif->current_state = cur_status;
		}
	}
}
 1813e20:	00000706 	br	1813e40 <lwip_check_link_status+0x9c>
			}
		}
		else
		{
			// bring down the link
			ethif->link_alive = 0;
 1813e24:	e0bffc17 	ldw	r2,-16(fp)
 1813e28:	10000215 	stw	zero,8(r2)

			netif_set_link_down(netif);
 1813e2c:	e13ffe17 	ldw	r4,-8(fp)
 1813e30:	181a2e40 	call	181a2e4 <netif_set_link_down>
			ethif->current_state = cur_status;
 1813e34:	e0bffc17 	ldw	r2,-16(fp)
 1813e38:	e0fffd17 	ldw	r3,-12(fp)
 1813e3c:	10c01615 	stw	r3,88(r2)
		}
	}
}
 1813e40:	0001883a 	nop
 1813e44:	e037883a 	mov	sp,fp
 1813e48:	dfc00117 	ldw	ra,4(sp)
 1813e4c:	df000017 	ldw	fp,0(sp)
 1813e50:	dec00204 	addi	sp,sp,8
 1813e54:	f800283a 	ret

01813e58 <lwip_handle_ethernet_input>:

#define NR_TEST_PACKETS						50000

// Input / monitor task per ethernet device
static void lwip_handle_ethernet_input(void *pvParameters)
{
 1813e58:	defe7104 	addi	sp,sp,-1596
 1813e5c:	dfc18e15 	stw	ra,1592(sp)
 1813e60:	df018d15 	stw	fp,1588(sp)
 1813e64:	df018d04 	addi	fp,sp,1588
 1813e68:	e13fff15 	stw	r4,-4(fp)
	sys_sem_t rcvsem = NULL;
 1813e6c:	e03e7815 	stw	zero,-1568(fp)
	np_tse_mac* base = NULL;
 1813e70:	e03e7415 	stw	zero,-1584(fp)
	struct netif *cur_netif = (struct netif*)pvParameters;
 1813e74:	e0bfff17 	ldw	r2,-4(fp)
 1813e78:	e0be7515 	stw	r2,-1580(fp)
	struct ethernetif *cur_ethif = (struct ethernetif*)cur_netif->state;
 1813e7c:	e0be7517 	ldw	r2,-1580(fp)
 1813e80:	10800917 	ldw	r2,36(r2)
 1813e84:	e0be7615 	stw	r2,-1576(fp)
	int packets_waiting = 0;
 1813e88:	e03e7315 	stw	zero,-1588(fp)

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560]; // TODO remove
	int replug_state = 0; // TODO remove
 1813e8c:	e03e7715 	stw	zero,-1572(fp)

#if LWIP_RECEIVE_SEMAPHORE
	rcvsem = cur_ethif->tse_info->rx_semaphore;
 1813e90:	e0be7617 	ldw	r2,-1576(fp)
 1813e94:	10801717 	ldw	r2,92(r2)
 1813e98:	10800817 	ldw	r2,32(r2)
 1813e9c:	e0be7815 	stw	r2,-1568(fp)
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
 1813ea0:	e0be7517 	ldw	r2,-1580(fp)
 1813ea4:	10800f03 	ldbu	r2,60(r2)
 1813ea8:	10803fcc 	andi	r2,r2,255
 1813eac:	1009883a 	mov	r4,r2
 1813eb0:	1813c680 	call	1813c68 <get_mac_base>
 1813eb4:	e0be7415 	stw	r2,-1584(fp)
	if (!base)
 1813eb8:	e0be7417 	ldw	r2,-1584(fp)
 1813ebc:	10001426 	beq	r2,zero,1813f10 <lwip_handle_ethernet_input+0xb8>
	// else we'll poll the function once every 100ms
		while (1) {
		// if we have a semaphore wait for it to be released by the SGDMA IRQ, or sleep for 1 ms
			// if we timeout also call ethernetif_input although most likely it would be useless
			// it is use full however to check the link status
		if (rcvsem)
 1813ec0:	e0be7817 	ldw	r2,-1568(fp)
 1813ec4:	10000526 	beq	r2,zero,1813edc <lwip_handle_ethernet_input+0x84>
			sys_arch_sem_wait(&rcvsem, 100);
 1813ec8:	e0be7804 	addi	r2,fp,-1568
 1813ecc:	01401904 	movi	r5,100
 1813ed0:	1009883a 	mov	r4,r2
 1813ed4:	18150bc0 	call	18150bc <sys_arch_sem_wait>
 1813ed8:	00000406 	br	1813eec <lwip_handle_ethernet_input+0x94>
		else if (packets_waiting <= 0)	// only sleep if there are no packets waiting
 1813edc:	e0be7317 	ldw	r2,-1588(fp)
 1813ee0:	00800216 	blt	zero,r2,1813eec <lwip_handle_ethernet_input+0x94>
			mssleep(1);					// sleep a bit to be nice to the CPU
 1813ee4:	0100fa04 	movi	r4,1000
 1813ee8:	18132900 	call	1813290 <usleep>

			// Use semaphore or the timeout to call ethernet_input
			// this to avoid unnecessary load and faster responses ;)
		packets_waiting = ethernetif_input(cur_netif);
 1813eec:	e13e7517 	ldw	r4,-1580(fp)
 1813ef0:	18135a00 	call	18135a0 <ethernetif_input>
 1813ef4:	e0be7315 	stw	r2,-1588(fp)

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
 1813ef8:	e0be7317 	ldw	r2,-1588(fp)
 1813efc:	00bff016 	blt	zero,r2,1813ec0 <__ram_exceptions_end+0xff803a7c>
			lwip_check_link_status(cur_netif, base);
 1813f00:	e17e7417 	ldw	r5,-1584(fp)
 1813f04:	e13e7517 	ldw	r4,-1580(fp)
 1813f08:	1813da40 	call	1813da4 <lwip_check_link_status>
	}
 1813f0c:	003fec06 	br	1813ec0 <__ram_exceptions_end+0xff803a7c>
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
	if (!base)
		return;
 1813f10:	0001883a 	nop

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
			lwip_check_link_status(cur_netif, base);
	}
}
 1813f14:	e037883a 	mov	sp,fp
 1813f18:	dfc00117 	ldw	ra,4(sp)
 1813f1c:	df000017 	ldw	fp,0(sp)
 1813f20:	dec00204 	addi	sp,sp,8
 1813f24:	f800283a 	ret

01813f28 <print_ipad>:

const char* print_ipad(alt_u32 ip, char* buf)
{
 1813f28:	defff704 	addi	sp,sp,-36
 1813f2c:	dfc00815 	stw	ra,32(sp)
 1813f30:	df000715 	stw	fp,28(sp)
 1813f34:	df000704 	addi	fp,sp,28
 1813f38:	e13ffe15 	stw	r4,-8(fp)
 1813f3c:	e17fff15 	stw	r5,-4(fp)
	alt_u8 bip[4];
	alt_u32 idx = 0;
 1813f40:	e03ffc15 	stw	zero,-16(fp)

	for (; idx < sizeof(bip); idx++) {
 1813f44:	00000c06 	br	1813f78 <print_ipad+0x50>
		bip[idx] = ip & 0xFF;
 1813f48:	e0bffe17 	ldw	r2,-8(fp)
 1813f4c:	1009883a 	mov	r4,r2
 1813f50:	e0fffd04 	addi	r3,fp,-12
 1813f54:	e0bffc17 	ldw	r2,-16(fp)
 1813f58:	1885883a 	add	r2,r3,r2
 1813f5c:	11000005 	stb	r4,0(r2)
		ip >>= 8;
 1813f60:	e0bffe17 	ldw	r2,-8(fp)
 1813f64:	1004d23a 	srli	r2,r2,8
 1813f68:	e0bffe15 	stw	r2,-8(fp)
const char* print_ipad(alt_u32 ip, char* buf)
{
	alt_u8 bip[4];
	alt_u32 idx = 0;

	for (; idx < sizeof(bip); idx++) {
 1813f6c:	e0bffc17 	ldw	r2,-16(fp)
 1813f70:	10800044 	addi	r2,r2,1
 1813f74:	e0bffc15 	stw	r2,-16(fp)
 1813f78:	e0bffc17 	ldw	r2,-16(fp)
 1813f7c:	10800130 	cmpltui	r2,r2,4
 1813f80:	103ff11e 	bne	r2,zero,1813f48 <__ram_exceptions_end+0xff803b04>
		bip[idx] = ip & 0xFF;
		ip >>= 8;
	}

	snprintf(buf, 17, "%d.%d.%d.%d", bip[0], bip[1], bip[2], bip[3]);
 1813f84:	e0bffd03 	ldbu	r2,-12(fp)
 1813f88:	11403fcc 	andi	r5,r2,255
 1813f8c:	e0bffd43 	ldbu	r2,-11(fp)
 1813f90:	10803fcc 	andi	r2,r2,255
 1813f94:	e0fffd83 	ldbu	r3,-10(fp)
 1813f98:	18c03fcc 	andi	r3,r3,255
 1813f9c:	e13ffdc3 	ldbu	r4,-9(fp)
 1813fa0:	21003fcc 	andi	r4,r4,255
 1813fa4:	d9000215 	stw	r4,8(sp)
 1813fa8:	d8c00115 	stw	r3,4(sp)
 1813fac:	d8800015 	stw	r2,0(sp)
 1813fb0:	280f883a 	mov	r7,r5
 1813fb4:	01806134 	movhi	r6,388
 1813fb8:	3185e704 	addi	r6,r6,6044
 1813fbc:	01400444 	movi	r5,17
 1813fc0:	e13fff17 	ldw	r4,-4(fp)
 1813fc4:	183d3e80 	call	183d3e8 <snprintf>

	return buf;
 1813fc8:	e0bfff17 	ldw	r2,-4(fp)
}
 1813fcc:	e037883a 	mov	sp,fp
 1813fd0:	dfc00117 	ldw	ra,4(sp)
 1813fd4:	df000017 	ldw	fp,0(sp)
 1813fd8:	dec00204 	addi	sp,sp,8
 1813fdc:	f800283a 	ret

01813fe0 <lwip_status_callback>:

static void lwip_status_callback(struct netif *netif)
{
 1813fe0:	defffd04 	addi	sp,sp,-12
 1813fe4:	dfc00215 	stw	ra,8(sp)
 1813fe8:	df000115 	stw	fp,4(sp)
 1813fec:	df000104 	addi	fp,sp,4
 1813ff0:	e13fff15 	stw	r4,-4(fp)
	if (status_callback)
 1813ff4:	d0a7e817 	ldw	r2,-24672(gp)
 1813ff8:	10000326 	beq	r2,zero,1814008 <lwip_status_callback+0x28>
		status_callback(netif);
 1813ffc:	d0a7e817 	ldw	r2,-24672(gp)
 1814000:	e13fff17 	ldw	r4,-4(fp)
 1814004:	103ee83a 	callr	r2
}
 1814008:	0001883a 	nop
 181400c:	e037883a 	mov	sp,fp
 1814010:	dfc00117 	ldw	ra,4(sp)
 1814014:	df000017 	ldw	fp,0(sp)
 1814018:	dec00204 	addi	sp,sp,8
 181401c:	f800283a 	ret

01814020 <lwip_initialize_phys>:

void lwip_initialize_phys(void)
{
 1814020:	defff604 	addi	sp,sp,-40
 1814024:	dfc00915 	stw	ra,36(sp)
 1814028:	df000815 	stw	fp,32(sp)
 181402c:	df000804 	addi	fp,sp,32
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 1814030:	e03ff815 	stw	zero,-32(fp)
 1814034:	00006e06 	br	18141f0 <lwip_initialize_phys+0x1d0>
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
 1814038:	e13ff817 	ldw	r4,-32(fp)
 181403c:	1800ab40 	call	1800ab4 <is_interface_active>
 1814040:	10006326 	beq	r2,zero,18141d0 <lwip_initialize_phys+0x1b0>
			continue;

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
 1814044:	e13ff817 	ldw	r4,-32(fp)
 1814048:	1813c680 	call	1813c68 <get_mac_base>
 181404c:	e0bffd15 	stw	r2,-12(fp)
		if (!pmac)
 1814050:	e0bffd17 	ldw	r2,-12(fp)
 1814054:	10006026 	beq	r2,zero,18141d8 <lwip_initialize_phys+0x1b8>
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 1814058:	e03ff915 	stw	zero,-28(fp)
 181405c:	00001206 	br	18140a8 <lwip_initialize_phys+0x88>
		{
			IOWR(&pmac->MDIO_ADDR1, 0, phyadd);
 1814060:	e0bffd17 	ldw	r2,-12(fp)
 1814064:	10801004 	addi	r2,r2,64
 1814068:	e0fff917 	ldw	r3,-28(fp)
 181406c:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
 1814070:	e0bffd17 	ldw	r2,-12(fp)
 1814074:	1080a204 	addi	r2,r2,648
 1814078:	10800037 	ldwio	r2,0(r2)
 181407c:	e0bffa15 	stw	r2,-24(fp)
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);
 1814080:	e0bffd17 	ldw	r2,-12(fp)
 1814084:	1080a304 	addi	r2,r2,652
 1814088:	10800037 	ldwio	r2,0(r2)
 181408c:	e0bffb15 	stw	r2,-20(fp)

			if (phyid != phyid2)
 1814090:	e0fffa17 	ldw	r3,-24(fp)
 1814094:	e0bffb17 	ldw	r2,-20(fp)
 1814098:	1880071e 	bne	r3,r2,18140b8 <lwip_initialize_phys+0x98>
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 181409c:	e0bff917 	ldw	r2,-28(fp)
 18140a0:	10800044 	addi	r2,r2,1
 18140a4:	e0bff915 	stw	r2,-28(fp)
 18140a8:	e0bff917 	ldw	r2,-28(fp)
 18140ac:	10800810 	cmplti	r2,r2,32
 18140b0:	103feb1e 	bne	r2,zero,1814060 <__ram_exceptions_end+0xff803c1c>
 18140b4:	00000106 	br	18140bc <lwip_initialize_phys+0x9c>

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);

			if (phyid != phyid2)
				break;
 18140b8:	0001883a 	nop
		}

		// if we have the PHY we can initialize it if we can find the driver in the pphy_profiles array
		if (phyid != phyid2)
 18140bc:	e0fffa17 	ldw	r3,-24(fp)
 18140c0:	e0bffb17 	ldw	r2,-20(fp)
 18140c4:	18804726 	beq	r3,r2,18141e4 <lwip_initialize_phys+0x1c4>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 18140c8:	e03ffc15 	stw	zero,-16(fp)
 18140cc:	00003b06 	br	18141bc <lwip_initialize_phys+0x19c>
                alt_u32 oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 18140d0:	e0bffa17 	ldw	r2,-24(fp)
 18140d4:	100691ba 	slli	r3,r2,6
 18140d8:	e0bffb17 	ldw	r2,-20(fp)
 18140dc:	1005d2ba 	srai	r2,r2,10
 18140e0:	10800fcc 	andi	r2,r2,63
 18140e4:	1884b03a 	or	r2,r3,r2
 18140e8:	e0bffe15 	stw	r2,-8(fp)
                alt_u8 model_number = (phyid2 >> 4) & 0x3f;
 18140ec:	e0bffb17 	ldw	r2,-20(fp)
 18140f0:	1005d13a 	srai	r2,r2,4
 18140f4:	10800fcc 	andi	r2,r2,63
 18140f8:	e0bfff05 	stb	r2,-4(fp)
                // unused so far... alt_u8 revision_number = phyid2 & 0x0f;

                // if PHY match with PHY in profile we can call the initialize function
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 18140fc:	008061f4 	movhi	r2,391
 1814100:	10aab904 	addi	r2,r2,-21788
 1814104:	e0fffc17 	ldw	r3,-16(fp)
 1814108:	18c7883a 	add	r3,r3,r3
 181410c:	18c7883a 	add	r3,r3,r3
 1814110:	10c5883a 	add	r2,r2,r3
 1814114:	10800017 	ldw	r2,0(r2)
 1814118:	10c01417 	ldw	r3,80(r2)
 181411c:	e0bffe17 	ldw	r2,-8(fp)
 1814120:	1880231e 	bne	r3,r2,18141b0 <lwip_initialize_phys+0x190>
 1814124:	008061f4 	movhi	r2,391
 1814128:	10aab904 	addi	r2,r2,-21788
 181412c:	e0fffc17 	ldw	r3,-16(fp)
 1814130:	18c7883a 	add	r3,r3,r3
 1814134:	18c7883a 	add	r3,r3,r3
 1814138:	10c5883a 	add	r2,r2,r3
 181413c:	10800017 	ldw	r2,0(r2)
 1814140:	10801503 	ldbu	r2,84(r2)
 1814144:	10c03fcc 	andi	r3,r2,255
 1814148:	e0bfff03 	ldbu	r2,-4(fp)
 181414c:	1880181e 	bne	r3,r2,18141b0 <lwip_initialize_phys+0x190>
                {
                    if (pphy_profiles[i]->phy_cfg)
 1814150:	008061f4 	movhi	r2,391
 1814154:	10aab904 	addi	r2,r2,-21788
 1814158:	e0fffc17 	ldw	r3,-16(fp)
 181415c:	18c7883a 	add	r3,r3,r3
 1814160:	18c7883a 	add	r3,r3,r3
 1814164:	10c5883a 	add	r2,r2,r3
 1814168:	10800017 	ldw	r2,0(r2)
 181416c:	10801717 	ldw	r2,92(r2)
 1814170:	10001b26 	beq	r2,zero,18141e0 <lwip_initialize_phys+0x1c0>
                    {
                    	// initialize the PHY
                    	pphy_profiles[i]->phy_cfg(pmac);
 1814174:	008061f4 	movhi	r2,391
 1814178:	10aab904 	addi	r2,r2,-21788
 181417c:	e0fffc17 	ldw	r3,-16(fp)
 1814180:	18c7883a 	add	r3,r3,r3
 1814184:	18c7883a 	add	r3,r3,r3
 1814188:	10c5883a 	add	r2,r2,r3
 181418c:	10800017 	ldw	r2,0(r2)
 1814190:	10801717 	ldw	r2,92(r2)
 1814194:	e13ffd17 	ldw	r4,-12(fp)
 1814198:	103ee83a 	callr	r2

                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
 181419c:	e0bffd17 	ldw	r2,-12(fp)
 18141a0:	1080a004 	addi	r2,r2,640
 18141a4:	00c48004 	movi	r3,4608
 18141a8:	10c00035 	stwio	r3,0(r2)
                    }

                    // and done for this PHY
                    break;
 18141ac:	00000c06 	br	18141e0 <lwip_initialize_phys+0x1c0>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 18141b0:	e0bffc17 	ldw	r2,-16(fp)
 18141b4:	10800044 	addi	r2,r2,1
 18141b8:	e0bffc15 	stw	r2,-16(fp)
 18141bc:	d0a81003 	ldbu	r2,-24512(gp)
 18141c0:	10803fcc 	andi	r2,r2,255
 18141c4:	e0fffc17 	ldw	r3,-16(fp)
 18141c8:	18bfc116 	blt	r3,r2,18140d0 <__ram_exceptions_end+0xff803c8c>
 18141cc:	00000506 	br	18141e4 <lwip_initialize_phys+0x1c4>

	for (idx = 0; idx < PHY_COUNT; ++idx)
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 18141d0:	0001883a 	nop
 18141d4:	00000306 	br	18141e4 <lwip_initialize_phys+0x1c4>

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;
 18141d8:	0001883a 	nop
 18141dc:	00000106 	br	18141e4 <lwip_initialize_phys+0x1c4>
                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
                    }

                    // and done for this PHY
                    break;
 18141e0:	0001883a 	nop
void lwip_initialize_phys(void)
{
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 18141e4:	e0bff817 	ldw	r2,-32(fp)
 18141e8:	10800044 	addi	r2,r2,1
 18141ec:	e0bff815 	stw	r2,-32(fp)
 18141f0:	e0bff817 	ldw	r2,-32(fp)
 18141f4:	00bf900e 	bge	zero,r2,1814038 <__ram_exceptions_end+0xff803bf4>
                    break;
                }
            }
		}
	}
}
 18141f8:	0001883a 	nop
 18141fc:	e037883a 	mov	sp,fp
 1814200:	dfc00117 	ldw	ra,4(sp)
 1814204:	df000017 	ldw	fp,0(sp)
 1814208:	dec00204 	addi	sp,sp,8
 181420c:	f800283a 	ret

01814210 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
 1814210:	defff004 	addi	sp,sp,-64
 1814214:	dfc00f15 	stw	ra,60(sp)
 1814218:	df000e15 	stw	fp,56(sp)
 181421c:	df000e04 	addi	fp,sp,56
 1814220:	e13ffe15 	stw	r4,-8(fp)
 1814224:	e17fff15 	stw	r5,-4(fp)
	int speed, duplex, result;
	int x;

	alt_sgdma_dev *sgdma_tx_dev;
	alt_sgdma_dev *sgdma_rx_dev;
	alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 1814228:	008061b4 	movhi	r2,390
 181422c:	1089b904 	addi	r2,r2,9956
 1814230:	e0fffe17 	ldw	r3,-8(fp)
 1814234:	18c00924 	muli	r3,r3,36
 1814238:	10c5883a 	add	r2,r2,r3
 181423c:	10800704 	addi	r2,r2,28
 1814240:	10800017 	ldw	r2,0(r2)
 1814244:	e0bff715 	stw	r2,-36(fp)
	np_tse_mac *mi_base;
	alt_tse_mac_info *pmac_info;

#if LWIP_RECEIVE_SEMAPHORE
	if (!tse[iface].rx_semaphore) {
 1814248:	008061b4 	movhi	r2,390
 181424c:	1089b904 	addi	r2,r2,9956
 1814250:	e0fffe17 	ldw	r3,-8(fp)
 1814254:	18c00924 	muli	r3,r3,36
 1814258:	10c5883a 	add	r2,r2,r3
 181425c:	10800804 	addi	r2,r2,32
 1814260:	10800017 	ldw	r2,0(r2)
 1814264:	10001e1e 	bne	r2,zero,18142e0 <tse_mac_init+0xd0>
		dprintf(("creating RX SGDMA semaphore\n"));
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
 1814268:	e0bffe17 	ldw	r2,-8(fp)
 181426c:	10800924 	muli	r2,r2,36
 1814270:	10c00804 	addi	r3,r2,32
 1814274:	008061b4 	movhi	r2,390
 1814278:	1089b904 	addi	r2,r2,9956
 181427c:	1885883a 	add	r2,r3,r2
 1814280:	01400304 	movi	r5,12
 1814284:	1009883a 	mov	r4,r2
 1814288:	1814f380 	call	1814f38 <sys_sem_new>
 181428c:	10803fcc 	andi	r2,r2,255
 1814290:	1080201c 	xori	r2,r2,128
 1814294:	10bfe004 	addi	r2,r2,-128
 1814298:	1000111e 	bne	r2,zero,18142e0 <tse_mac_init+0xd0>
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 181429c:	e03ff515 	stw	zero,-44(fp)
 18142a0:	00000c06 	br	18142d4 <tse_mac_init+0xc4>
				sys_arch_sem_wait(&tse[iface].rx_semaphore, 1);
 18142a4:	e0bffe17 	ldw	r2,-8(fp)
 18142a8:	10800924 	muli	r2,r2,36
 18142ac:	10c00804 	addi	r3,r2,32
 18142b0:	008061b4 	movhi	r2,390
 18142b4:	1089b904 	addi	r2,r2,9956
 18142b8:	1885883a 	add	r2,r3,r2
 18142bc:	01400044 	movi	r5,1
 18142c0:	1009883a 	mov	r4,r2
 18142c4:	18150bc0 	call	18150bc <sys_arch_sem_wait>
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 18142c8:	e0bff517 	ldw	r2,-44(fp)
 18142cc:	10800044 	addi	r2,r2,1
 18142d0:	e0bff515 	stw	r2,-44(fp)
 18142d4:	e0bff517 	ldw	r2,-44(fp)
 18142d8:	10800310 	cmplti	r2,r2,12
 18142dc:	103ff11e 	bne	r2,zero,18142a4 <__ram_exceptions_end+0xff803e60>
	dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
	dprintf(("tse_mac_init %d\n", iface));
#endif    
	// These lines were done in prep_tse_mac
	tse_hw = &tse_mac_device[iface];
 18142e0:	e0bffe17 	ldw	r2,-8(fp)
 18142e4:	10c01224 	muli	r3,r2,72
 18142e8:	00806134 	movhi	r2,388
 18142ec:	1096c404 	addi	r2,r2,23312
 18142f0:	1885883a 	add	r2,r3,r2
 18142f4:	e0bff715 	stw	r2,-36(fp)
	tse[iface].tse = tse_hw;
 18142f8:	008061b4 	movhi	r2,390
 18142fc:	1089b904 	addi	r2,r2,9956
 1814300:	e0fffe17 	ldw	r3,-8(fp)
 1814304:	18c00924 	muli	r3,r3,36
 1814308:	10c5883a 	add	r2,r2,r3
 181430c:	10800704 	addi	r2,r2,28
 1814310:	e0fff717 	ldw	r3,-36(fp)
 1814314:	10c00015 	stw	r3,0(r2)

	// Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
	tse[iface].ethernetif = ethernetif;
 1814318:	008061b4 	movhi	r2,390
 181431c:	1089b904 	addi	r2,r2,9956
 1814320:	e0fffe17 	ldw	r3,-8(fp)
 1814324:	18c00924 	muli	r3,r3,36
 1814328:	10c5883a 	add	r2,r2,r3
 181432c:	10800604 	addi	r2,r2,24
 1814330:	e0ffff17 	ldw	r3,-4(fp)
 1814334:	10c00015 	stw	r3,0(r2)
	ethernetif->iface = iface;
 1814338:	e0bfff17 	ldw	r2,-4(fp)
 181433c:	e0fffe17 	ldw	r3,-8(fp)
 1814340:	10c00115 	stw	r3,4(r2)
	ethernetif->tse_info = &tse[iface];
 1814344:	e0bffe17 	ldw	r2,-8(fp)
 1814348:	10c00924 	muli	r3,r2,36
 181434c:	008061b4 	movhi	r2,390
 1814350:	1089b904 	addi	r2,r2,9956
 1814354:	1887883a 	add	r3,r3,r2
 1814358:	e0bfff17 	ldw	r2,-4(fp)
 181435c:	10c01715 	stw	r3,92(r2)

	if (tse_hw->ext_desc_mem == 1)
 1814360:	e0bff717 	ldw	r2,-36(fp)
 1814364:	10800783 	ldbu	r2,30(r2)
 1814368:	10803fcc 	andi	r2,r2,255
 181436c:	10800058 	cmpnei	r2,r2,1
 1814370:	10000b1e 	bne	r2,zero,18143a0 <tse_mac_init+0x190>
	{
		tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 1814374:	e0bff717 	ldw	r2,-36(fp)
 1814378:	10800817 	ldw	r2,32(r2)
 181437c:	1009883a 	mov	r4,r2
 1814380:	008061b4 	movhi	r2,390
 1814384:	1089b904 	addi	r2,r2,9956
 1814388:	e0fffe17 	ldw	r3,-8(fp)
 181438c:	18c00924 	muli	r3,r3,36
 1814390:	10c5883a 	add	r2,r2,r3
 1814394:	10800504 	addi	r2,r2,20
 1814398:	11000015 	stw	r4,0(r2)
 181439c:	00001206 	br	18143e8 <tse_mac_init+0x1d8>
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 18143a0:	01002804 	movi	r4,160
 18143a4:	18286980 	call	1828698 <alt_uncached_malloc>
 18143a8:	e0bff615 	stw	r2,-40(fp)

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 18143ac:	00000306 	br	18143bc <tse_mac_init+0x1ac>
			temp_desc++;
 18143b0:	e0bff617 	ldw	r2,-40(fp)
 18143b4:	10800044 	addi	r2,r2,1
 18143b8:	e0bff615 	stw	r2,-40(fp)
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 18143bc:	e0bff617 	ldw	r2,-40(fp)
 18143c0:	108007cc 	andi	r2,r2,31
 18143c4:	103ffa1e 	bne	r2,zero,18143b0 <__ram_exceptions_end+0xff803f6c>
			temp_desc++;
		tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 18143c8:	008061b4 	movhi	r2,390
 18143cc:	1089b904 	addi	r2,r2,9956
 18143d0:	e0fffe17 	ldw	r3,-8(fp)
 18143d4:	18c00924 	muli	r3,r3,36
 18143d8:	10c5883a 	add	r2,r2,r3
 18143dc:	10800504 	addi	r2,r2,20
 18143e0:	e0fff617 	ldw	r3,-40(fp)
 18143e4:	10c00015 	stw	r3,0(r2)
	}

	/* Get the Rx and Tx SGDMA addresses */
	sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 18143e8:	e0bff717 	ldw	r2,-36(fp)
 18143ec:	10800517 	ldw	r2,20(r2)
 18143f0:	1009883a 	mov	r4,r2
 18143f4:	18260000 	call	1826000 <alt_avalon_sgdma_open>
 18143f8:	e0bff815 	stw	r2,-32(fp)

	if (!sgdma_tx_dev)
 18143fc:	e0bff817 	ldw	r2,-32(fp)
 1814400:	1000021e 	bne	r2,zero,181440c <tse_mac_init+0x1fc>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
		return ENP_RESOURCE;
 1814404:	00bffa84 	movi	r2,-22
 1814408:	00018f06 	br	1814a48 <tse_mac_init+0x838>
	}

	sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 181440c:	e0bff717 	ldw	r2,-36(fp)
 1814410:	10800617 	ldw	r2,24(r2)
 1814414:	1009883a 	mov	r4,r2
 1814418:	18260000 	call	1826000 <alt_avalon_sgdma_open>
 181441c:	e0bff915 	stw	r2,-28(fp)
	if (!sgdma_rx_dev)
 1814420:	e0bff917 	ldw	r2,-28(fp)
 1814424:	1000021e 	bne	r2,zero,1814430 <tse_mac_init+0x220>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
		return ENP_RESOURCE;
 1814428:	00bffa84 	movi	r2,-22
 181442c:	00018606 	br	1814a48 <tse_mac_init+0x838>
	}

	/* Initialize mtip_mac_trans_info structure with values from <system.h>*/

	tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 1814430:	e0bffe17 	ldw	r2,-8(fp)
 1814434:	10c00924 	muli	r3,r2,36
 1814438:	008061b4 	movhi	r2,390
 181443c:	1089b904 	addi	r2,r2,9956
 1814440:	1887883a 	add	r3,r3,r2
 1814444:	e0bff717 	ldw	r2,-36(fp)
 1814448:	10800017 	ldw	r2,0(r2)
 181444c:	e13ff817 	ldw	r4,-32(fp)
 1814450:	e17ff917 	ldw	r5,-28(fp)
 1814454:	d8000015 	stw	zero,0(sp)
 1814458:	280f883a 	mov	r7,r5
 181445c:	200d883a 	mov	r6,r4
 1814460:	100b883a 	mov	r5,r2
 1814464:	1809883a 	mov	r4,r3
 1814468:	182c1c80 	call	182c1c8 <tse_mac_initTransInfo2>
			(unsigned int)sgdma_tx_dev,
			(unsigned int)sgdma_rx_dev,
			0);
	mi_base = tse[iface].mi.base;
 181446c:	008061b4 	movhi	r2,390
 1814470:	1089b904 	addi	r2,r2,9956
 1814474:	e0fffe17 	ldw	r3,-8(fp)
 1814478:	18c00924 	muli	r3,r3,36
 181447c:	10c5883a 	add	r2,r2,r3
 1814480:	10800017 	ldw	r2,0(r2)
 1814484:	e0bffa15 	stw	r2,-24(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
 1814488:	008061b4 	movhi	r2,390
 181448c:	1089b904 	addi	r2,r2,9956
 1814490:	e0fffe17 	ldw	r3,-8(fp)
 1814494:	18c00924 	muli	r3,r3,36
 1814498:	10c5883a 	add	r2,r2,r3
 181449c:	10800204 	addi	r2,r2,8
 18144a0:	10800017 	ldw	r2,0(r2)
 18144a4:	10800317 	ldw	r2,12(r2)
 18144a8:	10800404 	addi	r2,r2,16
 18144ac:	00c00074 	movhi	r3,1
 18144b0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 18144b4:	008061b4 	movhi	r2,390
 18144b8:	1089b904 	addi	r2,r2,9956
 18144bc:	e0fffe17 	ldw	r3,-8(fp)
 18144c0:	18c00924 	muli	r3,r3,36
 18144c4:	10c5883a 	add	r2,r2,r3
 18144c8:	10800204 	addi	r2,r2,8
 18144cc:	10800017 	ldw	r2,0(r2)
 18144d0:	10800317 	ldw	r2,12(r2)
 18144d4:	10800404 	addi	r2,r2,16
 18144d8:	0007883a 	mov	r3,zero
 18144dc:	10c00035 	stwio	r3,0(r2)

	/* reset the PHY if necessary */
	result = getPHYSpeed(tse[iface].mi.base);
 18144e0:	008061b4 	movhi	r2,390
 18144e4:	1089b904 	addi	r2,r2,9956
 18144e8:	e0fffe17 	ldw	r3,-8(fp)
 18144ec:	18c00924 	muli	r3,r3,36
 18144f0:	10c5883a 	add	r2,r2,r3
 18144f4:	10800017 	ldw	r2,0(r2)
 18144f8:	1009883a 	mov	r4,r2
 18144fc:	182d6540 	call	182d654 <getPHYSpeed>
 1814500:	e0bffb15 	stw	r2,-20(fp)
	speed = (result >> 1) & 0x07;
 1814504:	e0bffb17 	ldw	r2,-20(fp)
 1814508:	1005d07a 	srai	r2,r2,1
 181450c:	108001cc 	andi	r2,r2,7
 1814510:	e0bffc15 	stw	r2,-16(fp)
	duplex = result & 0x01;
 1814514:	e0bffb17 	ldw	r2,-20(fp)
 1814518:	1080004c 	andi	r2,r2,1
 181451c:	e0bff415 	stw	r2,-48(fp)

	/* reset the mac */
	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 1814520:	008061b4 	movhi	r2,390
 1814524:	1089b904 	addi	r2,r2,9956
 1814528:	e0fffe17 	ldw	r3,-8(fp)
 181452c:	18c00924 	muli	r3,r3,36
 1814530:	10c5883a 	add	r2,r2,r3
 1814534:	10800017 	ldw	r2,0(r2)
 1814538:	10800204 	addi	r2,r2,8
 181453c:	00c800c4 	movi	r3,8195
 1814540:	10c00035 	stwio	r3,0(r2)
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
 1814544:	e03ff515 	stw	zero,-44(fp)
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 1814548:	00000506 	br	1814560 <tse_mac_init+0x350>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
 181454c:	e0bff517 	ldw	r2,-44(fp)
 1814550:	10c00044 	addi	r3,r2,1
 1814554:	e0fff515 	stw	r3,-44(fp)
 1814558:	1089c450 	cmplti	r2,r2,10001
 181455c:	10000b26 	beq	r2,zero,181458c <tse_mac_init+0x37c>
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 1814560:	008061b4 	movhi	r2,390
 1814564:	1089b904 	addi	r2,r2,9956
 1814568:	e0fffe17 	ldw	r3,-8(fp)
 181456c:	18c00924 	muli	r3,r3,36
 1814570:	10c5883a 	add	r2,r2,r3
 1814574:	10800017 	ldw	r2,0(r2)
 1814578:	10800204 	addi	r2,r2,8
 181457c:	10800037 	ldwio	r2,0(r2)
 1814580:	1088000c 	andi	r2,r2,8192
 1814584:	103ff11e 	bne	r2,zero,181454c <__ram_exceptions_end+0xff804108>
 1814588:	00000106 	br	1814590 <tse_mac_init+0x380>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
			break;
 181458c:	0001883a 	nop
	}

	if (x >= 10000)
		dprintf(("TSEMAC SW reset bit never cleared!\n"));

	dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 1814590:	008061b4 	movhi	r2,390
 1814594:	1089b904 	addi	r2,r2,9956
 1814598:	e0fffe17 	ldw	r3,-8(fp)
 181459c:	18c00924 	muli	r3,r3,36
 18145a0:	10c5883a 	add	r2,r2,r3
 18145a4:	10800017 	ldw	r2,0(r2)
 18145a8:	10800204 	addi	r2,r2,8
 18145ac:	10800037 	ldwio	r2,0(r2)
 18145b0:	e0bff315 	stw	r2,-52(fp)
		dprintf(("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat));
	else
		dprintf(("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat));

	/* Initialize MAC registers */
	IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE);
 18145b4:	e0bffa17 	ldw	r2,-24(fp)
 18145b8:	10800504 	addi	r2,r2,20
 18145bc:	00c17b84 	movi	r3,1518
 18145c0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
 18145c4:	e0bffa17 	ldw	r2,-24(fp)
 18145c8:	10800b04 	addi	r2,r2,44
 18145cc:	00c00204 	movi	r3,8
 18145d0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
 18145d4:	e0bffa17 	ldw	r2,-24(fp)
 18145d8:	10800c04 	addi	r2,r2,48
 18145dc:	00c00204 	movi	r3,8
 18145e0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
 18145e4:	e0bffa17 	ldw	r2,-24(fp)
 18145e8:	10800d04 	addi	r2,r2,52
 18145ec:	00c00204 	movi	r3,8
 18145f0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
 18145f4:	e0bffa17 	ldw	r2,-24(fp)
 18145f8:	10800e04 	addi	r2,r2,56
 18145fc:	00c000c4 	movi	r3,3
 1814600:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16);
 1814604:	e0bffa17 	ldw	r2,-24(fp)
 1814608:	10800904 	addi	r2,r2,36
 181460c:	e0fff717 	ldw	r3,-36(fp)
 1814610:	18c0010b 	ldhu	r3,4(r3)
 1814614:	18ffffcc 	andi	r3,r3,65535
 1814618:	18fffc04 	addi	r3,r3,-16
 181461c:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0);
 1814620:	e0bffa17 	ldw	r2,-24(fp)
 1814624:	10800a04 	addi	r2,r2,40
 1814628:	0007883a 	mov	r3,zero
 181462c:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16);
 1814630:	e0bffa17 	ldw	r2,-24(fp)
 1814634:	10800704 	addi	r2,r2,28
 1814638:	e0fff717 	ldw	r3,-36(fp)
 181463c:	18c0018b 	ldhu	r3,6(r3)
 1814640:	18ffffcc 	andi	r3,r3,65535
 1814644:	18fffc04 	addi	r3,r3,-16
 1814648:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
 181464c:	e0bffa17 	ldw	r2,-24(fp)
 1814650:	10800804 	addi	r2,r2,32
 1814654:	0007883a 	mov	r3,zero
 1814658:	10c00035 	stwio	r3,0(r2)

	/* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
	IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 181465c:	008061b4 	movhi	r2,390
 1814660:	1089b904 	addi	r2,r2,9956
 1814664:	e0fffe17 	ldw	r3,-8(fp)
 1814668:	18c00924 	muli	r3,r3,36
 181466c:	10c5883a 	add	r2,r2,r3
 1814670:	10800017 	ldw	r2,0(r2)
 1814674:	10803a04 	addi	r2,r2,232
 1814678:	00c00134 	movhi	r3,4
 181467c:	10c00035 	stwio	r3,0(r2)

	/*
	 * check if the MAC supports the 16-bit shift option allowing us
	 * to send BIASed frames without copying. Used by the send function later.
	 */
	if ((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
 1814680:	008061b4 	movhi	r2,390
 1814684:	1089b904 	addi	r2,r2,9956
 1814688:	e0fffe17 	ldw	r3,-8(fp)
 181468c:	18c00924 	muli	r3,r3,36
 1814690:	10c5883a 	add	r2,r2,r3
 1814694:	10800017 	ldw	r2,0(r2)
 1814698:	10803a04 	addi	r2,r2,232
 181469c:	10800037 	ldwio	r2,0(r2)
 18146a0:	1080012c 	andhi	r2,r2,4
 18146a4:	1000021e 	bne	r2,zero,18146b0 <tse_mac_init+0x4a0>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 18146a8:	00bffc44 	movi	r2,-15
 18146ac:	0000e606 	br	1814a48 <tse_mac_init+0x838>
	}

	/* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
	IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 18146b0:	008061b4 	movhi	r2,390
 18146b4:	1089b904 	addi	r2,r2,9956
 18146b8:	e0fffe17 	ldw	r3,-8(fp)
 18146bc:	18c00924 	muli	r3,r3,36
 18146c0:	10c5883a 	add	r2,r2,r3
 18146c4:	10800017 	ldw	r2,0(r2)
 18146c8:	10803b04 	addi	r2,r2,236
 18146cc:	00c08034 	movhi	r3,512
 18146d0:	10c00035 	stwio	r3,0(r2)

	/* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */
	if ((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
 18146d4:	008061b4 	movhi	r2,390
 18146d8:	1089b904 	addi	r2,r2,9956
 18146dc:	e0fffe17 	ldw	r3,-8(fp)
 18146e0:	18c00924 	muli	r3,r3,36
 18146e4:	10c5883a 	add	r2,r2,r3
 18146e8:	10800017 	ldw	r2,0(r2)
 18146ec:	10803b04 	addi	r2,r2,236
 18146f0:	10800037 	ldwio	r2,0(r2)
 18146f4:	1080802c 	andhi	r2,r2,512
 18146f8:	1000021e 	bne	r2,zero,1814704 <tse_mac_init+0x4f4>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 18146fc:	00bffc44 	movi	r2,-15
 1814700:	0000d106 	br	1814a48 <tse_mac_init+0x838>
	}

	/* Set the MAC address */
	IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
 1814704:	e0bffa17 	ldw	r2,-24(fp)
 1814708:	10800304 	addi	r2,r2,12
 181470c:	e0ffff17 	ldw	r3,-4(fp)
 1814710:	18c00017 	ldw	r3,0(r3)
 1814714:	18c00003 	ldbu	r3,0(r3)
 1814718:	19003fcc 	andi	r4,r3,255
 181471c:	e0ffff17 	ldw	r3,-4(fp)
 1814720:	18c00017 	ldw	r3,0(r3)
 1814724:	18c00043 	ldbu	r3,1(r3)
 1814728:	18c03fcc 	andi	r3,r3,255
 181472c:	1806923a 	slli	r3,r3,8
 1814730:	20c8b03a 	or	r4,r4,r3
 1814734:	e0ffff17 	ldw	r3,-4(fp)
 1814738:	18c00017 	ldw	r3,0(r3)
 181473c:	18c00083 	ldbu	r3,2(r3)
 1814740:	18c03fcc 	andi	r3,r3,255
 1814744:	1806943a 	slli	r3,r3,16
 1814748:	20c8b03a 	or	r4,r4,r3
 181474c:	e0ffff17 	ldw	r3,-4(fp)
 1814750:	18c00017 	ldw	r3,0(r3)
 1814754:	18c000c3 	ldbu	r3,3(r3)
 1814758:	18c03fcc 	andi	r3,r3,255
 181475c:	1806963a 	slli	r3,r3,24
 1814760:	20c6b03a 	or	r3,r4,r3
 1814764:	10c00035 	stwio	r3,0(r2)
			((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
					(int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
					(int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

	IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
 1814768:	e0bffa17 	ldw	r2,-24(fp)
 181476c:	10800404 	addi	r2,r2,16
 1814770:	e0ffff17 	ldw	r3,-4(fp)
 1814774:	18c00017 	ldw	r3,0(r3)
 1814778:	18c00103 	ldbu	r3,4(r3)
 181477c:	19003fcc 	andi	r4,r3,255
 1814780:	e0ffff17 	ldw	r3,-4(fp)
 1814784:	18c00017 	ldw	r3,0(r3)
 1814788:	18c00143 	ldbu	r3,5(r3)
 181478c:	18c03fcc 	andi	r3,r3,255
 1814790:	1806923a 	slli	r3,r3,8
 1814794:	20c6b03a 	or	r3,r4,r3
 1814798:	18ffffcc 	andi	r3,r3,65535
 181479c:	10c00035 	stwio	r3,0(r2)
			(((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));

	/* enable MAC */
	dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 18147a0:	00810034 	movhi	r2,1024
 18147a4:	108080c4 	addi	r2,r2,515
 18147a8:	e0bff315 	stw	r2,-52(fp)
			ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
			ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
			ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */

	if ((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0)
 18147ac:	e0bffb17 	ldw	r2,-20(fp)
 18147b0:	1080022c 	andhi	r2,r2,8
 18147b4:	1000461e 	bne	r2,zero,18148d0 <tse_mac_init+0x6c0>
	{
		speed = (result >> 1) & 0x07;
 18147b8:	e0bffb17 	ldw	r2,-20(fp)
 18147bc:	1005d07a 	srai	r2,r2,1
 18147c0:	108001cc 	andi	r2,r2,7
 18147c4:	e0bffc15 	stw	r2,-16(fp)
		duplex = result & 0x01;
 18147c8:	e0bffb17 	ldw	r2,-20(fp)
 18147cc:	1080004c 	andi	r2,r2,1
 18147d0:	e0bff415 	stw	r2,-48(fp)

		/* 1000 Mbps */
		if(speed == 0x01)
 18147d4:	e0bffc17 	ldw	r2,-16(fp)
 18147d8:	10800058 	cmpnei	r2,r2,1
 18147dc:	1000121e 	bne	r2,zero,1814828 <tse_mac_init+0x618>
		{
			dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 18147e0:	e0bff317 	ldw	r2,-52(fp)
 18147e4:	10800214 	ori	r2,r2,8
 18147e8:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 18147ec:	e0fff317 	ldw	r3,-52(fp)
 18147f0:	00bf8034 	movhi	r2,65024
 18147f4:	10bfffc4 	addi	r2,r2,-1
 18147f8:	1884703a 	and	r2,r3,r2
 18147fc:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 1000;
 1814800:	008061b4 	movhi	r2,390
 1814804:	1089b904 	addi	r2,r2,9956
 1814808:	e0fffe17 	ldw	r3,-8(fp)
 181480c:	18c00924 	muli	r3,r3,36
 1814810:	10c5883a 	add	r2,r2,r3
 1814814:	10800604 	addi	r2,r2,24
 1814818:	10800017 	ldw	r2,0(r2)
 181481c:	00c0fa04 	movi	r3,1000
 1814820:	10c00315 	stw	r3,12(r2)
 1814824:	00003306 	br	18148f4 <tse_mac_init+0x6e4>
		}
		/* 100 Mbps */
		else if(speed == 0x02)
 1814828:	e0bffc17 	ldw	r2,-16(fp)
 181482c:	10800098 	cmpnei	r2,r2,2
 1814830:	1000131e 	bne	r2,zero,1814880 <tse_mac_init+0x670>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 1814834:	e0fff317 	ldw	r3,-52(fp)
 1814838:	00bffdc4 	movi	r2,-9
 181483c:	1884703a 	and	r2,r3,r2
 1814840:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 1814844:	e0fff317 	ldw	r3,-52(fp)
 1814848:	00bf8034 	movhi	r2,65024
 181484c:	10bfffc4 	addi	r2,r2,-1
 1814850:	1884703a 	and	r2,r3,r2
 1814854:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 100;
 1814858:	008061b4 	movhi	r2,390
 181485c:	1089b904 	addi	r2,r2,9956
 1814860:	e0fffe17 	ldw	r3,-8(fp)
 1814864:	18c00924 	muli	r3,r3,36
 1814868:	10c5883a 	add	r2,r2,r3
 181486c:	10800604 	addi	r2,r2,24
 1814870:	10800017 	ldw	r2,0(r2)
 1814874:	00c01904 	movi	r3,100
 1814878:	10c00315 	stw	r3,12(r2)
 181487c:	00001d06 	br	18148f4 <tse_mac_init+0x6e4>
		}
		/* 10 Mbps */
		else if(speed == 0x04)
 1814880:	e0bffc17 	ldw	r2,-16(fp)
 1814884:	10800118 	cmpnei	r2,r2,4
 1814888:	10001a1e 	bne	r2,zero,18148f4 <tse_mac_init+0x6e4>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 181488c:	e0fff317 	ldw	r3,-52(fp)
 1814890:	00bffdc4 	movi	r2,-9
 1814894:	1884703a 	and	r2,r3,r2
 1814898:	e0bff315 	stw	r2,-52(fp)
			dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 181489c:	e0bff317 	ldw	r2,-52(fp)
 18148a0:	10808034 	orhi	r2,r2,512
 18148a4:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 10;
 18148a8:	008061b4 	movhi	r2,390
 18148ac:	1089b904 	addi	r2,r2,9956
 18148b0:	e0fffe17 	ldw	r3,-8(fp)
 18148b4:	18c00924 	muli	r3,r3,36
 18148b8:	10c5883a 	add	r2,r2,r3
 18148bc:	10800604 	addi	r2,r2,24
 18148c0:	10800017 	ldw	r2,0(r2)
 18148c4:	00c00284 	movi	r3,10
 18148c8:	10c00315 	stw	r3,12(r2)
 18148cc:	00000906 	br	18148f4 <tse_mac_init+0x6e4>
		}
	}
	/* default to 100 Mbps if returned invalid speed */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 18148d0:	e0fff317 	ldw	r3,-52(fp)
 18148d4:	00bffdc4 	movi	r2,-9
 18148d8:	1884703a 	and	r2,r3,r2
 18148dc:	e0bff315 	stw	r2,-52(fp)
		dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 18148e0:	e0fff317 	ldw	r3,-52(fp)
 18148e4:	00bf8034 	movhi	r2,65024
 18148e8:	10bfffc4 	addi	r2,r2,-1
 18148ec:	1884703a 	and	r2,r3,r2
 18148f0:	e0bff315 	stw	r2,-52(fp)
	}

	/* Half Duplex */
	if(duplex == TSE_PHY_DUPLEX_HALF)
 18148f4:	e0bff417 	ldw	r2,-48(fp)
 18148f8:	10000c1e 	bne	r2,zero,181492c <tse_mac_init+0x71c>
	{
		dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 18148fc:	e0bff317 	ldw	r2,-52(fp)
 1814900:	10810014 	ori	r2,r2,1024
 1814904:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 0;
 1814908:	008061b4 	movhi	r2,390
 181490c:	1089b904 	addi	r2,r2,9956
 1814910:	e0fffe17 	ldw	r3,-8(fp)
 1814914:	18c00924 	muli	r3,r3,36
 1814918:	10c5883a 	add	r2,r2,r3
 181491c:	10800604 	addi	r2,r2,24
 1814920:	10800017 	ldw	r2,0(r2)
 1814924:	10000415 	stw	zero,16(r2)
 1814928:	00000d06 	br	1814960 <tse_mac_init+0x750>
	}
	/* Full Duplex */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 181492c:	e0fff317 	ldw	r3,-52(fp)
 1814930:	00beffc4 	movi	r2,-1025
 1814934:	1884703a 	and	r2,r3,r2
 1814938:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 1;
 181493c:	008061b4 	movhi	r2,390
 1814940:	1089b904 	addi	r2,r2,9956
 1814944:	e0fffe17 	ldw	r3,-8(fp)
 1814948:	18c00924 	muli	r3,r3,36
 181494c:	10c5883a 	add	r2,r2,r3
 1814950:	10800604 	addi	r2,r2,24
 1814954:	10800017 	ldw	r2,0(r2)
 1814958:	00c00044 	movi	r3,1
 181495c:	10c00415 	stw	r3,16(r2)
	}

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 1814960:	008061b4 	movhi	r2,390
 1814964:	1089b904 	addi	r2,r2,9956
 1814968:	e0fffe17 	ldw	r3,-8(fp)
 181496c:	18c00924 	muli	r3,r3,36
 1814970:	10c5883a 	add	r2,r2,r3
 1814974:	10800017 	ldw	r2,0(r2)
 1814978:	10800204 	addi	r2,r2,8
 181497c:	e0fff317 	ldw	r3,-52(fp)
 1814980:	10c00035 	stwio	r3,0(r2)
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 1814984:	008061b4 	movhi	r2,390
 1814988:	1089b904 	addi	r2,r2,9956
 181498c:	e0fffe17 	ldw	r3,-8(fp)
 1814990:	18c00924 	muli	r3,r3,36
 1814994:	10c5883a 	add	r2,r2,r3
 1814998:	10800204 	addi	r2,r2,8
 181499c:	11000017 	ldw	r4,0(r2)
#ifndef ALTERA_TSE_IRQ_R
			(alt_avalon_sgdma_callback)&tse_sgdma_rx_isr,
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
 18149a0:	e0bffe17 	ldw	r2,-8(fp)
 18149a4:	10c00924 	muli	r3,r2,36
 18149a8:	008061b4 	movhi	r2,390
 18149ac:	1089b904 	addi	r2,r2,9956
 18149b0:	1885883a 	add	r2,r3,r2

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 18149b4:	100f883a 	mov	r7,r2
 18149b8:	01800604 	movi	r6,24
 18149bc:	01406074 	movhi	r5,385
 18149c0:	2952c004 	addi	r5,r5,19200
 18149c4:	1825e940 	call	1825e94 <alt_avalon_sgdma_register_callback>
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));

	tse_sgdma_read_init(&tse[iface]);
 18149c8:	e0bffe17 	ldw	r2,-8(fp)
 18149cc:	10c00924 	muli	r3,r2,36
 18149d0:	008061b4 	movhi	r2,390
 18149d4:	1089b904 	addi	r2,r2,9956
 18149d8:	1885883a 	add	r2,r3,r2
 18149dc:	1009883a 	mov	r4,r2
 18149e0:	1814a5c0 	call	1814a5c <tse_sgdma_read_init>
	pmac_info = alt_tse_get_mac_info(mi_base);
 18149e4:	e13ffa17 	ldw	r4,-24(fp)
 18149e8:	182d4100 	call	182d410 <alt_tse_get_mac_info>
 18149ec:	e0bffd15 	stw	r2,-12(fp)
	alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
 18149f0:	e0bffd17 	ldw	r2,-12(fp)
 18149f4:	10c00117 	ldw	r3,4(r2)
 18149f8:	e0bffd17 	ldw	r2,-12(fp)
 18149fc:	10800117 	ldw	r2,4(r2)
 1814a00:	10800003 	ldbu	r2,0(r2)
 1814a04:	10803fcc 	andi	r2,r2,255
 1814a08:	100b883a 	mov	r5,r2
 1814a0c:	1809883a 	mov	r4,r3
 1814a10:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
	ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;// && (((IORD(&(mi_base->mdio1.reg10), 0) >> 4) & 0xF) <= 3);
 1814a14:	e0bffd17 	ldw	r2,-12(fp)
 1814a18:	10800117 	ldw	r2,4(r2)
 1814a1c:	01c00044 	movi	r7,1
 1814a20:	01800144 	movi	r6,5
 1814a24:	01400044 	movi	r5,1
 1814a28:	1009883a 	mov	r4,r2
 1814a2c:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1814a30:	1004c03a 	cmpne	r2,r2,zero
 1814a34:	10c03fcc 	andi	r3,r2,255
 1814a38:	e0bfff17 	ldw	r2,-4(fp)
 1814a3c:	10c00215 	stw	r3,8(r2)
	return ethernetif->link_alive;
 1814a40:	e0bfff17 	ldw	r2,-4(fp)
 1814a44:	10800217 	ldw	r2,8(r2)
}
 1814a48:	e037883a 	mov	sp,fp
 1814a4c:	dfc00117 	ldw	ra,4(sp)
 1814a50:	df000017 	ldw	fp,0(sp)
 1814a54:	dec00204 	addi	sp,sp,8
 1814a58:	f800283a 	ret

01814a5c <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
 1814a5c:	defffb04 	addi	sp,sp,-20
 1814a60:	dfc00415 	stw	ra,16(sp)
 1814a64:	df000315 	stw	fp,12(sp)
 1814a68:	df000304 	addi	fp,sp,12
 1814a6c:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;
 1814a70:	e0bfff17 	ldw	r2,-4(fp)
 1814a74:	10800617 	ldw	r2,24(r2)
 1814a78:	e0bffe15 	stw	r2,-8(fp)

	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 1814a7c:	e0bfff17 	ldw	r2,-4(fp)
 1814a80:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 1814a84:	11001004 	addi	r4,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 1814a88:	e0bfff17 	ldw	r2,-4(fp)
 1814a8c:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 1814a90:	11401804 	addi	r5,r2,96
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
			(alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
 1814a94:	e0bfff17 	ldw	r2,-4(fp)
 1814a98:	10800617 	ldw	r2,24(r2)
 1814a9c:	10801317 	ldw	r2,76(r2)
 1814aa0:	e0fffe17 	ldw	r3,-8(fp)
 1814aa4:	108001c4 	addi	r2,r2,7
 1814aa8:	1085883a 	add	r2,r2,r2
 1814aac:	1085883a 	add	r2,r2,r2
 1814ab0:	1885883a 	add	r2,r3,r2
 1814ab4:	10800017 	ldw	r2,0(r2)
 1814ab8:	10800117 	ldw	r2,4(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 1814abc:	d8000015 	stw	zero,0(sp)
 1814ac0:	000f883a 	mov	r7,zero
 1814ac4:	100d883a 	mov	r6,r2
 1814ac8:	1825cb00 	call	1825cb0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  // read until EOP
			0);          // don't write to constant address

	dprintf(("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0));

	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 1814acc:	e0ffff17 	ldw	r3,-4(fp)
 1814ad0:	e0bfff17 	ldw	r2,-4(fp)
 1814ad4:	10800517 	ldw	r2,20(r2)
 1814ad8:	10801004 	addi	r2,r2,64
 1814adc:	100b883a 	mov	r5,r2
 1814ae0:	1809883a 	mov	r4,r3
 1814ae4:	182c30c0 	call	182c30c <tse_mac_aRxRead>

	return SUCCESS;
 1814ae8:	0005883a 	mov	r2,zero
}
 1814aec:	e037883a 	mov	sp,fp
 1814af0:	dfc00117 	ldw	ra,4(sp)
 1814af4:	df000017 	ldw	fp,0(sp)
 1814af8:	dec00204 	addi	sp,sp,8
 1814afc:	f800283a 	ret

01814b00 <tse_sgdma_rx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdma_rx_isr(void * context, __unused u_long intnum)
{
 1814b00:	defffb04 	addi	sp,sp,-20
 1814b04:	dfc00415 	stw	ra,16(sp)
 1814b08:	df000315 	stw	fp,12(sp)
 1814b0c:	df000304 	addi	fp,sp,12
 1814b10:	e13ffe15 	stw	r4,-8(fp)
 1814b14:	e17fff15 	stw	r5,-4(fp)
	lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
 1814b18:	e0bffe17 	ldw	r2,-8(fp)
 1814b1c:	e0bffd15 	stw	r2,-12(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
 1814b20:	e0bffd17 	ldw	r2,-12(fp)
 1814b24:	10800217 	ldw	r2,8(r2)
 1814b28:	10800304 	addi	r2,r2,12
 1814b2c:	10800404 	addi	r2,r2,16
 1814b30:	00e00034 	movhi	r3,32768
 1814b34:	10c00035 	stwio	r3,0(r2)

	// process the newly received data and cycle to the next free pbuf for receive
	tse_mac_rcv(tse_ptr->ethernetif);
 1814b38:	e0bffd17 	ldw	r2,-12(fp)
 1814b3c:	10800617 	ldw	r2,24(r2)
 1814b40:	1009883a 	mov	r4,r2
 1814b44:	1814cf40 	call	1814cf4 <tse_mac_rcv>

	// start a new async read transaction
	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 1814b48:	e0fffd17 	ldw	r3,-12(fp)
 1814b4c:	e0bffd17 	ldw	r2,-12(fp)
 1814b50:	10800517 	ldw	r2,20(r2)
 1814b54:	10801004 	addi	r2,r2,64
 1814b58:	100b883a 	mov	r5,r2
 1814b5c:	1809883a 	mov	r4,r3
 1814b60:	182c30c0 	call	182c30c <tse_mac_aRxRead>

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
 1814b64:	e0bffd17 	ldw	r2,-12(fp)
 1814b68:	10800217 	ldw	r2,8(r2)
 1814b6c:	10800304 	addi	r2,r2,12
 1814b70:	10800404 	addi	r2,r2,16
 1814b74:	00c00604 	movi	r3,24
 1814b78:	10c00035 	stwio	r3,0(r2)

	return SUCCESS;
 1814b7c:	0005883a 	mov	r2,zero
}
 1814b80:	e037883a 	mov	sp,fp
 1814b84:	dfc00117 	ldw	ra,4(sp)
 1814b88:	df000017 	ldw	fp,0(sp)
 1814b8c:	dec00204 	addi	sp,sp,8
 1814b90:	f800283a 	ret

01814b94 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
 1814b94:	defe6a04 	addi	sp,sp,-1624
 1814b98:	dfc19515 	stw	ra,1620(sp)
 1814b9c:	df019415 	stw	fp,1616(sp)
 1814ba0:	df019404 	addi	fp,sp,1616
 1814ba4:	e13ffe15 	stw	r4,-8(fp)
 1814ba8:	e17fff15 	stw	r5,-4(fp)
	alt_u32			   *ActualData;

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560];

	ethernetif = netif->state;
 1814bac:	e0bffe17 	ldw	r2,-8(fp)
 1814bb0:	10800917 	ldw	r2,36(r2)
 1814bb4:	e0be7215 	stw	r2,-1592(fp)
	tse_ptr = ethernetif->tse_info;
 1814bb8:	e0be7217 	ldw	r2,-1592(fp)
 1814bbc:	10801717 	ldw	r2,92(r2)
 1814bc0:	e0be7315 	stw	r2,-1588(fp)
	mi = &tse_ptr->mi;
 1814bc4:	e0be7317 	ldw	r2,-1588(fp)
 1814bc8:	e0be7415 	stw	r2,-1584(fp)

	for(p = pkt; p != NULL; p = p->next)
 1814bcc:	e0bfff17 	ldw	r2,-4(fp)
 1814bd0:	e0be7015 	stw	r2,-1600(fp)
 1814bd4:	00003806 	br	1814cb8 <tse_mac_raw_send+0x124>
	{
		data = p->payload;
 1814bd8:	e0be7017 	ldw	r2,-1600(fp)
 1814bdc:	10800117 	ldw	r2,4(r2)
 1814be0:	e0be7115 	stw	r2,-1596(fp)
		len = p->len;
 1814be4:	e0be7017 	ldw	r2,-1600(fp)
 1814be8:	1080028b 	ldhu	r2,10(r2)
 1814bec:	10bfffcc 	andi	r2,r2,65535
 1814bf0:	e0be7515 	stw	r2,-1580(fp)

		// just in case we have an unaligned buffer, this should never occur
		if(((unsigned long)data & 0x03) != 0)
 1814bf4:	e0be7117 	ldw	r2,-1596(fp)
 1814bf8:	108000cc 	andi	r2,r2,3
 1814bfc:	10000726 	beq	r2,zero,1814c1c <tse_mac_raw_send+0x88>
			/*
			 * Copy data to temporary buffer <buf2>. This is done because of alignment
			 * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
			 * because it needs a 32-bit aligned address space.
			 */
			memcpy(buf2,data,len);
 1814c00:	e0be7804 	addi	r2,fp,-1568
 1814c04:	e1be7517 	ldw	r6,-1580(fp)
 1814c08:	e17e7117 	ldw	r5,-1596(fp)
 1814c0c:	1009883a 	mov	r4,r2
 1814c10:	180608c0 	call	180608c <memcpy>
			data = (alt_u32 *)buf2;
 1814c14:	e0be7804 	addi	r2,fp,-1568
 1814c18:	e0be7115 	stw	r2,-1596(fp)
		}

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));
 1814c1c:	e0be7117 	ldw	r2,-1596(fp)
 1814c20:	e0be7615 	stw	r2,-1576(fp)

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 1814c24:	e0be7317 	ldw	r2,-1588(fp)
 1814c28:	11000517 	ldw	r4,20(r2)
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 1814c2c:	e0be7317 	ldw	r2,-1588(fp)
 1814c30:	10800517 	ldw	r2,20(r2)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 1814c34:	11400804 	addi	r5,r2,32
 1814c38:	e0be7517 	ldw	r2,-1580(fp)
 1814c3c:	11bfffcc 	andi	r6,r2,65535
 1814c40:	e0fe7017 	ldw	r3,-1600(fp)
 1814c44:	e0bfff17 	ldw	r2,-4(fp)
 1814c48:	1885003a 	cmpeq	r2,r3,r2
 1814c4c:	10803fcc 	andi	r2,r2,255
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
				(alt_u32*)ActualData,                    // starting read address
				(len),                                   // # bytes
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
 1814c50:	e0fe7017 	ldw	r3,-1600(fp)
 1814c54:	18c00017 	ldw	r3,0(r3)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 1814c58:	1807003a 	cmpeq	r3,r3,zero
 1814c5c:	18c03fcc 	andi	r3,r3,255
 1814c60:	d8000315 	stw	zero,12(sp)
 1814c64:	d8c00215 	stw	r3,8(sp)
 1814c68:	d8800115 	stw	r2,4(sp)
 1814c6c:	d8000015 	stw	zero,0(sp)
 1814c70:	300f883a 	mov	r7,r6
 1814c74:	e1be7617 	ldw	r6,-1576(fp)
 1814c78:	1825d880 	call	1825d88 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
				0);                                      // atlantic channel (don't know/don't care: set to 0)

		tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
 1814c7c:	e0be7317 	ldw	r2,-1588(fp)
 1814c80:	10800517 	ldw	r2,20(r2)
 1814c84:	100b883a 	mov	r5,r2
 1814c88:	e13e7417 	ldw	r4,-1584(fp)
 1814c8c:	182c2280 	call	182c228 <tse_mac_sTxWrite>
 1814c90:	e0be7715 	stw	r2,-1572(fp)

		if (tx_length != p->len)
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
 1814c94:	e0be7217 	ldw	r2,-1592(fp)
 1814c98:	10c00517 	ldw	r3,20(r2)
 1814c9c:	e0be7717 	ldw	r2,-1572(fp)
 1814ca0:	1887883a 	add	r3,r3,r2
 1814ca4:	e0be7217 	ldw	r2,-1592(fp)
 1814ca8:	10c00515 	stw	r3,20(r2)

	ethernetif = netif->state;
	tse_ptr = ethernetif->tse_info;
	mi = &tse_ptr->mi;

	for(p = pkt; p != NULL; p = p->next)
 1814cac:	e0be7017 	ldw	r2,-1600(fp)
 1814cb0:	10800017 	ldw	r2,0(r2)
 1814cb4:	e0be7015 	stw	r2,-1600(fp)
 1814cb8:	e0be7017 	ldw	r2,-1600(fp)
 1814cbc:	103fc61e 	bne	r2,zero,1814bd8 <__ram_exceptions_end+0xff804794>
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
	}

	LINK_STATS_INC(link.xmit);
 1814cc0:	008061f4 	movhi	r2,391
 1814cc4:	10a9d404 	addi	r2,r2,-22704
 1814cc8:	10800017 	ldw	r2,0(r2)
 1814ccc:	10c00044 	addi	r3,r2,1
 1814cd0:	008061f4 	movhi	r2,391
 1814cd4:	10a9d404 	addi	r2,r2,-22704
 1814cd8:	10c00015 	stw	r3,0(r2)

	return ERR_OK;
 1814cdc:	0005883a 	mov	r2,zero
}
 1814ce0:	e037883a 	mov	sp,fp
 1814ce4:	dfc00117 	ldw	ra,4(sp)
 1814ce8:	df000017 	ldw	fp,0(sp)
 1814cec:	dec00204 	addi	sp,sp,8
 1814cf0:	f800283a 	ret

01814cf4 <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{
 1814cf4:	defff704 	addi	sp,sp,-36
 1814cf8:	dfc00815 	stw	ra,32(sp)
 1814cfc:	df000715 	stw	fp,28(sp)
 1814d00:	df000704 	addi	fp,sp,28
 1814d04:	e13fff15 	stw	r4,-4(fp)
#if LWIP_RECEIVE_SEMAPHORE
	signed portBASE_TYPE switch_context = 0;
 1814d08:	e03ffe15 	stw	zero,-8(fp)
	int pklen;
	lwip_tse_info* tse_ptr;
	alt_u32 *uncached_packet_payload;
	struct pbuf *p;

	tse_ptr = ethernetif->tse_info;
 1814d0c:	e0bfff17 	ldw	r2,-4(fp)
 1814d10:	10801717 	ldw	r2,92(r2)
 1814d14:	e0bffa15 	stw	r2,-24(fp)
	pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
 1814d18:	e0bffa17 	ldw	r2,-24(fp)
 1814d1c:	10800517 	ldw	r2,20(r2)
 1814d20:	10801004 	addi	r2,r2,64
 1814d24:	10800704 	addi	r2,r2,28
 1814d28:	1080002b 	ldhuio	r2,0(r2)
 1814d2c:	10bfffcc 	andi	r2,r2,65535
 1814d30:	e0bffb15 	stw	r2,-20(fp)
	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
 1814d34:	e0bfff17 	ldw	r2,-4(fp)
 1814d38:	10801317 	ldw	r2,76(r2)
 1814d3c:	e0ffff17 	ldw	r3,-4(fp)
 1814d40:	108001c4 	addi	r2,r2,7
 1814d44:	1085883a 	add	r2,r2,r2
 1814d48:	1085883a 	add	r2,r2,r2
 1814d4c:	1885883a 	add	r2,r3,r2
 1814d50:	10800017 	ldw	r2,0(r2)
 1814d54:	e0bffc15 	stw	r2,-16(fp)
	p->tot_len = pklen;
 1814d58:	e0bffb17 	ldw	r2,-20(fp)
 1814d5c:	1007883a 	mov	r3,r2
 1814d60:	e0bffc17 	ldw	r2,-16(fp)
 1814d64:	10c0020d 	sth	r3,8(r2)
	p->len = pklen;
 1814d68:	e0bffb17 	ldw	r2,-20(fp)
 1814d6c:	1007883a 	mov	r3,r2
 1814d70:	e0bffc17 	ldw	r2,-16(fp)
 1814d74:	10c0028d 	sth	r3,10(r2)
	if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
 1814d78:	e0bffa17 	ldw	r2,-24(fp)
 1814d7c:	10800517 	ldw	r2,20(r2)
 1814d80:	10801704 	addi	r2,r2,92
 1814d84:	10800037 	ldwio	r2,0(r2)
 1814d88:	1005d43a 	srai	r2,r2,16
 1814d8c:	10801fcc 	andi	r2,r2,127
 1814d90:	10002d1e 	bne	r2,zero,1814e48 <tse_mac_rcv+0x154>
	{
		enh_alt_irq_disable_all();
 1814d94:	18275c00 	call	18275c0 <enh_alt_irq_disable_all>

		if (++ethernetif->lwipRxCount >= LWIP_RX_ETH_BUFFER)
 1814d98:	e0bfff17 	ldw	r2,-4(fp)
 1814d9c:	10801517 	ldw	r2,84(r2)
 1814da0:	10800044 	addi	r2,r2,1
 1814da4:	e0ffff17 	ldw	r3,-4(fp)
 1814da8:	18801515 	stw	r2,84(r3)
 1814dac:	10800310 	cmplti	r2,r2,12
 1814db0:	10000e1e 	bne	r2,zero,1814dec <tse_mac_rcv+0xf8>
		{
			LINK_STATS_INC(link.drop);
 1814db4:	008061f4 	movhi	r2,391
 1814db8:	10a9d404 	addi	r2,r2,-22704
 1814dbc:	10800317 	ldw	r2,12(r2)
 1814dc0:	10c00044 	addi	r3,r2,1
 1814dc4:	008061f4 	movhi	r2,391
 1814dc8:	10a9d404 	addi	r2,r2,-22704
 1814dcc:	10c00315 	stw	r3,12(r2)
			--ethernetif->lwipRxCount;
 1814dd0:	e0bfff17 	ldw	r2,-4(fp)
 1814dd4:	10801517 	ldw	r2,84(r2)
 1814dd8:	10ffffc4 	addi	r3,r2,-1
 1814ddc:	e0bfff17 	ldw	r2,-4(fp)
 1814de0:	10c01515 	stw	r3,84(r2)

			enh_alt_irq_enable_all();
 1814de4:	18276100 	call	1827610 <enh_alt_irq_enable_all>
 1814de8:	00001706 	br	1814e48 <tse_mac_rcv+0x154>

			dprintf(("No free buffers for RX on iface: %hhd\n", ethernetif->iface));
		}
		else
		{
			ethernetif->bytes_recv += pklen;
 1814dec:	e0bfff17 	ldw	r2,-4(fp)
 1814df0:	10c00617 	ldw	r3,24(r2)
 1814df4:	e0bffb17 	ldw	r2,-20(fp)
 1814df8:	1887883a 	add	r3,r3,r2
 1814dfc:	e0bfff17 	ldw	r2,-4(fp)
 1814e00:	10c00615 	stw	r3,24(r2)

			//  Set up DMA for the next pbuf in the buffer
			if (++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER)
 1814e04:	e0bfff17 	ldw	r2,-4(fp)
 1814e08:	10801317 	ldw	r2,76(r2)
 1814e0c:	10800044 	addi	r2,r2,1
 1814e10:	e0ffff17 	ldw	r3,-4(fp)
 1814e14:	18801315 	stw	r2,76(r3)
 1814e18:	10800310 	cmplti	r2,r2,12
 1814e1c:	1000021e 	bne	r2,zero,1814e28 <tse_mac_rcv+0x134>
				ethernetif->lwipRxIndexIsr = 0;
 1814e20:	e0bfff17 	ldw	r2,-4(fp)
 1814e24:	10001315 	stw	zero,76(r2)

			enh_alt_irq_enable_all();
 1814e28:	18276100 	call	1827610 <enh_alt_irq_enable_all>

#if LWIP_RECEIVE_SEMAPHORE
			// we can't use the LwIP sys_signal_sem since this can't be used in an ISR
			// release the semaphore and check if a task with a higher priority then the current one is waiting for it
			xSemaphoreGiveFromISR(ethernetif->tse_info->rx_semaphore, &switch_context);
 1814e2c:	e0bfff17 	ldw	r2,-4(fp)
 1814e30:	10801717 	ldw	r2,92(r2)
 1814e34:	10800817 	ldw	r2,32(r2)
 1814e38:	e0fffe04 	addi	r3,fp,-8
 1814e3c:	180b883a 	mov	r5,r3
 1814e40:	1009883a 	mov	r4,r2
 1814e44:	180dd540 	call	180dd54 <xQueueGiveFromISR>
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
 1814e48:	e0bfff17 	ldw	r2,-4(fp)
 1814e4c:	10801317 	ldw	r2,76(r2)
 1814e50:	e0ffff17 	ldw	r3,-4(fp)
 1814e54:	108001c4 	addi	r2,r2,7
 1814e58:	1085883a 	add	r2,r2,r2
 1814e5c:	1085883a 	add	r2,r2,r2
 1814e60:	1885883a 	add	r2,r3,r2
 1814e64:	10800017 	ldw	r2,0(r2)
 1814e68:	10800117 	ldw	r2,4(r2)
 1814e6c:	e0bffd15 	stw	r2,-12(fp)
	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
 1814e70:	e0bffa17 	ldw	r2,-24(fp)
 1814e74:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 1814e78:	10c01004 	addi	r3,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 1814e7c:	e0bffa17 	ldw	r2,-24(fp)
 1814e80:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 1814e84:	10801804 	addi	r2,r2,96
 1814e88:	d8000015 	stw	zero,0(sp)
 1814e8c:	000f883a 	mov	r7,zero
 1814e90:	e1bffd17 	ldw	r6,-12(fp)
 1814e94:	100b883a 	mov	r5,r2
 1814e98:	1809883a 	mov	r4,r3
 1814e9c:	1825cb00 	call	1825cb0 <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  											// read until EOP
			0);          																	// don't write to constant address

#if LWIP_RECEIVE_SEMAPHORE
	// if it's waiting we will force a context switch so this task will run right away
	portEND_SWITCHING_ISR(switch_context);
 1814ea0:	e0bffe17 	ldw	r2,-8(fp)
 1814ea4:	10000126 	beq	r2,zero,1814eac <tse_mac_rcv+0x1b8>
 1814ea8:	18100a40 	call	18100a4 <vTaskSwitchContext>
#endif

	return ERR_OK;
 1814eac:	0005883a 	mov	r2,zero
}
 1814eb0:	e037883a 	mov	sp,fp
 1814eb4:	dfc00117 	ldw	ra,4(sp)
 1814eb8:	df000017 	ldw	fp,0(sp)
 1814ebc:	dec00204 	addi	sp,sp,8
 1814ec0:	f800283a 	ret

01814ec4 <sys_init>:
#include <lwip/err.h>
#include <lwip/stats.h>

// LwIP FreeRTOS port
void sys_init(void)
{
 1814ec4:	deffff04 	addi	sp,sp,-4
 1814ec8:	df000015 	stw	fp,0(sp)
 1814ecc:	d839883a 	mov	fp,sp
	return;
 1814ed0:	0001883a 	nop
}
 1814ed4:	e037883a 	mov	sp,fp
 1814ed8:	df000017 	ldw	fp,0(sp)
 1814edc:	dec00104 	addi	sp,sp,4
 1814ee0:	f800283a 	ret

01814ee4 <sys_now>:

u32_t sys_now(void)
{
 1814ee4:	defffb04 	addi	sp,sp,-20
 1814ee8:	dfc00415 	stw	ra,16(sp)
 1814eec:	df000315 	stw	fp,12(sp)
 1814ef0:	dc000215 	stw	r16,8(sp)
 1814ef4:	df000304 	addi	fp,sp,12
	struct timeval tv;
	gettimeofday(&tv, NULL);
 1814ef8:	000b883a 	mov	r5,zero
 1814efc:	e13ffd04 	addi	r4,fp,-12
 1814f00:	1827ef40 	call	1827ef4 <gettimeofday>

	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 1814f04:	e0bffd17 	ldw	r2,-12(fp)
 1814f08:	1400fa24 	muli	r16,r2,1000
 1814f0c:	e0bffe17 	ldw	r2,-8(fp)
 1814f10:	0140fa04 	movi	r5,1000
 1814f14:	1009883a 	mov	r4,r2
 1814f18:	180ac180 	call	180ac18 <__divsi3>
 1814f1c:	8085883a 	add	r2,r16,r2
}
 1814f20:	e6ffff04 	addi	sp,fp,-4
 1814f24:	dfc00217 	ldw	ra,8(sp)
 1814f28:	df000117 	ldw	fp,4(sp)
 1814f2c:	dc000017 	ldw	r16,0(sp)
 1814f30:	dec00304 	addi	sp,sp,12
 1814f34:	f800283a 	ret

01814f38 <sys_sem_new>:
/**
 * Creates and returns a new semaphore. The "count" argument specifies
 * the initial state of the semaphore.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 1814f38:	defffc04 	addi	sp,sp,-16
 1814f3c:	dfc00315 	stw	ra,12(sp)
 1814f40:	df000215 	stw	fp,8(sp)
 1814f44:	df000204 	addi	fp,sp,8
 1814f48:	e13ffe15 	stw	r4,-8(fp)
 1814f4c:	2805883a 	mov	r2,r5
 1814f50:	e0bfff05 	stb	r2,-4(fp)
	// count 0 means a binary semaphore so max value should be 1
	*sem = xSemaphoreCreateCounting((count ? count : 1), count);
 1814f54:	e0bfff03 	ldbu	r2,-4(fp)
 1814f58:	10000226 	beq	r2,zero,1814f64 <sys_sem_new+0x2c>
 1814f5c:	e0bfff03 	ldbu	r2,-4(fp)
 1814f60:	00000106 	br	1814f68 <sys_sem_new+0x30>
 1814f64:	00800044 	movi	r2,1
 1814f68:	e0ffff03 	ldbu	r3,-4(fp)
 1814f6c:	180b883a 	mov	r5,r3
 1814f70:	1009883a 	mov	r4,r2
 1814f74:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 1814f78:	1007883a 	mov	r3,r2
 1814f7c:	e0bffe17 	ldw	r2,-8(fp)
 1814f80:	10c00015 	stw	r3,0(r2)

	if (*sem == NULL) {
 1814f84:	e0bffe17 	ldw	r2,-8(fp)
 1814f88:	10800017 	ldw	r2,0(r2)
 1814f8c:	1000091e 	bne	r2,zero,1814fb4 <sys_sem_new+0x7c>
		SYS_STATS_INC(sem.err);
 1814f90:	008061f4 	movhi	r2,391
 1814f94:	10a9d404 	addi	r2,r2,-22704
 1814f98:	10809617 	ldw	r2,600(r2)
 1814f9c:	10c00044 	addi	r3,r2,1
 1814fa0:	008061f4 	movhi	r2,391
 1814fa4:	10a9d404 	addi	r2,r2,-22704
 1814fa8:	10c09615 	stw	r3,600(r2)
		return ERR_MEM;  // TBD need assert
 1814fac:	00bfffc4 	movi	r2,-1
 1814fb0:	00001506 	br	1815008 <sys_sem_new+0xd0>
	}

	SYS_STATS_INC_USED(sem);
 1814fb4:	008061f4 	movhi	r2,391
 1814fb8:	10a9d404 	addi	r2,r2,-22704
 1814fbc:	10809417 	ldw	r2,592(r2)
 1814fc0:	10c00044 	addi	r3,r2,1
 1814fc4:	008061f4 	movhi	r2,391
 1814fc8:	10a9d404 	addi	r2,r2,-22704
 1814fcc:	10c09415 	stw	r3,592(r2)
 1814fd0:	008061f4 	movhi	r2,391
 1814fd4:	10a9d404 	addi	r2,r2,-22704
 1814fd8:	10c09517 	ldw	r3,596(r2)
 1814fdc:	008061f4 	movhi	r2,391
 1814fe0:	10a9d404 	addi	r2,r2,-22704
 1814fe4:	10809417 	ldw	r2,592(r2)
 1814fe8:	1880062e 	bgeu	r3,r2,1815004 <sys_sem_new+0xcc>
 1814fec:	008061f4 	movhi	r2,391
 1814ff0:	10a9d404 	addi	r2,r2,-22704
 1814ff4:	10c09417 	ldw	r3,592(r2)
 1814ff8:	008061f4 	movhi	r2,391
 1814ffc:	10a9d404 	addi	r2,r2,-22704
 1815000:	10c09515 	stw	r3,596(r2)

	return ERR_OK;
 1815004:	0005883a 	mov	r2,zero
}
 1815008:	e037883a 	mov	sp,fp
 181500c:	dfc00117 	ldw	ra,4(sp)
 1815010:	df000017 	ldw	fp,0(sp)
 1815014:	dec00204 	addi	sp,sp,8
 1815018:	f800283a 	ret

0181501c <sys_sem_free>:

/**
 * Deallocates a semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
 181501c:	defffd04 	addi	sp,sp,-12
 1815020:	dfc00215 	stw	ra,8(sp)
 1815024:	df000115 	stw	fp,4(sp)
 1815028:	df000104 	addi	fp,sp,4
 181502c:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*sem);
 1815030:	e0bfff17 	ldw	r2,-4(fp)
 1815034:	10800017 	ldw	r2,0(r2)
 1815038:	1009883a 	mov	r4,r2
 181503c:	180e6940 	call	180e694 <vQueueDelete>

	SYS_STATS_DEC(sem.used);
 1815040:	008061f4 	movhi	r2,391
 1815044:	10a9d404 	addi	r2,r2,-22704
 1815048:	10809417 	ldw	r2,592(r2)
 181504c:	10ffffc4 	addi	r3,r2,-1
 1815050:	008061f4 	movhi	r2,391
 1815054:	10a9d404 	addi	r2,r2,-22704
 1815058:	10c09415 	stw	r3,592(r2)
}
 181505c:	0001883a 	nop
 1815060:	e037883a 	mov	sp,fp
 1815064:	dfc00117 	ldw	ra,4(sp)
 1815068:	df000017 	ldw	fp,0(sp)
 181506c:	dec00204 	addi	sp,sp,8
 1815070:	f800283a 	ret

01815074 <sys_sem_signal>:

/**
 * Signals a semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
 1815074:	defffd04 	addi	sp,sp,-12
 1815078:	dfc00215 	stw	ra,8(sp)
 181507c:	df000115 	stw	fp,4(sp)
 1815080:	df000104 	addi	fp,sp,4
 1815084:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*sem);
 1815088:	e0bfff17 	ldw	r2,-4(fp)
 181508c:	10800017 	ldw	r2,0(r2)
 1815090:	000f883a 	mov	r7,zero
 1815094:	000d883a 	mov	r6,zero
 1815098:	000b883a 	mov	r5,zero
 181509c:	1009883a 	mov	r4,r2
 18150a0:	180da7c0 	call	180da7c <xQueueGenericSend>
}
 18150a4:	0001883a 	nop
 18150a8:	e037883a 	mov	sp,fp
 18150ac:	dfc00117 	ldw	ra,4(sp)
 18150b0:	df000017 	ldw	fp,0(sp)
 18150b4:	dec00204 	addi	sp,sp,8
 18150b8:	f800283a 	ret

018150bc <sys_arch_sem_wait>:
 *
 * Notice that lwIP implements a function with a similar name,
 * sys_sem_wait(), that uses the sys_arch_sem_wait() function.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 18150bc:	defff904 	addi	sp,sp,-28
 18150c0:	dfc00615 	stw	ra,24(sp)
 18150c4:	df000515 	stw	fp,20(sp)
 18150c8:	df000504 	addi	fp,sp,20
 18150cc:	e13ffe15 	stw	r4,-8(fp)
 18150d0:	e17fff15 	stw	r5,-4(fp)
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
 18150d4:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 18150d8:	e0bffc15 	stw	r2,-16(fp)

	if (timeout != 0)
 18150dc:	e0bfff17 	ldw	r2,-4(fp)
 18150e0:	10001526 	beq	r2,zero,1815138 <sys_arch_sem_wait+0x7c>
	{
		if (xSemaphoreTake(*sem, timeout) == pdTRUE)
 18150e4:	e0bffe17 	ldw	r2,-8(fp)
 18150e8:	10800017 	ldw	r2,0(r2)
 18150ec:	e17fff17 	ldw	r5,-4(fp)
 18150f0:	1009883a 	mov	r4,r2
 18150f4:	180e0080 	call	180e008 <xQueueSemaphoreTake>
 18150f8:	10800058 	cmpnei	r2,r2,1
 18150fc:	10000c1e 	bne	r2,zero,1815130 <sys_arch_sem_wait+0x74>
		{
			nEndTime = xTaskGetTickCount();
 1815100:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 1815104:	e0bffd15 	stw	r2,-12(fp)
			nElapsed = nEndTime - nStartTime;
 1815108:	e0fffd17 	ldw	r3,-12(fp)
 181510c:	e0bffc17 	ldw	r2,-16(fp)
 1815110:	1885c83a 	sub	r2,r3,r2
 1815114:	e0bffb15 	stw	r2,-20(fp)

			if (nElapsed == 0)
 1815118:	e0bffb17 	ldw	r2,-20(fp)
 181511c:	1000021e 	bne	r2,zero,1815128 <sys_arch_sem_wait+0x6c>
				nElapsed = 1;
 1815120:	00800044 	movi	r2,1
 1815124:	e0bffb15 	stw	r2,-20(fp)

			return nElapsed; // return time blocked TBD test
 1815128:	e0bffb17 	ldw	r2,-20(fp)
 181512c:	00001506 	br	1815184 <sys_arch_sem_wait+0xc8>
		}
		else
			return SYS_ARCH_TIMEOUT;
 1815130:	00bfffc4 	movi	r2,-1
 1815134:	00001306 	br	1815184 <sys_arch_sem_wait+0xc8>
	}
	else // must block without a timeout
	{
		while (xSemaphoreTake(*sem, 10000) != pdTRUE);
 1815138:	0001883a 	nop
 181513c:	e0bffe17 	ldw	r2,-8(fp)
 1815140:	10800017 	ldw	r2,0(r2)
 1815144:	0149c404 	movi	r5,10000
 1815148:	1009883a 	mov	r4,r2
 181514c:	180e0080 	call	180e008 <xQueueSemaphoreTake>
 1815150:	10800058 	cmpnei	r2,r2,1
 1815154:	103ff91e 	bne	r2,zero,181513c <__ram_exceptions_end+0xff804cf8>

		nEndTime = xTaskGetTickCount();
 1815158:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 181515c:	e0bffd15 	stw	r2,-12(fp)
		nElapsed = nEndTime - nStartTime;
 1815160:	e0fffd17 	ldw	r3,-12(fp)
 1815164:	e0bffc17 	ldw	r2,-16(fp)
 1815168:	1885c83a 	sub	r2,r3,r2
 181516c:	e0bffb15 	stw	r2,-20(fp)
		if( nElapsed == 0 )
 1815170:	e0bffb17 	ldw	r2,-20(fp)
 1815174:	1000021e 	bne	r2,zero,1815180 <sys_arch_sem_wait+0xc4>
			nElapsed = 1;
 1815178:	00800044 	movi	r2,1
 181517c:	e0bffb15 	stw	r2,-20(fp)

		return nElapsed; // return time blocked
 1815180:	e0bffb17 	ldw	r2,-20(fp)
	}
}
 1815184:	e037883a 	mov	sp,fp
 1815188:	dfc00117 	ldw	ra,4(sp)
 181518c:	df000017 	ldw	fp,0(sp)
 1815190:	dec00204 	addi	sp,sp,8
 1815194:	f800283a 	ret

01815198 <sys_mutex_new>:
#if ! LWIP_COMPAT_MUTEX
/** Create a new mutex
 * @param mutex pointer to the mutex to create
 * @return a new mutex */
err_t sys_mutex_new(sys_mutex_t *mutex)
{
 1815198:	defffd04 	addi	sp,sp,-12
 181519c:	dfc00215 	stw	ra,8(sp)
 18151a0:	df000115 	stw	fp,4(sp)
 18151a4:	df000104 	addi	fp,sp,4
 18151a8:	e13fff15 	stw	r4,-4(fp)
	*mutex = xSemaphoreCreateMutex();
 18151ac:	01000044 	movi	r4,1
 18151b0:	180d89c0 	call	180d89c <xQueueCreateMutex>
 18151b4:	1007883a 	mov	r3,r2
 18151b8:	e0bfff17 	ldw	r2,-4(fp)
 18151bc:	10c00015 	stw	r3,0(r2)

	if (!*mutex) {
 18151c0:	e0bfff17 	ldw	r2,-4(fp)
 18151c4:	10800017 	ldw	r2,0(r2)
 18151c8:	1000091e 	bne	r2,zero,18151f0 <sys_mutex_new+0x58>
		SYS_STATS_INC(mutex.err);
 18151cc:	008061f4 	movhi	r2,391
 18151d0:	10a9d404 	addi	r2,r2,-22704
 18151d4:	10809917 	ldw	r2,612(r2)
 18151d8:	10c00044 	addi	r3,r2,1
 18151dc:	008061f4 	movhi	r2,391
 18151e0:	10a9d404 	addi	r2,r2,-22704
 18151e4:	10c09915 	stw	r3,612(r2)
		return ERR_MEM;
 18151e8:	00bfffc4 	movi	r2,-1
 18151ec:	00001506 	br	1815244 <sys_mutex_new+0xac>
	}

	SYS_STATS_INC_USED(mutex);
 18151f0:	008061f4 	movhi	r2,391
 18151f4:	10a9d404 	addi	r2,r2,-22704
 18151f8:	10809717 	ldw	r2,604(r2)
 18151fc:	10c00044 	addi	r3,r2,1
 1815200:	008061f4 	movhi	r2,391
 1815204:	10a9d404 	addi	r2,r2,-22704
 1815208:	10c09715 	stw	r3,604(r2)
 181520c:	008061f4 	movhi	r2,391
 1815210:	10a9d404 	addi	r2,r2,-22704
 1815214:	10c09817 	ldw	r3,608(r2)
 1815218:	008061f4 	movhi	r2,391
 181521c:	10a9d404 	addi	r2,r2,-22704
 1815220:	10809717 	ldw	r2,604(r2)
 1815224:	1880062e 	bgeu	r3,r2,1815240 <sys_mutex_new+0xa8>
 1815228:	008061f4 	movhi	r2,391
 181522c:	10a9d404 	addi	r2,r2,-22704
 1815230:	10c09717 	ldw	r3,604(r2)
 1815234:	008061f4 	movhi	r2,391
 1815238:	10a9d404 	addi	r2,r2,-22704
 181523c:	10c09815 	stw	r3,608(r2)

	return ERR_OK;
 1815240:	0005883a 	mov	r2,zero
}
 1815244:	e037883a 	mov	sp,fp
 1815248:	dfc00117 	ldw	ra,4(sp)
 181524c:	df000017 	ldw	fp,0(sp)
 1815250:	dec00204 	addi	sp,sp,8
 1815254:	f800283a 	ret

01815258 <sys_mutex_lock>:

/** Lock a mutex
 * @param mutex the mutex to lock */
void sys_mutex_lock(sys_mutex_t *mutex)
{
 1815258:	defffd04 	addi	sp,sp,-12
 181525c:	dfc00215 	stw	ra,8(sp)
 1815260:	df000115 	stw	fp,4(sp)
 1815264:	df000104 	addi	fp,sp,4
 1815268:	e13fff15 	stw	r4,-4(fp)
	// wait on mutex forever
	while (xSemaphoreTake(*mutex, 10000) != pdTRUE);
 181526c:	0001883a 	nop
 1815270:	e0bfff17 	ldw	r2,-4(fp)
 1815274:	10800017 	ldw	r2,0(r2)
 1815278:	0149c404 	movi	r5,10000
 181527c:	1009883a 	mov	r4,r2
 1815280:	180e0080 	call	180e008 <xQueueSemaphoreTake>
 1815284:	10800058 	cmpnei	r2,r2,1
 1815288:	103ff91e 	bne	r2,zero,1815270 <__ram_exceptions_end+0xff804e2c>
}
 181528c:	0001883a 	nop
 1815290:	e037883a 	mov	sp,fp
 1815294:	dfc00117 	ldw	ra,4(sp)
 1815298:	df000017 	ldw	fp,0(sp)
 181529c:	dec00204 	addi	sp,sp,8
 18152a0:	f800283a 	ret

018152a4 <sys_mutex_unlock>:

/** Unlock a mutex
 * @param mutex the mutex to unlock */
void sys_mutex_unlock(sys_mutex_t *mutex)
{
 18152a4:	defffd04 	addi	sp,sp,-12
 18152a8:	dfc00215 	stw	ra,8(sp)
 18152ac:	df000115 	stw	fp,4(sp)
 18152b0:	df000104 	addi	fp,sp,4
 18152b4:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*mutex);
 18152b8:	e0bfff17 	ldw	r2,-4(fp)
 18152bc:	10800017 	ldw	r2,0(r2)
 18152c0:	000f883a 	mov	r7,zero
 18152c4:	000d883a 	mov	r6,zero
 18152c8:	000b883a 	mov	r5,zero
 18152cc:	1009883a 	mov	r4,r2
 18152d0:	180da7c0 	call	180da7c <xQueueGenericSend>
}
 18152d4:	0001883a 	nop
 18152d8:	e037883a 	mov	sp,fp
 18152dc:	dfc00117 	ldw	ra,4(sp)
 18152e0:	df000017 	ldw	fp,0(sp)
 18152e4:	dec00204 	addi	sp,sp,8
 18152e8:	f800283a 	ret

018152ec <sys_mutex_free>:

/** Delete a semaphore
 * @param mutex the mutex to delete */
void sys_mutex_free(sys_mutex_t *mutex)
{
 18152ec:	defffd04 	addi	sp,sp,-12
 18152f0:	dfc00215 	stw	ra,8(sp)
 18152f4:	df000115 	stw	fp,4(sp)
 18152f8:	df000104 	addi	fp,sp,4
 18152fc:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*mutex);
 1815300:	e0bfff17 	ldw	r2,-4(fp)
 1815304:	10800017 	ldw	r2,0(r2)
 1815308:	1009883a 	mov	r4,r2
 181530c:	180e6940 	call	180e694 <vQueueDelete>
	SYS_STATS_DEC(mutex.used);
 1815310:	008061f4 	movhi	r2,391
 1815314:	10a9d404 	addi	r2,r2,-22704
 1815318:	10809717 	ldw	r2,604(r2)
 181531c:	10ffffc4 	addi	r3,r2,-1
 1815320:	008061f4 	movhi	r2,391
 1815324:	10a9d404 	addi	r2,r2,-22704
 1815328:	10c09715 	stw	r3,604(r2)
}
 181532c:	0001883a 	nop
 1815330:	e037883a 	mov	sp,fp
 1815334:	dfc00117 	ldw	ra,4(sp)
 1815338:	df000017 	ldw	fp,0(sp)
 181533c:	dec00204 	addi	sp,sp,8
 1815340:	f800283a 	ret

01815344 <sys_mbox_new>:
 * in mailboxes are pointers. You have to define macros "_MBOX_SIZE"
 * in your lwipopts.h, or ignore this parameter in your implementation
 * and use a default size.
 */
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 1815344:	defffc04 	addi	sp,sp,-16
 1815348:	dfc00315 	stw	ra,12(sp)
 181534c:	df000215 	stw	fp,8(sp)
 1815350:	df000204 	addi	fp,sp,8
 1815354:	e13ffe15 	stw	r4,-8(fp)
 1815358:	e17fff15 	stw	r5,-4(fp)
	*mbox = xQueueCreate(size, sizeof(void *)); // XXX correct? We are posting pointers so I guess it is...
 181535c:	e0bfff17 	ldw	r2,-4(fp)
 1815360:	000d883a 	mov	r6,zero
 1815364:	01400104 	movi	r5,4
 1815368:	1009883a 	mov	r4,r2
 181536c:	180d7140 	call	180d714 <xQueueGenericCreate>
 1815370:	1007883a 	mov	r3,r2
 1815374:	e0bffe17 	ldw	r2,-8(fp)
 1815378:	10c00015 	stw	r3,0(r2)

	if (!*mbox) {
 181537c:	e0bffe17 	ldw	r2,-8(fp)
 1815380:	10800017 	ldw	r2,0(r2)
 1815384:	1000091e 	bne	r2,zero,18153ac <sys_mbox_new+0x68>
		SYS_STATS_INC(mbox.err);
 1815388:	008061f4 	movhi	r2,391
 181538c:	10a9d404 	addi	r2,r2,-22704
 1815390:	10809c17 	ldw	r2,624(r2)
 1815394:	10c00044 	addi	r3,r2,1
 1815398:	008061f4 	movhi	r2,391
 181539c:	10a9d404 	addi	r2,r2,-22704
 18153a0:	10c09c15 	stw	r3,624(r2)
		return ERR_MEM;
 18153a4:	00bfffc4 	movi	r2,-1
 18153a8:	00001506 	br	1815400 <sys_mbox_new+0xbc>
	}

	SYS_STATS_INC_USED(mbox);
 18153ac:	008061f4 	movhi	r2,391
 18153b0:	10a9d404 	addi	r2,r2,-22704
 18153b4:	10809a17 	ldw	r2,616(r2)
 18153b8:	10c00044 	addi	r3,r2,1
 18153bc:	008061f4 	movhi	r2,391
 18153c0:	10a9d404 	addi	r2,r2,-22704
 18153c4:	10c09a15 	stw	r3,616(r2)
 18153c8:	008061f4 	movhi	r2,391
 18153cc:	10a9d404 	addi	r2,r2,-22704
 18153d0:	10c09b17 	ldw	r3,620(r2)
 18153d4:	008061f4 	movhi	r2,391
 18153d8:	10a9d404 	addi	r2,r2,-22704
 18153dc:	10809a17 	ldw	r2,616(r2)
 18153e0:	1880062e 	bgeu	r3,r2,18153fc <sys_mbox_new+0xb8>
 18153e4:	008061f4 	movhi	r2,391
 18153e8:	10a9d404 	addi	r2,r2,-22704
 18153ec:	10c09a17 	ldw	r3,616(r2)
 18153f0:	008061f4 	movhi	r2,391
 18153f4:	10a9d404 	addi	r2,r2,-22704
 18153f8:	10c09b15 	stw	r3,620(r2)

	return ERR_OK;
 18153fc:	0005883a 	mov	r2,zero
}
 1815400:	e037883a 	mov	sp,fp
 1815404:	dfc00117 	ldw	ra,4(sp)
 1815408:	df000017 	ldw	fp,0(sp)
 181540c:	dec00204 	addi	sp,sp,8
 1815410:	f800283a 	ret

01815414 <sys_mbox_free>:
 * Deallocates a mailbox. If there are messages still present in the
 * mailbox when the mailbox is deallocated, it is an indication of a
 * programming error in lwIP and the developer should be notified.
 */
void sys_mbox_free(sys_mbox_t *mbox)
{
 1815414:	defffd04 	addi	sp,sp,-12
 1815418:	dfc00215 	stw	ra,8(sp)
 181541c:	df000115 	stw	fp,4(sp)
 1815420:	df000104 	addi	fp,sp,4
 1815424:	e13fff15 	stw	r4,-4(fp)
	if (uxQueueMessagesWaiting(*mbox))
 1815428:	e0bfff17 	ldw	r2,-4(fp)
 181542c:	10800017 	ldw	r2,0(r2)
 1815430:	1009883a 	mov	r4,r2
 1815434:	180e5a80 	call	180e5a8 <uxQueueMessagesWaiting>
 1815438:	10000126 	beq	r2,zero,1815440 <sys_mbox_free+0x2c>
	{
		// Line for breakpoint.  Should never break here!
		__asm__ __volatile__ ( "nop" );
 181543c:	0001883a 	nop
	}

	vQueueDelete(*mbox);
 1815440:	e0bfff17 	ldw	r2,-4(fp)
 1815444:	10800017 	ldw	r2,0(r2)
 1815448:	1009883a 	mov	r4,r2
 181544c:	180e6940 	call	180e694 <vQueueDelete>

	SYS_STATS_DEC(mbox.used);
 1815450:	008061f4 	movhi	r2,391
 1815454:	10a9d404 	addi	r2,r2,-22704
 1815458:	10809a17 	ldw	r2,616(r2)
 181545c:	10ffffc4 	addi	r3,r2,-1
 1815460:	008061f4 	movhi	r2,391
 1815464:	10a9d404 	addi	r2,r2,-22704
 1815468:	10c09a15 	stw	r3,616(r2)
}
 181546c:	0001883a 	nop
 1815470:	e037883a 	mov	sp,fp
 1815474:	dfc00117 	ldw	ra,4(sp)
 1815478:	df000017 	ldw	fp,0(sp)
 181547c:	dec00204 	addi	sp,sp,8
 1815480:	f800283a 	ret

01815484 <sys_mbox_post>:
/**
 * Posts the "msg" to the mailbox. This function have to block until
 * the "msg" is really posted.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *data)
{
 1815484:	defffc04 	addi	sp,sp,-16
 1815488:	dfc00315 	stw	ra,12(sp)
 181548c:	df000215 	stw	fp,8(sp)
 1815490:	df000204 	addi	fp,sp,8
 1815494:	e13ffe15 	stw	r4,-8(fp)
 1815498:	e17fff15 	stw	r5,-4(fp)
	xQueueSend(*mbox, &data, (portTickType)(archPOST_BLOCK_TIME_MS / portTICK_RATE_MS));
 181549c:	e0bffe17 	ldw	r2,-8(fp)
 18154a0:	10800017 	ldw	r2,0(r2)
 18154a4:	e0ffff04 	addi	r3,fp,-4
 18154a8:	000f883a 	mov	r7,zero
 18154ac:	0189c404 	movi	r6,10000
 18154b0:	180b883a 	mov	r5,r3
 18154b4:	1009883a 	mov	r4,r2
 18154b8:	180da7c0 	call	180da7c <xQueueGenericSend>
}
 18154bc:	0001883a 	nop
 18154c0:	e037883a 	mov	sp,fp
 18154c4:	dfc00117 	ldw	ra,4(sp)
 18154c8:	df000017 	ldw	fp,0(sp)
 18154cc:	dec00204 	addi	sp,sp,8
 18154d0:	f800283a 	ret

018154d4 <sys_mbox_trypost>:
/**
 * Try to post the "msg" to the mailbox. Returns ERR_MEM if this one
 * is full, else, ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *data)
{
 18154d4:	defffc04 	addi	sp,sp,-16
 18154d8:	dfc00315 	stw	ra,12(sp)
 18154dc:	df000215 	stw	fp,8(sp)
 18154e0:	df000204 	addi	fp,sp,8
 18154e4:	e13ffe15 	stw	r4,-8(fp)
 18154e8:	e17fff15 	stw	r5,-4(fp)
	return (xQueueSend(*mbox, &data, 0) == pdTRUE) ? ERR_OK : ERR_MEM;
 18154ec:	e0bffe17 	ldw	r2,-8(fp)
 18154f0:	10800017 	ldw	r2,0(r2)
 18154f4:	e0ffff04 	addi	r3,fp,-4
 18154f8:	000f883a 	mov	r7,zero
 18154fc:	000d883a 	mov	r6,zero
 1815500:	180b883a 	mov	r5,r3
 1815504:	1009883a 	mov	r4,r2
 1815508:	180da7c0 	call	180da7c <xQueueGenericSend>
 181550c:	10800058 	cmpnei	r2,r2,1
 1815510:	1000021e 	bne	r2,zero,181551c <sys_mbox_trypost+0x48>
 1815514:	0005883a 	mov	r2,zero
 1815518:	00000106 	br	1815520 <sys_mbox_trypost+0x4c>
 181551c:	00bfffc4 	movi	r2,-1
}
 1815520:	e037883a 	mov	sp,fp
 1815524:	dfc00117 	ldw	ra,4(sp)
 1815528:	df000017 	ldw	fp,0(sp)
 181552c:	dec00204 	addi	sp,sp,8
 1815530:	f800283a 	ret

01815534 <sys_arch_mbox_fetch>:
 *
 * Note that a function with a similar name, sys_mbox_fetch(), is
 * implemented by lwIP.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 1815534:	defff704 	addi	sp,sp,-36
 1815538:	dfc00815 	stw	ra,32(sp)
 181553c:	df000715 	stw	fp,28(sp)
 1815540:	df000704 	addi	fp,sp,28
 1815544:	e13ffd15 	stw	r4,-12(fp)
 1815548:	e17ffe15 	stw	r5,-8(fp)
 181554c:	e1bfff15 	stw	r6,-4(fp)
	void *dummyptr;
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
 1815550:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 1815554:	e0bffa15 	stw	r2,-24(fp)

	if (msg == NULL)
 1815558:	e0bffe17 	ldw	r2,-8(fp)
 181555c:	1000021e 	bne	r2,zero,1815568 <sys_arch_mbox_fetch+0x34>
		msg = &dummyptr;
 1815560:	e0bffc04 	addi	r2,fp,-16
 1815564:	e0bffe15 	stw	r2,-8(fp)

	if (timeout != 0)
 1815568:	e0bfff17 	ldw	r2,-4(fp)
 181556c:	10001826 	beq	r2,zero,18155d0 <sys_arch_mbox_fetch+0x9c>
	{
		if (pdTRUE == xQueueReceive(*mbox, msg, timeout))
 1815570:	e0bffd17 	ldw	r2,-12(fp)
 1815574:	10800017 	ldw	r2,0(r2)
 1815578:	e1bfff17 	ldw	r6,-4(fp)
 181557c:	e17ffe17 	ldw	r5,-8(fp)
 1815580:	1009883a 	mov	r4,r2
 1815584:	180de300 	call	180de30 <xQueueReceive>
 1815588:	10800058 	cmpnei	r2,r2,1
 181558c:	10000c1e 	bne	r2,zero,18155c0 <sys_arch_mbox_fetch+0x8c>
		{
			nEndTime = xTaskGetTickCount();
 1815590:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 1815594:	e0bffb15 	stw	r2,-20(fp)
			nElapsed = nEndTime - nStartTime;
 1815598:	e0fffb17 	ldw	r3,-20(fp)
 181559c:	e0bffa17 	ldw	r2,-24(fp)
 18155a0:	1885c83a 	sub	r2,r3,r2
 18155a4:	e0bff915 	stw	r2,-28(fp)

			if (nElapsed == 0)
 18155a8:	e0bff917 	ldw	r2,-28(fp)
 18155ac:	1000021e 	bne	r2,zero,18155b8 <sys_arch_mbox_fetch+0x84>
				nElapsed = 1;
 18155b0:	00800044 	movi	r2,1
 18155b4:	e0bff915 	stw	r2,-28(fp)

			return nElapsed;
 18155b8:	e0bff917 	ldw	r2,-28(fp)
 18155bc:	00001806 	br	1815620 <sys_arch_mbox_fetch+0xec>
		}
		else // timed out blocking for message
		{
			*msg = NULL;
 18155c0:	e0bffe17 	ldw	r2,-8(fp)
 18155c4:	10000015 	stw	zero,0(r2)
			return SYS_ARCH_TIMEOUT;
 18155c8:	00bfffc4 	movi	r2,-1
 18155cc:	00001406 	br	1815620 <sys_arch_mbox_fetch+0xec>
		}
	}
	else // block forever for a message.
	{
		// wait on message forever
		while (pdTRUE != xQueueReceive(*mbox, msg, 10000));
 18155d0:	0001883a 	nop
 18155d4:	e0bffd17 	ldw	r2,-12(fp)
 18155d8:	10800017 	ldw	r2,0(r2)
 18155dc:	0189c404 	movi	r6,10000
 18155e0:	e17ffe17 	ldw	r5,-8(fp)
 18155e4:	1009883a 	mov	r4,r2
 18155e8:	180de300 	call	180de30 <xQueueReceive>
 18155ec:	10800058 	cmpnei	r2,r2,1
 18155f0:	103ff81e 	bne	r2,zero,18155d4 <__ram_exceptions_end+0xff805190>

		nEndTime = xTaskGetTickCount();
 18155f4:	180fc4c0 	call	180fc4c <xTaskGetTickCount>
 18155f8:	e0bffb15 	stw	r2,-20(fp)
		nElapsed = nEndTime - nStartTime;
 18155fc:	e0fffb17 	ldw	r3,-20(fp)
 1815600:	e0bffa17 	ldw	r2,-24(fp)
 1815604:	1885c83a 	sub	r2,r3,r2
 1815608:	e0bff915 	stw	r2,-28(fp)

		if (nElapsed == 0)
 181560c:	e0bff917 	ldw	r2,-28(fp)
 1815610:	1000021e 	bne	r2,zero,181561c <sys_arch_mbox_fetch+0xe8>
			nElapsed = 1;
 1815614:	00800044 	movi	r2,1
 1815618:	e0bff915 	stw	r2,-28(fp)

		return nElapsed; // return time blocked TBD test
 181561c:	e0bff917 	ldw	r2,-28(fp)
	}
}
 1815620:	e037883a 	mov	sp,fp
 1815624:	dfc00117 	ldw	ra,4(sp)
 1815628:	df000017 	ldw	fp,0(sp)
 181562c:	dec00204 	addi	sp,sp,8
 1815630:	f800283a 	ret

01815634 <sys_arch_mbox_tryfetch>:
 * #define sys_arch_mbox_tryfetch(mbox,msg) \
 * 		sys_arch_mbox_fetch(mbox,msg,1)
 * although this would introduce unnecessary delays.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 1815634:	defffb04 	addi	sp,sp,-20
 1815638:	dfc00415 	stw	ra,16(sp)
 181563c:	df000315 	stw	fp,12(sp)
 1815640:	df000304 	addi	fp,sp,12
 1815644:	e13ffe15 	stw	r4,-8(fp)
 1815648:	e17fff15 	stw	r5,-4(fp)
	void *dummyptr;

	if (msg == NULL)
 181564c:	e0bfff17 	ldw	r2,-4(fp)
 1815650:	1000021e 	bne	r2,zero,181565c <sys_arch_mbox_tryfetch+0x28>
		msg = &dummyptr;
 1815654:	e0bffd04 	addi	r2,fp,-12
 1815658:	e0bfff15 	stw	r2,-4(fp)

	return (pdTRUE == xQueueReceive(*mbox, msg, 0)) ? 0 : SYS_MBOX_EMPTY;
 181565c:	e0bffe17 	ldw	r2,-8(fp)
 1815660:	10800017 	ldw	r2,0(r2)
 1815664:	000d883a 	mov	r6,zero
 1815668:	e17fff17 	ldw	r5,-4(fp)
 181566c:	1009883a 	mov	r4,r2
 1815670:	180de300 	call	180de30 <xQueueReceive>
 1815674:	10800058 	cmpnei	r2,r2,1
 1815678:	1000021e 	bne	r2,zero,1815684 <sys_arch_mbox_tryfetch+0x50>
 181567c:	0005883a 	mov	r2,zero
 1815680:	00000106 	br	1815688 <sys_arch_mbox_tryfetch+0x54>
 1815684:	00bfffc4 	movi	r2,-1
}
 1815688:	e037883a 	mov	sp,fp
 181568c:	dfc00117 	ldw	ra,4(sp)
 1815690:	df000017 	ldw	fp,0(sp)
 1815694:	dec00204 	addi	sp,sp,8
 1815698:	f800283a 	ret

0181569c <sys_thread_new>:
 * argument to the thread() function. The stack size to used for this thread is
 * the "stacksize" parameter. The id of the new thread is returned. Both the id
 * and the priority are system dependent.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
 181569c:	defff604 	addi	sp,sp,-40
 18156a0:	dfc00915 	stw	ra,36(sp)
 18156a4:	df000815 	stw	fp,32(sp)
 18156a8:	df000804 	addi	fp,sp,32
 18156ac:	e13ffc15 	stw	r4,-16(fp)
 18156b0:	e17ffd15 	stw	r5,-12(fp)
 18156b4:	e1bffe15 	stw	r6,-8(fp)
 18156b8:	e1ffff15 	stw	r7,-4(fp)
	xTaskHandle objTask;
	int result = pdFAIL;
 18156bc:	e03ffa15 	stw	zero,-24(fp)

	result = xTaskCreate(thread, (signed portCHAR*)name, stacksize, arg, prio, &objTask);
 18156c0:	e13fff17 	ldw	r4,-4(fp)
 18156c4:	e0800217 	ldw	r2,8(fp)
 18156c8:	e0fffb04 	addi	r3,fp,-20
 18156cc:	d8c00115 	stw	r3,4(sp)
 18156d0:	d8800015 	stw	r2,0(sp)
 18156d4:	e1fffe17 	ldw	r7,-8(fp)
 18156d8:	200d883a 	mov	r6,r4
 18156dc:	e17ffc17 	ldw	r5,-16(fp)
 18156e0:	e13ffd17 	ldw	r4,-12(fp)
 18156e4:	180ed080 	call	180ed08 <xTaskCreate>
 18156e8:	e0bffa15 	stw	r2,-24(fp)

	return (result == pdPASS) ? objTask : NULL;
 18156ec:	e0bffa17 	ldw	r2,-24(fp)
 18156f0:	10800058 	cmpnei	r2,r2,1
 18156f4:	1000021e 	bne	r2,zero,1815700 <sys_thread_new+0x64>
 18156f8:	e0bffb17 	ldw	r2,-20(fp)
 18156fc:	00000106 	br	1815704 <sys_thread_new+0x68>
 1815700:	0005883a 	mov	r2,zero
}
 1815704:	e037883a 	mov	sp,fp
 1815708:	dfc00117 	ldw	ra,4(sp)
 181570c:	df000017 	ldw	fp,0(sp)
 1815710:	dec00204 	addi	sp,sp,8
 1815714:	f800283a 	ret

01815718 <dhcp_clear_assignment>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_clear_assignment(struct netif *netif)
{
 1815718:	defffd04 	addi	sp,sp,-12
 181571c:	dfc00215 	stw	ra,8(sp)
 1815720:	df000115 	stw	fp,4(sp)
 1815724:	df000104 	addi	fp,sp,4
 1815728:	e13fff15 	stw	r4,-4(fp)
  netif_set_down(netif);
 181572c:	e13fff17 	ldw	r4,-4(fp)
 1815730:	181a1500 	call	181a150 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 1815734:	d1600d04 	addi	r5,gp,-32716
 1815738:	e13fff17 	ldw	r4,-4(fp)
 181573c:	1819ebc0 	call	1819ebc <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 1815740:	d1600d04 	addi	r5,gp,-32716
 1815744:	e13fff17 	ldw	r4,-4(fp)
 1815748:	1819fe40 	call	1819fe4 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
 181574c:	d1600d04 	addi	r5,gp,-32716
 1815750:	e13fff17 	ldw	r4,-4(fp)
 1815754:	181a02c0 	call	181a02c <netif_set_netmask>
}
 1815758:	0001883a 	nop
 181575c:	e037883a 	mov	sp,fp
 1815760:	dfc00117 	ldw	ra,4(sp)
 1815764:	df000017 	ldw	fp,0(sp)
 1815768:	dec00204 	addi	sp,sp,8
 181576c:	f800283a 	ret

01815770 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
 1815770:	defffc04 	addi	sp,sp,-16
 1815774:	dfc00315 	stw	ra,12(sp)
 1815778:	df000215 	stw	fp,8(sp)
 181577c:	df000204 	addi	fp,sp,8
 1815780:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815784:	e0bfff17 	ldw	r2,-4(fp)
 1815788:	10800a17 	ldw	r2,40(r2)
 181578c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  dhcp_clear_assignment(netif);
 1815790:	e13fff17 	ldw	r4,-4(fp)
 1815794:	18157180 	call	1815718 <dhcp_clear_assignment>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 1815798:	01400304 	movi	r5,12
 181579c:	e13ffe17 	ldw	r4,-8(fp)
 18157a0:	18173840 	call	1817384 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 18157a4:	e13fff17 	ldw	r4,-4(fp)
 18157a8:	18168980 	call	1816898 <dhcp_discover>
}
 18157ac:	0001883a 	nop
 18157b0:	e037883a 	mov	sp,fp
 18157b4:	dfc00117 	ldw	ra,4(sp)
 18157b8:	df000017 	ldw	fp,0(sp)
 18157bc:	dec00204 	addi	sp,sp,8
 18157c0:	f800283a 	ret

018157c4 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
 18157c4:	defffb04 	addi	sp,sp,-20
 18157c8:	dfc00415 	stw	ra,16(sp)
 18157cc:	df000315 	stw	fp,12(sp)
 18157d0:	df000304 	addi	fp,sp,12
 18157d4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 18157d8:	e0bfff17 	ldw	r2,-4(fp)
 18157dc:	10800a17 	ldw	r2,40(r2)
 18157e0:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
 18157e4:	01400204 	movi	r5,8
 18157e8:	e13ffd17 	ldw	r4,-12(fp)
 18157ec:	18173840 	call	1817384 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 18157f0:	e0bffd17 	ldw	r2,-12(fp)
 18157f4:	10800904 	addi	r2,r2,36
 18157f8:	000d883a 	mov	r6,zero
 18157fc:	100b883a 	mov	r5,r2
 1815800:	e13fff17 	ldw	r4,-4(fp)
 1815804:	1823e840 	call	1823e84 <etharp_query>
 1815808:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 181580c:	e0bffd17 	ldw	r2,-12(fp)
 1815810:	10800343 	ldbu	r2,13(r2)
 1815814:	10800044 	addi	r2,r2,1
 1815818:	1007883a 	mov	r3,r2
 181581c:	e0bffd17 	ldw	r2,-12(fp)
 1815820:	10c00345 	stb	r3,13(r2)
  msecs = 500;
 1815824:	00807d04 	movi	r2,500
 1815828:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 181582c:	e0bffe8b 	ldhu	r2,-6(fp)
 1815830:	10807cc4 	addi	r2,r2,499
 1815834:	01407d04 	movi	r5,500
 1815838:	1009883a 	mov	r4,r2
 181583c:	180ac180 	call	180ac18 <__divsi3>
 1815840:	1007883a 	mov	r3,r2
 1815844:	e0bffd17 	ldw	r2,-12(fp)
 1815848:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
 181584c:	0001883a 	nop
 1815850:	e037883a 	mov	sp,fp
 1815854:	dfc00117 	ldw	ra,4(sp)
 1815858:	df000017 	ldw	fp,0(sp)
 181585c:	dec00204 	addi	sp,sp,8
 1815860:	f800283a 	ret

01815864 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
 1815864:	defffc04 	addi	sp,sp,-16
 1815868:	dfc00315 	stw	ra,12(sp)
 181586c:	df000215 	stw	fp,8(sp)
 1815870:	df000204 	addi	fp,sp,8
 1815874:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815878:	e0bfff17 	ldw	r2,-4(fp)
 181587c:	10800a17 	ldw	r2,40(r2)
 1815880:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 1815884:	008061b4 	movhi	r2,390
 1815888:	1089c204 	addi	r2,r2,9992
 181588c:	10800083 	ldbu	r2,2(r2)
 1815890:	10803fcc 	andi	r2,r2,255
 1815894:	10002826 	beq	r2,zero,1815938 <dhcp_handle_offer+0xd4>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 1815898:	008061b4 	movhi	r2,390
 181589c:	1089c504 	addi	r2,r2,10004
 18158a0:	10800217 	ldw	r2,8(r2)
 18158a4:	1006d63a 	srli	r3,r2,24
 18158a8:	008061b4 	movhi	r2,390
 18158ac:	1089c504 	addi	r2,r2,10004
 18158b0:	10800217 	ldw	r2,8(r2)
 18158b4:	1004d23a 	srli	r2,r2,8
 18158b8:	10bfc00c 	andi	r2,r2,65280
 18158bc:	1886b03a 	or	r3,r3,r2
 18158c0:	008061b4 	movhi	r2,390
 18158c4:	1089c504 	addi	r2,r2,10004
 18158c8:	10800217 	ldw	r2,8(r2)
 18158cc:	10bfc00c 	andi	r2,r2,65280
 18158d0:	1004923a 	slli	r2,r2,8
 18158d4:	1886b03a 	or	r3,r3,r2
 18158d8:	008061b4 	movhi	r2,390
 18158dc:	1089c504 	addi	r2,r2,10004
 18158e0:	10800217 	ldw	r2,8(r2)
 18158e4:	1004963a 	slli	r2,r2,24
 18158e8:	1886b03a 	or	r3,r3,r2
 18158ec:	e0bffe17 	ldw	r2,-8(fp)
 18158f0:	10c00815 	stw	r3,32(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 18158f4:	e0bffe17 	ldw	r2,-8(fp)
 18158f8:	10800217 	ldw	r2,8(r2)
 18158fc:	10c00403 	ldbu	r3,16(r2)
 1815900:	11000443 	ldbu	r4,17(r2)
 1815904:	2008923a 	slli	r4,r4,8
 1815908:	20c6b03a 	or	r3,r4,r3
 181590c:	11000483 	ldbu	r4,18(r2)
 1815910:	2008943a 	slli	r4,r4,16
 1815914:	20c6b03a 	or	r3,r4,r3
 1815918:	108004c3 	ldbu	r2,19(r2)
 181591c:	1004963a 	slli	r2,r2,24
 1815920:	10c4b03a 	or	r2,r2,r3
 1815924:	1007883a 	mov	r3,r2
 1815928:	e0bffe17 	ldw	r2,-8(fp)
 181592c:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
 1815930:	e13fff17 	ldw	r4,-4(fp)
 1815934:	18159500 	call	1815950 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
 1815938:	0001883a 	nop
 181593c:	e037883a 	mov	sp,fp
 1815940:	dfc00117 	ldw	ra,4(sp)
 1815944:	df000017 	ldw	fp,0(sp)
 1815948:	dec00204 	addi	sp,sp,8
 181594c:	f800283a 	ret

01815950 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 1815950:	defffa04 	addi	sp,sp,-24
 1815954:	dfc00515 	stw	ra,20(sp)
 1815958:	df000415 	stw	fp,16(sp)
 181595c:	df000404 	addi	fp,sp,16
 1815960:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815964:	e0bfff17 	ldw	r2,-4(fp)
 1815968:	10800a17 	ldw	r2,40(r2)
 181596c:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
 1815970:	01400044 	movi	r5,1
 1815974:	e13ffd17 	ldw	r4,-12(fp)
 1815978:	18173840 	call	1817384 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 181597c:	018000c4 	movi	r6,3
 1815980:	e17ffd17 	ldw	r5,-12(fp)
 1815984:	e13fff17 	ldw	r4,-4(fp)
 1815988:	181835c0 	call	181835c <dhcp_create_msg>
 181598c:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 1815990:	e0bffe07 	ldb	r2,-8(fp)
 1815994:	1000651e 	bne	r2,zero,1815b2c <dhcp_select+0x1dc>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 1815998:	01800084 	movi	r6,2
 181599c:	01400e44 	movi	r5,57
 18159a0:	e13ffd17 	ldw	r4,-12(fp)
 18159a4:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 18159a8:	e0bfff17 	ldw	r2,-4(fp)
 18159ac:	10800c0b 	ldhu	r2,48(r2)
 18159b0:	10bfffcc 	andi	r2,r2,65535
 18159b4:	100b883a 	mov	r5,r2
 18159b8:	e13ffd17 	ldw	r4,-12(fp)
 18159bc:	18174dc0 	call	18174dc <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 18159c0:	01800104 	movi	r6,4
 18159c4:	01400c84 	movi	r5,50
 18159c8:	e13ffd17 	ldw	r4,-12(fp)
 18159cc:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 18159d0:	e0bffd17 	ldw	r2,-12(fp)
 18159d4:	10800917 	ldw	r2,36(r2)
 18159d8:	1006d63a 	srli	r3,r2,24
 18159dc:	e0bffd17 	ldw	r2,-12(fp)
 18159e0:	10800917 	ldw	r2,36(r2)
 18159e4:	1004d23a 	srli	r2,r2,8
 18159e8:	10bfc00c 	andi	r2,r2,65280
 18159ec:	1886b03a 	or	r3,r3,r2
 18159f0:	e0bffd17 	ldw	r2,-12(fp)
 18159f4:	10800917 	ldw	r2,36(r2)
 18159f8:	10bfc00c 	andi	r2,r2,65280
 18159fc:	1004923a 	slli	r2,r2,8
 1815a00:	1886b03a 	or	r3,r3,r2
 1815a04:	e0bffd17 	ldw	r2,-12(fp)
 1815a08:	10800917 	ldw	r2,36(r2)
 1815a0c:	1004963a 	slli	r2,r2,24
 1815a10:	1884b03a 	or	r2,r3,r2
 1815a14:	100b883a 	mov	r5,r2
 1815a18:	e13ffd17 	ldw	r4,-12(fp)
 1815a1c:	18175740 	call	1817574 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
 1815a20:	01800104 	movi	r6,4
 1815a24:	01400d84 	movi	r5,54
 1815a28:	e13ffd17 	ldw	r4,-12(fp)
 1815a2c:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
 1815a30:	e0bffd17 	ldw	r2,-12(fp)
 1815a34:	10800817 	ldw	r2,32(r2)
 1815a38:	1006d63a 	srli	r3,r2,24
 1815a3c:	e0bffd17 	ldw	r2,-12(fp)
 1815a40:	10800817 	ldw	r2,32(r2)
 1815a44:	1004d23a 	srli	r2,r2,8
 1815a48:	10bfc00c 	andi	r2,r2,65280
 1815a4c:	1886b03a 	or	r3,r3,r2
 1815a50:	e0bffd17 	ldw	r2,-12(fp)
 1815a54:	10800817 	ldw	r2,32(r2)
 1815a58:	10bfc00c 	andi	r2,r2,65280
 1815a5c:	1004923a 	slli	r2,r2,8
 1815a60:	1886b03a 	or	r3,r3,r2
 1815a64:	e0bffd17 	ldw	r2,-12(fp)
 1815a68:	10800817 	ldw	r2,32(r2)
 1815a6c:	1004963a 	slli	r2,r2,24
 1815a70:	1884b03a 	or	r2,r3,r2
 1815a74:	100b883a 	mov	r5,r2
 1815a78:	e13ffd17 	ldw	r4,-12(fp)
 1815a7c:	18175740 	call	1817574 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
 1815a80:	01800104 	movi	r6,4
 1815a84:	01400dc4 	movi	r5,55
 1815a88:	e13ffd17 	ldw	r4,-12(fp)
 1815a8c:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
 1815a90:	01400044 	movi	r5,1
 1815a94:	e13ffd17 	ldw	r4,-12(fp)
 1815a98:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
 1815a9c:	014000c4 	movi	r5,3
 1815aa0:	e13ffd17 	ldw	r4,-12(fp)
 1815aa4:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
 1815aa8:	01400704 	movi	r5,28
 1815aac:	e13ffd17 	ldw	r4,-12(fp)
 1815ab0:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
 1815ab4:	01400184 	movi	r5,6
 1815ab8:	e13ffd17 	ldw	r4,-12(fp)
 1815abc:	181747c0 	call	181747c <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 1815ac0:	e17fff17 	ldw	r5,-4(fp)
 1815ac4:	e13ffd17 	ldw	r4,-12(fp)
 1815ac8:	18176800 	call	1817680 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
 1815acc:	e13ffd17 	ldw	r4,-12(fp)
 1815ad0:	18189640 	call	1818964 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 1815ad4:	e0bffd17 	ldw	r2,-12(fp)
 1815ad8:	10c00417 	ldw	r3,16(r2)
 1815adc:	e0bffd17 	ldw	r2,-12(fp)
 1815ae0:	1080060b 	ldhu	r2,24(r2)
 1815ae4:	10803c04 	addi	r2,r2,240
 1815ae8:	10bfffcc 	andi	r2,r2,65535
 1815aec:	100b883a 	mov	r5,r2
 1815af0:	1809883a 	mov	r4,r3
 1815af4:	181a9940 	call	181a994 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 1815af8:	e0bffd17 	ldw	r2,-12(fp)
 1815afc:	10c00117 	ldw	r3,4(r2)
 1815b00:	e0bffd17 	ldw	r2,-12(fp)
 1815b04:	11000417 	ldw	r4,16(r2)
 1815b08:	e0bfff17 	ldw	r2,-4(fp)
 1815b0c:	d8800015 	stw	r2,0(sp)
 1815b10:	01c010c4 	movi	r7,67
 1815b14:	d1a00e04 	addi	r6,gp,-32712
 1815b18:	200b883a 	mov	r5,r4
 1815b1c:	1809883a 	mov	r4,r3
 1815b20:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 1815b24:	e13ffd17 	ldw	r4,-12(fp)
 1815b28:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 1815b2c:	e0bffd17 	ldw	r2,-12(fp)
 1815b30:	10800343 	ldbu	r2,13(r2)
 1815b34:	10800044 	addi	r2,r2,1
 1815b38:	1007883a 	mov	r3,r2
 1815b3c:	e0bffd17 	ldw	r2,-12(fp)
 1815b40:	10c00345 	stb	r3,13(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 1815b44:	e0bffd17 	ldw	r2,-12(fp)
 1815b48:	10800343 	ldbu	r2,13(r2)
 1815b4c:	10803fcc 	andi	r2,r2,255
 1815b50:	108001a8 	cmpgeui	r2,r2,6
 1815b54:	1000061e 	bne	r2,zero,1815b70 <dhcp_select+0x220>
 1815b58:	e0bffd17 	ldw	r2,-12(fp)
 1815b5c:	10800343 	ldbu	r2,13(r2)
 1815b60:	10803fcc 	andi	r2,r2,255
 1815b64:	00c0fa04 	movi	r3,1000
 1815b68:	1884983a 	sll	r2,r3,r2
 1815b6c:	00000106 	br	1815b74 <dhcp_select+0x224>
 1815b70:	00ba9804 	movi	r2,-5536
 1815b74:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1815b78:	e0bffe8b 	ldhu	r2,-6(fp)
 1815b7c:	10807cc4 	addi	r2,r2,499
 1815b80:	01407d04 	movi	r5,500
 1815b84:	1009883a 	mov	r4,r2
 1815b88:	180ac180 	call	180ac18 <__divsi3>
 1815b8c:	1007883a 	mov	r3,r2
 1815b90:	e0bffd17 	ldw	r2,-12(fp)
 1815b94:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1815b98:	e0bffe03 	ldbu	r2,-8(fp)
}
 1815b9c:	e037883a 	mov	sp,fp
 1815ba0:	dfc00117 	ldw	ra,4(sp)
 1815ba4:	df000017 	ldw	fp,0(sp)
 1815ba8:	dec00204 	addi	sp,sp,8
 1815bac:	f800283a 	ret

01815bb0 <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
 1815bb0:	defffd04 	addi	sp,sp,-12
 1815bb4:	dfc00215 	stw	ra,8(sp)
 1815bb8:	df000115 	stw	fp,4(sp)
 1815bbc:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
 1815bc0:	d0a7f317 	ldw	r2,-24628(gp)
 1815bc4:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 1815bc8:	00001b06 	br	1815c38 <dhcp_coarse_tmr+0x88>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 1815bcc:	e0bfff17 	ldw	r2,-4(fp)
 1815bd0:	10800a17 	ldw	r2,40(r2)
 1815bd4:	10001526 	beq	r2,zero,1815c2c <dhcp_coarse_tmr+0x7c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
 1815bd8:	e0bfff17 	ldw	r2,-4(fp)
 1815bdc:	10800a17 	ldw	r2,40(r2)
 1815be0:	10c0078b 	ldhu	r3,30(r2)
 1815be4:	193fffc4 	addi	r4,r3,-1
 1815be8:	1100078d 	sth	r4,30(r2)
 1815bec:	18bfffcc 	andi	r2,r3,65535
 1815bf0:	10800058 	cmpnei	r2,r2,1
 1815bf4:	1000031e 	bne	r2,zero,1815c04 <dhcp_coarse_tmr+0x54>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
 1815bf8:	e13fff17 	ldw	r4,-4(fp)
 1815bfc:	1815f240 	call	1815f24 <dhcp_t2_timeout>
 1815c00:	00000a06 	br	1815c2c <dhcp_coarse_tmr+0x7c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
 1815c04:	e0bfff17 	ldw	r2,-4(fp)
 1815c08:	10800a17 	ldw	r2,40(r2)
 1815c0c:	10c0070b 	ldhu	r3,28(r2)
 1815c10:	193fffc4 	addi	r4,r3,-1
 1815c14:	1100070d 	sth	r4,28(r2)
 1815c18:	18bfffcc 	andi	r2,r3,65535
 1815c1c:	10800058 	cmpnei	r2,r2,1
 1815c20:	1000021e 	bne	r2,zero,1815c2c <dhcp_coarse_tmr+0x7c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
 1815c24:	e13fff17 	ldw	r4,-4(fp)
 1815c28:	1815ea80 	call	1815ea8 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
 1815c2c:	e0bfff17 	ldw	r2,-4(fp)
 1815c30:	10800017 	ldw	r2,0(r2)
 1815c34:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 1815c38:	e0bfff17 	ldw	r2,-4(fp)
 1815c3c:	103fe31e 	bne	r2,zero,1815bcc <__ram_exceptions_end+0xff805788>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
 1815c40:	0001883a 	nop
 1815c44:	e037883a 	mov	sp,fp
 1815c48:	dfc00117 	ldw	ra,4(sp)
 1815c4c:	df000017 	ldw	fp,0(sp)
 1815c50:	dec00204 	addi	sp,sp,8
 1815c54:	f800283a 	ret

01815c58 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
 1815c58:	defffd04 	addi	sp,sp,-12
 1815c5c:	dfc00215 	stw	ra,8(sp)
 1815c60:	df000115 	stw	fp,4(sp)
 1815c64:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
 1815c68:	d0a7f317 	ldw	r2,-24628(gp)
 1815c6c:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
 1815c70:	00001f06 	br	1815cf0 <dhcp_fine_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 1815c74:	e0bfff17 	ldw	r2,-4(fp)
 1815c78:	10800a17 	ldw	r2,40(r2)
 1815c7c:	10001926 	beq	r2,zero,1815ce4 <dhcp_fine_tmr+0x8c>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
 1815c80:	e0bfff17 	ldw	r2,-4(fp)
 1815c84:	10800a17 	ldw	r2,40(r2)
 1815c88:	1080068b 	ldhu	r2,26(r2)
 1815c8c:	10bfffcc 	andi	r2,r2,65535
 1815c90:	108000b0 	cmpltui	r2,r2,2
 1815c94:	1000061e 	bne	r2,zero,1815cb0 <dhcp_fine_tmr+0x58>
        netif->dhcp->request_timeout--;
 1815c98:	e0bfff17 	ldw	r2,-4(fp)
 1815c9c:	10800a17 	ldw	r2,40(r2)
 1815ca0:	10c0068b 	ldhu	r3,26(r2)
 1815ca4:	18ffffc4 	addi	r3,r3,-1
 1815ca8:	10c0068d 	sth	r3,26(r2)
 1815cac:	00000d06 	br	1815ce4 <dhcp_fine_tmr+0x8c>
      }
      else if (netif->dhcp->request_timeout == 1) {
 1815cb0:	e0bfff17 	ldw	r2,-4(fp)
 1815cb4:	10800a17 	ldw	r2,40(r2)
 1815cb8:	1080068b 	ldhu	r2,26(r2)
 1815cbc:	10bfffcc 	andi	r2,r2,65535
 1815cc0:	10800058 	cmpnei	r2,r2,1
 1815cc4:	1000071e 	bne	r2,zero,1815ce4 <dhcp_fine_tmr+0x8c>
        netif->dhcp->request_timeout--;
 1815cc8:	e0bfff17 	ldw	r2,-4(fp)
 1815ccc:	10800a17 	ldw	r2,40(r2)
 1815cd0:	10c0068b 	ldhu	r3,26(r2)
 1815cd4:	18ffffc4 	addi	r3,r3,-1
 1815cd8:	10c0068d 	sth	r3,26(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
 1815cdc:	e13fff17 	ldw	r4,-4(fp)
 1815ce0:	1815d100 	call	1815d10 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 1815ce4:	e0bfff17 	ldw	r2,-4(fp)
 1815ce8:	10800017 	ldw	r2,0(r2)
 1815cec:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
 1815cf0:	e0bfff17 	ldw	r2,-4(fp)
 1815cf4:	103fdf1e 	bne	r2,zero,1815c74 <__ram_exceptions_end+0xff805830>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
 1815cf8:	0001883a 	nop
 1815cfc:	e037883a 	mov	sp,fp
 1815d00:	dfc00117 	ldw	ra,4(sp)
 1815d04:	df000017 	ldw	fp,0(sp)
 1815d08:	dec00204 	addi	sp,sp,8
 1815d0c:	f800283a 	ret

01815d10 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
 1815d10:	defffc04 	addi	sp,sp,-16
 1815d14:	dfc00315 	stw	ra,12(sp)
 1815d18:	df000215 	stw	fp,8(sp)
 1815d1c:	df000204 	addi	fp,sp,8
 1815d20:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815d24:	e0bfff17 	ldw	r2,-4(fp)
 1815d28:	10800a17 	ldw	r2,40(r2)
 1815d2c:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
 1815d30:	e0bffe17 	ldw	r2,-8(fp)
 1815d34:	10800303 	ldbu	r2,12(r2)
 1815d38:	10803fcc 	andi	r2,r2,255
 1815d3c:	10800320 	cmpeqi	r2,r2,12
 1815d40:	1000051e 	bne	r2,zero,1815d58 <dhcp_timeout+0x48>
 1815d44:	e0bffe17 	ldw	r2,-8(fp)
 1815d48:	10800303 	ldbu	r2,12(r2)
 1815d4c:	10803fcc 	andi	r2,r2,255
 1815d50:	10800198 	cmpnei	r2,r2,6
 1815d54:	1000031e 	bne	r2,zero,1815d64 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
 1815d58:	e13fff17 	ldw	r4,-4(fp)
 1815d5c:	18168980 	call	1816898 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815d60:	00004b06 	br	1815e90 <dhcp_timeout+0x180>
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
 1815d64:	e0bffe17 	ldw	r2,-8(fp)
 1815d68:	10800303 	ldbu	r2,12(r2)
 1815d6c:	10803fcc 	andi	r2,r2,255
 1815d70:	10800058 	cmpnei	r2,r2,1
 1815d74:	10000d1e 	bne	r2,zero,1815dac <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
 1815d78:	e0bffe17 	ldw	r2,-8(fp)
 1815d7c:	10800343 	ldbu	r2,13(r2)
 1815d80:	10803fcc 	andi	r2,r2,255
 1815d84:	108001a8 	cmpgeui	r2,r2,6
 1815d88:	1000031e 	bne	r2,zero,1815d98 <dhcp_timeout+0x88>
      dhcp_select(netif);
 1815d8c:	e13fff17 	ldw	r4,-4(fp)
 1815d90:	18159500 	call	1815950 <dhcp_select>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815d94:	00003e06 	br	1815e90 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
 1815d98:	e13fff17 	ldw	r4,-4(fp)
 1815d9c:	18171280 	call	1817128 <dhcp_release>
      dhcp_discover(netif);
 1815da0:	e13fff17 	ldw	r4,-4(fp)
 1815da4:	18168980 	call	1816898 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815da8:	00003906 	br	1815e90 <dhcp_timeout+0x180>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
 1815dac:	e0bffe17 	ldw	r2,-8(fp)
 1815db0:	10800303 	ldbu	r2,12(r2)
 1815db4:	10803fcc 	andi	r2,r2,255
 1815db8:	10800218 	cmpnei	r2,r2,8
 1815dbc:	10000b1e 	bne	r2,zero,1815dec <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
 1815dc0:	e0bffe17 	ldw	r2,-8(fp)
 1815dc4:	10800343 	ldbu	r2,13(r2)
 1815dc8:	10803fcc 	andi	r2,r2,255
 1815dcc:	108000a8 	cmpgeui	r2,r2,2
 1815dd0:	1000031e 	bne	r2,zero,1815de0 <dhcp_timeout+0xd0>
      dhcp_check(netif);
 1815dd4:	e13fff17 	ldw	r4,-4(fp)
 1815dd8:	18157c40 	call	18157c4 <dhcp_check>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815ddc:	00002c06 	br	1815e90 <dhcp_timeout+0x180>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
 1815de0:	e13fff17 	ldw	r4,-4(fp)
 1815de4:	1816a380 	call	1816a38 <dhcp_bind>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815de8:	00002906 	br	1815e90 <dhcp_timeout+0x180>
      dhcp_bind(netif);
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
 1815dec:	e0bffe17 	ldw	r2,-8(fp)
 1815df0:	10800303 	ldbu	r2,12(r2)
 1815df4:	10803fcc 	andi	r2,r2,255
 1815df8:	10800158 	cmpnei	r2,r2,5
 1815dfc:	1000031e 	bne	r2,zero,1815e0c <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
 1815e00:	e13fff17 	ldw	r4,-4(fp)
 1815e04:	1816cc40 	call	1816cc4 <dhcp_renew>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815e08:	00002106 	br	1815e90 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
 1815e0c:	e0bffe17 	ldw	r2,-8(fp)
 1815e10:	10800303 	ldbu	r2,12(r2)
 1815e14:	10803fcc 	andi	r2,r2,255
 1815e18:	10800118 	cmpnei	r2,r2,4
 1815e1c:	10000d1e 	bne	r2,zero,1815e54 <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
 1815e20:	e0bffe17 	ldw	r2,-8(fp)
 1815e24:	10800343 	ldbu	r2,13(r2)
 1815e28:	10803fcc 	andi	r2,r2,255
 1815e2c:	10800268 	cmpgeui	r2,r2,9
 1815e30:	1000031e 	bne	r2,zero,1815e40 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
 1815e34:	e13fff17 	ldw	r4,-4(fp)
 1815e38:	1816e280 	call	1816e28 <dhcp_rebind>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815e3c:	00001406 	br	1815e90 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
 1815e40:	e13fff17 	ldw	r4,-4(fp)
 1815e44:	18171280 	call	1817128 <dhcp_release>
      dhcp_discover(netif);
 1815e48:	e13fff17 	ldw	r4,-4(fp)
 1815e4c:	18168980 	call	1816898 <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815e50:	00000f06 	br	1815e90 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
 1815e54:	e0bffe17 	ldw	r2,-8(fp)
 1815e58:	10800303 	ldbu	r2,12(r2)
 1815e5c:	10803fcc 	andi	r2,r2,255
 1815e60:	108000d8 	cmpnei	r2,r2,3
 1815e64:	10000a1e 	bne	r2,zero,1815e90 <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
 1815e68:	e0bffe17 	ldw	r2,-8(fp)
 1815e6c:	10800343 	ldbu	r2,13(r2)
 1815e70:	10803fcc 	andi	r2,r2,255
 1815e74:	108000a8 	cmpgeui	r2,r2,2
 1815e78:	1000031e 	bne	r2,zero,1815e88 <dhcp_timeout+0x178>
      dhcp_reboot(netif);
 1815e7c:	e13fff17 	ldw	r4,-4(fp)
 1815e80:	1816f840 	call	1816f84 <dhcp_reboot>
    } else {
      dhcp_discover(netif);
    }
  }
}
 1815e84:	00000206 	br	1815e90 <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
 1815e88:	e13fff17 	ldw	r4,-4(fp)
 1815e8c:	18168980 	call	1816898 <dhcp_discover>
    }
  }
}
 1815e90:	0001883a 	nop
 1815e94:	e037883a 	mov	sp,fp
 1815e98:	dfc00117 	ldw	ra,4(sp)
 1815e9c:	df000017 	ldw	fp,0(sp)
 1815ea0:	dec00204 	addi	sp,sp,8
 1815ea4:	f800283a 	ret

01815ea8 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
 1815ea8:	defffc04 	addi	sp,sp,-16
 1815eac:	dfc00315 	stw	ra,12(sp)
 1815eb0:	df000215 	stw	fp,8(sp)
 1815eb4:	df000204 	addi	fp,sp,8
 1815eb8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815ebc:	e0bfff17 	ldw	r2,-4(fp)
 1815ec0:	10800a17 	ldw	r2,40(r2)
 1815ec4:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 1815ec8:	e0bffe17 	ldw	r2,-8(fp)
 1815ecc:	10800303 	ldbu	r2,12(r2)
 1815ed0:	10803fcc 	andi	r2,r2,255
 1815ed4:	10800060 	cmpeqi	r2,r2,1
 1815ed8:	10000a1e 	bne	r2,zero,1815f04 <dhcp_t1_timeout+0x5c>
 1815edc:	e0bffe17 	ldw	r2,-8(fp)
 1815ee0:	10800303 	ldbu	r2,12(r2)
 1815ee4:	10803fcc 	andi	r2,r2,255
 1815ee8:	108002a0 	cmpeqi	r2,r2,10
 1815eec:	1000051e 	bne	r2,zero,1815f04 <dhcp_t1_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
 1815ef0:	e0bffe17 	ldw	r2,-8(fp)
 1815ef4:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 1815ef8:	10803fcc 	andi	r2,r2,255
 1815efc:	10800158 	cmpnei	r2,r2,5
 1815f00:	1000021e 	bne	r2,zero,1815f0c <dhcp_t1_timeout+0x64>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
 1815f04:	e13fff17 	ldw	r4,-4(fp)
 1815f08:	1816cc40 	call	1816cc4 <dhcp_renew>
  }
}
 1815f0c:	0001883a 	nop
 1815f10:	e037883a 	mov	sp,fp
 1815f14:	dfc00117 	ldw	ra,4(sp)
 1815f18:	df000017 	ldw	fp,0(sp)
 1815f1c:	dec00204 	addi	sp,sp,8
 1815f20:	f800283a 	ret

01815f24 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
 1815f24:	defffc04 	addi	sp,sp,-16
 1815f28:	dfc00315 	stw	ra,12(sp)
 1815f2c:	df000215 	stw	fp,8(sp)
 1815f30:	df000204 	addi	fp,sp,8
 1815f34:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815f38:	e0bfff17 	ldw	r2,-4(fp)
 1815f3c:	10800a17 	ldw	r2,40(r2)
 1815f40:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 1815f44:	e0bffe17 	ldw	r2,-8(fp)
 1815f48:	10800303 	ldbu	r2,12(r2)
 1815f4c:	10803fcc 	andi	r2,r2,255
 1815f50:	10800060 	cmpeqi	r2,r2,1
 1815f54:	10000a1e 	bne	r2,zero,1815f80 <dhcp_t2_timeout+0x5c>
 1815f58:	e0bffe17 	ldw	r2,-8(fp)
 1815f5c:	10800303 	ldbu	r2,12(r2)
 1815f60:	10803fcc 	andi	r2,r2,255
 1815f64:	108002a0 	cmpeqi	r2,r2,10
 1815f68:	1000051e 	bne	r2,zero,1815f80 <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
 1815f6c:	e0bffe17 	ldw	r2,-8(fp)
 1815f70:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 1815f74:	10803fcc 	andi	r2,r2,255
 1815f78:	10800158 	cmpnei	r2,r2,5
 1815f7c:	1000021e 	bne	r2,zero,1815f88 <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
 1815f80:	e13fff17 	ldw	r4,-4(fp)
 1815f84:	1816e280 	call	1816e28 <dhcp_rebind>
  }
}
 1815f88:	0001883a 	nop
 1815f8c:	e037883a 	mov	sp,fp
 1815f90:	dfc00117 	ldw	ra,4(sp)
 1815f94:	df000017 	ldw	fp,0(sp)
 1815f98:	dec00204 	addi	sp,sp,8
 1815f9c:	f800283a 	ret

01815fa0 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
 1815fa0:	defffd04 	addi	sp,sp,-12
 1815fa4:	df000215 	stw	fp,8(sp)
 1815fa8:	df000204 	addi	fp,sp,8
 1815fac:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1815fb0:	e0bfff17 	ldw	r2,-4(fp)
 1815fb4:	10800a17 	ldw	r2,40(r2)
 1815fb8:	e0bffe15 	stw	r2,-8(fp)
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 1815fbc:	e0bffe17 	ldw	r2,-8(fp)
 1815fc0:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 1815fc4:	e0bffe17 	ldw	r2,-8(fp)
 1815fc8:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 1815fcc:	008061b4 	movhi	r2,390
 1815fd0:	1089c204 	addi	r2,r2,9992
 1815fd4:	108000c3 	ldbu	r2,3(r2)
 1815fd8:	10803fcc 	andi	r2,r2,255
 1815fdc:	10000526 	beq	r2,zero,1815ff4 <dhcp_handle_ack+0x54>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
 1815fe0:	008061b4 	movhi	r2,390
 1815fe4:	1089c504 	addi	r2,r2,10004
 1815fe8:	10c00317 	ldw	r3,12(r2)
 1815fec:	e0bffe17 	ldw	r2,-8(fp)
 1815ff0:	10c00c15 	stw	r3,48(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
 1815ff4:	008061b4 	movhi	r2,390
 1815ff8:	1089c204 	addi	r2,r2,9992
 1815ffc:	10800103 	ldbu	r2,4(r2)
 1816000:	10803fcc 	andi	r2,r2,255
 1816004:	10000626 	beq	r2,zero,1816020 <dhcp_handle_ack+0x80>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
 1816008:	008061b4 	movhi	r2,390
 181600c:	1089c504 	addi	r2,r2,10004
 1816010:	10c00417 	ldw	r3,16(r2)
 1816014:	e0bffe17 	ldw	r2,-8(fp)
 1816018:	10c00d15 	stw	r3,52(r2)
 181601c:	00000506 	br	1816034 <dhcp_handle_ack+0x94>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
 1816020:	e0bffe17 	ldw	r2,-8(fp)
 1816024:	10800c17 	ldw	r2,48(r2)
 1816028:	1006d07a 	srli	r3,r2,1
 181602c:	e0bffe17 	ldw	r2,-8(fp)
 1816030:	10c00d15 	stw	r3,52(r2)
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
 1816034:	008061b4 	movhi	r2,390
 1816038:	1089c204 	addi	r2,r2,9992
 181603c:	10800143 	ldbu	r2,5(r2)
 1816040:	10803fcc 	andi	r2,r2,255
 1816044:	10000626 	beq	r2,zero,1816060 <dhcp_handle_ack+0xc0>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
 1816048:	008061b4 	movhi	r2,390
 181604c:	1089c504 	addi	r2,r2,10004
 1816050:	10c00517 	ldw	r3,20(r2)
 1816054:	e0bffe17 	ldw	r2,-8(fp)
 1816058:	10c00e15 	stw	r3,56(r2)
 181605c:	00000406 	br	1816070 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
 1816060:	e0bffe17 	ldw	r2,-8(fp)
 1816064:	10c00c17 	ldw	r3,48(r2)
 1816068:	e0bffe17 	ldw	r2,-8(fp)
 181606c:	10c00e15 	stw	r3,56(r2)
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 1816070:	e0bffe17 	ldw	r2,-8(fp)
 1816074:	10800217 	ldw	r2,8(r2)
 1816078:	10c00403 	ldbu	r3,16(r2)
 181607c:	11000443 	ldbu	r4,17(r2)
 1816080:	2008923a 	slli	r4,r4,8
 1816084:	20c6b03a 	or	r3,r4,r3
 1816088:	11000483 	ldbu	r4,18(r2)
 181608c:	2008943a 	slli	r4,r4,16
 1816090:	20c6b03a 	or	r3,r4,r3
 1816094:	108004c3 	ldbu	r2,19(r2)
 1816098:	1004963a 	slli	r2,r2,24
 181609c:	10c4b03a 	or	r2,r2,r3
 18160a0:	1007883a 	mov	r3,r2
 18160a4:	e0bffe17 	ldw	r2,-8(fp)
 18160a8:	10c00915 	stw	r3,36(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 18160ac:	008061b4 	movhi	r2,390
 18160b0:	1089c204 	addi	r2,r2,9992
 18160b4:	10800183 	ldbu	r2,6(r2)
 18160b8:	10803fcc 	andi	r2,r2,255
 18160bc:	10001b26 	beq	r2,zero,181612c <dhcp_handle_ack+0x18c>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 18160c0:	008061b4 	movhi	r2,390
 18160c4:	1089c504 	addi	r2,r2,10004
 18160c8:	10800617 	ldw	r2,24(r2)
 18160cc:	1006d63a 	srli	r3,r2,24
 18160d0:	008061b4 	movhi	r2,390
 18160d4:	1089c504 	addi	r2,r2,10004
 18160d8:	10800617 	ldw	r2,24(r2)
 18160dc:	1004d23a 	srli	r2,r2,8
 18160e0:	10bfc00c 	andi	r2,r2,65280
 18160e4:	1886b03a 	or	r3,r3,r2
 18160e8:	008061b4 	movhi	r2,390
 18160ec:	1089c504 	addi	r2,r2,10004
 18160f0:	10800617 	ldw	r2,24(r2)
 18160f4:	10bfc00c 	andi	r2,r2,65280
 18160f8:	1004923a 	slli	r2,r2,8
 18160fc:	1886b03a 	or	r3,r3,r2
 1816100:	008061b4 	movhi	r2,390
 1816104:	1089c504 	addi	r2,r2,10004
 1816108:	10800617 	ldw	r2,24(r2)
 181610c:	1004963a 	slli	r2,r2,24
 1816110:	1886b03a 	or	r3,r3,r2
 1816114:	e0bffe17 	ldw	r2,-8(fp)
 1816118:	10c00a15 	stw	r3,40(r2)
    dhcp->subnet_mask_given = 1;
 181611c:	e0bffe17 	ldw	r2,-8(fp)
 1816120:	00c00044 	movi	r3,1
 1816124:	10c00385 	stb	r3,14(r2)
 1816128:	00000206 	br	1816134 <dhcp_handle_ack+0x194>
  } else {
    dhcp->subnet_mask_given = 0;
 181612c:	e0bffe17 	ldw	r2,-8(fp)
 1816130:	10000385 	stb	zero,14(r2)
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
 1816134:	008061b4 	movhi	r2,390
 1816138:	1089c204 	addi	r2,r2,9992
 181613c:	108001c3 	ldbu	r2,7(r2)
 1816140:	10803fcc 	andi	r2,r2,255
 1816144:	10001726 	beq	r2,zero,18161a4 <dhcp_handle_ack+0x204>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
 1816148:	008061b4 	movhi	r2,390
 181614c:	1089c504 	addi	r2,r2,10004
 1816150:	10800717 	ldw	r2,28(r2)
 1816154:	1006d63a 	srli	r3,r2,24
 1816158:	008061b4 	movhi	r2,390
 181615c:	1089c504 	addi	r2,r2,10004
 1816160:	10800717 	ldw	r2,28(r2)
 1816164:	1004d23a 	srli	r2,r2,8
 1816168:	10bfc00c 	andi	r2,r2,65280
 181616c:	1886b03a 	or	r3,r3,r2
 1816170:	008061b4 	movhi	r2,390
 1816174:	1089c504 	addi	r2,r2,10004
 1816178:	10800717 	ldw	r2,28(r2)
 181617c:	10bfc00c 	andi	r2,r2,65280
 1816180:	1004923a 	slli	r2,r2,8
 1816184:	1886b03a 	or	r3,r3,r2
 1816188:	008061b4 	movhi	r2,390
 181618c:	1089c504 	addi	r2,r2,10004
 1816190:	10800717 	ldw	r2,28(r2)
 1816194:	1004963a 	slli	r2,r2,24
 1816198:	1886b03a 	or	r3,r3,r2
 181619c:	e0bffe17 	ldw	r2,-8(fp)
 18161a0:	10c00b15 	stw	r3,44(r2)
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
    n++;
  }
#endif /* LWIP_DNS */
}
 18161a4:	0001883a 	nop
 18161a8:	e037883a 	mov	sp,fp
 18161ac:	df000017 	ldw	fp,0(sp)
 18161b0:	dec00104 	addi	sp,sp,4
 18161b4:	f800283a 	ret

018161b8 <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
 18161b8:	defffc04 	addi	sp,sp,-16
 18161bc:	dfc00315 	stw	ra,12(sp)
 18161c0:	df000215 	stw	fp,8(sp)
 18161c4:	df000204 	addi	fp,sp,8
 18161c8:	e13ffe15 	stw	r4,-8(fp)
 18161cc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 18161d0:	01800f04 	movi	r6,60
 18161d4:	000b883a 	mov	r5,zero
 18161d8:	e13fff17 	ldw	r4,-4(fp)
 18161dc:	18061d40 	call	18061d4 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
 18161e0:	e0bffe17 	ldw	r2,-8(fp)
 18161e4:	e0ffff17 	ldw	r3,-4(fp)
 18161e8:	10c00a15 	stw	r3,40(r2)
}
 18161ec:	0001883a 	nop
 18161f0:	e037883a 	mov	sp,fp
 18161f4:	dfc00117 	ldw	ra,4(sp)
 18161f8:	df000017 	ldw	fp,0(sp)
 18161fc:	dec00204 	addi	sp,sp,8
 1816200:	f800283a 	ret

01816204 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
 1816204:	defffd04 	addi	sp,sp,-12
 1816208:	dfc00215 	stw	ra,8(sp)
 181620c:	df000115 	stw	fp,4(sp)
 1816210:	df000104 	addi	fp,sp,4
 1816214:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);

  if (netif->dhcp != NULL) {
 1816218:	e0bfff17 	ldw	r2,-4(fp)
 181621c:	10800a17 	ldw	r2,40(r2)
 1816220:	10000626 	beq	r2,zero,181623c <dhcp_cleanup+0x38>
    mem_free(netif->dhcp);
 1816224:	e0bfff17 	ldw	r2,-4(fp)
 1816228:	10800a17 	ldw	r2,40(r2)
 181622c:	1009883a 	mov	r4,r2
 1816230:	18193dc0 	call	18193dc <mem_free>
    netif->dhcp = NULL;
 1816234:	e0bfff17 	ldw	r2,-4(fp)
 1816238:	10000a15 	stw	zero,40(r2)
  }
}
 181623c:	0001883a 	nop
 1816240:	e037883a 	mov	sp,fp
 1816244:	dfc00117 	ldw	ra,4(sp)
 1816248:	df000017 	ldw	fp,0(sp)
 181624c:	dec00204 	addi	sp,sp,8
 1816250:	f800283a 	ret

01816254 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
 1816254:	defffb04 	addi	sp,sp,-20
 1816258:	dfc00415 	stw	ra,16(sp)
 181625c:	df000315 	stw	fp,12(sp)
 1816260:	df000304 	addi	fp,sp,12
 1816264:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
 1816268:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 181626c:	e0bfff17 	ldw	r2,-4(fp)
 1816270:	1000091e 	bne	r2,zero,1816298 <dhcp_start+0x44>
 1816274:	01c06134 	movhi	r7,388
 1816278:	39c5ea04 	addi	r7,r7,6056
 181627c:	0180a144 	movi	r6,645
 1816280:	01406134 	movhi	r5,388
 1816284:	2945f004 	addi	r5,r5,6080
 1816288:	01006134 	movhi	r4,388
 181628c:	2105f404 	addi	r4,r4,6096
 1816290:	1800c180 	call	1800c18 <printf>
 1816294:	003fff06 	br	1816294 <__ram_exceptions_end+0xff805e50>
  dhcp = netif->dhcp;
 1816298:	e0bfff17 	ldw	r2,-4(fp)
 181629c:	10800a17 	ldw	r2,40(r2)
 18162a0:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 18162a4:	e0bfff17 	ldw	r2,-4(fp)
 18162a8:	10c00e43 	ldbu	r3,57(r2)
 18162ac:	00bffdc4 	movi	r2,-9
 18162b0:	1884703a 	and	r2,r3,r2
 18162b4:	1007883a 	mov	r3,r2
 18162b8:	e0bfff17 	ldw	r2,-4(fp)
 18162bc:	10c00e45 	stb	r3,57(r2)

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
 18162c0:	e0bfff17 	ldw	r2,-4(fp)
 18162c4:	10800e43 	ldbu	r2,57(r2)
 18162c8:	10803fcc 	andi	r2,r2,255
 18162cc:	1080080c 	andi	r2,r2,32
 18162d0:	1000021e 	bne	r2,zero,18162dc <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
 18162d4:	00bffc84 	movi	r2,-14
 18162d8:	00005406 	br	181642c <dhcp_start+0x1d8>
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
 18162dc:	e0bfff17 	ldw	r2,-4(fp)
 18162e0:	10800c0b 	ldhu	r2,48(r2)
 18162e4:	10bfffcc 	andi	r2,r2,65535
 18162e8:	10809028 	cmpgeui	r2,r2,576
 18162ec:	1000021e 	bne	r2,zero,18162f8 <dhcp_start+0xa4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
 18162f0:	00bfffc4 	movi	r2,-1
 18162f4:	00004d06 	br	181642c <dhcp_start+0x1d8>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
 18162f8:	e0bffd17 	ldw	r2,-12(fp)
 18162fc:	10000b1e 	bne	r2,zero,181632c <dhcp_start+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
 1816300:	01000f04 	movi	r4,60
 1816304:	18197f00 	call	18197f0 <mem_malloc>
 1816308:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
 181630c:	e0bffd17 	ldw	r2,-12(fp)
 1816310:	1000021e 	bne	r2,zero,181631c <dhcp_start+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
 1816314:	00bfffc4 	movi	r2,-1
 1816318:	00004406 	br	181642c <dhcp_start+0x1d8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
 181631c:	e0bfff17 	ldw	r2,-4(fp)
 1816320:	e0fffd17 	ldw	r3,-12(fp)
 1816324:	10c00a15 	stw	r3,40(r2)
 1816328:	00000706 	br	1816348 <dhcp_start+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
 181632c:	e0bffd17 	ldw	r2,-12(fp)
 1816330:	10800117 	ldw	r2,4(r2)
 1816334:	10000426 	beq	r2,zero,1816348 <dhcp_start+0xf4>
      udp_remove(dhcp->pcb);
 1816338:	e0bffd17 	ldw	r2,-12(fp)
 181633c:	10800117 	ldw	r2,4(r2)
 1816340:	1009883a 	mov	r4,r2
 1816344:	1822bb80 	call	1822bb8 <udp_remove>
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear the previous IP assignment */
  dhcp_clear_assignment(netif);
 1816348:	e13fff17 	ldw	r4,-4(fp)
 181634c:	18157180 	call	1815718 <dhcp_clear_assignment>
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 1816350:	01800f04 	movi	r6,60
 1816354:	000b883a 	mov	r5,zero
 1816358:	e13ffd17 	ldw	r4,-12(fp)
 181635c:	18061d40 	call	18061d4 <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
 1816360:	1822c580 	call	1822c58 <udp_new>
 1816364:	1007883a 	mov	r3,r2
 1816368:	e0bffd17 	ldw	r2,-12(fp)
 181636c:	10c00115 	stw	r3,4(r2)
  if (dhcp->pcb == NULL) {
 1816370:	e0bffd17 	ldw	r2,-12(fp)
 1816374:	10800117 	ldw	r2,4(r2)
 1816378:	1000021e 	bne	r2,zero,1816384 <dhcp_start+0x130>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
 181637c:	00bfffc4 	movi	r2,-1
 1816380:	00002a06 	br	181642c <dhcp_start+0x1d8>
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
 1816384:	e0bffd17 	ldw	r2,-12(fp)
 1816388:	10800117 	ldw	r2,4(r2)
 181638c:	e0fffd17 	ldw	r3,-12(fp)
 1816390:	18c00117 	ldw	r3,4(r3)
 1816394:	18c00203 	ldbu	r3,8(r3)
 1816398:	18c00814 	ori	r3,r3,32
 181639c:	10c00205 	stb	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 18163a0:	e0bffd17 	ldw	r2,-12(fp)
 18163a4:	10800117 	ldw	r2,4(r2)
 18163a8:	01801104 	movi	r6,68
 18163ac:	d1600d04 	addi	r5,gp,-32716
 18163b0:	1009883a 	mov	r4,r2
 18163b4:	18228c00 	call	18228c0 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
 18163b8:	e0bffd17 	ldw	r2,-12(fp)
 18163bc:	10800117 	ldw	r2,4(r2)
 18163c0:	018010c4 	movi	r6,67
 18163c4:	d1600d04 	addi	r5,gp,-32716
 18163c8:	1009883a 	mov	r4,r2
 18163cc:	1822a1c0 	call	1822a1c <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
 18163d0:	e0bffd17 	ldw	r2,-12(fp)
 18163d4:	10800117 	ldw	r2,4(r2)
 18163d8:	e1bfff17 	ldw	r6,-4(fp)
 18163dc:	014060b4 	movhi	r5,386
 18163e0:	29600104 	addi	r5,r5,-32764
 18163e4:	1009883a 	mov	r4,r2
 18163e8:	1822b740 	call	1822b74 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
 18163ec:	e13fff17 	ldw	r4,-4(fp)
 18163f0:	18168980 	call	1816898 <dhcp_discover>
 18163f4:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
 18163f8:	e0bffe07 	ldb	r2,-8(fp)
 18163fc:	10000426 	beq	r2,zero,1816410 <dhcp_start+0x1bc>
    /* free resources allocated above */
    dhcp_stop(netif);
 1816400:	e13fff17 	ldw	r4,-4(fp)
 1816404:	18172cc0 	call	18172cc <dhcp_stop>
    return ERR_MEM;
 1816408:	00bfffc4 	movi	r2,-1
 181640c:	00000706 	br	181642c <dhcp_start+0x1d8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
 1816410:	e0bfff17 	ldw	r2,-4(fp)
 1816414:	10800e43 	ldbu	r2,57(r2)
 1816418:	10800214 	ori	r2,r2,8
 181641c:	1007883a 	mov	r3,r2
 1816420:	e0bfff17 	ldw	r2,-4(fp)
 1816424:	10c00e45 	stb	r3,57(r2)
  return result;
 1816428:	e0bffe03 	ldbu	r2,-8(fp)
}
 181642c:	e037883a 	mov	sp,fp
 1816430:	dfc00117 	ldw	ra,4(sp)
 1816434:	df000017 	ldw	fp,0(sp)
 1816438:	dec00204 	addi	sp,sp,8
 181643c:	f800283a 	ret

01816440 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
 1816440:	deffeb04 	addi	sp,sp,-84
 1816444:	dfc01415 	stw	ra,80(sp)
 1816448:	df001315 	stw	fp,76(sp)
 181644c:	df001304 	addi	fp,sp,76
 1816450:	e13fff15 	stw	r4,-4(fp)
  struct dhcp dhcp;
  err_t result = ERR_OK;
 1816454:	e03fef05 	stb	zero,-68(fp)
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 1816458:	e0bfff17 	ldw	r2,-4(fp)
 181645c:	1000091e 	bne	r2,zero,1816484 <dhcp_inform+0x44>
 1816460:	01c06134 	movhi	r7,388
 1816464:	39c5ea04 	addi	r7,r7,6056
 1816468:	0180b6c4 	movi	r6,731
 181646c:	01406134 	movhi	r5,388
 1816470:	2945f004 	addi	r5,r5,6080
 1816474:	01006134 	movhi	r4,388
 1816478:	2105f404 	addi	r4,r4,6096
 181647c:	1800c180 	call	1800c18 <printf>
 1816480:	003fff06 	br	1816480 <__ram_exceptions_end+0xff80603c>

  memset(&dhcp, 0, sizeof(struct dhcp));
 1816484:	e0bff004 	addi	r2,fp,-64
 1816488:	01800f04 	movi	r6,60
 181648c:	000b883a 	mov	r5,zero
 1816490:	1009883a 	mov	r4,r2
 1816494:	18061d40 	call	18061d4 <memset>
  dhcp_set_state(&dhcp, DHCP_INFORM);
 1816498:	e0bff004 	addi	r2,fp,-64
 181649c:	01400204 	movi	r5,8
 18164a0:	1009883a 	mov	r4,r2
 18164a4:	18173840 	call	1817384 <dhcp_set_state>

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
 18164a8:	e0bfff17 	ldw	r2,-4(fp)
 18164ac:	10800a17 	ldw	r2,40(r2)
 18164b0:	10000926 	beq	r2,zero,18164d8 <dhcp_inform+0x98>
 18164b4:	e0bfff17 	ldw	r2,-4(fp)
 18164b8:	10800a17 	ldw	r2,40(r2)
 18164bc:	10800117 	ldw	r2,4(r2)
 18164c0:	10000526 	beq	r2,zero,18164d8 <dhcp_inform+0x98>
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
 18164c4:	e0bfff17 	ldw	r2,-4(fp)
 18164c8:	10800a17 	ldw	r2,40(r2)
 18164cc:	10800117 	ldw	r2,4(r2)
 18164d0:	e0bfee15 	stw	r2,-72(fp)
 18164d4:	00001006 	br	1816518 <dhcp_inform+0xd8>
  } else {
    pcb = udp_new();
 18164d8:	1822c580 	call	1822c58 <udp_new>
 18164dc:	e0bfee15 	stw	r2,-72(fp)
    if (pcb == NULL) {
 18164e0:	e0bfee17 	ldw	r2,-72(fp)
 18164e4:	10003b26 	beq	r2,zero,18165d4 <dhcp_inform+0x194>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
 18164e8:	e0bfee17 	ldw	r2,-72(fp)
 18164ec:	e0bff115 	stw	r2,-60(fp)
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
 18164f0:	e0bff117 	ldw	r2,-60(fp)
 18164f4:	e0fff117 	ldw	r3,-60(fp)
 18164f8:	18c00203 	ldbu	r3,8(r3)
 18164fc:	18c00814 	ori	r3,r3,32
 1816500:	10c00205 	stb	r3,8(r2)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 1816504:	e0bff117 	ldw	r2,-60(fp)
 1816508:	01801104 	movi	r6,68
 181650c:	d1600d04 	addi	r5,gp,-32716
 1816510:	1009883a 	mov	r4,r2
 1816514:	18228c00 	call	18228c0 <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
 1816518:	e0bff004 	addi	r2,fp,-64
 181651c:	01800204 	movi	r6,8
 1816520:	100b883a 	mov	r5,r2
 1816524:	e13fff17 	ldw	r4,-4(fp)
 1816528:	181835c0 	call	181835c <dhcp_create_msg>
 181652c:	e0bfef05 	stb	r2,-68(fp)
  if (result == ERR_OK) {
 1816530:	e0bfef07 	ldb	r2,-68(fp)
 1816534:	1000211e 	bne	r2,zero,18165bc <dhcp_inform+0x17c>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 1816538:	e0bff004 	addi	r2,fp,-64
 181653c:	01800084 	movi	r6,2
 1816540:	01400e44 	movi	r5,57
 1816544:	1009883a 	mov	r4,r2
 1816548:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
 181654c:	e0bfff17 	ldw	r2,-4(fp)
 1816550:	10800c0b 	ldhu	r2,48(r2)
 1816554:	10ffffcc 	andi	r3,r2,65535
 1816558:	e0bff004 	addi	r2,fp,-64
 181655c:	180b883a 	mov	r5,r3
 1816560:	1009883a 	mov	r4,r2
 1816564:	18174dc0 	call	18174dc <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
 1816568:	e0bff004 	addi	r2,fp,-64
 181656c:	1009883a 	mov	r4,r2
 1816570:	18189640 	call	1818964 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
 1816574:	e0fff417 	ldw	r3,-48(fp)
 1816578:	e0bff60b 	ldhu	r2,-40(fp)
 181657c:	10803c04 	addi	r2,r2,240
 1816580:	10bfffcc 	andi	r2,r2,65535
 1816584:	100b883a 	mov	r5,r2
 1816588:	1809883a 	mov	r4,r3
 181658c:	181a9940 	call	181a994 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 1816590:	e0fff417 	ldw	r3,-48(fp)
 1816594:	e0bfff17 	ldw	r2,-4(fp)
 1816598:	d8800015 	stw	r2,0(sp)
 181659c:	01c010c4 	movi	r7,67
 18165a0:	d1a00e04 	addi	r6,gp,-32712
 18165a4:	180b883a 	mov	r5,r3
 18165a8:	e13fee17 	ldw	r4,-72(fp)
 18165ac:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(&dhcp);
 18165b0:	e0bff004 	addi	r2,fp,-64
 18165b4:	1009883a 	mov	r4,r2
 18165b8:	18188e00 	call	18188e0 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
 18165bc:	e0bff117 	ldw	r2,-60(fp)
 18165c0:	10000526 	beq	r2,zero,18165d8 <dhcp_inform+0x198>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
 18165c4:	e0bff117 	ldw	r2,-60(fp)
 18165c8:	1009883a 	mov	r4,r2
 18165cc:	1822bb80 	call	1822bb8 <udp_remove>
 18165d0:	00000106 	br	18165d8 <dhcp_inform+0x198>
    pcb = netif->dhcp->pcb;
  } else {
    pcb = udp_new();
    if (pcb == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
 18165d4:	0001883a 	nop

  if (dhcp.pcb != NULL) {
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
  }
}
 18165d8:	e037883a 	mov	sp,fp
 18165dc:	dfc00117 	ldw	ra,4(sp)
 18165e0:	df000017 	ldw	fp,0(sp)
 18165e4:	dec00204 	addi	sp,sp,8
 18165e8:	f800283a 	ret

018165ec <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
 18165ec:	defffc04 	addi	sp,sp,-16
 18165f0:	dfc00315 	stw	ra,12(sp)
 18165f4:	df000215 	stw	fp,8(sp)
 18165f8:	df000204 	addi	fp,sp,8
 18165fc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1816600:	e0bfff17 	ldw	r2,-4(fp)
 1816604:	10800a17 	ldw	r2,40(r2)
 1816608:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
 181660c:	e0bffe17 	ldw	r2,-8(fp)
 1816610:	10001826 	beq	r2,zero,1816674 <dhcp_network_changed+0x88>
    return;
  switch (dhcp->state) {
 1816614:	e0bffe17 	ldw	r2,-8(fp)
 1816618:	10800303 	ldbu	r2,12(r2)
 181661c:	10803fcc 	andi	r2,r2,255
 1816620:	10c00188 	cmpgei	r3,r2,6
 1816624:	1800041e 	bne	r3,zero,1816638 <dhcp_network_changed+0x4c>
 1816628:	10c000c8 	cmpgei	r3,r2,3
 181662c:	1800041e 	bne	r3,zero,1816640 <dhcp_network_changed+0x54>
 1816630:	10001226 	beq	r2,zero,181667c <dhcp_network_changed+0x90>
 1816634:	00000906 	br	181665c <dhcp_network_changed+0x70>
 1816638:	108002a0 	cmpeqi	r2,r2,10
 181663c:	10000726 	beq	r2,zero,181665c <dhcp_network_changed+0x70>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
 1816640:	e13fff17 	ldw	r4,-4(fp)
 1816644:	181a1500 	call	181a150 <netif_set_down>
    dhcp->tries = 0;
 1816648:	e0bffe17 	ldw	r2,-8(fp)
 181664c:	10000345 	stb	zero,13(r2)
    dhcp_reboot(netif);
 1816650:	e13fff17 	ldw	r4,-4(fp)
 1816654:	1816f840 	call	1816f84 <dhcp_reboot>
    break;
 1816658:	00000906 	br	1816680 <dhcp_network_changed+0x94>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
 181665c:	e0bffe17 	ldw	r2,-8(fp)
 1816660:	10000345 	stb	zero,13(r2)
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
 1816664:	e13fff17 	ldw	r4,-4(fp)
 1816668:	18168980 	call	1816898 <dhcp_discover>
    break;
 181666c:	0001883a 	nop
 1816670:	00000306 	br	1816680 <dhcp_network_changed+0x94>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
 1816674:	0001883a 	nop
 1816678:	00000106 	br	1816680 <dhcp_network_changed+0x94>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
 181667c:	0001883a 	nop
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
 1816680:	e037883a 	mov	sp,fp
 1816684:	dfc00117 	ldw	ra,4(sp)
 1816688:	df000017 	ldw	fp,0(sp)
 181668c:	dec00204 	addi	sp,sp,8
 1816690:	f800283a 	ret

01816694 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
 1816694:	defffc04 	addi	sp,sp,-16
 1816698:	dfc00315 	stw	ra,12(sp)
 181669c:	df000215 	stw	fp,8(sp)
 18166a0:	df000204 	addi	fp,sp,8
 18166a4:	e13ffe15 	stw	r4,-8(fp)
 18166a8:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 18166ac:	e0bffe17 	ldw	r2,-8(fp)
 18166b0:	1000091e 	bne	r2,zero,18166d8 <dhcp_arp_reply+0x44>
 18166b4:	01c06134 	movhi	r7,388
 18166b8:	39c5ea04 	addi	r7,r7,6056
 18166bc:	0180cc84 	movi	r6,818
 18166c0:	01406134 	movhi	r5,388
 18166c4:	2945f004 	addi	r5,r5,6080
 18166c8:	01006134 	movhi	r4,388
 18166cc:	2105f404 	addi	r4,r4,6096
 18166d0:	1800c180 	call	1800c18 <printf>
 18166d4:	003fff06 	br	18166d4 <__ram_exceptions_end+0xff806290>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
 18166d8:	e0bffe17 	ldw	r2,-8(fp)
 18166dc:	10800a17 	ldw	r2,40(r2)
 18166e0:	10000e26 	beq	r2,zero,181671c <dhcp_arp_reply+0x88>
 18166e4:	e0bffe17 	ldw	r2,-8(fp)
 18166e8:	10800a17 	ldw	r2,40(r2)
 18166ec:	10800303 	ldbu	r2,12(r2)
 18166f0:	10803fcc 	andi	r2,r2,255
 18166f4:	10800218 	cmpnei	r2,r2,8
 18166f8:	1000081e 	bne	r2,zero,181671c <dhcp_arp_reply+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
 18166fc:	e0bfff17 	ldw	r2,-4(fp)
 1816700:	10c00017 	ldw	r3,0(r2)
 1816704:	e0bffe17 	ldw	r2,-8(fp)
 1816708:	10800a17 	ldw	r2,40(r2)
 181670c:	10800917 	ldw	r2,36(r2)
 1816710:	1880021e 	bne	r3,r2,181671c <dhcp_arp_reply+0x88>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
 1816714:	e13ffe17 	ldw	r4,-8(fp)
 1816718:	18167340 	call	1816734 <dhcp_decline>
    }
  }
}
 181671c:	0001883a 	nop
 1816720:	e037883a 	mov	sp,fp
 1816724:	dfc00117 	ldw	ra,4(sp)
 1816728:	df000017 	ldw	fp,0(sp)
 181672c:	dec00204 	addi	sp,sp,8
 1816730:	f800283a 	ret

01816734 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
 1816734:	defffa04 	addi	sp,sp,-24
 1816738:	dfc00515 	stw	ra,20(sp)
 181673c:	df000415 	stw	fp,16(sp)
 1816740:	df000404 	addi	fp,sp,16
 1816744:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1816748:	e0bfff17 	ldw	r2,-4(fp)
 181674c:	10800a17 	ldw	r2,40(r2)
 1816750:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
 1816754:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 1816758:	01400304 	movi	r5,12
 181675c:	e13ffd17 	ldw	r4,-12(fp)
 1816760:	18173840 	call	1817384 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
 1816764:	01800104 	movi	r6,4
 1816768:	e17ffd17 	ldw	r5,-12(fp)
 181676c:	e13fff17 	ldw	r4,-4(fp)
 1816770:	181835c0 	call	181835c <dhcp_create_msg>
 1816774:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 1816778:	e0bffe07 	ldb	r2,-8(fp)
 181677c:	1000301e 	bne	r2,zero,1816840 <dhcp_decline+0x10c>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 1816780:	01800104 	movi	r6,4
 1816784:	01400c84 	movi	r5,50
 1816788:	e13ffd17 	ldw	r4,-12(fp)
 181678c:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 1816790:	e0bffd17 	ldw	r2,-12(fp)
 1816794:	10800917 	ldw	r2,36(r2)
 1816798:	1006d63a 	srli	r3,r2,24
 181679c:	e0bffd17 	ldw	r2,-12(fp)
 18167a0:	10800917 	ldw	r2,36(r2)
 18167a4:	1004d23a 	srli	r2,r2,8
 18167a8:	10bfc00c 	andi	r2,r2,65280
 18167ac:	1886b03a 	or	r3,r3,r2
 18167b0:	e0bffd17 	ldw	r2,-12(fp)
 18167b4:	10800917 	ldw	r2,36(r2)
 18167b8:	10bfc00c 	andi	r2,r2,65280
 18167bc:	1004923a 	slli	r2,r2,8
 18167c0:	1886b03a 	or	r3,r3,r2
 18167c4:	e0bffd17 	ldw	r2,-12(fp)
 18167c8:	10800917 	ldw	r2,36(r2)
 18167cc:	1004963a 	slli	r2,r2,24
 18167d0:	1884b03a 	or	r2,r3,r2
 18167d4:	100b883a 	mov	r5,r2
 18167d8:	e13ffd17 	ldw	r4,-12(fp)
 18167dc:	18175740 	call	1817574 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
 18167e0:	e13ffd17 	ldw	r4,-12(fp)
 18167e4:	18189640 	call	1818964 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 18167e8:	e0bffd17 	ldw	r2,-12(fp)
 18167ec:	10c00417 	ldw	r3,16(r2)
 18167f0:	e0bffd17 	ldw	r2,-12(fp)
 18167f4:	1080060b 	ldhu	r2,24(r2)
 18167f8:	10803c04 	addi	r2,r2,240
 18167fc:	10bfffcc 	andi	r2,r2,65535
 1816800:	100b883a 	mov	r5,r2
 1816804:	1809883a 	mov	r4,r3
 1816808:	181a9940 	call	181a994 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 181680c:	e0bffd17 	ldw	r2,-12(fp)
 1816810:	10c00117 	ldw	r3,4(r2)
 1816814:	e0bffd17 	ldw	r2,-12(fp)
 1816818:	11000417 	ldw	r4,16(r2)
 181681c:	e0bfff17 	ldw	r2,-4(fp)
 1816820:	d8800015 	stw	r2,0(sp)
 1816824:	01c010c4 	movi	r7,67
 1816828:	d1a00e04 	addi	r6,gp,-32712
 181682c:	200b883a 	mov	r5,r4
 1816830:	1809883a 	mov	r4,r3
 1816834:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 1816838:	e13ffd17 	ldw	r4,-12(fp)
 181683c:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 1816840:	e0bffd17 	ldw	r2,-12(fp)
 1816844:	10800343 	ldbu	r2,13(r2)
 1816848:	10800044 	addi	r2,r2,1
 181684c:	1007883a 	mov	r3,r2
 1816850:	e0bffd17 	ldw	r2,-12(fp)
 1816854:	10c00345 	stb	r3,13(r2)
  msecs = 10*1000;
 1816858:	0089c404 	movi	r2,10000
 181685c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1816860:	e0bffe8b 	ldhu	r2,-6(fp)
 1816864:	10807cc4 	addi	r2,r2,499
 1816868:	01407d04 	movi	r5,500
 181686c:	1009883a 	mov	r4,r2
 1816870:	180ac180 	call	180ac18 <__divsi3>
 1816874:	1007883a 	mov	r3,r2
 1816878:	e0bffd17 	ldw	r2,-12(fp)
 181687c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1816880:	e0bffe03 	ldbu	r2,-8(fp)
}
 1816884:	e037883a 	mov	sp,fp
 1816888:	dfc00117 	ldw	ra,4(sp)
 181688c:	df000017 	ldw	fp,0(sp)
 1816890:	dec00204 	addi	sp,sp,8
 1816894:	f800283a 	ret

01816898 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 1816898:	defffa04 	addi	sp,sp,-24
 181689c:	dfc00515 	stw	ra,20(sp)
 18168a0:	df000415 	stw	fp,16(sp)
 18168a4:	df000404 	addi	fp,sp,16
 18168a8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 18168ac:	e0bfff17 	ldw	r2,-4(fp)
 18168b0:	10800a17 	ldw	r2,40(r2)
 18168b4:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
 18168b8:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
 18168bc:	e0bffd17 	ldw	r2,-12(fp)
 18168c0:	10000915 	stw	zero,36(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
 18168c4:	01400184 	movi	r5,6
 18168c8:	e13ffd17 	ldw	r4,-12(fp)
 18168cc:	18173840 	call	1817384 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
 18168d0:	01800044 	movi	r6,1
 18168d4:	e17ffd17 	ldw	r5,-12(fp)
 18168d8:	e13fff17 	ldw	r4,-4(fp)
 18168dc:	181835c0 	call	181835c <dhcp_create_msg>
 18168e0:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 18168e4:	e0bffe07 	ldb	r2,-8(fp)
 18168e8:	1000321e 	bne	r2,zero,18169b4 <dhcp_discover+0x11c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 18168ec:	01800084 	movi	r6,2
 18168f0:	01400e44 	movi	r5,57
 18168f4:	e13ffd17 	ldw	r4,-12(fp)
 18168f8:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 18168fc:	e0bfff17 	ldw	r2,-4(fp)
 1816900:	10800c0b 	ldhu	r2,48(r2)
 1816904:	10bfffcc 	andi	r2,r2,65535
 1816908:	100b883a 	mov	r5,r2
 181690c:	e13ffd17 	ldw	r4,-12(fp)
 1816910:	18174dc0 	call	18174dc <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
 1816914:	01800104 	movi	r6,4
 1816918:	01400dc4 	movi	r5,55
 181691c:	e13ffd17 	ldw	r4,-12(fp)
 1816920:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
 1816924:	01400044 	movi	r5,1
 1816928:	e13ffd17 	ldw	r4,-12(fp)
 181692c:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
 1816930:	014000c4 	movi	r5,3
 1816934:	e13ffd17 	ldw	r4,-12(fp)
 1816938:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
 181693c:	01400704 	movi	r5,28
 1816940:	e13ffd17 	ldw	r4,-12(fp)
 1816944:	181747c0 	call	181747c <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
 1816948:	01400184 	movi	r5,6
 181694c:	e13ffd17 	ldw	r4,-12(fp)
 1816950:	181747c0 	call	181747c <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
 1816954:	e13ffd17 	ldw	r4,-12(fp)
 1816958:	18189640 	call	1818964 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 181695c:	e0bffd17 	ldw	r2,-12(fp)
 1816960:	10c00417 	ldw	r3,16(r2)
 1816964:	e0bffd17 	ldw	r2,-12(fp)
 1816968:	1080060b 	ldhu	r2,24(r2)
 181696c:	10803c04 	addi	r2,r2,240
 1816970:	10bfffcc 	andi	r2,r2,65535
 1816974:	100b883a 	mov	r5,r2
 1816978:	1809883a 	mov	r4,r3
 181697c:	181a9940 	call	181a994 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 1816980:	e0bffd17 	ldw	r2,-12(fp)
 1816984:	10c00117 	ldw	r3,4(r2)
 1816988:	e0bffd17 	ldw	r2,-12(fp)
 181698c:	11000417 	ldw	r4,16(r2)
 1816990:	e0bfff17 	ldw	r2,-4(fp)
 1816994:	d8800015 	stw	r2,0(sp)
 1816998:	01c010c4 	movi	r7,67
 181699c:	d1a00e04 	addi	r6,gp,-32712
 18169a0:	200b883a 	mov	r5,r4
 18169a4:	1809883a 	mov	r4,r3
 18169a8:	182240c0 	call	182240c <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
 18169ac:	e13ffd17 	ldw	r4,-12(fp)
 18169b0:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 18169b4:	e0bffd17 	ldw	r2,-12(fp)
 18169b8:	10800343 	ldbu	r2,13(r2)
 18169bc:	10800044 	addi	r2,r2,1
 18169c0:	1007883a 	mov	r3,r2
 18169c4:	e0bffd17 	ldw	r2,-12(fp)
 18169c8:	10c00345 	stb	r3,13(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 18169cc:	e0bffd17 	ldw	r2,-12(fp)
 18169d0:	10800343 	ldbu	r2,13(r2)
 18169d4:	10803fcc 	andi	r2,r2,255
 18169d8:	108001a8 	cmpgeui	r2,r2,6
 18169dc:	1000061e 	bne	r2,zero,18169f8 <dhcp_discover+0x160>
 18169e0:	e0bffd17 	ldw	r2,-12(fp)
 18169e4:	10800343 	ldbu	r2,13(r2)
 18169e8:	10803fcc 	andi	r2,r2,255
 18169ec:	00c0fa04 	movi	r3,1000
 18169f0:	1884983a 	sll	r2,r3,r2
 18169f4:	00000106 	br	18169fc <dhcp_discover+0x164>
 18169f8:	00ba9804 	movi	r2,-5536
 18169fc:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1816a00:	e0bffe8b 	ldhu	r2,-6(fp)
 1816a04:	10807cc4 	addi	r2,r2,499
 1816a08:	01407d04 	movi	r5,500
 1816a0c:	1009883a 	mov	r4,r2
 1816a10:	180ac180 	call	180ac18 <__divsi3>
 1816a14:	1007883a 	mov	r3,r2
 1816a18:	e0bffd17 	ldw	r2,-12(fp)
 1816a1c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1816a20:	e0bffe03 	ldbu	r2,-8(fp)
}
 1816a24:	e037883a 	mov	sp,fp
 1816a28:	dfc00117 	ldw	ra,4(sp)
 1816a2c:	df000017 	ldw	fp,0(sp)
 1816a30:	dec00204 	addi	sp,sp,8
 1816a34:	f800283a 	ret

01816a38 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 1816a38:	defff804 	addi	sp,sp,-32
 1816a3c:	dfc00715 	stw	ra,28(sp)
 1816a40:	df000615 	stw	fp,24(sp)
 1816a44:	df000604 	addi	fp,sp,24
 1816a48:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 1816a4c:	e0bfff17 	ldw	r2,-4(fp)
 1816a50:	1000091e 	bne	r2,zero,1816a78 <dhcp_bind+0x40>
 1816a54:	01c06134 	movhi	r7,388
 1816a58:	39c5ea04 	addi	r7,r7,6056
 1816a5c:	0180ec44 	movi	r6,945
 1816a60:	01406134 	movhi	r5,388
 1816a64:	29460004 	addi	r5,r5,6144
 1816a68:	01006134 	movhi	r4,388
 1816a6c:	2105f404 	addi	r4,r4,6096
 1816a70:	1800c180 	call	1800c18 <printf>
 1816a74:	003fff06 	br	1816a74 <__ram_exceptions_end+0xff806630>
  dhcp = netif->dhcp;
 1816a78:	e0bfff17 	ldw	r2,-4(fp)
 1816a7c:	10800a17 	ldw	r2,40(r2)
 1816a80:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 1816a84:	e0bffb17 	ldw	r2,-20(fp)
 1816a88:	1000091e 	bne	r2,zero,1816ab0 <dhcp_bind+0x78>
 1816a8c:	01c06134 	movhi	r7,388
 1816a90:	39c5ea04 	addi	r7,r7,6056
 1816a94:	0180ecc4 	movi	r6,947
 1816a98:	01406134 	movhi	r5,388
 1816a9c:	29460704 	addi	r5,r5,6172
 1816aa0:	01006134 	movhi	r4,388
 1816aa4:	2105f404 	addi	r4,r4,6096
 1816aa8:	1800c180 	call	1800c18 <printf>
 1816aac:	003fff06 	br	1816aac <__ram_exceptions_end+0xff806668>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 1816ab0:	e0bffb17 	ldw	r2,-20(fp)
 1816ab4:	10800d17 	ldw	r2,52(r2)
 1816ab8:	10bfffe0 	cmpeqi	r2,r2,-1
 1816abc:	1000171e 	bne	r2,zero,1816b1c <dhcp_bind+0xe4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 1816ac0:	e0bffb17 	ldw	r2,-20(fp)
 1816ac4:	10800d17 	ldw	r2,52(r2)
 1816ac8:	10800784 	addi	r2,r2,30
 1816acc:	01400f04 	movi	r5,60
 1816ad0:	1009883a 	mov	r4,r2
 1816ad4:	180ad100 	call	180ad10 <__udivsi3>
 1816ad8:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
 1816adc:	e0bffa17 	ldw	r2,-24(fp)
 1816ae0:	00ffffd4 	movui	r3,65535
 1816ae4:	1880022e 	bgeu	r3,r2,1816af0 <dhcp_bind+0xb8>
      timeout = 0xffff;
 1816ae8:	00bfffd4 	movui	r2,65535
 1816aec:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
 1816af0:	e0bffa17 	ldw	r2,-24(fp)
 1816af4:	1007883a 	mov	r3,r2
 1816af8:	e0bffb17 	ldw	r2,-20(fp)
 1816afc:	10c0070d 	sth	r3,28(r2)
    if (dhcp->t1_timeout == 0) {
 1816b00:	e0bffb17 	ldw	r2,-20(fp)
 1816b04:	1080070b 	ldhu	r2,28(r2)
 1816b08:	10bfffcc 	andi	r2,r2,65535
 1816b0c:	1000031e 	bne	r2,zero,1816b1c <dhcp_bind+0xe4>
      dhcp->t1_timeout = 1;
 1816b10:	e0bffb17 	ldw	r2,-20(fp)
 1816b14:	00c00044 	movi	r3,1
 1816b18:	10c0070d 	sth	r3,28(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 1816b1c:	e0bffb17 	ldw	r2,-20(fp)
 1816b20:	10800e17 	ldw	r2,56(r2)
 1816b24:	10bfffe0 	cmpeqi	r2,r2,-1
 1816b28:	1000171e 	bne	r2,zero,1816b88 <dhcp_bind+0x150>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 1816b2c:	e0bffb17 	ldw	r2,-20(fp)
 1816b30:	10800e17 	ldw	r2,56(r2)
 1816b34:	10800784 	addi	r2,r2,30
 1816b38:	01400f04 	movi	r5,60
 1816b3c:	1009883a 	mov	r4,r2
 1816b40:	180ad100 	call	180ad10 <__udivsi3>
 1816b44:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
 1816b48:	e0bffa17 	ldw	r2,-24(fp)
 1816b4c:	00ffffd4 	movui	r3,65535
 1816b50:	1880022e 	bgeu	r3,r2,1816b5c <dhcp_bind+0x124>
      timeout = 0xffff;
 1816b54:	00bfffd4 	movui	r2,65535
 1816b58:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
 1816b5c:	e0bffa17 	ldw	r2,-24(fp)
 1816b60:	1007883a 	mov	r3,r2
 1816b64:	e0bffb17 	ldw	r2,-20(fp)
 1816b68:	10c0078d 	sth	r3,30(r2)
    if (dhcp->t2_timeout == 0) {
 1816b6c:	e0bffb17 	ldw	r2,-20(fp)
 1816b70:	1080078b 	ldhu	r2,30(r2)
 1816b74:	10bfffcc 	andi	r2,r2,65535
 1816b78:	1000031e 	bne	r2,zero,1816b88 <dhcp_bind+0x150>
      dhcp->t2_timeout = 1;
 1816b7c:	e0bffb17 	ldw	r2,-20(fp)
 1816b80:	00c00044 	movi	r3,1
 1816b84:	10c0078d 	sth	r3,30(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 1816b88:	e0bffb17 	ldw	r2,-20(fp)
 1816b8c:	10c0070b 	ldhu	r3,28(r2)
 1816b90:	e0bffb17 	ldw	r2,-20(fp)
 1816b94:	1080078b 	ldhu	r2,30(r2)
 1816b98:	18ffffcc 	andi	r3,r3,65535
 1816b9c:	10bfffcc 	andi	r2,r2,65535
 1816ba0:	18800636 	bltu	r3,r2,1816bbc <dhcp_bind+0x184>
 1816ba4:	e0bffb17 	ldw	r2,-20(fp)
 1816ba8:	1080078b 	ldhu	r2,30(r2)
 1816bac:	10bfffcc 	andi	r2,r2,65535
 1816bb0:	10000226 	beq	r2,zero,1816bbc <dhcp_bind+0x184>
    dhcp->t1_timeout = 0;
 1816bb4:	e0bffb17 	ldw	r2,-20(fp)
 1816bb8:	1000070d 	sth	zero,28(r2)
  }

  if (dhcp->subnet_mask_given) {
 1816bbc:	e0bffb17 	ldw	r2,-20(fp)
 1816bc0:	10800383 	ldbu	r2,14(r2)
 1816bc4:	10803fcc 	andi	r2,r2,255
 1816bc8:	10000426 	beq	r2,zero,1816bdc <dhcp_bind+0x1a4>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
 1816bcc:	e0bffb17 	ldw	r2,-20(fp)
 1816bd0:	10800a17 	ldw	r2,40(r2)
 1816bd4:	e0bffd15 	stw	r2,-12(fp)
 1816bd8:	00001506 	br	1816c30 <dhcp_bind+0x1f8>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 1816bdc:	e0bffb17 	ldw	r2,-20(fp)
 1816be0:	10800904 	addi	r2,r2,36
 1816be4:	10800003 	ldbu	r2,0(r2)
 1816be8:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
 1816bec:	e0bffc03 	ldbu	r2,-16(fp)
 1816bf0:	10803fcc 	andi	r2,r2,255
 1816bf4:	1080201c 	xori	r2,r2,128
 1816bf8:	10bfe004 	addi	r2,r2,-128
 1816bfc:	10000316 	blt	r2,zero,1816c0c <dhcp_bind+0x1d4>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 1816c00:	00803fc4 	movi	r2,255
 1816c04:	e0bffd15 	stw	r2,-12(fp)
 1816c08:	00000906 	br	1816c30 <dhcp_bind+0x1f8>
    } else if (first_octet >= 192) {
 1816c0c:	e0bffc03 	ldbu	r2,-16(fp)
 1816c10:	10803030 	cmpltui	r2,r2,192
 1816c14:	1000041e 	bne	r2,zero,1816c28 <dhcp_bind+0x1f0>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 1816c18:	00804034 	movhi	r2,256
 1816c1c:	10bfffc4 	addi	r2,r2,-1
 1816c20:	e0bffd15 	stw	r2,-12(fp)
 1816c24:	00000206 	br	1816c30 <dhcp_bind+0x1f8>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 1816c28:	00bfffd4 	movui	r2,65535
 1816c2c:	e0bffd15 	stw	r2,-12(fp)
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
 1816c30:	e0bffb17 	ldw	r2,-20(fp)
 1816c34:	10800b17 	ldw	r2,44(r2)
 1816c38:	e0bffe15 	stw	r2,-8(fp)
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
 1816c3c:	e0bffe17 	ldw	r2,-8(fp)
 1816c40:	1000081e 	bne	r2,zero,1816c64 <dhcp_bind+0x22c>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
 1816c44:	e0bffb17 	ldw	r2,-20(fp)
 1816c48:	10c00917 	ldw	r3,36(r2)
 1816c4c:	e0bffd17 	ldw	r2,-12(fp)
 1816c50:	1884703a 	and	r2,r3,r2
 1816c54:	e0bffe15 	stw	r2,-8(fp)
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 1816c58:	e0bffe17 	ldw	r2,-8(fp)
 1816c5c:	10804034 	orhi	r2,r2,256
 1816c60:	e0bffe15 	stw	r2,-8(fp)
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
 1816c64:	e0bffb17 	ldw	r2,-20(fp)
 1816c68:	10800904 	addi	r2,r2,36
 1816c6c:	100b883a 	mov	r5,r2
 1816c70:	e13fff17 	ldw	r4,-4(fp)
 1816c74:	1819ebc0 	call	1819ebc <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
 1816c78:	e0bffd04 	addi	r2,fp,-12
 1816c7c:	100b883a 	mov	r5,r2
 1816c80:	e13fff17 	ldw	r4,-4(fp)
 1816c84:	181a02c0 	call	181a02c <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
 1816c88:	e0bffe04 	addi	r2,fp,-8
 1816c8c:	100b883a 	mov	r5,r2
 1816c90:	e13fff17 	ldw	r4,-4(fp)
 1816c94:	1819fe40 	call	1819fe4 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
 1816c98:	e13fff17 	ldw	r4,-4(fp)
 1816c9c:	181a0a00 	call	181a0a0 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
 1816ca0:	01400284 	movi	r5,10
 1816ca4:	e13ffb17 	ldw	r4,-20(fp)
 1816ca8:	18173840 	call	1817384 <dhcp_set_state>
}
 1816cac:	0001883a 	nop
 1816cb0:	e037883a 	mov	sp,fp
 1816cb4:	dfc00117 	ldw	ra,4(sp)
 1816cb8:	df000017 	ldw	fp,0(sp)
 1816cbc:	dec00204 	addi	sp,sp,8
 1816cc0:	f800283a 	ret

01816cc4 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 1816cc4:	defffa04 	addi	sp,sp,-24
 1816cc8:	dfc00515 	stw	ra,20(sp)
 1816ccc:	df000415 	stw	fp,16(sp)
 1816cd0:	df000404 	addi	fp,sp,16
 1816cd4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1816cd8:	e0bfff17 	ldw	r2,-4(fp)
 1816cdc:	10800a17 	ldw	r2,40(r2)
 1816ce0:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
 1816ce4:	01400144 	movi	r5,5
 1816ce8:	e13ffd17 	ldw	r4,-12(fp)
 1816cec:	18173840 	call	1817384 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 1816cf0:	018000c4 	movi	r6,3
 1816cf4:	e17ffd17 	ldw	r5,-12(fp)
 1816cf8:	e13fff17 	ldw	r4,-4(fp)
 1816cfc:	181835c0 	call	181835c <dhcp_create_msg>
 1816d00:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 1816d04:	e0bffe07 	ldb	r2,-8(fp)
 1816d08:	1000271e 	bne	r2,zero,1816da8 <dhcp_renew+0xe4>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 1816d0c:	01800084 	movi	r6,2
 1816d10:	01400e44 	movi	r5,57
 1816d14:	e13ffd17 	ldw	r4,-12(fp)
 1816d18:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 1816d1c:	e0bfff17 	ldw	r2,-4(fp)
 1816d20:	10800c0b 	ldhu	r2,48(r2)
 1816d24:	10bfffcc 	andi	r2,r2,65535
 1816d28:	100b883a 	mov	r5,r2
 1816d2c:	e13ffd17 	ldw	r4,-12(fp)
 1816d30:	18174dc0 	call	18174dc <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 1816d34:	e17fff17 	ldw	r5,-4(fp)
 1816d38:	e13ffd17 	ldw	r4,-12(fp)
 1816d3c:	18176800 	call	1817680 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
 1816d40:	e13ffd17 	ldw	r4,-12(fp)
 1816d44:	18189640 	call	1818964 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 1816d48:	e0bffd17 	ldw	r2,-12(fp)
 1816d4c:	10c00417 	ldw	r3,16(r2)
 1816d50:	e0bffd17 	ldw	r2,-12(fp)
 1816d54:	1080060b 	ldhu	r2,24(r2)
 1816d58:	10803c04 	addi	r2,r2,240
 1816d5c:	10bfffcc 	andi	r2,r2,65535
 1816d60:	100b883a 	mov	r5,r2
 1816d64:	1809883a 	mov	r4,r3
 1816d68:	181a9940 	call	181a994 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 1816d6c:	e0bffd17 	ldw	r2,-12(fp)
 1816d70:	10c00117 	ldw	r3,4(r2)
 1816d74:	e0bffd17 	ldw	r2,-12(fp)
 1816d78:	11000417 	ldw	r4,16(r2)
 1816d7c:	e0bffd17 	ldw	r2,-12(fp)
 1816d80:	11400804 	addi	r5,r2,32
 1816d84:	e0bfff17 	ldw	r2,-4(fp)
 1816d88:	d8800015 	stw	r2,0(sp)
 1816d8c:	01c010c4 	movi	r7,67
 1816d90:	280d883a 	mov	r6,r5
 1816d94:	200b883a 	mov	r5,r4
 1816d98:	1809883a 	mov	r4,r3
 1816d9c:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 1816da0:	e13ffd17 	ldw	r4,-12(fp)
 1816da4:	18188e00 	call	18188e0 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 1816da8:	e0bffd17 	ldw	r2,-12(fp)
 1816dac:	10800343 	ldbu	r2,13(r2)
 1816db0:	10800044 	addi	r2,r2,1
 1816db4:	1007883a 	mov	r3,r2
 1816db8:	e0bffd17 	ldw	r2,-12(fp)
 1816dbc:	10c00345 	stb	r3,13(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
 1816dc0:	e0bffd17 	ldw	r2,-12(fp)
 1816dc4:	10800343 	ldbu	r2,13(r2)
 1816dc8:	10803fcc 	andi	r2,r2,255
 1816dcc:	108002a8 	cmpgeui	r2,r2,10
 1816dd0:	1000051e 	bne	r2,zero,1816de8 <dhcp_renew+0x124>
 1816dd4:	e0bffd17 	ldw	r2,-12(fp)
 1816dd8:	10800343 	ldbu	r2,13(r2)
 1816ddc:	10803fcc 	andi	r2,r2,255
 1816de0:	1081f424 	muli	r2,r2,2000
 1816de4:	00000106 	br	1816dec <dhcp_renew+0x128>
 1816de8:	00938804 	movi	r2,20000
 1816dec:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1816df0:	e0bffe8b 	ldhu	r2,-6(fp)
 1816df4:	10807cc4 	addi	r2,r2,499
 1816df8:	01407d04 	movi	r5,500
 1816dfc:	1009883a 	mov	r4,r2
 1816e00:	180ac180 	call	180ac18 <__divsi3>
 1816e04:	1007883a 	mov	r3,r2
 1816e08:	e0bffd17 	ldw	r2,-12(fp)
 1816e0c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1816e10:	e0bffe03 	ldbu	r2,-8(fp)
}
 1816e14:	e037883a 	mov	sp,fp
 1816e18:	dfc00117 	ldw	ra,4(sp)
 1816e1c:	df000017 	ldw	fp,0(sp)
 1816e20:	dec00204 	addi	sp,sp,8
 1816e24:	f800283a 	ret

01816e28 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 1816e28:	defffa04 	addi	sp,sp,-24
 1816e2c:	dfc00515 	stw	ra,20(sp)
 1816e30:	df000415 	stw	fp,16(sp)
 1816e34:	df000404 	addi	fp,sp,16
 1816e38:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1816e3c:	e0bfff17 	ldw	r2,-4(fp)
 1816e40:	10800a17 	ldw	r2,40(r2)
 1816e44:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
 1816e48:	01400104 	movi	r5,4
 1816e4c:	e13ffd17 	ldw	r4,-12(fp)
 1816e50:	18173840 	call	1817384 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 1816e54:	018000c4 	movi	r6,3
 1816e58:	e17ffd17 	ldw	r5,-12(fp)
 1816e5c:	e13fff17 	ldw	r4,-4(fp)
 1816e60:	181835c0 	call	181835c <dhcp_create_msg>
 1816e64:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 1816e68:	e0bffe07 	ldb	r2,-8(fp)
 1816e6c:	1000251e 	bne	r2,zero,1816f04 <dhcp_rebind+0xdc>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 1816e70:	01800084 	movi	r6,2
 1816e74:	01400e44 	movi	r5,57
 1816e78:	e13ffd17 	ldw	r4,-12(fp)
 1816e7c:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 1816e80:	e0bfff17 	ldw	r2,-4(fp)
 1816e84:	10800c0b 	ldhu	r2,48(r2)
 1816e88:	10bfffcc 	andi	r2,r2,65535
 1816e8c:	100b883a 	mov	r5,r2
 1816e90:	e13ffd17 	ldw	r4,-12(fp)
 1816e94:	18174dc0 	call	18174dc <dhcp_option_short>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 1816e98:	e17fff17 	ldw	r5,-4(fp)
 1816e9c:	e13ffd17 	ldw	r4,-12(fp)
 1816ea0:	18176800 	call	1817680 <dhcp_option_hostname>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
 1816ea4:	e13ffd17 	ldw	r4,-12(fp)
 1816ea8:	18189640 	call	1818964 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 1816eac:	e0bffd17 	ldw	r2,-12(fp)
 1816eb0:	10c00417 	ldw	r3,16(r2)
 1816eb4:	e0bffd17 	ldw	r2,-12(fp)
 1816eb8:	1080060b 	ldhu	r2,24(r2)
 1816ebc:	10803c04 	addi	r2,r2,240
 1816ec0:	10bfffcc 	andi	r2,r2,65535
 1816ec4:	100b883a 	mov	r5,r2
 1816ec8:	1809883a 	mov	r4,r3
 1816ecc:	181a9940 	call	181a994 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 1816ed0:	e0bffd17 	ldw	r2,-12(fp)
 1816ed4:	10c00117 	ldw	r3,4(r2)
 1816ed8:	e0bffd17 	ldw	r2,-12(fp)
 1816edc:	11000417 	ldw	r4,16(r2)
 1816ee0:	e0bfff17 	ldw	r2,-4(fp)
 1816ee4:	d8800015 	stw	r2,0(sp)
 1816ee8:	01c010c4 	movi	r7,67
 1816eec:	d1a00e04 	addi	r6,gp,-32712
 1816ef0:	200b883a 	mov	r5,r4
 1816ef4:	1809883a 	mov	r4,r3
 1816ef8:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 1816efc:	e13ffd17 	ldw	r4,-12(fp)
 1816f00:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 1816f04:	e0bffd17 	ldw	r2,-12(fp)
 1816f08:	10800343 	ldbu	r2,13(r2)
 1816f0c:	10800044 	addi	r2,r2,1
 1816f10:	1007883a 	mov	r3,r2
 1816f14:	e0bffd17 	ldw	r2,-12(fp)
 1816f18:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 1816f1c:	e0bffd17 	ldw	r2,-12(fp)
 1816f20:	10800343 	ldbu	r2,13(r2)
 1816f24:	10803fcc 	andi	r2,r2,255
 1816f28:	108002a8 	cmpgeui	r2,r2,10
 1816f2c:	1000051e 	bne	r2,zero,1816f44 <dhcp_rebind+0x11c>
 1816f30:	e0bffd17 	ldw	r2,-12(fp)
 1816f34:	10800343 	ldbu	r2,13(r2)
 1816f38:	10803fcc 	andi	r2,r2,255
 1816f3c:	1080fa24 	muli	r2,r2,1000
 1816f40:	00000106 	br	1816f48 <dhcp_rebind+0x120>
 1816f44:	0089c404 	movi	r2,10000
 1816f48:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1816f4c:	e0bffe8b 	ldhu	r2,-6(fp)
 1816f50:	10807cc4 	addi	r2,r2,499
 1816f54:	01407d04 	movi	r5,500
 1816f58:	1009883a 	mov	r4,r2
 1816f5c:	180ac180 	call	180ac18 <__divsi3>
 1816f60:	1007883a 	mov	r3,r2
 1816f64:	e0bffd17 	ldw	r2,-12(fp)
 1816f68:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1816f6c:	e0bffe03 	ldbu	r2,-8(fp)
}
 1816f70:	e037883a 	mov	sp,fp
 1816f74:	dfc00117 	ldw	ra,4(sp)
 1816f78:	df000017 	ldw	fp,0(sp)
 1816f7c:	dec00204 	addi	sp,sp,8
 1816f80:	f800283a 	ret

01816f84 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 1816f84:	defffa04 	addi	sp,sp,-24
 1816f88:	dfc00515 	stw	ra,20(sp)
 1816f8c:	df000415 	stw	fp,16(sp)
 1816f90:	df000404 	addi	fp,sp,16
 1816f94:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 1816f98:	e0bfff17 	ldw	r2,-4(fp)
 1816f9c:	10800a17 	ldw	r2,40(r2)
 1816fa0:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
 1816fa4:	014000c4 	movi	r5,3
 1816fa8:	e13ffd17 	ldw	r4,-12(fp)
 1816fac:	18173840 	call	1817384 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 1816fb0:	018000c4 	movi	r6,3
 1816fb4:	e17ffd17 	ldw	r5,-12(fp)
 1816fb8:	e13fff17 	ldw	r4,-4(fp)
 1816fbc:	181835c0 	call	181835c <dhcp_create_msg>
 1816fc0:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 1816fc4:	e0bffe07 	ldb	r2,-8(fp)
 1816fc8:	1000371e 	bne	r2,zero,18170a8 <dhcp_reboot+0x124>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 1816fcc:	01800084 	movi	r6,2
 1816fd0:	01400e44 	movi	r5,57
 1816fd4:	e13ffd17 	ldw	r4,-12(fp)
 1816fd8:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_short(dhcp, 576);
 1816fdc:	01409004 	movi	r5,576
 1816fe0:	e13ffd17 	ldw	r4,-12(fp)
 1816fe4:	18174dc0 	call	18174dc <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 1816fe8:	01800104 	movi	r6,4
 1816fec:	01400c84 	movi	r5,50
 1816ff0:	e13ffd17 	ldw	r4,-12(fp)
 1816ff4:	18173e00 	call	18173e0 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 1816ff8:	e0bffd17 	ldw	r2,-12(fp)
 1816ffc:	10800917 	ldw	r2,36(r2)
 1817000:	1006d63a 	srli	r3,r2,24
 1817004:	e0bffd17 	ldw	r2,-12(fp)
 1817008:	10800917 	ldw	r2,36(r2)
 181700c:	1004d23a 	srli	r2,r2,8
 1817010:	10bfc00c 	andi	r2,r2,65280
 1817014:	1886b03a 	or	r3,r3,r2
 1817018:	e0bffd17 	ldw	r2,-12(fp)
 181701c:	10800917 	ldw	r2,36(r2)
 1817020:	10bfc00c 	andi	r2,r2,65280
 1817024:	1004923a 	slli	r2,r2,8
 1817028:	1886b03a 	or	r3,r3,r2
 181702c:	e0bffd17 	ldw	r2,-12(fp)
 1817030:	10800917 	ldw	r2,36(r2)
 1817034:	1004963a 	slli	r2,r2,24
 1817038:	1884b03a 	or	r2,r3,r2
 181703c:	100b883a 	mov	r5,r2
 1817040:	e13ffd17 	ldw	r4,-12(fp)
 1817044:	18175740 	call	1817574 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
 1817048:	e13ffd17 	ldw	r4,-12(fp)
 181704c:	18189640 	call	1818964 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 1817050:	e0bffd17 	ldw	r2,-12(fp)
 1817054:	10c00417 	ldw	r3,16(r2)
 1817058:	e0bffd17 	ldw	r2,-12(fp)
 181705c:	1080060b 	ldhu	r2,24(r2)
 1817060:	10803c04 	addi	r2,r2,240
 1817064:	10bfffcc 	andi	r2,r2,65535
 1817068:	100b883a 	mov	r5,r2
 181706c:	1809883a 	mov	r4,r3
 1817070:	181a9940 	call	181a994 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 1817074:	e0bffd17 	ldw	r2,-12(fp)
 1817078:	10c00117 	ldw	r3,4(r2)
 181707c:	e0bffd17 	ldw	r2,-12(fp)
 1817080:	11000417 	ldw	r4,16(r2)
 1817084:	e0bfff17 	ldw	r2,-4(fp)
 1817088:	d8800015 	stw	r2,0(sp)
 181708c:	01c010c4 	movi	r7,67
 1817090:	d1a00e04 	addi	r6,gp,-32712
 1817094:	200b883a 	mov	r5,r4
 1817098:	1809883a 	mov	r4,r3
 181709c:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 18170a0:	e13ffd17 	ldw	r4,-12(fp)
 18170a4:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 18170a8:	e0bffd17 	ldw	r2,-12(fp)
 18170ac:	10800343 	ldbu	r2,13(r2)
 18170b0:	10800044 	addi	r2,r2,1
 18170b4:	1007883a 	mov	r3,r2
 18170b8:	e0bffd17 	ldw	r2,-12(fp)
 18170bc:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 18170c0:	e0bffd17 	ldw	r2,-12(fp)
 18170c4:	10800343 	ldbu	r2,13(r2)
 18170c8:	10803fcc 	andi	r2,r2,255
 18170cc:	108002a8 	cmpgeui	r2,r2,10
 18170d0:	1000051e 	bne	r2,zero,18170e8 <dhcp_reboot+0x164>
 18170d4:	e0bffd17 	ldw	r2,-12(fp)
 18170d8:	10800343 	ldbu	r2,13(r2)
 18170dc:	10803fcc 	andi	r2,r2,255
 18170e0:	1080fa24 	muli	r2,r2,1000
 18170e4:	00000106 	br	18170ec <dhcp_reboot+0x168>
 18170e8:	0089c404 	movi	r2,10000
 18170ec:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 18170f0:	e0bffe8b 	ldhu	r2,-6(fp)
 18170f4:	10807cc4 	addi	r2,r2,499
 18170f8:	01407d04 	movi	r5,500
 18170fc:	1009883a 	mov	r4,r2
 1817100:	180ac180 	call	180ac18 <__divsi3>
 1817104:	1007883a 	mov	r3,r2
 1817108:	e0bffd17 	ldw	r2,-12(fp)
 181710c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 1817110:	e0bffe03 	ldbu	r2,-8(fp)
}
 1817114:	e037883a 	mov	sp,fp
 1817118:	dfc00117 	ldw	ra,4(sp)
 181711c:	df000017 	ldw	fp,0(sp)
 1817120:	dec00204 	addi	sp,sp,8
 1817124:	f800283a 	ret

01817128 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
 1817128:	defffa04 	addi	sp,sp,-24
 181712c:	dfc00515 	stw	ra,20(sp)
 1817130:	df000415 	stw	fp,16(sp)
 1817134:	df000404 	addi	fp,sp,16
 1817138:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 181713c:	e0bfff17 	ldw	r2,-4(fp)
 1817140:	10800a17 	ldw	r2,40(r2)
 1817144:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
 1817148:	000b883a 	mov	r5,zero
 181714c:	e13ffd17 	ldw	r4,-12(fp)
 1817150:	18173840 	call	1817384 <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
 1817154:	e0bffd17 	ldw	r2,-12(fp)
 1817158:	10000815 	stw	zero,32(r2)
  ip_addr_set_zero(&dhcp->offered_ip_addr);
 181715c:	e0bffd17 	ldw	r2,-12(fp)
 1817160:	10000915 	stw	zero,36(r2)
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 1817164:	e0bffd17 	ldw	r2,-12(fp)
 1817168:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 181716c:	e0bffd17 	ldw	r2,-12(fp)
 1817170:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 1817174:	e0bffd17 	ldw	r2,-12(fp)
 1817178:	10000e15 	stw	zero,56(r2)
 181717c:	e0bffd17 	ldw	r2,-12(fp)
 1817180:	10c00e17 	ldw	r3,56(r2)
 1817184:	e0bffd17 	ldw	r2,-12(fp)
 1817188:	10c00d15 	stw	r3,52(r2)
 181718c:	e0bffd17 	ldw	r2,-12(fp)
 1817190:	10c00d17 	ldw	r3,52(r2)
 1817194:	e0bffd17 	ldw	r2,-12(fp)
 1817198:	10c00c15 	stw	r3,48(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
 181719c:	018001c4 	movi	r6,7
 18171a0:	e17ffd17 	ldw	r5,-12(fp)
 18171a4:	e13fff17 	ldw	r4,-4(fp)
 18171a8:	181835c0 	call	181835c <dhcp_create_msg>
 18171ac:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 18171b0:	e0bffe07 	ldb	r2,-8(fp)
 18171b4:	10001a1e 	bne	r2,zero,1817220 <dhcp_release+0xf8>
    dhcp_option_trailer(dhcp);
 18171b8:	e13ffd17 	ldw	r4,-12(fp)
 18171bc:	18189640 	call	1818964 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 18171c0:	e0bffd17 	ldw	r2,-12(fp)
 18171c4:	10c00417 	ldw	r3,16(r2)
 18171c8:	e0bffd17 	ldw	r2,-12(fp)
 18171cc:	1080060b 	ldhu	r2,24(r2)
 18171d0:	10803c04 	addi	r2,r2,240
 18171d4:	10bfffcc 	andi	r2,r2,65535
 18171d8:	100b883a 	mov	r5,r2
 18171dc:	1809883a 	mov	r4,r3
 18171e0:	181a9940 	call	181a994 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 18171e4:	e0bffd17 	ldw	r2,-12(fp)
 18171e8:	10c00117 	ldw	r3,4(r2)
 18171ec:	e0bffd17 	ldw	r2,-12(fp)
 18171f0:	11000417 	ldw	r4,16(r2)
 18171f4:	e0bffd17 	ldw	r2,-12(fp)
 18171f8:	11400804 	addi	r5,r2,32
 18171fc:	e0bfff17 	ldw	r2,-4(fp)
 1817200:	d8800015 	stw	r2,0(sp)
 1817204:	01c010c4 	movi	r7,67
 1817208:	280d883a 	mov	r6,r5
 181720c:	200b883a 	mov	r5,r4
 1817210:	1809883a 	mov	r4,r3
 1817214:	182240c0 	call	182240c <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 1817218:	e13ffd17 	ldw	r4,-12(fp)
 181721c:	18188e00 	call	18188e0 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 1817220:	e0bffd17 	ldw	r2,-12(fp)
 1817224:	10800343 	ldbu	r2,13(r2)
 1817228:	10800044 	addi	r2,r2,1
 181722c:	1007883a 	mov	r3,r2
 1817230:	e0bffd17 	ldw	r2,-12(fp)
 1817234:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 1817238:	e0bffd17 	ldw	r2,-12(fp)
 181723c:	10800343 	ldbu	r2,13(r2)
 1817240:	10803fcc 	andi	r2,r2,255
 1817244:	108002a8 	cmpgeui	r2,r2,10
 1817248:	1000051e 	bne	r2,zero,1817260 <dhcp_release+0x138>
 181724c:	e0bffd17 	ldw	r2,-12(fp)
 1817250:	10800343 	ldbu	r2,13(r2)
 1817254:	10803fcc 	andi	r2,r2,255
 1817258:	1080fa24 	muli	r2,r2,1000
 181725c:	00000106 	br	1817264 <dhcp_release+0x13c>
 1817260:	0089c404 	movi	r2,10000
 1817264:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 1817268:	e0bffe8b 	ldhu	r2,-6(fp)
 181726c:	10807cc4 	addi	r2,r2,499
 1817270:	01407d04 	movi	r5,500
 1817274:	1009883a 	mov	r4,r2
 1817278:	180ac180 	call	180ac18 <__divsi3>
 181727c:	1007883a 	mov	r3,r2
 1817280:	e0bffd17 	ldw	r2,-12(fp)
 1817284:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
 1817288:	e13fff17 	ldw	r4,-4(fp)
 181728c:	181a1500 	call	181a150 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 1817290:	d1600d04 	addi	r5,gp,-32716
 1817294:	e13fff17 	ldw	r4,-4(fp)
 1817298:	1819ebc0 	call	1819ebc <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 181729c:	d1600d04 	addi	r5,gp,-32716
 18172a0:	e13fff17 	ldw	r4,-4(fp)
 18172a4:	1819fe40 	call	1819fe4 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
 18172a8:	d1600d04 	addi	r5,gp,-32716
 18172ac:	e13fff17 	ldw	r4,-4(fp)
 18172b0:	181a02c0 	call	181a02c <netif_set_netmask>
  
  return result;
 18172b4:	e0bffe03 	ldbu	r2,-8(fp)
}
 18172b8:	e037883a 	mov	sp,fp
 18172bc:	dfc00117 	ldw	ra,4(sp)
 18172c0:	df000017 	ldw	fp,0(sp)
 18172c4:	dec00204 	addi	sp,sp,8
 18172c8:	f800283a 	ret

018172cc <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
 18172cc:	defffc04 	addi	sp,sp,-16
 18172d0:	dfc00315 	stw	ra,12(sp)
 18172d4:	df000215 	stw	fp,8(sp)
 18172d8:	df000204 	addi	fp,sp,8
 18172dc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
 18172e0:	e0bfff17 	ldw	r2,-4(fp)
 18172e4:	1000091e 	bne	r2,zero,181730c <dhcp_stop+0x40>
 18172e8:	01c06134 	movhi	r7,388
 18172ec:	39c5ea04 	addi	r7,r7,6056
 18172f0:	01813504 	movi	r6,1236
 18172f4:	01406134 	movhi	r5,388
 18172f8:	29460d04 	addi	r5,r5,6196
 18172fc:	01006134 	movhi	r4,388
 1817300:	2105f404 	addi	r4,r4,6096
 1817304:	1800c180 	call	1800c18 <printf>
 1817308:	003fff06 	br	1817308 <__ram_exceptions_end+0xff806ec4>
  dhcp = netif->dhcp;
 181730c:	e0bfff17 	ldw	r2,-4(fp)
 1817310:	10800a17 	ldw	r2,40(r2)
 1817314:	e0bffe15 	stw	r2,-8(fp)
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 1817318:	e0bfff17 	ldw	r2,-4(fp)
 181731c:	10c00e43 	ldbu	r3,57(r2)
 1817320:	00bffdc4 	movi	r2,-9
 1817324:	1884703a 	and	r2,r3,r2
 1817328:	1007883a 	mov	r3,r2
 181732c:	e0bfff17 	ldw	r2,-4(fp)
 1817330:	10c00e45 	stb	r3,57(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
 1817334:	e0bffe17 	ldw	r2,-8(fp)
 1817338:	10000c26 	beq	r2,zero,181736c <dhcp_stop+0xa0>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
 181733c:	e0bffe17 	ldw	r2,-8(fp)
 1817340:	10800117 	ldw	r2,4(r2)
 1817344:	10000626 	beq	r2,zero,1817360 <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
 1817348:	e0bffe17 	ldw	r2,-8(fp)
 181734c:	10800117 	ldw	r2,4(r2)
 1817350:	1009883a 	mov	r4,r2
 1817354:	1822bb80 	call	1822bb8 <udp_remove>
      dhcp->pcb = NULL;
 1817358:	e0bffe17 	ldw	r2,-8(fp)
 181735c:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    dhcp_set_state(dhcp, DHCP_OFF);
 1817360:	000b883a 	mov	r5,zero
 1817364:	e13ffe17 	ldw	r4,-8(fp)
 1817368:	18173840 	call	1817384 <dhcp_set_state>
  }
}
 181736c:	0001883a 	nop
 1817370:	e037883a 	mov	sp,fp
 1817374:	dfc00117 	ldw	ra,4(sp)
 1817378:	df000017 	ldw	fp,0(sp)
 181737c:	dec00204 	addi	sp,sp,8
 1817380:	f800283a 	ret

01817384 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
 1817384:	defffd04 	addi	sp,sp,-12
 1817388:	df000215 	stw	fp,8(sp)
 181738c:	df000204 	addi	fp,sp,8
 1817390:	e13ffe15 	stw	r4,-8(fp)
 1817394:	2805883a 	mov	r2,r5
 1817398:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
 181739c:	e0bffe17 	ldw	r2,-8(fp)
 18173a0:	10800303 	ldbu	r2,12(r2)
 18173a4:	10c03fcc 	andi	r3,r2,255
 18173a8:	e0bfff03 	ldbu	r2,-4(fp)
 18173ac:	18800726 	beq	r3,r2,18173cc <dhcp_set_state+0x48>
    dhcp->state = new_state;
 18173b0:	e0bffe17 	ldw	r2,-8(fp)
 18173b4:	e0ffff03 	ldbu	r3,-4(fp)
 18173b8:	10c00305 	stb	r3,12(r2)
    dhcp->tries = 0;
 18173bc:	e0bffe17 	ldw	r2,-8(fp)
 18173c0:	10000345 	stb	zero,13(r2)
    dhcp->request_timeout = 0;
 18173c4:	e0bffe17 	ldw	r2,-8(fp)
 18173c8:	1000068d 	sth	zero,26(r2)
  }
}
 18173cc:	0001883a 	nop
 18173d0:	e037883a 	mov	sp,fp
 18173d4:	df000017 	ldw	fp,0(sp)
 18173d8:	dec00104 	addi	sp,sp,4
 18173dc:	f800283a 	ret

018173e0 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
 18173e0:	defffc04 	addi	sp,sp,-16
 18173e4:	df000315 	stw	fp,12(sp)
 18173e8:	df000304 	addi	fp,sp,12
 18173ec:	e13ffd15 	stw	r4,-12(fp)
 18173f0:	2807883a 	mov	r3,r5
 18173f4:	3005883a 	mov	r2,r6
 18173f8:	e0fffe05 	stb	r3,-8(fp)
 18173fc:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 1817400:	e0bffd17 	ldw	r2,-12(fp)
 1817404:	10c00517 	ldw	r3,20(r2)
 1817408:	e0bffd17 	ldw	r2,-12(fp)
 181740c:	1080060b 	ldhu	r2,24(r2)
 1817410:	11000044 	addi	r4,r2,1
 1817414:	200b883a 	mov	r5,r4
 1817418:	e13ffd17 	ldw	r4,-12(fp)
 181741c:	2140060d 	sth	r5,24(r4)
 1817420:	10bfffcc 	andi	r2,r2,65535
 1817424:	1885883a 	add	r2,r3,r2
 1817428:	10803c04 	addi	r2,r2,240
 181742c:	e0fffe03 	ldbu	r3,-8(fp)
 1817430:	10c00005 	stb	r3,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 1817434:	e0bffd17 	ldw	r2,-12(fp)
 1817438:	10c00517 	ldw	r3,20(r2)
 181743c:	e0bffd17 	ldw	r2,-12(fp)
 1817440:	1080060b 	ldhu	r2,24(r2)
 1817444:	11000044 	addi	r4,r2,1
 1817448:	200b883a 	mov	r5,r4
 181744c:	e13ffd17 	ldw	r4,-12(fp)
 1817450:	2140060d 	sth	r5,24(r4)
 1817454:	10bfffcc 	andi	r2,r2,65535
 1817458:	1885883a 	add	r2,r3,r2
 181745c:	10803c04 	addi	r2,r2,240
 1817460:	e0ffff03 	ldbu	r3,-4(fp)
 1817464:	10c00005 	stb	r3,0(r2)
}
 1817468:	0001883a 	nop
 181746c:	e037883a 	mov	sp,fp
 1817470:	df000017 	ldw	fp,0(sp)
 1817474:	dec00104 	addi	sp,sp,4
 1817478:	f800283a 	ret

0181747c <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
 181747c:	defffd04 	addi	sp,sp,-12
 1817480:	df000215 	stw	fp,8(sp)
 1817484:	df000204 	addi	fp,sp,8
 1817488:	e13ffe15 	stw	r4,-8(fp)
 181748c:	2805883a 	mov	r2,r5
 1817490:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 1817494:	e0bffe17 	ldw	r2,-8(fp)
 1817498:	10c00517 	ldw	r3,20(r2)
 181749c:	e0bffe17 	ldw	r2,-8(fp)
 18174a0:	1080060b 	ldhu	r2,24(r2)
 18174a4:	11000044 	addi	r4,r2,1
 18174a8:	200b883a 	mov	r5,r4
 18174ac:	e13ffe17 	ldw	r4,-8(fp)
 18174b0:	2140060d 	sth	r5,24(r4)
 18174b4:	10bfffcc 	andi	r2,r2,65535
 18174b8:	1885883a 	add	r2,r3,r2
 18174bc:	10803c04 	addi	r2,r2,240
 18174c0:	e0ffff03 	ldbu	r3,-4(fp)
 18174c4:	10c00005 	stb	r3,0(r2)
}
 18174c8:	0001883a 	nop
 18174cc:	e037883a 	mov	sp,fp
 18174d0:	df000017 	ldw	fp,0(sp)
 18174d4:	dec00104 	addi	sp,sp,4
 18174d8:	f800283a 	ret

018174dc <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
 18174dc:	defffd04 	addi	sp,sp,-12
 18174e0:	df000215 	stw	fp,8(sp)
 18174e4:	df000204 	addi	fp,sp,8
 18174e8:	e13ffe15 	stw	r4,-8(fp)
 18174ec:	2805883a 	mov	r2,r5
 18174f0:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 18174f4:	e0bffe17 	ldw	r2,-8(fp)
 18174f8:	10c00517 	ldw	r3,20(r2)
 18174fc:	e0bffe17 	ldw	r2,-8(fp)
 1817500:	1080060b 	ldhu	r2,24(r2)
 1817504:	11000044 	addi	r4,r2,1
 1817508:	200b883a 	mov	r5,r4
 181750c:	e13ffe17 	ldw	r4,-8(fp)
 1817510:	2140060d 	sth	r5,24(r4)
 1817514:	10bfffcc 	andi	r2,r2,65535
 1817518:	e13fff0b 	ldhu	r4,-4(fp)
 181751c:	2008d23a 	srli	r4,r4,8
 1817520:	1885883a 	add	r2,r3,r2
 1817524:	10803c04 	addi	r2,r2,240
 1817528:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 181752c:	e0bffe17 	ldw	r2,-8(fp)
 1817530:	10c00517 	ldw	r3,20(r2)
 1817534:	e0bffe17 	ldw	r2,-8(fp)
 1817538:	1080060b 	ldhu	r2,24(r2)
 181753c:	11000044 	addi	r4,r2,1
 1817540:	200b883a 	mov	r5,r4
 1817544:	e13ffe17 	ldw	r4,-8(fp)
 1817548:	2140060d 	sth	r5,24(r4)
 181754c:	10bfffcc 	andi	r2,r2,65535
 1817550:	e13fff0b 	ldhu	r4,-4(fp)
 1817554:	1885883a 	add	r2,r3,r2
 1817558:	10803c04 	addi	r2,r2,240
 181755c:	11000005 	stb	r4,0(r2)
}
 1817560:	0001883a 	nop
 1817564:	e037883a 	mov	sp,fp
 1817568:	df000017 	ldw	fp,0(sp)
 181756c:	dec00104 	addi	sp,sp,4
 1817570:	f800283a 	ret

01817574 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
 1817574:	defffd04 	addi	sp,sp,-12
 1817578:	df000215 	stw	fp,8(sp)
 181757c:	df000204 	addi	fp,sp,8
 1817580:	e13ffe15 	stw	r4,-8(fp)
 1817584:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 1817588:	e0bffe17 	ldw	r2,-8(fp)
 181758c:	10c00517 	ldw	r3,20(r2)
 1817590:	e0bffe17 	ldw	r2,-8(fp)
 1817594:	1080060b 	ldhu	r2,24(r2)
 1817598:	11000044 	addi	r4,r2,1
 181759c:	200b883a 	mov	r5,r4
 18175a0:	e13ffe17 	ldw	r4,-8(fp)
 18175a4:	2140060d 	sth	r5,24(r4)
 18175a8:	10bfffcc 	andi	r2,r2,65535
 18175ac:	e13fff17 	ldw	r4,-4(fp)
 18175b0:	2008d63a 	srli	r4,r4,24
 18175b4:	1885883a 	add	r2,r3,r2
 18175b8:	10803c04 	addi	r2,r2,240
 18175bc:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 18175c0:	e0bffe17 	ldw	r2,-8(fp)
 18175c4:	10c00517 	ldw	r3,20(r2)
 18175c8:	e0bffe17 	ldw	r2,-8(fp)
 18175cc:	1080060b 	ldhu	r2,24(r2)
 18175d0:	11000044 	addi	r4,r2,1
 18175d4:	200b883a 	mov	r5,r4
 18175d8:	e13ffe17 	ldw	r4,-8(fp)
 18175dc:	2140060d 	sth	r5,24(r4)
 18175e0:	10bfffcc 	andi	r2,r2,65535
 18175e4:	e13fff17 	ldw	r4,-4(fp)
 18175e8:	21003fec 	andhi	r4,r4,255
 18175ec:	2008d43a 	srli	r4,r4,16
 18175f0:	1885883a 	add	r2,r3,r2
 18175f4:	10803c04 	addi	r2,r2,240
 18175f8:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 18175fc:	e0bffe17 	ldw	r2,-8(fp)
 1817600:	10c00517 	ldw	r3,20(r2)
 1817604:	e0bffe17 	ldw	r2,-8(fp)
 1817608:	1080060b 	ldhu	r2,24(r2)
 181760c:	11000044 	addi	r4,r2,1
 1817610:	200b883a 	mov	r5,r4
 1817614:	e13ffe17 	ldw	r4,-8(fp)
 1817618:	2140060d 	sth	r5,24(r4)
 181761c:	10bfffcc 	andi	r2,r2,65535
 1817620:	e13fff17 	ldw	r4,-4(fp)
 1817624:	213fc00c 	andi	r4,r4,65280
 1817628:	2008d23a 	srli	r4,r4,8
 181762c:	1885883a 	add	r2,r3,r2
 1817630:	10803c04 	addi	r2,r2,240
 1817634:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 1817638:	e0bffe17 	ldw	r2,-8(fp)
 181763c:	10c00517 	ldw	r3,20(r2)
 1817640:	e0bffe17 	ldw	r2,-8(fp)
 1817644:	1080060b 	ldhu	r2,24(r2)
 1817648:	11000044 	addi	r4,r2,1
 181764c:	200b883a 	mov	r5,r4
 1817650:	e13ffe17 	ldw	r4,-8(fp)
 1817654:	2140060d 	sth	r5,24(r4)
 1817658:	10bfffcc 	andi	r2,r2,65535
 181765c:	e13fff17 	ldw	r4,-4(fp)
 1817660:	1885883a 	add	r2,r3,r2
 1817664:	10803c04 	addi	r2,r2,240
 1817668:	11000005 	stb	r4,0(r2)
}
 181766c:	0001883a 	nop
 1817670:	e037883a 	mov	sp,fp
 1817674:	df000017 	ldw	fp,0(sp)
 1817678:	dec00104 	addi	sp,sp,4
 181767c:	f800283a 	ret

01817680 <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static void
dhcp_option_hostname(struct dhcp *dhcp, struct netif *netif)
{
 1817680:	defff804 	addi	sp,sp,-32
 1817684:	dfc00715 	stw	ra,28(sp)
 1817688:	df000615 	stw	fp,24(sp)
 181768c:	df000604 	addi	fp,sp,24
 1817690:	e13ffe15 	stw	r4,-8(fp)
 1817694:	e17fff15 	stw	r5,-4(fp)
  if (netif->hostname != NULL) {
 1817698:	e0bfff17 	ldw	r2,-4(fp)
 181769c:	10800b17 	ldw	r2,44(r2)
 18176a0:	10002826 	beq	r2,zero,1817744 <dhcp_option_hostname+0xc4>
    size_t namelen = strlen(netif->hostname);
 18176a4:	e0bfff17 	ldw	r2,-4(fp)
 18176a8:	10800b17 	ldw	r2,44(r2)
 18176ac:	1009883a 	mov	r4,r2
 18176b0:	18075d80 	call	18075d8 <strlen>
 18176b4:	e0bffc15 	stw	r2,-16(fp)
    if (namelen > 0) {
 18176b8:	e0bffc17 	ldw	r2,-16(fp)
 18176bc:	10002126 	beq	r2,zero,1817744 <dhcp_option_hostname+0xc4>
      u8_t len;
      const char *p = netif->hostname;
 18176c0:	e0bfff17 	ldw	r2,-4(fp)
 18176c4:	10800b17 	ldw	r2,44(r2)
 18176c8:	e0bffb15 	stw	r2,-20(fp)
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
 18176cc:	e0bffe17 	ldw	r2,-8(fp)
 18176d0:	1080060b 	ldhu	r2,24(r2)
 18176d4:	10bfffcc 	andi	r2,r2,65535
 18176d8:	00c01044 	movi	r3,65
 18176dc:	1885c83a 	sub	r2,r3,r2
 18176e0:	e0bffd15 	stw	r2,-12(fp)
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
 18176e4:	e0fffc17 	ldw	r3,-16(fp)
 18176e8:	e0bffd17 	ldw	r2,-12(fp)
 18176ec:	1880012e 	bgeu	r3,r2,18176f4 <dhcp_option_hostname+0x74>
 18176f0:	1805883a 	mov	r2,r3
 18176f4:	e0bffa05 	stb	r2,-24(fp)
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
 18176f8:	e0bffa03 	ldbu	r2,-24(fp)
 18176fc:	100d883a 	mov	r6,r2
 1817700:	01400304 	movi	r5,12
 1817704:	e13ffe17 	ldw	r4,-8(fp)
 1817708:	18173e00 	call	18173e0 <dhcp_option>
      while (len--) {
 181770c:	00000806 	br	1817730 <dhcp_option_hostname+0xb0>
        dhcp_option_byte(dhcp, *p++);
 1817710:	e0bffb17 	ldw	r2,-20(fp)
 1817714:	10c00044 	addi	r3,r2,1
 1817718:	e0fffb15 	stw	r3,-20(fp)
 181771c:	10800003 	ldbu	r2,0(r2)
 1817720:	10803fcc 	andi	r2,r2,255
 1817724:	100b883a 	mov	r5,r2
 1817728:	e13ffe17 	ldw	r4,-8(fp)
 181772c:	181747c0 	call	181747c <dhcp_option_byte>
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
      while (len--) {
 1817730:	e0bffa03 	ldbu	r2,-24(fp)
 1817734:	10ffffc4 	addi	r3,r2,-1
 1817738:	e0fffa05 	stb	r3,-24(fp)
 181773c:	10803fcc 	andi	r2,r2,255
 1817740:	103ff31e 	bne	r2,zero,1817710 <__ram_exceptions_end+0xff8072cc>
        dhcp_option_byte(dhcp, *p++);
      }
    }
  }
}
 1817744:	0001883a 	nop
 1817748:	e037883a 	mov	sp,fp
 181774c:	dfc00117 	ldw	ra,4(sp)
 1817750:	df000017 	ldw	fp,0(sp)
 1817754:	dec00204 	addi	sp,sp,8
 1817758:	f800283a 	ret

0181775c <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
 181775c:	defff004 	addi	sp,sp,-64
 1817760:	dfc00f15 	stw	ra,60(sp)
 1817764:	df000e15 	stw	fp,56(sp)
 1817768:	df000e04 	addi	fp,sp,56
 181776c:	e13ffe15 	stw	r4,-8(fp)
 1817770:	e17fff15 	stw	r5,-4(fp)
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
 1817774:	e03ff615 	stw	zero,-40(fp)
  int parse_sname_as_options = 0;
 1817778:	e03ff715 	stw	zero,-36(fp)

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 181777c:	01800284 	movi	r6,10
 1817780:	000b883a 	mov	r5,zero
 1817784:	010061b4 	movhi	r4,390
 1817788:	2109c204 	addi	r4,r4,9992
 181778c:	18061d40 	call	18061d4 <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 1817790:	e0bfff17 	ldw	r2,-4(fp)
 1817794:	1080028b 	ldhu	r2,10(r2)
 1817798:	10bfffcc 	andi	r2,r2,65535
 181779c:	10800b28 	cmpgeui	r2,r2,44
 18177a0:	1000021e 	bne	r2,zero,18177ac <dhcp_parse_reply+0x50>
    return ERR_BUF;
 18177a4:	00bfff84 	movi	r2,-2
 18177a8:	00021106 	br	1817ff0 <dhcp_parse_reply+0x894>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
 18177ac:	e0bfff17 	ldw	r2,-4(fp)
 18177b0:	10c00117 	ldw	r3,4(r2)
 18177b4:	e0bffe17 	ldw	r2,-8(fp)
 18177b8:	10c00215 	stw	r3,8(r2)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
 18177bc:	00803c04 	movi	r2,240
 18177c0:	e0bff40d 	sth	r2,-48(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 18177c4:	e0bfff17 	ldw	r2,-4(fp)
 18177c8:	1080020b 	ldhu	r2,8(r2)
 18177cc:	e0bff48d 	sth	r2,-46(fp)
again:
  q = p;
 18177d0:	e0bfff17 	ldw	r2,-4(fp)
 18177d4:	e0bff515 	stw	r2,-44(fp)
  while((q != NULL) && (options_idx >= q->len)) {
 18177d8:	00000d06 	br	1817810 <dhcp_parse_reply+0xb4>
    options_idx -= q->len;
 18177dc:	e0bff517 	ldw	r2,-44(fp)
 18177e0:	1080028b 	ldhu	r2,10(r2)
 18177e4:	e0fff40b 	ldhu	r3,-48(fp)
 18177e8:	1885c83a 	sub	r2,r3,r2
 18177ec:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max -= q->len;
 18177f0:	e0bff517 	ldw	r2,-44(fp)
 18177f4:	1080028b 	ldhu	r2,10(r2)
 18177f8:	e0fff48b 	ldhu	r3,-46(fp)
 18177fc:	1885c83a 	sub	r2,r3,r2
 1817800:	e0bff48d 	sth	r2,-46(fp)
    q = q->next;
 1817804:	e0bff517 	ldw	r2,-44(fp)
 1817808:	10800017 	ldw	r2,0(r2)
 181780c:	e0bff515 	stw	r2,-44(fp)
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
 1817810:	e0bff517 	ldw	r2,-44(fp)
 1817814:	10000526 	beq	r2,zero,181782c <dhcp_parse_reply+0xd0>
 1817818:	e0bff517 	ldw	r2,-44(fp)
 181781c:	1080028b 	ldhu	r2,10(r2)
 1817820:	10bfffcc 	andi	r2,r2,65535
 1817824:	e0fff40b 	ldhu	r3,-48(fp)
 1817828:	18bfec2e 	bgeu	r3,r2,18177dc <__ram_exceptions_end+0xff807398>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == NULL) {
 181782c:	e0bff517 	ldw	r2,-44(fp)
 1817830:	1000021e 	bne	r2,zero,181783c <dhcp_parse_reply+0xe0>
    return ERR_BUF;
 1817834:	00bfff84 	movi	r2,-2
 1817838:	0001ed06 	br	1817ff0 <dhcp_parse_reply+0x894>
  }
  offset = options_idx;
 181783c:	e0bff40b 	ldhu	r2,-48(fp)
 1817840:	e0bff30d 	sth	r2,-52(fp)
  offset_max = options_idx_max;
 1817844:	e0bff48b 	ldhu	r2,-46(fp)
 1817848:	e0bff38d 	sth	r2,-50(fp)
  options = (u8_t*)q->payload;
 181784c:	e0bff517 	ldw	r2,-44(fp)
 1817850:	10800117 	ldw	r2,4(r2)
 1817854:	e0bff215 	stw	r2,-56(fp)
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
 1817858:	0001a906 	br	1817f00 <dhcp_parse_reply+0x7a4>
    u8_t op = options[offset];
 181785c:	e0bff30b 	ldhu	r2,-52(fp)
 1817860:	e0fff217 	ldw	r3,-56(fp)
 1817864:	1885883a 	add	r2,r3,r2
 1817868:	10800003 	ldbu	r2,0(r2)
 181786c:	e0bffa85 	stb	r2,-22(fp)
    u8_t len;
    u8_t decode_len = 0;
 1817870:	e03ff845 	stb	zero,-31(fp)
    int decode_idx = -1;
 1817874:	00bfffc4 	movi	r2,-1
 1817878:	e0bff915 	stw	r2,-28(fp)
    u16_t val_offset = offset + 2;
 181787c:	e0bff30b 	ldhu	r2,-52(fp)
 1817880:	10800084 	addi	r2,r2,2
 1817884:	e0bffa0d 	sth	r2,-24(fp)
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
 1817888:	e0bff30b 	ldhu	r2,-52(fp)
 181788c:	10c00044 	addi	r3,r2,1
 1817890:	e0bff517 	ldw	r2,-44(fp)
 1817894:	1080028b 	ldhu	r2,10(r2)
 1817898:	10bfffcc 	andi	r2,r2,65535
 181789c:	1880070e 	bge	r3,r2,18178bc <dhcp_parse_reply+0x160>
      len = options[offset + 1];
 18178a0:	e0bff30b 	ldhu	r2,-52(fp)
 18178a4:	10800044 	addi	r2,r2,1
 18178a8:	e0fff217 	ldw	r3,-56(fp)
 18178ac:	1885883a 	add	r2,r3,r2
 18178b0:	10800003 	ldbu	r2,0(r2)
 18178b4:	e0bff805 	stb	r2,-32(fp)
 18178b8:	00000a06 	br	18178e4 <dhcp_parse_reply+0x188>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
 18178bc:	e0bff517 	ldw	r2,-44(fp)
 18178c0:	10800017 	ldw	r2,0(r2)
 18178c4:	10000526 	beq	r2,zero,18178dc <dhcp_parse_reply+0x180>
 18178c8:	e0bff517 	ldw	r2,-44(fp)
 18178cc:	10800017 	ldw	r2,0(r2)
 18178d0:	10800117 	ldw	r2,4(r2)
 18178d4:	10800003 	ldbu	r2,0(r2)
 18178d8:	00000106 	br	18178e0 <dhcp_parse_reply+0x184>
 18178dc:	0005883a 	mov	r2,zero
 18178e0:	e0bff805 	stb	r2,-32(fp)
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
 18178e4:	e0bff803 	ldbu	r2,-32(fp)
 18178e8:	e0bff845 	stb	r2,-31(fp)
    switch(op) {
 18178ec:	e0bffa83 	ldbu	r2,-22(fp)
 18178f0:	10c00f28 	cmpgeui	r3,r2,60
 18178f4:	1800e41e 	bne	r3,zero,1817c88 <dhcp_parse_reply+0x52c>
 18178f8:	100690ba 	slli	r3,r2,2
 18178fc:	00806074 	movhi	r2,385
 1817900:	109e4404 	addi	r2,r2,30992
 1817904:	1885883a 	add	r2,r3,r2
 1817908:	10800017 	ldw	r2,0(r2)
 181790c:	1000683a 	jmp	r2
 1817910:	01817a00 	call	1817a0 <__alt_mem_tse_descriptor_memory_0+0x1817a0>
 1817914:	01817a1c 	xori	r6,zero,1512
 1817918:	01817c88 	cmpgei	r6,zero,1522
 181791c:	01817a58 	cmpnei	r6,zero,1513
 1817920:	01817c88 	cmpgei	r6,zero,1522
 1817924:	01817c88 	cmpgei	r6,zero,1522
 1817928:	01817a9c 	xori	r6,zero,1514
 181792c:	01817c88 	cmpgei	r6,zero,1522
 1817930:	01817c88 	cmpgei	r6,zero,1522
 1817934:	01817c88 	cmpgei	r6,zero,1522
 1817938:	01817c88 	cmpgei	r6,zero,1522
 181793c:	01817c88 	cmpgei	r6,zero,1522
 1817940:	01817c88 	cmpgei	r6,zero,1522
 1817944:	01817c88 	cmpgei	r6,zero,1522
 1817948:	01817c88 	cmpgei	r6,zero,1522
 181794c:	01817c88 	cmpgei	r6,zero,1522
 1817950:	01817c88 	cmpgei	r6,zero,1522
 1817954:	01817c88 	cmpgei	r6,zero,1522
 1817958:	01817c88 	cmpgei	r6,zero,1522
 181795c:	01817c88 	cmpgei	r6,zero,1522
 1817960:	01817c88 	cmpgei	r6,zero,1522
 1817964:	01817c88 	cmpgei	r6,zero,1522
 1817968:	01817c88 	cmpgei	r6,zero,1522
 181796c:	01817c88 	cmpgei	r6,zero,1522
 1817970:	01817c88 	cmpgei	r6,zero,1522
 1817974:	01817c88 	cmpgei	r6,zero,1522
 1817978:	01817c88 	cmpgei	r6,zero,1522
 181797c:	01817c88 	cmpgei	r6,zero,1522
 1817980:	01817c88 	cmpgei	r6,zero,1522
 1817984:	01817c88 	cmpgei	r6,zero,1522
 1817988:	01817c88 	cmpgei	r6,zero,1522
 181798c:	01817c88 	cmpgei	r6,zero,1522
 1817990:	01817c88 	cmpgei	r6,zero,1522
 1817994:	01817c88 	cmpgei	r6,zero,1522
 1817998:	01817c88 	cmpgei	r6,zero,1522
 181799c:	01817c88 	cmpgei	r6,zero,1522
 18179a0:	01817c88 	cmpgei	r6,zero,1522
 18179a4:	01817c88 	cmpgei	r6,zero,1522
 18179a8:	01817c88 	cmpgei	r6,zero,1522
 18179ac:	01817c88 	cmpgei	r6,zero,1522
 18179b0:	01817c88 	cmpgei	r6,zero,1522
 18179b4:	01817c88 	cmpgei	r6,zero,1522
 18179b8:	01817c88 	cmpgei	r6,zero,1522
 18179bc:	01817c88 	cmpgei	r6,zero,1522
 18179c0:	01817c88 	cmpgei	r6,zero,1522
 18179c4:	01817c88 	cmpgei	r6,zero,1522
 18179c8:	01817c88 	cmpgei	r6,zero,1522
 18179cc:	01817c88 	cmpgei	r6,zero,1522
 18179d0:	01817c88 	cmpgei	r6,zero,1522
 18179d4:	01817c88 	cmpgei	r6,zero,1522
 18179d8:	01817c88 	cmpgei	r6,zero,1522
 18179dc:	01817b24 	muli	r6,zero,1516
 18179e0:	01817b60 	cmpeqi	r6,zero,1517
 18179e4:	01817b98 	cmpnei	r6,zero,1518
 18179e8:	01817bd4 	movui	r6,1519
 18179ec:	01817c88 	cmpgei	r6,zero,1522
 18179f0:	01817c88 	cmpgei	r6,zero,1522
 18179f4:	01817c88 	cmpgei	r6,zero,1522
 18179f8:	01817c10 	cmplti	r6,zero,1520
 18179fc:	01817c4c 	andi	r6,zero,1521
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
 1817a00:	e03ff805 	stb	zero,-32(fp)
 1817a04:	e0bff803 	ldbu	r2,-32(fp)
 1817a08:	e0bff845 	stb	r2,-31(fp)
        /* will be increased below */
        offset--;
 1817a0c:	e0bff30b 	ldhu	r2,-52(fp)
 1817a10:	10bfffc4 	addi	r2,r2,-1
 1817a14:	e0bff30d 	sth	r2,-52(fp)
        break;
 1817a18:	00009d06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 1817a1c:	e0bff803 	ldbu	r2,-32(fp)
 1817a20:	10800120 	cmpeqi	r2,r2,4
 1817a24:	1000091e 	bne	r2,zero,1817a4c <dhcp_parse_reply+0x2f0>
 1817a28:	01c06134 	movhi	r7,388
 1817a2c:	39c5ea04 	addi	r7,r7,6056
 1817a30:	01816204 	movi	r6,1416
 1817a34:	01406134 	movhi	r5,388
 1817a38:	29461404 	addi	r5,r5,6224
 1817a3c:	01006134 	movhi	r4,388
 1817a40:	2105f404 	addi	r4,r4,6096
 1817a44:	1800c180 	call	1800c18 <printf>
 1817a48:	003fff06 	br	1817a48 <__ram_exceptions_end+0xff807604>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
 1817a4c:	00800184 	movi	r2,6
 1817a50:	e0bff915 	stw	r2,-28(fp)
        break;
 1817a54:	00008e06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
 1817a58:	00800104 	movi	r2,4
 1817a5c:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 1817a60:	e0fff803 	ldbu	r3,-32(fp)
 1817a64:	e0bff843 	ldbu	r2,-31(fp)
 1817a68:	1880092e 	bgeu	r3,r2,1817a90 <dhcp_parse_reply+0x334>
 1817a6c:	01c06134 	movhi	r7,388
 1817a70:	39c5ea04 	addi	r7,r7,6056
 1817a74:	01816344 	movi	r6,1421
 1817a78:	01406134 	movhi	r5,388
 1817a7c:	29461704 	addi	r5,r5,6236
 1817a80:	01006134 	movhi	r4,388
 1817a84:	2105f404 	addi	r4,r4,6096
 1817a88:	1800c180 	call	1800c18 <printf>
 1817a8c:	003fff06 	br	1817a8c <__ram_exceptions_end+0xff807648>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
 1817a90:	008001c4 	movi	r2,7
 1817a94:	e0bff915 	stw	r2,-28(fp)
        break;
 1817a98:	00007d06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
 1817a9c:	e0bff803 	ldbu	r2,-32(fp)
 1817aa0:	108000cc 	andi	r2,r2,3
 1817aa4:	10803fcc 	andi	r2,r2,255
 1817aa8:	10000926 	beq	r2,zero,1817ad0 <dhcp_parse_reply+0x374>
 1817aac:	01c06134 	movhi	r7,388
 1817ab0:	39c5ea04 	addi	r7,r7,6056
 1817ab4:	01816484 	movi	r6,1426
 1817ab8:	01406134 	movhi	r5,388
 1817abc:	29461c04 	addi	r5,r5,6256
 1817ac0:	01006134 	movhi	r4,388
 1817ac4:	2105f404 	addi	r4,r4,6096
 1817ac8:	1800c180 	call	1800c18 <printf>
 1817acc:	003fff06 	br	1817acc <__ram_exceptions_end+0xff807688>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
 1817ad0:	e0bff803 	ldbu	r2,-32(fp)
 1817ad4:	10c03fcc 	andi	r3,r2,255
 1817ad8:	18c00270 	cmpltui	r3,r3,9
 1817adc:	1800011e 	bne	r3,zero,1817ae4 <dhcp_parse_reply+0x388>
 1817ae0:	00800204 	movi	r2,8
 1817ae4:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 1817ae8:	e0fff803 	ldbu	r3,-32(fp)
 1817aec:	e0bff843 	ldbu	r2,-31(fp)
 1817af0:	1880092e 	bgeu	r3,r2,1817b18 <dhcp_parse_reply+0x3bc>
 1817af4:	01c06134 	movhi	r7,388
 1817af8:	39c5ea04 	addi	r7,r7,6056
 1817afc:	01816544 	movi	r6,1429
 1817b00:	01406134 	movhi	r5,388
 1817b04:	29461704 	addi	r5,r5,6236
 1817b08:	01006134 	movhi	r4,388
 1817b0c:	2105f404 	addi	r4,r4,6096
 1817b10:	1800c180 	call	1800c18 <printf>
 1817b14:	003fff06 	br	1817b14 <__ram_exceptions_end+0xff8076d0>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
 1817b18:	00800204 	movi	r2,8
 1817b1c:	e0bff915 	stw	r2,-28(fp)
        break;
 1817b20:	00005b06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 1817b24:	e0bff803 	ldbu	r2,-32(fp)
 1817b28:	10800120 	cmpeqi	r2,r2,4
 1817b2c:	1000091e 	bne	r2,zero,1817b54 <dhcp_parse_reply+0x3f8>
 1817b30:	01c06134 	movhi	r7,388
 1817b34:	39c5ea04 	addi	r7,r7,6056
 1817b38:	01816644 	movi	r6,1433
 1817b3c:	01406134 	movhi	r5,388
 1817b40:	29461404 	addi	r5,r5,6224
 1817b44:	01006134 	movhi	r4,388
 1817b48:	2105f404 	addi	r4,r4,6096
 1817b4c:	1800c180 	call	1800c18 <printf>
 1817b50:	003fff06 	br	1817b50 <__ram_exceptions_end+0xff80770c>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
 1817b54:	008000c4 	movi	r2,3
 1817b58:	e0bff915 	stw	r2,-28(fp)
        break;
 1817b5c:	00004c06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 1817b60:	e0bff803 	ldbu	r2,-32(fp)
 1817b64:	10800060 	cmpeqi	r2,r2,1
 1817b68:	1000091e 	bne	r2,zero,1817b90 <dhcp_parse_reply+0x434>
 1817b6c:	01c06134 	movhi	r7,388
 1817b70:	39c5ea04 	addi	r7,r7,6056
 1817b74:	01816744 	movi	r6,1437
 1817b78:	01406134 	movhi	r5,388
 1817b7c:	29462004 	addi	r5,r5,6272
 1817b80:	01006134 	movhi	r4,388
 1817b84:	2105f404 	addi	r4,r4,6096
 1817b88:	1800c180 	call	1800c18 <printf>
 1817b8c:	003fff06 	br	1817b8c <__ram_exceptions_end+0xff807748>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
 1817b90:	e03ff915 	stw	zero,-28(fp)
        break;
 1817b94:	00003e06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 1817b98:	e0bff803 	ldbu	r2,-32(fp)
 1817b9c:	10800060 	cmpeqi	r2,r2,1
 1817ba0:	1000091e 	bne	r2,zero,1817bc8 <dhcp_parse_reply+0x46c>
 1817ba4:	01c06134 	movhi	r7,388
 1817ba8:	39c5ea04 	addi	r7,r7,6056
 1817bac:	01816844 	movi	r6,1441
 1817bb0:	01406134 	movhi	r5,388
 1817bb4:	29462004 	addi	r5,r5,6272
 1817bb8:	01006134 	movhi	r4,388
 1817bbc:	2105f404 	addi	r4,r4,6096
 1817bc0:	1800c180 	call	1800c18 <printf>
 1817bc4:	003fff06 	br	1817bc4 <__ram_exceptions_end+0xff807780>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
 1817bc8:	00800044 	movi	r2,1
 1817bcc:	e0bff915 	stw	r2,-28(fp)
        break;
 1817bd0:	00002f06 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 1817bd4:	e0bff803 	ldbu	r2,-32(fp)
 1817bd8:	10800120 	cmpeqi	r2,r2,4
 1817bdc:	1000091e 	bne	r2,zero,1817c04 <dhcp_parse_reply+0x4a8>
 1817be0:	01c06134 	movhi	r7,388
 1817be4:	39c5ea04 	addi	r7,r7,6056
 1817be8:	01816944 	movi	r6,1445
 1817bec:	01406134 	movhi	r5,388
 1817bf0:	29461404 	addi	r5,r5,6224
 1817bf4:	01006134 	movhi	r4,388
 1817bf8:	2105f404 	addi	r4,r4,6096
 1817bfc:	1800c180 	call	1800c18 <printf>
 1817c00:	003fff06 	br	1817c00 <__ram_exceptions_end+0xff8077bc>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
 1817c04:	00800084 	movi	r2,2
 1817c08:	e0bff915 	stw	r2,-28(fp)
        break;
 1817c0c:	00002006 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 1817c10:	e0bff803 	ldbu	r2,-32(fp)
 1817c14:	10800120 	cmpeqi	r2,r2,4
 1817c18:	1000091e 	bne	r2,zero,1817c40 <dhcp_parse_reply+0x4e4>
 1817c1c:	01c06134 	movhi	r7,388
 1817c20:	39c5ea04 	addi	r7,r7,6056
 1817c24:	01816a44 	movi	r6,1449
 1817c28:	01406134 	movhi	r5,388
 1817c2c:	29461404 	addi	r5,r5,6224
 1817c30:	01006134 	movhi	r4,388
 1817c34:	2105f404 	addi	r4,r4,6096
 1817c38:	1800c180 	call	1800c18 <printf>
 1817c3c:	003fff06 	br	1817c3c <__ram_exceptions_end+0xff8077f8>
        decode_idx = DHCP_OPTION_IDX_T1;
 1817c40:	00800104 	movi	r2,4
 1817c44:	e0bff915 	stw	r2,-28(fp)
        break;
 1817c48:	00001106 	br	1817c90 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 1817c4c:	e0bff803 	ldbu	r2,-32(fp)
 1817c50:	10800120 	cmpeqi	r2,r2,4
 1817c54:	1000091e 	bne	r2,zero,1817c7c <dhcp_parse_reply+0x520>
 1817c58:	01c06134 	movhi	r7,388
 1817c5c:	39c5ea04 	addi	r7,r7,6056
 1817c60:	01816b44 	movi	r6,1453
 1817c64:	01406134 	movhi	r5,388
 1817c68:	29461404 	addi	r5,r5,6224
 1817c6c:	01006134 	movhi	r4,388
 1817c70:	2105f404 	addi	r4,r4,6096
 1817c74:	1800c180 	call	1800c18 <printf>
 1817c78:	003fff06 	br	1817c78 <__ram_exceptions_end+0xff807834>
        decode_idx = DHCP_OPTION_IDX_T2;
 1817c7c:	00800144 	movi	r2,5
 1817c80:	e0bff915 	stw	r2,-28(fp)
        break;
 1817c84:	00000206 	br	1817c90 <dhcp_parse_reply+0x534>
      default:
        decode_len = 0;
 1817c88:	e03ff845 	stb	zero,-31(fp)
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
 1817c8c:	0001883a 	nop
    }
    offset += len + 2;
 1817c90:	e0fff803 	ldbu	r3,-32(fp)
 1817c94:	e0bff30b 	ldhu	r2,-52(fp)
 1817c98:	1885883a 	add	r2,r3,r2
 1817c9c:	10800084 	addi	r2,r2,2
 1817ca0:	e0bff30d 	sth	r2,-52(fp)
    if (decode_len > 0) {
 1817ca4:	e0bff843 	ldbu	r2,-31(fp)
 1817ca8:	10007b26 	beq	r2,zero,1817e98 <dhcp_parse_reply+0x73c>
      u32_t value = 0;
 1817cac:	e03ffd15 	stw	zero,-12(fp)
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 1817cb0:	008061b4 	movhi	r2,390
 1817cb4:	1089c204 	addi	r2,r2,9992
 1817cb8:	e0fff917 	ldw	r3,-28(fp)
 1817cbc:	10c5883a 	add	r2,r2,r3
 1817cc0:	10800003 	ldbu	r2,0(r2)
 1817cc4:	10803fcc 	andi	r2,r2,255
 1817cc8:	1000731e 	bne	r2,zero,1817e98 <dhcp_parse_reply+0x73c>
        copy_len = LWIP_MIN(decode_len, 4);
 1817ccc:	e0bff843 	ldbu	r2,-31(fp)
 1817cd0:	10800128 	cmpgeui	r2,r2,4
 1817cd4:	1000021e 	bne	r2,zero,1817ce0 <dhcp_parse_reply+0x584>
 1817cd8:	e0bff843 	ldbu	r2,-31(fp)
 1817cdc:	00000106 	br	1817ce4 <dhcp_parse_reply+0x588>
 1817ce0:	00800104 	movi	r2,4
 1817ce4:	e0bffb0d 	sth	r2,-20(fp)
        pbuf_copy_partial(q, &value, copy_len, val_offset);
 1817ce8:	e0fffb0b 	ldhu	r3,-20(fp)
 1817cec:	e13ffa0b 	ldhu	r4,-24(fp)
 1817cf0:	e0bffd04 	addi	r2,fp,-12
 1817cf4:	200f883a 	mov	r7,r4
 1817cf8:	180d883a 	mov	r6,r3
 1817cfc:	100b883a 	mov	r5,r2
 1817d00:	e13ff517 	ldw	r4,-44(fp)
 1817d04:	181b2a80 	call	181b2a8 <pbuf_copy_partial>
        if (decode_len > 4) {
 1817d08:	e0bff843 	ldbu	r2,-31(fp)
 1817d0c:	10800170 	cmpltui	r2,r2,5
 1817d10:	1000311e 	bne	r2,zero,1817dd8 <dhcp_parse_reply+0x67c>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
 1817d14:	e0bff843 	ldbu	r2,-31(fp)
 1817d18:	108000cc 	andi	r2,r2,3
 1817d1c:	10803fcc 	andi	r2,r2,255
 1817d20:	10000926 	beq	r2,zero,1817d48 <dhcp_parse_reply+0x5ec>
 1817d24:	01c06134 	movhi	r7,388
 1817d28:	39c5ea04 	addi	r7,r7,6056
 1817d2c:	01817004 	movi	r6,1472
 1817d30:	01406134 	movhi	r5,388
 1817d34:	29462304 	addi	r5,r5,6284
 1817d38:	01006134 	movhi	r4,388
 1817d3c:	2105f404 	addi	r4,r4,6096
 1817d40:	1800c180 	call	1800c18 <printf>
 1817d44:	003fff06 	br	1817d44 <__ram_exceptions_end+0xff807900>
          dhcp_got_option(dhcp, decode_idx);
 1817d48:	008061b4 	movhi	r2,390
 1817d4c:	1089c204 	addi	r2,r2,9992
 1817d50:	e0fff917 	ldw	r3,-28(fp)
 1817d54:	10c5883a 	add	r2,r2,r3
 1817d58:	00c00044 	movi	r3,1
 1817d5c:	10c00005 	stb	r3,0(r2)
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
 1817d60:	e0bffd17 	ldw	r2,-12(fp)
 1817d64:	1006d63a 	srli	r3,r2,24
 1817d68:	e0bffd17 	ldw	r2,-12(fp)
 1817d6c:	1004d23a 	srli	r2,r2,8
 1817d70:	10bfc00c 	andi	r2,r2,65280
 1817d74:	1886b03a 	or	r3,r3,r2
 1817d78:	e0bffd17 	ldw	r2,-12(fp)
 1817d7c:	10bfc00c 	andi	r2,r2,65280
 1817d80:	1004923a 	slli	r2,r2,8
 1817d84:	1886b03a 	or	r3,r3,r2
 1817d88:	e0bffd17 	ldw	r2,-12(fp)
 1817d8c:	1004963a 	slli	r2,r2,24
 1817d90:	1888b03a 	or	r4,r3,r2
 1817d94:	008061b4 	movhi	r2,390
 1817d98:	1089c504 	addi	r2,r2,10004
 1817d9c:	e0fff917 	ldw	r3,-28(fp)
 1817da0:	18c7883a 	add	r3,r3,r3
 1817da4:	18c7883a 	add	r3,r3,r3
 1817da8:	10c5883a 	add	r2,r2,r3
 1817dac:	11000015 	stw	r4,0(r2)
          decode_len -= 4;
 1817db0:	e0bff843 	ldbu	r2,-31(fp)
 1817db4:	10bfff04 	addi	r2,r2,-4
 1817db8:	e0bff845 	stb	r2,-31(fp)
          val_offset += 4;
 1817dbc:	e0bffa0b 	ldhu	r2,-24(fp)
 1817dc0:	10800104 	addi	r2,r2,4
 1817dc4:	e0bffa0d 	sth	r2,-24(fp)
          decode_idx++;
 1817dc8:	e0bff917 	ldw	r2,-28(fp)
 1817dcc:	10800044 	addi	r2,r2,1
 1817dd0:	e0bff915 	stw	r2,-28(fp)
          goto decode_next;
 1817dd4:	003fb606 	br	1817cb0 <__ram_exceptions_end+0xff80786c>
        } else if (decode_len == 4) {
 1817dd8:	e0bff843 	ldbu	r2,-31(fp)
 1817ddc:	10800118 	cmpnei	r2,r2,4
 1817de0:	10000f1e 	bne	r2,zero,1817e20 <dhcp_parse_reply+0x6c4>
          value = ntohl(value);
 1817de4:	e0bffd17 	ldw	r2,-12(fp)
 1817de8:	1006d63a 	srli	r3,r2,24
 1817dec:	e0bffd17 	ldw	r2,-12(fp)
 1817df0:	1004d23a 	srli	r2,r2,8
 1817df4:	10bfc00c 	andi	r2,r2,65280
 1817df8:	1886b03a 	or	r3,r3,r2
 1817dfc:	e0bffd17 	ldw	r2,-12(fp)
 1817e00:	10bfc00c 	andi	r2,r2,65280
 1817e04:	1004923a 	slli	r2,r2,8
 1817e08:	1886b03a 	or	r3,r3,r2
 1817e0c:	e0bffd17 	ldw	r2,-12(fp)
 1817e10:	1004963a 	slli	r2,r2,24
 1817e14:	1884b03a 	or	r2,r3,r2
 1817e18:	e0bffd15 	stw	r2,-12(fp)
 1817e1c:	00001006 	br	1817e60 <dhcp_parse_reply+0x704>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
 1817e20:	e0bff843 	ldbu	r2,-31(fp)
 1817e24:	10800060 	cmpeqi	r2,r2,1
 1817e28:	1000091e 	bne	r2,zero,1817e50 <dhcp_parse_reply+0x6f4>
 1817e2c:	01c06134 	movhi	r7,388
 1817e30:	39c5ea04 	addi	r7,r7,6056
 1817e34:	01817284 	movi	r6,1482
 1817e38:	01406134 	movhi	r5,388
 1817e3c:	29462804 	addi	r5,r5,6304
 1817e40:	01006134 	movhi	r4,388
 1817e44:	2105f404 	addi	r4,r4,6096
 1817e48:	1800c180 	call	1800c18 <printf>
 1817e4c:	003fff06 	br	1817e4c <__ram_exceptions_end+0xff807a08>
          value = ((u8_t*)&value)[0];
 1817e50:	e0bffd04 	addi	r2,fp,-12
 1817e54:	10800003 	ldbu	r2,0(r2)
 1817e58:	10803fcc 	andi	r2,r2,255
 1817e5c:	e0bffd15 	stw	r2,-12(fp)
        }
        dhcp_got_option(dhcp, decode_idx);
 1817e60:	008061b4 	movhi	r2,390
 1817e64:	1089c204 	addi	r2,r2,9992
 1817e68:	e0fff917 	ldw	r3,-28(fp)
 1817e6c:	10c5883a 	add	r2,r2,r3
 1817e70:	00c00044 	movi	r3,1
 1817e74:	10c00005 	stb	r3,0(r2)
        dhcp_set_option_value(dhcp, decode_idx, value);
 1817e78:	e13ffd17 	ldw	r4,-12(fp)
 1817e7c:	008061b4 	movhi	r2,390
 1817e80:	1089c504 	addi	r2,r2,10004
 1817e84:	e0fff917 	ldw	r3,-28(fp)
 1817e88:	18c7883a 	add	r3,r3,r3
 1817e8c:	18c7883a 	add	r3,r3,r3
 1817e90:	10c5883a 	add	r2,r2,r3
 1817e94:	11000015 	stw	r4,0(r2)
      }
    }
    if (offset >= q->len) {
 1817e98:	e0bff517 	ldw	r2,-44(fp)
 1817e9c:	1080028b 	ldhu	r2,10(r2)
 1817ea0:	10bfffcc 	andi	r2,r2,65535
 1817ea4:	e0fff30b 	ldhu	r3,-52(fp)
 1817ea8:	18801536 	bltu	r3,r2,1817f00 <dhcp_parse_reply+0x7a4>
      offset -= q->len;
 1817eac:	e0bff517 	ldw	r2,-44(fp)
 1817eb0:	1080028b 	ldhu	r2,10(r2)
 1817eb4:	e0fff30b 	ldhu	r3,-52(fp)
 1817eb8:	1885c83a 	sub	r2,r3,r2
 1817ebc:	e0bff30d 	sth	r2,-52(fp)
      offset_max -= q->len;
 1817ec0:	e0bff517 	ldw	r2,-44(fp)
 1817ec4:	1080028b 	ldhu	r2,10(r2)
 1817ec8:	e0fff38b 	ldhu	r3,-50(fp)
 1817ecc:	1885c83a 	sub	r2,r3,r2
 1817ed0:	e0bff38d 	sth	r2,-50(fp)
      if ((offset < offset_max) && offset_max) {
 1817ed4:	e0fff30b 	ldhu	r3,-52(fp)
 1817ed8:	e0bff38b 	ldhu	r2,-50(fp)
 1817edc:	1880142e 	bgeu	r3,r2,1817f30 <dhcp_parse_reply+0x7d4>
 1817ee0:	e0bff38b 	ldhu	r2,-50(fp)
 1817ee4:	10001226 	beq	r2,zero,1817f30 <dhcp_parse_reply+0x7d4>
        q = q->next;
 1817ee8:	e0bff517 	ldw	r2,-44(fp)
 1817eec:	10800017 	ldw	r2,0(r2)
 1817ef0:	e0bff515 	stw	r2,-44(fp)
        LWIP_ASSERT("next pbuf was null", q);
        options = (u8_t*)q->payload;
 1817ef4:	e0bff517 	ldw	r2,-44(fp)
 1817ef8:	10800117 	ldw	r2,4(r2)
 1817efc:	e0bff215 	stw	r2,-56(fp)
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
 1817f00:	e0bff517 	ldw	r2,-44(fp)
 1817f04:	10000a26 	beq	r2,zero,1817f30 <dhcp_parse_reply+0x7d4>
 1817f08:	e0bff30b 	ldhu	r2,-52(fp)
 1817f0c:	e0fff217 	ldw	r3,-56(fp)
 1817f10:	1885883a 	add	r2,r3,r2
 1817f14:	10800003 	ldbu	r2,0(r2)
 1817f18:	10803fcc 	andi	r2,r2,255
 1817f1c:	10803fe0 	cmpeqi	r2,r2,255
 1817f20:	1000031e 	bne	r2,zero,1817f30 <dhcp_parse_reply+0x7d4>
 1817f24:	e0fff30b 	ldhu	r3,-52(fp)
 1817f28:	e0bff38b 	ldhu	r2,-50(fp)
 1817f2c:	18be4b36 	bltu	r3,r2,181785c <__ram_exceptions_end+0xff807418>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
 1817f30:	008061b4 	movhi	r2,390
 1817f34:	1089c204 	addi	r2,r2,9992
 1817f38:	10800003 	ldbu	r2,0(r2)
 1817f3c:	10803fcc 	andi	r2,r2,255
 1817f40:	10001a26 	beq	r2,zero,1817fac <dhcp_parse_reply+0x850>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 1817f44:	008061b4 	movhi	r2,390
 1817f48:	1089c504 	addi	r2,r2,10004
 1817f4c:	10800017 	ldw	r2,0(r2)
 1817f50:	e0bffc15 	stw	r2,-16(fp)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 1817f54:	008061b4 	movhi	r2,390
 1817f58:	1089c204 	addi	r2,r2,9992
 1817f5c:	10000005 	stb	zero,0(r2)
    if (overload == DHCP_OVERLOAD_FILE) {
 1817f60:	e0bffc17 	ldw	r2,-16(fp)
 1817f64:	10800058 	cmpnei	r2,r2,1
 1817f68:	1000031e 	bne	r2,zero,1817f78 <dhcp_parse_reply+0x81c>
      parse_file_as_options = 1;
 1817f6c:	00800044 	movi	r2,1
 1817f70:	e0bff615 	stw	r2,-40(fp)
 1817f74:	00000d06 	br	1817fac <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
 1817f78:	e0bffc17 	ldw	r2,-16(fp)
 1817f7c:	10800098 	cmpnei	r2,r2,2
 1817f80:	1000031e 	bne	r2,zero,1817f90 <dhcp_parse_reply+0x834>
      parse_sname_as_options = 1;
 1817f84:	00800044 	movi	r2,1
 1817f88:	e0bff715 	stw	r2,-36(fp)
 1817f8c:	00000706 	br	1817fac <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
 1817f90:	e0bffc17 	ldw	r2,-16(fp)
 1817f94:	108000d8 	cmpnei	r2,r2,3
 1817f98:	1000041e 	bne	r2,zero,1817fac <dhcp_parse_reply+0x850>
      parse_sname_as_options = 1;
 1817f9c:	00800044 	movi	r2,1
 1817fa0:	e0bff715 	stw	r2,-36(fp)
      parse_file_as_options = 1;
 1817fa4:	00800044 	movi	r2,1
 1817fa8:	e0bff615 	stw	r2,-40(fp)
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
 1817fac:	e0bff617 	ldw	r2,-40(fp)
 1817fb0:	10000626 	beq	r2,zero,1817fcc <dhcp_parse_reply+0x870>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
 1817fb4:	e03ff615 	stw	zero,-40(fp)
    options_idx = DHCP_FILE_OFS;
 1817fb8:	00801b04 	movi	r2,108
 1817fbc:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
 1817fc0:	00803b04 	movi	r2,236
 1817fc4:	e0bff48d 	sth	r2,-46(fp)
    goto again;
 1817fc8:	003e0106 	br	18177d0 <__ram_exceptions_end+0xff80738c>
  } else if (parse_sname_as_options) {
 1817fcc:	e0bff717 	ldw	r2,-36(fp)
 1817fd0:	10000626 	beq	r2,zero,1817fec <dhcp_parse_reply+0x890>
    parse_sname_as_options = 0;
 1817fd4:	e03ff715 	stw	zero,-36(fp)
    options_idx = DHCP_SNAME_OFS;
 1817fd8:	00800b04 	movi	r2,44
 1817fdc:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
 1817fe0:	00801b04 	movi	r2,108
 1817fe4:	e0bff48d 	sth	r2,-46(fp)
    goto again;
 1817fe8:	003df906 	br	18177d0 <__ram_exceptions_end+0xff80738c>
  }
  return ERR_OK;
 1817fec:	0005883a 	mov	r2,zero
}
 1817ff0:	e037883a 	mov	sp,fp
 1817ff4:	dfc00117 	ldw	ra,4(sp)
 1817ff8:	df000017 	ldw	fp,0(sp)
 1817ffc:	dec00204 	addi	sp,sp,8
 1818000:	f800283a 	ret

01818004 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
 1818004:	defff404 	addi	sp,sp,-48
 1818008:	dfc00b15 	stw	ra,44(sp)
 181800c:	df000a15 	stw	fp,40(sp)
 1818010:	df000a04 	addi	fp,sp,40
 1818014:	e13ffb15 	stw	r4,-20(fp)
 1818018:	e17ffc15 	stw	r5,-16(fp)
 181801c:	e1bffd15 	stw	r6,-12(fp)
 1818020:	e1fffe15 	stw	r7,-8(fp)
 1818024:	e0800217 	ldw	r2,8(fp)
 1818028:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
 181802c:	e0bffb17 	ldw	r2,-20(fp)
 1818030:	e0bff715 	stw	r2,-36(fp)
  struct dhcp *dhcp = netif->dhcp;
 1818034:	e0bff717 	ldw	r2,-36(fp)
 1818038:	10800a17 	ldw	r2,40(r2)
 181803c:	e0bff815 	stw	r2,-32(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
 1818040:	e0bffd17 	ldw	r2,-12(fp)
 1818044:	10800117 	ldw	r2,4(r2)
 1818048:	e0bff915 	stw	r2,-28(fp)
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 181804c:	e0bffd17 	ldw	r2,-12(fp)
 1818050:	1080028b 	ldhu	r2,10(r2)
 1818054:	10bfffcc 	andi	r2,r2,65535
 1818058:	10800b28 	cmpgeui	r2,r2,44
 181805c:	1000aa26 	beq	r2,zero,1818308 <dhcp_recv+0x304>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
 1818060:	e0bff917 	ldw	r2,-28(fp)
 1818064:	10800003 	ldbu	r2,0(r2)
 1818068:	10803fcc 	andi	r2,r2,255
 181806c:	108000a0 	cmpeqi	r2,r2,2
 1818070:	1000a726 	beq	r2,zero,1818310 <dhcp_recv+0x30c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 1818074:	e03ff605 	stb	zero,-40(fp)
 1818078:	00001006 	br	18180bc <dhcp_recv+0xb8>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 181807c:	e0bff603 	ldbu	r2,-40(fp)
 1818080:	e0fff717 	ldw	r3,-36(fp)
 1818084:	1885883a 	add	r2,r3,r2
 1818088:	10800cc4 	addi	r2,r2,51
 181808c:	11000003 	ldbu	r4,0(r2)
 1818090:	e0bff603 	ldbu	r2,-40(fp)
 1818094:	e0fff917 	ldw	r3,-28(fp)
 1818098:	1885883a 	add	r2,r3,r2
 181809c:	10800704 	addi	r2,r2,28
 18180a0:	10800003 	ldbu	r2,0(r2)
 18180a4:	20c03fcc 	andi	r3,r4,255
 18180a8:	10803fcc 	andi	r2,r2,255
 18180ac:	18809a1e 	bne	r3,r2,1818318 <dhcp_recv+0x314>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 18180b0:	e0bff603 	ldbu	r2,-40(fp)
 18180b4:	10800044 	addi	r2,r2,1
 18180b8:	e0bff605 	stb	r2,-40(fp)
 18180bc:	e0bff717 	ldw	r2,-36(fp)
 18180c0:	10800c83 	ldbu	r2,50(r2)
 18180c4:	10803fcc 	andi	r2,r2,255
 18180c8:	e0fff603 	ldbu	r3,-40(fp)
 18180cc:	18bfeb36 	bltu	r3,r2,181807c <__ram_exceptions_end+0xff807c38>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
 18180d0:	e0bff917 	ldw	r2,-28(fp)
 18180d4:	10c00103 	ldbu	r3,4(r2)
 18180d8:	11000143 	ldbu	r4,5(r2)
 18180dc:	2008923a 	slli	r4,r4,8
 18180e0:	20c6b03a 	or	r3,r4,r3
 18180e4:	11000183 	ldbu	r4,6(r2)
 18180e8:	2008943a 	slli	r4,r4,16
 18180ec:	20c6b03a 	or	r3,r4,r3
 18180f0:	108001c3 	ldbu	r2,7(r2)
 18180f4:	1004963a 	slli	r2,r2,24
 18180f8:	10c4b03a 	or	r2,r2,r3
 18180fc:	1006d63a 	srli	r3,r2,24
 1818100:	e0bff917 	ldw	r2,-28(fp)
 1818104:	11000103 	ldbu	r4,4(r2)
 1818108:	11400143 	ldbu	r5,5(r2)
 181810c:	280a923a 	slli	r5,r5,8
 1818110:	2908b03a 	or	r4,r5,r4
 1818114:	11400183 	ldbu	r5,6(r2)
 1818118:	280a943a 	slli	r5,r5,16
 181811c:	2908b03a 	or	r4,r5,r4
 1818120:	108001c3 	ldbu	r2,7(r2)
 1818124:	1004963a 	slli	r2,r2,24
 1818128:	1104b03a 	or	r2,r2,r4
 181812c:	1004d23a 	srli	r2,r2,8
 1818130:	10bfc00c 	andi	r2,r2,65280
 1818134:	1886b03a 	or	r3,r3,r2
 1818138:	e0bff917 	ldw	r2,-28(fp)
 181813c:	11000103 	ldbu	r4,4(r2)
 1818140:	11400143 	ldbu	r5,5(r2)
 1818144:	280a923a 	slli	r5,r5,8
 1818148:	2908b03a 	or	r4,r5,r4
 181814c:	11400183 	ldbu	r5,6(r2)
 1818150:	280a943a 	slli	r5,r5,16
 1818154:	2908b03a 	or	r4,r5,r4
 1818158:	108001c3 	ldbu	r2,7(r2)
 181815c:	1004963a 	slli	r2,r2,24
 1818160:	1104b03a 	or	r2,r2,r4
 1818164:	10bfc00c 	andi	r2,r2,65280
 1818168:	1004923a 	slli	r2,r2,8
 181816c:	1886b03a 	or	r3,r3,r2
 1818170:	e0bff917 	ldw	r2,-28(fp)
 1818174:	11000103 	ldbu	r4,4(r2)
 1818178:	11400143 	ldbu	r5,5(r2)
 181817c:	280a923a 	slli	r5,r5,8
 1818180:	2908b03a 	or	r4,r5,r4
 1818184:	11400183 	ldbu	r5,6(r2)
 1818188:	280a943a 	slli	r5,r5,16
 181818c:	2908b03a 	or	r4,r5,r4
 1818190:	108001c3 	ldbu	r2,7(r2)
 1818194:	1004963a 	slli	r2,r2,24
 1818198:	1104b03a 	or	r2,r2,r4
 181819c:	1004963a 	slli	r2,r2,24
 18181a0:	1886b03a 	or	r3,r3,r2
 18181a4:	e0bff817 	ldw	r2,-32(fp)
 18181a8:	10800017 	ldw	r2,0(r2)
 18181ac:	18805c1e 	bne	r3,r2,1818320 <dhcp_recv+0x31c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
 18181b0:	e17ffd17 	ldw	r5,-12(fp)
 18181b4:	e13ff817 	ldw	r4,-32(fp)
 18181b8:	181775c0 	call	181775c <dhcp_parse_reply>
 18181bc:	10803fcc 	andi	r2,r2,255
 18181c0:	1080201c 	xori	r2,r2,128
 18181c4:	10bfe004 	addi	r2,r2,-128
 18181c8:	1000571e 	bne	r2,zero,1818328 <dhcp_recv+0x324>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
 18181cc:	008061b4 	movhi	r2,390
 18181d0:	1089c204 	addi	r2,r2,9992
 18181d4:	10800043 	ldbu	r2,1(r2)
 18181d8:	10803fcc 	andi	r2,r2,255
 18181dc:	10005426 	beq	r2,zero,1818330 <dhcp_recv+0x32c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
 18181e0:	008061b4 	movhi	r2,390
 18181e4:	1089c504 	addi	r2,r2,10004
 18181e8:	10800117 	ldw	r2,4(r2)
 18181ec:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
 18181f0:	e0bffa03 	ldbu	r2,-24(fp)
 18181f4:	10800158 	cmpnei	r2,r2,5
 18181f8:	10001c1e 	bne	r2,zero,181826c <dhcp_recv+0x268>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
 18181fc:	e0bff817 	ldw	r2,-32(fp)
 1818200:	10800303 	ldbu	r2,12(r2)
 1818204:	10803fcc 	andi	r2,r2,255
 1818208:	10800058 	cmpnei	r2,r2,1
 181820c:	1000051e 	bne	r2,zero,1818224 <dhcp_recv+0x220>
      dhcp_handle_ack(netif);
 1818210:	e13ff717 	ldw	r4,-36(fp)
 1818214:	1815fa00 	call	1815fa0 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
 1818218:	e13ff717 	ldw	r4,-36(fp)
 181821c:	18157c40 	call	18157c4 <dhcp_check>
 1818220:	00004406 	br	1818334 <dhcp_recv+0x330>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
 1818224:	e0bff817 	ldw	r2,-32(fp)
 1818228:	10800303 	ldbu	r2,12(r2)
 181822c:	10803fcc 	andi	r2,r2,255
 1818230:	108000e0 	cmpeqi	r2,r2,3
 1818234:	10000a1e 	bne	r2,zero,1818260 <dhcp_recv+0x25c>
 1818238:	e0bff817 	ldw	r2,-32(fp)
 181823c:	10800303 	ldbu	r2,12(r2)
 1818240:	10803fcc 	andi	r2,r2,255
 1818244:	10800120 	cmpeqi	r2,r2,4
 1818248:	1000051e 	bne	r2,zero,1818260 <dhcp_recv+0x25c>
 181824c:	e0bff817 	ldw	r2,-32(fp)
 1818250:	10800303 	ldbu	r2,12(r2)
 1818254:	10803fcc 	andi	r2,r2,255
 1818258:	10800158 	cmpnei	r2,r2,5
 181825c:	1000351e 	bne	r2,zero,1818334 <dhcp_recv+0x330>
      dhcp_bind(netif);
 1818260:	e13ff717 	ldw	r4,-36(fp)
 1818264:	1816a380 	call	1816a38 <dhcp_bind>
 1818268:	00003206 	br	1818334 <dhcp_recv+0x330>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 181826c:	e0bffa03 	ldbu	r2,-24(fp)
 1818270:	10800198 	cmpnei	r2,r2,6
 1818274:	1000171e 	bne	r2,zero,18182d4 <dhcp_recv+0x2d0>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 1818278:	e0bff817 	ldw	r2,-32(fp)
 181827c:	10800303 	ldbu	r2,12(r2)
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 1818280:	10803fcc 	andi	r2,r2,255
 1818284:	108000e0 	cmpeqi	r2,r2,3
 1818288:	10000f1e 	bne	r2,zero,18182c8 <dhcp_recv+0x2c4>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 181828c:	e0bff817 	ldw	r2,-32(fp)
 1818290:	10800303 	ldbu	r2,12(r2)
 1818294:	10803fcc 	andi	r2,r2,255
 1818298:	10800060 	cmpeqi	r2,r2,1
 181829c:	10000a1e 	bne	r2,zero,18182c8 <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
 18182a0:	e0bff817 	ldw	r2,-32(fp)
 18182a4:	10800303 	ldbu	r2,12(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 18182a8:	10803fcc 	andi	r2,r2,255
 18182ac:	10800120 	cmpeqi	r2,r2,4
 18182b0:	1000051e 	bne	r2,zero,18182c8 <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
 18182b4:	e0bff817 	ldw	r2,-32(fp)
 18182b8:	10800303 	ldbu	r2,12(r2)
 18182bc:	10803fcc 	andi	r2,r2,255
 18182c0:	10800158 	cmpnei	r2,r2,5
 18182c4:	1000031e 	bne	r2,zero,18182d4 <dhcp_recv+0x2d0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
 18182c8:	e13ff717 	ldw	r4,-36(fp)
 18182cc:	18157700 	call	1815770 <dhcp_handle_nak>
 18182d0:	00001806 	br	1818334 <dhcp_recv+0x330>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
 18182d4:	e0bffa03 	ldbu	r2,-24(fp)
 18182d8:	10800098 	cmpnei	r2,r2,2
 18182dc:	1000151e 	bne	r2,zero,1818334 <dhcp_recv+0x330>
 18182e0:	e0bff817 	ldw	r2,-32(fp)
 18182e4:	10800303 	ldbu	r2,12(r2)
 18182e8:	10803fcc 	andi	r2,r2,255
 18182ec:	10800198 	cmpnei	r2,r2,6
 18182f0:	1000101e 	bne	r2,zero,1818334 <dhcp_recv+0x330>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
 18182f4:	e0bff817 	ldw	r2,-32(fp)
 18182f8:	1000068d 	sth	zero,26(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
 18182fc:	e13ff717 	ldw	r4,-36(fp)
 1818300:	18158640 	call	1815864 <dhcp_handle_offer>
 1818304:	00000b06 	br	1818334 <dhcp_recv+0x330>

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
 1818308:	0001883a 	nop
 181830c:	00000906 	br	1818334 <dhcp_recv+0x330>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
 1818310:	0001883a 	nop
 1818314:	00000706 	br	1818334 <dhcp_recv+0x330>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
 1818318:	0001883a 	nop
 181831c:	00000506 	br	1818334 <dhcp_recv+0x330>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
 1818320:	0001883a 	nop
 1818324:	00000306 	br	1818334 <dhcp_recv+0x330>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
 1818328:	0001883a 	nop
 181832c:	00000106 	br	1818334 <dhcp_recv+0x330>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
 1818330:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
 1818334:	e0bff817 	ldw	r2,-32(fp)
 1818338:	10000215 	stw	zero,8(r2)
  pbuf_free(p);
 181833c:	e13ffd17 	ldw	r4,-12(fp)
 1818340:	181aca40 	call	181aca4 <pbuf_free>
}
 1818344:	0001883a 	nop
 1818348:	e037883a 	mov	sp,fp
 181834c:	dfc00117 	ldw	ra,4(sp)
 1818350:	df000017 	ldw	fp,0(sp)
 1818354:	dec00204 	addi	sp,sp,8
 1818358:	f800283a 	ret

0181835c <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
 181835c:	defffa04 	addi	sp,sp,-24
 1818360:	dfc00515 	stw	ra,20(sp)
 1818364:	df000415 	stw	fp,16(sp)
 1818368:	df000404 	addi	fp,sp,16
 181836c:	e13ffd15 	stw	r4,-12(fp)
 1818370:	e17ffe15 	stw	r5,-8(fp)
 1818374:	3005883a 	mov	r2,r6
 1818378:	e0bfff05 	stb	r2,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
 181837c:	e0bffd17 	ldw	r2,-12(fp)
 1818380:	1000091e 	bne	r2,zero,18183a8 <dhcp_create_msg+0x4c>
 1818384:	01c06134 	movhi	r7,388
 1818388:	39c5ea04 	addi	r7,r7,6056
 181838c:	0181a244 	movi	r6,1673
 1818390:	01406134 	movhi	r5,388
 1818394:	29462d04 	addi	r5,r5,6324
 1818398:	01006134 	movhi	r4,388
 181839c:	2105f404 	addi	r4,r4,6096
 18183a0:	1800c180 	call	1800c18 <printf>
 18183a4:	003fff06 	br	18183a4 <__ram_exceptions_end+0xff807f60>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 18183a8:	e0bffe17 	ldw	r2,-8(fp)
 18183ac:	1000091e 	bne	r2,zero,18183d4 <dhcp_create_msg+0x78>
 18183b0:	01c06134 	movhi	r7,388
 18183b4:	39c5ea04 	addi	r7,r7,6056
 18183b8:	0181a284 	movi	r6,1674
 18183bc:	01406134 	movhi	r5,388
 18183c0:	29463504 	addi	r5,r5,6356
 18183c4:	01006134 	movhi	r4,388
 18183c8:	2105f404 	addi	r4,r4,6096
 18183cc:	1800c180 	call	1800c18 <printf>
 18183d0:	003fff06 	br	18183d0 <__ram_exceptions_end+0xff807f8c>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 18183d4:	000d883a 	mov	r6,zero
 18183d8:	01404d04 	movi	r5,308
 18183dc:	0009883a 	mov	r4,zero
 18183e0:	181a4e80 	call	181a4e8 <pbuf_alloc>
 18183e4:	1007883a 	mov	r3,r2
 18183e8:	e0bffe17 	ldw	r2,-8(fp)
 18183ec:	10c00415 	stw	r3,16(r2)
  if (dhcp->p_out == NULL) {
 18183f0:	e0bffe17 	ldw	r2,-8(fp)
 18183f4:	10800417 	ldw	r2,16(r2)
 18183f8:	1000021e 	bne	r2,zero,1818404 <dhcp_create_msg+0xa8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 18183fc:	00bfffc4 	movi	r2,-1
 1818400:	00013206 	br	18188cc <dhcp_create_msg+0x570>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 1818404:	e0bffe17 	ldw	r2,-8(fp)
 1818408:	10800343 	ldbu	r2,13(r2)
 181840c:	10803fcc 	andi	r2,r2,255
 1818410:	1000031e 	bne	r2,zero,1818420 <dhcp_create_msg+0xc4>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 1818414:	d0a00c17 	ldw	r2,-32720(gp)
 1818418:	10800044 	addi	r2,r2,1
 181841c:	d0a00c15 	stw	r2,-32720(gp)
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 1818420:	d0e00c17 	ldw	r3,-32720(gp)
 1818424:	e0bffe17 	ldw	r2,-8(fp)
 1818428:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 181842c:	e0bffe17 	ldw	r2,-8(fp)
 1818430:	10800417 	ldw	r2,16(r2)
 1818434:	10c00117 	ldw	r3,4(r2)
 1818438:	e0bffe17 	ldw	r2,-8(fp)
 181843c:	10c00515 	stw	r3,20(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 1818440:	e0bffe17 	ldw	r2,-8(fp)
 1818444:	10800517 	ldw	r2,20(r2)
 1818448:	00c00044 	movi	r3,1
 181844c:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 1818450:	e0bffe17 	ldw	r2,-8(fp)
 1818454:	10800517 	ldw	r2,20(r2)
 1818458:	00c00044 	movi	r3,1
 181845c:	10c00045 	stb	r3,1(r2)
  dhcp->msg_out->hlen = netif->hwaddr_len;
 1818460:	e0bffe17 	ldw	r2,-8(fp)
 1818464:	10800517 	ldw	r2,20(r2)
 1818468:	e0fffd17 	ldw	r3,-12(fp)
 181846c:	18c00c83 	ldbu	r3,50(r3)
 1818470:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
 1818474:	e0bffe17 	ldw	r2,-8(fp)
 1818478:	10800517 	ldw	r2,20(r2)
 181847c:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
 1818480:	e0bffe17 	ldw	r2,-8(fp)
 1818484:	10800517 	ldw	r2,20(r2)
 1818488:	e0fffe17 	ldw	r3,-8(fp)
 181848c:	18c00017 	ldw	r3,0(r3)
 1818490:	1808d63a 	srli	r4,r3,24
 1818494:	e0fffe17 	ldw	r3,-8(fp)
 1818498:	18c00017 	ldw	r3,0(r3)
 181849c:	1806d23a 	srli	r3,r3,8
 18184a0:	18ffc00c 	andi	r3,r3,65280
 18184a4:	20c8b03a 	or	r4,r4,r3
 18184a8:	e0fffe17 	ldw	r3,-8(fp)
 18184ac:	18c00017 	ldw	r3,0(r3)
 18184b0:	18ffc00c 	andi	r3,r3,65280
 18184b4:	1806923a 	slli	r3,r3,8
 18184b8:	20c8b03a 	or	r4,r4,r3
 18184bc:	e0fffe17 	ldw	r3,-8(fp)
 18184c0:	18c00017 	ldw	r3,0(r3)
 18184c4:	1806963a 	slli	r3,r3,24
 18184c8:	20c6b03a 	or	r3,r4,r3
 18184cc:	19803fcc 	andi	r6,r3,255
 18184d0:	11000103 	ldbu	r4,4(r2)
 18184d4:	2008703a 	and	r4,r4,zero
 18184d8:	200b883a 	mov	r5,r4
 18184dc:	3009883a 	mov	r4,r6
 18184e0:	2908b03a 	or	r4,r5,r4
 18184e4:	11000105 	stb	r4,4(r2)
 18184e8:	1808d23a 	srli	r4,r3,8
 18184ec:	21803fcc 	andi	r6,r4,255
 18184f0:	11000143 	ldbu	r4,5(r2)
 18184f4:	2008703a 	and	r4,r4,zero
 18184f8:	200b883a 	mov	r5,r4
 18184fc:	3009883a 	mov	r4,r6
 1818500:	2908b03a 	or	r4,r5,r4
 1818504:	11000145 	stb	r4,5(r2)
 1818508:	1808d43a 	srli	r4,r3,16
 181850c:	21803fcc 	andi	r6,r4,255
 1818510:	11000183 	ldbu	r4,6(r2)
 1818514:	2008703a 	and	r4,r4,zero
 1818518:	200b883a 	mov	r5,r4
 181851c:	3009883a 	mov	r4,r6
 1818520:	2908b03a 	or	r4,r5,r4
 1818524:	11000185 	stb	r4,6(r2)
 1818528:	180ad63a 	srli	r5,r3,24
 181852c:	10c001c3 	ldbu	r3,7(r2)
 1818530:	1806703a 	and	r3,r3,zero
 1818534:	1809883a 	mov	r4,r3
 1818538:	2807883a 	mov	r3,r5
 181853c:	20c6b03a 	or	r3,r4,r3
 1818540:	10c001c5 	stb	r3,7(r2)
  dhcp->msg_out->secs = 0;
 1818544:	e0bffe17 	ldw	r2,-8(fp)
 1818548:	10800517 	ldw	r2,20(r2)
 181854c:	10c00203 	ldbu	r3,8(r2)
 1818550:	1806703a 	and	r3,r3,zero
 1818554:	10c00205 	stb	r3,8(r2)
 1818558:	10c00243 	ldbu	r3,9(r2)
 181855c:	1806703a 	and	r3,r3,zero
 1818560:	10c00245 	stb	r3,9(r2)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 1818564:	e0bffe17 	ldw	r2,-8(fp)
 1818568:	10800517 	ldw	r2,20(r2)
 181856c:	10c00283 	ldbu	r3,10(r2)
 1818570:	1806703a 	and	r3,r3,zero
 1818574:	10c00285 	stb	r3,10(r2)
 1818578:	10c002c3 	ldbu	r3,11(r2)
 181857c:	1806703a 	and	r3,r3,zero
 1818580:	10c002c5 	stb	r3,11(r2)
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 1818584:	e0bffe17 	ldw	r2,-8(fp)
 1818588:	10800517 	ldw	r2,20(r2)
 181858c:	10c00303 	ldbu	r3,12(r2)
 1818590:	1806703a 	and	r3,r3,zero
 1818594:	10c00305 	stb	r3,12(r2)
 1818598:	10c00343 	ldbu	r3,13(r2)
 181859c:	1806703a 	and	r3,r3,zero
 18185a0:	10c00345 	stb	r3,13(r2)
 18185a4:	10c00383 	ldbu	r3,14(r2)
 18185a8:	1806703a 	and	r3,r3,zero
 18185ac:	10c00385 	stb	r3,14(r2)
 18185b0:	10c003c3 	ldbu	r3,15(r2)
 18185b4:	1806703a 	and	r3,r3,zero
 18185b8:	10c003c5 	stb	r3,15(r2)
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
 18185bc:	e0bfff03 	ldbu	r2,-4(fp)
 18185c0:	10800220 	cmpeqi	r2,r2,8
 18185c4:	1000101e 	bne	r2,zero,1818608 <dhcp_create_msg+0x2ac>
 18185c8:	e0bfff03 	ldbu	r2,-4(fp)
 18185cc:	10800120 	cmpeqi	r2,r2,4
 18185d0:	10000d1e 	bne	r2,zero,1818608 <dhcp_create_msg+0x2ac>
 18185d4:	e0bfff03 	ldbu	r2,-4(fp)
 18185d8:	108000d8 	cmpnei	r2,r2,3
 18185dc:	10002c1e 	bne	r2,zero,1818690 <dhcp_create_msg+0x334>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
 18185e0:	e0bffe17 	ldw	r2,-8(fp)
 18185e4:	10800303 	ldbu	r2,12(r2)
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 18185e8:	10803fcc 	andi	r2,r2,255
 18185ec:	10800160 	cmpeqi	r2,r2,5
 18185f0:	1000051e 	bne	r2,zero,1818608 <dhcp_create_msg+0x2ac>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
 18185f4:	e0bffe17 	ldw	r2,-8(fp)
 18185f8:	10800303 	ldbu	r2,12(r2)
 18185fc:	10803fcc 	andi	r2,r2,255
 1818600:	10800118 	cmpnei	r2,r2,4
 1818604:	1000221e 	bne	r2,zero,1818690 <dhcp_create_msg+0x334>
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 1818608:	e0bffe17 	ldw	r2,-8(fp)
 181860c:	10800517 	ldw	r2,20(r2)
 1818610:	e0fffd17 	ldw	r3,-12(fp)
 1818614:	18c00117 	ldw	r3,4(r3)
 1818618:	19803fcc 	andi	r6,r3,255
 181861c:	11000303 	ldbu	r4,12(r2)
 1818620:	2008703a 	and	r4,r4,zero
 1818624:	200b883a 	mov	r5,r4
 1818628:	3009883a 	mov	r4,r6
 181862c:	2908b03a 	or	r4,r5,r4
 1818630:	11000305 	stb	r4,12(r2)
 1818634:	1808d23a 	srli	r4,r3,8
 1818638:	21803fcc 	andi	r6,r4,255
 181863c:	11000343 	ldbu	r4,13(r2)
 1818640:	2008703a 	and	r4,r4,zero
 1818644:	200b883a 	mov	r5,r4
 1818648:	3009883a 	mov	r4,r6
 181864c:	2908b03a 	or	r4,r5,r4
 1818650:	11000345 	stb	r4,13(r2)
 1818654:	1808d43a 	srli	r4,r3,16
 1818658:	21803fcc 	andi	r6,r4,255
 181865c:	11000383 	ldbu	r4,14(r2)
 1818660:	2008703a 	and	r4,r4,zero
 1818664:	200b883a 	mov	r5,r4
 1818668:	3009883a 	mov	r4,r6
 181866c:	2908b03a 	or	r4,r5,r4
 1818670:	11000385 	stb	r4,14(r2)
 1818674:	180ad63a 	srli	r5,r3,24
 1818678:	10c003c3 	ldbu	r3,15(r2)
 181867c:	1806703a 	and	r3,r3,zero
 1818680:	1809883a 	mov	r4,r3
 1818684:	2807883a 	mov	r3,r5
 1818688:	20c6b03a 	or	r3,r4,r3
 181868c:	10c003c5 	stb	r3,15(r2)
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 1818690:	e0bffe17 	ldw	r2,-8(fp)
 1818694:	10800517 	ldw	r2,20(r2)
 1818698:	10c00403 	ldbu	r3,16(r2)
 181869c:	1806703a 	and	r3,r3,zero
 18186a0:	10c00405 	stb	r3,16(r2)
 18186a4:	10c00443 	ldbu	r3,17(r2)
 18186a8:	1806703a 	and	r3,r3,zero
 18186ac:	10c00445 	stb	r3,17(r2)
 18186b0:	10c00483 	ldbu	r3,18(r2)
 18186b4:	1806703a 	and	r3,r3,zero
 18186b8:	10c00485 	stb	r3,18(r2)
 18186bc:	10c004c3 	ldbu	r3,19(r2)
 18186c0:	1806703a 	and	r3,r3,zero
 18186c4:	10c004c5 	stb	r3,19(r2)
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 18186c8:	e0bffe17 	ldw	r2,-8(fp)
 18186cc:	10800517 	ldw	r2,20(r2)
 18186d0:	10c00503 	ldbu	r3,20(r2)
 18186d4:	1806703a 	and	r3,r3,zero
 18186d8:	10c00505 	stb	r3,20(r2)
 18186dc:	10c00543 	ldbu	r3,21(r2)
 18186e0:	1806703a 	and	r3,r3,zero
 18186e4:	10c00545 	stb	r3,21(r2)
 18186e8:	10c00583 	ldbu	r3,22(r2)
 18186ec:	1806703a 	and	r3,r3,zero
 18186f0:	10c00585 	stb	r3,22(r2)
 18186f4:	10c005c3 	ldbu	r3,23(r2)
 18186f8:	1806703a 	and	r3,r3,zero
 18186fc:	10c005c5 	stb	r3,23(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 1818700:	e0bffe17 	ldw	r2,-8(fp)
 1818704:	10800517 	ldw	r2,20(r2)
 1818708:	10c00603 	ldbu	r3,24(r2)
 181870c:	1806703a 	and	r3,r3,zero
 1818710:	10c00605 	stb	r3,24(r2)
 1818714:	10c00643 	ldbu	r3,25(r2)
 1818718:	1806703a 	and	r3,r3,zero
 181871c:	10c00645 	stb	r3,25(r2)
 1818720:	10c00683 	ldbu	r3,26(r2)
 1818724:	1806703a 	and	r3,r3,zero
 1818728:	10c00685 	stb	r3,26(r2)
 181872c:	10c006c3 	ldbu	r3,27(r2)
 1818730:	1806703a 	and	r3,r3,zero
 1818734:	10c006c5 	stb	r3,27(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 1818738:	e03ffc0d 	sth	zero,-16(fp)
 181873c:	00001606 	br	1818798 <dhcp_create_msg+0x43c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 1818740:	e0bffe17 	ldw	r2,-8(fp)
 1818744:	11000517 	ldw	r4,20(r2)
 1818748:	e0fffc0b 	ldhu	r3,-16(fp)
 181874c:	e0bffd17 	ldw	r2,-12(fp)
 1818750:	10800c83 	ldbu	r2,50(r2)
 1818754:	10803fcc 	andi	r2,r2,255
 1818758:	10bfffcc 	andi	r2,r2,65535
 181875c:	e17ffc0b 	ldhu	r5,-16(fp)
 1818760:	2880062e 	bgeu	r5,r2,181877c <dhcp_create_msg+0x420>
 1818764:	e0bffc0b 	ldhu	r2,-16(fp)
 1818768:	e17ffd17 	ldw	r5,-12(fp)
 181876c:	2885883a 	add	r2,r5,r2
 1818770:	10800cc4 	addi	r2,r2,51
 1818774:	10800003 	ldbu	r2,0(r2)
 1818778:	00000106 	br	1818780 <dhcp_create_msg+0x424>
 181877c:	0005883a 	mov	r2,zero
 1818780:	20c7883a 	add	r3,r4,r3
 1818784:	18c00704 	addi	r3,r3,28
 1818788:	18800005 	stb	r2,0(r3)
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 181878c:	e0bffc0b 	ldhu	r2,-16(fp)
 1818790:	10800044 	addi	r2,r2,1
 1818794:	e0bffc0d 	sth	r2,-16(fp)
 1818798:	e0bffc0b 	ldhu	r2,-16(fp)
 181879c:	10800430 	cmpltui	r2,r2,16
 18187a0:	103fe71e 	bne	r2,zero,1818740 <__ram_exceptions_end+0xff8082fc>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 18187a4:	e03ffc0d 	sth	zero,-16(fp)
 18187a8:	00000906 	br	18187d0 <dhcp_create_msg+0x474>
    dhcp->msg_out->sname[i] = 0;
 18187ac:	e0bffe17 	ldw	r2,-8(fp)
 18187b0:	10c00517 	ldw	r3,20(r2)
 18187b4:	e0bffc0b 	ldhu	r2,-16(fp)
 18187b8:	1885883a 	add	r2,r3,r2
 18187bc:	10800b04 	addi	r2,r2,44
 18187c0:	10000005 	stb	zero,0(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 18187c4:	e0bffc0b 	ldhu	r2,-16(fp)
 18187c8:	10800044 	addi	r2,r2,1
 18187cc:	e0bffc0d 	sth	r2,-16(fp)
 18187d0:	e0bffc0b 	ldhu	r2,-16(fp)
 18187d4:	10801030 	cmpltui	r2,r2,64
 18187d8:	103ff41e 	bne	r2,zero,18187ac <__ram_exceptions_end+0xff808368>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 18187dc:	e03ffc0d 	sth	zero,-16(fp)
 18187e0:	00000906 	br	1818808 <dhcp_create_msg+0x4ac>
    dhcp->msg_out->file[i] = 0;
 18187e4:	e0bffe17 	ldw	r2,-8(fp)
 18187e8:	10c00517 	ldw	r3,20(r2)
 18187ec:	e0bffc0b 	ldhu	r2,-16(fp)
 18187f0:	1885883a 	add	r2,r3,r2
 18187f4:	10801b04 	addi	r2,r2,108
 18187f8:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 18187fc:	e0bffc0b 	ldhu	r2,-16(fp)
 1818800:	10800044 	addi	r2,r2,1
 1818804:	e0bffc0d 	sth	r2,-16(fp)
 1818808:	e0bffc0b 	ldhu	r2,-16(fp)
 181880c:	10802030 	cmpltui	r2,r2,128
 1818810:	103ff41e 	bne	r2,zero,18187e4 <__ram_exceptions_end+0xff8083a0>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 1818814:	e0bffe17 	ldw	r2,-8(fp)
 1818818:	10800517 	ldw	r2,20(r2)
 181881c:	10c03b03 	ldbu	r3,236(r2)
 1818820:	1806703a 	and	r3,r3,zero
 1818824:	18c018d4 	ori	r3,r3,99
 1818828:	10c03b05 	stb	r3,236(r2)
 181882c:	10c03b43 	ldbu	r3,237(r2)
 1818830:	1806703a 	and	r3,r3,zero
 1818834:	1809883a 	mov	r4,r3
 1818838:	00ffe084 	movi	r3,-126
 181883c:	20c6b03a 	or	r3,r4,r3
 1818840:	10c03b45 	stb	r3,237(r2)
 1818844:	10c03b83 	ldbu	r3,238(r2)
 1818848:	1806703a 	and	r3,r3,zero
 181884c:	18c014d4 	ori	r3,r3,83
 1818850:	10c03b85 	stb	r3,238(r2)
 1818854:	10c03bc3 	ldbu	r3,239(r2)
 1818858:	1806703a 	and	r3,r3,zero
 181885c:	18c018d4 	ori	r3,r3,99
 1818860:	10c03bc5 	stb	r3,239(r2)
  dhcp->options_out_len = 0;
 1818864:	e0bffe17 	ldw	r2,-8(fp)
 1818868:	1000060d 	sth	zero,24(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 181886c:	e03ffc0d 	sth	zero,-16(fp)
 1818870:	00000a06 	br	181889c <dhcp_create_msg+0x540>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 1818874:	e0bffe17 	ldw	r2,-8(fp)
 1818878:	10c00517 	ldw	r3,20(r2)
 181887c:	e0bffc0b 	ldhu	r2,-16(fp)
 1818880:	e13ffc0b 	ldhu	r4,-16(fp)
 1818884:	1885883a 	add	r2,r3,r2
 1818888:	10803c04 	addi	r2,r2,240
 181888c:	11000005 	stb	r4,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 1818890:	e0bffc0b 	ldhu	r2,-16(fp)
 1818894:	10800044 	addi	r2,r2,1
 1818898:	e0bffc0d 	sth	r2,-16(fp)
 181889c:	e0bffc0b 	ldhu	r2,-16(fp)
 18188a0:	10801130 	cmpltui	r2,r2,68
 18188a4:	103ff31e 	bne	r2,zero,1818874 <__ram_exceptions_end+0xff808430>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 18188a8:	01800044 	movi	r6,1
 18188ac:	01400d44 	movi	r5,53
 18188b0:	e13ffe17 	ldw	r4,-8(fp)
 18188b4:	18173e00 	call	18173e0 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
 18188b8:	e0bfff03 	ldbu	r2,-4(fp)
 18188bc:	100b883a 	mov	r5,r2
 18188c0:	e13ffe17 	ldw	r4,-8(fp)
 18188c4:	181747c0 	call	181747c <dhcp_option_byte>
  return ERR_OK;
 18188c8:	0005883a 	mov	r2,zero
}
 18188cc:	e037883a 	mov	sp,fp
 18188d0:	dfc00117 	ldw	ra,4(sp)
 18188d4:	df000017 	ldw	fp,0(sp)
 18188d8:	dec00204 	addi	sp,sp,8
 18188dc:	f800283a 	ret

018188e0 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
 18188e0:	defffd04 	addi	sp,sp,-12
 18188e4:	dfc00215 	stw	ra,8(sp)
 18188e8:	df000115 	stw	fp,4(sp)
 18188ec:	df000104 	addi	fp,sp,4
 18188f0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
 18188f4:	e0bfff17 	ldw	r2,-4(fp)
 18188f8:	1000091e 	bne	r2,zero,1818920 <dhcp_delete_msg+0x40>
 18188fc:	01c06134 	movhi	r7,388
 1818900:	39c5ea04 	addi	r7,r7,6056
 1818904:	0181b584 	movi	r6,1750
 1818908:	01406134 	movhi	r5,388
 181890c:	29463d04 	addi	r5,r5,6388
 1818910:	01006134 	movhi	r4,388
 1818914:	2105f404 	addi	r4,r4,6096
 1818918:	1800c180 	call	1800c18 <printf>
 181891c:	003fff06 	br	181891c <__ram_exceptions_end+0xff8084d8>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 1818920:	e0bfff17 	ldw	r2,-4(fp)
 1818924:	10800417 	ldw	r2,16(r2)
 1818928:	10000426 	beq	r2,zero,181893c <dhcp_delete_msg+0x5c>
    pbuf_free(dhcp->p_out);
 181892c:	e0bfff17 	ldw	r2,-4(fp)
 1818930:	10800417 	ldw	r2,16(r2)
 1818934:	1009883a 	mov	r4,r2
 1818938:	181aca40 	call	181aca4 <pbuf_free>
  }
  dhcp->p_out = NULL;
 181893c:	e0bfff17 	ldw	r2,-4(fp)
 1818940:	10000415 	stw	zero,16(r2)
  dhcp->msg_out = NULL;
 1818944:	e0bfff17 	ldw	r2,-4(fp)
 1818948:	10000515 	stw	zero,20(r2)
}
 181894c:	0001883a 	nop
 1818950:	e037883a 	mov	sp,fp
 1818954:	dfc00117 	ldw	ra,4(sp)
 1818958:	df000017 	ldw	fp,0(sp)
 181895c:	dec00204 	addi	sp,sp,8
 1818960:	f800283a 	ret

01818964 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
 1818964:	defffd04 	addi	sp,sp,-12
 1818968:	dfc00215 	stw	ra,8(sp)
 181896c:	df000115 	stw	fp,4(sp)
 1818970:	df000104 	addi	fp,sp,4
 1818974:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 1818978:	e0bfff17 	ldw	r2,-4(fp)
 181897c:	1000091e 	bne	r2,zero,18189a4 <dhcp_option_trailer+0x40>
 1818980:	01c06134 	movhi	r7,388
 1818984:	39c5ea04 	addi	r7,r7,6056
 1818988:	0181bac4 	movi	r6,1771
 181898c:	01406134 	movhi	r5,388
 1818990:	29464504 	addi	r5,r5,6420
 1818994:	01006134 	movhi	r4,388
 1818998:	2105f404 	addi	r4,r4,6096
 181899c:	1800c180 	call	1800c18 <printf>
 18189a0:	003fff06 	br	18189a0 <__ram_exceptions_end+0xff80855c>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 18189a4:	e0bfff17 	ldw	r2,-4(fp)
 18189a8:	10c00517 	ldw	r3,20(r2)
 18189ac:	e0bfff17 	ldw	r2,-4(fp)
 18189b0:	1080060b 	ldhu	r2,24(r2)
 18189b4:	11000044 	addi	r4,r2,1
 18189b8:	200b883a 	mov	r5,r4
 18189bc:	e13fff17 	ldw	r4,-4(fp)
 18189c0:	2140060d 	sth	r5,24(r4)
 18189c4:	10bfffcc 	andi	r2,r2,65535
 18189c8:	1885883a 	add	r2,r3,r2
 18189cc:	10803c04 	addi	r2,r2,240
 18189d0:	00ffffc4 	movi	r3,-1
 18189d4:	10c00005 	stb	r3,0(r2)
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 18189d8:	00000c06 	br	1818a0c <dhcp_option_trailer+0xa8>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 18189dc:	e0bfff17 	ldw	r2,-4(fp)
 18189e0:	10c00517 	ldw	r3,20(r2)
 18189e4:	e0bfff17 	ldw	r2,-4(fp)
 18189e8:	1080060b 	ldhu	r2,24(r2)
 18189ec:	11000044 	addi	r4,r2,1
 18189f0:	200b883a 	mov	r5,r4
 18189f4:	e13fff17 	ldw	r4,-4(fp)
 18189f8:	2140060d 	sth	r5,24(r4)
 18189fc:	10bfffcc 	andi	r2,r2,65535
 1818a00:	1885883a 	add	r2,r3,r2
 1818a04:	10803c04 	addi	r2,r2,240
 1818a08:	10000005 	stb	zero,0(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 1818a0c:	e0bfff17 	ldw	r2,-4(fp)
 1818a10:	1080060b 	ldhu	r2,24(r2)
 1818a14:	10bfffcc 	andi	r2,r2,65535
 1818a18:	10801130 	cmpltui	r2,r2,68
 1818a1c:	1000051e 	bne	r2,zero,1818a34 <dhcp_option_trailer+0xd0>
 1818a20:	e0bfff17 	ldw	r2,-4(fp)
 1818a24:	1080060b 	ldhu	r2,24(r2)
 1818a28:	10bfffcc 	andi	r2,r2,65535
 1818a2c:	108000cc 	andi	r2,r2,3
 1818a30:	10000526 	beq	r2,zero,1818a48 <dhcp_option_trailer+0xe4>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
 1818a34:	e0bfff17 	ldw	r2,-4(fp)
 1818a38:	1080060b 	ldhu	r2,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 1818a3c:	10bfffcc 	andi	r2,r2,65535
 1818a40:	10801130 	cmpltui	r2,r2,68
 1818a44:	103fe51e 	bne	r2,zero,18189dc <__ram_exceptions_end+0xff808598>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
 1818a48:	0001883a 	nop
 1818a4c:	e037883a 	mov	sp,fp
 1818a50:	dfc00117 	ldw	ra,4(sp)
 1818a54:	df000017 	ldw	fp,0(sp)
 1818a58:	dec00204 	addi	sp,sp,8
 1818a5c:	f800283a 	ret

01818a60 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
 1818a60:	defffc04 	addi	sp,sp,-16
 1818a64:	df000315 	stw	fp,12(sp)
 1818a68:	df000304 	addi	fp,sp,12
 1818a6c:	e13ffe15 	stw	r4,-8(fp)
 1818a70:	e17fff15 	stw	r5,-4(fp)
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 1818a74:	e0bffe17 	ldw	r2,-8(fp)
 1818a78:	e0bffd15 	stw	r2,-12(fp)

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 1818a7c:	e0bffe17 	ldw	r2,-8(fp)
 1818a80:	10bfffe0 	cmpeqi	r2,r2,-1
 1818a84:	1000021e 	bne	r2,zero,1818a90 <ip4_addr_isbroadcast+0x30>
 1818a88:	e0bffe17 	ldw	r2,-8(fp)
 1818a8c:	1000021e 	bne	r2,zero,1818a98 <ip4_addr_isbroadcast+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
 1818a90:	00800044 	movi	r2,1
 1818a94:	00002106 	br	1818b1c <ip4_addr_isbroadcast+0xbc>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 1818a98:	e0bfff17 	ldw	r2,-4(fp)
 1818a9c:	10800e43 	ldbu	r2,57(r2)
 1818aa0:	10803fcc 	andi	r2,r2,255
 1818aa4:	1080008c 	andi	r2,r2,2
 1818aa8:	1000021e 	bne	r2,zero,1818ab4 <ip4_addr_isbroadcast+0x54>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 1818aac:	0005883a 	mov	r2,zero
 1818ab0:	00001a06 	br	1818b1c <ip4_addr_isbroadcast+0xbc>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 1818ab4:	e0bfff17 	ldw	r2,-4(fp)
 1818ab8:	10c00117 	ldw	r3,4(r2)
 1818abc:	e0bffe17 	ldw	r2,-8(fp)
 1818ac0:	1880021e 	bne	r3,r2,1818acc <ip4_addr_isbroadcast+0x6c>
    return 0;
 1818ac4:	0005883a 	mov	r2,zero
 1818ac8:	00001406 	br	1818b1c <ip4_addr_isbroadcast+0xbc>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 1818acc:	e0fffd17 	ldw	r3,-12(fp)
 1818ad0:	e0bfff17 	ldw	r2,-4(fp)
 1818ad4:	10800117 	ldw	r2,4(r2)
 1818ad8:	1886f03a 	xor	r3,r3,r2
 1818adc:	e0bfff17 	ldw	r2,-4(fp)
 1818ae0:	10800217 	ldw	r2,8(r2)
 1818ae4:	1884703a 	and	r2,r3,r2
 1818ae8:	10000b1e 	bne	r2,zero,1818b18 <ip4_addr_isbroadcast+0xb8>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 1818aec:	e0bfff17 	ldw	r2,-4(fp)
 1818af0:	10800217 	ldw	r2,8(r2)
 1818af4:	0086303a 	nor	r3,zero,r2
 1818af8:	e0bffe17 	ldw	r2,-8(fp)
 1818afc:	1886703a 	and	r3,r3,r2
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
 1818b00:	e0bfff17 	ldw	r2,-4(fp)
 1818b04:	10800217 	ldw	r2,8(r2)
 1818b08:	0084303a 	nor	r2,zero,r2
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 1818b0c:	1880021e 	bne	r3,r2,1818b18 <ip4_addr_isbroadcast+0xb8>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
 1818b10:	00800044 	movi	r2,1
 1818b14:	00000106 	br	1818b1c <ip4_addr_isbroadcast+0xbc>
  } else {
    return 0;
 1818b18:	0005883a 	mov	r2,zero
  }
}
 1818b1c:	e037883a 	mov	sp,fp
 1818b20:	df000017 	ldw	fp,0(sp)
 1818b24:	dec00104 	addi	sp,sp,4
 1818b28:	f800283a 	ret

01818b2c <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
 1818b2c:	defffc04 	addi	sp,sp,-16
 1818b30:	df000315 	stw	fp,12(sp)
 1818b34:	df000304 	addi	fp,sp,12
 1818b38:	e13fff15 	stw	r4,-4(fp)
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
 1818b3c:	e0bfff17 	ldw	r2,-4(fp)
 1818b40:	1006d63a 	srli	r3,r2,24
 1818b44:	e0bfff17 	ldw	r2,-4(fp)
 1818b48:	1004d23a 	srli	r2,r2,8
 1818b4c:	10bfc00c 	andi	r2,r2,65280
 1818b50:	1886b03a 	or	r3,r3,r2
 1818b54:	e0bfff17 	ldw	r2,-4(fp)
 1818b58:	10bfc00c 	andi	r2,r2,65280
 1818b5c:	1004923a 	slli	r2,r2,8
 1818b60:	1886b03a 	or	r3,r3,r2
 1818b64:	e0bfff17 	ldw	r2,-4(fp)
 1818b68:	1004963a 	slli	r2,r2,24
 1818b6c:	1884b03a 	or	r2,r3,r2
 1818b70:	e0bffe15 	stw	r2,-8(fp)

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 1818b74:	00a00034 	movhi	r2,32768
 1818b78:	e0bffd15 	stw	r2,-12(fp)
 1818b7c:	00000706 	br	1818b9c <ip4_addr_netmask_valid+0x70>
    if ((nm_hostorder & mask) == 0) {
 1818b80:	e0fffe17 	ldw	r3,-8(fp)
 1818b84:	e0bffd17 	ldw	r2,-12(fp)
 1818b88:	1884703a 	and	r2,r3,r2
 1818b8c:	10000626 	beq	r2,zero,1818ba8 <ip4_addr_netmask_valid+0x7c>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 1818b90:	e0bffd17 	ldw	r2,-12(fp)
 1818b94:	1004d07a 	srli	r2,r2,1
 1818b98:	e0bffd15 	stw	r2,-12(fp)
 1818b9c:	e0bffd17 	ldw	r2,-12(fp)
 1818ba0:	103ff71e 	bne	r2,zero,1818b80 <__ram_exceptions_end+0xff80873c>
 1818ba4:	00000b06 	br	1818bd4 <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) == 0) {
      break;
 1818ba8:	0001883a 	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 1818bac:	00000906 	br	1818bd4 <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) != 0) {
 1818bb0:	e0fffe17 	ldw	r3,-8(fp)
 1818bb4:	e0bffd17 	ldw	r2,-12(fp)
 1818bb8:	1884703a 	and	r2,r3,r2
 1818bbc:	10000226 	beq	r2,zero,1818bc8 <ip4_addr_netmask_valid+0x9c>
      /* there is a one after the first zero -> invalid */
      return 0;
 1818bc0:	0005883a 	mov	r2,zero
 1818bc4:	00000606 	br	1818be0 <ip4_addr_netmask_valid+0xb4>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 1818bc8:	e0bffd17 	ldw	r2,-12(fp)
 1818bcc:	1004d07a 	srli	r2,r2,1
 1818bd0:	e0bffd15 	stw	r2,-12(fp)
 1818bd4:	e0bffd17 	ldw	r2,-12(fp)
 1818bd8:	103ff51e 	bne	r2,zero,1818bb0 <__ram_exceptions_end+0xff80876c>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
 1818bdc:	00800044 	movi	r2,1
}
 1818be0:	e037883a 	mov	sp,fp
 1818be4:	df000017 	ldw	fp,0(sp)
 1818be8:	dec00104 	addi	sp,sp,4
 1818bec:	f800283a 	ret

01818bf0 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
 1818bf0:	defffc04 	addi	sp,sp,-16
 1818bf4:	dfc00315 	stw	ra,12(sp)
 1818bf8:	df000215 	stw	fp,8(sp)
 1818bfc:	df000204 	addi	fp,sp,8
 1818c00:	e13fff15 	stw	r4,-4(fp)
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
 1818c04:	e17ffe04 	addi	r5,fp,-8
 1818c08:	e13fff17 	ldw	r4,-4(fp)
 1818c0c:	1818c340 	call	1818c34 <ipaddr_aton>
 1818c10:	10000226 	beq	r2,zero,1818c1c <ipaddr_addr+0x2c>
    return ip4_addr_get_u32(&val);
 1818c14:	e0bffe17 	ldw	r2,-8(fp)
 1818c18:	00000106 	br	1818c20 <ipaddr_addr+0x30>
  }
  return (IPADDR_NONE);
 1818c1c:	00bfffc4 	movi	r2,-1
}
 1818c20:	e037883a 	mov	sp,fp
 1818c24:	dfc00117 	ldw	ra,4(sp)
 1818c28:	df000017 	ldw	fp,0(sp)
 1818c2c:	dec00204 	addi	sp,sp,8
 1818c30:	f800283a 	ret

01818c34 <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 1818c34:	defff604 	addi	sp,sp,-40
 1818c38:	df000915 	stw	fp,36(sp)
 1818c3c:	df000904 	addi	fp,sp,36
 1818c40:	e13ffe15 	stw	r4,-8(fp)
 1818c44:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 1818c48:	e0bffa04 	addi	r2,fp,-24
 1818c4c:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
 1818c50:	e0bffe17 	ldw	r2,-8(fp)
 1818c54:	10800003 	ldbu	r2,0(r2)
 1818c58:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 1818c5c:	e0bff843 	ldbu	r2,-31(fp)
 1818c60:	10803fcc 	andi	r2,r2,255
 1818c64:	10800c30 	cmpltui	r2,r2,48
 1818c68:	1000041e 	bne	r2,zero,1818c7c <ipaddr_aton+0x48>
 1818c6c:	e0bff843 	ldbu	r2,-31(fp)
 1818c70:	10803fcc 	andi	r2,r2,255
 1818c74:	10800eb0 	cmpltui	r2,r2,58
 1818c78:	1000021e 	bne	r2,zero,1818c84 <ipaddr_aton+0x50>
      return (0);
 1818c7c:	0005883a 	mov	r2,zero
 1818c80:	0000e606 	br	181901c <ipaddr_aton+0x3e8>
    val = 0;
 1818c84:	e03ff715 	stw	zero,-36(fp)
    base = 10;
 1818c88:	00800284 	movi	r2,10
 1818c8c:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
 1818c90:	e0bff847 	ldb	r2,-31(fp)
 1818c94:	10800c18 	cmpnei	r2,r2,48
 1818c98:	1000171e 	bne	r2,zero,1818cf8 <ipaddr_aton+0xc4>
      c = *++cp;
 1818c9c:	e0bffe17 	ldw	r2,-8(fp)
 1818ca0:	10800044 	addi	r2,r2,1
 1818ca4:	e0bffe15 	stw	r2,-8(fp)
 1818ca8:	e0bffe17 	ldw	r2,-8(fp)
 1818cac:	10800003 	ldbu	r2,0(r2)
 1818cb0:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
 1818cb4:	e0bff847 	ldb	r2,-31(fp)
 1818cb8:	10801e20 	cmpeqi	r2,r2,120
 1818cbc:	1000031e 	bne	r2,zero,1818ccc <ipaddr_aton+0x98>
 1818cc0:	e0bff847 	ldb	r2,-31(fp)
 1818cc4:	10801618 	cmpnei	r2,r2,88
 1818cc8:	1000091e 	bne	r2,zero,1818cf0 <ipaddr_aton+0xbc>
        base = 16;
 1818ccc:	00800404 	movi	r2,16
 1818cd0:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
 1818cd4:	e0bffe17 	ldw	r2,-8(fp)
 1818cd8:	10800044 	addi	r2,r2,1
 1818cdc:	e0bffe15 	stw	r2,-8(fp)
 1818ce0:	e0bffe17 	ldw	r2,-8(fp)
 1818ce4:	10800003 	ldbu	r2,0(r2)
 1818ce8:	e0bff845 	stb	r2,-31(fp)
 1818cec:	00000206 	br	1818cf8 <ipaddr_aton+0xc4>
      } else
        base = 8;
 1818cf0:	00800204 	movi	r2,8
 1818cf4:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
 1818cf8:	e0bff843 	ldbu	r2,-31(fp)
 1818cfc:	10803fcc 	andi	r2,r2,255
 1818d00:	10800c30 	cmpltui	r2,r2,48
 1818d04:	1000121e 	bne	r2,zero,1818d50 <ipaddr_aton+0x11c>
 1818d08:	e0bff843 	ldbu	r2,-31(fp)
 1818d0c:	10803fcc 	andi	r2,r2,255
 1818d10:	10800ea8 	cmpgeui	r2,r2,58
 1818d14:	10000e1e 	bne	r2,zero,1818d50 <ipaddr_aton+0x11c>
        val = (val * base) + (int)(c - '0');
 1818d18:	e0fff803 	ldbu	r3,-32(fp)
 1818d1c:	e0bff717 	ldw	r2,-36(fp)
 1818d20:	1887383a 	mul	r3,r3,r2
 1818d24:	e0bff847 	ldb	r2,-31(fp)
 1818d28:	1885883a 	add	r2,r3,r2
 1818d2c:	10bff404 	addi	r2,r2,-48
 1818d30:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 1818d34:	e0bffe17 	ldw	r2,-8(fp)
 1818d38:	10800044 	addi	r2,r2,1
 1818d3c:	e0bffe15 	stw	r2,-8(fp)
 1818d40:	e0bffe17 	ldw	r2,-8(fp)
 1818d44:	10800003 	ldbu	r2,0(r2)
 1818d48:	e0bff845 	stb	r2,-31(fp)
 1818d4c:	00003306 	br	1818e1c <ipaddr_aton+0x1e8>
      } else if (base == 16 && isxdigit(c)) {
 1818d50:	e0bff803 	ldbu	r2,-32(fp)
 1818d54:	10800418 	cmpnei	r2,r2,16
 1818d58:	1000311e 	bne	r2,zero,1818e20 <ipaddr_aton+0x1ec>
 1818d5c:	e0bff843 	ldbu	r2,-31(fp)
 1818d60:	10803fcc 	andi	r2,r2,255
 1818d64:	10800c30 	cmpltui	r2,r2,48
 1818d68:	1000041e 	bne	r2,zero,1818d7c <ipaddr_aton+0x148>
 1818d6c:	e0bff843 	ldbu	r2,-31(fp)
 1818d70:	10803fcc 	andi	r2,r2,255
 1818d74:	10800eb0 	cmpltui	r2,r2,58
 1818d78:	1000101e 	bne	r2,zero,1818dbc <ipaddr_aton+0x188>
 1818d7c:	e0bff843 	ldbu	r2,-31(fp)
 1818d80:	10803fcc 	andi	r2,r2,255
 1818d84:	10801870 	cmpltui	r2,r2,97
 1818d88:	1000041e 	bne	r2,zero,1818d9c <ipaddr_aton+0x168>
 1818d8c:	e0bff843 	ldbu	r2,-31(fp)
 1818d90:	10803fcc 	andi	r2,r2,255
 1818d94:	108019f0 	cmpltui	r2,r2,103
 1818d98:	1000081e 	bne	r2,zero,1818dbc <ipaddr_aton+0x188>
 1818d9c:	e0bff843 	ldbu	r2,-31(fp)
 1818da0:	10803fcc 	andi	r2,r2,255
 1818da4:	10801070 	cmpltui	r2,r2,65
 1818da8:	10001d1e 	bne	r2,zero,1818e20 <ipaddr_aton+0x1ec>
 1818dac:	e0bff843 	ldbu	r2,-31(fp)
 1818db0:	10803fcc 	andi	r2,r2,255
 1818db4:	108011e8 	cmpgeui	r2,r2,71
 1818db8:	1000191e 	bne	r2,zero,1818e20 <ipaddr_aton+0x1ec>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 1818dbc:	e0bff717 	ldw	r2,-36(fp)
 1818dc0:	1006913a 	slli	r3,r2,4
 1818dc4:	e0bff847 	ldb	r2,-31(fp)
 1818dc8:	11000284 	addi	r4,r2,10
 1818dcc:	e0bff843 	ldbu	r2,-31(fp)
 1818dd0:	10803fcc 	andi	r2,r2,255
 1818dd4:	10801870 	cmpltui	r2,r2,97
 1818dd8:	1000061e 	bne	r2,zero,1818df4 <ipaddr_aton+0x1c0>
 1818ddc:	e0bff843 	ldbu	r2,-31(fp)
 1818de0:	10803fcc 	andi	r2,r2,255
 1818de4:	10801ee8 	cmpgeui	r2,r2,123
 1818de8:	1000021e 	bne	r2,zero,1818df4 <ipaddr_aton+0x1c0>
 1818dec:	00801844 	movi	r2,97
 1818df0:	00000106 	br	1818df8 <ipaddr_aton+0x1c4>
 1818df4:	00801044 	movi	r2,65
 1818df8:	2085c83a 	sub	r2,r4,r2
 1818dfc:	1884b03a 	or	r2,r3,r2
 1818e00:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 1818e04:	e0bffe17 	ldw	r2,-8(fp)
 1818e08:	10800044 	addi	r2,r2,1
 1818e0c:	e0bffe15 	stw	r2,-8(fp)
 1818e10:	e0bffe17 	ldw	r2,-8(fp)
 1818e14:	10800003 	ldbu	r2,0(r2)
 1818e18:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
 1818e1c:	003fb606 	br	1818cf8 <__ram_exceptions_end+0xff8088b4>
    if (c == '.') {
 1818e20:	e0bff847 	ldb	r2,-31(fp)
 1818e24:	10800b98 	cmpnei	r2,r2,46
 1818e28:	1000121e 	bne	r2,zero,1818e74 <ipaddr_aton+0x240>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 1818e2c:	e0bffa04 	addi	r2,fp,-24
 1818e30:	10800304 	addi	r2,r2,12
 1818e34:	e0fff917 	ldw	r3,-28(fp)
 1818e38:	18800236 	bltu	r3,r2,1818e44 <ipaddr_aton+0x210>
        return (0);
 1818e3c:	0005883a 	mov	r2,zero
 1818e40:	00007606 	br	181901c <ipaddr_aton+0x3e8>
      }
      *pp++ = val;
 1818e44:	e0bff917 	ldw	r2,-28(fp)
 1818e48:	10c00104 	addi	r3,r2,4
 1818e4c:	e0fff915 	stw	r3,-28(fp)
 1818e50:	e0fff717 	ldw	r3,-36(fp)
 1818e54:	10c00015 	stw	r3,0(r2)
      c = *++cp;
 1818e58:	e0bffe17 	ldw	r2,-8(fp)
 1818e5c:	10800044 	addi	r2,r2,1
 1818e60:	e0bffe15 	stw	r2,-8(fp)
 1818e64:	e0bffe17 	ldw	r2,-8(fp)
 1818e68:	10800003 	ldbu	r2,0(r2)
 1818e6c:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
 1818e70:	003f7a06 	br	1818c5c <__ram_exceptions_end+0xff808818>
        return (0);
      }
      *pp++ = val;
      c = *++cp;
    } else
      break;
 1818e74:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 1818e78:	e0bff847 	ldb	r2,-31(fp)
 1818e7c:	10001426 	beq	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818e80:	e0bff847 	ldb	r2,-31(fp)
 1818e84:	10800820 	cmpeqi	r2,r2,32
 1818e88:	1000111e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818e8c:	e0bff847 	ldb	r2,-31(fp)
 1818e90:	10800320 	cmpeqi	r2,r2,12
 1818e94:	10000e1e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818e98:	e0bff847 	ldb	r2,-31(fp)
 1818e9c:	108002a0 	cmpeqi	r2,r2,10
 1818ea0:	10000b1e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818ea4:	e0bff847 	ldb	r2,-31(fp)
 1818ea8:	10800360 	cmpeqi	r2,r2,13
 1818eac:	1000081e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818eb0:	e0bff847 	ldb	r2,-31(fp)
 1818eb4:	10800260 	cmpeqi	r2,r2,9
 1818eb8:	1000051e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
 1818ebc:	e0bff847 	ldb	r2,-31(fp)
 1818ec0:	108002e0 	cmpeqi	r2,r2,11
 1818ec4:	1000021e 	bne	r2,zero,1818ed0 <ipaddr_aton+0x29c>
    return (0);
 1818ec8:	0005883a 	mov	r2,zero
 1818ecc:	00005306 	br	181901c <ipaddr_aton+0x3e8>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 1818ed0:	e0fff917 	ldw	r3,-28(fp)
 1818ed4:	e0bffa04 	addi	r2,fp,-24
 1818ed8:	1885c83a 	sub	r2,r3,r2
 1818edc:	1005d0ba 	srai	r2,r2,2
 1818ee0:	10800044 	addi	r2,r2,1
 1818ee4:	10c00168 	cmpgeui	r3,r2,5
 1818ee8:	1800371e 	bne	r3,zero,1818fc8 <ipaddr_aton+0x394>
 1818eec:	100690ba 	slli	r3,r2,2
 1818ef0:	008060b4 	movhi	r2,386
 1818ef4:	10a3c104 	addi	r2,r2,-28924
 1818ef8:	1885883a 	add	r2,r3,r2
 1818efc:	10800017 	ldw	r2,0(r2)
 1818f00:	1000683a 	jmp	r2
 1818f04:	01818f18 	cmpnei	r6,zero,1596
 1818f08:	01818fd0 	cmplti	r6,zero,1599
 1818f0c:	01818f20 	cmpeqi	r6,zero,1596
 1818f10:	01818f4c 	andi	r6,zero,1597
 1818f14:	01818f84 	movi	r6,1598

  case 0:
    return (0);       /* initial nondigit */
 1818f18:	0005883a 	mov	r2,zero
 1818f1c:	00003f06 	br	181901c <ipaddr_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 1818f20:	e0fff717 	ldw	r3,-36(fp)
 1818f24:	00804034 	movhi	r2,256
 1818f28:	18800236 	bltu	r3,r2,1818f34 <ipaddr_aton+0x300>
      return (0);
 1818f2c:	0005883a 	mov	r2,zero
 1818f30:	00003a06 	br	181901c <ipaddr_aton+0x3e8>
    }
    val |= parts[0] << 24;
 1818f34:	e0bffa17 	ldw	r2,-24(fp)
 1818f38:	1004963a 	slli	r2,r2,24
 1818f3c:	e0fff717 	ldw	r3,-36(fp)
 1818f40:	1884b03a 	or	r2,r3,r2
 1818f44:	e0bff715 	stw	r2,-36(fp)
    break;
 1818f48:	00002206 	br	1818fd4 <ipaddr_aton+0x3a0>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
 1818f4c:	e0bff717 	ldw	r2,-36(fp)
 1818f50:	00ffffd4 	movui	r3,65535
 1818f54:	1880022e 	bgeu	r3,r2,1818f60 <ipaddr_aton+0x32c>
      return (0);
 1818f58:	0005883a 	mov	r2,zero
 1818f5c:	00002f06 	br	181901c <ipaddr_aton+0x3e8>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
 1818f60:	e0bffa17 	ldw	r2,-24(fp)
 1818f64:	1006963a 	slli	r3,r2,24
 1818f68:	e0bffb17 	ldw	r2,-20(fp)
 1818f6c:	1004943a 	slli	r2,r2,16
 1818f70:	1884b03a 	or	r2,r3,r2
 1818f74:	e0fff717 	ldw	r3,-36(fp)
 1818f78:	1884b03a 	or	r2,r3,r2
 1818f7c:	e0bff715 	stw	r2,-36(fp)
    break;
 1818f80:	00001406 	br	1818fd4 <ipaddr_aton+0x3a0>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
 1818f84:	e0bff717 	ldw	r2,-36(fp)
 1818f88:	10804030 	cmpltui	r2,r2,256
 1818f8c:	1000021e 	bne	r2,zero,1818f98 <ipaddr_aton+0x364>
      return (0);
 1818f90:	0005883a 	mov	r2,zero
 1818f94:	00002106 	br	181901c <ipaddr_aton+0x3e8>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 1818f98:	e0bffa17 	ldw	r2,-24(fp)
 1818f9c:	1006963a 	slli	r3,r2,24
 1818fa0:	e0bffb17 	ldw	r2,-20(fp)
 1818fa4:	1004943a 	slli	r2,r2,16
 1818fa8:	1886b03a 	or	r3,r3,r2
 1818fac:	e0bffc17 	ldw	r2,-16(fp)
 1818fb0:	1004923a 	slli	r2,r2,8
 1818fb4:	1884b03a 	or	r2,r3,r2
 1818fb8:	e0fff717 	ldw	r3,-36(fp)
 1818fbc:	1884b03a 	or	r2,r3,r2
 1818fc0:	e0bff715 	stw	r2,-36(fp)
    break;
 1818fc4:	00000306 	br	1818fd4 <ipaddr_aton+0x3a0>
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
 1818fc8:	0001883a 	nop
 1818fcc:	00000106 	br	1818fd4 <ipaddr_aton+0x3a0>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
 1818fd0:	0001883a 	nop
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
 1818fd4:	e0bfff17 	ldw	r2,-4(fp)
 1818fd8:	10000f26 	beq	r2,zero,1819018 <ipaddr_aton+0x3e4>
    ip4_addr_set_u32(addr, htonl(val));
 1818fdc:	e0bff717 	ldw	r2,-36(fp)
 1818fe0:	1006d63a 	srli	r3,r2,24
 1818fe4:	e0bff717 	ldw	r2,-36(fp)
 1818fe8:	1004d23a 	srli	r2,r2,8
 1818fec:	10bfc00c 	andi	r2,r2,65280
 1818ff0:	1886b03a 	or	r3,r3,r2
 1818ff4:	e0bff717 	ldw	r2,-36(fp)
 1818ff8:	10bfc00c 	andi	r2,r2,65280
 1818ffc:	1004923a 	slli	r2,r2,8
 1819000:	1886b03a 	or	r3,r3,r2
 1819004:	e0bff717 	ldw	r2,-36(fp)
 1819008:	1004963a 	slli	r2,r2,24
 181900c:	1886b03a 	or	r3,r3,r2
 1819010:	e0bfff17 	ldw	r2,-4(fp)
 1819014:	10c00015 	stw	r3,0(r2)
  }
  return (1);
 1819018:	00800044 	movi	r2,1
}
 181901c:	e037883a 	mov	sp,fp
 1819020:	df000017 	ldw	fp,0(sp)
 1819024:	dec00104 	addi	sp,sp,4
 1819028:	f800283a 	ret

0181902c <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
 181902c:	defffd04 	addi	sp,sp,-12
 1819030:	dfc00215 	stw	ra,8(sp)
 1819034:	df000115 	stw	fp,4(sp)
 1819038:	df000104 	addi	fp,sp,4
 181903c:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
 1819040:	01800404 	movi	r6,16
 1819044:	01406134 	movhi	r5,388
 1819048:	295fbb04 	addi	r5,r5,32492
 181904c:	e13fff17 	ldw	r4,-4(fp)
 1819050:	18190680 	call	1819068 <ipaddr_ntoa_r>
}
 1819054:	e037883a 	mov	sp,fp
 1819058:	dfc00117 	ldw	ra,4(sp)
 181905c:	df000017 	ldw	fp,0(sp)
 1819060:	dec00204 	addi	sp,sp,8
 1819064:	f800283a 	ret

01819068 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
 1819068:	defff404 	addi	sp,sp,-48
 181906c:	dfc00b15 	stw	ra,44(sp)
 1819070:	df000a15 	stw	fp,40(sp)
 1819074:	df000a04 	addi	fp,sp,40
 1819078:	e13ffd15 	stw	r4,-12(fp)
 181907c:	e17ffe15 	stw	r5,-8(fp)
 1819080:	e1bfff15 	stw	r6,-4(fp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 1819084:	e03ff915 	stw	zero,-28(fp)

  s_addr = ip4_addr_get_u32(addr);
 1819088:	e0bffd17 	ldw	r2,-12(fp)
 181908c:	10800017 	ldw	r2,0(r2)
 1819090:	e0bffb15 	stw	r2,-20(fp)

  rp = buf;
 1819094:	e0bffe17 	ldw	r2,-8(fp)
 1819098:	e0bff615 	stw	r2,-40(fp)
  ap = (u8_t *)&s_addr;
 181909c:	e0bffb04 	addi	r2,fp,-20
 18190a0:	e0bff715 	stw	r2,-36(fp)
  for(n = 0; n < 4; n++) {
 18190a4:	e03ff805 	stb	zero,-32(fp)
 18190a8:	00004606 	br	18191c4 <ipaddr_ntoa_r+0x15c>
    i = 0;
 18190ac:	e03ff845 	stb	zero,-31(fp)
    do {
      rem = *ap % (u8_t)10;
 18190b0:	e0bff717 	ldw	r2,-36(fp)
 18190b4:	10800003 	ldbu	r2,0(r2)
 18190b8:	10803fcc 	andi	r2,r2,255
 18190bc:	01400284 	movi	r5,10
 18190c0:	1009883a 	mov	r4,r2
 18190c4:	180ad740 	call	180ad74 <__umodsi3>
 18190c8:	e0bffa05 	stb	r2,-24(fp)
      *ap /= (u8_t)10;
 18190cc:	e0bff717 	ldw	r2,-36(fp)
 18190d0:	10800003 	ldbu	r2,0(r2)
 18190d4:	10803fcc 	andi	r2,r2,255
 18190d8:	01400284 	movi	r5,10
 18190dc:	1009883a 	mov	r4,r2
 18190e0:	180ad100 	call	180ad10 <__udivsi3>
 18190e4:	1007883a 	mov	r3,r2
 18190e8:	e0bff717 	ldw	r2,-36(fp)
 18190ec:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
 18190f0:	e0bff843 	ldbu	r2,-31(fp)
 18190f4:	10c00044 	addi	r3,r2,1
 18190f8:	e0fff845 	stb	r3,-31(fp)
 18190fc:	10803fcc 	andi	r2,r2,255
 1819100:	e0fffa03 	ldbu	r3,-24(fp)
 1819104:	18c00c04 	addi	r3,r3,48
 1819108:	1809883a 	mov	r4,r3
 181910c:	e0fffc04 	addi	r3,fp,-16
 1819110:	1885883a 	add	r2,r3,r2
 1819114:	11000005 	stb	r4,0(r2)
    } while(*ap);
 1819118:	e0bff717 	ldw	r2,-36(fp)
 181911c:	10800003 	ldbu	r2,0(r2)
 1819120:	10803fcc 	andi	r2,r2,255
 1819124:	103fe21e 	bne	r2,zero,18190b0 <__ram_exceptions_end+0xff808c6c>
    while(i--) {
 1819128:	00000f06 	br	1819168 <ipaddr_ntoa_r+0x100>
      if (len++ >= buflen) {
 181912c:	e0bff917 	ldw	r2,-28(fp)
 1819130:	10c00044 	addi	r3,r2,1
 1819134:	e0fff915 	stw	r3,-28(fp)
 1819138:	e0ffff17 	ldw	r3,-4(fp)
 181913c:	10c00216 	blt	r2,r3,1819148 <ipaddr_ntoa_r+0xe0>
        return NULL;
 1819140:	0005883a 	mov	r2,zero
 1819144:	00002806 	br	18191e8 <ipaddr_ntoa_r+0x180>
      }
      *rp++ = inv[i];
 1819148:	e0bff617 	ldw	r2,-40(fp)
 181914c:	10c00044 	addi	r3,r2,1
 1819150:	e0fff615 	stw	r3,-40(fp)
 1819154:	e0fff843 	ldbu	r3,-31(fp)
 1819158:	e13ffc04 	addi	r4,fp,-16
 181915c:	20c7883a 	add	r3,r4,r3
 1819160:	18c00003 	ldbu	r3,0(r3)
 1819164:	10c00005 	stb	r3,0(r2)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 1819168:	e0bff843 	ldbu	r2,-31(fp)
 181916c:	10ffffc4 	addi	r3,r2,-1
 1819170:	e0fff845 	stb	r3,-31(fp)
 1819174:	10803fcc 	andi	r2,r2,255
 1819178:	103fec1e 	bne	r2,zero,181912c <__ram_exceptions_end+0xff808ce8>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
 181917c:	e0bff917 	ldw	r2,-28(fp)
 1819180:	10c00044 	addi	r3,r2,1
 1819184:	e0fff915 	stw	r3,-28(fp)
 1819188:	e0ffff17 	ldw	r3,-4(fp)
 181918c:	10c00216 	blt	r2,r3,1819198 <ipaddr_ntoa_r+0x130>
      return NULL;
 1819190:	0005883a 	mov	r2,zero
 1819194:	00001406 	br	18191e8 <ipaddr_ntoa_r+0x180>
    }
    *rp++ = '.';
 1819198:	e0bff617 	ldw	r2,-40(fp)
 181919c:	10c00044 	addi	r3,r2,1
 18191a0:	e0fff615 	stw	r3,-40(fp)
 18191a4:	00c00b84 	movi	r3,46
 18191a8:	10c00005 	stb	r3,0(r2)
    ap++;
 18191ac:	e0bff717 	ldw	r2,-36(fp)
 18191b0:	10800044 	addi	r2,r2,1
 18191b4:	e0bff715 	stw	r2,-36(fp)

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 18191b8:	e0bff803 	ldbu	r2,-32(fp)
 18191bc:	10800044 	addi	r2,r2,1
 18191c0:	e0bff805 	stb	r2,-32(fp)
 18191c4:	e0bff803 	ldbu	r2,-32(fp)
 18191c8:	10800130 	cmpltui	r2,r2,4
 18191cc:	103fb71e 	bne	r2,zero,18190ac <__ram_exceptions_end+0xff808c68>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 18191d0:	e0bff617 	ldw	r2,-40(fp)
 18191d4:	10bfffc4 	addi	r2,r2,-1
 18191d8:	e0bff615 	stw	r2,-40(fp)
 18191dc:	e0bff617 	ldw	r2,-40(fp)
 18191e0:	10000005 	stb	zero,0(r2)
  return buf;
 18191e4:	e0bffe17 	ldw	r2,-8(fp)
}
 18191e8:	e037883a 	mov	sp,fp
 18191ec:	dfc00117 	ldw	ra,4(sp)
 18191f0:	df000017 	ldw	fp,0(sp)
 18191f4:	dec00204 	addi	sp,sp,8
 18191f8:	f800283a 	ret

018191fc <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 18191fc:	defffc04 	addi	sp,sp,-16
 1819200:	df000315 	stw	fp,12(sp)
 1819204:	df000304 	addi	fp,sp,12
 1819208:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
 181920c:	d0e7ee17 	ldw	r3,-24648(gp)
 1819210:	e0bfff17 	ldw	r2,-4(fp)
 1819214:	1080000b 	ldhu	r2,0(r2)
 1819218:	10bfffcc 	andi	r2,r2,65535
 181921c:	1885883a 	add	r2,r3,r2
 1819220:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 1819224:	e0ffff17 	ldw	r3,-4(fp)
 1819228:	e0bffd17 	ldw	r2,-12(fp)
 181922c:	18801926 	beq	r3,r2,1819294 <plug_holes+0x98>
 1819230:	e0bffd17 	ldw	r2,-12(fp)
 1819234:	10800103 	ldbu	r2,4(r2)
 1819238:	10803fcc 	andi	r2,r2,255
 181923c:	1000151e 	bne	r2,zero,1819294 <plug_holes+0x98>
 1819240:	d0a7ef17 	ldw	r2,-24644(gp)
 1819244:	e0fffd17 	ldw	r3,-12(fp)
 1819248:	18801226 	beq	r3,r2,1819294 <plug_holes+0x98>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 181924c:	d0e7f017 	ldw	r3,-24640(gp)
 1819250:	e0bffd17 	ldw	r2,-12(fp)
 1819254:	1880021e 	bne	r3,r2,1819260 <plug_holes+0x64>
      lfree = mem;
 1819258:	e0bfff17 	ldw	r2,-4(fp)
 181925c:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem->next = nmem->next;
 1819260:	e0bffd17 	ldw	r2,-12(fp)
 1819264:	10c0000b 	ldhu	r3,0(r2)
 1819268:	e0bfff17 	ldw	r2,-4(fp)
 181926c:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 1819270:	d0e7ee17 	ldw	r3,-24648(gp)
 1819274:	e0bffd17 	ldw	r2,-12(fp)
 1819278:	1080000b 	ldhu	r2,0(r2)
 181927c:	10bfffcc 	andi	r2,r2,65535
 1819280:	1885883a 	add	r2,r3,r2
 1819284:	e0ffff17 	ldw	r3,-4(fp)
 1819288:	d127ee17 	ldw	r4,-24648(gp)
 181928c:	1907c83a 	sub	r3,r3,r4
 1819290:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 1819294:	d0e7ee17 	ldw	r3,-24648(gp)
 1819298:	e0bfff17 	ldw	r2,-4(fp)
 181929c:	1080008b 	ldhu	r2,2(r2)
 18192a0:	10bfffcc 	andi	r2,r2,65535
 18192a4:	1885883a 	add	r2,r3,r2
 18192a8:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
 18192ac:	e0fffe17 	ldw	r3,-8(fp)
 18192b0:	e0bfff17 	ldw	r2,-4(fp)
 18192b4:	18801626 	beq	r3,r2,1819310 <plug_holes+0x114>
 18192b8:	e0bffe17 	ldw	r2,-8(fp)
 18192bc:	10800103 	ldbu	r2,4(r2)
 18192c0:	10803fcc 	andi	r2,r2,255
 18192c4:	1000121e 	bne	r2,zero,1819310 <plug_holes+0x114>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 18192c8:	d0e7f017 	ldw	r3,-24640(gp)
 18192cc:	e0bfff17 	ldw	r2,-4(fp)
 18192d0:	1880021e 	bne	r3,r2,18192dc <plug_holes+0xe0>
      lfree = pmem;
 18192d4:	e0bffe17 	ldw	r2,-8(fp)
 18192d8:	d0a7f015 	stw	r2,-24640(gp)
    }
    pmem->next = mem->next;
 18192dc:	e0bfff17 	ldw	r2,-4(fp)
 18192e0:	10c0000b 	ldhu	r3,0(r2)
 18192e4:	e0bffe17 	ldw	r2,-8(fp)
 18192e8:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 18192ec:	d0e7ee17 	ldw	r3,-24648(gp)
 18192f0:	e0bfff17 	ldw	r2,-4(fp)
 18192f4:	1080000b 	ldhu	r2,0(r2)
 18192f8:	10bfffcc 	andi	r2,r2,65535
 18192fc:	1885883a 	add	r2,r3,r2
 1819300:	e0fffe17 	ldw	r3,-8(fp)
 1819304:	d127ee17 	ldw	r4,-24648(gp)
 1819308:	1907c83a 	sub	r3,r3,r4
 181930c:	10c0008d 	sth	r3,2(r2)
  }
}
 1819310:	0001883a 	nop
 1819314:	e037883a 	mov	sp,fp
 1819318:	df000017 	ldw	fp,0(sp)
 181931c:	dec00104 	addi	sp,sp,4
 1819320:	f800283a 	ret

01819324 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 1819324:	defffd04 	addi	sp,sp,-12
 1819328:	dfc00215 	stw	ra,8(sp)
 181932c:	df000115 	stw	fp,4(sp)
 1819330:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 1819334:	008061b4 	movhi	r2,390
 1819338:	1089cf04 	addi	r2,r2,10044
 181933c:	10c000c4 	addi	r3,r2,3
 1819340:	00bfff04 	movi	r2,-4
 1819344:	1884703a 	and	r2,r3,r2
 1819348:	d0a7ee15 	stw	r2,-24648(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 181934c:	d0a7ee17 	ldw	r2,-24648(gp)
 1819350:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
 1819354:	e0bfff17 	ldw	r2,-4(fp)
 1819358:	00e00004 	movi	r3,-32768
 181935c:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
 1819360:	e0bfff17 	ldw	r2,-4(fp)
 1819364:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
 1819368:	e0bfff17 	ldw	r2,-4(fp)
 181936c:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 1819370:	d0e7ee17 	ldw	r3,-24648(gp)
 1819374:	00a00014 	movui	r2,32768
 1819378:	1885883a 	add	r2,r3,r2
 181937c:	d0a7ef15 	stw	r2,-24644(gp)
  ram_end->used = 1;
 1819380:	d0a7ef17 	ldw	r2,-24644(gp)
 1819384:	00c00044 	movi	r3,1
 1819388:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
 181938c:	d0a7ef17 	ldw	r2,-24644(gp)
 1819390:	00e00004 	movi	r3,-32768
 1819394:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
 1819398:	d0a7ef17 	ldw	r2,-24644(gp)
 181939c:	00e00004 	movi	r3,-32768
 18193a0:	10c0008d 	sth	r3,2(r2)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 18193a4:	d0a7ee17 	ldw	r2,-24648(gp)
 18193a8:	d0a7f015 	stw	r2,-24640(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 18193ac:	008061f4 	movhi	r2,391
 18193b0:	10a9d404 	addi	r2,r2,-22704
 18193b4:	00e00004 	movi	r3,-32768
 18193b8:	10c0540d 	sth	r3,336(r2)

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 18193bc:	d127f104 	addi	r4,gp,-24636
 18193c0:	18151980 	call	1815198 <sys_mutex_new>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 18193c4:	0001883a 	nop
 18193c8:	e037883a 	mov	sp,fp
 18193cc:	dfc00117 	ldw	ra,4(sp)
 18193d0:	df000017 	ldw	fp,0(sp)
 18193d4:	dec00204 	addi	sp,sp,8
 18193d8:	f800283a 	ret

018193dc <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 18193dc:	defffc04 	addi	sp,sp,-16
 18193e0:	dfc00315 	stw	ra,12(sp)
 18193e4:	df000215 	stw	fp,8(sp)
 18193e8:	df000204 	addi	fp,sp,8
 18193ec:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 18193f0:	e0bfff17 	ldw	r2,-4(fp)
 18193f4:	10003426 	beq	r2,zero,18194c8 <mem_free+0xec>
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 18193f8:	d0a7ee17 	ldw	r2,-24648(gp)
 18193fc:	e0ffff17 	ldw	r3,-4(fp)
 1819400:	18800336 	bltu	r3,r2,1819410 <mem_free+0x34>
 1819404:	d0a7ef17 	ldw	r2,-24644(gp)
 1819408:	e0ffff17 	ldw	r3,-4(fp)
 181940c:	18800e36 	bltu	r3,r2,1819448 <mem_free+0x6c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 1819410:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1819414:	10000126 	beq	r2,zero,181941c <mem_free+0x40>
 1819418:	181103c0 	call	181103c <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
 181941c:	008061f4 	movhi	r2,391
 1819420:	10a9d404 	addi	r2,r2,-22704
 1819424:	10805717 	ldw	r2,348(r2)
 1819428:	10c00044 	addi	r3,r2,1
 181942c:	008061f4 	movhi	r2,391
 1819430:	10a9d404 	addi	r2,r2,-22704
 1819434:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
 1819438:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181943c:	10002426 	beq	r2,zero,18194d0 <mem_free+0xf4>
 1819440:	18110840 	call	1811084 <vTaskExitCritical>
    return;
 1819444:	00002206 	br	18194d0 <mem_free+0xf4>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 1819448:	d127f104 	addi	r4,gp,-24636
 181944c:	18152580 	call	1815258 <sys_mutex_lock>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 1819450:	e0bfff17 	ldw	r2,-4(fp)
 1819454:	10bffe04 	addi	r2,r2,-8
 1819458:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 181945c:	e0bffe17 	ldw	r2,-8(fp)
 1819460:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
 1819464:	d0a7f017 	ldw	r2,-24640(gp)
 1819468:	e0fffe17 	ldw	r3,-8(fp)
 181946c:	1880022e 	bgeu	r3,r2,1819478 <mem_free+0x9c>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 1819470:	e0bffe17 	ldw	r2,-8(fp)
 1819474:	d0a7f015 	stw	r2,-24640(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 1819478:	008061f4 	movhi	r2,391
 181947c:	10a9d404 	addi	r2,r2,-22704
 1819480:	1080548b 	ldhu	r2,338(r2)
 1819484:	e0fffe17 	ldw	r3,-8(fp)
 1819488:	d127ee17 	ldw	r4,-24648(gp)
 181948c:	1907c83a 	sub	r3,r3,r4
 1819490:	1809883a 	mov	r4,r3
 1819494:	e0fffe17 	ldw	r3,-8(fp)
 1819498:	18c0000b 	ldhu	r3,0(r3)
 181949c:	20c7c83a 	sub	r3,r4,r3
 18194a0:	10c5883a 	add	r2,r2,r3
 18194a4:	1007883a 	mov	r3,r2
 18194a8:	008061f4 	movhi	r2,391
 18194ac:	10a9d404 	addi	r2,r2,-22704
 18194b0:	10c0548d 	sth	r3,338(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 18194b4:	e13ffe17 	ldw	r4,-8(fp)
 18194b8:	18191fc0 	call	18191fc <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 18194bc:	d127f104 	addi	r4,gp,-24636
 18194c0:	18152a40 	call	18152a4 <sys_mutex_unlock>
 18194c4:	00000306 	br	18194d4 <mem_free+0xf8>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
 18194c8:	0001883a 	nop
 18194cc:	00000106 	br	18194d4 <mem_free+0xf8>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
 18194d0:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 18194d4:	e037883a 	mov	sp,fp
 18194d8:	dfc00117 	ldw	ra,4(sp)
 18194dc:	df000017 	ldw	fp,0(sp)
 18194e0:	dec00204 	addi	sp,sp,8
 18194e4:	f800283a 	ret

018194e8 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 18194e8:	defff804 	addi	sp,sp,-32
 18194ec:	dfc00715 	stw	ra,28(sp)
 18194f0:	df000615 	stw	fp,24(sp)
 18194f4:	df000604 	addi	fp,sp,24
 18194f8:	e13ffe15 	stw	r4,-8(fp)
 18194fc:	2805883a 	mov	r2,r5
 1819500:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 1819504:	e0bfff0b 	ldhu	r2,-4(fp)
 1819508:	108000c4 	addi	r2,r2,3
 181950c:	1007883a 	mov	r3,r2
 1819510:	00bfff04 	movi	r2,-4
 1819514:	1884703a 	and	r2,r3,r2
 1819518:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
 181951c:	e0bfff0b 	ldhu	r2,-4(fp)
 1819520:	10800328 	cmpgeui	r2,r2,12
 1819524:	1000021e 	bne	r2,zero,1819530 <mem_trim+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 1819528:	00800304 	movi	r2,12
 181952c:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 1819530:	e0bfff0b 	ldhu	r2,-4(fp)
 1819534:	10a00070 	cmpltui	r2,r2,32769
 1819538:	1000021e 	bne	r2,zero,1819544 <mem_trim+0x5c>
    return NULL;
 181953c:	0005883a 	mov	r2,zero
 1819540:	0000a606 	br	18197dc <mem_trim+0x2f4>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 1819544:	d0a7ee17 	ldw	r2,-24648(gp)
 1819548:	e0fffe17 	ldw	r3,-8(fp)
 181954c:	18800336 	bltu	r3,r2,181955c <mem_trim+0x74>
 1819550:	d0a7ef17 	ldw	r2,-24644(gp)
 1819554:	e0fffe17 	ldw	r3,-8(fp)
 1819558:	18800f36 	bltu	r3,r2,1819598 <mem_trim+0xb0>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 181955c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1819560:	10000126 	beq	r2,zero,1819568 <mem_trim+0x80>
 1819564:	181103c0 	call	181103c <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
 1819568:	008061f4 	movhi	r2,391
 181956c:	10a9d404 	addi	r2,r2,-22704
 1819570:	10805717 	ldw	r2,348(r2)
 1819574:	10c00044 	addi	r3,r2,1
 1819578:	008061f4 	movhi	r2,391
 181957c:	10a9d404 	addi	r2,r2,-22704
 1819580:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
 1819584:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1819588:	10000126 	beq	r2,zero,1819590 <mem_trim+0xa8>
 181958c:	18110840 	call	1811084 <vTaskExitCritical>
    return rmem;
 1819590:	e0bffe17 	ldw	r2,-8(fp)
 1819594:	00009106 	br	18197dc <mem_trim+0x2f4>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 1819598:	e0bffe17 	ldw	r2,-8(fp)
 181959c:	10bffe04 	addi	r2,r2,-8
 18195a0:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 18195a4:	e0bffa17 	ldw	r2,-24(fp)
 18195a8:	d0e7ee17 	ldw	r3,-24648(gp)
 18195ac:	10c5c83a 	sub	r2,r2,r3
 18195b0:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 18195b4:	e0bffa17 	ldw	r2,-24(fp)
 18195b8:	10c0000b 	ldhu	r3,0(r2)
 18195bc:	e0bffb0b 	ldhu	r2,-20(fp)
 18195c0:	1885c83a 	sub	r2,r3,r2
 18195c4:	10bffe04 	addi	r2,r2,-8
 18195c8:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 18195cc:	e0bfff0b 	ldhu	r2,-4(fp)
 18195d0:	e0fffb8b 	ldhu	r3,-18(fp)
 18195d4:	1880022e 	bgeu	r3,r2,18195e0 <mem_trim+0xf8>
    /* not supported */
    return NULL;
 18195d8:	0005883a 	mov	r2,zero
 18195dc:	00007f06 	br	18197dc <mem_trim+0x2f4>
  }
  if (newsize == size) {
 18195e0:	e0ffff0b 	ldhu	r3,-4(fp)
 18195e4:	e0bffb8b 	ldhu	r2,-18(fp)
 18195e8:	1880021e 	bne	r3,r2,18195f4 <mem_trim+0x10c>
    /* No change in size, simply return */
    return rmem;
 18195ec:	e0bffe17 	ldw	r2,-8(fp)
 18195f0:	00007a06 	br	18197dc <mem_trim+0x2f4>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 18195f4:	d127f104 	addi	r4,gp,-24636
 18195f8:	18152580 	call	1815258 <sys_mutex_lock>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 18195fc:	d0e7ee17 	ldw	r3,-24648(gp)
 1819600:	e0bffa17 	ldw	r2,-24(fp)
 1819604:	1080000b 	ldhu	r2,0(r2)
 1819608:	10bfffcc 	andi	r2,r2,65535
 181960c:	1885883a 	add	r2,r3,r2
 1819610:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
 1819614:	e0bffc17 	ldw	r2,-16(fp)
 1819618:	10800103 	ldbu	r2,4(r2)
 181961c:	10803fcc 	andi	r2,r2,255
 1819620:	1000361e 	bne	r2,zero,18196fc <mem_trim+0x214>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 1819624:	e0bffc17 	ldw	r2,-16(fp)
 1819628:	1080000b 	ldhu	r2,0(r2)
 181962c:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 1819630:	e0fffb0b 	ldhu	r3,-20(fp)
 1819634:	e0bfff0b 	ldhu	r2,-4(fp)
 1819638:	1885883a 	add	r2,r3,r2
 181963c:	10800204 	addi	r2,r2,8
 1819640:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
 1819644:	d0e7f017 	ldw	r3,-24640(gp)
 1819648:	e0bffc17 	ldw	r2,-16(fp)
 181964c:	1880041e 	bne	r3,r2,1819660 <mem_trim+0x178>
      lfree = (struct mem *)(void *)&ram[ptr2];
 1819650:	d0e7ee17 	ldw	r3,-24648(gp)
 1819654:	e0bffd8b 	ldhu	r2,-10(fp)
 1819658:	1885883a 	add	r2,r3,r2
 181965c:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 1819660:	d0e7ee17 	ldw	r3,-24648(gp)
 1819664:	e0bffd8b 	ldhu	r2,-10(fp)
 1819668:	1885883a 	add	r2,r3,r2
 181966c:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
 1819670:	e0bffc17 	ldw	r2,-16(fp)
 1819674:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
 1819678:	e0bffc17 	ldw	r2,-16(fp)
 181967c:	e0fffd0b 	ldhu	r3,-12(fp)
 1819680:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
 1819684:	e0bffc17 	ldw	r2,-16(fp)
 1819688:	e0fffb0b 	ldhu	r3,-20(fp)
 181968c:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
 1819690:	e0bffa17 	ldw	r2,-24(fp)
 1819694:	e0fffd8b 	ldhu	r3,-10(fp)
 1819698:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 181969c:	e0bffc17 	ldw	r2,-16(fp)
 18196a0:	1080000b 	ldhu	r2,0(r2)
 18196a4:	10ffffcc 	andi	r3,r2,65535
 18196a8:	00a00014 	movui	r2,32768
 18196ac:	18800726 	beq	r3,r2,18196cc <mem_trim+0x1e4>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 18196b0:	d0e7ee17 	ldw	r3,-24648(gp)
 18196b4:	e0bffc17 	ldw	r2,-16(fp)
 18196b8:	1080000b 	ldhu	r2,0(r2)
 18196bc:	10bfffcc 	andi	r2,r2,65535
 18196c0:	1885883a 	add	r2,r3,r2
 18196c4:	e0fffd8b 	ldhu	r3,-10(fp)
 18196c8:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 18196cc:	008061f4 	movhi	r2,391
 18196d0:	10a9d404 	addi	r2,r2,-22704
 18196d4:	1080548b 	ldhu	r2,338(r2)
 18196d8:	e13fff0b 	ldhu	r4,-4(fp)
 18196dc:	e0fffb8b 	ldhu	r3,-18(fp)
 18196e0:	20c7c83a 	sub	r3,r4,r3
 18196e4:	10c5883a 	add	r2,r2,r3
 18196e8:	1007883a 	mov	r3,r2
 18196ec:	008061f4 	movhi	r2,391
 18196f0:	10a9d404 	addi	r2,r2,-22704
 18196f4:	10c0548d 	sth	r3,338(r2)
 18196f8:	00003506 	br	18197d0 <mem_trim+0x2e8>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 18196fc:	e0bfff0b 	ldhu	r2,-4(fp)
 1819700:	10800504 	addi	r2,r2,20
 1819704:	e0fffb8b 	ldhu	r3,-18(fp)
 1819708:	18803136 	bltu	r3,r2,18197d0 <mem_trim+0x2e8>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 181970c:	e0fffb0b 	ldhu	r3,-20(fp)
 1819710:	e0bfff0b 	ldhu	r2,-4(fp)
 1819714:	1885883a 	add	r2,r3,r2
 1819718:	10800204 	addi	r2,r2,8
 181971c:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)(void *)&ram[ptr2];
 1819720:	d0e7ee17 	ldw	r3,-24648(gp)
 1819724:	e0bffd8b 	ldhu	r2,-10(fp)
 1819728:	1885883a 	add	r2,r3,r2
 181972c:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
 1819730:	d0a7f017 	ldw	r2,-24640(gp)
 1819734:	e0fffc17 	ldw	r3,-16(fp)
 1819738:	1880022e 	bgeu	r3,r2,1819744 <mem_trim+0x25c>
      lfree = mem2;
 181973c:	e0bffc17 	ldw	r2,-16(fp)
 1819740:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem2->used = 0;
 1819744:	e0bffc17 	ldw	r2,-16(fp)
 1819748:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
 181974c:	e0bffa17 	ldw	r2,-24(fp)
 1819750:	10c0000b 	ldhu	r3,0(r2)
 1819754:	e0bffc17 	ldw	r2,-16(fp)
 1819758:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
 181975c:	e0bffc17 	ldw	r2,-16(fp)
 1819760:	e0fffb0b 	ldhu	r3,-20(fp)
 1819764:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
 1819768:	e0bffa17 	ldw	r2,-24(fp)
 181976c:	e0fffd8b 	ldhu	r3,-10(fp)
 1819770:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
 1819774:	e0bffc17 	ldw	r2,-16(fp)
 1819778:	1080000b 	ldhu	r2,0(r2)
 181977c:	10ffffcc 	andi	r3,r2,65535
 1819780:	00a00014 	movui	r2,32768
 1819784:	18800726 	beq	r3,r2,18197a4 <mem_trim+0x2bc>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 1819788:	d0e7ee17 	ldw	r3,-24648(gp)
 181978c:	e0bffc17 	ldw	r2,-16(fp)
 1819790:	1080000b 	ldhu	r2,0(r2)
 1819794:	10bfffcc 	andi	r2,r2,65535
 1819798:	1885883a 	add	r2,r3,r2
 181979c:	e0fffd8b 	ldhu	r3,-10(fp)
 18197a0:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 18197a4:	008061f4 	movhi	r2,391
 18197a8:	10a9d404 	addi	r2,r2,-22704
 18197ac:	1080548b 	ldhu	r2,338(r2)
 18197b0:	e13fff0b 	ldhu	r4,-4(fp)
 18197b4:	e0fffb8b 	ldhu	r3,-18(fp)
 18197b8:	20c7c83a 	sub	r3,r4,r3
 18197bc:	10c5883a 	add	r2,r2,r3
 18197c0:	1007883a 	mov	r3,r2
 18197c4:	008061f4 	movhi	r2,391
 18197c8:	10a9d404 	addi	r2,r2,-22704
 18197cc:	10c0548d 	sth	r3,338(r2)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 18197d0:	d127f104 	addi	r4,gp,-24636
 18197d4:	18152a40 	call	18152a4 <sys_mutex_unlock>
  return rmem;
 18197d8:	e0bffe17 	ldw	r2,-8(fp)
}
 18197dc:	e037883a 	mov	sp,fp
 18197e0:	dfc00117 	ldw	ra,4(sp)
 18197e4:	df000017 	ldw	fp,0(sp)
 18197e8:	dec00204 	addi	sp,sp,8
 18197ec:	f800283a 	ret

018197f0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 18197f0:	defff804 	addi	sp,sp,-32
 18197f4:	dfc00715 	stw	ra,28(sp)
 18197f8:	df000615 	stw	fp,24(sp)
 18197fc:	df000604 	addi	fp,sp,24
 1819800:	2005883a 	mov	r2,r4
 1819804:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 1819808:	e0bfff0b 	ldhu	r2,-4(fp)
 181980c:	1000021e 	bne	r2,zero,1819818 <mem_malloc+0x28>
    return NULL;
 1819810:	0005883a 	mov	r2,zero
 1819814:	0000bd06 	br	1819b0c <mem_malloc+0x31c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 1819818:	e0bfff0b 	ldhu	r2,-4(fp)
 181981c:	108000c4 	addi	r2,r2,3
 1819820:	1007883a 	mov	r3,r2
 1819824:	00bfff04 	movi	r2,-4
 1819828:	1884703a 	and	r2,r3,r2
 181982c:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
 1819830:	e0bfff0b 	ldhu	r2,-4(fp)
 1819834:	10800328 	cmpgeui	r2,r2,12
 1819838:	1000021e 	bne	r2,zero,1819844 <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 181983c:	00800304 	movi	r2,12
 1819840:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
 1819844:	e0bfff0b 	ldhu	r2,-4(fp)
 1819848:	10a00070 	cmpltui	r2,r2,32769
 181984c:	1000021e 	bne	r2,zero,1819858 <mem_malloc+0x68>
    return NULL;
 1819850:	0005883a 	mov	r2,zero
 1819854:	0000ad06 	br	1819b0c <mem_malloc+0x31c>
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 1819858:	d127f104 	addi	r4,gp,-24636
 181985c:	18152580 	call	1815258 <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 1819860:	d0a7f017 	ldw	r2,-24640(gp)
 1819864:	1007883a 	mov	r3,r2
 1819868:	d0a7ee17 	ldw	r2,-24648(gp)
 181986c:	1885c83a 	sub	r2,r3,r2
 1819870:	e0bffa0d 	sth	r2,-24(fp)
 1819874:	00009606 	br	1819ad0 <mem_malloc+0x2e0>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 1819878:	d0e7ee17 	ldw	r3,-24648(gp)
 181987c:	e0bffa0b 	ldhu	r2,-24(fp)
 1819880:	1885883a 	add	r2,r3,r2
 1819884:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 1819888:	e0bffc17 	ldw	r2,-16(fp)
 181988c:	10800103 	ldbu	r2,4(r2)
 1819890:	10803fcc 	andi	r2,r2,255
 1819894:	1000891e 	bne	r2,zero,1819abc <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 1819898:	e0bffc17 	ldw	r2,-16(fp)
 181989c:	1080000b 	ldhu	r2,0(r2)
 18198a0:	10ffffcc 	andi	r3,r2,65535
 18198a4:	e0bffa0b 	ldhu	r2,-24(fp)
 18198a8:	1885c83a 	sub	r2,r3,r2
 18198ac:	10fffe04 	addi	r3,r2,-8
 18198b0:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 18198b4:	18808136 	bltu	r3,r2,1819abc <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 18198b8:	e0bffc17 	ldw	r2,-16(fp)
 18198bc:	1080000b 	ldhu	r2,0(r2)
 18198c0:	10ffffcc 	andi	r3,r2,65535
 18198c4:	e0bffa0b 	ldhu	r2,-24(fp)
 18198c8:	1885c83a 	sub	r2,r3,r2
 18198cc:	10fffe04 	addi	r3,r2,-8
 18198d0:	e0bfff0b 	ldhu	r2,-4(fp)
 18198d4:	10800504 	addi	r2,r2,20
 18198d8:	18803e36 	bltu	r3,r2,18199d4 <mem_malloc+0x1e4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 18198dc:	e0fffa0b 	ldhu	r3,-24(fp)
 18198e0:	e0bfff0b 	ldhu	r2,-4(fp)
 18198e4:	1885883a 	add	r2,r3,r2
 18198e8:	10800204 	addi	r2,r2,8
 18198ec:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 18198f0:	d0e7ee17 	ldw	r3,-24648(gp)
 18198f4:	e0bffd0b 	ldhu	r2,-12(fp)
 18198f8:	1885883a 	add	r2,r3,r2
 18198fc:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
 1819900:	e0bffe17 	ldw	r2,-8(fp)
 1819904:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
 1819908:	e0bffc17 	ldw	r2,-16(fp)
 181990c:	10c0000b 	ldhu	r3,0(r2)
 1819910:	e0bffe17 	ldw	r2,-8(fp)
 1819914:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
 1819918:	e0bffe17 	ldw	r2,-8(fp)
 181991c:	e0fffa0b 	ldhu	r3,-24(fp)
 1819920:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 1819924:	e0bffc17 	ldw	r2,-16(fp)
 1819928:	e0fffd0b 	ldhu	r3,-12(fp)
 181992c:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
 1819930:	e0bffc17 	ldw	r2,-16(fp)
 1819934:	00c00044 	movi	r3,1
 1819938:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
 181993c:	e0bffe17 	ldw	r2,-8(fp)
 1819940:	1080000b 	ldhu	r2,0(r2)
 1819944:	10ffffcc 	andi	r3,r2,65535
 1819948:	00a00014 	movui	r2,32768
 181994c:	18800726 	beq	r3,r2,181996c <mem_malloc+0x17c>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 1819950:	d0e7ee17 	ldw	r3,-24648(gp)
 1819954:	e0bffe17 	ldw	r2,-8(fp)
 1819958:	1080000b 	ldhu	r2,0(r2)
 181995c:	10bfffcc 	andi	r2,r2,65535
 1819960:	1885883a 	add	r2,r3,r2
 1819964:	e0fffd0b 	ldhu	r3,-12(fp)
 1819968:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 181996c:	008061f4 	movhi	r2,391
 1819970:	10a9d404 	addi	r2,r2,-22704
 1819974:	10c0548b 	ldhu	r3,338(r2)
 1819978:	e0bfff0b 	ldhu	r2,-4(fp)
 181997c:	1885883a 	add	r2,r3,r2
 1819980:	10800204 	addi	r2,r2,8
 1819984:	1007883a 	mov	r3,r2
 1819988:	008061f4 	movhi	r2,391
 181998c:	10a9d404 	addi	r2,r2,-22704
 1819990:	10c0548d 	sth	r3,338(r2)
 1819994:	008061f4 	movhi	r2,391
 1819998:	10a9d404 	addi	r2,r2,-22704
 181999c:	10c0550b 	ldhu	r3,340(r2)
 18199a0:	008061f4 	movhi	r2,391
 18199a4:	10a9d404 	addi	r2,r2,-22704
 18199a8:	1080548b 	ldhu	r2,338(r2)
 18199ac:	18ffffcc 	andi	r3,r3,65535
 18199b0:	10bfffcc 	andi	r2,r2,65535
 18199b4:	1880272e 	bgeu	r3,r2,1819a54 <mem_malloc+0x264>
 18199b8:	008061f4 	movhi	r2,391
 18199bc:	10a9d404 	addi	r2,r2,-22704
 18199c0:	10c0548b 	ldhu	r3,338(r2)
 18199c4:	008061f4 	movhi	r2,391
 18199c8:	10a9d404 	addi	r2,r2,-22704
 18199cc:	10c0550d 	sth	r3,340(r2)
 18199d0:	00002006 	br	1819a54 <mem_malloc+0x264>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 18199d4:	e0bffc17 	ldw	r2,-16(fp)
 18199d8:	00c00044 	movi	r3,1
 18199dc:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 18199e0:	008061f4 	movhi	r2,391
 18199e4:	10a9d404 	addi	r2,r2,-22704
 18199e8:	1080548b 	ldhu	r2,338(r2)
 18199ec:	e0fffc17 	ldw	r3,-16(fp)
 18199f0:	18c0000b 	ldhu	r3,0(r3)
 18199f4:	e13ffc17 	ldw	r4,-16(fp)
 18199f8:	d167ee17 	ldw	r5,-24648(gp)
 18199fc:	2149c83a 	sub	r4,r4,r5
 1819a00:	1907c83a 	sub	r3,r3,r4
 1819a04:	10c5883a 	add	r2,r2,r3
 1819a08:	1007883a 	mov	r3,r2
 1819a0c:	008061f4 	movhi	r2,391
 1819a10:	10a9d404 	addi	r2,r2,-22704
 1819a14:	10c0548d 	sth	r3,338(r2)
 1819a18:	008061f4 	movhi	r2,391
 1819a1c:	10a9d404 	addi	r2,r2,-22704
 1819a20:	10c0550b 	ldhu	r3,340(r2)
 1819a24:	008061f4 	movhi	r2,391
 1819a28:	10a9d404 	addi	r2,r2,-22704
 1819a2c:	1080548b 	ldhu	r2,338(r2)
 1819a30:	18ffffcc 	andi	r3,r3,65535
 1819a34:	10bfffcc 	andi	r2,r2,65535
 1819a38:	1880062e 	bgeu	r3,r2,1819a54 <mem_malloc+0x264>
 1819a3c:	008061f4 	movhi	r2,391
 1819a40:	10a9d404 	addi	r2,r2,-22704
 1819a44:	10c0548b 	ldhu	r3,338(r2)
 1819a48:	008061f4 	movhi	r2,391
 1819a4c:	10a9d404 	addi	r2,r2,-22704
 1819a50:	10c0550d 	sth	r3,340(r2)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 1819a54:	d0a7f017 	ldw	r2,-24640(gp)
 1819a58:	e0fffc17 	ldw	r3,-16(fp)
 1819a5c:	1880121e 	bne	r3,r2,1819aa8 <mem_malloc+0x2b8>
          struct mem *cur = lfree;
 1819a60:	d0a7f017 	ldw	r2,-24640(gp)
 1819a64:	e0bffb15 	stw	r2,-20(fp)
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 1819a68:	00000606 	br	1819a84 <mem_malloc+0x294>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 1819a6c:	d0e7ee17 	ldw	r3,-24648(gp)
 1819a70:	e0bffb17 	ldw	r2,-20(fp)
 1819a74:	1080000b 	ldhu	r2,0(r2)
 1819a78:	10bfffcc 	andi	r2,r2,65535
 1819a7c:	1885883a 	add	r2,r3,r2
 1819a80:	e0bffb15 	stw	r2,-20(fp)
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 1819a84:	e0bffb17 	ldw	r2,-20(fp)
 1819a88:	10800103 	ldbu	r2,4(r2)
 1819a8c:	10803fcc 	andi	r2,r2,255
 1819a90:	10000326 	beq	r2,zero,1819aa0 <mem_malloc+0x2b0>
 1819a94:	d0a7ef17 	ldw	r2,-24644(gp)
 1819a98:	e0fffb17 	ldw	r3,-20(fp)
 1819a9c:	18bff31e 	bne	r3,r2,1819a6c <__ram_exceptions_end+0xff809628>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 1819aa0:	e0bffb17 	ldw	r2,-20(fp)
 1819aa4:	d0a7f015 	stw	r2,-24640(gp)
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 1819aa8:	d127f104 	addi	r4,gp,-24636
 1819aac:	18152a40 	call	18152a4 <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 1819ab0:	e0bffc17 	ldw	r2,-16(fp)
 1819ab4:	10800204 	addi	r2,r2,8
 1819ab8:	00001406 	br	1819b0c <mem_malloc+0x31c>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 1819abc:	d0e7ee17 	ldw	r3,-24648(gp)
 1819ac0:	e0bffa0b 	ldhu	r2,-24(fp)
 1819ac4:	1885883a 	add	r2,r3,r2
 1819ac8:	1080000b 	ldhu	r2,0(r2)
 1819acc:	e0bffa0d 	sth	r2,-24(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 1819ad0:	e0fffa0b 	ldhu	r3,-24(fp)
 1819ad4:	e0bfff0b 	ldhu	r2,-4(fp)
 1819ad8:	01200014 	movui	r4,32768
 1819adc:	2085c83a 	sub	r2,r4,r2
 1819ae0:	18bf6516 	blt	r3,r2,1819878 <__ram_exceptions_end+0xff809434>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 1819ae4:	008061f4 	movhi	r2,391
 1819ae8:	10a9d404 	addi	r2,r2,-22704
 1819aec:	10805617 	ldw	r2,344(r2)
 1819af0:	10c00044 	addi	r3,r2,1
 1819af4:	008061f4 	movhi	r2,391
 1819af8:	10a9d404 	addi	r2,r2,-22704
 1819afc:	10c05615 	stw	r3,344(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 1819b00:	d127f104 	addi	r4,gp,-24636
 1819b04:	18152a40 	call	18152a4 <sys_mutex_unlock>
  return NULL;
 1819b08:	0005883a 	mov	r2,zero
}
 1819b0c:	e037883a 	mov	sp,fp
 1819b10:	dfc00117 	ldw	ra,4(sp)
 1819b14:	df000017 	ldw	fp,0(sp)
 1819b18:	dec00204 	addi	sp,sp,8
 1819b1c:	f800283a 	ret

01819b20 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
 1819b20:	defffb04 	addi	sp,sp,-20
 1819b24:	dfc00415 	stw	ra,16(sp)
 1819b28:	df000315 	stw	fp,12(sp)
 1819b2c:	df000304 	addi	fp,sp,12
 1819b30:	2007883a 	mov	r3,r4
 1819b34:	2805883a 	mov	r2,r5
 1819b38:	e0fffe0d 	sth	r3,-8(fp)
 1819b3c:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
 1819b40:	e0fffe0b 	ldhu	r3,-8(fp)
 1819b44:	e0bfff0b 	ldhu	r2,-4(fp)
 1819b48:	1885383a 	mul	r2,r3,r2
 1819b4c:	10bfffcc 	andi	r2,r2,65535
 1819b50:	1009883a 	mov	r4,r2
 1819b54:	18197f00 	call	18197f0 <mem_malloc>
 1819b58:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
 1819b5c:	e0bffd17 	ldw	r2,-12(fp)
 1819b60:	10000726 	beq	r2,zero,1819b80 <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
 1819b64:	e0fffe0b 	ldhu	r3,-8(fp)
 1819b68:	e0bfff0b 	ldhu	r2,-4(fp)
 1819b6c:	1885383a 	mul	r2,r3,r2
 1819b70:	100d883a 	mov	r6,r2
 1819b74:	000b883a 	mov	r5,zero
 1819b78:	e13ffd17 	ldw	r4,-12(fp)
 1819b7c:	18061d40 	call	18061d4 <memset>
  }
  return p;
 1819b80:	e0bffd17 	ldw	r2,-12(fp)
}
 1819b84:	e037883a 	mov	sp,fp
 1819b88:	dfc00117 	ldw	ra,4(sp)
 1819b8c:	df000017 	ldw	fp,0(sp)
 1819b90:	dec00204 	addi	sp,sp,8
 1819b94:	f800283a 	ret

01819b98 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 1819b98:	deffff04 	addi	sp,sp,-4
 1819b9c:	df000015 	stw	fp,0(sp)
 1819ba0:	d839883a 	mov	fp,sp
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 1819ba4:	0001883a 	nop
 1819ba8:	e037883a 	mov	sp,fp
 1819bac:	df000017 	ldw	fp,0(sp)
 1819bb0:	dec00104 	addi	sp,sp,4
 1819bb4:	f800283a 	ret

01819bb8 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 1819bb8:	defffa04 	addi	sp,sp,-24
 1819bbc:	dfc00515 	stw	ra,20(sp)
 1819bc0:	df000415 	stw	fp,16(sp)
 1819bc4:	df000404 	addi	fp,sp,16
 1819bc8:	e13ffc15 	stw	r4,-16(fp)
 1819bcc:	e17ffd15 	stw	r5,-12(fp)
 1819bd0:	e1bffe15 	stw	r6,-8(fp)
 1819bd4:	e1ffff15 	stw	r7,-4(fp)

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 1819bd8:	e0bffc17 	ldw	r2,-16(fp)
 1819bdc:	10000115 	stw	zero,4(r2)
  ip_addr_set_zero(&netif->netmask);
 1819be0:	e0bffc17 	ldw	r2,-16(fp)
 1819be4:	10000215 	stw	zero,8(r2)
  ip_addr_set_zero(&netif->gw);
 1819be8:	e0bffc17 	ldw	r2,-16(fp)
 1819bec:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
 1819bf0:	e0bffc17 	ldw	r2,-16(fp)
 1819bf4:	10000e45 	stb	zero,57(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
 1819bf8:	e0bffc17 	ldw	r2,-16(fp)
 1819bfc:	10000a15 	stw	zero,40(r2)
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 1819c00:	e0bffc17 	ldw	r2,-16(fp)
 1819c04:	10000715 	stw	zero,28(r2)
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 1819c08:	e0bffc17 	ldw	r2,-16(fp)
 1819c0c:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 1819c10:	e0bffc17 	ldw	r2,-16(fp)
 1819c14:	e0c00217 	ldw	r3,8(fp)
 1819c18:	10c00915 	stw	r3,36(r2)
  netif->num = netif_num++;
 1819c1c:	d0a7f203 	ldbu	r2,-24632(gp)
 1819c20:	10c00044 	addi	r3,r2,1
 1819c24:	d0e7f205 	stb	r3,-24632(gp)
 1819c28:	e0fffc17 	ldw	r3,-16(fp)
 1819c2c:	18800f05 	stb	r2,60(r3)
  netif->input = input;
 1819c30:	e0bffc17 	ldw	r2,-16(fp)
 1819c34:	e0c00417 	ldw	r3,16(fp)
 1819c38:	10c00415 	stw	r3,16(r2)
  NETIF_SET_HWADDRHINT(netif, NULL);
 1819c3c:	e0bffc17 	ldw	r2,-16(fp)
 1819c40:	10001015 	stw	zero,64(r2)
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
 1819c44:	e1ffff17 	ldw	r7,-4(fp)
 1819c48:	e1bffe17 	ldw	r6,-8(fp)
 1819c4c:	e17ffd17 	ldw	r5,-12(fp)
 1819c50:	e13ffc17 	ldw	r4,-16(fp)
 1819c54:	1819ca80 	call	1819ca8 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 1819c58:	e0800317 	ldw	r2,12(fp)
 1819c5c:	e13ffc17 	ldw	r4,-16(fp)
 1819c60:	103ee83a 	callr	r2
 1819c64:	10803fcc 	andi	r2,r2,255
 1819c68:	1080201c 	xori	r2,r2,128
 1819c6c:	10bfe004 	addi	r2,r2,-128
 1819c70:	10000226 	beq	r2,zero,1819c7c <netif_add+0xc4>
    return NULL;
 1819c74:	0005883a 	mov	r2,zero
 1819c78:	00000606 	br	1819c94 <netif_add+0xdc>
  }

  /* add this netif to the list */
  netif->next = netif_list;
 1819c7c:	d0e7f317 	ldw	r3,-24628(gp)
 1819c80:	e0bffc17 	ldw	r2,-16(fp)
 1819c84:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
 1819c88:	e0bffc17 	ldw	r2,-16(fp)
 1819c8c:	d0a7f315 	stw	r2,-24628(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 1819c90:	e0bffc17 	ldw	r2,-16(fp)
}
 1819c94:	e037883a 	mov	sp,fp
 1819c98:	dfc00117 	ldw	ra,4(sp)
 1819c9c:	df000017 	ldw	fp,0(sp)
 1819ca0:	dec00204 	addi	sp,sp,8
 1819ca4:	f800283a 	ret

01819ca8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
 1819ca8:	defffa04 	addi	sp,sp,-24
 1819cac:	dfc00515 	stw	ra,20(sp)
 1819cb0:	df000415 	stw	fp,16(sp)
 1819cb4:	df000404 	addi	fp,sp,16
 1819cb8:	e13ffc15 	stw	r4,-16(fp)
 1819cbc:	e17ffd15 	stw	r5,-12(fp)
 1819cc0:	e1bffe15 	stw	r6,-8(fp)
 1819cc4:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
 1819cc8:	e17ffd17 	ldw	r5,-12(fp)
 1819ccc:	e13ffc17 	ldw	r4,-16(fp)
 1819cd0:	1819ebc0 	call	1819ebc <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
 1819cd4:	e17ffe17 	ldw	r5,-8(fp)
 1819cd8:	e13ffc17 	ldw	r4,-16(fp)
 1819cdc:	181a02c0 	call	181a02c <netif_set_netmask>
  netif_set_gw(netif, gw);
 1819ce0:	e17fff17 	ldw	r5,-4(fp)
 1819ce4:	e13ffc17 	ldw	r4,-16(fp)
 1819ce8:	1819fe40 	call	1819fe4 <netif_set_gw>
}
 1819cec:	0001883a 	nop
 1819cf0:	e037883a 	mov	sp,fp
 1819cf4:	dfc00117 	ldw	ra,4(sp)
 1819cf8:	df000017 	ldw	fp,0(sp)
 1819cfc:	dec00204 	addi	sp,sp,8
 1819d00:	f800283a 	ret

01819d04 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 1819d04:	defffc04 	addi	sp,sp,-16
 1819d08:	dfc00315 	stw	ra,12(sp)
 1819d0c:	df000215 	stw	fp,8(sp)
 1819d10:	df000204 	addi	fp,sp,8
 1819d14:	e13fff15 	stw	r4,-4(fp)
  if (netif == NULL) {
 1819d18:	e0bfff17 	ldw	r2,-4(fp)
 1819d1c:	10002726 	beq	r2,zero,1819dbc <netif_remove+0xb8>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
 1819d20:	e0bfff17 	ldw	r2,-4(fp)
 1819d24:	10800e43 	ldbu	r2,57(r2)
 1819d28:	10803fcc 	andi	r2,r2,255
 1819d2c:	1080004c 	andi	r2,r2,1
 1819d30:	10000226 	beq	r2,zero,1819d3c <netif_remove+0x38>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 1819d34:	e13fff17 	ldw	r4,-4(fp)
 1819d38:	181a1500 	call	181a150 <netif_set_down>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
 1819d3c:	d0e7f317 	ldw	r3,-24628(gp)
 1819d40:	e0bfff17 	ldw	r2,-4(fp)
 1819d44:	1880041e 	bne	r3,r2,1819d58 <netif_remove+0x54>
    netif_list = netif->next;
 1819d48:	e0bfff17 	ldw	r2,-4(fp)
 1819d4c:	10800017 	ldw	r2,0(r2)
 1819d50:	d0a7f315 	stw	r2,-24628(gp)
 1819d54:	00001306 	br	1819da4 <netif_remove+0xa0>
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 1819d58:	d0a7f317 	ldw	r2,-24628(gp)
 1819d5c:	e0bffe15 	stw	r2,-8(fp)
 1819d60:	00000c06 	br	1819d94 <netif_remove+0x90>
      if (tmpNetif->next == netif) {
 1819d64:	e0bffe17 	ldw	r2,-8(fp)
 1819d68:	10c00017 	ldw	r3,0(r2)
 1819d6c:	e0bfff17 	ldw	r2,-4(fp)
 1819d70:	1880051e 	bne	r3,r2,1819d88 <netif_remove+0x84>
        tmpNetif->next = netif->next;
 1819d74:	e0bfff17 	ldw	r2,-4(fp)
 1819d78:	10c00017 	ldw	r3,0(r2)
 1819d7c:	e0bffe17 	ldw	r2,-8(fp)
 1819d80:	10c00015 	stw	r3,0(r2)
        break;
 1819d84:	00000506 	br	1819d9c <netif_remove+0x98>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 1819d88:	e0bffe17 	ldw	r2,-8(fp)
 1819d8c:	10800017 	ldw	r2,0(r2)
 1819d90:	e0bffe15 	stw	r2,-8(fp)
 1819d94:	e0bffe17 	ldw	r2,-8(fp)
 1819d98:	103ff21e 	bne	r2,zero,1819d64 <__ram_exceptions_end+0xff809920>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
 1819d9c:	e0bffe17 	ldw	r2,-8(fp)
 1819da0:	10000826 	beq	r2,zero,1819dc4 <netif_remove+0xc0>
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
 1819da4:	d0e7f417 	ldw	r3,-24624(gp)
 1819da8:	e0bfff17 	ldw	r2,-4(fp)
 1819dac:	1880061e 	bne	r3,r2,1819dc8 <netif_remove+0xc4>
    /* reset default netif */
    netif_set_default(NULL);
 1819db0:	0009883a 	mov	r4,zero
 1819db4:	181a0740 	call	181a074 <netif_set_default>
 1819db8:	00000306 	br	1819dc8 <netif_remove+0xc4>
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
    return;
 1819dbc:	0001883a 	nop
 1819dc0:	00000106 	br	1819dc8 <netif_remove+0xc4>
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
 1819dc4:	0001883a 	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 1819dc8:	e037883a 	mov	sp,fp
 1819dcc:	dfc00117 	ldw	ra,4(sp)
 1819dd0:	df000017 	ldw	fp,0(sp)
 1819dd4:	dec00204 	addi	sp,sp,8
 1819dd8:	f800283a 	ret

01819ddc <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
 1819ddc:	defffc04 	addi	sp,sp,-16
 1819de0:	df000315 	stw	fp,12(sp)
 1819de4:	df000304 	addi	fp,sp,12
 1819de8:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
 1819dec:	e0bfff17 	ldw	r2,-4(fp)
 1819df0:	1000021e 	bne	r2,zero,1819dfc <netif_find+0x20>
    return NULL;
 1819df4:	0005883a 	mov	r2,zero
 1819df8:	00002c06 	br	1819eac <netif_find+0xd0>
  }

  num = name[2] - '0';
 1819dfc:	e0bfff17 	ldw	r2,-4(fp)
 1819e00:	10800084 	addi	r2,r2,2
 1819e04:	10800003 	ldbu	r2,0(r2)
 1819e08:	10bff404 	addi	r2,r2,-48
 1819e0c:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 1819e10:	d0a7f317 	ldw	r2,-24628(gp)
 1819e14:	e0bffd15 	stw	r2,-12(fp)
 1819e18:	00002106 	br	1819ea0 <netif_find+0xc4>
    if (num == netif->num &&
 1819e1c:	e0bffd17 	ldw	r2,-12(fp)
 1819e20:	10800f03 	ldbu	r2,60(r2)
 1819e24:	10c03fcc 	andi	r3,r2,255
 1819e28:	e0bffe03 	ldbu	r2,-8(fp)
 1819e2c:	1880191e 	bne	r3,r2,1819e94 <netif_find+0xb8>
       name[0] == netif->name[0] &&
 1819e30:	e0bfff17 	ldw	r2,-4(fp)
 1819e34:	10c00003 	ldbu	r3,0(r2)
 1819e38:	e0bffd17 	ldw	r2,-12(fp)
 1819e3c:	10800e83 	ldbu	r2,58(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
 1819e40:	18c03fcc 	andi	r3,r3,255
 1819e44:	18c0201c 	xori	r3,r3,128
 1819e48:	18ffe004 	addi	r3,r3,-128
 1819e4c:	10803fcc 	andi	r2,r2,255
 1819e50:	1080201c 	xori	r2,r2,128
 1819e54:	10bfe004 	addi	r2,r2,-128
 1819e58:	18800e1e 	bne	r3,r2,1819e94 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
 1819e5c:	e0bfff17 	ldw	r2,-4(fp)
 1819e60:	10800044 	addi	r2,r2,1
 1819e64:	10c00003 	ldbu	r3,0(r2)
 1819e68:	e0bffd17 	ldw	r2,-12(fp)
 1819e6c:	10800ec3 	ldbu	r2,59(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
 1819e70:	18c03fcc 	andi	r3,r3,255
 1819e74:	18c0201c 	xori	r3,r3,128
 1819e78:	18ffe004 	addi	r3,r3,-128
 1819e7c:	10803fcc 	andi	r2,r2,255
 1819e80:	1080201c 	xori	r2,r2,128
 1819e84:	10bfe004 	addi	r2,r2,-128
 1819e88:	1880021e 	bne	r3,r2,1819e94 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
 1819e8c:	e0bffd17 	ldw	r2,-12(fp)
 1819e90:	00000606 	br	1819eac <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 1819e94:	e0bffd17 	ldw	r2,-12(fp)
 1819e98:	10800017 	ldw	r2,0(r2)
 1819e9c:	e0bffd15 	stw	r2,-12(fp)
 1819ea0:	e0bffd17 	ldw	r2,-12(fp)
 1819ea4:	103fdd1e 	bne	r2,zero,1819e1c <__ram_exceptions_end+0xff8099d8>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
 1819ea8:	0005883a 	mov	r2,zero
}
 1819eac:	e037883a 	mov	sp,fp
 1819eb0:	df000017 	ldw	fp,0(sp)
 1819eb4:	dec00104 	addi	sp,sp,4
 1819eb8:	f800283a 	ret

01819ebc <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 1819ebc:	defff904 	addi	sp,sp,-28
 1819ec0:	dfc00615 	stw	ra,24(sp)
 1819ec4:	df000515 	stw	fp,20(sp)
 1819ec8:	df000504 	addi	fp,sp,20
 1819ecc:	e13ffe15 	stw	r4,-8(fp)
 1819ed0:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 1819ed4:	e0bfff17 	ldw	r2,-4(fp)
 1819ed8:	10003426 	beq	r2,zero,1819fac <netif_set_ipaddr+0xf0>
 1819edc:	e0bfff17 	ldw	r2,-4(fp)
 1819ee0:	10c00017 	ldw	r3,0(r2)
 1819ee4:	e0bffe17 	ldw	r2,-8(fp)
 1819ee8:	10800117 	ldw	r2,4(r2)
 1819eec:	18802f26 	beq	r3,r2,1819fac <netif_set_ipaddr+0xf0>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 1819ef0:	d0a7f717 	ldw	r2,-24612(gp)
 1819ef4:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
 1819ef8:	00001006 	br	1819f3c <netif_set_ipaddr+0x80>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 1819efc:	e0bffb17 	ldw	r2,-20(fp)
 1819f00:	10c00017 	ldw	r3,0(r2)
 1819f04:	e0bffe17 	ldw	r2,-8(fp)
 1819f08:	10800117 	ldw	r2,4(r2)
 1819f0c:	1880081e 	bne	r3,r2,1819f30 <netif_set_ipaddr+0x74>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 1819f10:	e0bffb17 	ldw	r2,-20(fp)
 1819f14:	10800317 	ldw	r2,12(r2)
 1819f18:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 1819f1c:	e13ffb17 	ldw	r4,-20(fp)
 1819f20:	181c0f00 	call	181c0f0 <tcp_abort>
        pcb = next;
 1819f24:	e0bffd17 	ldw	r2,-12(fp)
 1819f28:	e0bffb15 	stw	r2,-20(fp)
 1819f2c:	00000306 	br	1819f3c <netif_set_ipaddr+0x80>
      } else {
        pcb = pcb->next;
 1819f30:	e0bffb17 	ldw	r2,-20(fp)
 1819f34:	10800317 	ldw	r2,12(r2)
 1819f38:	e0bffb15 	stw	r2,-20(fp)
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 1819f3c:	e0bffb17 	ldw	r2,-20(fp)
 1819f40:	103fee1e 	bne	r2,zero,1819efc <__ram_exceptions_end+0xff809ab8>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 1819f44:	d0a7f917 	ldw	r2,-24604(gp)
 1819f48:	e0bffc15 	stw	r2,-16(fp)
 1819f4c:	00001506 	br	1819fa4 <netif_set_ipaddr+0xe8>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 1819f50:	e0bffc17 	ldw	r2,-16(fp)
 1819f54:	10001026 	beq	r2,zero,1819f98 <netif_set_ipaddr+0xdc>
 1819f58:	e0bffc17 	ldw	r2,-16(fp)
 1819f5c:	10800017 	ldw	r2,0(r2)
 1819f60:	10000d26 	beq	r2,zero,1819f98 <netif_set_ipaddr+0xdc>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
 1819f64:	e0bffc17 	ldw	r2,-16(fp)
 1819f68:	10c00017 	ldw	r3,0(r2)
 1819f6c:	e0bffe17 	ldw	r2,-8(fp)
 1819f70:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 1819f74:	1880081e 	bne	r3,r2,1819f98 <netif_set_ipaddr+0xdc>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 1819f78:	e0bfff17 	ldw	r2,-4(fp)
 1819f7c:	10000326 	beq	r2,zero,1819f8c <netif_set_ipaddr+0xd0>
 1819f80:	e0bfff17 	ldw	r2,-4(fp)
 1819f84:	10800017 	ldw	r2,0(r2)
 1819f88:	00000106 	br	1819f90 <netif_set_ipaddr+0xd4>
 1819f8c:	0005883a 	mov	r2,zero
 1819f90:	e0fffc17 	ldw	r3,-16(fp)
 1819f94:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 1819f98:	e0bffc17 	ldw	r2,-16(fp)
 1819f9c:	10800317 	ldw	r2,12(r2)
 1819fa0:	e0bffc15 	stw	r2,-16(fp)
 1819fa4:	e0bffc17 	ldw	r2,-16(fp)
 1819fa8:	103fe91e 	bne	r2,zero,1819f50 <__ram_exceptions_end+0xff809b0c>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 1819fac:	e0bfff17 	ldw	r2,-4(fp)
 1819fb0:	10000326 	beq	r2,zero,1819fc0 <netif_set_ipaddr+0x104>
 1819fb4:	e0bfff17 	ldw	r2,-4(fp)
 1819fb8:	10800017 	ldw	r2,0(r2)
 1819fbc:	00000106 	br	1819fc4 <netif_set_ipaddr+0x108>
 1819fc0:	0005883a 	mov	r2,zero
 1819fc4:	e0fffe17 	ldw	r3,-8(fp)
 1819fc8:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 1819fcc:	0001883a 	nop
 1819fd0:	e037883a 	mov	sp,fp
 1819fd4:	dfc00117 	ldw	ra,4(sp)
 1819fd8:	df000017 	ldw	fp,0(sp)
 1819fdc:	dec00204 	addi	sp,sp,8
 1819fe0:	f800283a 	ret

01819fe4 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
 1819fe4:	defffd04 	addi	sp,sp,-12
 1819fe8:	df000215 	stw	fp,8(sp)
 1819fec:	df000204 	addi	fp,sp,8
 1819ff0:	e13ffe15 	stw	r4,-8(fp)
 1819ff4:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
 1819ff8:	e0bfff17 	ldw	r2,-4(fp)
 1819ffc:	10000326 	beq	r2,zero,181a00c <netif_set_gw+0x28>
 181a000:	e0bfff17 	ldw	r2,-4(fp)
 181a004:	10800017 	ldw	r2,0(r2)
 181a008:	00000106 	br	181a010 <netif_set_gw+0x2c>
 181a00c:	0005883a 	mov	r2,zero
 181a010:	e0fffe17 	ldw	r3,-8(fp)
 181a014:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
 181a018:	0001883a 	nop
 181a01c:	e037883a 	mov	sp,fp
 181a020:	df000017 	ldw	fp,0(sp)
 181a024:	dec00104 	addi	sp,sp,4
 181a028:	f800283a 	ret

0181a02c <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
 181a02c:	defffd04 	addi	sp,sp,-12
 181a030:	df000215 	stw	fp,8(sp)
 181a034:	df000204 	addi	fp,sp,8
 181a038:	e13ffe15 	stw	r4,-8(fp)
 181a03c:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 181a040:	e0bfff17 	ldw	r2,-4(fp)
 181a044:	10000326 	beq	r2,zero,181a054 <netif_set_netmask+0x28>
 181a048:	e0bfff17 	ldw	r2,-4(fp)
 181a04c:	10800017 	ldw	r2,0(r2)
 181a050:	00000106 	br	181a058 <netif_set_netmask+0x2c>
 181a054:	0005883a 	mov	r2,zero
 181a058:	e0fffe17 	ldw	r3,-8(fp)
 181a05c:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
 181a060:	0001883a 	nop
 181a064:	e037883a 	mov	sp,fp
 181a068:	df000017 	ldw	fp,0(sp)
 181a06c:	dec00104 	addi	sp,sp,4
 181a070:	f800283a 	ret

0181a074 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 181a074:	defffe04 	addi	sp,sp,-8
 181a078:	df000115 	stw	fp,4(sp)
 181a07c:	df000104 	addi	fp,sp,4
 181a080:	e13fff15 	stw	r4,-4(fp)
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 181a084:	e0bfff17 	ldw	r2,-4(fp)
 181a088:	d0a7f415 	stw	r2,-24624(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 181a08c:	0001883a 	nop
 181a090:	e037883a 	mov	sp,fp
 181a094:	df000017 	ldw	fp,0(sp)
 181a098:	dec00104 	addi	sp,sp,4
 181a09c:	f800283a 	ret

0181a0a0 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 181a0a0:	defffd04 	addi	sp,sp,-12
 181a0a4:	dfc00215 	stw	ra,8(sp)
 181a0a8:	df000115 	stw	fp,4(sp)
 181a0ac:	df000104 	addi	fp,sp,4
 181a0b0:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_UP)) {
 181a0b4:	e0bfff17 	ldw	r2,-4(fp)
 181a0b8:	10800e43 	ldbu	r2,57(r2)
 181a0bc:	10803fcc 	andi	r2,r2,255
 181a0c0:	1080004c 	andi	r2,r2,1
 181a0c4:	10001c1e 	bne	r2,zero,181a138 <netif_set_up+0x98>
    netif->flags |= NETIF_FLAG_UP;
 181a0c8:	e0bfff17 	ldw	r2,-4(fp)
 181a0cc:	10800e43 	ldbu	r2,57(r2)
 181a0d0:	10800054 	ori	r2,r2,1
 181a0d4:	1007883a 	mov	r3,r2
 181a0d8:	e0bfff17 	ldw	r2,-4(fp)
 181a0dc:	10c00e45 	stb	r3,57(r2)
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);
 181a0e0:	e0bfff17 	ldw	r2,-4(fp)
 181a0e4:	10800717 	ldw	r2,28(r2)
 181a0e8:	10000426 	beq	r2,zero,181a0fc <netif_set_up+0x5c>
 181a0ec:	e0bfff17 	ldw	r2,-4(fp)
 181a0f0:	10800717 	ldw	r2,28(r2)
 181a0f4:	e13fff17 	ldw	r4,-4(fp)
 181a0f8:	103ee83a 	callr	r2

    if (netif->flags & NETIF_FLAG_LINK_UP) {
 181a0fc:	e0bfff17 	ldw	r2,-4(fp)
 181a100:	10800e43 	ldbu	r2,57(r2)
 181a104:	10803fcc 	andi	r2,r2,255
 181a108:	1080040c 	andi	r2,r2,16
 181a10c:	10000a26 	beq	r2,zero,181a138 <netif_set_up+0x98>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 181a110:	e0bfff17 	ldw	r2,-4(fp)
 181a114:	10800e43 	ldbu	r2,57(r2)
 181a118:	10803fcc 	andi	r2,r2,255
 181a11c:	1080080c 	andi	r2,r2,32
 181a120:	10000526 	beq	r2,zero,181a138 <netif_set_up+0x98>
        etharp_gratuitous(netif);
 181a124:	e0bfff17 	ldw	r2,-4(fp)
 181a128:	10800104 	addi	r2,r2,4
 181a12c:	100b883a 	mov	r5,r2
 181a130:	e13fff17 	ldw	r4,-4(fp)
 181a134:	18244840 	call	1824484 <etharp_request>
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
 181a138:	0001883a 	nop
 181a13c:	e037883a 	mov	sp,fp
 181a140:	dfc00117 	ldw	ra,4(sp)
 181a144:	df000017 	ldw	fp,0(sp)
 181a148:	dec00204 	addi	sp,sp,8
 181a14c:	f800283a 	ret

0181a150 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
 181a150:	defffd04 	addi	sp,sp,-12
 181a154:	dfc00215 	stw	ra,8(sp)
 181a158:	df000115 	stw	fp,4(sp)
 181a15c:	df000104 	addi	fp,sp,4
 181a160:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_UP) {
 181a164:	e0bfff17 	ldw	r2,-4(fp)
 181a168:	10800e43 	ldbu	r2,57(r2)
 181a16c:	10803fcc 	andi	r2,r2,255
 181a170:	1080004c 	andi	r2,r2,1
 181a174:	10001526 	beq	r2,zero,181a1cc <netif_set_down+0x7c>
    netif->flags &= ~NETIF_FLAG_UP;
 181a178:	e0bfff17 	ldw	r2,-4(fp)
 181a17c:	10c00e43 	ldbu	r3,57(r2)
 181a180:	00bfff84 	movi	r2,-2
 181a184:	1884703a 	and	r2,r3,r2
 181a188:	1007883a 	mov	r3,r2
 181a18c:	e0bfff17 	ldw	r2,-4(fp)
 181a190:	10c00e45 	stb	r3,57(r2)
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 181a194:	e0bfff17 	ldw	r2,-4(fp)
 181a198:	10800e43 	ldbu	r2,57(r2)
 181a19c:	10803fcc 	andi	r2,r2,255
 181a1a0:	1080080c 	andi	r2,r2,32
 181a1a4:	10000226 	beq	r2,zero,181a1b0 <netif_set_down+0x60>
      etharp_cleanup_netif(netif);
 181a1a8:	e13fff17 	ldw	r4,-4(fp)
 181a1ac:	18234b40 	call	18234b4 <etharp_cleanup_netif>
    }
#endif /* LWIP_ARP */
    NETIF_STATUS_CALLBACK(netif);
 181a1b0:	e0bfff17 	ldw	r2,-4(fp)
 181a1b4:	10800717 	ldw	r2,28(r2)
 181a1b8:	10000426 	beq	r2,zero,181a1cc <netif_set_down+0x7c>
 181a1bc:	e0bfff17 	ldw	r2,-4(fp)
 181a1c0:	10800717 	ldw	r2,28(r2)
 181a1c4:	e13fff17 	ldw	r4,-4(fp)
 181a1c8:	103ee83a 	callr	r2
  }
}
 181a1cc:	0001883a 	nop
 181a1d0:	e037883a 	mov	sp,fp
 181a1d4:	dfc00117 	ldw	ra,4(sp)
 181a1d8:	df000017 	ldw	fp,0(sp)
 181a1dc:	dec00204 	addi	sp,sp,8
 181a1e0:	f800283a 	ret

0181a1e4 <netif_set_status_callback>:
#if LWIP_NETIF_STATUS_CALLBACK
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
 181a1e4:	defffd04 	addi	sp,sp,-12
 181a1e8:	df000215 	stw	fp,8(sp)
 181a1ec:	df000204 	addi	fp,sp,8
 181a1f0:	e13ffe15 	stw	r4,-8(fp)
 181a1f4:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
 181a1f8:	e0bffe17 	ldw	r2,-8(fp)
 181a1fc:	10000326 	beq	r2,zero,181a20c <netif_set_status_callback+0x28>
    netif->status_callback = status_callback;
 181a200:	e0bffe17 	ldw	r2,-8(fp)
 181a204:	e0ffff17 	ldw	r3,-4(fp)
 181a208:	10c00715 	stw	r3,28(r2)
  }
}
 181a20c:	0001883a 	nop
 181a210:	e037883a 	mov	sp,fp
 181a214:	df000017 	ldw	fp,0(sp)
 181a218:	dec00104 	addi	sp,sp,4
 181a21c:	f800283a 	ret

0181a220 <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 181a220:	defffd04 	addi	sp,sp,-12
 181a224:	dfc00215 	stw	ra,8(sp)
 181a228:	df000115 	stw	fp,4(sp)
 181a22c:	df000104 	addi	fp,sp,4
 181a230:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 181a234:	e0bfff17 	ldw	r2,-4(fp)
 181a238:	10800e43 	ldbu	r2,57(r2)
 181a23c:	10803fcc 	andi	r2,r2,255
 181a240:	1080040c 	andi	r2,r2,16
 181a244:	1000211e 	bne	r2,zero,181a2cc <netif_set_link_up+0xac>
    netif->flags |= NETIF_FLAG_LINK_UP;
 181a248:	e0bfff17 	ldw	r2,-4(fp)
 181a24c:	10800e43 	ldbu	r2,57(r2)
 181a250:	10800414 	ori	r2,r2,16
 181a254:	1007883a 	mov	r3,r2
 181a258:	e0bfff17 	ldw	r2,-4(fp)
 181a25c:	10c00e45 	stb	r3,57(r2)

#if LWIP_DHCP
    if (netif->dhcp) {
 181a260:	e0bfff17 	ldw	r2,-4(fp)
 181a264:	10800a17 	ldw	r2,40(r2)
 181a268:	10000226 	beq	r2,zero,181a274 <netif_set_link_up+0x54>
      dhcp_network_changed(netif);
 181a26c:	e13fff17 	ldw	r4,-4(fp)
 181a270:	18165ec0 	call	18165ec <dhcp_network_changed>
    if (netif->autoip) {
      autoip_network_changed(netif);
    }
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
 181a274:	e0bfff17 	ldw	r2,-4(fp)
 181a278:	10800e43 	ldbu	r2,57(r2)
 181a27c:	10803fcc 	andi	r2,r2,255
 181a280:	1080004c 	andi	r2,r2,1
 181a284:	10000a26 	beq	r2,zero,181a2b0 <netif_set_link_up+0x90>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 181a288:	e0bfff17 	ldw	r2,-4(fp)
 181a28c:	10800e43 	ldbu	r2,57(r2)
 181a290:	10803fcc 	andi	r2,r2,255
 181a294:	1080080c 	andi	r2,r2,32
 181a298:	10000526 	beq	r2,zero,181a2b0 <netif_set_link_up+0x90>
        etharp_gratuitous(netif);
 181a29c:	e0bfff17 	ldw	r2,-4(fp)
 181a2a0:	10800104 	addi	r2,r2,4
 181a2a4:	100b883a 	mov	r5,r2
 181a2a8:	e13fff17 	ldw	r4,-4(fp)
 181a2ac:	18244840 	call	1824484 <etharp_request>
      if (netif->flags & NETIF_FLAG_IGMP) {
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
 181a2b0:	e0bfff17 	ldw	r2,-4(fp)
 181a2b4:	10800817 	ldw	r2,32(r2)
 181a2b8:	10000426 	beq	r2,zero,181a2cc <netif_set_link_up+0xac>
 181a2bc:	e0bfff17 	ldw	r2,-4(fp)
 181a2c0:	10800817 	ldw	r2,32(r2)
 181a2c4:	e13fff17 	ldw	r4,-4(fp)
 181a2c8:	103ee83a 	callr	r2
  }
}
 181a2cc:	0001883a 	nop
 181a2d0:	e037883a 	mov	sp,fp
 181a2d4:	dfc00117 	ldw	ra,4(sp)
 181a2d8:	df000017 	ldw	fp,0(sp)
 181a2dc:	dec00204 	addi	sp,sp,8
 181a2e0:	f800283a 	ret

0181a2e4 <netif_set_link_down>:

/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
 181a2e4:	defffd04 	addi	sp,sp,-12
 181a2e8:	dfc00215 	stw	ra,8(sp)
 181a2ec:	df000115 	stw	fp,4(sp)
 181a2f0:	df000104 	addi	fp,sp,4
 181a2f4:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 181a2f8:	e0bfff17 	ldw	r2,-4(fp)
 181a2fc:	10800e43 	ldbu	r2,57(r2)
 181a300:	10803fcc 	andi	r2,r2,255
 181a304:	1080040c 	andi	r2,r2,16
 181a308:	10000e26 	beq	r2,zero,181a344 <netif_set_link_down+0x60>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 181a30c:	e0bfff17 	ldw	r2,-4(fp)
 181a310:	10c00e43 	ldbu	r3,57(r2)
 181a314:	00bffbc4 	movi	r2,-17
 181a318:	1884703a 	and	r2,r3,r2
 181a31c:	1007883a 	mov	r3,r2
 181a320:	e0bfff17 	ldw	r2,-4(fp)
 181a324:	10c00e45 	stb	r3,57(r2)
    NETIF_LINK_CALLBACK(netif);
 181a328:	e0bfff17 	ldw	r2,-4(fp)
 181a32c:	10800817 	ldw	r2,32(r2)
 181a330:	10000426 	beq	r2,zero,181a344 <netif_set_link_down+0x60>
 181a334:	e0bfff17 	ldw	r2,-4(fp)
 181a338:	10800817 	ldw	r2,32(r2)
 181a33c:	e13fff17 	ldw	r4,-4(fp)
 181a340:	103ee83a 	callr	r2
  }
}
 181a344:	0001883a 	nop
 181a348:	e037883a 	mov	sp,fp
 181a34c:	dfc00117 	ldw	ra,4(sp)
 181a350:	df000017 	ldw	fp,0(sp)
 181a354:	dec00204 	addi	sp,sp,8
 181a358:	f800283a 	ret

0181a35c <netif_set_link_callback>:
#if LWIP_NETIF_LINK_CALLBACK
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
 181a35c:	defffd04 	addi	sp,sp,-12
 181a360:	df000215 	stw	fp,8(sp)
 181a364:	df000204 	addi	fp,sp,8
 181a368:	e13ffe15 	stw	r4,-8(fp)
 181a36c:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
 181a370:	e0bffe17 	ldw	r2,-8(fp)
 181a374:	10000326 	beq	r2,zero,181a384 <netif_set_link_callback+0x28>
    netif->link_callback = link_callback;
 181a378:	e0bffe17 	ldw	r2,-8(fp)
 181a37c:	e0ffff17 	ldw	r3,-4(fp)
 181a380:	10c00815 	stw	r3,32(r2)
  }
}
 181a384:	0001883a 	nop
 181a388:	e037883a 	mov	sp,fp
 181a38c:	df000017 	ldw	fp,0(sp)
 181a390:	dec00104 	addi	sp,sp,4
 181a394:	f800283a 	ret

0181a398 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 181a398:	defffd04 	addi	sp,sp,-12
 181a39c:	dfc00215 	stw	ra,8(sp)
 181a3a0:	df000115 	stw	fp,4(sp)
 181a3a4:	df000104 	addi	fp,sp,4
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
 181a3a8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a3ac:	10000126 	beq	r2,zero,181a3b4 <pbuf_free_ooseq+0x1c>
 181a3b0:	181103c0 	call	181103c <vTaskEnterCritical>
  pbuf_free_ooseq_pending = 0;
 181a3b4:	d027f505 	stb	zero,-24620(gp)
  SYS_ARCH_UNPROTECT(old_level);
 181a3b8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a3bc:	10000126 	beq	r2,zero,181a3c4 <pbuf_free_ooseq+0x2c>
 181a3c0:	18110840 	call	1811084 <vTaskExitCritical>

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 181a3c4:	d0a7f717 	ldw	r2,-24612(gp)
 181a3c8:	e0bfff15 	stw	r2,-4(fp)
 181a3cc:	00000d06 	br	181a404 <pbuf_free_ooseq+0x6c>
    if (NULL != pcb->ooseq) {
 181a3d0:	e0bfff17 	ldw	r2,-4(fp)
 181a3d4:	10801e17 	ldw	r2,120(r2)
 181a3d8:	10000726 	beq	r2,zero,181a3f8 <pbuf_free_ooseq+0x60>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
 181a3dc:	e0bfff17 	ldw	r2,-4(fp)
 181a3e0:	10801e17 	ldw	r2,120(r2)
 181a3e4:	1009883a 	mov	r4,r2
 181a3e8:	181d5180 	call	181d518 <tcp_segs_free>
      pcb->ooseq = NULL;
 181a3ec:	e0bfff17 	ldw	r2,-4(fp)
 181a3f0:	10001e15 	stw	zero,120(r2)
      return;
 181a3f4:	00000506 	br	181a40c <pbuf_free_ooseq+0x74>

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 181a3f8:	e0bfff17 	ldw	r2,-4(fp)
 181a3fc:	10800317 	ldw	r2,12(r2)
 181a400:	e0bfff15 	stw	r2,-4(fp)
 181a404:	e0bfff17 	ldw	r2,-4(fp)
 181a408:	103ff11e 	bne	r2,zero,181a3d0 <__ram_exceptions_end+0xff809f8c>
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      return;
    }
  }
}
 181a40c:	e037883a 	mov	sp,fp
 181a410:	dfc00117 	ldw	ra,4(sp)
 181a414:	df000017 	ldw	fp,0(sp)
 181a418:	dec00204 	addi	sp,sp,8
 181a41c:	f800283a 	ret

0181a420 <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
 181a420:	defffd04 	addi	sp,sp,-12
 181a424:	dfc00215 	stw	ra,8(sp)
 181a428:	df000115 	stw	fp,4(sp)
 181a42c:	df000104 	addi	fp,sp,4
 181a430:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
 181a434:	181a3980 	call	181a398 <pbuf_free_ooseq>
}
 181a438:	0001883a 	nop
 181a43c:	e037883a 	mov	sp,fp
 181a440:	dfc00117 	ldw	ra,4(sp)
 181a444:	df000017 	ldw	fp,0(sp)
 181a448:	dec00204 	addi	sp,sp,8
 181a44c:	f800283a 	ret

0181a450 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 181a450:	defffd04 	addi	sp,sp,-12
 181a454:	dfc00215 	stw	ra,8(sp)
 181a458:	df000115 	stw	fp,4(sp)
 181a45c:	df000104 	addi	fp,sp,4
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
 181a460:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a464:	10000126 	beq	r2,zero,181a46c <pbuf_pool_is_empty+0x1c>
 181a468:	181103c0 	call	181103c <vTaskEnterCritical>
  queued = pbuf_free_ooseq_pending;
 181a46c:	d0a7f503 	ldbu	r2,-24620(gp)
 181a470:	e0bfff05 	stb	r2,-4(fp)
  pbuf_free_ooseq_pending = 1;
 181a474:	00800044 	movi	r2,1
 181a478:	d0a7f505 	stb	r2,-24620(gp)
  SYS_ARCH_UNPROTECT(old_level);
 181a47c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a480:	10000126 	beq	r2,zero,181a488 <pbuf_pool_is_empty+0x38>
 181a484:	18110840 	call	1811084 <vTaskExitCritical>

  if(!queued) {
 181a488:	e0bfff03 	ldbu	r2,-4(fp)
 181a48c:	1000101e 	bne	r2,zero,181a4d0 <pbuf_pool_is_empty+0x80>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 181a490:	000d883a 	mov	r6,zero
 181a494:	000b883a 	mov	r5,zero
 181a498:	010060b4 	movhi	r4,386
 181a49c:	21290804 	addi	r4,r4,-23520
 181a4a0:	182bd1c0 	call	182bd1c <tcpip_callback_with_block>
 181a4a4:	10803fcc 	andi	r2,r2,255
 181a4a8:	1080201c 	xori	r2,r2,128
 181a4ac:	10bfe004 	addi	r2,r2,-128
 181a4b0:	10000726 	beq	r2,zero,181a4d0 <pbuf_pool_is_empty+0x80>
 181a4b4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a4b8:	10000126 	beq	r2,zero,181a4c0 <pbuf_pool_is_empty+0x70>
 181a4bc:	181103c0 	call	181103c <vTaskEnterCritical>
 181a4c0:	d027f505 	stb	zero,-24620(gp)
 181a4c4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181a4c8:	10000126 	beq	r2,zero,181a4d0 <pbuf_pool_is_empty+0x80>
 181a4cc:	18110840 	call	1811084 <vTaskExitCritical>
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 181a4d0:	0001883a 	nop
 181a4d4:	e037883a 	mov	sp,fp
 181a4d8:	dfc00117 	ldw	ra,4(sp)
 181a4dc:	df000017 	ldw	fp,0(sp)
 181a4e0:	dec00204 	addi	sp,sp,8
 181a4e4:	f800283a 	ret

0181a4e8 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 181a4e8:	defff604 	addi	sp,sp,-40
 181a4ec:	dfc00915 	stw	ra,36(sp)
 181a4f0:	df000815 	stw	fp,32(sp)
 181a4f4:	df000804 	addi	fp,sp,32
 181a4f8:	e13ffd15 	stw	r4,-12(fp)
 181a4fc:	2805883a 	mov	r2,r5
 181a500:	e1bfff15 	stw	r6,-4(fp)
 181a504:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 181a508:	e0bffd17 	ldw	r2,-12(fp)
 181a50c:	10c00060 	cmpeqi	r3,r2,1
 181a510:	1800091e 	bne	r3,zero,181a538 <pbuf_alloc+0x50>
 181a514:	0080052e 	bgeu	zero,r2,181a52c <pbuf_alloc+0x44>
 181a518:	10c000a0 	cmpeqi	r3,r2,2
 181a51c:	1800091e 	bne	r3,zero,181a544 <pbuf_alloc+0x5c>
 181a520:	108000e0 	cmpeqi	r2,r2,3
 181a524:	10000a1e 	bne	r2,zero,181a550 <pbuf_alloc+0x68>
 181a528:	00000b06 	br	181a558 <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 181a52c:	00800e04 	movi	r2,56
 181a530:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a534:	00000a06 	br	181a560 <pbuf_alloc+0x78>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 181a538:	00800904 	movi	r2,36
 181a53c:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a540:	00000706 	br	181a560 <pbuf_alloc+0x78>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 181a544:	00800404 	movi	r2,16
 181a548:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a54c:	00000406 	br	181a560 <pbuf_alloc+0x78>
  case PBUF_RAW:
    offset = 0;
 181a550:	e03ffa0d 	sth	zero,-24(fp)
    break;
 181a554:	00000206 	br	181a560 <pbuf_alloc+0x78>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
 181a558:	0005883a 	mov	r2,zero
 181a55c:	0000b806 	br	181a840 <pbuf_alloc+0x358>
  }

  switch (type) {
 181a560:	e0bfff17 	ldw	r2,-4(fp)
 181a564:	10c000e8 	cmpgeui	r3,r2,3
 181a568:	1800021e 	bne	r3,zero,181a574 <pbuf_alloc+0x8c>
 181a56c:	00809536 	bltu	zero,r2,181a7c4 <pbuf_alloc+0x2dc>
 181a570:	00006806 	br	181a714 <pbuf_alloc+0x22c>
 181a574:	108000e0 	cmpeqi	r2,r2,3
 181a578:	1000a926 	beq	r2,zero,181a820 <pbuf_alloc+0x338>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 181a57c:	01000384 	movi	r4,14
 181a580:	18349580 	call	1834958 <memp_malloc>
 181a584:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 181a588:	e0bff817 	ldw	r2,-32(fp)
 181a58c:	1000031e 	bne	r2,zero,181a59c <pbuf_alloc+0xb4>
      PBUF_POOL_IS_EMPTY();
 181a590:	181a4500 	call	181a450 <pbuf_pool_is_empty>
      return NULL;
 181a594:	0005883a 	mov	r2,zero
 181a598:	0000a906 	br	181a840 <pbuf_alloc+0x358>
    }
    p->type = type;
 181a59c:	e0bfff17 	ldw	r2,-4(fp)
 181a5a0:	1007883a 	mov	r3,r2
 181a5a4:	e0bff817 	ldw	r2,-32(fp)
 181a5a8:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
 181a5ac:	e0bff817 	ldw	r2,-32(fp)
 181a5b0:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 181a5b4:	e0bffa0b 	ldhu	r2,-24(fp)
 181a5b8:	10800404 	addi	r2,r2,16
 181a5bc:	e0fff817 	ldw	r3,-32(fp)
 181a5c0:	1885883a 	add	r2,r3,r2
 181a5c4:	10c000c4 	addi	r3,r2,3
 181a5c8:	00bfff04 	movi	r2,-4
 181a5cc:	1884703a 	and	r2,r3,r2
 181a5d0:	1007883a 	mov	r3,r2
 181a5d4:	e0bff817 	ldw	r2,-32(fp)
 181a5d8:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 181a5dc:	e0bff817 	ldw	r2,-32(fp)
 181a5e0:	e0fffe0b 	ldhu	r3,-8(fp)
 181a5e4:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 181a5e8:	e0bffa0b 	ldhu	r2,-24(fp)
 181a5ec:	10c000c4 	addi	r3,r2,3
 181a5f0:	00bfff04 	movi	r2,-4
 181a5f4:	1884703a 	and	r2,r3,r2
 181a5f8:	00c17b04 	movi	r3,1516
 181a5fc:	1885c83a 	sub	r2,r3,r2
 181a600:	e0fffe0b 	ldhu	r3,-8(fp)
 181a604:	1880010e 	bge	r3,r2,181a60c <pbuf_alloc+0x124>
 181a608:	1805883a 	mov	r2,r3
 181a60c:	1007883a 	mov	r3,r2
 181a610:	e0bff817 	ldw	r2,-32(fp)
 181a614:	10c0028d 	sth	r3,10(r2)
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 181a618:	e0bff817 	ldw	r2,-32(fp)
 181a61c:	00c00044 	movi	r3,1
 181a620:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
 181a624:	e0bff817 	ldw	r2,-32(fp)
 181a628:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
 181a62c:	e0fffe0b 	ldhu	r3,-8(fp)
 181a630:	e0bff817 	ldw	r2,-32(fp)
 181a634:	1080028b 	ldhu	r2,10(r2)
 181a638:	10bfffcc 	andi	r2,r2,65535
 181a63c:	1885c83a 	sub	r2,r3,r2
 181a640:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 181a644:	00003006 	br	181a708 <pbuf_alloc+0x220>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 181a648:	01000384 	movi	r4,14
 181a64c:	18349580 	call	1834958 <memp_malloc>
 181a650:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
 181a654:	e0bffc17 	ldw	r2,-16(fp)
 181a658:	1000051e 	bne	r2,zero,181a670 <pbuf_alloc+0x188>
        PBUF_POOL_IS_EMPTY();
 181a65c:	181a4500 	call	181a450 <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
 181a660:	e13ff817 	ldw	r4,-32(fp)
 181a664:	181aca40 	call	181aca4 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 181a668:	0005883a 	mov	r2,zero
 181a66c:	00007406 	br	181a840 <pbuf_alloc+0x358>
      }
      q->type = type;
 181a670:	e0bfff17 	ldw	r2,-4(fp)
 181a674:	1007883a 	mov	r3,r2
 181a678:	e0bffc17 	ldw	r2,-16(fp)
 181a67c:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
 181a680:	e0bffc17 	ldw	r2,-16(fp)
 181a684:	10000345 	stb	zero,13(r2)
      q->next = NULL;
 181a688:	e0bffc17 	ldw	r2,-16(fp)
 181a68c:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
 181a690:	e0bff917 	ldw	r2,-28(fp)
 181a694:	e0fffc17 	ldw	r3,-16(fp)
 181a698:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 181a69c:	e0bffb17 	ldw	r2,-20(fp)
 181a6a0:	1007883a 	mov	r3,r2
 181a6a4:	e0bffc17 	ldw	r2,-16(fp)
 181a6a8:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 181a6ac:	e0bffb17 	ldw	r2,-20(fp)
 181a6b0:	10bfffcc 	andi	r2,r2,65535
 181a6b4:	10c17b50 	cmplti	r3,r2,1517
 181a6b8:	1800011e 	bne	r3,zero,181a6c0 <pbuf_alloc+0x1d8>
 181a6bc:	00817b04 	movi	r2,1516
 181a6c0:	1007883a 	mov	r3,r2
 181a6c4:	e0bffc17 	ldw	r2,-16(fp)
 181a6c8:	10c0028d 	sth	r3,10(r2)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 181a6cc:	e0bffc17 	ldw	r2,-16(fp)
 181a6d0:	10c00404 	addi	r3,r2,16
 181a6d4:	e0bffc17 	ldw	r2,-16(fp)
 181a6d8:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 181a6dc:	e0bffc17 	ldw	r2,-16(fp)
 181a6e0:	00c00044 	movi	r3,1
 181a6e4:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 181a6e8:	e0bffc17 	ldw	r2,-16(fp)
 181a6ec:	1080028b 	ldhu	r2,10(r2)
 181a6f0:	10bfffcc 	andi	r2,r2,65535
 181a6f4:	e0fffb17 	ldw	r3,-20(fp)
 181a6f8:	1885c83a 	sub	r2,r3,r2
 181a6fc:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
 181a700:	e0bffc17 	ldw	r2,-16(fp)
 181a704:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 181a708:	e0bffb17 	ldw	r2,-20(fp)
 181a70c:	00bfce16 	blt	zero,r2,181a648 <__ram_exceptions_end+0xff80a204>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
 181a710:	00004506 	br	181a828 <pbuf_alloc+0x340>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 181a714:	e0bffa0b 	ldhu	r2,-24(fp)
 181a718:	108004c4 	addi	r2,r2,19
 181a71c:	1007883a 	mov	r3,r2
 181a720:	00bfff04 	movi	r2,-4
 181a724:	1884703a 	and	r2,r3,r2
 181a728:	1007883a 	mov	r3,r2
 181a72c:	e0bffe0b 	ldhu	r2,-8(fp)
 181a730:	108000c4 	addi	r2,r2,3
 181a734:	1009883a 	mov	r4,r2
 181a738:	00bfff04 	movi	r2,-4
 181a73c:	2084703a 	and	r2,r4,r2
 181a740:	1885883a 	add	r2,r3,r2
 181a744:	10bfffcc 	andi	r2,r2,65535
 181a748:	1009883a 	mov	r4,r2
 181a74c:	18197f00 	call	18197f0 <mem_malloc>
 181a750:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
 181a754:	e0bff817 	ldw	r2,-32(fp)
 181a758:	1000021e 	bne	r2,zero,181a764 <pbuf_alloc+0x27c>
      return NULL;
 181a75c:	0005883a 	mov	r2,zero
 181a760:	00003706 	br	181a840 <pbuf_alloc+0x358>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 181a764:	e0bffa0b 	ldhu	r2,-24(fp)
 181a768:	10800404 	addi	r2,r2,16
 181a76c:	e0fff817 	ldw	r3,-32(fp)
 181a770:	1885883a 	add	r2,r3,r2
 181a774:	10c000c4 	addi	r3,r2,3
 181a778:	00bfff04 	movi	r2,-4
 181a77c:	1884703a 	and	r2,r3,r2
 181a780:	1007883a 	mov	r3,r2
 181a784:	e0bff817 	ldw	r2,-32(fp)
 181a788:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
 181a78c:	e0bff817 	ldw	r2,-32(fp)
 181a790:	e0fffe0b 	ldhu	r3,-8(fp)
 181a794:	10c0020d 	sth	r3,8(r2)
 181a798:	e0bff817 	ldw	r2,-32(fp)
 181a79c:	10c0020b 	ldhu	r3,8(r2)
 181a7a0:	e0bff817 	ldw	r2,-32(fp)
 181a7a4:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
 181a7a8:	e0bff817 	ldw	r2,-32(fp)
 181a7ac:	10000015 	stw	zero,0(r2)
    p->type = type;
 181a7b0:	e0bfff17 	ldw	r2,-4(fp)
 181a7b4:	1007883a 	mov	r3,r2
 181a7b8:	e0bff817 	ldw	r2,-32(fp)
 181a7bc:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
 181a7c0:	00001906 	br	181a828 <pbuf_alloc+0x340>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 181a7c4:	01000344 	movi	r4,13
 181a7c8:	18349580 	call	1834958 <memp_malloc>
 181a7cc:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
 181a7d0:	e0bff817 	ldw	r2,-32(fp)
 181a7d4:	1000021e 	bne	r2,zero,181a7e0 <pbuf_alloc+0x2f8>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
 181a7d8:	0005883a 	mov	r2,zero
 181a7dc:	00001806 	br	181a840 <pbuf_alloc+0x358>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 181a7e0:	e0bff817 	ldw	r2,-32(fp)
 181a7e4:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
 181a7e8:	e0bff817 	ldw	r2,-32(fp)
 181a7ec:	e0fffe0b 	ldhu	r3,-8(fp)
 181a7f0:	10c0020d 	sth	r3,8(r2)
 181a7f4:	e0bff817 	ldw	r2,-32(fp)
 181a7f8:	10c0020b 	ldhu	r3,8(r2)
 181a7fc:	e0bff817 	ldw	r2,-32(fp)
 181a800:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
 181a804:	e0bff817 	ldw	r2,-32(fp)
 181a808:	10000015 	stw	zero,0(r2)
    p->type = type;
 181a80c:	e0bfff17 	ldw	r2,-4(fp)
 181a810:	1007883a 	mov	r3,r2
 181a814:	e0bff817 	ldw	r2,-32(fp)
 181a818:	10c00305 	stb	r3,12(r2)
    break;
 181a81c:	00000206 	br	181a828 <pbuf_alloc+0x340>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 181a820:	0005883a 	mov	r2,zero
 181a824:	00000606 	br	181a840 <pbuf_alloc+0x358>
  }
  /* set reference count */
  p->ref = 1;
 181a828:	e0bff817 	ldw	r2,-32(fp)
 181a82c:	00c00044 	movi	r3,1
 181a830:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
 181a834:	e0bff817 	ldw	r2,-32(fp)
 181a838:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 181a83c:	e0bff817 	ldw	r2,-32(fp)
}
 181a840:	e037883a 	mov	sp,fp
 181a844:	dfc00117 	ldw	ra,4(sp)
 181a848:	df000017 	ldw	fp,0(sp)
 181a84c:	dec00204 	addi	sp,sp,8
 181a850:	f800283a 	ret

0181a854 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 181a854:	defff904 	addi	sp,sp,-28
 181a858:	df000615 	stw	fp,24(sp)
 181a85c:	df000604 	addi	fp,sp,24
 181a860:	e13ffb15 	stw	r4,-20(fp)
 181a864:	2807883a 	mov	r3,r5
 181a868:	e1bffd15 	stw	r6,-12(fp)
 181a86c:	e1fffe15 	stw	r7,-8(fp)
 181a870:	e0800217 	ldw	r2,8(fp)
 181a874:	e0fffc0d 	sth	r3,-16(fp)
 181a878:	e0bfff0d 	sth	r2,-4(fp)
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 181a87c:	e0bffb17 	ldw	r2,-20(fp)
 181a880:	10c00060 	cmpeqi	r3,r2,1
 181a884:	1800091e 	bne	r3,zero,181a8ac <pbuf_alloced_custom+0x58>
 181a888:	0080052e 	bgeu	zero,r2,181a8a0 <pbuf_alloced_custom+0x4c>
 181a88c:	10c000a0 	cmpeqi	r3,r2,2
 181a890:	1800091e 	bne	r3,zero,181a8b8 <pbuf_alloced_custom+0x64>
 181a894:	108000e0 	cmpeqi	r2,r2,3
 181a898:	10000a1e 	bne	r2,zero,181a8c4 <pbuf_alloced_custom+0x70>
 181a89c:	00000b06 	br	181a8cc <pbuf_alloced_custom+0x78>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 181a8a0:	00800e04 	movi	r2,56
 181a8a4:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a8a8:	00000a06 	br	181a8d4 <pbuf_alloced_custom+0x80>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 181a8ac:	00800904 	movi	r2,36
 181a8b0:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a8b4:	00000706 	br	181a8d4 <pbuf_alloced_custom+0x80>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 181a8b8:	00800404 	movi	r2,16
 181a8bc:	e0bffa0d 	sth	r2,-24(fp)
    break;
 181a8c0:	00000406 	br	181a8d4 <pbuf_alloced_custom+0x80>
  case PBUF_RAW:
    offset = 0;
 181a8c4:	e03ffa0d 	sth	zero,-24(fp)
    break;
 181a8c8:	00000206 	br	181a8d4 <pbuf_alloced_custom+0x80>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
 181a8cc:	0005883a 	mov	r2,zero
 181a8d0:	00002c06 	br	181a984 <pbuf_alloced_custom+0x130>
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 181a8d4:	e0bffa0b 	ldhu	r2,-24(fp)
 181a8d8:	10c000c4 	addi	r3,r2,3
 181a8dc:	00bfff04 	movi	r2,-4
 181a8e0:	1886703a 	and	r3,r3,r2
 181a8e4:	e0bffc0b 	ldhu	r2,-16(fp)
 181a8e8:	1885883a 	add	r2,r3,r2
 181a8ec:	e0ffff0b 	ldhu	r3,-4(fp)
 181a8f0:	1880020e 	bge	r3,r2,181a8fc <pbuf_alloced_custom+0xa8>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 181a8f4:	0005883a 	mov	r2,zero
 181a8f8:	00002206 	br	181a984 <pbuf_alloced_custom+0x130>
  }

  p->pbuf.next = NULL;
 181a8fc:	e0bffe17 	ldw	r2,-8(fp)
 181a900:	10000015 	stw	zero,0(r2)
  if (payload_mem != NULL) {
 181a904:	e0800117 	ldw	r2,4(fp)
 181a908:	10000a26 	beq	r2,zero,181a934 <pbuf_alloced_custom+0xe0>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 181a90c:	e0bffa0b 	ldhu	r2,-24(fp)
 181a910:	108000c4 	addi	r2,r2,3
 181a914:	1007883a 	mov	r3,r2
 181a918:	00bfff04 	movi	r2,-4
 181a91c:	1884703a 	and	r2,r3,r2
 181a920:	e0c00117 	ldw	r3,4(fp)
 181a924:	1887883a 	add	r3,r3,r2
 181a928:	e0bffe17 	ldw	r2,-8(fp)
 181a92c:	10c00115 	stw	r3,4(r2)
 181a930:	00000206 	br	181a93c <pbuf_alloced_custom+0xe8>
  } else {
    p->pbuf.payload = NULL;
 181a934:	e0bffe17 	ldw	r2,-8(fp)
 181a938:	10000115 	stw	zero,4(r2)
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 181a93c:	e0bffe17 	ldw	r2,-8(fp)
 181a940:	00c00084 	movi	r3,2
 181a944:	10c00345 	stb	r3,13(r2)
  p->pbuf.len = p->pbuf.tot_len = length;
 181a948:	e0bffe17 	ldw	r2,-8(fp)
 181a94c:	e0fffc0b 	ldhu	r3,-16(fp)
 181a950:	10c0020d 	sth	r3,8(r2)
 181a954:	e0bffe17 	ldw	r2,-8(fp)
 181a958:	10c0020b 	ldhu	r3,8(r2)
 181a95c:	e0bffe17 	ldw	r2,-8(fp)
 181a960:	10c0028d 	sth	r3,10(r2)
  p->pbuf.type = type;
 181a964:	e0bffd17 	ldw	r2,-12(fp)
 181a968:	1007883a 	mov	r3,r2
 181a96c:	e0bffe17 	ldw	r2,-8(fp)
 181a970:	10c00305 	stb	r3,12(r2)
  p->pbuf.ref = 1;
 181a974:	e0bffe17 	ldw	r2,-8(fp)
 181a978:	00c00044 	movi	r3,1
 181a97c:	10c0038d 	sth	r3,14(r2)
  return &p->pbuf;
 181a980:	e0bffe17 	ldw	r2,-8(fp)
}
 181a984:	e037883a 	mov	sp,fp
 181a988:	df000017 	ldw	fp,0(sp)
 181a98c:	dec00104 	addi	sp,sp,4
 181a990:	f800283a 	ret

0181a994 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 181a994:	defff904 	addi	sp,sp,-28
 181a998:	dfc00615 	stw	ra,24(sp)
 181a99c:	df000515 	stw	fp,20(sp)
 181a9a0:	df000504 	addi	fp,sp,20
 181a9a4:	e13ffe15 	stw	r4,-8(fp)
 181a9a8:	2805883a 	mov	r2,r5
 181a9ac:	e0bfff0d 	sth	r2,-4(fp)
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 181a9b0:	e0bffe17 	ldw	r2,-8(fp)
 181a9b4:	1080020b 	ldhu	r2,8(r2)
 181a9b8:	10bfffcc 	andi	r2,r2,65535
 181a9bc:	e0ffff0b 	ldhu	r3,-4(fp)
 181a9c0:	1880462e 	bgeu	r3,r2,181aadc <pbuf_realloc+0x148>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 181a9c4:	e0ffff0b 	ldhu	r3,-4(fp)
 181a9c8:	e0bffe17 	ldw	r2,-8(fp)
 181a9cc:	1080020b 	ldhu	r2,8(r2)
 181a9d0:	10bfffcc 	andi	r2,r2,65535
 181a9d4:	1885c83a 	sub	r2,r3,r2
 181a9d8:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 181a9dc:	e0bfff0b 	ldhu	r2,-4(fp)
 181a9e0:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
 181a9e4:	e0bffe17 	ldw	r2,-8(fp)
 181a9e8:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 181a9ec:	00000f06 	br	181aa2c <pbuf_realloc+0x98>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 181a9f0:	e0bffb17 	ldw	r2,-20(fp)
 181a9f4:	1080028b 	ldhu	r2,10(r2)
 181a9f8:	e0fffc0b 	ldhu	r3,-16(fp)
 181a9fc:	1885c83a 	sub	r2,r3,r2
 181aa00:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 181aa04:	e0bffb17 	ldw	r2,-20(fp)
 181aa08:	1080020b 	ldhu	r2,8(r2)
 181aa0c:	e0fffd17 	ldw	r3,-12(fp)
 181aa10:	10c5883a 	add	r2,r2,r3
 181aa14:	1007883a 	mov	r3,r2
 181aa18:	e0bffb17 	ldw	r2,-20(fp)
 181aa1c:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
 181aa20:	e0bffb17 	ldw	r2,-20(fp)
 181aa24:	10800017 	ldw	r2,0(r2)
 181aa28:	e0bffb15 	stw	r2,-20(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 181aa2c:	e0bffb17 	ldw	r2,-20(fp)
 181aa30:	1080028b 	ldhu	r2,10(r2)
 181aa34:	10ffffcc 	andi	r3,r2,65535
 181aa38:	e0bffc0b 	ldhu	r2,-16(fp)
 181aa3c:	18bfec36 	bltu	r3,r2,181a9f0 <__ram_exceptions_end+0xff80a5ac>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 181aa40:	e0bffb17 	ldw	r2,-20(fp)
 181aa44:	10800303 	ldbu	r2,12(r2)
 181aa48:	10803fcc 	andi	r2,r2,255
 181aa4c:	1000121e 	bne	r2,zero,181aa98 <pbuf_realloc+0x104>
 181aa50:	e0bffb17 	ldw	r2,-20(fp)
 181aa54:	1080028b 	ldhu	r2,10(r2)
 181aa58:	10ffffcc 	andi	r3,r2,65535
 181aa5c:	e0bffc0b 	ldhu	r2,-16(fp)
 181aa60:	18800d26 	beq	r3,r2,181aa98 <pbuf_realloc+0x104>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 181aa64:	e0bffb17 	ldw	r2,-20(fp)
 181aa68:	10800117 	ldw	r2,4(r2)
 181aa6c:	1007883a 	mov	r3,r2
 181aa70:	e0bffb17 	ldw	r2,-20(fp)
 181aa74:	1885c83a 	sub	r2,r3,r2
 181aa78:	1007883a 	mov	r3,r2
 181aa7c:	e0bffc0b 	ldhu	r2,-16(fp)
 181aa80:	1885883a 	add	r2,r3,r2
 181aa84:	10bfffcc 	andi	r2,r2,65535
 181aa88:	100b883a 	mov	r5,r2
 181aa8c:	e13ffb17 	ldw	r4,-20(fp)
 181aa90:	18194e80 	call	18194e8 <mem_trim>
 181aa94:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 181aa98:	e0bffb17 	ldw	r2,-20(fp)
 181aa9c:	e0fffc0b 	ldhu	r3,-16(fp)
 181aaa0:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
 181aaa4:	e0bffb17 	ldw	r2,-20(fp)
 181aaa8:	10c0028b 	ldhu	r3,10(r2)
 181aaac:	e0bffb17 	ldw	r2,-20(fp)
 181aab0:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 181aab4:	e0bffb17 	ldw	r2,-20(fp)
 181aab8:	10800017 	ldw	r2,0(r2)
 181aabc:	10000426 	beq	r2,zero,181aad0 <pbuf_realloc+0x13c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 181aac0:	e0bffb17 	ldw	r2,-20(fp)
 181aac4:	10800017 	ldw	r2,0(r2)
 181aac8:	1009883a 	mov	r4,r2
 181aacc:	181aca40 	call	181aca4 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 181aad0:	e0bffb17 	ldw	r2,-20(fp)
 181aad4:	10000015 	stw	zero,0(r2)
 181aad8:	00000106 	br	181aae0 <pbuf_realloc+0x14c>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
 181aadc:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
 181aae0:	e037883a 	mov	sp,fp
 181aae4:	dfc00117 	ldw	ra,4(sp)
 181aae8:	df000017 	ldw	fp,0(sp)
 181aaec:	dec00204 	addi	sp,sp,8
 181aaf0:	f800283a 	ret

0181aaf4 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 181aaf4:	defffa04 	addi	sp,sp,-24
 181aaf8:	dfc00515 	stw	ra,20(sp)
 181aafc:	df000415 	stw	fp,16(sp)
 181ab00:	df000404 	addi	fp,sp,16
 181ab04:	e13ffe15 	stw	r4,-8(fp)
 181ab08:	2805883a 	mov	r2,r5
 181ab0c:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 181ab10:	e0bfff0f 	ldh	r2,-4(fp)
 181ab14:	10000226 	beq	r2,zero,181ab20 <pbuf_header+0x2c>
 181ab18:	e0bffe17 	ldw	r2,-8(fp)
 181ab1c:	1000021e 	bne	r2,zero,181ab28 <pbuf_header+0x34>
    return 0;
 181ab20:	0005883a 	mov	r2,zero
 181ab24:	00005a06 	br	181ac90 <pbuf_header+0x19c>
  }
 
  if (header_size_increment < 0){
 181ab28:	e0bfff0f 	ldh	r2,-4(fp)
 181ab2c:	1000110e 	bge	r2,zero,181ab74 <pbuf_header+0x80>
    increment_magnitude = -header_size_increment;
 181ab30:	e0bfff0b 	ldhu	r2,-4(fp)
 181ab34:	0085c83a 	sub	r2,zero,r2
 181ab38:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 181ab3c:	e0bffe17 	ldw	r2,-8(fp)
 181ab40:	1080028b 	ldhu	r2,10(r2)
 181ab44:	10ffffcc 	andi	r3,r2,65535
 181ab48:	e0bffc0b 	ldhu	r2,-16(fp)
 181ab4c:	18800b2e 	bgeu	r3,r2,181ab7c <pbuf_header+0x88>
 181ab50:	01c06134 	movhi	r7,388
 181ab54:	39c64e04 	addi	r7,r7,6456
 181ab58:	01808344 	movi	r6,525
 181ab5c:	01406134 	movhi	r5,388
 181ab60:	29465404 	addi	r5,r5,6480
 181ab64:	01006134 	movhi	r4,388
 181ab68:	21065c04 	addi	r4,r4,6512
 181ab6c:	1800c180 	call	1800c18 <printf>
 181ab70:	003fff06 	br	181ab70 <__ram_exceptions_end+0xff80a72c>
  } else {
    increment_magnitude = header_size_increment;
 181ab74:	e0bfff0b 	ldhu	r2,-4(fp)
 181ab78:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 181ab7c:	e0bffe17 	ldw	r2,-8(fp)
 181ab80:	10800303 	ldbu	r2,12(r2)
 181ab84:	10803fcc 	andi	r2,r2,255
 181ab88:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
 181ab8c:	e0bffe17 	ldw	r2,-8(fp)
 181ab90:	10800117 	ldw	r2,4(r2)
 181ab94:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 181ab98:	e0bffc8b 	ldhu	r2,-14(fp)
 181ab9c:	10000326 	beq	r2,zero,181abac <pbuf_header+0xb8>
 181aba0:	e0bffc8b 	ldhu	r2,-14(fp)
 181aba4:	108000d8 	cmpnei	r2,r2,3
 181aba8:	1000111e 	bne	r2,zero,181abf0 <pbuf_header+0xfc>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 181abac:	e0bffe17 	ldw	r2,-8(fp)
 181abb0:	10c00117 	ldw	r3,4(r2)
 181abb4:	e0bfff0f 	ldh	r2,-4(fp)
 181abb8:	0085c83a 	sub	r2,zero,r2
 181abbc:	1887883a 	add	r3,r3,r2
 181abc0:	e0bffe17 	ldw	r2,-8(fp)
 181abc4:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 181abc8:	e0bffe17 	ldw	r2,-8(fp)
 181abcc:	10c00117 	ldw	r3,4(r2)
 181abd0:	e0bffe17 	ldw	r2,-8(fp)
 181abd4:	10800404 	addi	r2,r2,16
 181abd8:	18801e2e 	bgeu	r3,r2,181ac54 <pbuf_header+0x160>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 181abdc:	e0bffe17 	ldw	r2,-8(fp)
 181abe0:	e0fffd17 	ldw	r3,-12(fp)
 181abe4:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
 181abe8:	00800044 	movi	r2,1
 181abec:	00002806 	br	181ac90 <pbuf_header+0x19c>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 181abf0:	e0bffc8b 	ldhu	r2,-14(fp)
 181abf4:	108000a0 	cmpeqi	r2,r2,2
 181abf8:	1000031e 	bne	r2,zero,181ac08 <pbuf_header+0x114>
 181abfc:	e0bffc8b 	ldhu	r2,-14(fp)
 181ac00:	10800058 	cmpnei	r2,r2,1
 181ac04:	1000111e 	bne	r2,zero,181ac4c <pbuf_header+0x158>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 181ac08:	e0bfff0f 	ldh	r2,-4(fp)
 181ac0c:	10000d0e 	bge	r2,zero,181ac44 <pbuf_header+0x150>
 181ac10:	e0bffe17 	ldw	r2,-8(fp)
 181ac14:	1080028b 	ldhu	r2,10(r2)
 181ac18:	10ffffcc 	andi	r3,r2,65535
 181ac1c:	e0bffc0b 	ldhu	r2,-16(fp)
 181ac20:	18800836 	bltu	r3,r2,181ac44 <pbuf_header+0x150>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 181ac24:	e0bffe17 	ldw	r2,-8(fp)
 181ac28:	10c00117 	ldw	r3,4(r2)
 181ac2c:	e0bfff0f 	ldh	r2,-4(fp)
 181ac30:	0085c83a 	sub	r2,zero,r2
 181ac34:	1887883a 	add	r3,r3,r2
 181ac38:	e0bffe17 	ldw	r2,-8(fp)
 181ac3c:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 181ac40:	00000406 	br	181ac54 <pbuf_header+0x160>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 181ac44:	00800044 	movi	r2,1
 181ac48:	00001106 	br	181ac90 <pbuf_header+0x19c>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 181ac4c:	00800044 	movi	r2,1
 181ac50:	00000f06 	br	181ac90 <pbuf_header+0x19c>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 181ac54:	e0bffe17 	ldw	r2,-8(fp)
 181ac58:	10c0028b 	ldhu	r3,10(r2)
 181ac5c:	e0bfff0b 	ldhu	r2,-4(fp)
 181ac60:	1885883a 	add	r2,r3,r2
 181ac64:	1007883a 	mov	r3,r2
 181ac68:	e0bffe17 	ldw	r2,-8(fp)
 181ac6c:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
 181ac70:	e0bffe17 	ldw	r2,-8(fp)
 181ac74:	10c0020b 	ldhu	r3,8(r2)
 181ac78:	e0bfff0b 	ldhu	r2,-4(fp)
 181ac7c:	1885883a 	add	r2,r3,r2
 181ac80:	1007883a 	mov	r3,r2
 181ac84:	e0bffe17 	ldw	r2,-8(fp)
 181ac88:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 181ac8c:	0005883a 	mov	r2,zero
}
 181ac90:	e037883a 	mov	sp,fp
 181ac94:	dfc00117 	ldw	ra,4(sp)
 181ac98:	df000017 	ldw	fp,0(sp)
 181ac9c:	dec00204 	addi	sp,sp,8
 181aca0:	f800283a 	ret

0181aca4 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 181aca4:	defff904 	addi	sp,sp,-28
 181aca8:	dfc00615 	stw	ra,24(sp)
 181acac:	df000515 	stw	fp,20(sp)
 181acb0:	df000504 	addi	fp,sp,20
 181acb4:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 181acb8:	e0bfff17 	ldw	r2,-4(fp)
 181acbc:	1000021e 	bne	r2,zero,181acc8 <pbuf_free+0x24>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 181acc0:	0005883a 	mov	r2,zero
 181acc4:	00004306 	br	181add4 <pbuf_free+0x130>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
 181acc8:	e03ffb05 	stb	zero,-20(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 181accc:	00003e06 	br	181adc8 <pbuf_free+0x124>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 181acd0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181acd4:	10000126 	beq	r2,zero,181acdc <pbuf_free+0x38>
 181acd8:	181103c0 	call	181103c <vTaskEnterCritical>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 181acdc:	e0bfff17 	ldw	r2,-4(fp)
 181ace0:	1080038b 	ldhu	r2,14(r2)
 181ace4:	10bfffc4 	addi	r2,r2,-1
 181ace8:	1007883a 	mov	r3,r2
 181acec:	e0bfff17 	ldw	r2,-4(fp)
 181acf0:	10c0038d 	sth	r3,14(r2)
 181acf4:	e0bfff17 	ldw	r2,-4(fp)
 181acf8:	1080038b 	ldhu	r2,14(r2)
 181acfc:	e0bffb8d 	sth	r2,-18(fp)
    SYS_ARCH_UNPROTECT(old_level);
 181ad00:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181ad04:	10000126 	beq	r2,zero,181ad0c <pbuf_free+0x68>
 181ad08:	18110840 	call	1811084 <vTaskExitCritical>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 181ad0c:	e0bffb8b 	ldhu	r2,-18(fp)
 181ad10:	10002c1e 	bne	r2,zero,181adc4 <pbuf_free+0x120>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 181ad14:	e0bfff17 	ldw	r2,-4(fp)
 181ad18:	10800017 	ldw	r2,0(r2)
 181ad1c:	e0bffc15 	stw	r2,-16(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 181ad20:	e0bfff17 	ldw	r2,-4(fp)
 181ad24:	10800303 	ldbu	r2,12(r2)
 181ad28:	10803fcc 	andi	r2,r2,255
 181ad2c:	e0bffd0d 	sth	r2,-12(fp)
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 181ad30:	e0bfff17 	ldw	r2,-4(fp)
 181ad34:	10800343 	ldbu	r2,13(r2)
 181ad38:	10803fcc 	andi	r2,r2,255
 181ad3c:	1080008c 	andi	r2,r2,2
 181ad40:	10000726 	beq	r2,zero,181ad60 <pbuf_free+0xbc>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
 181ad44:	e0bfff17 	ldw	r2,-4(fp)
 181ad48:	e0bffe15 	stw	r2,-8(fp)
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 181ad4c:	e0bffe17 	ldw	r2,-8(fp)
 181ad50:	10800417 	ldw	r2,16(r2)
 181ad54:	e13fff17 	ldw	r4,-4(fp)
 181ad58:	103ee83a 	callr	r2
 181ad5c:	00001306 	br	181adac <pbuf_free+0x108>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 181ad60:	e0bffd0b 	ldhu	r2,-12(fp)
 181ad64:	108000d8 	cmpnei	r2,r2,3
 181ad68:	1000041e 	bne	r2,zero,181ad7c <pbuf_free+0xd8>
          memp_free(MEMP_PBUF_POOL, p);
 181ad6c:	e17fff17 	ldw	r5,-4(fp)
 181ad70:	01000384 	movi	r4,14
 181ad74:	1834b240 	call	1834b24 <memp_free>
 181ad78:	00000c06 	br	181adac <pbuf_free+0x108>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 181ad7c:	e0bffd0b 	ldhu	r2,-12(fp)
 181ad80:	10800060 	cmpeqi	r2,r2,1
 181ad84:	1000031e 	bne	r2,zero,181ad94 <pbuf_free+0xf0>
 181ad88:	e0bffd0b 	ldhu	r2,-12(fp)
 181ad8c:	10800098 	cmpnei	r2,r2,2
 181ad90:	1000041e 	bne	r2,zero,181ada4 <pbuf_free+0x100>
          memp_free(MEMP_PBUF, p);
 181ad94:	e17fff17 	ldw	r5,-4(fp)
 181ad98:	01000344 	movi	r4,13
 181ad9c:	1834b240 	call	1834b24 <memp_free>
 181ada0:	00000206 	br	181adac <pbuf_free+0x108>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 181ada4:	e13fff17 	ldw	r4,-4(fp)
 181ada8:	18193dc0 	call	18193dc <mem_free>
        }
      }
      count++;
 181adac:	e0bffb03 	ldbu	r2,-20(fp)
 181adb0:	10800044 	addi	r2,r2,1
 181adb4:	e0bffb05 	stb	r2,-20(fp)
      /* proceed to next pbuf */
      p = q;
 181adb8:	e0bffc17 	ldw	r2,-16(fp)
 181adbc:	e0bfff15 	stw	r2,-4(fp)
 181adc0:	00000106 	br	181adc8 <pbuf_free+0x124>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
 181adc4:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 181adc8:	e0bfff17 	ldw	r2,-4(fp)
 181adcc:	103fc01e 	bne	r2,zero,181acd0 <__ram_exceptions_end+0xff80a88c>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 181add0:	e0bffb03 	ldbu	r2,-20(fp)
}
 181add4:	e037883a 	mov	sp,fp
 181add8:	dfc00117 	ldw	ra,4(sp)
 181addc:	df000017 	ldw	fp,0(sp)
 181ade0:	dec00204 	addi	sp,sp,8
 181ade4:	f800283a 	ret

0181ade8 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 181ade8:	defffd04 	addi	sp,sp,-12
 181adec:	df000215 	stw	fp,8(sp)
 181adf0:	df000204 	addi	fp,sp,8
 181adf4:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
 181adf8:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
 181adfc:	00000606 	br	181ae18 <pbuf_clen+0x30>
    ++len;
 181ae00:	e0bffe03 	ldbu	r2,-8(fp)
 181ae04:	10800044 	addi	r2,r2,1
 181ae08:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
 181ae0c:	e0bfff17 	ldw	r2,-4(fp)
 181ae10:	10800017 	ldw	r2,0(r2)
 181ae14:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 181ae18:	e0bfff17 	ldw	r2,-4(fp)
 181ae1c:	103ff81e 	bne	r2,zero,181ae00 <__ram_exceptions_end+0xff80a9bc>
    ++len;
    p = p->next;
  }
  return len;
 181ae20:	e0bffe03 	ldbu	r2,-8(fp)
}
 181ae24:	e037883a 	mov	sp,fp
 181ae28:	df000017 	ldw	fp,0(sp)
 181ae2c:	dec00104 	addi	sp,sp,4
 181ae30:	f800283a 	ret

0181ae34 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 181ae34:	defffd04 	addi	sp,sp,-12
 181ae38:	dfc00215 	stw	ra,8(sp)
 181ae3c:	df000115 	stw	fp,4(sp)
 181ae40:	df000104 	addi	fp,sp,4
 181ae44:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 181ae48:	e0bfff17 	ldw	r2,-4(fp)
 181ae4c:	10000c26 	beq	r2,zero,181ae80 <pbuf_ref+0x4c>
    SYS_ARCH_PROTECT(old_level);
 181ae50:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181ae54:	10000126 	beq	r2,zero,181ae5c <pbuf_ref+0x28>
 181ae58:	181103c0 	call	181103c <vTaskEnterCritical>
    ++(p->ref);
 181ae5c:	e0bfff17 	ldw	r2,-4(fp)
 181ae60:	1080038b 	ldhu	r2,14(r2)
 181ae64:	10800044 	addi	r2,r2,1
 181ae68:	1007883a 	mov	r3,r2
 181ae6c:	e0bfff17 	ldw	r2,-4(fp)
 181ae70:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
 181ae74:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 181ae78:	10000126 	beq	r2,zero,181ae80 <pbuf_ref+0x4c>
 181ae7c:	18110840 	call	1811084 <vTaskExitCritical>
  }
}
 181ae80:	0001883a 	nop
 181ae84:	e037883a 	mov	sp,fp
 181ae88:	dfc00117 	ldw	ra,4(sp)
 181ae8c:	df000017 	ldw	fp,0(sp)
 181ae90:	dec00204 	addi	sp,sp,8
 181ae94:	f800283a 	ret

0181ae98 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 181ae98:	defffb04 	addi	sp,sp,-20
 181ae9c:	dfc00415 	stw	ra,16(sp)
 181aea0:	df000315 	stw	fp,12(sp)
 181aea4:	df000304 	addi	fp,sp,12
 181aea8:	e13ffe15 	stw	r4,-8(fp)
 181aeac:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 181aeb0:	e0bffe17 	ldw	r2,-8(fp)
 181aeb4:	10000226 	beq	r2,zero,181aec0 <pbuf_cat+0x28>
 181aeb8:	e0bfff17 	ldw	r2,-4(fp)
 181aebc:	1000091e 	bne	r2,zero,181aee4 <pbuf_cat+0x4c>
 181aec0:	01c06134 	movhi	r7,388
 181aec4:	39c64e04 	addi	r7,r7,6456
 181aec8:	0180bb84 	movi	r6,750
 181aecc:	01406134 	movhi	r5,388
 181aed0:	29466804 	addi	r5,r5,6560
 181aed4:	01006134 	movhi	r4,388
 181aed8:	21065c04 	addi	r4,r4,6512
 181aedc:	1800c180 	call	1800c18 <printf>
 181aee0:	003fff06 	br	181aee0 <__ram_exceptions_end+0xff80aa9c>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 181aee4:	e0bffe17 	ldw	r2,-8(fp)
 181aee8:	e0bffd15 	stw	r2,-12(fp)
 181aeec:	00000b06 	br	181af1c <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 181aef0:	e0bffd17 	ldw	r2,-12(fp)
 181aef4:	10c0020b 	ldhu	r3,8(r2)
 181aef8:	e0bfff17 	ldw	r2,-4(fp)
 181aefc:	1080020b 	ldhu	r2,8(r2)
 181af00:	1885883a 	add	r2,r3,r2
 181af04:	1007883a 	mov	r3,r2
 181af08:	e0bffd17 	ldw	r2,-12(fp)
 181af0c:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 181af10:	e0bffd17 	ldw	r2,-12(fp)
 181af14:	10800017 	ldw	r2,0(r2)
 181af18:	e0bffd15 	stw	r2,-12(fp)
 181af1c:	e0bffd17 	ldw	r2,-12(fp)
 181af20:	10800017 	ldw	r2,0(r2)
 181af24:	103ff21e 	bne	r2,zero,181aef0 <__ram_exceptions_end+0xff80aaac>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 181af28:	e0bffd17 	ldw	r2,-12(fp)
 181af2c:	10c0020b 	ldhu	r3,8(r2)
 181af30:	e0bfff17 	ldw	r2,-4(fp)
 181af34:	1080020b 	ldhu	r2,8(r2)
 181af38:	1885883a 	add	r2,r3,r2
 181af3c:	1007883a 	mov	r3,r2
 181af40:	e0bffd17 	ldw	r2,-12(fp)
 181af44:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 181af48:	e0bffd17 	ldw	r2,-12(fp)
 181af4c:	e0ffff17 	ldw	r3,-4(fp)
 181af50:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 181af54:	0001883a 	nop
 181af58:	e037883a 	mov	sp,fp
 181af5c:	dfc00117 	ldw	ra,4(sp)
 181af60:	df000017 	ldw	fp,0(sp)
 181af64:	dec00204 	addi	sp,sp,8
 181af68:	f800283a 	ret

0181af6c <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 181af6c:	defffc04 	addi	sp,sp,-16
 181af70:	dfc00315 	stw	ra,12(sp)
 181af74:	df000215 	stw	fp,8(sp)
 181af78:	df000204 	addi	fp,sp,8
 181af7c:	e13ffe15 	stw	r4,-8(fp)
 181af80:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
 181af84:	e17fff17 	ldw	r5,-4(fp)
 181af88:	e13ffe17 	ldw	r4,-8(fp)
 181af8c:	181ae980 	call	181ae98 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 181af90:	e13fff17 	ldw	r4,-4(fp)
 181af94:	181ae340 	call	181ae34 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 181af98:	0001883a 	nop
 181af9c:	e037883a 	mov	sp,fp
 181afa0:	dfc00117 	ldw	ra,4(sp)
 181afa4:	df000017 	ldw	fp,0(sp)
 181afa8:	dec00204 	addi	sp,sp,8
 181afac:	f800283a 	ret

0181afb0 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 181afb0:	defffb04 	addi	sp,sp,-20
 181afb4:	dfc00415 	stw	ra,16(sp)
 181afb8:	df000315 	stw	fp,12(sp)
 181afbc:	df000304 	addi	fp,sp,12
 181afc0:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
 181afc4:	00800044 	movi	r2,1
 181afc8:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
 181afcc:	e0bfff17 	ldw	r2,-4(fp)
 181afd0:	10800017 	ldw	r2,0(r2)
 181afd4:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
 181afd8:	e0bffe17 	ldw	r2,-8(fp)
 181afdc:	10001126 	beq	r2,zero,181b024 <pbuf_dechain+0x74>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
 181afe0:	e0bfff17 	ldw	r2,-4(fp)
 181afe4:	10c0020b 	ldhu	r3,8(r2)
 181afe8:	e0bfff17 	ldw	r2,-4(fp)
 181afec:	1080028b 	ldhu	r2,10(r2)
 181aff0:	1885c83a 	sub	r2,r3,r2
 181aff4:	1007883a 	mov	r3,r2
 181aff8:	e0bffe17 	ldw	r2,-8(fp)
 181affc:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
 181b000:	e0bfff17 	ldw	r2,-4(fp)
 181b004:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 181b008:	e0bfff17 	ldw	r2,-4(fp)
 181b00c:	10c0028b 	ldhu	r3,10(r2)
 181b010:	e0bfff17 	ldw	r2,-4(fp)
 181b014:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 181b018:	e13ffe17 	ldw	r4,-8(fp)
 181b01c:	181aca40 	call	181aca4 <pbuf_free>
 181b020:	e0bffd05 	stb	r2,-12(fp)
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 181b024:	e0bffd03 	ldbu	r2,-12(fp)
 181b028:	1000021e 	bne	r2,zero,181b034 <pbuf_dechain+0x84>
 181b02c:	e0bffe17 	ldw	r2,-8(fp)
 181b030:	00000106 	br	181b038 <pbuf_dechain+0x88>
 181b034:	0005883a 	mov	r2,zero
}
 181b038:	e037883a 	mov	sp,fp
 181b03c:	dfc00117 	ldw	ra,4(sp)
 181b040:	df000017 	ldw	fp,0(sp)
 181b044:	dec00204 	addi	sp,sp,8
 181b048:	f800283a 	ret

0181b04c <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 181b04c:	defffa04 	addi	sp,sp,-24
 181b050:	dfc00515 	stw	ra,20(sp)
 181b054:	df000415 	stw	fp,16(sp)
 181b058:	df000404 	addi	fp,sp,16
 181b05c:	e13ffe15 	stw	r4,-8(fp)
 181b060:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
 181b064:	e03ffc0d 	sth	zero,-16(fp)
 181b068:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 181b06c:	e0bffe17 	ldw	r2,-8(fp)
 181b070:	10000926 	beq	r2,zero,181b098 <pbuf_copy+0x4c>
 181b074:	e0bfff17 	ldw	r2,-4(fp)
 181b078:	10000726 	beq	r2,zero,181b098 <pbuf_copy+0x4c>
 181b07c:	e0bffe17 	ldw	r2,-8(fp)
 181b080:	10c0020b 	ldhu	r3,8(r2)
 181b084:	e0bfff17 	ldw	r2,-4(fp)
 181b088:	1080020b 	ldhu	r2,8(r2)
 181b08c:	18ffffcc 	andi	r3,r3,65535
 181b090:	10bfffcc 	andi	r2,r2,65535
 181b094:	1880092e 	bgeu	r3,r2,181b0bc <pbuf_copy+0x70>
 181b098:	01c06134 	movhi	r7,388
 181b09c:	39c64e04 	addi	r7,r7,6456
 181b0a0:	0180d744 	movi	r6,861
 181b0a4:	01406134 	movhi	r5,388
 181b0a8:	29467604 	addi	r5,r5,6616
 181b0ac:	01006134 	movhi	r4,388
 181b0b0:	21065c04 	addi	r4,r4,6512
 181b0b4:	1800c180 	call	1800c18 <printf>
 181b0b8:	003fff06 	br	181b0b8 <__ram_exceptions_end+0xff80ac74>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 181b0bc:	e0bffe17 	ldw	r2,-8(fp)
 181b0c0:	1080028b 	ldhu	r2,10(r2)
 181b0c4:	10ffffcc 	andi	r3,r2,65535
 181b0c8:	e0bffc0b 	ldhu	r2,-16(fp)
 181b0cc:	1887c83a 	sub	r3,r3,r2
 181b0d0:	e0bfff17 	ldw	r2,-4(fp)
 181b0d4:	1080028b 	ldhu	r2,10(r2)
 181b0d8:	113fffcc 	andi	r4,r2,65535
 181b0dc:	e0bffc8b 	ldhu	r2,-14(fp)
 181b0e0:	2085c83a 	sub	r2,r4,r2
 181b0e4:	18800616 	blt	r3,r2,181b100 <pbuf_copy+0xb4>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 181b0e8:	e0bfff17 	ldw	r2,-4(fp)
 181b0ec:	10c0028b 	ldhu	r3,10(r2)
 181b0f0:	e0bffc8b 	ldhu	r2,-14(fp)
 181b0f4:	1885c83a 	sub	r2,r3,r2
 181b0f8:	e0bffd0d 	sth	r2,-12(fp)
 181b0fc:	00000506 	br	181b114 <pbuf_copy+0xc8>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 181b100:	e0bffe17 	ldw	r2,-8(fp)
 181b104:	10c0028b 	ldhu	r3,10(r2)
 181b108:	e0bffc0b 	ldhu	r2,-16(fp)
 181b10c:	1885c83a 	sub	r2,r3,r2
 181b110:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 181b114:	e0bffe17 	ldw	r2,-8(fp)
 181b118:	10c00117 	ldw	r3,4(r2)
 181b11c:	e0bffc0b 	ldhu	r2,-16(fp)
 181b120:	1889883a 	add	r4,r3,r2
 181b124:	e0bfff17 	ldw	r2,-4(fp)
 181b128:	10c00117 	ldw	r3,4(r2)
 181b12c:	e0bffc8b 	ldhu	r2,-14(fp)
 181b130:	1885883a 	add	r2,r3,r2
 181b134:	e0fffd0b 	ldhu	r3,-12(fp)
 181b138:	180d883a 	mov	r6,r3
 181b13c:	100b883a 	mov	r5,r2
 181b140:	180608c0 	call	180608c <memcpy>
    offset_to += len;
 181b144:	e0fffc0b 	ldhu	r3,-16(fp)
 181b148:	e0bffd0b 	ldhu	r2,-12(fp)
 181b14c:	1885883a 	add	r2,r3,r2
 181b150:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
 181b154:	e0fffc8b 	ldhu	r3,-14(fp)
 181b158:	e0bffd0b 	ldhu	r2,-12(fp)
 181b15c:	1885883a 	add	r2,r3,r2
 181b160:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 181b164:	e0bfff17 	ldw	r2,-4(fp)
 181b168:	1080028b 	ldhu	r2,10(r2)
 181b16c:	10bfffcc 	andi	r2,r2,65535
 181b170:	e0fffc8b 	ldhu	r3,-14(fp)
 181b174:	18800436 	bltu	r3,r2,181b188 <pbuf_copy+0x13c>
      /* on to next p_from (if any) */
      offset_from = 0;
 181b178:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
 181b17c:	e0bfff17 	ldw	r2,-4(fp)
 181b180:	10800017 	ldw	r2,0(r2)
 181b184:	e0bfff15 	stw	r2,-4(fp)
    }
    if (offset_to == p_to->len) {
 181b188:	e0bffe17 	ldw	r2,-8(fp)
 181b18c:	1080028b 	ldhu	r2,10(r2)
 181b190:	10ffffcc 	andi	r3,r2,65535
 181b194:	e0bffc0b 	ldhu	r2,-16(fp)
 181b198:	1880111e 	bne	r3,r2,181b1e0 <pbuf_copy+0x194>
      /* on to next p_to (if any) */
      offset_to = 0;
 181b19c:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
 181b1a0:	e0bffe17 	ldw	r2,-8(fp)
 181b1a4:	10800017 	ldw	r2,0(r2)
 181b1a8:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 181b1ac:	e0bffe17 	ldw	r2,-8(fp)
 181b1b0:	10000b1e 	bne	r2,zero,181b1e0 <pbuf_copy+0x194>
 181b1b4:	e0bfff17 	ldw	r2,-4(fp)
 181b1b8:	10000926 	beq	r2,zero,181b1e0 <pbuf_copy+0x194>
 181b1bc:	01c06134 	movhi	r7,388
 181b1c0:	39c64e04 	addi	r7,r7,6456
 181b1c4:	0180de04 	movi	r6,888
 181b1c8:	01406134 	movhi	r5,388
 181b1cc:	29468204 	addi	r5,r5,6664
 181b1d0:	01006134 	movhi	r4,388
 181b1d4:	21065c04 	addi	r4,r4,6512
 181b1d8:	1800c180 	call	1800c18 <printf>
 181b1dc:	003fff06 	br	181b1dc <__ram_exceptions_end+0xff80ad98>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 181b1e0:	e0bfff17 	ldw	r2,-4(fp)
 181b1e4:	10001326 	beq	r2,zero,181b234 <pbuf_copy+0x1e8>
 181b1e8:	e0bfff17 	ldw	r2,-4(fp)
 181b1ec:	10c0028b 	ldhu	r3,10(r2)
 181b1f0:	e0bfff17 	ldw	r2,-4(fp)
 181b1f4:	1080020b 	ldhu	r2,8(r2)
 181b1f8:	18ffffcc 	andi	r3,r3,65535
 181b1fc:	10bfffcc 	andi	r2,r2,65535
 181b200:	18800c1e 	bne	r3,r2,181b234 <pbuf_copy+0x1e8>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 181b204:	e0bfff17 	ldw	r2,-4(fp)
 181b208:	10800017 	ldw	r2,0(r2)
 181b20c:	10000926 	beq	r2,zero,181b234 <pbuf_copy+0x1e8>
 181b210:	01c06134 	movhi	r7,388
 181b214:	39c64e04 	addi	r7,r7,6456
 181b218:	0180df84 	movi	r6,894
 181b21c:	01406134 	movhi	r5,388
 181b220:	29468604 	addi	r5,r5,6680
 181b224:	01006134 	movhi	r4,388
 181b228:	21065c04 	addi	r4,r4,6512
 181b22c:	1800c180 	call	1800c18 <printf>
 181b230:	003fff06 	br	181b230 <__ram_exceptions_end+0xff80adec>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 181b234:	e0bffe17 	ldw	r2,-8(fp)
 181b238:	10001326 	beq	r2,zero,181b288 <pbuf_copy+0x23c>
 181b23c:	e0bffe17 	ldw	r2,-8(fp)
 181b240:	10c0028b 	ldhu	r3,10(r2)
 181b244:	e0bffe17 	ldw	r2,-8(fp)
 181b248:	1080020b 	ldhu	r2,8(r2)
 181b24c:	18ffffcc 	andi	r3,r3,65535
 181b250:	10bfffcc 	andi	r2,r2,65535
 181b254:	18800c1e 	bne	r3,r2,181b288 <pbuf_copy+0x23c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 181b258:	e0bffe17 	ldw	r2,-8(fp)
 181b25c:	10800017 	ldw	r2,0(r2)
 181b260:	10000926 	beq	r2,zero,181b288 <pbuf_copy+0x23c>
 181b264:	01c06134 	movhi	r7,388
 181b268:	39c64e04 	addi	r7,r7,6456
 181b26c:	0180e0c4 	movi	r6,899
 181b270:	01406134 	movhi	r5,388
 181b274:	29468604 	addi	r5,r5,6680
 181b278:	01006134 	movhi	r4,388
 181b27c:	21065c04 	addi	r4,r4,6512
 181b280:	1800c180 	call	1800c18 <printf>
 181b284:	003fff06 	br	181b284 <__ram_exceptions_end+0xff80ae40>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 181b288:	e0bfff17 	ldw	r2,-4(fp)
 181b28c:	103f8b1e 	bne	r2,zero,181b0bc <__ram_exceptions_end+0xff80ac78>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 181b290:	0005883a 	mov	r2,zero
}
 181b294:	e037883a 	mov	sp,fp
 181b298:	dfc00117 	ldw	ra,4(sp)
 181b29c:	df000017 	ldw	fp,0(sp)
 181b2a0:	dec00204 	addi	sp,sp,8
 181b2a4:	f800283a 	ret

0181b2a8 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 181b2a8:	defff704 	addi	sp,sp,-36
 181b2ac:	dfc00815 	stw	ra,32(sp)
 181b2b0:	df000715 	stw	fp,28(sp)
 181b2b4:	df000704 	addi	fp,sp,28
 181b2b8:	e13ffc15 	stw	r4,-16(fp)
 181b2bc:	e17ffd15 	stw	r5,-12(fp)
 181b2c0:	3007883a 	mov	r3,r6
 181b2c4:	3805883a 	mov	r2,r7
 181b2c8:	e0fffe0d 	sth	r3,-8(fp)
 181b2cc:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 181b2d0:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 181b2d4:	e0bffc17 	ldw	r2,-16(fp)
 181b2d8:	1000091e 	bne	r2,zero,181b300 <pbuf_copy_partial+0x58>
 181b2dc:	01c06134 	movhi	r7,388
 181b2e0:	39c64e04 	addi	r7,r7,6456
 181b2e4:	0180e744 	movi	r6,925
 181b2e8:	01406134 	movhi	r5,388
 181b2ec:	29469104 	addi	r5,r5,6724
 181b2f0:	01006134 	movhi	r4,388
 181b2f4:	21065c04 	addi	r4,r4,6512
 181b2f8:	1800c180 	call	1800c18 <printf>
 181b2fc:	003fff06 	br	181b2fc <__ram_exceptions_end+0xff80aeb8>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 181b300:	e0bffd17 	ldw	r2,-12(fp)
 181b304:	1000091e 	bne	r2,zero,181b32c <pbuf_copy_partial+0x84>
 181b308:	01c06134 	movhi	r7,388
 181b30c:	39c64e04 	addi	r7,r7,6456
 181b310:	0180e784 	movi	r6,926
 181b314:	01406134 	movhi	r5,388
 181b318:	29469904 	addi	r5,r5,6756
 181b31c:	01006134 	movhi	r4,388
 181b320:	21065c04 	addi	r4,r4,6512
 181b324:	1800c180 	call	1800c18 <printf>
 181b328:	003fff06 	br	181b328 <__ram_exceptions_end+0xff80aee4>

  left = 0;
 181b32c:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
 181b330:	e0bffc17 	ldw	r2,-16(fp)
 181b334:	10000226 	beq	r2,zero,181b340 <pbuf_copy_partial+0x98>
 181b338:	e0bffd17 	ldw	r2,-12(fp)
 181b33c:	1000021e 	bne	r2,zero,181b348 <pbuf_copy_partial+0xa0>
    return 0;
 181b340:	0005883a 	mov	r2,zero
 181b344:	00003a06 	br	181b430 <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 181b348:	e0bffc17 	ldw	r2,-16(fp)
 181b34c:	e0bff915 	stw	r2,-28(fp)
 181b350:	00003206 	br	181b41c <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
 181b354:	e0bfff0b 	ldhu	r2,-4(fp)
 181b358:	10000b26 	beq	r2,zero,181b388 <pbuf_copy_partial+0xe0>
 181b35c:	e0bff917 	ldw	r2,-28(fp)
 181b360:	1080028b 	ldhu	r2,10(r2)
 181b364:	10bfffcc 	andi	r2,r2,65535
 181b368:	e0ffff0b 	ldhu	r3,-4(fp)
 181b36c:	18800636 	bltu	r3,r2,181b388 <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 181b370:	e0bff917 	ldw	r2,-28(fp)
 181b374:	1080028b 	ldhu	r2,10(r2)
 181b378:	e0ffff0b 	ldhu	r3,-4(fp)
 181b37c:	1885c83a 	sub	r2,r3,r2
 181b380:	e0bfff0d 	sth	r2,-4(fp)
 181b384:	00002206 	br	181b410 <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 181b388:	e0bff917 	ldw	r2,-28(fp)
 181b38c:	10c0028b 	ldhu	r3,10(r2)
 181b390:	e0bfff0b 	ldhu	r2,-4(fp)
 181b394:	1885c83a 	sub	r2,r3,r2
 181b398:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
 181b39c:	e0bffa8b 	ldhu	r2,-22(fp)
 181b3a0:	e0fffe0b 	ldhu	r3,-8(fp)
 181b3a4:	1880022e 	bgeu	r3,r2,181b3b0 <pbuf_copy_partial+0x108>
          buf_copy_len = len;
 181b3a8:	e0bffe0b 	ldhu	r2,-8(fp)
 181b3ac:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 181b3b0:	e0bffa0b 	ldhu	r2,-24(fp)
 181b3b4:	e0fffd17 	ldw	r3,-12(fp)
 181b3b8:	1889883a 	add	r4,r3,r2
 181b3bc:	e0bff917 	ldw	r2,-28(fp)
 181b3c0:	10c00117 	ldw	r3,4(r2)
 181b3c4:	e0bfff0b 	ldhu	r2,-4(fp)
 181b3c8:	1885883a 	add	r2,r3,r2
 181b3cc:	e0fffa8b 	ldhu	r3,-22(fp)
 181b3d0:	180d883a 	mov	r6,r3
 181b3d4:	100b883a 	mov	r5,r2
 181b3d8:	180608c0 	call	180608c <memcpy>
      copied_total += buf_copy_len;
 181b3dc:	e0fffb0b 	ldhu	r3,-20(fp)
 181b3e0:	e0bffa8b 	ldhu	r2,-22(fp)
 181b3e4:	1885883a 	add	r2,r3,r2
 181b3e8:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
 181b3ec:	e0fffa0b 	ldhu	r3,-24(fp)
 181b3f0:	e0bffa8b 	ldhu	r2,-22(fp)
 181b3f4:	1885883a 	add	r2,r3,r2
 181b3f8:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
 181b3fc:	e0fffe0b 	ldhu	r3,-8(fp)
 181b400:	e0bffa8b 	ldhu	r2,-22(fp)
 181b404:	1885c83a 	sub	r2,r3,r2
 181b408:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
 181b40c:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 181b410:	e0bff917 	ldw	r2,-28(fp)
 181b414:	10800017 	ldw	r2,0(r2)
 181b418:	e0bff915 	stw	r2,-28(fp)
 181b41c:	e0bffe0b 	ldhu	r2,-8(fp)
 181b420:	10000226 	beq	r2,zero,181b42c <pbuf_copy_partial+0x184>
 181b424:	e0bff917 	ldw	r2,-28(fp)
 181b428:	103fca1e 	bne	r2,zero,181b354 <__ram_exceptions_end+0xff80af10>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
 181b42c:	e0bffb0b 	ldhu	r2,-20(fp)
}
 181b430:	e037883a 	mov	sp,fp
 181b434:	dfc00117 	ldw	ra,4(sp)
 181b438:	df000017 	ldw	fp,0(sp)
 181b43c:	dec00204 	addi	sp,sp,8
 181b440:	f800283a 	ret

0181b444 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 181b444:	defff804 	addi	sp,sp,-32
 181b448:	dfc00715 	stw	ra,28(sp)
 181b44c:	df000615 	stw	fp,24(sp)
 181b450:	df000604 	addi	fp,sp,24
 181b454:	e13ffd15 	stw	r4,-12(fp)
 181b458:	e17ffe15 	stw	r5,-8(fp)
 181b45c:	3005883a 	mov	r2,r6
 181b460:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
 181b464:	e0bfff0b 	ldhu	r2,-4(fp)
 181b468:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
 181b46c:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 181b470:	e0bffd17 	ldw	r2,-12(fp)
 181b474:	1000091e 	bne	r2,zero,181b49c <pbuf_take+0x58>
 181b478:	01c06134 	movhi	r7,388
 181b47c:	39c64e04 	addi	r7,r7,6456
 181b480:	0180f344 	movi	r6,973
 181b484:	01406134 	movhi	r5,388
 181b488:	2946a204 	addi	r5,r5,6792
 181b48c:	01006134 	movhi	r4,388
 181b490:	21065c04 	addi	r4,r4,6512
 181b494:	1800c180 	call	1800c18 <printf>
 181b498:	003fff06 	br	181b498 <__ram_exceptions_end+0xff80b054>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 181b49c:	e0bffe17 	ldw	r2,-8(fp)
 181b4a0:	1000091e 	bne	r2,zero,181b4c8 <pbuf_take+0x84>
 181b4a4:	01c06134 	movhi	r7,388
 181b4a8:	39c64e04 	addi	r7,r7,6456
 181b4ac:	0180f384 	movi	r6,974
 181b4b0:	01406134 	movhi	r5,388
 181b4b4:	2946a804 	addi	r5,r5,6816
 181b4b8:	01006134 	movhi	r4,388
 181b4bc:	21065c04 	addi	r4,r4,6512
 181b4c0:	1800c180 	call	1800c18 <printf>
 181b4c4:	003fff06 	br	181b4c4 <__ram_exceptions_end+0xff80b080>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 181b4c8:	e0bffd17 	ldw	r2,-12(fp)
 181b4cc:	10000726 	beq	r2,zero,181b4ec <pbuf_take+0xa8>
 181b4d0:	e0bffe17 	ldw	r2,-8(fp)
 181b4d4:	10000526 	beq	r2,zero,181b4ec <pbuf_take+0xa8>
 181b4d8:	e0bffd17 	ldw	r2,-12(fp)
 181b4dc:	1080020b 	ldhu	r2,8(r2)
 181b4e0:	10ffffcc 	andi	r3,r2,65535
 181b4e4:	e0bfff0b 	ldhu	r2,-4(fp)
 181b4e8:	1880022e 	bgeu	r3,r2,181b4f4 <pbuf_take+0xb0>
    return ERR_ARG;
 181b4ec:	00bffc84 	movi	r2,-14
 181b4f0:	00002406 	br	181b584 <pbuf_take+0x140>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 181b4f4:	e0bffd17 	ldw	r2,-12(fp)
 181b4f8:	e0bffa15 	stw	r2,-24(fp)
 181b4fc:	00001e06 	br	181b578 <pbuf_take+0x134>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
 181b500:	e0bffb8b 	ldhu	r2,-18(fp)
 181b504:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
 181b508:	e0bffa17 	ldw	r2,-24(fp)
 181b50c:	1080028b 	ldhu	r2,10(r2)
 181b510:	10ffffcc 	andi	r3,r2,65535
 181b514:	e0bffb0b 	ldhu	r2,-20(fp)
 181b518:	1880032e 	bgeu	r3,r2,181b528 <pbuf_take+0xe4>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 181b51c:	e0bffa17 	ldw	r2,-24(fp)
 181b520:	1080028b 	ldhu	r2,10(r2)
 181b524:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 181b528:	e0bffa17 	ldw	r2,-24(fp)
 181b52c:	11000117 	ldw	r4,4(r2)
 181b530:	e0bffc0b 	ldhu	r2,-16(fp)
 181b534:	e0fffe17 	ldw	r3,-8(fp)
 181b538:	1885883a 	add	r2,r3,r2
 181b53c:	e0fffb0b 	ldhu	r3,-20(fp)
 181b540:	180d883a 	mov	r6,r3
 181b544:	100b883a 	mov	r5,r2
 181b548:	180608c0 	call	180608c <memcpy>
    total_copy_len -= buf_copy_len;
 181b54c:	e0fffb8b 	ldhu	r3,-18(fp)
 181b550:	e0bffb0b 	ldhu	r2,-20(fp)
 181b554:	1885c83a 	sub	r2,r3,r2
 181b558:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
 181b55c:	e0fffc0b 	ldhu	r3,-16(fp)
 181b560:	e0bffb0b 	ldhu	r2,-20(fp)
 181b564:	1885883a 	add	r2,r3,r2
 181b568:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 181b56c:	e0bffa17 	ldw	r2,-24(fp)
 181b570:	10800017 	ldw	r2,0(r2)
 181b574:	e0bffa15 	stw	r2,-24(fp)
 181b578:	e0bffb8b 	ldhu	r2,-18(fp)
 181b57c:	103fe01e 	bne	r2,zero,181b500 <__ram_exceptions_end+0xff80b0bc>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 181b580:	0005883a 	mov	r2,zero
}
 181b584:	e037883a 	mov	sp,fp
 181b588:	dfc00117 	ldw	ra,4(sp)
 181b58c:	df000017 	ldw	fp,0(sp)
 181b590:	dec00204 	addi	sp,sp,8
 181b594:	f800283a 	ret

0181b598 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 181b598:	defffa04 	addi	sp,sp,-24
 181b59c:	dfc00515 	stw	ra,20(sp)
 181b5a0:	df000415 	stw	fp,16(sp)
 181b5a4:	df000404 	addi	fp,sp,16
 181b5a8:	e13ffe15 	stw	r4,-8(fp)
 181b5ac:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 181b5b0:	e0bffe17 	ldw	r2,-8(fp)
 181b5b4:	10800017 	ldw	r2,0(r2)
 181b5b8:	1000021e 	bne	r2,zero,181b5c4 <pbuf_coalesce+0x2c>
    return p;
 181b5bc:	e0bffe17 	ldw	r2,-8(fp)
 181b5c0:	00001306 	br	181b610 <pbuf_coalesce+0x78>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 181b5c4:	e0bffe17 	ldw	r2,-8(fp)
 181b5c8:	1080020b 	ldhu	r2,8(r2)
 181b5cc:	10bfffcc 	andi	r2,r2,65535
 181b5d0:	000d883a 	mov	r6,zero
 181b5d4:	100b883a 	mov	r5,r2
 181b5d8:	e13fff17 	ldw	r4,-4(fp)
 181b5dc:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181b5e0:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
 181b5e4:	e0bffc17 	ldw	r2,-16(fp)
 181b5e8:	1000021e 	bne	r2,zero,181b5f4 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
 181b5ec:	e0bffe17 	ldw	r2,-8(fp)
 181b5f0:	00000706 	br	181b610 <pbuf_coalesce+0x78>
  }
  err = pbuf_copy(q, p);
 181b5f4:	e17ffe17 	ldw	r5,-8(fp)
 181b5f8:	e13ffc17 	ldw	r4,-16(fp)
 181b5fc:	181b04c0 	call	181b04c <pbuf_copy>
 181b600:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
 181b604:	e13ffe17 	ldw	r4,-8(fp)
 181b608:	181aca40 	call	181aca4 <pbuf_free>
  return q;
 181b60c:	e0bffc17 	ldw	r2,-16(fp)
}
 181b610:	e037883a 	mov	sp,fp
 181b614:	dfc00117 	ldw	ra,4(sp)
 181b618:	df000017 	ldw	fp,0(sp)
 181b61c:	dec00204 	addi	sp,sp,8
 181b620:	f800283a 	ret

0181b624 <pbuf_fill_chksum>:
 *         within the (first) pbuf (no pbuf queues!)
 */
err_t
pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
                 u16_t len, u16_t *chksum)
{
 181b624:	defff704 	addi	sp,sp,-36
 181b628:	dfc00815 	stw	ra,32(sp)
 181b62c:	df000715 	stw	fp,28(sp)
 181b630:	df000704 	addi	fp,sp,28
 181b634:	e13ffc15 	stw	r4,-16(fp)
 181b638:	2807883a 	mov	r3,r5
 181b63c:	e1bffe15 	stw	r6,-8(fp)
 181b640:	3805883a 	mov	r2,r7
 181b644:	e0fffd0d 	sth	r3,-12(fp)
 181b648:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("dataptr != NULL", dataptr != NULL);
  LWIP_ASSERT("chksum != NULL", chksum != NULL);
  LWIP_ASSERT("len != 0", len != 0);

  if ((start_offset >= p->len) || (start_offset + len > p->len)) {
 181b64c:	e0bffc17 	ldw	r2,-16(fp)
 181b650:	1080028b 	ldhu	r2,10(r2)
 181b654:	10bfffcc 	andi	r2,r2,65535
 181b658:	e0fffd0b 	ldhu	r3,-12(fp)
 181b65c:	1880072e 	bgeu	r3,r2,181b67c <pbuf_fill_chksum+0x58>
 181b660:	e0fffd0b 	ldhu	r3,-12(fp)
 181b664:	e0bfff0b 	ldhu	r2,-4(fp)
 181b668:	1885883a 	add	r2,r3,r2
 181b66c:	e0fffc17 	ldw	r3,-16(fp)
 181b670:	18c0028b 	ldhu	r3,10(r3)
 181b674:	18ffffcc 	andi	r3,r3,65535
 181b678:	1880020e 	bge	r3,r2,181b684 <pbuf_fill_chksum+0x60>
    return ERR_ARG;
 181b67c:	00bffc84 	movi	r2,-14
 181b680:	00002606 	br	181b71c <pbuf_fill_chksum+0xf8>
  }

  dst_ptr = ((char*)p->payload) + start_offset;
 181b684:	e0bffc17 	ldw	r2,-16(fp)
 181b688:	10c00117 	ldw	r3,4(r2)
 181b68c:	e0bffd0b 	ldhu	r2,-12(fp)
 181b690:	1885883a 	add	r2,r3,r2
 181b694:	e0bffa15 	stw	r2,-24(fp)
  copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);
 181b698:	e0bfff0b 	ldhu	r2,-4(fp)
 181b69c:	100d883a 	mov	r6,r2
 181b6a0:	e17ffe17 	ldw	r5,-8(fp)
 181b6a4:	e13ffa17 	ldw	r4,-24(fp)
 181b6a8:	18321e80 	call	18321e8 <lwip_chksum_copy>
 181b6ac:	e0bff90d 	sth	r2,-28(fp)
  if ((start_offset & 1) != 0) {
 181b6b0:	e0bffd0b 	ldhu	r2,-12(fp)
 181b6b4:	1080004c 	andi	r2,r2,1
 181b6b8:	10000726 	beq	r2,zero,181b6d8 <pbuf_fill_chksum+0xb4>
    copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);
 181b6bc:	e0bff90b 	ldhu	r2,-28(fp)
 181b6c0:	1004d23a 	srli	r2,r2,8
 181b6c4:	1007883a 	mov	r3,r2
 181b6c8:	e0bff90b 	ldhu	r2,-28(fp)
 181b6cc:	1004923a 	slli	r2,r2,8
 181b6d0:	1884b03a 	or	r2,r3,r2
 181b6d4:	e0bff90d 	sth	r2,-28(fp)
  }
  acc = *chksum;
 181b6d8:	e0800217 	ldw	r2,8(fp)
 181b6dc:	1080000b 	ldhu	r2,0(r2)
 181b6e0:	10bfffcc 	andi	r2,r2,65535
 181b6e4:	e0bffb15 	stw	r2,-20(fp)
  acc += copy_chksum;
 181b6e8:	e0bff90b 	ldhu	r2,-28(fp)
 181b6ec:	e0fffb17 	ldw	r3,-20(fp)
 181b6f0:	1885883a 	add	r2,r3,r2
 181b6f4:	e0bffb15 	stw	r2,-20(fp)
  *chksum = FOLD_U32T(acc);
 181b6f8:	e0bffb17 	ldw	r2,-20(fp)
 181b6fc:	1004d43a 	srli	r2,r2,16
 181b700:	1007883a 	mov	r3,r2
 181b704:	e0bffb17 	ldw	r2,-20(fp)
 181b708:	1885883a 	add	r2,r3,r2
 181b70c:	1007883a 	mov	r3,r2
 181b710:	e0800217 	ldw	r2,8(fp)
 181b714:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 181b718:	0005883a 	mov	r2,zero
}
 181b71c:	e037883a 	mov	sp,fp
 181b720:	dfc00117 	ldw	ra,4(sp)
 181b724:	df000017 	ldw	fp,0(sp)
 181b728:	dec00204 	addi	sp,sp,8
 181b72c:	f800283a 	ret

0181b730 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(struct pbuf* p, u16_t offset)
{
 181b730:	defffb04 	addi	sp,sp,-20
 181b734:	df000415 	stw	fp,16(sp)
 181b738:	df000404 	addi	fp,sp,16
 181b73c:	e13ffe15 	stw	r4,-8(fp)
 181b740:	2805883a 	mov	r2,r5
 181b744:	e0bfff0d 	sth	r2,-4(fp)
  u16_t copy_from = offset;
 181b748:	e0bfff0b 	ldhu	r2,-4(fp)
 181b74c:	e0bffc0d 	sth	r2,-16(fp)
  struct pbuf* q = p;
 181b750:	e0bffe17 	ldw	r2,-8(fp)
 181b754:	e0bffd15 	stw	r2,-12(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 181b758:	00000806 	br	181b77c <pbuf_get_at+0x4c>
    copy_from -= q->len;
 181b75c:	e0bffd17 	ldw	r2,-12(fp)
 181b760:	1080028b 	ldhu	r2,10(r2)
 181b764:	e0fffc0b 	ldhu	r3,-16(fp)
 181b768:	1885c83a 	sub	r2,r3,r2
 181b76c:	e0bffc0d 	sth	r2,-16(fp)
    q = q->next;
 181b770:	e0bffd17 	ldw	r2,-12(fp)
 181b774:	10800017 	ldw	r2,0(r2)
 181b778:	e0bffd15 	stw	r2,-12(fp)
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 181b77c:	e0bffd17 	ldw	r2,-12(fp)
 181b780:	10000526 	beq	r2,zero,181b798 <pbuf_get_at+0x68>
 181b784:	e0bffd17 	ldw	r2,-12(fp)
 181b788:	1080028b 	ldhu	r2,10(r2)
 181b78c:	10bfffcc 	andi	r2,r2,65535
 181b790:	e0fffc0b 	ldhu	r3,-16(fp)
 181b794:	18bff12e 	bgeu	r3,r2,181b75c <__ram_exceptions_end+0xff80b318>
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
 181b798:	e0bffd17 	ldw	r2,-12(fp)
 181b79c:	10000b26 	beq	r2,zero,181b7cc <pbuf_get_at+0x9c>
 181b7a0:	e0bffd17 	ldw	r2,-12(fp)
 181b7a4:	1080028b 	ldhu	r2,10(r2)
 181b7a8:	10bfffcc 	andi	r2,r2,65535
 181b7ac:	e0fffc0b 	ldhu	r3,-16(fp)
 181b7b0:	1880062e 	bgeu	r3,r2,181b7cc <pbuf_get_at+0x9c>
    return ((u8_t*)q->payload)[copy_from];
 181b7b4:	e0bffd17 	ldw	r2,-12(fp)
 181b7b8:	10c00117 	ldw	r3,4(r2)
 181b7bc:	e0bffc0b 	ldhu	r2,-16(fp)
 181b7c0:	1885883a 	add	r2,r3,r2
 181b7c4:	10800003 	ldbu	r2,0(r2)
 181b7c8:	00000106 	br	181b7d0 <pbuf_get_at+0xa0>
  }
  return 0;
 181b7cc:	0005883a 	mov	r2,zero
}
 181b7d0:	e037883a 	mov	sp,fp
 181b7d4:	df000017 	ldw	fp,0(sp)
 181b7d8:	dec00104 	addi	sp,sp,4
 181b7dc:	f800283a 	ret

0181b7e0 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
 181b7e0:	defff704 	addi	sp,sp,-36
 181b7e4:	dfc00815 	stw	ra,32(sp)
 181b7e8:	df000715 	stw	fp,28(sp)
 181b7ec:	df000704 	addi	fp,sp,28
 181b7f0:	e13ffc15 	stw	r4,-16(fp)
 181b7f4:	2807883a 	mov	r3,r5
 181b7f8:	e1bffe15 	stw	r6,-8(fp)
 181b7fc:	3805883a 	mov	r2,r7
 181b800:	e0fffd0d 	sth	r3,-12(fp)
 181b804:	e0bfff0d 	sth	r2,-4(fp)
  u16_t start = offset;
 181b808:	e0bffd0b 	ldhu	r2,-12(fp)
 181b80c:	e0bff90d 	sth	r2,-28(fp)
  struct pbuf* q = p;
 181b810:	e0bffc17 	ldw	r2,-16(fp)
 181b814:	e0bffa15 	stw	r2,-24(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 181b818:	00000806 	br	181b83c <pbuf_memcmp+0x5c>
    start -= q->len;
 181b81c:	e0bffa17 	ldw	r2,-24(fp)
 181b820:	1080028b 	ldhu	r2,10(r2)
 181b824:	e0fff90b 	ldhu	r3,-28(fp)
 181b828:	1885c83a 	sub	r2,r3,r2
 181b82c:	e0bff90d 	sth	r2,-28(fp)
    q = q->next;
 181b830:	e0bffa17 	ldw	r2,-24(fp)
 181b834:	10800017 	ldw	r2,0(r2)
 181b838:	e0bffa15 	stw	r2,-24(fp)
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 181b83c:	e0bffa17 	ldw	r2,-24(fp)
 181b840:	10000526 	beq	r2,zero,181b858 <pbuf_memcmp+0x78>
 181b844:	e0bffa17 	ldw	r2,-24(fp)
 181b848:	1080028b 	ldhu	r2,10(r2)
 181b84c:	10bfffcc 	andi	r2,r2,65535
 181b850:	e0fff90b 	ldhu	r3,-28(fp)
 181b854:	18bff12e 	bgeu	r3,r2,181b81c <__ram_exceptions_end+0xff80b3d8>
    start -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
 181b858:	e0bffa17 	ldw	r2,-24(fp)
 181b85c:	10002226 	beq	r2,zero,181b8e8 <pbuf_memcmp+0x108>
 181b860:	e0bffa17 	ldw	r2,-24(fp)
 181b864:	1080028b 	ldhu	r2,10(r2)
 181b868:	10bfffcc 	andi	r2,r2,65535
 181b86c:	e0fff90b 	ldhu	r3,-28(fp)
 181b870:	18801d2e 	bgeu	r3,r2,181b8e8 <pbuf_memcmp+0x108>
    u16_t i;
    for(i = 0; i < n; i++) {
 181b874:	e03ffb0d 	sth	zero,-20(fp)
 181b878:	00001606 	br	181b8d4 <pbuf_memcmp+0xf4>
      u8_t a = pbuf_get_at(q, start + i);
 181b87c:	e0fff90b 	ldhu	r3,-28(fp)
 181b880:	e0bffb0b 	ldhu	r2,-20(fp)
 181b884:	1885883a 	add	r2,r3,r2
 181b888:	10bfffcc 	andi	r2,r2,65535
 181b88c:	100b883a 	mov	r5,r2
 181b890:	e13ffa17 	ldw	r4,-24(fp)
 181b894:	181b7300 	call	181b730 <pbuf_get_at>
 181b898:	e0bffb85 	stb	r2,-18(fp)
      u8_t b = ((u8_t*)s2)[i];
 181b89c:	e0bffb0b 	ldhu	r2,-20(fp)
 181b8a0:	e0fffe17 	ldw	r3,-8(fp)
 181b8a4:	1885883a 	add	r2,r3,r2
 181b8a8:	10800003 	ldbu	r2,0(r2)
 181b8ac:	e0bffbc5 	stb	r2,-17(fp)
      if (a != b) {
 181b8b0:	e0fffb83 	ldbu	r3,-18(fp)
 181b8b4:	e0bffbc3 	ldbu	r2,-17(fp)
 181b8b8:	18800326 	beq	r3,r2,181b8c8 <pbuf_memcmp+0xe8>
        return i+1;
 181b8bc:	e0bffb0b 	ldhu	r2,-20(fp)
 181b8c0:	10800044 	addi	r2,r2,1
 181b8c4:	00000906 	br	181b8ec <pbuf_memcmp+0x10c>
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
 181b8c8:	e0bffb0b 	ldhu	r2,-20(fp)
 181b8cc:	10800044 	addi	r2,r2,1
 181b8d0:	e0bffb0d 	sth	r2,-20(fp)
 181b8d4:	e0fffb0b 	ldhu	r3,-20(fp)
 181b8d8:	e0bfff0b 	ldhu	r2,-4(fp)
 181b8dc:	18bfe736 	bltu	r3,r2,181b87c <__ram_exceptions_end+0xff80b438>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
 181b8e0:	0005883a 	mov	r2,zero
 181b8e4:	00000106 	br	181b8ec <pbuf_memcmp+0x10c>
  }
  return 0xffff;
 181b8e8:	00bfffc4 	movi	r2,-1
}
 181b8ec:	e037883a 	mov	sp,fp
 181b8f0:	dfc00117 	ldw	ra,4(sp)
 181b8f4:	df000017 	ldw	fp,0(sp)
 181b8f8:	dec00204 	addi	sp,sp,8
 181b8fc:	f800283a 	ret

0181b900 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
 181b900:	defff804 	addi	sp,sp,-32
 181b904:	dfc00715 	stw	ra,28(sp)
 181b908:	df000615 	stw	fp,24(sp)
 181b90c:	df000604 	addi	fp,sp,24
 181b910:	e13ffc15 	stw	r4,-16(fp)
 181b914:	e17ffd15 	stw	r5,-12(fp)
 181b918:	3007883a 	mov	r3,r6
 181b91c:	3805883a 	mov	r2,r7
 181b920:	e0fffe0d 	sth	r3,-8(fp)
 181b924:	e0bfff0d 	sth	r2,-4(fp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
 181b928:	e0bffc17 	ldw	r2,-16(fp)
 181b92c:	10c0020b 	ldhu	r3,8(r2)
 181b930:	e0bffe0b 	ldhu	r2,-8(fp)
 181b934:	1885c83a 	sub	r2,r3,r2
 181b938:	e0bffa8d 	sth	r2,-22(fp)
  if (p->tot_len >= mem_len + start_offset) {
 181b93c:	e0bffc17 	ldw	r2,-16(fp)
 181b940:	1080020b 	ldhu	r2,8(r2)
 181b944:	10ffffcc 	andi	r3,r2,65535
 181b948:	e13ffe0b 	ldhu	r4,-8(fp)
 181b94c:	e0bfff0b 	ldhu	r2,-4(fp)
 181b950:	2085883a 	add	r2,r4,r2
 181b954:	18801616 	blt	r3,r2,181b9b0 <pbuf_memfind+0xb0>
    for(i = start_offset; i <= max; ) {
 181b958:	e0bfff0b 	ldhu	r2,-4(fp)
 181b95c:	e0bffa0d 	sth	r2,-24(fp)
 181b960:	00001006 	br	181b9a4 <pbuf_memfind+0xa4>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 181b964:	e0bffa0b 	ldhu	r2,-24(fp)
 181b968:	e0fffe0b 	ldhu	r3,-8(fp)
 181b96c:	180f883a 	mov	r7,r3
 181b970:	e1bffd17 	ldw	r6,-12(fp)
 181b974:	100b883a 	mov	r5,r2
 181b978:	e13ffc17 	ldw	r4,-16(fp)
 181b97c:	181b7e00 	call	181b7e0 <pbuf_memcmp>
 181b980:	e0bffb0d 	sth	r2,-20(fp)
      if (plus == 0) {
 181b984:	e0bffb0b 	ldhu	r2,-20(fp)
 181b988:	1000021e 	bne	r2,zero,181b994 <pbuf_memfind+0x94>
        return i;
 181b98c:	e0bffa0b 	ldhu	r2,-24(fp)
 181b990:	00000806 	br	181b9b4 <pbuf_memfind+0xb4>
      } else {
        i += plus;
 181b994:	e0fffa0b 	ldhu	r3,-24(fp)
 181b998:	e0bffb0b 	ldhu	r2,-20(fp)
 181b99c:	1885883a 	add	r2,r3,r2
 181b9a0:	e0bffa0d 	sth	r2,-24(fp)
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
 181b9a4:	e0bffa0b 	ldhu	r2,-24(fp)
 181b9a8:	e0fffa8b 	ldhu	r3,-22(fp)
 181b9ac:	18bfed2e 	bgeu	r3,r2,181b964 <__ram_exceptions_end+0xff80b520>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
 181b9b0:	00bfffc4 	movi	r2,-1
}
 181b9b4:	e037883a 	mov	sp,fp
 181b9b8:	dfc00117 	ldw	ra,4(sp)
 181b9bc:	df000017 	ldw	fp,0(sp)
 181b9c0:	dec00204 	addi	sp,sp,8
 181b9c4:	f800283a 	ret

0181b9c8 <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
 181b9c8:	defffb04 	addi	sp,sp,-20
 181b9cc:	dfc00415 	stw	ra,16(sp)
 181b9d0:	df000315 	stw	fp,12(sp)
 181b9d4:	df000304 	addi	fp,sp,12
 181b9d8:	e13ffe15 	stw	r4,-8(fp)
 181b9dc:	e17fff15 	stw	r5,-4(fp)
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 181b9e0:	e0bfff17 	ldw	r2,-4(fp)
 181b9e4:	10000b26 	beq	r2,zero,181ba14 <pbuf_strstr+0x4c>
 181b9e8:	e0bfff17 	ldw	r2,-4(fp)
 181b9ec:	10800003 	ldbu	r2,0(r2)
 181b9f0:	10803fcc 	andi	r2,r2,255
 181b9f4:	1080201c 	xori	r2,r2,128
 181b9f8:	10bfe004 	addi	r2,r2,-128
 181b9fc:	10000526 	beq	r2,zero,181ba14 <pbuf_strstr+0x4c>
 181ba00:	e0bffe17 	ldw	r2,-8(fp)
 181ba04:	1080020b 	ldhu	r2,8(r2)
 181ba08:	10ffffcc 	andi	r3,r2,65535
 181ba0c:	00bfffd4 	movui	r2,65535
 181ba10:	1880021e 	bne	r3,r2,181ba1c <pbuf_strstr+0x54>
    return 0xFFFF;
 181ba14:	00bfffc4 	movi	r2,-1
 181ba18:	00000f06 	br	181ba58 <pbuf_strstr+0x90>
  }
  substr_len = strlen(substr);
 181ba1c:	e13fff17 	ldw	r4,-4(fp)
 181ba20:	18075d80 	call	18075d8 <strlen>
 181ba24:	e0bffd15 	stw	r2,-12(fp)
  if (substr_len >= 0xFFFF) {
 181ba28:	e0bffd17 	ldw	r2,-12(fp)
 181ba2c:	10bffff0 	cmpltui	r2,r2,65535
 181ba30:	1000021e 	bne	r2,zero,181ba3c <pbuf_strstr+0x74>
    return 0xFFFF;
 181ba34:	00bfffc4 	movi	r2,-1
 181ba38:	00000706 	br	181ba58 <pbuf_strstr+0x90>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 181ba3c:	e0bffd17 	ldw	r2,-12(fp)
 181ba40:	10bfffcc 	andi	r2,r2,65535
 181ba44:	000f883a 	mov	r7,zero
 181ba48:	100d883a 	mov	r6,r2
 181ba4c:	e17fff17 	ldw	r5,-4(fp)
 181ba50:	e13ffe17 	ldw	r4,-8(fp)
 181ba54:	181b9000 	call	181b900 <pbuf_memfind>
}
 181ba58:	e037883a 	mov	sp,fp
 181ba5c:	dfc00117 	ldw	ra,4(sp)
 181ba60:	df000017 	ldw	fp,0(sp)
 181ba64:	dec00204 	addi	sp,sp,8
 181ba68:	f800283a 	ret

0181ba6c <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 181ba6c:	deffff04 	addi	sp,sp,-4
 181ba70:	df000015 	stw	fp,0(sp)
 181ba74:	d839883a 	mov	fp,sp
#endif /* MEMP_STATS */
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
 181ba78:	0001883a 	nop
 181ba7c:	e037883a 	mov	sp,fp
 181ba80:	df000017 	ldw	fp,0(sp)
 181ba84:	dec00104 	addi	sp,sp,4
 181ba88:	f800283a 	ret

0181ba8c <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 181ba8c:	deffff04 	addi	sp,sp,-4
 181ba90:	df000015 	stw	fp,0(sp)
 181ba94:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
 181ba98:	0001883a 	nop
 181ba9c:	e037883a 	mov	sp,fp
 181baa0:	df000017 	ldw	fp,0(sp)
 181baa4:	dec00104 	addi	sp,sp,4
 181baa8:	f800283a 	ret

0181baac <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 181baac:	defffe04 	addi	sp,sp,-8
 181bab0:	dfc00115 	stw	ra,4(sp)
 181bab4:	df000015 	stw	fp,0(sp)
 181bab8:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 181babc:	181d2d00 	call	181d2d0 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 181bac0:	d0a7f603 	ldbu	r2,-24616(gp)
 181bac4:	10800044 	addi	r2,r2,1
 181bac8:	d0a7f605 	stb	r2,-24616(gp)
 181bacc:	d0a7f603 	ldbu	r2,-24616(gp)
 181bad0:	10803fcc 	andi	r2,r2,255
 181bad4:	1080004c 	andi	r2,r2,1
 181bad8:	10000126 	beq	r2,zero,181bae0 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 181badc:	181cb980 	call	181cb98 <tcp_slowtmr>
  }
}
 181bae0:	0001883a 	nop
 181bae4:	e037883a 	mov	sp,fp
 181bae8:	dfc00117 	ldw	ra,4(sp)
 181baec:	df000017 	ldw	fp,0(sp)
 181baf0:	dec00204 	addi	sp,sp,8
 181baf4:	f800283a 	ret

0181baf8 <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 181baf8:	defff904 	addi	sp,sp,-28
 181bafc:	dfc00615 	stw	ra,24(sp)
 181bb00:	df000515 	stw	fp,20(sp)
 181bb04:	df000504 	addi	fp,sp,20
 181bb08:	e13ffe15 	stw	r4,-8(fp)
 181bb0c:	2805883a 	mov	r2,r5
 181bb10:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 181bb14:	e0bfff03 	ldbu	r2,-4(fp)
 181bb18:	10005126 	beq	r2,zero,181bc60 <tcp_close_shutdown+0x168>
 181bb1c:	e0bffe17 	ldw	r2,-8(fp)
 181bb20:	10800617 	ldw	r2,24(r2)
 181bb24:	10800120 	cmpeqi	r2,r2,4
 181bb28:	1000041e 	bne	r2,zero,181bb3c <tcp_close_shutdown+0x44>
 181bb2c:	e0bffe17 	ldw	r2,-8(fp)
 181bb30:	10800617 	ldw	r2,24(r2)
 181bb34:	108001d8 	cmpnei	r2,r2,7
 181bb38:	1000491e 	bne	r2,zero,181bc60 <tcp_close_shutdown+0x168>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 181bb3c:	e0bffe17 	ldw	r2,-8(fp)
 181bb40:	10801f17 	ldw	r2,124(r2)
 181bb44:	1000051e 	bne	r2,zero,181bb5c <tcp_close_shutdown+0x64>
 181bb48:	e0bffe17 	ldw	r2,-8(fp)
 181bb4c:	10800c0b 	ldhu	r2,48(r2)
 181bb50:	10bfffcc 	andi	r2,r2,65535
 181bb54:	10880020 	cmpeqi	r2,r2,8192
 181bb58:	1000411e 	bne	r2,zero,181bc60 <tcp_close_shutdown+0x168>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181bb5c:	e0bffe17 	ldw	r2,-8(fp)
 181bb60:	11001517 	ldw	r4,84(r2)
 181bb64:	e0bffe17 	ldw	r2,-8(fp)
 181bb68:	11400b17 	ldw	r5,44(r2)
 181bb6c:	e1bffe17 	ldw	r6,-8(fp)
 181bb70:	e0bffe17 	ldw	r2,-8(fp)
 181bb74:	11c00104 	addi	r7,r2,4
        pcb->local_port, pcb->remote_port);
 181bb78:	e0bffe17 	ldw	r2,-8(fp)
 181bb7c:	1080078b 	ldhu	r2,30(r2)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181bb80:	10bfffcc 	andi	r2,r2,65535
        pcb->local_port, pcb->remote_port);
 181bb84:	e0fffe17 	ldw	r3,-8(fp)
 181bb88:	18c0080b 	ldhu	r3,32(r3)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181bb8c:	18ffffcc 	andi	r3,r3,65535
 181bb90:	d8c00115 	stw	r3,4(sp)
 181bb94:	d8800015 	stw	r2,0(sp)
 181bb98:	18209680 	call	1820968 <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 181bb9c:	e13ffe17 	ldw	r4,-8(fp)
 181bba0:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 181bba4:	d0e7f717 	ldw	r3,-24612(gp)
 181bba8:	e0bffe17 	ldw	r2,-8(fp)
 181bbac:	1880041e 	bne	r3,r2,181bbc0 <tcp_close_shutdown+0xc8>
 181bbb0:	d0a7f717 	ldw	r2,-24612(gp)
 181bbb4:	10800317 	ldw	r2,12(r2)
 181bbb8:	d0a7f715 	stw	r2,-24612(gp)
 181bbbc:	00001106 	br	181bc04 <tcp_close_shutdown+0x10c>
 181bbc0:	d0a7f717 	ldw	r2,-24612(gp)
 181bbc4:	d0a7fa15 	stw	r2,-24600(gp)
 181bbc8:	00000c06 	br	181bbfc <tcp_close_shutdown+0x104>
 181bbcc:	d0a7fa17 	ldw	r2,-24600(gp)
 181bbd0:	10c00317 	ldw	r3,12(r2)
 181bbd4:	e0bffe17 	ldw	r2,-8(fp)
 181bbd8:	1880051e 	bne	r3,r2,181bbf0 <tcp_close_shutdown+0xf8>
 181bbdc:	d0a7fa17 	ldw	r2,-24600(gp)
 181bbe0:	e0fffe17 	ldw	r3,-8(fp)
 181bbe4:	18c00317 	ldw	r3,12(r3)
 181bbe8:	10c00315 	stw	r3,12(r2)
 181bbec:	00000506 	br	181bc04 <tcp_close_shutdown+0x10c>
 181bbf0:	d0a7fa17 	ldw	r2,-24600(gp)
 181bbf4:	10800317 	ldw	r2,12(r2)
 181bbf8:	d0a7fa15 	stw	r2,-24600(gp)
 181bbfc:	d0a7fa17 	ldw	r2,-24600(gp)
 181bc00:	103ff21e 	bne	r2,zero,181bbcc <__ram_exceptions_end+0xff80b788>
 181bc04:	e0bffe17 	ldw	r2,-8(fp)
 181bc08:	10000315 	stw	zero,12(r2)
 181bc0c:	00800044 	movi	r2,1
 181bc10:	d0a7f685 	stb	r2,-24614(gp)
      if (pcb->state == ESTABLISHED) {
 181bc14:	e0bffe17 	ldw	r2,-8(fp)
 181bc18:	10800617 	ldw	r2,24(r2)
 181bc1c:	10800118 	cmpnei	r2,r2,4
 181bc20:	10000a1e 	bne	r2,zero,181bc4c <tcp_close_shutdown+0x154>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 181bc24:	e0bffe17 	ldw	r2,-8(fp)
 181bc28:	00c00284 	movi	r3,10
 181bc2c:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 181bc30:	d0e7fc17 	ldw	r3,-24592(gp)
 181bc34:	e0bffe17 	ldw	r2,-8(fp)
 181bc38:	10c00315 	stw	r3,12(r2)
 181bc3c:	e0bffe17 	ldw	r2,-8(fp)
 181bc40:	d0a7fc15 	stw	r2,-24592(gp)
 181bc44:	18216900 	call	1821690 <tcp_timer_needed>
 181bc48:	00000306 	br	181bc58 <tcp_close_shutdown+0x160>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 181bc4c:	e17ffe17 	ldw	r5,-8(fp)
 181bc50:	01000084 	movi	r4,2
 181bc54:	1834b240 	call	1834b24 <memp_free>
      }
      return ERR_OK;
 181bc58:	0005883a 	mov	r2,zero
 181bc5c:	00007406 	br	181be30 <tcp_close_shutdown+0x338>
    }
  }

  switch (pcb->state) {
 181bc60:	e0bffe17 	ldw	r2,-8(fp)
 181bc64:	10800617 	ldw	r2,24(r2)
 181bc68:	10c00228 	cmpgeui	r3,r2,8
 181bc6c:	1800611e 	bne	r3,zero,181bdf4 <tcp_close_shutdown+0x2fc>
 181bc70:	100690ba 	slli	r3,r2,2
 181bc74:	008060b4 	movhi	r2,386
 181bc78:	10af2204 	addi	r2,r2,-17272
 181bc7c:	1885883a 	add	r2,r3,r2
 181bc80:	10800017 	ldw	r2,0(r2)
 181bc84:	1000683a 	jmp	r2
 181bc88:	0181bca8 	cmpgeui	r6,zero,1778
 181bc8c:	0181bd38 	rdprs	r6,zero,1780
 181bc90:	0181bd5c 	xori	r6,zero,1781
 181bc94:	0181bd88 	cmpgei	r6,zero,1782
 181bc98:	0181bdac 	andhi	r6,zero,1782
 181bc9c:	0181bdf4 	movhi	r6,1783
 181bca0:	0181bdf4 	movhi	r6,1783
 181bca4:	0181bdd0 	cmplti	r6,zero,1783
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
 181bca8:	e03ffd05 	stb	zero,-12(fp)
    if (pcb->local_port != 0) {
 181bcac:	e0bffe17 	ldw	r2,-8(fp)
 181bcb0:	1080078b 	ldhu	r2,30(r2)
 181bcb4:	10bfffcc 	andi	r2,r2,65535
 181bcb8:	10001a26 	beq	r2,zero,181bd24 <tcp_close_shutdown+0x22c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 181bcbc:	d0e7fb17 	ldw	r3,-24596(gp)
 181bcc0:	e0bffe17 	ldw	r2,-8(fp)
 181bcc4:	1880041e 	bne	r3,r2,181bcd8 <tcp_close_shutdown+0x1e0>
 181bcc8:	d0a7fb17 	ldw	r2,-24596(gp)
 181bccc:	10800317 	ldw	r2,12(r2)
 181bcd0:	d0a7fb15 	stw	r2,-24596(gp)
 181bcd4:	00001106 	br	181bd1c <tcp_close_shutdown+0x224>
 181bcd8:	d0a7fb17 	ldw	r2,-24596(gp)
 181bcdc:	d0a7fa15 	stw	r2,-24600(gp)
 181bce0:	00000c06 	br	181bd14 <tcp_close_shutdown+0x21c>
 181bce4:	d0a7fa17 	ldw	r2,-24600(gp)
 181bce8:	10c00317 	ldw	r3,12(r2)
 181bcec:	e0bffe17 	ldw	r2,-8(fp)
 181bcf0:	1880051e 	bne	r3,r2,181bd08 <tcp_close_shutdown+0x210>
 181bcf4:	d0a7fa17 	ldw	r2,-24600(gp)
 181bcf8:	e0fffe17 	ldw	r3,-8(fp)
 181bcfc:	18c00317 	ldw	r3,12(r3)
 181bd00:	10c00315 	stw	r3,12(r2)
 181bd04:	00000506 	br	181bd1c <tcp_close_shutdown+0x224>
 181bd08:	d0a7fa17 	ldw	r2,-24600(gp)
 181bd0c:	10800317 	ldw	r2,12(r2)
 181bd10:	d0a7fa15 	stw	r2,-24600(gp)
 181bd14:	d0a7fa17 	ldw	r2,-24600(gp)
 181bd18:	103ff21e 	bne	r2,zero,181bce4 <__ram_exceptions_end+0xff80b8a0>
 181bd1c:	e0bffe17 	ldw	r2,-8(fp)
 181bd20:	10000315 	stw	zero,12(r2)
    }
    memp_free(MEMP_TCP_PCB, pcb);
 181bd24:	e17ffe17 	ldw	r5,-8(fp)
 181bd28:	01000084 	movi	r4,2
 181bd2c:	1834b240 	call	1834b24 <memp_free>
    pcb = NULL;
 181bd30:	e03ffe15 	stw	zero,-8(fp)
    break;
 181bd34:	00003706 	br	181be14 <tcp_close_shutdown+0x31c>
  case LISTEN:
    err = ERR_OK;
 181bd38:	e03ffd05 	stb	zero,-12(fp)
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 181bd3c:	e17ffe17 	ldw	r5,-8(fp)
 181bd40:	d127f904 	addi	r4,gp,-24604
 181bd44:	181dd380 	call	181dd38 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 181bd48:	e17ffe17 	ldw	r5,-8(fp)
 181bd4c:	010000c4 	movi	r4,3
 181bd50:	1834b240 	call	1834b24 <memp_free>
    pcb = NULL;
 181bd54:	e03ffe15 	stw	zero,-8(fp)
    break;
 181bd58:	00002e06 	br	181be14 <tcp_close_shutdown+0x31c>
  case SYN_SENT:
    err = ERR_OK;
 181bd5c:	e03ffd05 	stb	zero,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
 181bd60:	e17ffe17 	ldw	r5,-8(fp)
 181bd64:	d127f704 	addi	r4,gp,-24612
 181bd68:	181dd380 	call	181dd38 <tcp_pcb_remove>
 181bd6c:	00800044 	movi	r2,1
 181bd70:	d0a7f685 	stb	r2,-24614(gp)
    memp_free(MEMP_TCP_PCB, pcb);
 181bd74:	e17ffe17 	ldw	r5,-8(fp)
 181bd78:	01000084 	movi	r4,2
 181bd7c:	1834b240 	call	1834b24 <memp_free>
    pcb = NULL;
 181bd80:	e03ffe15 	stw	zero,-8(fp)
    snmp_inc_tcpattemptfails();
    break;
 181bd84:	00002306 	br	181be14 <tcp_close_shutdown+0x31c>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 181bd88:	e13ffe17 	ldw	r4,-8(fp)
 181bd8c:	181e3240 	call	181e324 <tcp_send_fin>
 181bd90:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 181bd94:	e0bffd07 	ldb	r2,-12(fp)
 181bd98:	1000191e 	bne	r2,zero,181be00 <tcp_close_shutdown+0x308>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 181bd9c:	e0bffe17 	ldw	r2,-8(fp)
 181bda0:	00c00144 	movi	r3,5
 181bda4:	10c00615 	stw	r3,24(r2)
    }
    break;
 181bda8:	00001506 	br	181be00 <tcp_close_shutdown+0x308>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
 181bdac:	e13ffe17 	ldw	r4,-8(fp)
 181bdb0:	181e3240 	call	181e324 <tcp_send_fin>
 181bdb4:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 181bdb8:	e0bffd07 	ldb	r2,-12(fp)
 181bdbc:	1000121e 	bne	r2,zero,181be08 <tcp_close_shutdown+0x310>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
 181bdc0:	e0bffe17 	ldw	r2,-8(fp)
 181bdc4:	00c00144 	movi	r3,5
 181bdc8:	10c00615 	stw	r3,24(r2)
    }
    break;
 181bdcc:	00000e06 	br	181be08 <tcp_close_shutdown+0x310>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 181bdd0:	e13ffe17 	ldw	r4,-8(fp)
 181bdd4:	181e3240 	call	181e324 <tcp_send_fin>
 181bdd8:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 181bddc:	e0bffd07 	ldb	r2,-12(fp)
 181bde0:	10000b1e 	bne	r2,zero,181be10 <tcp_close_shutdown+0x318>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 181bde4:	e0bffe17 	ldw	r2,-8(fp)
 181bde8:	00c00244 	movi	r3,9
 181bdec:	10c00615 	stw	r3,24(r2)
    }
    break;
 181bdf0:	00000706 	br	181be10 <tcp_close_shutdown+0x318>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
 181bdf4:	e03ffd05 	stb	zero,-12(fp)
    pcb = NULL;
 181bdf8:	e03ffe15 	stw	zero,-8(fp)
    break;
 181bdfc:	00000506 	br	181be14 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
 181be00:	0001883a 	nop
 181be04:	00000306 	br	181be14 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
 181be08:	0001883a 	nop
 181be0c:	00000106 	br	181be14 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
 181be10:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
 181be14:	e0bffe17 	ldw	r2,-8(fp)
 181be18:	10000426 	beq	r2,zero,181be2c <tcp_close_shutdown+0x334>
 181be1c:	e0bffd07 	ldb	r2,-12(fp)
 181be20:	1000021e 	bne	r2,zero,181be2c <tcp_close_shutdown+0x334>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 181be24:	e13ffe17 	ldw	r4,-8(fp)
 181be28:	181f8bc0 	call	181f8bc <tcp_output>
  }
  return err;
 181be2c:	e0bffd03 	ldbu	r2,-12(fp)
}
 181be30:	e037883a 	mov	sp,fp
 181be34:	dfc00117 	ldw	ra,4(sp)
 181be38:	df000017 	ldw	fp,0(sp)
 181be3c:	dec00204 	addi	sp,sp,8
 181be40:	f800283a 	ret

0181be44 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 181be44:	defffd04 	addi	sp,sp,-12
 181be48:	dfc00215 	stw	ra,8(sp)
 181be4c:	df000115 	stw	fp,4(sp)
 181be50:	df000104 	addi	fp,sp,4
 181be54:	e13fff15 	stw	r4,-4(fp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 181be58:	e0bfff17 	ldw	r2,-4(fp)
 181be5c:	10800617 	ldw	r2,24(r2)
 181be60:	10800060 	cmpeqi	r2,r2,1
 181be64:	1000061e 	bne	r2,zero,181be80 <tcp_close+0x3c>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 181be68:	e0bfff17 	ldw	r2,-4(fp)
 181be6c:	10800883 	ldbu	r2,34(r2)
 181be70:	10800414 	ori	r2,r2,16
 181be74:	1007883a 	mov	r3,r2
 181be78:	e0bfff17 	ldw	r2,-4(fp)
 181be7c:	10c00885 	stb	r3,34(r2)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 181be80:	01400044 	movi	r5,1
 181be84:	e13fff17 	ldw	r4,-4(fp)
 181be88:	181baf80 	call	181baf8 <tcp_close_shutdown>
}
 181be8c:	e037883a 	mov	sp,fp
 181be90:	dfc00117 	ldw	ra,4(sp)
 181be94:	df000017 	ldw	fp,0(sp)
 181be98:	dec00204 	addi	sp,sp,8
 181be9c:	f800283a 	ret

0181bea0 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 181bea0:	defffb04 	addi	sp,sp,-20
 181bea4:	dfc00415 	stw	ra,16(sp)
 181bea8:	df000315 	stw	fp,12(sp)
 181beac:	df000304 	addi	fp,sp,12
 181beb0:	e13ffd15 	stw	r4,-12(fp)
 181beb4:	e17ffe15 	stw	r5,-8(fp)
 181beb8:	e1bfff15 	stw	r6,-4(fp)
  if (pcb->state == LISTEN) {
 181bebc:	e0bffd17 	ldw	r2,-12(fp)
 181bec0:	10800617 	ldw	r2,24(r2)
 181bec4:	10800058 	cmpnei	r2,r2,1
 181bec8:	1000021e 	bne	r2,zero,181bed4 <tcp_shutdown+0x34>
    return ERR_CONN;
 181becc:	00bffcc4 	movi	r2,-13
 181bed0:	00002a06 	br	181bf7c <tcp_shutdown+0xdc>
  }
  if (shut_rx) {
 181bed4:	e0bffe17 	ldw	r2,-8(fp)
 181bed8:	10001526 	beq	r2,zero,181bf30 <tcp_shutdown+0x90>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 181bedc:	e0bffd17 	ldw	r2,-12(fp)
 181bee0:	10800883 	ldbu	r2,34(r2)
 181bee4:	10800414 	ori	r2,r2,16
 181bee8:	1007883a 	mov	r3,r2
 181beec:	e0bffd17 	ldw	r2,-12(fp)
 181bef0:	10c00885 	stb	r3,34(r2)
    if (shut_tx) {
 181bef4:	e0bfff17 	ldw	r2,-4(fp)
 181bef8:	10000426 	beq	r2,zero,181bf0c <tcp_shutdown+0x6c>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 181befc:	01400044 	movi	r5,1
 181bf00:	e13ffd17 	ldw	r4,-12(fp)
 181bf04:	181baf80 	call	181baf8 <tcp_close_shutdown>
 181bf08:	00001c06 	br	181bf7c <tcp_shutdown+0xdc>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
 181bf0c:	e0bffd17 	ldw	r2,-12(fp)
 181bf10:	10801f17 	ldw	r2,124(r2)
 181bf14:	10000626 	beq	r2,zero,181bf30 <tcp_shutdown+0x90>
      pbuf_free(pcb->refused_data);
 181bf18:	e0bffd17 	ldw	r2,-12(fp)
 181bf1c:	10801f17 	ldw	r2,124(r2)
 181bf20:	1009883a 	mov	r4,r2
 181bf24:	181aca40 	call	181aca4 <pbuf_free>
      pcb->refused_data = NULL;
 181bf28:	e0bffd17 	ldw	r2,-12(fp)
 181bf2c:	10001f15 	stw	zero,124(r2)
    }
  }
  if (shut_tx) {
 181bf30:	e0bfff17 	ldw	r2,-4(fp)
 181bf34:	10001026 	beq	r2,zero,181bf78 <tcp_shutdown+0xd8>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
 181bf38:	e0bffd17 	ldw	r2,-12(fp)
 181bf3c:	10800617 	ldw	r2,24(r2)
 181bf40:	10c000f0 	cmpltui	r3,r2,3
 181bf44:	18000a1e 	bne	r3,zero,181bf70 <tcp_shutdown+0xd0>
 181bf48:	10c00170 	cmpltui	r3,r2,5
 181bf4c:	1800021e 	bne	r3,zero,181bf58 <tcp_shutdown+0xb8>
 181bf50:	108001e0 	cmpeqi	r2,r2,7
 181bf54:	10000626 	beq	r2,zero,181bf70 <tcp_shutdown+0xd0>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
 181bf58:	e0bffe17 	ldw	r2,-8(fp)
 181bf5c:	10803fcc 	andi	r2,r2,255
 181bf60:	100b883a 	mov	r5,r2
 181bf64:	e13ffd17 	ldw	r4,-12(fp)
 181bf68:	181baf80 	call	181baf8 <tcp_close_shutdown>
 181bf6c:	00000306 	br	181bf7c <tcp_shutdown+0xdc>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
 181bf70:	00bffcc4 	movi	r2,-13
 181bf74:	00000106 	br	181bf7c <tcp_shutdown+0xdc>
    }
  }
  return ERR_OK;
 181bf78:	0005883a 	mov	r2,zero
}
 181bf7c:	e037883a 	mov	sp,fp
 181bf80:	dfc00117 	ldw	ra,4(sp)
 181bf84:	df000017 	ldw	fp,0(sp)
 181bf88:	dec00204 	addi	sp,sp,8
 181bf8c:	f800283a 	ret

0181bf90 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 181bf90:	defff604 	addi	sp,sp,-40
 181bf94:	dfc00915 	stw	ra,36(sp)
 181bf98:	df000815 	stw	fp,32(sp)
 181bf9c:	df000804 	addi	fp,sp,32
 181bfa0:	e13ffe15 	stw	r4,-8(fp)
 181bfa4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 181bfa8:	e0bffe17 	ldw	r2,-8(fp)
 181bfac:	10800617 	ldw	r2,24(r2)
 181bfb0:	10800298 	cmpnei	r2,r2,10
 181bfb4:	1000071e 	bne	r2,zero,181bfd4 <tcp_abandon+0x44>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 181bfb8:	e17ffe17 	ldw	r5,-8(fp)
 181bfbc:	d127fc04 	addi	r4,gp,-24592
 181bfc0:	181dd380 	call	181dd38 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 181bfc4:	e17ffe17 	ldw	r5,-8(fp)
 181bfc8:	01000084 	movi	r4,2
 181bfcc:	1834b240 	call	1834b24 <memp_free>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
 181bfd0:	00004106 	br	181c0d8 <tcp_abandon+0x148>
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
 181bfd4:	e0bffe17 	ldw	r2,-8(fp)
 181bfd8:	10801517 	ldw	r2,84(r2)
 181bfdc:	e0bffa15 	stw	r2,-24(fp)
    ackno = pcb->rcv_nxt;
 181bfe0:	e0bffe17 	ldw	r2,-8(fp)
 181bfe4:	10800b17 	ldw	r2,44(r2)
 181bfe8:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 181bfec:	e0bffe17 	ldw	r2,-8(fp)
 181bff0:	10802417 	ldw	r2,144(r2)
 181bff4:	e0bffc15 	stw	r2,-16(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 181bff8:	e0bffe17 	ldw	r2,-8(fp)
 181bffc:	10800417 	ldw	r2,16(r2)
 181c000:	e0bffd15 	stw	r2,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
 181c004:	e17ffe17 	ldw	r5,-8(fp)
 181c008:	d127f704 	addi	r4,gp,-24612
 181c00c:	181dd380 	call	181dd38 <tcp_pcb_remove>
 181c010:	00800044 	movi	r2,1
 181c014:	d0a7f685 	stb	r2,-24614(gp)
    if (pcb->unacked != NULL) {
 181c018:	e0bffe17 	ldw	r2,-8(fp)
 181c01c:	10801d17 	ldw	r2,116(r2)
 181c020:	10000426 	beq	r2,zero,181c034 <tcp_abandon+0xa4>
      tcp_segs_free(pcb->unacked);
 181c024:	e0bffe17 	ldw	r2,-8(fp)
 181c028:	10801d17 	ldw	r2,116(r2)
 181c02c:	1009883a 	mov	r4,r2
 181c030:	181d5180 	call	181d518 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 181c034:	e0bffe17 	ldw	r2,-8(fp)
 181c038:	10801c17 	ldw	r2,112(r2)
 181c03c:	10000426 	beq	r2,zero,181c050 <tcp_abandon+0xc0>
      tcp_segs_free(pcb->unsent);
 181c040:	e0bffe17 	ldw	r2,-8(fp)
 181c044:	10801c17 	ldw	r2,112(r2)
 181c048:	1009883a 	mov	r4,r2
 181c04c:	181d5180 	call	181d518 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
 181c050:	e0bffe17 	ldw	r2,-8(fp)
 181c054:	10801e17 	ldw	r2,120(r2)
 181c058:	10000426 	beq	r2,zero,181c06c <tcp_abandon+0xdc>
      tcp_segs_free(pcb->ooseq);
 181c05c:	e0bffe17 	ldw	r2,-8(fp)
 181c060:	10801e17 	ldw	r2,120(r2)
 181c064:	1009883a 	mov	r4,r2
 181c068:	181d5180 	call	181d518 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
 181c06c:	e0bfff17 	ldw	r2,-4(fp)
 181c070:	10001026 	beq	r2,zero,181c0b4 <tcp_abandon+0x124>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 181c074:	e13ffe17 	ldw	r4,-8(fp)
 181c078:	e0bffe17 	ldw	r2,-8(fp)
 181c07c:	11400104 	addi	r5,r2,4
 181c080:	e0bffe17 	ldw	r2,-8(fp)
 181c084:	1080078b 	ldhu	r2,30(r2)
 181c088:	10bfffcc 	andi	r2,r2,65535
 181c08c:	e0fffe17 	ldw	r3,-8(fp)
 181c090:	18c0080b 	ldhu	r3,32(r3)
 181c094:	18ffffcc 	andi	r3,r3,65535
 181c098:	d8c00115 	stw	r3,4(sp)
 181c09c:	d8800015 	stw	r2,0(sp)
 181c0a0:	280f883a 	mov	r7,r5
 181c0a4:	200d883a 	mov	r6,r4
 181c0a8:	e17ffb17 	ldw	r5,-20(fp)
 181c0ac:	e13ffa17 	ldw	r4,-24(fp)
 181c0b0:	18209680 	call	1820968 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
 181c0b4:	e17ffe17 	ldw	r5,-8(fp)
 181c0b8:	01000084 	movi	r4,2
 181c0bc:	1834b240 	call	1834b24 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 181c0c0:	e0bffc17 	ldw	r2,-16(fp)
 181c0c4:	10000426 	beq	r2,zero,181c0d8 <tcp_abandon+0x148>
 181c0c8:	e0bffc17 	ldw	r2,-16(fp)
 181c0cc:	017ffd84 	movi	r5,-10
 181c0d0:	e13ffd17 	ldw	r4,-12(fp)
 181c0d4:	103ee83a 	callr	r2
  }
}
 181c0d8:	0001883a 	nop
 181c0dc:	e037883a 	mov	sp,fp
 181c0e0:	dfc00117 	ldw	ra,4(sp)
 181c0e4:	df000017 	ldw	fp,0(sp)
 181c0e8:	dec00204 	addi	sp,sp,8
 181c0ec:	f800283a 	ret

0181c0f0 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 181c0f0:	defffd04 	addi	sp,sp,-12
 181c0f4:	dfc00215 	stw	ra,8(sp)
 181c0f8:	df000115 	stw	fp,4(sp)
 181c0fc:	df000104 	addi	fp,sp,4
 181c100:	e13fff15 	stw	r4,-4(fp)
  tcp_abandon(pcb, 1);
 181c104:	01400044 	movi	r5,1
 181c108:	e13fff17 	ldw	r4,-4(fp)
 181c10c:	181bf900 	call	181bf90 <tcp_abandon>
}
 181c110:	0001883a 	nop
 181c114:	e037883a 	mov	sp,fp
 181c118:	dfc00117 	ldw	ra,4(sp)
 181c11c:	df000017 	ldw	fp,0(sp)
 181c120:	dec00204 	addi	sp,sp,8
 181c124:	f800283a 	ret

0181c128 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 181c128:	defff804 	addi	sp,sp,-32
 181c12c:	dfc00715 	stw	ra,28(sp)
 181c130:	df000615 	stw	fp,24(sp)
 181c134:	df000604 	addi	fp,sp,24
 181c138:	e13ffd15 	stw	r4,-12(fp)
 181c13c:	e17ffe15 	stw	r5,-8(fp)
 181c140:	3005883a 	mov	r2,r6
 181c144:	e0bfff0d 	sth	r2,-4(fp)
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
 181c148:	00800104 	movi	r2,4
 181c14c:	e0bffb15 	stw	r2,-20(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 181c150:	e0bffd17 	ldw	r2,-12(fp)
 181c154:	10800617 	ldw	r2,24(r2)
 181c158:	10000926 	beq	r2,zero,181c180 <tcp_bind+0x58>
 181c15c:	01c06134 	movhi	r7,388
 181c160:	39c6e004 	addi	r7,r7,7040
 181c164:	01806dc4 	movi	r6,439
 181c168:	01406134 	movhi	r5,388
 181c16c:	2946e504 	addi	r5,r5,7060
 181c170:	01006134 	movhi	r4,388
 181c174:	2106ef04 	addi	r4,r4,7100
 181c178:	1800c180 	call	1800c18 <printf>
 181c17c:	003fff06 	br	181c17c <__ram_exceptions_end+0xff80bd38>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 181c180:	e0bffd17 	ldw	r2,-12(fp)
 181c184:	10800203 	ldbu	r2,8(r2)
 181c188:	10803fcc 	andi	r2,r2,255
 181c18c:	1080010c 	andi	r2,r2,4
 181c190:	10000226 	beq	r2,zero,181c19c <tcp_bind+0x74>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
 181c194:	008000c4 	movi	r2,3
 181c198:	e0bffb15 	stw	r2,-20(fp)
  }
#endif /* SO_REUSE */

  if (port == 0) {
 181c19c:	e0bfff0b 	ldhu	r2,-4(fp)
 181c1a0:	1000061e 	bne	r2,zero,181c1bc <tcp_bind+0x94>
    port = tcp_new_port();
 181c1a4:	181c7280 	call	181c728 <tcp_new_port>
 181c1a8:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 181c1ac:	e0bfff0b 	ldhu	r2,-4(fp)
 181c1b0:	1000021e 	bne	r2,zero,181c1bc <tcp_bind+0x94>
      return ERR_BUF;
 181c1b4:	00bfff84 	movi	r2,-2
 181c1b8:	00004a06 	br	181c2e4 <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 181c1bc:	e03ffa15 	stw	zero,-24(fp)
 181c1c0:	00003206 	br	181c28c <tcp_bind+0x164>
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 181c1c4:	00806134 	movhi	r2,388
 181c1c8:	1086dc04 	addi	r2,r2,7024
 181c1cc:	e0fffa17 	ldw	r3,-24(fp)
 181c1d0:	18c7883a 	add	r3,r3,r3
 181c1d4:	18c7883a 	add	r3,r3,r3
 181c1d8:	10c5883a 	add	r2,r2,r3
 181c1dc:	10800017 	ldw	r2,0(r2)
 181c1e0:	10800017 	ldw	r2,0(r2)
 181c1e4:	e0bffc15 	stw	r2,-16(fp)
 181c1e8:	00002306 	br	181c278 <tcp_bind+0x150>
      if (cpcb->local_port == port) {
 181c1ec:	e0bffc17 	ldw	r2,-16(fp)
 181c1f0:	1080078b 	ldhu	r2,30(r2)
 181c1f4:	10ffffcc 	andi	r3,r2,65535
 181c1f8:	e0bfff0b 	ldhu	r2,-4(fp)
 181c1fc:	18801b1e 	bne	r3,r2,181c26c <tcp_bind+0x144>
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 181c200:	e0bffd17 	ldw	r2,-12(fp)
 181c204:	10800203 	ldbu	r2,8(r2)
 181c208:	10803fcc 	andi	r2,r2,255
 181c20c:	1080010c 	andi	r2,r2,4
 181c210:	10000526 	beq	r2,zero,181c228 <tcp_bind+0x100>
            !ip_get_option(cpcb, SOF_REUSEADDR))
 181c214:	e0bffc17 	ldw	r2,-16(fp)
 181c218:	10800203 	ldbu	r2,8(r2)
 181c21c:	10803fcc 	andi	r2,r2,255
 181c220:	1080010c 	andi	r2,r2,4
      if (cpcb->local_port == port) {
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 181c224:	1000111e 	bne	r2,zero,181c26c <tcp_bind+0x144>
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
 181c228:	e0bffc17 	ldw	r2,-16(fp)
 181c22c:	10000d26 	beq	r2,zero,181c264 <tcp_bind+0x13c>
 181c230:	e0bffc17 	ldw	r2,-16(fp)
 181c234:	10800017 	ldw	r2,0(r2)
 181c238:	10000a26 	beq	r2,zero,181c264 <tcp_bind+0x13c>
 181c23c:	e0bffe17 	ldw	r2,-8(fp)
 181c240:	10000826 	beq	r2,zero,181c264 <tcp_bind+0x13c>
              ip_addr_isany(ipaddr) ||
 181c244:	e0bffe17 	ldw	r2,-8(fp)
 181c248:	10800017 	ldw	r2,0(r2)
 181c24c:	10000526 	beq	r2,zero,181c264 <tcp_bind+0x13c>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 181c250:	e0bffc17 	ldw	r2,-16(fp)
 181c254:	10c00017 	ldw	r3,0(r2)
 181c258:	e0bffe17 	ldw	r2,-8(fp)
 181c25c:	10800017 	ldw	r2,0(r2)
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
 181c260:	1880021e 	bne	r3,r2,181c26c <tcp_bind+0x144>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 181c264:	00bffe04 	movi	r2,-8
 181c268:	00001e06 	br	181c2e4 <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 181c26c:	e0bffc17 	ldw	r2,-16(fp)
 181c270:	10800317 	ldw	r2,12(r2)
 181c274:	e0bffc15 	stw	r2,-16(fp)
 181c278:	e0bffc17 	ldw	r2,-16(fp)
 181c27c:	103fdb1e 	bne	r2,zero,181c1ec <__ram_exceptions_end+0xff80bda8>
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 181c280:	e0bffa17 	ldw	r2,-24(fp)
 181c284:	10800044 	addi	r2,r2,1
 181c288:	e0bffa15 	stw	r2,-24(fp)
 181c28c:	e0fffa17 	ldw	r3,-24(fp)
 181c290:	e0bffb17 	ldw	r2,-20(fp)
 181c294:	18bfcb16 	blt	r3,r2,181c1c4 <__ram_exceptions_end+0xff80bd80>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 181c298:	e0bffe17 	ldw	r2,-8(fp)
 181c29c:	10000726 	beq	r2,zero,181c2bc <tcp_bind+0x194>
 181c2a0:	e0bffe17 	ldw	r2,-8(fp)
 181c2a4:	10800017 	ldw	r2,0(r2)
 181c2a8:	10000426 	beq	r2,zero,181c2bc <tcp_bind+0x194>
    pcb->local_ip = *ipaddr;
 181c2ac:	e0bffd17 	ldw	r2,-12(fp)
 181c2b0:	e0fffe17 	ldw	r3,-8(fp)
 181c2b4:	18c00017 	ldw	r3,0(r3)
 181c2b8:	10c00015 	stw	r3,0(r2)
  }
  pcb->local_port = port;
 181c2bc:	e0bffd17 	ldw	r2,-12(fp)
 181c2c0:	e0ffff0b 	ldhu	r3,-4(fp)
 181c2c4:	10c0078d 	sth	r3,30(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
 181c2c8:	d0e7fb17 	ldw	r3,-24596(gp)
 181c2cc:	e0bffd17 	ldw	r2,-12(fp)
 181c2d0:	10c00315 	stw	r3,12(r2)
 181c2d4:	e0bffd17 	ldw	r2,-12(fp)
 181c2d8:	d0a7fb15 	stw	r2,-24596(gp)
 181c2dc:	18216900 	call	1821690 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 181c2e0:	0005883a 	mov	r2,zero
}
 181c2e4:	e037883a 	mov	sp,fp
 181c2e8:	dfc00117 	ldw	ra,4(sp)
 181c2ec:	df000017 	ldw	fp,0(sp)
 181c2f0:	dec00204 	addi	sp,sp,8
 181c2f4:	f800283a 	ret

0181c2f8 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
 181c2f8:	defffc04 	addi	sp,sp,-16
 181c2fc:	df000315 	stw	fp,12(sp)
 181c300:	df000304 	addi	fp,sp,12
 181c304:	e13ffd15 	stw	r4,-12(fp)
 181c308:	e17ffe15 	stw	r5,-8(fp)
 181c30c:	3005883a 	mov	r2,r6
 181c310:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
 181c314:	00bffd84 	movi	r2,-10
}
 181c318:	e037883a 	mov	sp,fp
 181c31c:	df000017 	ldw	fp,0(sp)
 181c320:	dec00104 	addi	sp,sp,4
 181c324:	f800283a 	ret

0181c328 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 181c328:	defffb04 	addi	sp,sp,-20
 181c32c:	dfc00415 	stw	ra,16(sp)
 181c330:	df000315 	stw	fp,12(sp)
 181c334:	df000304 	addi	fp,sp,12
 181c338:	e13ffe15 	stw	r4,-8(fp)
 181c33c:	2805883a 	mov	r2,r5
 181c340:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 181c344:	e0bffe17 	ldw	r2,-8(fp)
 181c348:	10800617 	ldw	r2,24(r2)
 181c34c:	10000926 	beq	r2,zero,181c374 <tcp_listen_with_backlog+0x4c>
 181c350:	01c06134 	movhi	r7,388
 181c354:	39c6e004 	addi	r7,r7,7040
 181c358:	01808304 	movi	r6,524
 181c35c:	01406134 	movhi	r5,388
 181c360:	2946fb04 	addi	r5,r5,7148
 181c364:	01006134 	movhi	r4,388
 181c368:	2106ef04 	addi	r4,r4,7100
 181c36c:	1800c180 	call	1800c18 <printf>
 181c370:	003fff06 	br	181c370 <__ram_exceptions_end+0xff80bf2c>

  /* already listening? */
  if (pcb->state == LISTEN) {
 181c374:	e0bffe17 	ldw	r2,-8(fp)
 181c378:	10800617 	ldw	r2,24(r2)
 181c37c:	10800058 	cmpnei	r2,r2,1
 181c380:	1000021e 	bne	r2,zero,181c38c <tcp_listen_with_backlog+0x64>
    return pcb;
 181c384:	e0bffe17 	ldw	r2,-8(fp)
 181c388:	00007c06 	br	181c57c <tcp_listen_with_backlog+0x254>
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 181c38c:	e0bffe17 	ldw	r2,-8(fp)
 181c390:	10800203 	ldbu	r2,8(r2)
 181c394:	10803fcc 	andi	r2,r2,255
 181c398:	1080010c 	andi	r2,r2,4
 181c39c:	10001626 	beq	r2,zero,181c3f8 <tcp_listen_with_backlog+0xd0>
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 181c3a0:	d0a7f917 	ldw	r2,-24604(gp)
 181c3a4:	e0bffd15 	stw	r2,-12(fp)
 181c3a8:	00001106 	br	181c3f0 <tcp_listen_with_backlog+0xc8>
      if (lpcb->local_port == pcb->local_port) {
 181c3ac:	e0bffd17 	ldw	r2,-12(fp)
 181c3b0:	10c0078b 	ldhu	r3,30(r2)
 181c3b4:	e0bffe17 	ldw	r2,-8(fp)
 181c3b8:	1080078b 	ldhu	r2,30(r2)
 181c3bc:	18ffffcc 	andi	r3,r3,65535
 181c3c0:	10bfffcc 	andi	r2,r2,65535
 181c3c4:	1880071e 	bne	r3,r2,181c3e4 <tcp_listen_with_backlog+0xbc>
        if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
 181c3c8:	e0bffd17 	ldw	r2,-12(fp)
 181c3cc:	10c00017 	ldw	r3,0(r2)
 181c3d0:	e0bffe17 	ldw	r2,-8(fp)
 181c3d4:	10800017 	ldw	r2,0(r2)
 181c3d8:	1880021e 	bne	r3,r2,181c3e4 <tcp_listen_with_backlog+0xbc>
          /* this address/port is already used */
          return NULL;
 181c3dc:	0005883a 	mov	r2,zero
 181c3e0:	00006606 	br	181c57c <tcp_listen_with_backlog+0x254>
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 181c3e4:	e0bffd17 	ldw	r2,-12(fp)
 181c3e8:	10800317 	ldw	r2,12(r2)
 181c3ec:	e0bffd15 	stw	r2,-12(fp)
 181c3f0:	e0bffd17 	ldw	r2,-12(fp)
 181c3f4:	103fed1e 	bne	r2,zero,181c3ac <__ram_exceptions_end+0xff80bf68>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 181c3f8:	010000c4 	movi	r4,3
 181c3fc:	18349580 	call	1834958 <memp_malloc>
 181c400:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
 181c404:	e0bffd17 	ldw	r2,-12(fp)
 181c408:	1000021e 	bne	r2,zero,181c414 <tcp_listen_with_backlog+0xec>
    return NULL;
 181c40c:	0005883a 	mov	r2,zero
 181c410:	00005a06 	br	181c57c <tcp_listen_with_backlog+0x254>
  }
  lpcb->callback_arg = pcb->callback_arg;
 181c414:	e0bffe17 	ldw	r2,-8(fp)
 181c418:	10c00417 	ldw	r3,16(r2)
 181c41c:	e0bffd17 	ldw	r2,-12(fp)
 181c420:	10c00415 	stw	r3,16(r2)
  lpcb->local_port = pcb->local_port;
 181c424:	e0bffe17 	ldw	r2,-8(fp)
 181c428:	10c0078b 	ldhu	r3,30(r2)
 181c42c:	e0bffd17 	ldw	r2,-12(fp)
 181c430:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
 181c434:	e0bffd17 	ldw	r2,-12(fp)
 181c438:	00c00044 	movi	r3,1
 181c43c:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
 181c440:	e0bffe17 	ldw	r2,-8(fp)
 181c444:	10c00703 	ldbu	r3,28(r2)
 181c448:	e0bffd17 	ldw	r2,-12(fp)
 181c44c:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
 181c450:	e0bffe17 	ldw	r2,-8(fp)
 181c454:	10c00203 	ldbu	r3,8(r2)
 181c458:	e0bffd17 	ldw	r2,-12(fp)
 181c45c:	10c00205 	stb	r3,8(r2)
  ip_set_option(lpcb, SOF_ACCEPTCONN);
 181c460:	e0bffd17 	ldw	r2,-12(fp)
 181c464:	10800203 	ldbu	r2,8(r2)
 181c468:	10800094 	ori	r2,r2,2
 181c46c:	1007883a 	mov	r3,r2
 181c470:	e0bffd17 	ldw	r2,-12(fp)
 181c474:	10c00205 	stb	r3,8(r2)
  lpcb->ttl = pcb->ttl;
 181c478:	e0bffe17 	ldw	r2,-8(fp)
 181c47c:	10c00283 	ldbu	r3,10(r2)
 181c480:	e0bffd17 	ldw	r2,-12(fp)
 181c484:	10c00285 	stb	r3,10(r2)
  lpcb->tos = pcb->tos;
 181c488:	e0bffe17 	ldw	r2,-8(fp)
 181c48c:	10c00243 	ldbu	r3,9(r2)
 181c490:	e0bffd17 	ldw	r2,-12(fp)
 181c494:	10c00245 	stb	r3,9(r2)
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 181c498:	e0bffe17 	ldw	r2,-8(fp)
 181c49c:	10c00017 	ldw	r3,0(r2)
 181c4a0:	e0bffd17 	ldw	r2,-12(fp)
 181c4a4:	10c00015 	stw	r3,0(r2)
  if (pcb->local_port != 0) {
 181c4a8:	e0bffe17 	ldw	r2,-8(fp)
 181c4ac:	1080078b 	ldhu	r2,30(r2)
 181c4b0:	10bfffcc 	andi	r2,r2,65535
 181c4b4:	10001a26 	beq	r2,zero,181c520 <tcp_listen_with_backlog+0x1f8>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 181c4b8:	d0e7fb17 	ldw	r3,-24596(gp)
 181c4bc:	e0bffe17 	ldw	r2,-8(fp)
 181c4c0:	1880041e 	bne	r3,r2,181c4d4 <tcp_listen_with_backlog+0x1ac>
 181c4c4:	d0a7fb17 	ldw	r2,-24596(gp)
 181c4c8:	10800317 	ldw	r2,12(r2)
 181c4cc:	d0a7fb15 	stw	r2,-24596(gp)
 181c4d0:	00001106 	br	181c518 <tcp_listen_with_backlog+0x1f0>
 181c4d4:	d0a7fb17 	ldw	r2,-24596(gp)
 181c4d8:	d0a7fa15 	stw	r2,-24600(gp)
 181c4dc:	00000c06 	br	181c510 <tcp_listen_with_backlog+0x1e8>
 181c4e0:	d0a7fa17 	ldw	r2,-24600(gp)
 181c4e4:	10c00317 	ldw	r3,12(r2)
 181c4e8:	e0bffe17 	ldw	r2,-8(fp)
 181c4ec:	1880051e 	bne	r3,r2,181c504 <tcp_listen_with_backlog+0x1dc>
 181c4f0:	d0a7fa17 	ldw	r2,-24600(gp)
 181c4f4:	e0fffe17 	ldw	r3,-8(fp)
 181c4f8:	18c00317 	ldw	r3,12(r3)
 181c4fc:	10c00315 	stw	r3,12(r2)
 181c500:	00000506 	br	181c518 <tcp_listen_with_backlog+0x1f0>
 181c504:	d0a7fa17 	ldw	r2,-24600(gp)
 181c508:	10800317 	ldw	r2,12(r2)
 181c50c:	d0a7fa15 	stw	r2,-24600(gp)
 181c510:	d0a7fa17 	ldw	r2,-24600(gp)
 181c514:	103ff21e 	bne	r2,zero,181c4e0 <__ram_exceptions_end+0xff80c09c>
 181c518:	e0bffe17 	ldw	r2,-8(fp)
 181c51c:	10000315 	stw	zero,12(r2)
  }
  memp_free(MEMP_TCP_PCB, pcb);
 181c520:	e17ffe17 	ldw	r5,-8(fp)
 181c524:	01000084 	movi	r4,2
 181c528:	1834b240 	call	1834b24 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 181c52c:	e0fffd17 	ldw	r3,-12(fp)
 181c530:	008060b4 	movhi	r2,386
 181c534:	10b0be04 	addi	r2,r2,-15624
 181c538:	18800515 	stw	r2,20(r3)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
 181c53c:	e0bffd17 	ldw	r2,-12(fp)
 181c540:	10000845 	stb	zero,33(r2)
  lpcb->backlog = (backlog ? backlog : 1);
 181c544:	e0bfff03 	ldbu	r2,-4(fp)
 181c548:	10000226 	beq	r2,zero,181c554 <tcp_listen_with_backlog+0x22c>
 181c54c:	e0bfff03 	ldbu	r2,-4(fp)
 181c550:	00000106 	br	181c558 <tcp_listen_with_backlog+0x230>
 181c554:	00800044 	movi	r2,1
 181c558:	e0fffd17 	ldw	r3,-12(fp)
 181c55c:	18800805 	stb	r2,32(r3)
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 181c560:	d0e7f917 	ldw	r3,-24604(gp)
 181c564:	e0bffd17 	ldw	r2,-12(fp)
 181c568:	10c00315 	stw	r3,12(r2)
 181c56c:	e0bffd17 	ldw	r2,-12(fp)
 181c570:	d0a7f915 	stw	r2,-24604(gp)
 181c574:	18216900 	call	1821690 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 181c578:	e0bffd17 	ldw	r2,-12(fp)
}
 181c57c:	e037883a 	mov	sp,fp
 181c580:	dfc00117 	ldw	ra,4(sp)
 181c584:	df000017 	ldw	fp,0(sp)
 181c588:	dec00204 	addi	sp,sp,8
 181c58c:	f800283a 	ret

0181c590 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 181c590:	defffc04 	addi	sp,sp,-16
 181c594:	df000315 	stw	fp,12(sp)
 181c598:	df000304 	addi	fp,sp,12
 181c59c:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 181c5a0:	e0bfff17 	ldw	r2,-4(fp)
 181c5a4:	10c00b17 	ldw	r3,44(r2)
 181c5a8:	e0bfff17 	ldw	r2,-4(fp)
 181c5ac:	10800c0b 	ldhu	r2,48(r2)
 181c5b0:	10bfffcc 	andi	r2,r2,65535
 181c5b4:	1885883a 	add	r2,r3,r2
 181c5b8:	e0bffd15 	stw	r2,-12(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 181c5bc:	e0bfff17 	ldw	r2,-4(fp)
 181c5c0:	10c00d17 	ldw	r3,52(r2)
 181c5c4:	e0bfff17 	ldw	r2,-4(fp)
 181c5c8:	10800e8b 	ldhu	r2,58(r2)
 181c5cc:	10bfffcc 	andi	r2,r2,65535
 181c5d0:	10840068 	cmpgeui	r2,r2,4097
 181c5d4:	1000041e 	bne	r2,zero,181c5e8 <tcp_update_rcv_ann_wnd+0x58>
 181c5d8:	e0bfff17 	ldw	r2,-4(fp)
 181c5dc:	10800e8b 	ldhu	r2,58(r2)
 181c5e0:	10bfffcc 	andi	r2,r2,65535
 181c5e4:	00000106 	br	181c5ec <tcp_update_rcv_ann_wnd+0x5c>
 181c5e8:	00840004 	movi	r2,4096
 181c5ec:	1885883a 	add	r2,r3,r2
 181c5f0:	e0fffd17 	ldw	r3,-12(fp)
 181c5f4:	1885c83a 	sub	r2,r3,r2
 181c5f8:	10000916 	blt	r2,zero,181c620 <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 181c5fc:	e0bfff17 	ldw	r2,-4(fp)
 181c600:	10c00c0b 	ldhu	r3,48(r2)
 181c604:	e0bfff17 	ldw	r2,-4(fp)
 181c608:	10c00c8d 	sth	r3,50(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
 181c60c:	e0bfff17 	ldw	r2,-4(fp)
 181c610:	10800d17 	ldw	r2,52(r2)
 181c614:	e0fffd17 	ldw	r3,-12(fp)
 181c618:	1885c83a 	sub	r2,r3,r2
 181c61c:	00001406 	br	181c670 <tcp_update_rcv_ann_wnd+0xe0>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 181c620:	e0bfff17 	ldw	r2,-4(fp)
 181c624:	10c00b17 	ldw	r3,44(r2)
 181c628:	e0bfff17 	ldw	r2,-4(fp)
 181c62c:	10800d17 	ldw	r2,52(r2)
 181c630:	1885c83a 	sub	r2,r3,r2
 181c634:	0080030e 	bge	zero,r2,181c644 <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 181c638:	e0bfff17 	ldw	r2,-4(fp)
 181c63c:	10000c8d 	sth	zero,50(r2)
 181c640:	00000a06 	br	181c66c <tcp_update_rcv_ann_wnd+0xdc>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 181c644:	e0bfff17 	ldw	r2,-4(fp)
 181c648:	10c00d17 	ldw	r3,52(r2)
 181c64c:	e0bfff17 	ldw	r2,-4(fp)
 181c650:	10800b17 	ldw	r2,44(r2)
 181c654:	1885c83a 	sub	r2,r3,r2
 181c658:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 181c65c:	e0bffe17 	ldw	r2,-8(fp)
 181c660:	1007883a 	mov	r3,r2
 181c664:	e0bfff17 	ldw	r2,-4(fp)
 181c668:	10c00c8d 	sth	r3,50(r2)
    }
    return 0;
 181c66c:	0005883a 	mov	r2,zero
  }
}
 181c670:	e037883a 	mov	sp,fp
 181c674:	df000017 	ldw	fp,0(sp)
 181c678:	dec00104 	addi	sp,sp,4
 181c67c:	f800283a 	ret

0181c680 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 181c680:	defffb04 	addi	sp,sp,-20
 181c684:	dfc00415 	stw	ra,16(sp)
 181c688:	df000315 	stw	fp,12(sp)
 181c68c:	df000304 	addi	fp,sp,12
 181c690:	e13ffe15 	stw	r4,-8(fp)
 181c694:	2805883a 	mov	r2,r5
 181c698:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 181c69c:	e0bffe17 	ldw	r2,-8(fp)
 181c6a0:	10c00c0b 	ldhu	r3,48(r2)
 181c6a4:	e0bfff0b 	ldhu	r2,-4(fp)
 181c6a8:	1885883a 	add	r2,r3,r2
 181c6ac:	1007883a 	mov	r3,r2
 181c6b0:	e0bffe17 	ldw	r2,-8(fp)
 181c6b4:	10c00c0d 	sth	r3,48(r2)
  if (pcb->rcv_wnd > TCP_WND) {
 181c6b8:	e0bffe17 	ldw	r2,-8(fp)
 181c6bc:	10800c0b 	ldhu	r2,48(r2)
 181c6c0:	10bfffcc 	andi	r2,r2,65535
 181c6c4:	10880070 	cmpltui	r2,r2,8193
 181c6c8:	1000031e 	bne	r2,zero,181c6d8 <tcp_recved+0x58>
    pcb->rcv_wnd = TCP_WND;
 181c6cc:	e0bffe17 	ldw	r2,-8(fp)
 181c6d0:	00c80004 	movi	r3,8192
 181c6d4:	10c00c0d 	sth	r3,48(r2)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 181c6d8:	e13ffe17 	ldw	r4,-8(fp)
 181c6dc:	181c5900 	call	181c590 <tcp_update_rcv_ann_wnd>
 181c6e0:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 181c6e4:	e0bffd17 	ldw	r2,-12(fp)
 181c6e8:	10820010 	cmplti	r2,r2,2048
 181c6ec:	1000081e 	bne	r2,zero,181c710 <tcp_recved+0x90>
    tcp_ack_now(pcb);
 181c6f0:	e0bffe17 	ldw	r2,-8(fp)
 181c6f4:	10800883 	ldbu	r2,34(r2)
 181c6f8:	10800094 	ori	r2,r2,2
 181c6fc:	1007883a 	mov	r3,r2
 181c700:	e0bffe17 	ldw	r2,-8(fp)
 181c704:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
 181c708:	e13ffe17 	ldw	r4,-8(fp)
 181c70c:	181f8bc0 	call	181f8bc <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 181c710:	0001883a 	nop
 181c714:	e037883a 	mov	sp,fp
 181c718:	dfc00117 	ldw	ra,4(sp)
 181c71c:	df000017 	ldw	fp,0(sp)
 181c720:	dec00204 	addi	sp,sp,8
 181c724:	f800283a 	ret

0181c728 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 181c728:	defffd04 	addi	sp,sp,-12
 181c72c:	df000215 	stw	fp,8(sp)
 181c730:	df000204 	addi	fp,sp,8
  u8_t i;
  u16_t n = 0;
 181c734:	e03ffe8d 	sth	zero,-6(fp)
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 181c738:	d0a00f0b 	ldhu	r2,-32708(gp)
 181c73c:	10c00044 	addi	r3,r2,1
 181c740:	d0e00f0d 	sth	r3,-32708(gp)
 181c744:	10ffffcc 	andi	r3,r2,65535
 181c748:	00bfffd4 	movui	r2,65535
 181c74c:	1880021e 	bne	r3,r2,181c758 <tcp_new_port+0x30>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 181c750:	00b00004 	movi	r2,-16384
 181c754:	d0a00f0d 	sth	r2,-32708(gp)
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 181c758:	e03ffe05 	stb	zero,-8(fp)
 181c75c:	00002006 	br	181c7e0 <tcp_new_port+0xb8>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 181c760:	e0fffe03 	ldbu	r3,-8(fp)
 181c764:	00806134 	movhi	r2,388
 181c768:	1086dc04 	addi	r2,r2,7024
 181c76c:	18c7883a 	add	r3,r3,r3
 181c770:	18c7883a 	add	r3,r3,r3
 181c774:	10c5883a 	add	r2,r2,r3
 181c778:	10800017 	ldw	r2,0(r2)
 181c77c:	10800017 	ldw	r2,0(r2)
 181c780:	e0bfff15 	stw	r2,-4(fp)
 181c784:	00001106 	br	181c7cc <tcp_new_port+0xa4>
      if (pcb->local_port == tcp_port) {
 181c788:	e0bfff17 	ldw	r2,-4(fp)
 181c78c:	10c0078b 	ldhu	r3,30(r2)
 181c790:	d0a00f0b 	ldhu	r2,-32708(gp)
 181c794:	18ffffcc 	andi	r3,r3,65535
 181c798:	10bfffcc 	andi	r2,r2,65535
 181c79c:	1880081e 	bne	r3,r2,181c7c0 <tcp_new_port+0x98>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 181c7a0:	e0bffe8b 	ldhu	r2,-6(fp)
 181c7a4:	10800044 	addi	r2,r2,1
 181c7a8:	e0bffe8d 	sth	r2,-6(fp)
 181c7ac:	e0bffe8b 	ldhu	r2,-6(fp)
 181c7b0:	10900030 	cmpltui	r2,r2,16384
 181c7b4:	103fe01e 	bne	r2,zero,181c738 <__ram_exceptions_end+0xff80c2f4>
          return 0;
 181c7b8:	0005883a 	mov	r2,zero
 181c7bc:	00000c06 	br	181c7f0 <tcp_new_port+0xc8>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 181c7c0:	e0bfff17 	ldw	r2,-4(fp)
 181c7c4:	10800317 	ldw	r2,12(r2)
 181c7c8:	e0bfff15 	stw	r2,-4(fp)
 181c7cc:	e0bfff17 	ldw	r2,-4(fp)
 181c7d0:	103fed1e 	bne	r2,zero,181c788 <__ram_exceptions_end+0xff80c344>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 181c7d4:	e0bffe03 	ldbu	r2,-8(fp)
 181c7d8:	10800044 	addi	r2,r2,1
 181c7dc:	e0bffe05 	stb	r2,-8(fp)
 181c7e0:	e0bffe03 	ldbu	r2,-8(fp)
 181c7e4:	10800130 	cmpltui	r2,r2,4
 181c7e8:	103fdd1e 	bne	r2,zero,181c760 <__ram_exceptions_end+0xff80c31c>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 181c7ec:	d0a00f0b 	ldhu	r2,-32708(gp)
}
 181c7f0:	e037883a 	mov	sp,fp
 181c7f4:	df000017 	ldw	fp,0(sp)
 181c7f8:	dec00104 	addi	sp,sp,4
 181c7fc:	f800283a 	ret

0181c800 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
 181c800:	defff404 	addi	sp,sp,-48
 181c804:	dfc00b15 	stw	ra,44(sp)
 181c808:	df000a15 	stw	fp,40(sp)
 181c80c:	df000a04 	addi	fp,sp,40
 181c810:	e13ffc15 	stw	r4,-16(fp)
 181c814:	e17ffd15 	stw	r5,-12(fp)
 181c818:	3005883a 	mov	r2,r6
 181c81c:	e1ffff15 	stw	r7,-4(fp)
 181c820:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 181c824:	e0bffc17 	ldw	r2,-16(fp)
 181c828:	10800617 	ldw	r2,24(r2)
 181c82c:	10000926 	beq	r2,zero,181c854 <tcp_connect+0x54>
 181c830:	01c06134 	movhi	r7,388
 181c834:	39c6e004 	addi	r7,r7,7040
 181c838:	0180acc4 	movi	r6,691
 181c83c:	01406134 	movhi	r5,388
 181c840:	29470404 	addi	r5,r5,7184
 181c844:	01006134 	movhi	r4,388
 181c848:	2106ef04 	addi	r4,r4,7100
 181c84c:	1800c180 	call	1800c18 <printf>
 181c850:	003fff06 	br	181c850 <__ram_exceptions_end+0xff80c40c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
 181c854:	e0bffd17 	ldw	r2,-12(fp)
 181c858:	10000a26 	beq	r2,zero,181c884 <tcp_connect+0x84>
    pcb->remote_ip = *ipaddr;
 181c85c:	e0bffc17 	ldw	r2,-16(fp)
 181c860:	e0fffd17 	ldw	r3,-12(fp)
 181c864:	18c00017 	ldw	r3,0(r3)
 181c868:	10c00115 	stw	r3,4(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
 181c86c:	e0bffc17 	ldw	r2,-16(fp)
 181c870:	e0fffe0b 	ldhu	r3,-8(fp)
 181c874:	10c0080d 	sth	r3,32(r2)

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 181c878:	e0bffc17 	ldw	r2,-16(fp)
 181c87c:	10000626 	beq	r2,zero,181c898 <tcp_connect+0x98>
 181c880:	00000206 	br	181c88c <tcp_connect+0x8c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
 181c884:	00bffe84 	movi	r2,-6
 181c888:	0000be06 	br	181cb84 <tcp_connect+0x384>
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 181c88c:	e0bffc17 	ldw	r2,-16(fp)
 181c890:	10800017 	ldw	r2,0(r2)
 181c894:	10000f1e 	bne	r2,zero,181c8d4 <tcp_connect+0xd4>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
 181c898:	e0fffc17 	ldw	r3,-16(fp)
 181c89c:	e0bffc17 	ldw	r2,-16(fp)
 181c8a0:	10800104 	addi	r2,r2,4
 181c8a4:	100b883a 	mov	r5,r2
 181c8a8:	1809883a 	mov	r4,r3
 181c8ac:	18322400 	call	1832240 <ip_route>
 181c8b0:	e0bff815 	stw	r2,-32(fp)
    if (netif == NULL) {
 181c8b4:	e0bff817 	ldw	r2,-32(fp)
 181c8b8:	1000021e 	bne	r2,zero,181c8c4 <tcp_connect+0xc4>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
 181c8bc:	00bfff04 	movi	r2,-4
 181c8c0:	0000b006 	br	181cb84 <tcp_connect+0x384>
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 181c8c4:	e0bff817 	ldw	r2,-32(fp)
 181c8c8:	10c00117 	ldw	r3,4(r2)
 181c8cc:	e0bffc17 	ldw	r2,-16(fp)
 181c8d0:	10c00015 	stw	r3,0(r2)
  }

  old_local_port = pcb->local_port;
 181c8d4:	e0bffc17 	ldw	r2,-16(fp)
 181c8d8:	1080078b 	ldhu	r2,30(r2)
 181c8dc:	e0bff90d 	sth	r2,-28(fp)
  if (pcb->local_port == 0) {
 181c8e0:	e0bffc17 	ldw	r2,-16(fp)
 181c8e4:	1080078b 	ldhu	r2,30(r2)
 181c8e8:	10bfffcc 	andi	r2,r2,65535
 181c8ec:	10000a1e 	bne	r2,zero,181c918 <tcp_connect+0x118>
    pcb->local_port = tcp_new_port();
 181c8f0:	181c7280 	call	181c728 <tcp_new_port>
 181c8f4:	1007883a 	mov	r3,r2
 181c8f8:	e0bffc17 	ldw	r2,-16(fp)
 181c8fc:	10c0078d 	sth	r3,30(r2)
    if (pcb->local_port == 0) {
 181c900:	e0bffc17 	ldw	r2,-16(fp)
 181c904:	1080078b 	ldhu	r2,30(r2)
 181c908:	10bfffcc 	andi	r2,r2,65535
 181c90c:	1000021e 	bne	r2,zero,181c918 <tcp_connect+0x118>
      return ERR_BUF;
 181c910:	00bfff84 	movi	r2,-2
 181c914:	00009b06 	br	181cb84 <tcp_connect+0x384>
    }
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 181c918:	e0bffc17 	ldw	r2,-16(fp)
 181c91c:	10800203 	ldbu	r2,8(r2)
 181c920:	10803fcc 	andi	r2,r2,255
 181c924:	1080010c 	andi	r2,r2,4
 181c928:	10003026 	beq	r2,zero,181c9ec <tcp_connect+0x1ec>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 181c92c:	00800084 	movi	r2,2
 181c930:	e0bff715 	stw	r2,-36(fp)
 181c934:	00002a06 	br	181c9e0 <tcp_connect+0x1e0>
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 181c938:	00806134 	movhi	r2,388
 181c93c:	1086dc04 	addi	r2,r2,7024
 181c940:	e0fff717 	ldw	r3,-36(fp)
 181c944:	18c7883a 	add	r3,r3,r3
 181c948:	18c7883a 	add	r3,r3,r3
 181c94c:	10c5883a 	add	r2,r2,r3
 181c950:	10800017 	ldw	r2,0(r2)
 181c954:	10800017 	ldw	r2,0(r2)
 181c958:	e0bff615 	stw	r2,-40(fp)
 181c95c:	00001b06 	br	181c9cc <tcp_connect+0x1cc>
        if ((cpcb->local_port == pcb->local_port) &&
 181c960:	e0bff617 	ldw	r2,-40(fp)
 181c964:	10c0078b 	ldhu	r3,30(r2)
 181c968:	e0bffc17 	ldw	r2,-16(fp)
 181c96c:	1080078b 	ldhu	r2,30(r2)
 181c970:	18ffffcc 	andi	r3,r3,65535
 181c974:	10bfffcc 	andi	r2,r2,65535
 181c978:	1880111e 	bne	r3,r2,181c9c0 <tcp_connect+0x1c0>
            (cpcb->remote_port == port) &&
 181c97c:	e0bff617 	ldw	r2,-40(fp)
 181c980:	1080080b 	ldhu	r2,32(r2)
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
 181c984:	10ffffcc 	andi	r3,r2,65535
 181c988:	e0bffe0b 	ldhu	r2,-8(fp)
 181c98c:	18800c1e 	bne	r3,r2,181c9c0 <tcp_connect+0x1c0>
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 181c990:	e0bff617 	ldw	r2,-40(fp)
 181c994:	10c00017 	ldw	r3,0(r2)
 181c998:	e0bffc17 	ldw	r2,-16(fp)
 181c99c:	10800017 	ldw	r2,0(r2)
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
 181c9a0:	1880071e 	bne	r3,r2,181c9c0 <tcp_connect+0x1c0>
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 181c9a4:	e0bff617 	ldw	r2,-40(fp)
 181c9a8:	10c00117 	ldw	r3,4(r2)
 181c9ac:	e0bffd17 	ldw	r2,-12(fp)
 181c9b0:	10800017 	ldw	r2,0(r2)
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 181c9b4:	1880021e 	bne	r3,r2,181c9c0 <tcp_connect+0x1c0>
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
          /* linux returns EISCONN here, but ERR_USE should be OK for us */
          return ERR_USE;
 181c9b8:	00bffe04 	movi	r2,-8
 181c9bc:	00007106 	br	181cb84 <tcp_connect+0x384>
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 181c9c0:	e0bff617 	ldw	r2,-40(fp)
 181c9c4:	10800317 	ldw	r2,12(r2)
 181c9c8:	e0bff615 	stw	r2,-40(fp)
 181c9cc:	e0bff617 	ldw	r2,-40(fp)
 181c9d0:	103fe31e 	bne	r2,zero,181c960 <__ram_exceptions_end+0xff80c51c>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 181c9d4:	e0bff717 	ldw	r2,-36(fp)
 181c9d8:	10800044 	addi	r2,r2,1
 181c9dc:	e0bff715 	stw	r2,-36(fp)
 181c9e0:	e0bff717 	ldw	r2,-36(fp)
 181c9e4:	10800110 	cmplti	r2,r2,4
 181c9e8:	103fd31e 	bne	r2,zero,181c938 <__ram_exceptions_end+0xff80c4f4>
        }
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
 181c9ec:	181de440 	call	181de44 <tcp_next_iss>
 181c9f0:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
 181c9f4:	e0bffc17 	ldw	r2,-16(fp)
 181c9f8:	10000b15 	stw	zero,44(r2)
  pcb->snd_nxt = iss;
 181c9fc:	e0bffc17 	ldw	r2,-16(fp)
 181ca00:	e0fffa17 	ldw	r3,-24(fp)
 181ca04:	10c01515 	stw	r3,84(r2)
  pcb->lastack = iss - 1;
 181ca08:	e0bffa17 	ldw	r2,-24(fp)
 181ca0c:	10ffffc4 	addi	r3,r2,-1
 181ca10:	e0bffc17 	ldw	r2,-16(fp)
 181ca14:	10c01315 	stw	r3,76(r2)
  pcb->snd_lbb = iss - 1;
 181ca18:	e0bffa17 	ldw	r2,-24(fp)
 181ca1c:	10ffffc4 	addi	r3,r2,-1
 181ca20:	e0bffc17 	ldw	r2,-16(fp)
 181ca24:	10c01815 	stw	r3,96(r2)
  pcb->rcv_wnd = TCP_WND;
 181ca28:	e0bffc17 	ldw	r2,-16(fp)
 181ca2c:	00c80004 	movi	r3,8192
 181ca30:	10c00c0d 	sth	r3,48(r2)
  pcb->rcv_ann_wnd = TCP_WND;
 181ca34:	e0bffc17 	ldw	r2,-16(fp)
 181ca38:	00c80004 	movi	r3,8192
 181ca3c:	10c00c8d 	sth	r3,50(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 181ca40:	e0bffc17 	ldw	r2,-16(fp)
 181ca44:	10c00b17 	ldw	r3,44(r2)
 181ca48:	e0bffc17 	ldw	r2,-16(fp)
 181ca4c:	10c00d15 	stw	r3,52(r2)
  pcb->snd_wnd = TCP_WND;
 181ca50:	e0bffc17 	ldw	r2,-16(fp)
 181ca54:	00c80004 	movi	r3,8192
 181ca58:	10c0190d 	sth	r3,100(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 181ca5c:	e0bffc17 	ldw	r2,-16(fp)
 181ca60:	00c08604 	movi	r3,536
 181ca64:	10c00e8d 	sth	r3,58(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), ipaddr);
 181ca68:	e0bffc17 	ldw	r2,-16(fp)
 181ca6c:	10800e8b 	ldhu	r2,58(r2)
 181ca70:	10bfffcc 	andi	r2,r2,65535
 181ca74:	e0fffc17 	ldw	r3,-16(fp)
 181ca78:	e1bffd17 	ldw	r6,-12(fp)
 181ca7c:	180b883a 	mov	r5,r3
 181ca80:	1009883a 	mov	r4,r2
 181ca84:	181de740 	call	181de74 <tcp_eff_send_mss>
 181ca88:	1007883a 	mov	r3,r2
 181ca8c:	e0bffc17 	ldw	r2,-16(fp)
 181ca90:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 181ca94:	e0bffc17 	ldw	r2,-16(fp)
 181ca98:	00c00044 	movi	r3,1
 181ca9c:	10c0140d 	sth	r3,80(r2)
  pcb->ssthresh = pcb->mss * 10;
 181caa0:	e0bffc17 	ldw	r2,-16(fp)
 181caa4:	10800e8b 	ldhu	r2,58(r2)
 181caa8:	108002a4 	muli	r2,r2,10
 181caac:	1007883a 	mov	r3,r2
 181cab0:	e0bffc17 	ldw	r2,-16(fp)
 181cab4:	10c0148d 	sth	r3,82(r2)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 181cab8:	e0bffc17 	ldw	r2,-16(fp)
 181cabc:	e0ffff17 	ldw	r3,-4(fp)
 181cac0:	10c02215 	stw	r3,136(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 181cac4:	01400084 	movi	r5,2
 181cac8:	e13ffc17 	ldw	r4,-16(fp)
 181cacc:	181f4380 	call	181f438 <tcp_enqueue_flags>
 181cad0:	e0bffb05 	stb	r2,-20(fp)
  if (ret == ERR_OK) {
 181cad4:	e0bffb07 	ldb	r2,-20(fp)
 181cad8:	1000291e 	bne	r2,zero,181cb80 <tcp_connect+0x380>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 181cadc:	e0bffc17 	ldw	r2,-16(fp)
 181cae0:	00c00084 	movi	r3,2
 181cae4:	10c00615 	stw	r3,24(r2)
    if (old_local_port != 0) {
 181cae8:	e0bff90b 	ldhu	r2,-28(fp)
 181caec:	10001a26 	beq	r2,zero,181cb58 <tcp_connect+0x358>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 181caf0:	d0e7fb17 	ldw	r3,-24596(gp)
 181caf4:	e0bffc17 	ldw	r2,-16(fp)
 181caf8:	1880041e 	bne	r3,r2,181cb0c <tcp_connect+0x30c>
 181cafc:	d0a7fb17 	ldw	r2,-24596(gp)
 181cb00:	10800317 	ldw	r2,12(r2)
 181cb04:	d0a7fb15 	stw	r2,-24596(gp)
 181cb08:	00001106 	br	181cb50 <tcp_connect+0x350>
 181cb0c:	d0a7fb17 	ldw	r2,-24596(gp)
 181cb10:	d0a7fa15 	stw	r2,-24600(gp)
 181cb14:	00000c06 	br	181cb48 <tcp_connect+0x348>
 181cb18:	d0a7fa17 	ldw	r2,-24600(gp)
 181cb1c:	10c00317 	ldw	r3,12(r2)
 181cb20:	e0bffc17 	ldw	r2,-16(fp)
 181cb24:	1880051e 	bne	r3,r2,181cb3c <tcp_connect+0x33c>
 181cb28:	d0a7fa17 	ldw	r2,-24600(gp)
 181cb2c:	e0fffc17 	ldw	r3,-16(fp)
 181cb30:	18c00317 	ldw	r3,12(r3)
 181cb34:	10c00315 	stw	r3,12(r2)
 181cb38:	00000506 	br	181cb50 <tcp_connect+0x350>
 181cb3c:	d0a7fa17 	ldw	r2,-24600(gp)
 181cb40:	10800317 	ldw	r2,12(r2)
 181cb44:	d0a7fa15 	stw	r2,-24600(gp)
 181cb48:	d0a7fa17 	ldw	r2,-24600(gp)
 181cb4c:	103ff21e 	bne	r2,zero,181cb18 <__ram_exceptions_end+0xff80c6d4>
 181cb50:	e0bffc17 	ldw	r2,-16(fp)
 181cb54:	10000315 	stw	zero,12(r2)
    }
    TCP_REG_ACTIVE(pcb);
 181cb58:	d0e7f717 	ldw	r3,-24612(gp)
 181cb5c:	e0bffc17 	ldw	r2,-16(fp)
 181cb60:	10c00315 	stw	r3,12(r2)
 181cb64:	e0bffc17 	ldw	r2,-16(fp)
 181cb68:	d0a7f715 	stw	r2,-24612(gp)
 181cb6c:	18216900 	call	1821690 <tcp_timer_needed>
 181cb70:	00800044 	movi	r2,1
 181cb74:	d0a7f685 	stb	r2,-24614(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
 181cb78:	e13ffc17 	ldw	r4,-16(fp)
 181cb7c:	181f8bc0 	call	181f8bc <tcp_output>
  }
  return ret;
 181cb80:	e0bffb03 	ldbu	r2,-20(fp)
}
 181cb84:	e037883a 	mov	sp,fp
 181cb88:	dfc00117 	ldw	ra,4(sp)
 181cb8c:	df000017 	ldw	fp,0(sp)
 181cb90:	dec00204 	addi	sp,sp,8
 181cb94:	f800283a 	ret

0181cb98 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 181cb98:	defff304 	addi	sp,sp,-52
 181cb9c:	dfc00c15 	stw	ra,48(sp)
 181cba0:	df000b15 	stw	fp,44(sp)
 181cba4:	dc000a15 	stw	r16,40(sp)
 181cba8:	df000b04 	addi	fp,sp,44
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 181cbac:	e03ff985 	stb	zero,-26(fp)

  ++tcp_ticks;
 181cbb0:	d0a7f817 	ldw	r2,-24608(gp)
 181cbb4:	10800044 	addi	r2,r2,1
 181cbb8:	d0a7f815 	stw	r2,-24608(gp)
  ++tcp_timer_ctr;
 181cbbc:	d0a7f643 	ldbu	r2,-24615(gp)
 181cbc0:	10800044 	addi	r2,r2,1
 181cbc4:	d0a7f645 	stb	r2,-24615(gp)

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 181cbc8:	e03ff815 	stw	zero,-32(fp)
  pcb = tcp_active_pcbs;
 181cbcc:	d0a7f717 	ldw	r2,-24612(gp)
 181cbd0:	e0bff715 	stw	r2,-36(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 181cbd4:	00018906 	br	181d1fc <tcp_slowtmr+0x664>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
 181cbd8:	e0bff717 	ldw	r2,-36(fp)
 181cbdc:	10c00943 	ldbu	r3,37(r2)
 181cbe0:	d0a7f643 	ldbu	r2,-24615(gp)
 181cbe4:	18c03fcc 	andi	r3,r3,255
 181cbe8:	10803fcc 	andi	r2,r2,255
 181cbec:	1880041e 	bne	r3,r2,181cc00 <tcp_slowtmr+0x68>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
 181cbf0:	e0bff717 	ldw	r2,-36(fp)
 181cbf4:	10800317 	ldw	r2,12(r2)
 181cbf8:	e0bff715 	stw	r2,-36(fp)
      continue;
 181cbfc:	00017f06 	br	181d1fc <tcp_slowtmr+0x664>
    }
    pcb->last_timer = tcp_timer_ctr;
 181cc00:	d0e7f643 	ldbu	r3,-24615(gp)
 181cc04:	e0bff717 	ldw	r2,-36(fp)
 181cc08:	10c00945 	stb	r3,37(r2)

    pcb_remove = 0;
 181cc0c:	e03ff905 	stb	zero,-28(fp)
    pcb_reset = 0;
 181cc10:	e03ff945 	stb	zero,-27(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 181cc14:	e0bff717 	ldw	r2,-36(fp)
 181cc18:	10800617 	ldw	r2,24(r2)
 181cc1c:	10800098 	cmpnei	r2,r2,2
 181cc20:	1000091e 	bne	r2,zero,181cc48 <tcp_slowtmr+0xb0>
 181cc24:	e0bff717 	ldw	r2,-36(fp)
 181cc28:	10801283 	ldbu	r2,74(r2)
 181cc2c:	10803fcc 	andi	r2,r2,255
 181cc30:	10800198 	cmpnei	r2,r2,6
 181cc34:	1000041e 	bne	r2,zero,181cc48 <tcp_slowtmr+0xb0>
      ++pcb_remove;
 181cc38:	e0bff903 	ldbu	r2,-28(fp)
 181cc3c:	10800044 	addi	r2,r2,1
 181cc40:	e0bff905 	stb	r2,-28(fp)
 181cc44:	00008d06 	br	181ce7c <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 181cc48:	e0bff717 	ldw	r2,-36(fp)
 181cc4c:	10801283 	ldbu	r2,74(r2)
 181cc50:	10803fcc 	andi	r2,r2,255
 181cc54:	10800318 	cmpnei	r2,r2,12
 181cc58:	1000041e 	bne	r2,zero,181cc6c <tcp_slowtmr+0xd4>
      ++pcb_remove;
 181cc5c:	e0bff903 	ldbu	r2,-28(fp)
 181cc60:	10800044 	addi	r2,r2,1
 181cc64:	e0bff905 	stb	r2,-28(fp)
 181cc68:	00008406 	br	181ce7c <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 181cc6c:	e0bff717 	ldw	r2,-36(fp)
 181cc70:	10802843 	ldbu	r2,161(r2)
 181cc74:	10803fcc 	andi	r2,r2,255
 181cc78:	10002226 	beq	r2,zero,181cd04 <tcp_slowtmr+0x16c>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 181cc7c:	e0bff717 	ldw	r2,-36(fp)
 181cc80:	10802803 	ldbu	r2,160(r2)
 181cc84:	10800044 	addi	r2,r2,1
 181cc88:	1007883a 	mov	r3,r2
 181cc8c:	e0bff717 	ldw	r2,-36(fp)
 181cc90:	10c02805 	stb	r3,160(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 181cc94:	e0bff717 	ldw	r2,-36(fp)
 181cc98:	11002803 	ldbu	r4,160(r2)
 181cc9c:	e0bff717 	ldw	r2,-36(fp)
 181cca0:	10802843 	ldbu	r2,161(r2)
 181cca4:	10803fcc 	andi	r2,r2,255
 181cca8:	10ffffc4 	addi	r3,r2,-1
 181ccac:	d0a00f84 	addi	r2,gp,-32706
 181ccb0:	1885883a 	add	r2,r3,r2
 181ccb4:	10800003 	ldbu	r2,0(r2)
 181ccb8:	20c03fcc 	andi	r3,r4,255
 181ccbc:	10803fcc 	andi	r2,r2,255
 181ccc0:	18806e36 	bltu	r3,r2,181ce7c <tcp_slowtmr+0x2e4>
          pcb->persist_cnt = 0;
 181ccc4:	e0bff717 	ldw	r2,-36(fp)
 181ccc8:	10002805 	stb	zero,160(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 181cccc:	e0bff717 	ldw	r2,-36(fp)
 181ccd0:	10802843 	ldbu	r2,161(r2)
 181ccd4:	10803fcc 	andi	r2,r2,255
 181ccd8:	108001e8 	cmpgeui	r2,r2,7
 181ccdc:	1000061e 	bne	r2,zero,181ccf8 <tcp_slowtmr+0x160>
            pcb->persist_backoff++;
 181cce0:	e0bff717 	ldw	r2,-36(fp)
 181cce4:	10802843 	ldbu	r2,161(r2)
 181cce8:	10800044 	addi	r2,r2,1
 181ccec:	1007883a 	mov	r3,r2
 181ccf0:	e0bff717 	ldw	r2,-36(fp)
 181ccf4:	10c02845 	stb	r3,161(r2)
          }
          tcp_zero_window_probe(pcb);
 181ccf8:	e13ff717 	ldw	r4,-36(fp)
 181ccfc:	182134c0 	call	182134c <tcp_zero_window_probe>
 181cd00:	00005e06 	br	181ce7c <tcp_slowtmr+0x2e4>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
 181cd04:	e0bff717 	ldw	r2,-36(fp)
 181cd08:	10800e0b 	ldhu	r2,56(r2)
 181cd0c:	10bfffcc 	andi	r2,r2,65535
 181cd10:	10a0001c 	xori	r2,r2,32768
 181cd14:	10a00004 	addi	r2,r2,-32768
 181cd18:	10000616 	blt	r2,zero,181cd34 <tcp_slowtmr+0x19c>
          ++pcb->rtime;
 181cd1c:	e0bff717 	ldw	r2,-36(fp)
 181cd20:	10800e0b 	ldhu	r2,56(r2)
 181cd24:	10800044 	addi	r2,r2,1
 181cd28:	1007883a 	mov	r3,r2
 181cd2c:	e0bff717 	ldw	r2,-36(fp)
 181cd30:	10c00e0d 	sth	r3,56(r2)
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 181cd34:	e0bff717 	ldw	r2,-36(fp)
 181cd38:	10801d17 	ldw	r2,116(r2)
 181cd3c:	10004f26 	beq	r2,zero,181ce7c <tcp_slowtmr+0x2e4>
 181cd40:	e0bff717 	ldw	r2,-36(fp)
 181cd44:	10c00e0b 	ldhu	r3,56(r2)
 181cd48:	e0bff717 	ldw	r2,-36(fp)
 181cd4c:	1080120b 	ldhu	r2,72(r2)
 181cd50:	18ffffcc 	andi	r3,r3,65535
 181cd54:	18e0001c 	xori	r3,r3,32768
 181cd58:	18e00004 	addi	r3,r3,-32768
 181cd5c:	10bfffcc 	andi	r2,r2,65535
 181cd60:	10a0001c 	xori	r2,r2,32768
 181cd64:	10a00004 	addi	r2,r2,-32768
 181cd68:	18804416 	blt	r3,r2,181ce7c <tcp_slowtmr+0x2e4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 181cd6c:	e0bff717 	ldw	r2,-36(fp)
 181cd70:	10800617 	ldw	r2,24(r2)
 181cd74:	108000a0 	cmpeqi	r2,r2,2
 181cd78:	10001b1e 	bne	r2,zero,181cde8 <tcp_slowtmr+0x250>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 181cd7c:	e0bff717 	ldw	r2,-36(fp)
 181cd80:	1080110b 	ldhu	r2,68(r2)
 181cd84:	10bfffcc 	andi	r2,r2,65535
 181cd88:	10a0001c 	xori	r2,r2,32768
 181cd8c:	10a00004 	addi	r2,r2,-32768
 181cd90:	1005d0fa 	srai	r2,r2,3
 181cd94:	10ffffcc 	andi	r3,r2,65535
 181cd98:	18e0001c 	xori	r3,r3,32768
 181cd9c:	18e00004 	addi	r3,r3,-32768
 181cda0:	e0bff717 	ldw	r2,-36(fp)
 181cda4:	1080118b 	ldhu	r2,70(r2)
 181cda8:	10bfffcc 	andi	r2,r2,65535
 181cdac:	10a0001c 	xori	r2,r2,32768
 181cdb0:	10a00004 	addi	r2,r2,-32768
 181cdb4:	1887883a 	add	r3,r3,r2
 181cdb8:	e0bff717 	ldw	r2,-36(fp)
 181cdbc:	10801283 	ldbu	r2,74(r2)
 181cdc0:	11003fcc 	andi	r4,r2,255
 181cdc4:	00806134 	movhi	r2,388
 181cdc8:	1086d804 	addi	r2,r2,7008
 181cdcc:	1105883a 	add	r2,r2,r4
 181cdd0:	10800003 	ldbu	r2,0(r2)
 181cdd4:	10803fcc 	andi	r2,r2,255
 181cdd8:	1884983a 	sll	r2,r3,r2
 181cddc:	1007883a 	mov	r3,r2
 181cde0:	e0bff717 	ldw	r2,-36(fp)
 181cde4:	10c0120d 	sth	r3,72(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 181cde8:	e0bff717 	ldw	r2,-36(fp)
 181cdec:	10000e0d 	sth	zero,56(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 181cdf0:	e0bff717 	ldw	r2,-36(fp)
 181cdf4:	10c0190b 	ldhu	r3,100(r2)
 181cdf8:	e0bff717 	ldw	r2,-36(fp)
 181cdfc:	1140140b 	ldhu	r5,80(r2)
 181ce00:	1805883a 	mov	r2,r3
 181ce04:	10ffffcc 	andi	r3,r2,65535
 181ce08:	293fffcc 	andi	r4,r5,65535
 181ce0c:	20c0012e 	bgeu	r4,r3,181ce14 <tcp_slowtmr+0x27c>
 181ce10:	2805883a 	mov	r2,r5
 181ce14:	e0bffa0d 	sth	r2,-24(fp)
          pcb->ssthresh = eff_wnd >> 1;
 181ce18:	e0bffa0b 	ldhu	r2,-24(fp)
 181ce1c:	1004d07a 	srli	r2,r2,1
 181ce20:	1007883a 	mov	r3,r2
 181ce24:	e0bff717 	ldw	r2,-36(fp)
 181ce28:	10c0148d 	sth	r3,82(r2)
          if (pcb->ssthresh < (pcb->mss << 1)) {
 181ce2c:	e0bff717 	ldw	r2,-36(fp)
 181ce30:	1080148b 	ldhu	r2,82(r2)
 181ce34:	10ffffcc 	andi	r3,r2,65535
 181ce38:	e0bff717 	ldw	r2,-36(fp)
 181ce3c:	10800e8b 	ldhu	r2,58(r2)
 181ce40:	10bfffcc 	andi	r2,r2,65535
 181ce44:	1085883a 	add	r2,r2,r2
 181ce48:	1880060e 	bge	r3,r2,181ce64 <tcp_slowtmr+0x2cc>
            pcb->ssthresh = (pcb->mss << 1);
 181ce4c:	e0bff717 	ldw	r2,-36(fp)
 181ce50:	10800e8b 	ldhu	r2,58(r2)
 181ce54:	1085883a 	add	r2,r2,r2
 181ce58:	1007883a 	mov	r3,r2
 181ce5c:	e0bff717 	ldw	r2,-36(fp)
 181ce60:	10c0148d 	sth	r3,82(r2)
          }
          pcb->cwnd = pcb->mss;
 181ce64:	e0bff717 	ldw	r2,-36(fp)
 181ce68:	10c00e8b 	ldhu	r3,58(r2)
 181ce6c:	e0bff717 	ldw	r2,-36(fp)
 181ce70:	10c0140d 	sth	r3,80(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 181ce74:	e13ff717 	ldw	r4,-36(fp)
 181ce78:	1820d340 	call	1820d34 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 181ce7c:	e0bff717 	ldw	r2,-36(fp)
 181ce80:	10800617 	ldw	r2,24(r2)
 181ce84:	10800198 	cmpnei	r2,r2,6
 181ce88:	10000e1e 	bne	r2,zero,181cec4 <tcp_slowtmr+0x32c>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 181ce8c:	e0bff717 	ldw	r2,-36(fp)
 181ce90:	10800883 	ldbu	r2,34(r2)
 181ce94:	10803fcc 	andi	r2,r2,255
 181ce98:	1080040c 	andi	r2,r2,16
 181ce9c:	10000926 	beq	r2,zero,181cec4 <tcp_slowtmr+0x32c>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 181cea0:	d0e7f817 	ldw	r3,-24608(gp)
 181cea4:	e0bff717 	ldw	r2,-36(fp)
 181cea8:	10800a17 	ldw	r2,40(r2)
 181ceac:	1885c83a 	sub	r2,r3,r2
 181ceb0:	10800a70 	cmpltui	r2,r2,41
 181ceb4:	1000031e 	bne	r2,zero,181cec4 <tcp_slowtmr+0x32c>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 181ceb8:	e0bff903 	ldbu	r2,-28(fp)
 181cebc:	10800044 	addi	r2,r2,1
 181cec0:	e0bff905 	stb	r2,-28(fp)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 181cec4:	e0bff717 	ldw	r2,-36(fp)
 181cec8:	10800203 	ldbu	r2,8(r2)
 181cecc:	10803fcc 	andi	r2,r2,255
 181ced0:	1080020c 	andi	r2,r2,8
 181ced4:	10003826 	beq	r2,zero,181cfb8 <tcp_slowtmr+0x420>
       ((pcb->state == ESTABLISHED) ||
 181ced8:	e0bff717 	ldw	r2,-36(fp)
 181cedc:	10800617 	ldw	r2,24(r2)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 181cee0:	10800120 	cmpeqi	r2,r2,4
 181cee4:	1000041e 	bne	r2,zero,181cef8 <tcp_slowtmr+0x360>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
 181cee8:	e0bff717 	ldw	r2,-36(fp)
 181ceec:	10800617 	ldw	r2,24(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
 181cef0:	108001d8 	cmpnei	r2,r2,7
 181cef4:	1000301e 	bne	r2,zero,181cfb8 <tcp_slowtmr+0x420>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 181cef8:	d0e7f817 	ldw	r3,-24608(gp)
 181cefc:	e0bff717 	ldw	r2,-36(fp)
 181cf00:	10800a17 	ldw	r2,40(r2)
 181cf04:	18a1c83a 	sub	r16,r3,r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 181cf08:	e0bff717 	ldw	r2,-36(fp)
 181cf0c:	10c02517 	ldw	r3,148(r2)
 181cf10:	e0bff717 	ldw	r2,-36(fp)
 181cf14:	11002717 	ldw	r4,156(r2)
 181cf18:	e0bff717 	ldw	r2,-36(fp)
 181cf1c:	10802617 	ldw	r2,152(r2)
 181cf20:	2085383a 	mul	r2,r4,r2
 181cf24:	1885883a 	add	r2,r3,r2
 181cf28:	01407d04 	movi	r5,500
 181cf2c:	1009883a 	mov	r4,r2
 181cf30:	180ad100 	call	180ad10 <__udivsi3>

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 181cf34:	1400072e 	bgeu	r2,r16,181cf54 <tcp_slowtmr+0x3bc>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
 181cf38:	e0bff903 	ldbu	r2,-28(fp)
 181cf3c:	10800044 	addi	r2,r2,1
 181cf40:	e0bff905 	stb	r2,-28(fp)
        ++pcb_reset;
 181cf44:	e0bff943 	ldbu	r2,-27(fp)
 181cf48:	10800044 	addi	r2,r2,1
 181cf4c:	e0bff945 	stb	r2,-27(fp)
 181cf50:	00001906 	br	181cfb8 <tcp_slowtmr+0x420>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 181cf54:	d0e7f817 	ldw	r3,-24608(gp)
 181cf58:	e0bff717 	ldw	r2,-36(fp)
 181cf5c:	10800a17 	ldw	r2,40(r2)
 181cf60:	18a1c83a 	sub	r16,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 181cf64:	e0bff717 	ldw	r2,-36(fp)
 181cf68:	10c02517 	ldw	r3,148(r2)
 181cf6c:	e0bff717 	ldw	r2,-36(fp)
 181cf70:	10802883 	ldbu	r2,162(r2)
 181cf74:	11003fcc 	andi	r4,r2,255
 181cf78:	e0bff717 	ldw	r2,-36(fp)
 181cf7c:	10802617 	ldw	r2,152(r2)
 181cf80:	2085383a 	mul	r2,r4,r2
 181cf84:	1885883a 	add	r2,r3,r2
              / TCP_SLOW_INTERVAL)
 181cf88:	01407d04 	movi	r5,500
 181cf8c:	1009883a 	mov	r4,r2
 181cf90:	180ad100 	call	180ad10 <__udivsi3>
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 181cf94:	1400082e 	bgeu	r2,r16,181cfb8 <tcp_slowtmr+0x420>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
 181cf98:	e13ff717 	ldw	r4,-36(fp)
 181cf9c:	18211b80 	call	18211b8 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 181cfa0:	e0bff717 	ldw	r2,-36(fp)
 181cfa4:	10802883 	ldbu	r2,162(r2)
 181cfa8:	10800044 	addi	r2,r2,1
 181cfac:	1007883a 	mov	r3,r2
 181cfb0:	e0bff717 	ldw	r2,-36(fp)
 181cfb4:	10c02885 	stb	r3,162(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 181cfb8:	e0bff717 	ldw	r2,-36(fp)
 181cfbc:	10801e17 	ldw	r2,120(r2)
 181cfc0:	10001126 	beq	r2,zero,181d008 <tcp_slowtmr+0x470>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 181cfc4:	d0e7f817 	ldw	r3,-24608(gp)
 181cfc8:	e0bff717 	ldw	r2,-36(fp)
 181cfcc:	10800a17 	ldw	r2,40(r2)
 181cfd0:	1887c83a 	sub	r3,r3,r2
 181cfd4:	e0bff717 	ldw	r2,-36(fp)
 181cfd8:	1080120b 	ldhu	r2,72(r2)
 181cfdc:	10bfffcc 	andi	r2,r2,65535
 181cfe0:	10a0001c 	xori	r2,r2,32768
 181cfe4:	10a00004 	addi	r2,r2,-32768
 181cfe8:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 181cfec:	18800636 	bltu	r3,r2,181d008 <tcp_slowtmr+0x470>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
 181cff0:	e0bff717 	ldw	r2,-36(fp)
 181cff4:	10801e17 	ldw	r2,120(r2)
 181cff8:	1009883a 	mov	r4,r2
 181cffc:	181d5180 	call	181d518 <tcp_segs_free>
      pcb->ooseq = NULL;
 181d000:	e0bff717 	ldw	r2,-36(fp)
 181d004:	10001e15 	stw	zero,120(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 181d008:	e0bff717 	ldw	r2,-36(fp)
 181d00c:	10800617 	ldw	r2,24(r2)
 181d010:	108000d8 	cmpnei	r2,r2,3
 181d014:	1000091e 	bne	r2,zero,181d03c <tcp_slowtmr+0x4a4>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 181d018:	d0e7f817 	ldw	r3,-24608(gp)
 181d01c:	e0bff717 	ldw	r2,-36(fp)
 181d020:	10800a17 	ldw	r2,40(r2)
 181d024:	1885c83a 	sub	r2,r3,r2
 181d028:	10800a70 	cmpltui	r2,r2,41
 181d02c:	1000031e 	bne	r2,zero,181d03c <tcp_slowtmr+0x4a4>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 181d030:	e0bff903 	ldbu	r2,-28(fp)
 181d034:	10800044 	addi	r2,r2,1
 181d038:	e0bff905 	stb	r2,-28(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 181d03c:	e0bff717 	ldw	r2,-36(fp)
 181d040:	10800617 	ldw	r2,24(r2)
 181d044:	10800258 	cmpnei	r2,r2,9
 181d048:	1000091e 	bne	r2,zero,181d070 <tcp_slowtmr+0x4d8>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 181d04c:	d0e7f817 	ldw	r3,-24608(gp)
 181d050:	e0bff717 	ldw	r2,-36(fp)
 181d054:	10800a17 	ldw	r2,40(r2)
 181d058:	1885c83a 	sub	r2,r3,r2
 181d05c:	10803c70 	cmpltui	r2,r2,241
 181d060:	1000031e 	bne	r2,zero,181d070 <tcp_slowtmr+0x4d8>
        ++pcb_remove;
 181d064:	e0bff903 	ldbu	r2,-28(fp)
 181d068:	10800044 	addi	r2,r2,1
 181d06c:	e0bff905 	stb	r2,-28(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 181d070:	e0bff903 	ldbu	r2,-28(fp)
 181d074:	10003726 	beq	r2,zero,181d154 <tcp_slowtmr+0x5bc>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
 181d078:	e13ff717 	ldw	r4,-36(fp)
 181d07c:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 181d080:	e0bff817 	ldw	r2,-32(fp)
 181d084:	10000526 	beq	r2,zero,181d09c <tcp_slowtmr+0x504>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 181d088:	e0bff717 	ldw	r2,-36(fp)
 181d08c:	10c00317 	ldw	r3,12(r2)
 181d090:	e0bff817 	ldw	r2,-32(fp)
 181d094:	10c00315 	stw	r3,12(r2)
 181d098:	00000306 	br	181d0a8 <tcp_slowtmr+0x510>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 181d09c:	e0bff717 	ldw	r2,-36(fp)
 181d0a0:	10800317 	ldw	r2,12(r2)
 181d0a4:	d0a7f715 	stw	r2,-24612(gp)
      }

      if (pcb_reset) {
 181d0a8:	e0bff943 	ldbu	r2,-27(fp)
 181d0ac:	10001026 	beq	r2,zero,181d0f0 <tcp_slowtmr+0x558>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181d0b0:	e0bff717 	ldw	r2,-36(fp)
 181d0b4:	11001517 	ldw	r4,84(r2)
 181d0b8:	e0bff717 	ldw	r2,-36(fp)
 181d0bc:	11400b17 	ldw	r5,44(r2)
 181d0c0:	e1bff717 	ldw	r6,-36(fp)
 181d0c4:	e0bff717 	ldw	r2,-36(fp)
 181d0c8:	11c00104 	addi	r7,r2,4
          pcb->local_port, pcb->remote_port);
 181d0cc:	e0bff717 	ldw	r2,-36(fp)
 181d0d0:	1080078b 	ldhu	r2,30(r2)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181d0d4:	10bfffcc 	andi	r2,r2,65535
          pcb->local_port, pcb->remote_port);
 181d0d8:	e0fff717 	ldw	r3,-36(fp)
 181d0dc:	18c0080b 	ldhu	r3,32(r3)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 181d0e0:	18ffffcc 	andi	r3,r3,65535
 181d0e4:	d8c00115 	stw	r3,4(sp)
 181d0e8:	d8800015 	stw	r2,0(sp)
 181d0ec:	18209680 	call	1820968 <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
 181d0f0:	e0bff717 	ldw	r2,-36(fp)
 181d0f4:	10802417 	ldw	r2,144(r2)
 181d0f8:	e0bffb15 	stw	r2,-20(fp)
      err_arg = pcb->callback_arg;
 181d0fc:	e0bff717 	ldw	r2,-36(fp)
 181d100:	10800417 	ldw	r2,16(r2)
 181d104:	e0bffc15 	stw	r2,-16(fp)
      pcb2 = pcb;
 181d108:	e0bff717 	ldw	r2,-36(fp)
 181d10c:	e0bffd15 	stw	r2,-12(fp)
      pcb = pcb->next;
 181d110:	e0bff717 	ldw	r2,-36(fp)
 181d114:	10800317 	ldw	r2,12(r2)
 181d118:	e0bff715 	stw	r2,-36(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
 181d11c:	e17ffd17 	ldw	r5,-12(fp)
 181d120:	01000084 	movi	r4,2
 181d124:	1834b240 	call	1834b24 <memp_free>

      tcp_active_pcbs_changed = 0;
 181d128:	d027f685 	stb	zero,-24614(gp)
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 181d12c:	e0bffb17 	ldw	r2,-20(fp)
 181d130:	10000426 	beq	r2,zero,181d144 <tcp_slowtmr+0x5ac>
 181d134:	e0bffb17 	ldw	r2,-20(fp)
 181d138:	017ffd84 	movi	r5,-10
 181d13c:	e13ffc17 	ldw	r4,-16(fp)
 181d140:	103ee83a 	callr	r2
      if (tcp_active_pcbs_changed) {
 181d144:	d0a7f683 	ldbu	r2,-24614(gp)
 181d148:	10803fcc 	andi	r2,r2,255
 181d14c:	10002b26 	beq	r2,zero,181d1fc <tcp_slowtmr+0x664>
        goto tcp_slowtmr_start;
 181d150:	003e9d06 	br	181cbc8 <__ram_exceptions_end+0xff80c784>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 181d154:	e0bff717 	ldw	r2,-36(fp)
 181d158:	e0bff815 	stw	r2,-32(fp)
      pcb = pcb->next;
 181d15c:	e0bff717 	ldw	r2,-36(fp)
 181d160:	10800317 	ldw	r2,12(r2)
 181d164:	e0bff715 	stw	r2,-36(fp)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 181d168:	e0bff817 	ldw	r2,-32(fp)
 181d16c:	108008c3 	ldbu	r2,35(r2)
 181d170:	10800044 	addi	r2,r2,1
 181d174:	1007883a 	mov	r3,r2
 181d178:	e0bff817 	ldw	r2,-32(fp)
 181d17c:	10c008c5 	stb	r3,35(r2)
      if (prev->polltmr >= prev->pollinterval) {
 181d180:	e0bff817 	ldw	r2,-32(fp)
 181d184:	10c008c3 	ldbu	r3,35(r2)
 181d188:	e0bff817 	ldw	r2,-32(fp)
 181d18c:	10800903 	ldbu	r2,36(r2)
 181d190:	18c03fcc 	andi	r3,r3,255
 181d194:	10803fcc 	andi	r2,r2,255
 181d198:	18801836 	bltu	r3,r2,181d1fc <tcp_slowtmr+0x664>
        prev->polltmr = 0;
 181d19c:	e0bff817 	ldw	r2,-32(fp)
 181d1a0:	100008c5 	stb	zero,35(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 181d1a4:	d027f685 	stb	zero,-24614(gp)
        TCP_EVENT_POLL(prev, err);
 181d1a8:	e0bff817 	ldw	r2,-32(fp)
 181d1ac:	10802317 	ldw	r2,140(r2)
 181d1b0:	10000926 	beq	r2,zero,181d1d8 <tcp_slowtmr+0x640>
 181d1b4:	e0bff817 	ldw	r2,-32(fp)
 181d1b8:	10802317 	ldw	r2,140(r2)
 181d1bc:	e0fff817 	ldw	r3,-32(fp)
 181d1c0:	18c00417 	ldw	r3,16(r3)
 181d1c4:	e17ff817 	ldw	r5,-32(fp)
 181d1c8:	1809883a 	mov	r4,r3
 181d1cc:	103ee83a 	callr	r2
 181d1d0:	e0bff985 	stb	r2,-26(fp)
 181d1d4:	00000106 	br	181d1dc <tcp_slowtmr+0x644>
 181d1d8:	e03ff985 	stb	zero,-26(fp)
        if (tcp_active_pcbs_changed) {
 181d1dc:	d0a7f683 	ldbu	r2,-24614(gp)
 181d1e0:	10803fcc 	andi	r2,r2,255
 181d1e4:	10000126 	beq	r2,zero,181d1ec <tcp_slowtmr+0x654>
          goto tcp_slowtmr_start;
 181d1e8:	003e7706 	br	181cbc8 <__ram_exceptions_end+0xff80c784>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 181d1ec:	e0bff987 	ldb	r2,-26(fp)
 181d1f0:	1000021e 	bne	r2,zero,181d1fc <tcp_slowtmr+0x664>
          tcp_output(prev);
 181d1f4:	e13ff817 	ldw	r4,-32(fp)
 181d1f8:	181f8bc0 	call	181f8bc <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 181d1fc:	e0bff717 	ldw	r2,-36(fp)
 181d200:	103e751e 	bne	r2,zero,181cbd8 <__ram_exceptions_end+0xff80c794>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 181d204:	e03ff815 	stw	zero,-32(fp)
  pcb = tcp_tw_pcbs;
 181d208:	d0a7fc17 	ldw	r2,-24592(gp)
 181d20c:	e0bff715 	stw	r2,-36(fp)
  while (pcb != NULL) {
 181d210:	00002606 	br	181d2ac <tcp_slowtmr+0x714>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
 181d214:	e03ff905 	stb	zero,-28(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 181d218:	d0e7f817 	ldw	r3,-24608(gp)
 181d21c:	e0bff717 	ldw	r2,-36(fp)
 181d220:	10800a17 	ldw	r2,40(r2)
 181d224:	1885c83a 	sub	r2,r3,r2
 181d228:	10803c70 	cmpltui	r2,r2,241
 181d22c:	1000031e 	bne	r2,zero,181d23c <tcp_slowtmr+0x6a4>
      ++pcb_remove;
 181d230:	e0bff903 	ldbu	r2,-28(fp)
 181d234:	10800044 	addi	r2,r2,1
 181d238:	e0bff905 	stb	r2,-28(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 181d23c:	e0bff903 	ldbu	r2,-28(fp)
 181d240:	10001526 	beq	r2,zero,181d298 <tcp_slowtmr+0x700>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 181d244:	e13ff717 	ldw	r4,-36(fp)
 181d248:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 181d24c:	e0bff817 	ldw	r2,-32(fp)
 181d250:	10000526 	beq	r2,zero,181d268 <tcp_slowtmr+0x6d0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 181d254:	e0bff717 	ldw	r2,-36(fp)
 181d258:	10c00317 	ldw	r3,12(r2)
 181d25c:	e0bff817 	ldw	r2,-32(fp)
 181d260:	10c00315 	stw	r3,12(r2)
 181d264:	00000306 	br	181d274 <tcp_slowtmr+0x6dc>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 181d268:	e0bff717 	ldw	r2,-36(fp)
 181d26c:	10800317 	ldw	r2,12(r2)
 181d270:	d0a7fc15 	stw	r2,-24592(gp)
      }
      pcb2 = pcb;
 181d274:	e0bff717 	ldw	r2,-36(fp)
 181d278:	e0bffe15 	stw	r2,-8(fp)
      pcb = pcb->next;
 181d27c:	e0bff717 	ldw	r2,-36(fp)
 181d280:	10800317 	ldw	r2,12(r2)
 181d284:	e0bff715 	stw	r2,-36(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
 181d288:	e17ffe17 	ldw	r5,-8(fp)
 181d28c:	01000084 	movi	r4,2
 181d290:	1834b240 	call	1834b24 <memp_free>
 181d294:	00000506 	br	181d2ac <tcp_slowtmr+0x714>
    } else {
      prev = pcb;
 181d298:	e0bff717 	ldw	r2,-36(fp)
 181d29c:	e0bff815 	stw	r2,-32(fp)
      pcb = pcb->next;
 181d2a0:	e0bff717 	ldw	r2,-36(fp)
 181d2a4:	10800317 	ldw	r2,12(r2)
 181d2a8:	e0bff715 	stw	r2,-36(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 181d2ac:	e0bff717 	ldw	r2,-36(fp)
 181d2b0:	103fd81e 	bne	r2,zero,181d214 <__ram_exceptions_end+0xff80cdd0>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 181d2b4:	0001883a 	nop
 181d2b8:	e6ffff04 	addi	sp,fp,-4
 181d2bc:	dfc00217 	ldw	ra,8(sp)
 181d2c0:	df000117 	ldw	fp,4(sp)
 181d2c4:	dc000017 	ldw	r16,0(sp)
 181d2c8:	dec00304 	addi	sp,sp,12
 181d2cc:	f800283a 	ret

0181d2d0 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 181d2d0:	defffc04 	addi	sp,sp,-16
 181d2d4:	dfc00315 	stw	ra,12(sp)
 181d2d8:	df000215 	stw	fp,8(sp)
 181d2dc:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 181d2e0:	d0a7f643 	ldbu	r2,-24615(gp)
 181d2e4:	10800044 	addi	r2,r2,1
 181d2e8:	d0a7f645 	stb	r2,-24615(gp)

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 181d2ec:	d0a7f717 	ldw	r2,-24612(gp)
 181d2f0:	e0bffe15 	stw	r2,-8(fp)

  while(pcb != NULL) {
 181d2f4:	00002c06 	br	181d3a8 <tcp_fasttmr+0xd8>
    if (pcb->last_timer != tcp_timer_ctr) {
 181d2f8:	e0bffe17 	ldw	r2,-8(fp)
 181d2fc:	10c00943 	ldbu	r3,37(r2)
 181d300:	d0a7f643 	ldbu	r2,-24615(gp)
 181d304:	18c03fcc 	andi	r3,r3,255
 181d308:	10803fcc 	andi	r2,r2,255
 181d30c:	18802626 	beq	r3,r2,181d3a8 <tcp_fasttmr+0xd8>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 181d310:	d0e7f643 	ldbu	r3,-24615(gp)
 181d314:	e0bffe17 	ldw	r2,-8(fp)
 181d318:	10c00945 	stb	r3,37(r2)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 181d31c:	e0bffe17 	ldw	r2,-8(fp)
 181d320:	10800883 	ldbu	r2,34(r2)
 181d324:	10803fcc 	andi	r2,r2,255
 181d328:	1080004c 	andi	r2,r2,1
 181d32c:	10000f26 	beq	r2,zero,181d36c <tcp_fasttmr+0x9c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 181d330:	e0bffe17 	ldw	r2,-8(fp)
 181d334:	10800883 	ldbu	r2,34(r2)
 181d338:	10800094 	ori	r2,r2,2
 181d33c:	1007883a 	mov	r3,r2
 181d340:	e0bffe17 	ldw	r2,-8(fp)
 181d344:	10c00885 	stb	r3,34(r2)
        tcp_output(pcb);
 181d348:	e13ffe17 	ldw	r4,-8(fp)
 181d34c:	181f8bc0 	call	181f8bc <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 181d350:	e0bffe17 	ldw	r2,-8(fp)
 181d354:	10c00883 	ldbu	r3,34(r2)
 181d358:	00bfff04 	movi	r2,-4
 181d35c:	1884703a 	and	r2,r3,r2
 181d360:	1007883a 	mov	r3,r2
 181d364:	e0bffe17 	ldw	r2,-8(fp)
 181d368:	10c00885 	stb	r3,34(r2)
      }

      next = pcb->next;
 181d36c:	e0bffe17 	ldw	r2,-8(fp)
 181d370:	10800317 	ldw	r2,12(r2)
 181d374:	e0bfff15 	stw	r2,-4(fp)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 181d378:	e0bffe17 	ldw	r2,-8(fp)
 181d37c:	10801f17 	ldw	r2,124(r2)
 181d380:	10000726 	beq	r2,zero,181d3a0 <tcp_fasttmr+0xd0>
        tcp_active_pcbs_changed = 0;
 181d384:	d027f685 	stb	zero,-24614(gp)
        tcp_process_refused_data(pcb);
 181d388:	e13ffe17 	ldw	r4,-8(fp)
 181d38c:	181d3c80 	call	181d3c8 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 181d390:	d0a7f683 	ldbu	r2,-24614(gp)
 181d394:	10803fcc 	andi	r2,r2,255
 181d398:	10000126 	beq	r2,zero,181d3a0 <tcp_fasttmr+0xd0>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 181d39c:	003fd306 	br	181d2ec <__ram_exceptions_end+0xff80cea8>
        }
      }
      pcb = next;
 181d3a0:	e0bfff17 	ldw	r2,-4(fp)
 181d3a4:	e0bffe15 	stw	r2,-8(fp)
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
 181d3a8:	e0bffe17 	ldw	r2,-8(fp)
 181d3ac:	103fd21e 	bne	r2,zero,181d2f8 <__ram_exceptions_end+0xff80ceb4>
        }
      }
      pcb = next;
    }
  }
}
 181d3b0:	0001883a 	nop
 181d3b4:	e037883a 	mov	sp,fp
 181d3b8:	dfc00117 	ldw	ra,4(sp)
 181d3bc:	df000017 	ldw	fp,0(sp)
 181d3c0:	dec00204 	addi	sp,sp,8
 181d3c4:	f800283a 	ret

0181d3c8 <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 181d3c8:	defffb04 	addi	sp,sp,-20
 181d3cc:	dfc00415 	stw	ra,16(sp)
 181d3d0:	df000315 	stw	fp,12(sp)
 181d3d4:	df000304 	addi	fp,sp,12
 181d3d8:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 181d3dc:	e0bfff17 	ldw	r2,-4(fp)
 181d3e0:	10801f17 	ldw	r2,124(r2)
 181d3e4:	10800343 	ldbu	r2,13(r2)
 181d3e8:	e0bffd45 	stb	r2,-11(fp)
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
 181d3ec:	e0bfff17 	ldw	r2,-4(fp)
 181d3f0:	10801f17 	ldw	r2,124(r2)
 181d3f4:	e0bffe15 	stw	r2,-8(fp)
  pcb->refused_data = NULL;
 181d3f8:	e0bfff17 	ldw	r2,-4(fp)
 181d3fc:	10001f15 	stw	zero,124(r2)
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 181d400:	e0bfff17 	ldw	r2,-4(fp)
 181d404:	10802117 	ldw	r2,132(r2)
 181d408:	10000b26 	beq	r2,zero,181d438 <tcp_process_refused_data+0x70>
 181d40c:	e0bfff17 	ldw	r2,-4(fp)
 181d410:	10802117 	ldw	r2,132(r2)
 181d414:	e0ffff17 	ldw	r3,-4(fp)
 181d418:	18c00417 	ldw	r3,16(r3)
 181d41c:	000f883a 	mov	r7,zero
 181d420:	e1bffe17 	ldw	r6,-8(fp)
 181d424:	e17fff17 	ldw	r5,-4(fp)
 181d428:	1809883a 	mov	r4,r3
 181d42c:	103ee83a 	callr	r2
 181d430:	e0bffd05 	stb	r2,-12(fp)
 181d434:	00000606 	br	181d450 <tcp_process_refused_data+0x88>
 181d438:	000f883a 	mov	r7,zero
 181d43c:	e1bffe17 	ldw	r6,-8(fp)
 181d440:	e17fff17 	ldw	r5,-4(fp)
 181d444:	0009883a 	mov	r4,zero
 181d448:	181d6680 	call	181d668 <tcp_recv_null>
 181d44c:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
 181d450:	e0bffd07 	ldb	r2,-12(fp)
 181d454:	1000221e 	bne	r2,zero,181d4e0 <tcp_process_refused_data+0x118>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 181d458:	e0bffd43 	ldbu	r2,-11(fp)
 181d45c:	1080080c 	andi	r2,r2,32
 181d460:	10002726 	beq	r2,zero,181d500 <tcp_process_refused_data+0x138>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 181d464:	e0bfff17 	ldw	r2,-4(fp)
 181d468:	10800c0b 	ldhu	r2,48(r2)
 181d46c:	10bfffcc 	andi	r2,r2,65535
 181d470:	10880020 	cmpeqi	r2,r2,8192
 181d474:	1000061e 	bne	r2,zero,181d490 <tcp_process_refused_data+0xc8>
        pcb->rcv_wnd++;
 181d478:	e0bfff17 	ldw	r2,-4(fp)
 181d47c:	10800c0b 	ldhu	r2,48(r2)
 181d480:	10800044 	addi	r2,r2,1
 181d484:	1007883a 	mov	r3,r2
 181d488:	e0bfff17 	ldw	r2,-4(fp)
 181d48c:	10c00c0d 	sth	r3,48(r2)
      }
      TCP_EVENT_CLOSED(pcb, err);
 181d490:	e0bfff17 	ldw	r2,-4(fp)
 181d494:	10802117 	ldw	r2,132(r2)
 181d498:	10000b26 	beq	r2,zero,181d4c8 <tcp_process_refused_data+0x100>
 181d49c:	e0bfff17 	ldw	r2,-4(fp)
 181d4a0:	10802117 	ldw	r2,132(r2)
 181d4a4:	e0ffff17 	ldw	r3,-4(fp)
 181d4a8:	18c00417 	ldw	r3,16(r3)
 181d4ac:	000f883a 	mov	r7,zero
 181d4b0:	000d883a 	mov	r6,zero
 181d4b4:	e17fff17 	ldw	r5,-4(fp)
 181d4b8:	1809883a 	mov	r4,r3
 181d4bc:	103ee83a 	callr	r2
 181d4c0:	e0bffd05 	stb	r2,-12(fp)
 181d4c4:	00000106 	br	181d4cc <tcp_process_refused_data+0x104>
 181d4c8:	e03ffd05 	stb	zero,-12(fp)
      if (err == ERR_ABRT) {
 181d4cc:	e0bffd07 	ldb	r2,-12(fp)
 181d4d0:	10bffd98 	cmpnei	r2,r2,-10
 181d4d4:	10000a1e 	bne	r2,zero,181d500 <tcp_process_refused_data+0x138>
        return ERR_ABRT;
 181d4d8:	00bffd84 	movi	r2,-10
 181d4dc:	00000906 	br	181d504 <tcp_process_refused_data+0x13c>
      }
    }
  } else if (err == ERR_ABRT) {
 181d4e0:	e0bffd07 	ldb	r2,-12(fp)
 181d4e4:	10bffd98 	cmpnei	r2,r2,-10
 181d4e8:	1000021e 	bne	r2,zero,181d4f4 <tcp_process_refused_data+0x12c>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
 181d4ec:	00bffd84 	movi	r2,-10
 181d4f0:	00000406 	br	181d504 <tcp_process_refused_data+0x13c>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
 181d4f4:	e0bfff17 	ldw	r2,-4(fp)
 181d4f8:	e0fffe17 	ldw	r3,-8(fp)
 181d4fc:	10c01f15 	stw	r3,124(r2)
  }
  return ERR_OK;
 181d500:	0005883a 	mov	r2,zero
}
 181d504:	e037883a 	mov	sp,fp
 181d508:	dfc00117 	ldw	ra,4(sp)
 181d50c:	df000017 	ldw	fp,0(sp)
 181d510:	dec00204 	addi	sp,sp,8
 181d514:	f800283a 	ret

0181d518 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 181d518:	defffc04 	addi	sp,sp,-16
 181d51c:	dfc00315 	stw	ra,12(sp)
 181d520:	df000215 	stw	fp,8(sp)
 181d524:	df000204 	addi	fp,sp,8
 181d528:	e13fff15 	stw	r4,-4(fp)
  while (seg != NULL) {
 181d52c:	00000706 	br	181d54c <tcp_segs_free+0x34>
    struct tcp_seg *next = seg->next;
 181d530:	e0bfff17 	ldw	r2,-4(fp)
 181d534:	10800017 	ldw	r2,0(r2)
 181d538:	e0bffe15 	stw	r2,-8(fp)
    tcp_seg_free(seg);
 181d53c:	e13fff17 	ldw	r4,-4(fp)
 181d540:	181d56c0 	call	181d56c <tcp_seg_free>
    seg = next;
 181d544:	e0bffe17 	ldw	r2,-8(fp)
 181d548:	e0bfff15 	stw	r2,-4(fp)
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 181d54c:	e0bfff17 	ldw	r2,-4(fp)
 181d550:	103ff71e 	bne	r2,zero,181d530 <__ram_exceptions_end+0xff80d0ec>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
 181d554:	0001883a 	nop
 181d558:	e037883a 	mov	sp,fp
 181d55c:	dfc00117 	ldw	ra,4(sp)
 181d560:	df000017 	ldw	fp,0(sp)
 181d564:	dec00204 	addi	sp,sp,8
 181d568:	f800283a 	ret

0181d56c <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 181d56c:	defffd04 	addi	sp,sp,-12
 181d570:	dfc00215 	stw	ra,8(sp)
 181d574:	df000115 	stw	fp,4(sp)
 181d578:	df000104 	addi	fp,sp,4
 181d57c:	e13fff15 	stw	r4,-4(fp)
  if (seg != NULL) {
 181d580:	e0bfff17 	ldw	r2,-4(fp)
 181d584:	10000a26 	beq	r2,zero,181d5b0 <tcp_seg_free+0x44>
    if (seg->p != NULL) {
 181d588:	e0bfff17 	ldw	r2,-4(fp)
 181d58c:	10800117 	ldw	r2,4(r2)
 181d590:	10000426 	beq	r2,zero,181d5a4 <tcp_seg_free+0x38>
      pbuf_free(seg->p);
 181d594:	e0bfff17 	ldw	r2,-4(fp)
 181d598:	10800117 	ldw	r2,4(r2)
 181d59c:	1009883a 	mov	r4,r2
 181d5a0:	181aca40 	call	181aca4 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 181d5a4:	e17fff17 	ldw	r5,-4(fp)
 181d5a8:	01000104 	movi	r4,4
 181d5ac:	1834b240 	call	1834b24 <memp_free>
  }
}
 181d5b0:	0001883a 	nop
 181d5b4:	e037883a 	mov	sp,fp
 181d5b8:	dfc00117 	ldw	ra,4(sp)
 181d5bc:	df000017 	ldw	fp,0(sp)
 181d5c0:	dec00204 	addi	sp,sp,8
 181d5c4:	f800283a 	ret

0181d5c8 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
 181d5c8:	defffd04 	addi	sp,sp,-12
 181d5cc:	df000215 	stw	fp,8(sp)
 181d5d0:	df000204 	addi	fp,sp,8
 181d5d4:	e13ffe15 	stw	r4,-8(fp)
 181d5d8:	2805883a 	mov	r2,r5
 181d5dc:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
 181d5e0:	e0bffe17 	ldw	r2,-8(fp)
 181d5e4:	e0ffff03 	ldbu	r3,-4(fp)
 181d5e8:	10c00705 	stb	r3,28(r2)
}
 181d5ec:	0001883a 	nop
 181d5f0:	e037883a 	mov	sp,fp
 181d5f4:	df000017 	ldw	fp,0(sp)
 181d5f8:	dec00104 	addi	sp,sp,4
 181d5fc:	f800283a 	ret

0181d600 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 181d600:	defffc04 	addi	sp,sp,-16
 181d604:	dfc00315 	stw	ra,12(sp)
 181d608:	df000215 	stw	fp,8(sp)
 181d60c:	df000204 	addi	fp,sp,8
 181d610:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 181d614:	01000104 	movi	r4,4
 181d618:	18349580 	call	1834958 <memp_malloc>
 181d61c:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
 181d620:	e0bffe17 	ldw	r2,-8(fp)
 181d624:	1000021e 	bne	r2,zero,181d630 <tcp_seg_copy+0x30>
    return NULL;
 181d628:	0005883a 	mov	r2,zero
 181d62c:	00000906 	br	181d654 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 181d630:	01800504 	movi	r6,20
 181d634:	e17fff17 	ldw	r5,-4(fp)
 181d638:	e13ffe17 	ldw	r4,-8(fp)
 181d63c:	180608c0 	call	180608c <memcpy>
  pbuf_ref(cseg->p);
 181d640:	e0bffe17 	ldw	r2,-8(fp)
 181d644:	10800117 	ldw	r2,4(r2)
 181d648:	1009883a 	mov	r4,r2
 181d64c:	181ae340 	call	181ae34 <pbuf_ref>
  return cseg;
 181d650:	e0bffe17 	ldw	r2,-8(fp)
}
 181d654:	e037883a 	mov	sp,fp
 181d658:	dfc00117 	ldw	ra,4(sp)
 181d65c:	df000017 	ldw	fp,0(sp)
 181d660:	dec00204 	addi	sp,sp,8
 181d664:	f800283a 	ret

0181d668 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 181d668:	defffa04 	addi	sp,sp,-24
 181d66c:	dfc00515 	stw	ra,20(sp)
 181d670:	df000415 	stw	fp,16(sp)
 181d674:	df000404 	addi	fp,sp,16
 181d678:	e13ffc15 	stw	r4,-16(fp)
 181d67c:	e17ffd15 	stw	r5,-12(fp)
 181d680:	e1bffe15 	stw	r6,-8(fp)
 181d684:	3805883a 	mov	r2,r7
 181d688:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 181d68c:	e0bffe17 	ldw	r2,-8(fp)
 181d690:	10000926 	beq	r2,zero,181d6b8 <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
 181d694:	e0bffe17 	ldw	r2,-8(fp)
 181d698:	1080020b 	ldhu	r2,8(r2)
 181d69c:	10bfffcc 	andi	r2,r2,65535
 181d6a0:	100b883a 	mov	r5,r2
 181d6a4:	e13ffd17 	ldw	r4,-12(fp)
 181d6a8:	181c6800 	call	181c680 <tcp_recved>
    pbuf_free(p);
 181d6ac:	e13ffe17 	ldw	r4,-8(fp)
 181d6b0:	181aca40 	call	181aca4 <pbuf_free>
 181d6b4:	00000506 	br	181d6cc <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
 181d6b8:	e0bfff07 	ldb	r2,-4(fp)
 181d6bc:	1000031e 	bne	r2,zero,181d6cc <tcp_recv_null+0x64>
    return tcp_close(pcb);
 181d6c0:	e13ffd17 	ldw	r4,-12(fp)
 181d6c4:	181be440 	call	181be44 <tcp_close>
 181d6c8:	00000106 	br	181d6d0 <tcp_recv_null+0x68>
  }
  return ERR_OK;
 181d6cc:	0005883a 	mov	r2,zero
}
 181d6d0:	e037883a 	mov	sp,fp
 181d6d4:	dfc00117 	ldw	ra,4(sp)
 181d6d8:	df000017 	ldw	fp,0(sp)
 181d6dc:	dec00204 	addi	sp,sp,8
 181d6e0:	f800283a 	ret

0181d6e4 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 181d6e4:	defff904 	addi	sp,sp,-28
 181d6e8:	dfc00615 	stw	ra,24(sp)
 181d6ec:	df000515 	stw	fp,20(sp)
 181d6f0:	df000504 	addi	fp,sp,20
 181d6f4:	2005883a 	mov	r2,r4
 181d6f8:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
 181d6fc:	00801fc4 	movi	r2,127
 181d700:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
 181d704:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
 181d708:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 181d70c:	d0a7f717 	ldw	r2,-24612(gp)
 181d710:	e0bffb15 	stw	r2,-20(fp)
 181d714:	00001d06 	br	181d78c <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
 181d718:	e0bffb17 	ldw	r2,-20(fp)
 181d71c:	10800703 	ldbu	r2,28(r2)
 181d720:	10803fcc 	andi	r2,r2,255
 181d724:	e0ffff03 	ldbu	r3,-4(fp)
 181d728:	18801536 	bltu	r3,r2,181d780 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
 181d72c:	e0bffb17 	ldw	r2,-20(fp)
 181d730:	10800703 	ldbu	r2,28(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 181d734:	10803fcc 	andi	r2,r2,255
 181d738:	e0fffe03 	ldbu	r3,-8(fp)
 181d73c:	18801036 	bltu	r3,r2,181d780 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 181d740:	d0e7f817 	ldw	r3,-24608(gp)
 181d744:	e0bffb17 	ldw	r2,-20(fp)
 181d748:	10800a17 	ldw	r2,40(r2)
 181d74c:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 181d750:	e0bffd17 	ldw	r2,-12(fp)
 181d754:	18800a36 	bltu	r3,r2,181d780 <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
 181d758:	d0e7f817 	ldw	r3,-24608(gp)
 181d75c:	e0bffb17 	ldw	r2,-20(fp)
 181d760:	10800a17 	ldw	r2,40(r2)
 181d764:	1885c83a 	sub	r2,r3,r2
 181d768:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
 181d76c:	e0bffb17 	ldw	r2,-20(fp)
 181d770:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
 181d774:	e0bffb17 	ldw	r2,-20(fp)
 181d778:	10800703 	ldbu	r2,28(r2)
 181d77c:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 181d780:	e0bffb17 	ldw	r2,-20(fp)
 181d784:	10800317 	ldw	r2,12(r2)
 181d788:	e0bffb15 	stw	r2,-20(fp)
 181d78c:	e0bffb17 	ldw	r2,-20(fp)
 181d790:	103fe11e 	bne	r2,zero,181d718 <__ram_exceptions_end+0xff80d2d4>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 181d794:	e0bffc17 	ldw	r2,-16(fp)
 181d798:	10000226 	beq	r2,zero,181d7a4 <tcp_kill_prio+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 181d79c:	e13ffc17 	ldw	r4,-16(fp)
 181d7a0:	181c0f00 	call	181c0f0 <tcp_abort>
  }
}
 181d7a4:	0001883a 	nop
 181d7a8:	e037883a 	mov	sp,fp
 181d7ac:	dfc00117 	ldw	ra,4(sp)
 181d7b0:	df000017 	ldw	fp,0(sp)
 181d7b4:	dec00204 	addi	sp,sp,8
 181d7b8:	f800283a 	ret

0181d7bc <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 181d7bc:	defffb04 	addi	sp,sp,-20
 181d7c0:	dfc00415 	stw	ra,16(sp)
 181d7c4:	df000315 	stw	fp,12(sp)
 181d7c8:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 181d7cc:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
 181d7d0:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 181d7d4:	d0a7fc17 	ldw	r2,-24592(gp)
 181d7d8:	e0bffd15 	stw	r2,-12(fp)
 181d7dc:	00001006 	br	181d820 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 181d7e0:	d0e7f817 	ldw	r3,-24608(gp)
 181d7e4:	e0bffd17 	ldw	r2,-12(fp)
 181d7e8:	10800a17 	ldw	r2,40(r2)
 181d7ec:	1887c83a 	sub	r3,r3,r2
 181d7f0:	e0bfff17 	ldw	r2,-4(fp)
 181d7f4:	18800736 	bltu	r3,r2,181d814 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
 181d7f8:	d0e7f817 	ldw	r3,-24608(gp)
 181d7fc:	e0bffd17 	ldw	r2,-12(fp)
 181d800:	10800a17 	ldw	r2,40(r2)
 181d804:	1885c83a 	sub	r2,r3,r2
 181d808:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
 181d80c:	e0bffd17 	ldw	r2,-12(fp)
 181d810:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 181d814:	e0bffd17 	ldw	r2,-12(fp)
 181d818:	10800317 	ldw	r2,12(r2)
 181d81c:	e0bffd15 	stw	r2,-12(fp)
 181d820:	e0bffd17 	ldw	r2,-12(fp)
 181d824:	103fee1e 	bne	r2,zero,181d7e0 <__ram_exceptions_end+0xff80d39c>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
 181d828:	e0bffe17 	ldw	r2,-8(fp)
 181d82c:	10000226 	beq	r2,zero,181d838 <tcp_kill_timewait+0x7c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 181d830:	e13ffe17 	ldw	r4,-8(fp)
 181d834:	181c0f00 	call	181c0f0 <tcp_abort>
  }
}
 181d838:	0001883a 	nop
 181d83c:	e037883a 	mov	sp,fp
 181d840:	dfc00117 	ldw	ra,4(sp)
 181d844:	df000017 	ldw	fp,0(sp)
 181d848:	dec00204 	addi	sp,sp,8
 181d84c:	f800283a 	ret

0181d850 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 181d850:	defffb04 	addi	sp,sp,-20
 181d854:	dfc00415 	stw	ra,16(sp)
 181d858:	df000315 	stw	fp,12(sp)
 181d85c:	df000304 	addi	fp,sp,12
 181d860:	2005883a 	mov	r2,r4
 181d864:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 181d868:	01000084 	movi	r4,2
 181d86c:	18349580 	call	1834958 <memp_malloc>
 181d870:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
 181d874:	e0bffd17 	ldw	r2,-12(fp)
 181d878:	10001e1e 	bne	r2,zero,181d8f4 <tcp_alloc+0xa4>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 181d87c:	181d7bc0 	call	181d7bc <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 181d880:	01000084 	movi	r4,2
 181d884:	18349580 	call	1834958 <memp_malloc>
 181d888:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
 181d88c:	e0bffd17 	ldw	r2,-12(fp)
 181d890:	10000f1e 	bne	r2,zero,181d8d0 <tcp_alloc+0x80>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
 181d894:	e0bfff03 	ldbu	r2,-4(fp)
 181d898:	1009883a 	mov	r4,r2
 181d89c:	181d6e40 	call	181d6e4 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 181d8a0:	01000084 	movi	r4,2
 181d8a4:	18349580 	call	1834958 <memp_malloc>
 181d8a8:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
 181d8ac:	e0bffd17 	ldw	r2,-12(fp)
 181d8b0:	10000726 	beq	r2,zero,181d8d0 <tcp_alloc+0x80>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 181d8b4:	008061f4 	movhi	r2,391
 181d8b8:	10a9d404 	addi	r2,r2,-22704
 181d8bc:	10806217 	ldw	r2,392(r2)
 181d8c0:	10ffffc4 	addi	r3,r2,-1
 181d8c4:	008061f4 	movhi	r2,391
 181d8c8:	10a9d404 	addi	r2,r2,-22704
 181d8cc:	10c06215 	stw	r3,392(r2)
      }
    }
    if (pcb != NULL) {
 181d8d0:	e0bffd17 	ldw	r2,-12(fp)
 181d8d4:	10000726 	beq	r2,zero,181d8f4 <tcp_alloc+0xa4>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 181d8d8:	008061f4 	movhi	r2,391
 181d8dc:	10a9d404 	addi	r2,r2,-22704
 181d8e0:	10806217 	ldw	r2,392(r2)
 181d8e4:	10ffffc4 	addi	r3,r2,-1
 181d8e8:	008061f4 	movhi	r2,391
 181d8ec:	10a9d404 	addi	r2,r2,-22704
 181d8f0:	10c06215 	stw	r3,392(r2)
    }
  }
  if (pcb != NULL) {
 181d8f4:	e0bffd17 	ldw	r2,-12(fp)
 181d8f8:	10004f26 	beq	r2,zero,181da38 <tcp_alloc+0x1e8>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 181d8fc:	01802904 	movi	r6,164
 181d900:	000b883a 	mov	r5,zero
 181d904:	e13ffd17 	ldw	r4,-12(fp)
 181d908:	18061d40 	call	18061d4 <memset>
    pcb->prio = prio;
 181d90c:	e0bffd17 	ldw	r2,-12(fp)
 181d910:	e0ffff03 	ldbu	r3,-4(fp)
 181d914:	10c00705 	stb	r3,28(r2)
    pcb->snd_buf = TCP_SND_BUF;
 181d918:	e0bffd17 	ldw	r2,-12(fp)
 181d91c:	00c2da04 	movi	r3,2920
 181d920:	10c01a8d 	sth	r3,106(r2)
    pcb->snd_queuelen = 0;
 181d924:	e0bffd17 	ldw	r2,-12(fp)
 181d928:	10001b0d 	sth	zero,108(r2)
    pcb->rcv_wnd = TCP_WND;
 181d92c:	e0bffd17 	ldw	r2,-12(fp)
 181d930:	00c80004 	movi	r3,8192
 181d934:	10c00c0d 	sth	r3,48(r2)
    pcb->rcv_ann_wnd = TCP_WND;
 181d938:	e0bffd17 	ldw	r2,-12(fp)
 181d93c:	00c80004 	movi	r3,8192
 181d940:	10c00c8d 	sth	r3,50(r2)
    pcb->tos = 0;
 181d944:	e0bffd17 	ldw	r2,-12(fp)
 181d948:	10000245 	stb	zero,9(r2)
    pcb->ttl = TCP_TTL;
 181d94c:	e0bffd17 	ldw	r2,-12(fp)
 181d950:	00c01004 	movi	r3,64
 181d954:	10c00285 	stb	r3,10(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 181d958:	e0bffd17 	ldw	r2,-12(fp)
 181d95c:	00c08604 	movi	r3,536
 181d960:	10c00e8d 	sth	r3,58(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 181d964:	e0bffd17 	ldw	r2,-12(fp)
 181d968:	00c00184 	movi	r3,6
 181d96c:	10c0120d 	sth	r3,72(r2)
    pcb->sa = 0;
 181d970:	e0bffd17 	ldw	r2,-12(fp)
 181d974:	1000110d 	sth	zero,68(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 181d978:	e0bffd17 	ldw	r2,-12(fp)
 181d97c:	00c00184 	movi	r3,6
 181d980:	10c0118d 	sth	r3,70(r2)
    pcb->rtime = -1;
 181d984:	e0bffd17 	ldw	r2,-12(fp)
 181d988:	00ffffc4 	movi	r3,-1
 181d98c:	10c00e0d 	sth	r3,56(r2)
    pcb->cwnd = 1;
 181d990:	e0bffd17 	ldw	r2,-12(fp)
 181d994:	00c00044 	movi	r3,1
 181d998:	10c0140d 	sth	r3,80(r2)
    iss = tcp_next_iss();
 181d99c:	181de440 	call	181de44 <tcp_next_iss>
 181d9a0:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
 181d9a4:	e0bffd17 	ldw	r2,-12(fp)
 181d9a8:	e0fffe17 	ldw	r3,-8(fp)
 181d9ac:	10c01715 	stw	r3,92(r2)
    pcb->snd_nxt = iss;
 181d9b0:	e0bffd17 	ldw	r2,-12(fp)
 181d9b4:	e0fffe17 	ldw	r3,-8(fp)
 181d9b8:	10c01515 	stw	r3,84(r2)
    pcb->lastack = iss;
 181d9bc:	e0bffd17 	ldw	r2,-12(fp)
 181d9c0:	e0fffe17 	ldw	r3,-8(fp)
 181d9c4:	10c01315 	stw	r3,76(r2)
    pcb->snd_lbb = iss;   
 181d9c8:	e0bffd17 	ldw	r2,-12(fp)
 181d9cc:	e0fffe17 	ldw	r3,-8(fp)
 181d9d0:	10c01815 	stw	r3,96(r2)
    pcb->tmr = tcp_ticks;
 181d9d4:	d0e7f817 	ldw	r3,-24608(gp)
 181d9d8:	e0bffd17 	ldw	r2,-12(fp)
 181d9dc:	10c00a15 	stw	r3,40(r2)
    pcb->last_timer = tcp_timer_ctr;
 181d9e0:	d0e7f643 	ldbu	r3,-24615(gp)
 181d9e4:	e0bffd17 	ldw	r2,-12(fp)
 181d9e8:	10c00945 	stb	r3,37(r2)

    pcb->polltmr = 0;
 181d9ec:	e0bffd17 	ldw	r2,-12(fp)
 181d9f0:	100008c5 	stb	zero,35(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 181d9f4:	e0fffd17 	ldw	r3,-12(fp)
 181d9f8:	008060b4 	movhi	r2,386
 181d9fc:	10b59a04 	addi	r2,r2,-10648
 181da00:	18802115 	stw	r2,132(r3)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 181da04:	e0fffd17 	ldw	r3,-12(fp)
 181da08:	00801bb4 	movhi	r2,110
 181da0c:	10b74004 	addi	r2,r2,-8960
 181da10:	18802515 	stw	r2,148(r3)
    
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 181da14:	e0fffd17 	ldw	r3,-12(fp)
 181da18:	00800074 	movhi	r2,1
 181da1c:	10893e04 	addi	r2,r2,9464
 181da20:	18802615 	stw	r2,152(r3)
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 181da24:	e0bffd17 	ldw	r2,-12(fp)
 181da28:	00c00244 	movi	r3,9
 181da2c:	10c02715 	stw	r3,156(r2)
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 181da30:	e0bffd17 	ldw	r2,-12(fp)
 181da34:	10002885 	stb	zero,162(r2)
  }
  return pcb;
 181da38:	e0bffd17 	ldw	r2,-12(fp)
}
 181da3c:	e037883a 	mov	sp,fp
 181da40:	dfc00117 	ldw	ra,4(sp)
 181da44:	df000017 	ldw	fp,0(sp)
 181da48:	dec00204 	addi	sp,sp,8
 181da4c:	f800283a 	ret

0181da50 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 181da50:	defffe04 	addi	sp,sp,-8
 181da54:	dfc00115 	stw	ra,4(sp)
 181da58:	df000015 	stw	fp,0(sp)
 181da5c:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
 181da60:	01001004 	movi	r4,64
 181da64:	181d8500 	call	181d850 <tcp_alloc>
}
 181da68:	e037883a 	mov	sp,fp
 181da6c:	dfc00117 	ldw	ra,4(sp)
 181da70:	df000017 	ldw	fp,0(sp)
 181da74:	dec00204 	addi	sp,sp,8
 181da78:	f800283a 	ret

0181da7c <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 181da7c:	defffd04 	addi	sp,sp,-12
 181da80:	df000215 	stw	fp,8(sp)
 181da84:	df000204 	addi	fp,sp,8
 181da88:	e13ffe15 	stw	r4,-8(fp)
 181da8c:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 181da90:	e0bffe17 	ldw	r2,-8(fp)
 181da94:	e0ffff17 	ldw	r3,-4(fp)
 181da98:	10c00415 	stw	r3,16(r2)
}
 181da9c:	0001883a 	nop
 181daa0:	e037883a 	mov	sp,fp
 181daa4:	df000017 	ldw	fp,0(sp)
 181daa8:	dec00104 	addi	sp,sp,4
 181daac:	f800283a 	ret

0181dab0 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 181dab0:	defffd04 	addi	sp,sp,-12
 181dab4:	df000215 	stw	fp,8(sp)
 181dab8:	df000204 	addi	fp,sp,8
 181dabc:	e13ffe15 	stw	r4,-8(fp)
 181dac0:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
 181dac4:	e0bffe17 	ldw	r2,-8(fp)
 181dac8:	e0ffff17 	ldw	r3,-4(fp)
 181dacc:	10c02115 	stw	r3,132(r2)
}
 181dad0:	0001883a 	nop
 181dad4:	e037883a 	mov	sp,fp
 181dad8:	df000017 	ldw	fp,0(sp)
 181dadc:	dec00104 	addi	sp,sp,4
 181dae0:	f800283a 	ret

0181dae4 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 181dae4:	defffd04 	addi	sp,sp,-12
 181dae8:	df000215 	stw	fp,8(sp)
 181daec:	df000204 	addi	fp,sp,8
 181daf0:	e13ffe15 	stw	r4,-8(fp)
 181daf4:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
 181daf8:	e0bffe17 	ldw	r2,-8(fp)
 181dafc:	e0ffff17 	ldw	r3,-4(fp)
 181db00:	10c02015 	stw	r3,128(r2)
}
 181db04:	0001883a 	nop
 181db08:	e037883a 	mov	sp,fp
 181db0c:	df000017 	ldw	fp,0(sp)
 181db10:	dec00104 	addi	sp,sp,4
 181db14:	f800283a 	ret

0181db18 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 181db18:	defffd04 	addi	sp,sp,-12
 181db1c:	df000215 	stw	fp,8(sp)
 181db20:	df000204 	addi	fp,sp,8
 181db24:	e13ffe15 	stw	r4,-8(fp)
 181db28:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
 181db2c:	e0bffe17 	ldw	r2,-8(fp)
 181db30:	e0ffff17 	ldw	r3,-4(fp)
 181db34:	10c02415 	stw	r3,144(r2)
}
 181db38:	0001883a 	nop
 181db3c:	e037883a 	mov	sp,fp
 181db40:	df000017 	ldw	fp,0(sp)
 181db44:	dec00104 	addi	sp,sp,4
 181db48:	f800283a 	ret

0181db4c <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
 181db4c:	defffd04 	addi	sp,sp,-12
 181db50:	df000215 	stw	fp,8(sp)
 181db54:	df000204 	addi	fp,sp,8
 181db58:	e13ffe15 	stw	r4,-8(fp)
 181db5c:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 181db60:	e0bffe17 	ldw	r2,-8(fp)
 181db64:	e0ffff17 	ldw	r3,-4(fp)
 181db68:	10c00515 	stw	r3,20(r2)
}
 181db6c:	0001883a 	nop
 181db70:	e037883a 	mov	sp,fp
 181db74:	df000017 	ldw	fp,0(sp)
 181db78:	dec00104 	addi	sp,sp,4
 181db7c:	f800283a 	ret

0181db80 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 181db80:	defffc04 	addi	sp,sp,-16
 181db84:	df000315 	stw	fp,12(sp)
 181db88:	df000304 	addi	fp,sp,12
 181db8c:	e13ffd15 	stw	r4,-12(fp)
 181db90:	e17ffe15 	stw	r5,-8(fp)
 181db94:	3005883a 	mov	r2,r6
 181db98:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 181db9c:	e0bffd17 	ldw	r2,-12(fp)
 181dba0:	e0fffe17 	ldw	r3,-8(fp)
 181dba4:	10c02315 	stw	r3,140(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 181dba8:	e0bffd17 	ldw	r2,-12(fp)
 181dbac:	e0ffff03 	ldbu	r3,-4(fp)
 181dbb0:	10c00905 	stb	r3,36(r2)
}
 181dbb4:	0001883a 	nop
 181dbb8:	e037883a 	mov	sp,fp
 181dbbc:	df000017 	ldw	fp,0(sp)
 181dbc0:	dec00104 	addi	sp,sp,4
 181dbc4:	f800283a 	ret

0181dbc8 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 181dbc8:	defffc04 	addi	sp,sp,-16
 181dbcc:	dfc00315 	stw	ra,12(sp)
 181dbd0:	df000215 	stw	fp,8(sp)
 181dbd4:	df000204 	addi	fp,sp,8
 181dbd8:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
 181dbdc:	e0bfff17 	ldw	r2,-4(fp)
 181dbe0:	10800617 	ldw	r2,24(r2)
 181dbe4:	10004e26 	beq	r2,zero,181dd20 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
 181dbe8:	e0bfff17 	ldw	r2,-4(fp)
 181dbec:	10800617 	ldw	r2,24(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 181dbf0:	108002a0 	cmpeqi	r2,r2,10
 181dbf4:	10004a1e 	bne	r2,zero,181dd20 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
 181dbf8:	e0bfff17 	ldw	r2,-4(fp)
 181dbfc:	10800617 	ldw	r2,24(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
 181dc00:	10800060 	cmpeqi	r2,r2,1
 181dc04:	1000461e 	bne	r2,zero,181dd20 <tcp_pcb_purge+0x158>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

#if TCP_LISTEN_BACKLOG
    if (pcb->state == SYN_RCVD) {
 181dc08:	e0bfff17 	ldw	r2,-4(fp)
 181dc0c:	10800617 	ldw	r2,24(r2)
 181dc10:	108000d8 	cmpnei	r2,r2,3
 181dc14:	1000201e 	bne	r2,zero,181dc98 <tcp_pcb_purge+0xd0>
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 181dc18:	d0a7f917 	ldw	r2,-24604(gp)
 181dc1c:	e0bffe15 	stw	r2,-8(fp)
 181dc20:	00001b06 	br	181dc90 <tcp_pcb_purge+0xc8>
        if ((lpcb->local_port == pcb->local_port) &&
 181dc24:	e0bffe17 	ldw	r2,-8(fp)
 181dc28:	10c0078b 	ldhu	r3,30(r2)
 181dc2c:	e0bfff17 	ldw	r2,-4(fp)
 181dc30:	1080078b 	ldhu	r2,30(r2)
 181dc34:	18ffffcc 	andi	r3,r3,65535
 181dc38:	10bfffcc 	andi	r2,r2,65535
 181dc3c:	1880111e 	bne	r3,r2,181dc84 <tcp_pcb_purge+0xbc>
            (ip_addr_isany(&lpcb->local_ip) ||
 181dc40:	e0bffe17 	ldw	r2,-8(fp)
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
 181dc44:	10000826 	beq	r2,zero,181dc68 <tcp_pcb_purge+0xa0>
            (ip_addr_isany(&lpcb->local_ip) ||
 181dc48:	e0bffe17 	ldw	r2,-8(fp)
 181dc4c:	10800017 	ldw	r2,0(r2)
 181dc50:	10000526 	beq	r2,zero,181dc68 <tcp_pcb_purge+0xa0>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
 181dc54:	e0bfff17 	ldw	r2,-4(fp)
 181dc58:	10c00017 	ldw	r3,0(r2)
 181dc5c:	e0bffe17 	ldw	r2,-8(fp)
 181dc60:	10800017 	ldw	r2,0(r2)
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
            (ip_addr_isany(&lpcb->local_ip) ||
 181dc64:	1880071e 	bne	r3,r2,181dc84 <tcp_pcb_purge+0xbc>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
            /* port and address of the listen pcb match the timed-out pcb */
            LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
              lpcb->accepts_pending > 0);
            lpcb->accepts_pending--;
 181dc68:	e0bffe17 	ldw	r2,-8(fp)
 181dc6c:	10800843 	ldbu	r2,33(r2)
 181dc70:	10bfffc4 	addi	r2,r2,-1
 181dc74:	1007883a 	mov	r3,r2
 181dc78:	e0bffe17 	ldw	r2,-8(fp)
 181dc7c:	10c00845 	stb	r3,33(r2)
            break;
 181dc80:	00000506 	br	181dc98 <tcp_pcb_purge+0xd0>
    if (pcb->state == SYN_RCVD) {
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 181dc84:	e0bffe17 	ldw	r2,-8(fp)
 181dc88:	10800317 	ldw	r2,12(r2)
 181dc8c:	e0bffe15 	stw	r2,-8(fp)
 181dc90:	e0bffe17 	ldw	r2,-8(fp)
 181dc94:	103fe31e 	bne	r2,zero,181dc24 <__ram_exceptions_end+0xff80d7e0>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 181dc98:	e0bfff17 	ldw	r2,-4(fp)
 181dc9c:	10801f17 	ldw	r2,124(r2)
 181dca0:	10000626 	beq	r2,zero,181dcbc <tcp_pcb_purge+0xf4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 181dca4:	e0bfff17 	ldw	r2,-4(fp)
 181dca8:	10801f17 	ldw	r2,124(r2)
 181dcac:	1009883a 	mov	r4,r2
 181dcb0:	181aca40 	call	181aca4 <pbuf_free>
      pcb->refused_data = NULL;
 181dcb4:	e0bfff17 	ldw	r2,-4(fp)
 181dcb8:	10001f15 	stw	zero,124(r2)
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 181dcbc:	e0bfff17 	ldw	r2,-4(fp)
 181dcc0:	10801e17 	ldw	r2,120(r2)
 181dcc4:	1009883a 	mov	r4,r2
 181dcc8:	181d5180 	call	181d518 <tcp_segs_free>
    pcb->ooseq = NULL;
 181dccc:	e0bfff17 	ldw	r2,-4(fp)
 181dcd0:	10001e15 	stw	zero,120(r2)
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 181dcd4:	e0bfff17 	ldw	r2,-4(fp)
 181dcd8:	00ffffc4 	movi	r3,-1
 181dcdc:	10c00e0d 	sth	r3,56(r2)

    tcp_segs_free(pcb->unsent);
 181dce0:	e0bfff17 	ldw	r2,-4(fp)
 181dce4:	10801c17 	ldw	r2,112(r2)
 181dce8:	1009883a 	mov	r4,r2
 181dcec:	181d5180 	call	181d518 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 181dcf0:	e0bfff17 	ldw	r2,-4(fp)
 181dcf4:	10801d17 	ldw	r2,116(r2)
 181dcf8:	1009883a 	mov	r4,r2
 181dcfc:	181d5180 	call	181d518 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 181dd00:	e0bfff17 	ldw	r2,-4(fp)
 181dd04:	10001c15 	stw	zero,112(r2)
 181dd08:	e0bfff17 	ldw	r2,-4(fp)
 181dd0c:	10c01c17 	ldw	r3,112(r2)
 181dd10:	e0bfff17 	ldw	r2,-4(fp)
 181dd14:	10c01d15 	stw	r3,116(r2)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 181dd18:	e0bfff17 	ldw	r2,-4(fp)
 181dd1c:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */
  }
}
 181dd20:	0001883a 	nop
 181dd24:	e037883a 	mov	sp,fp
 181dd28:	dfc00117 	ldw	ra,4(sp)
 181dd2c:	df000017 	ldw	fp,0(sp)
 181dd30:	dec00204 	addi	sp,sp,8
 181dd34:	f800283a 	ret

0181dd38 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 181dd38:	defffc04 	addi	sp,sp,-16
 181dd3c:	dfc00315 	stw	ra,12(sp)
 181dd40:	df000215 	stw	fp,8(sp)
 181dd44:	df000204 	addi	fp,sp,8
 181dd48:	e13ffe15 	stw	r4,-8(fp)
 181dd4c:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
 181dd50:	e0bffe17 	ldw	r2,-8(fp)
 181dd54:	10c00017 	ldw	r3,0(r2)
 181dd58:	e0bfff17 	ldw	r2,-4(fp)
 181dd5c:	1880061e 	bne	r3,r2,181dd78 <tcp_pcb_remove+0x40>
 181dd60:	e0bffe17 	ldw	r2,-8(fp)
 181dd64:	10800017 	ldw	r2,0(r2)
 181dd68:	10c00317 	ldw	r3,12(r2)
 181dd6c:	e0bffe17 	ldw	r2,-8(fp)
 181dd70:	10c00015 	stw	r3,0(r2)
 181dd74:	00001206 	br	181ddc0 <tcp_pcb_remove+0x88>
 181dd78:	e0bffe17 	ldw	r2,-8(fp)
 181dd7c:	10800017 	ldw	r2,0(r2)
 181dd80:	d0a7fa15 	stw	r2,-24600(gp)
 181dd84:	00000c06 	br	181ddb8 <tcp_pcb_remove+0x80>
 181dd88:	d0a7fa17 	ldw	r2,-24600(gp)
 181dd8c:	10c00317 	ldw	r3,12(r2)
 181dd90:	e0bfff17 	ldw	r2,-4(fp)
 181dd94:	1880051e 	bne	r3,r2,181ddac <tcp_pcb_remove+0x74>
 181dd98:	d0a7fa17 	ldw	r2,-24600(gp)
 181dd9c:	e0ffff17 	ldw	r3,-4(fp)
 181dda0:	18c00317 	ldw	r3,12(r3)
 181dda4:	10c00315 	stw	r3,12(r2)
 181dda8:	00000506 	br	181ddc0 <tcp_pcb_remove+0x88>
 181ddac:	d0a7fa17 	ldw	r2,-24600(gp)
 181ddb0:	10800317 	ldw	r2,12(r2)
 181ddb4:	d0a7fa15 	stw	r2,-24600(gp)
 181ddb8:	d0a7fa17 	ldw	r2,-24600(gp)
 181ddbc:	103ff21e 	bne	r2,zero,181dd88 <__ram_exceptions_end+0xff80d944>
 181ddc0:	e0bfff17 	ldw	r2,-4(fp)
 181ddc4:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
 181ddc8:	e13fff17 	ldw	r4,-4(fp)
 181ddcc:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 181ddd0:	e0bfff17 	ldw	r2,-4(fp)
 181ddd4:	10800617 	ldw	r2,24(r2)
 181ddd8:	108002a0 	cmpeqi	r2,r2,10
 181dddc:	1000111e 	bne	r2,zero,181de24 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
 181dde0:	e0bfff17 	ldw	r2,-4(fp)
 181dde4:	10800617 	ldw	r2,24(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 181dde8:	10800060 	cmpeqi	r2,r2,1
 181ddec:	10000d1e 	bne	r2,zero,181de24 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 181ddf0:	e0bfff17 	ldw	r2,-4(fp)
 181ddf4:	10800883 	ldbu	r2,34(r2)
 181ddf8:	10803fcc 	andi	r2,r2,255
 181ddfc:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 181de00:	10000826 	beq	r2,zero,181de24 <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 181de04:	e0bfff17 	ldw	r2,-4(fp)
 181de08:	10800883 	ldbu	r2,34(r2)
 181de0c:	10800094 	ori	r2,r2,2
 181de10:	1007883a 	mov	r3,r2
 181de14:	e0bfff17 	ldw	r2,-4(fp)
 181de18:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
 181de1c:	e13fff17 	ldw	r4,-4(fp)
 181de20:	181f8bc0 	call	181f8bc <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 181de24:	e0bfff17 	ldw	r2,-4(fp)
 181de28:	10000615 	stw	zero,24(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 181de2c:	0001883a 	nop
 181de30:	e037883a 	mov	sp,fp
 181de34:	dfc00117 	ldw	ra,4(sp)
 181de38:	df000017 	ldw	fp,0(sp)
 181de3c:	dec00204 	addi	sp,sp,8
 181de40:	f800283a 	ret

0181de44 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
 181de44:	deffff04 	addi	sp,sp,-4
 181de48:	df000015 	stw	fp,0(sp)
 181de4c:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 181de50:	d0e01217 	ldw	r3,-32696(gp)
 181de54:	d0a7f817 	ldw	r2,-24608(gp)
 181de58:	1885883a 	add	r2,r3,r2
 181de5c:	d0a01215 	stw	r2,-32696(gp)
  return iss;
 181de60:	d0a01217 	ldw	r2,-32696(gp)
}
 181de64:	e037883a 	mov	sp,fp
 181de68:	df000017 	ldw	fp,0(sp)
 181de6c:	dec00104 	addi	sp,sp,4
 181de70:	f800283a 	ret

0181de74 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *src, ip_addr_t *addr)
{
 181de74:	defff904 	addi	sp,sp,-28
 181de78:	dfc00615 	stw	ra,24(sp)
 181de7c:	df000515 	stw	fp,20(sp)
 181de80:	df000504 	addi	fp,sp,20
 181de84:	2005883a 	mov	r2,r4
 181de88:	e17ffe15 	stw	r5,-8(fp)
 181de8c:	e1bfff15 	stw	r6,-4(fp)
 181de90:	e0bffd0d 	sth	r2,-12(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(src, addr);
 181de94:	e17fff17 	ldw	r5,-4(fp)
 181de98:	e13ffe17 	ldw	r4,-8(fp)
 181de9c:	18322400 	call	1832240 <ip_route>
 181dea0:	e0bffb15 	stw	r2,-20(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
 181dea4:	e0bffb17 	ldw	r2,-20(fp)
 181dea8:	10000f26 	beq	r2,zero,181dee8 <tcp_eff_send_mss+0x74>
 181deac:	e0bffb17 	ldw	r2,-20(fp)
 181deb0:	10800c0b 	ldhu	r2,48(r2)
 181deb4:	10bfffcc 	andi	r2,r2,65535
 181deb8:	10000b26 	beq	r2,zero,181dee8 <tcp_eff_send_mss+0x74>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 181debc:	e0bffb17 	ldw	r2,-20(fp)
 181dec0:	10800c0b 	ldhu	r2,48(r2)
 181dec4:	10bff604 	addi	r2,r2,-40
 181dec8:	e0bffc0d 	sth	r2,-16(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 181decc:	e17ffd0b 	ldhu	r5,-12(fp)
 181ded0:	e0bffc0b 	ldhu	r2,-16(fp)
 181ded4:	10ffffcc 	andi	r3,r2,65535
 181ded8:	293fffcc 	andi	r4,r5,65535
 181dedc:	20c0012e 	bgeu	r4,r3,181dee4 <tcp_eff_send_mss+0x70>
 181dee0:	2805883a 	mov	r2,r5
 181dee4:	e0bffd0d 	sth	r2,-12(fp)
  }
  return sendmss;
 181dee8:	e0bffd0b 	ldhu	r2,-12(fp)
}
 181deec:	e037883a 	mov	sp,fp
 181def0:	dfc00117 	ldw	ra,4(sp)
 181def4:	df000017 	ldw	fp,0(sp)
 181def8:	dec00204 	addi	sp,sp,8
 181defc:	f800283a 	ret

0181df00 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
 181df00:	defffe04 	addi	sp,sp,-8
 181df04:	df000115 	stw	fp,4(sp)
 181df08:	df000104 	addi	fp,sp,4
 181df0c:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
 181df10:	00806134 	movhi	r2,388
 181df14:	1086cd04 	addi	r2,r2,6964
 181df18:	e0ffff17 	ldw	r3,-4(fp)
 181df1c:	18c7883a 	add	r3,r3,r3
 181df20:	18c7883a 	add	r3,r3,r3
 181df24:	10c5883a 	add	r2,r2,r3
 181df28:	10800017 	ldw	r2,0(r2)
}
 181df2c:	e037883a 	mov	sp,fp
 181df30:	df000017 	ldw	fp,0(sp)
 181df34:	dec00104 	addi	sp,sp,4
 181df38:	f800283a 	ret

0181df3c <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
 181df3c:	defff804 	addi	sp,sp,-32
 181df40:	dfc00715 	stw	ra,28(sp)
 181df44:	df000615 	stw	fp,24(sp)
 181df48:	df000604 	addi	fp,sp,24
 181df4c:	e13ffc15 	stw	r4,-16(fp)
 181df50:	2807883a 	mov	r3,r5
 181df54:	3005883a 	mov	r2,r6
 181df58:	e1ffff15 	stw	r7,-4(fp)
 181df5c:	e0fffd0d 	sth	r3,-12(fp)
 181df60:	e0bffe0d 	sth	r2,-8(fp)
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 181df64:	e0fffd0b 	ldhu	r3,-12(fp)
 181df68:	e0bffe0b 	ldhu	r2,-8(fp)
 181df6c:	1885883a 	add	r2,r3,r2
 181df70:	10800504 	addi	r2,r2,20
 181df74:	10bfffcc 	andi	r2,r2,65535
 181df78:	000d883a 	mov	r6,zero
 181df7c:	100b883a 	mov	r5,r2
 181df80:	01000044 	movi	r4,1
 181df84:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181df88:	e0bffa15 	stw	r2,-24(fp)
  if (p != NULL) {
 181df8c:	e0bffa17 	ldw	r2,-24(fp)
 181df90:	1000de26 	beq	r2,zero,181e30c <tcp_output_alloc_header+0x3d0>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 181df94:	e0bffa17 	ldw	r2,-24(fp)
 181df98:	10800117 	ldw	r2,4(r2)
 181df9c:	e0bffb15 	stw	r2,-20(fp)
    tcphdr->src = htons(pcb->local_port);
 181dfa0:	e0bffc17 	ldw	r2,-16(fp)
 181dfa4:	1080078b 	ldhu	r2,30(r2)
 181dfa8:	10bfffcc 	andi	r2,r2,65535
 181dfac:	1004d23a 	srli	r2,r2,8
 181dfb0:	1007883a 	mov	r3,r2
 181dfb4:	e0bffc17 	ldw	r2,-16(fp)
 181dfb8:	1080078b 	ldhu	r2,30(r2)
 181dfbc:	10bfffcc 	andi	r2,r2,65535
 181dfc0:	1004923a 	slli	r2,r2,8
 181dfc4:	1884b03a 	or	r2,r3,r2
 181dfc8:	100d883a 	mov	r6,r2
 181dfcc:	e0bffb17 	ldw	r2,-20(fp)
 181dfd0:	30ffffcc 	andi	r3,r6,65535
 181dfd4:	19403fcc 	andi	r5,r3,255
 181dfd8:	10c00003 	ldbu	r3,0(r2)
 181dfdc:	1806703a 	and	r3,r3,zero
 181dfe0:	1809883a 	mov	r4,r3
 181dfe4:	2807883a 	mov	r3,r5
 181dfe8:	20c6b03a 	or	r3,r4,r3
 181dfec:	10c00005 	stb	r3,0(r2)
 181dff0:	30ffffcc 	andi	r3,r6,65535
 181dff4:	1806d23a 	srli	r3,r3,8
 181dff8:	197fffcc 	andi	r5,r3,65535
 181dffc:	10c00043 	ldbu	r3,1(r2)
 181e000:	1806703a 	and	r3,r3,zero
 181e004:	1809883a 	mov	r4,r3
 181e008:	2807883a 	mov	r3,r5
 181e00c:	20c6b03a 	or	r3,r4,r3
 181e010:	10c00045 	stb	r3,1(r2)
    tcphdr->dest = htons(pcb->remote_port);
 181e014:	e0bffc17 	ldw	r2,-16(fp)
 181e018:	1080080b 	ldhu	r2,32(r2)
 181e01c:	10bfffcc 	andi	r2,r2,65535
 181e020:	1004d23a 	srli	r2,r2,8
 181e024:	1007883a 	mov	r3,r2
 181e028:	e0bffc17 	ldw	r2,-16(fp)
 181e02c:	1080080b 	ldhu	r2,32(r2)
 181e030:	10bfffcc 	andi	r2,r2,65535
 181e034:	1004923a 	slli	r2,r2,8
 181e038:	1884b03a 	or	r2,r3,r2
 181e03c:	100d883a 	mov	r6,r2
 181e040:	e0bffb17 	ldw	r2,-20(fp)
 181e044:	30ffffcc 	andi	r3,r6,65535
 181e048:	19403fcc 	andi	r5,r3,255
 181e04c:	10c00083 	ldbu	r3,2(r2)
 181e050:	1806703a 	and	r3,r3,zero
 181e054:	1809883a 	mov	r4,r3
 181e058:	2807883a 	mov	r3,r5
 181e05c:	20c6b03a 	or	r3,r4,r3
 181e060:	10c00085 	stb	r3,2(r2)
 181e064:	30ffffcc 	andi	r3,r6,65535
 181e068:	1806d23a 	srli	r3,r3,8
 181e06c:	197fffcc 	andi	r5,r3,65535
 181e070:	10c000c3 	ldbu	r3,3(r2)
 181e074:	1806703a 	and	r3,r3,zero
 181e078:	1809883a 	mov	r4,r3
 181e07c:	2807883a 	mov	r3,r5
 181e080:	20c6b03a 	or	r3,r4,r3
 181e084:	10c000c5 	stb	r3,3(r2)
    tcphdr->seqno = seqno_be;
 181e088:	e0bffb17 	ldw	r2,-20(fp)
 181e08c:	e0ffff17 	ldw	r3,-4(fp)
 181e090:	19403fcc 	andi	r5,r3,255
 181e094:	10c00103 	ldbu	r3,4(r2)
 181e098:	1806703a 	and	r3,r3,zero
 181e09c:	1809883a 	mov	r4,r3
 181e0a0:	2807883a 	mov	r3,r5
 181e0a4:	20c6b03a 	or	r3,r4,r3
 181e0a8:	10c00105 	stb	r3,4(r2)
 181e0ac:	e0ffff17 	ldw	r3,-4(fp)
 181e0b0:	1806d23a 	srli	r3,r3,8
 181e0b4:	19403fcc 	andi	r5,r3,255
 181e0b8:	10c00143 	ldbu	r3,5(r2)
 181e0bc:	1806703a 	and	r3,r3,zero
 181e0c0:	1809883a 	mov	r4,r3
 181e0c4:	2807883a 	mov	r3,r5
 181e0c8:	20c6b03a 	or	r3,r4,r3
 181e0cc:	10c00145 	stb	r3,5(r2)
 181e0d0:	e0ffff17 	ldw	r3,-4(fp)
 181e0d4:	1806d43a 	srli	r3,r3,16
 181e0d8:	19403fcc 	andi	r5,r3,255
 181e0dc:	10c00183 	ldbu	r3,6(r2)
 181e0e0:	1806703a 	and	r3,r3,zero
 181e0e4:	1809883a 	mov	r4,r3
 181e0e8:	2807883a 	mov	r3,r5
 181e0ec:	20c6b03a 	or	r3,r4,r3
 181e0f0:	10c00185 	stb	r3,6(r2)
 181e0f4:	e0ffff17 	ldw	r3,-4(fp)
 181e0f8:	180ad63a 	srli	r5,r3,24
 181e0fc:	10c001c3 	ldbu	r3,7(r2)
 181e100:	1806703a 	and	r3,r3,zero
 181e104:	1809883a 	mov	r4,r3
 181e108:	2807883a 	mov	r3,r5
 181e10c:	20c6b03a 	or	r3,r4,r3
 181e110:	10c001c5 	stb	r3,7(r2)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 181e114:	e0bffc17 	ldw	r2,-16(fp)
 181e118:	10800b17 	ldw	r2,44(r2)
 181e11c:	1006d63a 	srli	r3,r2,24
 181e120:	e0bffc17 	ldw	r2,-16(fp)
 181e124:	10800b17 	ldw	r2,44(r2)
 181e128:	1004d23a 	srli	r2,r2,8
 181e12c:	10bfc00c 	andi	r2,r2,65280
 181e130:	1886b03a 	or	r3,r3,r2
 181e134:	e0bffc17 	ldw	r2,-16(fp)
 181e138:	10800b17 	ldw	r2,44(r2)
 181e13c:	10bfc00c 	andi	r2,r2,65280
 181e140:	1004923a 	slli	r2,r2,8
 181e144:	1886b03a 	or	r3,r3,r2
 181e148:	e0bffc17 	ldw	r2,-16(fp)
 181e14c:	10800b17 	ldw	r2,44(r2)
 181e150:	1004963a 	slli	r2,r2,24
 181e154:	1886b03a 	or	r3,r3,r2
 181e158:	e0bffb17 	ldw	r2,-20(fp)
 181e15c:	19803fcc 	andi	r6,r3,255
 181e160:	11000203 	ldbu	r4,8(r2)
 181e164:	2008703a 	and	r4,r4,zero
 181e168:	200b883a 	mov	r5,r4
 181e16c:	3009883a 	mov	r4,r6
 181e170:	2908b03a 	or	r4,r5,r4
 181e174:	11000205 	stb	r4,8(r2)
 181e178:	1808d23a 	srli	r4,r3,8
 181e17c:	21803fcc 	andi	r6,r4,255
 181e180:	11000243 	ldbu	r4,9(r2)
 181e184:	2008703a 	and	r4,r4,zero
 181e188:	200b883a 	mov	r5,r4
 181e18c:	3009883a 	mov	r4,r6
 181e190:	2908b03a 	or	r4,r5,r4
 181e194:	11000245 	stb	r4,9(r2)
 181e198:	1808d43a 	srli	r4,r3,16
 181e19c:	21803fcc 	andi	r6,r4,255
 181e1a0:	11000283 	ldbu	r4,10(r2)
 181e1a4:	2008703a 	and	r4,r4,zero
 181e1a8:	200b883a 	mov	r5,r4
 181e1ac:	3009883a 	mov	r4,r6
 181e1b0:	2908b03a 	or	r4,r5,r4
 181e1b4:	11000285 	stb	r4,10(r2)
 181e1b8:	180ad63a 	srli	r5,r3,24
 181e1bc:	10c002c3 	ldbu	r3,11(r2)
 181e1c0:	1806703a 	and	r3,r3,zero
 181e1c4:	1809883a 	mov	r4,r3
 181e1c8:	2807883a 	mov	r3,r5
 181e1cc:	20c6b03a 	or	r3,r4,r3
 181e1d0:	10c002c5 	stb	r3,11(r2)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 181e1d4:	e0bffd0b 	ldhu	r2,-12(fp)
 181e1d8:	1004d0ba 	srli	r2,r2,2
 181e1dc:	10bfffcc 	andi	r2,r2,65535
 181e1e0:	10800144 	addi	r2,r2,5
 181e1e4:	1004933a 	slli	r2,r2,12
 181e1e8:	10bfffcc 	andi	r2,r2,65535
 181e1ec:	1004d23a 	srli	r2,r2,8
 181e1f0:	10840014 	ori	r2,r2,4096
 181e1f4:	100d883a 	mov	r6,r2
 181e1f8:	e0bffb17 	ldw	r2,-20(fp)
 181e1fc:	30ffffcc 	andi	r3,r6,65535
 181e200:	19403fcc 	andi	r5,r3,255
 181e204:	10c00303 	ldbu	r3,12(r2)
 181e208:	1806703a 	and	r3,r3,zero
 181e20c:	1809883a 	mov	r4,r3
 181e210:	2807883a 	mov	r3,r5
 181e214:	20c6b03a 	or	r3,r4,r3
 181e218:	10c00305 	stb	r3,12(r2)
 181e21c:	30ffffcc 	andi	r3,r6,65535
 181e220:	1806d23a 	srli	r3,r3,8
 181e224:	197fffcc 	andi	r5,r3,65535
 181e228:	10c00343 	ldbu	r3,13(r2)
 181e22c:	1806703a 	and	r3,r3,zero
 181e230:	1809883a 	mov	r4,r3
 181e234:	2807883a 	mov	r3,r5
 181e238:	20c6b03a 	or	r3,r4,r3
 181e23c:	10c00345 	stb	r3,13(r2)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 181e240:	e0bffc17 	ldw	r2,-16(fp)
 181e244:	10800c8b 	ldhu	r2,50(r2)
 181e248:	10bfffcc 	andi	r2,r2,65535
 181e24c:	1004d23a 	srli	r2,r2,8
 181e250:	1007883a 	mov	r3,r2
 181e254:	e0bffc17 	ldw	r2,-16(fp)
 181e258:	10800c8b 	ldhu	r2,50(r2)
 181e25c:	10bfffcc 	andi	r2,r2,65535
 181e260:	1004923a 	slli	r2,r2,8
 181e264:	1884b03a 	or	r2,r3,r2
 181e268:	100d883a 	mov	r6,r2
 181e26c:	e0bffb17 	ldw	r2,-20(fp)
 181e270:	30ffffcc 	andi	r3,r6,65535
 181e274:	19403fcc 	andi	r5,r3,255
 181e278:	10c00383 	ldbu	r3,14(r2)
 181e27c:	1806703a 	and	r3,r3,zero
 181e280:	1809883a 	mov	r4,r3
 181e284:	2807883a 	mov	r3,r5
 181e288:	20c6b03a 	or	r3,r4,r3
 181e28c:	10c00385 	stb	r3,14(r2)
 181e290:	30ffffcc 	andi	r3,r6,65535
 181e294:	1806d23a 	srli	r3,r3,8
 181e298:	197fffcc 	andi	r5,r3,65535
 181e29c:	10c003c3 	ldbu	r3,15(r2)
 181e2a0:	1806703a 	and	r3,r3,zero
 181e2a4:	1809883a 	mov	r4,r3
 181e2a8:	2807883a 	mov	r3,r5
 181e2ac:	20c6b03a 	or	r3,r4,r3
 181e2b0:	10c003c5 	stb	r3,15(r2)
    tcphdr->chksum = 0;
 181e2b4:	e0bffb17 	ldw	r2,-20(fp)
 181e2b8:	10c00403 	ldbu	r3,16(r2)
 181e2bc:	1806703a 	and	r3,r3,zero
 181e2c0:	10c00405 	stb	r3,16(r2)
 181e2c4:	10c00443 	ldbu	r3,17(r2)
 181e2c8:	1806703a 	and	r3,r3,zero
 181e2cc:	10c00445 	stb	r3,17(r2)
    tcphdr->urgp = 0;
 181e2d0:	e0bffb17 	ldw	r2,-20(fp)
 181e2d4:	10c00483 	ldbu	r3,18(r2)
 181e2d8:	1806703a 	and	r3,r3,zero
 181e2dc:	10c00485 	stb	r3,18(r2)
 181e2e0:	10c004c3 	ldbu	r3,19(r2)
 181e2e4:	1806703a 	and	r3,r3,zero
 181e2e8:	10c004c5 	stb	r3,19(r2)

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 181e2ec:	e0bffc17 	ldw	r2,-16(fp)
 181e2f0:	10c00b17 	ldw	r3,44(r2)
 181e2f4:	e0bffc17 	ldw	r2,-16(fp)
 181e2f8:	10800c8b 	ldhu	r2,50(r2)
 181e2fc:	10bfffcc 	andi	r2,r2,65535
 181e300:	1887883a 	add	r3,r3,r2
 181e304:	e0bffc17 	ldw	r2,-16(fp)
 181e308:	10c00d15 	stw	r3,52(r2)
  }
  return p;
 181e30c:	e0bffa17 	ldw	r2,-24(fp)
}
 181e310:	e037883a 	mov	sp,fp
 181e314:	dfc00117 	ldw	ra,4(sp)
 181e318:	df000017 	ldw	fp,0(sp)
 181e31c:	dec00204 	addi	sp,sp,8
 181e320:	f800283a 	ret

0181e324 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 181e324:	defffc04 	addi	sp,sp,-16
 181e328:	dfc00315 	stw	ra,12(sp)
 181e32c:	df000215 	stw	fp,8(sp)
 181e330:	df000204 	addi	fp,sp,8
 181e334:	e13fff15 	stw	r4,-4(fp)
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 181e338:	e0bfff17 	ldw	r2,-4(fp)
 181e33c:	10801c17 	ldw	r2,112(r2)
 181e340:	10004226 	beq	r2,zero,181e44c <tcp_send_fin+0x128>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 181e344:	e0bfff17 	ldw	r2,-4(fp)
 181e348:	10801c17 	ldw	r2,112(r2)
 181e34c:	e0bffe15 	stw	r2,-8(fp)
 181e350:	00000306 	br	181e360 <tcp_send_fin+0x3c>
         last_unsent = last_unsent->next);
 181e354:	e0bffe17 	ldw	r2,-8(fp)
 181e358:	10800017 	ldw	r2,0(r2)
 181e35c:	e0bffe15 	stw	r2,-8(fp)
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 181e360:	e0bffe17 	ldw	r2,-8(fp)
 181e364:	10800017 	ldw	r2,0(r2)
 181e368:	103ffa1e 	bne	r2,zero,181e354 <__ram_exceptions_end+0xff80df10>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 181e36c:	e0bffe17 	ldw	r2,-8(fp)
 181e370:	10800417 	ldw	r2,16(r2)
 181e374:	10c00303 	ldbu	r3,12(r2)
 181e378:	10800343 	ldbu	r2,13(r2)
 181e37c:	1004923a 	slli	r2,r2,8
 181e380:	10c4b03a 	or	r2,r2,r3
 181e384:	10bfffcc 	andi	r2,r2,65535
 181e388:	1004d23a 	srli	r2,r2,8
 181e38c:	10ffffcc 	andi	r3,r2,65535
 181e390:	e0bffe17 	ldw	r2,-8(fp)
 181e394:	10800417 	ldw	r2,16(r2)
 181e398:	11000303 	ldbu	r4,12(r2)
 181e39c:	10800343 	ldbu	r2,13(r2)
 181e3a0:	1004923a 	slli	r2,r2,8
 181e3a4:	1104b03a 	or	r2,r2,r4
 181e3a8:	10bfffcc 	andi	r2,r2,65535
 181e3ac:	1004923a 	slli	r2,r2,8
 181e3b0:	10bfffcc 	andi	r2,r2,65535
 181e3b4:	1884b03a 	or	r2,r3,r2
 181e3b8:	108001cc 	andi	r2,r2,7
 181e3bc:	1000231e 	bne	r2,zero,181e44c <tcp_send_fin+0x128>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 181e3c0:	e0bffe17 	ldw	r2,-8(fp)
 181e3c4:	10800417 	ldw	r2,16(r2)
 181e3c8:	e0fffe17 	ldw	r3,-8(fp)
 181e3cc:	18c00417 	ldw	r3,16(r3)
 181e3d0:	19000303 	ldbu	r4,12(r3)
 181e3d4:	18c00343 	ldbu	r3,13(r3)
 181e3d8:	1806923a 	slli	r3,r3,8
 181e3dc:	1906b03a 	or	r3,r3,r4
 181e3e0:	18c04014 	ori	r3,r3,256
 181e3e4:	180d883a 	mov	r6,r3
 181e3e8:	30ffffcc 	andi	r3,r6,65535
 181e3ec:	19403fcc 	andi	r5,r3,255
 181e3f0:	10c00303 	ldbu	r3,12(r2)
 181e3f4:	1806703a 	and	r3,r3,zero
 181e3f8:	1809883a 	mov	r4,r3
 181e3fc:	2807883a 	mov	r3,r5
 181e400:	20c6b03a 	or	r3,r4,r3
 181e404:	10c00305 	stb	r3,12(r2)
 181e408:	30ffffcc 	andi	r3,r6,65535
 181e40c:	1806d23a 	srli	r3,r3,8
 181e410:	197fffcc 	andi	r5,r3,65535
 181e414:	10c00343 	ldbu	r3,13(r2)
 181e418:	1806703a 	and	r3,r3,zero
 181e41c:	1809883a 	mov	r4,r3
 181e420:	2807883a 	mov	r3,r5
 181e424:	20c6b03a 	or	r3,r4,r3
 181e428:	10c00345 	stb	r3,13(r2)
      pcb->flags |= TF_FIN;
 181e42c:	e0bfff17 	ldw	r2,-4(fp)
 181e430:	10800883 	ldbu	r2,34(r2)
 181e434:	10800814 	ori	r2,r2,32
 181e438:	1007883a 	mov	r3,r2
 181e43c:	e0bfff17 	ldw	r2,-4(fp)
 181e440:	10c00885 	stb	r3,34(r2)
      return ERR_OK;
 181e444:	0005883a 	mov	r2,zero
 181e448:	00000306 	br	181e458 <tcp_send_fin+0x134>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 181e44c:	01400044 	movi	r5,1
 181e450:	e13fff17 	ldw	r4,-4(fp)
 181e454:	181f4380 	call	181f438 <tcp_enqueue_flags>
}
 181e458:	e037883a 	mov	sp,fp
 181e45c:	dfc00117 	ldw	ra,4(sp)
 181e460:	df000017 	ldw	fp,0(sp)
 181e464:	dec00204 	addi	sp,sp,8
 181e468:	f800283a 	ret

0181e46c <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
 181e46c:	defff704 	addi	sp,sp,-36
 181e470:	dfc00815 	stw	ra,32(sp)
 181e474:	df000715 	stw	fp,28(sp)
 181e478:	df000704 	addi	fp,sp,28
 181e47c:	e13ffb15 	stw	r4,-20(fp)
 181e480:	e17ffc15 	stw	r5,-16(fp)
 181e484:	3007883a 	mov	r3,r6
 181e488:	e1fffe15 	stw	r7,-8(fp)
 181e48c:	e0800217 	ldw	r2,8(fp)
 181e490:	e0fffd05 	stb	r3,-12(fp)
 181e494:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 181e498:	e0bfff03 	ldbu	r2,-4(fp)
 181e49c:	1080004c 	andi	r2,r2,1
 181e4a0:	10000226 	beq	r2,zero,181e4ac <tcp_create_segment+0x40>
 181e4a4:	00c00104 	movi	r3,4
 181e4a8:	00000106 	br	181e4b0 <tcp_create_segment+0x44>
 181e4ac:	0007883a 	mov	r3,zero
 181e4b0:	e0bfff03 	ldbu	r2,-4(fp)
 181e4b4:	1080008c 	andi	r2,r2,2
 181e4b8:	10000226 	beq	r2,zero,181e4c4 <tcp_create_segment+0x58>
 181e4bc:	00800304 	movi	r2,12
 181e4c0:	00000106 	br	181e4c8 <tcp_create_segment+0x5c>
 181e4c4:	0005883a 	mov	r2,zero
 181e4c8:	1885883a 	add	r2,r3,r2
 181e4cc:	e0bff905 	stb	r2,-28(fp)

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 181e4d0:	01000104 	movi	r4,4
 181e4d4:	18349580 	call	1834958 <memp_malloc>
 181e4d8:	e0bffa15 	stw	r2,-24(fp)
 181e4dc:	e0bffa17 	ldw	r2,-24(fp)
 181e4e0:	1000041e 	bne	r2,zero,181e4f4 <tcp_create_segment+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 181e4e4:	e13ffc17 	ldw	r4,-16(fp)
 181e4e8:	181aca40 	call	181aca4 <pbuf_free>
    return NULL;
 181e4ec:	0005883a 	mov	r2,zero
 181e4f0:	0000c106 	br	181e7f8 <tcp_create_segment+0x38c>
  }
  seg->flags = optflags;
 181e4f4:	e0bffa17 	ldw	r2,-24(fp)
 181e4f8:	e0ffff03 	ldbu	r3,-4(fp)
 181e4fc:	10c00345 	stb	r3,13(r2)
  seg->next = NULL;
 181e500:	e0bffa17 	ldw	r2,-24(fp)
 181e504:	10000015 	stw	zero,0(r2)
  seg->p = p;
 181e508:	e0bffa17 	ldw	r2,-24(fp)
 181e50c:	e0fffc17 	ldw	r3,-16(fp)
 181e510:	10c00115 	stw	r3,4(r2)
  seg->len = p->tot_len - optlen;
 181e514:	e0bffc17 	ldw	r2,-16(fp)
 181e518:	10c0020b 	ldhu	r3,8(r2)
 181e51c:	e0bff903 	ldbu	r2,-28(fp)
 181e520:	1885c83a 	sub	r2,r3,r2
 181e524:	1007883a 	mov	r3,r2
 181e528:	e0bffa17 	ldw	r2,-24(fp)
 181e52c:	10c0020d 	sth	r3,8(r2)
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 181e530:	e0bffa17 	ldw	r2,-24(fp)
 181e534:	1000028d 	sth	zero,10(r2)
  seg->chksum_swapped = 0;
 181e538:	e0bffa17 	ldw	r2,-24(fp)
 181e53c:	10000305 	stb	zero,12(r2)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 181e540:	01400504 	movi	r5,20
 181e544:	e13ffc17 	ldw	r4,-16(fp)
 181e548:	181aaf40 	call	181aaf4 <pbuf_header>
 181e54c:	10803fcc 	andi	r2,r2,255
 181e550:	10000b26 	beq	r2,zero,181e580 <tcp_create_segment+0x114>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
 181e554:	008061f4 	movhi	r2,391
 181e558:	10a9d404 	addi	r2,r2,-22704
 181e55c:	10805217 	ldw	r2,328(r2)
 181e560:	10c00044 	addi	r3,r2,1
 181e564:	008061f4 	movhi	r2,391
 181e568:	10a9d404 	addi	r2,r2,-22704
 181e56c:	10c05215 	stw	r3,328(r2)
    tcp_seg_free(seg);
 181e570:	e13ffa17 	ldw	r4,-24(fp)
 181e574:	181d56c0 	call	181d56c <tcp_seg_free>
    return NULL;
 181e578:	0005883a 	mov	r2,zero
 181e57c:	00009e06 	br	181e7f8 <tcp_create_segment+0x38c>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 181e580:	e0bffa17 	ldw	r2,-24(fp)
 181e584:	10800117 	ldw	r2,4(r2)
 181e588:	10c00117 	ldw	r3,4(r2)
 181e58c:	e0bffa17 	ldw	r2,-24(fp)
 181e590:	10c00415 	stw	r3,16(r2)
  seg->tcphdr->src = htons(pcb->local_port);
 181e594:	e0bffa17 	ldw	r2,-24(fp)
 181e598:	10800417 	ldw	r2,16(r2)
 181e59c:	e0fffb17 	ldw	r3,-20(fp)
 181e5a0:	18c0078b 	ldhu	r3,30(r3)
 181e5a4:	18ffffcc 	andi	r3,r3,65535
 181e5a8:	1806d23a 	srli	r3,r3,8
 181e5ac:	1809883a 	mov	r4,r3
 181e5b0:	e0fffb17 	ldw	r3,-20(fp)
 181e5b4:	18c0078b 	ldhu	r3,30(r3)
 181e5b8:	18ffffcc 	andi	r3,r3,65535
 181e5bc:	1806923a 	slli	r3,r3,8
 181e5c0:	20c6b03a 	or	r3,r4,r3
 181e5c4:	180d883a 	mov	r6,r3
 181e5c8:	30ffffcc 	andi	r3,r6,65535
 181e5cc:	19403fcc 	andi	r5,r3,255
 181e5d0:	10c00003 	ldbu	r3,0(r2)
 181e5d4:	1806703a 	and	r3,r3,zero
 181e5d8:	1809883a 	mov	r4,r3
 181e5dc:	2807883a 	mov	r3,r5
 181e5e0:	20c6b03a 	or	r3,r4,r3
 181e5e4:	10c00005 	stb	r3,0(r2)
 181e5e8:	30ffffcc 	andi	r3,r6,65535
 181e5ec:	1806d23a 	srli	r3,r3,8
 181e5f0:	197fffcc 	andi	r5,r3,65535
 181e5f4:	10c00043 	ldbu	r3,1(r2)
 181e5f8:	1806703a 	and	r3,r3,zero
 181e5fc:	1809883a 	mov	r4,r3
 181e600:	2807883a 	mov	r3,r5
 181e604:	20c6b03a 	or	r3,r4,r3
 181e608:	10c00045 	stb	r3,1(r2)
  seg->tcphdr->dest = htons(pcb->remote_port);
 181e60c:	e0bffa17 	ldw	r2,-24(fp)
 181e610:	10800417 	ldw	r2,16(r2)
 181e614:	e0fffb17 	ldw	r3,-20(fp)
 181e618:	18c0080b 	ldhu	r3,32(r3)
 181e61c:	18ffffcc 	andi	r3,r3,65535
 181e620:	1806d23a 	srli	r3,r3,8
 181e624:	1809883a 	mov	r4,r3
 181e628:	e0fffb17 	ldw	r3,-20(fp)
 181e62c:	18c0080b 	ldhu	r3,32(r3)
 181e630:	18ffffcc 	andi	r3,r3,65535
 181e634:	1806923a 	slli	r3,r3,8
 181e638:	20c6b03a 	or	r3,r4,r3
 181e63c:	180d883a 	mov	r6,r3
 181e640:	30ffffcc 	andi	r3,r6,65535
 181e644:	19403fcc 	andi	r5,r3,255
 181e648:	10c00083 	ldbu	r3,2(r2)
 181e64c:	1806703a 	and	r3,r3,zero
 181e650:	1809883a 	mov	r4,r3
 181e654:	2807883a 	mov	r3,r5
 181e658:	20c6b03a 	or	r3,r4,r3
 181e65c:	10c00085 	stb	r3,2(r2)
 181e660:	30ffffcc 	andi	r3,r6,65535
 181e664:	1806d23a 	srli	r3,r3,8
 181e668:	197fffcc 	andi	r5,r3,65535
 181e66c:	10c000c3 	ldbu	r3,3(r2)
 181e670:	1806703a 	and	r3,r3,zero
 181e674:	1809883a 	mov	r4,r3
 181e678:	2807883a 	mov	r3,r5
 181e67c:	20c6b03a 	or	r3,r4,r3
 181e680:	10c000c5 	stb	r3,3(r2)
  seg->tcphdr->seqno = htonl(seqno);
 181e684:	e0bffa17 	ldw	r2,-24(fp)
 181e688:	10800417 	ldw	r2,16(r2)
 181e68c:	e0fffe17 	ldw	r3,-8(fp)
 181e690:	1808d63a 	srli	r4,r3,24
 181e694:	e0fffe17 	ldw	r3,-8(fp)
 181e698:	1806d23a 	srli	r3,r3,8
 181e69c:	18ffc00c 	andi	r3,r3,65280
 181e6a0:	20c8b03a 	or	r4,r4,r3
 181e6a4:	e0fffe17 	ldw	r3,-8(fp)
 181e6a8:	18ffc00c 	andi	r3,r3,65280
 181e6ac:	1806923a 	slli	r3,r3,8
 181e6b0:	20c8b03a 	or	r4,r4,r3
 181e6b4:	e0fffe17 	ldw	r3,-8(fp)
 181e6b8:	1806963a 	slli	r3,r3,24
 181e6bc:	20c6b03a 	or	r3,r4,r3
 181e6c0:	19803fcc 	andi	r6,r3,255
 181e6c4:	11000103 	ldbu	r4,4(r2)
 181e6c8:	2008703a 	and	r4,r4,zero
 181e6cc:	200b883a 	mov	r5,r4
 181e6d0:	3009883a 	mov	r4,r6
 181e6d4:	2908b03a 	or	r4,r5,r4
 181e6d8:	11000105 	stb	r4,4(r2)
 181e6dc:	1808d23a 	srli	r4,r3,8
 181e6e0:	21803fcc 	andi	r6,r4,255
 181e6e4:	11000143 	ldbu	r4,5(r2)
 181e6e8:	2008703a 	and	r4,r4,zero
 181e6ec:	200b883a 	mov	r5,r4
 181e6f0:	3009883a 	mov	r4,r6
 181e6f4:	2908b03a 	or	r4,r5,r4
 181e6f8:	11000145 	stb	r4,5(r2)
 181e6fc:	1808d43a 	srli	r4,r3,16
 181e700:	21803fcc 	andi	r6,r4,255
 181e704:	11000183 	ldbu	r4,6(r2)
 181e708:	2008703a 	and	r4,r4,zero
 181e70c:	200b883a 	mov	r5,r4
 181e710:	3009883a 	mov	r4,r6
 181e714:	2908b03a 	or	r4,r5,r4
 181e718:	11000185 	stb	r4,6(r2)
 181e71c:	180ad63a 	srli	r5,r3,24
 181e720:	10c001c3 	ldbu	r3,7(r2)
 181e724:	1806703a 	and	r3,r3,zero
 181e728:	1809883a 	mov	r4,r3
 181e72c:	2807883a 	mov	r3,r5
 181e730:	20c6b03a 	or	r3,r4,r3
 181e734:	10c001c5 	stb	r3,7(r2)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 181e738:	e0bffa17 	ldw	r2,-24(fp)
 181e73c:	10800417 	ldw	r2,16(r2)
 181e740:	e0fff903 	ldbu	r3,-28(fp)
 181e744:	1806d0ba 	srli	r3,r3,2
 181e748:	18c03fcc 	andi	r3,r3,255
 181e74c:	18c00144 	addi	r3,r3,5
 181e750:	1808933a 	slli	r4,r3,12
 181e754:	e0fffd03 	ldbu	r3,-12(fp)
 181e758:	20c6b03a 	or	r3,r4,r3
 181e75c:	18ffc00c 	andi	r3,r3,65280
 181e760:	1807d23a 	srai	r3,r3,8
 181e764:	180b883a 	mov	r5,r3
 181e768:	e0fff903 	ldbu	r3,-28(fp)
 181e76c:	1806d0ba 	srli	r3,r3,2
 181e770:	18c03fcc 	andi	r3,r3,255
 181e774:	18c00144 	addi	r3,r3,5
 181e778:	1808933a 	slli	r4,r3,12
 181e77c:	e0fffd03 	ldbu	r3,-12(fp)
 181e780:	20c6b03a 	or	r3,r4,r3
 181e784:	1806923a 	slli	r3,r3,8
 181e788:	28c6b03a 	or	r3,r5,r3
 181e78c:	180d883a 	mov	r6,r3
 181e790:	30ffffcc 	andi	r3,r6,65535
 181e794:	19403fcc 	andi	r5,r3,255
 181e798:	10c00303 	ldbu	r3,12(r2)
 181e79c:	1806703a 	and	r3,r3,zero
 181e7a0:	1809883a 	mov	r4,r3
 181e7a4:	2807883a 	mov	r3,r5
 181e7a8:	20c6b03a 	or	r3,r4,r3
 181e7ac:	10c00305 	stb	r3,12(r2)
 181e7b0:	30ffffcc 	andi	r3,r6,65535
 181e7b4:	1806d23a 	srli	r3,r3,8
 181e7b8:	197fffcc 	andi	r5,r3,65535
 181e7bc:	10c00343 	ldbu	r3,13(r2)
 181e7c0:	1806703a 	and	r3,r3,zero
 181e7c4:	1809883a 	mov	r4,r3
 181e7c8:	2807883a 	mov	r3,r5
 181e7cc:	20c6b03a 	or	r3,r4,r3
 181e7d0:	10c00345 	stb	r3,13(r2)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 181e7d4:	e0bffa17 	ldw	r2,-24(fp)
 181e7d8:	10800417 	ldw	r2,16(r2)
 181e7dc:	10c00483 	ldbu	r3,18(r2)
 181e7e0:	1806703a 	and	r3,r3,zero
 181e7e4:	10c00485 	stb	r3,18(r2)
 181e7e8:	10c004c3 	ldbu	r3,19(r2)
 181e7ec:	1806703a 	and	r3,r3,zero
 181e7f0:	10c004c5 	stb	r3,19(r2)
  return seg;
 181e7f4:	e0bffa17 	ldw	r2,-24(fp)
} 
 181e7f8:	e037883a 	mov	sp,fp
 181e7fc:	dfc00117 	ldw	ra,4(sp)
 181e800:	df000017 	ldw	fp,0(sp)
 181e804:	dec00204 	addi	sp,sp,8
 181e808:	f800283a 	ret

0181e80c <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 181e80c:	defff604 	addi	sp,sp,-40
 181e810:	dfc00915 	stw	ra,36(sp)
 181e814:	df000815 	stw	fp,32(sp)
 181e818:	df000804 	addi	fp,sp,32
 181e81c:	e13ffa15 	stw	r4,-24(fp)
 181e820:	3009883a 	mov	r4,r6
 181e824:	e1fffd15 	stw	r7,-12(fp)
 181e828:	e0c00317 	ldw	r3,12(fp)
 181e82c:	e0800417 	ldw	r2,16(fp)
 181e830:	e17ffb0d 	sth	r5,-20(fp)
 181e834:	e13ffc0d 	sth	r4,-16(fp)
 181e838:	e0fffe05 	stb	r3,-8(fp)
 181e83c:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  u16_t alloc = length;
 181e840:	e0bffb0b 	ldhu	r2,-20(fp)
 181e844:	e0bff80d 	sth	r2,-32(fp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 181e848:	e0fffb0b 	ldhu	r3,-20(fp)
 181e84c:	e0bffc0b 	ldhu	r2,-16(fp)
 181e850:	1880182e 	bgeu	r3,r2,181e8b4 <tcp_pbuf_prealloc+0xa8>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 181e854:	e0bffe03 	ldbu	r2,-8(fp)
 181e858:	1080008c 	andi	r2,r2,2
 181e85c:	10000d1e 	bne	r2,zero,181e894 <tcp_pbuf_prealloc+0x88>
        (!(pcb->flags & TF_NODELAY) &&
 181e860:	e0800217 	ldw	r2,8(fp)
 181e864:	10800883 	ldbu	r2,34(r2)
 181e868:	10803fcc 	andi	r2,r2,255
 181e86c:	1080100c 	andi	r2,r2,64
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 181e870:	1000101e 	bne	r2,zero,181e8b4 <tcp_pbuf_prealloc+0xa8>
        (!(pcb->flags & TF_NODELAY) &&
 181e874:	e0bfff03 	ldbu	r2,-4(fp)
 181e878:	10000626 	beq	r2,zero,181e894 <tcp_pbuf_prealloc+0x88>
         (!first_seg ||
          pcb->unsent != NULL ||
 181e87c:	e0800217 	ldw	r2,8(fp)
 181e880:	10801c17 	ldw	r2,112(r2)
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
 181e884:	1000031e 	bne	r2,zero,181e894 <tcp_pbuf_prealloc+0x88>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
 181e888:	e0800217 	ldw	r2,8(fp)
 181e88c:	10801d17 	ldw	r2,116(r2)
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
 181e890:	10000826 	beq	r2,zero,181e8b4 <tcp_pbuf_prealloc+0xa8>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 181e894:	e0bffb0b 	ldhu	r2,-20(fp)
 181e898:	10c16dc4 	addi	r3,r2,1463
 181e89c:	00bfff04 	movi	r2,-4
 181e8a0:	1884703a 	and	r2,r3,r2
 181e8a4:	e0fffc0b 	ldhu	r3,-16(fp)
 181e8a8:	1880010e 	bge	r3,r2,181e8b0 <tcp_pbuf_prealloc+0xa4>
 181e8ac:	1805883a 	mov	r2,r3
 181e8b0:	e0bff80d 	sth	r2,-32(fp)
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 181e8b4:	e0bff80b 	ldhu	r2,-32(fp)
 181e8b8:	000d883a 	mov	r6,zero
 181e8bc:	100b883a 	mov	r5,r2
 181e8c0:	e13ffa17 	ldw	r4,-24(fp)
 181e8c4:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181e8c8:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
 181e8cc:	e0bff917 	ldw	r2,-28(fp)
 181e8d0:	1000021e 	bne	r2,zero,181e8dc <tcp_pbuf_prealloc+0xd0>
    return NULL;
 181e8d4:	0005883a 	mov	r2,zero
 181e8d8:	00000f06 	br	181e918 <tcp_pbuf_prealloc+0x10c>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 181e8dc:	e0bff917 	ldw	r2,-28(fp)
 181e8e0:	10c0028b 	ldhu	r3,10(r2)
 181e8e4:	e0bffb0b 	ldhu	r2,-20(fp)
 181e8e8:	1885c83a 	sub	r2,r3,r2
 181e8ec:	1007883a 	mov	r3,r2
 181e8f0:	e0bffd17 	ldw	r2,-12(fp)
 181e8f4:	10c0000d 	sth	r3,0(r2)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 181e8f8:	e0bff917 	ldw	r2,-28(fp)
 181e8fc:	e0fffb0b 	ldhu	r3,-20(fp)
 181e900:	10c0020d 	sth	r3,8(r2)
 181e904:	e0bff917 	ldw	r2,-28(fp)
 181e908:	10c0020b 	ldhu	r3,8(r2)
 181e90c:	e0bff917 	ldw	r2,-28(fp)
 181e910:	10c0028d 	sth	r3,10(r2)
  return p;
 181e914:	e0bff917 	ldw	r2,-28(fp)
}
 181e918:	e037883a 	mov	sp,fp
 181e91c:	dfc00117 	ldw	ra,4(sp)
 181e920:	df000017 	ldw	fp,0(sp)
 181e924:	dec00204 	addi	sp,sp,8
 181e928:	f800283a 	ret

0181e92c <tcp_seg_add_chksum>:
#if TCP_CHECKSUM_ON_COPY
/** Add a checksum of newly added data to the segment */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 181e92c:	defffa04 	addi	sp,sp,-24
 181e930:	df000515 	stw	fp,20(sp)
 181e934:	df000504 	addi	fp,sp,20
 181e938:	2007883a 	mov	r3,r4
 181e93c:	2805883a 	mov	r2,r5
 181e940:	e1bffe15 	stw	r6,-8(fp)
 181e944:	e1ffff15 	stw	r7,-4(fp)
 181e948:	e0fffc0d 	sth	r3,-16(fp)
 181e94c:	e0bffd0d 	sth	r2,-12(fp)
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 181e950:	e0fffc0b 	ldhu	r3,-16(fp)
 181e954:	e0bffe17 	ldw	r2,-8(fp)
 181e958:	1080000b 	ldhu	r2,0(r2)
 181e95c:	10bfffcc 	andi	r2,r2,65535
 181e960:	1885883a 	add	r2,r3,r2
 181e964:	e0bffb15 	stw	r2,-20(fp)
  chksum = FOLD_U32T(helper);
 181e968:	e0bffb17 	ldw	r2,-20(fp)
 181e96c:	1004d43a 	srli	r2,r2,16
 181e970:	1007883a 	mov	r3,r2
 181e974:	e0bffb17 	ldw	r2,-20(fp)
 181e978:	1885883a 	add	r2,r3,r2
 181e97c:	e0bffc0d 	sth	r2,-16(fp)
  if ((len & 1) != 0) {
 181e980:	e0bffd0b 	ldhu	r2,-12(fp)
 181e984:	1080004c 	andi	r2,r2,1
 181e988:	10000e26 	beq	r2,zero,181e9c4 <tcp_seg_add_chksum+0x98>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 181e98c:	e0bfff17 	ldw	r2,-4(fp)
 181e990:	10800003 	ldbu	r2,0(r2)
 181e994:	00c00044 	movi	r3,1
 181e998:	1885c83a 	sub	r2,r3,r2
 181e99c:	1007883a 	mov	r3,r2
 181e9a0:	e0bfff17 	ldw	r2,-4(fp)
 181e9a4:	10c00005 	stb	r3,0(r2)
    chksum = SWAP_BYTES_IN_WORD(chksum);
 181e9a8:	e0bffc0b 	ldhu	r2,-16(fp)
 181e9ac:	1004d23a 	srli	r2,r2,8
 181e9b0:	1007883a 	mov	r3,r2
 181e9b4:	e0bffc0b 	ldhu	r2,-16(fp)
 181e9b8:	1004923a 	slli	r2,r2,8
 181e9bc:	1884b03a 	or	r2,r3,r2
 181e9c0:	e0bffc0d 	sth	r2,-16(fp)
  }
  *seg_chksum = chksum;
 181e9c4:	e0bffe17 	ldw	r2,-8(fp)
 181e9c8:	e0fffc0b 	ldhu	r3,-16(fp)
 181e9cc:	10c0000d 	sth	r3,0(r2)
}
 181e9d0:	0001883a 	nop
 181e9d4:	e037883a 	mov	sp,fp
 181e9d8:	df000017 	ldw	fp,0(sp)
 181e9dc:	dec00104 	addi	sp,sp,4
 181e9e0:	f800283a 	ret

0181e9e4 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 181e9e4:	defffd04 	addi	sp,sp,-12
 181e9e8:	df000215 	stw	fp,8(sp)
 181e9ec:	df000204 	addi	fp,sp,8
 181e9f0:	e13ffe15 	stw	r4,-8(fp)
 181e9f4:	2805883a 	mov	r2,r5
 181e9f8:	e0bfff0d 	sth	r2,-4(fp)
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 181e9fc:	e0bffe17 	ldw	r2,-8(fp)
 181ea00:	10800617 	ldw	r2,24(r2)
 181ea04:	10800120 	cmpeqi	r2,r2,4
 181ea08:	10000e1e 	bne	r2,zero,181ea44 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
 181ea0c:	e0bffe17 	ldw	r2,-8(fp)
 181ea10:	10800617 	ldw	r2,24(r2)
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 181ea14:	108001e0 	cmpeqi	r2,r2,7
 181ea18:	10000a1e 	bne	r2,zero,181ea44 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 181ea1c:	e0bffe17 	ldw	r2,-8(fp)
 181ea20:	10800617 	ldw	r2,24(r2)
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
 181ea24:	108000a0 	cmpeqi	r2,r2,2
 181ea28:	1000061e 	bne	r2,zero,181ea44 <tcp_write_checks+0x60>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
 181ea2c:	e0bffe17 	ldw	r2,-8(fp)
 181ea30:	10800617 	ldw	r2,24(r2)
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 181ea34:	108000e0 	cmpeqi	r2,r2,3
 181ea38:	1000021e 	bne	r2,zero,181ea44 <tcp_write_checks+0x60>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 181ea3c:	00bffcc4 	movi	r2,-13
 181ea40:	00002d06 	br	181eaf8 <tcp_write_checks+0x114>
  } else if (len == 0) {
 181ea44:	e0bfff0b 	ldhu	r2,-4(fp)
 181ea48:	1000021e 	bne	r2,zero,181ea54 <tcp_write_checks+0x70>
    return ERR_OK;
 181ea4c:	0005883a 	mov	r2,zero
 181ea50:	00002906 	br	181eaf8 <tcp_write_checks+0x114>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 181ea54:	e0bffe17 	ldw	r2,-8(fp)
 181ea58:	10801a8b 	ldhu	r2,106(r2)
 181ea5c:	10ffffcc 	andi	r3,r2,65535
 181ea60:	e0bfff0b 	ldhu	r2,-4(fp)
 181ea64:	1880092e 	bgeu	r3,r2,181ea8c <tcp_write_checks+0xa8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 181ea68:	e0bffe17 	ldw	r2,-8(fp)
 181ea6c:	10c00883 	ldbu	r3,34(r2)
 181ea70:	00bfe004 	movi	r2,-128
 181ea74:	1884b03a 	or	r2,r3,r2
 181ea78:	1007883a 	mov	r3,r2
 181ea7c:	e0bffe17 	ldw	r2,-8(fp)
 181ea80:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 181ea84:	00bfffc4 	movi	r2,-1
 181ea88:	00001b06 	br	181eaf8 <tcp_write_checks+0x114>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 181ea8c:	e0bffe17 	ldw	r2,-8(fp)
 181ea90:	10801b0b 	ldhu	r2,108(r2)
 181ea94:	10bfffcc 	andi	r2,r2,65535
 181ea98:	10800228 	cmpgeui	r2,r2,8
 181ea9c:	1000051e 	bne	r2,zero,181eab4 <tcp_write_checks+0xd0>
 181eaa0:	e0bffe17 	ldw	r2,-8(fp)
 181eaa4:	10801b0b 	ldhu	r2,108(r2)
 181eaa8:	10bfffcc 	andi	r2,r2,65535
 181eaac:	10bfff70 	cmpltui	r2,r2,65533
 181eab0:	1000101e 	bne	r2,zero,181eaf4 <tcp_write_checks+0x110>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 181eab4:	008061f4 	movhi	r2,391
 181eab8:	10a9d404 	addi	r2,r2,-22704
 181eabc:	10804e17 	ldw	r2,312(r2)
 181eac0:	10c00044 	addi	r3,r2,1
 181eac4:	008061f4 	movhi	r2,391
 181eac8:	10a9d404 	addi	r2,r2,-22704
 181eacc:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
 181ead0:	e0bffe17 	ldw	r2,-8(fp)
 181ead4:	10c00883 	ldbu	r3,34(r2)
 181ead8:	00bfe004 	movi	r2,-128
 181eadc:	1884b03a 	or	r2,r3,r2
 181eae0:	1007883a 	mov	r3,r2
 181eae4:	e0bffe17 	ldw	r2,-8(fp)
 181eae8:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 181eaec:	00bfffc4 	movi	r2,-1
 181eaf0:	00000106 	br	181eaf8 <tcp_write_checks+0x114>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 181eaf4:	0005883a 	mov	r2,zero
}
 181eaf8:	e037883a 	mov	sp,fp
 181eafc:	df000017 	ldw	fp,0(sp)
 181eb00:	dec00104 	addi	sp,sp,4
 181eb04:	f800283a 	ret

0181eb08 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 181eb08:	deffe504 	addi	sp,sp,-108
 181eb0c:	dfc01a15 	stw	ra,104(sp)
 181eb10:	df001915 	stw	fp,100(sp)
 181eb14:	df001904 	addi	fp,sp,100
 181eb18:	e13ffc15 	stw	r4,-16(fp)
 181eb1c:	e17ffd15 	stw	r5,-12(fp)
 181eb20:	3007883a 	mov	r3,r6
 181eb24:	3805883a 	mov	r2,r7
 181eb28:	e0fffe0d 	sth	r3,-8(fp)
 181eb2c:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *concat_p = NULL;
 181eb30:	e03fea15 	stw	zero,-88(fp)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 181eb34:	e03feb15 	stw	zero,-84(fp)
 181eb38:	e03fec15 	stw	zero,-80(fp)
 181eb3c:	e03fed15 	stw	zero,-76(fp)
 181eb40:	e03fee15 	stw	zero,-72(fp)
  u16_t pos = 0; /* position in 'arg' data */
 181eb44:	e03fef0d 	sth	zero,-68(fp)
  u16_t queuelen;
  u8_t optlen = 0;
 181eb48:	e03ff405 	stb	zero,-48(fp)
  u8_t optflags = 0;
 181eb4c:	e03ff445 	stb	zero,-47(fp)
#if TCP_OVERSIZE
  u16_t oversize = 0;
 181eb50:	e03ff90d 	sth	zero,-28(fp)
  u16_t oversize_used = 0;
 181eb54:	e03ff00d 	sth	zero,-64(fp)
#endif /* TCP_OVERSIZE */
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 181eb58:	e03ff98d 	sth	zero,-26(fp)
  u8_t concat_chksum_swapped = 0;
 181eb5c:	e03ffa05 	stb	zero,-24(fp)
  u16_t concat_chksummed = 0;
 181eb60:	e03ff08d 	sth	zero,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 181eb64:	e0bffc17 	ldw	r2,-16(fp)
 181eb68:	1080198b 	ldhu	r2,102(r2)
 181eb6c:	10bfffcc 	andi	r2,r2,65535
 181eb70:	1004d07a 	srli	r2,r2,1
 181eb74:	1007883a 	mov	r3,r2
 181eb78:	e0bffc17 	ldw	r2,-16(fp)
 181eb7c:	11400e8b 	ldhu	r5,58(r2)
 181eb80:	1805883a 	mov	r2,r3
 181eb84:	10ffffcc 	andi	r3,r2,65535
 181eb88:	293fffcc 	andi	r4,r5,65535
 181eb8c:	20c0012e 	bgeu	r4,r3,181eb94 <tcp_write+0x8c>
 181eb90:	2805883a 	mov	r2,r5
 181eb94:	e0bff48d 	sth	r2,-46(fp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 181eb98:	e0bffd17 	ldw	r2,-12(fp)
 181eb9c:	1000091e 	bne	r2,zero,181ebc4 <tcp_write+0xbc>
 181eba0:	01c06134 	movhi	r7,388
 181eba4:	39c71004 	addi	r7,r7,7232
 181eba8:	01805fc4 	movi	r6,383
 181ebac:	01406134 	movhi	r5,388
 181ebb0:	29471604 	addi	r5,r5,7256
 181ebb4:	01006134 	movhi	r4,388
 181ebb8:	21072304 	addi	r4,r4,7308
 181ebbc:	1800c180 	call	1800c18 <printf>
 181ebc0:	003fff06 	br	181ebc0 <__ram_exceptions_end+0xff80e77c>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 181ebc4:	e0bffe0b 	ldhu	r2,-8(fp)
 181ebc8:	100b883a 	mov	r5,r2
 181ebcc:	e13ffc17 	ldw	r4,-16(fp)
 181ebd0:	181e9e40 	call	181e9e4 <tcp_write_checks>
 181ebd4:	e0bff505 	stb	r2,-44(fp)
  if (err != ERR_OK) {
 181ebd8:	e0bff507 	ldb	r2,-44(fp)
 181ebdc:	10000226 	beq	r2,zero,181ebe8 <tcp_write+0xe0>
    return err;
 181ebe0:	e0bff503 	ldbu	r2,-44(fp)
 181ebe4:	00020f06 	br	181f424 <tcp_write+0x91c>
  }
  queuelen = pcb->snd_queuelen;
 181ebe8:	e0bffc17 	ldw	r2,-16(fp)
 181ebec:	10801b0b 	ldhu	r2,108(r2)
 181ebf0:	e0bfef8d 	sth	r2,-66(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 181ebf4:	e0bffc17 	ldw	r2,-16(fp)
 181ebf8:	10801c17 	ldw	r2,112(r2)
 181ebfc:	10014326 	beq	r2,zero,181f10c <tcp_write+0x604>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 181ec00:	e0bffc17 	ldw	r2,-16(fp)
 181ec04:	10801c17 	ldw	r2,112(r2)
 181ec08:	e0bfeb15 	stw	r2,-84(fp)
 181ec0c:	00000306 	br	181ec1c <tcp_write+0x114>
         last_unsent = last_unsent->next);
 181ec10:	e0bfeb17 	ldw	r2,-84(fp)
 181ec14:	10800017 	ldw	r2,0(r2)
 181ec18:	e0bfeb15 	stw	r2,-84(fp)
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 181ec1c:	e0bfeb17 	ldw	r2,-84(fp)
 181ec20:	10800017 	ldw	r2,0(r2)
 181ec24:	103ffa1e 	bne	r2,zero,181ec10 <__ram_exceptions_end+0xff80e7cc>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 181ec28:	e0bfeb17 	ldw	r2,-84(fp)
 181ec2c:	10800343 	ldbu	r2,13(r2)
 181ec30:	10803fcc 	andi	r2,r2,255
 181ec34:	1080004c 	andi	r2,r2,1
 181ec38:	10000226 	beq	r2,zero,181ec44 <tcp_write+0x13c>
 181ec3c:	00c00104 	movi	r3,4
 181ec40:	00000106 	br	181ec48 <tcp_write+0x140>
 181ec44:	0007883a 	mov	r3,zero
 181ec48:	e0bfeb17 	ldw	r2,-84(fp)
 181ec4c:	10800343 	ldbu	r2,13(r2)
 181ec50:	10803fcc 	andi	r2,r2,255
 181ec54:	1080008c 	andi	r2,r2,2
 181ec58:	10000226 	beq	r2,zero,181ec64 <tcp_write+0x15c>
 181ec5c:	00800304 	movi	r2,12
 181ec60:	00000106 	br	181ec68 <tcp_write+0x160>
 181ec64:	0005883a 	mov	r2,zero
 181ec68:	1885883a 	add	r2,r3,r2
 181ec6c:	e0bff58d 	sth	r2,-42(fp)
    space = mss_local - (last_unsent->len + unsent_optlen);
 181ec70:	e0bfeb17 	ldw	r2,-84(fp)
 181ec74:	10c0020b 	ldhu	r3,8(r2)
 181ec78:	e0bff58b 	ldhu	r2,-42(fp)
 181ec7c:	1885883a 	add	r2,r3,r2
 181ec80:	1007883a 	mov	r3,r2
 181ec84:	e0bff48b 	ldhu	r2,-46(fp)
 181ec88:	10c5c83a 	sub	r2,r2,r3
 181ec8c:	e0bff10d 	sth	r2,-60(fp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 181ec90:	e0bffc17 	ldw	r2,-16(fp)
 181ec94:	10801b8b 	ldhu	r2,110(r2)
 181ec98:	e0bff90d 	sth	r2,-28(fp)
    if (oversize > 0) {
 181ec9c:	e0bff90b 	ldhu	r2,-28(fp)
 181eca0:	10bfffcc 	andi	r2,r2,65535
 181eca4:	10001526 	beq	r2,zero,181ecfc <tcp_write+0x1f4>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
 181eca8:	e0bfeb17 	ldw	r2,-84(fp)
 181ecac:	e0bfec15 	stw	r2,-80(fp)
      oversize_used = oversize < len ? oversize : len;
 181ecb0:	e17ff90b 	ldhu	r5,-28(fp)
 181ecb4:	e0bffe0b 	ldhu	r2,-8(fp)
 181ecb8:	10ffffcc 	andi	r3,r2,65535
 181ecbc:	293fffcc 	andi	r4,r5,65535
 181ecc0:	20c0012e 	bgeu	r4,r3,181ecc8 <tcp_write+0x1c0>
 181ecc4:	2805883a 	mov	r2,r5
 181ecc8:	e0bff00d 	sth	r2,-64(fp)
      pos += oversize_used;
 181eccc:	e0ffef0b 	ldhu	r3,-68(fp)
 181ecd0:	e0bff00b 	ldhu	r2,-64(fp)
 181ecd4:	1885883a 	add	r2,r3,r2
 181ecd8:	e0bfef0d 	sth	r2,-68(fp)
      oversize -= oversize_used;
 181ecdc:	e0fff90b 	ldhu	r3,-28(fp)
 181ece0:	e0bff00b 	ldhu	r2,-64(fp)
 181ece4:	1885c83a 	sub	r2,r3,r2
 181ece8:	e0bff90d 	sth	r2,-28(fp)
      space -= oversize_used;
 181ecec:	e0fff10b 	ldhu	r3,-60(fp)
 181ecf0:	e0bff00b 	ldhu	r2,-64(fp)
 181ecf4:	1885c83a 	sub	r2,r3,r2
 181ecf8:	e0bff10d 	sth	r2,-60(fp)
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 181ecfc:	e0ffef0b 	ldhu	r3,-68(fp)
 181ed00:	e0bffe0b 	ldhu	r2,-8(fp)
 181ed04:	1881012e 	bgeu	r3,r2,181f10c <tcp_write+0x604>
 181ed08:	e0bff10b 	ldhu	r2,-60(fp)
 181ed0c:	1000ff26 	beq	r2,zero,181f10c <tcp_write+0x604>
 181ed10:	e0bfeb17 	ldw	r2,-84(fp)
 181ed14:	1080020b 	ldhu	r2,8(r2)
 181ed18:	10bfffcc 	andi	r2,r2,65535
 181ed1c:	1000fb26 	beq	r2,zero,181f10c <tcp_write+0x604>
      u16_t seglen = space < len - pos ? space : len - pos;
 181ed20:	e0fffe0b 	ldhu	r3,-8(fp)
 181ed24:	e0bfef0b 	ldhu	r2,-68(fp)
 181ed28:	1885c83a 	sub	r2,r3,r2
 181ed2c:	e0fff10b 	ldhu	r3,-60(fp)
 181ed30:	1880010e 	bge	r3,r2,181ed38 <tcp_write+0x230>
 181ed34:	1805883a 	mov	r2,r3
 181ed38:	e0bff60d 	sth	r2,-40(fp)
      seg = last_unsent;
 181ed3c:	e0bfeb17 	ldw	r2,-84(fp)
 181ed40:	e0bfec15 	stw	r2,-80(fp)

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 181ed44:	e0bfff03 	ldbu	r2,-4(fp)
 181ed48:	1080004c 	andi	r2,r2,1
 181ed4c:	10002826 	beq	r2,zero,181edf0 <tcp_write+0x2e8>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 181ed50:	e13ff60b 	ldhu	r4,-40(fp)
 181ed54:	e17ff10b 	ldhu	r5,-60(fp)
 181ed58:	e0bfff03 	ldbu	r2,-4(fp)
 181ed5c:	e1bff904 	addi	r6,fp,-28
 181ed60:	00c00044 	movi	r3,1
 181ed64:	d8c00215 	stw	r3,8(sp)
 181ed68:	d8800115 	stw	r2,4(sp)
 181ed6c:	e0bffc17 	ldw	r2,-16(fp)
 181ed70:	d8800015 	stw	r2,0(sp)
 181ed74:	300f883a 	mov	r7,r6
 181ed78:	280d883a 	mov	r6,r5
 181ed7c:	200b883a 	mov	r5,r4
 181ed80:	010000c4 	movi	r4,3
 181ed84:	181e80c0 	call	181e80c <tcp_pbuf_prealloc>
 181ed88:	e0bfea15 	stw	r2,-88(fp)
 181ed8c:	e0bfea17 	ldw	r2,-88(fp)
 181ed90:	10018426 	beq	r2,zero,181f3a4 <tcp_write+0x89c>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 181ed94:	e0bfea17 	ldw	r2,-88(fp)
 181ed98:	11000117 	ldw	r4,4(r2)
 181ed9c:	e0bfef0b 	ldhu	r2,-68(fp)
 181eda0:	e0fffd17 	ldw	r3,-12(fp)
 181eda4:	1885883a 	add	r2,r3,r2
 181eda8:	e0fff60b 	ldhu	r3,-40(fp)
 181edac:	180d883a 	mov	r6,r3
 181edb0:	100b883a 	mov	r5,r2
 181edb4:	18321e80 	call	18321e8 <lwip_chksum_copy>
 181edb8:	10bfffcc 	andi	r2,r2,65535
 181edbc:	e0fff60b 	ldhu	r3,-40(fp)
 181edc0:	e17ffa04 	addi	r5,fp,-24
 181edc4:	e13ff984 	addi	r4,fp,-26
 181edc8:	280f883a 	mov	r7,r5
 181edcc:	200d883a 	mov	r6,r4
 181edd0:	180b883a 	mov	r5,r3
 181edd4:	1009883a 	mov	r4,r2
 181edd8:	181e92c0 	call	181e92c <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 181eddc:	e0fff08b 	ldhu	r3,-62(fp)
 181ede0:	e0bff60b 	ldhu	r2,-40(fp)
 181ede4:	1885883a 	add	r2,r3,r2
 181ede8:	e0bff08d 	sth	r2,-62(fp)
 181edec:	00002206 	br	181ee78 <tcp_write+0x370>
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 181edf0:	e0bff60b 	ldhu	r2,-40(fp)
 181edf4:	01800044 	movi	r6,1
 181edf8:	100b883a 	mov	r5,r2
 181edfc:	010000c4 	movi	r4,3
 181ee00:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181ee04:	e0bfea15 	stw	r2,-88(fp)
 181ee08:	e0bfea17 	ldw	r2,-88(fp)
 181ee0c:	10016726 	beq	r2,zero,181f3ac <tcp_write+0x8a4>
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
 181ee10:	e0bfef0b 	ldhu	r2,-68(fp)
 181ee14:	e0fffd17 	ldw	r3,-12(fp)
 181ee18:	1885883a 	add	r2,r3,r2
 181ee1c:	e0fff60b 	ldhu	r3,-40(fp)
 181ee20:	180b883a 	mov	r5,r3
 181ee24:	1009883a 	mov	r4,r2
 181ee28:	18320980 	call	1832098 <inet_chksum>
 181ee2c:	0084303a 	nor	r2,zero,r2
 181ee30:	10bfffcc 	andi	r2,r2,65535
 181ee34:	e0fff60b 	ldhu	r3,-40(fp)
 181ee38:	e17ffa04 	addi	r5,fp,-24
 181ee3c:	e13ff984 	addi	r4,fp,-26
 181ee40:	280f883a 	mov	r7,r5
 181ee44:	200d883a 	mov	r6,r4
 181ee48:	180b883a 	mov	r5,r3
 181ee4c:	1009883a 	mov	r4,r2
 181ee50:	181e92c0 	call	181e92c <tcp_seg_add_chksum>
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 181ee54:	e0fff08b 	ldhu	r3,-62(fp)
 181ee58:	e0bff60b 	ldhu	r2,-40(fp)
 181ee5c:	1885883a 	add	r2,r3,r2
 181ee60:	e0bff08d 	sth	r2,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 181ee64:	e0bfef0b 	ldhu	r2,-68(fp)
 181ee68:	e0fffd17 	ldw	r3,-12(fp)
 181ee6c:	1887883a 	add	r3,r3,r2
 181ee70:	e0bfea17 	ldw	r2,-88(fp)
 181ee74:	10c00115 	stw	r3,4(r2)
      }

      pos += seglen;
 181ee78:	e0ffef0b 	ldhu	r3,-68(fp)
 181ee7c:	e0bff60b 	ldhu	r2,-40(fp)
 181ee80:	1885883a 	add	r2,r3,r2
 181ee84:	e0bfef0d 	sth	r2,-68(fp)
      queuelen += pbuf_clen(concat_p);
 181ee88:	e13fea17 	ldw	r4,-88(fp)
 181ee8c:	181ade80 	call	181ade8 <pbuf_clen>
 181ee90:	10c03fcc 	andi	r3,r2,255
 181ee94:	e0bfef8b 	ldhu	r2,-66(fp)
 181ee98:	1885883a 	add	r2,r3,r2
 181ee9c:	e0bfef8d 	sth	r2,-66(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 181eea0:	00009a06 	br	181f10c <tcp_write+0x604>
    struct pbuf *p;
    u16_t left = len - pos;
 181eea4:	e0fffe0b 	ldhu	r3,-8(fp)
 181eea8:	e0bfef0b 	ldhu	r2,-68(fp)
 181eeac:	1885c83a 	sub	r2,r3,r2
 181eeb0:	e0bff68d 	sth	r2,-38(fp)
    u16_t max_len = mss_local - optlen;
 181eeb4:	e0bff403 	ldbu	r2,-48(fp)
 181eeb8:	e0fff48b 	ldhu	r3,-46(fp)
 181eebc:	1885c83a 	sub	r2,r3,r2
 181eec0:	e0bff70d 	sth	r2,-36(fp)
    u16_t seglen = left > max_len ? max_len : left;
 181eec4:	e17ff70b 	ldhu	r5,-36(fp)
 181eec8:	e0bff68b 	ldhu	r2,-38(fp)
 181eecc:	10ffffcc 	andi	r3,r2,65535
 181eed0:	293fffcc 	andi	r4,r5,65535
 181eed4:	20c0012e 	bgeu	r4,r3,181eedc <tcp_write+0x3d4>
 181eed8:	2805883a 	mov	r2,r5
 181eedc:	e0bff78d 	sth	r2,-34(fp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 181eee0:	e03ffa8d 	sth	zero,-22(fp)
    u8_t chksum_swapped = 0;
 181eee4:	e03ffb05 	stb	zero,-20(fp)
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 181eee8:	e0bfff03 	ldbu	r2,-4(fp)
 181eeec:	1080004c 	andi	r2,r2,1
 181eef0:	10002b26 	beq	r2,zero,181efa0 <tcp_write+0x498>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 181eef4:	e0fff403 	ldbu	r3,-48(fp)
 181eef8:	e0bff78b 	ldhu	r2,-34(fp)
 181eefc:	1885883a 	add	r2,r3,r2
 181ef00:	113fffcc 	andi	r4,r2,65535
 181ef04:	e17ff48b 	ldhu	r5,-46(fp)
 181ef08:	e0bfff03 	ldbu	r2,-4(fp)
 181ef0c:	e0ffee17 	ldw	r3,-72(fp)
 181ef10:	1807003a 	cmpeq	r3,r3,zero
 181ef14:	18c03fcc 	andi	r3,r3,255
 181ef18:	e1bff904 	addi	r6,fp,-28
 181ef1c:	d8c00215 	stw	r3,8(sp)
 181ef20:	d8800115 	stw	r2,4(sp)
 181ef24:	e0bffc17 	ldw	r2,-16(fp)
 181ef28:	d8800015 	stw	r2,0(sp)
 181ef2c:	300f883a 	mov	r7,r6
 181ef30:	280d883a 	mov	r6,r5
 181ef34:	200b883a 	mov	r5,r4
 181ef38:	0009883a 	mov	r4,zero
 181ef3c:	181e80c0 	call	181e80c <tcp_pbuf_prealloc>
 181ef40:	e0bff215 	stw	r2,-56(fp)
 181ef44:	e0bff217 	ldw	r2,-56(fp)
 181ef48:	10011a26 	beq	r2,zero,181f3b4 <tcp_write+0x8ac>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 181ef4c:	e0bff217 	ldw	r2,-56(fp)
 181ef50:	10c00117 	ldw	r3,4(r2)
 181ef54:	e0bff403 	ldbu	r2,-48(fp)
 181ef58:	1889883a 	add	r4,r3,r2
 181ef5c:	e0bfef0b 	ldhu	r2,-68(fp)
 181ef60:	e0fffd17 	ldw	r3,-12(fp)
 181ef64:	1885883a 	add	r2,r3,r2
 181ef68:	e0fff78b 	ldhu	r3,-34(fp)
 181ef6c:	180d883a 	mov	r6,r3
 181ef70:	100b883a 	mov	r5,r2
 181ef74:	18321e80 	call	18321e8 <lwip_chksum_copy>
 181ef78:	10bfffcc 	andi	r2,r2,65535
 181ef7c:	e0fff78b 	ldhu	r3,-34(fp)
 181ef80:	e17ffb04 	addi	r5,fp,-20
 181ef84:	e13ffa84 	addi	r4,fp,-22
 181ef88:	280f883a 	mov	r7,r5
 181ef8c:	200d883a 	mov	r6,r4
 181ef90:	180b883a 	mov	r5,r3
 181ef94:	1009883a 	mov	r4,r2
 181ef98:	181e92c0 	call	181e92c <tcp_seg_add_chksum>
 181ef9c:	00002406 	br	181f030 <tcp_write+0x528>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 181efa0:	e0bff78b 	ldhu	r2,-34(fp)
 181efa4:	01800044 	movi	r6,1
 181efa8:	100b883a 	mov	r5,r2
 181efac:	0009883a 	mov	r4,zero
 181efb0:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181efb4:	e0bff815 	stw	r2,-32(fp)
 181efb8:	e0bff817 	ldw	r2,-32(fp)
 181efbc:	1000ff26 	beq	r2,zero,181f3bc <tcp_write+0x8b4>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
 181efc0:	e0bfef0b 	ldhu	r2,-68(fp)
 181efc4:	e0fffd17 	ldw	r3,-12(fp)
 181efc8:	1885883a 	add	r2,r3,r2
 181efcc:	e0fff78b 	ldhu	r3,-34(fp)
 181efd0:	180b883a 	mov	r5,r3
 181efd4:	1009883a 	mov	r4,r2
 181efd8:	18320980 	call	1832098 <inet_chksum>
 181efdc:	0084303a 	nor	r2,zero,r2
 181efe0:	e0bffa8d 	sth	r2,-22(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 181efe4:	e0bfef0b 	ldhu	r2,-68(fp)
 181efe8:	e0fffd17 	ldw	r3,-12(fp)
 181efec:	1887883a 	add	r3,r3,r2
 181eff0:	e0bff817 	ldw	r2,-32(fp)
 181eff4:	10c00115 	stw	r3,4(r2)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 181eff8:	e0bff403 	ldbu	r2,-48(fp)
 181effc:	000d883a 	mov	r6,zero
 181f000:	100b883a 	mov	r5,r2
 181f004:	0009883a 	mov	r4,zero
 181f008:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181f00c:	e0bff215 	stw	r2,-56(fp)
 181f010:	e0bff217 	ldw	r2,-56(fp)
 181f014:	1000031e 	bne	r2,zero,181f024 <tcp_write+0x51c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 181f018:	e13ff817 	ldw	r4,-32(fp)
 181f01c:	181aca40 	call	181aca4 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 181f020:	0000e906 	br	181f3c8 <tcp_write+0x8c0>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 181f024:	e17ff817 	ldw	r5,-32(fp)
 181f028:	e13ff217 	ldw	r4,-56(fp)
 181f02c:	181ae980 	call	181ae98 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 181f030:	e13ff217 	ldw	r4,-56(fp)
 181f034:	181ade80 	call	181ade8 <pbuf_clen>
 181f038:	10c03fcc 	andi	r3,r2,255
 181f03c:	e0bfef8b 	ldhu	r2,-66(fp)
 181f040:	1885883a 	add	r2,r3,r2
 181f044:	e0bfef8d 	sth	r2,-66(fp)

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 181f048:	e0bfef8b 	ldhu	r2,-66(fp)
 181f04c:	10800268 	cmpgeui	r2,r2,9
 181f050:	1000031e 	bne	r2,zero,181f060 <tcp_write+0x558>
 181f054:	e0bfef8b 	ldhu	r2,-66(fp)
 181f058:	10bfff70 	cmpltui	r2,r2,65533
 181f05c:	1000031e 	bne	r2,zero,181f06c <tcp_write+0x564>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
 181f060:	e13ff217 	ldw	r4,-56(fp)
 181f064:	181aca40 	call	181aca4 <pbuf_free>
      goto memerr;
 181f068:	0000d706 	br	181f3c8 <tcp_write+0x8c0>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 181f06c:	e0bffc17 	ldw	r2,-16(fp)
 181f070:	10c01817 	ldw	r3,96(r2)
 181f074:	e0bfef0b 	ldhu	r2,-68(fp)
 181f078:	1887883a 	add	r3,r3,r2
 181f07c:	e0bff443 	ldbu	r2,-47(fp)
 181f080:	d8800015 	stw	r2,0(sp)
 181f084:	180f883a 	mov	r7,r3
 181f088:	000d883a 	mov	r6,zero
 181f08c:	e17ff217 	ldw	r5,-56(fp)
 181f090:	e13ffc17 	ldw	r4,-16(fp)
 181f094:	181e46c0 	call	181e46c <tcp_create_segment>
 181f098:	e0bfec15 	stw	r2,-80(fp)
 181f09c:	e0bfec17 	ldw	r2,-80(fp)
 181f0a0:	1000c826 	beq	r2,zero,181f3c4 <tcp_write+0x8bc>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 181f0a4:	e0fffa8b 	ldhu	r3,-22(fp)
 181f0a8:	e0bfec17 	ldw	r2,-80(fp)
 181f0ac:	10c0028d 	sth	r3,10(r2)
    seg->chksum_swapped = chksum_swapped;
 181f0b0:	e0fffb03 	ldbu	r3,-20(fp)
 181f0b4:	e0bfec17 	ldw	r2,-80(fp)
 181f0b8:	10c00305 	stb	r3,12(r2)
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 181f0bc:	e0bfec17 	ldw	r2,-80(fp)
 181f0c0:	10800343 	ldbu	r2,13(r2)
 181f0c4:	10800114 	ori	r2,r2,4
 181f0c8:	1007883a 	mov	r3,r2
 181f0cc:	e0bfec17 	ldw	r2,-80(fp)
 181f0d0:	10c00345 	stb	r3,13(r2)
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 181f0d4:	e0bfee17 	ldw	r2,-72(fp)
 181f0d8:	1000031e 	bne	r2,zero,181f0e8 <tcp_write+0x5e0>
      queue = seg;
 181f0dc:	e0bfec17 	ldw	r2,-80(fp)
 181f0e0:	e0bfee15 	stw	r2,-72(fp)
 181f0e4:	00000306 	br	181f0f4 <tcp_write+0x5ec>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 181f0e8:	e0bfed17 	ldw	r2,-76(fp)
 181f0ec:	e0ffec17 	ldw	r3,-80(fp)
 181f0f0:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 181f0f4:	e0bfec17 	ldw	r2,-80(fp)
 181f0f8:	e0bfed15 	stw	r2,-76(fp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 181f0fc:	e0ffef0b 	ldhu	r3,-68(fp)
 181f100:	e0bff78b 	ldhu	r2,-34(fp)
 181f104:	1885883a 	add	r2,r3,r2
 181f108:	e0bfef0d 	sth	r2,-68(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 181f10c:	e0ffef0b 	ldhu	r3,-68(fp)
 181f110:	e0bffe0b 	ldhu	r2,-8(fp)
 181f114:	18bf6336 	bltu	r3,r2,181eea4 <__ram_exceptions_end+0xff80ea60>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 181f118:	e0bff00b 	ldhu	r2,-64(fp)
 181f11c:	10003d26 	beq	r2,zero,181f214 <tcp_write+0x70c>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 181f120:	e0bfeb17 	ldw	r2,-84(fp)
 181f124:	10800117 	ldw	r2,4(r2)
 181f128:	e0bff315 	stw	r2,-52(fp)
 181f12c:	00003006 	br	181f1f0 <tcp_write+0x6e8>
      p->tot_len += oversize_used;
 181f130:	e0bff317 	ldw	r2,-52(fp)
 181f134:	10c0020b 	ldhu	r3,8(r2)
 181f138:	e0bff00b 	ldhu	r2,-64(fp)
 181f13c:	1885883a 	add	r2,r3,r2
 181f140:	1007883a 	mov	r3,r2
 181f144:	e0bff317 	ldw	r2,-52(fp)
 181f148:	10c0020d 	sth	r3,8(r2)
      if (p->next == NULL) {
 181f14c:	e0bff317 	ldw	r2,-52(fp)
 181f150:	10800017 	ldw	r2,0(r2)
 181f154:	1000231e 	bne	r2,zero,181f1e4 <tcp_write+0x6dc>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 181f158:	e0bff317 	ldw	r2,-52(fp)
 181f15c:	10c00117 	ldw	r3,4(r2)
 181f160:	e0bff317 	ldw	r2,-52(fp)
 181f164:	1080028b 	ldhu	r2,10(r2)
 181f168:	10bfffcc 	andi	r2,r2,65535
 181f16c:	1885883a 	add	r2,r3,r2
 181f170:	e0fff00b 	ldhu	r3,-64(fp)
 181f174:	180d883a 	mov	r6,r3
 181f178:	e17ffd17 	ldw	r5,-12(fp)
 181f17c:	1009883a 	mov	r4,r2
 181f180:	18321e80 	call	18321e8 <lwip_chksum_copy>
 181f184:	10ffffcc 	andi	r3,r2,65535
 181f188:	e13ff00b 	ldhu	r4,-64(fp)
 181f18c:	e0bfeb17 	ldw	r2,-84(fp)
 181f190:	11400284 	addi	r5,r2,10
 181f194:	e0bfeb17 	ldw	r2,-84(fp)
 181f198:	10800304 	addi	r2,r2,12
 181f19c:	100f883a 	mov	r7,r2
 181f1a0:	280d883a 	mov	r6,r5
 181f1a4:	200b883a 	mov	r5,r4
 181f1a8:	1809883a 	mov	r4,r3
 181f1ac:	181e92c0 	call	181e92c <tcp_seg_add_chksum>
 181f1b0:	e0bfeb17 	ldw	r2,-84(fp)
 181f1b4:	10800343 	ldbu	r2,13(r2)
 181f1b8:	10800114 	ori	r2,r2,4
 181f1bc:	1007883a 	mov	r3,r2
 181f1c0:	e0bfeb17 	ldw	r2,-84(fp)
 181f1c4:	10c00345 	stb	r3,13(r2)
        p->len += oversize_used;
 181f1c8:	e0bff317 	ldw	r2,-52(fp)
 181f1cc:	10c0028b 	ldhu	r3,10(r2)
 181f1d0:	e0bff00b 	ldhu	r2,-64(fp)
 181f1d4:	1885883a 	add	r2,r3,r2
 181f1d8:	1007883a 	mov	r3,r2
 181f1dc:	e0bff317 	ldw	r2,-52(fp)
 181f1e0:	10c0028d 	sth	r3,10(r2)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 181f1e4:	e0bff317 	ldw	r2,-52(fp)
 181f1e8:	10800017 	ldw	r2,0(r2)
 181f1ec:	e0bff315 	stw	r2,-52(fp)
 181f1f0:	e0bff317 	ldw	r2,-52(fp)
 181f1f4:	103fce1e 	bne	r2,zero,181f130 <__ram_exceptions_end+0xff80ecec>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 181f1f8:	e0bfeb17 	ldw	r2,-84(fp)
 181f1fc:	10c0020b 	ldhu	r3,8(r2)
 181f200:	e0bff00b 	ldhu	r2,-64(fp)
 181f204:	1885883a 	add	r2,r3,r2
 181f208:	1007883a 	mov	r3,r2
 181f20c:	e0bfeb17 	ldw	r2,-84(fp)
 181f210:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 181f214:	e0fff90b 	ldhu	r3,-28(fp)
 181f218:	e0bffc17 	ldw	r2,-16(fp)
 181f21c:	10c01b8d 	sth	r3,110(r2)
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 181f220:	e0bfea17 	ldw	r2,-88(fp)
 181f224:	10002126 	beq	r2,zero,181f2ac <tcp_write+0x7a4>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 181f228:	e0bfeb17 	ldw	r2,-84(fp)
 181f22c:	10800117 	ldw	r2,4(r2)
 181f230:	e17fea17 	ldw	r5,-88(fp)
 181f234:	1009883a 	mov	r4,r2
 181f238:	181ae980 	call	181ae98 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 181f23c:	e0bfeb17 	ldw	r2,-84(fp)
 181f240:	10c0020b 	ldhu	r3,8(r2)
 181f244:	e0bfea17 	ldw	r2,-88(fp)
 181f248:	1080020b 	ldhu	r2,8(r2)
 181f24c:	1885883a 	add	r2,r3,r2
 181f250:	1007883a 	mov	r3,r2
 181f254:	e0bfeb17 	ldw	r2,-84(fp)
 181f258:	10c0020d 	sth	r3,8(r2)
#if TCP_CHECKSUM_ON_COPY
    if (concat_chksummed) {
 181f25c:	e0bff08b 	ldhu	r2,-62(fp)
 181f260:	10001226 	beq	r2,zero,181f2ac <tcp_write+0x7a4>
      tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 181f264:	e0bff98b 	ldhu	r2,-26(fp)
 181f268:	10ffffcc 	andi	r3,r2,65535
 181f26c:	e13ff08b 	ldhu	r4,-62(fp)
 181f270:	e0bfeb17 	ldw	r2,-84(fp)
 181f274:	11400284 	addi	r5,r2,10
 181f278:	e0bfeb17 	ldw	r2,-84(fp)
 181f27c:	10800304 	addi	r2,r2,12
 181f280:	100f883a 	mov	r7,r2
 181f284:	280d883a 	mov	r6,r5
 181f288:	200b883a 	mov	r5,r4
 181f28c:	1809883a 	mov	r4,r3
 181f290:	181e92c0 	call	181e92c <tcp_seg_add_chksum>
        &last_unsent->chksum_swapped);
      last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 181f294:	e0bfeb17 	ldw	r2,-84(fp)
 181f298:	10800343 	ldbu	r2,13(r2)
 181f29c:	10800114 	ori	r2,r2,4
 181f2a0:	1007883a 	mov	r3,r2
 181f2a4:	e0bfeb17 	ldw	r2,-84(fp)
 181f2a8:	10c00345 	stb	r3,13(r2)

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 181f2ac:	e0bfeb17 	ldw	r2,-84(fp)
 181f2b0:	1000041e 	bne	r2,zero,181f2c4 <tcp_write+0x7bc>
    pcb->unsent = queue;
 181f2b4:	e0bffc17 	ldw	r2,-16(fp)
 181f2b8:	e0ffee17 	ldw	r3,-72(fp)
 181f2bc:	10c01c15 	stw	r3,112(r2)
 181f2c0:	00000306 	br	181f2d0 <tcp_write+0x7c8>
  } else {
    last_unsent->next = queue;
 181f2c4:	e0bfeb17 	ldw	r2,-84(fp)
 181f2c8:	e0ffee17 	ldw	r3,-72(fp)
 181f2cc:	10c00015 	stw	r3,0(r2)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 181f2d0:	e0bffc17 	ldw	r2,-16(fp)
 181f2d4:	10c01817 	ldw	r3,96(r2)
 181f2d8:	e0bffe0b 	ldhu	r2,-8(fp)
 181f2dc:	1887883a 	add	r3,r3,r2
 181f2e0:	e0bffc17 	ldw	r2,-16(fp)
 181f2e4:	10c01815 	stw	r3,96(r2)
  pcb->snd_buf -= len;
 181f2e8:	e0bffc17 	ldw	r2,-16(fp)
 181f2ec:	10c01a8b 	ldhu	r3,106(r2)
 181f2f0:	e0bffe0b 	ldhu	r2,-8(fp)
 181f2f4:	1885c83a 	sub	r2,r3,r2
 181f2f8:	1007883a 	mov	r3,r2
 181f2fc:	e0bffc17 	ldw	r2,-16(fp)
 181f300:	10c01a8d 	sth	r3,106(r2)
  pcb->snd_queuelen = queuelen;
 181f304:	e0bffc17 	ldw	r2,-16(fp)
 181f308:	e0ffef8b 	ldhu	r3,-66(fp)
 181f30c:	10c01b0d 	sth	r3,108(r2)
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 181f310:	e0bfec17 	ldw	r2,-80(fp)
 181f314:	10002126 	beq	r2,zero,181f39c <tcp_write+0x894>
 181f318:	e0bfec17 	ldw	r2,-80(fp)
 181f31c:	10800417 	ldw	r2,16(r2)
 181f320:	10001e26 	beq	r2,zero,181f39c <tcp_write+0x894>
 181f324:	e0bfff03 	ldbu	r2,-4(fp)
 181f328:	1080008c 	andi	r2,r2,2
 181f32c:	10001b1e 	bne	r2,zero,181f39c <tcp_write+0x894>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 181f330:	e0bfec17 	ldw	r2,-80(fp)
 181f334:	10800417 	ldw	r2,16(r2)
 181f338:	e0ffec17 	ldw	r3,-80(fp)
 181f33c:	18c00417 	ldw	r3,16(r3)
 181f340:	19000303 	ldbu	r4,12(r3)
 181f344:	18c00343 	ldbu	r3,13(r3)
 181f348:	1806923a 	slli	r3,r3,8
 181f34c:	1906b03a 	or	r3,r3,r4
 181f350:	18c20014 	ori	r3,r3,2048
 181f354:	180d883a 	mov	r6,r3
 181f358:	30ffffcc 	andi	r3,r6,65535
 181f35c:	19403fcc 	andi	r5,r3,255
 181f360:	10c00303 	ldbu	r3,12(r2)
 181f364:	1806703a 	and	r3,r3,zero
 181f368:	1809883a 	mov	r4,r3
 181f36c:	2807883a 	mov	r3,r5
 181f370:	20c6b03a 	or	r3,r4,r3
 181f374:	10c00305 	stb	r3,12(r2)
 181f378:	30ffffcc 	andi	r3,r6,65535
 181f37c:	1806d23a 	srli	r3,r3,8
 181f380:	197fffcc 	andi	r5,r3,65535
 181f384:	10c00343 	ldbu	r3,13(r2)
 181f388:	1806703a 	and	r3,r3,zero
 181f38c:	1809883a 	mov	r4,r3
 181f390:	2807883a 	mov	r3,r5
 181f394:	20c6b03a 	or	r3,r4,r3
 181f398:	10c00345 	stb	r3,13(r2)
  }

  return ERR_OK;
 181f39c:	0005883a 	mov	r2,zero
 181f3a0:	00002006 	br	181f424 <tcp_write+0x91c>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
 181f3a4:	0001883a 	nop
 181f3a8:	00000706 	br	181f3c8 <tcp_write+0x8c0>
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
 181f3ac:	0001883a 	nop
 181f3b0:	00000506 	br	181f3c8 <tcp_write+0x8c0>
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
 181f3b4:	0001883a 	nop
 181f3b8:	00000306 	br	181f3c8 <tcp_write+0x8c0>
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
 181f3bc:	0001883a 	nop
 181f3c0:	00000106 	br	181f3c8 <tcp_write+0x8c0>
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
 181f3c4:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 181f3c8:	e0bffc17 	ldw	r2,-16(fp)
 181f3cc:	10c00883 	ldbu	r3,34(r2)
 181f3d0:	00bfe004 	movi	r2,-128
 181f3d4:	1884b03a 	or	r2,r3,r2
 181f3d8:	1007883a 	mov	r3,r2
 181f3dc:	e0bffc17 	ldw	r2,-16(fp)
 181f3e0:	10c00885 	stb	r3,34(r2)
  TCP_STATS_INC(tcp.memerr);
 181f3e4:	008061f4 	movhi	r2,391
 181f3e8:	10a9d404 	addi	r2,r2,-22704
 181f3ec:	10804e17 	ldw	r2,312(r2)
 181f3f0:	10c00044 	addi	r3,r2,1
 181f3f4:	008061f4 	movhi	r2,391
 181f3f8:	10a9d404 	addi	r2,r2,-22704
 181f3fc:	10c04e15 	stw	r3,312(r2)

  if (concat_p != NULL) {
 181f400:	e0bfea17 	ldw	r2,-88(fp)
 181f404:	10000226 	beq	r2,zero,181f410 <tcp_write+0x908>
    pbuf_free(concat_p);
 181f408:	e13fea17 	ldw	r4,-88(fp)
 181f40c:	181aca40 	call	181aca4 <pbuf_free>
  }
  if (queue != NULL) {
 181f410:	e0bfee17 	ldw	r2,-72(fp)
 181f414:	10000226 	beq	r2,zero,181f420 <tcp_write+0x918>
    tcp_segs_free(queue);
 181f418:	e13fee17 	ldw	r4,-72(fp)
 181f41c:	181d5180 	call	181d518 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 181f420:	00bfffc4 	movi	r2,-1
}
 181f424:	e037883a 	mov	sp,fp
 181f428:	dfc00117 	ldw	ra,4(sp)
 181f42c:	df000017 	ldw	fp,0(sp)
 181f430:	dec00204 	addi	sp,sp,8
 181f434:	f800283a 	ret

0181f438 <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 181f438:	defff604 	addi	sp,sp,-40
 181f43c:	dfc00915 	stw	ra,36(sp)
 181f440:	df000815 	stw	fp,32(sp)
 181f444:	df000804 	addi	fp,sp,32
 181f448:	e13ffe15 	stw	r4,-8(fp)
 181f44c:	2805883a 	mov	r2,r5
 181f450:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 181f454:	e03ff905 	stb	zero,-28(fp)
  u8_t optlen = 0;
 181f458:	e03ffb05 	stb	zero,-20(fp)

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 181f45c:	e0bffe17 	ldw	r2,-8(fp)
 181f460:	10801b0b 	ldhu	r2,108(r2)
 181f464:	10bfffcc 	andi	r2,r2,65535
 181f468:	10800228 	cmpgeui	r2,r2,8
 181f46c:	1000051e 	bne	r2,zero,181f484 <tcp_enqueue_flags+0x4c>
 181f470:	e0bffe17 	ldw	r2,-8(fp)
 181f474:	10801b0b 	ldhu	r2,108(r2)
 181f478:	10bfffcc 	andi	r2,r2,65535
 181f47c:	10bfff70 	cmpltui	r2,r2,65533
 181f480:	1000101e 	bne	r2,zero,181f4c4 <tcp_enqueue_flags+0x8c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 181f484:	008061f4 	movhi	r2,391
 181f488:	10a9d404 	addi	r2,r2,-22704
 181f48c:	10804e17 	ldw	r2,312(r2)
 181f490:	10c00044 	addi	r3,r2,1
 181f494:	008061f4 	movhi	r2,391
 181f498:	10a9d404 	addi	r2,r2,-22704
 181f49c:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
 181f4a0:	e0bffe17 	ldw	r2,-8(fp)
 181f4a4:	10c00883 	ldbu	r3,34(r2)
 181f4a8:	00bfe004 	movi	r2,-128
 181f4ac:	1884b03a 	or	r2,r3,r2
 181f4b0:	1007883a 	mov	r3,r2
 181f4b4:	e0bffe17 	ldw	r2,-8(fp)
 181f4b8:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 181f4bc:	00bfffc4 	movi	r2,-1
 181f4c0:	00009206 	br	181f70c <tcp_enqueue_flags+0x2d4>
  }

  if (flags & TCP_SYN) {
 181f4c4:	e0bfff03 	ldbu	r2,-4(fp)
 181f4c8:	1080008c 	andi	r2,r2,2
 181f4cc:	10000226 	beq	r2,zero,181f4d8 <tcp_enqueue_flags+0xa0>
    optflags = TF_SEG_OPTS_MSS;
 181f4d0:	00800044 	movi	r2,1
 181f4d4:	e0bff905 	stb	r2,-28(fp)
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 181f4d8:	e0bff903 	ldbu	r2,-28(fp)
 181f4dc:	1080004c 	andi	r2,r2,1
 181f4e0:	10000226 	beq	r2,zero,181f4ec <tcp_enqueue_flags+0xb4>
 181f4e4:	00c00104 	movi	r3,4
 181f4e8:	00000106 	br	181f4f0 <tcp_enqueue_flags+0xb8>
 181f4ec:	0007883a 	mov	r3,zero
 181f4f0:	e0bff903 	ldbu	r2,-28(fp)
 181f4f4:	1080008c 	andi	r2,r2,2
 181f4f8:	10000226 	beq	r2,zero,181f504 <tcp_enqueue_flags+0xcc>
 181f4fc:	00800304 	movi	r2,12
 181f500:	00000106 	br	181f508 <tcp_enqueue_flags+0xd0>
 181f504:	0005883a 	mov	r2,zero
 181f508:	1885883a 	add	r2,r3,r2
 181f50c:	e0bffb05 	stb	r2,-20(fp)

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 181f510:	e0bffe17 	ldw	r2,-8(fp)
 181f514:	10801a8b 	ldhu	r2,106(r2)
 181f518:	10bfffcc 	andi	r2,r2,65535
 181f51c:	1000091e 	bne	r2,zero,181f544 <tcp_enqueue_flags+0x10c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
 181f520:	008061f4 	movhi	r2,391
 181f524:	10a9d404 	addi	r2,r2,-22704
 181f528:	10804e17 	ldw	r2,312(r2)
 181f52c:	10c00044 	addi	r3,r2,1
 181f530:	008061f4 	movhi	r2,391
 181f534:	10a9d404 	addi	r2,r2,-22704
 181f538:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 181f53c:	00bfffc4 	movi	r2,-1
 181f540:	00007206 	br	181f70c <tcp_enqueue_flags+0x2d4>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 181f544:	e0bffb03 	ldbu	r2,-20(fp)
 181f548:	000d883a 	mov	r6,zero
 181f54c:	100b883a 	mov	r5,r2
 181f550:	0009883a 	mov	r4,zero
 181f554:	181a4e80 	call	181a4e8 <pbuf_alloc>
 181f558:	e0bffc15 	stw	r2,-16(fp)
 181f55c:	e0bffc17 	ldw	r2,-16(fp)
 181f560:	1000101e 	bne	r2,zero,181f5a4 <tcp_enqueue_flags+0x16c>
    pcb->flags |= TF_NAGLEMEMERR;
 181f564:	e0bffe17 	ldw	r2,-8(fp)
 181f568:	10c00883 	ldbu	r3,34(r2)
 181f56c:	00bfe004 	movi	r2,-128
 181f570:	1884b03a 	or	r2,r3,r2
 181f574:	1007883a 	mov	r3,r2
 181f578:	e0bffe17 	ldw	r2,-8(fp)
 181f57c:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 181f580:	008061f4 	movhi	r2,391
 181f584:	10a9d404 	addi	r2,r2,-22704
 181f588:	10804e17 	ldw	r2,312(r2)
 181f58c:	10c00044 	addi	r3,r2,1
 181f590:	008061f4 	movhi	r2,391
 181f594:	10a9d404 	addi	r2,r2,-22704
 181f598:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 181f59c:	00bfffc4 	movi	r2,-1
 181f5a0:	00005a06 	br	181f70c <tcp_enqueue_flags+0x2d4>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 181f5a4:	e0ffff03 	ldbu	r3,-4(fp)
 181f5a8:	e0bffe17 	ldw	r2,-8(fp)
 181f5ac:	11001817 	ldw	r4,96(r2)
 181f5b0:	e0bff903 	ldbu	r2,-28(fp)
 181f5b4:	d8800015 	stw	r2,0(sp)
 181f5b8:	200f883a 	mov	r7,r4
 181f5bc:	180d883a 	mov	r6,r3
 181f5c0:	e17ffc17 	ldw	r5,-16(fp)
 181f5c4:	e13ffe17 	ldw	r4,-8(fp)
 181f5c8:	181e46c0 	call	181e46c <tcp_create_segment>
 181f5cc:	e0bffd15 	stw	r2,-12(fp)
 181f5d0:	e0bffd17 	ldw	r2,-12(fp)
 181f5d4:	1000101e 	bne	r2,zero,181f618 <tcp_enqueue_flags+0x1e0>
    pcb->flags |= TF_NAGLEMEMERR;
 181f5d8:	e0bffe17 	ldw	r2,-8(fp)
 181f5dc:	10c00883 	ldbu	r3,34(r2)
 181f5e0:	00bfe004 	movi	r2,-128
 181f5e4:	1884b03a 	or	r2,r3,r2
 181f5e8:	1007883a 	mov	r3,r2
 181f5ec:	e0bffe17 	ldw	r2,-8(fp)
 181f5f0:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 181f5f4:	008061f4 	movhi	r2,391
 181f5f8:	10a9d404 	addi	r2,r2,-22704
 181f5fc:	10804e17 	ldw	r2,312(r2)
 181f600:	10c00044 	addi	r3,r2,1
 181f604:	008061f4 	movhi	r2,391
 181f608:	10a9d404 	addi	r2,r2,-22704
 181f60c:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 181f610:	00bfffc4 	movi	r2,-1
 181f614:	00003d06 	br	181f70c <tcp_enqueue_flags+0x2d4>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 181f618:	e0bffe17 	ldw	r2,-8(fp)
 181f61c:	10801c17 	ldw	r2,112(r2)
 181f620:	1000041e 	bne	r2,zero,181f634 <tcp_enqueue_flags+0x1fc>
    pcb->unsent = seg;
 181f624:	e0bffe17 	ldw	r2,-8(fp)
 181f628:	e0fffd17 	ldw	r3,-12(fp)
 181f62c:	10c01c15 	stw	r3,112(r2)
 181f630:	00000d06 	br	181f668 <tcp_enqueue_flags+0x230>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 181f634:	e0bffe17 	ldw	r2,-8(fp)
 181f638:	10801c17 	ldw	r2,112(r2)
 181f63c:	e0bffa15 	stw	r2,-24(fp)
 181f640:	00000306 	br	181f650 <tcp_enqueue_flags+0x218>
 181f644:	e0bffa17 	ldw	r2,-24(fp)
 181f648:	10800017 	ldw	r2,0(r2)
 181f64c:	e0bffa15 	stw	r2,-24(fp)
 181f650:	e0bffa17 	ldw	r2,-24(fp)
 181f654:	10800017 	ldw	r2,0(r2)
 181f658:	103ffa1e 	bne	r2,zero,181f644 <__ram_exceptions_end+0xff80f200>
    useg->next = seg;
 181f65c:	e0bffa17 	ldw	r2,-24(fp)
 181f660:	e0fffd17 	ldw	r3,-12(fp)
 181f664:	10c00015 	stw	r3,0(r2)
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 181f668:	e0bffe17 	ldw	r2,-8(fp)
 181f66c:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 181f670:	e0bfff03 	ldbu	r2,-4(fp)
 181f674:	1080008c 	andi	r2,r2,2
 181f678:	1000031e 	bne	r2,zero,181f688 <tcp_enqueue_flags+0x250>
 181f67c:	e0bfff03 	ldbu	r2,-4(fp)
 181f680:	1080004c 	andi	r2,r2,1
 181f684:	10000b26 	beq	r2,zero,181f6b4 <tcp_enqueue_flags+0x27c>
    pcb->snd_lbb++;
 181f688:	e0bffe17 	ldw	r2,-8(fp)
 181f68c:	10801817 	ldw	r2,96(r2)
 181f690:	10c00044 	addi	r3,r2,1
 181f694:	e0bffe17 	ldw	r2,-8(fp)
 181f698:	10c01815 	stw	r3,96(r2)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 181f69c:	e0bffe17 	ldw	r2,-8(fp)
 181f6a0:	10801a8b 	ldhu	r2,106(r2)
 181f6a4:	10bfffc4 	addi	r2,r2,-1
 181f6a8:	1007883a 	mov	r3,r2
 181f6ac:	e0bffe17 	ldw	r2,-8(fp)
 181f6b0:	10c01a8d 	sth	r3,106(r2)
  }
  if (flags & TCP_FIN) {
 181f6b4:	e0bfff03 	ldbu	r2,-4(fp)
 181f6b8:	1080004c 	andi	r2,r2,1
 181f6bc:	10000626 	beq	r2,zero,181f6d8 <tcp_enqueue_flags+0x2a0>
    pcb->flags |= TF_FIN;
 181f6c0:	e0bffe17 	ldw	r2,-8(fp)
 181f6c4:	10800883 	ldbu	r2,34(r2)
 181f6c8:	10800814 	ori	r2,r2,32
 181f6cc:	1007883a 	mov	r3,r2
 181f6d0:	e0bffe17 	ldw	r2,-8(fp)
 181f6d4:	10c00885 	stb	r3,34(r2)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 181f6d8:	e0bffd17 	ldw	r2,-12(fp)
 181f6dc:	10800117 	ldw	r2,4(r2)
 181f6e0:	1009883a 	mov	r4,r2
 181f6e4:	181ade80 	call	181ade8 <pbuf_clen>
 181f6e8:	1009883a 	mov	r4,r2
 181f6ec:	e0bffe17 	ldw	r2,-8(fp)
 181f6f0:	10c01b0b 	ldhu	r3,108(r2)
 181f6f4:	20803fcc 	andi	r2,r4,255
 181f6f8:	1885883a 	add	r2,r3,r2
 181f6fc:	1007883a 	mov	r3,r2
 181f700:	e0bffe17 	ldw	r2,-8(fp)
 181f704:	10c01b0d 	sth	r3,108(r2)
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 181f708:	0005883a 	mov	r2,zero
}
 181f70c:	e037883a 	mov	sp,fp
 181f710:	dfc00117 	ldw	ra,4(sp)
 181f714:	df000017 	ldw	fp,0(sp)
 181f718:	dec00204 	addi	sp,sp,8
 181f71c:	f800283a 	ret

0181f720 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 181f720:	defff704 	addi	sp,sp,-36
 181f724:	dfc00815 	stw	ra,32(sp)
 181f728:	df000715 	stw	fp,28(sp)
 181f72c:	df000704 	addi	fp,sp,28
 181f730:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
 181f734:	e03ffc05 	stb	zero,-16(fp)
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 181f738:	e13ffc03 	ldbu	r4,-16(fp)
 181f73c:	e0bfff17 	ldw	r2,-4(fp)
 181f740:	10801517 	ldw	r2,84(r2)
 181f744:	1006d63a 	srli	r3,r2,24
 181f748:	e0bfff17 	ldw	r2,-4(fp)
 181f74c:	10801517 	ldw	r2,84(r2)
 181f750:	1004d23a 	srli	r2,r2,8
 181f754:	10bfc00c 	andi	r2,r2,65280
 181f758:	1886b03a 	or	r3,r3,r2
 181f75c:	e0bfff17 	ldw	r2,-4(fp)
 181f760:	10801517 	ldw	r2,84(r2)
 181f764:	10bfc00c 	andi	r2,r2,65280
 181f768:	1004923a 	slli	r2,r2,8
 181f76c:	1886b03a 	or	r3,r3,r2
 181f770:	e0bfff17 	ldw	r2,-4(fp)
 181f774:	10801517 	ldw	r2,84(r2)
 181f778:	1004963a 	slli	r2,r2,24
 181f77c:	1884b03a 	or	r2,r3,r2
 181f780:	100f883a 	mov	r7,r2
 181f784:	000d883a 	mov	r6,zero
 181f788:	200b883a 	mov	r5,r4
 181f78c:	e13fff17 	ldw	r4,-4(fp)
 181f790:	181df3c0 	call	181df3c <tcp_output_alloc_header>
 181f794:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
 181f798:	e0bffd17 	ldw	r2,-12(fp)
 181f79c:	1000021e 	bne	r2,zero,181f7a8 <tcp_send_empty_ack+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 181f7a0:	00bfff84 	movi	r2,-2
 181f7a4:	00004006 	br	181f8a8 <tcp_send_empty_ack+0x188>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 181f7a8:	e0bffd17 	ldw	r2,-12(fp)
 181f7ac:	10800117 	ldw	r2,4(r2)
 181f7b0:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 181f7b4:	e0bfff17 	ldw	r2,-4(fp)
 181f7b8:	10c00883 	ldbu	r3,34(r2)
 181f7bc:	00bfff04 	movi	r2,-4
 181f7c0:	1884703a 	and	r2,r3,r2
 181f7c4:	1007883a 	mov	r3,r2
 181f7c8:	e0bfff17 	ldw	r2,-4(fp)
 181f7cc:	10c00885 	stb	r3,34(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 181f7d0:	e0ffff17 	ldw	r3,-4(fp)
 181f7d4:	e0bfff17 	ldw	r2,-4(fp)
 181f7d8:	11000104 	addi	r4,r2,4
        IP_PROTO_TCP, p->tot_len);
 181f7dc:	e0bffd17 	ldw	r2,-12(fp)
 181f7e0:	1080020b 	ldhu	r2,8(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 181f7e4:	10bfffcc 	andi	r2,r2,65535
 181f7e8:	d8800015 	stw	r2,0(sp)
 181f7ec:	01c00184 	movi	r7,6
 181f7f0:	200d883a 	mov	r6,r4
 181f7f4:	180b883a 	mov	r5,r3
 181f7f8:	e13ffd17 	ldw	r4,-12(fp)
 181f7fc:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 181f800:	100d883a 	mov	r6,r2
 181f804:	e0bffe17 	ldw	r2,-8(fp)
 181f808:	30ffffcc 	andi	r3,r6,65535
 181f80c:	19403fcc 	andi	r5,r3,255
 181f810:	10c00403 	ldbu	r3,16(r2)
 181f814:	1806703a 	and	r3,r3,zero
 181f818:	1809883a 	mov	r4,r3
 181f81c:	2807883a 	mov	r3,r5
 181f820:	20c6b03a 	or	r3,r4,r3
 181f824:	10c00405 	stb	r3,16(r2)
 181f828:	30ffffcc 	andi	r3,r6,65535
 181f82c:	1806d23a 	srli	r3,r3,8
 181f830:	197fffcc 	andi	r5,r3,65535
 181f834:	10c00443 	ldbu	r3,17(r2)
 181f838:	1806703a 	and	r3,r3,zero
 181f83c:	1809883a 	mov	r4,r3
 181f840:	2807883a 	mov	r3,r5
 181f844:	20c6b03a 	or	r3,r4,r3
 181f848:	10c00445 	stb	r3,17(r2)
        IP_PROTO_TCP, p->tot_len);
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 181f84c:	e13fff17 	ldw	r4,-4(fp)
 181f850:	e0bfff17 	ldw	r2,-4(fp)
 181f854:	11400104 	addi	r5,r2,4
 181f858:	e0bfff17 	ldw	r2,-4(fp)
 181f85c:	10800283 	ldbu	r2,10(r2)
 181f860:	11803fcc 	andi	r6,r2,255
 181f864:	e0bfff17 	ldw	r2,-4(fp)
 181f868:	10800243 	ldbu	r2,9(r2)
 181f86c:	10803fcc 	andi	r2,r2,255
 181f870:	e0ffff17 	ldw	r3,-4(fp)
 181f874:	18c002c4 	addi	r3,r3,11
 181f878:	d8c00215 	stw	r3,8(sp)
 181f87c:	00c00184 	movi	r3,6
 181f880:	d8c00115 	stw	r3,4(sp)
 181f884:	d8800015 	stw	r2,0(sp)
 181f888:	300f883a 	mov	r7,r6
 181f88c:	280d883a 	mov	r6,r5
 181f890:	200b883a 	mov	r5,r4
 181f894:	e13ffd17 	ldw	r4,-12(fp)
 181f898:	1832f6c0 	call	1832f6c <ip_output_hinted>
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 181f89c:	e13ffd17 	ldw	r4,-12(fp)
 181f8a0:	181aca40 	call	181aca4 <pbuf_free>

  return ERR_OK;
 181f8a4:	0005883a 	mov	r2,zero
}
 181f8a8:	e037883a 	mov	sp,fp
 181f8ac:	dfc00117 	ldw	ra,4(sp)
 181f8b0:	df000017 	ldw	fp,0(sp)
 181f8b4:	dec00204 	addi	sp,sp,8
 181f8b8:	f800283a 	ret

0181f8bc <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 181f8bc:	defff804 	addi	sp,sp,-32
 181f8c0:	dfc00715 	stw	ra,28(sp)
 181f8c4:	df000615 	stw	fp,24(sp)
 181f8c8:	df000604 	addi	fp,sp,24
 181f8cc:	e13fff15 	stw	r4,-4(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 181f8d0:	d0e82017 	ldw	r3,-24448(gp)
 181f8d4:	e0bfff17 	ldw	r2,-4(fp)
 181f8d8:	1880021e 	bne	r3,r2,181f8e4 <tcp_output+0x28>
    return ERR_OK;
 181f8dc:	0005883a 	mov	r2,zero
 181f8e0:	00029c06 	br	1820354 <tcp_output+0xa98>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 181f8e4:	e0bfff17 	ldw	r2,-4(fp)
 181f8e8:	10c0140b 	ldhu	r3,80(r2)
 181f8ec:	e0bfff17 	ldw	r2,-4(fp)
 181f8f0:	1140190b 	ldhu	r5,100(r2)
 181f8f4:	1809883a 	mov	r4,r3
 181f8f8:	20bfffcc 	andi	r2,r4,65535
 181f8fc:	28ffffcc 	andi	r3,r5,65535
 181f900:	1880012e 	bgeu	r3,r2,181f908 <tcp_output+0x4c>
 181f904:	2809883a 	mov	r4,r5
 181f908:	20bfffcc 	andi	r2,r4,65535
 181f90c:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
 181f910:	e0bfff17 	ldw	r2,-4(fp)
 181f914:	10801c17 	ldw	r2,112(r2)
 181f918:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 181f91c:	e0bfff17 	ldw	r2,-4(fp)
 181f920:	10800883 	ldbu	r2,34(r2)
 181f924:	10803fcc 	andi	r2,r2,255
 181f928:	1080008c 	andi	r2,r2,2
 181f92c:	10004726 	beq	r2,zero,181fa4c <tcp_output+0x190>
 181f930:	e0bffa17 	ldw	r2,-24(fp)
 181f934:	10004226 	beq	r2,zero,181fa40 <tcp_output+0x184>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 181f938:	e0bffa17 	ldw	r2,-24(fp)
 181f93c:	10800417 	ldw	r2,16(r2)
 181f940:	10c00103 	ldbu	r3,4(r2)
 181f944:	11000143 	ldbu	r4,5(r2)
 181f948:	2008923a 	slli	r4,r4,8
 181f94c:	20c6b03a 	or	r3,r4,r3
 181f950:	11000183 	ldbu	r4,6(r2)
 181f954:	2008943a 	slli	r4,r4,16
 181f958:	20c6b03a 	or	r3,r4,r3
 181f95c:	108001c3 	ldbu	r2,7(r2)
 181f960:	1004963a 	slli	r2,r2,24
 181f964:	10c4b03a 	or	r2,r2,r3
 181f968:	1006d63a 	srli	r3,r2,24
 181f96c:	e0bffa17 	ldw	r2,-24(fp)
 181f970:	10800417 	ldw	r2,16(r2)
 181f974:	11000103 	ldbu	r4,4(r2)
 181f978:	11400143 	ldbu	r5,5(r2)
 181f97c:	280a923a 	slli	r5,r5,8
 181f980:	2908b03a 	or	r4,r5,r4
 181f984:	11400183 	ldbu	r5,6(r2)
 181f988:	280a943a 	slli	r5,r5,16
 181f98c:	2908b03a 	or	r4,r5,r4
 181f990:	108001c3 	ldbu	r2,7(r2)
 181f994:	1004963a 	slli	r2,r2,24
 181f998:	1104b03a 	or	r2,r2,r4
 181f99c:	1004d23a 	srli	r2,r2,8
 181f9a0:	10bfc00c 	andi	r2,r2,65280
 181f9a4:	1886b03a 	or	r3,r3,r2
 181f9a8:	e0bffa17 	ldw	r2,-24(fp)
 181f9ac:	10800417 	ldw	r2,16(r2)
 181f9b0:	11000103 	ldbu	r4,4(r2)
 181f9b4:	11400143 	ldbu	r5,5(r2)
 181f9b8:	280a923a 	slli	r5,r5,8
 181f9bc:	2908b03a 	or	r4,r5,r4
 181f9c0:	11400183 	ldbu	r5,6(r2)
 181f9c4:	280a943a 	slli	r5,r5,16
 181f9c8:	2908b03a 	or	r4,r5,r4
 181f9cc:	108001c3 	ldbu	r2,7(r2)
 181f9d0:	1004963a 	slli	r2,r2,24
 181f9d4:	1104b03a 	or	r2,r2,r4
 181f9d8:	10bfc00c 	andi	r2,r2,65280
 181f9dc:	1004923a 	slli	r2,r2,8
 181f9e0:	1886b03a 	or	r3,r3,r2
 181f9e4:	e0bffa17 	ldw	r2,-24(fp)
 181f9e8:	10800417 	ldw	r2,16(r2)
 181f9ec:	11000103 	ldbu	r4,4(r2)
 181f9f0:	11400143 	ldbu	r5,5(r2)
 181f9f4:	280a923a 	slli	r5,r5,8
 181f9f8:	2908b03a 	or	r4,r5,r4
 181f9fc:	11400183 	ldbu	r5,6(r2)
 181fa00:	280a943a 	slli	r5,r5,16
 181fa04:	2908b03a 	or	r4,r5,r4
 181fa08:	108001c3 	ldbu	r2,7(r2)
 181fa0c:	1004963a 	slli	r2,r2,24
 181fa10:	1104b03a 	or	r2,r2,r4
 181fa14:	1004963a 	slli	r2,r2,24
 181fa18:	1886b03a 	or	r3,r3,r2
 181fa1c:	e0bfff17 	ldw	r2,-4(fp)
 181fa20:	10801317 	ldw	r2,76(r2)
 181fa24:	1887c83a 	sub	r3,r3,r2
 181fa28:	e0bffa17 	ldw	r2,-24(fp)
 181fa2c:	1080020b 	ldhu	r2,8(r2)
 181fa30:	10bfffcc 	andi	r2,r2,65535
 181fa34:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 181fa38:	e0fffd17 	ldw	r3,-12(fp)
 181fa3c:	1880032e 	bgeu	r3,r2,181fa4c <tcp_output+0x190>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 181fa40:	e13fff17 	ldw	r4,-4(fp)
 181fa44:	181f7200 	call	181f720 <tcp_send_empty_ack>
 181fa48:	00024206 	br	1820354 <tcp_output+0xa98>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 181fa4c:	e0bfff17 	ldw	r2,-4(fp)
 181fa50:	10801d17 	ldw	r2,116(r2)
 181fa54:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
 181fa58:	e0bffb17 	ldw	r2,-20(fp)
 181fa5c:	1001eb26 	beq	r2,zero,182020c <tcp_output+0x950>
    for (; useg->next != NULL; useg = useg->next);
 181fa60:	00000306 	br	181fa70 <tcp_output+0x1b4>
 181fa64:	e0bffb17 	ldw	r2,-20(fp)
 181fa68:	10800017 	ldw	r2,0(r2)
 181fa6c:	e0bffb15 	stw	r2,-20(fp)
 181fa70:	e0bffb17 	ldw	r2,-20(fp)
 181fa74:	10800017 	ldw	r2,0(r2)
 181fa78:	103ffa1e 	bne	r2,zero,181fa64 <__ram_exceptions_end+0xff80f620>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 181fa7c:	0001e306 	br	182020c <tcp_output+0x950>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 181fa80:	e0bfff17 	ldw	r2,-4(fp)
 181fa84:	10801d17 	ldw	r2,116(r2)
 181fa88:	10001d26 	beq	r2,zero,181fb00 <tcp_output+0x244>
 181fa8c:	e0bfff17 	ldw	r2,-4(fp)
 181fa90:	10800883 	ldbu	r2,34(r2)
 181fa94:	10803fcc 	andi	r2,r2,255
 181fa98:	1080110c 	andi	r2,r2,68
 181fa9c:	1000181e 	bne	r2,zero,181fb00 <tcp_output+0x244>
 181faa0:	e0bfff17 	ldw	r2,-4(fp)
 181faa4:	10801c17 	ldw	r2,112(r2)
 181faa8:	10000c26 	beq	r2,zero,181fadc <tcp_output+0x220>
 181faac:	e0bfff17 	ldw	r2,-4(fp)
 181fab0:	10801c17 	ldw	r2,112(r2)
 181fab4:	10800017 	ldw	r2,0(r2)
 181fab8:	1000111e 	bne	r2,zero,181fb00 <tcp_output+0x244>
 181fabc:	e0bfff17 	ldw	r2,-4(fp)
 181fac0:	10801c17 	ldw	r2,112(r2)
 181fac4:	10c0020b 	ldhu	r3,8(r2)
 181fac8:	e0bfff17 	ldw	r2,-4(fp)
 181facc:	10800e8b 	ldhu	r2,58(r2)
 181fad0:	18ffffcc 	andi	r3,r3,65535
 181fad4:	10bfffcc 	andi	r2,r2,65535
 181fad8:	1880092e 	bgeu	r3,r2,181fb00 <tcp_output+0x244>
 181fadc:	e0bfff17 	ldw	r2,-4(fp)
 181fae0:	10801a8b 	ldhu	r2,106(r2)
 181fae4:	10bfffcc 	andi	r2,r2,65535
 181fae8:	10000526 	beq	r2,zero,181fb00 <tcp_output+0x244>
 181faec:	e0bfff17 	ldw	r2,-4(fp)
 181faf0:	10801b0b 	ldhu	r2,108(r2)
 181faf4:	10bfffcc 	andi	r2,r2,65535
 181faf8:	10800230 	cmpltui	r2,r2,8
 181fafc:	1000021e 	bne	r2,zero,181fb08 <tcp_output+0x24c>
 181fb00:	00800044 	movi	r2,1
 181fb04:	00000106 	br	181fb0c <tcp_output+0x250>
 181fb08:	0005883a 	mov	r2,zero
 181fb0c:	1000051e 	bne	r2,zero,181fb24 <tcp_output+0x268>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 181fb10:	e0bfff17 	ldw	r2,-4(fp)
 181fb14:	10800883 	ldbu	r2,34(r2)
 181fb18:	10803fcc 	andi	r2,r2,255
 181fb1c:	1080280c 	andi	r2,r2,160
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 181fb20:	1001ff26 	beq	r2,zero,1820320 <tcp_output+0xa64>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 181fb24:	e0bffa17 	ldw	r2,-24(fp)
 181fb28:	10c00017 	ldw	r3,0(r2)
 181fb2c:	e0bfff17 	ldw	r2,-4(fp)
 181fb30:	10c01c15 	stw	r3,112(r2)

    if (pcb->state != SYN_SENT) {
 181fb34:	e0bfff17 	ldw	r2,-4(fp)
 181fb38:	10800617 	ldw	r2,24(r2)
 181fb3c:	108000a0 	cmpeqi	r2,r2,2
 181fb40:	1000221e 	bne	r2,zero,181fbcc <tcp_output+0x310>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 181fb44:	e0bffa17 	ldw	r2,-24(fp)
 181fb48:	10800417 	ldw	r2,16(r2)
 181fb4c:	e0fffa17 	ldw	r3,-24(fp)
 181fb50:	18c00417 	ldw	r3,16(r3)
 181fb54:	19000303 	ldbu	r4,12(r3)
 181fb58:	18c00343 	ldbu	r3,13(r3)
 181fb5c:	1806923a 	slli	r3,r3,8
 181fb60:	1906b03a 	or	r3,r3,r4
 181fb64:	18c40014 	ori	r3,r3,4096
 181fb68:	180d883a 	mov	r6,r3
 181fb6c:	30ffffcc 	andi	r3,r6,65535
 181fb70:	19403fcc 	andi	r5,r3,255
 181fb74:	10c00303 	ldbu	r3,12(r2)
 181fb78:	1806703a 	and	r3,r3,zero
 181fb7c:	1809883a 	mov	r4,r3
 181fb80:	2807883a 	mov	r3,r5
 181fb84:	20c6b03a 	or	r3,r4,r3
 181fb88:	10c00305 	stb	r3,12(r2)
 181fb8c:	30ffffcc 	andi	r3,r6,65535
 181fb90:	1806d23a 	srli	r3,r3,8
 181fb94:	197fffcc 	andi	r5,r3,65535
 181fb98:	10c00343 	ldbu	r3,13(r2)
 181fb9c:	1806703a 	and	r3,r3,zero
 181fba0:	1809883a 	mov	r4,r3
 181fba4:	2807883a 	mov	r3,r5
 181fba8:	20c6b03a 	or	r3,r4,r3
 181fbac:	10c00345 	stb	r3,13(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 181fbb0:	e0bfff17 	ldw	r2,-4(fp)
 181fbb4:	10c00883 	ldbu	r3,34(r2)
 181fbb8:	00bfff04 	movi	r2,-4
 181fbbc:	1884703a 	and	r2,r3,r2
 181fbc0:	1007883a 	mov	r3,r2
 181fbc4:	e0bfff17 	ldw	r2,-4(fp)
 181fbc8:	10c00885 	stb	r3,34(r2)
    }

    tcp_output_segment(seg, pcb);
 181fbcc:	e17fff17 	ldw	r5,-4(fp)
 181fbd0:	e13ffa17 	ldw	r4,-24(fp)
 181fbd4:	18203680 	call	1820368 <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 181fbd8:	e0bffa17 	ldw	r2,-24(fp)
 181fbdc:	10800417 	ldw	r2,16(r2)
 181fbe0:	10c00103 	ldbu	r3,4(r2)
 181fbe4:	11000143 	ldbu	r4,5(r2)
 181fbe8:	2008923a 	slli	r4,r4,8
 181fbec:	20c6b03a 	or	r3,r4,r3
 181fbf0:	11000183 	ldbu	r4,6(r2)
 181fbf4:	2008943a 	slli	r4,r4,16
 181fbf8:	20c6b03a 	or	r3,r4,r3
 181fbfc:	108001c3 	ldbu	r2,7(r2)
 181fc00:	1004963a 	slli	r2,r2,24
 181fc04:	10c4b03a 	or	r2,r2,r3
 181fc08:	1006d63a 	srli	r3,r2,24
 181fc0c:	e0bffa17 	ldw	r2,-24(fp)
 181fc10:	10800417 	ldw	r2,16(r2)
 181fc14:	11000103 	ldbu	r4,4(r2)
 181fc18:	11400143 	ldbu	r5,5(r2)
 181fc1c:	280a923a 	slli	r5,r5,8
 181fc20:	2908b03a 	or	r4,r5,r4
 181fc24:	11400183 	ldbu	r5,6(r2)
 181fc28:	280a943a 	slli	r5,r5,16
 181fc2c:	2908b03a 	or	r4,r5,r4
 181fc30:	108001c3 	ldbu	r2,7(r2)
 181fc34:	1004963a 	slli	r2,r2,24
 181fc38:	1104b03a 	or	r2,r2,r4
 181fc3c:	1004d23a 	srli	r2,r2,8
 181fc40:	10bfc00c 	andi	r2,r2,65280
 181fc44:	1886b03a 	or	r3,r3,r2
 181fc48:	e0bffa17 	ldw	r2,-24(fp)
 181fc4c:	10800417 	ldw	r2,16(r2)
 181fc50:	11000103 	ldbu	r4,4(r2)
 181fc54:	11400143 	ldbu	r5,5(r2)
 181fc58:	280a923a 	slli	r5,r5,8
 181fc5c:	2908b03a 	or	r4,r5,r4
 181fc60:	11400183 	ldbu	r5,6(r2)
 181fc64:	280a943a 	slli	r5,r5,16
 181fc68:	2908b03a 	or	r4,r5,r4
 181fc6c:	108001c3 	ldbu	r2,7(r2)
 181fc70:	1004963a 	slli	r2,r2,24
 181fc74:	1104b03a 	or	r2,r2,r4
 181fc78:	10bfc00c 	andi	r2,r2,65280
 181fc7c:	1004923a 	slli	r2,r2,8
 181fc80:	1886b03a 	or	r3,r3,r2
 181fc84:	e0bffa17 	ldw	r2,-24(fp)
 181fc88:	10800417 	ldw	r2,16(r2)
 181fc8c:	11000103 	ldbu	r4,4(r2)
 181fc90:	11400143 	ldbu	r5,5(r2)
 181fc94:	280a923a 	slli	r5,r5,8
 181fc98:	2908b03a 	or	r4,r5,r4
 181fc9c:	11400183 	ldbu	r5,6(r2)
 181fca0:	280a943a 	slli	r5,r5,16
 181fca4:	2908b03a 	or	r4,r5,r4
 181fca8:	108001c3 	ldbu	r2,7(r2)
 181fcac:	1004963a 	slli	r2,r2,24
 181fcb0:	1104b03a 	or	r2,r2,r4
 181fcb4:	1004963a 	slli	r2,r2,24
 181fcb8:	1886b03a 	or	r3,r3,r2
 181fcbc:	e0bffa17 	ldw	r2,-24(fp)
 181fcc0:	1080020b 	ldhu	r2,8(r2)
 181fcc4:	113fffcc 	andi	r4,r2,65535
 181fcc8:	e0bffa17 	ldw	r2,-24(fp)
 181fccc:	10800417 	ldw	r2,16(r2)
 181fcd0:	11400303 	ldbu	r5,12(r2)
 181fcd4:	10800343 	ldbu	r2,13(r2)
 181fcd8:	1004923a 	slli	r2,r2,8
 181fcdc:	1144b03a 	or	r2,r2,r5
 181fce0:	10bfffcc 	andi	r2,r2,65535
 181fce4:	1004d23a 	srli	r2,r2,8
 181fce8:	117fffcc 	andi	r5,r2,65535
 181fcec:	e0bffa17 	ldw	r2,-24(fp)
 181fcf0:	10800417 	ldw	r2,16(r2)
 181fcf4:	11800303 	ldbu	r6,12(r2)
 181fcf8:	10800343 	ldbu	r2,13(r2)
 181fcfc:	1004923a 	slli	r2,r2,8
 181fd00:	1184b03a 	or	r2,r2,r6
 181fd04:	10bfffcc 	andi	r2,r2,65535
 181fd08:	1004923a 	slli	r2,r2,8
 181fd0c:	10bfffcc 	andi	r2,r2,65535
 181fd10:	2884b03a 	or	r2,r5,r2
 181fd14:	108000cc 	andi	r2,r2,3
 181fd18:	1004c03a 	cmpne	r2,r2,zero
 181fd1c:	10803fcc 	andi	r2,r2,255
 181fd20:	2085883a 	add	r2,r4,r2
 181fd24:	1885883a 	add	r2,r3,r2
 181fd28:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 181fd2c:	e0bfff17 	ldw	r2,-4(fp)
 181fd30:	10c01517 	ldw	r3,84(r2)
 181fd34:	e0bffe17 	ldw	r2,-8(fp)
 181fd38:	1885c83a 	sub	r2,r3,r2
 181fd3c:	1000030e 	bge	r2,zero,181fd4c <tcp_output+0x490>
      pcb->snd_nxt = snd_nxt;
 181fd40:	e0bfff17 	ldw	r2,-4(fp)
 181fd44:	e0fffe17 	ldw	r3,-8(fp)
 181fd48:	10c01515 	stw	r3,84(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 181fd4c:	e0bffa17 	ldw	r2,-24(fp)
 181fd50:	1080020b 	ldhu	r2,8(r2)
 181fd54:	10ffffcc 	andi	r3,r2,65535
 181fd58:	e0bffa17 	ldw	r2,-24(fp)
 181fd5c:	10800417 	ldw	r2,16(r2)
 181fd60:	11000303 	ldbu	r4,12(r2)
 181fd64:	10800343 	ldbu	r2,13(r2)
 181fd68:	1004923a 	slli	r2,r2,8
 181fd6c:	1104b03a 	or	r2,r2,r4
 181fd70:	10bfffcc 	andi	r2,r2,65535
 181fd74:	1004d23a 	srli	r2,r2,8
 181fd78:	113fffcc 	andi	r4,r2,65535
 181fd7c:	e0bffa17 	ldw	r2,-24(fp)
 181fd80:	10800417 	ldw	r2,16(r2)
 181fd84:	11400303 	ldbu	r5,12(r2)
 181fd88:	10800343 	ldbu	r2,13(r2)
 181fd8c:	1004923a 	slli	r2,r2,8
 181fd90:	1144b03a 	or	r2,r2,r5
 181fd94:	10bfffcc 	andi	r2,r2,65535
 181fd98:	1004923a 	slli	r2,r2,8
 181fd9c:	10bfffcc 	andi	r2,r2,65535
 181fda0:	2084b03a 	or	r2,r4,r2
 181fda4:	108000cc 	andi	r2,r2,3
 181fda8:	1004c03a 	cmpne	r2,r2,zero
 181fdac:	10803fcc 	andi	r2,r2,255
 181fdb0:	1885883a 	add	r2,r3,r2
 181fdb4:	0081100e 	bge	zero,r2,18201f8 <tcp_output+0x93c>
      seg->next = NULL;
 181fdb8:	e0bffa17 	ldw	r2,-24(fp)
 181fdbc:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 181fdc0:	e0bfff17 	ldw	r2,-4(fp)
 181fdc4:	10801d17 	ldw	r2,116(r2)
 181fdc8:	1000061e 	bne	r2,zero,181fde4 <tcp_output+0x528>
        pcb->unacked = seg;
 181fdcc:	e0bfff17 	ldw	r2,-4(fp)
 181fdd0:	e0fffa17 	ldw	r3,-24(fp)
 181fdd4:	10c01d15 	stw	r3,116(r2)
        useg = seg;
 181fdd8:	e0bffa17 	ldw	r2,-24(fp)
 181fddc:	e0bffb15 	stw	r2,-20(fp)
 181fde0:	00010706 	br	1820200 <tcp_output+0x944>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 181fde4:	e0bffa17 	ldw	r2,-24(fp)
 181fde8:	10800417 	ldw	r2,16(r2)
 181fdec:	10c00103 	ldbu	r3,4(r2)
 181fdf0:	11000143 	ldbu	r4,5(r2)
 181fdf4:	2008923a 	slli	r4,r4,8
 181fdf8:	20c6b03a 	or	r3,r4,r3
 181fdfc:	11000183 	ldbu	r4,6(r2)
 181fe00:	2008943a 	slli	r4,r4,16
 181fe04:	20c6b03a 	or	r3,r4,r3
 181fe08:	108001c3 	ldbu	r2,7(r2)
 181fe0c:	1004963a 	slli	r2,r2,24
 181fe10:	10c4b03a 	or	r2,r2,r3
 181fe14:	1006d63a 	srli	r3,r2,24
 181fe18:	e0bffa17 	ldw	r2,-24(fp)
 181fe1c:	10800417 	ldw	r2,16(r2)
 181fe20:	11000103 	ldbu	r4,4(r2)
 181fe24:	11400143 	ldbu	r5,5(r2)
 181fe28:	280a923a 	slli	r5,r5,8
 181fe2c:	2908b03a 	or	r4,r5,r4
 181fe30:	11400183 	ldbu	r5,6(r2)
 181fe34:	280a943a 	slli	r5,r5,16
 181fe38:	2908b03a 	or	r4,r5,r4
 181fe3c:	108001c3 	ldbu	r2,7(r2)
 181fe40:	1004963a 	slli	r2,r2,24
 181fe44:	1104b03a 	or	r2,r2,r4
 181fe48:	1004d23a 	srli	r2,r2,8
 181fe4c:	10bfc00c 	andi	r2,r2,65280
 181fe50:	1886b03a 	or	r3,r3,r2
 181fe54:	e0bffa17 	ldw	r2,-24(fp)
 181fe58:	10800417 	ldw	r2,16(r2)
 181fe5c:	11000103 	ldbu	r4,4(r2)
 181fe60:	11400143 	ldbu	r5,5(r2)
 181fe64:	280a923a 	slli	r5,r5,8
 181fe68:	2908b03a 	or	r4,r5,r4
 181fe6c:	11400183 	ldbu	r5,6(r2)
 181fe70:	280a943a 	slli	r5,r5,16
 181fe74:	2908b03a 	or	r4,r5,r4
 181fe78:	108001c3 	ldbu	r2,7(r2)
 181fe7c:	1004963a 	slli	r2,r2,24
 181fe80:	1104b03a 	or	r2,r2,r4
 181fe84:	10bfc00c 	andi	r2,r2,65280
 181fe88:	1004923a 	slli	r2,r2,8
 181fe8c:	1886b03a 	or	r3,r3,r2
 181fe90:	e0bffa17 	ldw	r2,-24(fp)
 181fe94:	10800417 	ldw	r2,16(r2)
 181fe98:	11000103 	ldbu	r4,4(r2)
 181fe9c:	11400143 	ldbu	r5,5(r2)
 181fea0:	280a923a 	slli	r5,r5,8
 181fea4:	2908b03a 	or	r4,r5,r4
 181fea8:	11400183 	ldbu	r5,6(r2)
 181feac:	280a943a 	slli	r5,r5,16
 181feb0:	2908b03a 	or	r4,r5,r4
 181feb4:	108001c3 	ldbu	r2,7(r2)
 181feb8:	1004963a 	slli	r2,r2,24
 181febc:	1104b03a 	or	r2,r2,r4
 181fec0:	1004963a 	slli	r2,r2,24
 181fec4:	1886b03a 	or	r3,r3,r2
 181fec8:	e0bffb17 	ldw	r2,-20(fp)
 181fecc:	10800417 	ldw	r2,16(r2)
 181fed0:	11000103 	ldbu	r4,4(r2)
 181fed4:	11400143 	ldbu	r5,5(r2)
 181fed8:	280a923a 	slli	r5,r5,8
 181fedc:	2908b03a 	or	r4,r5,r4
 181fee0:	11400183 	ldbu	r5,6(r2)
 181fee4:	280a943a 	slli	r5,r5,16
 181fee8:	2908b03a 	or	r4,r5,r4
 181feec:	108001c3 	ldbu	r2,7(r2)
 181fef0:	1004963a 	slli	r2,r2,24
 181fef4:	1104b03a 	or	r2,r2,r4
 181fef8:	1008d63a 	srli	r4,r2,24
 181fefc:	e0bffb17 	ldw	r2,-20(fp)
 181ff00:	10800417 	ldw	r2,16(r2)
 181ff04:	11400103 	ldbu	r5,4(r2)
 181ff08:	11800143 	ldbu	r6,5(r2)
 181ff0c:	300c923a 	slli	r6,r6,8
 181ff10:	314ab03a 	or	r5,r6,r5
 181ff14:	11800183 	ldbu	r6,6(r2)
 181ff18:	300c943a 	slli	r6,r6,16
 181ff1c:	314ab03a 	or	r5,r6,r5
 181ff20:	108001c3 	ldbu	r2,7(r2)
 181ff24:	1004963a 	slli	r2,r2,24
 181ff28:	1144b03a 	or	r2,r2,r5
 181ff2c:	1004d23a 	srli	r2,r2,8
 181ff30:	10bfc00c 	andi	r2,r2,65280
 181ff34:	2088b03a 	or	r4,r4,r2
 181ff38:	e0bffb17 	ldw	r2,-20(fp)
 181ff3c:	10800417 	ldw	r2,16(r2)
 181ff40:	11400103 	ldbu	r5,4(r2)
 181ff44:	11800143 	ldbu	r6,5(r2)
 181ff48:	300c923a 	slli	r6,r6,8
 181ff4c:	314ab03a 	or	r5,r6,r5
 181ff50:	11800183 	ldbu	r6,6(r2)
 181ff54:	300c943a 	slli	r6,r6,16
 181ff58:	314ab03a 	or	r5,r6,r5
 181ff5c:	108001c3 	ldbu	r2,7(r2)
 181ff60:	1004963a 	slli	r2,r2,24
 181ff64:	1144b03a 	or	r2,r2,r5
 181ff68:	10bfc00c 	andi	r2,r2,65280
 181ff6c:	1004923a 	slli	r2,r2,8
 181ff70:	2088b03a 	or	r4,r4,r2
 181ff74:	e0bffb17 	ldw	r2,-20(fp)
 181ff78:	10800417 	ldw	r2,16(r2)
 181ff7c:	11400103 	ldbu	r5,4(r2)
 181ff80:	11800143 	ldbu	r6,5(r2)
 181ff84:	300c923a 	slli	r6,r6,8
 181ff88:	314ab03a 	or	r5,r6,r5
 181ff8c:	11800183 	ldbu	r6,6(r2)
 181ff90:	300c943a 	slli	r6,r6,16
 181ff94:	314ab03a 	or	r5,r6,r5
 181ff98:	108001c3 	ldbu	r2,7(r2)
 181ff9c:	1004963a 	slli	r2,r2,24
 181ffa0:	1144b03a 	or	r2,r2,r5
 181ffa4:	1004963a 	slli	r2,r2,24
 181ffa8:	2084b03a 	or	r2,r4,r2
 181ffac:	1885c83a 	sub	r2,r3,r2
 181ffb0:	10008a0e 	bge	r2,zero,18201dc <tcp_output+0x920>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 181ffb4:	e0bfff17 	ldw	r2,-4(fp)
 181ffb8:	10801d04 	addi	r2,r2,116
 181ffbc:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
 181ffc0:	00000306 	br	181ffd0 <tcp_output+0x714>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 181ffc4:	e0bffc17 	ldw	r2,-16(fp)
 181ffc8:	10800017 	ldw	r2,0(r2)
 181ffcc:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 181ffd0:	e0bffc17 	ldw	r2,-16(fp)
 181ffd4:	10800017 	ldw	r2,0(r2)
 181ffd8:	10007826 	beq	r2,zero,18201bc <tcp_output+0x900>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 181ffdc:	e0bffc17 	ldw	r2,-16(fp)
 181ffe0:	10800017 	ldw	r2,0(r2)
 181ffe4:	10800417 	ldw	r2,16(r2)
 181ffe8:	10c00103 	ldbu	r3,4(r2)
 181ffec:	11000143 	ldbu	r4,5(r2)
 181fff0:	2008923a 	slli	r4,r4,8
 181fff4:	20c6b03a 	or	r3,r4,r3
 181fff8:	11000183 	ldbu	r4,6(r2)
 181fffc:	2008943a 	slli	r4,r4,16
 1820000:	20c6b03a 	or	r3,r4,r3
 1820004:	108001c3 	ldbu	r2,7(r2)
 1820008:	1004963a 	slli	r2,r2,24
 182000c:	10c4b03a 	or	r2,r2,r3
 1820010:	1006d63a 	srli	r3,r2,24
 1820014:	e0bffc17 	ldw	r2,-16(fp)
 1820018:	10800017 	ldw	r2,0(r2)
 182001c:	10800417 	ldw	r2,16(r2)
 1820020:	11000103 	ldbu	r4,4(r2)
 1820024:	11400143 	ldbu	r5,5(r2)
 1820028:	280a923a 	slli	r5,r5,8
 182002c:	2908b03a 	or	r4,r5,r4
 1820030:	11400183 	ldbu	r5,6(r2)
 1820034:	280a943a 	slli	r5,r5,16
 1820038:	2908b03a 	or	r4,r5,r4
 182003c:	108001c3 	ldbu	r2,7(r2)
 1820040:	1004963a 	slli	r2,r2,24
 1820044:	1104b03a 	or	r2,r2,r4
 1820048:	1004d23a 	srli	r2,r2,8
 182004c:	10bfc00c 	andi	r2,r2,65280
 1820050:	1886b03a 	or	r3,r3,r2
 1820054:	e0bffc17 	ldw	r2,-16(fp)
 1820058:	10800017 	ldw	r2,0(r2)
 182005c:	10800417 	ldw	r2,16(r2)
 1820060:	11000103 	ldbu	r4,4(r2)
 1820064:	11400143 	ldbu	r5,5(r2)
 1820068:	280a923a 	slli	r5,r5,8
 182006c:	2908b03a 	or	r4,r5,r4
 1820070:	11400183 	ldbu	r5,6(r2)
 1820074:	280a943a 	slli	r5,r5,16
 1820078:	2908b03a 	or	r4,r5,r4
 182007c:	108001c3 	ldbu	r2,7(r2)
 1820080:	1004963a 	slli	r2,r2,24
 1820084:	1104b03a 	or	r2,r2,r4
 1820088:	10bfc00c 	andi	r2,r2,65280
 182008c:	1004923a 	slli	r2,r2,8
 1820090:	1886b03a 	or	r3,r3,r2
 1820094:	e0bffc17 	ldw	r2,-16(fp)
 1820098:	10800017 	ldw	r2,0(r2)
 182009c:	10800417 	ldw	r2,16(r2)
 18200a0:	11000103 	ldbu	r4,4(r2)
 18200a4:	11400143 	ldbu	r5,5(r2)
 18200a8:	280a923a 	slli	r5,r5,8
 18200ac:	2908b03a 	or	r4,r5,r4
 18200b0:	11400183 	ldbu	r5,6(r2)
 18200b4:	280a943a 	slli	r5,r5,16
 18200b8:	2908b03a 	or	r4,r5,r4
 18200bc:	108001c3 	ldbu	r2,7(r2)
 18200c0:	1004963a 	slli	r2,r2,24
 18200c4:	1104b03a 	or	r2,r2,r4
 18200c8:	1004963a 	slli	r2,r2,24
 18200cc:	1886b03a 	or	r3,r3,r2
 18200d0:	e0bffa17 	ldw	r2,-24(fp)
 18200d4:	10800417 	ldw	r2,16(r2)
 18200d8:	11000103 	ldbu	r4,4(r2)
 18200dc:	11400143 	ldbu	r5,5(r2)
 18200e0:	280a923a 	slli	r5,r5,8
 18200e4:	2908b03a 	or	r4,r5,r4
 18200e8:	11400183 	ldbu	r5,6(r2)
 18200ec:	280a943a 	slli	r5,r5,16
 18200f0:	2908b03a 	or	r4,r5,r4
 18200f4:	108001c3 	ldbu	r2,7(r2)
 18200f8:	1004963a 	slli	r2,r2,24
 18200fc:	1104b03a 	or	r2,r2,r4
 1820100:	1008d63a 	srli	r4,r2,24
 1820104:	e0bffa17 	ldw	r2,-24(fp)
 1820108:	10800417 	ldw	r2,16(r2)
 182010c:	11400103 	ldbu	r5,4(r2)
 1820110:	11800143 	ldbu	r6,5(r2)
 1820114:	300c923a 	slli	r6,r6,8
 1820118:	314ab03a 	or	r5,r6,r5
 182011c:	11800183 	ldbu	r6,6(r2)
 1820120:	300c943a 	slli	r6,r6,16
 1820124:	314ab03a 	or	r5,r6,r5
 1820128:	108001c3 	ldbu	r2,7(r2)
 182012c:	1004963a 	slli	r2,r2,24
 1820130:	1144b03a 	or	r2,r2,r5
 1820134:	1004d23a 	srli	r2,r2,8
 1820138:	10bfc00c 	andi	r2,r2,65280
 182013c:	2088b03a 	or	r4,r4,r2
 1820140:	e0bffa17 	ldw	r2,-24(fp)
 1820144:	10800417 	ldw	r2,16(r2)
 1820148:	11400103 	ldbu	r5,4(r2)
 182014c:	11800143 	ldbu	r6,5(r2)
 1820150:	300c923a 	slli	r6,r6,8
 1820154:	314ab03a 	or	r5,r6,r5
 1820158:	11800183 	ldbu	r6,6(r2)
 182015c:	300c943a 	slli	r6,r6,16
 1820160:	314ab03a 	or	r5,r6,r5
 1820164:	108001c3 	ldbu	r2,7(r2)
 1820168:	1004963a 	slli	r2,r2,24
 182016c:	1144b03a 	or	r2,r2,r5
 1820170:	10bfc00c 	andi	r2,r2,65280
 1820174:	1004923a 	slli	r2,r2,8
 1820178:	2088b03a 	or	r4,r4,r2
 182017c:	e0bffa17 	ldw	r2,-24(fp)
 1820180:	10800417 	ldw	r2,16(r2)
 1820184:	11400103 	ldbu	r5,4(r2)
 1820188:	11800143 	ldbu	r6,5(r2)
 182018c:	300c923a 	slli	r6,r6,8
 1820190:	314ab03a 	or	r5,r6,r5
 1820194:	11800183 	ldbu	r6,6(r2)
 1820198:	300c943a 	slli	r6,r6,16
 182019c:	314ab03a 	or	r5,r6,r5
 18201a0:	108001c3 	ldbu	r2,7(r2)
 18201a4:	1004963a 	slli	r2,r2,24
 18201a8:	1144b03a 	or	r2,r2,r5
 18201ac:	1004963a 	slli	r2,r2,24
 18201b0:	2084b03a 	or	r2,r4,r2
 18201b4:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 18201b8:	103f8216 	blt	r2,zero,181ffc4 <__ram_exceptions_end+0xff80fb80>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 18201bc:	e0bffc17 	ldw	r2,-16(fp)
 18201c0:	10c00017 	ldw	r3,0(r2)
 18201c4:	e0bffa17 	ldw	r2,-24(fp)
 18201c8:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
 18201cc:	e0bffc17 	ldw	r2,-16(fp)
 18201d0:	e0fffa17 	ldw	r3,-24(fp)
 18201d4:	10c00015 	stw	r3,0(r2)
 18201d8:	00000906 	br	1820200 <tcp_output+0x944>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 18201dc:	e0bffb17 	ldw	r2,-20(fp)
 18201e0:	e0fffa17 	ldw	r3,-24(fp)
 18201e4:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
 18201e8:	e0bffb17 	ldw	r2,-20(fp)
 18201ec:	10800017 	ldw	r2,0(r2)
 18201f0:	e0bffb15 	stw	r2,-20(fp)
 18201f4:	00000206 	br	1820200 <tcp_output+0x944>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 18201f8:	e13ffa17 	ldw	r4,-24(fp)
 18201fc:	181d56c0 	call	181d56c <tcp_seg_free>
    }
    seg = pcb->unsent;
 1820200:	e0bfff17 	ldw	r2,-4(fp)
 1820204:	10801c17 	ldw	r2,112(r2)
 1820208:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 182020c:	e0bffa17 	ldw	r2,-24(fp)
 1820210:	10004426 	beq	r2,zero,1820324 <tcp_output+0xa68>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 1820214:	e0bffa17 	ldw	r2,-24(fp)
 1820218:	10800417 	ldw	r2,16(r2)
 182021c:	10c00103 	ldbu	r3,4(r2)
 1820220:	11000143 	ldbu	r4,5(r2)
 1820224:	2008923a 	slli	r4,r4,8
 1820228:	20c6b03a 	or	r3,r4,r3
 182022c:	11000183 	ldbu	r4,6(r2)
 1820230:	2008943a 	slli	r4,r4,16
 1820234:	20c6b03a 	or	r3,r4,r3
 1820238:	108001c3 	ldbu	r2,7(r2)
 182023c:	1004963a 	slli	r2,r2,24
 1820240:	10c4b03a 	or	r2,r2,r3
 1820244:	1006d63a 	srli	r3,r2,24
 1820248:	e0bffa17 	ldw	r2,-24(fp)
 182024c:	10800417 	ldw	r2,16(r2)
 1820250:	11000103 	ldbu	r4,4(r2)
 1820254:	11400143 	ldbu	r5,5(r2)
 1820258:	280a923a 	slli	r5,r5,8
 182025c:	2908b03a 	or	r4,r5,r4
 1820260:	11400183 	ldbu	r5,6(r2)
 1820264:	280a943a 	slli	r5,r5,16
 1820268:	2908b03a 	or	r4,r5,r4
 182026c:	108001c3 	ldbu	r2,7(r2)
 1820270:	1004963a 	slli	r2,r2,24
 1820274:	1104b03a 	or	r2,r2,r4
 1820278:	1004d23a 	srli	r2,r2,8
 182027c:	10bfc00c 	andi	r2,r2,65280
 1820280:	1886b03a 	or	r3,r3,r2
 1820284:	e0bffa17 	ldw	r2,-24(fp)
 1820288:	10800417 	ldw	r2,16(r2)
 182028c:	11000103 	ldbu	r4,4(r2)
 1820290:	11400143 	ldbu	r5,5(r2)
 1820294:	280a923a 	slli	r5,r5,8
 1820298:	2908b03a 	or	r4,r5,r4
 182029c:	11400183 	ldbu	r5,6(r2)
 18202a0:	280a943a 	slli	r5,r5,16
 18202a4:	2908b03a 	or	r4,r5,r4
 18202a8:	108001c3 	ldbu	r2,7(r2)
 18202ac:	1004963a 	slli	r2,r2,24
 18202b0:	1104b03a 	or	r2,r2,r4
 18202b4:	10bfc00c 	andi	r2,r2,65280
 18202b8:	1004923a 	slli	r2,r2,8
 18202bc:	1886b03a 	or	r3,r3,r2
 18202c0:	e0bffa17 	ldw	r2,-24(fp)
 18202c4:	10800417 	ldw	r2,16(r2)
 18202c8:	11000103 	ldbu	r4,4(r2)
 18202cc:	11400143 	ldbu	r5,5(r2)
 18202d0:	280a923a 	slli	r5,r5,8
 18202d4:	2908b03a 	or	r4,r5,r4
 18202d8:	11400183 	ldbu	r5,6(r2)
 18202dc:	280a943a 	slli	r5,r5,16
 18202e0:	2908b03a 	or	r4,r5,r4
 18202e4:	108001c3 	ldbu	r2,7(r2)
 18202e8:	1004963a 	slli	r2,r2,24
 18202ec:	1104b03a 	or	r2,r2,r4
 18202f0:	1004963a 	slli	r2,r2,24
 18202f4:	1886b03a 	or	r3,r3,r2
 18202f8:	e0bfff17 	ldw	r2,-4(fp)
 18202fc:	10801317 	ldw	r2,76(r2)
 1820300:	1887c83a 	sub	r3,r3,r2
 1820304:	e0bffa17 	ldw	r2,-24(fp)
 1820308:	1080020b 	ldhu	r2,8(r2)
 182030c:	10bfffcc 	andi	r2,r2,65535
 1820310:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 1820314:	e0fffd17 	ldw	r3,-12(fp)
 1820318:	18bdd92e 	bgeu	r3,r2,181fa80 <__ram_exceptions_end+0xff80f63c>
 182031c:	00000106 	br	1820324 <tcp_output+0xa68>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
 1820320:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 1820324:	e0bfff17 	ldw	r2,-4(fp)
 1820328:	10801c17 	ldw	r2,112(r2)
 182032c:	1000021e 	bne	r2,zero,1820338 <tcp_output+0xa7c>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 1820330:	e0bfff17 	ldw	r2,-4(fp)
 1820334:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 1820338:	e0bfff17 	ldw	r2,-4(fp)
 182033c:	10800883 	ldbu	r2,34(r2)
 1820340:	10801fcc 	andi	r2,r2,127
 1820344:	1007883a 	mov	r3,r2
 1820348:	e0bfff17 	ldw	r2,-4(fp)
 182034c:	10c00885 	stb	r3,34(r2)
  return ERR_OK;
 1820350:	0005883a 	mov	r2,zero
}
 1820354:	e037883a 	mov	sp,fp
 1820358:	dfc00117 	ldw	ra,4(sp)
 182035c:	df000017 	ldw	fp,0(sp)
 1820360:	dec00204 	addi	sp,sp,8
 1820364:	f800283a 	ret

01820368 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
 1820368:	defff404 	addi	sp,sp,-48
 182036c:	dfc00b15 	stw	ra,44(sp)
 1820370:	df000a15 	stw	fp,40(sp)
 1820374:	df000a04 	addi	fp,sp,40
 1820378:	e13ffe15 	stw	r4,-8(fp)
 182037c:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 1820380:	e0bffe17 	ldw	r2,-8(fp)
 1820384:	10800417 	ldw	r2,16(r2)
 1820388:	e0ffff17 	ldw	r3,-4(fp)
 182038c:	18c00b17 	ldw	r3,44(r3)
 1820390:	1808d63a 	srli	r4,r3,24
 1820394:	e0ffff17 	ldw	r3,-4(fp)
 1820398:	18c00b17 	ldw	r3,44(r3)
 182039c:	1806d23a 	srli	r3,r3,8
 18203a0:	18ffc00c 	andi	r3,r3,65280
 18203a4:	20c8b03a 	or	r4,r4,r3
 18203a8:	e0ffff17 	ldw	r3,-4(fp)
 18203ac:	18c00b17 	ldw	r3,44(r3)
 18203b0:	18ffc00c 	andi	r3,r3,65280
 18203b4:	1806923a 	slli	r3,r3,8
 18203b8:	20c8b03a 	or	r4,r4,r3
 18203bc:	e0ffff17 	ldw	r3,-4(fp)
 18203c0:	18c00b17 	ldw	r3,44(r3)
 18203c4:	1806963a 	slli	r3,r3,24
 18203c8:	20c6b03a 	or	r3,r4,r3
 18203cc:	19803fcc 	andi	r6,r3,255
 18203d0:	11000203 	ldbu	r4,8(r2)
 18203d4:	2008703a 	and	r4,r4,zero
 18203d8:	200b883a 	mov	r5,r4
 18203dc:	3009883a 	mov	r4,r6
 18203e0:	2908b03a 	or	r4,r5,r4
 18203e4:	11000205 	stb	r4,8(r2)
 18203e8:	1808d23a 	srli	r4,r3,8
 18203ec:	21803fcc 	andi	r6,r4,255
 18203f0:	11000243 	ldbu	r4,9(r2)
 18203f4:	2008703a 	and	r4,r4,zero
 18203f8:	200b883a 	mov	r5,r4
 18203fc:	3009883a 	mov	r4,r6
 1820400:	2908b03a 	or	r4,r5,r4
 1820404:	11000245 	stb	r4,9(r2)
 1820408:	1808d43a 	srli	r4,r3,16
 182040c:	21803fcc 	andi	r6,r4,255
 1820410:	11000283 	ldbu	r4,10(r2)
 1820414:	2008703a 	and	r4,r4,zero
 1820418:	200b883a 	mov	r5,r4
 182041c:	3009883a 	mov	r4,r6
 1820420:	2908b03a 	or	r4,r5,r4
 1820424:	11000285 	stb	r4,10(r2)
 1820428:	180ad63a 	srli	r5,r3,24
 182042c:	10c002c3 	ldbu	r3,11(r2)
 1820430:	1806703a 	and	r3,r3,zero
 1820434:	1809883a 	mov	r4,r3
 1820438:	2807883a 	mov	r3,r5
 182043c:	20c6b03a 	or	r3,r4,r3
 1820440:	10c002c5 	stb	r3,11(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 1820444:	e0bffe17 	ldw	r2,-8(fp)
 1820448:	10800417 	ldw	r2,16(r2)
 182044c:	e0ffff17 	ldw	r3,-4(fp)
 1820450:	18c00c8b 	ldhu	r3,50(r3)
 1820454:	18ffffcc 	andi	r3,r3,65535
 1820458:	1806d23a 	srli	r3,r3,8
 182045c:	1809883a 	mov	r4,r3
 1820460:	e0ffff17 	ldw	r3,-4(fp)
 1820464:	18c00c8b 	ldhu	r3,50(r3)
 1820468:	18ffffcc 	andi	r3,r3,65535
 182046c:	1806923a 	slli	r3,r3,8
 1820470:	20c6b03a 	or	r3,r4,r3
 1820474:	180d883a 	mov	r6,r3
 1820478:	30ffffcc 	andi	r3,r6,65535
 182047c:	19403fcc 	andi	r5,r3,255
 1820480:	10c00383 	ldbu	r3,14(r2)
 1820484:	1806703a 	and	r3,r3,zero
 1820488:	1809883a 	mov	r4,r3
 182048c:	2807883a 	mov	r3,r5
 1820490:	20c6b03a 	or	r3,r4,r3
 1820494:	10c00385 	stb	r3,14(r2)
 1820498:	30ffffcc 	andi	r3,r6,65535
 182049c:	1806d23a 	srli	r3,r3,8
 18204a0:	197fffcc 	andi	r5,r3,65535
 18204a4:	10c003c3 	ldbu	r3,15(r2)
 18204a8:	1806703a 	and	r3,r3,zero
 18204ac:	1809883a 	mov	r4,r3
 18204b0:	2807883a 	mov	r3,r5
 18204b4:	20c6b03a 	or	r3,r4,r3
 18204b8:	10c003c5 	stb	r3,15(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 18204bc:	e0bfff17 	ldw	r2,-4(fp)
 18204c0:	10c00b17 	ldw	r3,44(r2)
 18204c4:	e0bfff17 	ldw	r2,-4(fp)
 18204c8:	10800c8b 	ldhu	r2,50(r2)
 18204cc:	10bfffcc 	andi	r2,r2,65535
 18204d0:	1887883a 	add	r3,r3,r2
 18204d4:	e0bfff17 	ldw	r2,-4(fp)
 18204d8:	10c00d15 	stw	r3,52(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 18204dc:	e0bffe17 	ldw	r2,-8(fp)
 18204e0:	10800417 	ldw	r2,16(r2)
 18204e4:	10800504 	addi	r2,r2,20
 18204e8:	e0bff915 	stw	r2,-28(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
 18204ec:	e0bffe17 	ldw	r2,-8(fp)
 18204f0:	10800343 	ldbu	r2,13(r2)
 18204f4:	10803fcc 	andi	r2,r2,255
 18204f8:	1080004c 	andi	r2,r2,1
 18204fc:	10001e26 	beq	r2,zero,1820578 <tcp_output_segment+0x210>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &(pcb->local_ip), &(pcb->remote_ip));
 1820500:	e0ffff17 	ldw	r3,-4(fp)
 1820504:	e0bfff17 	ldw	r2,-4(fp)
 1820508:	10800104 	addi	r2,r2,4
 182050c:	100d883a 	mov	r6,r2
 1820510:	180b883a 	mov	r5,r3
 1820514:	01016d04 	movi	r4,1460
 1820518:	181de740 	call	181de74 <tcp_eff_send_mss>
 182051c:	e0bffa0d 	sth	r2,-24(fp)
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 1820520:	e0bffa0b 	ldhu	r2,-24(fp)
 1820524:	10808134 	orhi	r2,r2,516
 1820528:	1004d63a 	srli	r2,r2,24
 182052c:	1007883a 	mov	r3,r2
 1820530:	e0bffa0b 	ldhu	r2,-24(fp)
 1820534:	10808134 	orhi	r2,r2,516
 1820538:	1005d23a 	srai	r2,r2,8
 182053c:	10bfc00c 	andi	r2,r2,65280
 1820540:	1886b03a 	or	r3,r3,r2
 1820544:	e0bffa0b 	ldhu	r2,-24(fp)
 1820548:	10bfc00c 	andi	r2,r2,65280
 182054c:	1004923a 	slli	r2,r2,8
 1820550:	1886b03a 	or	r3,r3,r2
 1820554:	e0bffa0b 	ldhu	r2,-24(fp)
 1820558:	1004963a 	slli	r2,r2,24
 182055c:	1884b03a 	or	r2,r3,r2
 1820560:	1007883a 	mov	r3,r2
 1820564:	e0bff917 	ldw	r2,-28(fp)
 1820568:	10c00015 	stw	r3,0(r2)
    opts += 1;
 182056c:	e0bff917 	ldw	r2,-28(fp)
 1820570:	10800104 	addi	r2,r2,4
 1820574:	e0bff915 	stw	r2,-28(fp)
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 1820578:	e0bfff17 	ldw	r2,-4(fp)
 182057c:	10800e0b 	ldhu	r2,56(r2)
 1820580:	10bfffcc 	andi	r2,r2,65535
 1820584:	10a0001c 	xori	r2,r2,32768
 1820588:	10a00004 	addi	r2,r2,-32768
 182058c:	10bfffd8 	cmpnei	r2,r2,-1
 1820590:	1000021e 	bne	r2,zero,182059c <tcp_output_segment+0x234>
    pcb->rtime = 0;
 1820594:	e0bfff17 	ldw	r2,-4(fp)
 1820598:	10000e0d 	sth	zero,56(r2)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 182059c:	e0bfff17 	ldw	r2,-4(fp)
 18205a0:	10000326 	beq	r2,zero,18205b0 <tcp_output_segment+0x248>
 18205a4:	e0bfff17 	ldw	r2,-4(fp)
 18205a8:	10800017 	ldw	r2,0(r2)
 18205ac:	10000d1e 	bne	r2,zero,18205e4 <tcp_output_segment+0x27c>
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
 18205b0:	e0ffff17 	ldw	r3,-4(fp)
 18205b4:	e0bfff17 	ldw	r2,-4(fp)
 18205b8:	10800104 	addi	r2,r2,4
 18205bc:	100b883a 	mov	r5,r2
 18205c0:	1809883a 	mov	r4,r3
 18205c4:	18322400 	call	1832240 <ip_route>
 18205c8:	e0bffb15 	stw	r2,-20(fp)
    if (netif == NULL) {
 18205cc:	e0bffb17 	ldw	r2,-20(fp)
 18205d0:	1000df26 	beq	r2,zero,1820950 <tcp_output_segment+0x5e8>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 18205d4:	e0bffb17 	ldw	r2,-20(fp)
 18205d8:	10c00117 	ldw	r3,4(r2)
 18205dc:	e0bfff17 	ldw	r2,-4(fp)
 18205e0:	10c00015 	stw	r3,0(r2)
  }

  if (pcb->rttest == 0) {
 18205e4:	e0bfff17 	ldw	r2,-4(fp)
 18205e8:	10800f17 	ldw	r2,60(r2)
 18205ec:	10003e1e 	bne	r2,zero,18206e8 <tcp_output_segment+0x380>
    pcb->rttest = tcp_ticks;
 18205f0:	d0e7f817 	ldw	r3,-24608(gp)
 18205f4:	e0bfff17 	ldw	r2,-4(fp)
 18205f8:	10c00f15 	stw	r3,60(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 18205fc:	e0bffe17 	ldw	r2,-8(fp)
 1820600:	10800417 	ldw	r2,16(r2)
 1820604:	10c00103 	ldbu	r3,4(r2)
 1820608:	11000143 	ldbu	r4,5(r2)
 182060c:	2008923a 	slli	r4,r4,8
 1820610:	20c6b03a 	or	r3,r4,r3
 1820614:	11000183 	ldbu	r4,6(r2)
 1820618:	2008943a 	slli	r4,r4,16
 182061c:	20c6b03a 	or	r3,r4,r3
 1820620:	108001c3 	ldbu	r2,7(r2)
 1820624:	1004963a 	slli	r2,r2,24
 1820628:	10c4b03a 	or	r2,r2,r3
 182062c:	1006d63a 	srli	r3,r2,24
 1820630:	e0bffe17 	ldw	r2,-8(fp)
 1820634:	10800417 	ldw	r2,16(r2)
 1820638:	11000103 	ldbu	r4,4(r2)
 182063c:	11400143 	ldbu	r5,5(r2)
 1820640:	280a923a 	slli	r5,r5,8
 1820644:	2908b03a 	or	r4,r5,r4
 1820648:	11400183 	ldbu	r5,6(r2)
 182064c:	280a943a 	slli	r5,r5,16
 1820650:	2908b03a 	or	r4,r5,r4
 1820654:	108001c3 	ldbu	r2,7(r2)
 1820658:	1004963a 	slli	r2,r2,24
 182065c:	1104b03a 	or	r2,r2,r4
 1820660:	1004d23a 	srli	r2,r2,8
 1820664:	10bfc00c 	andi	r2,r2,65280
 1820668:	1886b03a 	or	r3,r3,r2
 182066c:	e0bffe17 	ldw	r2,-8(fp)
 1820670:	10800417 	ldw	r2,16(r2)
 1820674:	11000103 	ldbu	r4,4(r2)
 1820678:	11400143 	ldbu	r5,5(r2)
 182067c:	280a923a 	slli	r5,r5,8
 1820680:	2908b03a 	or	r4,r5,r4
 1820684:	11400183 	ldbu	r5,6(r2)
 1820688:	280a943a 	slli	r5,r5,16
 182068c:	2908b03a 	or	r4,r5,r4
 1820690:	108001c3 	ldbu	r2,7(r2)
 1820694:	1004963a 	slli	r2,r2,24
 1820698:	1104b03a 	or	r2,r2,r4
 182069c:	10bfc00c 	andi	r2,r2,65280
 18206a0:	1004923a 	slli	r2,r2,8
 18206a4:	1886b03a 	or	r3,r3,r2
 18206a8:	e0bffe17 	ldw	r2,-8(fp)
 18206ac:	10800417 	ldw	r2,16(r2)
 18206b0:	11000103 	ldbu	r4,4(r2)
 18206b4:	11400143 	ldbu	r5,5(r2)
 18206b8:	280a923a 	slli	r5,r5,8
 18206bc:	2908b03a 	or	r4,r5,r4
 18206c0:	11400183 	ldbu	r5,6(r2)
 18206c4:	280a943a 	slli	r5,r5,16
 18206c8:	2908b03a 	or	r4,r5,r4
 18206cc:	108001c3 	ldbu	r2,7(r2)
 18206d0:	1004963a 	slli	r2,r2,24
 18206d4:	1104b03a 	or	r2,r2,r4
 18206d8:	1004963a 	slli	r2,r2,24
 18206dc:	1886b03a 	or	r3,r3,r2
 18206e0:	e0bfff17 	ldw	r2,-4(fp)
 18206e4:	10c01015 	stw	r3,64(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 18206e8:	e0bffe17 	ldw	r2,-8(fp)
 18206ec:	10800417 	ldw	r2,16(r2)
 18206f0:	1007883a 	mov	r3,r2
 18206f4:	e0bffe17 	ldw	r2,-8(fp)
 18206f8:	10800117 	ldw	r2,4(r2)
 18206fc:	10800117 	ldw	r2,4(r2)
 1820700:	1885c83a 	sub	r2,r3,r2
 1820704:	e0bffc0d 	sth	r2,-16(fp)

  seg->p->len -= len;
 1820708:	e0bffe17 	ldw	r2,-8(fp)
 182070c:	10800117 	ldw	r2,4(r2)
 1820710:	e0fffe17 	ldw	r3,-8(fp)
 1820714:	18c00117 	ldw	r3,4(r3)
 1820718:	1900028b 	ldhu	r4,10(r3)
 182071c:	e0fffc0b 	ldhu	r3,-16(fp)
 1820720:	20c7c83a 	sub	r3,r4,r3
 1820724:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
 1820728:	e0bffe17 	ldw	r2,-8(fp)
 182072c:	10800117 	ldw	r2,4(r2)
 1820730:	e0fffe17 	ldw	r3,-8(fp)
 1820734:	18c00117 	ldw	r3,4(r3)
 1820738:	1900020b 	ldhu	r4,8(r3)
 182073c:	e0fffc0b 	ldhu	r3,-16(fp)
 1820740:	20c7c83a 	sub	r3,r4,r3
 1820744:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
 1820748:	e0bffe17 	ldw	r2,-8(fp)
 182074c:	10800117 	ldw	r2,4(r2)
 1820750:	e0fffe17 	ldw	r3,-8(fp)
 1820754:	18c00417 	ldw	r3,16(r3)
 1820758:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
 182075c:	e0bffe17 	ldw	r2,-8(fp)
 1820760:	10800417 	ldw	r2,16(r2)
 1820764:	10c00403 	ldbu	r3,16(r2)
 1820768:	1806703a 	and	r3,r3,zero
 182076c:	10c00405 	stb	r3,16(r2)
 1820770:	10c00443 	ldbu	r3,17(r2)
 1820774:	1806703a 	and	r3,r3,zero
 1820778:	10c00445 	stb	r3,17(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 182077c:	e0bffe17 	ldw	r2,-8(fp)
 1820780:	12000117 	ldw	r8,4(r2)
 1820784:	e27fff17 	ldw	r9,-4(fp)
 1820788:	e0bfff17 	ldw	r2,-4(fp)
 182078c:	11800104 	addi	r6,r2,4
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
 1820790:	e0bffe17 	ldw	r2,-8(fp)
 1820794:	10800117 	ldw	r2,4(r2)
 1820798:	1080020b 	ldhu	r2,8(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 182079c:	10ffffcc 	andi	r3,r2,65535
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
 18207a0:	e0bffe17 	ldw	r2,-8(fp)
 18207a4:	10800417 	ldw	r2,16(r2)
 18207a8:	11000303 	ldbu	r4,12(r2)
 18207ac:	10800343 	ldbu	r2,13(r2)
 18207b0:	1004923a 	slli	r2,r2,8
 18207b4:	1104b03a 	or	r2,r2,r4
 18207b8:	10bfffcc 	andi	r2,r2,65535
 18207bc:	1004d23a 	srli	r2,r2,8
 18207c0:	113fffcc 	andi	r4,r2,65535
 18207c4:	e0bffe17 	ldw	r2,-8(fp)
 18207c8:	10800417 	ldw	r2,16(r2)
 18207cc:	11400303 	ldbu	r5,12(r2)
 18207d0:	10800343 	ldbu	r2,13(r2)
 18207d4:	1004923a 	slli	r2,r2,8
 18207d8:	1144b03a 	or	r2,r2,r5
 18207dc:	10bfffcc 	andi	r2,r2,65535
 18207e0:	1004923a 	slli	r2,r2,8
 18207e4:	10bfffcc 	andi	r2,r2,65535
 18207e8:	2084b03a 	or	r2,r4,r2
 18207ec:	1005d33a 	srai	r2,r2,12
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 18207f0:	1085883a 	add	r2,r2,r2
 18207f4:	1085883a 	add	r2,r2,r2
 18207f8:	10bfffcc 	andi	r2,r2,65535
 18207fc:	d8800115 	stw	r2,4(sp)
 1820800:	d8c00015 	stw	r3,0(sp)
 1820804:	01c00184 	movi	r7,6
 1820808:	480b883a 	mov	r5,r9
 182080c:	4009883a 	mov	r4,r8
 1820810:	1831e600 	call	1831e60 <inet_chksum_pseudo_partial>
 1820814:	10bfffcc 	andi	r2,r2,65535
 1820818:	e0bffd15 	stw	r2,-12(fp)
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
    /* add payload checksum */
    if (seg->chksum_swapped) {
 182081c:	e0bffe17 	ldw	r2,-8(fp)
 1820820:	10800303 	ldbu	r2,12(r2)
 1820824:	10803fcc 	andi	r2,r2,255
 1820828:	10000f26 	beq	r2,zero,1820868 <tcp_output_segment+0x500>
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 182082c:	e0bffe17 	ldw	r2,-8(fp)
 1820830:	1080028b 	ldhu	r2,10(r2)
 1820834:	10bfffcc 	andi	r2,r2,65535
 1820838:	1004d23a 	srli	r2,r2,8
 182083c:	1007883a 	mov	r3,r2
 1820840:	e0bffe17 	ldw	r2,-8(fp)
 1820844:	1080028b 	ldhu	r2,10(r2)
 1820848:	10bfffcc 	andi	r2,r2,65535
 182084c:	1004923a 	slli	r2,r2,8
 1820850:	1884b03a 	or	r2,r3,r2
 1820854:	1007883a 	mov	r3,r2
 1820858:	e0bffe17 	ldw	r2,-8(fp)
 182085c:	10c0028d 	sth	r3,10(r2)
      seg->chksum_swapped = 0;
 1820860:	e0bffe17 	ldw	r2,-8(fp)
 1820864:	10000305 	stb	zero,12(r2)
    }
    acc += (u16_t)~(seg->chksum);
 1820868:	e0bffe17 	ldw	r2,-8(fp)
 182086c:	1080028b 	ldhu	r2,10(r2)
 1820870:	0084303a 	nor	r2,zero,r2
 1820874:	10bfffcc 	andi	r2,r2,65535
 1820878:	e0fffd17 	ldw	r3,-12(fp)
 182087c:	1885883a 	add	r2,r3,r2
 1820880:	e0bffd15 	stw	r2,-12(fp)
    seg->tcphdr->chksum = FOLD_U32T(acc);
 1820884:	e0bffe17 	ldw	r2,-8(fp)
 1820888:	10800417 	ldw	r2,16(r2)
 182088c:	e0fffd17 	ldw	r3,-12(fp)
 1820890:	1806d43a 	srli	r3,r3,16
 1820894:	1809883a 	mov	r4,r3
 1820898:	e0fffd17 	ldw	r3,-12(fp)
 182089c:	20c7883a 	add	r3,r4,r3
 18208a0:	180d883a 	mov	r6,r3
 18208a4:	30ffffcc 	andi	r3,r6,65535
 18208a8:	19403fcc 	andi	r5,r3,255
 18208ac:	10c00403 	ldbu	r3,16(r2)
 18208b0:	1806703a 	and	r3,r3,zero
 18208b4:	1809883a 	mov	r4,r3
 18208b8:	2807883a 	mov	r3,r5
 18208bc:	20c6b03a 	or	r3,r4,r3
 18208c0:	10c00405 	stb	r3,16(r2)
 18208c4:	30ffffcc 	andi	r3,r6,65535
 18208c8:	1806d23a 	srli	r3,r3,8
 18208cc:	197fffcc 	andi	r5,r3,65535
 18208d0:	10c00443 	ldbu	r3,17(r2)
 18208d4:	1806703a 	and	r3,r3,zero
 18208d8:	1809883a 	mov	r4,r3
 18208dc:	2807883a 	mov	r3,r5
 18208e0:	20c6b03a 	or	r3,r4,r3
 18208e4:	10c00445 	stb	r3,17(r2)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 18208e8:	008061f4 	movhi	r2,391
 18208ec:	10a9d404 	addi	r2,r2,-22704
 18208f0:	10804817 	ldw	r2,288(r2)
 18208f4:	10c00044 	addi	r3,r2,1
 18208f8:	008061f4 	movhi	r2,391
 18208fc:	10a9d404 	addi	r2,r2,-22704
 1820900:	10c04815 	stw	r3,288(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 1820904:	e0bffe17 	ldw	r2,-8(fp)
 1820908:	11000117 	ldw	r4,4(r2)
 182090c:	e17fff17 	ldw	r5,-4(fp)
 1820910:	e0bfff17 	ldw	r2,-4(fp)
 1820914:	11800104 	addi	r6,r2,4
 1820918:	e0bfff17 	ldw	r2,-4(fp)
 182091c:	10800283 	ldbu	r2,10(r2)
 1820920:	11c03fcc 	andi	r7,r2,255
 1820924:	e0bfff17 	ldw	r2,-4(fp)
 1820928:	10800243 	ldbu	r2,9(r2)
 182092c:	10803fcc 	andi	r2,r2,255
 1820930:	e0ffff17 	ldw	r3,-4(fp)
 1820934:	18c002c4 	addi	r3,r3,11
 1820938:	d8c00215 	stw	r3,8(sp)
 182093c:	00c00184 	movi	r3,6
 1820940:	d8c00115 	stw	r3,4(sp)
 1820944:	d8800015 	stw	r2,0(sp)
 1820948:	1832f6c0 	call	1832f6c <ip_output_hinted>
 182094c:	00000106 	br	1820954 <tcp_output_segment+0x5ec>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
    if (netif == NULL) {
      return;
 1820950:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
 1820954:	e037883a 	mov	sp,fp
 1820958:	dfc00117 	ldw	ra,4(sp)
 182095c:	df000017 	ldw	fp,0(sp)
 1820960:	dec00204 	addi	sp,sp,8
 1820964:	f800283a 	ret

01820968 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 1820968:	defff404 	addi	sp,sp,-48
 182096c:	dfc00b15 	stw	ra,44(sp)
 1820970:	df000a15 	stw	fp,40(sp)
 1820974:	df000a04 	addi	fp,sp,40
 1820978:	e13ffa15 	stw	r4,-24(fp)
 182097c:	e17ffb15 	stw	r5,-20(fp)
 1820980:	e1bffc15 	stw	r6,-16(fp)
 1820984:	e1fffd15 	stw	r7,-12(fp)
 1820988:	e0c00217 	ldw	r3,8(fp)
 182098c:	e0800317 	ldw	r2,12(fp)
 1820990:	e0fffe0d 	sth	r3,-8(fp)
 1820994:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 1820998:	000d883a 	mov	r6,zero
 182099c:	01400504 	movi	r5,20
 18209a0:	01000044 	movi	r4,1
 18209a4:	181a4e80 	call	181a4e8 <pbuf_alloc>
 18209a8:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
 18209ac:	e0bff817 	ldw	r2,-32(fp)
 18209b0:	1000da26 	beq	r2,zero,1820d1c <tcp_rst+0x3b4>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 18209b4:	e0bff817 	ldw	r2,-32(fp)
 18209b8:	10800117 	ldw	r2,4(r2)
 18209bc:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
 18209c0:	e0bffe0b 	ldhu	r2,-8(fp)
 18209c4:	1004d23a 	srli	r2,r2,8
 18209c8:	1007883a 	mov	r3,r2
 18209cc:	e0bffe0b 	ldhu	r2,-8(fp)
 18209d0:	1004923a 	slli	r2,r2,8
 18209d4:	1884b03a 	or	r2,r3,r2
 18209d8:	100d883a 	mov	r6,r2
 18209dc:	e0bff917 	ldw	r2,-28(fp)
 18209e0:	30ffffcc 	andi	r3,r6,65535
 18209e4:	19403fcc 	andi	r5,r3,255
 18209e8:	10c00003 	ldbu	r3,0(r2)
 18209ec:	1806703a 	and	r3,r3,zero
 18209f0:	1809883a 	mov	r4,r3
 18209f4:	2807883a 	mov	r3,r5
 18209f8:	20c6b03a 	or	r3,r4,r3
 18209fc:	10c00005 	stb	r3,0(r2)
 1820a00:	30ffffcc 	andi	r3,r6,65535
 1820a04:	1806d23a 	srli	r3,r3,8
 1820a08:	197fffcc 	andi	r5,r3,65535
 1820a0c:	10c00043 	ldbu	r3,1(r2)
 1820a10:	1806703a 	and	r3,r3,zero
 1820a14:	1809883a 	mov	r4,r3
 1820a18:	2807883a 	mov	r3,r5
 1820a1c:	20c6b03a 	or	r3,r4,r3
 1820a20:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = htons(remote_port);
 1820a24:	e0bfff0b 	ldhu	r2,-4(fp)
 1820a28:	1004d23a 	srli	r2,r2,8
 1820a2c:	1007883a 	mov	r3,r2
 1820a30:	e0bfff0b 	ldhu	r2,-4(fp)
 1820a34:	1004923a 	slli	r2,r2,8
 1820a38:	1884b03a 	or	r2,r3,r2
 1820a3c:	100d883a 	mov	r6,r2
 1820a40:	e0bff917 	ldw	r2,-28(fp)
 1820a44:	30ffffcc 	andi	r3,r6,65535
 1820a48:	19403fcc 	andi	r5,r3,255
 1820a4c:	10c00083 	ldbu	r3,2(r2)
 1820a50:	1806703a 	and	r3,r3,zero
 1820a54:	1809883a 	mov	r4,r3
 1820a58:	2807883a 	mov	r3,r5
 1820a5c:	20c6b03a 	or	r3,r4,r3
 1820a60:	10c00085 	stb	r3,2(r2)
 1820a64:	30ffffcc 	andi	r3,r6,65535
 1820a68:	1806d23a 	srli	r3,r3,8
 1820a6c:	197fffcc 	andi	r5,r3,65535
 1820a70:	10c000c3 	ldbu	r3,3(r2)
 1820a74:	1806703a 	and	r3,r3,zero
 1820a78:	1809883a 	mov	r4,r3
 1820a7c:	2807883a 	mov	r3,r5
 1820a80:	20c6b03a 	or	r3,r4,r3
 1820a84:	10c000c5 	stb	r3,3(r2)
  tcphdr->seqno = htonl(seqno);
 1820a88:	e0bffa17 	ldw	r2,-24(fp)
 1820a8c:	1006d63a 	srli	r3,r2,24
 1820a90:	e0bffa17 	ldw	r2,-24(fp)
 1820a94:	1004d23a 	srli	r2,r2,8
 1820a98:	10bfc00c 	andi	r2,r2,65280
 1820a9c:	1886b03a 	or	r3,r3,r2
 1820aa0:	e0bffa17 	ldw	r2,-24(fp)
 1820aa4:	10bfc00c 	andi	r2,r2,65280
 1820aa8:	1004923a 	slli	r2,r2,8
 1820aac:	1886b03a 	or	r3,r3,r2
 1820ab0:	e0bffa17 	ldw	r2,-24(fp)
 1820ab4:	1004963a 	slli	r2,r2,24
 1820ab8:	1886b03a 	or	r3,r3,r2
 1820abc:	e0bff917 	ldw	r2,-28(fp)
 1820ac0:	19803fcc 	andi	r6,r3,255
 1820ac4:	11000103 	ldbu	r4,4(r2)
 1820ac8:	2008703a 	and	r4,r4,zero
 1820acc:	200b883a 	mov	r5,r4
 1820ad0:	3009883a 	mov	r4,r6
 1820ad4:	2908b03a 	or	r4,r5,r4
 1820ad8:	11000105 	stb	r4,4(r2)
 1820adc:	1808d23a 	srli	r4,r3,8
 1820ae0:	21803fcc 	andi	r6,r4,255
 1820ae4:	11000143 	ldbu	r4,5(r2)
 1820ae8:	2008703a 	and	r4,r4,zero
 1820aec:	200b883a 	mov	r5,r4
 1820af0:	3009883a 	mov	r4,r6
 1820af4:	2908b03a 	or	r4,r5,r4
 1820af8:	11000145 	stb	r4,5(r2)
 1820afc:	1808d43a 	srli	r4,r3,16
 1820b00:	21803fcc 	andi	r6,r4,255
 1820b04:	11000183 	ldbu	r4,6(r2)
 1820b08:	2008703a 	and	r4,r4,zero
 1820b0c:	200b883a 	mov	r5,r4
 1820b10:	3009883a 	mov	r4,r6
 1820b14:	2908b03a 	or	r4,r5,r4
 1820b18:	11000185 	stb	r4,6(r2)
 1820b1c:	180ad63a 	srli	r5,r3,24
 1820b20:	10c001c3 	ldbu	r3,7(r2)
 1820b24:	1806703a 	and	r3,r3,zero
 1820b28:	1809883a 	mov	r4,r3
 1820b2c:	2807883a 	mov	r3,r5
 1820b30:	20c6b03a 	or	r3,r4,r3
 1820b34:	10c001c5 	stb	r3,7(r2)
  tcphdr->ackno = htonl(ackno);
 1820b38:	e0bffb17 	ldw	r2,-20(fp)
 1820b3c:	1006d63a 	srli	r3,r2,24
 1820b40:	e0bffb17 	ldw	r2,-20(fp)
 1820b44:	1004d23a 	srli	r2,r2,8
 1820b48:	10bfc00c 	andi	r2,r2,65280
 1820b4c:	1886b03a 	or	r3,r3,r2
 1820b50:	e0bffb17 	ldw	r2,-20(fp)
 1820b54:	10bfc00c 	andi	r2,r2,65280
 1820b58:	1004923a 	slli	r2,r2,8
 1820b5c:	1886b03a 	or	r3,r3,r2
 1820b60:	e0bffb17 	ldw	r2,-20(fp)
 1820b64:	1004963a 	slli	r2,r2,24
 1820b68:	1886b03a 	or	r3,r3,r2
 1820b6c:	e0bff917 	ldw	r2,-28(fp)
 1820b70:	19803fcc 	andi	r6,r3,255
 1820b74:	11000203 	ldbu	r4,8(r2)
 1820b78:	2008703a 	and	r4,r4,zero
 1820b7c:	200b883a 	mov	r5,r4
 1820b80:	3009883a 	mov	r4,r6
 1820b84:	2908b03a 	or	r4,r5,r4
 1820b88:	11000205 	stb	r4,8(r2)
 1820b8c:	1808d23a 	srli	r4,r3,8
 1820b90:	21803fcc 	andi	r6,r4,255
 1820b94:	11000243 	ldbu	r4,9(r2)
 1820b98:	2008703a 	and	r4,r4,zero
 1820b9c:	200b883a 	mov	r5,r4
 1820ba0:	3009883a 	mov	r4,r6
 1820ba4:	2908b03a 	or	r4,r5,r4
 1820ba8:	11000245 	stb	r4,9(r2)
 1820bac:	1808d43a 	srli	r4,r3,16
 1820bb0:	21803fcc 	andi	r6,r4,255
 1820bb4:	11000283 	ldbu	r4,10(r2)
 1820bb8:	2008703a 	and	r4,r4,zero
 1820bbc:	200b883a 	mov	r5,r4
 1820bc0:	3009883a 	mov	r4,r6
 1820bc4:	2908b03a 	or	r4,r5,r4
 1820bc8:	11000285 	stb	r4,10(r2)
 1820bcc:	180ad63a 	srli	r5,r3,24
 1820bd0:	10c002c3 	ldbu	r3,11(r2)
 1820bd4:	1806703a 	and	r3,r3,zero
 1820bd8:	1809883a 	mov	r4,r3
 1820bdc:	2807883a 	mov	r3,r5
 1820be0:	20c6b03a 	or	r3,r4,r3
 1820be4:	10c002c5 	stb	r3,11(r2)
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 1820be8:	e0bff917 	ldw	r2,-28(fp)
 1820bec:	10c00303 	ldbu	r3,12(r2)
 1820bf0:	1806703a 	and	r3,r3,zero
 1820bf4:	18c01414 	ori	r3,r3,80
 1820bf8:	10c00305 	stb	r3,12(r2)
 1820bfc:	10c00343 	ldbu	r3,13(r2)
 1820c00:	1806703a 	and	r3,r3,zero
 1820c04:	18c00514 	ori	r3,r3,20
 1820c08:	10c00345 	stb	r3,13(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
 1820c0c:	e0bff917 	ldw	r2,-28(fp)
 1820c10:	10c00383 	ldbu	r3,14(r2)
 1820c14:	1806703a 	and	r3,r3,zero
 1820c18:	18c00814 	ori	r3,r3,32
 1820c1c:	10c00385 	stb	r3,14(r2)
 1820c20:	10c003c3 	ldbu	r3,15(r2)
 1820c24:	1806703a 	and	r3,r3,zero
 1820c28:	10c003c5 	stb	r3,15(r2)
  tcphdr->chksum = 0;
 1820c2c:	e0bff917 	ldw	r2,-28(fp)
 1820c30:	10c00403 	ldbu	r3,16(r2)
 1820c34:	1806703a 	and	r3,r3,zero
 1820c38:	10c00405 	stb	r3,16(r2)
 1820c3c:	10c00443 	ldbu	r3,17(r2)
 1820c40:	1806703a 	and	r3,r3,zero
 1820c44:	10c00445 	stb	r3,17(r2)
  tcphdr->urgp = 0;
 1820c48:	e0bff917 	ldw	r2,-28(fp)
 1820c4c:	10c00483 	ldbu	r3,18(r2)
 1820c50:	1806703a 	and	r3,r3,zero
 1820c54:	10c00485 	stb	r3,18(r2)
 1820c58:	10c004c3 	ldbu	r3,19(r2)
 1820c5c:	1806703a 	and	r3,r3,zero
 1820c60:	10c004c5 	stb	r3,19(r2)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
 1820c64:	e0bff817 	ldw	r2,-32(fp)
 1820c68:	1080020b 	ldhu	r2,8(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 1820c6c:	10bfffcc 	andi	r2,r2,65535
 1820c70:	d8800015 	stw	r2,0(sp)
 1820c74:	01c00184 	movi	r7,6
 1820c78:	e1bffd17 	ldw	r6,-12(fp)
 1820c7c:	e17ffc17 	ldw	r5,-16(fp)
 1820c80:	e13ff817 	ldw	r4,-32(fp)
 1820c84:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 1820c88:	100d883a 	mov	r6,r2
 1820c8c:	e0bff917 	ldw	r2,-28(fp)
 1820c90:	30ffffcc 	andi	r3,r6,65535
 1820c94:	19403fcc 	andi	r5,r3,255
 1820c98:	10c00403 	ldbu	r3,16(r2)
 1820c9c:	1806703a 	and	r3,r3,zero
 1820ca0:	1809883a 	mov	r4,r3
 1820ca4:	2807883a 	mov	r3,r5
 1820ca8:	20c6b03a 	or	r3,r4,r3
 1820cac:	10c00405 	stb	r3,16(r2)
 1820cb0:	30ffffcc 	andi	r3,r6,65535
 1820cb4:	1806d23a 	srli	r3,r3,8
 1820cb8:	197fffcc 	andi	r5,r3,65535
 1820cbc:	10c00443 	ldbu	r3,17(r2)
 1820cc0:	1806703a 	and	r3,r3,zero
 1820cc4:	1809883a 	mov	r4,r3
 1820cc8:	2807883a 	mov	r3,r5
 1820ccc:	20c6b03a 	or	r3,r4,r3
 1820cd0:	10c00445 	stb	r3,17(r2)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 1820cd4:	008061f4 	movhi	r2,391
 1820cd8:	10a9d404 	addi	r2,r2,-22704
 1820cdc:	10804817 	ldw	r2,288(r2)
 1820ce0:	10c00044 	addi	r3,r2,1
 1820ce4:	008061f4 	movhi	r2,391
 1820ce8:	10a9d404 	addi	r2,r2,-22704
 1820cec:	10c04815 	stw	r3,288(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 1820cf0:	00800184 	movi	r2,6
 1820cf4:	d8800115 	stw	r2,4(sp)
 1820cf8:	d8000015 	stw	zero,0(sp)
 1820cfc:	01c01004 	movi	r7,64
 1820d00:	e1bffd17 	ldw	r6,-12(fp)
 1820d04:	e17ffc17 	ldw	r5,-16(fp)
 1820d08:	e13ff817 	ldw	r4,-32(fp)
 1820d0c:	1832eb80 	call	1832eb8 <ip_output>
  pbuf_free(p);
 1820d10:	e13ff817 	ldw	r4,-32(fp)
 1820d14:	181aca40 	call	181aca4 <pbuf_free>
 1820d18:	00000106 	br	1820d20 <tcp_rst+0x3b8>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
 1820d1c:	0001883a 	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 1820d20:	e037883a 	mov	sp,fp
 1820d24:	dfc00117 	ldw	ra,4(sp)
 1820d28:	df000017 	ldw	fp,0(sp)
 1820d2c:	dec00204 	addi	sp,sp,8
 1820d30:	f800283a 	ret

01820d34 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 1820d34:	defffc04 	addi	sp,sp,-16
 1820d38:	dfc00315 	stw	ra,12(sp)
 1820d3c:	df000215 	stw	fp,8(sp)
 1820d40:	df000204 	addi	fp,sp,8
 1820d44:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 1820d48:	e0bfff17 	ldw	r2,-4(fp)
 1820d4c:	10801d17 	ldw	r2,116(r2)
 1820d50:	10001f26 	beq	r2,zero,1820dd0 <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 1820d54:	e0bfff17 	ldw	r2,-4(fp)
 1820d58:	10801d17 	ldw	r2,116(r2)
 1820d5c:	e0bffe15 	stw	r2,-8(fp)
 1820d60:	00000306 	br	1820d70 <tcp_rexmit_rto+0x3c>
 1820d64:	e0bffe17 	ldw	r2,-8(fp)
 1820d68:	10800017 	ldw	r2,0(r2)
 1820d6c:	e0bffe15 	stw	r2,-8(fp)
 1820d70:	e0bffe17 	ldw	r2,-8(fp)
 1820d74:	10800017 	ldw	r2,0(r2)
 1820d78:	103ffa1e 	bne	r2,zero,1820d64 <__ram_exceptions_end+0xff810920>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 1820d7c:	e0bfff17 	ldw	r2,-4(fp)
 1820d80:	10c01c17 	ldw	r3,112(r2)
 1820d84:	e0bffe17 	ldw	r2,-8(fp)
 1820d88:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 1820d8c:	e0bfff17 	ldw	r2,-4(fp)
 1820d90:	10c01d17 	ldw	r3,116(r2)
 1820d94:	e0bfff17 	ldw	r2,-4(fp)
 1820d98:	10c01c15 	stw	r3,112(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 1820d9c:	e0bfff17 	ldw	r2,-4(fp)
 1820da0:	10001d15 	stw	zero,116(r2)
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 1820da4:	e0bfff17 	ldw	r2,-4(fp)
 1820da8:	10801283 	ldbu	r2,74(r2)
 1820dac:	10800044 	addi	r2,r2,1
 1820db0:	1007883a 	mov	r3,r2
 1820db4:	e0bfff17 	ldw	r2,-4(fp)
 1820db8:	10c01285 	stb	r3,74(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 1820dbc:	e0bfff17 	ldw	r2,-4(fp)
 1820dc0:	10000f15 	stw	zero,60(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
 1820dc4:	e13fff17 	ldw	r4,-4(fp)
 1820dc8:	181f8bc0 	call	181f8bc <tcp_output>
 1820dcc:	00000106 	br	1820dd4 <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
 1820dd0:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 1820dd4:	e037883a 	mov	sp,fp
 1820dd8:	dfc00117 	ldw	ra,4(sp)
 1820ddc:	df000017 	ldw	fp,0(sp)
 1820de0:	dec00204 	addi	sp,sp,8
 1820de4:	f800283a 	ret

01820de8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 1820de8:	defffc04 	addi	sp,sp,-16
 1820dec:	df000315 	stw	fp,12(sp)
 1820df0:	df000304 	addi	fp,sp,12
 1820df4:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 1820df8:	e0bfff17 	ldw	r2,-4(fp)
 1820dfc:	10801d17 	ldw	r2,116(r2)
 1820e00:	10009e26 	beq	r2,zero,182107c <tcp_rexmit+0x294>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
 1820e04:	e0bfff17 	ldw	r2,-4(fp)
 1820e08:	10801d17 	ldw	r2,116(r2)
 1820e0c:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
 1820e10:	e0bffe17 	ldw	r2,-8(fp)
 1820e14:	10c00017 	ldw	r3,0(r2)
 1820e18:	e0bfff17 	ldw	r2,-4(fp)
 1820e1c:	10c01d15 	stw	r3,116(r2)

  cur_seg = &(pcb->unsent);
 1820e20:	e0bfff17 	ldw	r2,-4(fp)
 1820e24:	10801c04 	addi	r2,r2,112
 1820e28:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
 1820e2c:	00000306 	br	1820e3c <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 1820e30:	e0bffd17 	ldw	r2,-12(fp)
 1820e34:	10800017 	ldw	r2,0(r2)
 1820e38:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 1820e3c:	e0bffd17 	ldw	r2,-12(fp)
 1820e40:	10800017 	ldw	r2,0(r2)
 1820e44:	10007826 	beq	r2,zero,1821028 <tcp_rexmit+0x240>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 1820e48:	e0bffd17 	ldw	r2,-12(fp)
 1820e4c:	10800017 	ldw	r2,0(r2)
 1820e50:	10800417 	ldw	r2,16(r2)
 1820e54:	10c00103 	ldbu	r3,4(r2)
 1820e58:	11000143 	ldbu	r4,5(r2)
 1820e5c:	2008923a 	slli	r4,r4,8
 1820e60:	20c6b03a 	or	r3,r4,r3
 1820e64:	11000183 	ldbu	r4,6(r2)
 1820e68:	2008943a 	slli	r4,r4,16
 1820e6c:	20c6b03a 	or	r3,r4,r3
 1820e70:	108001c3 	ldbu	r2,7(r2)
 1820e74:	1004963a 	slli	r2,r2,24
 1820e78:	10c4b03a 	or	r2,r2,r3
 1820e7c:	1006d63a 	srli	r3,r2,24
 1820e80:	e0bffd17 	ldw	r2,-12(fp)
 1820e84:	10800017 	ldw	r2,0(r2)
 1820e88:	10800417 	ldw	r2,16(r2)
 1820e8c:	11000103 	ldbu	r4,4(r2)
 1820e90:	11400143 	ldbu	r5,5(r2)
 1820e94:	280a923a 	slli	r5,r5,8
 1820e98:	2908b03a 	or	r4,r5,r4
 1820e9c:	11400183 	ldbu	r5,6(r2)
 1820ea0:	280a943a 	slli	r5,r5,16
 1820ea4:	2908b03a 	or	r4,r5,r4
 1820ea8:	108001c3 	ldbu	r2,7(r2)
 1820eac:	1004963a 	slli	r2,r2,24
 1820eb0:	1104b03a 	or	r2,r2,r4
 1820eb4:	1004d23a 	srli	r2,r2,8
 1820eb8:	10bfc00c 	andi	r2,r2,65280
 1820ebc:	1886b03a 	or	r3,r3,r2
 1820ec0:	e0bffd17 	ldw	r2,-12(fp)
 1820ec4:	10800017 	ldw	r2,0(r2)
 1820ec8:	10800417 	ldw	r2,16(r2)
 1820ecc:	11000103 	ldbu	r4,4(r2)
 1820ed0:	11400143 	ldbu	r5,5(r2)
 1820ed4:	280a923a 	slli	r5,r5,8
 1820ed8:	2908b03a 	or	r4,r5,r4
 1820edc:	11400183 	ldbu	r5,6(r2)
 1820ee0:	280a943a 	slli	r5,r5,16
 1820ee4:	2908b03a 	or	r4,r5,r4
 1820ee8:	108001c3 	ldbu	r2,7(r2)
 1820eec:	1004963a 	slli	r2,r2,24
 1820ef0:	1104b03a 	or	r2,r2,r4
 1820ef4:	10bfc00c 	andi	r2,r2,65280
 1820ef8:	1004923a 	slli	r2,r2,8
 1820efc:	1886b03a 	or	r3,r3,r2
 1820f00:	e0bffd17 	ldw	r2,-12(fp)
 1820f04:	10800017 	ldw	r2,0(r2)
 1820f08:	10800417 	ldw	r2,16(r2)
 1820f0c:	11000103 	ldbu	r4,4(r2)
 1820f10:	11400143 	ldbu	r5,5(r2)
 1820f14:	280a923a 	slli	r5,r5,8
 1820f18:	2908b03a 	or	r4,r5,r4
 1820f1c:	11400183 	ldbu	r5,6(r2)
 1820f20:	280a943a 	slli	r5,r5,16
 1820f24:	2908b03a 	or	r4,r5,r4
 1820f28:	108001c3 	ldbu	r2,7(r2)
 1820f2c:	1004963a 	slli	r2,r2,24
 1820f30:	1104b03a 	or	r2,r2,r4
 1820f34:	1004963a 	slli	r2,r2,24
 1820f38:	1886b03a 	or	r3,r3,r2
 1820f3c:	e0bffe17 	ldw	r2,-8(fp)
 1820f40:	10800417 	ldw	r2,16(r2)
 1820f44:	11000103 	ldbu	r4,4(r2)
 1820f48:	11400143 	ldbu	r5,5(r2)
 1820f4c:	280a923a 	slli	r5,r5,8
 1820f50:	2908b03a 	or	r4,r5,r4
 1820f54:	11400183 	ldbu	r5,6(r2)
 1820f58:	280a943a 	slli	r5,r5,16
 1820f5c:	2908b03a 	or	r4,r5,r4
 1820f60:	108001c3 	ldbu	r2,7(r2)
 1820f64:	1004963a 	slli	r2,r2,24
 1820f68:	1104b03a 	or	r2,r2,r4
 1820f6c:	1008d63a 	srli	r4,r2,24
 1820f70:	e0bffe17 	ldw	r2,-8(fp)
 1820f74:	10800417 	ldw	r2,16(r2)
 1820f78:	11400103 	ldbu	r5,4(r2)
 1820f7c:	11800143 	ldbu	r6,5(r2)
 1820f80:	300c923a 	slli	r6,r6,8
 1820f84:	314ab03a 	or	r5,r6,r5
 1820f88:	11800183 	ldbu	r6,6(r2)
 1820f8c:	300c943a 	slli	r6,r6,16
 1820f90:	314ab03a 	or	r5,r6,r5
 1820f94:	108001c3 	ldbu	r2,7(r2)
 1820f98:	1004963a 	slli	r2,r2,24
 1820f9c:	1144b03a 	or	r2,r2,r5
 1820fa0:	1004d23a 	srli	r2,r2,8
 1820fa4:	10bfc00c 	andi	r2,r2,65280
 1820fa8:	2088b03a 	or	r4,r4,r2
 1820fac:	e0bffe17 	ldw	r2,-8(fp)
 1820fb0:	10800417 	ldw	r2,16(r2)
 1820fb4:	11400103 	ldbu	r5,4(r2)
 1820fb8:	11800143 	ldbu	r6,5(r2)
 1820fbc:	300c923a 	slli	r6,r6,8
 1820fc0:	314ab03a 	or	r5,r6,r5
 1820fc4:	11800183 	ldbu	r6,6(r2)
 1820fc8:	300c943a 	slli	r6,r6,16
 1820fcc:	314ab03a 	or	r5,r6,r5
 1820fd0:	108001c3 	ldbu	r2,7(r2)
 1820fd4:	1004963a 	slli	r2,r2,24
 1820fd8:	1144b03a 	or	r2,r2,r5
 1820fdc:	10bfc00c 	andi	r2,r2,65280
 1820fe0:	1004923a 	slli	r2,r2,8
 1820fe4:	2088b03a 	or	r4,r4,r2
 1820fe8:	e0bffe17 	ldw	r2,-8(fp)
 1820fec:	10800417 	ldw	r2,16(r2)
 1820ff0:	11400103 	ldbu	r5,4(r2)
 1820ff4:	11800143 	ldbu	r6,5(r2)
 1820ff8:	300c923a 	slli	r6,r6,8
 1820ffc:	314ab03a 	or	r5,r6,r5
 1821000:	11800183 	ldbu	r6,6(r2)
 1821004:	300c943a 	slli	r6,r6,16
 1821008:	314ab03a 	or	r5,r6,r5
 182100c:	108001c3 	ldbu	r2,7(r2)
 1821010:	1004963a 	slli	r2,r2,24
 1821014:	1144b03a 	or	r2,r2,r5
 1821018:	1004963a 	slli	r2,r2,24
 182101c:	2084b03a 	or	r2,r4,r2
 1821020:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 1821024:	103f8216 	blt	r2,zero,1820e30 <__ram_exceptions_end+0xff8109ec>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 1821028:	e0bffd17 	ldw	r2,-12(fp)
 182102c:	10c00017 	ldw	r3,0(r2)
 1821030:	e0bffe17 	ldw	r2,-8(fp)
 1821034:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
 1821038:	e0bffd17 	ldw	r2,-12(fp)
 182103c:	e0fffe17 	ldw	r3,-8(fp)
 1821040:	10c00015 	stw	r3,0(r2)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 1821044:	e0bffe17 	ldw	r2,-8(fp)
 1821048:	10800017 	ldw	r2,0(r2)
 182104c:	1000021e 	bne	r2,zero,1821058 <tcp_rexmit+0x270>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 1821050:	e0bfff17 	ldw	r2,-4(fp)
 1821054:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 1821058:	e0bfff17 	ldw	r2,-4(fp)
 182105c:	10801283 	ldbu	r2,74(r2)
 1821060:	10800044 	addi	r2,r2,1
 1821064:	1007883a 	mov	r3,r2
 1821068:	e0bfff17 	ldw	r2,-4(fp)
 182106c:	10c01285 	stb	r3,74(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 1821070:	e0bfff17 	ldw	r2,-4(fp)
 1821074:	10000f15 	stw	zero,60(r2)
 1821078:	00000106 	br	1821080 <tcp_rexmit+0x298>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
 182107c:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 1821080:	e037883a 	mov	sp,fp
 1821084:	df000017 	ldw	fp,0(sp)
 1821088:	dec00104 	addi	sp,sp,4
 182108c:	f800283a 	ret

01821090 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 1821090:	defffd04 	addi	sp,sp,-12
 1821094:	dfc00215 	stw	ra,8(sp)
 1821098:	df000115 	stw	fp,4(sp)
 182109c:	df000104 	addi	fp,sp,4
 18210a0:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 18210a4:	e0bfff17 	ldw	r2,-4(fp)
 18210a8:	10801d17 	ldw	r2,116(r2)
 18210ac:	10003c26 	beq	r2,zero,18211a0 <tcp_rexmit_fast+0x110>
 18210b0:	e0bfff17 	ldw	r2,-4(fp)
 18210b4:	10800883 	ldbu	r2,34(r2)
 18210b8:	10803fcc 	andi	r2,r2,255
 18210bc:	1080010c 	andi	r2,r2,4
 18210c0:	1000371e 	bne	r2,zero,18211a0 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 18210c4:	e13fff17 	ldw	r4,-4(fp)
 18210c8:	1820de80 	call	1820de8 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 18210cc:	e0bfff17 	ldw	r2,-4(fp)
 18210d0:	1100140b 	ldhu	r4,80(r2)
 18210d4:	e0bfff17 	ldw	r2,-4(fp)
 18210d8:	10c0190b 	ldhu	r3,100(r2)
 18210dc:	20bfffcc 	andi	r2,r4,65535
 18210e0:	18ffffcc 	andi	r3,r3,65535
 18210e4:	1880082e 	bgeu	r3,r2,1821108 <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
 18210e8:	e0bfff17 	ldw	r2,-4(fp)
 18210ec:	1080190b 	ldhu	r2,100(r2)
 18210f0:	10bfffcc 	andi	r2,r2,65535
 18210f4:	1004d07a 	srli	r2,r2,1
 18210f8:	1007883a 	mov	r3,r2
 18210fc:	e0bfff17 	ldw	r2,-4(fp)
 1821100:	10c0148d 	sth	r3,82(r2)
 1821104:	00000706 	br	1821124 <tcp_rexmit_fast+0x94>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 1821108:	e0bfff17 	ldw	r2,-4(fp)
 182110c:	1080140b 	ldhu	r2,80(r2)
 1821110:	10bfffcc 	andi	r2,r2,65535
 1821114:	1004d07a 	srli	r2,r2,1
 1821118:	1007883a 	mov	r3,r2
 182111c:	e0bfff17 	ldw	r2,-4(fp)
 1821120:	10c0148d 	sth	r3,82(r2)
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 1821124:	e0bfff17 	ldw	r2,-4(fp)
 1821128:	1080148b 	ldhu	r2,82(r2)
 182112c:	10ffffcc 	andi	r3,r2,65535
 1821130:	e0bfff17 	ldw	r2,-4(fp)
 1821134:	10800e8b 	ldhu	r2,58(r2)
 1821138:	10bfffcc 	andi	r2,r2,65535
 182113c:	1085883a 	add	r2,r2,r2
 1821140:	1880060e 	bge	r3,r2,182115c <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 1821144:	e0bfff17 	ldw	r2,-4(fp)
 1821148:	10800e8b 	ldhu	r2,58(r2)
 182114c:	1085883a 	add	r2,r2,r2
 1821150:	1007883a 	mov	r3,r2
 1821154:	e0bfff17 	ldw	r2,-4(fp)
 1821158:	10c0148d 	sth	r3,82(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 182115c:	e0bfff17 	ldw	r2,-4(fp)
 1821160:	1100148b 	ldhu	r4,82(r2)
 1821164:	e0bfff17 	ldw	r2,-4(fp)
 1821168:	10c00e8b 	ldhu	r3,58(r2)
 182116c:	1805883a 	mov	r2,r3
 1821170:	1085883a 	add	r2,r2,r2
 1821174:	10c5883a 	add	r2,r2,r3
 1821178:	2085883a 	add	r2,r4,r2
 182117c:	1007883a 	mov	r3,r2
 1821180:	e0bfff17 	ldw	r2,-4(fp)
 1821184:	10c0140d 	sth	r3,80(r2)
    pcb->flags |= TF_INFR;
 1821188:	e0bfff17 	ldw	r2,-4(fp)
 182118c:	10800883 	ldbu	r2,34(r2)
 1821190:	10800114 	ori	r2,r2,4
 1821194:	1007883a 	mov	r3,r2
 1821198:	e0bfff17 	ldw	r2,-4(fp)
 182119c:	10c00885 	stb	r3,34(r2)
  } 
}
 18211a0:	0001883a 	nop
 18211a4:	e037883a 	mov	sp,fp
 18211a8:	dfc00117 	ldw	ra,4(sp)
 18211ac:	df000017 	ldw	fp,0(sp)
 18211b0:	dec00204 	addi	sp,sp,8
 18211b4:	f800283a 	ret

018211b8 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 18211b8:	defff804 	addi	sp,sp,-32
 18211bc:	dfc00715 	stw	ra,28(sp)
 18211c0:	df000615 	stw	fp,24(sp)
 18211c4:	df000604 	addi	fp,sp,24
 18211c8:	e13fff15 	stw	r4,-4(fp)
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 18211cc:	e0bfff17 	ldw	r2,-4(fp)
 18211d0:	10801517 	ldw	r2,84(r2)
 18211d4:	10bfffc4 	addi	r2,r2,-1
 18211d8:	1006d63a 	srli	r3,r2,24
 18211dc:	e0bfff17 	ldw	r2,-4(fp)
 18211e0:	10801517 	ldw	r2,84(r2)
 18211e4:	10bfffc4 	addi	r2,r2,-1
 18211e8:	1004d23a 	srli	r2,r2,8
 18211ec:	10bfc00c 	andi	r2,r2,65280
 18211f0:	1886b03a 	or	r3,r3,r2
 18211f4:	e0bfff17 	ldw	r2,-4(fp)
 18211f8:	10801517 	ldw	r2,84(r2)
 18211fc:	10bfffc4 	addi	r2,r2,-1
 1821200:	10bfc00c 	andi	r2,r2,65280
 1821204:	1004923a 	slli	r2,r2,8
 1821208:	1886b03a 	or	r3,r3,r2
 182120c:	e0bfff17 	ldw	r2,-4(fp)
 1821210:	10801517 	ldw	r2,84(r2)
 1821214:	10bfffc4 	addi	r2,r2,-1
 1821218:	1004963a 	slli	r2,r2,24
 182121c:	1884b03a 	or	r2,r3,r2
 1821220:	100f883a 	mov	r7,r2
 1821224:	000d883a 	mov	r6,zero
 1821228:	000b883a 	mov	r5,zero
 182122c:	e13fff17 	ldw	r4,-4(fp)
 1821230:	181df3c0 	call	181df3c <tcp_output_alloc_header>
 1821234:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
 1821238:	e0bffd17 	ldw	r2,-12(fp)
 182123c:	10003d26 	beq	r2,zero,1821334 <tcp_keepalive+0x17c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 1821240:	e0bffd17 	ldw	r2,-12(fp)
 1821244:	10800117 	ldw	r2,4(r2)
 1821248:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 182124c:	e0ffff17 	ldw	r3,-4(fp)
 1821250:	e0bfff17 	ldw	r2,-4(fp)
 1821254:	11000104 	addi	r4,r2,4
                                      IP_PROTO_TCP, p->tot_len);
 1821258:	e0bffd17 	ldw	r2,-12(fp)
 182125c:	1080020b 	ldhu	r2,8(r2)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 1821260:	10bfffcc 	andi	r2,r2,65535
 1821264:	d8800015 	stw	r2,0(sp)
 1821268:	01c00184 	movi	r7,6
 182126c:	200d883a 	mov	r6,r4
 1821270:	180b883a 	mov	r5,r3
 1821274:	e13ffd17 	ldw	r4,-12(fp)
 1821278:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 182127c:	100d883a 	mov	r6,r2
 1821280:	e0bffe17 	ldw	r2,-8(fp)
 1821284:	30ffffcc 	andi	r3,r6,65535
 1821288:	19403fcc 	andi	r5,r3,255
 182128c:	10c00403 	ldbu	r3,16(r2)
 1821290:	1806703a 	and	r3,r3,zero
 1821294:	1809883a 	mov	r4,r3
 1821298:	2807883a 	mov	r3,r5
 182129c:	20c6b03a 	or	r3,r4,r3
 18212a0:	10c00405 	stb	r3,16(r2)
 18212a4:	30ffffcc 	andi	r3,r6,65535
 18212a8:	1806d23a 	srli	r3,r3,8
 18212ac:	197fffcc 	andi	r5,r3,65535
 18212b0:	10c00443 	ldbu	r3,17(r2)
 18212b4:	1806703a 	and	r3,r3,zero
 18212b8:	1809883a 	mov	r4,r3
 18212bc:	2807883a 	mov	r3,r5
 18212c0:	20c6b03a 	or	r3,r4,r3
 18212c4:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 18212c8:	008061f4 	movhi	r2,391
 18212cc:	10a9d404 	addi	r2,r2,-22704
 18212d0:	10804817 	ldw	r2,288(r2)
 18212d4:	10c00044 	addi	r3,r2,1
 18212d8:	008061f4 	movhi	r2,391
 18212dc:	10a9d404 	addi	r2,r2,-22704
 18212e0:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
 18212e4:	e0ffff17 	ldw	r3,-4(fp)
 18212e8:	e0bfff17 	ldw	r2,-4(fp)
 18212ec:	11000104 	addi	r4,r2,4
 18212f0:	e0bfff17 	ldw	r2,-4(fp)
 18212f4:	10800283 	ldbu	r2,10(r2)
 18212f8:	11403fcc 	andi	r5,r2,255
 18212fc:	e0bfff17 	ldw	r2,-4(fp)
 1821300:	108002c4 	addi	r2,r2,11
 1821304:	d8800215 	stw	r2,8(sp)
 1821308:	00800184 	movi	r2,6
 182130c:	d8800115 	stw	r2,4(sp)
 1821310:	d8000015 	stw	zero,0(sp)
 1821314:	280f883a 	mov	r7,r5
 1821318:	200d883a 	mov	r6,r4
 182131c:	180b883a 	mov	r5,r3
 1821320:	e13ffd17 	ldw	r4,-12(fp)
 1821324:	1832f6c0 	call	1832f6c <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 1821328:	e13ffd17 	ldw	r4,-12(fp)
 182132c:	181aca40 	call	181aca4 <pbuf_free>
 1821330:	00000106 	br	1821338 <tcp_keepalive+0x180>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
 1821334:	0001883a 	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 1821338:	e037883a 	mov	sp,fp
 182133c:	dfc00117 	ldw	ra,4(sp)
 1821340:	df000017 	ldw	fp,0(sp)
 1821344:	dec00204 	addi	sp,sp,8
 1821348:	f800283a 	ret

0182134c <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 182134c:	defff504 	addi	sp,sp,-44
 1821350:	dfc00a15 	stw	ra,40(sp)
 1821354:	df000915 	stw	fp,36(sp)
 1821358:	df000904 	addi	fp,sp,36
 182135c:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 1821360:	e0bfff17 	ldw	r2,-4(fp)
 1821364:	10801d17 	ldw	r2,116(r2)
 1821368:	e0bffa15 	stw	r2,-24(fp)

  if(seg == NULL) {
 182136c:	e0bffa17 	ldw	r2,-24(fp)
 1821370:	1000031e 	bne	r2,zero,1821380 <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
 1821374:	e0bfff17 	ldw	r2,-4(fp)
 1821378:	10801c17 	ldw	r2,112(r2)
 182137c:	e0bffa15 	stw	r2,-24(fp)
  }
  if(seg == NULL) {
 1821380:	e0bffa17 	ldw	r2,-24(fp)
 1821384:	1000a326 	beq	r2,zero,1821614 <tcp_zero_window_probe+0x2c8>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 1821388:	e0bffa17 	ldw	r2,-24(fp)
 182138c:	10800417 	ldw	r2,16(r2)
 1821390:	10c00303 	ldbu	r3,12(r2)
 1821394:	10800343 	ldbu	r2,13(r2)
 1821398:	1004923a 	slli	r2,r2,8
 182139c:	10c4b03a 	or	r2,r2,r3
 18213a0:	10bfffcc 	andi	r2,r2,65535
 18213a4:	1004d23a 	srli	r2,r2,8
 18213a8:	10ffffcc 	andi	r3,r2,65535
 18213ac:	e0bffa17 	ldw	r2,-24(fp)
 18213b0:	10800417 	ldw	r2,16(r2)
 18213b4:	11000303 	ldbu	r4,12(r2)
 18213b8:	10800343 	ldbu	r2,13(r2)
 18213bc:	1004923a 	slli	r2,r2,8
 18213c0:	1104b03a 	or	r2,r2,r4
 18213c4:	10bfffcc 	andi	r2,r2,65535
 18213c8:	1004923a 	slli	r2,r2,8
 18213cc:	10bfffcc 	andi	r2,r2,65535
 18213d0:	1884b03a 	or	r2,r3,r2
 18213d4:	1080004c 	andi	r2,r2,1
 18213d8:	10000626 	beq	r2,zero,18213f4 <tcp_zero_window_probe+0xa8>
 18213dc:	e0bffa17 	ldw	r2,-24(fp)
 18213e0:	1080020b 	ldhu	r2,8(r2)
 18213e4:	10bfffcc 	andi	r2,r2,65535
 18213e8:	1000021e 	bne	r2,zero,18213f4 <tcp_zero_window_probe+0xa8>
 18213ec:	00800044 	movi	r2,1
 18213f0:	00000106 	br	18213f8 <tcp_zero_window_probe+0xac>
 18213f4:	0005883a 	mov	r2,zero
 18213f8:	e0bffb05 	stb	r2,-20(fp)
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 18213fc:	e0bffb03 	ldbu	r2,-20(fp)
 1821400:	1005003a 	cmpeq	r2,r2,zero
 1821404:	10803fcc 	andi	r2,r2,255
 1821408:	e0bffb8d 	sth	r2,-18(fp)

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 182140c:	e17ffb8b 	ldhu	r5,-18(fp)
 1821410:	e0bffa17 	ldw	r2,-24(fp)
 1821414:	10800417 	ldw	r2,16(r2)
 1821418:	10c00103 	ldbu	r3,4(r2)
 182141c:	11000143 	ldbu	r4,5(r2)
 1821420:	2008923a 	slli	r4,r4,8
 1821424:	20c6b03a 	or	r3,r4,r3
 1821428:	11000183 	ldbu	r4,6(r2)
 182142c:	2008943a 	slli	r4,r4,16
 1821430:	20c6b03a 	or	r3,r4,r3
 1821434:	108001c3 	ldbu	r2,7(r2)
 1821438:	1004963a 	slli	r2,r2,24
 182143c:	10c4b03a 	or	r2,r2,r3
 1821440:	100f883a 	mov	r7,r2
 1821444:	280d883a 	mov	r6,r5
 1821448:	000b883a 	mov	r5,zero
 182144c:	e13fff17 	ldw	r4,-4(fp)
 1821450:	181df3c0 	call	181df3c <tcp_output_alloc_header>
 1821454:	e0bffc15 	stw	r2,-16(fp)
  if(p == NULL) {
 1821458:	e0bffc17 	ldw	r2,-16(fp)
 182145c:	10006f26 	beq	r2,zero,182161c <tcp_zero_window_probe+0x2d0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 1821460:	e0bffc17 	ldw	r2,-16(fp)
 1821464:	10800117 	ldw	r2,4(r2)
 1821468:	e0bffd15 	stw	r2,-12(fp)

  if (is_fin) {
 182146c:	e0bffb03 	ldbu	r2,-20(fp)
 1821470:	10001d26 	beq	r2,zero,18214e8 <tcp_zero_window_probe+0x19c>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 1821474:	e0bffd17 	ldw	r2,-12(fp)
 1821478:	10c00303 	ldbu	r3,12(r2)
 182147c:	10800343 	ldbu	r2,13(r2)
 1821480:	1004923a 	slli	r2,r2,8
 1821484:	10c4b03a 	or	r2,r2,r3
 1821488:	1007883a 	mov	r3,r2
 182148c:	00b03fc4 	movi	r2,-16129
 1821490:	1884703a 	and	r2,r3,r2
 1821494:	10844014 	ori	r2,r2,4352
 1821498:	100d883a 	mov	r6,r2
 182149c:	e0bffd17 	ldw	r2,-12(fp)
 18214a0:	30ffffcc 	andi	r3,r6,65535
 18214a4:	19403fcc 	andi	r5,r3,255
 18214a8:	10c00303 	ldbu	r3,12(r2)
 18214ac:	1806703a 	and	r3,r3,zero
 18214b0:	1809883a 	mov	r4,r3
 18214b4:	2807883a 	mov	r3,r5
 18214b8:	20c6b03a 	or	r3,r4,r3
 18214bc:	10c00305 	stb	r3,12(r2)
 18214c0:	30ffffcc 	andi	r3,r6,65535
 18214c4:	1806d23a 	srli	r3,r3,8
 18214c8:	197fffcc 	andi	r5,r3,65535
 18214cc:	10c00343 	ldbu	r3,13(r2)
 18214d0:	1806703a 	and	r3,r3,zero
 18214d4:	1809883a 	mov	r4,r3
 18214d8:	2807883a 	mov	r3,r5
 18214dc:	20c6b03a 	or	r3,r4,r3
 18214e0:	10c00345 	stb	r3,13(r2)
 18214e4:	00001106 	br	182152c <tcp_zero_window_probe+0x1e0>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 18214e8:	e0bffc17 	ldw	r2,-16(fp)
 18214ec:	10800117 	ldw	r2,4(r2)
 18214f0:	10800504 	addi	r2,r2,20
 18214f4:	e0bffe15 	stw	r2,-8(fp)
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 18214f8:	e0bffa17 	ldw	r2,-24(fp)
 18214fc:	11000117 	ldw	r4,4(r2)
 1821500:	e0bffa17 	ldw	r2,-24(fp)
 1821504:	10800117 	ldw	r2,4(r2)
 1821508:	10c0020b 	ldhu	r3,8(r2)
 182150c:	e0bffa17 	ldw	r2,-24(fp)
 1821510:	1080020b 	ldhu	r2,8(r2)
 1821514:	1885c83a 	sub	r2,r3,r2
 1821518:	10bfffcc 	andi	r2,r2,65535
 182151c:	100f883a 	mov	r7,r2
 1821520:	01800044 	movi	r6,1
 1821524:	e17ffe17 	ldw	r5,-8(fp)
 1821528:	181b2a80 	call	181b2a8 <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 182152c:	e0ffff17 	ldw	r3,-4(fp)
 1821530:	e0bfff17 	ldw	r2,-4(fp)
 1821534:	11000104 	addi	r4,r2,4
                                      IP_PROTO_TCP, p->tot_len);
 1821538:	e0bffc17 	ldw	r2,-16(fp)
 182153c:	1080020b 	ldhu	r2,8(r2)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 1821540:	10bfffcc 	andi	r2,r2,65535
 1821544:	d8800015 	stw	r2,0(sp)
 1821548:	01c00184 	movi	r7,6
 182154c:	200d883a 	mov	r6,r4
 1821550:	180b883a 	mov	r5,r3
 1821554:	e13ffc17 	ldw	r4,-16(fp)
 1821558:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 182155c:	100d883a 	mov	r6,r2
 1821560:	e0bffd17 	ldw	r2,-12(fp)
 1821564:	30ffffcc 	andi	r3,r6,65535
 1821568:	19403fcc 	andi	r5,r3,255
 182156c:	10c00403 	ldbu	r3,16(r2)
 1821570:	1806703a 	and	r3,r3,zero
 1821574:	1809883a 	mov	r4,r3
 1821578:	2807883a 	mov	r3,r5
 182157c:	20c6b03a 	or	r3,r4,r3
 1821580:	10c00405 	stb	r3,16(r2)
 1821584:	30ffffcc 	andi	r3,r6,65535
 1821588:	1806d23a 	srli	r3,r3,8
 182158c:	197fffcc 	andi	r5,r3,65535
 1821590:	10c00443 	ldbu	r3,17(r2)
 1821594:	1806703a 	and	r3,r3,zero
 1821598:	1809883a 	mov	r4,r3
 182159c:	2807883a 	mov	r3,r5
 18215a0:	20c6b03a 	or	r3,r4,r3
 18215a4:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 18215a8:	008061f4 	movhi	r2,391
 18215ac:	10a9d404 	addi	r2,r2,-22704
 18215b0:	10804817 	ldw	r2,288(r2)
 18215b4:	10c00044 	addi	r3,r2,1
 18215b8:	008061f4 	movhi	r2,391
 18215bc:	10a9d404 	addi	r2,r2,-22704
 18215c0:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
 18215c4:	e0ffff17 	ldw	r3,-4(fp)
 18215c8:	e0bfff17 	ldw	r2,-4(fp)
 18215cc:	11000104 	addi	r4,r2,4
 18215d0:	e0bfff17 	ldw	r2,-4(fp)
 18215d4:	10800283 	ldbu	r2,10(r2)
 18215d8:	11403fcc 	andi	r5,r2,255
 18215dc:	e0bfff17 	ldw	r2,-4(fp)
 18215e0:	108002c4 	addi	r2,r2,11
 18215e4:	d8800215 	stw	r2,8(sp)
 18215e8:	00800184 	movi	r2,6
 18215ec:	d8800115 	stw	r2,4(sp)
 18215f0:	d8000015 	stw	zero,0(sp)
 18215f4:	280f883a 	mov	r7,r5
 18215f8:	200d883a 	mov	r6,r4
 18215fc:	180b883a 	mov	r5,r3
 1821600:	e13ffc17 	ldw	r4,-16(fp)
 1821604:	1832f6c0 	call	1832f6c <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 1821608:	e13ffc17 	ldw	r4,-16(fp)
 182160c:	181aca40 	call	181aca4 <pbuf_free>
 1821610:	00000306 	br	1821620 <tcp_zero_window_probe+0x2d4>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
 1821614:	0001883a 	nop
 1821618:	00000106 	br	1821620 <tcp_zero_window_probe+0x2d4>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
 182161c:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 1821620:	e037883a 	mov	sp,fp
 1821624:	dfc00117 	ldw	ra,4(sp)
 1821628:	df000017 	ldw	fp,0(sp)
 182162c:	dec00204 	addi	sp,sp,8
 1821630:	f800283a 	ret

01821634 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 1821634:	defffd04 	addi	sp,sp,-12
 1821638:	dfc00215 	stw	ra,8(sp)
 182163c:	df000115 	stw	fp,4(sp)
 1821640:	df000104 	addi	fp,sp,4
 1821644:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 1821648:	181baac0 	call	181baac <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 182164c:	d0a7f717 	ldw	r2,-24612(gp)
 1821650:	1000021e 	bne	r2,zero,182165c <tcpip_tcp_timer+0x28>
 1821654:	d0a7fc17 	ldw	r2,-24592(gp)
 1821658:	10000626 	beq	r2,zero,1821674 <tcpip_tcp_timer+0x40>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 182165c:	000d883a 	mov	r6,zero
 1821660:	014060b4 	movhi	r5,386
 1821664:	29458d04 	addi	r5,r5,5684
 1821668:	01003e84 	movi	r4,250
 182166c:	18218740 	call	1821874 <sys_timeout>
 1821670:	00000106 	br	1821678 <tcpip_tcp_timer+0x44>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 1821674:	d027fe15 	stw	zero,-24584(gp)
  }
}
 1821678:	0001883a 	nop
 182167c:	e037883a 	mov	sp,fp
 1821680:	dfc00117 	ldw	ra,4(sp)
 1821684:	df000017 	ldw	fp,0(sp)
 1821688:	dec00204 	addi	sp,sp,8
 182168c:	f800283a 	ret

01821690 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 1821690:	defffe04 	addi	sp,sp,-8
 1821694:	dfc00115 	stw	ra,4(sp)
 1821698:	df000015 	stw	fp,0(sp)
 182169c:	d839883a 	mov	fp,sp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 18216a0:	d0a7fe17 	ldw	r2,-24584(gp)
 18216a4:	10000b1e 	bne	r2,zero,18216d4 <tcp_timer_needed+0x44>
 18216a8:	d0a7f717 	ldw	r2,-24612(gp)
 18216ac:	1000021e 	bne	r2,zero,18216b8 <tcp_timer_needed+0x28>
 18216b0:	d0a7fc17 	ldw	r2,-24592(gp)
 18216b4:	10000726 	beq	r2,zero,18216d4 <tcp_timer_needed+0x44>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 18216b8:	00800044 	movi	r2,1
 18216bc:	d0a7fe15 	stw	r2,-24584(gp)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 18216c0:	000d883a 	mov	r6,zero
 18216c4:	014060b4 	movhi	r5,386
 18216c8:	29458d04 	addi	r5,r5,5684
 18216cc:	01003e84 	movi	r4,250
 18216d0:	18218740 	call	1821874 <sys_timeout>
  }
}
 18216d4:	0001883a 	nop
 18216d8:	e037883a 	mov	sp,fp
 18216dc:	dfc00117 	ldw	ra,4(sp)
 18216e0:	df000017 	ldw	fp,0(sp)
 18216e4:	dec00204 	addi	sp,sp,8
 18216e8:	f800283a 	ret

018216ec <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
 18216ec:	defffd04 	addi	sp,sp,-12
 18216f0:	dfc00215 	stw	ra,8(sp)
 18216f4:	df000115 	stw	fp,4(sp)
 18216f8:	df000104 	addi	fp,sp,4
 18216fc:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
 1821700:	183303c0 	call	183303c <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 1821704:	000d883a 	mov	r6,zero
 1821708:	014060b4 	movhi	r5,386
 182170c:	2945bb04 	addi	r5,r5,5868
 1821710:	0100fa04 	movi	r4,1000
 1821714:	18218740 	call	1821874 <sys_timeout>
}
 1821718:	0001883a 	nop
 182171c:	e037883a 	mov	sp,fp
 1821720:	dfc00117 	ldw	ra,4(sp)
 1821724:	df000017 	ldw	fp,0(sp)
 1821728:	dec00204 	addi	sp,sp,8
 182172c:	f800283a 	ret

01821730 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
 1821730:	defffd04 	addi	sp,sp,-12
 1821734:	dfc00215 	stw	ra,8(sp)
 1821738:	df000115 	stw	fp,4(sp)
 182173c:	df000104 	addi	fp,sp,4
 1821740:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
 1821744:	1822db40 	call	1822db4 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 1821748:	000d883a 	mov	r6,zero
 182174c:	014060b4 	movhi	r5,386
 1821750:	2945cc04 	addi	r5,r5,5936
 1821754:	0104e204 	movi	r4,5000
 1821758:	18218740 	call	1821874 <sys_timeout>
}
 182175c:	0001883a 	nop
 1821760:	e037883a 	mov	sp,fp
 1821764:	dfc00117 	ldw	ra,4(sp)
 1821768:	df000017 	ldw	fp,0(sp)
 182176c:	dec00204 	addi	sp,sp,8
 1821770:	f800283a 	ret

01821774 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
 1821774:	defffd04 	addi	sp,sp,-12
 1821778:	dfc00215 	stw	ra,8(sp)
 182177c:	df000115 	stw	fp,4(sp)
 1821780:	df000104 	addi	fp,sp,4
 1821784:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
 1821788:	1815bb00 	call	1815bb0 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
 182178c:	000d883a 	mov	r6,zero
 1821790:	014060b4 	movhi	r5,386
 1821794:	2945dd04 	addi	r5,r5,6004
 1821798:	013a9814 	movui	r4,60000
 182179c:	18218740 	call	1821874 <sys_timeout>
}
 18217a0:	0001883a 	nop
 18217a4:	e037883a 	mov	sp,fp
 18217a8:	dfc00117 	ldw	ra,4(sp)
 18217ac:	df000017 	ldw	fp,0(sp)
 18217b0:	dec00204 	addi	sp,sp,8
 18217b4:	f800283a 	ret

018217b8 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
 18217b8:	defffd04 	addi	sp,sp,-12
 18217bc:	dfc00215 	stw	ra,8(sp)
 18217c0:	df000115 	stw	fp,4(sp)
 18217c4:	df000104 	addi	fp,sp,4
 18217c8:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
 18217cc:	1815c580 	call	1815c58 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 18217d0:	000d883a 	mov	r6,zero
 18217d4:	014060b4 	movhi	r5,386
 18217d8:	2945ee04 	addi	r5,r5,6072
 18217dc:	01007d04 	movi	r4,500
 18217e0:	18218740 	call	1821874 <sys_timeout>
}
 18217e4:	0001883a 	nop
 18217e8:	e037883a 	mov	sp,fp
 18217ec:	dfc00117 	ldw	ra,4(sp)
 18217f0:	df000017 	ldw	fp,0(sp)
 18217f4:	dec00204 	addi	sp,sp,8
 18217f8:	f800283a 	ret

018217fc <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
 18217fc:	defffe04 	addi	sp,sp,-8
 1821800:	dfc00115 	stw	ra,4(sp)
 1821804:	df000015 	stw	fp,0(sp)
 1821808:	d839883a 	mov	fp,sp
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 182180c:	000d883a 	mov	r6,zero
 1821810:	014060b4 	movhi	r5,386
 1821814:	2945bb04 	addi	r5,r5,5868
 1821818:	0100fa04 	movi	r4,1000
 182181c:	18218740 	call	1821874 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 1821820:	000d883a 	mov	r6,zero
 1821824:	014060b4 	movhi	r5,386
 1821828:	2945cc04 	addi	r5,r5,5936
 182182c:	0104e204 	movi	r4,5000
 1821830:	18218740 	call	1821874 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
 1821834:	000d883a 	mov	r6,zero
 1821838:	014060b4 	movhi	r5,386
 182183c:	2945dd04 	addi	r5,r5,6004
 1821840:	013a9814 	movui	r4,60000
 1821844:	18218740 	call	1821874 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 1821848:	000d883a 	mov	r6,zero
 182184c:	014060b4 	movhi	r5,386
 1821850:	2945ee04 	addi	r5,r5,6072
 1821854:	01007d04 	movi	r4,500
 1821858:	18218740 	call	1821874 <sys_timeout>

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
 182185c:	0001883a 	nop
 1821860:	e037883a 	mov	sp,fp
 1821864:	dfc00117 	ldw	ra,4(sp)
 1821868:	df000017 	ldw	fp,0(sp)
 182186c:	dec00204 	addi	sp,sp,8
 1821870:	f800283a 	ret

01821874 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 1821874:	defff904 	addi	sp,sp,-28
 1821878:	dfc00615 	stw	ra,24(sp)
 182187c:	df000515 	stw	fp,20(sp)
 1821880:	df000504 	addi	fp,sp,20
 1821884:	e13ffd15 	stw	r4,-12(fp)
 1821888:	e17ffe15 	stw	r5,-8(fp)
 182188c:	e1bfff15 	stw	r6,-4(fp)
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 1821890:	01000304 	movi	r4,12
 1821894:	18349580 	call	1834958 <memp_malloc>
 1821898:	e0bffc15 	stw	r2,-16(fp)
  if (timeout == NULL) {
 182189c:	e0bffc17 	ldw	r2,-16(fp)
 18218a0:	10004d26 	beq	r2,zero,18219d8 <sys_timeout+0x164>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 18218a4:	e0bffc17 	ldw	r2,-16(fp)
 18218a8:	10000015 	stw	zero,0(r2)
  timeout->h = handler;
 18218ac:	e0bffc17 	ldw	r2,-16(fp)
 18218b0:	e0fffe17 	ldw	r3,-8(fp)
 18218b4:	10c00215 	stw	r3,8(r2)
  timeout->arg = arg;
 18218b8:	e0bffc17 	ldw	r2,-16(fp)
 18218bc:	e0ffff17 	ldw	r3,-4(fp)
 18218c0:	10c00315 	stw	r3,12(r2)
  timeout->time = msecs;
 18218c4:	e0bffc17 	ldw	r2,-16(fp)
 18218c8:	e0fffd17 	ldw	r3,-12(fp)
 18218cc:	10c00115 	stw	r3,4(r2)
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 18218d0:	d0a7fd17 	ldw	r2,-24588(gp)
 18218d4:	1000031e 	bne	r2,zero,18218e4 <sys_timeout+0x70>
    next_timeout = timeout;
 18218d8:	e0bffc17 	ldw	r2,-16(fp)
 18218dc:	d0a7fd15 	stw	r2,-24588(gp)
    return;
 18218e0:	00003e06 	br	18219dc <sys_timeout+0x168>
  }

  if (next_timeout->time > msecs) {
 18218e4:	d0a7fd17 	ldw	r2,-24588(gp)
 18218e8:	10800117 	ldw	r2,4(r2)
 18218ec:	e0fffd17 	ldw	r3,-12(fp)
 18218f0:	18800c2e 	bgeu	r3,r2,1821924 <sys_timeout+0xb0>
    next_timeout->time -= msecs;
 18218f4:	d0a7fd17 	ldw	r2,-24588(gp)
 18218f8:	d0e7fd17 	ldw	r3,-24588(gp)
 18218fc:	19000117 	ldw	r4,4(r3)
 1821900:	e0fffd17 	ldw	r3,-12(fp)
 1821904:	20c7c83a 	sub	r3,r4,r3
 1821908:	10c00115 	stw	r3,4(r2)
    timeout->next = next_timeout;
 182190c:	d0e7fd17 	ldw	r3,-24588(gp)
 1821910:	e0bffc17 	ldw	r2,-16(fp)
 1821914:	10c00015 	stw	r3,0(r2)
    next_timeout = timeout;
 1821918:	e0bffc17 	ldw	r2,-16(fp)
 182191c:	d0a7fd15 	stw	r2,-24588(gp)
 1821920:	00002e06 	br	18219dc <sys_timeout+0x168>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 1821924:	d0a7fd17 	ldw	r2,-24588(gp)
 1821928:	e0bffb15 	stw	r2,-20(fp)
 182192c:	00002706 	br	18219cc <sys_timeout+0x158>
      timeout->time -= t->time;
 1821930:	e0bffc17 	ldw	r2,-16(fp)
 1821934:	10c00117 	ldw	r3,4(r2)
 1821938:	e0bffb17 	ldw	r2,-20(fp)
 182193c:	10800117 	ldw	r2,4(r2)
 1821940:	1887c83a 	sub	r3,r3,r2
 1821944:	e0bffc17 	ldw	r2,-16(fp)
 1821948:	10c00115 	stw	r3,4(r2)
      if (t->next == NULL || t->next->time > timeout->time) {
 182194c:	e0bffb17 	ldw	r2,-20(fp)
 1821950:	10800017 	ldw	r2,0(r2)
 1821954:	10000626 	beq	r2,zero,1821970 <sys_timeout+0xfc>
 1821958:	e0bffb17 	ldw	r2,-20(fp)
 182195c:	10800017 	ldw	r2,0(r2)
 1821960:	10800117 	ldw	r2,4(r2)
 1821964:	e0fffc17 	ldw	r3,-16(fp)
 1821968:	18c00117 	ldw	r3,4(r3)
 182196c:	1880142e 	bgeu	r3,r2,18219c0 <sys_timeout+0x14c>
        if (t->next != NULL) {
 1821970:	e0bffb17 	ldw	r2,-20(fp)
 1821974:	10800017 	ldw	r2,0(r2)
 1821978:	10000926 	beq	r2,zero,18219a0 <sys_timeout+0x12c>
          t->next->time -= timeout->time;
 182197c:	e0bffb17 	ldw	r2,-20(fp)
 1821980:	10800017 	ldw	r2,0(r2)
 1821984:	e0fffb17 	ldw	r3,-20(fp)
 1821988:	18c00017 	ldw	r3,0(r3)
 182198c:	19000117 	ldw	r4,4(r3)
 1821990:	e0fffc17 	ldw	r3,-16(fp)
 1821994:	18c00117 	ldw	r3,4(r3)
 1821998:	20c7c83a 	sub	r3,r4,r3
 182199c:	10c00115 	stw	r3,4(r2)
        }
        timeout->next = t->next;
 18219a0:	e0bffb17 	ldw	r2,-20(fp)
 18219a4:	10c00017 	ldw	r3,0(r2)
 18219a8:	e0bffc17 	ldw	r2,-16(fp)
 18219ac:	10c00015 	stw	r3,0(r2)
        t->next = timeout;
 18219b0:	e0bffb17 	ldw	r2,-20(fp)
 18219b4:	e0fffc17 	ldw	r3,-16(fp)
 18219b8:	10c00015 	stw	r3,0(r2)
        break;
 18219bc:	00000706 	br	18219dc <sys_timeout+0x168>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 18219c0:	e0bffb17 	ldw	r2,-20(fp)
 18219c4:	10800017 	ldw	r2,0(r2)
 18219c8:	e0bffb15 	stw	r2,-20(fp)
 18219cc:	e0bffb17 	ldw	r2,-20(fp)
 18219d0:	103fd71e 	bne	r2,zero,1821930 <__ram_exceptions_end+0xff8114ec>
 18219d4:	00000106 	br	18219dc <sys_timeout+0x168>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
 18219d8:	0001883a 	nop
        t->next = timeout;
        break;
      }
    }
  }
}
 18219dc:	e037883a 	mov	sp,fp
 18219e0:	dfc00117 	ldw	ra,4(sp)
 18219e4:	df000017 	ldw	fp,0(sp)
 18219e8:	dec00204 	addi	sp,sp,8
 18219ec:	f800283a 	ret

018219f0 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 18219f0:	defffa04 	addi	sp,sp,-24
 18219f4:	dfc00515 	stw	ra,20(sp)
 18219f8:	df000415 	stw	fp,16(sp)
 18219fc:	df000404 	addi	fp,sp,16
 1821a00:	e13ffe15 	stw	r4,-8(fp)
 1821a04:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
 1821a08:	d0a7fd17 	ldw	r2,-24588(gp)
 1821a0c:	10002f26 	beq	r2,zero,1821acc <sys_untimeout+0xdc>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 1821a10:	d0a7fd17 	ldw	r2,-24588(gp)
 1821a14:	e0bffd15 	stw	r2,-12(fp)
 1821a18:	e03ffc15 	stw	zero,-16(fp)
 1821a1c:	00002706 	br	1821abc <sys_untimeout+0xcc>
    if ((t->h == handler) && (t->arg == arg)) {
 1821a20:	e0bffd17 	ldw	r2,-12(fp)
 1821a24:	10c00217 	ldw	r3,8(r2)
 1821a28:	e0bffe17 	ldw	r2,-8(fp)
 1821a2c:	18801e1e 	bne	r3,r2,1821aa8 <sys_untimeout+0xb8>
 1821a30:	e0bffd17 	ldw	r2,-12(fp)
 1821a34:	10c00317 	ldw	r3,12(r2)
 1821a38:	e0bfff17 	ldw	r2,-4(fp)
 1821a3c:	18801a1e 	bne	r3,r2,1821aa8 <sys_untimeout+0xb8>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 1821a40:	e0bffc17 	ldw	r2,-16(fp)
 1821a44:	1000041e 	bne	r2,zero,1821a58 <sys_untimeout+0x68>
        next_timeout = t->next;
 1821a48:	e0bffd17 	ldw	r2,-12(fp)
 1821a4c:	10800017 	ldw	r2,0(r2)
 1821a50:	d0a7fd15 	stw	r2,-24588(gp)
 1821a54:	00000406 	br	1821a68 <sys_untimeout+0x78>
      } else {
        prev_t->next = t->next;
 1821a58:	e0bffd17 	ldw	r2,-12(fp)
 1821a5c:	10c00017 	ldw	r3,0(r2)
 1821a60:	e0bffc17 	ldw	r2,-16(fp)
 1821a64:	10c00015 	stw	r3,0(r2)
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
 1821a68:	e0bffd17 	ldw	r2,-12(fp)
 1821a6c:	10800017 	ldw	r2,0(r2)
 1821a70:	10000926 	beq	r2,zero,1821a98 <sys_untimeout+0xa8>
        t->next->time += t->time;
 1821a74:	e0bffd17 	ldw	r2,-12(fp)
 1821a78:	10800017 	ldw	r2,0(r2)
 1821a7c:	e0fffd17 	ldw	r3,-12(fp)
 1821a80:	18c00017 	ldw	r3,0(r3)
 1821a84:	19000117 	ldw	r4,4(r3)
 1821a88:	e0fffd17 	ldw	r3,-12(fp)
 1821a8c:	18c00117 	ldw	r3,4(r3)
 1821a90:	20c7883a 	add	r3,r4,r3
 1821a94:	10c00115 	stw	r3,4(r2)
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 1821a98:	e17ffd17 	ldw	r5,-12(fp)
 1821a9c:	01000304 	movi	r4,12
 1821aa0:	1834b240 	call	1834b24 <memp_free>
      return;
 1821aa4:	00000a06 	br	1821ad0 <sys_untimeout+0xe0>

  if (next_timeout == NULL) {
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 1821aa8:	e0bffd17 	ldw	r2,-12(fp)
 1821aac:	e0bffc15 	stw	r2,-16(fp)
 1821ab0:	e0bffd17 	ldw	r2,-12(fp)
 1821ab4:	10800017 	ldw	r2,0(r2)
 1821ab8:	e0bffd15 	stw	r2,-12(fp)
 1821abc:	e0bffd17 	ldw	r2,-12(fp)
 1821ac0:	103fd71e 	bne	r2,zero,1821a20 <__ram_exceptions_end+0xff8115dc>
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
 1821ac4:	0001883a 	nop
 1821ac8:	00000106 	br	1821ad0 <sys_untimeout+0xe0>
sys_untimeout(sys_timeout_handler handler, void *arg)
{
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
    return;
 1821acc:	0001883a 	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
 1821ad0:	e037883a 	mov	sp,fp
 1821ad4:	dfc00117 	ldw	ra,4(sp)
 1821ad8:	df000017 	ldw	fp,0(sp)
 1821adc:	dec00204 	addi	sp,sp,8
 1821ae0:	f800283a 	ret

01821ae4 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 1821ae4:	defff804 	addi	sp,sp,-32
 1821ae8:	dfc00715 	stw	ra,28(sp)
 1821aec:	df000615 	stw	fp,24(sp)
 1821af0:	df000604 	addi	fp,sp,24
 1821af4:	e13ffe15 	stw	r4,-8(fp)
 1821af8:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 1821afc:	d0a7fd17 	ldw	r2,-24588(gp)
 1821b00:	1000061e 	bne	r2,zero,1821b1c <sys_timeouts_mbox_fetch+0x38>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 1821b04:	000d883a 	mov	r6,zero
 1821b08:	e17fff17 	ldw	r5,-4(fp)
 1821b0c:	e13ffe17 	ldw	r4,-8(fp)
 1821b10:	18155340 	call	1815534 <sys_arch_mbox_fetch>
 1821b14:	e0bffa15 	stw	r2,-24(fp)
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 1821b18:	00003106 	br	1821be0 <sys_timeouts_mbox_fetch+0xfc>

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  } else {
    if (next_timeout->time > 0) {
 1821b1c:	d0a7fd17 	ldw	r2,-24588(gp)
 1821b20:	10800117 	ldw	r2,4(r2)
 1821b24:	10000826 	beq	r2,zero,1821b48 <sys_timeouts_mbox_fetch+0x64>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 1821b28:	d0a7fd17 	ldw	r2,-24588(gp)
 1821b2c:	10800117 	ldw	r2,4(r2)
 1821b30:	100d883a 	mov	r6,r2
 1821b34:	e17fff17 	ldw	r5,-4(fp)
 1821b38:	e13ffe17 	ldw	r4,-8(fp)
 1821b3c:	18155340 	call	1815534 <sys_arch_mbox_fetch>
 1821b40:	e0bffa15 	stw	r2,-24(fp)
 1821b44:	00000206 	br	1821b50 <sys_timeouts_mbox_fetch+0x6c>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
 1821b48:	00bfffc4 	movi	r2,-1
 1821b4c:	e0bffa15 	stw	r2,-24(fp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
 1821b50:	e0bffa17 	ldw	r2,-24(fp)
 1821b54:	10bfffd8 	cmpnei	r2,r2,-1
 1821b58:	1000141e 	bne	r2,zero,1821bac <sys_timeouts_mbox_fetch+0xc8>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
 1821b5c:	d0a7fd17 	ldw	r2,-24588(gp)
 1821b60:	e0bffb15 	stw	r2,-20(fp)
      next_timeout = tmptimeout->next;
 1821b64:	e0bffb17 	ldw	r2,-20(fp)
 1821b68:	10800017 	ldw	r2,0(r2)
 1821b6c:	d0a7fd15 	stw	r2,-24588(gp)
      handler = tmptimeout->h;
 1821b70:	e0bffb17 	ldw	r2,-20(fp)
 1821b74:	10800217 	ldw	r2,8(r2)
 1821b78:	e0bffc15 	stw	r2,-16(fp)
      arg = tmptimeout->arg;
 1821b7c:	e0bffb17 	ldw	r2,-20(fp)
 1821b80:	10800317 	ldw	r2,12(r2)
 1821b84:	e0bffd15 	stw	r2,-12(fp)
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 1821b88:	e17ffb17 	ldw	r5,-20(fp)
 1821b8c:	01000304 	movi	r4,12
 1821b90:	1834b240 	call	1834b24 <memp_free>
      if (handler != NULL) {
 1821b94:	e0bffc17 	ldw	r2,-16(fp)
 1821b98:	103fd826 	beq	r2,zero,1821afc <__ram_exceptions_end+0xff8116b8>
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
 1821b9c:	e0bffc17 	ldw	r2,-16(fp)
 1821ba0:	e13ffd17 	ldw	r4,-12(fp)
 1821ba4:	103ee83a 	callr	r2
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
 1821ba8:	003fd406 	br	1821afc <__ram_exceptions_end+0xff8116b8>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
 1821bac:	d0a7fd17 	ldw	r2,-24588(gp)
 1821bb0:	10800117 	ldw	r2,4(r2)
 1821bb4:	e0fffa17 	ldw	r3,-24(fp)
 1821bb8:	1880072e 	bgeu	r3,r2,1821bd8 <sys_timeouts_mbox_fetch+0xf4>
        next_timeout->time -= time_needed;
 1821bbc:	d0a7fd17 	ldw	r2,-24588(gp)
 1821bc0:	d0e7fd17 	ldw	r3,-24588(gp)
 1821bc4:	19000117 	ldw	r4,4(r3)
 1821bc8:	e0fffa17 	ldw	r3,-24(fp)
 1821bcc:	20c7c83a 	sub	r3,r4,r3
 1821bd0:	10c00115 	stw	r3,4(r2)
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 1821bd4:	00000206 	br	1821be0 <sys_timeouts_mbox_fetch+0xfc>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
        next_timeout->time -= time_needed;
      } else {
        next_timeout->time = 0;
 1821bd8:	d0a7fd17 	ldw	r2,-24588(gp)
 1821bdc:	10000115 	stw	zero,4(r2)
      }
    }
  }
}
 1821be0:	0001883a 	nop
 1821be4:	e037883a 	mov	sp,fp
 1821be8:	dfc00117 	ldw	ra,4(sp)
 1821bec:	df000017 	ldw	fp,0(sp)
 1821bf0:	dec00204 	addi	sp,sp,8
 1821bf4:	f800283a 	ret

01821bf8 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 1821bf8:	deffff04 	addi	sp,sp,-4
 1821bfc:	df000015 	stw	fp,0(sp)
 1821c00:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
 1821c04:	0001883a 	nop
 1821c08:	e037883a 	mov	sp,fp
 1821c0c:	df000017 	ldw	fp,0(sp)
 1821c10:	dec00104 	addi	sp,sp,4
 1821c14:	f800283a 	ret

01821c18 <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 1821c18:	defffd04 	addi	sp,sp,-12
 1821c1c:	df000215 	stw	fp,8(sp)
 1821c20:	df000204 	addi	fp,sp,8
  u16_t n = 0;
 1821c24:	e03ffe0d 	sth	zero,-8(fp)
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 1821c28:	d0a0130b 	ldhu	r2,-32692(gp)
 1821c2c:	10c00044 	addi	r3,r2,1
 1821c30:	d0e0130d 	sth	r3,-32692(gp)
 1821c34:	10ffffcc 	andi	r3,r2,65535
 1821c38:	00bfffd4 	movui	r2,65535
 1821c3c:	1880021e 	bne	r3,r2,1821c48 <udp_new_port+0x30>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 1821c40:	00b00004 	movi	r2,-16384
 1821c44:	d0a0130d 	sth	r2,-32692(gp)
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 1821c48:	d0a7ff17 	ldw	r2,-24580(gp)
 1821c4c:	e0bfff15 	stw	r2,-4(fp)
 1821c50:	00001106 	br	1821c98 <udp_new_port+0x80>
    if (pcb->local_port == udp_port) {
 1821c54:	e0bfff17 	ldw	r2,-4(fp)
 1821c58:	10c0048b 	ldhu	r3,18(r2)
 1821c5c:	d0a0130b 	ldhu	r2,-32692(gp)
 1821c60:	18ffffcc 	andi	r3,r3,65535
 1821c64:	10bfffcc 	andi	r2,r2,65535
 1821c68:	1880081e 	bne	r3,r2,1821c8c <udp_new_port+0x74>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 1821c6c:	e0bffe0b 	ldhu	r2,-8(fp)
 1821c70:	10800044 	addi	r2,r2,1
 1821c74:	e0bffe0d 	sth	r2,-8(fp)
 1821c78:	e0bffe0b 	ldhu	r2,-8(fp)
 1821c7c:	10900030 	cmpltui	r2,r2,16384
 1821c80:	103fe91e 	bne	r2,zero,1821c28 <__ram_exceptions_end+0xff8117e4>
        return 0;
 1821c84:	0005883a 	mov	r2,zero
 1821c88:	00000606 	br	1821ca4 <udp_new_port+0x8c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 1821c8c:	e0bfff17 	ldw	r2,-4(fp)
 1821c90:	10800317 	ldw	r2,12(r2)
 1821c94:	e0bfff15 	stw	r2,-4(fp)
 1821c98:	e0bfff17 	ldw	r2,-4(fp)
 1821c9c:	103fed1e 	bne	r2,zero,1821c54 <__ram_exceptions_end+0xff811810>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
 1821ca0:	d0a0130b 	ldhu	r2,-32692(gp)
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
 1821ca4:	e037883a 	mov	sp,fp
 1821ca8:	df000017 	ldw	fp,0(sp)
 1821cac:	dec00104 	addi	sp,sp,4
 1821cb0:	f800283a 	ret

01821cb4 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 1821cb4:	defff304 	addi	sp,sp,-52
 1821cb8:	dfc00c15 	stw	ra,48(sp)
 1821cbc:	df000b15 	stw	fp,44(sp)
 1821cc0:	df000b04 	addi	fp,sp,44
 1821cc4:	e13ffe15 	stw	r4,-8(fp)
 1821cc8:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 1821ccc:	008061f4 	movhi	r2,391
 1821cd0:	10a9d404 	addi	r2,r2,-22704
 1821cd4:	10803d17 	ldw	r2,244(r2)
 1821cd8:	10c00044 	addi	r3,r2,1
 1821cdc:	008061f4 	movhi	r2,391
 1821ce0:	10a9d404 	addi	r2,r2,-22704
 1821ce4:	10c03d15 	stw	r3,244(r2)

  iphdr = (struct ip_hdr *)p->payload;
 1821ce8:	e0bffe17 	ldw	r2,-8(fp)
 1821cec:	10800117 	ldw	r2,4(r2)
 1821cf0:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 1821cf4:	e0bffe17 	ldw	r2,-8(fp)
 1821cf8:	1080020b 	ldhu	r2,8(r2)
 1821cfc:	10ffffcc 	andi	r3,r2,65535
 1821d00:	e0bffa17 	ldw	r2,-24(fp)
 1821d04:	10800003 	ldbu	r2,0(r2)
 1821d08:	10803fcc 	andi	r2,r2,255
 1821d0c:	108003cc 	andi	r2,r2,15
 1821d10:	10800084 	addi	r2,r2,2
 1821d14:	1085883a 	add	r2,r2,r2
 1821d18:	1085883a 	add	r2,r2,r2
 1821d1c:	18800f16 	blt	r3,r2,1821d5c <udp_input+0xa8>
 1821d20:	e0bffa17 	ldw	r2,-24(fp)
 1821d24:	10800003 	ldbu	r2,0(r2)
 1821d28:	10803fcc 	andi	r2,r2,255
 1821d2c:	108003cc 	andi	r2,r2,15
 1821d30:	1085883a 	add	r2,r2,r2
 1821d34:	1085883a 	add	r2,r2,r2
 1821d38:	0085c83a 	sub	r2,zero,r2
 1821d3c:	10bfffcc 	andi	r2,r2,65535
 1821d40:	10a0001c 	xori	r2,r2,32768
 1821d44:	10a00004 	addi	r2,r2,-32768
 1821d48:	100b883a 	mov	r5,r2
 1821d4c:	e13ffe17 	ldw	r4,-8(fp)
 1821d50:	181aaf40 	call	181aaf4 <pbuf_header>
 1821d54:	10803fcc 	andi	r2,r2,255
 1821d58:	10001126 	beq	r2,zero,1821da0 <udp_input+0xec>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 1821d5c:	008061f4 	movhi	r2,391
 1821d60:	10a9d404 	addi	r2,r2,-22704
 1821d64:	10804117 	ldw	r2,260(r2)
 1821d68:	10c00044 	addi	r3,r2,1
 1821d6c:	008061f4 	movhi	r2,391
 1821d70:	10a9d404 	addi	r2,r2,-22704
 1821d74:	10c04115 	stw	r3,260(r2)
    UDP_STATS_INC(udp.drop);
 1821d78:	008061f4 	movhi	r2,391
 1821d7c:	10a9d404 	addi	r2,r2,-22704
 1821d80:	10803f17 	ldw	r2,252(r2)
 1821d84:	10c00044 	addi	r3,r2,1
 1821d88:	008061f4 	movhi	r2,391
 1821d8c:	10a9d404 	addi	r2,r2,-22704
 1821d90:	10c03f15 	stw	r3,252(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
 1821d94:	e13ffe17 	ldw	r4,-8(fp)
 1821d98:	181aca40 	call	181aca4 <pbuf_free>
    goto end;
 1821d9c:	00011f06 	br	182221c <udp_input+0x568>
  }

  udphdr = (struct udp_hdr *)p->payload;
 1821da0:	e0bffe17 	ldw	r2,-8(fp)
 1821da4:	10800117 	ldw	r2,4(r2)
 1821da8:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 1821dac:	d0a81417 	ldw	r2,-24496(gp)
 1821db0:	e17fff17 	ldw	r5,-4(fp)
 1821db4:	1009883a 	mov	r4,r2
 1821db8:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 1821dbc:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 1821dc0:	e0bffb17 	ldw	r2,-20(fp)
 1821dc4:	10c00003 	ldbu	r3,0(r2)
 1821dc8:	10800043 	ldbu	r2,1(r2)
 1821dcc:	1004923a 	slli	r2,r2,8
 1821dd0:	10c4b03a 	or	r2,r2,r3
 1821dd4:	10bfffcc 	andi	r2,r2,65535
 1821dd8:	1004d23a 	srli	r2,r2,8
 1821ddc:	1009883a 	mov	r4,r2
 1821de0:	e0bffb17 	ldw	r2,-20(fp)
 1821de4:	10c00003 	ldbu	r3,0(r2)
 1821de8:	10800043 	ldbu	r2,1(r2)
 1821dec:	1004923a 	slli	r2,r2,8
 1821df0:	10c4b03a 	or	r2,r2,r3
 1821df4:	10bfffcc 	andi	r2,r2,65535
 1821df8:	1004923a 	slli	r2,r2,8
 1821dfc:	2084b03a 	or	r2,r4,r2
 1821e00:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
 1821e04:	e0bffb17 	ldw	r2,-20(fp)
 1821e08:	10c00083 	ldbu	r3,2(r2)
 1821e0c:	108000c3 	ldbu	r2,3(r2)
 1821e10:	1004923a 	slli	r2,r2,8
 1821e14:	10c4b03a 	or	r2,r2,r3
 1821e18:	10bfffcc 	andi	r2,r2,65535
 1821e1c:	1004d23a 	srli	r2,r2,8
 1821e20:	1009883a 	mov	r4,r2
 1821e24:	e0bffb17 	ldw	r2,-20(fp)
 1821e28:	10c00083 	ldbu	r3,2(r2)
 1821e2c:	108000c3 	ldbu	r2,3(r2)
 1821e30:	1004923a 	slli	r2,r2,8
 1821e34:	10c4b03a 	or	r2,r2,r3
 1821e38:	10bfffcc 	andi	r2,r2,65535
 1821e3c:	1004923a 	slli	r2,r2,8
 1821e40:	2084b03a 	or	r2,r4,r2
 1821e44:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
               ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
 1821e48:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
 1821e4c:	e0bffd0b 	ldhu	r2,-12(fp)
 1821e50:	10801118 	cmpnei	r2,r2,68
 1821e54:	10001f1e 	bne	r2,zero,1821ed4 <udp_input+0x220>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
 1821e58:	e0bffc8b 	ldhu	r2,-14(fp)
 1821e5c:	108010d8 	cmpnei	r2,r2,67
 1821e60:	10007a1e 	bne	r2,zero,182204c <udp_input+0x398>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 1821e64:	e0bfff17 	ldw	r2,-4(fp)
 1821e68:	10800a17 	ldw	r2,40(r2)
 1821e6c:	10007726 	beq	r2,zero,182204c <udp_input+0x398>
 1821e70:	e0bfff17 	ldw	r2,-4(fp)
 1821e74:	10800a17 	ldw	r2,40(r2)
 1821e78:	10800117 	ldw	r2,4(r2)
 1821e7c:	10007326 	beq	r2,zero,182204c <udp_input+0x398>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 1821e80:	e0bfff17 	ldw	r2,-4(fp)
 1821e84:	10800a17 	ldw	r2,40(r2)
 1821e88:	10800117 	ldw	r2,4(r2)
 1821e8c:	10800104 	addi	r2,r2,4
 1821e90:	10000b26 	beq	r2,zero,1821ec0 <udp_input+0x20c>
 1821e94:	e0bfff17 	ldw	r2,-4(fp)
 1821e98:	10800a17 	ldw	r2,40(r2)
 1821e9c:	10800117 	ldw	r2,4(r2)
 1821ea0:	10800117 	ldw	r2,4(r2)
 1821ea4:	10000626 	beq	r2,zero,1821ec0 <udp_input+0x20c>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
 1821ea8:	e0bfff17 	ldw	r2,-4(fp)
 1821eac:	10800a17 	ldw	r2,40(r2)
 1821eb0:	10800117 	ldw	r2,4(r2)
 1821eb4:	10c00117 	ldw	r3,4(r2)
 1821eb8:	d0a81217 	ldw	r2,-24504(gp)
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 1821ebc:	1880631e 	bne	r3,r2,182204c <udp_input+0x398>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
          pcb = inp->dhcp->pcb;
 1821ec0:	e0bfff17 	ldw	r2,-4(fp)
 1821ec4:	10800a17 	ldw	r2,40(r2)
 1821ec8:	10800117 	ldw	r2,4(r2)
 1821ecc:	e0bff615 	stw	r2,-40(fp)
 1821ed0:	00005e06 	br	182204c <udp_input+0x398>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
 1821ed4:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
 1821ed8:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
 1821edc:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 1821ee0:	d0a7ff17 	ldw	r2,-24580(gp)
 1821ee4:	e0bff615 	stw	r2,-40(fp)
 1821ee8:	00005206 	br	1822034 <udp_input+0x380>
      local_match = 0;
 1821eec:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
 1821ef0:	e0bff617 	ldw	r2,-40(fp)
 1821ef4:	1080048b 	ldhu	r2,18(r2)
 1821ef8:	10ffffcc 	andi	r3,r2,65535
 1821efc:	e0bffd0b 	ldhu	r2,-12(fp)
 1821f00:	1880221e 	bne	r3,r2,1821f8c <udp_input+0x2d8>
 1821f04:	e0bffc03 	ldbu	r2,-16(fp)
 1821f08:	1000051e 	bne	r2,zero,1821f20 <udp_input+0x26c>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 1821f0c:	e0bff617 	ldw	r2,-40(fp)
 1821f10:	10001326 	beq	r2,zero,1821f60 <udp_input+0x2ac>
 1821f14:	e0bff617 	ldw	r2,-40(fp)
 1821f18:	10800017 	ldw	r2,0(r2)
 1821f1c:	10001026 	beq	r2,zero,1821f60 <udp_input+0x2ac>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 1821f20:	e0bff617 	ldw	r2,-40(fp)
 1821f24:	10c00017 	ldw	r3,0(r2)
 1821f28:	d0a81417 	ldw	r2,-24496(gp)
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 1821f2c:	18800c26 	beq	r3,r2,1821f60 <udp_input+0x2ac>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 1821f30:	e0bffc03 	ldbu	r2,-16(fp)
 1821f34:	10001526 	beq	r2,zero,1821f8c <udp_input+0x2d8>
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
 1821f38:	e0bff617 	ldw	r2,-40(fp)
 1821f3c:	10c00017 	ldw	r3,0(r2)
 1821f40:	e0bfff17 	ldw	r2,-4(fp)
 1821f44:	10800117 	ldw	r2,4(r2)
           ip_addr_ismulticast(&current_iphdr_dest) ||
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
 1821f48:	18800526 	beq	r3,r2,1821f60 <udp_input+0x2ac>
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
 1821f4c:	e0bff617 	ldw	r2,-40(fp)
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
 1821f50:	10000326 	beq	r2,zero,1821f60 <udp_input+0x2ac>
			 ip_addr_isany(&pcb->local_ip))))) {
 1821f54:	e0bff617 	ldw	r2,-40(fp)
 1821f58:	10800017 	ldw	r2,0(r2)
 1821f5c:	10000b1e 	bne	r2,zero,1821f8c <udp_input+0x2d8>
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
 1821f60:	00800044 	movi	r2,1
 1821f64:	e0bff905 	stb	r2,-28(fp)
          if ((uncon_pcb == NULL) && 
 1821f68:	e0bff817 	ldw	r2,-32(fp)
 1821f6c:	1000071e 	bne	r2,zero,1821f8c <udp_input+0x2d8>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 1821f70:	e0bff617 	ldw	r2,-40(fp)
 1821f74:	10800403 	ldbu	r2,16(r2)
 1821f78:	10803fcc 	andi	r2,r2,255
 1821f7c:	1080010c 	andi	r2,r2,4
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 1821f80:	1000021e 	bne	r2,zero,1821f8c <udp_input+0x2d8>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
 1821f84:	e0bff617 	ldw	r2,-40(fp)
 1821f88:	e0bff815 	stw	r2,-32(fp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 1821f8c:	e0bff903 	ldbu	r2,-28(fp)
 1821f90:	10002326 	beq	r2,zero,1822020 <udp_input+0x36c>
          (pcb->remote_port == src) &&
 1821f94:	e0bff617 	ldw	r2,-40(fp)
 1821f98:	1080050b 	ldhu	r2,20(r2)
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 1821f9c:	10ffffcc 	andi	r3,r2,65535
 1821fa0:	e0bffc8b 	ldhu	r2,-14(fp)
 1821fa4:	18801e1e 	bne	r3,r2,1822020 <udp_input+0x36c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 1821fa8:	e0bff617 	ldw	r2,-40(fp)
 1821fac:	10800104 	addi	r2,r2,4
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
 1821fb0:	10000726 	beq	r2,zero,1821fd0 <udp_input+0x31c>
          (ip_addr_isany(&pcb->remote_ip) ||
 1821fb4:	e0bff617 	ldw	r2,-40(fp)
 1821fb8:	10800117 	ldw	r2,4(r2)
 1821fbc:	10000426 	beq	r2,zero,1821fd0 <udp_input+0x31c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 1821fc0:	e0bff617 	ldw	r2,-40(fp)
 1821fc4:	10c00117 	ldw	r3,4(r2)
 1821fc8:	d0a81217 	ldw	r2,-24504(gp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 1821fcc:	1880141e 	bne	r3,r2,1822020 <udp_input+0x36c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 1821fd0:	e0bff717 	ldw	r2,-36(fp)
 1821fd4:	10000a26 	beq	r2,zero,1822000 <udp_input+0x34c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 1821fd8:	e0bff617 	ldw	r2,-40(fp)
 1821fdc:	10c00317 	ldw	r3,12(r2)
 1821fe0:	e0bff717 	ldw	r2,-36(fp)
 1821fe4:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
 1821fe8:	d0e7ff17 	ldw	r3,-24580(gp)
 1821fec:	e0bff617 	ldw	r2,-40(fp)
 1821ff0:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
 1821ff4:	e0bff617 	ldw	r2,-40(fp)
 1821ff8:	d0a7ff15 	stw	r2,-24580(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 1821ffc:	00000f06 	br	182203c <udp_input+0x388>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
 1822000:	008061f4 	movhi	r2,391
 1822004:	10a9d404 	addi	r2,r2,-22704
 1822008:	10804717 	ldw	r2,284(r2)
 182200c:	10c00044 	addi	r3,r2,1
 1822010:	008061f4 	movhi	r2,391
 1822014:	10a9d404 	addi	r2,r2,-22704
 1822018:	10c04715 	stw	r3,284(r2)
        }
        break;
 182201c:	00000706 	br	182203c <udp_input+0x388>
      }
      prev = pcb;
 1822020:	e0bff617 	ldw	r2,-40(fp)
 1822024:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 1822028:	e0bff617 	ldw	r2,-40(fp)
 182202c:	10800317 	ldw	r2,12(r2)
 1822030:	e0bff615 	stw	r2,-40(fp)
 1822034:	e0bff617 	ldw	r2,-40(fp)
 1822038:	103fac1e 	bne	r2,zero,1821eec <__ram_exceptions_end+0xff811aa8>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
 182203c:	e0bff617 	ldw	r2,-40(fp)
 1822040:	1000021e 	bne	r2,zero,182204c <udp_input+0x398>
      pcb = uncon_pcb;
 1822044:	e0bff817 	ldw	r2,-32(fp)
 1822048:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 182204c:	e0bff617 	ldw	r2,-40(fp)
 1822050:	1000041e 	bne	r2,zero,1822064 <udp_input+0x3b0>
 1822054:	e0bfff17 	ldw	r2,-4(fp)
 1822058:	10c00117 	ldw	r3,4(r2)
 182205c:	d0a81417 	ldw	r2,-24496(gp)
 1822060:	18806c1e 	bne	r3,r2,1822214 <udp_input+0x560>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
 1822064:	e0bffb17 	ldw	r2,-20(fp)
 1822068:	10c00183 	ldbu	r3,6(r2)
 182206c:	108001c3 	ldbu	r2,7(r2)
 1822070:	1004923a 	slli	r2,r2,8
 1822074:	10c4b03a 	or	r2,r2,r3
 1822078:	10bfffcc 	andi	r2,r2,65535
 182207c:	10001c26 	beq	r2,zero,18220f0 <udp_input+0x43c>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
 1822080:	e0bffe17 	ldw	r2,-8(fp)
 1822084:	1080020b 	ldhu	r2,8(r2)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 1822088:	10bfffcc 	andi	r2,r2,65535
 182208c:	d8800015 	stw	r2,0(sp)
 1822090:	01c00444 	movi	r7,17
 1822094:	d1a81404 	addi	r6,gp,-24496
 1822098:	d1681204 	addi	r5,gp,-24504
 182209c:	e13ffe17 	ldw	r4,-8(fp)
 18220a0:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 18220a4:	10bfffcc 	andi	r2,r2,65535
 18220a8:	10001126 	beq	r2,zero,18220f0 <udp_input+0x43c>
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
 18220ac:	008061f4 	movhi	r2,391
 18220b0:	10a9d404 	addi	r2,r2,-22704
 18220b4:	10804017 	ldw	r2,256(r2)
 18220b8:	10c00044 	addi	r3,r2,1
 18220bc:	008061f4 	movhi	r2,391
 18220c0:	10a9d404 	addi	r2,r2,-22704
 18220c4:	10c04015 	stw	r3,256(r2)
          UDP_STATS_INC(udp.drop);
 18220c8:	008061f4 	movhi	r2,391
 18220cc:	10a9d404 	addi	r2,r2,-22704
 18220d0:	10803f17 	ldw	r2,252(r2)
 18220d4:	10c00044 	addi	r3,r2,1
 18220d8:	008061f4 	movhi	r2,391
 18220dc:	10a9d404 	addi	r2,r2,-22704
 18220e0:	10c03f15 	stw	r3,252(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
 18220e4:	e13ffe17 	ldw	r4,-8(fp)
 18220e8:	181aca40 	call	181aca4 <pbuf_free>
          goto end;
 18220ec:	00004b06 	br	182221c <udp_input+0x568>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 18220f0:	017ffe04 	movi	r5,-8
 18220f4:	e13ffe17 	ldw	r4,-8(fp)
 18220f8:	181aaf40 	call	181aaf4 <pbuf_header>
 18220fc:	10803fcc 	andi	r2,r2,255
 1822100:	10000a26 	beq	r2,zero,182212c <udp_input+0x478>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
 1822104:	008061f4 	movhi	r2,391
 1822108:	10a9d404 	addi	r2,r2,-22704
 182210c:	10803f17 	ldw	r2,252(r2)
 1822110:	10c00044 	addi	r3,r2,1
 1822114:	008061f4 	movhi	r2,391
 1822118:	10a9d404 	addi	r2,r2,-22704
 182211c:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpinerrors();
      pbuf_free(p);
 1822120:	e13ffe17 	ldw	r4,-8(fp)
 1822124:	181aca40 	call	181aca4 <pbuf_free>
      goto end;
 1822128:	00003c06 	br	182221c <udp_input+0x568>
    }
    if (pcb != NULL) {
 182212c:	e0bff617 	ldw	r2,-40(fp)
 1822130:	10001126 	beq	r2,zero,1822178 <udp_input+0x4c4>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 1822134:	e0bff617 	ldw	r2,-40(fp)
 1822138:	10800617 	ldw	r2,24(r2)
 182213c:	10000b26 	beq	r2,zero,182216c <udp_input+0x4b8>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 1822140:	e0bff617 	ldw	r2,-40(fp)
 1822144:	10800617 	ldw	r2,24(r2)
 1822148:	e0fff617 	ldw	r3,-40(fp)
 182214c:	19000717 	ldw	r4,28(r3)
 1822150:	e0fffc8b 	ldhu	r3,-14(fp)
 1822154:	d8c00015 	stw	r3,0(sp)
 1822158:	d1e81204 	addi	r7,gp,-24504
 182215c:	e1bffe17 	ldw	r6,-8(fp)
 1822160:	e17ff617 	ldw	r5,-40(fp)
 1822164:	103ee83a 	callr	r2
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 1822168:	00002c06 	br	182221c <udp_input+0x568>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 182216c:	e13ffe17 	ldw	r4,-8(fp)
 1822170:	181aca40 	call	181aca4 <pbuf_free>
        goto end;
 1822174:	00002906 	br	182221c <udp_input+0x568>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 1822178:	e0bffc03 	ldbu	r2,-16(fp)
 182217c:	1000141e 	bne	r2,zero,18221d0 <udp_input+0x51c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 1822180:	d0a81417 	ldw	r2,-24496(gp)
 1822184:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 1822188:	10803820 	cmpeqi	r2,r2,224
 182218c:	1000101e 	bne	r2,zero,18221d0 <udp_input+0x51c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 1822190:	e0bffa17 	ldw	r2,-24(fp)
 1822194:	10800003 	ldbu	r2,0(r2)
 1822198:	10803fcc 	andi	r2,r2,255
 182219c:	108003cc 	andi	r2,r2,15
 18221a0:	10800084 	addi	r2,r2,2
 18221a4:	1085883a 	add	r2,r2,r2
 18221a8:	1085883a 	add	r2,r2,r2
 18221ac:	10bfffcc 	andi	r2,r2,65535
 18221b0:	10a0001c 	xori	r2,r2,32768
 18221b4:	10a00004 	addi	r2,r2,-32768
 18221b8:	100b883a 	mov	r5,r2
 18221bc:	e13ffe17 	ldw	r4,-8(fp)
 18221c0:	181aaf40 	call	181aaf4 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 18221c4:	014000c4 	movi	r5,3
 18221c8:	e13ffe17 	ldw	r4,-8(fp)
 18221cc:	18317bc0 	call	18317bc <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
 18221d0:	008061f4 	movhi	r2,391
 18221d4:	10a9d404 	addi	r2,r2,-22704
 18221d8:	10804417 	ldw	r2,272(r2)
 18221dc:	10c00044 	addi	r3,r2,1
 18221e0:	008061f4 	movhi	r2,391
 18221e4:	10a9d404 	addi	r2,r2,-22704
 18221e8:	10c04415 	stw	r3,272(r2)
      UDP_STATS_INC(udp.drop);
 18221ec:	008061f4 	movhi	r2,391
 18221f0:	10a9d404 	addi	r2,r2,-22704
 18221f4:	10803f17 	ldw	r2,252(r2)
 18221f8:	10c00044 	addi	r3,r2,1
 18221fc:	008061f4 	movhi	r2,391
 1822200:	10a9d404 	addi	r2,r2,-22704
 1822204:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
 1822208:	e13ffe17 	ldw	r4,-8(fp)
 182220c:	181aca40 	call	181aca4 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 1822210:	00000206 	br	182221c <udp_input+0x568>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
 1822214:	e13ffe17 	ldw	r4,-8(fp)
 1822218:	181aca40 	call	181aca4 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
 182221c:	0001883a 	nop
 1822220:	e037883a 	mov	sp,fp
 1822224:	dfc00117 	ldw	ra,4(sp)
 1822228:	df000017 	ldw	fp,0(sp)
 182222c:	dec00204 	addi	sp,sp,8
 1822230:	f800283a 	ret

01822234 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 1822234:	defffc04 	addi	sp,sp,-16
 1822238:	dfc00315 	stw	ra,12(sp)
 182223c:	df000215 	stw	fp,8(sp)
 1822240:	df000204 	addi	fp,sp,8
 1822244:	e13ffe15 	stw	r4,-8(fp)
 1822248:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 182224c:	e0bffe17 	ldw	r2,-8(fp)
 1822250:	10c00104 	addi	r3,r2,4
 1822254:	e0bffe17 	ldw	r2,-8(fp)
 1822258:	1080050b 	ldhu	r2,20(r2)
 182225c:	10bfffcc 	andi	r2,r2,65535
 1822260:	100f883a 	mov	r7,r2
 1822264:	180d883a 	mov	r6,r3
 1822268:	e17fff17 	ldw	r5,-4(fp)
 182226c:	e13ffe17 	ldw	r4,-8(fp)
 1822270:	18222fc0 	call	18222fc <udp_sendto>
}
 1822274:	e037883a 	mov	sp,fp
 1822278:	dfc00117 	ldw	ra,4(sp)
 182227c:	df000017 	ldw	fp,0(sp)
 1822280:	dec00204 	addi	sp,sp,8
 1822284:	f800283a 	ret

01822288 <udp_send_chksum>:
/** Same as udp_send() but with checksum
 */
err_t
udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
                u8_t have_chksum, u16_t chksum)
{
 1822288:	defff804 	addi	sp,sp,-32
 182228c:	dfc00715 	stw	ra,28(sp)
 1822290:	df000615 	stw	fp,24(sp)
 1822294:	df000604 	addi	fp,sp,24
 1822298:	e13ffc15 	stw	r4,-16(fp)
 182229c:	e17ffd15 	stw	r5,-12(fp)
 18222a0:	3007883a 	mov	r3,r6
 18222a4:	3805883a 	mov	r2,r7
 18222a8:	e0fffe05 	stb	r3,-8(fp)
 18222ac:	e0bfff0d 	sth	r2,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 18222b0:	e0bffc17 	ldw	r2,-16(fp)
 18222b4:	11000104 	addi	r4,r2,4
 18222b8:	e0bffc17 	ldw	r2,-16(fp)
 18222bc:	1080050b 	ldhu	r2,20(r2)
 18222c0:	117fffcc 	andi	r5,r2,65535
 18222c4:	e0bffe03 	ldbu	r2,-8(fp)
 18222c8:	e0ffff0b 	ldhu	r3,-4(fp)
 18222cc:	d8c00115 	stw	r3,4(sp)
 18222d0:	d8800015 	stw	r2,0(sp)
 18222d4:	280f883a 	mov	r7,r5
 18222d8:	200d883a 	mov	r6,r4
 18222dc:	e17ffd17 	ldw	r5,-12(fp)
 18222e0:	e13ffc17 	ldw	r4,-16(fp)
 18222e4:	18223540 	call	1822354 <udp_sendto_chksum>
    have_chksum, chksum);
}
 18222e8:	e037883a 	mov	sp,fp
 18222ec:	dfc00117 	ldw	ra,4(sp)
 18222f0:	df000017 	ldw	fp,0(sp)
 18222f4:	dec00204 	addi	sp,sp,8
 18222f8:	f800283a 	ret

018222fc <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
 18222fc:	defff804 	addi	sp,sp,-32
 1822300:	dfc00715 	stw	ra,28(sp)
 1822304:	df000615 	stw	fp,24(sp)
 1822308:	df000604 	addi	fp,sp,24
 182230c:	e13ffc15 	stw	r4,-16(fp)
 1822310:	e17ffd15 	stw	r5,-12(fp)
 1822314:	e1bffe15 	stw	r6,-8(fp)
 1822318:	3805883a 	mov	r2,r7
 182231c:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 1822320:	e0bfff0b 	ldhu	r2,-4(fp)
 1822324:	d8000115 	stw	zero,4(sp)
 1822328:	d8000015 	stw	zero,0(sp)
 182232c:	100f883a 	mov	r7,r2
 1822330:	e1bffe17 	ldw	r6,-8(fp)
 1822334:	e17ffd17 	ldw	r5,-12(fp)
 1822338:	e13ffc17 	ldw	r4,-16(fp)
 182233c:	18223540 	call	1822354 <udp_sendto_chksum>
}
 1822340:	e037883a 	mov	sp,fp
 1822344:	dfc00117 	ldw	ra,4(sp)
 1822348:	df000017 	ldw	fp,0(sp)
 182234c:	dec00204 	addi	sp,sp,8
 1822350:	f800283a 	ret

01822354 <udp_sendto_chksum>:

/** Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 1822354:	defff404 	addi	sp,sp,-48
 1822358:	dfc00b15 	stw	ra,44(sp)
 182235c:	df000a15 	stw	fp,40(sp)
 1822360:	df000a04 	addi	fp,sp,40
 1822364:	e13ffa15 	stw	r4,-24(fp)
 1822368:	e17ffb15 	stw	r5,-20(fp)
 182236c:	e1bffc15 	stw	r6,-16(fp)
 1822370:	3809883a 	mov	r4,r7
 1822374:	e0c00217 	ldw	r3,8(fp)
 1822378:	e0800317 	ldw	r2,12(fp)
 182237c:	e13ffd0d 	sth	r4,-12(fp)
 1822380:	e0fffe05 	stb	r3,-8(fp)
 1822384:	e0bfff0d 	sth	r2,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(&(pcb->local_ip), dst_ip);
 1822388:	e0bffa17 	ldw	r2,-24(fp)
 182238c:	e17ffc17 	ldw	r5,-16(fp)
 1822390:	1009883a 	mov	r4,r2
 1822394:	18322400 	call	1832240 <ip_route>
 1822398:	e0bff915 	stw	r2,-28(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 182239c:	e0bff917 	ldw	r2,-28(fp)
 18223a0:	1000091e 	bne	r2,zero,18223c8 <udp_sendto_chksum+0x74>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
 18223a4:	008061f4 	movhi	r2,391
 18223a8:	10a9d404 	addi	r2,r2,-22704
 18223ac:	10804317 	ldw	r2,268(r2)
 18223b0:	10c00044 	addi	r3,r2,1
 18223b4:	008061f4 	movhi	r2,391
 18223b8:	10a9d404 	addi	r2,r2,-22704
 18223bc:	10c04315 	stw	r3,268(r2)
    return ERR_RTE;
 18223c0:	00bfff04 	movi	r2,-4
 18223c4:	00000c06 	br	18223f8 <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 18223c8:	e13ffd0b 	ldhu	r4,-12(fp)
 18223cc:	e0bffe03 	ldbu	r2,-8(fp)
 18223d0:	e0ffff0b 	ldhu	r3,-4(fp)
 18223d4:	d8c00215 	stw	r3,8(sp)
 18223d8:	d8800115 	stw	r2,4(sp)
 18223dc:	e0bff917 	ldw	r2,-28(fp)
 18223e0:	d8800015 	stw	r2,0(sp)
 18223e4:	200f883a 	mov	r7,r4
 18223e8:	e1bffc17 	ldw	r6,-16(fp)
 18223ec:	e17ffb17 	ldw	r5,-20(fp)
 18223f0:	e13ffa17 	ldw	r4,-24(fp)
 18223f4:	182246c0 	call	182246c <udp_sendto_if_chksum>
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY */
}
 18223f8:	e037883a 	mov	sp,fp
 18223fc:	dfc00117 	ldw	ra,4(sp)
 1822400:	df000017 	ldw	fp,0(sp)
 1822404:	dec00204 	addi	sp,sp,8
 1822408:	f800283a 	ret

0182240c <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 182240c:	defff704 	addi	sp,sp,-36
 1822410:	dfc00815 	stw	ra,32(sp)
 1822414:	df000715 	stw	fp,28(sp)
 1822418:	df000704 	addi	fp,sp,28
 182241c:	e13ffc15 	stw	r4,-16(fp)
 1822420:	e17ffd15 	stw	r5,-12(fp)
 1822424:	e1bffe15 	stw	r6,-8(fp)
 1822428:	3805883a 	mov	r2,r7
 182242c:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 1822430:	e0ffff0b 	ldhu	r3,-4(fp)
 1822434:	d8000215 	stw	zero,8(sp)
 1822438:	d8000115 	stw	zero,4(sp)
 182243c:	e0800217 	ldw	r2,8(fp)
 1822440:	d8800015 	stw	r2,0(sp)
 1822444:	180f883a 	mov	r7,r3
 1822448:	e1bffe17 	ldw	r6,-8(fp)
 182244c:	e17ffd17 	ldw	r5,-12(fp)
 1822450:	e13ffc17 	ldw	r4,-16(fp)
 1822454:	182246c0 	call	182246c <udp_sendto_if_chksum>
}
 1822458:	e037883a 	mov	sp,fp
 182245c:	dfc00117 	ldw	ra,4(sp)
 1822460:	df000017 	ldw	fp,0(sp)
 1822464:	dec00204 	addi	sp,sp,8
 1822468:	f800283a 	ret

0182246c <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 182246c:	defff004 	addi	sp,sp,-64
 1822470:	dfc00f15 	stw	ra,60(sp)
 1822474:	df000e15 	stw	fp,56(sp)
 1822478:	df000e04 	addi	fp,sp,56
 182247c:	e13ffa15 	stw	r4,-24(fp)
 1822480:	e17ffb15 	stw	r5,-20(fp)
 1822484:	e1bffc15 	stw	r6,-16(fp)
 1822488:	3809883a 	mov	r4,r7
 182248c:	e0c00317 	ldw	r3,12(fp)
 1822490:	e0800417 	ldw	r2,16(fp)
 1822494:	e13ffd0d 	sth	r4,-12(fp)
 1822498:	e0fffe05 	stb	r3,-8(fp)
 182249c:	e0bfff0d 	sth	r2,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 18224a0:	e0bffa17 	ldw	r2,-24(fp)
 18224a4:	1080048b 	ldhu	r2,18(r2)
 18224a8:	10bfffcc 	andi	r2,r2,65535
 18224ac:	10000d1e 	bne	r2,zero,18224e4 <udp_sendto_if_chksum+0x78>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 18224b0:	e0fffa17 	ldw	r3,-24(fp)
 18224b4:	e0bffa17 	ldw	r2,-24(fp)
 18224b8:	1080048b 	ldhu	r2,18(r2)
 18224bc:	10bfffcc 	andi	r2,r2,65535
 18224c0:	100d883a 	mov	r6,r2
 18224c4:	180b883a 	mov	r5,r3
 18224c8:	e13ffa17 	ldw	r4,-24(fp)
 18224cc:	18228c00 	call	18228c0 <udp_bind>
 18224d0:	e0bff785 	stb	r2,-34(fp)
    if (err != ERR_OK) {
 18224d4:	e0bff787 	ldb	r2,-34(fp)
 18224d8:	10000226 	beq	r2,zero,18224e4 <udp_sendto_if_chksum+0x78>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 18224dc:	e0bff783 	ldbu	r2,-34(fp)
 18224e0:	0000f206 	br	18228ac <udp_sendto_if_chksum+0x440>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 18224e4:	01400204 	movi	r5,8
 18224e8:	e13ffb17 	ldw	r4,-20(fp)
 18224ec:	181aaf40 	call	181aaf4 <pbuf_header>
 18224f0:	10803fcc 	andi	r2,r2,255
 18224f4:	10001126 	beq	r2,zero,182253c <udp_sendto_if_chksum+0xd0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 18224f8:	000d883a 	mov	r6,zero
 18224fc:	01400204 	movi	r5,8
 1822500:	01000044 	movi	r4,1
 1822504:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1822508:	e0bff615 	stw	r2,-40(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 182250c:	e0bff617 	ldw	r2,-40(fp)
 1822510:	1000021e 	bne	r2,zero,182251c <udp_sendto_if_chksum+0xb0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 1822514:	00bfffc4 	movi	r2,-1
 1822518:	0000e406 	br	18228ac <udp_sendto_if_chksum+0x440>
    }
    if (p->tot_len != 0) {
 182251c:	e0bffb17 	ldw	r2,-20(fp)
 1822520:	1080020b 	ldhu	r2,8(r2)
 1822524:	10bfffcc 	andi	r2,r2,65535
 1822528:	10000626 	beq	r2,zero,1822544 <udp_sendto_if_chksum+0xd8>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 182252c:	e17ffb17 	ldw	r5,-20(fp)
 1822530:	e13ff617 	ldw	r4,-40(fp)
 1822534:	181af6c0 	call	181af6c <pbuf_chain>
 1822538:	00000206 	br	1822544 <udp_sendto_if_chksum+0xd8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 182253c:	e0bffb17 	ldw	r2,-20(fp)
 1822540:	e0bff615 	stw	r2,-40(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 1822544:	e0bff617 	ldw	r2,-40(fp)
 1822548:	10800117 	ldw	r2,4(r2)
 182254c:	e0bff815 	stw	r2,-32(fp)
  udphdr->src = htons(pcb->local_port);
 1822550:	e0bffa17 	ldw	r2,-24(fp)
 1822554:	1080048b 	ldhu	r2,18(r2)
 1822558:	10bfffcc 	andi	r2,r2,65535
 182255c:	1004d23a 	srli	r2,r2,8
 1822560:	1007883a 	mov	r3,r2
 1822564:	e0bffa17 	ldw	r2,-24(fp)
 1822568:	1080048b 	ldhu	r2,18(r2)
 182256c:	10bfffcc 	andi	r2,r2,65535
 1822570:	1004923a 	slli	r2,r2,8
 1822574:	1884b03a 	or	r2,r3,r2
 1822578:	100d883a 	mov	r6,r2
 182257c:	e0bff817 	ldw	r2,-32(fp)
 1822580:	30ffffcc 	andi	r3,r6,65535
 1822584:	19403fcc 	andi	r5,r3,255
 1822588:	10c00003 	ldbu	r3,0(r2)
 182258c:	1806703a 	and	r3,r3,zero
 1822590:	1809883a 	mov	r4,r3
 1822594:	2807883a 	mov	r3,r5
 1822598:	20c6b03a 	or	r3,r4,r3
 182259c:	10c00005 	stb	r3,0(r2)
 18225a0:	30ffffcc 	andi	r3,r6,65535
 18225a4:	1806d23a 	srli	r3,r3,8
 18225a8:	197fffcc 	andi	r5,r3,65535
 18225ac:	10c00043 	ldbu	r3,1(r2)
 18225b0:	1806703a 	and	r3,r3,zero
 18225b4:	1809883a 	mov	r4,r3
 18225b8:	2807883a 	mov	r3,r5
 18225bc:	20c6b03a 	or	r3,r4,r3
 18225c0:	10c00045 	stb	r3,1(r2)
  udphdr->dest = htons(dst_port);
 18225c4:	e0bffd0b 	ldhu	r2,-12(fp)
 18225c8:	1004d23a 	srli	r2,r2,8
 18225cc:	1007883a 	mov	r3,r2
 18225d0:	e0bffd0b 	ldhu	r2,-12(fp)
 18225d4:	1004923a 	slli	r2,r2,8
 18225d8:	1884b03a 	or	r2,r3,r2
 18225dc:	100d883a 	mov	r6,r2
 18225e0:	e0bff817 	ldw	r2,-32(fp)
 18225e4:	30ffffcc 	andi	r3,r6,65535
 18225e8:	19403fcc 	andi	r5,r3,255
 18225ec:	10c00083 	ldbu	r3,2(r2)
 18225f0:	1806703a 	and	r3,r3,zero
 18225f4:	1809883a 	mov	r4,r3
 18225f8:	2807883a 	mov	r3,r5
 18225fc:	20c6b03a 	or	r3,r4,r3
 1822600:	10c00085 	stb	r3,2(r2)
 1822604:	30ffffcc 	andi	r3,r6,65535
 1822608:	1806d23a 	srli	r3,r3,8
 182260c:	197fffcc 	andi	r5,r3,65535
 1822610:	10c000c3 	ldbu	r3,3(r2)
 1822614:	1806703a 	and	r3,r3,zero
 1822618:	1809883a 	mov	r4,r3
 182261c:	2807883a 	mov	r3,r5
 1822620:	20c6b03a 	or	r3,r4,r3
 1822624:	10c000c5 	stb	r3,3(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 1822628:	e0bff817 	ldw	r2,-32(fp)
 182262c:	10c00183 	ldbu	r3,6(r2)
 1822630:	1806703a 	and	r3,r3,zero
 1822634:	10c00185 	stb	r3,6(r2)
 1822638:	10c001c3 	ldbu	r3,7(r2)
 182263c:	1806703a 	and	r3,r3,zero
 1822640:	10c001c5 	stb	r3,7(r2)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 1822644:	e0bffa17 	ldw	r2,-24(fp)
 1822648:	10000326 	beq	r2,zero,1822658 <udp_sendto_if_chksum+0x1ec>
 182264c:	e0bffa17 	ldw	r2,-24(fp)
 1822650:	10800017 	ldw	r2,0(r2)
 1822654:	1000041e 	bne	r2,zero,1822668 <udp_sendto_if_chksum+0x1fc>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 1822658:	e0800217 	ldw	r2,8(fp)
 182265c:	10800104 	addi	r2,r2,4
 1822660:	e0bff515 	stw	r2,-44(fp)
 1822664:	00000f06 	br	18226a4 <udp_sendto_if_chksum+0x238>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 1822668:	e0bffa17 	ldw	r2,-24(fp)
 182266c:	10c00017 	ldw	r3,0(r2)
 1822670:	e0800217 	ldw	r2,8(fp)
 1822674:	10800117 	ldw	r2,4(r2)
 1822678:	18800826 	beq	r3,r2,182269c <udp_sendto_if_chksum+0x230>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 182267c:	e0fff617 	ldw	r3,-40(fp)
 1822680:	e0bffb17 	ldw	r2,-20(fp)
 1822684:	18800326 	beq	r3,r2,1822694 <udp_sendto_if_chksum+0x228>
        /* free the header pbuf */
        pbuf_free(q);
 1822688:	e13ff617 	ldw	r4,-40(fp)
 182268c:	181aca40 	call	181aca4 <pbuf_free>
        q = NULL;
 1822690:	e03ff615 	stw	zero,-40(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 1822694:	00bffe84 	movi	r2,-6
 1822698:	00008406 	br	18228ac <udp_sendto_if_chksum+0x440>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 182269c:	e0bffa17 	ldw	r2,-24(fp)
 18226a0:	e0bff515 	stw	r2,-44(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 18226a4:	e0bff617 	ldw	r2,-40(fp)
 18226a8:	1080020b 	ldhu	r2,8(r2)
 18226ac:	10bfffcc 	andi	r2,r2,65535
 18226b0:	1004d23a 	srli	r2,r2,8
 18226b4:	1007883a 	mov	r3,r2
 18226b8:	e0bff617 	ldw	r2,-40(fp)
 18226bc:	1080020b 	ldhu	r2,8(r2)
 18226c0:	10bfffcc 	andi	r2,r2,65535
 18226c4:	1004923a 	slli	r2,r2,8
 18226c8:	1884b03a 	or	r2,r3,r2
 18226cc:	100d883a 	mov	r6,r2
 18226d0:	e0bff817 	ldw	r2,-32(fp)
 18226d4:	30ffffcc 	andi	r3,r6,65535
 18226d8:	19403fcc 	andi	r5,r3,255
 18226dc:	10c00103 	ldbu	r3,4(r2)
 18226e0:	1806703a 	and	r3,r3,zero
 18226e4:	1809883a 	mov	r4,r3
 18226e8:	2807883a 	mov	r3,r5
 18226ec:	20c6b03a 	or	r3,r4,r3
 18226f0:	10c00105 	stb	r3,4(r2)
 18226f4:	30ffffcc 	andi	r3,r6,65535
 18226f8:	1806d23a 	srli	r3,r3,8
 18226fc:	197fffcc 	andi	r5,r3,65535
 1822700:	10c00143 	ldbu	r3,5(r2)
 1822704:	1806703a 	and	r3,r3,zero
 1822708:	1809883a 	mov	r4,r3
 182270c:	2807883a 	mov	r3,r5
 1822710:	20c6b03a 	or	r3,r4,r3
 1822714:	10c00145 	stb	r3,5(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 1822718:	e0bffa17 	ldw	r2,-24(fp)
 182271c:	10800403 	ldbu	r2,16(r2)
 1822720:	10803fcc 	andi	r2,r2,255
 1822724:	1080004c 	andi	r2,r2,1
 1822728:	10003b1e 	bne	r2,zero,1822818 <udp_sendto_if_chksum+0x3ac>
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
 182272c:	e0bffe03 	ldbu	r2,-8(fp)
 1822730:	10001926 	beq	r2,zero,1822798 <udp_sendto_if_chksum+0x32c>
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
          q->tot_len, UDP_HLEN);
 1822734:	e0bff617 	ldw	r2,-40(fp)
 1822738:	1080020b 	ldhu	r2,8(r2)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
 182273c:	10bfffcc 	andi	r2,r2,65535
 1822740:	00c00204 	movi	r3,8
 1822744:	d8c00115 	stw	r3,4(sp)
 1822748:	d8800015 	stw	r2,0(sp)
 182274c:	01c00444 	movi	r7,17
 1822750:	e1bffc17 	ldw	r6,-16(fp)
 1822754:	e17ff517 	ldw	r5,-44(fp)
 1822758:	e13ff617 	ldw	r4,-40(fp)
 182275c:	1831e600 	call	1831e60 <inet_chksum_pseudo_partial>
 1822760:	e0bff70d 	sth	r2,-36(fp)
          q->tot_len, UDP_HLEN);
        acc = udpchksum + (u16_t)~(chksum);
 1822764:	e0fff70b 	ldhu	r3,-36(fp)
 1822768:	e0bfff0b 	ldhu	r2,-4(fp)
 182276c:	0084303a 	nor	r2,zero,r2
 1822770:	10bfffcc 	andi	r2,r2,65535
 1822774:	1885883a 	add	r2,r3,r2
 1822778:	e0bff915 	stw	r2,-28(fp)
        udpchksum = FOLD_U32T(acc);
 182277c:	e0bff917 	ldw	r2,-28(fp)
 1822780:	1004d43a 	srli	r2,r2,16
 1822784:	1007883a 	mov	r3,r2
 1822788:	e0bff917 	ldw	r2,-28(fp)
 182278c:	1885883a 	add	r2,r3,r2
 1822790:	e0bff70d 	sth	r2,-36(fp)
 1822794:	00000a06 	br	18227c0 <udp_sendto_if_chksum+0x354>
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 1822798:	e0bff617 	ldw	r2,-40(fp)
 182279c:	1080020b 	ldhu	r2,8(r2)
 18227a0:	10bfffcc 	andi	r2,r2,65535
 18227a4:	d8800015 	stw	r2,0(sp)
 18227a8:	01c00444 	movi	r7,17
 18227ac:	e1bffc17 	ldw	r6,-16(fp)
 18227b0:	e17ff517 	ldw	r5,-44(fp)
 18227b4:	e13ff617 	ldw	r4,-40(fp)
 18227b8:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 18227bc:	e0bff70d 	sth	r2,-36(fp)
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
 18227c0:	e0bff70b 	ldhu	r2,-36(fp)
 18227c4:	1000021e 	bne	r2,zero,18227d0 <udp_sendto_if_chksum+0x364>
        udpchksum = 0xffff;
 18227c8:	00bfffc4 	movi	r2,-1
 18227cc:	e0bff70d 	sth	r2,-36(fp)
      }
      udphdr->chksum = udpchksum;
 18227d0:	e0bff817 	ldw	r2,-32(fp)
 18227d4:	e0fff70b 	ldhu	r3,-36(fp)
 18227d8:	19403fcc 	andi	r5,r3,255
 18227dc:	10c00183 	ldbu	r3,6(r2)
 18227e0:	1806703a 	and	r3,r3,zero
 18227e4:	1809883a 	mov	r4,r3
 18227e8:	2807883a 	mov	r3,r5
 18227ec:	20c6b03a 	or	r3,r4,r3
 18227f0:	10c00185 	stb	r3,6(r2)
 18227f4:	e0fff70b 	ldhu	r3,-36(fp)
 18227f8:	1806d23a 	srli	r3,r3,8
 18227fc:	197fffcc 	andi	r5,r3,65535
 1822800:	10c001c3 	ldbu	r3,7(r2)
 1822804:	1806703a 	and	r3,r3,zero
 1822808:	1809883a 	mov	r4,r3
 182280c:	2807883a 	mov	r3,r5
 1822810:	20c6b03a 	or	r3,r4,r3
 1822814:	10c001c5 	stb	r3,7(r2)
    }
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 1822818:	e0bffa17 	ldw	r2,-24(fp)
 182281c:	10c002c4 	addi	r3,r2,11
 1822820:	e0800217 	ldw	r2,8(fp)
 1822824:	10c01015 	stw	r3,64(r2)
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 1822828:	e0bffa17 	ldw	r2,-24(fp)
 182282c:	10800283 	ldbu	r2,10(r2)
 1822830:	11003fcc 	andi	r4,r2,255
 1822834:	e0bffa17 	ldw	r2,-24(fp)
 1822838:	10800243 	ldbu	r2,9(r2)
 182283c:	10803fcc 	andi	r2,r2,255
 1822840:	e0c00217 	ldw	r3,8(fp)
 1822844:	d8c00215 	stw	r3,8(sp)
 1822848:	00c00444 	movi	r3,17
 182284c:	d8c00115 	stw	r3,4(sp)
 1822850:	d8800015 	stw	r2,0(sp)
 1822854:	200f883a 	mov	r7,r4
 1822858:	e1bffc17 	ldw	r6,-16(fp)
 182285c:	e17ff517 	ldw	r5,-44(fp)
 1822860:	e13ff617 	ldw	r4,-40(fp)
 1822864:	183286c0 	call	183286c <ip_output_if>
 1822868:	e0bff785 	stb	r2,-34(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
 182286c:	e0800217 	ldw	r2,8(fp)
 1822870:	10001015 	stw	zero,64(r2)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 1822874:	e0fff617 	ldw	r3,-40(fp)
 1822878:	e0bffb17 	ldw	r2,-20(fp)
 182287c:	18800326 	beq	r3,r2,182288c <udp_sendto_if_chksum+0x420>
    /* free the header pbuf */
    pbuf_free(q);
 1822880:	e13ff617 	ldw	r4,-40(fp)
 1822884:	181aca40 	call	181aca4 <pbuf_free>
    q = NULL;
 1822888:	e03ff615 	stw	zero,-40(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
 182288c:	008061f4 	movhi	r2,391
 1822890:	10a9d404 	addi	r2,r2,-22704
 1822894:	10803c17 	ldw	r2,240(r2)
 1822898:	10c00044 	addi	r3,r2,1
 182289c:	008061f4 	movhi	r2,391
 18228a0:	10a9d404 	addi	r2,r2,-22704
 18228a4:	10c03c15 	stw	r3,240(r2)
  return err;
 18228a8:	e0bff783 	ldbu	r2,-34(fp)
}
 18228ac:	e037883a 	mov	sp,fp
 18228b0:	dfc00117 	ldw	ra,4(sp)
 18228b4:	df000017 	ldw	fp,0(sp)
 18228b8:	dec00204 	addi	sp,sp,8
 18228bc:	f800283a 	ret

018228c0 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 18228c0:	defff904 	addi	sp,sp,-28
 18228c4:	dfc00615 	stw	ra,24(sp)
 18228c8:	df000515 	stw	fp,20(sp)
 18228cc:	df000504 	addi	fp,sp,20
 18228d0:	e13ffd15 	stw	r4,-12(fp)
 18228d4:	e17ffe15 	stw	r5,-8(fp)
 18228d8:	3005883a 	mov	r2,r6
 18228dc:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 18228e0:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 18228e4:	d0a7ff17 	ldw	r2,-24580(gp)
 18228e8:	e0bffb15 	stw	r2,-20(fp)
 18228ec:	00002906 	br	1822994 <udp_bind+0xd4>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 18228f0:	e0fffd17 	ldw	r3,-12(fp)
 18228f4:	e0bffb17 	ldw	r2,-20(fp)
 18228f8:	1880031e 	bne	r3,r2,1822908 <udp_bind+0x48>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 18228fc:	00800044 	movi	r2,1
 1822900:	e0bffc05 	stb	r2,-16(fp)
 1822904:	00002006 	br	1822988 <udp_bind+0xc8>

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
 1822908:	e0bffd17 	ldw	r2,-12(fp)
 182290c:	10800203 	ldbu	r2,8(r2)
 1822910:	10803fcc 	andi	r2,r2,255
 1822914:	1080010c 	andi	r2,r2,4
 1822918:	10001b1e 	bne	r2,zero,1822988 <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
 182291c:	e0bffb17 	ldw	r2,-20(fp)
 1822920:	10800203 	ldbu	r2,8(r2)
 1822924:	10803fcc 	andi	r2,r2,255
 1822928:	1080010c 	andi	r2,r2,4

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
 182292c:	1000161e 	bne	r2,zero,1822988 <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 1822930:	e0bffb17 	ldw	r2,-20(fp)
 1822934:	1080048b 	ldhu	r2,18(r2)
 1822938:	10ffffcc 	andi	r3,r2,65535
 182293c:	e0bfff0b 	ldhu	r2,-4(fp)
 1822940:	1880111e 	bne	r3,r2,1822988 <udp_bind+0xc8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 1822944:	e0bffb17 	ldw	r2,-20(fp)
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 1822948:	10000d26 	beq	r2,zero,1822980 <udp_bind+0xc0>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 182294c:	e0bffb17 	ldw	r2,-20(fp)
 1822950:	10800017 	ldw	r2,0(r2)
 1822954:	10000a26 	beq	r2,zero,1822980 <udp_bind+0xc0>
 1822958:	e0bffe17 	ldw	r2,-8(fp)
 182295c:	10000826 	beq	r2,zero,1822980 <udp_bind+0xc0>
           ip_addr_isany(ipaddr) ||
 1822960:	e0bffe17 	ldw	r2,-8(fp)
 1822964:	10800017 	ldw	r2,0(r2)
 1822968:	10000526 	beq	r2,zero,1822980 <udp_bind+0xc0>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
 182296c:	e0bffb17 	ldw	r2,-20(fp)
 1822970:	10c00017 	ldw	r3,0(r2)
 1822974:	e0bffe17 	ldw	r2,-8(fp)
 1822978:	10800017 	ldw	r2,0(r2)
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
 182297c:	1880021e 	bne	r3,r2,1822988 <udp_bind+0xc8>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 1822980:	00bffe04 	movi	r2,-8
 1822984:	00002006 	br	1822a08 <udp_bind+0x148>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1822988:	e0bffb17 	ldw	r2,-20(fp)
 182298c:	10800317 	ldw	r2,12(r2)
 1822990:	e0bffb15 	stw	r2,-20(fp)
 1822994:	e0bffb17 	ldw	r2,-20(fp)
 1822998:	103fd51e 	bne	r2,zero,18228f0 <__ram_exceptions_end+0xff8124ac>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 182299c:	e0bffe17 	ldw	r2,-8(fp)
 18229a0:	10000326 	beq	r2,zero,18229b0 <udp_bind+0xf0>
 18229a4:	e0bffe17 	ldw	r2,-8(fp)
 18229a8:	10800017 	ldw	r2,0(r2)
 18229ac:	00000106 	br	18229b4 <udp_bind+0xf4>
 18229b0:	0005883a 	mov	r2,zero
 18229b4:	e0fffd17 	ldw	r3,-12(fp)
 18229b8:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
 18229bc:	e0bfff0b 	ldhu	r2,-4(fp)
 18229c0:	1000061e 	bne	r2,zero,18229dc <udp_bind+0x11c>
    port = udp_new_port();
 18229c4:	1821c180 	call	1821c18 <udp_new_port>
 18229c8:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 18229cc:	e0bfff0b 	ldhu	r2,-4(fp)
 18229d0:	1000021e 	bne	r2,zero,18229dc <udp_bind+0x11c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 18229d4:	00bffe04 	movi	r2,-8
 18229d8:	00000b06 	br	1822a08 <udp_bind+0x148>
    }
  }
  pcb->local_port = port;
 18229dc:	e0bffd17 	ldw	r2,-12(fp)
 18229e0:	e0ffff0b 	ldhu	r3,-4(fp)
 18229e4:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 18229e8:	e0bffc03 	ldbu	r2,-16(fp)
 18229ec:	1000051e 	bne	r2,zero,1822a04 <udp_bind+0x144>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 18229f0:	d0e7ff17 	ldw	r3,-24580(gp)
 18229f4:	e0bffd17 	ldw	r2,-12(fp)
 18229f8:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
 18229fc:	e0bffd17 	ldw	r2,-12(fp)
 1822a00:	d0a7ff15 	stw	r2,-24580(gp)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 1822a04:	0005883a 	mov	r2,zero
}
 1822a08:	e037883a 	mov	sp,fp
 1822a0c:	dfc00117 	ldw	ra,4(sp)
 1822a10:	df000017 	ldw	fp,0(sp)
 1822a14:	dec00204 	addi	sp,sp,8
 1822a18:	f800283a 	ret

01822a1c <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 1822a1c:	defff904 	addi	sp,sp,-28
 1822a20:	dfc00615 	stw	ra,24(sp)
 1822a24:	df000515 	stw	fp,20(sp)
 1822a28:	df000504 	addi	fp,sp,20
 1822a2c:	e13ffd15 	stw	r4,-12(fp)
 1822a30:	e17ffe15 	stw	r5,-8(fp)
 1822a34:	3005883a 	mov	r2,r6
 1822a38:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 1822a3c:	e0bffd17 	ldw	r2,-12(fp)
 1822a40:	1080048b 	ldhu	r2,18(r2)
 1822a44:	10bfffcc 	andi	r2,r2,65535
 1822a48:	10000d1e 	bne	r2,zero,1822a80 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 1822a4c:	e0fffd17 	ldw	r3,-12(fp)
 1822a50:	e0bffd17 	ldw	r2,-12(fp)
 1822a54:	1080048b 	ldhu	r2,18(r2)
 1822a58:	10bfffcc 	andi	r2,r2,65535
 1822a5c:	100d883a 	mov	r6,r2
 1822a60:	180b883a 	mov	r5,r3
 1822a64:	e13ffd17 	ldw	r4,-12(fp)
 1822a68:	18228c00 	call	18228c0 <udp_bind>
 1822a6c:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 1822a70:	e0bffc07 	ldb	r2,-16(fp)
 1822a74:	10000226 	beq	r2,zero,1822a80 <udp_connect+0x64>
      return err;
 1822a78:	e0bffc03 	ldbu	r2,-16(fp)
 1822a7c:	00002406 	br	1822b10 <udp_connect+0xf4>
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 1822a80:	e0bffe17 	ldw	r2,-8(fp)
 1822a84:	10000326 	beq	r2,zero,1822a94 <udp_connect+0x78>
 1822a88:	e0bffe17 	ldw	r2,-8(fp)
 1822a8c:	10800017 	ldw	r2,0(r2)
 1822a90:	00000106 	br	1822a98 <udp_connect+0x7c>
 1822a94:	0005883a 	mov	r2,zero
 1822a98:	e0fffd17 	ldw	r3,-12(fp)
 1822a9c:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
 1822aa0:	e0bffd17 	ldw	r2,-12(fp)
 1822aa4:	e0ffff0b 	ldhu	r3,-4(fp)
 1822aa8:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
 1822aac:	e0bffd17 	ldw	r2,-12(fp)
 1822ab0:	10800403 	ldbu	r2,16(r2)
 1822ab4:	10800114 	ori	r2,r2,4
 1822ab8:	1007883a 	mov	r3,r2
 1822abc:	e0bffd17 	ldw	r2,-12(fp)
 1822ac0:	10c00405 	stb	r3,16(r2)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1822ac4:	d0a7ff17 	ldw	r2,-24580(gp)
 1822ac8:	e0bffb15 	stw	r2,-20(fp)
 1822acc:	00000806 	br	1822af0 <udp_connect+0xd4>
    if (pcb == ipcb) {
 1822ad0:	e0fffd17 	ldw	r3,-12(fp)
 1822ad4:	e0bffb17 	ldw	r2,-20(fp)
 1822ad8:	1880021e 	bne	r3,r2,1822ae4 <udp_connect+0xc8>
      /* already on the list, just return */
      return ERR_OK;
 1822adc:	0005883a 	mov	r2,zero
 1822ae0:	00000b06 	br	1822b10 <udp_connect+0xf4>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 1822ae4:	e0bffb17 	ldw	r2,-20(fp)
 1822ae8:	10800317 	ldw	r2,12(r2)
 1822aec:	e0bffb15 	stw	r2,-20(fp)
 1822af0:	e0bffb17 	ldw	r2,-20(fp)
 1822af4:	103ff61e 	bne	r2,zero,1822ad0 <__ram_exceptions_end+0xff81268c>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 1822af8:	d0e7ff17 	ldw	r3,-24580(gp)
 1822afc:	e0bffd17 	ldw	r2,-12(fp)
 1822b00:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
 1822b04:	e0bffd17 	ldw	r2,-12(fp)
 1822b08:	d0a7ff15 	stw	r2,-24580(gp)
  return ERR_OK;
 1822b0c:	0005883a 	mov	r2,zero
}
 1822b10:	e037883a 	mov	sp,fp
 1822b14:	dfc00117 	ldw	ra,4(sp)
 1822b18:	df000017 	ldw	fp,0(sp)
 1822b1c:	dec00204 	addi	sp,sp,8
 1822b20:	f800283a 	ret

01822b24 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 1822b24:	defffe04 	addi	sp,sp,-8
 1822b28:	df000115 	stw	fp,4(sp)
 1822b2c:	df000104 	addi	fp,sp,4
 1822b30:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
 1822b34:	e0bfff17 	ldw	r2,-4(fp)
 1822b38:	10000115 	stw	zero,4(r2)
  pcb->remote_port = 0;
 1822b3c:	e0bfff17 	ldw	r2,-4(fp)
 1822b40:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 1822b44:	e0bfff17 	ldw	r2,-4(fp)
 1822b48:	10c00403 	ldbu	r3,16(r2)
 1822b4c:	00bffec4 	movi	r2,-5
 1822b50:	1884703a 	and	r2,r3,r2
 1822b54:	1007883a 	mov	r3,r2
 1822b58:	e0bfff17 	ldw	r2,-4(fp)
 1822b5c:	10c00405 	stb	r3,16(r2)
}
 1822b60:	0001883a 	nop
 1822b64:	e037883a 	mov	sp,fp
 1822b68:	df000017 	ldw	fp,0(sp)
 1822b6c:	dec00104 	addi	sp,sp,4
 1822b70:	f800283a 	ret

01822b74 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 1822b74:	defffc04 	addi	sp,sp,-16
 1822b78:	df000315 	stw	fp,12(sp)
 1822b7c:	df000304 	addi	fp,sp,12
 1822b80:	e13ffd15 	stw	r4,-12(fp)
 1822b84:	e17ffe15 	stw	r5,-8(fp)
 1822b88:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
 1822b8c:	e0bffd17 	ldw	r2,-12(fp)
 1822b90:	e0fffe17 	ldw	r3,-8(fp)
 1822b94:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
 1822b98:	e0bffd17 	ldw	r2,-12(fp)
 1822b9c:	e0ffff17 	ldw	r3,-4(fp)
 1822ba0:	10c00715 	stw	r3,28(r2)
}
 1822ba4:	0001883a 	nop
 1822ba8:	e037883a 	mov	sp,fp
 1822bac:	df000017 	ldw	fp,0(sp)
 1822bb0:	dec00104 	addi	sp,sp,4
 1822bb4:	f800283a 	ret

01822bb8 <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 1822bb8:	defffc04 	addi	sp,sp,-16
 1822bbc:	dfc00315 	stw	ra,12(sp)
 1822bc0:	df000215 	stw	fp,8(sp)
 1822bc4:	df000204 	addi	fp,sp,8
 1822bc8:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 1822bcc:	d0e7ff17 	ldw	r3,-24580(gp)
 1822bd0:	e0bfff17 	ldw	r2,-4(fp)
 1822bd4:	1880041e 	bne	r3,r2,1822be8 <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 1822bd8:	d0a7ff17 	ldw	r2,-24580(gp)
 1822bdc:	10800317 	ldw	r2,12(r2)
 1822be0:	d0a7ff15 	stw	r2,-24580(gp)
 1822be4:	00001306 	br	1822c34 <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1822be8:	d0a7ff17 	ldw	r2,-24580(gp)
 1822bec:	e0bffe15 	stw	r2,-8(fp)
 1822bf0:	00000e06 	br	1822c2c <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 1822bf4:	e0bffe17 	ldw	r2,-8(fp)
 1822bf8:	10800317 	ldw	r2,12(r2)
 1822bfc:	10000826 	beq	r2,zero,1822c20 <udp_remove+0x68>
 1822c00:	e0bffe17 	ldw	r2,-8(fp)
 1822c04:	10c00317 	ldw	r3,12(r2)
 1822c08:	e0bfff17 	ldw	r2,-4(fp)
 1822c0c:	1880041e 	bne	r3,r2,1822c20 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 1822c10:	e0bfff17 	ldw	r2,-4(fp)
 1822c14:	10c00317 	ldw	r3,12(r2)
 1822c18:	e0bffe17 	ldw	r2,-8(fp)
 1822c1c:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1822c20:	e0bffe17 	ldw	r2,-8(fp)
 1822c24:	10800317 	ldw	r2,12(r2)
 1822c28:	e0bffe15 	stw	r2,-8(fp)
 1822c2c:	e0bffe17 	ldw	r2,-8(fp)
 1822c30:	103ff01e 	bne	r2,zero,1822bf4 <__ram_exceptions_end+0xff8127b0>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 1822c34:	e17fff17 	ldw	r5,-4(fp)
 1822c38:	01000044 	movi	r4,1
 1822c3c:	1834b240 	call	1834b24 <memp_free>
}
 1822c40:	0001883a 	nop
 1822c44:	e037883a 	mov	sp,fp
 1822c48:	dfc00117 	ldw	ra,4(sp)
 1822c4c:	df000017 	ldw	fp,0(sp)
 1822c50:	dec00204 	addi	sp,sp,8
 1822c54:	f800283a 	ret

01822c58 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 1822c58:	defffd04 	addi	sp,sp,-12
 1822c5c:	dfc00215 	stw	ra,8(sp)
 1822c60:	df000115 	stw	fp,4(sp)
 1822c64:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 1822c68:	01000044 	movi	r4,1
 1822c6c:	18349580 	call	1834958 <memp_malloc>
 1822c70:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 1822c74:	e0bfff17 	ldw	r2,-4(fp)
 1822c78:	10000726 	beq	r2,zero,1822c98 <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 1822c7c:	01800804 	movi	r6,32
 1822c80:	000b883a 	mov	r5,zero
 1822c84:	e13fff17 	ldw	r4,-4(fp)
 1822c88:	18061d40 	call	18061d4 <memset>
    pcb->ttl = UDP_TTL;
 1822c8c:	e0bfff17 	ldw	r2,-4(fp)
 1822c90:	00c01004 	movi	r3,64
 1822c94:	10c00285 	stb	r3,10(r2)
  }
  return pcb;
 1822c98:	e0bfff17 	ldw	r2,-4(fp)
}
 1822c9c:	e037883a 	mov	sp,fp
 1822ca0:	dfc00117 	ldw	ra,4(sp)
 1822ca4:	df000017 	ldw	fp,0(sp)
 1822ca8:	dec00204 	addi	sp,sp,8
 1822cac:	f800283a 	ret

01822cb0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 1822cb0:	defffc04 	addi	sp,sp,-16
 1822cb4:	dfc00315 	stw	ra,12(sp)
 1822cb8:	df000215 	stw	fp,8(sp)
 1822cbc:	df000204 	addi	fp,sp,8
 1822cc0:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 1822cc4:	00000c06 	br	1822cf8 <free_etharp_q+0x48>
    r = q;
 1822cc8:	e0bfff17 	ldw	r2,-4(fp)
 1822ccc:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
 1822cd0:	e0bfff17 	ldw	r2,-4(fp)
 1822cd4:	10800017 	ldw	r2,0(r2)
 1822cd8:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
 1822cdc:	e0bffe17 	ldw	r2,-8(fp)
 1822ce0:	10800117 	ldw	r2,4(r2)
 1822ce4:	1009883a 	mov	r4,r2
 1822ce8:	181aca40 	call	181aca4 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 1822cec:	e17ffe17 	ldw	r5,-8(fp)
 1822cf0:	010002c4 	movi	r4,11
 1822cf4:	1834b240 	call	1834b24 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 1822cf8:	e0bfff17 	ldw	r2,-4(fp)
 1822cfc:	103ff21e 	bne	r2,zero,1822cc8 <__ram_exceptions_end+0xff812884>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
 1822d00:	0001883a 	nop
 1822d04:	e037883a 	mov	sp,fp
 1822d08:	dfc00117 	ldw	ra,4(sp)
 1822d0c:	df000017 	ldw	fp,0(sp)
 1822d10:	dec00204 	addi	sp,sp,8
 1822d14:	f800283a 	ret

01822d18 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 1822d18:	defffd04 	addi	sp,sp,-12
 1822d1c:	dfc00215 	stw	ra,8(sp)
 1822d20:	df000115 	stw	fp,4(sp)
 1822d24:	df000104 	addi	fp,sp,4
 1822d28:	e13fff15 	stw	r4,-4(fp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 1822d2c:	00806134 	movhi	r2,388
 1822d30:	109fbf04 	addi	r2,r2,32508
 1822d34:	e0ffff17 	ldw	r3,-4(fp)
 1822d38:	18c00524 	muli	r3,r3,20
 1822d3c:	10c5883a 	add	r2,r2,r3
 1822d40:	10800017 	ldw	r2,0(r2)
 1822d44:	10000e26 	beq	r2,zero,1822d80 <etharp_free_entry+0x68>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 1822d48:	00806134 	movhi	r2,388
 1822d4c:	109fbf04 	addi	r2,r2,32508
 1822d50:	e0ffff17 	ldw	r3,-4(fp)
 1822d54:	18c00524 	muli	r3,r3,20
 1822d58:	10c5883a 	add	r2,r2,r3
 1822d5c:	10800017 	ldw	r2,0(r2)
 1822d60:	1009883a 	mov	r4,r2
 1822d64:	1822cb00 	call	1822cb0 <free_etharp_q>
    arp_table[i].q = NULL;
 1822d68:	00806134 	movhi	r2,388
 1822d6c:	109fbf04 	addi	r2,r2,32508
 1822d70:	e0ffff17 	ldw	r3,-4(fp)
 1822d74:	18c00524 	muli	r3,r3,20
 1822d78:	10c5883a 	add	r2,r2,r3
 1822d7c:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 1822d80:	00806134 	movhi	r2,388
 1822d84:	109fbf04 	addi	r2,r2,32508
 1822d88:	e0ffff17 	ldw	r3,-4(fp)
 1822d8c:	18c00524 	muli	r3,r3,20
 1822d90:	10c5883a 	add	r2,r2,r3
 1822d94:	10800484 	addi	r2,r2,18
 1822d98:	10000005 	stb	zero,0(r2)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 1822d9c:	0001883a 	nop
 1822da0:	e037883a 	mov	sp,fp
 1822da4:	dfc00117 	ldw	ra,4(sp)
 1822da8:	df000017 	ldw	fp,0(sp)
 1822dac:	dec00204 	addi	sp,sp,8
 1822db0:	f800283a 	ret

01822db4 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 1822db4:	defffd04 	addi	sp,sp,-12
 1822db8:	dfc00215 	stw	ra,8(sp)
 1822dbc:	df000115 	stw	fp,4(sp)
 1822dc0:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1822dc4:	e03fff05 	stb	zero,-4(fp)
 1822dc8:	00005006 	br	1822f0c <etharp_tmr+0x158>
    u8_t state = arp_table[i].state;
 1822dcc:	e0ffff03 	ldbu	r3,-4(fp)
 1822dd0:	00806134 	movhi	r2,388
 1822dd4:	109fbf04 	addi	r2,r2,32508
 1822dd8:	18c00524 	muli	r3,r3,20
 1822ddc:	10c5883a 	add	r2,r2,r3
 1822de0:	10800484 	addi	r2,r2,18
 1822de4:	10800003 	ldbu	r2,0(r2)
 1822de8:	e0bfff45 	stb	r2,-3(fp)
    if (state != ETHARP_STATE_EMPTY
 1822dec:	e0bfff43 	ldbu	r2,-3(fp)
 1822df0:	10004326 	beq	r2,zero,1822f00 <etharp_tmr+0x14c>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 1822df4:	e0ffff03 	ldbu	r3,-4(fp)
 1822df8:	00806134 	movhi	r2,388
 1822dfc:	109fbf04 	addi	r2,r2,32508
 1822e00:	19000524 	muli	r4,r3,20
 1822e04:	1105883a 	add	r2,r2,r4
 1822e08:	108004c4 	addi	r2,r2,19
 1822e0c:	10800003 	ldbu	r2,0(r2)
 1822e10:	10800044 	addi	r2,r2,1
 1822e14:	1009883a 	mov	r4,r2
 1822e18:	00806134 	movhi	r2,388
 1822e1c:	109fbf04 	addi	r2,r2,32508
 1822e20:	18c00524 	muli	r3,r3,20
 1822e24:	10c5883a 	add	r2,r2,r3
 1822e28:	108004c4 	addi	r2,r2,19
 1822e2c:	11000005 	stb	r4,0(r2)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 1822e30:	e0ffff03 	ldbu	r3,-4(fp)
 1822e34:	00806134 	movhi	r2,388
 1822e38:	109fbf04 	addi	r2,r2,32508
 1822e3c:	18c00524 	muli	r3,r3,20
 1822e40:	10c5883a 	add	r2,r2,r3
 1822e44:	108004c4 	addi	r2,r2,19
 1822e48:	10800003 	ldbu	r2,0(r2)
 1822e4c:	10803fcc 	andi	r2,r2,255
 1822e50:	10803c28 	cmpgeui	r2,r2,240
 1822e54:	1000141e 	bne	r2,zero,1822ea8 <etharp_tmr+0xf4>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 1822e58:	e0ffff03 	ldbu	r3,-4(fp)
 1822e5c:	00806134 	movhi	r2,388
 1822e60:	109fbf04 	addi	r2,r2,32508
 1822e64:	18c00524 	muli	r3,r3,20
 1822e68:	10c5883a 	add	r2,r2,r3
 1822e6c:	10800484 	addi	r2,r2,18
 1822e70:	10800003 	ldbu	r2,0(r2)
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 1822e74:	10803fcc 	andi	r2,r2,255
 1822e78:	10800058 	cmpnei	r2,r2,1
 1822e7c:	10000e1e 	bne	r2,zero,1822eb8 <etharp_tmr+0x104>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
 1822e80:	e0ffff03 	ldbu	r3,-4(fp)
 1822e84:	00806134 	movhi	r2,388
 1822e88:	109fbf04 	addi	r2,r2,32508
 1822e8c:	18c00524 	muli	r3,r3,20
 1822e90:	10c5883a 	add	r2,r2,r3
 1822e94:	108004c4 	addi	r2,r2,19
 1822e98:	10800003 	ldbu	r2,0(r2)
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 1822e9c:	10803fcc 	andi	r2,r2,255
 1822ea0:	108000b0 	cmpltui	r2,r2,2
 1822ea4:	1000041e 	bne	r2,zero,1822eb8 <etharp_tmr+0x104>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
 1822ea8:	e0bfff03 	ldbu	r2,-4(fp)
 1822eac:	1009883a 	mov	r4,r2
 1822eb0:	1822d180 	call	1822d18 <etharp_free_entry>
 1822eb4:	00001206 	br	1822f00 <etharp_tmr+0x14c>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 1822eb8:	e0ffff03 	ldbu	r3,-4(fp)
 1822ebc:	00806134 	movhi	r2,388
 1822ec0:	109fbf04 	addi	r2,r2,32508
 1822ec4:	18c00524 	muli	r3,r3,20
 1822ec8:	10c5883a 	add	r2,r2,r3
 1822ecc:	10800484 	addi	r2,r2,18
 1822ed0:	10800003 	ldbu	r2,0(r2)
 1822ed4:	10803fcc 	andi	r2,r2,255
 1822ed8:	108000d8 	cmpnei	r2,r2,3
 1822edc:	1000081e 	bne	r2,zero,1822f00 <etharp_tmr+0x14c>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 1822ee0:	e0ffff03 	ldbu	r3,-4(fp)
 1822ee4:	00806134 	movhi	r2,388
 1822ee8:	109fbf04 	addi	r2,r2,32508
 1822eec:	18c00524 	muli	r3,r3,20
 1822ef0:	10c5883a 	add	r2,r2,r3
 1822ef4:	10800484 	addi	r2,r2,18
 1822ef8:	00c00084 	movi	r3,2
 1822efc:	10c00005 	stb	r3,0(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1822f00:	e0bfff03 	ldbu	r2,-4(fp)
 1822f04:	10800044 	addi	r2,r2,1
 1822f08:	e0bfff05 	stb	r2,-4(fp)
 1822f0c:	e0bfff03 	ldbu	r2,-4(fp)
 1822f10:	10800670 	cmpltui	r2,r2,25
 1822f14:	103fad1e 	bne	r2,zero,1822dcc <__ram_exceptions_end+0xff812988>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
 1822f18:	0001883a 	nop
 1822f1c:	e037883a 	mov	sp,fp
 1822f20:	dfc00117 	ldw	ra,4(sp)
 1822f24:	df000017 	ldw	fp,0(sp)
 1822f28:	dec00204 	addi	sp,sp,8
 1822f2c:	f800283a 	ret

01822f30 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 1822f30:	defff904 	addi	sp,sp,-28
 1822f34:	dfc00615 	stw	ra,24(sp)
 1822f38:	df000515 	stw	fp,20(sp)
 1822f3c:	df000504 	addi	fp,sp,20
 1822f40:	e13ffe15 	stw	r4,-8(fp)
 1822f44:	2805883a 	mov	r2,r5
 1822f48:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 1822f4c:	00800644 	movi	r2,25
 1822f50:	e0bffb05 	stb	r2,-20(fp)
 1822f54:	00800644 	movi	r2,25
 1822f58:	e0bffb45 	stb	r2,-19(fp)
  s8_t empty = ARP_TABLE_SIZE;
 1822f5c:	00800644 	movi	r2,25
 1822f60:	e0bffb85 	stb	r2,-18(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
 1822f64:	e03ffbc5 	stb	zero,-17(fp)
 1822f68:	e03ffc05 	stb	zero,-16(fp)
 1822f6c:	e03ffc45 	stb	zero,-15(fp)
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 1822f70:	00800644 	movi	r2,25
 1822f74:	e0bffc85 	stb	r2,-14(fp)
  /* its age */
  u8_t age_queue = 0;
 1822f78:	e03ffcc5 	stb	zero,-13(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1822f7c:	e03ffbc5 	stb	zero,-17(fp)
 1822f80:	00006e06 	br	182313c <etharp_find_entry+0x20c>
    u8_t state = arp_table[i].state;
 1822f84:	e0fffbc3 	ldbu	r3,-17(fp)
 1822f88:	00806134 	movhi	r2,388
 1822f8c:	109fbf04 	addi	r2,r2,32508
 1822f90:	18c00524 	muli	r3,r3,20
 1822f94:	10c5883a 	add	r2,r2,r3
 1822f98:	10800484 	addi	r2,r2,18
 1822f9c:	10800003 	ldbu	r2,0(r2)
 1822fa0:	e0bffd05 	stb	r2,-12(fp)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 1822fa4:	e0bffb87 	ldb	r2,-18(fp)
 1822fa8:	10800658 	cmpnei	r2,r2,25
 1822fac:	1000051e 	bne	r2,zero,1822fc4 <etharp_find_entry+0x94>
 1822fb0:	e0bffd03 	ldbu	r2,-12(fp)
 1822fb4:	1000031e 	bne	r2,zero,1822fc4 <etharp_find_entry+0x94>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 1822fb8:	e0bffbc3 	ldbu	r2,-17(fp)
 1822fbc:	e0bffb85 	stb	r2,-18(fp)
 1822fc0:	00005b06 	br	1823130 <etharp_find_entry+0x200>
    } else if (state != ETHARP_STATE_EMPTY) {
 1822fc4:	e0bffd03 	ldbu	r2,-12(fp)
 1822fc8:	10005926 	beq	r2,zero,1823130 <etharp_find_entry+0x200>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 1822fcc:	e0bffe17 	ldw	r2,-8(fp)
 1822fd0:	10000c26 	beq	r2,zero,1823004 <etharp_find_entry+0xd4>
 1822fd4:	e0bffe17 	ldw	r2,-8(fp)
 1822fd8:	10c00017 	ldw	r3,0(r2)
 1822fdc:	e13ffbc3 	ldbu	r4,-17(fp)
 1822fe0:	00806134 	movhi	r2,388
 1822fe4:	109fbf04 	addi	r2,r2,32508
 1822fe8:	21000524 	muli	r4,r4,20
 1822fec:	1105883a 	add	r2,r2,r4
 1822ff0:	10800104 	addi	r2,r2,4
 1822ff4:	10800017 	ldw	r2,0(r2)
 1822ff8:	1880021e 	bne	r3,r2,1823004 <etharp_find_entry+0xd4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
 1822ffc:	e0bffbc3 	ldbu	r2,-17(fp)
 1823000:	00008c06 	br	1823234 <etharp_find_entry+0x304>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 1823004:	e0bffd03 	ldbu	r2,-12(fp)
 1823008:	10800058 	cmpnei	r2,r2,1
 182300c:	1000311e 	bne	r2,zero,18230d4 <etharp_find_entry+0x1a4>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 1823010:	e0fffbc3 	ldbu	r3,-17(fp)
 1823014:	00806134 	movhi	r2,388
 1823018:	109fbf04 	addi	r2,r2,32508
 182301c:	18c00524 	muli	r3,r3,20
 1823020:	10c5883a 	add	r2,r2,r3
 1823024:	10800017 	ldw	r2,0(r2)
 1823028:	10001526 	beq	r2,zero,1823080 <etharp_find_entry+0x150>
          if (arp_table[i].ctime >= age_queue) {
 182302c:	e0fffbc3 	ldbu	r3,-17(fp)
 1823030:	00806134 	movhi	r2,388
 1823034:	109fbf04 	addi	r2,r2,32508
 1823038:	18c00524 	muli	r3,r3,20
 182303c:	10c5883a 	add	r2,r2,r3
 1823040:	108004c4 	addi	r2,r2,19
 1823044:	10800003 	ldbu	r2,0(r2)
 1823048:	10c03fcc 	andi	r3,r2,255
 182304c:	e0bffcc3 	ldbu	r2,-13(fp)
 1823050:	18803736 	bltu	r3,r2,1823130 <etharp_find_entry+0x200>
            old_queue = i;
 1823054:	e0bffbc3 	ldbu	r2,-17(fp)
 1823058:	e0bffc85 	stb	r2,-14(fp)
            age_queue = arp_table[i].ctime;
 182305c:	e0fffbc3 	ldbu	r3,-17(fp)
 1823060:	00806134 	movhi	r2,388
 1823064:	109fbf04 	addi	r2,r2,32508
 1823068:	18c00524 	muli	r3,r3,20
 182306c:	10c5883a 	add	r2,r2,r3
 1823070:	108004c4 	addi	r2,r2,19
 1823074:	10800003 	ldbu	r2,0(r2)
 1823078:	e0bffcc5 	stb	r2,-13(fp)
 182307c:	00002c06 	br	1823130 <etharp_find_entry+0x200>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 1823080:	e0fffbc3 	ldbu	r3,-17(fp)
 1823084:	00806134 	movhi	r2,388
 1823088:	109fbf04 	addi	r2,r2,32508
 182308c:	18c00524 	muli	r3,r3,20
 1823090:	10c5883a 	add	r2,r2,r3
 1823094:	108004c4 	addi	r2,r2,19
 1823098:	10800003 	ldbu	r2,0(r2)
 182309c:	10c03fcc 	andi	r3,r2,255
 18230a0:	e0bffc03 	ldbu	r2,-16(fp)
 18230a4:	18802236 	bltu	r3,r2,1823130 <etharp_find_entry+0x200>
            old_pending = i;
 18230a8:	e0bffbc3 	ldbu	r2,-17(fp)
 18230ac:	e0bffb05 	stb	r2,-20(fp)
            age_pending = arp_table[i].ctime;
 18230b0:	e0fffbc3 	ldbu	r3,-17(fp)
 18230b4:	00806134 	movhi	r2,388
 18230b8:	109fbf04 	addi	r2,r2,32508
 18230bc:	18c00524 	muli	r3,r3,20
 18230c0:	10c5883a 	add	r2,r2,r3
 18230c4:	108004c4 	addi	r2,r2,19
 18230c8:	10800003 	ldbu	r2,0(r2)
 18230cc:	e0bffc05 	stb	r2,-16(fp)
 18230d0:	00001706 	br	1823130 <etharp_find_entry+0x200>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 18230d4:	e0bffd03 	ldbu	r2,-12(fp)
 18230d8:	108000b0 	cmpltui	r2,r2,2
 18230dc:	1000141e 	bne	r2,zero,1823130 <etharp_find_entry+0x200>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 18230e0:	e0fffbc3 	ldbu	r3,-17(fp)
 18230e4:	00806134 	movhi	r2,388
 18230e8:	109fbf04 	addi	r2,r2,32508
 18230ec:	18c00524 	muli	r3,r3,20
 18230f0:	10c5883a 	add	r2,r2,r3
 18230f4:	108004c4 	addi	r2,r2,19
 18230f8:	10800003 	ldbu	r2,0(r2)
 18230fc:	10c03fcc 	andi	r3,r2,255
 1823100:	e0bffc43 	ldbu	r2,-15(fp)
 1823104:	18800a36 	bltu	r3,r2,1823130 <etharp_find_entry+0x200>
            old_stable = i;
 1823108:	e0bffbc3 	ldbu	r2,-17(fp)
 182310c:	e0bffb45 	stb	r2,-19(fp)
            age_stable = arp_table[i].ctime;
 1823110:	e0fffbc3 	ldbu	r3,-17(fp)
 1823114:	00806134 	movhi	r2,388
 1823118:	109fbf04 	addi	r2,r2,32508
 182311c:	18c00524 	muli	r3,r3,20
 1823120:	10c5883a 	add	r2,r2,r3
 1823124:	108004c4 	addi	r2,r2,19
 1823128:	10800003 	ldbu	r2,0(r2)
 182312c:	e0bffc45 	stb	r2,-15(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1823130:	e0bffbc3 	ldbu	r2,-17(fp)
 1823134:	10800044 	addi	r2,r2,1
 1823138:	e0bffbc5 	stb	r2,-17(fp)
 182313c:	e0bffbc3 	ldbu	r2,-17(fp)
 1823140:	10800670 	cmpltui	r2,r2,25
 1823144:	103f8f1e 	bne	r2,zero,1822f84 <__ram_exceptions_end+0xff812b40>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 1823148:	e0bfff03 	ldbu	r2,-4(fp)
 182314c:	1080008c 	andi	r2,r2,2
 1823150:	1000061e 	bne	r2,zero,182316c <etharp_find_entry+0x23c>
 1823154:	e0bffb87 	ldb	r2,-18(fp)
 1823158:	10800658 	cmpnei	r2,r2,25
 182315c:	1000051e 	bne	r2,zero,1823174 <etharp_find_entry+0x244>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 1823160:	e0bfff03 	ldbu	r2,-4(fp)
 1823164:	1080004c 	andi	r2,r2,1
 1823168:	1000021e 	bne	r2,zero,1823174 <etharp_find_entry+0x244>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 182316c:	00bfffc4 	movi	r2,-1
 1823170:	00003006 	br	1823234 <etharp_find_entry+0x304>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 1823174:	e0bffb87 	ldb	r2,-18(fp)
 1823178:	10800648 	cmpgei	r2,r2,25
 182317c:	1000031e 	bne	r2,zero,182318c <etharp_find_entry+0x25c>
    i = empty;
 1823180:	e0bffb83 	ldbu	r2,-18(fp)
 1823184:	e0bffbc5 	stb	r2,-17(fp)
 1823188:	00001706 	br	18231e8 <etharp_find_entry+0x2b8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 182318c:	e0bffb47 	ldb	r2,-19(fp)
 1823190:	10800648 	cmpgei	r2,r2,25
 1823194:	1000031e 	bne	r2,zero,18231a4 <etharp_find_entry+0x274>
      /* recycle oldest stable*/
      i = old_stable;
 1823198:	e0bffb43 	ldbu	r2,-19(fp)
 182319c:	e0bffbc5 	stb	r2,-17(fp)
 18231a0:	00000e06 	br	18231dc <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 18231a4:	e0bffb07 	ldb	r2,-20(fp)
 18231a8:	10800648 	cmpgei	r2,r2,25
 18231ac:	1000031e 	bne	r2,zero,18231bc <etharp_find_entry+0x28c>
      /* recycle oldest pending */
      i = old_pending;
 18231b0:	e0bffb03 	ldbu	r2,-20(fp)
 18231b4:	e0bffbc5 	stb	r2,-17(fp)
 18231b8:	00000806 	br	18231dc <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 18231bc:	e0bffc87 	ldb	r2,-14(fp)
 18231c0:	10800648 	cmpgei	r2,r2,25
 18231c4:	1000031e 	bne	r2,zero,18231d4 <etharp_find_entry+0x2a4>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 18231c8:	e0bffc83 	ldbu	r2,-14(fp)
 18231cc:	e0bffbc5 	stb	r2,-17(fp)
 18231d0:	00000206 	br	18231dc <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
 18231d4:	00bfffc4 	movi	r2,-1
 18231d8:	00001606 	br	1823234 <etharp_find_entry+0x304>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
 18231dc:	e0bffbc3 	ldbu	r2,-17(fp)
 18231e0:	1009883a 	mov	r4,r2
 18231e4:	1822d180 	call	1822d18 <etharp_free_entry>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 18231e8:	e0bffe17 	ldw	r2,-8(fp)
 18231ec:	10000926 	beq	r2,zero,1823214 <etharp_find_entry+0x2e4>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 18231f0:	e13ffbc3 	ldbu	r4,-17(fp)
 18231f4:	e0bffe17 	ldw	r2,-8(fp)
 18231f8:	10c00017 	ldw	r3,0(r2)
 18231fc:	00806134 	movhi	r2,388
 1823200:	109fbf04 	addi	r2,r2,32508
 1823204:	21000524 	muli	r4,r4,20
 1823208:	1105883a 	add	r2,r2,r4
 182320c:	10800104 	addi	r2,r2,4
 1823210:	10c00015 	stw	r3,0(r2)
  }
  arp_table[i].ctime = 0;
 1823214:	e0fffbc3 	ldbu	r3,-17(fp)
 1823218:	00806134 	movhi	r2,388
 182321c:	109fbf04 	addi	r2,r2,32508
 1823220:	18c00524 	muli	r3,r3,20
 1823224:	10c5883a 	add	r2,r2,r3
 1823228:	108004c4 	addi	r2,r2,19
 182322c:	10000005 	stb	zero,0(r2)
  return (err_t)i;
 1823230:	e0bffbc3 	ldbu	r2,-17(fp)
}
 1823234:	e037883a 	mov	sp,fp
 1823238:	dfc00117 	ldw	ra,4(sp)
 182323c:	df000017 	ldw	fp,0(sp)
 1823240:	dec00204 	addi	sp,sp,8
 1823244:	f800283a 	ret

01823248 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 1823248:	defff904 	addi	sp,sp,-28
 182324c:	dfc00615 	stw	ra,24(sp)
 1823250:	df000515 	stw	fp,20(sp)
 1823254:	df000504 	addi	fp,sp,20
 1823258:	e13ffc15 	stw	r4,-16(fp)
 182325c:	e17ffd15 	stw	r5,-12(fp)
 1823260:	e1bffe15 	stw	r6,-8(fp)
 1823264:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 1823268:	e0bffd17 	ldw	r2,-12(fp)
 182326c:	10800117 	ldw	r2,4(r2)
 1823270:	e0bffb15 	stw	r2,-20(fp)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 1823274:	e0bffb17 	ldw	r2,-20(fp)
 1823278:	10800084 	addi	r2,r2,2
 182327c:	01800184 	movi	r6,6
 1823280:	e17fff17 	ldw	r5,-4(fp)
 1823284:	1009883a 	mov	r4,r2
 1823288:	180608c0 	call	180608c <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
 182328c:	e0bffb17 	ldw	r2,-20(fp)
 1823290:	10800204 	addi	r2,r2,8
 1823294:	01800184 	movi	r6,6
 1823298:	e17ffe17 	ldw	r5,-8(fp)
 182329c:	1009883a 	mov	r4,r2
 18232a0:	180608c0 	call	180608c <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 18232a4:	e0bffb17 	ldw	r2,-20(fp)
 18232a8:	10c00383 	ldbu	r3,14(r2)
 18232ac:	1806703a 	and	r3,r3,zero
 18232b0:	18c00214 	ori	r3,r3,8
 18232b4:	10c00385 	stb	r3,14(r2)
 18232b8:	10c003c3 	ldbu	r3,15(r2)
 18232bc:	1806703a 	and	r3,r3,zero
 18232c0:	10c003c5 	stb	r3,15(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 18232c4:	e0bffc17 	ldw	r2,-16(fp)
 18232c8:	10800617 	ldw	r2,24(r2)
 18232cc:	e17ffd17 	ldw	r5,-12(fp)
 18232d0:	e13ffc17 	ldw	r4,-16(fp)
 18232d4:	103ee83a 	callr	r2
}
 18232d8:	e037883a 	mov	sp,fp
 18232dc:	dfc00117 	ldw	ra,4(sp)
 18232e0:	df000017 	ldw	fp,0(sp)
 18232e4:	dec00204 	addi	sp,sp,8
 18232e8:	f800283a 	ret

018232ec <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 18232ec:	defff704 	addi	sp,sp,-36
 18232f0:	dfc00815 	stw	ra,32(sp)
 18232f4:	df000715 	stw	fp,28(sp)
 18232f8:	df000704 	addi	fp,sp,28
 18232fc:	e13ffc15 	stw	r4,-16(fp)
 1823300:	e17ffd15 	stw	r5,-12(fp)
 1823304:	e1bffe15 	stw	r6,-8(fp)
 1823308:	3805883a 	mov	r2,r7
 182330c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 1823310:	e0bffd17 	ldw	r2,-12(fp)
 1823314:	10000f26 	beq	r2,zero,1823354 <etharp_update_arp_entry+0x68>
 1823318:	e0bffd17 	ldw	r2,-12(fp)
 182331c:	10800017 	ldw	r2,0(r2)
 1823320:	10000c26 	beq	r2,zero,1823354 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
 1823324:	e0bffd17 	ldw	r2,-12(fp)
 1823328:	10800017 	ldw	r2,0(r2)
 182332c:	e17ffc17 	ldw	r5,-16(fp)
 1823330:	1009883a 	mov	r4,r2
 1823334:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 1823338:	10803fcc 	andi	r2,r2,255
 182333c:	1000051e 	bne	r2,zero,1823354 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
 1823340:	e0bffd17 	ldw	r2,-12(fp)
 1823344:	10800017 	ldw	r2,0(r2)
 1823348:	10803c0c 	andi	r2,r2,240
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
 182334c:	10803818 	cmpnei	r2,r2,224
 1823350:	1000021e 	bne	r2,zero,182335c <etharp_update_arp_entry+0x70>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 1823354:	00bffc84 	movi	r2,-14
 1823358:	00005106 	br	18234a0 <etharp_update_arp_entry+0x1b4>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 182335c:	e0bfff03 	ldbu	r2,-4(fp)
 1823360:	100b883a 	mov	r5,r2
 1823364:	e13ffd17 	ldw	r4,-12(fp)
 1823368:	1822f300 	call	1822f30 <etharp_find_entry>
 182336c:	e0bff905 	stb	r2,-28(fp)
  /* bail out if no entry could be found */
  if (i < 0) {
 1823370:	e0bff907 	ldb	r2,-28(fp)
 1823374:	1000020e 	bge	r2,zero,1823380 <etharp_update_arp_entry+0x94>
    return (err_t)i;
 1823378:	e0bff903 	ldbu	r2,-28(fp)
 182337c:	00004806 	br	18234a0 <etharp_update_arp_entry+0x1b4>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 1823380:	e0fff907 	ldb	r3,-28(fp)
 1823384:	00806134 	movhi	r2,388
 1823388:	109fbf04 	addi	r2,r2,32508
 182338c:	18c00524 	muli	r3,r3,20
 1823390:	10c5883a 	add	r2,r2,r3
 1823394:	10800484 	addi	r2,r2,18
 1823398:	00c00084 	movi	r3,2
 182339c:	10c00005 	stb	r3,0(r2)
  }

  /* record network interface */
  arp_table[i].netif = netif;
 18233a0:	e0fff907 	ldb	r3,-28(fp)
 18233a4:	00806134 	movhi	r2,388
 18233a8:	109fbf04 	addi	r2,r2,32508
 18233ac:	18c00524 	muli	r3,r3,20
 18233b0:	10c5883a 	add	r2,r2,r3
 18233b4:	10800204 	addi	r2,r2,8
 18233b8:	e0fffc17 	ldw	r3,-16(fp)
 18233bc:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 18233c0:	e0bff907 	ldb	r2,-28(fp)
 18233c4:	10800524 	muli	r2,r2,20
 18233c8:	10c00304 	addi	r3,r2,12
 18233cc:	00806134 	movhi	r2,388
 18233d0:	109fbf04 	addi	r2,r2,32508
 18233d4:	1885883a 	add	r2,r3,r2
 18233d8:	01800184 	movi	r6,6
 18233dc:	e17ffe17 	ldw	r5,-8(fp)
 18233e0:	1009883a 	mov	r4,r2
 18233e4:	180608c0 	call	180608c <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
 18233e8:	e0fff907 	ldb	r3,-28(fp)
 18233ec:	00806134 	movhi	r2,388
 18233f0:	109fbf04 	addi	r2,r2,32508
 18233f4:	18c00524 	muli	r3,r3,20
 18233f8:	10c5883a 	add	r2,r2,r3
 18233fc:	108004c4 	addi	r2,r2,19
 1823400:	10000005 	stb	zero,0(r2)
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 1823404:	00001e06 	br	1823480 <etharp_update_arp_entry+0x194>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
 1823408:	e0fff907 	ldb	r3,-28(fp)
 182340c:	00806134 	movhi	r2,388
 1823410:	109fbf04 	addi	r2,r2,32508
 1823414:	18c00524 	muli	r3,r3,20
 1823418:	10c5883a 	add	r2,r2,r3
 182341c:	10800017 	ldw	r2,0(r2)
 1823420:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 1823424:	e13ff907 	ldb	r4,-28(fp)
 1823428:	e0bffa17 	ldw	r2,-24(fp)
 182342c:	10c00017 	ldw	r3,0(r2)
 1823430:	00806134 	movhi	r2,388
 1823434:	109fbf04 	addi	r2,r2,32508
 1823438:	21000524 	muli	r4,r4,20
 182343c:	1105883a 	add	r2,r2,r4
 1823440:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
 1823444:	e0bffa17 	ldw	r2,-24(fp)
 1823448:	10800117 	ldw	r2,4(r2)
 182344c:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 1823450:	e17ffa17 	ldw	r5,-24(fp)
 1823454:	010002c4 	movi	r4,11
 1823458:	1834b240 	call	1834b24 <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 182345c:	e0bffc17 	ldw	r2,-16(fp)
 1823460:	10800cc4 	addi	r2,r2,51
 1823464:	e1fffe17 	ldw	r7,-8(fp)
 1823468:	100d883a 	mov	r6,r2
 182346c:	e17ffb17 	ldw	r5,-20(fp)
 1823470:	e13ffc17 	ldw	r4,-16(fp)
 1823474:	18232480 	call	1823248 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 1823478:	e13ffb17 	ldw	r4,-20(fp)
 182347c:	181aca40 	call	181aca4 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 1823480:	e0fff907 	ldb	r3,-28(fp)
 1823484:	00806134 	movhi	r2,388
 1823488:	109fbf04 	addi	r2,r2,32508
 182348c:	18c00524 	muli	r3,r3,20
 1823490:	10c5883a 	add	r2,r2,r3
 1823494:	10800017 	ldw	r2,0(r2)
 1823498:	103fdb1e 	bne	r2,zero,1823408 <__ram_exceptions_end+0xff812fc4>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
 182349c:	0005883a 	mov	r2,zero
}
 18234a0:	e037883a 	mov	sp,fp
 18234a4:	dfc00117 	ldw	ra,4(sp)
 18234a8:	df000017 	ldw	fp,0(sp)
 18234ac:	dec00204 	addi	sp,sp,8
 18234b0:	f800283a 	ret

018234b4 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
 18234b4:	defffc04 	addi	sp,sp,-16
 18234b8:	dfc00315 	stw	ra,12(sp)
 18234bc:	df000215 	stw	fp,8(sp)
 18234c0:	df000204 	addi	fp,sp,8
 18234c4:	e13fff15 	stw	r4,-4(fp)
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 18234c8:	e03ffe05 	stb	zero,-8(fp)
 18234cc:	00001906 	br	1823534 <etharp_cleanup_netif+0x80>
    u8_t state = arp_table[i].state;
 18234d0:	e0fffe03 	ldbu	r3,-8(fp)
 18234d4:	00806134 	movhi	r2,388
 18234d8:	109fbf04 	addi	r2,r2,32508
 18234dc:	18c00524 	muli	r3,r3,20
 18234e0:	10c5883a 	add	r2,r2,r3
 18234e4:	10800484 	addi	r2,r2,18
 18234e8:	10800003 	ldbu	r2,0(r2)
 18234ec:	e0bffe45 	stb	r2,-7(fp)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 18234f0:	e0bffe43 	ldbu	r2,-7(fp)
 18234f4:	10000c26 	beq	r2,zero,1823528 <etharp_cleanup_netif+0x74>
 18234f8:	e0fffe03 	ldbu	r3,-8(fp)
 18234fc:	00806134 	movhi	r2,388
 1823500:	109fbf04 	addi	r2,r2,32508
 1823504:	18c00524 	muli	r3,r3,20
 1823508:	10c5883a 	add	r2,r2,r3
 182350c:	10800204 	addi	r2,r2,8
 1823510:	10c00017 	ldw	r3,0(r2)
 1823514:	e0bfff17 	ldw	r2,-4(fp)
 1823518:	1880031e 	bne	r3,r2,1823528 <etharp_cleanup_netif+0x74>
      etharp_free_entry(i);
 182351c:	e0bffe03 	ldbu	r2,-8(fp)
 1823520:	1009883a 	mov	r4,r2
 1823524:	1822d180 	call	1822d18 <etharp_free_entry>
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 1823528:	e0bffe03 	ldbu	r2,-8(fp)
 182352c:	10800044 	addi	r2,r2,1
 1823530:	e0bffe05 	stb	r2,-8(fp)
 1823534:	e0bffe03 	ldbu	r2,-8(fp)
 1823538:	10800670 	cmpltui	r2,r2,25
 182353c:	103fe41e 	bne	r2,zero,18234d0 <__ram_exceptions_end+0xff81308c>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
 1823540:	0001883a 	nop
 1823544:	e037883a 	mov	sp,fp
 1823548:	dfc00117 	ldw	ra,4(sp)
 182354c:	df000017 	ldw	fp,0(sp)
 1823550:	dec00204 	addi	sp,sp,8
 1823554:	f800283a 	ret

01823558 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
 1823558:	defff904 	addi	sp,sp,-28
 182355c:	dfc00615 	stw	ra,24(sp)
 1823560:	df000515 	stw	fp,20(sp)
 1823564:	df000504 	addi	fp,sp,20
 1823568:	e13ffc15 	stw	r4,-16(fp)
 182356c:	e17ffd15 	stw	r5,-12(fp)
 1823570:	e1bffe15 	stw	r6,-8(fp)
 1823574:	e1ffff15 	stw	r7,-4(fp)
  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 1823578:	01400084 	movi	r5,2
 182357c:	e13ffd17 	ldw	r4,-12(fp)
 1823580:	1822f300 	call	1822f30 <etharp_find_entry>
 1823584:	e0bffb05 	stb	r2,-20(fp)
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 1823588:	e0bffb07 	ldb	r2,-20(fp)
 182358c:	10001c16 	blt	r2,zero,1823600 <etharp_find_addr+0xa8>
 1823590:	e0fffb07 	ldb	r3,-20(fp)
 1823594:	00806134 	movhi	r2,388
 1823598:	109fbf04 	addi	r2,r2,32508
 182359c:	18c00524 	muli	r3,r3,20
 18235a0:	10c5883a 	add	r2,r2,r3
 18235a4:	10800484 	addi	r2,r2,18
 18235a8:	10800003 	ldbu	r2,0(r2)
 18235ac:	10803fcc 	andi	r2,r2,255
 18235b0:	108000b0 	cmpltui	r2,r2,2
 18235b4:	1000121e 	bne	r2,zero,1823600 <etharp_find_addr+0xa8>
      *eth_ret = &arp_table[i].ethaddr;
 18235b8:	e0bffb07 	ldb	r2,-20(fp)
 18235bc:	10800524 	muli	r2,r2,20
 18235c0:	10c00304 	addi	r3,r2,12
 18235c4:	00806134 	movhi	r2,388
 18235c8:	109fbf04 	addi	r2,r2,32508
 18235cc:	1887883a 	add	r3,r3,r2
 18235d0:	e0bffe17 	ldw	r2,-8(fp)
 18235d4:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
 18235d8:	e0bffb07 	ldb	r2,-20(fp)
 18235dc:	10800524 	muli	r2,r2,20
 18235e0:	10c00104 	addi	r3,r2,4
 18235e4:	00806134 	movhi	r2,388
 18235e8:	109fbf04 	addi	r2,r2,32508
 18235ec:	1887883a 	add	r3,r3,r2
 18235f0:	e0bfff17 	ldw	r2,-4(fp)
 18235f4:	10c00015 	stw	r3,0(r2)
      return i;
 18235f8:	e0bffb03 	ldbu	r2,-20(fp)
 18235fc:	00000106 	br	1823604 <etharp_find_addr+0xac>
  }
  return -1;
 1823600:	00bfffc4 	movi	r2,-1
}
 1823604:	e037883a 	mov	sp,fp
 1823608:	dfc00117 	ldw	ra,4(sp)
 182360c:	df000017 	ldw	fp,0(sp)
 1823610:	dec00204 	addi	sp,sp,8
 1823614:	f800283a 	ret

01823618 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
 1823618:	defff904 	addi	sp,sp,-28
 182361c:	dfc00615 	stw	ra,24(sp)
 1823620:	df000515 	stw	fp,20(sp)
 1823624:	df000504 	addi	fp,sp,20
 1823628:	e13ffe15 	stw	r4,-8(fp)
 182362c:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 1823630:	e0bffe17 	ldw	r2,-8(fp)
 1823634:	1000091e 	bne	r2,zero,182365c <etharp_ip_input+0x44>
 1823638:	01c06134 	movhi	r7,388
 182363c:	39c72f04 	addi	r7,r7,7356
 1823640:	0180a104 	movi	r6,644
 1823644:	01406134 	movhi	r5,388
 1823648:	29473504 	addi	r5,r5,7380
 182364c:	01006134 	movhi	r4,388
 1823650:	21073904 	addi	r4,r4,7396
 1823654:	1800c180 	call	1800c18 <printf>
 1823658:	003fff06 	br	1823658 <__ram_exceptions_end+0xff813214>

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
 182365c:	e0bfff17 	ldw	r2,-4(fp)
 1823660:	10800117 	ldw	r2,4(r2)
 1823664:	e0bffb15 	stw	r2,-20(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 1823668:	e0bffb17 	ldw	r2,-20(fp)
 182366c:	10800404 	addi	r2,r2,16
 1823670:	e0bffc15 	stw	r2,-16(fp)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
 1823674:	e0bffc17 	ldw	r2,-16(fp)
 1823678:	10c00303 	ldbu	r3,12(r2)
 182367c:	11000343 	ldbu	r4,13(r2)
 1823680:	2008923a 	slli	r4,r4,8
 1823684:	20c6b03a 	or	r3,r4,r3
 1823688:	11000383 	ldbu	r4,14(r2)
 182368c:	2008943a 	slli	r4,r4,16
 1823690:	20c6b03a 	or	r3,r4,r3
 1823694:	108003c3 	ldbu	r2,15(r2)
 1823698:	1004963a 	slli	r2,r2,24
 182369c:	10c4b03a 	or	r2,r2,r3
 18236a0:	e0bffd15 	stw	r2,-12(fp)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 18236a4:	e0fffd17 	ldw	r3,-12(fp)
 18236a8:	e0bffe17 	ldw	r2,-8(fp)
 18236ac:	10800117 	ldw	r2,4(r2)
 18236b0:	1886f03a 	xor	r3,r3,r2
 18236b4:	e0bffe17 	ldw	r2,-8(fp)
 18236b8:	10800217 	ldw	r2,8(r2)
 18236bc:	1884703a 	and	r2,r3,r2
 18236c0:	1000091e 	bne	r2,zero,18236e8 <etharp_ip_input+0xd0>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
 18236c4:	e0bffb17 	ldw	r2,-20(fp)
 18236c8:	10c00204 	addi	r3,r2,8
 18236cc:	e0bffd04 	addi	r2,fp,-12
 18236d0:	01c00084 	movi	r7,2
 18236d4:	180d883a 	mov	r6,r3
 18236d8:	100b883a 	mov	r5,r2
 18236dc:	e13ffe17 	ldw	r4,-8(fp)
 18236e0:	18232ec0 	call	18232ec <etharp_update_arp_entry>
 18236e4:	00000106 	br	18236ec <etharp_ip_input+0xd4>
  ip_addr_copy(iphdr_src, iphdr->src);

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
 18236e8:	0001883a 	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
}
 18236ec:	e037883a 	mov	sp,fp
 18236f0:	dfc00117 	ldw	ra,4(sp)
 18236f4:	df000017 	ldw	fp,0(sp)
 18236f8:	dec00204 	addi	sp,sp,8
 18236fc:	f800283a 	ret

01823700 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
 1823700:	defff404 	addi	sp,sp,-48
 1823704:	dfc00b15 	stw	ra,44(sp)
 1823708:	df000a15 	stw	fp,40(sp)
 182370c:	df000a04 	addi	fp,sp,40
 1823710:	e13ffb15 	stw	r4,-20(fp)
 1823714:	e17ffc15 	stw	r5,-16(fp)
 1823718:	e1bffd15 	stw	r6,-12(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 182371c:	e0bffb17 	ldw	r2,-20(fp)
 1823720:	1000091e 	bne	r2,zero,1823748 <etharp_arp_input+0x48>
 1823724:	01c06134 	movhi	r7,388
 1823728:	39c72f04 	addi	r7,r7,7356
 182372c:	0180aec4 	movi	r6,699
 1823730:	01406134 	movhi	r5,388
 1823734:	29473504 	addi	r5,r5,7380
 1823738:	01006134 	movhi	r4,388
 182373c:	21073904 	addi	r4,r4,7396
 1823740:	1800c180 	call	1800c18 <printf>
 1823744:	003fff06 	br	1823744 <__ram_exceptions_end+0xff813300>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 1823748:	e0bffd17 	ldw	r2,-12(fp)
 182374c:	1080028b 	ldhu	r2,10(r2)
 1823750:	10bfffcc 	andi	r2,r2,65535
 1823754:	10800b28 	cmpgeui	r2,r2,44
 1823758:	1000111e 	bne	r2,zero,18237a0 <etharp_arp_input+0xa0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
 182375c:	008061f4 	movhi	r2,391
 1823760:	10a9d404 	addi	r2,r2,-22704
 1823764:	10801117 	ldw	r2,68(r2)
 1823768:	10c00044 	addi	r3,r2,1
 182376c:	008061f4 	movhi	r2,391
 1823770:	10a9d404 	addi	r2,r2,-22704
 1823774:	10c01115 	stw	r3,68(r2)
    ETHARP_STATS_INC(etharp.drop);
 1823778:	008061f4 	movhi	r2,391
 182377c:	10a9d404 	addi	r2,r2,-22704
 1823780:	10800f17 	ldw	r2,60(r2)
 1823784:	10c00044 	addi	r3,r2,1
 1823788:	008061f4 	movhi	r2,391
 182378c:	10a9d404 	addi	r2,r2,-22704
 1823790:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
 1823794:	e13ffd17 	ldw	r4,-12(fp)
 1823798:	181aca40 	call	181aca4 <pbuf_free>
    return;
 182379c:	0000b606 	br	1823a78 <etharp_arp_input+0x378>
  }

  ethhdr = (struct eth_hdr *)p->payload;
 18237a0:	e0bffd17 	ldw	r2,-12(fp)
 18237a4:	10800117 	ldw	r2,4(r2)
 18237a8:	e0bff715 	stw	r2,-36(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 18237ac:	e0bff717 	ldw	r2,-36(fp)
 18237b0:	10800404 	addi	r2,r2,16
 18237b4:	e0bff815 	stw	r2,-32(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 18237b8:	e0bff817 	ldw	r2,-32(fp)
 18237bc:	10c00003 	ldbu	r3,0(r2)
 18237c0:	10800043 	ldbu	r2,1(r2)
 18237c4:	1004923a 	slli	r2,r2,8
 18237c8:	10c4b03a 	or	r2,r2,r3
 18237cc:	10bfffcc 	andi	r2,r2,65535
 18237d0:	10804018 	cmpnei	r2,r2,256
 18237d4:	1000121e 	bne	r2,zero,1823820 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 18237d8:	e0bff817 	ldw	r2,-32(fp)
 18237dc:	10800103 	ldbu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 18237e0:	10803fcc 	andi	r2,r2,255
 18237e4:	10800198 	cmpnei	r2,r2,6
 18237e8:	10000d1e 	bne	r2,zero,1823820 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
 18237ec:	e0bff817 	ldw	r2,-32(fp)
 18237f0:	10800143 	ldbu	r2,5(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 18237f4:	10803fcc 	andi	r2,r2,255
 18237f8:	10800118 	cmpnei	r2,r2,4
 18237fc:	1000081e 	bne	r2,zero,1823820 <etharp_arp_input+0x120>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 1823800:	e0bff817 	ldw	r2,-32(fp)
 1823804:	10c00083 	ldbu	r3,2(r2)
 1823808:	108000c3 	ldbu	r2,3(r2)
 182380c:	1004923a 	slli	r2,r2,8
 1823810:	10c4b03a 	or	r2,r2,r3
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
 1823814:	10bfffcc 	andi	r2,r2,65535
 1823818:	10800220 	cmpeqi	r2,r2,8
 182381c:	1000111e 	bne	r2,zero,1823864 <etharp_arp_input+0x164>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 1823820:	008061f4 	movhi	r2,391
 1823824:	10a9d404 	addi	r2,r2,-22704
 1823828:	10801417 	ldw	r2,80(r2)
 182382c:	10c00044 	addi	r3,r2,1
 1823830:	008061f4 	movhi	r2,391
 1823834:	10a9d404 	addi	r2,r2,-22704
 1823838:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 182383c:	008061f4 	movhi	r2,391
 1823840:	10a9d404 	addi	r2,r2,-22704
 1823844:	10800f17 	ldw	r2,60(r2)
 1823848:	10c00044 	addi	r3,r2,1
 182384c:	008061f4 	movhi	r2,391
 1823850:	10a9d404 	addi	r2,r2,-22704
 1823854:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
 1823858:	e13ffd17 	ldw	r4,-12(fp)
 182385c:	181aca40 	call	181aca4 <pbuf_free>
    return;
 1823860:	00008506 	br	1823a78 <etharp_arp_input+0x378>
  }
  ETHARP_STATS_INC(etharp.recv);
 1823864:	008061f4 	movhi	r2,391
 1823868:	10a9d404 	addi	r2,r2,-22704
 182386c:	10800d17 	ldw	r2,52(r2)
 1823870:	10c00044 	addi	r3,r2,1
 1823874:	008061f4 	movhi	r2,391
 1823878:	10a9d404 	addi	r2,r2,-22704
 182387c:	10c00d15 	stw	r3,52(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 1823880:	e0bff817 	ldw	r2,-32(fp)
 1823884:	10c00384 	addi	r3,r2,14
 1823888:	e0bff904 	addi	r2,fp,-28
 182388c:	01800104 	movi	r6,4
 1823890:	180b883a 	mov	r5,r3
 1823894:	1009883a 	mov	r4,r2
 1823898:	180608c0 	call	180608c <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 182389c:	e0bff817 	ldw	r2,-32(fp)
 18238a0:	10c00604 	addi	r3,r2,24
 18238a4:	e0bffa04 	addi	r2,fp,-24
 18238a8:	01800104 	movi	r6,4
 18238ac:	180b883a 	mov	r5,r3
 18238b0:	1009883a 	mov	r4,r2
 18238b4:	180608c0 	call	180608c <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 18238b8:	e0bffb17 	ldw	r2,-20(fp)
 18238bc:	10800104 	addi	r2,r2,4
 18238c0:	10000326 	beq	r2,zero,18238d0 <etharp_arp_input+0x1d0>
 18238c4:	e0bffb17 	ldw	r2,-20(fp)
 18238c8:	10800117 	ldw	r2,4(r2)
 18238cc:	1000021e 	bne	r2,zero,18238d8 <etharp_arp_input+0x1d8>
    for_us = 0;
 18238d0:	e03ff605 	stb	zero,-40(fp)
 18238d4:	00000506 	br	18238ec <etharp_arp_input+0x1ec>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 18238d8:	e0fffa17 	ldw	r3,-24(fp)
 18238dc:	e0bffb17 	ldw	r2,-20(fp)
 18238e0:	10800117 	ldw	r2,4(r2)
 18238e4:	1885003a 	cmpeq	r2,r3,r2
 18238e8:	e0bff605 	stb	r2,-40(fp)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 18238ec:	e0bff817 	ldw	r2,-32(fp)
 18238f0:	11000204 	addi	r4,r2,8
 18238f4:	e0bff603 	ldbu	r2,-40(fp)
 18238f8:	10000226 	beq	r2,zero,1823904 <etharp_arp_input+0x204>
 18238fc:	00800044 	movi	r2,1
 1823900:	00000106 	br	1823908 <etharp_arp_input+0x208>
 1823904:	00800084 	movi	r2,2
 1823908:	e0fff904 	addi	r3,fp,-28
 182390c:	100f883a 	mov	r7,r2
 1823910:	200d883a 	mov	r6,r4
 1823914:	180b883a 	mov	r5,r3
 1823918:	e13ffb17 	ldw	r4,-20(fp)
 182391c:	18232ec0 	call	18232ec <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 1823920:	e0bff817 	ldw	r2,-32(fp)
 1823924:	10c00183 	ldbu	r3,6(r2)
 1823928:	108001c3 	ldbu	r2,7(r2)
 182392c:	1004923a 	slli	r2,r2,8
 1823930:	10c4b03a 	or	r2,r2,r3
 1823934:	10bfffcc 	andi	r2,r2,65535
 1823938:	10c04020 	cmpeqi	r3,r2,256
 182393c:	1800031e 	bne	r3,zero,182394c <etharp_arp_input+0x24c>
 1823940:	10808020 	cmpeqi	r2,r2,512
 1823944:	10003d1e 	bne	r2,zero,1823a3c <etharp_arp_input+0x33c>
 1823948:	00004106 	br	1823a50 <etharp_arp_input+0x350>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
 182394c:	e0bff603 	ldbu	r2,-40(fp)
 1823950:	10004726 	beq	r2,zero,1823a70 <etharp_arp_input+0x370>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 1823954:	e0bff817 	ldw	r2,-32(fp)
 1823958:	10c00183 	ldbu	r3,6(r2)
 182395c:	1806703a 	and	r3,r3,zero
 1823960:	10c00185 	stb	r3,6(r2)
 1823964:	10c001c3 	ldbu	r3,7(r2)
 1823968:	1806703a 	and	r3,r3,zero
 182396c:	18c00094 	ori	r3,r3,2
 1823970:	10c001c5 	stb	r3,7(r2)

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 1823974:	e0bff817 	ldw	r2,-32(fp)
 1823978:	10c00604 	addi	r3,r2,24
 182397c:	e0bff817 	ldw	r2,-32(fp)
 1823980:	10800384 	addi	r2,r2,14
 1823984:	01800104 	movi	r6,4
 1823988:	100b883a 	mov	r5,r2
 182398c:	1809883a 	mov	r4,r3
 1823990:	180608c0 	call	180608c <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 1823994:	e0bff817 	ldw	r2,-32(fp)
 1823998:	10c00384 	addi	r3,r2,14
 182399c:	e0bffb17 	ldw	r2,-20(fp)
 18239a0:	10800104 	addi	r2,r2,4
 18239a4:	01800104 	movi	r6,4
 18239a8:	100b883a 	mov	r5,r2
 18239ac:	1809883a 	mov	r4,r3
 18239b0:	180608c0 	call	180608c <memcpy>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 18239b4:	e0bff817 	ldw	r2,-32(fp)
 18239b8:	10c00484 	addi	r3,r2,18
 18239bc:	e0bff817 	ldw	r2,-32(fp)
 18239c0:	10800204 	addi	r2,r2,8
 18239c4:	01800184 	movi	r6,6
 18239c8:	100b883a 	mov	r5,r2
 18239cc:	1809883a 	mov	r4,r3
 18239d0:	180608c0 	call	180608c <memcpy>
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 18239d4:	e0bff717 	ldw	r2,-36(fp)
 18239d8:	10c00084 	addi	r3,r2,2
 18239dc:	e0bff817 	ldw	r2,-32(fp)
 18239e0:	10800204 	addi	r2,r2,8
 18239e4:	01800184 	movi	r6,6
 18239e8:	100b883a 	mov	r5,r2
 18239ec:	1809883a 	mov	r4,r3
 18239f0:	180608c0 	call	180608c <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 18239f4:	e0bff817 	ldw	r2,-32(fp)
 18239f8:	10800204 	addi	r2,r2,8
 18239fc:	01800184 	movi	r6,6
 1823a00:	e17ffc17 	ldw	r5,-16(fp)
 1823a04:	1009883a 	mov	r4,r2
 1823a08:	180608c0 	call	180608c <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 1823a0c:	e0bff717 	ldw	r2,-36(fp)
 1823a10:	10800204 	addi	r2,r2,8
 1823a14:	01800184 	movi	r6,6
 1823a18:	e17ffc17 	ldw	r5,-16(fp)
 1823a1c:	1009883a 	mov	r4,r2
 1823a20:	180608c0 	call	180608c <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 1823a24:	e0bffb17 	ldw	r2,-20(fp)
 1823a28:	10800617 	ldw	r2,24(r2)
 1823a2c:	e17ffd17 	ldw	r5,-12(fp)
 1823a30:	e13ffb17 	ldw	r4,-20(fp)
 1823a34:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
 1823a38:	00000d06 	br	1823a70 <etharp_arp_input+0x370>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
 1823a3c:	e0bff904 	addi	r2,fp,-28
 1823a40:	100b883a 	mov	r5,r2
 1823a44:	e13ffb17 	ldw	r4,-20(fp)
 1823a48:	18166940 	call	1816694 <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
 1823a4c:	00000806 	br	1823a70 <etharp_arp_input+0x370>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
 1823a50:	008061f4 	movhi	r2,391
 1823a54:	10a9d404 	addi	r2,r2,-22704
 1823a58:	10801617 	ldw	r2,88(r2)
 1823a5c:	10c00044 	addi	r3,r2,1
 1823a60:	008061f4 	movhi	r2,391
 1823a64:	10a9d404 	addi	r2,r2,-22704
 1823a68:	10c01615 	stw	r3,88(r2)
    break;
 1823a6c:	0001883a 	nop
  }
  /* free ARP packet */
  pbuf_free(p);
 1823a70:	e13ffd17 	ldw	r4,-12(fp)
 1823a74:	181aca40 	call	181aca4 <pbuf_free>
}
 1823a78:	e037883a 	mov	sp,fp
 1823a7c:	dfc00117 	ldw	ra,4(sp)
 1823a80:	df000017 	ldw	fp,0(sp)
 1823a84:	dec00204 	addi	sp,sp,8
 1823a88:	f800283a 	ret

01823a8c <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 1823a8c:	defffb04 	addi	sp,sp,-20
 1823a90:	dfc00415 	stw	ra,16(sp)
 1823a94:	df000315 	stw	fp,12(sp)
 1823a98:	df000304 	addi	fp,sp,12
 1823a9c:	e13ffd15 	stw	r4,-12(fp)
 1823aa0:	e17ffe15 	stw	r5,-8(fp)
 1823aa4:	3005883a 	mov	r2,r6
 1823aa8:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 1823aac:	e0ffff03 	ldbu	r3,-4(fp)
 1823ab0:	00806134 	movhi	r2,388
 1823ab4:	109fbf04 	addi	r2,r2,32508
 1823ab8:	18c00524 	muli	r3,r3,20
 1823abc:	10c5883a 	add	r2,r2,r3
 1823ac0:	10800484 	addi	r2,r2,18
 1823ac4:	10800003 	ldbu	r2,0(r2)
 1823ac8:	10803fcc 	andi	r2,r2,255
 1823acc:	10800098 	cmpnei	r2,r2,2
 1823ad0:	10001f1e 	bne	r2,zero,1823b50 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 1823ad4:	e0ffff03 	ldbu	r3,-4(fp)
 1823ad8:	00806134 	movhi	r2,388
 1823adc:	109fbf04 	addi	r2,r2,32508
 1823ae0:	18c00524 	muli	r3,r3,20
 1823ae4:	10c5883a 	add	r2,r2,r3
 1823ae8:	108004c4 	addi	r2,r2,19
 1823aec:	10800003 	ldbu	r2,0(r2)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 1823af0:	10803fcc 	andi	r2,r2,255
 1823af4:	10803930 	cmpltui	r2,r2,228
 1823af8:	1000151e 	bne	r2,zero,1823b50 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 1823afc:	e0bfff03 	ldbu	r2,-4(fp)
 1823b00:	10800524 	muli	r2,r2,20
 1823b04:	10c00104 	addi	r3,r2,4
 1823b08:	00806134 	movhi	r2,388
 1823b0c:	109fbf04 	addi	r2,r2,32508
 1823b10:	1885883a 	add	r2,r3,r2
 1823b14:	100b883a 	mov	r5,r2
 1823b18:	e13ffd17 	ldw	r4,-12(fp)
 1823b1c:	18244840 	call	1824484 <etharp_request>
 1823b20:	10803fcc 	andi	r2,r2,255
 1823b24:	1080201c 	xori	r2,r2,128
 1823b28:	10bfe004 	addi	r2,r2,-128
 1823b2c:	1000081e 	bne	r2,zero,1823b50 <etharp_output_to_arp_index+0xc4>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 1823b30:	e0ffff03 	ldbu	r3,-4(fp)
 1823b34:	00806134 	movhi	r2,388
 1823b38:	109fbf04 	addi	r2,r2,32508
 1823b3c:	18c00524 	muli	r3,r3,20
 1823b40:	10c5883a 	add	r2,r2,r3
 1823b44:	10800484 	addi	r2,r2,18
 1823b48:	00c000c4 	movi	r3,3
 1823b4c:	10c00005 	stb	r3,0(r2)
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 1823b50:	e0bffd17 	ldw	r2,-12(fp)
 1823b54:	11000cc4 	addi	r4,r2,51
    &arp_table[arp_idx].ethaddr);
 1823b58:	e0bfff03 	ldbu	r2,-4(fp)
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 1823b5c:	10800524 	muli	r2,r2,20
 1823b60:	10c00304 	addi	r3,r2,12
 1823b64:	00806134 	movhi	r2,388
 1823b68:	109fbf04 	addi	r2,r2,32508
 1823b6c:	1885883a 	add	r2,r3,r2
 1823b70:	100f883a 	mov	r7,r2
 1823b74:	200d883a 	mov	r6,r4
 1823b78:	e17ffe17 	ldw	r5,-8(fp)
 1823b7c:	e13ffd17 	ldw	r4,-12(fp)
 1823b80:	18232480 	call	1823248 <etharp_send_ip>
    &arp_table[arp_idx].ethaddr);
}
 1823b84:	e037883a 	mov	sp,fp
 1823b88:	dfc00117 	ldw	ra,4(sp)
 1823b8c:	df000017 	ldw	fp,0(sp)
 1823b90:	dec00204 	addi	sp,sp,8
 1823b94:	f800283a 	ret

01823b98 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 1823b98:	defff704 	addi	sp,sp,-36
 1823b9c:	dfc00815 	stw	ra,32(sp)
 1823ba0:	df000715 	stw	fp,28(sp)
 1823ba4:	df000704 	addi	fp,sp,28
 1823ba8:	e13ffd15 	stw	r4,-12(fp)
 1823bac:	e17ffe15 	stw	r5,-8(fp)
 1823bb0:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
 1823bb4:	e0bfff17 	ldw	r2,-4(fp)
 1823bb8:	e0bffa15 	stw	r2,-24(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 1823bbc:	01400404 	movi	r5,16
 1823bc0:	e13ffe17 	ldw	r4,-8(fp)
 1823bc4:	181aaf40 	call	181aaf4 <pbuf_header>
 1823bc8:	10803fcc 	andi	r2,r2,255
 1823bcc:	10000926 	beq	r2,zero,1823bf4 <etharp_output+0x5c>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
 1823bd0:	008061f4 	movhi	r2,391
 1823bd4:	10a9d404 	addi	r2,r2,-22704
 1823bd8:	10800517 	ldw	r2,20(r2)
 1823bdc:	10c00044 	addi	r3,r2,1
 1823be0:	008061f4 	movhi	r2,391
 1823be4:	10a9d404 	addi	r2,r2,-22704
 1823be8:	10c00515 	stw	r3,20(r2)
    return ERR_BUF;
 1823bec:	00bfff84 	movi	r2,-2
 1823bf0:	00009f06 	br	1823e70 <etharp_output+0x2d8>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 1823bf4:	e0bfff17 	ldw	r2,-4(fp)
 1823bf8:	10800017 	ldw	r2,0(r2)
 1823bfc:	e17ffd17 	ldw	r5,-12(fp)
 1823c00:	1009883a 	mov	r4,r2
 1823c04:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 1823c08:	10803fcc 	andi	r2,r2,255
 1823c0c:	10000326 	beq	r2,zero,1823c1c <etharp_output+0x84>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 1823c10:	d0a01384 	addi	r2,gp,-32690
 1823c14:	e0bff915 	stw	r2,-28(fp)
 1823c18:	00008e06 	br	1823e54 <etharp_output+0x2bc>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 1823c1c:	e0bfff17 	ldw	r2,-4(fp)
 1823c20:	10800017 	ldw	r2,0(r2)
 1823c24:	10803c0c 	andi	r2,r2,240
 1823c28:	10803818 	cmpnei	r2,r2,224
 1823c2c:	1000131e 	bne	r2,zero,1823c7c <etharp_output+0xe4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 1823c30:	00800044 	movi	r2,1
 1823c34:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 1823c38:	e03ffbc5 	stb	zero,-17(fp)
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 1823c3c:	00801784 	movi	r2,94
 1823c40:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 1823c44:	e0bfff17 	ldw	r2,-4(fp)
 1823c48:	10800044 	addi	r2,r2,1
 1823c4c:	10800003 	ldbu	r2,0(r2)
 1823c50:	10801fcc 	andi	r2,r2,127
 1823c54:	e0bffc45 	stb	r2,-15(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 1823c58:	e0bfff17 	ldw	r2,-4(fp)
 1823c5c:	10800083 	ldbu	r2,2(r2)
 1823c60:	e0bffc85 	stb	r2,-14(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 1823c64:	e0bfff17 	ldw	r2,-4(fp)
 1823c68:	108000c3 	ldbu	r2,3(r2)
 1823c6c:	e0bffcc5 	stb	r2,-13(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 1823c70:	e0bffb84 	addi	r2,fp,-18
 1823c74:	e0bff915 	stw	r2,-28(fp)
 1823c78:	00007606 	br	1823e54 <etharp_output+0x2bc>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 1823c7c:	e0bfff17 	ldw	r2,-4(fp)
 1823c80:	10c00017 	ldw	r3,0(r2)
 1823c84:	e0bffd17 	ldw	r2,-12(fp)
 1823c88:	10800117 	ldw	r2,4(r2)
 1823c8c:	1886f03a 	xor	r3,r3,r2
 1823c90:	e0bffd17 	ldw	r2,-12(fp)
 1823c94:	10800217 	ldw	r2,8(r2)
 1823c98:	1884703a 	and	r2,r3,r2
 1823c9c:	10001126 	beq	r2,zero,1823ce4 <etharp_output+0x14c>
        !ip_addr_islinklocal(ipaddr)) {
 1823ca0:	e0bfff17 	ldw	r2,-4(fp)
 1823ca4:	10800017 	ldw	r2,0(r2)
 1823ca8:	10ffffcc 	andi	r3,r2,65535
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 1823cac:	00bfaa54 	movui	r2,65193
 1823cb0:	18800c26 	beq	r3,r2,1823ce4 <etharp_output+0x14c>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
 1823cb4:	e0bffd17 	ldw	r2,-12(fp)
 1823cb8:	10800304 	addi	r2,r2,12
 1823cbc:	10000726 	beq	r2,zero,1823cdc <etharp_output+0x144>
 1823cc0:	e0bffd17 	ldw	r2,-12(fp)
 1823cc4:	10800317 	ldw	r2,12(r2)
 1823cc8:	10000426 	beq	r2,zero,1823cdc <etharp_output+0x144>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
 1823ccc:	e0bffd17 	ldw	r2,-12(fp)
 1823cd0:	10800304 	addi	r2,r2,12
 1823cd4:	e0bffa15 	stw	r2,-24(fp)
 1823cd8:	00000206 	br	1823ce4 <etharp_output+0x14c>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
 1823cdc:	00bfff04 	movi	r2,-4
 1823ce0:	00006306 	br	1823e70 <etharp_output+0x2d8>
        }
      }
    }
#if LWIP_NETIF_HWADDRHINT
    if (netif->addr_hint != NULL) {
 1823ce4:	e0bffd17 	ldw	r2,-12(fp)
 1823ce8:	10801017 	ldw	r2,64(r2)
 1823cec:	10002826 	beq	r2,zero,1823d90 <etharp_output+0x1f8>
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
 1823cf0:	e0bffd17 	ldw	r2,-12(fp)
 1823cf4:	10801017 	ldw	r2,64(r2)
 1823cf8:	10800003 	ldbu	r2,0(r2)
 1823cfc:	e0bffb45 	stb	r2,-19(fp)
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
 1823d00:	e0bffb43 	ldbu	r2,-19(fp)
 1823d04:	10800668 	cmpgeui	r2,r2,25
 1823d08:	1000211e 	bne	r2,zero,1823d90 <etharp_output+0x1f8>
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 1823d0c:	e0fffb43 	ldbu	r3,-19(fp)
 1823d10:	00806134 	movhi	r2,388
 1823d14:	109fbf04 	addi	r2,r2,32508
 1823d18:	18c00524 	muli	r3,r3,20
 1823d1c:	10c5883a 	add	r2,r2,r3
 1823d20:	10800484 	addi	r2,r2,18
 1823d24:	10800003 	ldbu	r2,0(r2)
 1823d28:	10803fcc 	andi	r2,r2,255
 1823d2c:	108000b0 	cmpltui	r2,r2,2
 1823d30:	1000171e 	bne	r2,zero,1823d90 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 1823d34:	e0bffa17 	ldw	r2,-24(fp)
 1823d38:	10c00017 	ldw	r3,0(r2)
 1823d3c:	e13ffb43 	ldbu	r4,-19(fp)
 1823d40:	00806134 	movhi	r2,388
 1823d44:	109fbf04 	addi	r2,r2,32508
 1823d48:	21000524 	muli	r4,r4,20
 1823d4c:	1105883a 	add	r2,r2,r4
 1823d50:	10800104 	addi	r2,r2,4
 1823d54:	10800017 	ldw	r2,0(r2)
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 1823d58:	18800d1e 	bne	r3,r2,1823d90 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 1823d5c:	008061f4 	movhi	r2,391
 1823d60:	10a9d404 	addi	r2,r2,-22704
 1823d64:	10801717 	ldw	r2,92(r2)
 1823d68:	10c00044 	addi	r3,r2,1
 1823d6c:	008061f4 	movhi	r2,391
 1823d70:	10a9d404 	addi	r2,r2,-22704
 1823d74:	10c01715 	stw	r3,92(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 1823d78:	e0bffb43 	ldbu	r2,-19(fp)
 1823d7c:	100d883a 	mov	r6,r2
 1823d80:	e17ffe17 	ldw	r5,-8(fp)
 1823d84:	e13ffd17 	ldw	r4,-12(fp)
 1823d88:	1823a8c0 	call	1823a8c <etharp_output_to_arp_index>
 1823d8c:	00003806 	br	1823e70 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 1823d90:	e03ffb05 	stb	zero,-20(fp)
 1823d94:	00002706 	br	1823e34 <etharp_output+0x29c>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1823d98:	e0fffb07 	ldb	r3,-20(fp)
 1823d9c:	00806134 	movhi	r2,388
 1823da0:	109fbf04 	addi	r2,r2,32508
 1823da4:	18c00524 	muli	r3,r3,20
 1823da8:	10c5883a 	add	r2,r2,r3
 1823dac:	10800484 	addi	r2,r2,18
 1823db0:	10800003 	ldbu	r2,0(r2)
 1823db4:	10803fcc 	andi	r2,r2,255
 1823db8:	108000b0 	cmpltui	r2,r2,2
 1823dbc:	10001a1e 	bne	r2,zero,1823e28 <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 1823dc0:	e0bffa17 	ldw	r2,-24(fp)
 1823dc4:	10c00017 	ldw	r3,0(r2)
 1823dc8:	e13ffb07 	ldb	r4,-20(fp)
 1823dcc:	00806134 	movhi	r2,388
 1823dd0:	109fbf04 	addi	r2,r2,32508
 1823dd4:	21000524 	muli	r4,r4,20
 1823dd8:	1105883a 	add	r2,r2,r4
 1823ddc:	10800104 	addi	r2,r2,4
 1823de0:	10800017 	ldw	r2,0(r2)
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 1823de4:	1880101e 	bne	r3,r2,1823e28 <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 1823de8:	e0bffd17 	ldw	r2,-12(fp)
 1823dec:	10000726 	beq	r2,zero,1823e0c <etharp_output+0x274>
 1823df0:	e0bffd17 	ldw	r2,-12(fp)
 1823df4:	10801017 	ldw	r2,64(r2)
 1823df8:	10000426 	beq	r2,zero,1823e0c <etharp_output+0x274>
 1823dfc:	e0bffd17 	ldw	r2,-12(fp)
 1823e00:	10801017 	ldw	r2,64(r2)
 1823e04:	e0fffb03 	ldbu	r3,-20(fp)
 1823e08:	10c00005 	stb	r3,0(r2)
        return etharp_output_to_arp_index(netif, q, i);
 1823e0c:	e0bffb03 	ldbu	r2,-20(fp)
 1823e10:	10803fcc 	andi	r2,r2,255
 1823e14:	100d883a 	mov	r6,r2
 1823e18:	e17ffe17 	ldw	r5,-8(fp)
 1823e1c:	e13ffd17 	ldw	r4,-12(fp)
 1823e20:	1823a8c0 	call	1823a8c <etharp_output_to_arp_index>
 1823e24:	00001206 	br	1823e70 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 1823e28:	e0bffb03 	ldbu	r2,-20(fp)
 1823e2c:	10800044 	addi	r2,r2,1
 1823e30:	e0bffb05 	stb	r2,-20(fp)
 1823e34:	e0bffb07 	ldb	r2,-20(fp)
 1823e38:	10800650 	cmplti	r2,r2,25
 1823e3c:	103fd61e 	bne	r2,zero,1823d98 <__ram_exceptions_end+0xff813954>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 1823e40:	e1bffe17 	ldw	r6,-8(fp)
 1823e44:	e17ffa17 	ldw	r5,-24(fp)
 1823e48:	e13ffd17 	ldw	r4,-12(fp)
 1823e4c:	1823e840 	call	1823e84 <etharp_query>
 1823e50:	00000706 	br	1823e70 <etharp_output+0x2d8>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 1823e54:	e0bffd17 	ldw	r2,-12(fp)
 1823e58:	10800cc4 	addi	r2,r2,51
 1823e5c:	e1fff917 	ldw	r7,-28(fp)
 1823e60:	100d883a 	mov	r6,r2
 1823e64:	e17ffe17 	ldw	r5,-8(fp)
 1823e68:	e13ffd17 	ldw	r4,-12(fp)
 1823e6c:	18232480 	call	1823248 <etharp_send_ip>
}
 1823e70:	e037883a 	mov	sp,fp
 1823e74:	dfc00117 	ldw	ra,4(sp)
 1823e78:	df000017 	ldw	fp,0(sp)
 1823e7c:	dec00204 	addi	sp,sp,8
 1823e80:	f800283a 	ret

01823e84 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 1823e84:	defff404 	addi	sp,sp,-48
 1823e88:	dfc00b15 	stw	ra,44(sp)
 1823e8c:	df000a15 	stw	fp,40(sp)
 1823e90:	df000a04 	addi	fp,sp,40
 1823e94:	e13ffd15 	stw	r4,-12(fp)
 1823e98:	e17ffe15 	stw	r5,-8(fp)
 1823e9c:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 1823ea0:	e0bffd17 	ldw	r2,-12(fp)
 1823ea4:	10800cc4 	addi	r2,r2,51
 1823ea8:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
 1823eac:	00bfffc4 	movi	r2,-1
 1823eb0:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 1823eb4:	e0bffe17 	ldw	r2,-8(fp)
 1823eb8:	10800017 	ldw	r2,0(r2)
 1823ebc:	e17ffd17 	ldw	r5,-12(fp)
 1823ec0:	1009883a 	mov	r4,r2
 1823ec4:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 1823ec8:	10803fcc 	andi	r2,r2,255
 1823ecc:	10000a1e 	bne	r2,zero,1823ef8 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
 1823ed0:	e0bffe17 	ldw	r2,-8(fp)
 1823ed4:	10800017 	ldw	r2,0(r2)
 1823ed8:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 1823edc:	10803820 	cmpeqi	r2,r2,224
 1823ee0:	1000051e 	bne	r2,zero,1823ef8 <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
 1823ee4:	e0bffe17 	ldw	r2,-8(fp)
 1823ee8:	10000326 	beq	r2,zero,1823ef8 <etharp_query+0x74>
      ip_addr_isany(ipaddr)) {
 1823eec:	e0bffe17 	ldw	r2,-8(fp)
 1823ef0:	10800017 	ldw	r2,0(r2)
 1823ef4:	1000021e 	bne	r2,zero,1823f00 <etharp_query+0x7c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 1823ef8:	00bffc84 	movi	r2,-14
 1823efc:	0000c906 	br	1824224 <etharp_query+0x3a0>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 1823f00:	01400044 	movi	r5,1
 1823f04:	e13ffe17 	ldw	r4,-8(fp)
 1823f08:	1822f300 	call	1822f30 <etharp_find_entry>
 1823f0c:	e0bffb05 	stb	r2,-20(fp)

  /* could not find or create entry? */
  if (i < 0) {
 1823f10:	e0bffb07 	ldb	r2,-20(fp)
 1823f14:	10000b0e 	bge	r2,zero,1823f44 <etharp_query+0xc0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
 1823f18:	e0bfff17 	ldw	r2,-4(fp)
 1823f1c:	10000726 	beq	r2,zero,1823f3c <etharp_query+0xb8>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
 1823f20:	008061f4 	movhi	r2,391
 1823f24:	10a9d404 	addi	r2,r2,-22704
 1823f28:	10801217 	ldw	r2,72(r2)
 1823f2c:	10c00044 	addi	r3,r2,1
 1823f30:	008061f4 	movhi	r2,391
 1823f34:	10a9d404 	addi	r2,r2,-22704
 1823f38:	10c01215 	stw	r3,72(r2)
    }
    return (err_t)i;
 1823f3c:	e0bffb03 	ldbu	r2,-20(fp)
 1823f40:	0000b806 	br	1824224 <etharp_query+0x3a0>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 1823f44:	e0fffb07 	ldb	r3,-20(fp)
 1823f48:	00806134 	movhi	r2,388
 1823f4c:	109fbf04 	addi	r2,r2,32508
 1823f50:	18c00524 	muli	r3,r3,20
 1823f54:	10c5883a 	add	r2,r2,r3
 1823f58:	10800484 	addi	r2,r2,18
 1823f5c:	10800003 	ldbu	r2,0(r2)
 1823f60:	10803fcc 	andi	r2,r2,255
 1823f64:	1000081e 	bne	r2,zero,1823f88 <etharp_query+0x104>
    arp_table[i].state = ETHARP_STATE_PENDING;
 1823f68:	e0fffb07 	ldb	r3,-20(fp)
 1823f6c:	00806134 	movhi	r2,388
 1823f70:	109fbf04 	addi	r2,r2,32508
 1823f74:	18c00524 	muli	r3,r3,20
 1823f78:	10c5883a 	add	r2,r2,r3
 1823f7c:	10800484 	addi	r2,r2,18
 1823f80:	00c00044 	movi	r3,1
 1823f84:	10c00005 	stb	r3,0(r2)
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 1823f88:	e0fffb07 	ldb	r3,-20(fp)
 1823f8c:	00806134 	movhi	r2,388
 1823f90:	109fbf04 	addi	r2,r2,32508
 1823f94:	18c00524 	muli	r3,r3,20
 1823f98:	10c5883a 	add	r2,r2,r3
 1823f9c:	10800484 	addi	r2,r2,18
 1823fa0:	10800003 	ldbu	r2,0(r2)
 1823fa4:	10803fcc 	andi	r2,r2,255
 1823fa8:	10800060 	cmpeqi	r2,r2,1
 1823fac:	1000021e 	bne	r2,zero,1823fb8 <etharp_query+0x134>
 1823fb0:	e0bfff17 	ldw	r2,-4(fp)
 1823fb4:	1000081e 	bne	r2,zero,1823fd8 <etharp_query+0x154>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 1823fb8:	e17ffe17 	ldw	r5,-8(fp)
 1823fbc:	e13ffd17 	ldw	r4,-12(fp)
 1823fc0:	18244840 	call	1824484 <etharp_request>
 1823fc4:	e0bff605 	stb	r2,-40(fp)
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 1823fc8:	e0bfff17 	ldw	r2,-4(fp)
 1823fcc:	1000021e 	bne	r2,zero,1823fd8 <etharp_query+0x154>
      return result;
 1823fd0:	e0bff603 	ldbu	r2,-40(fp)
 1823fd4:	00009306 	br	1824224 <etharp_query+0x3a0>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 1823fd8:	e0fffb07 	ldb	r3,-20(fp)
 1823fdc:	00806134 	movhi	r2,388
 1823fe0:	109fbf04 	addi	r2,r2,32508
 1823fe4:	18c00524 	muli	r3,r3,20
 1823fe8:	10c5883a 	add	r2,r2,r3
 1823fec:	10800484 	addi	r2,r2,18
 1823ff0:	10800003 	ldbu	r2,0(r2)
 1823ff4:	10803fcc 	andi	r2,r2,255
 1823ff8:	108000b0 	cmpltui	r2,r2,2
 1823ffc:	1000161e 	bne	r2,zero,1824058 <etharp_query+0x1d4>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 1824000:	e0bffd17 	ldw	r2,-12(fp)
 1824004:	10000726 	beq	r2,zero,1824024 <etharp_query+0x1a0>
 1824008:	e0bffd17 	ldw	r2,-12(fp)
 182400c:	10801017 	ldw	r2,64(r2)
 1824010:	10000426 	beq	r2,zero,1824024 <etharp_query+0x1a0>
 1824014:	e0bffd17 	ldw	r2,-12(fp)
 1824018:	10801017 	ldw	r2,64(r2)
 182401c:	e0fffb03 	ldbu	r3,-20(fp)
 1824020:	10c00005 	stb	r3,0(r2)
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 1824024:	e0bffb07 	ldb	r2,-20(fp)
 1824028:	10800524 	muli	r2,r2,20
 182402c:	10c00304 	addi	r3,r2,12
 1824030:	00806134 	movhi	r2,388
 1824034:	109fbf04 	addi	r2,r2,32508
 1824038:	1885883a 	add	r2,r3,r2
 182403c:	100f883a 	mov	r7,r2
 1824040:	e1bffa17 	ldw	r6,-24(fp)
 1824044:	e17fff17 	ldw	r5,-4(fp)
 1824048:	e13ffd17 	ldw	r4,-12(fp)
 182404c:	18232480 	call	1823248 <etharp_send_ip>
 1824050:	e0bff605 	stb	r2,-40(fp)
 1824054:	00007206 	br	1824220 <etharp_query+0x39c>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 1824058:	e0fffb07 	ldb	r3,-20(fp)
 182405c:	00806134 	movhi	r2,388
 1824060:	109fbf04 	addi	r2,r2,32508
 1824064:	18c00524 	muli	r3,r3,20
 1824068:	10c5883a 	add	r2,r2,r3
 182406c:	10800484 	addi	r2,r2,18
 1824070:	10800003 	ldbu	r2,0(r2)
 1824074:	10803fcc 	andi	r2,r2,255
 1824078:	10800058 	cmpnei	r2,r2,1
 182407c:	1000681e 	bne	r2,zero,1824220 <etharp_query+0x39c>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
 1824080:	e03ff815 	stw	zero,-32(fp)
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
 1824084:	e0bfff17 	ldw	r2,-4(fp)
 1824088:	e0bff715 	stw	r2,-36(fp)
    while (p) {
 182408c:	00000b06 	br	18240bc <etharp_query+0x238>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 1824090:	e0bff717 	ldw	r2,-36(fp)
 1824094:	10800303 	ldbu	r2,12(r2)
 1824098:	10803fcc 	andi	r2,r2,255
 182409c:	10800060 	cmpeqi	r2,r2,1
 18240a0:	1000031e 	bne	r2,zero,18240b0 <etharp_query+0x22c>
        copy_needed = 1;
 18240a4:	00800044 	movi	r2,1
 18240a8:	e0bff815 	stw	r2,-32(fp)
        break;
 18240ac:	00000506 	br	18240c4 <etharp_query+0x240>
      }
      p = p->next;
 18240b0:	e0bff717 	ldw	r2,-36(fp)
 18240b4:	10800017 	ldw	r2,0(r2)
 18240b8:	e0bff715 	stw	r2,-36(fp)
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
 18240bc:	e0bff717 	ldw	r2,-36(fp)
 18240c0:	103ff31e 	bne	r2,zero,1824090 <__ram_exceptions_end+0xff813c4c>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
 18240c4:	e0bff817 	ldw	r2,-32(fp)
 18240c8:	10001526 	beq	r2,zero,1824120 <etharp_query+0x29c>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 18240cc:	e0bff717 	ldw	r2,-36(fp)
 18240d0:	1080020b 	ldhu	r2,8(r2)
 18240d4:	10bfffcc 	andi	r2,r2,65535
 18240d8:	000d883a 	mov	r6,zero
 18240dc:	100b883a 	mov	r5,r2
 18240e0:	010000c4 	movi	r4,3
 18240e4:	181a4e80 	call	181a4e8 <pbuf_alloc>
 18240e8:	e0bff715 	stw	r2,-36(fp)
      if(p != NULL) {
 18240ec:	e0bff717 	ldw	r2,-36(fp)
 18240f0:	10000f26 	beq	r2,zero,1824130 <etharp_query+0x2ac>
        if (pbuf_copy(p, q) != ERR_OK) {
 18240f4:	e17fff17 	ldw	r5,-4(fp)
 18240f8:	e13ff717 	ldw	r4,-36(fp)
 18240fc:	181b04c0 	call	181b04c <pbuf_copy>
 1824100:	10803fcc 	andi	r2,r2,255
 1824104:	1080201c 	xori	r2,r2,128
 1824108:	10bfe004 	addi	r2,r2,-128
 182410c:	10000826 	beq	r2,zero,1824130 <etharp_query+0x2ac>
          pbuf_free(p);
 1824110:	e13ff717 	ldw	r4,-36(fp)
 1824114:	181aca40 	call	181aca4 <pbuf_free>
          p = NULL;
 1824118:	e03ff715 	stw	zero,-36(fp)
 182411c:	00000406 	br	1824130 <etharp_query+0x2ac>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
 1824120:	e0bfff17 	ldw	r2,-4(fp)
 1824124:	e0bff715 	stw	r2,-36(fp)
      pbuf_ref(p);
 1824128:	e13ff717 	ldw	r4,-36(fp)
 182412c:	181ae340 	call	181ae34 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
 1824130:	e0bff717 	ldw	r2,-36(fp)
 1824134:	10003126 	beq	r2,zero,18241fc <etharp_query+0x378>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
 1824138:	010002c4 	movi	r4,11
 182413c:	18349580 	call	1834958 <memp_malloc>
 1824140:	e0bffc15 	stw	r2,-16(fp)
      if (new_entry != NULL) {
 1824144:	e0bffc17 	ldw	r2,-16(fp)
 1824148:	10002726 	beq	r2,zero,18241e8 <etharp_query+0x364>
        new_entry->next = 0;
 182414c:	e0bffc17 	ldw	r2,-16(fp)
 1824150:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
 1824154:	e0bffc17 	ldw	r2,-16(fp)
 1824158:	e0fff717 	ldw	r3,-36(fp)
 182415c:	10c00115 	stw	r3,4(r2)
        if(arp_table[i].q != NULL) {
 1824160:	e0fffb07 	ldb	r3,-20(fp)
 1824164:	00806134 	movhi	r2,388
 1824168:	109fbf04 	addi	r2,r2,32508
 182416c:	18c00524 	muli	r3,r3,20
 1824170:	10c5883a 	add	r2,r2,r3
 1824174:	10800017 	ldw	r2,0(r2)
 1824178:	10001226 	beq	r2,zero,18241c4 <etharp_query+0x340>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
 182417c:	e0fffb07 	ldb	r3,-20(fp)
 1824180:	00806134 	movhi	r2,388
 1824184:	109fbf04 	addi	r2,r2,32508
 1824188:	18c00524 	muli	r3,r3,20
 182418c:	10c5883a 	add	r2,r2,r3
 1824190:	10800017 	ldw	r2,0(r2)
 1824194:	e0bff915 	stw	r2,-28(fp)
          while (r->next != NULL) {
 1824198:	00000306 	br	18241a8 <etharp_query+0x324>
            r = r->next;
 182419c:	e0bff917 	ldw	r2,-28(fp)
 18241a0:	10800017 	ldw	r2,0(r2)
 18241a4:	e0bff915 	stw	r2,-28(fp)
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
 18241a8:	e0bff917 	ldw	r2,-28(fp)
 18241ac:	10800017 	ldw	r2,0(r2)
 18241b0:	103ffa1e 	bne	r2,zero,182419c <__ram_exceptions_end+0xff813d58>
            r = r->next;
          }
          r->next = new_entry;
 18241b4:	e0bff917 	ldw	r2,-28(fp)
 18241b8:	e0fffc17 	ldw	r3,-16(fp)
 18241bc:	10c00015 	stw	r3,0(r2)
 18241c0:	00000706 	br	18241e0 <etharp_query+0x35c>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
 18241c4:	e0fffb07 	ldb	r3,-20(fp)
 18241c8:	00806134 	movhi	r2,388
 18241cc:	109fbf04 	addi	r2,r2,32508
 18241d0:	18c00524 	muli	r3,r3,20
 18241d4:	10c5883a 	add	r2,r2,r3
 18241d8:	e0fffc17 	ldw	r3,-16(fp)
 18241dc:	10c00015 	stw	r3,0(r2)
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
 18241e0:	e03ff605 	stb	zero,-40(fp)
 18241e4:	00000e06 	br	1824220 <etharp_query+0x39c>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
 18241e8:	e13ff717 	ldw	r4,-36(fp)
 18241ec:	181aca40 	call	181aca4 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
 18241f0:	00bfffc4 	movi	r2,-1
 18241f4:	e0bff605 	stb	r2,-40(fp)
 18241f8:	00000906 	br	1824220 <etharp_query+0x39c>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
 18241fc:	008061f4 	movhi	r2,391
 1824200:	10a9d404 	addi	r2,r2,-22704
 1824204:	10801217 	ldw	r2,72(r2)
 1824208:	10c00044 	addi	r3,r2,1
 182420c:	008061f4 	movhi	r2,391
 1824210:	10a9d404 	addi	r2,r2,-22704
 1824214:	10c01215 	stw	r3,72(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 1824218:	00bfffc4 	movi	r2,-1
 182421c:	e0bff605 	stb	r2,-40(fp)
    }
  }
  return result;
 1824220:	e0bff603 	ldbu	r2,-40(fp)
}
 1824224:	e037883a 	mov	sp,fp
 1824228:	dfc00117 	ldw	ra,4(sp)
 182422c:	df000017 	ldw	fp,0(sp)
 1824230:	dec00204 	addi	sp,sp,8
 1824234:	f800283a 	ret

01824238 <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
 1824238:	defff504 	addi	sp,sp,-44
 182423c:	dfc00a15 	stw	ra,40(sp)
 1824240:	df000915 	stw	fp,36(sp)
 1824244:	df000904 	addi	fp,sp,36
 1824248:	e13ffb15 	stw	r4,-20(fp)
 182424c:	e17ffc15 	stw	r5,-16(fp)
 1824250:	e1bffd15 	stw	r6,-12(fp)
 1824254:	e1fffe15 	stw	r7,-8(fp)
 1824258:	e0800517 	ldw	r2,20(fp)
 182425c:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
 1824260:	e03ff705 	stb	zero,-36(fp)
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 1824264:	000d883a 	mov	r6,zero
 1824268:	01400b04 	movi	r5,44
 182426c:	010000c4 	movi	r4,3
 1824270:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1824274:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 1824278:	e0bff817 	ldw	r2,-32(fp)
 182427c:	1000091e 	bne	r2,zero,18242a4 <etharp_raw+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
 1824280:	008061f4 	movhi	r2,391
 1824284:	10a9d404 	addi	r2,r2,-22704
 1824288:	10801217 	ldw	r2,72(r2)
 182428c:	10c00044 	addi	r3,r2,1
 1824290:	008061f4 	movhi	r2,391
 1824294:	10a9d404 	addi	r2,r2,-22704
 1824298:	10c01215 	stw	r3,72(r2)
    return ERR_MEM;
 182429c:	00bfffc4 	movi	r2,-1
 18242a0:	00007306 	br	1824470 <etharp_raw+0x238>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 18242a4:	e0bff817 	ldw	r2,-32(fp)
 18242a8:	10800117 	ldw	r2,4(r2)
 18242ac:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 18242b0:	e0bff917 	ldw	r2,-28(fp)
 18242b4:	10800404 	addi	r2,r2,16
 18242b8:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 18242bc:	e0bfff0b 	ldhu	r2,-4(fp)
 18242c0:	1004d23a 	srli	r2,r2,8
 18242c4:	1007883a 	mov	r3,r2
 18242c8:	e0bfff0b 	ldhu	r2,-4(fp)
 18242cc:	1004923a 	slli	r2,r2,8
 18242d0:	1884b03a 	or	r2,r3,r2
 18242d4:	100d883a 	mov	r6,r2
 18242d8:	e0bffa17 	ldw	r2,-24(fp)
 18242dc:	30ffffcc 	andi	r3,r6,65535
 18242e0:	19403fcc 	andi	r5,r3,255
 18242e4:	10c00183 	ldbu	r3,6(r2)
 18242e8:	1806703a 	and	r3,r3,zero
 18242ec:	1809883a 	mov	r4,r3
 18242f0:	2807883a 	mov	r3,r5
 18242f4:	20c6b03a 	or	r3,r4,r3
 18242f8:	10c00185 	stb	r3,6(r2)
 18242fc:	30ffffcc 	andi	r3,r6,65535
 1824300:	1806d23a 	srli	r3,r3,8
 1824304:	197fffcc 	andi	r5,r3,65535
 1824308:	10c001c3 	ldbu	r3,7(r2)
 182430c:	1806703a 	and	r3,r3,zero
 1824310:	1809883a 	mov	r4,r3
 1824314:	2807883a 	mov	r3,r5
 1824318:	20c6b03a 	or	r3,r4,r3
 182431c:	10c001c5 	stb	r3,7(r2)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 1824320:	e0bffa17 	ldw	r2,-24(fp)
 1824324:	10800204 	addi	r2,r2,8
 1824328:	01800184 	movi	r6,6
 182432c:	e17ffe17 	ldw	r5,-8(fp)
 1824330:	1009883a 	mov	r4,r2
 1824334:	180608c0 	call	180608c <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 1824338:	e0bffa17 	ldw	r2,-24(fp)
 182433c:	10800484 	addi	r2,r2,18
 1824340:	01800184 	movi	r6,6
 1824344:	e1400317 	ldw	r5,12(fp)
 1824348:	1009883a 	mov	r4,r2
 182434c:	180608c0 	call	180608c <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 1824350:	e0bff917 	ldw	r2,-28(fp)
 1824354:	10800084 	addi	r2,r2,2
 1824358:	01800184 	movi	r6,6
 182435c:	e17ffd17 	ldw	r5,-12(fp)
 1824360:	1009883a 	mov	r4,r2
 1824364:	180608c0 	call	180608c <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 1824368:	e0bff917 	ldw	r2,-28(fp)
 182436c:	10800204 	addi	r2,r2,8
 1824370:	01800184 	movi	r6,6
 1824374:	e17ffc17 	ldw	r5,-16(fp)
 1824378:	1009883a 	mov	r4,r2
 182437c:	180608c0 	call	180608c <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 1824380:	e0bffa17 	ldw	r2,-24(fp)
 1824384:	10800384 	addi	r2,r2,14
 1824388:	01800104 	movi	r6,4
 182438c:	e1400217 	ldw	r5,8(fp)
 1824390:	1009883a 	mov	r4,r2
 1824394:	180608c0 	call	180608c <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 1824398:	e0bffa17 	ldw	r2,-24(fp)
 182439c:	10800604 	addi	r2,r2,24
 18243a0:	01800104 	movi	r6,4
 18243a4:	e1400417 	ldw	r5,16(fp)
 18243a8:	1009883a 	mov	r4,r2
 18243ac:	180608c0 	call	180608c <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 18243b0:	e0bffa17 	ldw	r2,-24(fp)
 18243b4:	10c00003 	ldbu	r3,0(r2)
 18243b8:	1806703a 	and	r3,r3,zero
 18243bc:	10c00005 	stb	r3,0(r2)
 18243c0:	10c00043 	ldbu	r3,1(r2)
 18243c4:	1806703a 	and	r3,r3,zero
 18243c8:	18c00054 	ori	r3,r3,1
 18243cc:	10c00045 	stb	r3,1(r2)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 18243d0:	e0bffa17 	ldw	r2,-24(fp)
 18243d4:	10c00083 	ldbu	r3,2(r2)
 18243d8:	1806703a 	and	r3,r3,zero
 18243dc:	18c00214 	ori	r3,r3,8
 18243e0:	10c00085 	stb	r3,2(r2)
 18243e4:	10c000c3 	ldbu	r3,3(r2)
 18243e8:	1806703a 	and	r3,r3,zero
 18243ec:	10c000c5 	stb	r3,3(r2)
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 18243f0:	e0bffa17 	ldw	r2,-24(fp)
 18243f4:	00c00184 	movi	r3,6
 18243f8:	10c00105 	stb	r3,4(r2)
  hdr->protolen = sizeof(ip_addr_t);
 18243fc:	e0bffa17 	ldw	r2,-24(fp)
 1824400:	00c00104 	movi	r3,4
 1824404:	10c00145 	stb	r3,5(r2)

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 1824408:	e0bff917 	ldw	r2,-28(fp)
 182440c:	10c00383 	ldbu	r3,14(r2)
 1824410:	1806703a 	and	r3,r3,zero
 1824414:	18c00214 	ori	r3,r3,8
 1824418:	10c00385 	stb	r3,14(r2)
 182441c:	10c003c3 	ldbu	r3,15(r2)
 1824420:	1806703a 	and	r3,r3,zero
 1824424:	18c00194 	ori	r3,r3,6
 1824428:	10c003c5 	stb	r3,15(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 182442c:	e0bffb17 	ldw	r2,-20(fp)
 1824430:	10800617 	ldw	r2,24(r2)
 1824434:	e17ff817 	ldw	r5,-32(fp)
 1824438:	e13ffb17 	ldw	r4,-20(fp)
 182443c:	103ee83a 	callr	r2
 1824440:	e0bff705 	stb	r2,-36(fp)
  ETHARP_STATS_INC(etharp.xmit);
 1824444:	008061f4 	movhi	r2,391
 1824448:	10a9d404 	addi	r2,r2,-22704
 182444c:	10800c17 	ldw	r2,48(r2)
 1824450:	10c00044 	addi	r3,r2,1
 1824454:	008061f4 	movhi	r2,391
 1824458:	10a9d404 	addi	r2,r2,-22704
 182445c:	10c00c15 	stw	r3,48(r2)
  /* free ARP query packet */
  pbuf_free(p);
 1824460:	e13ff817 	ldw	r4,-32(fp)
 1824464:	181aca40 	call	181aca4 <pbuf_free>
  p = NULL;
 1824468:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
 182446c:	e0bff703 	ldbu	r2,-36(fp)
}
 1824470:	e037883a 	mov	sp,fp
 1824474:	dfc00117 	ldw	ra,4(sp)
 1824478:	df000017 	ldw	fp,0(sp)
 182447c:	dec00204 	addi	sp,sp,8
 1824480:	f800283a 	ret

01824484 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 1824484:	defff804 	addi	sp,sp,-32
 1824488:	dfc00715 	stw	ra,28(sp)
 182448c:	df000615 	stw	fp,24(sp)
 1824490:	df000604 	addi	fp,sp,24
 1824494:	e13ffe15 	stw	r4,-8(fp)
 1824498:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 182449c:	e0bffe17 	ldw	r2,-8(fp)
 18244a0:	11000cc4 	addi	r4,r2,51
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 18244a4:	e0bffe17 	ldw	r2,-8(fp)
 18244a8:	11400cc4 	addi	r5,r2,51
 18244ac:	e0bffe17 	ldw	r2,-8(fp)
 18244b0:	10800104 	addi	r2,r2,4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 18244b4:	00c00044 	movi	r3,1
 18244b8:	d8c00315 	stw	r3,12(sp)
 18244bc:	e0ffff17 	ldw	r3,-4(fp)
 18244c0:	d8c00215 	stw	r3,8(sp)
 18244c4:	d0e01504 	addi	r3,gp,-32684
 18244c8:	d8c00115 	stw	r3,4(sp)
 18244cc:	d8800015 	stw	r2,0(sp)
 18244d0:	280f883a 	mov	r7,r5
 18244d4:	d1a01384 	addi	r6,gp,-32690
 18244d8:	200b883a 	mov	r5,r4
 18244dc:	e13ffe17 	ldw	r4,-8(fp)
 18244e0:	18242380 	call	1824238 <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 18244e4:	e037883a 	mov	sp,fp
 18244e8:	dfc00117 	ldw	ra,4(sp)
 18244ec:	df000017 	ldw	fp,0(sp)
 18244f0:	dec00204 	addi	sp,sp,8
 18244f4:	f800283a 	ret

018244f8 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 18244f8:	defff904 	addi	sp,sp,-28
 18244fc:	dfc00615 	stw	ra,24(sp)
 1824500:	df000515 	stw	fp,20(sp)
 1824504:	df000504 	addi	fp,sp,20
 1824508:	e13ffe15 	stw	r4,-8(fp)
 182450c:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
 1824510:	00800404 	movi	r2,16
 1824514:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 1824518:	e0bffe17 	ldw	r2,-8(fp)
 182451c:	1080028b 	ldhu	r2,10(r2)
 1824520:	10bfffcc 	andi	r2,r2,65535
 1824524:	10800468 	cmpgeui	r2,r2,17
 1824528:	10000f1e 	bne	r2,zero,1824568 <ethernet_input+0x70>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 182452c:	008061f4 	movhi	r2,391
 1824530:	10a9d404 	addi	r2,r2,-22704
 1824534:	10801417 	ldw	r2,80(r2)
 1824538:	10c00044 	addi	r3,r2,1
 182453c:	008061f4 	movhi	r2,391
 1824540:	10a9d404 	addi	r2,r2,-22704
 1824544:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 1824548:	008061f4 	movhi	r2,391
 182454c:	10a9d404 	addi	r2,r2,-22704
 1824550:	10800f17 	ldw	r2,60(r2)
 1824554:	10c00044 	addi	r3,r2,1
 1824558:	008061f4 	movhi	r2,391
 182455c:	10a9d404 	addi	r2,r2,-22704
 1824560:	10c00f15 	stw	r3,60(r2)
    goto free_and_return;
 1824564:	00006e06 	br	1824720 <ethernet_input+0x228>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 1824568:	e0bffe17 	ldw	r2,-8(fp)
 182456c:	10800117 	ldw	r2,4(r2)
 1824570:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
 1824574:	e0bffc17 	ldw	r2,-16(fp)
 1824578:	10c00383 	ldbu	r3,14(r2)
 182457c:	108003c3 	ldbu	r2,15(r2)
 1824580:	1004923a 	slli	r2,r2,8
 1824584:	10c4b03a 	or	r2,r2,r3
 1824588:	e0bffd0d 	sth	r2,-12(fp)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 182458c:	e0bffc17 	ldw	r2,-16(fp)
 1824590:	10800083 	ldbu	r2,2(r2)
 1824594:	10803fcc 	andi	r2,r2,255
 1824598:	1080004c 	andi	r2,r2,1
 182459c:	10002226 	beq	r2,zero,1824628 <ethernet_input+0x130>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 18245a0:	e0bffc17 	ldw	r2,-16(fp)
 18245a4:	10800083 	ldbu	r2,2(r2)
 18245a8:	10803fcc 	andi	r2,r2,255
 18245ac:	10800058 	cmpnei	r2,r2,1
 18245b0:	1000101e 	bne	r2,zero,18245f4 <ethernet_input+0xfc>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 18245b4:	e0bffc17 	ldw	r2,-16(fp)
 18245b8:	108000c3 	ldbu	r2,3(r2)
 18245bc:	10803fcc 	andi	r2,r2,255
 18245c0:	1000191e 	bne	r2,zero,1824628 <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
 18245c4:	e0bffc17 	ldw	r2,-16(fp)
 18245c8:	10800103 	ldbu	r2,4(r2)
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 18245cc:	10803fcc 	andi	r2,r2,255
 18245d0:	10801798 	cmpnei	r2,r2,94
 18245d4:	1000141e 	bne	r2,zero,1824628 <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 18245d8:	e0bffe17 	ldw	r2,-8(fp)
 18245dc:	10800343 	ldbu	r2,13(r2)
 18245e0:	10800414 	ori	r2,r2,16
 18245e4:	1007883a 	mov	r3,r2
 18245e8:	e0bffe17 	ldw	r2,-8(fp)
 18245ec:	10c00345 	stb	r3,13(r2)
 18245f0:	00000d06 	br	1824628 <ethernet_input+0x130>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 18245f4:	e0bffc17 	ldw	r2,-16(fp)
 18245f8:	10800084 	addi	r2,r2,2
 18245fc:	01800184 	movi	r6,6
 1824600:	d1601384 	addi	r5,gp,-32690
 1824604:	1009883a 	mov	r4,r2
 1824608:	183d0580 	call	183d058 <memcmp>
 182460c:	1000061e 	bne	r2,zero,1824628 <ethernet_input+0x130>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 1824610:	e0bffe17 	ldw	r2,-8(fp)
 1824614:	10800343 	ldbu	r2,13(r2)
 1824618:	10800214 	ori	r2,r2,8
 182461c:	1007883a 	mov	r3,r2
 1824620:	e0bffe17 	ldw	r2,-8(fp)
 1824624:	10c00345 	stb	r3,13(r2)
    }
  }

  switch (type) {
 1824628:	e0bffd0b 	ldhu	r2,-12(fp)
 182462c:	10c00220 	cmpeqi	r3,r2,8
 1824630:	1800031e 	bne	r3,zero,1824640 <ethernet_input+0x148>
 1824634:	10818220 	cmpeqi	r2,r2,1544
 1824638:	1000171e 	bne	r2,zero,1824698 <ethernet_input+0x1a0>
 182463c:	00002206 	br	18246c8 <ethernet_input+0x1d0>
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 1824640:	e0bfff17 	ldw	r2,-4(fp)
 1824644:	10800e43 	ldbu	r2,57(r2)
 1824648:	10803fcc 	andi	r2,r2,255
 182464c:	1080080c 	andi	r2,r2,32
 1824650:	10002e26 	beq	r2,zero,182470c <ethernet_input+0x214>
        goto free_and_return;
      }
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
 1824654:	e17ffe17 	ldw	r5,-8(fp)
 1824658:	e13fff17 	ldw	r4,-4(fp)
 182465c:	18236180 	call	1823618 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
 1824660:	e0bffb0b 	ldhu	r2,-20(fp)
 1824664:	0085c83a 	sub	r2,zero,r2
 1824668:	10bfffcc 	andi	r2,r2,65535
 182466c:	10a0001c 	xori	r2,r2,32768
 1824670:	10a00004 	addi	r2,r2,-32768
 1824674:	100b883a 	mov	r5,r2
 1824678:	e13ffe17 	ldw	r4,-8(fp)
 182467c:	181aaf40 	call	181aaf4 <pbuf_header>
 1824680:	10803fcc 	andi	r2,r2,255
 1824684:	1000231e 	bne	r2,zero,1824714 <ethernet_input+0x21c>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 1824688:	e17fff17 	ldw	r5,-4(fp)
 182468c:	e13ffe17 	ldw	r4,-8(fp)
 1824690:	18323300 	call	1832330 <ip_input>
      }
      break;
 1824694:	00001b06 	br	1824704 <ethernet_input+0x20c>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 1824698:	e0bfff17 	ldw	r2,-4(fp)
 182469c:	10800e43 	ldbu	r2,57(r2)
 18246a0:	10803fcc 	andi	r2,r2,255
 18246a4:	1080080c 	andi	r2,r2,32
 18246a8:	10001c26 	beq	r2,zero,182471c <ethernet_input+0x224>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 18246ac:	e0bfff17 	ldw	r2,-4(fp)
 18246b0:	10800cc4 	addi	r2,r2,51
 18246b4:	e1bffe17 	ldw	r6,-8(fp)
 18246b8:	100b883a 	mov	r5,r2
 18246bc:	e13fff17 	ldw	r4,-4(fp)
 18246c0:	18237000 	call	1823700 <etharp_arp_input>
      break;
 18246c4:	00000f06 	br	1824704 <ethernet_input+0x20c>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
 18246c8:	008061f4 	movhi	r2,391
 18246cc:	10a9d404 	addi	r2,r2,-22704
 18246d0:	10801417 	ldw	r2,80(r2)
 18246d4:	10c00044 	addi	r3,r2,1
 18246d8:	008061f4 	movhi	r2,391
 18246dc:	10a9d404 	addi	r2,r2,-22704
 18246e0:	10c01415 	stw	r3,80(r2)
      ETHARP_STATS_INC(etharp.drop);
 18246e4:	008061f4 	movhi	r2,391
 18246e8:	10a9d404 	addi	r2,r2,-22704
 18246ec:	10800f17 	ldw	r2,60(r2)
 18246f0:	10c00044 	addi	r3,r2,1
 18246f4:	008061f4 	movhi	r2,391
 18246f8:	10a9d404 	addi	r2,r2,-22704
 18246fc:	10c00f15 	stw	r3,60(r2)
      goto free_and_return;
 1824700:	00000706 	br	1824720 <ethernet_input+0x228>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 1824704:	0005883a 	mov	r2,zero
 1824708:	00000806 	br	182472c <ethernet_input+0x234>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 182470c:	0001883a 	nop
 1824710:	00000306 	br	1824720 <ethernet_input+0x228>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
 1824714:	0001883a 	nop
 1824718:	00000106 	br	1824720 <ethernet_input+0x228>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 182471c:	0001883a 	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 1824720:	e13ffe17 	ldw	r4,-8(fp)
 1824724:	181aca40 	call	181aca4 <pbuf_free>
  return ERR_OK;
 1824728:	0005883a 	mov	r2,zero
}
 182472c:	e037883a 	mov	sp,fp
 1824730:	dfc00117 	ldw	ra,4(sp)
 1824734:	df000017 	ldw	fp,0(sp)
 1824738:	dec00204 	addi	sp,sp,8
 182473c:	f800283a 	ret

01824740 <ping_send>:
#define LWIP_PING_DATA_LENGTH			10

static u16_t ping_seq_num;
static u32_t ping_time;

err_t ping_send(int s, ip_addr_t *addr, u8_t *data, u16_t size) {
 1824740:	defff104 	addi	sp,sp,-60
 1824744:	dfc00e15 	stw	ra,56(sp)
 1824748:	df000d15 	stw	fp,52(sp)
 182474c:	df000d04 	addi	fp,sp,52
 1824750:	e13ffc15 	stw	r4,-16(fp)
 1824754:	e17ffd15 	stw	r5,-12(fp)
 1824758:	e1bffe15 	stw	r6,-8(fp)
 182475c:	3805883a 	mov	r2,r7
 1824760:	e0bfff0d 	sth	r2,-4(fp)
	int err;
	struct icmp_echo_hdr *iecho;
	struct sockaddr_in to;
	size_t total_size = sizeof(struct icmp_echo_hdr) + size;
 1824764:	e0bfff0b 	ldhu	r2,-4(fp)
 1824768:	10800204 	addi	r2,r2,8
 182476c:	e0bff515 	stw	r2,-44(fp)

	LWIP_ASSERT("ping_size is too big", total_size <= 0xffff);

	iecho = (struct icmp_echo_hdr *)mem_malloc(total_size);
 1824770:	e0bff517 	ldw	r2,-44(fp)
 1824774:	10bfffcc 	andi	r2,r2,65535
 1824778:	1009883a 	mov	r4,r2
 182477c:	18197f00 	call	18197f0 <mem_malloc>
 1824780:	e0bff615 	stw	r2,-40(fp)
	if (!iecho)
 1824784:	e0bff617 	ldw	r2,-40(fp)
 1824788:	1000021e 	bne	r2,zero,1824794 <ping_send+0x54>
		return ERR_MEM;
 182478c:	00bfffc4 	movi	r2,-1
 1824790:	00006f06 	br	1824950 <ping_send+0x210>

	// increase ping counter
	++ping_seq_num;
 1824794:	d0a8000b 	ldhu	r2,-24576(gp)
 1824798:	10800044 	addi	r2,r2,1
 182479c:	d0a8000d 	sth	r2,-24576(gp)

	// set appropriate data
	ICMPH_TYPE_SET(iecho, ICMP_ECHO);
 18247a0:	e0bff617 	ldw	r2,-40(fp)
 18247a4:	00c00204 	movi	r3,8
 18247a8:	10c00005 	stb	r3,0(r2)
	ICMPH_CODE_SET(iecho, 0);
 18247ac:	e0bff617 	ldw	r2,-40(fp)
 18247b0:	10000045 	stb	zero,1(r2)
	iecho->chksum = 0;
 18247b4:	e0bff617 	ldw	r2,-40(fp)
 18247b8:	10c00083 	ldbu	r3,2(r2)
 18247bc:	1806703a 	and	r3,r3,zero
 18247c0:	10c00085 	stb	r3,2(r2)
 18247c4:	10c000c3 	ldbu	r3,3(r2)
 18247c8:	1806703a 	and	r3,r3,zero
 18247cc:	10c000c5 	stb	r3,3(r2)
	iecho->id     = PING_ID;
 18247d0:	e0bff617 	ldw	r2,-40(fp)
 18247d4:	10c00103 	ldbu	r3,4(r2)
 18247d8:	1806703a 	and	r3,r3,zero
 18247dc:	1809883a 	mov	r4,r3
 18247e0:	00ffebc4 	movi	r3,-81
 18247e4:	20c6b03a 	or	r3,r4,r3
 18247e8:	10c00105 	stb	r3,4(r2)
 18247ec:	10c00143 	ldbu	r3,5(r2)
 18247f0:	1806703a 	and	r3,r3,zero
 18247f4:	1809883a 	mov	r4,r3
 18247f8:	00ffebc4 	movi	r3,-81
 18247fc:	20c6b03a 	or	r3,r4,r3
 1824800:	10c00145 	stb	r3,5(r2)
	iecho->seqno  = htons(ping_seq_num); // you can't assume that htons is a function if it's a macro with 2 shifts the counter will be incremented 2 times...
 1824804:	d0a8000b 	ldhu	r2,-24576(gp)
 1824808:	10bfffcc 	andi	r2,r2,65535
 182480c:	1004d23a 	srli	r2,r2,8
 1824810:	1007883a 	mov	r3,r2
 1824814:	d0a8000b 	ldhu	r2,-24576(gp)
 1824818:	10bfffcc 	andi	r2,r2,65535
 182481c:	1004923a 	slli	r2,r2,8
 1824820:	1884b03a 	or	r2,r3,r2
 1824824:	100d883a 	mov	r6,r2
 1824828:	e0bff617 	ldw	r2,-40(fp)
 182482c:	30ffffcc 	andi	r3,r6,65535
 1824830:	19403fcc 	andi	r5,r3,255
 1824834:	10c00183 	ldbu	r3,6(r2)
 1824838:	1806703a 	and	r3,r3,zero
 182483c:	1809883a 	mov	r4,r3
 1824840:	2807883a 	mov	r3,r5
 1824844:	20c6b03a 	or	r3,r4,r3
 1824848:	10c00185 	stb	r3,6(r2)
 182484c:	30ffffcc 	andi	r3,r6,65535
 1824850:	1806d23a 	srli	r3,r3,8
 1824854:	197fffcc 	andi	r5,r3,65535
 1824858:	10c001c3 	ldbu	r3,7(r2)
 182485c:	1806703a 	and	r3,r3,zero
 1824860:	1809883a 	mov	r4,r3
 1824864:	2807883a 	mov	r3,r5
 1824868:	20c6b03a 	or	r3,r4,r3
 182486c:	10c001c5 	stb	r3,7(r2)

	// fill additional data in the buffer
	memcpy((((char*)iecho) + sizeof(struct icmp_echo_hdr)), data, size);
 1824870:	e0bff617 	ldw	r2,-40(fp)
 1824874:	10800204 	addi	r2,r2,8
 1824878:	e0ffff0b 	ldhu	r3,-4(fp)
 182487c:	180d883a 	mov	r6,r3
 1824880:	e17ffe17 	ldw	r5,-8(fp)
 1824884:	1009883a 	mov	r4,r2
 1824888:	180608c0 	call	180608c <memcpy>

	// calculate the checksum
	iecho->chksum = inet_chksum(iecho, total_size);
 182488c:	e0bff517 	ldw	r2,-44(fp)
 1824890:	10bfffcc 	andi	r2,r2,65535
 1824894:	100b883a 	mov	r5,r2
 1824898:	e13ff617 	ldw	r4,-40(fp)
 182489c:	18320980 	call	1832098 <inet_chksum>
 18248a0:	100d883a 	mov	r6,r2
 18248a4:	e0bff617 	ldw	r2,-40(fp)
 18248a8:	30ffffcc 	andi	r3,r6,65535
 18248ac:	19403fcc 	andi	r5,r3,255
 18248b0:	10c00083 	ldbu	r3,2(r2)
 18248b4:	1806703a 	and	r3,r3,zero
 18248b8:	1809883a 	mov	r4,r3
 18248bc:	2807883a 	mov	r3,r5
 18248c0:	20c6b03a 	or	r3,r4,r3
 18248c4:	10c00085 	stb	r3,2(r2)
 18248c8:	30ffffcc 	andi	r3,r6,65535
 18248cc:	1806d23a 	srli	r3,r3,8
 18248d0:	197fffcc 	andi	r5,r3,65535
 18248d4:	10c000c3 	ldbu	r3,3(r2)
 18248d8:	1806703a 	and	r3,r3,zero
 18248dc:	1809883a 	mov	r4,r3
 18248e0:	2807883a 	mov	r3,r5
 18248e4:	20c6b03a 	or	r3,r4,r3
 18248e8:	10c000c5 	stb	r3,3(r2)

	// set the appropriate ethernet header
	to.sin_len = sizeof(to);
 18248ec:	00800404 	movi	r2,16
 18248f0:	e0bff805 	stb	r2,-32(fp)
	to.sin_family = AF_INET;
 18248f4:	00800084 	movi	r2,2
 18248f8:	e0bff845 	stb	r2,-31(fp)
	inet_addr_from_ipaddr(&to.sin_addr, addr);
 18248fc:	e0bffd17 	ldw	r2,-12(fp)
 1824900:	10800017 	ldw	r2,0(r2)
 1824904:	e0bff915 	stw	r2,-28(fp)
	//to.sin_addr.s_addr = addr->addr;

	// send the packet
	err = sendto(s, iecho, total_size, 0, (struct sockaddr*)&to, sizeof(to));
 1824908:	00800404 	movi	r2,16
 182490c:	d8800115 	stw	r2,4(sp)
 1824910:	e0bff804 	addi	r2,fp,-32
 1824914:	d8800015 	stw	r2,0(sp)
 1824918:	000f883a 	mov	r7,zero
 182491c:	e1bff517 	ldw	r6,-44(fp)
 1824920:	e17ff617 	ldw	r5,-40(fp)
 1824924:	e13ffc17 	ldw	r4,-16(fp)
 1824928:	18299980 	call	1829998 <lwip_sendto>
 182492c:	e0bff715 	stw	r2,-36(fp)
	if (err < 0)
		LWIP_DEBUGF(PING_DEBUG, ("Couldn't send ICMP Ping packet!\n"));

	// clear the ping object
	mem_free(iecho);
 1824930:	e13ff617 	ldw	r4,-40(fp)
 1824934:	18193dc0 	call	18193dc <mem_free>

	// how did it turn out?
	return ((err == (int)total_size) ? ERR_OK : ERR_VAL);
 1824938:	e0bff517 	ldw	r2,-44(fp)
 182493c:	e0fff717 	ldw	r3,-36(fp)
 1824940:	1880021e 	bne	r3,r2,182494c <ping_send+0x20c>
 1824944:	0005883a 	mov	r2,zero
 1824948:	00000106 	br	1824950 <ping_send+0x210>
 182494c:	00bffe84 	movi	r2,-6
}
 1824950:	e037883a 	mov	sp,fp
 1824954:	dfc00117 	ldw	ra,4(sp)
 1824958:	df000017 	ldw	fp,0(sp)
 182495c:	dec00204 	addi	sp,sp,8
 1824960:	f800283a 	ret

01824964 <ping_recv>:

int ping_recv(int s)
{
 1824964:	deffe204 	addi	sp,sp,-120
 1824968:	dfc01d15 	stw	ra,116(sp)
 182496c:	df001c15 	stw	fp,112(sp)
 1824970:	df001c04 	addi	fp,sp,112
 1824974:	e13fff15 	stw	r4,-4(fp)
	struct sockaddr_in from;
	struct ip_hdr *iphdr;
	struct icmp_echo_hdr *iecho;

	// remember that there is a one minute timeout on on the receive function ;)
	while ((len = recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, (socklen_t*)&fromlen)) > 0) {
 1824978:	00002b06 	br	1824a28 <ping_recv+0xc4>
		if (len >= (int)(sizeof(struct ip_hdr)+sizeof(struct icmp_echo_hdr))) {
 182497c:	e0bfe617 	ldw	r2,-104(fp)
 1824980:	10800710 	cmplti	r2,r2,28
 1824984:	1000281e 	bne	r2,zero,1824a28 <ping_recv+0xc4>
			ip_addr_t fromaddr;

			inet_addr_to_ipaddr(&fromaddr, &from.sin_addr);
 1824988:	e0bffb17 	ldw	r2,-20(fp)
 182498c:	e0bffe15 	stw	r2,-8(fp)

			LWIP_DEBUGF( PING_DEBUG, ("ping: recv "));
			ip_addr_debug_print(PING_DEBUG, &fromaddr);
			LWIP_DEBUGF( PING_DEBUG, (" %"U32_F" ms\n", (sys_now() - ping_time)));

			iphdr = (struct ip_hdr *)buf;
 1824990:	e0bfe904 	addi	r2,fp,-92
 1824994:	e0bfe715 	stw	r2,-100(fp)
			iecho = (struct icmp_echo_hdr *)(buf + (IPH_HL(iphdr) * 4));
 1824998:	e0bfe717 	ldw	r2,-100(fp)
 182499c:	10800003 	ldbu	r2,0(r2)
 18249a0:	10803fcc 	andi	r2,r2,255
 18249a4:	108003cc 	andi	r2,r2,15
 18249a8:	1085883a 	add	r2,r2,r2
 18249ac:	1085883a 	add	r2,r2,r2
 18249b0:	1007883a 	mov	r3,r2
 18249b4:	e0bfe904 	addi	r2,fp,-92
 18249b8:	10c5883a 	add	r2,r2,r3
 18249bc:	e0bfe815 	stw	r2,-96(fp)

			if ((iecho->id == PING_ID) && (iecho->seqno == htons(ping_seq_num))) {
 18249c0:	e0bfe817 	ldw	r2,-96(fp)
 18249c4:	10c00103 	ldbu	r3,4(r2)
 18249c8:	10800143 	ldbu	r2,5(r2)
 18249cc:	1004923a 	slli	r2,r2,8
 18249d0:	10c4b03a 	or	r2,r2,r3
 18249d4:	10ffffcc 	andi	r3,r2,65535
 18249d8:	00abebd4 	movui	r2,44975
 18249dc:	1880121e 	bne	r3,r2,1824a28 <ping_recv+0xc4>
 18249e0:	e0bfe817 	ldw	r2,-96(fp)
 18249e4:	10c00183 	ldbu	r3,6(r2)
 18249e8:	108001c3 	ldbu	r2,7(r2)
 18249ec:	1004923a 	slli	r2,r2,8
 18249f0:	10c4b03a 	or	r2,r2,r3
 18249f4:	10ffffcc 	andi	r3,r2,65535
 18249f8:	d0a8000b 	ldhu	r2,-24576(gp)
 18249fc:	10bfffcc 	andi	r2,r2,65535
 1824a00:	1004d23a 	srli	r2,r2,8
 1824a04:	113fffcc 	andi	r4,r2,65535
 1824a08:	d0a8000b 	ldhu	r2,-24576(gp)
 1824a0c:	10bfffcc 	andi	r2,r2,65535
 1824a10:	1004923a 	slli	r2,r2,8
 1824a14:	10bfffcc 	andi	r2,r2,65535
 1824a18:	2084b03a 	or	r2,r4,r2
 1824a1c:	1880021e 	bne	r3,r2,1824a28 <ping_recv+0xc4>
				return 1;
 1824a20:	00800044 	movi	r2,1
 1824a24:	00000e06 	br	1824a60 <ping_recv+0xfc>
	struct sockaddr_in from;
	struct ip_hdr *iphdr;
	struct icmp_echo_hdr *iecho;

	// remember that there is a one minute timeout on on the receive function ;)
	while ((len = recvfrom(s, buf, sizeof(buf), 0, (struct sockaddr*)&from, (socklen_t*)&fromlen)) > 0) {
 1824a28:	e0ffe904 	addi	r3,fp,-92
 1824a2c:	e0bff904 	addi	r2,fp,-28
 1824a30:	d8800115 	stw	r2,4(sp)
 1824a34:	e0bffa04 	addi	r2,fp,-24
 1824a38:	d8800015 	stw	r2,0(sp)
 1824a3c:	000f883a 	mov	r7,zero
 1824a40:	01801004 	movi	r6,64
 1824a44:	180b883a 	mov	r5,r3
 1824a48:	e13fff17 	ldw	r4,-4(fp)
 1824a4c:	18292e00 	call	18292e0 <lwip_recvfrom>
 1824a50:	e0bfe615 	stw	r2,-104(fp)
 1824a54:	e0bfe617 	ldw	r2,-104(fp)
 1824a58:	00bfc816 	blt	zero,r2,182497c <__ram_exceptions_end+0xff814538>
	if (len == 0) {
		LWIP_DEBUGF( PING_DEBUG, ("ping: recv - %"U32_F" ms - timeout\n", (sys_now()-ping_time)));
	}

	/* do some ping result processing */
	return -EXIT_FAILURE;
 1824a5c:	00bfffc4 	movi	r2,-1
}
 1824a60:	e037883a 	mov	sp,fp
 1824a64:	dfc00117 	ldw	ra,4(sp)
 1824a68:	df000017 	ldw	fp,0(sp)
 1824a6c:	dec00204 	addi	sp,sp,8
 1824a70:	f800283a 	ret

01824a74 <lwip_ping_target>:

int lwip_ping_target(u32_t addr, u8_t packets, int get_response, u8_t size)
{
 1824a74:	defff504 	addi	sp,sp,-44
 1824a78:	dfc00a15 	stw	ra,40(sp)
 1824a7c:	df000915 	stw	fp,36(sp)
 1824a80:	dc000815 	stw	r16,32(sp)
 1824a84:	df000904 	addi	fp,sp,36
 1824a88:	e13ffb15 	stw	r4,-20(fp)
 1824a8c:	e1bffd15 	stw	r6,-12(fp)
 1824a90:	3809883a 	mov	r4,r7
 1824a94:	e17ffc05 	stb	r5,-16(fp)
 1824a98:	e13ffe05 	stb	r4,-8(fp)
 1824a9c:	d809883a 	mov	r4,sp
 1824aa0:	2021883a 	mov	r16,r4
	u8_t buf[size];
 1824aa4:	e13ffe03 	ldbu	r4,-8(fp)
 1824aa8:	21403fcc 	andi	r5,r4,255
 1824aac:	297fffc4 	addi	r5,r5,-1
 1824ab0:	e17ff915 	stw	r5,-28(fp)
 1824ab4:	21403fcc 	andi	r5,r4,255
 1824ab8:	2819883a 	mov	r12,r5
 1824abc:	001b883a 	mov	r13,zero
 1824ac0:	600ad77a 	srli	r5,r12,29
 1824ac4:	681290fa 	slli	r9,r13,3
 1824ac8:	2a52b03a 	or	r9,r5,r9
 1824acc:	601090fa 	slli	r8,r12,3
 1824ad0:	21403fcc 	andi	r5,r4,255
 1824ad4:	2815883a 	mov	r10,r5
 1824ad8:	0017883a 	mov	r11,zero
 1824adc:	500ad77a 	srli	r5,r10,29
 1824ae0:	580690fa 	slli	r3,r11,3
 1824ae4:	28c6b03a 	or	r3,r5,r3
 1824ae8:	500490fa 	slli	r2,r10,3
 1824aec:	20803fcc 	andi	r2,r4,255
 1824af0:	108000c4 	addi	r2,r2,3
 1824af4:	1004d0ba 	srli	r2,r2,2
 1824af8:	1085883a 	add	r2,r2,r2
 1824afc:	1085883a 	add	r2,r2,r2
 1824b00:	d8b7c83a 	sub	sp,sp,r2
 1824b04:	d8800104 	addi	r2,sp,4
 1824b08:	1005883a 	mov	r2,r2
 1824b0c:	e0bffa15 	stw	r2,-24(fp)
	int idx;

	// fill dummy data
	for (idx = 0; idx < size; idx++)
 1824b10:	e03ff815 	stw	zero,-32(fp)
 1824b14:	00000906 	br	1824b3c <lwip_ping_target+0xc8>
		buf[idx] = idx;
 1824b18:	e0bff817 	ldw	r2,-32(fp)
 1824b1c:	1009883a 	mov	r4,r2
 1824b20:	e0fffa17 	ldw	r3,-24(fp)
 1824b24:	e0bff817 	ldw	r2,-32(fp)
 1824b28:	1885883a 	add	r2,r3,r2
 1824b2c:	11000005 	stb	r4,0(r2)
{
	u8_t buf[size];
	int idx;

	// fill dummy data
	for (idx = 0; idx < size; idx++)
 1824b30:	e0bff817 	ldw	r2,-32(fp)
 1824b34:	10800044 	addi	r2,r2,1
 1824b38:	e0bff815 	stw	r2,-32(fp)
 1824b3c:	e0bffe03 	ldbu	r2,-8(fp)
 1824b40:	e0fff817 	ldw	r3,-32(fp)
 1824b44:	18bff416 	blt	r3,r2,1824b18 <__ram_exceptions_end+0xff8146d4>
		buf[idx] = idx;

	// send this
	return lwip_ping_target_data(addr, packets, get_response, buf, size);
 1824b48:	e0fffc03 	ldbu	r3,-16(fp)
 1824b4c:	e13ffa17 	ldw	r4,-24(fp)
 1824b50:	e0bffe03 	ldbu	r2,-8(fp)
 1824b54:	d8800015 	stw	r2,0(sp)
 1824b58:	200f883a 	mov	r7,r4
 1824b5c:	e1bffd17 	ldw	r6,-12(fp)
 1824b60:	180b883a 	mov	r5,r3
 1824b64:	e13ffb17 	ldw	r4,-20(fp)
 1824b68:	1824b880 	call	1824b88 <lwip_ping_target_data>
 1824b6c:	8037883a 	mov	sp,r16
}
 1824b70:	e6ffff04 	addi	sp,fp,-4
 1824b74:	dfc00217 	ldw	ra,8(sp)
 1824b78:	df000117 	ldw	fp,4(sp)
 1824b7c:	dc000017 	ldw	r16,0(sp)
 1824b80:	dec00304 	addi	sp,sp,12
 1824b84:	f800283a 	ret

01824b88 <lwip_ping_target_data>:

int lwip_ping_target_data(u32_t addr, u8_t packets, int get_response, u8_t *data, u16_t size)
{
 1824b88:	defff404 	addi	sp,sp,-48
 1824b8c:	dfc00b15 	stw	ra,44(sp)
 1824b90:	df000a15 	stw	fp,40(sp)
 1824b94:	df000a04 	addi	fp,sp,40
 1824b98:	e13ffb15 	stw	r4,-20(fp)
 1824b9c:	2807883a 	mov	r3,r5
 1824ba0:	e1bffd15 	stw	r6,-12(fp)
 1824ba4:	e1fffe15 	stw	r7,-8(fp)
 1824ba8:	e0800217 	ldw	r2,8(fp)
 1824bac:	e0fffc05 	stb	r3,-16(fp)
 1824bb0:	e0bfff0d 	sth	r2,-4(fp)
	int s;
	ip_addr_t ping_target;
	int pongcnt = 0;
 1824bb4:	e03ff715 	stw	zero,-36(fp)
	int timeout = PING_RCV_TIMEO;
 1824bb8:	0080fa04 	movi	r2,1000
 1824bbc:	e0bffa15 	stw	r2,-24(fp)

	// open our raw socket
	if ((s = socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)) < 0)
 1824bc0:	01800044 	movi	r6,1
 1824bc4:	014000c4 	movi	r5,3
 1824bc8:	01000084 	movi	r4,2
 1824bcc:	1829b900 	call	1829b90 <lwip_socket>
 1824bd0:	e0bff815 	stw	r2,-32(fp)
 1824bd4:	e0bff817 	ldw	r2,-32(fp)
 1824bd8:	1000020e 	bge	r2,zero,1824be4 <lwip_ping_target_data+0x5c>
		return -EXIT_SUCCESS;
 1824bdc:	0005883a 	mov	r2,zero
 1824be0:	00003406 	br	1824cb4 <lwip_ping_target_data+0x12c>

	if (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0)
 1824be4:	e0fffa04 	addi	r3,fp,-24
 1824be8:	00800104 	movi	r2,4
 1824bec:	d8800015 	stw	r2,0(sp)
 1824bf0:	180f883a 	mov	r7,r3
 1824bf4:	01840184 	movi	r6,4102
 1824bf8:	0143ffc4 	movi	r5,4095
 1824bfc:	e13ff817 	ldw	r4,-32(fp)
 1824c00:	182b2f80 	call	182b2f8 <lwip_setsockopt>
		LWIP_DEBUGF(PING_DEBUG, ("Couldn't set ping receive socket timeout\n"));

	while (packets--) {
 1824c04:	00002306 	br	1824c94 <lwip_ping_target_data+0x10c>
		ping_target.addr = addr; // addr should already be converted with htonl just like normal socket operations
 1824c08:	e0bffb17 	ldw	r2,-20(fp)
 1824c0c:	e0bff915 	stw	r2,-28(fp)

		if (ping_send(s, &ping_target, data, size) == ERR_OK) {
 1824c10:	e0ffff0b 	ldhu	r3,-4(fp)
 1824c14:	e0bff904 	addi	r2,fp,-28
 1824c18:	180f883a 	mov	r7,r3
 1824c1c:	e1bffe17 	ldw	r6,-8(fp)
 1824c20:	100b883a 	mov	r5,r2
 1824c24:	e13ff817 	ldw	r4,-32(fp)
 1824c28:	18247400 	call	1824740 <ping_send>
 1824c2c:	10803fcc 	andi	r2,r2,255
 1824c30:	1080201c 	xori	r2,r2,128
 1824c34:	10bfe004 	addi	r2,r2,-128
 1824c38:	10000f1e 	bne	r2,zero,1824c78 <lwip_ping_target_data+0xf0>

			ip_addr_debug_print(PING_DEBUG, &ping_target);

			LWIP_DEBUGF( PING_DEBUG, ("\n"));

			ping_time = sys_now();
 1824c3c:	1814ee40 	call	1814ee4 <sys_now>
 1824c40:	d0a80115 	stw	r2,-24572(gp)

			// get the pong if we we ever receive one
			if (get_response)
 1824c44:	e0bffd17 	ldw	r2,-12(fp)
 1824c48:	10000726 	beq	r2,zero,1824c68 <lwip_ping_target_data+0xe0>
				pongcnt += ping_recv(s);
 1824c4c:	e13ff817 	ldw	r4,-32(fp)
 1824c50:	18249640 	call	1824964 <ping_recv>
 1824c54:	1007883a 	mov	r3,r2
 1824c58:	e0bff717 	ldw	r2,-36(fp)
 1824c5c:	10c5883a 	add	r2,r2,r3
 1824c60:	e0bff715 	stw	r2,-36(fp)
 1824c64:	00000706 	br	1824c84 <lwip_ping_target_data+0xfc>
			else
				pongcnt++;
 1824c68:	e0bff717 	ldw	r2,-36(fp)
 1824c6c:	10800044 	addi	r2,r2,1
 1824c70:	e0bff715 	stw	r2,-36(fp)
 1824c74:	00000306 	br	1824c84 <lwip_ping_target_data+0xfc>

			ip_addr_debug_print(PING_DEBUG, &ping_target);

			LWIP_DEBUGF( PING_DEBUG, (" - error\n"));

			pongcnt--;
 1824c78:	e0bff717 	ldw	r2,-36(fp)
 1824c7c:	10bfffc4 	addi	r2,r2,-1
 1824c80:	e0bff715 	stw	r2,-36(fp)
		}

		// if we need to send more packets, w'll wait a bit
		if (packets)
 1824c84:	e0bffc03 	ldbu	r2,-16(fp)
 1824c88:	10000226 	beq	r2,zero,1824c94 <lwip_ping_target_data+0x10c>
			sys_msleep(PING_DELAY);
 1824c8c:	0100fa04 	movi	r4,1000
 1824c90:	18350f80 	call	18350f8 <sys_msleep>
		return -EXIT_SUCCESS;

	if (setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0)
		LWIP_DEBUGF(PING_DEBUG, ("Couldn't set ping receive socket timeout\n"));

	while (packets--) {
 1824c94:	e0bffc03 	ldbu	r2,-16(fp)
 1824c98:	10ffffc4 	addi	r3,r2,-1
 1824c9c:	e0fffc05 	stb	r3,-16(fp)
 1824ca0:	10803fcc 	andi	r2,r2,255
 1824ca4:	103fd81e 	bne	r2,zero,1824c08 <__ram_exceptions_end+0xff8147c4>
		// if we need to send more packets, w'll wait a bit
		if (packets)
			sys_msleep(PING_DELAY);
	}

	close(s);
 1824ca8:	e13ff817 	ldw	r4,-32(fp)
 1824cac:	18132c00 	call	18132c0 <close>

	return pongcnt;
 1824cb0:	e0bff717 	ldw	r2,-36(fp)
}
 1824cb4:	e037883a 	mov	sp,fp
 1824cb8:	dfc00117 	ldw	ra,4(sp)
 1824cbc:	df000017 	ldw	fp,0(sp)
 1824cc0:	dec00204 	addi	sp,sp,8
 1824cc4:	f800283a 	ret

01824cc8 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 1824cc8:	defffd04 	addi	sp,sp,-12
 1824ccc:	dfc00215 	stw	ra,8(sp)
 1824cd0:	df000115 	stw	fp,4(sp)
 1824cd4:	df000104 	addi	fp,sp,4
 1824cd8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 1824cdc:	d1600804 	addi	r5,gp,-32736
 1824ce0:	e13fff17 	ldw	r4,-4(fp)
 1824ce4:	1827bd80 	call	1827bd8 <alt_dev_llist_insert>
}
 1824ce8:	e037883a 	mov	sp,fp
 1824cec:	dfc00117 	ldw	ra,4(sp)
 1824cf0:	df000017 	ldw	fp,0(sp)
 1824cf4:	dec00204 	addi	sp,sp,8
 1824cf8:	f800283a 	ret

01824cfc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 1824cfc:	defffd04 	addi	sp,sp,-12
 1824d00:	dfc00215 	stw	ra,8(sp)
 1824d04:	df000115 	stw	fp,4(sp)
 1824d08:	df000104 	addi	fp,sp,4
 1824d0c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU_0, cpu_0);
 1824d10:	18287fc0 	call	18287fc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 1824d14:	00800044 	movi	r2,1
 1824d18:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 1824d1c:	0001883a 	nop
 1824d20:	e037883a 	mov	sp,fp
 1824d24:	dfc00117 	ldw	ra,4(sp)
 1824d28:	df000017 	ldw	fp,0(sp)
 1824d2c:	dec00204 	addi	sp,sp,8
 1824d30:	f800283a 	ret

01824d34 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1824d34:	defffe04 	addi	sp,sp,-8
 1824d38:	dfc00115 	stw	ra,4(sp)
 1824d3c:	df000015 	stw	fp,0(sp)
 1824d40:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 1824d44:	01c0fa04 	movi	r7,1000
 1824d48:	018000c4 	movi	r6,3
 1824d4c:	000b883a 	mov	r5,zero
 1824d50:	010080b4 	movhi	r4,514
 1824d54:	21040804 	addi	r4,r4,4128
 1824d58:	18267540 	call	1826754 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 1824d5c:	01800084 	movi	r6,2
 1824d60:	000b883a 	mov	r5,zero
 1824d64:	01006134 	movhi	r4,388
 1824d68:	21126904 	addi	r4,r4,18852
 1824d6c:	1824f440 	call	1824f44 <altera_avalon_jtag_uart_init>
 1824d70:	01006134 	movhi	r4,388
 1824d74:	21125f04 	addi	r4,r4,18812
 1824d78:	1824cc80 	call	1824cc8 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_RX_0, sgdma_tse_rx_0);
 1824d7c:	000d883a 	mov	r6,zero
 1824d80:	000b883a 	mov	r5,zero
 1824d84:	01006134 	movhi	r4,388
 1824d88:	21167904 	addi	r4,r4,23012
 1824d8c:	18266340 	call	1826634 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_TX_0, sgdma_tse_tx_0);
 1824d90:	01800044 	movi	r6,1
 1824d94:	000b883a 	mov	r5,zero
 1824d98:	01006134 	movhi	r4,388
 1824d9c:	21168504 	addi	r4,r4,23060
 1824da0:	18266340 	call	1826634 <alt_avalon_sgdma_init>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
 1824da4:	01800104 	movi	r6,4
 1824da8:	000b883a 	mov	r5,zero
 1824dac:	01006134 	movhi	r4,388
 1824db0:	21169b04 	addi	r4,r4,23148
 1824db4:	18268e00 	call	18268e0 <altera_avalon_uart_init>
 1824db8:	01006134 	movhi	r4,388
 1824dbc:	21169104 	addi	r4,r4,23108
 1824dc0:	1824cc80 	call	1824cc8 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC_0, tse_mac_0);
 1824dc4:	0001883a 	nop
}
 1824dc8:	0001883a 	nop
 1824dcc:	e037883a 	mov	sp,fp
 1824dd0:	dfc00117 	ldw	ra,4(sp)
 1824dd4:	df000017 	ldw	fp,0(sp)
 1824dd8:	dec00204 	addi	sp,sp,8
 1824ddc:	f800283a 	ret

01824de0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1824de0:	defffa04 	addi	sp,sp,-24
 1824de4:	dfc00515 	stw	ra,20(sp)
 1824de8:	df000415 	stw	fp,16(sp)
 1824dec:	df000404 	addi	fp,sp,16
 1824df0:	e13ffd15 	stw	r4,-12(fp)
 1824df4:	e17ffe15 	stw	r5,-8(fp)
 1824df8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1824dfc:	e0bffd17 	ldw	r2,-12(fp)
 1824e00:	10800017 	ldw	r2,0(r2)
 1824e04:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 1824e08:	e0bffc17 	ldw	r2,-16(fp)
 1824e0c:	10c00a04 	addi	r3,r2,40
 1824e10:	e0bffd17 	ldw	r2,-12(fp)
 1824e14:	10800217 	ldw	r2,8(r2)
 1824e18:	100f883a 	mov	r7,r2
 1824e1c:	e1bfff17 	ldw	r6,-4(fp)
 1824e20:	e17ffe17 	ldw	r5,-8(fp)
 1824e24:	1809883a 	mov	r4,r3
 1824e28:	18254900 	call	1825490 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 1824e2c:	e037883a 	mov	sp,fp
 1824e30:	dfc00117 	ldw	ra,4(sp)
 1824e34:	df000017 	ldw	fp,0(sp)
 1824e38:	dec00204 	addi	sp,sp,8
 1824e3c:	f800283a 	ret

01824e40 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1824e40:	defffa04 	addi	sp,sp,-24
 1824e44:	dfc00515 	stw	ra,20(sp)
 1824e48:	df000415 	stw	fp,16(sp)
 1824e4c:	df000404 	addi	fp,sp,16
 1824e50:	e13ffd15 	stw	r4,-12(fp)
 1824e54:	e17ffe15 	stw	r5,-8(fp)
 1824e58:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1824e5c:	e0bffd17 	ldw	r2,-12(fp)
 1824e60:	10800017 	ldw	r2,0(r2)
 1824e64:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 1824e68:	e0bffc17 	ldw	r2,-16(fp)
 1824e6c:	10c00a04 	addi	r3,r2,40
 1824e70:	e0bffd17 	ldw	r2,-12(fp)
 1824e74:	10800217 	ldw	r2,8(r2)
 1824e78:	100f883a 	mov	r7,r2
 1824e7c:	e1bfff17 	ldw	r6,-4(fp)
 1824e80:	e17ffe17 	ldw	r5,-8(fp)
 1824e84:	1809883a 	mov	r4,r3
 1824e88:	18256e80 	call	18256e8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 1824e8c:	e037883a 	mov	sp,fp
 1824e90:	dfc00117 	ldw	ra,4(sp)
 1824e94:	df000017 	ldw	fp,0(sp)
 1824e98:	dec00204 	addi	sp,sp,8
 1824e9c:	f800283a 	ret

01824ea0 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 1824ea0:	defffc04 	addi	sp,sp,-16
 1824ea4:	dfc00315 	stw	ra,12(sp)
 1824ea8:	df000215 	stw	fp,8(sp)
 1824eac:	df000204 	addi	fp,sp,8
 1824eb0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1824eb4:	e0bfff17 	ldw	r2,-4(fp)
 1824eb8:	10800017 	ldw	r2,0(r2)
 1824ebc:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 1824ec0:	e0bffe17 	ldw	r2,-8(fp)
 1824ec4:	10c00a04 	addi	r3,r2,40
 1824ec8:	e0bfff17 	ldw	r2,-4(fp)
 1824ecc:	10800217 	ldw	r2,8(r2)
 1824ed0:	100b883a 	mov	r5,r2
 1824ed4:	1809883a 	mov	r4,r3
 1824ed8:	18253380 	call	1825338 <altera_avalon_jtag_uart_close>
}
 1824edc:	e037883a 	mov	sp,fp
 1824ee0:	dfc00117 	ldw	ra,4(sp)
 1824ee4:	df000017 	ldw	fp,0(sp)
 1824ee8:	dec00204 	addi	sp,sp,8
 1824eec:	f800283a 	ret

01824ef0 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 1824ef0:	defffa04 	addi	sp,sp,-24
 1824ef4:	dfc00515 	stw	ra,20(sp)
 1824ef8:	df000415 	stw	fp,16(sp)
 1824efc:	df000404 	addi	fp,sp,16
 1824f00:	e13ffd15 	stw	r4,-12(fp)
 1824f04:	e17ffe15 	stw	r5,-8(fp)
 1824f08:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 1824f0c:	e0bffd17 	ldw	r2,-12(fp)
 1824f10:	10800017 	ldw	r2,0(r2)
 1824f14:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 1824f18:	e0bffc17 	ldw	r2,-16(fp)
 1824f1c:	10800a04 	addi	r2,r2,40
 1824f20:	e1bfff17 	ldw	r6,-4(fp)
 1824f24:	e17ffe17 	ldw	r5,-8(fp)
 1824f28:	1009883a 	mov	r4,r2
 1824f2c:	18253a00 	call	18253a0 <altera_avalon_jtag_uart_ioctl>
}
 1824f30:	e037883a 	mov	sp,fp
 1824f34:	dfc00117 	ldw	ra,4(sp)
 1824f38:	df000017 	ldw	fp,0(sp)
 1824f3c:	dec00204 	addi	sp,sp,8
 1824f40:	f800283a 	ret

01824f44 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 1824f44:	defff304 	addi	sp,sp,-52
 1824f48:	dfc00c15 	stw	ra,48(sp)
 1824f4c:	df000b15 	stw	fp,44(sp)
 1824f50:	df000b04 	addi	fp,sp,44
 1824f54:	e13ff915 	stw	r4,-28(fp)
 1824f58:	e17ffa15 	stw	r5,-24(fp)
 1824f5c:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
 1824f60:	e0bff917 	ldw	r2,-28(fp)
 1824f64:	10800a04 	addi	r2,r2,40
 1824f68:	e0bff615 	stw	r2,-40(fp)
 1824f6c:	00800044 	movi	r2,1
 1824f70:	e0bff88d 	sth	r2,-30(fp)
 1824f74:	e0bff88b 	ldhu	r2,-30(fp)
 1824f78:	10000226 	beq	r2,zero,1824f84 <altera_avalon_jtag_uart_init+0x40>
 1824f7c:	e0bff88b 	ldhu	r2,-30(fp)
 1824f80:	00000106 	br	1824f88 <altera_avalon_jtag_uart_init+0x44>
 1824f84:	00800044 	movi	r2,1
 1824f88:	e0fff88b 	ldhu	r3,-30(fp)
 1824f8c:	180b883a 	mov	r5,r3
 1824f90:	1009883a 	mov	r4,r2
 1824f94:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 1824f98:	1007883a 	mov	r3,r2
 1824f9c:	e0bff617 	ldw	r2,-40(fp)
 1824fa0:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 1824fa4:	e0bff917 	ldw	r2,-28(fp)
 1824fa8:	10800b04 	addi	r2,r2,44
 1824fac:	e0bff715 	stw	r2,-36(fp)
 1824fb0:	00800044 	movi	r2,1
 1824fb4:	e0bff80d 	sth	r2,-32(fp)
 1824fb8:	e0bff80b 	ldhu	r2,-32(fp)
 1824fbc:	10000226 	beq	r2,zero,1824fc8 <altera_avalon_jtag_uart_init+0x84>
 1824fc0:	e0bff80b 	ldhu	r2,-32(fp)
 1824fc4:	00000106 	br	1824fcc <altera_avalon_jtag_uart_init+0x88>
 1824fc8:	00800044 	movi	r2,1
 1824fcc:	e0fff80b 	ldhu	r3,-32(fp)
 1824fd0:	180b883a 	mov	r5,r3
 1824fd4:	1009883a 	mov	r4,r2
 1824fd8:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 1824fdc:	1007883a 	mov	r3,r2
 1824fe0:	e0bff717 	ldw	r2,-36(fp)
 1824fe4:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1824fe8:	e0bff917 	ldw	r2,-28(fp)
 1824fec:	00c00044 	movi	r3,1
 1824ff0:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 1824ff4:	e0bff917 	ldw	r2,-28(fp)
 1824ff8:	10800017 	ldw	r2,0(r2)
 1824ffc:	10800104 	addi	r2,r2,4
 1825000:	1007883a 	mov	r3,r2
 1825004:	e0bff917 	ldw	r2,-28(fp)
 1825008:	10800817 	ldw	r2,32(r2)
 182500c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 1825010:	e0bffa17 	ldw	r2,-24(fp)
 1825014:	e0fffb17 	ldw	r3,-20(fp)
 1825018:	d8000015 	stw	zero,0(sp)
 182501c:	e1fff917 	ldw	r7,-28(fp)
 1825020:	018060b4 	movhi	r6,386
 1825024:	31942304 	addi	r6,r6,20620
 1825028:	180b883a 	mov	r5,r3
 182502c:	1009883a 	mov	r4,r2
 1825030:	182811c0 	call	182811c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 1825034:	e0bff917 	ldw	r2,-28(fp)
 1825038:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 182503c:	e0bff917 	ldw	r2,-28(fp)
 1825040:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1825044:	d0e80917 	ldw	r3,-24540(gp)
 1825048:	e1fff917 	ldw	r7,-28(fp)
 182504c:	018060b4 	movhi	r6,386
 1825050:	3194a604 	addi	r6,r6,21144
 1825054:	180b883a 	mov	r5,r3
 1825058:	1009883a 	mov	r4,r2
 182505c:	18277c40 	call	18277c4 <alt_alarm_start>
 1825060:	1000040e 	bge	r2,zero,1825074 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 1825064:	e0fff917 	ldw	r3,-28(fp)
 1825068:	00a00034 	movhi	r2,32768
 182506c:	10bfffc4 	addi	r2,r2,-1
 1825070:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 1825074:	0001883a 	nop
 1825078:	e037883a 	mov	sp,fp
 182507c:	dfc00117 	ldw	ra,4(sp)
 1825080:	df000017 	ldw	fp,0(sp)
 1825084:	dec00204 	addi	sp,sp,8
 1825088:	f800283a 	ret

0182508c <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 182508c:	defff804 	addi	sp,sp,-32
 1825090:	df000715 	stw	fp,28(sp)
 1825094:	df000704 	addi	fp,sp,28
 1825098:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 182509c:	e0bfff17 	ldw	r2,-4(fp)
 18250a0:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 18250a4:	e0bffb17 	ldw	r2,-20(fp)
 18250a8:	10800017 	ldw	r2,0(r2)
 18250ac:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 18250b0:	e0bffc17 	ldw	r2,-16(fp)
 18250b4:	10800104 	addi	r2,r2,4
 18250b8:	10800037 	ldwio	r2,0(r2)
 18250bc:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 18250c0:	e0bffd17 	ldw	r2,-12(fp)
 18250c4:	1080c00c 	andi	r2,r2,768
 18250c8:	10006d26 	beq	r2,zero,1825280 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 18250cc:	e0bffd17 	ldw	r2,-12(fp)
 18250d0:	1080400c 	andi	r2,r2,256
 18250d4:	10003526 	beq	r2,zero,18251ac <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 18250d8:	00800074 	movhi	r2,1
 18250dc:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 18250e0:	e0bffb17 	ldw	r2,-20(fp)
 18250e4:	10800c17 	ldw	r2,48(r2)
 18250e8:	10800044 	addi	r2,r2,1
 18250ec:	1081ffcc 	andi	r2,r2,2047
 18250f0:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 18250f4:	e0bffb17 	ldw	r2,-20(fp)
 18250f8:	10c00d17 	ldw	r3,52(r2)
 18250fc:	e0bffe17 	ldw	r2,-8(fp)
 1825100:	18801526 	beq	r3,r2,1825158 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 1825104:	e0bffc17 	ldw	r2,-16(fp)
 1825108:	10800037 	ldwio	r2,0(r2)
 182510c:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 1825110:	e0bff917 	ldw	r2,-28(fp)
 1825114:	10a0000c 	andi	r2,r2,32768
 1825118:	10001126 	beq	r2,zero,1825160 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 182511c:	e0bffb17 	ldw	r2,-20(fp)
 1825120:	10800c17 	ldw	r2,48(r2)
 1825124:	e0fff917 	ldw	r3,-28(fp)
 1825128:	1809883a 	mov	r4,r3
 182512c:	e0fffb17 	ldw	r3,-20(fp)
 1825130:	1885883a 	add	r2,r3,r2
 1825134:	10801004 	addi	r2,r2,64
 1825138:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 182513c:	e0bffb17 	ldw	r2,-20(fp)
 1825140:	10800c17 	ldw	r2,48(r2)
 1825144:	10800044 	addi	r2,r2,1
 1825148:	10c1ffcc 	andi	r3,r2,2047
 182514c:	e0bffb17 	ldw	r2,-20(fp)
 1825150:	10c00c15 	stw	r3,48(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 1825154:	003fe206 	br	18250e0 <__ram_exceptions_end+0xff814c9c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 1825158:	0001883a 	nop
 182515c:	00000106 	br	1825164 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 1825160:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 1825164:	e0bff917 	ldw	r2,-28(fp)
 1825168:	10bfffec 	andhi	r2,r2,65535
 182516c:	10000f26 	beq	r2,zero,18251ac <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1825170:	e0bffb17 	ldw	r2,-20(fp)
 1825174:	10c00817 	ldw	r3,32(r2)
 1825178:	00bfff84 	movi	r2,-2
 182517c:	1886703a 	and	r3,r3,r2
 1825180:	e0bffb17 	ldw	r2,-20(fp)
 1825184:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 1825188:	e0bffc17 	ldw	r2,-16(fp)
 182518c:	10800104 	addi	r2,r2,4
 1825190:	1007883a 	mov	r3,r2
 1825194:	e0bffb17 	ldw	r2,-20(fp)
 1825198:	10800817 	ldw	r2,32(r2)
 182519c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 18251a0:	e0bffc17 	ldw	r2,-16(fp)
 18251a4:	10800104 	addi	r2,r2,4
 18251a8:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 18251ac:	e0bffd17 	ldw	r2,-12(fp)
 18251b0:	1080800c 	andi	r2,r2,512
 18251b4:	103fbe26 	beq	r2,zero,18250b0 <__ram_exceptions_end+0xff814c6c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 18251b8:	e0bffd17 	ldw	r2,-12(fp)
 18251bc:	1004d43a 	srli	r2,r2,16
 18251c0:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 18251c4:	00001406 	br	1825218 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 18251c8:	e0bffc17 	ldw	r2,-16(fp)
 18251cc:	e0fffb17 	ldw	r3,-20(fp)
 18251d0:	18c00f17 	ldw	r3,60(r3)
 18251d4:	e13ffb17 	ldw	r4,-20(fp)
 18251d8:	20c7883a 	add	r3,r4,r3
 18251dc:	18c21004 	addi	r3,r3,2112
 18251e0:	18c00003 	ldbu	r3,0(r3)
 18251e4:	18c03fcc 	andi	r3,r3,255
 18251e8:	18c0201c 	xori	r3,r3,128
 18251ec:	18ffe004 	addi	r3,r3,-128
 18251f0:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 18251f4:	e0bffb17 	ldw	r2,-20(fp)
 18251f8:	10800f17 	ldw	r2,60(r2)
 18251fc:	10800044 	addi	r2,r2,1
 1825200:	10c1ffcc 	andi	r3,r2,2047
 1825204:	e0bffb17 	ldw	r2,-20(fp)
 1825208:	10c00f15 	stw	r3,60(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 182520c:	e0bffa17 	ldw	r2,-24(fp)
 1825210:	10bfffc4 	addi	r2,r2,-1
 1825214:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 1825218:	e0bffa17 	ldw	r2,-24(fp)
 182521c:	10000526 	beq	r2,zero,1825234 <altera_avalon_jtag_uart_irq+0x1a8>
 1825220:	e0bffb17 	ldw	r2,-20(fp)
 1825224:	10c00f17 	ldw	r3,60(r2)
 1825228:	e0bffb17 	ldw	r2,-20(fp)
 182522c:	10800e17 	ldw	r2,56(r2)
 1825230:	18bfe51e 	bne	r3,r2,18251c8 <__ram_exceptions_end+0xff814d84>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 1825234:	e0bffa17 	ldw	r2,-24(fp)
 1825238:	103f9d26 	beq	r2,zero,18250b0 <__ram_exceptions_end+0xff814c6c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 182523c:	e0bffb17 	ldw	r2,-20(fp)
 1825240:	10c00817 	ldw	r3,32(r2)
 1825244:	00bfff44 	movi	r2,-3
 1825248:	1886703a 	and	r3,r3,r2
 182524c:	e0bffb17 	ldw	r2,-20(fp)
 1825250:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1825254:	e0bffb17 	ldw	r2,-20(fp)
 1825258:	10800017 	ldw	r2,0(r2)
 182525c:	10800104 	addi	r2,r2,4
 1825260:	1007883a 	mov	r3,r2
 1825264:	e0bffb17 	ldw	r2,-20(fp)
 1825268:	10800817 	ldw	r2,32(r2)
 182526c:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1825270:	e0bffc17 	ldw	r2,-16(fp)
 1825274:	10800104 	addi	r2,r2,4
 1825278:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 182527c:	003f8c06 	br	18250b0 <__ram_exceptions_end+0xff814c6c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 1825280:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 1825284:	0001883a 	nop
 1825288:	e037883a 	mov	sp,fp
 182528c:	df000017 	ldw	fp,0(sp)
 1825290:	dec00104 	addi	sp,sp,4
 1825294:	f800283a 	ret

01825298 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 1825298:	defff804 	addi	sp,sp,-32
 182529c:	df000715 	stw	fp,28(sp)
 18252a0:	df000704 	addi	fp,sp,28
 18252a4:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 18252a8:	e0bffb17 	ldw	r2,-20(fp)
 18252ac:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 18252b0:	e0bff917 	ldw	r2,-28(fp)
 18252b4:	10800017 	ldw	r2,0(r2)
 18252b8:	10800104 	addi	r2,r2,4
 18252bc:	10800037 	ldwio	r2,0(r2)
 18252c0:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 18252c4:	e0bffa17 	ldw	r2,-24(fp)
 18252c8:	1081000c 	andi	r2,r2,1024
 18252cc:	10000b26 	beq	r2,zero,18252fc <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 18252d0:	e0bff917 	ldw	r2,-28(fp)
 18252d4:	10800017 	ldw	r2,0(r2)
 18252d8:	10800104 	addi	r2,r2,4
 18252dc:	1007883a 	mov	r3,r2
 18252e0:	e0bff917 	ldw	r2,-28(fp)
 18252e4:	10800817 	ldw	r2,32(r2)
 18252e8:	10810014 	ori	r2,r2,1024
 18252ec:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 18252f0:	e0bff917 	ldw	r2,-28(fp)
 18252f4:	10000915 	stw	zero,36(r2)
 18252f8:	00000a06 	br	1825324 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 18252fc:	e0bff917 	ldw	r2,-28(fp)
 1825300:	10c00917 	ldw	r3,36(r2)
 1825304:	00a00034 	movhi	r2,32768
 1825308:	10bfff04 	addi	r2,r2,-4
 182530c:	10c00536 	bltu	r2,r3,1825324 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 1825310:	e0bff917 	ldw	r2,-28(fp)
 1825314:	10800917 	ldw	r2,36(r2)
 1825318:	10c00044 	addi	r3,r2,1
 182531c:	e0bff917 	ldw	r2,-28(fp)
 1825320:	10c00915 	stw	r3,36(r2)
 1825324:	d0a80917 	ldw	r2,-24540(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 1825328:	e037883a 	mov	sp,fp
 182532c:	df000017 	ldw	fp,0(sp)
 1825330:	dec00104 	addi	sp,sp,4
 1825334:	f800283a 	ret

01825338 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 1825338:	defffd04 	addi	sp,sp,-12
 182533c:	df000215 	stw	fp,8(sp)
 1825340:	df000204 	addi	fp,sp,8
 1825344:	e13ffe15 	stw	r4,-8(fp)
 1825348:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 182534c:	00000506 	br	1825364 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 1825350:	e0bfff17 	ldw	r2,-4(fp)
 1825354:	1090000c 	andi	r2,r2,16384
 1825358:	10000226 	beq	r2,zero,1825364 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 182535c:	00bffd44 	movi	r2,-11
 1825360:	00000b06 	br	1825390 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 1825364:	e0bffe17 	ldw	r2,-8(fp)
 1825368:	10c00f17 	ldw	r3,60(r2)
 182536c:	e0bffe17 	ldw	r2,-8(fp)
 1825370:	10800e17 	ldw	r2,56(r2)
 1825374:	18800526 	beq	r3,r2,182538c <altera_avalon_jtag_uart_close+0x54>
 1825378:	e0bffe17 	ldw	r2,-8(fp)
 182537c:	10c00917 	ldw	r3,36(r2)
 1825380:	e0bffe17 	ldw	r2,-8(fp)
 1825384:	10800117 	ldw	r2,4(r2)
 1825388:	18bff136 	bltu	r3,r2,1825350 <__ram_exceptions_end+0xff814f0c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 182538c:	0005883a 	mov	r2,zero
}
 1825390:	e037883a 	mov	sp,fp
 1825394:	df000017 	ldw	fp,0(sp)
 1825398:	dec00104 	addi	sp,sp,4
 182539c:	f800283a 	ret

018253a0 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 18253a0:	defffa04 	addi	sp,sp,-24
 18253a4:	df000515 	stw	fp,20(sp)
 18253a8:	df000504 	addi	fp,sp,20
 18253ac:	e13ffd15 	stw	r4,-12(fp)
 18253b0:	e17ffe15 	stw	r5,-8(fp)
 18253b4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 18253b8:	00bff9c4 	movi	r2,-25
 18253bc:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 18253c0:	e0bffe17 	ldw	r2,-8(fp)
 18253c4:	10da8060 	cmpeqi	r3,r2,27137
 18253c8:	1800031e 	bne	r3,zero,18253d8 <altera_avalon_jtag_uart_ioctl+0x38>
 18253cc:	109a80a0 	cmpeqi	r2,r2,27138
 18253d0:	1000181e 	bne	r2,zero,1825434 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 18253d4:	00002906 	br	182547c <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 18253d8:	e0bffd17 	ldw	r2,-12(fp)
 18253dc:	10c00117 	ldw	r3,4(r2)
 18253e0:	00a00034 	movhi	r2,32768
 18253e4:	10bfffc4 	addi	r2,r2,-1
 18253e8:	18802126 	beq	r3,r2,1825470 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 18253ec:	e0bfff17 	ldw	r2,-4(fp)
 18253f0:	10800017 	ldw	r2,0(r2)
 18253f4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 18253f8:	e0bffc17 	ldw	r2,-16(fp)
 18253fc:	10800090 	cmplti	r2,r2,2
 1825400:	1000061e 	bne	r2,zero,182541c <altera_avalon_jtag_uart_ioctl+0x7c>
 1825404:	e0fffc17 	ldw	r3,-16(fp)
 1825408:	00a00034 	movhi	r2,32768
 182540c:	10bfffc4 	addi	r2,r2,-1
 1825410:	18800226 	beq	r3,r2,182541c <altera_avalon_jtag_uart_ioctl+0x7c>
 1825414:	e0bffc17 	ldw	r2,-16(fp)
 1825418:	00000206 	br	1825424 <altera_avalon_jtag_uart_ioctl+0x84>
 182541c:	00a00034 	movhi	r2,32768
 1825420:	10bfff84 	addi	r2,r2,-2
 1825424:	e0fffd17 	ldw	r3,-12(fp)
 1825428:	18800115 	stw	r2,4(r3)
      rc = 0;
 182542c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 1825430:	00000f06 	br	1825470 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 1825434:	e0bffd17 	ldw	r2,-12(fp)
 1825438:	10c00117 	ldw	r3,4(r2)
 182543c:	00a00034 	movhi	r2,32768
 1825440:	10bfffc4 	addi	r2,r2,-1
 1825444:	18800c26 	beq	r3,r2,1825478 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 1825448:	e0bffd17 	ldw	r2,-12(fp)
 182544c:	10c00917 	ldw	r3,36(r2)
 1825450:	e0bffd17 	ldw	r2,-12(fp)
 1825454:	10800117 	ldw	r2,4(r2)
 1825458:	1885803a 	cmpltu	r2,r3,r2
 182545c:	10c03fcc 	andi	r3,r2,255
 1825460:	e0bfff17 	ldw	r2,-4(fp)
 1825464:	10c00015 	stw	r3,0(r2)
      rc = 0;
 1825468:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 182546c:	00000206 	br	1825478 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 1825470:	0001883a 	nop
 1825474:	00000106 	br	182547c <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 1825478:	0001883a 	nop

  default:
    break;
  }

  return rc;
 182547c:	e0bffb17 	ldw	r2,-20(fp)
}
 1825480:	e037883a 	mov	sp,fp
 1825484:	df000017 	ldw	fp,0(sp)
 1825488:	dec00104 	addi	sp,sp,4
 182548c:	f800283a 	ret

01825490 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 1825490:	defff004 	addi	sp,sp,-64
 1825494:	dfc00f15 	stw	ra,60(sp)
 1825498:	df000e15 	stw	fp,56(sp)
 182549c:	df000e04 	addi	fp,sp,56
 18254a0:	e13ffb15 	stw	r4,-20(fp)
 18254a4:	e17ffc15 	stw	r5,-16(fp)
 18254a8:	e1bffd15 	stw	r6,-12(fp)
 18254ac:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 18254b0:	e0bffc17 	ldw	r2,-16(fp)
 18254b4:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 18254b8:	e0bffb17 	ldw	r2,-20(fp)
 18254bc:	10800a17 	ldw	r2,40(r2)
 18254c0:	e0bff915 	stw	r2,-28(fp)
 18254c4:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 18254c8:	e0bffa0b 	ldhu	r2,-24(fp)
 18254cc:	100b883a 	mov	r5,r2
 18254d0:	e13ff917 	ldw	r4,-28(fp)
 18254d4:	180e0080 	call	180e008 <xQueueSemaphoreTake>

  while (space > 0)
 18254d8:	00004706 	br	18255f8 <altera_avalon_jtag_uart_read+0x168>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 18254dc:	e0bffb17 	ldw	r2,-20(fp)
 18254e0:	10800c17 	ldw	r2,48(r2)
 18254e4:	e0bff515 	stw	r2,-44(fp)
      out = sp->rx_out;
 18254e8:	e0bffb17 	ldw	r2,-20(fp)
 18254ec:	10800d17 	ldw	r2,52(r2)
 18254f0:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 18254f4:	e0fff517 	ldw	r3,-44(fp)
 18254f8:	e0bff617 	ldw	r2,-40(fp)
 18254fc:	18800536 	bltu	r3,r2,1825514 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 1825500:	e0fff517 	ldw	r3,-44(fp)
 1825504:	e0bff617 	ldw	r2,-40(fp)
 1825508:	1885c83a 	sub	r2,r3,r2
 182550c:	e0bff315 	stw	r2,-52(fp)
 1825510:	00000406 	br	1825524 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 1825514:	00c20004 	movi	r3,2048
 1825518:	e0bff617 	ldw	r2,-40(fp)
 182551c:	1885c83a 	sub	r2,r3,r2
 1825520:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 1825524:	e0bff317 	ldw	r2,-52(fp)
 1825528:	10001e26 	beq	r2,zero,18255a4 <altera_avalon_jtag_uart_read+0x114>
        break; /* No more data available */

      if (n > space)
 182552c:	e0fffd17 	ldw	r3,-12(fp)
 1825530:	e0bff317 	ldw	r2,-52(fp)
 1825534:	1880022e 	bgeu	r3,r2,1825540 <altera_avalon_jtag_uart_read+0xb0>
        n = space;
 1825538:	e0bffd17 	ldw	r2,-12(fp)
 182553c:	e0bff315 	stw	r2,-52(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1825540:	e0bffb17 	ldw	r2,-20(fp)
 1825544:	10c01004 	addi	r3,r2,64
 1825548:	e0bff617 	ldw	r2,-40(fp)
 182554c:	1885883a 	add	r2,r3,r2
 1825550:	e1bff317 	ldw	r6,-52(fp)
 1825554:	100b883a 	mov	r5,r2
 1825558:	e13ff217 	ldw	r4,-56(fp)
 182555c:	180608c0 	call	180608c <memcpy>
      ptr   += n;
 1825560:	e0fff217 	ldw	r3,-56(fp)
 1825564:	e0bff317 	ldw	r2,-52(fp)
 1825568:	1885883a 	add	r2,r3,r2
 182556c:	e0bff215 	stw	r2,-56(fp)
      space -= n;
 1825570:	e0fffd17 	ldw	r3,-12(fp)
 1825574:	e0bff317 	ldw	r2,-52(fp)
 1825578:	1885c83a 	sub	r2,r3,r2
 182557c:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1825580:	e0fff617 	ldw	r3,-40(fp)
 1825584:	e0bff317 	ldw	r2,-52(fp)
 1825588:	1885883a 	add	r2,r3,r2
 182558c:	10c1ffcc 	andi	r3,r2,2047
 1825590:	e0bffb17 	ldw	r2,-20(fp)
 1825594:	10c00d15 	stw	r3,52(r2)
    }
    while (space > 0);
 1825598:	e0bffd17 	ldw	r2,-12(fp)
 182559c:	00bfcf16 	blt	zero,r2,18254dc <__ram_exceptions_end+0xff815098>
 18255a0:	00000106 	br	18255a8 <altera_avalon_jtag_uart_read+0x118>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 18255a4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 18255a8:	e0fff217 	ldw	r3,-56(fp)
 18255ac:	e0bffc17 	ldw	r2,-16(fp)
 18255b0:	1880141e 	bne	r3,r2,1825604 <altera_avalon_jtag_uart_read+0x174>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 18255b4:	e0bffe17 	ldw	r2,-8(fp)
 18255b8:	1090000c 	andi	r2,r2,16384
 18255bc:	1000131e 	bne	r2,zero,182560c <altera_avalon_jtag_uart_read+0x17c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 18255c0:	0001883a 	nop
 18255c4:	e0bffb17 	ldw	r2,-20(fp)
 18255c8:	10c00c17 	ldw	r3,48(r2)
 18255cc:	e0bff517 	ldw	r2,-44(fp)
 18255d0:	1880051e 	bne	r3,r2,18255e8 <altera_avalon_jtag_uart_read+0x158>
 18255d4:	e0bffb17 	ldw	r2,-20(fp)
 18255d8:	10c00917 	ldw	r3,36(r2)
 18255dc:	e0bffb17 	ldw	r2,-20(fp)
 18255e0:	10800117 	ldw	r2,4(r2)
 18255e4:	18bff736 	bltu	r3,r2,18255c4 <__ram_exceptions_end+0xff815180>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 18255e8:	e0bffb17 	ldw	r2,-20(fp)
 18255ec:	10c00c17 	ldw	r3,48(r2)
 18255f0:	e0bff517 	ldw	r2,-44(fp)
 18255f4:	18800726 	beq	r3,r2,1825614 <altera_avalon_jtag_uart_read+0x184>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 18255f8:	e0bffd17 	ldw	r2,-12(fp)
 18255fc:	00bfb716 	blt	zero,r2,18254dc <__ram_exceptions_end+0xff815098>
 1825600:	00000506 	br	1825618 <altera_avalon_jtag_uart_read+0x188>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 1825604:	0001883a 	nop
 1825608:	00000306 	br	1825618 <altera_avalon_jtag_uart_read+0x188>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 182560c:	0001883a 	nop
 1825610:	00000106 	br	1825618 <altera_avalon_jtag_uart_read+0x188>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 1825614:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 1825618:	e0bffb17 	ldw	r2,-20(fp)
 182561c:	10800a17 	ldw	r2,40(r2)
 1825620:	000f883a 	mov	r7,zero
 1825624:	000d883a 	mov	r6,zero
 1825628:	000b883a 	mov	r5,zero
 182562c:	1009883a 	mov	r4,r2
 1825630:	180da7c0 	call	180da7c <xQueueGenericSend>

  if (ptr != buffer)
 1825634:	e0fff217 	ldw	r3,-56(fp)
 1825638:	e0bffc17 	ldw	r2,-16(fp)
 182563c:	18801826 	beq	r3,r2,18256a0 <altera_avalon_jtag_uart_read+0x210>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1825640:	0005303a 	rdctl	r2,status
 1825644:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1825648:	e0fff817 	ldw	r3,-32(fp)
 182564c:	00bfff84 	movi	r2,-2
 1825650:	1884703a 	and	r2,r3,r2
 1825654:	1001703a 	wrctl	status,r2
  
  return context;
 1825658:	e0bff817 	ldw	r2,-32(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 182565c:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1825660:	e0bffb17 	ldw	r2,-20(fp)
 1825664:	10800817 	ldw	r2,32(r2)
 1825668:	10c00054 	ori	r3,r2,1
 182566c:	e0bffb17 	ldw	r2,-20(fp)
 1825670:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1825674:	e0bffb17 	ldw	r2,-20(fp)
 1825678:	10800017 	ldw	r2,0(r2)
 182567c:	10800104 	addi	r2,r2,4
 1825680:	1007883a 	mov	r3,r2
 1825684:	e0bffb17 	ldw	r2,-20(fp)
 1825688:	10800817 	ldw	r2,32(r2)
 182568c:	18800035 	stwio	r2,0(r3)
 1825690:	e0bff717 	ldw	r2,-36(fp)
 1825694:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1825698:	e0bff417 	ldw	r2,-48(fp)
 182569c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 18256a0:	e0fff217 	ldw	r3,-56(fp)
 18256a4:	e0bffc17 	ldw	r2,-16(fp)
 18256a8:	18800426 	beq	r3,r2,18256bc <altera_avalon_jtag_uart_read+0x22c>
    return ptr - buffer;
 18256ac:	e0fff217 	ldw	r3,-56(fp)
 18256b0:	e0bffc17 	ldw	r2,-16(fp)
 18256b4:	1885c83a 	sub	r2,r3,r2
 18256b8:	00000606 	br	18256d4 <altera_avalon_jtag_uart_read+0x244>
  else if (flags & O_NONBLOCK)
 18256bc:	e0bffe17 	ldw	r2,-8(fp)
 18256c0:	1090000c 	andi	r2,r2,16384
 18256c4:	10000226 	beq	r2,zero,18256d0 <altera_avalon_jtag_uart_read+0x240>
    return -EWOULDBLOCK;
 18256c8:	00bffd44 	movi	r2,-11
 18256cc:	00000106 	br	18256d4 <altera_avalon_jtag_uart_read+0x244>
  else
    return -EIO;
 18256d0:	00bffec4 	movi	r2,-5
}
 18256d4:	e037883a 	mov	sp,fp
 18256d8:	dfc00117 	ldw	ra,4(sp)
 18256dc:	df000017 	ldw	fp,0(sp)
 18256e0:	dec00204 	addi	sp,sp,8
 18256e4:	f800283a 	ret

018256e8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 18256e8:	defff004 	addi	sp,sp,-64
 18256ec:	dfc00f15 	stw	ra,60(sp)
 18256f0:	df000e15 	stw	fp,56(sp)
 18256f4:	df000e04 	addi	fp,sp,56
 18256f8:	e13ffb15 	stw	r4,-20(fp)
 18256fc:	e17ffc15 	stw	r5,-16(fp)
 1825700:	e1bffd15 	stw	r6,-12(fp)
 1825704:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 1825708:	e03ff215 	stw	zero,-56(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 182570c:	e0bffc17 	ldw	r2,-16(fp)
 1825710:	e0bff415 	stw	r2,-48(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 1825714:	e0bffb17 	ldw	r2,-20(fp)
 1825718:	10800b17 	ldw	r2,44(r2)
 182571c:	e0bff915 	stw	r2,-28(fp)
 1825720:	e03ffa0d 	sth	zero,-24(fp)
 1825724:	e0bffa0b 	ldhu	r2,-24(fp)
 1825728:	100b883a 	mov	r5,r2
 182572c:	e13ff917 	ldw	r4,-28(fp)
 1825730:	180e0080 	call	180e008 <xQueueSemaphoreTake>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1825734:	00003706 	br	1825814 <altera_avalon_jtag_uart_write+0x12c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 1825738:	e0bffb17 	ldw	r2,-20(fp)
 182573c:	10800e17 	ldw	r2,56(r2)
 1825740:	e0bff615 	stw	r2,-40(fp)
      out = sp->tx_out;
 1825744:	e0bffb17 	ldw	r2,-20(fp)
 1825748:	10800f17 	ldw	r2,60(r2)
 182574c:	e0bff215 	stw	r2,-56(fp)

      if (in < out)
 1825750:	e0fff617 	ldw	r3,-40(fp)
 1825754:	e0bff217 	ldw	r2,-56(fp)
 1825758:	1880062e 	bgeu	r3,r2,1825774 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 182575c:	e0fff217 	ldw	r3,-56(fp)
 1825760:	e0bff617 	ldw	r2,-40(fp)
 1825764:	1885c83a 	sub	r2,r3,r2
 1825768:	10bfffc4 	addi	r2,r2,-1
 182576c:	e0bff315 	stw	r2,-52(fp)
 1825770:	00000b06 	br	18257a0 <altera_avalon_jtag_uart_write+0xb8>
      else if (out > 0)
 1825774:	e0bff217 	ldw	r2,-56(fp)
 1825778:	10000526 	beq	r2,zero,1825790 <altera_avalon_jtag_uart_write+0xa8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 182577c:	00c20004 	movi	r3,2048
 1825780:	e0bff617 	ldw	r2,-40(fp)
 1825784:	1885c83a 	sub	r2,r3,r2
 1825788:	e0bff315 	stw	r2,-52(fp)
 182578c:	00000406 	br	18257a0 <altera_avalon_jtag_uart_write+0xb8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 1825790:	00c1ffc4 	movi	r3,2047
 1825794:	e0bff617 	ldw	r2,-40(fp)
 1825798:	1885c83a 	sub	r2,r3,r2
 182579c:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 18257a0:	e0bff317 	ldw	r2,-52(fp)
 18257a4:	10001e26 	beq	r2,zero,1825820 <altera_avalon_jtag_uart_write+0x138>
        break;

      if (n > count)
 18257a8:	e0fffd17 	ldw	r3,-12(fp)
 18257ac:	e0bff317 	ldw	r2,-52(fp)
 18257b0:	1880022e 	bgeu	r3,r2,18257bc <altera_avalon_jtag_uart_write+0xd4>
        n = count;
 18257b4:	e0bffd17 	ldw	r2,-12(fp)
 18257b8:	e0bff315 	stw	r2,-52(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 18257bc:	e0bffb17 	ldw	r2,-20(fp)
 18257c0:	10c21004 	addi	r3,r2,2112
 18257c4:	e0bff617 	ldw	r2,-40(fp)
 18257c8:	1885883a 	add	r2,r3,r2
 18257cc:	e1bff317 	ldw	r6,-52(fp)
 18257d0:	e17ffc17 	ldw	r5,-16(fp)
 18257d4:	1009883a 	mov	r4,r2
 18257d8:	180608c0 	call	180608c <memcpy>
      ptr   += n;
 18257dc:	e0fffc17 	ldw	r3,-16(fp)
 18257e0:	e0bff317 	ldw	r2,-52(fp)
 18257e4:	1885883a 	add	r2,r3,r2
 18257e8:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 18257ec:	e0fffd17 	ldw	r3,-12(fp)
 18257f0:	e0bff317 	ldw	r2,-52(fp)
 18257f4:	1885c83a 	sub	r2,r3,r2
 18257f8:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 18257fc:	e0fff617 	ldw	r3,-40(fp)
 1825800:	e0bff317 	ldw	r2,-52(fp)
 1825804:	1885883a 	add	r2,r3,r2
 1825808:	10c1ffcc 	andi	r3,r2,2047
 182580c:	e0bffb17 	ldw	r2,-20(fp)
 1825810:	10c00e15 	stw	r3,56(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 1825814:	e0bffd17 	ldw	r2,-12(fp)
 1825818:	00bfc716 	blt	zero,r2,1825738 <__ram_exceptions_end+0xff8152f4>
 182581c:	00000106 	br	1825824 <altera_avalon_jtag_uart_write+0x13c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 1825820:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1825824:	0005303a 	rdctl	r2,status
 1825828:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 182582c:	e0fff817 	ldw	r3,-32(fp)
 1825830:	00bfff84 	movi	r2,-2
 1825834:	1884703a 	and	r2,r3,r2
 1825838:	1001703a 	wrctl	status,r2
  
  return context;
 182583c:	e0bff817 	ldw	r2,-32(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 1825840:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 1825844:	e0bffb17 	ldw	r2,-20(fp)
 1825848:	10800817 	ldw	r2,32(r2)
 182584c:	10c00094 	ori	r3,r2,2
 1825850:	e0bffb17 	ldw	r2,-20(fp)
 1825854:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1825858:	e0bffb17 	ldw	r2,-20(fp)
 182585c:	10800017 	ldw	r2,0(r2)
 1825860:	10800104 	addi	r2,r2,4
 1825864:	1007883a 	mov	r3,r2
 1825868:	e0bffb17 	ldw	r2,-20(fp)
 182586c:	10800817 	ldw	r2,32(r2)
 1825870:	18800035 	stwio	r2,0(r3)
 1825874:	e0bff717 	ldw	r2,-36(fp)
 1825878:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 182587c:	e0bff517 	ldw	r2,-44(fp)
 1825880:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 1825884:	e0bffd17 	ldw	r2,-12(fp)
 1825888:	0080100e 	bge	zero,r2,18258cc <altera_avalon_jtag_uart_write+0x1e4>
    {
      if (flags & O_NONBLOCK)
 182588c:	e0bffe17 	ldw	r2,-8(fp)
 1825890:	1090000c 	andi	r2,r2,16384
 1825894:	1000101e 	bne	r2,zero,18258d8 <altera_avalon_jtag_uart_write+0x1f0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 1825898:	0001883a 	nop
 182589c:	e0bffb17 	ldw	r2,-20(fp)
 18258a0:	10c00f17 	ldw	r3,60(r2)
 18258a4:	e0bff217 	ldw	r2,-56(fp)
 18258a8:	1880051e 	bne	r3,r2,18258c0 <altera_avalon_jtag_uart_write+0x1d8>
 18258ac:	e0bffb17 	ldw	r2,-20(fp)
 18258b0:	10c00917 	ldw	r3,36(r2)
 18258b4:	e0bffb17 	ldw	r2,-20(fp)
 18258b8:	10800117 	ldw	r2,4(r2)
 18258bc:	18bff736 	bltu	r3,r2,182589c <__ram_exceptions_end+0xff815458>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 18258c0:	e0bffb17 	ldw	r2,-20(fp)
 18258c4:	10800917 	ldw	r2,36(r2)
 18258c8:	1000051e 	bne	r2,zero,18258e0 <altera_avalon_jtag_uart_write+0x1f8>
         break;
    }
  }
  while (count > 0);
 18258cc:	e0bffd17 	ldw	r2,-12(fp)
 18258d0:	00bfd016 	blt	zero,r2,1825814 <__ram_exceptions_end+0xff8153d0>
 18258d4:	00000306 	br	18258e4 <altera_avalon_jtag_uart_write+0x1fc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 18258d8:	0001883a 	nop
 18258dc:	00000106 	br	18258e4 <altera_avalon_jtag_uart_write+0x1fc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 18258e0:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 18258e4:	e0bffb17 	ldw	r2,-20(fp)
 18258e8:	10800b17 	ldw	r2,44(r2)
 18258ec:	000f883a 	mov	r7,zero
 18258f0:	000d883a 	mov	r6,zero
 18258f4:	000b883a 	mov	r5,zero
 18258f8:	1009883a 	mov	r4,r2
 18258fc:	180da7c0 	call	180da7c <xQueueGenericSend>

  if (ptr != start)
 1825900:	e0fffc17 	ldw	r3,-16(fp)
 1825904:	e0bff417 	ldw	r2,-48(fp)
 1825908:	18800426 	beq	r3,r2,182591c <altera_avalon_jtag_uart_write+0x234>
    return ptr - start;
 182590c:	e0fffc17 	ldw	r3,-16(fp)
 1825910:	e0bff417 	ldw	r2,-48(fp)
 1825914:	1885c83a 	sub	r2,r3,r2
 1825918:	00000606 	br	1825934 <altera_avalon_jtag_uart_write+0x24c>
  else if (flags & O_NONBLOCK)
 182591c:	e0bffe17 	ldw	r2,-8(fp)
 1825920:	1090000c 	andi	r2,r2,16384
 1825924:	10000226 	beq	r2,zero,1825930 <altera_avalon_jtag_uart_write+0x248>
    return -EWOULDBLOCK;
 1825928:	00bffd44 	movi	r2,-11
 182592c:	00000106 	br	1825934 <altera_avalon_jtag_uart_write+0x24c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 1825930:	00bffec4 	movi	r2,-5
}
 1825934:	e037883a 	mov	sp,fp
 1825938:	dfc00117 	ldw	ra,4(sp)
 182593c:	df000017 	ldw	fp,0(sp)
 1825940:	dec00204 	addi	sp,sp,8
 1825944:	f800283a 	ret

01825948 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1825948:	defffe04 	addi	sp,sp,-8
 182594c:	dfc00115 	stw	ra,4(sp)
 1825950:	df000015 	stw	fp,0(sp)
 1825954:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1825958:	d0a01917 	ldw	r2,-32668(gp)
 182595c:	10000326 	beq	r2,zero,182596c <alt_get_errno+0x24>
 1825960:	d0a01917 	ldw	r2,-32668(gp)
 1825964:	103ee83a 	callr	r2
 1825968:	00000106 	br	1825970 <alt_get_errno+0x28>
 182596c:	d0a7ce04 	addi	r2,gp,-24776
}
 1825970:	e037883a 	mov	sp,fp
 1825974:	dfc00117 	ldw	ra,4(sp)
 1825978:	df000017 	ldw	fp,0(sp)
 182597c:	dec00204 	addi	sp,sp,8
 1825980:	f800283a 	ret

01825984 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 1825984:	defffc04 	addi	sp,sp,-16
 1825988:	df000315 	stw	fp,12(sp)
 182598c:	df000304 	addi	fp,sp,12
 1825990:	e13ffe15 	stw	r4,-8(fp)
 1825994:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 1825998:	e0bffe17 	ldw	r2,-8(fp)
 182599c:	10800317 	ldw	r2,12(r2)
 18259a0:	10800037 	ldwio	r2,0(r2)
 18259a4:	1080040c 	andi	r2,r2,16
 18259a8:	10000226 	beq	r2,zero,18259b4 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 18259ac:	00bffc04 	movi	r2,-16
 18259b0:	00003906 	br	1825a98 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 18259b4:	e0bffe17 	ldw	r2,-8(fp)
 18259b8:	10800317 	ldw	r2,12(r2)
 18259bc:	10800404 	addi	r2,r2,16
 18259c0:	e0fffe17 	ldw	r3,-8(fp)
 18259c4:	18c00317 	ldw	r3,12(r3)
 18259c8:	18c00404 	addi	r3,r3,16
 18259cc:	19000037 	ldwio	r4,0(r3)
 18259d0:	00fff7c4 	movi	r3,-33
 18259d4:	20c6703a 	and	r3,r4,r3
 18259d8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 18259dc:	e0bffe17 	ldw	r2,-8(fp)
 18259e0:	10800317 	ldw	r2,12(r2)
 18259e4:	00c03fc4 	movi	r3,255
 18259e8:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 18259ec:	e0bffe17 	ldw	r2,-8(fp)
 18259f0:	10800317 	ldw	r2,12(r2)
 18259f4:	10800804 	addi	r2,r2,32
 18259f8:	e0ffff17 	ldw	r3,-4(fp)
 18259fc:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 1825a00:	e0bffe17 	ldw	r2,-8(fp)
 1825a04:	10800917 	ldw	r2,36(r2)
 1825a08:	10001126 	beq	r2,zero,1825a50 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 1825a0c:	e0bffe17 	ldw	r2,-8(fp)
 1825a10:	10800317 	ldw	r2,12(r2)
 1825a14:	10800404 	addi	r2,r2,16
 1825a18:	10800037 	ldwio	r2,0(r2)
 1825a1c:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 1825a20:	e0bffe17 	ldw	r2,-8(fp)
 1825a24:	10c00b17 	ldw	r3,44(r2)
 1825a28:	e0bffd17 	ldw	r2,-12(fp)
 1825a2c:	1884b03a 	or	r2,r3,r2
 1825a30:	10801814 	ori	r2,r2,96
 1825a34:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1825a38:	e0bffe17 	ldw	r2,-8(fp)
 1825a3c:	10800317 	ldw	r2,12(r2)
 1825a40:	10800404 	addi	r2,r2,16
 1825a44:	e0fffd17 	ldw	r3,-12(fp)
 1825a48:	10c00035 	stwio	r3,0(r2)
 1825a4c:	00001106 	br	1825a94 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 1825a50:	e0bffe17 	ldw	r2,-8(fp)
 1825a54:	10800317 	ldw	r2,12(r2)
 1825a58:	10800404 	addi	r2,r2,16
 1825a5c:	10800037 	ldwio	r2,0(r2)
 1825a60:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 1825a64:	e0bffd17 	ldw	r2,-12(fp)
 1825a68:	10801814 	ori	r2,r2,96
 1825a6c:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 1825a70:	e0fffd17 	ldw	r3,-12(fp)
 1825a74:	00bffbc4 	movi	r2,-17
 1825a78:	1884703a 	and	r2,r3,r2
 1825a7c:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1825a80:	e0bffe17 	ldw	r2,-8(fp)
 1825a84:	10800317 	ldw	r2,12(r2)
 1825a88:	10800404 	addi	r2,r2,16
 1825a8c:	e0fffd17 	ldw	r3,-12(fp)
 1825a90:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 1825a94:	0005883a 	mov	r2,zero
}
 1825a98:	e037883a 	mov	sp,fp
 1825a9c:	df000017 	ldw	fp,0(sp)
 1825aa0:	dec00104 	addi	sp,sp,4
 1825aa4:	f800283a 	ret

01825aa8 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 1825aa8:	defffc04 	addi	sp,sp,-16
 1825aac:	df000315 	stw	fp,12(sp)
 1825ab0:	df000304 	addi	fp,sp,12
 1825ab4:	e13ffe15 	stw	r4,-8(fp)
 1825ab8:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 1825abc:	0001883a 	nop
 1825ac0:	e0bffe17 	ldw	r2,-8(fp)
 1825ac4:	10800317 	ldw	r2,12(r2)
 1825ac8:	10800037 	ldwio	r2,0(r2)
 1825acc:	1080040c 	andi	r2,r2,16
 1825ad0:	103ffb1e 	bne	r2,zero,1825ac0 <__ram_exceptions_end+0xff81567c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 1825ad4:	e0bffe17 	ldw	r2,-8(fp)
 1825ad8:	10800317 	ldw	r2,12(r2)
 1825adc:	10800404 	addi	r2,r2,16
 1825ae0:	e0fffe17 	ldw	r3,-8(fp)
 1825ae4:	18c00317 	ldw	r3,12(r3)
 1825ae8:	18c00404 	addi	r3,r3,16
 1825aec:	19000037 	ldwio	r4,0(r3)
 1825af0:	00fff7c4 	movi	r3,-33
 1825af4:	20c6703a 	and	r3,r4,r3
 1825af8:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 1825afc:	e0bffe17 	ldw	r2,-8(fp)
 1825b00:	10800317 	ldw	r2,12(r2)
 1825b04:	00c03fc4 	movi	r3,255
 1825b08:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 1825b0c:	e0bffe17 	ldw	r2,-8(fp)
 1825b10:	10800317 	ldw	r2,12(r2)
 1825b14:	10800804 	addi	r2,r2,32
 1825b18:	e0ffff17 	ldw	r3,-4(fp)
 1825b1c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 1825b20:	e0bffe17 	ldw	r2,-8(fp)
 1825b24:	10800317 	ldw	r2,12(r2)
 1825b28:	10800404 	addi	r2,r2,16
 1825b2c:	e0fffe17 	ldw	r3,-8(fp)
 1825b30:	18c00317 	ldw	r3,12(r3)
 1825b34:	18c00404 	addi	r3,r3,16
 1825b38:	18c00037 	ldwio	r3,0(r3)
 1825b3c:	18c01814 	ori	r3,r3,96
 1825b40:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 1825b44:	0001883a 	nop
 1825b48:	e0bffe17 	ldw	r2,-8(fp)
 1825b4c:	10800317 	ldw	r2,12(r2)
 1825b50:	10800037 	ldwio	r2,0(r2)
 1825b54:	1080040c 	andi	r2,r2,16
 1825b58:	103ffb1e 	bne	r2,zero,1825b48 <__ram_exceptions_end+0xff815704>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 1825b5c:	e0bffe17 	ldw	r2,-8(fp)
 1825b60:	10800317 	ldw	r2,12(r2)
 1825b64:	10800404 	addi	r2,r2,16
 1825b68:	e0fffe17 	ldw	r3,-8(fp)
 1825b6c:	18c00317 	ldw	r3,12(r3)
 1825b70:	18c00404 	addi	r3,r3,16
 1825b74:	19000037 	ldwio	r4,0(r3)
 1825b78:	00fff7c4 	movi	r3,-33
 1825b7c:	20c6703a 	and	r3,r4,r3
 1825b80:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 1825b84:	e0bffe17 	ldw	r2,-8(fp)
 1825b88:	10800317 	ldw	r2,12(r2)
 1825b8c:	10800037 	ldwio	r2,0(r2)
 1825b90:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 1825b94:	e0bffe17 	ldw	r2,-8(fp)
 1825b98:	10800317 	ldw	r2,12(r2)
 1825b9c:	00c03fc4 	movi	r3,255
 1825ba0:	10c00035 	stwio	r3,0(r2)

  return status;
 1825ba4:	e0bffd03 	ldbu	r2,-12(fp)
}
 1825ba8:	e037883a 	mov	sp,fp
 1825bac:	df000017 	ldw	fp,0(sp)
 1825bb0:	dec00104 	addi	sp,sp,4
 1825bb4:	f800283a 	ret

01825bb8 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 1825bb8:	defff404 	addi	sp,sp,-48
 1825bbc:	dfc00b15 	stw	ra,44(sp)
 1825bc0:	df000a15 	stw	fp,40(sp)
 1825bc4:	df000a04 	addi	fp,sp,40
 1825bc8:	e13ffb15 	stw	r4,-20(fp)
 1825bcc:	e17ffc15 	stw	r5,-16(fp)
 1825bd0:	e1bffd15 	stw	r6,-12(fp)
 1825bd4:	e1fffe15 	stw	r7,-8(fp)
 1825bd8:	e0800217 	ldw	r2,8(fp)
 1825bdc:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 1825be0:	e0bfff0b 	ldhu	r2,-4(fp)
 1825be4:	d8000415 	stw	zero,16(sp)
 1825be8:	d8000315 	stw	zero,12(sp)
 1825bec:	e0c00417 	ldw	r3,16(fp)
 1825bf0:	d8c00215 	stw	r3,8(sp)
 1825bf4:	e0c00317 	ldw	r3,12(fp)
 1825bf8:	d8c00115 	stw	r3,4(sp)
 1825bfc:	d8800015 	stw	r2,0(sp)
 1825c00:	e1fffe17 	ldw	r7,-8(fp)
 1825c04:	e1bffd17 	ldw	r6,-12(fp)
 1825c08:	e17ffc17 	ldw	r5,-16(fp)
 1825c0c:	e13ffb17 	ldw	r4,-20(fp)
 1825c10:	1825c2c0 	call	1825c2c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 1825c14:	0001883a 	nop
 1825c18:	e037883a 	mov	sp,fp
 1825c1c:	dfc00117 	ldw	ra,4(sp)
 1825c20:	df000017 	ldw	fp,0(sp)
 1825c24:	dec00204 	addi	sp,sp,8
 1825c28:	f800283a 	ret

01825c2c <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 1825c2c:	defff204 	addi	sp,sp,-56
 1825c30:	dfc00d15 	stw	ra,52(sp)
 1825c34:	df000c15 	stw	fp,48(sp)
 1825c38:	df000c04 	addi	fp,sp,48
 1825c3c:	e13ffb15 	stw	r4,-20(fp)
 1825c40:	e17ffc15 	stw	r5,-16(fp)
 1825c44:	e1bffd15 	stw	r6,-12(fp)
 1825c48:	e1fffe15 	stw	r7,-8(fp)
 1825c4c:	e0800217 	ldw	r2,8(fp)
 1825c50:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 1825c54:	e0bfff0b 	ldhu	r2,-4(fp)
 1825c58:	d8000615 	stw	zero,24(sp)
 1825c5c:	e0c00617 	ldw	r3,24(fp)
 1825c60:	d8c00515 	stw	r3,20(sp)
 1825c64:	e0c00517 	ldw	r3,20(fp)
 1825c68:	d8c00415 	stw	r3,16(sp)
 1825c6c:	e0c00417 	ldw	r3,16(fp)
 1825c70:	d8c00315 	stw	r3,12(sp)
 1825c74:	e0c00317 	ldw	r3,12(fp)
 1825c78:	d8c00215 	stw	r3,8(sp)
 1825c7c:	d8000115 	stw	zero,4(sp)
 1825c80:	d8800015 	stw	r2,0(sp)
 1825c84:	e1fffe17 	ldw	r7,-8(fp)
 1825c88:	e1bffd17 	ldw	r6,-12(fp)
 1825c8c:	e17ffc17 	ldw	r5,-16(fp)
 1825c90:	e13ffb17 	ldw	r4,-20(fp)
 1825c94:	18261c00 	call	18261c0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 1825c98:	0001883a 	nop
 1825c9c:	e037883a 	mov	sp,fp
 1825ca0:	dfc00117 	ldw	ra,4(sp)
 1825ca4:	df000017 	ldw	fp,0(sp)
 1825ca8:	dec00204 	addi	sp,sp,8
 1825cac:	f800283a 	ret

01825cb0 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 1825cb0:	defff804 	addi	sp,sp,-32
 1825cb4:	dfc00715 	stw	ra,28(sp)
 1825cb8:	df000615 	stw	fp,24(sp)
 1825cbc:	df000604 	addi	fp,sp,24
 1825cc0:	e13ffc15 	stw	r4,-16(fp)
 1825cc4:	e17ffd15 	stw	r5,-12(fp)
 1825cc8:	e1bffe15 	stw	r6,-8(fp)
 1825ccc:	3805883a 	mov	r2,r7
 1825cd0:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 1825cd4:	e0ffff0b 	ldhu	r3,-4(fp)
 1825cd8:	d8000115 	stw	zero,4(sp)
 1825cdc:	e0800217 	ldw	r2,8(fp)
 1825ce0:	d8800015 	stw	r2,0(sp)
 1825ce4:	180f883a 	mov	r7,r3
 1825ce8:	e1bffe17 	ldw	r6,-8(fp)
 1825cec:	e17ffd17 	ldw	r5,-12(fp)
 1825cf0:	e13ffc17 	ldw	r4,-16(fp)
 1825cf4:	1825d100 	call	1825d10 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 1825cf8:	0001883a 	nop
 1825cfc:	e037883a 	mov	sp,fp
 1825d00:	dfc00117 	ldw	ra,4(sp)
 1825d04:	df000017 	ldw	fp,0(sp)
 1825d08:	dec00204 	addi	sp,sp,8
 1825d0c:	f800283a 	ret

01825d10 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 1825d10:	defff304 	addi	sp,sp,-52
 1825d14:	dfc00c15 	stw	ra,48(sp)
 1825d18:	df000b15 	stw	fp,44(sp)
 1825d1c:	df000b04 	addi	fp,sp,44
 1825d20:	e13ffc15 	stw	r4,-16(fp)
 1825d24:	e17ffd15 	stw	r5,-12(fp)
 1825d28:	e1bffe15 	stw	r6,-8(fp)
 1825d2c:	3805883a 	mov	r2,r7
 1825d30:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 1825d34:	e0bfff0b 	ldhu	r2,-4(fp)
 1825d38:	d8000615 	stw	zero,24(sp)
 1825d3c:	e0c00317 	ldw	r3,12(fp)
 1825d40:	d8c00515 	stw	r3,20(sp)
 1825d44:	d8000415 	stw	zero,16(sp)
 1825d48:	e0c00217 	ldw	r3,8(fp)
 1825d4c:	d8c00315 	stw	r3,12(sp)
 1825d50:	d8000215 	stw	zero,8(sp)
 1825d54:	d8000115 	stw	zero,4(sp)
 1825d58:	d8800015 	stw	r2,0(sp)
 1825d5c:	e1fffe17 	ldw	r7,-8(fp)
 1825d60:	000d883a 	mov	r6,zero
 1825d64:	e17ffd17 	ldw	r5,-12(fp)
 1825d68:	e13ffc17 	ldw	r4,-16(fp)
 1825d6c:	18261c00 	call	18261c0 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 1825d70:	0001883a 	nop
 1825d74:	e037883a 	mov	sp,fp
 1825d78:	dfc00117 	ldw	ra,4(sp)
 1825d7c:	df000017 	ldw	fp,0(sp)
 1825d80:	dec00204 	addi	sp,sp,8
 1825d84:	f800283a 	ret

01825d88 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 1825d88:	defff404 	addi	sp,sp,-48
 1825d8c:	dfc00b15 	stw	ra,44(sp)
 1825d90:	df000a15 	stw	fp,40(sp)
 1825d94:	df000a04 	addi	fp,sp,40
 1825d98:	e13ffb15 	stw	r4,-20(fp)
 1825d9c:	e17ffc15 	stw	r5,-16(fp)
 1825da0:	e1bffd15 	stw	r6,-12(fp)
 1825da4:	3807883a 	mov	r3,r7
 1825da8:	e0800517 	ldw	r2,20(fp)
 1825dac:	e0fffe0d 	sth	r3,-8(fp)
 1825db0:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 1825db4:	e0fffe0b 	ldhu	r3,-8(fp)
 1825db8:	e0bfff03 	ldbu	r2,-4(fp)
 1825dbc:	d8800415 	stw	r2,16(sp)
 1825dc0:	d8000315 	stw	zero,12(sp)
 1825dc4:	e0800417 	ldw	r2,16(fp)
 1825dc8:	d8800215 	stw	r2,8(sp)
 1825dcc:	e0800317 	ldw	r2,12(fp)
 1825dd0:	d8800115 	stw	r2,4(sp)
 1825dd4:	e0800217 	ldw	r2,8(fp)
 1825dd8:	d8800015 	stw	r2,0(sp)
 1825ddc:	180f883a 	mov	r7,r3
 1825de0:	e1bffd17 	ldw	r6,-12(fp)
 1825de4:	e17ffc17 	ldw	r5,-16(fp)
 1825de8:	e13ffb17 	ldw	r4,-20(fp)
 1825dec:	1825e080 	call	1825e08 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 1825df0:	0001883a 	nop
 1825df4:	e037883a 	mov	sp,fp
 1825df8:	dfc00117 	ldw	ra,4(sp)
 1825dfc:	df000017 	ldw	fp,0(sp)
 1825e00:	dec00204 	addi	sp,sp,8
 1825e04:	f800283a 	ret

01825e08 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 1825e08:	defff204 	addi	sp,sp,-56
 1825e0c:	dfc00d15 	stw	ra,52(sp)
 1825e10:	df000c15 	stw	fp,48(sp)
 1825e14:	df000c04 	addi	fp,sp,48
 1825e18:	e13ffb15 	stw	r4,-20(fp)
 1825e1c:	e17ffc15 	stw	r5,-16(fp)
 1825e20:	e1bffd15 	stw	r6,-12(fp)
 1825e24:	3807883a 	mov	r3,r7
 1825e28:	e0800617 	ldw	r2,24(fp)
 1825e2c:	e0fffe0d 	sth	r3,-8(fp)
 1825e30:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 1825e34:	e0bffe0b 	ldhu	r2,-8(fp)
 1825e38:	e0ffff03 	ldbu	r3,-4(fp)
 1825e3c:	d8c00615 	stw	r3,24(sp)
 1825e40:	d8000515 	stw	zero,20(sp)
 1825e44:	e0c00517 	ldw	r3,20(fp)
 1825e48:	d8c00415 	stw	r3,16(sp)
 1825e4c:	e0c00317 	ldw	r3,12(fp)
 1825e50:	d8c00315 	stw	r3,12(sp)
 1825e54:	e0c00217 	ldw	r3,8(fp)
 1825e58:	d8c00215 	stw	r3,8(sp)
 1825e5c:	e0c00417 	ldw	r3,16(fp)
 1825e60:	d8c00115 	stw	r3,4(sp)
 1825e64:	d8800015 	stw	r2,0(sp)
 1825e68:	000f883a 	mov	r7,zero
 1825e6c:	e1bffd17 	ldw	r6,-12(fp)
 1825e70:	e17ffc17 	ldw	r5,-16(fp)
 1825e74:	e13ffb17 	ldw	r4,-20(fp)
 1825e78:	18261c00 	call	18261c0 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 1825e7c:	0001883a 	nop
 1825e80:	e037883a 	mov	sp,fp
 1825e84:	dfc00117 	ldw	ra,4(sp)
 1825e88:	df000017 	ldw	fp,0(sp)
 1825e8c:	dec00204 	addi	sp,sp,8
 1825e90:	f800283a 	ret

01825e94 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 1825e94:	defffb04 	addi	sp,sp,-20
 1825e98:	df000415 	stw	fp,16(sp)
 1825e9c:	df000404 	addi	fp,sp,16
 1825ea0:	e13ffc15 	stw	r4,-16(fp)
 1825ea4:	e17ffd15 	stw	r5,-12(fp)
 1825ea8:	e1bffe15 	stw	r6,-8(fp)
 1825eac:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 1825eb0:	e0bffc17 	ldw	r2,-16(fp)
 1825eb4:	e0fffd17 	ldw	r3,-12(fp)
 1825eb8:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 1825ebc:	e0bffc17 	ldw	r2,-16(fp)
 1825ec0:	e0ffff17 	ldw	r3,-4(fp)
 1825ec4:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 1825ec8:	e0bffc17 	ldw	r2,-16(fp)
 1825ecc:	e0fffe17 	ldw	r3,-8(fp)
 1825ed0:	10c00b15 	stw	r3,44(r2)
}
 1825ed4:	0001883a 	nop
 1825ed8:	e037883a 	mov	sp,fp
 1825edc:	df000017 	ldw	fp,0(sp)
 1825ee0:	dec00104 	addi	sp,sp,4
 1825ee4:	f800283a 	ret

01825ee8 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 1825ee8:	defffd04 	addi	sp,sp,-12
 1825eec:	df000215 	stw	fp,8(sp)
 1825ef0:	df000204 	addi	fp,sp,8
 1825ef4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 1825ef8:	e0bfff17 	ldw	r2,-4(fp)
 1825efc:	10800317 	ldw	r2,12(r2)
 1825f00:	10800404 	addi	r2,r2,16
 1825f04:	10800037 	ldwio	r2,0(r2)
 1825f08:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 1825f0c:	e0bffe17 	ldw	r2,-8(fp)
 1825f10:	10800814 	ori	r2,r2,32
 1825f14:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1825f18:	e0bfff17 	ldw	r2,-4(fp)
 1825f1c:	10800317 	ldw	r2,12(r2)
 1825f20:	10800404 	addi	r2,r2,16
 1825f24:	e0fffe17 	ldw	r3,-8(fp)
 1825f28:	10c00035 	stwio	r3,0(r2)
}
 1825f2c:	0001883a 	nop
 1825f30:	e037883a 	mov	sp,fp
 1825f34:	df000017 	ldw	fp,0(sp)
 1825f38:	dec00104 	addi	sp,sp,4
 1825f3c:	f800283a 	ret

01825f40 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 1825f40:	defffd04 	addi	sp,sp,-12
 1825f44:	df000215 	stw	fp,8(sp)
 1825f48:	df000204 	addi	fp,sp,8
 1825f4c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 1825f50:	e0bfff17 	ldw	r2,-4(fp)
 1825f54:	10800317 	ldw	r2,12(r2)
 1825f58:	10800404 	addi	r2,r2,16
 1825f5c:	10800037 	ldwio	r2,0(r2)
 1825f60:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 1825f64:	e0fffe17 	ldw	r3,-8(fp)
 1825f68:	00bff7c4 	movi	r2,-33
 1825f6c:	1884703a 	and	r2,r3,r2
 1825f70:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1825f74:	e0bfff17 	ldw	r2,-4(fp)
 1825f78:	10800317 	ldw	r2,12(r2)
 1825f7c:	10800404 	addi	r2,r2,16
 1825f80:	e0fffe17 	ldw	r3,-8(fp)
 1825f84:	10c00035 	stwio	r3,0(r2)
}
 1825f88:	0001883a 	nop
 1825f8c:	e037883a 	mov	sp,fp
 1825f90:	df000017 	ldw	fp,0(sp)
 1825f94:	dec00104 	addi	sp,sp,4
 1825f98:	f800283a 	ret

01825f9c <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 1825f9c:	defffe04 	addi	sp,sp,-8
 1825fa0:	df000115 	stw	fp,4(sp)
 1825fa4:	df000104 	addi	fp,sp,4
 1825fa8:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 1825fac:	e0bfff17 	ldw	r2,-4(fp)
 1825fb0:	10800784 	addi	r2,r2,30
 1825fb4:	10800023 	ldbuio	r2,0(r2)
 1825fb8:	10803fcc 	andi	r2,r2,255
 1825fbc:	10801fcc 	andi	r2,r2,127
 1825fc0:	10000226 	beq	r2,zero,1825fcc <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 1825fc4:	00bffec4 	movi	r2,-5
 1825fc8:	00000906 	br	1825ff0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 1825fcc:	e0bfff17 	ldw	r2,-4(fp)
 1825fd0:	108007c4 	addi	r2,r2,31
 1825fd4:	10800023 	ldbuio	r2,0(r2)
 1825fd8:	10803fcc 	andi	r2,r2,255
 1825fdc:	1080200c 	andi	r2,r2,128
 1825fe0:	10000226 	beq	r2,zero,1825fec <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 1825fe4:	00bfe244 	movi	r2,-119
 1825fe8:	00000106 	br	1825ff0 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 1825fec:	0005883a 	mov	r2,zero
}
 1825ff0:	e037883a 	mov	sp,fp
 1825ff4:	df000017 	ldw	fp,0(sp)
 1825ff8:	dec00104 	addi	sp,sp,4
 1825ffc:	f800283a 	ret

01826000 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 1826000:	defffc04 	addi	sp,sp,-16
 1826004:	dfc00315 	stw	ra,12(sp)
 1826008:	df000215 	stw	fp,8(sp)
 182600c:	df000204 	addi	fp,sp,8
 1826010:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 1826014:	d1601704 	addi	r5,gp,-32676
 1826018:	e13fff17 	ldw	r4,-4(fp)
 182601c:	1827c7c0 	call	1827c7c <alt_find_dev>
 1826020:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 1826024:	e0bffe17 	ldw	r2,-8(fp)
 1826028:	1000041e 	bne	r2,zero,182603c <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 182602c:	18259480 	call	1825948 <alt_get_errno>
 1826030:	1007883a 	mov	r3,r2
 1826034:	008004c4 	movi	r2,19
 1826038:	18800015 	stw	r2,0(r3)
  }

  return dev;
 182603c:	e0bffe17 	ldw	r2,-8(fp)
}
 1826040:	e037883a 	mov	sp,fp
 1826044:	dfc00117 	ldw	ra,4(sp)
 1826048:	df000017 	ldw	fp,0(sp)
 182604c:	dec00204 	addi	sp,sp,8
 1826050:	f800283a 	ret

01826054 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 1826054:	defff104 	addi	sp,sp,-60
 1826058:	dfc00e15 	stw	ra,56(sp)
 182605c:	df000d15 	stw	fp,52(sp)
 1826060:	df000d04 	addi	fp,sp,52
 1826064:	e13ffa15 	stw	r4,-24(fp)
 1826068:	e17ffb15 	stw	r5,-20(fp)
 182606c:	e1bffc15 	stw	r6,-16(fp)
 1826070:	e1fffd15 	stw	r7,-12(fp)
 1826074:	e0c00217 	ldw	r3,8(fp)
 1826078:	e0800617 	ldw	r2,24(fp)
 182607c:	e0fffe0d 	sth	r3,-8(fp)
 1826080:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 1826084:	e0bffe0b 	ldhu	r2,-8(fp)
 1826088:	e0ffff03 	ldbu	r3,-4(fp)
 182608c:	d8c00615 	stw	r3,24(sp)
 1826090:	d8000515 	stw	zero,20(sp)
 1826094:	d8000415 	stw	zero,16(sp)
 1826098:	e0c00517 	ldw	r3,20(fp)
 182609c:	d8c00315 	stw	r3,12(sp)
 18260a0:	e0c00417 	ldw	r3,16(fp)
 18260a4:	d8c00215 	stw	r3,8(sp)
 18260a8:	e0c00317 	ldw	r3,12(fp)
 18260ac:	d8c00115 	stw	r3,4(sp)
 18260b0:	d8800015 	stw	r2,0(sp)
 18260b4:	e1fffd17 	ldw	r7,-12(fp)
 18260b8:	e1bffc17 	ldw	r6,-16(fp)
 18260bc:	e17ffb17 	ldw	r5,-20(fp)
 18260c0:	e13ffa17 	ldw	r4,-24(fp)
 18260c4:	18261c00 	call	18261c0 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 18260c8:	0001883a 	nop
 18260cc:	e037883a 	mov	sp,fp
 18260d0:	dfc00117 	ldw	ra,4(sp)
 18260d4:	df000017 	ldw	fp,0(sp)
 18260d8:	dec00204 	addi	sp,sp,8
 18260dc:	f800283a 	ret

018260e0 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 18260e0:	defffc04 	addi	sp,sp,-16
 18260e4:	df000315 	stw	fp,12(sp)
 18260e8:	df000304 	addi	fp,sp,12
 18260ec:	e13ffe15 	stw	r4,-8(fp)
 18260f0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 18260f4:	e0bffe17 	ldw	r2,-8(fp)
 18260f8:	10800317 	ldw	r2,12(r2)
 18260fc:	10800404 	addi	r2,r2,16
 1826100:	10800037 	ldwio	r2,0(r2)
 1826104:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 1826108:	e0fffd17 	ldw	r3,-12(fp)
 182610c:	00a00434 	movhi	r2,32784
 1826110:	10bfffc4 	addi	r2,r2,-1
 1826114:	1884703a 	and	r2,r3,r2
 1826118:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 182611c:	e0bfff17 	ldw	r2,-4(fp)
 1826120:	1004953a 	slli	r2,r2,20
 1826124:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 1826128:	e0bffd17 	ldw	r2,-12(fp)
 182612c:	1884b03a 	or	r2,r3,r2
 1826130:	10800134 	orhi	r2,r2,4
 1826134:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1826138:	e0bffe17 	ldw	r2,-8(fp)
 182613c:	10800317 	ldw	r2,12(r2)
 1826140:	10800404 	addi	r2,r2,16
 1826144:	e0fffd17 	ldw	r3,-12(fp)
 1826148:	10c00035 	stwio	r3,0(r2)
  
  return;
 182614c:	0001883a 	nop
}
 1826150:	e037883a 	mov	sp,fp
 1826154:	df000017 	ldw	fp,0(sp)
 1826158:	dec00104 	addi	sp,sp,4
 182615c:	f800283a 	ret

01826160 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 1826160:	defffd04 	addi	sp,sp,-12
 1826164:	df000215 	stw	fp,8(sp)
 1826168:	df000204 	addi	fp,sp,8
 182616c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 1826170:	e0bfff17 	ldw	r2,-4(fp)
 1826174:	10800317 	ldw	r2,12(r2)
 1826178:	10800404 	addi	r2,r2,16
 182617c:	10800037 	ldwio	r2,0(r2)
 1826180:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 1826184:	e0fffe17 	ldw	r3,-8(fp)
 1826188:	00bfff34 	movhi	r2,65532
 182618c:	10bfffc4 	addi	r2,r2,-1
 1826190:	1884703a 	and	r2,r3,r2
 1826194:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 1826198:	e0bfff17 	ldw	r2,-4(fp)
 182619c:	10800317 	ldw	r2,12(r2)
 18261a0:	10800404 	addi	r2,r2,16
 18261a4:	e0fffe17 	ldw	r3,-8(fp)
 18261a8:	10c00035 	stwio	r3,0(r2)
  
  return;
 18261ac:	0001883a 	nop
}
 18261b0:	e037883a 	mov	sp,fp
 18261b4:	df000017 	ldw	fp,0(sp)
 18261b8:	dec00104 	addi	sp,sp,4
 18261bc:	f800283a 	ret

018261c0 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 18261c0:	defff804 	addi	sp,sp,-32
 18261c4:	dfc00715 	stw	ra,28(sp)
 18261c8:	df000615 	stw	fp,24(sp)
 18261cc:	df000604 	addi	fp,sp,24
 18261d0:	e13ffa15 	stw	r4,-24(fp)
 18261d4:	e17ffb15 	stw	r5,-20(fp)
 18261d8:	e1bffc15 	stw	r6,-16(fp)
 18261dc:	e1fffd15 	stw	r7,-12(fp)
 18261e0:	e0c00217 	ldw	r3,8(fp)
 18261e4:	e0800817 	ldw	r2,32(fp)
 18261e8:	e0fffe0d 	sth	r3,-8(fp)
 18261ec:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 18261f0:	e0bffb17 	ldw	r2,-20(fp)
 18261f4:	108007c4 	addi	r2,r2,31
 18261f8:	e0fffb17 	ldw	r3,-20(fp)
 18261fc:	18c007c3 	ldbu	r3,31(r3)
 1826200:	19003fcc 	andi	r4,r3,255
 1826204:	00ffdfc4 	movi	r3,-129
 1826208:	20c6703a 	and	r3,r4,r3
 182620c:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 1826210:	e0bffa17 	ldw	r2,-24(fp)
 1826214:	e0fffc17 	ldw	r3,-16(fp)
 1826218:	19403fcc 	andi	r5,r3,255
 182621c:	10c00003 	ldbu	r3,0(r2)
 1826220:	1806703a 	and	r3,r3,zero
 1826224:	1809883a 	mov	r4,r3
 1826228:	2807883a 	mov	r3,r5
 182622c:	20c6b03a 	or	r3,r4,r3
 1826230:	10c00005 	stb	r3,0(r2)
 1826234:	e0fffc17 	ldw	r3,-16(fp)
 1826238:	1806d23a 	srli	r3,r3,8
 182623c:	19403fcc 	andi	r5,r3,255
 1826240:	10c00043 	ldbu	r3,1(r2)
 1826244:	1806703a 	and	r3,r3,zero
 1826248:	1809883a 	mov	r4,r3
 182624c:	2807883a 	mov	r3,r5
 1826250:	20c6b03a 	or	r3,r4,r3
 1826254:	10c00045 	stb	r3,1(r2)
 1826258:	e0fffc17 	ldw	r3,-16(fp)
 182625c:	1806d43a 	srli	r3,r3,16
 1826260:	19403fcc 	andi	r5,r3,255
 1826264:	10c00083 	ldbu	r3,2(r2)
 1826268:	1806703a 	and	r3,r3,zero
 182626c:	1809883a 	mov	r4,r3
 1826270:	2807883a 	mov	r3,r5
 1826274:	20c6b03a 	or	r3,r4,r3
 1826278:	10c00085 	stb	r3,2(r2)
 182627c:	e0fffc17 	ldw	r3,-16(fp)
 1826280:	180ad63a 	srli	r5,r3,24
 1826284:	10c000c3 	ldbu	r3,3(r2)
 1826288:	1806703a 	and	r3,r3,zero
 182628c:	1809883a 	mov	r4,r3
 1826290:	2807883a 	mov	r3,r5
 1826294:	20c6b03a 	or	r3,r4,r3
 1826298:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 182629c:	e0bffa17 	ldw	r2,-24(fp)
 18262a0:	e0fffd17 	ldw	r3,-12(fp)
 18262a4:	19403fcc 	andi	r5,r3,255
 18262a8:	10c00203 	ldbu	r3,8(r2)
 18262ac:	1806703a 	and	r3,r3,zero
 18262b0:	1809883a 	mov	r4,r3
 18262b4:	2807883a 	mov	r3,r5
 18262b8:	20c6b03a 	or	r3,r4,r3
 18262bc:	10c00205 	stb	r3,8(r2)
 18262c0:	e0fffd17 	ldw	r3,-12(fp)
 18262c4:	1806d23a 	srli	r3,r3,8
 18262c8:	19403fcc 	andi	r5,r3,255
 18262cc:	10c00243 	ldbu	r3,9(r2)
 18262d0:	1806703a 	and	r3,r3,zero
 18262d4:	1809883a 	mov	r4,r3
 18262d8:	2807883a 	mov	r3,r5
 18262dc:	20c6b03a 	or	r3,r4,r3
 18262e0:	10c00245 	stb	r3,9(r2)
 18262e4:	e0fffd17 	ldw	r3,-12(fp)
 18262e8:	1806d43a 	srli	r3,r3,16
 18262ec:	19403fcc 	andi	r5,r3,255
 18262f0:	10c00283 	ldbu	r3,10(r2)
 18262f4:	1806703a 	and	r3,r3,zero
 18262f8:	1809883a 	mov	r4,r3
 18262fc:	2807883a 	mov	r3,r5
 1826300:	20c6b03a 	or	r3,r4,r3
 1826304:	10c00285 	stb	r3,10(r2)
 1826308:	e0fffd17 	ldw	r3,-12(fp)
 182630c:	180ad63a 	srli	r5,r3,24
 1826310:	10c002c3 	ldbu	r3,11(r2)
 1826314:	1806703a 	and	r3,r3,zero
 1826318:	1809883a 	mov	r4,r3
 182631c:	2807883a 	mov	r3,r5
 1826320:	20c6b03a 	or	r3,r4,r3
 1826324:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 1826328:	e0bffa17 	ldw	r2,-24(fp)
 182632c:	e0fffb17 	ldw	r3,-20(fp)
 1826330:	19403fcc 	andi	r5,r3,255
 1826334:	10c00403 	ldbu	r3,16(r2)
 1826338:	1806703a 	and	r3,r3,zero
 182633c:	1809883a 	mov	r4,r3
 1826340:	2807883a 	mov	r3,r5
 1826344:	20c6b03a 	or	r3,r4,r3
 1826348:	10c00405 	stb	r3,16(r2)
 182634c:	e0fffb17 	ldw	r3,-20(fp)
 1826350:	1806d23a 	srli	r3,r3,8
 1826354:	19403fcc 	andi	r5,r3,255
 1826358:	10c00443 	ldbu	r3,17(r2)
 182635c:	1806703a 	and	r3,r3,zero
 1826360:	1809883a 	mov	r4,r3
 1826364:	2807883a 	mov	r3,r5
 1826368:	20c6b03a 	or	r3,r4,r3
 182636c:	10c00445 	stb	r3,17(r2)
 1826370:	e0fffb17 	ldw	r3,-20(fp)
 1826374:	1806d43a 	srli	r3,r3,16
 1826378:	19403fcc 	andi	r5,r3,255
 182637c:	10c00483 	ldbu	r3,18(r2)
 1826380:	1806703a 	and	r3,r3,zero
 1826384:	1809883a 	mov	r4,r3
 1826388:	2807883a 	mov	r3,r5
 182638c:	20c6b03a 	or	r3,r4,r3
 1826390:	10c00485 	stb	r3,18(r2)
 1826394:	e0fffb17 	ldw	r3,-20(fp)
 1826398:	180ad63a 	srli	r5,r3,24
 182639c:	10c004c3 	ldbu	r3,19(r2)
 18263a0:	1806703a 	and	r3,r3,zero
 18263a4:	1809883a 	mov	r4,r3
 18263a8:	2807883a 	mov	r3,r5
 18263ac:	20c6b03a 	or	r3,r4,r3
 18263b0:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 18263b4:	e0bffa17 	ldw	r2,-24(fp)
 18263b8:	10c00103 	ldbu	r3,4(r2)
 18263bc:	1806703a 	and	r3,r3,zero
 18263c0:	10c00105 	stb	r3,4(r2)
 18263c4:	10c00143 	ldbu	r3,5(r2)
 18263c8:	1806703a 	and	r3,r3,zero
 18263cc:	10c00145 	stb	r3,5(r2)
 18263d0:	10c00183 	ldbu	r3,6(r2)
 18263d4:	1806703a 	and	r3,r3,zero
 18263d8:	10c00185 	stb	r3,6(r2)
 18263dc:	10c001c3 	ldbu	r3,7(r2)
 18263e0:	1806703a 	and	r3,r3,zero
 18263e4:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 18263e8:	e0bffa17 	ldw	r2,-24(fp)
 18263ec:	10c00303 	ldbu	r3,12(r2)
 18263f0:	1806703a 	and	r3,r3,zero
 18263f4:	10c00305 	stb	r3,12(r2)
 18263f8:	10c00343 	ldbu	r3,13(r2)
 18263fc:	1806703a 	and	r3,r3,zero
 1826400:	10c00345 	stb	r3,13(r2)
 1826404:	10c00383 	ldbu	r3,14(r2)
 1826408:	1806703a 	and	r3,r3,zero
 182640c:	10c00385 	stb	r3,14(r2)
 1826410:	10c003c3 	ldbu	r3,15(r2)
 1826414:	1806703a 	and	r3,r3,zero
 1826418:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 182641c:	e0bffa17 	ldw	r2,-24(fp)
 1826420:	10c00503 	ldbu	r3,20(r2)
 1826424:	1806703a 	and	r3,r3,zero
 1826428:	10c00505 	stb	r3,20(r2)
 182642c:	10c00543 	ldbu	r3,21(r2)
 1826430:	1806703a 	and	r3,r3,zero
 1826434:	10c00545 	stb	r3,21(r2)
 1826438:	10c00583 	ldbu	r3,22(r2)
 182643c:	1806703a 	and	r3,r3,zero
 1826440:	10c00585 	stb	r3,22(r2)
 1826444:	10c005c3 	ldbu	r3,23(r2)
 1826448:	1806703a 	and	r3,r3,zero
 182644c:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 1826450:	e0bffa17 	ldw	r2,-24(fp)
 1826454:	e0fffe17 	ldw	r3,-8(fp)
 1826458:	19403fcc 	andi	r5,r3,255
 182645c:	10c00603 	ldbu	r3,24(r2)
 1826460:	1806703a 	and	r3,r3,zero
 1826464:	1809883a 	mov	r4,r3
 1826468:	2807883a 	mov	r3,r5
 182646c:	20c6b03a 	or	r3,r4,r3
 1826470:	10c00605 	stb	r3,24(r2)
 1826474:	e0fffe17 	ldw	r3,-8(fp)
 1826478:	1806d23a 	srli	r3,r3,8
 182647c:	19403fcc 	andi	r5,r3,255
 1826480:	10c00643 	ldbu	r3,25(r2)
 1826484:	1806703a 	and	r3,r3,zero
 1826488:	1809883a 	mov	r4,r3
 182648c:	2807883a 	mov	r3,r5
 1826490:	20c6b03a 	or	r3,r4,r3
 1826494:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 1826498:	e0bffa17 	ldw	r2,-24(fp)
 182649c:	10c00703 	ldbu	r3,28(r2)
 18264a0:	1806703a 	and	r3,r3,zero
 18264a4:	10c00705 	stb	r3,28(r2)
 18264a8:	10c00743 	ldbu	r3,29(r2)
 18264ac:	1806703a 	and	r3,r3,zero
 18264b0:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 18264b4:	e0bffa17 	ldw	r2,-24(fp)
 18264b8:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 18264bc:	e0800617 	ldw	r2,24(fp)
 18264c0:	1007883a 	mov	r3,r2
 18264c4:	e0bffa17 	ldw	r2,-24(fp)
 18264c8:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 18264cc:	e0800717 	ldw	r2,28(fp)
 18264d0:	1007883a 	mov	r3,r2
 18264d4:	e0bffa17 	ldw	r2,-24(fp)
 18264d8:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 18264dc:	e0800317 	ldw	r2,12(fp)
 18264e0:	10000226 	beq	r2,zero,18264ec <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 18264e4:	00bfe044 	movi	r2,-127
 18264e8:	00000106 	br	18264f0 <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 18264ec:	00bfe004 	movi	r2,-128
 18264f0:	e0c00417 	ldw	r3,16(fp)
 18264f4:	18000226 	beq	r3,zero,1826500 <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 18264f8:	00c00084 	movi	r3,2
 18264fc:	00000106 	br	1826504 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 1826500:	0007883a 	mov	r3,zero
 1826504:	10c4b03a 	or	r2,r2,r3
 1826508:	1007883a 	mov	r3,r2
 182650c:	e0800517 	ldw	r2,20(fp)
 1826510:	10000226 	beq	r2,zero,182651c <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 1826514:	00800104 	movi	r2,4
 1826518:	00000106 	br	1826520 <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 182651c:	0005883a 	mov	r2,zero
 1826520:	1884b03a 	or	r2,r3,r2
 1826524:	1007883a 	mov	r3,r2
 1826528:	e0bfff03 	ldbu	r2,-4(fp)
 182652c:	10000426 	beq	r2,zero,1826540 <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 1826530:	e0bfff03 	ldbu	r2,-4(fp)
 1826534:	108003cc 	andi	r2,r2,15
 1826538:	100490fa 	slli	r2,r2,3
 182653c:	00000106 	br	1826544 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 1826540:	0005883a 	mov	r2,zero
 1826544:	1884b03a 	or	r2,r3,r2
 1826548:	1007883a 	mov	r3,r2
 182654c:	e0bffa17 	ldw	r2,-24(fp)
 1826550:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 1826554:	01400804 	movi	r5,32
 1826558:	e13ffa17 	ldw	r4,-24(fp)
 182655c:	1827b540 	call	1827b54 <alt_dcache_flush>
}
 1826560:	0001883a 	nop
 1826564:	e037883a 	mov	sp,fp
 1826568:	dfc00117 	ldw	ra,4(sp)
 182656c:	df000017 	ldw	fp,0(sp)
 1826570:	dec00204 	addi	sp,sp,8
 1826574:	f800283a 	ret

01826578 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 1826578:	defff904 	addi	sp,sp,-28
 182657c:	dfc00615 	stw	ra,24(sp)
 1826580:	df000515 	stw	fp,20(sp)
 1826584:	df000504 	addi	fp,sp,20
 1826588:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 182658c:	e0bfff17 	ldw	r2,-4(fp)
 1826590:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 1826594:	e0bffb17 	ldw	r2,-20(fp)
 1826598:	10800317 	ldw	r2,12(r2)
 182659c:	10800404 	addi	r2,r2,16
 18265a0:	e0fffb17 	ldw	r3,-20(fp)
 18265a4:	18c00317 	ldw	r3,12(r3)
 18265a8:	18c00404 	addi	r3,r3,16
 18265ac:	18c00037 	ldwio	r3,0(r3)
 18265b0:	18e00034 	orhi	r3,r3,32768
 18265b4:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 18265b8:	e0bffb17 	ldw	r2,-20(fp)
 18265bc:	10800317 	ldw	r2,12(r2)
 18265c0:	10800404 	addi	r2,r2,16
 18265c4:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 18265c8:	e0bffb17 	ldw	r2,-20(fp)
 18265cc:	10800917 	ldw	r2,36(r2)
 18265d0:	10001226 	beq	r2,zero,182661c <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18265d4:	0005303a 	rdctl	r2,status
 18265d8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18265dc:	e0fffd17 	ldw	r3,-12(fp)
 18265e0:	00bfff84 	movi	r2,-2
 18265e4:	1884703a 	and	r2,r3,r2
 18265e8:	1001703a 	wrctl	status,r2
  
  return context;
 18265ec:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 18265f0:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 18265f4:	e0bffb17 	ldw	r2,-20(fp)
 18265f8:	10800917 	ldw	r2,36(r2)
 18265fc:	e0fffb17 	ldw	r3,-20(fp)
 1826600:	18c00a17 	ldw	r3,40(r3)
 1826604:	1809883a 	mov	r4,r3
 1826608:	103ee83a 	callr	r2
 182660c:	e0bffc17 	ldw	r2,-16(fp)
 1826610:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1826614:	e0bffe17 	ldw	r2,-8(fp)
 1826618:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 182661c:	0001883a 	nop
 1826620:	e037883a 	mov	sp,fp
 1826624:	dfc00117 	ldw	ra,4(sp)
 1826628:	df000017 	ldw	fp,0(sp)
 182662c:	dec00204 	addi	sp,sp,8
 1826630:	f800283a 	ret

01826634 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 1826634:	defffa04 	addi	sp,sp,-24
 1826638:	dfc00515 	stw	ra,20(sp)
 182663c:	df000415 	stw	fp,16(sp)
 1826640:	df000404 	addi	fp,sp,16
 1826644:	e13ffd15 	stw	r4,-12(fp)
 1826648:	e17ffe15 	stw	r5,-8(fp)
 182664c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 1826650:	e0bffd17 	ldw	r2,-12(fp)
 1826654:	10800317 	ldw	r2,12(r2)
 1826658:	10800404 	addi	r2,r2,16
 182665c:	00c00074 	movhi	r3,1
 1826660:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 1826664:	e0bffd17 	ldw	r2,-12(fp)
 1826668:	10800317 	ldw	r2,12(r2)
 182666c:	10800404 	addi	r2,r2,16
 1826670:	00c00074 	movhi	r3,1
 1826674:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 1826678:	e0bffd17 	ldw	r2,-12(fp)
 182667c:	10800317 	ldw	r2,12(r2)
 1826680:	10800404 	addi	r2,r2,16
 1826684:	0007883a 	mov	r3,zero
 1826688:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 182668c:	e0bffd17 	ldw	r2,-12(fp)
 1826690:	10800317 	ldw	r2,12(r2)
 1826694:	00c03fc4 	movi	r3,255
 1826698:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 182669c:	d1601704 	addi	r5,gp,-32676
 18266a0:	e13ffd17 	ldw	r4,-12(fp)
 18266a4:	1827bd80 	call	1827bd8 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 18266a8:	d8000015 	stw	zero,0(sp)
 18266ac:	e1fffd17 	ldw	r7,-12(fp)
 18266b0:	018060b4 	movhi	r6,386
 18266b4:	31995e04 	addi	r6,r6,25976
 18266b8:	e17fff17 	ldw	r5,-4(fp)
 18266bc:	e13ffe17 	ldw	r4,-8(fp)
 18266c0:	182811c0 	call	182811c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 18266c4:	0001883a 	nop
 18266c8:	e037883a 	mov	sp,fp
 18266cc:	dfc00117 	ldw	ra,4(sp)
 18266d0:	df000017 	ldw	fp,0(sp)
 18266d4:	dec00204 	addi	sp,sp,8
 18266d8:	f800283a 	ret

018266dc <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 18266dc:	defffa04 	addi	sp,sp,-24
 18266e0:	dfc00515 	stw	ra,20(sp)
 18266e4:	df000415 	stw	fp,16(sp)
 18266e8:	df000404 	addi	fp,sp,16
 18266ec:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 18266f0:	0007883a 	mov	r3,zero
 18266f4:	e0bfff17 	ldw	r2,-4(fp)
 18266f8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 18266fc:	e0bfff17 	ldw	r2,-4(fp)
 1826700:	10800104 	addi	r2,r2,4
 1826704:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1826708:	0005303a 	rdctl	r2,status
 182670c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1826710:	e0fffd17 	ldw	r3,-12(fp)
 1826714:	00bfff84 	movi	r2,-2
 1826718:	1884703a 	and	r2,r3,r2
 182671c:	1001703a 	wrctl	status,r2
  
  return context;
 1826720:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 1826724:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 1826728:	18285900 	call	1828590 <alt_tick>
 182672c:	e0bffc17 	ldw	r2,-16(fp)
 1826730:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1826734:	e0bffe17 	ldw	r2,-8(fp)
 1826738:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 182673c:	0001883a 	nop
 1826740:	e037883a 	mov	sp,fp
 1826744:	dfc00117 	ldw	ra,4(sp)
 1826748:	df000017 	ldw	fp,0(sp)
 182674c:	dec00204 	addi	sp,sp,8
 1826750:	f800283a 	ret

01826754 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 1826754:	defff804 	addi	sp,sp,-32
 1826758:	dfc00715 	stw	ra,28(sp)
 182675c:	df000615 	stw	fp,24(sp)
 1826760:	df000604 	addi	fp,sp,24
 1826764:	e13ffc15 	stw	r4,-16(fp)
 1826768:	e17ffd15 	stw	r5,-12(fp)
 182676c:	e1bffe15 	stw	r6,-8(fp)
 1826770:	e1ffff15 	stw	r7,-4(fp)
 1826774:	e0bfff17 	ldw	r2,-4(fp)
 1826778:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 182677c:	d0a80917 	ldw	r2,-24540(gp)
 1826780:	1000021e 	bne	r2,zero,182678c <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 1826784:	e0bffb17 	ldw	r2,-20(fp)
 1826788:	d0a80915 	stw	r2,-24540(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 182678c:	e0bffc17 	ldw	r2,-16(fp)
 1826790:	10800104 	addi	r2,r2,4
 1826794:	00c001c4 	movi	r3,7
 1826798:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 182679c:	d8000015 	stw	zero,0(sp)
 18267a0:	e1fffc17 	ldw	r7,-16(fp)
 18267a4:	018060b4 	movhi	r6,386
 18267a8:	3199b704 	addi	r6,r6,26332
 18267ac:	e17ffe17 	ldw	r5,-8(fp)
 18267b0:	e13ffd17 	ldw	r4,-12(fp)
 18267b4:	182811c0 	call	182811c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 18267b8:	0001883a 	nop
 18267bc:	e037883a 	mov	sp,fp
 18267c0:	dfc00117 	ldw	ra,4(sp)
 18267c4:	df000017 	ldw	fp,0(sp)
 18267c8:	dec00204 	addi	sp,sp,8
 18267cc:	f800283a 	ret

018267d0 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 18267d0:	defffa04 	addi	sp,sp,-24
 18267d4:	dfc00515 	stw	ra,20(sp)
 18267d8:	df000415 	stw	fp,16(sp)
 18267dc:	df000404 	addi	fp,sp,16
 18267e0:	e13ffd15 	stw	r4,-12(fp)
 18267e4:	e17ffe15 	stw	r5,-8(fp)
 18267e8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 18267ec:	e0bffd17 	ldw	r2,-12(fp)
 18267f0:	10800017 	ldw	r2,0(r2)
 18267f4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 18267f8:	e0bffc17 	ldw	r2,-16(fp)
 18267fc:	10c00a04 	addi	r3,r2,40
 1826800:	e0bffd17 	ldw	r2,-12(fp)
 1826804:	10800217 	ldw	r2,8(r2)
 1826808:	100f883a 	mov	r7,r2
 182680c:	e1bfff17 	ldw	r6,-4(fp)
 1826810:	e17ffe17 	ldw	r5,-8(fp)
 1826814:	1809883a 	mov	r4,r3
 1826818:	1826d940 	call	1826d94 <altera_avalon_uart_read>
      fd->fd_flags);
}
 182681c:	e037883a 	mov	sp,fp
 1826820:	dfc00117 	ldw	ra,4(sp)
 1826824:	df000017 	ldw	fp,0(sp)
 1826828:	dec00204 	addi	sp,sp,8
 182682c:	f800283a 	ret

01826830 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1826830:	defffa04 	addi	sp,sp,-24
 1826834:	dfc00515 	stw	ra,20(sp)
 1826838:	df000415 	stw	fp,16(sp)
 182683c:	df000404 	addi	fp,sp,16
 1826840:	e13ffd15 	stw	r4,-12(fp)
 1826844:	e17ffe15 	stw	r5,-8(fp)
 1826848:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 182684c:	e0bffd17 	ldw	r2,-12(fp)
 1826850:	10800017 	ldw	r2,0(r2)
 1826854:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 1826858:	e0bffc17 	ldw	r2,-16(fp)
 182685c:	10c00a04 	addi	r3,r2,40
 1826860:	e0bffd17 	ldw	r2,-12(fp)
 1826864:	10800217 	ldw	r2,8(r2)
 1826868:	100f883a 	mov	r7,r2
 182686c:	e1bfff17 	ldw	r6,-4(fp)
 1826870:	e17ffe17 	ldw	r5,-8(fp)
 1826874:	1809883a 	mov	r4,r3
 1826878:	1826fe80 	call	1826fe8 <altera_avalon_uart_write>
      fd->fd_flags);
}
 182687c:	e037883a 	mov	sp,fp
 1826880:	dfc00117 	ldw	ra,4(sp)
 1826884:	df000017 	ldw	fp,0(sp)
 1826888:	dec00204 	addi	sp,sp,8
 182688c:	f800283a 	ret

01826890 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 1826890:	defffc04 	addi	sp,sp,-16
 1826894:	dfc00315 	stw	ra,12(sp)
 1826898:	df000215 	stw	fp,8(sp)
 182689c:	df000204 	addi	fp,sp,8
 18268a0:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 18268a4:	e0bfff17 	ldw	r2,-4(fp)
 18268a8:	10800017 	ldw	r2,0(r2)
 18268ac:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 18268b0:	e0bffe17 	ldw	r2,-8(fp)
 18268b4:	10c00a04 	addi	r3,r2,40
 18268b8:	e0bfff17 	ldw	r2,-4(fp)
 18268bc:	10800217 	ldw	r2,8(r2)
 18268c0:	100b883a 	mov	r5,r2
 18268c4:	1809883a 	mov	r4,r3
 18268c8:	1826d040 	call	1826d04 <altera_avalon_uart_close>
}
 18268cc:	e037883a 	mov	sp,fp
 18268d0:	dfc00117 	ldw	ra,4(sp)
 18268d4:	df000017 	ldw	fp,0(sp)
 18268d8:	dec00204 	addi	sp,sp,8
 18268dc:	f800283a 	ret

018268e0 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 18268e0:	defff504 	addi	sp,sp,-44
 18268e4:	dfc00a15 	stw	ra,40(sp)
 18268e8:	df000915 	stw	fp,36(sp)
 18268ec:	df000904 	addi	fp,sp,36
 18268f0:	e13ffd15 	stw	r4,-12(fp)
 18268f4:	e17ffe15 	stw	r5,-8(fp)
 18268f8:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 18268fc:	e0bffd17 	ldw	r2,-12(fp)
 1826900:	10800017 	ldw	r2,0(r2)
 1826904:	e0bff815 	stw	r2,-32(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 1826908:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 182690c:	1000301e 	bne	r2,zero,18269d0 <altera_avalon_uart_init+0xf0>
 1826910:	e0bffd17 	ldw	r2,-12(fp)
 1826914:	10800704 	addi	r2,r2,28
 1826918:	e0bff915 	stw	r2,-28(fp)
 182691c:	00800044 	movi	r2,1
 1826920:	e0bffc0d 	sth	r2,-16(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 1826924:	e0bffc0b 	ldhu	r2,-16(fp)
 1826928:	10000226 	beq	r2,zero,1826934 <altera_avalon_uart_init+0x54>
 182692c:	e0bffc0b 	ldhu	r2,-16(fp)
 1826930:	00000106 	br	1826938 <altera_avalon_uart_init+0x58>
 1826934:	00800044 	movi	r2,1
 1826938:	e0fffc0b 	ldhu	r3,-16(fp)
 182693c:	180b883a 	mov	r5,r3
 1826940:	1009883a 	mov	r4,r2
 1826944:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 1826948:	1007883a 	mov	r3,r2
 182694c:	e0bff917 	ldw	r2,-28(fp)
 1826950:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 1826954:	e0bff917 	ldw	r2,-28(fp)
 1826958:	10800017 	ldw	r2,0(r2)
 182695c:	10000226 	beq	r2,zero,1826968 <altera_avalon_uart_init+0x88>
 1826960:	0005883a 	mov	r2,zero
 1826964:	00000106 	br	182696c <altera_avalon_uart_init+0x8c>
 1826968:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 182696c:	1000181e 	bne	r2,zero,18269d0 <altera_avalon_uart_init+0xf0>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
 1826970:	e0bffd17 	ldw	r2,-12(fp)
 1826974:	10800804 	addi	r2,r2,32
 1826978:	e0bffa15 	stw	r2,-24(fp)
 182697c:	00800044 	movi	r2,1
 1826980:	e0bffc8d 	sth	r2,-14(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 1826984:	e0bffc8b 	ldhu	r2,-14(fp)
 1826988:	10000226 	beq	r2,zero,1826994 <altera_avalon_uart_init+0xb4>
 182698c:	e0bffc8b 	ldhu	r2,-14(fp)
 1826990:	00000106 	br	1826998 <altera_avalon_uart_init+0xb8>
 1826994:	00800044 	movi	r2,1
 1826998:	e0fffc8b 	ldhu	r3,-14(fp)
 182699c:	180b883a 	mov	r5,r3
 18269a0:	1009883a 	mov	r4,r2
 18269a4:	180da240 	call	180da24 <xQueueCreateCountingSemaphore>
 18269a8:	1007883a 	mov	r3,r2
 18269ac:	e0bffa17 	ldw	r2,-24(fp)
 18269b0:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 18269b4:	e0bffa17 	ldw	r2,-24(fp)
 18269b8:	10800017 	ldw	r2,0(r2)
 18269bc:	10000226 	beq	r2,zero,18269c8 <altera_avalon_uart_init+0xe8>
 18269c0:	0005883a 	mov	r2,zero
 18269c4:	00000106 	br	18269cc <altera_avalon_uart_init+0xec>
 18269c8:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 18269cc:	10000226 	beq	r2,zero,18269d8 <altera_avalon_uart_init+0xf8>
 18269d0:	00800044 	movi	r2,1
 18269d4:	00000106 	br	18269dc <altera_avalon_uart_init+0xfc>
 18269d8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 18269dc:	e0bffb15 	stw	r2,-20(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 18269e0:	e0bffb17 	ldw	r2,-20(fp)
 18269e4:	10000f1e 	bne	r2,zero,1826a24 <altera_avalon_uart_init+0x144>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 18269e8:	e0bffd17 	ldw	r2,-12(fp)
 18269ec:	00c32004 	movi	r3,3200
 18269f0:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 18269f4:	e0bff817 	ldw	r2,-32(fp)
 18269f8:	10800304 	addi	r2,r2,12
 18269fc:	e0fffd17 	ldw	r3,-12(fp)
 1826a00:	18c00117 	ldw	r3,4(r3)
 1826a04:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 1826a08:	d8000015 	stw	zero,0(sp)
 1826a0c:	e1fffd17 	ldw	r7,-12(fp)
 1826a10:	018060b4 	movhi	r6,386
 1826a14:	319a8f04 	addi	r6,r6,27196
 1826a18:	e17fff17 	ldw	r5,-4(fp)
 1826a1c:	e13ffe17 	ldw	r4,-8(fp)
 1826a20:	182811c0 	call	182811c <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 1826a24:	0001883a 	nop
 1826a28:	e037883a 	mov	sp,fp
 1826a2c:	dfc00117 	ldw	ra,4(sp)
 1826a30:	df000017 	ldw	fp,0(sp)
 1826a34:	dec00204 	addi	sp,sp,8
 1826a38:	f800283a 	ret

01826a3c <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 1826a3c:	defffa04 	addi	sp,sp,-24
 1826a40:	dfc00515 	stw	ra,20(sp)
 1826a44:	df000415 	stw	fp,16(sp)
 1826a48:	df000404 	addi	fp,sp,16
 1826a4c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 1826a50:	e0bfff17 	ldw	r2,-4(fp)
 1826a54:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 1826a58:	e0bffc17 	ldw	r2,-16(fp)
 1826a5c:	10800017 	ldw	r2,0(r2)
 1826a60:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 1826a64:	e0bffd17 	ldw	r2,-12(fp)
 1826a68:	10800204 	addi	r2,r2,8
 1826a6c:	10800037 	ldwio	r2,0(r2)
 1826a70:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 1826a74:	e0bffd17 	ldw	r2,-12(fp)
 1826a78:	10800204 	addi	r2,r2,8
 1826a7c:	0007883a 	mov	r3,zero
 1826a80:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 1826a84:	e0bffd17 	ldw	r2,-12(fp)
 1826a88:	10800204 	addi	r2,r2,8
 1826a8c:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 1826a90:	e0bffe17 	ldw	r2,-8(fp)
 1826a94:	1080200c 	andi	r2,r2,128
 1826a98:	10000326 	beq	r2,zero,1826aa8 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 1826a9c:	e17ffe17 	ldw	r5,-8(fp)
 1826aa0:	e13ffc17 	ldw	r4,-16(fp)
 1826aa4:	1826ad80 	call	1826ad8 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 1826aa8:	e0bffe17 	ldw	r2,-8(fp)
 1826aac:	1081100c 	andi	r2,r2,1088
 1826ab0:	10000326 	beq	r2,zero,1826ac0 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 1826ab4:	e17ffe17 	ldw	r5,-8(fp)
 1826ab8:	e13ffc17 	ldw	r4,-16(fp)
 1826abc:	1826bbc0 	call	1826bbc <altera_avalon_uart_txirq>
  }
  

}
 1826ac0:	0001883a 	nop
 1826ac4:	e037883a 	mov	sp,fp
 1826ac8:	dfc00117 	ldw	ra,4(sp)
 1826acc:	df000017 	ldw	fp,0(sp)
 1826ad0:	dec00204 	addi	sp,sp,8
 1826ad4:	f800283a 	ret

01826ad8 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 1826ad8:	defffc04 	addi	sp,sp,-16
 1826adc:	df000315 	stw	fp,12(sp)
 1826ae0:	df000304 	addi	fp,sp,12
 1826ae4:	e13ffe15 	stw	r4,-8(fp)
 1826ae8:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 1826aec:	e0bfff17 	ldw	r2,-4(fp)
 1826af0:	108000cc 	andi	r2,r2,3
 1826af4:	10002c1e 	bne	r2,zero,1826ba8 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 1826af8:	e0bffe17 	ldw	r2,-8(fp)
 1826afc:	10800317 	ldw	r2,12(r2)
 1826b00:	e0bffe17 	ldw	r2,-8(fp)
 1826b04:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1826b08:	e0bffe17 	ldw	r2,-8(fp)
 1826b0c:	10800317 	ldw	r2,12(r2)
 1826b10:	10800044 	addi	r2,r2,1
 1826b14:	10800fcc 	andi	r2,r2,63
 1826b18:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 1826b1c:	e0bffe17 	ldw	r2,-8(fp)
 1826b20:	10800317 	ldw	r2,12(r2)
 1826b24:	e0fffe17 	ldw	r3,-8(fp)
 1826b28:	18c00017 	ldw	r3,0(r3)
 1826b2c:	18c00037 	ldwio	r3,0(r3)
 1826b30:	1809883a 	mov	r4,r3
 1826b34:	e0fffe17 	ldw	r3,-8(fp)
 1826b38:	1885883a 	add	r2,r3,r2
 1826b3c:	10800904 	addi	r2,r2,36
 1826b40:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 1826b44:	e0bffe17 	ldw	r2,-8(fp)
 1826b48:	e0fffd17 	ldw	r3,-12(fp)
 1826b4c:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1826b50:	e0bffe17 	ldw	r2,-8(fp)
 1826b54:	10800317 	ldw	r2,12(r2)
 1826b58:	10800044 	addi	r2,r2,1
 1826b5c:	10800fcc 	andi	r2,r2,63
 1826b60:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 1826b64:	e0bffe17 	ldw	r2,-8(fp)
 1826b68:	10c00217 	ldw	r3,8(r2)
 1826b6c:	e0bffd17 	ldw	r2,-12(fp)
 1826b70:	18800e1e 	bne	r3,r2,1826bac <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1826b74:	e0bffe17 	ldw	r2,-8(fp)
 1826b78:	10c00117 	ldw	r3,4(r2)
 1826b7c:	00bfdfc4 	movi	r2,-129
 1826b80:	1886703a 	and	r3,r3,r2
 1826b84:	e0bffe17 	ldw	r2,-8(fp)
 1826b88:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 1826b8c:	e0bffe17 	ldw	r2,-8(fp)
 1826b90:	10800017 	ldw	r2,0(r2)
 1826b94:	10800304 	addi	r2,r2,12
 1826b98:	e0fffe17 	ldw	r3,-8(fp)
 1826b9c:	18c00117 	ldw	r3,4(r3)
 1826ba0:	10c00035 	stwio	r3,0(r2)
 1826ba4:	00000106 	br	1826bac <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 1826ba8:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 1826bac:	e037883a 	mov	sp,fp
 1826bb0:	df000017 	ldw	fp,0(sp)
 1826bb4:	dec00104 	addi	sp,sp,4
 1826bb8:	f800283a 	ret

01826bbc <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 1826bbc:	defffb04 	addi	sp,sp,-20
 1826bc0:	df000415 	stw	fp,16(sp)
 1826bc4:	df000404 	addi	fp,sp,16
 1826bc8:	e13ffc15 	stw	r4,-16(fp)
 1826bcc:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 1826bd0:	e0bffc17 	ldw	r2,-16(fp)
 1826bd4:	10c00417 	ldw	r3,16(r2)
 1826bd8:	e0bffc17 	ldw	r2,-16(fp)
 1826bdc:	10800517 	ldw	r2,20(r2)
 1826be0:	18803226 	beq	r3,r2,1826cac <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 1826be4:	e0bffc17 	ldw	r2,-16(fp)
 1826be8:	10800617 	ldw	r2,24(r2)
 1826bec:	1080008c 	andi	r2,r2,2
 1826bf0:	10000326 	beq	r2,zero,1826c00 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 1826bf4:	e0bffd17 	ldw	r2,-12(fp)
 1826bf8:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 1826bfc:	10001d26 	beq	r2,zero,1826c74 <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 1826c00:	e0bffc17 	ldw	r2,-16(fp)
 1826c04:	10800417 	ldw	r2,16(r2)
 1826c08:	e0bffc17 	ldw	r2,-16(fp)
 1826c0c:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 1826c10:	e0bffc17 	ldw	r2,-16(fp)
 1826c14:	10800017 	ldw	r2,0(r2)
 1826c18:	10800104 	addi	r2,r2,4
 1826c1c:	e0fffc17 	ldw	r3,-16(fp)
 1826c20:	18c00417 	ldw	r3,16(r3)
 1826c24:	e13ffc17 	ldw	r4,-16(fp)
 1826c28:	20c7883a 	add	r3,r4,r3
 1826c2c:	18c01904 	addi	r3,r3,100
 1826c30:	18c00003 	ldbu	r3,0(r3)
 1826c34:	18c03fcc 	andi	r3,r3,255
 1826c38:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 1826c3c:	e0bffc17 	ldw	r2,-16(fp)
 1826c40:	10800417 	ldw	r2,16(r2)
 1826c44:	10800044 	addi	r2,r2,1
 1826c48:	e0fffc17 	ldw	r3,-16(fp)
 1826c4c:	18800415 	stw	r2,16(r3)
 1826c50:	10c00fcc 	andi	r3,r2,63
 1826c54:	e0bffc17 	ldw	r2,-16(fp)
 1826c58:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1826c5c:	e0bffc17 	ldw	r2,-16(fp)
 1826c60:	10800117 	ldw	r2,4(r2)
 1826c64:	10c01014 	ori	r3,r2,64
 1826c68:	e0bffc17 	ldw	r2,-16(fp)
 1826c6c:	10c00115 	stw	r3,4(r2)
 1826c70:	00000e06 	br	1826cac <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 1826c74:	e0bffc17 	ldw	r2,-16(fp)
 1826c78:	10800017 	ldw	r2,0(r2)
 1826c7c:	10800204 	addi	r2,r2,8
 1826c80:	10800037 	ldwio	r2,0(r2)
 1826c84:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 1826c88:	e0bffd17 	ldw	r2,-12(fp)
 1826c8c:	1082000c 	andi	r2,r2,2048
 1826c90:	1000061e 	bne	r2,zero,1826cac <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1826c94:	e0bffc17 	ldw	r2,-16(fp)
 1826c98:	10c00117 	ldw	r3,4(r2)
 1826c9c:	00bfefc4 	movi	r2,-65
 1826ca0:	1886703a 	and	r3,r3,r2
 1826ca4:	e0bffc17 	ldw	r2,-16(fp)
 1826ca8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 1826cac:	e0bffc17 	ldw	r2,-16(fp)
 1826cb0:	10c00417 	ldw	r3,16(r2)
 1826cb4:	e0bffc17 	ldw	r2,-16(fp)
 1826cb8:	10800517 	ldw	r2,20(r2)
 1826cbc:	1880061e 	bne	r3,r2,1826cd8 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1826cc0:	e0bffc17 	ldw	r2,-16(fp)
 1826cc4:	10c00117 	ldw	r3,4(r2)
 1826cc8:	00beefc4 	movi	r2,-1089
 1826ccc:	1886703a 	and	r3,r3,r2
 1826cd0:	e0bffc17 	ldw	r2,-16(fp)
 1826cd4:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1826cd8:	e0bffc17 	ldw	r2,-16(fp)
 1826cdc:	10800017 	ldw	r2,0(r2)
 1826ce0:	10800304 	addi	r2,r2,12
 1826ce4:	e0fffc17 	ldw	r3,-16(fp)
 1826ce8:	18c00117 	ldw	r3,4(r3)
 1826cec:	10c00035 	stwio	r3,0(r2)
}
 1826cf0:	0001883a 	nop
 1826cf4:	e037883a 	mov	sp,fp
 1826cf8:	df000017 	ldw	fp,0(sp)
 1826cfc:	dec00104 	addi	sp,sp,4
 1826d00:	f800283a 	ret

01826d04 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 1826d04:	defffd04 	addi	sp,sp,-12
 1826d08:	df000215 	stw	fp,8(sp)
 1826d0c:	df000204 	addi	fp,sp,8
 1826d10:	e13ffe15 	stw	r4,-8(fp)
 1826d14:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1826d18:	00000506 	br	1826d30 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 1826d1c:	e0bfff17 	ldw	r2,-4(fp)
 1826d20:	1090000c 	andi	r2,r2,16384
 1826d24:	10000226 	beq	r2,zero,1826d30 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 1826d28:	00bffd44 	movi	r2,-11
 1826d2c:	00000606 	br	1826d48 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1826d30:	e0bffe17 	ldw	r2,-8(fp)
 1826d34:	10c00417 	ldw	r3,16(r2)
 1826d38:	e0bffe17 	ldw	r2,-8(fp)
 1826d3c:	10800517 	ldw	r2,20(r2)
 1826d40:	18bff61e 	bne	r3,r2,1826d1c <__ram_exceptions_end+0xff8168d8>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1826d44:	0005883a 	mov	r2,zero
}
 1826d48:	e037883a 	mov	sp,fp
 1826d4c:	df000017 	ldw	fp,0(sp)
 1826d50:	dec00104 	addi	sp,sp,4
 1826d54:	f800283a 	ret

01826d58 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1826d58:	defffe04 	addi	sp,sp,-8
 1826d5c:	dfc00115 	stw	ra,4(sp)
 1826d60:	df000015 	stw	fp,0(sp)
 1826d64:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1826d68:	d0a01917 	ldw	r2,-32668(gp)
 1826d6c:	10000326 	beq	r2,zero,1826d7c <alt_get_errno+0x24>
 1826d70:	d0a01917 	ldw	r2,-32668(gp)
 1826d74:	103ee83a 	callr	r2
 1826d78:	00000106 	br	1826d80 <alt_get_errno+0x28>
 1826d7c:	d0a7ce04 	addi	r2,gp,-24776
}
 1826d80:	e037883a 	mov	sp,fp
 1826d84:	dfc00117 	ldw	ra,4(sp)
 1826d88:	df000017 	ldw	fp,0(sp)
 1826d8c:	dec00204 	addi	sp,sp,8
 1826d90:	f800283a 	ret

01826d94 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 1826d94:	deffef04 	addi	sp,sp,-68
 1826d98:	dfc01015 	stw	ra,64(sp)
 1826d9c:	df000f15 	stw	fp,60(sp)
 1826da0:	df000f04 	addi	fp,sp,60
 1826da4:	e13ffb15 	stw	r4,-20(fp)
 1826da8:	e17ffc15 	stw	r5,-16(fp)
 1826dac:	e1bffd15 	stw	r6,-12(fp)
 1826db0:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 1826db4:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
 1826db8:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 1826dbc:	e0bffe17 	ldw	r2,-8(fp)
 1826dc0:	1090000c 	andi	r2,r2,16384
 1826dc4:	1005003a 	cmpeq	r2,r2,zero
 1826dc8:	10803fcc 	andi	r2,r2,255
 1826dcc:	e0bff315 	stw	r2,-52(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
 1826dd0:	e0bffb17 	ldw	r2,-20(fp)
 1826dd4:	10800717 	ldw	r2,28(r2)
 1826dd8:	e0bff915 	stw	r2,-28(fp)
 1826ddc:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 1826de0:	e0bffa0b 	ldhu	r2,-24(fp)
 1826de4:	100b883a 	mov	r5,r2
 1826de8:	e13ff917 	ldw	r4,-28(fp)
 1826dec:	180e0080 	call	180e008 <xQueueSemaphoreTake>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1826df0:	00001306 	br	1826e40 <altera_avalon_uart_read+0xac>
    {
      count++;
 1826df4:	e0bff217 	ldw	r2,-56(fp)
 1826df8:	10800044 	addi	r2,r2,1
 1826dfc:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 1826e00:	e0bffc17 	ldw	r2,-16(fp)
 1826e04:	10c00044 	addi	r3,r2,1
 1826e08:	e0fffc15 	stw	r3,-16(fp)
 1826e0c:	e0fffb17 	ldw	r3,-20(fp)
 1826e10:	18c00217 	ldw	r3,8(r3)
 1826e14:	e13ffb17 	ldw	r4,-20(fp)
 1826e18:	20c7883a 	add	r3,r4,r3
 1826e1c:	18c00904 	addi	r3,r3,36
 1826e20:	18c00003 	ldbu	r3,0(r3)
 1826e24:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 1826e28:	e0bffb17 	ldw	r2,-20(fp)
 1826e2c:	10800217 	ldw	r2,8(r2)
 1826e30:	10800044 	addi	r2,r2,1
 1826e34:	10c00fcc 	andi	r3,r2,63
 1826e38:	e0bffb17 	ldw	r2,-20(fp)
 1826e3c:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1826e40:	e0fff217 	ldw	r3,-56(fp)
 1826e44:	e0bffd17 	ldw	r2,-12(fp)
 1826e48:	1880050e 	bge	r3,r2,1826e60 <altera_avalon_uart_read+0xcc>
 1826e4c:	e0bffb17 	ldw	r2,-20(fp)
 1826e50:	10c00217 	ldw	r3,8(r2)
 1826e54:	e0bffb17 	ldw	r2,-20(fp)
 1826e58:	10800317 	ldw	r2,12(r2)
 1826e5c:	18bfe51e 	bne	r3,r2,1826df4 <__ram_exceptions_end+0xff8169b0>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 1826e60:	e0bff217 	ldw	r2,-56(fp)
 1826e64:	1000251e 	bne	r2,zero,1826efc <altera_avalon_uart_read+0x168>
 1826e68:	e0bffb17 	ldw	r2,-20(fp)
 1826e6c:	10c00217 	ldw	r3,8(r2)
 1826e70:	e0bffb17 	ldw	r2,-20(fp)
 1826e74:	10800317 	ldw	r2,12(r2)
 1826e78:	1880201e 	bne	r3,r2,1826efc <altera_avalon_uart_read+0x168>
    {
      if (!block)
 1826e7c:	e0bff317 	ldw	r2,-52(fp)
 1826e80:	1000071e 	bne	r2,zero,1826ea0 <altera_avalon_uart_read+0x10c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 1826e84:	1826d580 	call	1826d58 <alt_get_errno>
 1826e88:	1007883a 	mov	r3,r2
 1826e8c:	008002c4 	movi	r2,11
 1826e90:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 1826e94:	00800044 	movi	r2,1
 1826e98:	e0bff105 	stb	r2,-60(fp)
        break;
 1826e9c:	00001b06 	br	1826f0c <altera_avalon_uart_read+0x178>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1826ea0:	0005303a 	rdctl	r2,status
 1826ea4:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1826ea8:	e0fff617 	ldw	r3,-40(fp)
 1826eac:	00bfff84 	movi	r2,-2
 1826eb0:	1884703a 	and	r2,r3,r2
 1826eb4:	1001703a 	wrctl	status,r2
  
  return context;
 1826eb8:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 1826ebc:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1826ec0:	e0bffb17 	ldw	r2,-20(fp)
 1826ec4:	10800117 	ldw	r2,4(r2)
 1826ec8:	10c02014 	ori	r3,r2,128
 1826ecc:	e0bffb17 	ldw	r2,-20(fp)
 1826ed0:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1826ed4:	e0bffb17 	ldw	r2,-20(fp)
 1826ed8:	10800017 	ldw	r2,0(r2)
 1826edc:	10800304 	addi	r2,r2,12
 1826ee0:	e0fffb17 	ldw	r3,-20(fp)
 1826ee4:	18c00117 	ldw	r3,4(r3)
 1826ee8:	10c00035 	stwio	r3,0(r2)
 1826eec:	e0bff517 	ldw	r2,-44(fp)
 1826ef0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1826ef4:	e0bff717 	ldw	r2,-36(fp)
 1826ef8:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 1826efc:	e0bff217 	ldw	r2,-56(fp)
 1826f00:	1000021e 	bne	r2,zero,1826f0c <altera_avalon_uart_read+0x178>
 1826f04:	e0bffd17 	ldw	r2,-12(fp)
 1826f08:	103fcd1e 	bne	r2,zero,1826e40 <__ram_exceptions_end+0xff8169fc>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 1826f0c:	e0bffb17 	ldw	r2,-20(fp)
 1826f10:	10800717 	ldw	r2,28(r2)
 1826f14:	000f883a 	mov	r7,zero
 1826f18:	000d883a 	mov	r6,zero
 1826f1c:	000b883a 	mov	r5,zero
 1826f20:	1009883a 	mov	r4,r2
 1826f24:	180da7c0 	call	180da7c <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1826f28:	0005303a 	rdctl	r2,status
 1826f2c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1826f30:	e0fff817 	ldw	r3,-32(fp)
 1826f34:	00bfff84 	movi	r2,-2
 1826f38:	1884703a 	and	r2,r3,r2
 1826f3c:	1001703a 	wrctl	status,r2
  
  return context;
 1826f40:	e0bff817 	ldw	r2,-32(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 1826f44:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1826f48:	e0bffb17 	ldw	r2,-20(fp)
 1826f4c:	10800117 	ldw	r2,4(r2)
 1826f50:	10c02014 	ori	r3,r2,128
 1826f54:	e0bffb17 	ldw	r2,-20(fp)
 1826f58:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1826f5c:	e0bffb17 	ldw	r2,-20(fp)
 1826f60:	10800017 	ldw	r2,0(r2)
 1826f64:	10800304 	addi	r2,r2,12
 1826f68:	e0fffb17 	ldw	r3,-20(fp)
 1826f6c:	18c00117 	ldw	r3,4(r3)
 1826f70:	10c00035 	stwio	r3,0(r2)
 1826f74:	e0bff517 	ldw	r2,-44(fp)
 1826f78:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1826f7c:	e0bff417 	ldw	r2,-48(fp)
 1826f80:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 1826f84:	e0bff103 	ldbu	r2,-60(fp)
 1826f88:	10000226 	beq	r2,zero,1826f94 <altera_avalon_uart_read+0x200>
    return -EWOULDBLOCK;
 1826f8c:	00bffd44 	movi	r2,-11
 1826f90:	00000106 	br	1826f98 <altera_avalon_uart_read+0x204>
  }
  else {
    return count;
 1826f94:	e0bff217 	ldw	r2,-56(fp)
  }
}
 1826f98:	e037883a 	mov	sp,fp
 1826f9c:	dfc00117 	ldw	ra,4(sp)
 1826fa0:	df000017 	ldw	fp,0(sp)
 1826fa4:	dec00204 	addi	sp,sp,8
 1826fa8:	f800283a 	ret

01826fac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1826fac:	defffe04 	addi	sp,sp,-8
 1826fb0:	dfc00115 	stw	ra,4(sp)
 1826fb4:	df000015 	stw	fp,0(sp)
 1826fb8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1826fbc:	d0a01917 	ldw	r2,-32668(gp)
 1826fc0:	10000326 	beq	r2,zero,1826fd0 <alt_get_errno+0x24>
 1826fc4:	d0a01917 	ldw	r2,-32668(gp)
 1826fc8:	103ee83a 	callr	r2
 1826fcc:	00000106 	br	1826fd4 <alt_get_errno+0x28>
 1826fd0:	d0a7ce04 	addi	r2,gp,-24776
}
 1826fd4:	e037883a 	mov	sp,fp
 1826fd8:	dfc00117 	ldw	ra,4(sp)
 1826fdc:	df000017 	ldw	fp,0(sp)
 1826fe0:	dec00204 	addi	sp,sp,8
 1826fe4:	f800283a 	ret

01826fe8 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 1826fe8:	deffef04 	addi	sp,sp,-68
 1826fec:	dfc01015 	stw	ra,64(sp)
 1826ff0:	df000f15 	stw	fp,60(sp)
 1826ff4:	df000f04 	addi	fp,sp,60
 1826ff8:	e13ffb15 	stw	r4,-20(fp)
 1826ffc:	e17ffc15 	stw	r5,-16(fp)
 1827000:	e1bffd15 	stw	r6,-12(fp)
 1827004:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 1827008:	e0bffd17 	ldw	r2,-12(fp)
 182700c:	e0bff115 	stw	r2,-60(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 1827010:	e0bffe17 	ldw	r2,-8(fp)
 1827014:	1090000c 	andi	r2,r2,16384
 1827018:	e0bff215 	stw	r2,-56(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 182701c:	e0bffb17 	ldw	r2,-20(fp)
 1827020:	10800817 	ldw	r2,32(r2)
 1827024:	e0bff915 	stw	r2,-28(fp)
 1827028:	e03ffa0d 	sth	zero,-24(fp)
 182702c:	e0bffa0b 	ldhu	r2,-24(fp)
 1827030:	100b883a 	mov	r5,r2
 1827034:	e13ff917 	ldw	r4,-28(fp)
 1827038:	180e0080 	call	180e008 <xQueueSemaphoreTake>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 182703c:	00003c06 	br	1827130 <altera_avalon_uart_write+0x148>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1827040:	e0bffb17 	ldw	r2,-20(fp)
 1827044:	10800517 	ldw	r2,20(r2)
 1827048:	10800044 	addi	r2,r2,1
 182704c:	10800fcc 	andi	r2,r2,63
 1827050:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 1827054:	e0bffb17 	ldw	r2,-20(fp)
 1827058:	10c00417 	ldw	r3,16(r2)
 182705c:	e0bff417 	ldw	r2,-48(fp)
 1827060:	1880221e 	bne	r3,r2,18270ec <altera_avalon_uart_write+0x104>
    {
      if (no_block)
 1827064:	e0bff217 	ldw	r2,-56(fp)
 1827068:	10000526 	beq	r2,zero,1827080 <altera_avalon_uart_write+0x98>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 182706c:	1826fac0 	call	1826fac <alt_get_errno>
 1827070:	1007883a 	mov	r3,r2
 1827074:	008002c4 	movi	r2,11
 1827078:	18800015 	stw	r2,0(r3)
        break;
 182707c:	00002e06 	br	1827138 <altera_avalon_uart_write+0x150>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1827080:	0005303a 	rdctl	r2,status
 1827084:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1827088:	e0fff617 	ldw	r3,-40(fp)
 182708c:	00bfff84 	movi	r2,-2
 1827090:	1884703a 	and	r2,r3,r2
 1827094:	1001703a 	wrctl	status,r2
  
  return context;
 1827098:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 182709c:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 18270a0:	e0bffb17 	ldw	r2,-20(fp)
 18270a4:	10800117 	ldw	r2,4(r2)
 18270a8:	10c11014 	ori	r3,r2,1088
 18270ac:	e0bffb17 	ldw	r2,-20(fp)
 18270b0:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 18270b4:	e0bffb17 	ldw	r2,-20(fp)
 18270b8:	10800017 	ldw	r2,0(r2)
 18270bc:	10800304 	addi	r2,r2,12
 18270c0:	e0fffb17 	ldw	r3,-20(fp)
 18270c4:	18c00117 	ldw	r3,4(r3)
 18270c8:	10c00035 	stwio	r3,0(r2)
 18270cc:	e0bff517 	ldw	r2,-44(fp)
 18270d0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18270d4:	e0bff317 	ldw	r2,-52(fp)
 18270d8:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 18270dc:	e0bffb17 	ldw	r2,-20(fp)
 18270e0:	10c00417 	ldw	r3,16(r2)
 18270e4:	e0bff417 	ldw	r2,-48(fp)
 18270e8:	18bffc26 	beq	r3,r2,18270dc <__ram_exceptions_end+0xff816c98>
      }
    }

    count--;
 18270ec:	e0bff117 	ldw	r2,-60(fp)
 18270f0:	10bfffc4 	addi	r2,r2,-1
 18270f4:	e0bff115 	stw	r2,-60(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 18270f8:	e0bffb17 	ldw	r2,-20(fp)
 18270fc:	10c00517 	ldw	r3,20(r2)
 1827100:	e0bffc17 	ldw	r2,-16(fp)
 1827104:	11000044 	addi	r4,r2,1
 1827108:	e13ffc15 	stw	r4,-16(fp)
 182710c:	10800003 	ldbu	r2,0(r2)
 1827110:	1009883a 	mov	r4,r2
 1827114:	e0bffb17 	ldw	r2,-20(fp)
 1827118:	10c5883a 	add	r2,r2,r3
 182711c:	10801904 	addi	r2,r2,100
 1827120:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 1827124:	e0bffb17 	ldw	r2,-20(fp)
 1827128:	e0fff417 	ldw	r3,-48(fp)
 182712c:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 1827130:	e0bff117 	ldw	r2,-60(fp)
 1827134:	103fc21e 	bne	r2,zero,1827040 <__ram_exceptions_end+0xff816bfc>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 1827138:	e0bffb17 	ldw	r2,-20(fp)
 182713c:	10800817 	ldw	r2,32(r2)
 1827140:	000f883a 	mov	r7,zero
 1827144:	000d883a 	mov	r6,zero
 1827148:	000b883a 	mov	r5,zero
 182714c:	1009883a 	mov	r4,r2
 1827150:	180da7c0 	call	180da7c <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1827154:	0005303a 	rdctl	r2,status
 1827158:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 182715c:	e0fff817 	ldw	r3,-32(fp)
 1827160:	00bfff84 	movi	r2,-2
 1827164:	1884703a 	and	r2,r3,r2
 1827168:	1001703a 	wrctl	status,r2
  
  return context;
 182716c:	e0bff817 	ldw	r2,-32(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 1827170:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1827174:	e0bffb17 	ldw	r2,-20(fp)
 1827178:	10800117 	ldw	r2,4(r2)
 182717c:	10c11014 	ori	r3,r2,1088
 1827180:	e0bffb17 	ldw	r2,-20(fp)
 1827184:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1827188:	e0bffb17 	ldw	r2,-20(fp)
 182718c:	10800017 	ldw	r2,0(r2)
 1827190:	10800304 	addi	r2,r2,12
 1827194:	e0fffb17 	ldw	r3,-20(fp)
 1827198:	18c00117 	ldw	r3,4(r3)
 182719c:	10c00035 	stwio	r3,0(r2)
 18271a0:	e0bff517 	ldw	r2,-44(fp)
 18271a4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18271a8:	e0bff717 	ldw	r2,-36(fp)
 18271ac:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 18271b0:	e0fffd17 	ldw	r3,-12(fp)
 18271b4:	e0bff117 	ldw	r2,-60(fp)
 18271b8:	1885c83a 	sub	r2,r3,r2
}
 18271bc:	e037883a 	mov	sp,fp
 18271c0:	dfc00117 	ldw	ra,4(sp)
 18271c4:	df000017 	ldw	fp,0(sp)
 18271c8:	dec00204 	addi	sp,sp,8
 18271cc:	f800283a 	ret

018271d0 <__env_lock>:
xSemaphoreHandle alt_envsem;

/* __env_lock needs to provide recursive mutex locking */

void __env_lock ( struct _reent *_r )
{
 18271d0:	defffd04 	addi	sp,sp,-12
 18271d4:	dfc00215 	stw	ra,8(sp)
 18271d8:	df000115 	stw	fp,4(sp)
 18271dc:	df000104 	addi	fp,sp,4
 18271e0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 18271e4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18271e8:	10000b26 	beq	r2,zero,1827218 <__env_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 18271ec:	00000206 	br	18271f8 <__env_lock+0x28>
		vTaskDelay(1);
 18271f0:	01000044 	movi	r4,1
 18271f4:	180f2cc0 	call	180f2cc <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 18271f8:	d0a80217 	ldw	r2,-24568(gp)
 18271fc:	01400284 	movi	r5,10
 1827200:	1009883a 	mov	r4,r2
 1827204:	180d9880 	call	180d988 <xQueueTakeMutexRecursive>
 1827208:	10800058 	cmpnei	r2,r2,1
 182720c:	103ff81e 	bne	r2,zero,18271f0 <__ram_exceptions_end+0xff816dac>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 1827210:	0001883a 	nop
 1827214:	00000106 	br	182721c <__env_lock+0x4c>

void __env_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 1827218:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 182721c:	e037883a 	mov	sp,fp
 1827220:	dfc00117 	ldw	ra,4(sp)
 1827224:	df000017 	ldw	fp,0(sp)
 1827228:	dec00204 	addi	sp,sp,8
 182722c:	f800283a 	ret

01827230 <__env_unlock>:

/* __env_unlock needs to provide recursive mutex unlocking */

void __env_unlock ( struct _reent *_r )
{
 1827230:	defffd04 	addi	sp,sp,-12
 1827234:	dfc00215 	stw	ra,8(sp)
 1827238:	df000115 	stw	fp,4(sp)
 182723c:	df000104 	addi	fp,sp,4
 1827240:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 1827244:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1827248:	10000426 	beq	r2,zero,182725c <__env_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_envsem);
 182724c:	d0a80217 	ldw	r2,-24568(gp)
 1827250:	1009883a 	mov	r4,r2
 1827254:	180d8f80 	call	180d8f8 <xQueueGiveMutexRecursive>
 1827258:	00000106 	br	1827260 <__env_unlock+0x30>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 182725c:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_envsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 1827260:	e037883a 	mov	sp,fp
 1827264:	dfc00117 	ldw	ra,4(sp)
 1827268:	df000017 	ldw	fp,0(sp)
 182726c:	dec00204 	addi	sp,sp,8
 1827270:	f800283a 	ret

01827274 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1827274:	defffc04 	addi	sp,sp,-16
 1827278:	dfc00315 	stw	ra,12(sp)
 182727c:	df000215 	stw	fp,8(sp)
 1827280:	df000204 	addi	fp,sp,8
 1827284:	e13fff15 	stw	r4,-4(fp)
void *pvReturn;

	vTaskSuspendAll();
 1827288:	180fab80 	call	180fab8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
 182728c:	e13fff17 	ldw	r4,-4(fp)
 1827290:	183d0300 	call	183d030 <malloc>
 1827294:	e0bffe15 	stw	r2,-8(fp)
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 1827298:	180fae40 	call	180fae4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 182729c:	e0bffe17 	ldw	r2,-8(fp)
 18272a0:	1000011e 	bne	r2,zero,18272a8 <pvPortMalloc+0x34>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 18272a4:	18004600 	call	1800460 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
 18272a8:	e0bffe17 	ldw	r2,-8(fp)
}
 18272ac:	e037883a 	mov	sp,fp
 18272b0:	dfc00117 	ldw	ra,4(sp)
 18272b4:	df000017 	ldw	fp,0(sp)
 18272b8:	dec00204 	addi	sp,sp,8
 18272bc:	f800283a 	ret

018272c0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 18272c0:	defffd04 	addi	sp,sp,-12
 18272c4:	dfc00215 	stw	ra,8(sp)
 18272c8:	df000115 	stw	fp,4(sp)
 18272cc:	df000104 	addi	fp,sp,4
 18272d0:	e13fff15 	stw	r4,-4(fp)
	if( pv )
 18272d4:	e0bfff17 	ldw	r2,-4(fp)
 18272d8:	10000426 	beq	r2,zero,18272ec <vPortFree+0x2c>
	{
		vTaskSuspendAll();
 18272dc:	180fab80 	call	180fab8 <vTaskSuspendAll>
		{
			free( pv );
 18272e0:	e13fff17 	ldw	r4,-4(fp)
 18272e4:	183d0440 	call	183d044 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
 18272e8:	180fae40 	call	180fae4 <xTaskResumeAll>
	}
}
 18272ec:	0001883a 	nop
 18272f0:	e037883a 	mov	sp,fp
 18272f4:	dfc00117 	ldw	ra,4(sp)
 18272f8:	df000017 	ldw	fp,0(sp)
 18272fc:	dec00204 	addi	sp,sp,8
 1827300:	f800283a 	ret

01827304 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 1827304:	defffe04 	addi	sp,sp,-8
 1827308:	df000115 	stw	fp,4(sp)
 182730c:	df000104 	addi	fp,sp,4
 1827310:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1827314:	e0bfff17 	ldw	r2,-4(fp)
 1827318:	10c00204 	addi	r3,r2,8
 182731c:	e0bfff17 	ldw	r2,-4(fp)
 1827320:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 1827324:	e0bfff17 	ldw	r2,-4(fp)
 1827328:	00ffffc4 	movi	r3,-1
 182732c:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1827330:	e0bfff17 	ldw	r2,-4(fp)
 1827334:	10c00204 	addi	r3,r2,8
 1827338:	e0bfff17 	ldw	r2,-4(fp)
 182733c:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1827340:	e0bfff17 	ldw	r2,-4(fp)
 1827344:	10c00204 	addi	r3,r2,8
 1827348:	e0bfff17 	ldw	r2,-4(fp)
 182734c:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 1827350:	e0bfff17 	ldw	r2,-4(fp)
 1827354:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 1827358:	0001883a 	nop
 182735c:	e037883a 	mov	sp,fp
 1827360:	df000017 	ldw	fp,0(sp)
 1827364:	dec00104 	addi	sp,sp,4
 1827368:	f800283a 	ret

0182736c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 182736c:	defffe04 	addi	sp,sp,-8
 1827370:	df000115 	stw	fp,4(sp)
 1827374:	df000104 	addi	fp,sp,4
 1827378:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 182737c:	e0bfff17 	ldw	r2,-4(fp)
 1827380:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 1827384:	0001883a 	nop
 1827388:	e037883a 	mov	sp,fp
 182738c:	df000017 	ldw	fp,0(sp)
 1827390:	dec00104 	addi	sp,sp,4
 1827394:	f800283a 	ret

01827398 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1827398:	defffc04 	addi	sp,sp,-16
 182739c:	df000315 	stw	fp,12(sp)
 18273a0:	df000304 	addi	fp,sp,12
 18273a4:	e13ffe15 	stw	r4,-8(fp)
 18273a8:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 18273ac:	e0bffe17 	ldw	r2,-8(fp)
 18273b0:	10800117 	ldw	r2,4(r2)
 18273b4:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 18273b8:	e0bfff17 	ldw	r2,-4(fp)
 18273bc:	e0fffd17 	ldw	r3,-12(fp)
 18273c0:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 18273c4:	e0bffd17 	ldw	r2,-12(fp)
 18273c8:	10c00217 	ldw	r3,8(r2)
 18273cc:	e0bfff17 	ldw	r2,-4(fp)
 18273d0:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 18273d4:	e0bffd17 	ldw	r2,-12(fp)
 18273d8:	10800217 	ldw	r2,8(r2)
 18273dc:	e0ffff17 	ldw	r3,-4(fp)
 18273e0:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 18273e4:	e0bffd17 	ldw	r2,-12(fp)
 18273e8:	e0ffff17 	ldw	r3,-4(fp)
 18273ec:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 18273f0:	e0bfff17 	ldw	r2,-4(fp)
 18273f4:	e0fffe17 	ldw	r3,-8(fp)
 18273f8:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 18273fc:	e0bffe17 	ldw	r2,-8(fp)
 1827400:	10800017 	ldw	r2,0(r2)
 1827404:	10c00044 	addi	r3,r2,1
 1827408:	e0bffe17 	ldw	r2,-8(fp)
 182740c:	10c00015 	stw	r3,0(r2)
}
 1827410:	0001883a 	nop
 1827414:	e037883a 	mov	sp,fp
 1827418:	df000017 	ldw	fp,0(sp)
 182741c:	dec00104 	addi	sp,sp,4
 1827420:	f800283a 	ret

01827424 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1827424:	defffb04 	addi	sp,sp,-20
 1827428:	df000415 	stw	fp,16(sp)
 182742c:	df000404 	addi	fp,sp,16
 1827430:	e13ffe15 	stw	r4,-8(fp)
 1827434:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1827438:	e0bfff17 	ldw	r2,-4(fp)
 182743c:	10800017 	ldw	r2,0(r2)
 1827440:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1827444:	e0bffd17 	ldw	r2,-12(fp)
 1827448:	10bfffd8 	cmpnei	r2,r2,-1
 182744c:	1000041e 	bne	r2,zero,1827460 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1827450:	e0bffe17 	ldw	r2,-8(fp)
 1827454:	10800417 	ldw	r2,16(r2)
 1827458:	e0bffc15 	stw	r2,-16(fp)
 182745c:	00000c06 	br	1827490 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 1827460:	e0bffe17 	ldw	r2,-8(fp)
 1827464:	10800204 	addi	r2,r2,8
 1827468:	e0bffc15 	stw	r2,-16(fp)
 182746c:	00000306 	br	182747c <vListInsert+0x58>
 1827470:	e0bffc17 	ldw	r2,-16(fp)
 1827474:	10800117 	ldw	r2,4(r2)
 1827478:	e0bffc15 	stw	r2,-16(fp)
 182747c:	e0bffc17 	ldw	r2,-16(fp)
 1827480:	10800117 	ldw	r2,4(r2)
 1827484:	10800017 	ldw	r2,0(r2)
 1827488:	e0fffd17 	ldw	r3,-12(fp)
 182748c:	18bff82e 	bgeu	r3,r2,1827470 <__ram_exceptions_end+0xff81702c>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1827490:	e0bffc17 	ldw	r2,-16(fp)
 1827494:	10c00117 	ldw	r3,4(r2)
 1827498:	e0bfff17 	ldw	r2,-4(fp)
 182749c:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 18274a0:	e0bfff17 	ldw	r2,-4(fp)
 18274a4:	10800117 	ldw	r2,4(r2)
 18274a8:	e0ffff17 	ldw	r3,-4(fp)
 18274ac:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 18274b0:	e0bfff17 	ldw	r2,-4(fp)
 18274b4:	e0fffc17 	ldw	r3,-16(fp)
 18274b8:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 18274bc:	e0bffc17 	ldw	r2,-16(fp)
 18274c0:	e0ffff17 	ldw	r3,-4(fp)
 18274c4:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 18274c8:	e0bfff17 	ldw	r2,-4(fp)
 18274cc:	e0fffe17 	ldw	r3,-8(fp)
 18274d0:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 18274d4:	e0bffe17 	ldw	r2,-8(fp)
 18274d8:	10800017 	ldw	r2,0(r2)
 18274dc:	10c00044 	addi	r3,r2,1
 18274e0:	e0bffe17 	ldw	r2,-8(fp)
 18274e4:	10c00015 	stw	r3,0(r2)
}
 18274e8:	0001883a 	nop
 18274ec:	e037883a 	mov	sp,fp
 18274f0:	df000017 	ldw	fp,0(sp)
 18274f4:	dec00104 	addi	sp,sp,4
 18274f8:	f800283a 	ret

018274fc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 18274fc:	defffd04 	addi	sp,sp,-12
 1827500:	df000215 	stw	fp,8(sp)
 1827504:	df000204 	addi	fp,sp,8
 1827508:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 182750c:	e0bfff17 	ldw	r2,-4(fp)
 1827510:	10800417 	ldw	r2,16(r2)
 1827514:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1827518:	e0bfff17 	ldw	r2,-4(fp)
 182751c:	10800117 	ldw	r2,4(r2)
 1827520:	e0ffff17 	ldw	r3,-4(fp)
 1827524:	18c00217 	ldw	r3,8(r3)
 1827528:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 182752c:	e0bfff17 	ldw	r2,-4(fp)
 1827530:	10800217 	ldw	r2,8(r2)
 1827534:	e0ffff17 	ldw	r3,-4(fp)
 1827538:	18c00117 	ldw	r3,4(r3)
 182753c:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1827540:	e0bffe17 	ldw	r2,-8(fp)
 1827544:	10c00117 	ldw	r3,4(r2)
 1827548:	e0bfff17 	ldw	r2,-4(fp)
 182754c:	1880041e 	bne	r3,r2,1827560 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1827550:	e0bfff17 	ldw	r2,-4(fp)
 1827554:	10c00217 	ldw	r3,8(r2)
 1827558:	e0bffe17 	ldw	r2,-8(fp)
 182755c:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 1827560:	e0bfff17 	ldw	r2,-4(fp)
 1827564:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 1827568:	e0bffe17 	ldw	r2,-8(fp)
 182756c:	10800017 	ldw	r2,0(r2)
 1827570:	10ffffc4 	addi	r3,r2,-1
 1827574:	e0bffe17 	ldw	r2,-8(fp)
 1827578:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 182757c:	e0bffe17 	ldw	r2,-8(fp)
 1827580:	10800017 	ldw	r2,0(r2)
}
 1827584:	e037883a 	mov	sp,fp
 1827588:	df000017 	ldw	fp,0(sp)
 182758c:	dec00104 	addi	sp,sp,4
 1827590:	f800283a 	ret

01827594 <prvReadGp>:
#define portINITIAL_ESTATUS     ( portSTACK_TYPE ) 0x01 

/*-----------------------------------------------------------*/

static inline void prvReadGp( unsigned long *ulValue )
{
 1827594:	defffe04 	addi	sp,sp,-8
 1827598:	df000115 	stw	fp,4(sp)
 182759c:	df000104 	addi	fp,sp,4
 18275a0:	e13fff15 	stw	r4,-4(fp)
	asm volatile ( "stw gp, (%0)" : : "r"(ulValue) );
 18275a4:	e0bfff17 	ldw	r2,-4(fp)
 18275a8:	16800015 	stw	gp,0(r2)
}
 18275ac:	0001883a 	nop
 18275b0:	e037883a 	mov	sp,fp
 18275b4:	df000017 	ldw	fp,0(sp)
 18275b8:	dec00104 	addi	sp,sp,4
 18275bc:	f800283a 	ret

018275c0 <enh_alt_irq_disable_all>:
/*-----------------------------------------------------------*/

static volatile alt_irq_context lastContext;

void enh_alt_irq_disable_all()
{
 18275c0:	defffd04 	addi	sp,sp,-12
 18275c4:	df000215 	stw	fp,8(sp)
 18275c8:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 18275cc:	0005303a 	rdctl	r2,status
 18275d0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 18275d4:	e0ffff17 	ldw	r3,-4(fp)
 18275d8:	00bfff84 	movi	r2,-2
 18275dc:	1884703a 	and	r2,r3,r2
 18275e0:	1001703a 	wrctl	status,r2
  
  return context;
 18275e4:	e0bfff17 	ldw	r2,-4(fp)
	alt_irq_context ctxt = alt_irq_disable_all();
 18275e8:	e0bffe15 	stw	r2,-8(fp)
	lastContext |= ctxt;
 18275ec:	d0e80317 	ldw	r3,-24564(gp)
 18275f0:	e0bffe17 	ldw	r2,-8(fp)
 18275f4:	1884b03a 	or	r2,r3,r2
 18275f8:	d0a80315 	stw	r2,-24564(gp)
}
 18275fc:	0001883a 	nop
 1827600:	e037883a 	mov	sp,fp
 1827604:	df000017 	ldw	fp,0(sp)
 1827608:	dec00104 	addi	sp,sp,4
 182760c:	f800283a 	ret

01827610 <enh_alt_irq_enable_all>:

void enh_alt_irq_enable_all()
{
 1827610:	defffd04 	addi	sp,sp,-12
 1827614:	df000215 	stw	fp,8(sp)
 1827618:	df000204 	addi	fp,sp,8
	alt_irq_context restore = lastContext;
 182761c:	d0a80317 	ldw	r2,-24564(gp)
 1827620:	e0bffe15 	stw	r2,-8(fp)
	lastContext = 0;
 1827624:	d0280315 	stw	zero,-24564(gp)
 1827628:	e0bffe17 	ldw	r2,-8(fp)
 182762c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1827630:	e0bfff17 	ldw	r2,-4(fp)
 1827634:	1001703a 	wrctl	status,r2
	alt_irq_enable_all(restore);
}
 1827638:	0001883a 	nop
 182763c:	e037883a 	mov	sp,fp
 1827640:	df000017 	ldw	fp,0(sp)
 1827644:	dec00104 	addi	sp,sp,4
 1827648:	f800283a 	ret

0182764c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{    
 182764c:	defff904 	addi	sp,sp,-28
 1827650:	dfc00615 	stw	ra,24(sp)
 1827654:	df000515 	stw	fp,20(sp)
 1827658:	df000504 	addi	fp,sp,20
 182765c:	e13ffd15 	stw	r4,-12(fp)
 1827660:	e17ffe15 	stw	r5,-8(fp)
 1827664:	e1bfff15 	stw	r6,-4(fp)
portSTACK_TYPE *pxFramePointer = pxTopOfStack - 1;
 1827668:	e0bffd17 	ldw	r2,-12(fp)
 182766c:	10bfff04 	addi	r2,r2,-4
 1827670:	e0bffb15 	stw	r2,-20(fp)
portSTACK_TYPE xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 1827674:	e0bffc04 	addi	r2,fp,-16
 1827678:	1009883a 	mov	r4,r2
 182767c:	18275940 	call	1827594 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 1827680:	e0fffd17 	ldw	r3,-12(fp)
 1827684:	00b7abb4 	movhi	r2,57006
 1827688:	10afbbc4 	addi	r2,r2,-16657
 182768c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 1827690:	e0bffd17 	ldw	r2,-12(fp)
 1827694:	10bfff04 	addi	r2,r2,-4
 1827698:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxFramePointer;
 182769c:	e0fffb17 	ldw	r3,-20(fp)
 18276a0:	e0bffd17 	ldw	r2,-12(fp)
 18276a4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 18276a8:	e0bffd17 	ldw	r2,-12(fp)
 18276ac:	10bfff04 	addi	r2,r2,-4
 18276b0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 18276b4:	e0fffc17 	ldw	r3,-16(fp)
 18276b8:	e0bffd17 	ldw	r2,-12(fp)
 18276bc:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 18276c0:	e0bffd17 	ldw	r2,-12(fp)
 18276c4:	10bff704 	addi	r2,r2,-36
 18276c8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxCode;
 18276cc:	e0fffe17 	ldw	r3,-8(fp)
 18276d0:	e0bffd17 	ldw	r2,-12(fp)
 18276d4:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 18276d8:	e0bffd17 	ldw	r2,-12(fp)
 18276dc:	10bfff04 	addi	r2,r2,-4
 18276e0:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS;
 18276e4:	e0bffd17 	ldw	r2,-12(fp)
 18276e8:	00c00044 	movi	r3,1
 18276ec:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */
    pxTopOfStack -= 12;
 18276f0:	e0bffd17 	ldw	r2,-12(fp)
 18276f4:	10bff404 	addi	r2,r2,-48
 18276f8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
 18276fc:	e0ffff17 	ldw	r3,-4(fp)
 1827700:	e0bffd17 	ldw	r2,-12(fp)
 1827704:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 1827708:	e0bffd17 	ldw	r2,-12(fp)
 182770c:	10bffb04 	addi	r2,r2,-20
 1827710:	e0bffd15 	stw	r2,-12(fp)

    /* Initialize stack pointer to prevent debugger crash. */
    *pxTopOfStack = ( portSTACK_TYPE ) xPortStartScheduler;
 1827714:	008060b4 	movhi	r2,386
 1827718:	109dcf04 	addi	r2,r2,30524
 182771c:	e0fffd17 	ldw	r3,-12(fp)
 1827720:	18800015 	stw	r2,0(r3)

    return pxTopOfStack;
 1827724:	e0bffd17 	ldw	r2,-12(fp)
}
 1827728:	e037883a 	mov	sp,fp
 182772c:	dfc00117 	ldw	ra,4(sp)
 1827730:	df000017 	ldw	fp,0(sp)
 1827734:	dec00204 	addi	sp,sp,8
 1827738:	f800283a 	ret

0182773c <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
portBASE_TYPE xPortStartScheduler( void )
{
 182773c:	deffff04 	addi	sp,sp,-4
 1827740:	df000015 	stw	fp,0(sp)
 1827744:	d839883a 	mov	fp,sp
 1827748:	00808074 	movhi	r2,513
	// Just load the task which is currently revered to by TCB
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 182774c:	10803604 	addi	r2,r2,216
 1827750:	1000683a 	jmp	r2
                    " jmp r2                                          " );

    // This should never be reached
    return 0;
 1827754:	0005883a 	mov	r2,zero
}
 1827758:	e037883a 	mov	sp,fp
 182775c:	df000017 	ldw	fp,0(sp)
 1827760:	dec00104 	addi	sp,sp,4
 1827764:	f800283a 	ret

01827768 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1827768:	deffff04 	addi	sp,sp,-4
 182776c:	df000015 	stw	fp,0(sp)
 1827770:	d839883a 	mov	fp,sp
	// It is unlikely that the NIOS2 port will require this function as there is nothing to return to.
}
 1827774:	0001883a 	nop
 1827778:	e037883a 	mov	sp,fp
 182777c:	df000017 	ldw	fp,0(sp)
 1827780:	dec00104 	addi	sp,sp,4
 1827784:	f800283a 	ret

01827788 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void )
{
 1827788:	defffe04 	addi	sp,sp,-8
 182778c:	dfc00115 	stw	ra,4(sp)
 1827790:	df000015 	stw	fp,0(sp)
 1827794:	d839883a 	mov	fp,sp
	// only make ticks if the scheduler has been started.
	if ( xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED )
 1827798:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182779c:	10800060 	cmpeqi	r2,r2,1
 18277a0:	1000021e 	bne	r2,zero,18277ac <vPortSysTickHandler+0x24>
	{
		// Increment the Kernel Tick.
		xTaskIncrementTick();
 18277a4:	180fef40 	call	180fef4 <xTaskIncrementTick>

		// If using preemption, also force a context switch.
#if configUSE_PREEMPTION == 1
		vTaskSwitchContext();
 18277a8:	18100a40 	call	18100a4 <vTaskSwitchContext>
#endif
	}
}
 18277ac:	0001883a 	nop
 18277b0:	e037883a 	mov	sp,fp
 18277b4:	dfc00117 	ldw	ra,4(sp)
 18277b8:	df000017 	ldw	fp,0(sp)
 18277bc:	dec00204 	addi	sp,sp,8
 18277c0:	f800283a 	ret

018277c4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 18277c4:	defff504 	addi	sp,sp,-44
 18277c8:	df000a15 	stw	fp,40(sp)
 18277cc:	df000a04 	addi	fp,sp,40
 18277d0:	e13ffc15 	stw	r4,-16(fp)
 18277d4:	e17ffd15 	stw	r5,-12(fp)
 18277d8:	e1bffe15 	stw	r6,-8(fp)
 18277dc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 18277e0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 18277e4:	d0a80917 	ldw	r2,-24540(gp)
  
  if (alt_ticks_per_second ())
 18277e8:	10003c26 	beq	r2,zero,18278dc <alt_alarm_start+0x118>
  {
    if (alarm)
 18277ec:	e0bffc17 	ldw	r2,-16(fp)
 18277f0:	10003826 	beq	r2,zero,18278d4 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 18277f4:	e0bffc17 	ldw	r2,-16(fp)
 18277f8:	e0fffe17 	ldw	r3,-8(fp)
 18277fc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 1827800:	e0bffc17 	ldw	r2,-16(fp)
 1827804:	e0ffff17 	ldw	r3,-4(fp)
 1827808:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 182780c:	0005303a 	rdctl	r2,status
 1827810:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1827814:	e0fff917 	ldw	r3,-28(fp)
 1827818:	00bfff84 	movi	r2,-2
 182781c:	1884703a 	and	r2,r3,r2
 1827820:	1001703a 	wrctl	status,r2
  
  return context;
 1827824:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 1827828:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 182782c:	d0a80a17 	ldw	r2,-24536(gp)
      
      current_nticks = alt_nticks();
 1827830:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 1827834:	e0fffd17 	ldw	r3,-12(fp)
 1827838:	e0bff617 	ldw	r2,-40(fp)
 182783c:	1885883a 	add	r2,r3,r2
 1827840:	10c00044 	addi	r3,r2,1
 1827844:	e0bffc17 	ldw	r2,-16(fp)
 1827848:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 182784c:	e0bffc17 	ldw	r2,-16(fp)
 1827850:	10c00217 	ldw	r3,8(r2)
 1827854:	e0bff617 	ldw	r2,-40(fp)
 1827858:	1880042e 	bgeu	r3,r2,182786c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 182785c:	e0bffc17 	ldw	r2,-16(fp)
 1827860:	00c00044 	movi	r3,1
 1827864:	10c00405 	stb	r3,16(r2)
 1827868:	00000206 	br	1827874 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 182786c:	e0bffc17 	ldw	r2,-16(fp)
 1827870:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 1827874:	e0bffc17 	ldw	r2,-16(fp)
 1827878:	d0e01b04 	addi	r3,gp,-32660
 182787c:	e0fffa15 	stw	r3,-24(fp)
 1827880:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1827884:	e0bffb17 	ldw	r2,-20(fp)
 1827888:	e0fffa17 	ldw	r3,-24(fp)
 182788c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1827890:	e0bffa17 	ldw	r2,-24(fp)
 1827894:	10c00017 	ldw	r3,0(r2)
 1827898:	e0bffb17 	ldw	r2,-20(fp)
 182789c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 18278a0:	e0bffa17 	ldw	r2,-24(fp)
 18278a4:	10800017 	ldw	r2,0(r2)
 18278a8:	e0fffb17 	ldw	r3,-20(fp)
 18278ac:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 18278b0:	e0bffa17 	ldw	r2,-24(fp)
 18278b4:	e0fffb17 	ldw	r3,-20(fp)
 18278b8:	10c00015 	stw	r3,0(r2)
 18278bc:	e0bff817 	ldw	r2,-32(fp)
 18278c0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18278c4:	e0bff717 	ldw	r2,-36(fp)
 18278c8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 18278cc:	0005883a 	mov	r2,zero
 18278d0:	00000306 	br	18278e0 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 18278d4:	00bffa84 	movi	r2,-22
 18278d8:	00000106 	br	18278e0 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 18278dc:	00bfde84 	movi	r2,-134
  }
}
 18278e0:	e037883a 	mov	sp,fp
 18278e4:	df000017 	ldw	fp,0(sp)
 18278e8:	dec00104 	addi	sp,sp,4
 18278ec:	f800283a 	ret

018278f0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 18278f0:	defffa04 	addi	sp,sp,-24
 18278f4:	dfc00515 	stw	ra,20(sp)
 18278f8:	df000415 	stw	fp,16(sp)
 18278fc:	df000404 	addi	fp,sp,16
 1827900:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 1827904:	008000c4 	movi	r2,3
 1827908:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 182790c:	e0fffd17 	ldw	r3,-12(fp)
 1827910:	008003f4 	movhi	r2,15
 1827914:	10909004 	addi	r2,r2,16960
 1827918:	1885383a 	mul	r2,r3,r2
 182791c:	100b883a 	mov	r5,r2
 1827920:	0100bef4 	movhi	r4,763
 1827924:	213c2004 	addi	r4,r4,-3968
 1827928:	180ad100 	call	180ad10 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 182792c:	100b883a 	mov	r5,r2
 1827930:	01200034 	movhi	r4,32768
 1827934:	213fffc4 	addi	r4,r4,-1
 1827938:	180ad100 	call	180ad10 <__udivsi3>
 182793c:	100b883a 	mov	r5,r2
 1827940:	e13fff17 	ldw	r4,-4(fp)
 1827944:	180ad100 	call	180ad10 <__udivsi3>
 1827948:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 182794c:	e0bffe17 	ldw	r2,-8(fp)
 1827950:	10002a26 	beq	r2,zero,18279fc <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 1827954:	e03ffc15 	stw	zero,-16(fp)
 1827958:	00001706 	br	18279b8 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 182795c:	00a00034 	movhi	r2,32768
 1827960:	10bfffc4 	addi	r2,r2,-1
 1827964:	10bfffc4 	addi	r2,r2,-1
 1827968:	103ffe1e 	bne	r2,zero,1827964 <__ram_exceptions_end+0xff817520>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 182796c:	e0fffd17 	ldw	r3,-12(fp)
 1827970:	008003f4 	movhi	r2,15
 1827974:	10909004 	addi	r2,r2,16960
 1827978:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 182797c:	100b883a 	mov	r5,r2
 1827980:	0100bef4 	movhi	r4,763
 1827984:	213c2004 	addi	r4,r4,-3968
 1827988:	180ad100 	call	180ad10 <__udivsi3>
 182798c:	100b883a 	mov	r5,r2
 1827990:	01200034 	movhi	r4,32768
 1827994:	213fffc4 	addi	r4,r4,-1
 1827998:	180ad100 	call	180ad10 <__udivsi3>
 182799c:	1007883a 	mov	r3,r2
 18279a0:	e0bfff17 	ldw	r2,-4(fp)
 18279a4:	10c5c83a 	sub	r2,r2,r3
 18279a8:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 18279ac:	e0bffc17 	ldw	r2,-16(fp)
 18279b0:	10800044 	addi	r2,r2,1
 18279b4:	e0bffc15 	stw	r2,-16(fp)
 18279b8:	e0fffc17 	ldw	r3,-16(fp)
 18279bc:	e0bffe17 	ldw	r2,-8(fp)
 18279c0:	18bfe616 	blt	r3,r2,182795c <__ram_exceptions_end+0xff817518>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 18279c4:	e0fffd17 	ldw	r3,-12(fp)
 18279c8:	008003f4 	movhi	r2,15
 18279cc:	10909004 	addi	r2,r2,16960
 18279d0:	1885383a 	mul	r2,r3,r2
 18279d4:	100b883a 	mov	r5,r2
 18279d8:	0100bef4 	movhi	r4,763
 18279dc:	213c2004 	addi	r4,r4,-3968
 18279e0:	180ad100 	call	180ad10 <__udivsi3>
 18279e4:	1007883a 	mov	r3,r2
 18279e8:	e0bfff17 	ldw	r2,-4(fp)
 18279ec:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 18279f0:	10bfffc4 	addi	r2,r2,-1
 18279f4:	103ffe1e 	bne	r2,zero,18279f0 <__ram_exceptions_end+0xff8175ac>
 18279f8:	00000d06 	br	1827a30 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 18279fc:	e0fffd17 	ldw	r3,-12(fp)
 1827a00:	008003f4 	movhi	r2,15
 1827a04:	10909004 	addi	r2,r2,16960
 1827a08:	1885383a 	mul	r2,r3,r2
 1827a0c:	100b883a 	mov	r5,r2
 1827a10:	0100bef4 	movhi	r4,763
 1827a14:	213c2004 	addi	r4,r4,-3968
 1827a18:	180ad100 	call	180ad10 <__udivsi3>
 1827a1c:	1007883a 	mov	r3,r2
 1827a20:	e0bfff17 	ldw	r2,-4(fp)
 1827a24:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 1827a28:	10bfffc4 	addi	r2,r2,-1
 1827a2c:	00bffe16 	blt	zero,r2,1827a28 <__ram_exceptions_end+0xff8175e4>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 1827a30:	0005883a 	mov	r2,zero
}
 1827a34:	e037883a 	mov	sp,fp
 1827a38:	dfc00117 	ldw	ra,4(sp)
 1827a3c:	df000017 	ldw	fp,0(sp)
 1827a40:	dec00204 	addi	sp,sp,8
 1827a44:	f800283a 	ret

01827a48 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1827a48:	defffe04 	addi	sp,sp,-8
 1827a4c:	dfc00115 	stw	ra,4(sp)
 1827a50:	df000015 	stw	fp,0(sp)
 1827a54:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1827a58:	d0a01917 	ldw	r2,-32668(gp)
 1827a5c:	10000326 	beq	r2,zero,1827a6c <alt_get_errno+0x24>
 1827a60:	d0a01917 	ldw	r2,-32668(gp)
 1827a64:	103ee83a 	callr	r2
 1827a68:	00000106 	br	1827a70 <alt_get_errno+0x28>
 1827a6c:	d0a7ce04 	addi	r2,gp,-24776
}
 1827a70:	e037883a 	mov	sp,fp
 1827a74:	dfc00117 	ldw	ra,4(sp)
 1827a78:	df000017 	ldw	fp,0(sp)
 1827a7c:	dec00204 	addi	sp,sp,8
 1827a80:	f800283a 	ret

01827a84 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 1827a84:	defffb04 	addi	sp,sp,-20
 1827a88:	dfc00415 	stw	ra,16(sp)
 1827a8c:	df000315 	stw	fp,12(sp)
 1827a90:	df000304 	addi	fp,sp,12
 1827a94:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 1827a98:	e0bfff17 	ldw	r2,-4(fp)
 1827a9c:	10000616 	blt	r2,zero,1827ab8 <alt_close+0x34>
 1827aa0:	e0bfff17 	ldw	r2,-4(fp)
 1827aa4:	10c00324 	muli	r3,r2,12
 1827aa8:	00806134 	movhi	r2,388
 1827aac:	1091ff04 	addi	r2,r2,18428
 1827ab0:	1885883a 	add	r2,r3,r2
 1827ab4:	00000106 	br	1827abc <alt_close+0x38>
 1827ab8:	0005883a 	mov	r2,zero
 1827abc:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 1827ac0:	e0bffd17 	ldw	r2,-12(fp)
 1827ac4:	10001926 	beq	r2,zero,1827b2c <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 1827ac8:	e0bffd17 	ldw	r2,-12(fp)
 1827acc:	10800017 	ldw	r2,0(r2)
 1827ad0:	10800417 	ldw	r2,16(r2)
 1827ad4:	10000626 	beq	r2,zero,1827af0 <alt_close+0x6c>
 1827ad8:	e0bffd17 	ldw	r2,-12(fp)
 1827adc:	10800017 	ldw	r2,0(r2)
 1827ae0:	10800417 	ldw	r2,16(r2)
 1827ae4:	e13ffd17 	ldw	r4,-12(fp)
 1827ae8:	103ee83a 	callr	r2
 1827aec:	00000106 	br	1827af4 <alt_close+0x70>
 1827af0:	0005883a 	mov	r2,zero
 1827af4:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 1827af8:	e13fff17 	ldw	r4,-4(fp)
 1827afc:	181317c0 	call	181317c <alt_release_fd>
    if (rval < 0)
 1827b00:	e0bffe17 	ldw	r2,-8(fp)
 1827b04:	1000070e 	bge	r2,zero,1827b24 <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 1827b08:	1827a480 	call	1827a48 <alt_get_errno>
 1827b0c:	1007883a 	mov	r3,r2
 1827b10:	e0bffe17 	ldw	r2,-8(fp)
 1827b14:	0085c83a 	sub	r2,zero,r2
 1827b18:	18800015 	stw	r2,0(r3)
      return -1;
 1827b1c:	00bfffc4 	movi	r2,-1
 1827b20:	00000706 	br	1827b40 <alt_close+0xbc>
    }
    return 0;
 1827b24:	0005883a 	mov	r2,zero
 1827b28:	00000506 	br	1827b40 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1827b2c:	1827a480 	call	1827a48 <alt_get_errno>
 1827b30:	1007883a 	mov	r3,r2
 1827b34:	00801444 	movi	r2,81
 1827b38:	18800015 	stw	r2,0(r3)
    return -1;
 1827b3c:	00bfffc4 	movi	r2,-1
  }
}
 1827b40:	e037883a 	mov	sp,fp
 1827b44:	dfc00117 	ldw	ra,4(sp)
 1827b48:	df000017 	ldw	fp,0(sp)
 1827b4c:	dec00204 	addi	sp,sp,8
 1827b50:	f800283a 	ret

01827b54 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 1827b54:	defffd04 	addi	sp,sp,-12
 1827b58:	df000215 	stw	fp,8(sp)
 1827b5c:	df000204 	addi	fp,sp,8
 1827b60:	e13ffe15 	stw	r4,-8(fp)
 1827b64:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1827b68:	0001883a 	nop
 1827b6c:	e037883a 	mov	sp,fp
 1827b70:	df000017 	ldw	fp,0(sp)
 1827b74:	dec00104 	addi	sp,sp,4
 1827b78:	f800283a 	ret

01827b7c <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 1827b7c:	deffff04 	addi	sp,sp,-4
 1827b80:	df000015 	stw	fp,0(sp)
 1827b84:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 1827b88:	0001883a 	nop
 1827b8c:	e037883a 	mov	sp,fp
 1827b90:	df000017 	ldw	fp,0(sp)
 1827b94:	dec00104 	addi	sp,sp,4
 1827b98:	f800283a 	ret

01827b9c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1827b9c:	defffe04 	addi	sp,sp,-8
 1827ba0:	dfc00115 	stw	ra,4(sp)
 1827ba4:	df000015 	stw	fp,0(sp)
 1827ba8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1827bac:	d0a01917 	ldw	r2,-32668(gp)
 1827bb0:	10000326 	beq	r2,zero,1827bc0 <alt_get_errno+0x24>
 1827bb4:	d0a01917 	ldw	r2,-32668(gp)
 1827bb8:	103ee83a 	callr	r2
 1827bbc:	00000106 	br	1827bc4 <alt_get_errno+0x28>
 1827bc0:	d0a7ce04 	addi	r2,gp,-24776
}
 1827bc4:	e037883a 	mov	sp,fp
 1827bc8:	dfc00117 	ldw	ra,4(sp)
 1827bcc:	df000017 	ldw	fp,0(sp)
 1827bd0:	dec00204 	addi	sp,sp,8
 1827bd4:	f800283a 	ret

01827bd8 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 1827bd8:	defffa04 	addi	sp,sp,-24
 1827bdc:	dfc00515 	stw	ra,20(sp)
 1827be0:	df000415 	stw	fp,16(sp)
 1827be4:	df000404 	addi	fp,sp,16
 1827be8:	e13ffe15 	stw	r4,-8(fp)
 1827bec:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 1827bf0:	e0bffe17 	ldw	r2,-8(fp)
 1827bf4:	10000326 	beq	r2,zero,1827c04 <alt_dev_llist_insert+0x2c>
 1827bf8:	e0bffe17 	ldw	r2,-8(fp)
 1827bfc:	10800217 	ldw	r2,8(r2)
 1827c00:	1000061e 	bne	r2,zero,1827c1c <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 1827c04:	1827b9c0 	call	1827b9c <alt_get_errno>
 1827c08:	1007883a 	mov	r3,r2
 1827c0c:	00800584 	movi	r2,22
 1827c10:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1827c14:	00bffa84 	movi	r2,-22
 1827c18:	00001306 	br	1827c68 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 1827c1c:	e0bffe17 	ldw	r2,-8(fp)
 1827c20:	e0ffff17 	ldw	r3,-4(fp)
 1827c24:	e0fffc15 	stw	r3,-16(fp)
 1827c28:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1827c2c:	e0bffd17 	ldw	r2,-12(fp)
 1827c30:	e0fffc17 	ldw	r3,-16(fp)
 1827c34:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1827c38:	e0bffc17 	ldw	r2,-16(fp)
 1827c3c:	10c00017 	ldw	r3,0(r2)
 1827c40:	e0bffd17 	ldw	r2,-12(fp)
 1827c44:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1827c48:	e0bffc17 	ldw	r2,-16(fp)
 1827c4c:	10800017 	ldw	r2,0(r2)
 1827c50:	e0fffd17 	ldw	r3,-12(fp)
 1827c54:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1827c58:	e0bffc17 	ldw	r2,-16(fp)
 1827c5c:	e0fffd17 	ldw	r3,-12(fp)
 1827c60:	10c00015 	stw	r3,0(r2)

  return 0;  
 1827c64:	0005883a 	mov	r2,zero
}
 1827c68:	e037883a 	mov	sp,fp
 1827c6c:	dfc00117 	ldw	ra,4(sp)
 1827c70:	df000017 	ldw	fp,0(sp)
 1827c74:	dec00204 	addi	sp,sp,8
 1827c78:	f800283a 	ret

01827c7c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 1827c7c:	defffa04 	addi	sp,sp,-24
 1827c80:	dfc00515 	stw	ra,20(sp)
 1827c84:	df000415 	stw	fp,16(sp)
 1827c88:	df000404 	addi	fp,sp,16
 1827c8c:	e13ffe15 	stw	r4,-8(fp)
 1827c90:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 1827c94:	e0bfff17 	ldw	r2,-4(fp)
 1827c98:	10800017 	ldw	r2,0(r2)
 1827c9c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 1827ca0:	e13ffe17 	ldw	r4,-8(fp)
 1827ca4:	18075d80 	call	18075d8 <strlen>
 1827ca8:	10800044 	addi	r2,r2,1
 1827cac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1827cb0:	00000d06 	br	1827ce8 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 1827cb4:	e0bffc17 	ldw	r2,-16(fp)
 1827cb8:	10800217 	ldw	r2,8(r2)
 1827cbc:	e0fffd17 	ldw	r3,-12(fp)
 1827cc0:	180d883a 	mov	r6,r3
 1827cc4:	e17ffe17 	ldw	r5,-8(fp)
 1827cc8:	1009883a 	mov	r4,r2
 1827ccc:	183d0580 	call	183d058 <memcmp>
 1827cd0:	1000021e 	bne	r2,zero,1827cdc <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 1827cd4:	e0bffc17 	ldw	r2,-16(fp)
 1827cd8:	00000706 	br	1827cf8 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 1827cdc:	e0bffc17 	ldw	r2,-16(fp)
 1827ce0:	10800017 	ldw	r2,0(r2)
 1827ce4:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1827ce8:	e0fffc17 	ldw	r3,-16(fp)
 1827cec:	e0bfff17 	ldw	r2,-4(fp)
 1827cf0:	18bff01e 	bne	r3,r2,1827cb4 <__ram_exceptions_end+0xff817870>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 1827cf4:	0005883a 	mov	r2,zero
}
 1827cf8:	e037883a 	mov	sp,fp
 1827cfc:	dfc00117 	ldw	ra,4(sp)
 1827d00:	df000017 	ldw	fp,0(sp)
 1827d04:	dec00204 	addi	sp,sp,8
 1827d08:	f800283a 	ret

01827d0c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 1827d0c:	defffb04 	addi	sp,sp,-20
 1827d10:	dfc00415 	stw	ra,16(sp)
 1827d14:	df000315 	stw	fp,12(sp)
 1827d18:	df000304 	addi	fp,sp,12
 1827d1c:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 1827d20:	d0a00617 	ldw	r2,-32744(gp)
 1827d24:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1827d28:	00003106 	br	1827df0 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 1827d2c:	e0bffd17 	ldw	r2,-12(fp)
 1827d30:	10800217 	ldw	r2,8(r2)
 1827d34:	1009883a 	mov	r4,r2
 1827d38:	18075d80 	call	18075d8 <strlen>
 1827d3c:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 1827d40:	e0bffd17 	ldw	r2,-12(fp)
 1827d44:	10c00217 	ldw	r3,8(r2)
 1827d48:	e0bffe17 	ldw	r2,-8(fp)
 1827d4c:	10bfffc4 	addi	r2,r2,-1
 1827d50:	1885883a 	add	r2,r3,r2
 1827d54:	10800003 	ldbu	r2,0(r2)
 1827d58:	10803fcc 	andi	r2,r2,255
 1827d5c:	1080201c 	xori	r2,r2,128
 1827d60:	10bfe004 	addi	r2,r2,-128
 1827d64:	10800bd8 	cmpnei	r2,r2,47
 1827d68:	1000031e 	bne	r2,zero,1827d78 <alt_find_file+0x6c>
    {
      len -= 1;
 1827d6c:	e0bffe17 	ldw	r2,-8(fp)
 1827d70:	10bfffc4 	addi	r2,r2,-1
 1827d74:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1827d78:	e0bffe17 	ldw	r2,-8(fp)
 1827d7c:	e0ffff17 	ldw	r3,-4(fp)
 1827d80:	1885883a 	add	r2,r3,r2
 1827d84:	10800003 	ldbu	r2,0(r2)
 1827d88:	10803fcc 	andi	r2,r2,255
 1827d8c:	1080201c 	xori	r2,r2,128
 1827d90:	10bfe004 	addi	r2,r2,-128
 1827d94:	10800be0 	cmpeqi	r2,r2,47
 1827d98:	1000081e 	bne	r2,zero,1827dbc <alt_find_file+0xb0>
 1827d9c:	e0bffe17 	ldw	r2,-8(fp)
 1827da0:	e0ffff17 	ldw	r3,-4(fp)
 1827da4:	1885883a 	add	r2,r3,r2
 1827da8:	10800003 	ldbu	r2,0(r2)
 1827dac:	10803fcc 	andi	r2,r2,255
 1827db0:	1080201c 	xori	r2,r2,128
 1827db4:	10bfe004 	addi	r2,r2,-128
 1827db8:	10000a1e 	bne	r2,zero,1827de4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 1827dbc:	e0bffd17 	ldw	r2,-12(fp)
 1827dc0:	10800217 	ldw	r2,8(r2)
 1827dc4:	e0fffe17 	ldw	r3,-8(fp)
 1827dc8:	180d883a 	mov	r6,r3
 1827dcc:	e17fff17 	ldw	r5,-4(fp)
 1827dd0:	1009883a 	mov	r4,r2
 1827dd4:	183d0580 	call	183d058 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 1827dd8:	1000021e 	bne	r2,zero,1827de4 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 1827ddc:	e0bffd17 	ldw	r2,-12(fp)
 1827de0:	00000706 	br	1827e00 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 1827de4:	e0bffd17 	ldw	r2,-12(fp)
 1827de8:	10800017 	ldw	r2,0(r2)
 1827dec:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 1827df0:	e0fffd17 	ldw	r3,-12(fp)
 1827df4:	d0a00604 	addi	r2,gp,-32744
 1827df8:	18bfcc1e 	bne	r3,r2,1827d2c <__ram_exceptions_end+0xff8178e8>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 1827dfc:	0005883a 	mov	r2,zero
}
 1827e00:	e037883a 	mov	sp,fp
 1827e04:	dfc00117 	ldw	ra,4(sp)
 1827e08:	df000017 	ldw	fp,0(sp)
 1827e0c:	dec00204 	addi	sp,sp,8
 1827e10:	f800283a 	ret

01827e14 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 1827e14:	defff804 	addi	sp,sp,-32
 1827e18:	dfc00715 	stw	ra,28(sp)
 1827e1c:	df000615 	stw	fp,24(sp)
 1827e20:	df000604 	addi	fp,sp,24
 1827e24:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 1827e28:	00bffa04 	movi	r2,-24
 1827e2c:	e0bffb15 	stw	r2,-20(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 1827e30:	d0a7e717 	ldw	r2,-24676(gp)
 1827e34:	e0bffc15 	stw	r2,-16(fp)
 1827e38:	e03ffd0d 	sth	zero,-12(fp)
 1827e3c:	e0bffd0b 	ldhu	r2,-12(fp)
 1827e40:	100b883a 	mov	r5,r2
 1827e44:	e13ffc17 	ldw	r4,-16(fp)
 1827e48:	180e0080 	call	180e008 <xQueueSemaphoreTake>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1827e4c:	e03ffa15 	stw	zero,-24(fp)
 1827e50:	00001906 	br	1827eb8 <alt_get_fd+0xa4>
  {
    if (!alt_fd_list[i].dev)
 1827e54:	00806134 	movhi	r2,388
 1827e58:	1091ff04 	addi	r2,r2,18428
 1827e5c:	e0fffa17 	ldw	r3,-24(fp)
 1827e60:	18c00324 	muli	r3,r3,12
 1827e64:	10c5883a 	add	r2,r2,r3
 1827e68:	10800017 	ldw	r2,0(r2)
 1827e6c:	10000f1e 	bne	r2,zero,1827eac <alt_get_fd+0x98>
    {
      alt_fd_list[i].dev = dev;
 1827e70:	00806134 	movhi	r2,388
 1827e74:	1091ff04 	addi	r2,r2,18428
 1827e78:	e0fffa17 	ldw	r3,-24(fp)
 1827e7c:	18c00324 	muli	r3,r3,12
 1827e80:	10c5883a 	add	r2,r2,r3
 1827e84:	e0fffe17 	ldw	r3,-8(fp)
 1827e88:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 1827e8c:	d0e00a17 	ldw	r3,-32728(gp)
 1827e90:	e0bffa17 	ldw	r2,-24(fp)
 1827e94:	1880020e 	bge	r3,r2,1827ea0 <alt_get_fd+0x8c>
      {
        alt_max_fd = i;
 1827e98:	e0bffa17 	ldw	r2,-24(fp)
 1827e9c:	d0a00a15 	stw	r2,-32728(gp)
      }
      rc = i;
 1827ea0:	e0bffa17 	ldw	r2,-24(fp)
 1827ea4:	e0bffb15 	stw	r2,-20(fp)
      goto alt_get_fd_exit;
 1827ea8:	00000606 	br	1827ec4 <alt_get_fd+0xb0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 1827eac:	e0bffa17 	ldw	r2,-24(fp)
 1827eb0:	10800044 	addi	r2,r2,1
 1827eb4:	e0bffa15 	stw	r2,-24(fp)
 1827eb8:	e0bffa17 	ldw	r2,-24(fp)
 1827ebc:	10800810 	cmplti	r2,r2,32
 1827ec0:	103fe41e 	bne	r2,zero,1827e54 <__ram_exceptions_end+0xff817a10>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 1827ec4:	d0a7e717 	ldw	r2,-24676(gp)
 1827ec8:	000f883a 	mov	r7,zero
 1827ecc:	000d883a 	mov	r6,zero
 1827ed0:	000b883a 	mov	r5,zero
 1827ed4:	1009883a 	mov	r4,r2
 1827ed8:	180da7c0 	call	180da7c <xQueueGenericSend>

  return rc;
 1827edc:	e0bffb17 	ldw	r2,-20(fp)
}
 1827ee0:	e037883a 	mov	sp,fp
 1827ee4:	dfc00117 	ldw	ra,4(sp)
 1827ee8:	df000017 	ldw	fp,0(sp)
 1827eec:	dec00204 	addi	sp,sp,8
 1827ef0:	f800283a 	ret

01827ef4 <gettimeofday>:
 */
 

#if defined (__GNUC__) && (__GNUC__ >= 4)
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, void *ptimezone_vptr)
{
 1827ef4:	defff404 	addi	sp,sp,-48
 1827ef8:	dfc00b15 	stw	ra,44(sp)
 1827efc:	df000a15 	stw	fp,40(sp)
 1827f00:	dd000915 	stw	r20,36(sp)
 1827f04:	dcc00815 	stw	r19,32(sp)
 1827f08:	dc800715 	stw	r18,28(sp)
 1827f0c:	dc400615 	stw	r17,24(sp)
 1827f10:	dc000515 	stw	r16,20(sp)
 1827f14:	df000a04 	addi	fp,sp,40
 1827f18:	e13ff915 	stw	r4,-28(fp)
 1827f1c:	e17ffa15 	stw	r5,-24(fp)
  struct timezone *ptimezone = (struct timezone*)ptimezone_vptr;
 1827f20:	e0bffa17 	ldw	r2,-24(fp)
 1827f24:	e0bff615 	stw	r2,-40(fp)
 1827f28:	d0a80a17 	ldw	r2,-24536(gp)
#else
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, struct timezone *ptimezone)
{
#endif
  
  alt_u32 nticks = alt_nticks (); 
 1827f2c:	e0bff715 	stw	r2,-36(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1827f30:	d0a80917 	ldw	r2,-24540(gp)
  alt_u32 tick_rate = alt_ticks_per_second ();
 1827f34:	e0bff815 	stw	r2,-32(fp)
   * non-zero system clock rate. If the system clock is not running, an error
   * is generated and the contents of "ptimeval" and "ptimezone" are not
   * updated.
   */

  if (tick_rate)
 1827f38:	e0bff817 	ldw	r2,-32(fp)
 1827f3c:	10005f26 	beq	r2,zero,18280bc <gettimeofday+0x1c8>
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
 1827f40:	d0a80617 	ldw	r2,-24552(gp)
 1827f44:	1029883a 	mov	r20,r2
 1827f48:	e17ff817 	ldw	r5,-32(fp)
 1827f4c:	e13ff717 	ldw	r4,-36(fp)
 1827f50:	180ad100 	call	180ad10 <__udivsi3>
 1827f54:	a085883a 	add	r2,r20,r2
 1827f58:	1007883a 	mov	r3,r2
 1827f5c:	e0bff917 	ldw	r2,-28(fp)
 1827f60:	10c00015 	stw	r3,0(r2)
    ptimeval->tv_usec = alt_resettime.tv_usec +
 1827f64:	d0a80717 	ldw	r2,-24548(gp)
 1827f68:	1029883a 	mov	r20,r2
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
 1827f6c:	e0bff717 	ldw	r2,-36(fp)
 1827f70:	1021883a 	mov	r16,r2
 1827f74:	0023883a 	mov	r17,zero
 1827f78:	e17ff817 	ldw	r5,-32(fp)
 1827f7c:	010003f4 	movhi	r4,15
 1827f80:	21109004 	addi	r4,r4,16960
 1827f84:	180ad100 	call	180ad10 <__udivsi3>
 1827f88:	1025883a 	mov	r18,r2
 1827f8c:	0027883a 	mov	r19,zero
 1827f90:	900d883a 	mov	r6,r18
 1827f94:	980f883a 	mov	r7,r19
 1827f98:	8009883a 	mov	r4,r16
 1827f9c:	880b883a 	mov	r5,r17
 1827fa0:	1840dd80 	call	1840dd8 <__muldi3>
 1827fa4:	1009883a 	mov	r4,r2
 1827fa8:	180b883a 	mov	r5,r3
 1827fac:	2005883a 	mov	r2,r4
 1827fb0:	2807883a 	mov	r3,r5
 1827fb4:	018003f4 	movhi	r6,15
 1827fb8:	31909004 	addi	r6,r6,16960
 1827fbc:	000f883a 	mov	r7,zero
 1827fc0:	1009883a 	mov	r4,r2
 1827fc4:	180b883a 	mov	r5,r3
 1827fc8:	180a6e00 	call	180a6e0 <__umoddi3>
 1827fcc:	1009883a 	mov	r4,r2
 1827fd0:	180b883a 	mov	r5,r3
 1827fd4:	2005883a 	mov	r2,r4
 1827fd8:	2807883a 	mov	r3,r5
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
 1827fdc:	a085883a 	add	r2,r20,r2
 1827fe0:	1007883a 	mov	r3,r2
 1827fe4:	e0bff917 	ldw	r2,-28(fp)
 1827fe8:	10c00115 	stw	r3,4(r2)
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
 1827fec:	00001406 	br	1828040 <gettimeofday+0x14c>
      if (ptimeval->tv_sec <= 0)
 1827ff0:	e0bff917 	ldw	r2,-28(fp)
 1827ff4:	10800017 	ldw	r2,0(r2)
 1827ff8:	00800516 	blt	zero,r2,1828010 <gettimeofday+0x11c>
      {
          ptimeval->tv_sec = 0;
 1827ffc:	e0bff917 	ldw	r2,-28(fp)
 1828000:	10000015 	stw	zero,0(r2)
          ptimeval->tv_usec = 0;
 1828004:	e0bff917 	ldw	r2,-28(fp)
 1828008:	10000115 	stw	zero,4(r2)
          break;
 182800c:	00000f06 	br	182804c <gettimeofday+0x158>
      }
      else
      {
          ptimeval->tv_sec--;
 1828010:	e0bff917 	ldw	r2,-28(fp)
 1828014:	10800017 	ldw	r2,0(r2)
 1828018:	10ffffc4 	addi	r3,r2,-1
 182801c:	e0bff917 	ldw	r2,-28(fp)
 1828020:	10c00015 	stw	r3,0(r2)
          ptimeval->tv_usec += ALT_US;
 1828024:	e0bff917 	ldw	r2,-28(fp)
 1828028:	10c00117 	ldw	r3,4(r2)
 182802c:	008003f4 	movhi	r2,15
 1828030:	10909004 	addi	r2,r2,16960
 1828034:	1887883a 	add	r3,r3,r2
 1828038:	e0bff917 	ldw	r2,-28(fp)
 182803c:	10c00115 	stw	r3,4(r2)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
 1828040:	e0bff917 	ldw	r2,-28(fp)
 1828044:	10800117 	ldw	r2,4(r2)
 1828048:	103fe916 	blt	r2,zero,1827ff0 <__ram_exceptions_end+0xff817bac>
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 182804c:	00000c06 	br	1828080 <gettimeofday+0x18c>
      ptimeval->tv_sec++;
 1828050:	e0bff917 	ldw	r2,-28(fp)
 1828054:	10800017 	ldw	r2,0(r2)
 1828058:	10c00044 	addi	r3,r2,1
 182805c:	e0bff917 	ldw	r2,-28(fp)
 1828060:	10c00015 	stw	r3,0(r2)
      ptimeval->tv_usec -= ALT_US;
 1828064:	e0bff917 	ldw	r2,-28(fp)
 1828068:	10c00117 	ldw	r3,4(r2)
 182806c:	00bffc74 	movhi	r2,65521
 1828070:	10af7004 	addi	r2,r2,-16960
 1828074:	1887883a 	add	r3,r3,r2
 1828078:	e0bff917 	ldw	r2,-28(fp)
 182807c:	10c00115 	stw	r3,4(r2)
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 1828080:	e0bff917 	ldw	r2,-28(fp)
 1828084:	10c00117 	ldw	r3,4(r2)
 1828088:	008003f4 	movhi	r2,15
 182808c:	10908fc4 	addi	r2,r2,16959
 1828090:	10ffef16 	blt	r2,r3,1828050 <__ram_exceptions_end+0xff817c0c>
      ptimeval->tv_sec++;
      ptimeval->tv_usec -= ALT_US;
    }
      
    if (ptimezone)
 1828094:	e0bff617 	ldw	r2,-40(fp)
 1828098:	10000626 	beq	r2,zero,18280b4 <gettimeofday+0x1c0>
    { 
      ptimezone->tz_minuteswest = alt_timezone.tz_minuteswest;
 182809c:	d0e80417 	ldw	r3,-24560(gp)
 18280a0:	e0bff617 	ldw	r2,-40(fp)
 18280a4:	10c00015 	stw	r3,0(r2)
      ptimezone->tz_dsttime     = alt_timezone.tz_dsttime;
 18280a8:	d0e80517 	ldw	r3,-24556(gp)
 18280ac:	e0bff617 	ldw	r2,-40(fp)
 18280b0:	10c00115 	stw	r3,4(r2)
    }

    return 0;
 18280b4:	0005883a 	mov	r2,zero
 18280b8:	00000106 	br	18280c0 <gettimeofday+0x1cc>
  }

  return -ENOTSUP;
 18280bc:	00bfde84 	movi	r2,-134
}
 18280c0:	e6fffb04 	addi	sp,fp,-20
 18280c4:	dfc00617 	ldw	ra,24(sp)
 18280c8:	df000517 	ldw	fp,20(sp)
 18280cc:	dd000417 	ldw	r20,16(sp)
 18280d0:	dcc00317 	ldw	r19,12(sp)
 18280d4:	dc800217 	ldw	r18,8(sp)
 18280d8:	dc400117 	ldw	r17,4(sp)
 18280dc:	dc000017 	ldw	r16,0(sp)
 18280e0:	dec00704 	addi	sp,sp,28
 18280e4:	f800283a 	ret

018280e8 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 18280e8:	defffe04 	addi	sp,sp,-8
 18280ec:	dfc00115 	stw	ra,4(sp)
 18280f0:	df000015 	stw	fp,0(sp)
 18280f4:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 18280f8:	01500004 	movi	r5,16384
 18280fc:	0009883a 	mov	r4,zero
 1828100:	18393740 	call	1839374 <alt_icache_flush>
#endif
}
 1828104:	0001883a 	nop
 1828108:	e037883a 	mov	sp,fp
 182810c:	dfc00117 	ldw	ra,4(sp)
 1828110:	df000017 	ldw	fp,0(sp)
 1828114:	dec00204 	addi	sp,sp,8
 1828118:	f800283a 	ret

0182811c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 182811c:	defff904 	addi	sp,sp,-28
 1828120:	dfc00615 	stw	ra,24(sp)
 1828124:	df000515 	stw	fp,20(sp)
 1828128:	df000504 	addi	fp,sp,20
 182812c:	e13ffc15 	stw	r4,-16(fp)
 1828130:	e17ffd15 	stw	r5,-12(fp)
 1828134:	e1bffe15 	stw	r6,-8(fp)
 1828138:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 182813c:	e0800217 	ldw	r2,8(fp)
 1828140:	d8800015 	stw	r2,0(sp)
 1828144:	e1ffff17 	ldw	r7,-4(fp)
 1828148:	e1bffe17 	ldw	r6,-8(fp)
 182814c:	e17ffd17 	ldw	r5,-12(fp)
 1828150:	e13ffc17 	ldw	r4,-16(fp)
 1828154:	18282cc0 	call	18282cc <alt_iic_isr_register>
}  
 1828158:	e037883a 	mov	sp,fp
 182815c:	dfc00117 	ldw	ra,4(sp)
 1828160:	df000017 	ldw	fp,0(sp)
 1828164:	dec00204 	addi	sp,sp,8
 1828168:	f800283a 	ret

0182816c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 182816c:	defff904 	addi	sp,sp,-28
 1828170:	df000615 	stw	fp,24(sp)
 1828174:	df000604 	addi	fp,sp,24
 1828178:	e13ffe15 	stw	r4,-8(fp)
 182817c:	e17fff15 	stw	r5,-4(fp)
 1828180:	e0bfff17 	ldw	r2,-4(fp)
 1828184:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1828188:	0005303a 	rdctl	r2,status
 182818c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1828190:	e0fffb17 	ldw	r3,-20(fp)
 1828194:	00bfff84 	movi	r2,-2
 1828198:	1884703a 	and	r2,r3,r2
 182819c:	1001703a 	wrctl	status,r2
  
  return context;
 18281a0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 18281a4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 18281a8:	00c00044 	movi	r3,1
 18281ac:	e0bffa17 	ldw	r2,-24(fp)
 18281b0:	1884983a 	sll	r2,r3,r2
 18281b4:	1007883a 	mov	r3,r2
 18281b8:	d0a80817 	ldw	r2,-24544(gp)
 18281bc:	1884b03a 	or	r2,r3,r2
 18281c0:	d0a80815 	stw	r2,-24544(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 18281c4:	d0a80817 	ldw	r2,-24544(gp)
 18281c8:	100170fa 	wrctl	ienable,r2
 18281cc:	e0bffc17 	ldw	r2,-16(fp)
 18281d0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 18281d4:	e0bffd17 	ldw	r2,-12(fp)
 18281d8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 18281dc:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 18281e0:	0001883a 	nop
}
 18281e4:	e037883a 	mov	sp,fp
 18281e8:	df000017 	ldw	fp,0(sp)
 18281ec:	dec00104 	addi	sp,sp,4
 18281f0:	f800283a 	ret

018281f4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 18281f4:	defff904 	addi	sp,sp,-28
 18281f8:	df000615 	stw	fp,24(sp)
 18281fc:	df000604 	addi	fp,sp,24
 1828200:	e13ffe15 	stw	r4,-8(fp)
 1828204:	e17fff15 	stw	r5,-4(fp)
 1828208:	e0bfff17 	ldw	r2,-4(fp)
 182820c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1828210:	0005303a 	rdctl	r2,status
 1828214:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1828218:	e0fffb17 	ldw	r3,-20(fp)
 182821c:	00bfff84 	movi	r2,-2
 1828220:	1884703a 	and	r2,r3,r2
 1828224:	1001703a 	wrctl	status,r2
  
  return context;
 1828228:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 182822c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 1828230:	00c00044 	movi	r3,1
 1828234:	e0bffa17 	ldw	r2,-24(fp)
 1828238:	1884983a 	sll	r2,r3,r2
 182823c:	0084303a 	nor	r2,zero,r2
 1828240:	1007883a 	mov	r3,r2
 1828244:	d0a80817 	ldw	r2,-24544(gp)
 1828248:	1884703a 	and	r2,r3,r2
 182824c:	d0a80815 	stw	r2,-24544(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1828250:	d0a80817 	ldw	r2,-24544(gp)
 1828254:	100170fa 	wrctl	ienable,r2
 1828258:	e0bffc17 	ldw	r2,-16(fp)
 182825c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1828260:	e0bffd17 	ldw	r2,-12(fp)
 1828264:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1828268:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 182826c:	0001883a 	nop
}
 1828270:	e037883a 	mov	sp,fp
 1828274:	df000017 	ldw	fp,0(sp)
 1828278:	dec00104 	addi	sp,sp,4
 182827c:	f800283a 	ret

01828280 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 1828280:	defffc04 	addi	sp,sp,-16
 1828284:	df000315 	stw	fp,12(sp)
 1828288:	df000304 	addi	fp,sp,12
 182828c:	e13ffe15 	stw	r4,-8(fp)
 1828290:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 1828294:	000530fa 	rdctl	r2,ienable
 1828298:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 182829c:	00c00044 	movi	r3,1
 18282a0:	e0bfff17 	ldw	r2,-4(fp)
 18282a4:	1884983a 	sll	r2,r3,r2
 18282a8:	1007883a 	mov	r3,r2
 18282ac:	e0bffd17 	ldw	r2,-12(fp)
 18282b0:	1884703a 	and	r2,r3,r2
 18282b4:	1004c03a 	cmpne	r2,r2,zero
 18282b8:	10803fcc 	andi	r2,r2,255
}
 18282bc:	e037883a 	mov	sp,fp
 18282c0:	df000017 	ldw	fp,0(sp)
 18282c4:	dec00104 	addi	sp,sp,4
 18282c8:	f800283a 	ret

018282cc <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 18282cc:	defff504 	addi	sp,sp,-44
 18282d0:	dfc00a15 	stw	ra,40(sp)
 18282d4:	df000915 	stw	fp,36(sp)
 18282d8:	df000904 	addi	fp,sp,36
 18282dc:	e13ffc15 	stw	r4,-16(fp)
 18282e0:	e17ffd15 	stw	r5,-12(fp)
 18282e4:	e1bffe15 	stw	r6,-8(fp)
 18282e8:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 18282ec:	00bffa84 	movi	r2,-22
 18282f0:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 18282f4:	e0bffd17 	ldw	r2,-12(fp)
 18282f8:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 18282fc:	e0bff817 	ldw	r2,-32(fp)
 1828300:	10800808 	cmpgei	r2,r2,32
 1828304:	1000271e 	bne	r2,zero,18283a4 <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1828308:	0005303a 	rdctl	r2,status
 182830c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1828310:	e0fffb17 	ldw	r3,-20(fp)
 1828314:	00bfff84 	movi	r2,-2
 1828318:	1884703a 	and	r2,r3,r2
 182831c:	1001703a 	wrctl	status,r2
  
  return context;
 1828320:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 1828324:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 1828328:	008061f4 	movhi	r2,391
 182832c:	10aa7104 	addi	r2,r2,-22076
 1828330:	e0fff817 	ldw	r3,-32(fp)
 1828334:	180690fa 	slli	r3,r3,3
 1828338:	10c5883a 	add	r2,r2,r3
 182833c:	e0fffe17 	ldw	r3,-8(fp)
 1828340:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 1828344:	008061f4 	movhi	r2,391
 1828348:	10aa7104 	addi	r2,r2,-22076
 182834c:	e0fff817 	ldw	r3,-32(fp)
 1828350:	180690fa 	slli	r3,r3,3
 1828354:	10c5883a 	add	r2,r2,r3
 1828358:	10800104 	addi	r2,r2,4
 182835c:	e0ffff17 	ldw	r3,-4(fp)
 1828360:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 1828364:	e0bffe17 	ldw	r2,-8(fp)
 1828368:	10000526 	beq	r2,zero,1828380 <alt_iic_isr_register+0xb4>
 182836c:	e0bff817 	ldw	r2,-32(fp)
 1828370:	100b883a 	mov	r5,r2
 1828374:	e13ffc17 	ldw	r4,-16(fp)
 1828378:	182816c0 	call	182816c <alt_ic_irq_enable>
 182837c:	00000406 	br	1828390 <alt_iic_isr_register+0xc4>
 1828380:	e0bff817 	ldw	r2,-32(fp)
 1828384:	100b883a 	mov	r5,r2
 1828388:	e13ffc17 	ldw	r4,-16(fp)
 182838c:	18281f40 	call	18281f4 <alt_ic_irq_disable>
 1828390:	e0bff715 	stw	r2,-36(fp)
 1828394:	e0bffa17 	ldw	r2,-24(fp)
 1828398:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 182839c:	e0bff917 	ldw	r2,-28(fp)
 18283a0:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 18283a4:	e0bff717 	ldw	r2,-36(fp)
}
 18283a8:	e037883a 	mov	sp,fp
 18283ac:	dfc00117 	ldw	ra,4(sp)
 18283b0:	df000017 	ldw	fp,0(sp)
 18283b4:	dec00204 	addi	sp,sp,8
 18283b8:	f800283a 	ret

018283bc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 18283bc:	defffe04 	addi	sp,sp,-8
 18283c0:	dfc00115 	stw	ra,4(sp)
 18283c4:	df000015 	stw	fp,0(sp)
 18283c8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 18283cc:	d0a01917 	ldw	r2,-32668(gp)
 18283d0:	10000326 	beq	r2,zero,18283e0 <alt_get_errno+0x24>
 18283d4:	d0a01917 	ldw	r2,-32668(gp)
 18283d8:	103ee83a 	callr	r2
 18283dc:	00000106 	br	18283e4 <alt_get_errno+0x28>
 18283e0:	d0a7ce04 	addi	r2,gp,-24776
}
 18283e4:	e037883a 	mov	sp,fp
 18283e8:	dfc00117 	ldw	ra,4(sp)
 18283ec:	df000017 	ldw	fp,0(sp)
 18283f0:	dec00204 	addi	sp,sp,8
 18283f4:	f800283a 	ret

018283f8 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 18283f8:	defff904 	addi	sp,sp,-28
 18283fc:	dfc00615 	stw	ra,24(sp)
 1828400:	df000515 	stw	fp,20(sp)
 1828404:	df000504 	addi	fp,sp,20
 1828408:	e13ffd15 	stw	r4,-12(fp)
 182840c:	e17ffe15 	stw	r5,-8(fp)
 1828410:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1828414:	e0bffd17 	ldw	r2,-12(fp)
 1828418:	10000616 	blt	r2,zero,1828434 <alt_read+0x3c>
 182841c:	e0bffd17 	ldw	r2,-12(fp)
 1828420:	10c00324 	muli	r3,r2,12
 1828424:	00806134 	movhi	r2,388
 1828428:	1091ff04 	addi	r2,r2,18428
 182842c:	1885883a 	add	r2,r3,r2
 1828430:	00000106 	br	1828438 <alt_read+0x40>
 1828434:	0005883a 	mov	r2,zero
 1828438:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 182843c:	e0bffb17 	ldw	r2,-20(fp)
 1828440:	10002226 	beq	r2,zero,18284cc <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1828444:	e0bffb17 	ldw	r2,-20(fp)
 1828448:	10800217 	ldw	r2,8(r2)
 182844c:	108000cc 	andi	r2,r2,3
 1828450:	10800060 	cmpeqi	r2,r2,1
 1828454:	1000181e 	bne	r2,zero,18284b8 <alt_read+0xc0>
        (fd->dev->read))
 1828458:	e0bffb17 	ldw	r2,-20(fp)
 182845c:	10800017 	ldw	r2,0(r2)
 1828460:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1828464:	10001426 	beq	r2,zero,18284b8 <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 1828468:	e0bffb17 	ldw	r2,-20(fp)
 182846c:	10800017 	ldw	r2,0(r2)
 1828470:	10800517 	ldw	r2,20(r2)
 1828474:	e0ffff17 	ldw	r3,-4(fp)
 1828478:	180d883a 	mov	r6,r3
 182847c:	e17ffe17 	ldw	r5,-8(fp)
 1828480:	e13ffb17 	ldw	r4,-20(fp)
 1828484:	103ee83a 	callr	r2
 1828488:	e0bffc15 	stw	r2,-16(fp)
 182848c:	e0bffc17 	ldw	r2,-16(fp)
 1828490:	1000070e 	bge	r2,zero,18284b0 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 1828494:	18283bc0 	call	18283bc <alt_get_errno>
 1828498:	1007883a 	mov	r3,r2
 182849c:	e0bffc17 	ldw	r2,-16(fp)
 18284a0:	0085c83a 	sub	r2,zero,r2
 18284a4:	18800015 	stw	r2,0(r3)
          return -1;
 18284a8:	00bfffc4 	movi	r2,-1
 18284ac:	00000c06 	br	18284e0 <alt_read+0xe8>
        }
        return rval;
 18284b0:	e0bffc17 	ldw	r2,-16(fp)
 18284b4:	00000a06 	br	18284e0 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 18284b8:	18283bc0 	call	18283bc <alt_get_errno>
 18284bc:	1007883a 	mov	r3,r2
 18284c0:	00800344 	movi	r2,13
 18284c4:	18800015 	stw	r2,0(r3)
 18284c8:	00000406 	br	18284dc <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 18284cc:	18283bc0 	call	18283bc <alt_get_errno>
 18284d0:	1007883a 	mov	r3,r2
 18284d4:	00801444 	movi	r2,81
 18284d8:	18800015 	stw	r2,0(r3)
  }
  return -1;
 18284dc:	00bfffc4 	movi	r2,-1
}
 18284e0:	e037883a 	mov	sp,fp
 18284e4:	dfc00117 	ldw	ra,4(sp)
 18284e8:	df000017 	ldw	fp,0(sp)
 18284ec:	dec00204 	addi	sp,sp,8
 18284f0:	f800283a 	ret

018284f4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 18284f4:	defffa04 	addi	sp,sp,-24
 18284f8:	df000515 	stw	fp,20(sp)
 18284fc:	df000504 	addi	fp,sp,20
 1828500:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1828504:	0005303a 	rdctl	r2,status
 1828508:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 182850c:	e0fffc17 	ldw	r3,-16(fp)
 1828510:	00bfff84 	movi	r2,-2
 1828514:	1884703a 	and	r2,r3,r2
 1828518:	1001703a 	wrctl	status,r2
  
  return context;
 182851c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 1828520:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 1828524:	e0bfff17 	ldw	r2,-4(fp)
 1828528:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 182852c:	e0bffd17 	ldw	r2,-12(fp)
 1828530:	10800017 	ldw	r2,0(r2)
 1828534:	e0fffd17 	ldw	r3,-12(fp)
 1828538:	18c00117 	ldw	r3,4(r3)
 182853c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 1828540:	e0bffd17 	ldw	r2,-12(fp)
 1828544:	10800117 	ldw	r2,4(r2)
 1828548:	e0fffd17 	ldw	r3,-12(fp)
 182854c:	18c00017 	ldw	r3,0(r3)
 1828550:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 1828554:	e0bffd17 	ldw	r2,-12(fp)
 1828558:	e0fffd17 	ldw	r3,-12(fp)
 182855c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 1828560:	e0bffd17 	ldw	r2,-12(fp)
 1828564:	e0fffd17 	ldw	r3,-12(fp)
 1828568:	10c00015 	stw	r3,0(r2)
 182856c:	e0bffb17 	ldw	r2,-20(fp)
 1828570:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1828574:	e0bffe17 	ldw	r2,-8(fp)
 1828578:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 182857c:	0001883a 	nop
 1828580:	e037883a 	mov	sp,fp
 1828584:	df000017 	ldw	fp,0(sp)
 1828588:	dec00104 	addi	sp,sp,4
 182858c:	f800283a 	ret

01828590 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 1828590:	defffb04 	addi	sp,sp,-20
 1828594:	dfc00415 	stw	ra,16(sp)
 1828598:	df000315 	stw	fp,12(sp)
 182859c:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 18285a0:	d0a01b17 	ldw	r2,-32660(gp)
 18285a4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 18285a8:	d0a80a17 	ldw	r2,-24536(gp)
 18285ac:	10800044 	addi	r2,r2,1
 18285b0:	d0a80a15 	stw	r2,-24536(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 18285b4:	00002e06 	br	1828670 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 18285b8:	e0bffd17 	ldw	r2,-12(fp)
 18285bc:	10800017 	ldw	r2,0(r2)
 18285c0:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 18285c4:	e0bffd17 	ldw	r2,-12(fp)
 18285c8:	10800403 	ldbu	r2,16(r2)
 18285cc:	10803fcc 	andi	r2,r2,255
 18285d0:	10000426 	beq	r2,zero,18285e4 <alt_tick+0x54>
 18285d4:	d0a80a17 	ldw	r2,-24536(gp)
 18285d8:	1000021e 	bne	r2,zero,18285e4 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 18285dc:	e0bffd17 	ldw	r2,-12(fp)
 18285e0:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 18285e4:	e0bffd17 	ldw	r2,-12(fp)
 18285e8:	10800217 	ldw	r2,8(r2)
 18285ec:	d0e80a17 	ldw	r3,-24536(gp)
 18285f0:	18801d36 	bltu	r3,r2,1828668 <alt_tick+0xd8>
 18285f4:	e0bffd17 	ldw	r2,-12(fp)
 18285f8:	10800403 	ldbu	r2,16(r2)
 18285fc:	10803fcc 	andi	r2,r2,255
 1828600:	1000191e 	bne	r2,zero,1828668 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 1828604:	e0bffd17 	ldw	r2,-12(fp)
 1828608:	10800317 	ldw	r2,12(r2)
 182860c:	e0fffd17 	ldw	r3,-12(fp)
 1828610:	18c00517 	ldw	r3,20(r3)
 1828614:	1809883a 	mov	r4,r3
 1828618:	103ee83a 	callr	r2
 182861c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 1828620:	e0bfff17 	ldw	r2,-4(fp)
 1828624:	1000031e 	bne	r2,zero,1828634 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 1828628:	e13ffd17 	ldw	r4,-12(fp)
 182862c:	18284f40 	call	18284f4 <alt_alarm_stop>
 1828630:	00000d06 	br	1828668 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 1828634:	e0bffd17 	ldw	r2,-12(fp)
 1828638:	10c00217 	ldw	r3,8(r2)
 182863c:	e0bfff17 	ldw	r2,-4(fp)
 1828640:	1887883a 	add	r3,r3,r2
 1828644:	e0bffd17 	ldw	r2,-12(fp)
 1828648:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 182864c:	e0bffd17 	ldw	r2,-12(fp)
 1828650:	10c00217 	ldw	r3,8(r2)
 1828654:	d0a80a17 	ldw	r2,-24536(gp)
 1828658:	1880032e 	bgeu	r3,r2,1828668 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 182865c:	e0bffd17 	ldw	r2,-12(fp)
 1828660:	00c00044 	movi	r3,1
 1828664:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 1828668:	e0bffe17 	ldw	r2,-8(fp)
 182866c:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 1828670:	e0fffd17 	ldw	r3,-12(fp)
 1828674:	d0a01b04 	addi	r2,gp,-32660
 1828678:	18bfcf1e 	bne	r3,r2,18285b8 <__ram_exceptions_end+0xff818174>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 182867c:	18277880 	call	1827788 <vPortSysTickHandler>
}
 1828680:	0001883a 	nop
 1828684:	e037883a 	mov	sp,fp
 1828688:	dfc00117 	ldw	ra,4(sp)
 182868c:	df000017 	ldw	fp,0(sp)
 1828690:	dec00204 	addi	sp,sp,8
 1828694:	f800283a 	ret

01828698 <alt_uncached_malloc>:
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
 1828698:	defffd04 	addi	sp,sp,-12
 182869c:	dfc00215 	stw	ra,8(sp)
 18286a0:	df000115 	stw	fp,4(sp)
 18286a4:	df000104 	addi	fp,sp,4
 18286a8:	e13fff15 	stw	r4,-4(fp)
  ALT_LINK_ERROR("alt_uncached_malloc() is not available because CPU is not configured to use bit 31 of address to bypass data cache");
  return NULL;
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Just use regular malloc. */
  return malloc(size);
 18286ac:	e13fff17 	ldw	r4,-4(fp)
 18286b0:	183d0300 	call	183d030 <malloc>
#endif /* No data cache */
}
 18286b4:	e037883a 	mov	sp,fp
 18286b8:	dfc00117 	ldw	ra,4(sp)
 18286bc:	df000017 	ldw	fp,0(sp)
 18286c0:	dec00204 	addi	sp,sp,8
 18286c4:	f800283a 	ret

018286c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 18286c8:	defffe04 	addi	sp,sp,-8
 18286cc:	dfc00115 	stw	ra,4(sp)
 18286d0:	df000015 	stw	fp,0(sp)
 18286d4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 18286d8:	d0a01917 	ldw	r2,-32668(gp)
 18286dc:	10000326 	beq	r2,zero,18286ec <alt_get_errno+0x24>
 18286e0:	d0a01917 	ldw	r2,-32668(gp)
 18286e4:	103ee83a 	callr	r2
 18286e8:	00000106 	br	18286f0 <alt_get_errno+0x28>
 18286ec:	d0a7ce04 	addi	r2,gp,-24776
}
 18286f0:	e037883a 	mov	sp,fp
 18286f4:	dfc00117 	ldw	ra,4(sp)
 18286f8:	df000017 	ldw	fp,0(sp)
 18286fc:	dec00204 	addi	sp,sp,8
 1828700:	f800283a 	ret

01828704 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 1828704:	defff904 	addi	sp,sp,-28
 1828708:	dfc00615 	stw	ra,24(sp)
 182870c:	df000515 	stw	fp,20(sp)
 1828710:	df000504 	addi	fp,sp,20
 1828714:	e13ffd15 	stw	r4,-12(fp)
 1828718:	e17ffe15 	stw	r5,-8(fp)
 182871c:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1828720:	e0bffd17 	ldw	r2,-12(fp)
 1828724:	10000616 	blt	r2,zero,1828740 <alt_write+0x3c>
 1828728:	e0bffd17 	ldw	r2,-12(fp)
 182872c:	10c00324 	muli	r3,r2,12
 1828730:	00806134 	movhi	r2,388
 1828734:	1091ff04 	addi	r2,r2,18428
 1828738:	1885883a 	add	r2,r3,r2
 182873c:	00000106 	br	1828744 <alt_write+0x40>
 1828740:	0005883a 	mov	r2,zero
 1828744:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1828748:	e0bffb17 	ldw	r2,-20(fp)
 182874c:	10002126 	beq	r2,zero,18287d4 <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 1828750:	e0bffb17 	ldw	r2,-20(fp)
 1828754:	10800217 	ldw	r2,8(r2)
 1828758:	108000cc 	andi	r2,r2,3
 182875c:	10001826 	beq	r2,zero,18287c0 <alt_write+0xbc>
 1828760:	e0bffb17 	ldw	r2,-20(fp)
 1828764:	10800017 	ldw	r2,0(r2)
 1828768:	10800617 	ldw	r2,24(r2)
 182876c:	10001426 	beq	r2,zero,18287c0 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 1828770:	e0bffb17 	ldw	r2,-20(fp)
 1828774:	10800017 	ldw	r2,0(r2)
 1828778:	10800617 	ldw	r2,24(r2)
 182877c:	e0ffff17 	ldw	r3,-4(fp)
 1828780:	180d883a 	mov	r6,r3
 1828784:	e17ffe17 	ldw	r5,-8(fp)
 1828788:	e13ffb17 	ldw	r4,-20(fp)
 182878c:	103ee83a 	callr	r2
 1828790:	e0bffc15 	stw	r2,-16(fp)
 1828794:	e0bffc17 	ldw	r2,-16(fp)
 1828798:	1000070e 	bge	r2,zero,18287b8 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 182879c:	18286c80 	call	18286c8 <alt_get_errno>
 18287a0:	1007883a 	mov	r3,r2
 18287a4:	e0bffc17 	ldw	r2,-16(fp)
 18287a8:	0085c83a 	sub	r2,zero,r2
 18287ac:	18800015 	stw	r2,0(r3)
        return -1;
 18287b0:	00bfffc4 	movi	r2,-1
 18287b4:	00000c06 	br	18287e8 <alt_write+0xe4>
      }
      return rval;
 18287b8:	e0bffc17 	ldw	r2,-16(fp)
 18287bc:	00000a06 	br	18287e8 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 18287c0:	18286c80 	call	18286c8 <alt_get_errno>
 18287c4:	1007883a 	mov	r3,r2
 18287c8:	00800344 	movi	r2,13
 18287cc:	18800015 	stw	r2,0(r3)
 18287d0:	00000406 	br	18287e4 <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 18287d4:	18286c80 	call	18286c8 <alt_get_errno>
 18287d8:	1007883a 	mov	r3,r2
 18287dc:	00801444 	movi	r2,81
 18287e0:	18800015 	stw	r2,0(r3)
  }
  return -1;
 18287e4:	00bfffc4 	movi	r2,-1
}
 18287e8:	e037883a 	mov	sp,fp
 18287ec:	dfc00117 	ldw	ra,4(sp)
 18287f0:	df000017 	ldw	fp,0(sp)
 18287f4:	dec00204 	addi	sp,sp,8
 18287f8:	f800283a 	ret

018287fc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 18287fc:	deffff04 	addi	sp,sp,-4
 1828800:	df000015 	stw	fp,0(sp)
 1828804:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 1828808:	000170fa 	wrctl	ienable,zero
}
 182880c:	0001883a 	nop
 1828810:	e037883a 	mov	sp,fp
 1828814:	df000017 	ldw	fp,0(sp)
 1828818:	dec00104 	addi	sp,sp,4
 182881c:	f800283a 	ret

01828820 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
 1828820:	deffff04 	addi	sp,sp,-4
 1828824:	df000015 	stw	fp,0(sp)
 1828828:	d839883a 	mov	fp,sp
}
 182882c:	0001883a 	nop
 1828830:	e037883a 	mov	sp,fp
 1828834:	df000017 	ldw	fp,0(sp)
 1828838:	dec00104 	addi	sp,sp,4
 182883c:	f800283a 	ret

01828840 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
get_socket(int s)
{
 1828840:	defffd04 	addi	sp,sp,-12
 1828844:	df000215 	stw	fp,8(sp)
 1828848:	df000204 	addi	fp,sp,8
 182884c:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;

  s -= LWIP_SOCKET_OFFSET;
 1828850:	e0bfff17 	ldw	r2,-4(fp)
 1828854:	10bff804 	addi	r2,r2,-32
 1828858:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 182885c:	e0bfff17 	ldw	r2,-4(fp)
 1828860:	10000316 	blt	r2,zero,1828870 <get_socket+0x30>
 1828864:	e0bfff17 	ldw	r2,-4(fp)
 1828868:	10800a90 	cmplti	r2,r2,42
 182886c:	1000021e 	bne	r2,zero,1828878 <get_socket+0x38>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
 1828870:	0005883a 	mov	r2,zero
 1828874:	00000c06 	br	18288a8 <get_socket+0x68>
  }

  sock = &sockets[s];
 1828878:	e0bfff17 	ldw	r2,-4(fp)
 182887c:	10c00624 	muli	r3,r2,24
 1828880:	00806174 	movhi	r2,389
 1828884:	10a03c04 	addi	r2,r2,-32528
 1828888:	1885883a 	add	r2,r3,r2
 182888c:	e0bffe15 	stw	r2,-8(fp)

  if (!sock->conn) {
 1828890:	e0bffe17 	ldw	r2,-8(fp)
 1828894:	10800017 	ldw	r2,0(r2)
 1828898:	1000021e 	bne	r2,zero,18288a4 <get_socket+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
 182889c:	0005883a 	mov	r2,zero
 18288a0:	00000106 	br	18288a8 <get_socket+0x68>
  }

  return sock;
 18288a4:	e0bffe17 	ldw	r2,-8(fp)
}
 18288a8:	e037883a 	mov	sp,fp
 18288ac:	df000017 	ldw	fp,0(sp)
 18288b0:	dec00104 	addi	sp,sp,4
 18288b4:	f800283a 	ret

018288b8 <tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
 18288b8:	defffe04 	addi	sp,sp,-8
 18288bc:	df000115 	stw	fp,4(sp)
 18288c0:	df000104 	addi	fp,sp,4
 18288c4:	e13fff15 	stw	r4,-4(fp)
	s -= LWIP_SOCKET_OFFSET;
 18288c8:	e0bfff17 	ldw	r2,-4(fp)
 18288cc:	10bff804 	addi	r2,r2,-32
 18288d0:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 18288d4:	e0bfff17 	ldw	r2,-4(fp)
 18288d8:	10000316 	blt	r2,zero,18288e8 <tryget_socket+0x30>
 18288dc:	e0bfff17 	ldw	r2,-4(fp)
 18288e0:	10800a90 	cmplti	r2,r2,42
 18288e4:	1000021e 	bne	r2,zero,18288f0 <tryget_socket+0x38>
    return NULL;
 18288e8:	0005883a 	mov	r2,zero
 18288ec:	00000e06 	br	1828928 <tryget_socket+0x70>
  }
  if (!sockets[s].conn) {
 18288f0:	00806174 	movhi	r2,389
 18288f4:	10a03c04 	addi	r2,r2,-32528
 18288f8:	e0ffff17 	ldw	r3,-4(fp)
 18288fc:	18c00624 	muli	r3,r3,24
 1828900:	10c5883a 	add	r2,r2,r3
 1828904:	10800017 	ldw	r2,0(r2)
 1828908:	1000021e 	bne	r2,zero,1828914 <tryget_socket+0x5c>
    return NULL;
 182890c:	0005883a 	mov	r2,zero
 1828910:	00000506 	br	1828928 <tryget_socket+0x70>
  }
  return &sockets[s];
 1828914:	e0bfff17 	ldw	r2,-4(fp)
 1828918:	10c00624 	muli	r3,r2,24
 182891c:	00806174 	movhi	r2,389
 1828920:	10a03c04 	addi	r2,r2,-32528
 1828924:	1885883a 	add	r2,r3,r2
}
 1828928:	e037883a 	mov	sp,fp
 182892c:	df000017 	ldw	fp,0(sp)
 1828930:	dec00104 	addi	sp,sp,4
 1828934:	f800283a 	ret

01828938 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
 1828938:	defffb04 	addi	sp,sp,-20
 182893c:	dfc00415 	stw	ra,16(sp)
 1828940:	df000315 	stw	fp,12(sp)
 1828944:	df000304 	addi	fp,sp,12
 1828948:	e13ffe15 	stw	r4,-8(fp)
 182894c:	e17fff15 	stw	r5,-4(fp)
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 1828950:	e03ffd15 	stw	zero,-12(fp)
 1828954:	00005706 	br	1828ab4 <alloc_socket+0x17c>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
 1828958:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182895c:	10000126 	beq	r2,zero,1828964 <alloc_socket+0x2c>
 1828960:	181103c0 	call	181103c <vTaskEnterCritical>
    if (!sockets[i].conn) {
 1828964:	00806174 	movhi	r2,389
 1828968:	10a03c04 	addi	r2,r2,-32528
 182896c:	e0fffd17 	ldw	r3,-12(fp)
 1828970:	18c00624 	muli	r3,r3,24
 1828974:	10c5883a 	add	r2,r2,r3
 1828978:	10800017 	ldw	r2,0(r2)
 182897c:	1000471e 	bne	r2,zero,1828a9c <alloc_socket+0x164>
      sockets[i].conn       = newconn;
 1828980:	00806174 	movhi	r2,389
 1828984:	10a03c04 	addi	r2,r2,-32528
 1828988:	e0fffd17 	ldw	r3,-12(fp)
 182898c:	18c00624 	muli	r3,r3,24
 1828990:	10c5883a 	add	r2,r2,r3
 1828994:	e0fffe17 	ldw	r3,-8(fp)
 1828998:	10c00015 	stw	r3,0(r2)
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
 182899c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18289a0:	10000126 	beq	r2,zero,18289a8 <alloc_socket+0x70>
 18289a4:	18110840 	call	1811084 <vTaskExitCritical>
      sockets[i].lastdata   = NULL;
 18289a8:	00806174 	movhi	r2,389
 18289ac:	10a03c04 	addi	r2,r2,-32528
 18289b0:	e0fffd17 	ldw	r3,-12(fp)
 18289b4:	18c00624 	muli	r3,r3,24
 18289b8:	10c5883a 	add	r2,r2,r3
 18289bc:	10800104 	addi	r2,r2,4
 18289c0:	10000015 	stw	zero,0(r2)
      sockets[i].lastoffset = 0;
 18289c4:	00806174 	movhi	r2,389
 18289c8:	10a03c04 	addi	r2,r2,-32528
 18289cc:	e0fffd17 	ldw	r3,-12(fp)
 18289d0:	18c00624 	muli	r3,r3,24
 18289d4:	10c5883a 	add	r2,r2,r3
 18289d8:	10800204 	addi	r2,r2,8
 18289dc:	1000000d 	sth	zero,0(r2)
      sockets[i].rcvevent   = 0;
 18289e0:	00806174 	movhi	r2,389
 18289e4:	10a03c04 	addi	r2,r2,-32528
 18289e8:	e0fffd17 	ldw	r3,-12(fp)
 18289ec:	18c00624 	muli	r3,r3,24
 18289f0:	10c5883a 	add	r2,r2,r3
 18289f4:	10800284 	addi	r2,r2,10
 18289f8:	1000000d 	sth	zero,0(r2)
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 18289fc:	e0bffe17 	ldw	r2,-8(fp)
 1828a00:	10800017 	ldw	r2,0(r2)
 1828a04:	10800418 	cmpnei	r2,r2,16
 1828a08:	1000021e 	bne	r2,zero,1828a14 <alloc_socket+0xdc>
 1828a0c:	e0bfff17 	ldw	r2,-4(fp)
 1828a10:	10000226 	beq	r2,zero,1828a1c <alloc_socket+0xe4>
 1828a14:	00800044 	movi	r2,1
 1828a18:	00000106 	br	1828a20 <alloc_socket+0xe8>
 1828a1c:	0005883a 	mov	r2,zero
 1828a20:	1009883a 	mov	r4,r2
 1828a24:	00806174 	movhi	r2,389
 1828a28:	10a03c04 	addi	r2,r2,-32528
 1828a2c:	e0fffd17 	ldw	r3,-12(fp)
 1828a30:	18c00624 	muli	r3,r3,24
 1828a34:	10c5883a 	add	r2,r2,r3
 1828a38:	10800304 	addi	r2,r2,12
 1828a3c:	1100000d 	sth	r4,0(r2)
      sockets[i].errevent   = 0;
 1828a40:	00806174 	movhi	r2,389
 1828a44:	10a03c04 	addi	r2,r2,-32528
 1828a48:	e0fffd17 	ldw	r3,-12(fp)
 1828a4c:	18c00624 	muli	r3,r3,24
 1828a50:	10c5883a 	add	r2,r2,r3
 1828a54:	10800384 	addi	r2,r2,14
 1828a58:	1000000d 	sth	zero,0(r2)
      sockets[i].err        = 0;
 1828a5c:	00806174 	movhi	r2,389
 1828a60:	10a03c04 	addi	r2,r2,-32528
 1828a64:	e0fffd17 	ldw	r3,-12(fp)
 1828a68:	18c00624 	muli	r3,r3,24
 1828a6c:	10c5883a 	add	r2,r2,r3
 1828a70:	10800404 	addi	r2,r2,16
 1828a74:	10000015 	stw	zero,0(r2)
      sockets[i].select_waiting = 0;
 1828a78:	00806174 	movhi	r2,389
 1828a7c:	10a03c04 	addi	r2,r2,-32528
 1828a80:	e0fffd17 	ldw	r3,-12(fp)
 1828a84:	18c00624 	muli	r3,r3,24
 1828a88:	10c5883a 	add	r2,r2,r3
 1828a8c:	10800504 	addi	r2,r2,20
 1828a90:	10000015 	stw	zero,0(r2)
      return i;
 1828a94:	e0bffd17 	ldw	r2,-12(fp)
 1828a98:	00000a06 	br	1828ac4 <alloc_socket+0x18c>
    }
    SYS_ARCH_UNPROTECT(lev);
 1828a9c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1828aa0:	10000126 	beq	r2,zero,1828aa8 <alloc_socket+0x170>
 1828aa4:	18110840 	call	1811084 <vTaskExitCritical>
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 1828aa8:	e0bffd17 	ldw	r2,-12(fp)
 1828aac:	10800044 	addi	r2,r2,1
 1828ab0:	e0bffd15 	stw	r2,-12(fp)
 1828ab4:	e0bffd17 	ldw	r2,-12(fp)
 1828ab8:	10800a90 	cmplti	r2,r2,42
 1828abc:	103fa61e 	bne	r2,zero,1828958 <__ram_exceptions_end+0xff818514>
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
 1828ac0:	00bfffc4 	movi	r2,-1
}
 1828ac4:	e037883a 	mov	sp,fp
 1828ac8:	dfc00117 	ldw	ra,4(sp)
 1828acc:	df000017 	ldw	fp,0(sp)
 1828ad0:	dec00204 	addi	sp,sp,8
 1828ad4:	f800283a 	ret

01828ad8 <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
 1828ad8:	defffb04 	addi	sp,sp,-20
 1828adc:	dfc00415 	stw	ra,16(sp)
 1828ae0:	df000315 	stw	fp,12(sp)
 1828ae4:	df000304 	addi	fp,sp,12
 1828ae8:	e13ffe15 	stw	r4,-8(fp)
 1828aec:	e17fff15 	stw	r5,-4(fp)
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
 1828af0:	e0bffe17 	ldw	r2,-8(fp)
 1828af4:	10800117 	ldw	r2,4(r2)
 1828af8:	e0bffd15 	stw	r2,-12(fp)
  sock->lastdata   = NULL;
 1828afc:	e0bffe17 	ldw	r2,-8(fp)
 1828b00:	10000115 	stw	zero,4(r2)
  sock->lastoffset = 0;
 1828b04:	e0bffe17 	ldw	r2,-8(fp)
 1828b08:	1000020d 	sth	zero,8(r2)
  sock->err        = 0;
 1828b0c:	e0bffe17 	ldw	r2,-8(fp)
 1828b10:	10000415 	stw	zero,16(r2)

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
 1828b14:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1828b18:	10000126 	beq	r2,zero,1828b20 <free_socket+0x48>
 1828b1c:	181103c0 	call	181103c <vTaskEnterCritical>
  sock->conn       = NULL;
 1828b20:	e0bffe17 	ldw	r2,-8(fp)
 1828b24:	10000015 	stw	zero,0(r2)
  SYS_ARCH_UNPROTECT(lev);
 1828b28:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1828b2c:	10000126 	beq	r2,zero,1828b34 <free_socket+0x5c>
 1828b30:	18110840 	call	1811084 <vTaskExitCritical>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
 1828b34:	e0bffd17 	ldw	r2,-12(fp)
 1828b38:	10000726 	beq	r2,zero,1828b58 <free_socket+0x80>
    if (is_tcp) {
 1828b3c:	e0bfff17 	ldw	r2,-4(fp)
 1828b40:	10000326 	beq	r2,zero,1828b50 <free_socket+0x78>
      pbuf_free((struct pbuf *)lastdata);
 1828b44:	e13ffd17 	ldw	r4,-12(fp)
 1828b48:	181aca40 	call	181aca4 <pbuf_free>
    } else {
      netbuf_delete((struct netbuf *)lastdata);
    }
  }
}
 1828b4c:	00000206 	br	1828b58 <free_socket+0x80>

  if (lastdata != NULL) {
    if (is_tcp) {
      pbuf_free((struct pbuf *)lastdata);
    } else {
      netbuf_delete((struct netbuf *)lastdata);
 1828b50:	e13ffd17 	ldw	r4,-12(fp)
 1828b54:	183ca5c0 	call	183ca5c <netbuf_delete>
    }
  }
}
 1828b58:	0001883a 	nop
 1828b5c:	e037883a 	mov	sp,fp
 1828b60:	dfc00117 	ldw	ra,4(sp)
 1828b64:	df000017 	ldw	fp,0(sp)
 1828b68:	dec00204 	addi	sp,sp,8
 1828b6c:	f800283a 	ret

01828b70 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
 1828b70:	defff004 	addi	sp,sp,-64
 1828b74:	dfc00f15 	stw	ra,60(sp)
 1828b78:	df000e15 	stw	fp,56(sp)
 1828b7c:	df000e04 	addi	fp,sp,56
 1828b80:	e13ffd15 	stw	r4,-12(fp)
 1828b84:	e17ffe15 	stw	r5,-8(fp)
 1828b88:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in sin;
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
 1828b8c:	e13ffd17 	ldw	r4,-12(fp)
 1828b90:	18288400 	call	1828840 <get_socket>
 1828b94:	e0bff215 	stw	r2,-56(fp)
  if (!sock) {
 1828b98:	e0bff217 	ldw	r2,-56(fp)
 1828b9c:	1000021e 	bne	r2,zero,1828ba8 <lwip_accept+0x38>
    return -1;
 1828ba0:	00bfffc4 	movi	r2,-1
 1828ba4:	0000ae06 	br	1828e60 <lwip_accept+0x2f0>
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
 1828ba8:	e0bff217 	ldw	r2,-56(fp)
 1828bac:	10800017 	ldw	r2,0(r2)
 1828bb0:	10800903 	ldbu	r2,36(r2)
 1828bb4:	10803fcc 	andi	r2,r2,255
 1828bb8:	1080008c 	andi	r2,r2,2
 1828bbc:	10000b26 	beq	r2,zero,1828bec <lwip_accept+0x7c>
 1828bc0:	e0bff217 	ldw	r2,-56(fp)
 1828bc4:	1080028b 	ldhu	r2,10(r2)
 1828bc8:	10bfffcc 	andi	r2,r2,65535
 1828bcc:	10a0001c 	xori	r2,r2,32768
 1828bd0:	10a00004 	addi	r2,r2,-32768
 1828bd4:	00800516 	blt	zero,r2,1828bec <lwip_accept+0x7c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    sock_set_errno(sock, EWOULDBLOCK);
 1828bd8:	e0bff217 	ldw	r2,-56(fp)
 1828bdc:	00c002c4 	movi	r3,11
 1828be0:	10c00415 	stw	r3,16(r2)
    return -1;
 1828be4:	00bfffc4 	movi	r2,-1
 1828be8:	00009d06 	br	1828e60 <lwip_accept+0x2f0>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
 1828bec:	e0bff217 	ldw	r2,-56(fp)
 1828bf0:	10800017 	ldw	r2,0(r2)
 1828bf4:	e0fff604 	addi	r3,fp,-40
 1828bf8:	180b883a 	mov	r5,r3
 1828bfc:	1009883a 	mov	r4,r2
 1828c00:	18399940 	call	1839994 <netconn_accept>
 1828c04:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
 1828c08:	e0bff307 	ldb	r2,-52(fp)
 1828c0c:	10001c26 	beq	r2,zero,1828c80 <lwip_accept+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 1828c10:	e0bff217 	ldw	r2,-56(fp)
 1828c14:	10800017 	ldw	r2,0(r2)
 1828c18:	10800017 	ldw	r2,0(r2)
 1828c1c:	10800420 	cmpeqi	r2,r2,16
 1828c20:	1000051e 	bne	r2,zero,1828c38 <lwip_accept+0xc8>
      sock_set_errno(sock, EOPNOTSUPP);
 1828c24:	e0bff217 	ldw	r2,-56(fp)
 1828c28:	00c017c4 	movi	r3,95
 1828c2c:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 1828c30:	008017c4 	movi	r2,95
 1828c34:	00008a06 	br	1828e60 <lwip_accept+0x2f0>
    }
    sock_set_errno(sock, err_to_errno(err));
 1828c38:	e0bff307 	ldb	r2,-52(fp)
 1828c3c:	0085c83a 	sub	r2,zero,r2
 1828c40:	10800428 	cmpgeui	r2,r2,16
 1828c44:	1000091e 	bne	r2,zero,1828c6c <lwip_accept+0xfc>
 1828c48:	e0bff307 	ldb	r2,-52(fp)
 1828c4c:	0087c83a 	sub	r3,zero,r2
 1828c50:	00806134 	movhi	r2,388
 1828c54:	10876104 	addi	r2,r2,7556
 1828c58:	18c7883a 	add	r3,r3,r3
 1828c5c:	18c7883a 	add	r3,r3,r3
 1828c60:	10c5883a 	add	r2,r2,r3
 1828c64:	10800017 	ldw	r2,0(r2)
 1828c68:	00000106 	br	1828c70 <lwip_accept+0x100>
 1828c6c:	00800144 	movi	r2,5
 1828c70:	e0fff217 	ldw	r3,-56(fp)
 1828c74:	18800415 	stw	r2,16(r3)
    return -1;
 1828c78:	00bfffc4 	movi	r2,-1
 1828c7c:	00007806 	br	1828e60 <lwip_accept+0x2f0>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
 1828c80:	e0bff617 	ldw	r2,-40(fp)
 1828c84:	e0fff617 	ldw	r3,-40(fp)
 1828c88:	18c00903 	ldbu	r3,36(r3)
 1828c8c:	18c00214 	ori	r3,r3,8
 1828c90:	10c00905 	stb	r3,36(r2)

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
 1828c94:	e0bff617 	ldw	r2,-40(fp)
 1828c98:	e13ff804 	addi	r4,fp,-32
 1828c9c:	e0fff704 	addi	r3,fp,-36
 1828ca0:	000f883a 	mov	r7,zero
 1828ca4:	200d883a 	mov	r6,r4
 1828ca8:	180b883a 	mov	r5,r3
 1828cac:	1009883a 	mov	r4,r2
 1828cb0:	18395200 	call	1839520 <netconn_getaddr>
 1828cb4:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
 1828cb8:	e0bff307 	ldb	r2,-52(fp)
 1828cbc:	10001526 	beq	r2,zero,1828d14 <lwip_accept+0x1a4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
 1828cc0:	e0bff617 	ldw	r2,-40(fp)
 1828cc4:	1009883a 	mov	r4,r2
 1828cc8:	18394c00 	call	18394c0 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
 1828ccc:	e0bff307 	ldb	r2,-52(fp)
 1828cd0:	0085c83a 	sub	r2,zero,r2
 1828cd4:	10800428 	cmpgeui	r2,r2,16
 1828cd8:	1000091e 	bne	r2,zero,1828d00 <lwip_accept+0x190>
 1828cdc:	e0bff307 	ldb	r2,-52(fp)
 1828ce0:	0087c83a 	sub	r3,zero,r2
 1828ce4:	00806134 	movhi	r2,388
 1828ce8:	10876104 	addi	r2,r2,7556
 1828cec:	18c7883a 	add	r3,r3,r3
 1828cf0:	18c7883a 	add	r3,r3,r3
 1828cf4:	10c5883a 	add	r2,r2,r3
 1828cf8:	10800017 	ldw	r2,0(r2)
 1828cfc:	00000106 	br	1828d04 <lwip_accept+0x194>
 1828d00:	00800144 	movi	r2,5
 1828d04:	e0fff217 	ldw	r3,-56(fp)
 1828d08:	18800415 	stw	r2,16(r3)
    return -1;
 1828d0c:	00bfffc4 	movi	r2,-1
 1828d10:	00005306 	br	1828e60 <lwip_accept+0x2f0>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
 1828d14:	e0bffe17 	ldw	r2,-8(fp)
 1828d18:	10002226 	beq	r2,zero,1828da4 <lwip_accept+0x234>
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
 1828d1c:	e0bff904 	addi	r2,fp,-28
 1828d20:	01800404 	movi	r6,16
 1828d24:	000b883a 	mov	r5,zero
 1828d28:	1009883a 	mov	r4,r2
 1828d2c:	18061d40 	call	18061d4 <memset>
    sin.sin_len = sizeof(sin);
 1828d30:	00800404 	movi	r2,16
 1828d34:	e0bff905 	stb	r2,-28(fp)
    sin.sin_family = AF_INET;
 1828d38:	00800084 	movi	r2,2
 1828d3c:	e0bff945 	stb	r2,-27(fp)
    sin.sin_port = htons(port);
 1828d40:	e0bff80b 	ldhu	r2,-32(fp)
 1828d44:	10bfffcc 	andi	r2,r2,65535
 1828d48:	1004d23a 	srli	r2,r2,8
 1828d4c:	1007883a 	mov	r3,r2
 1828d50:	e0bff80b 	ldhu	r2,-32(fp)
 1828d54:	10bfffcc 	andi	r2,r2,65535
 1828d58:	1004923a 	slli	r2,r2,8
 1828d5c:	1884b03a 	or	r2,r3,r2
 1828d60:	e0bff98d 	sth	r2,-26(fp)
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 1828d64:	e0bff717 	ldw	r2,-36(fp)
 1828d68:	e0bffa15 	stw	r2,-24(fp)

    if (*addrlen > sizeof(sin))
 1828d6c:	e0bfff17 	ldw	r2,-4(fp)
 1828d70:	10800017 	ldw	r2,0(r2)
 1828d74:	10800470 	cmpltui	r2,r2,17
 1828d78:	1000031e 	bne	r2,zero,1828d88 <lwip_accept+0x218>
      *addrlen = sizeof(sin);
 1828d7c:	e0bfff17 	ldw	r2,-4(fp)
 1828d80:	00c00404 	movi	r3,16
 1828d84:	10c00015 	stw	r3,0(r2)

    MEMCPY(addr, &sin, *addrlen);
 1828d88:	e0bfff17 	ldw	r2,-4(fp)
 1828d8c:	10c00017 	ldw	r3,0(r2)
 1828d90:	e0bff904 	addi	r2,fp,-28
 1828d94:	180d883a 	mov	r6,r3
 1828d98:	100b883a 	mov	r5,r2
 1828d9c:	e13ffe17 	ldw	r4,-8(fp)
 1828da0:	180608c0 	call	180608c <memcpy>
  }

  newsock = alloc_socket(newconn, 1);
 1828da4:	e0bff617 	ldw	r2,-40(fp)
 1828da8:	01400044 	movi	r5,1
 1828dac:	1009883a 	mov	r4,r2
 1828db0:	18289380 	call	1828938 <alloc_socket>
 1828db4:	e0bff415 	stw	r2,-48(fp)
  if (newsock == -1) {
 1828db8:	e0bff417 	ldw	r2,-48(fp)
 1828dbc:	10bfffd8 	cmpnei	r2,r2,-1
 1828dc0:	1000081e 	bne	r2,zero,1828de4 <lwip_accept+0x274>
    netconn_delete(newconn);
 1828dc4:	e0bff617 	ldw	r2,-40(fp)
 1828dc8:	1009883a 	mov	r4,r2
 1828dcc:	18394c00 	call	18394c0 <netconn_delete>
    sock_set_errno(sock, ENFILE);
 1828dd0:	e0bff217 	ldw	r2,-56(fp)
 1828dd4:	00c005c4 	movi	r3,23
 1828dd8:	10c00415 	stw	r3,16(r2)
    return -1;
 1828ddc:	00bfffc4 	movi	r2,-1
 1828de0:	00001f06 	br	1828e60 <lwip_accept+0x2f0>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
  nsock = &sockets[newsock];
 1828de4:	e0bff417 	ldw	r2,-48(fp)
 1828de8:	10c00624 	muli	r3,r2,24
 1828dec:	00806174 	movhi	r2,389
 1828df0:	10a03c04 	addi	r2,r2,-32528
 1828df4:	1885883a 	add	r2,r3,r2
 1828df8:	e0bff515 	stw	r2,-44(fp)

  newsock += LWIP_SOCKET_OFFSET;
 1828dfc:	e0bff417 	ldw	r2,-48(fp)
 1828e00:	10800804 	addi	r2,r2,32
 1828e04:	e0bff415 	stw	r2,-48(fp)
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
 1828e08:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1828e0c:	10000126 	beq	r2,zero,1828e14 <lwip_accept+0x2a4>
 1828e10:	181103c0 	call	181103c <vTaskEnterCritical>
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
 1828e14:	e0bff517 	ldw	r2,-44(fp)
 1828e18:	1080028b 	ldhu	r2,10(r2)
 1828e1c:	1007883a 	mov	r3,r2
 1828e20:	e0bff617 	ldw	r2,-40(fp)
 1828e24:	10800717 	ldw	r2,28(r2)
 1828e28:	1885c83a 	sub	r2,r3,r2
 1828e2c:	10bfffc4 	addi	r2,r2,-1
 1828e30:	1007883a 	mov	r3,r2
 1828e34:	e0bff517 	ldw	r2,-44(fp)
 1828e38:	10c0028d 	sth	r3,10(r2)
  newconn->socket = newsock;
 1828e3c:	e0bff617 	ldw	r2,-40(fp)
 1828e40:	e0fff417 	ldw	r3,-48(fp)
 1828e44:	10c00715 	stw	r3,28(r2)
  SYS_ARCH_UNPROTECT(lev);
 1828e48:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1828e4c:	10000126 	beq	r2,zero,1828e54 <lwip_accept+0x2e4>
 1828e50:	18110840 	call	1811084 <vTaskExitCritical>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
 1828e54:	e0bff217 	ldw	r2,-56(fp)
 1828e58:	10000415 	stw	zero,16(r2)
  return newsock;
 1828e5c:	e0bff417 	ldw	r2,-48(fp)
}
 1828e60:	e037883a 	mov	sp,fp
 1828e64:	dfc00117 	ldw	ra,4(sp)
 1828e68:	df000017 	ldw	fp,0(sp)
 1828e6c:	dec00204 	addi	sp,sp,8
 1828e70:	f800283a 	ret

01828e74 <lwip_bind>:

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
 1828e74:	defff704 	addi	sp,sp,-36
 1828e78:	dfc00815 	stw	ra,32(sp)
 1828e7c:	df000715 	stw	fp,28(sp)
 1828e80:	df000704 	addi	fp,sp,28
 1828e84:	e13ffd15 	stw	r4,-12(fp)
 1828e88:	e17ffe15 	stw	r5,-8(fp)
 1828e8c:	e1bfff15 	stw	r6,-4(fp)
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
 1828e90:	e13ffd17 	ldw	r4,-12(fp)
 1828e94:	18288400 	call	1828840 <get_socket>
 1828e98:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 1828e9c:	e0bff917 	ldw	r2,-28(fp)
 1828ea0:	1000021e 	bne	r2,zero,1828eac <lwip_bind+0x38>
    return -1;
 1828ea4:	00bfffc4 	movi	r2,-1
 1828ea8:	00004206 	br	1828fb4 <lwip_bind+0x140>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 1828eac:	e0bfff17 	ldw	r2,-4(fp)
 1828eb0:	10800418 	cmpnei	r2,r2,16
 1828eb4:	1000081e 	bne	r2,zero,1828ed8 <lwip_bind+0x64>
 1828eb8:	e0bffe17 	ldw	r2,-8(fp)
 1828ebc:	10800043 	ldbu	r2,1(r2)
 1828ec0:	10803fcc 	andi	r2,r2,255
 1828ec4:	10800098 	cmpnei	r2,r2,2
 1828ec8:	1000031e 	bne	r2,zero,1828ed8 <lwip_bind+0x64>
 1828ecc:	e0bffe17 	ldw	r2,-8(fp)
 1828ed0:	108000cc 	andi	r2,r2,3
 1828ed4:	10000926 	beq	r2,zero,1828efc <lwip_bind+0x88>
 1828ed8:	01c06134 	movhi	r7,388
 1828edc:	39c77104 	addi	r7,r7,7620
 1828ee0:	01806ac4 	movi	r6,427
 1828ee4:	01406134 	movhi	r5,388
 1828ee8:	29477704 	addi	r5,r5,7644
 1828eec:	01006134 	movhi	r4,388
 1828ef0:	21077e04 	addi	r4,r4,7672
 1828ef4:	1800c180 	call	1800c18 <printf>
 1828ef8:	003fff06 	br	1828ef8 <__ram_exceptions_end+0xff818ab4>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
 1828efc:	e0bffe17 	ldw	r2,-8(fp)
 1828f00:	e0bffa15 	stw	r2,-24(fp)

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
 1828f04:	e0bffa17 	ldw	r2,-24(fp)
 1828f08:	10800117 	ldw	r2,4(r2)
 1828f0c:	e0bffc15 	stw	r2,-16(fp)
  local_port = name_in->sin_port;
 1828f10:	e0bffa17 	ldw	r2,-24(fp)
 1828f14:	1080008b 	ldhu	r2,2(r2)
 1828f18:	e0bffb0d 	sth	r2,-20(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
 1828f1c:	e0bff917 	ldw	r2,-28(fp)
 1828f20:	10c00017 	ldw	r3,0(r2)
 1828f24:	e0bffb0b 	ldhu	r2,-20(fp)
 1828f28:	1004d23a 	srli	r2,r2,8
 1828f2c:	1009883a 	mov	r4,r2
 1828f30:	e0bffb0b 	ldhu	r2,-20(fp)
 1828f34:	1004923a 	slli	r2,r2,8
 1828f38:	2084b03a 	or	r2,r4,r2
 1828f3c:	113fffcc 	andi	r4,r2,65535
 1828f40:	e0bffc04 	addi	r2,fp,-16
 1828f44:	200d883a 	mov	r6,r4
 1828f48:	100b883a 	mov	r5,r2
 1828f4c:	1809883a 	mov	r4,r3
 1828f50:	183965c0 	call	183965c <netconn_bind>
 1828f54:	e0bffb85 	stb	r2,-18(fp)

  if (err != ERR_OK) {
 1828f58:	e0bffb87 	ldb	r2,-18(fp)
 1828f5c:	10001226 	beq	r2,zero,1828fa8 <lwip_bind+0x134>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 1828f60:	e0bffb87 	ldb	r2,-18(fp)
 1828f64:	0085c83a 	sub	r2,zero,r2
 1828f68:	10800428 	cmpgeui	r2,r2,16
 1828f6c:	1000091e 	bne	r2,zero,1828f94 <lwip_bind+0x120>
 1828f70:	e0bffb87 	ldb	r2,-18(fp)
 1828f74:	0087c83a 	sub	r3,zero,r2
 1828f78:	00806134 	movhi	r2,388
 1828f7c:	10876104 	addi	r2,r2,7556
 1828f80:	18c7883a 	add	r3,r3,r3
 1828f84:	18c7883a 	add	r3,r3,r3
 1828f88:	10c5883a 	add	r2,r2,r3
 1828f8c:	10800017 	ldw	r2,0(r2)
 1828f90:	00000106 	br	1828f98 <lwip_bind+0x124>
 1828f94:	00800144 	movi	r2,5
 1828f98:	e0fff917 	ldw	r3,-28(fp)
 1828f9c:	18800415 	stw	r2,16(r3)
    return -1;
 1828fa0:	00bfffc4 	movi	r2,-1
 1828fa4:	00000306 	br	1828fb4 <lwip_bind+0x140>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 1828fa8:	e0bff917 	ldw	r2,-28(fp)
 1828fac:	10000415 	stw	zero,16(r2)
  return 0;
 1828fb0:	0005883a 	mov	r2,zero
}
 1828fb4:	e037883a 	mov	sp,fp
 1828fb8:	dfc00117 	ldw	ra,4(sp)
 1828fbc:	df000017 	ldw	fp,0(sp)
 1828fc0:	dec00204 	addi	sp,sp,8
 1828fc4:	f800283a 	ret

01828fc8 <lwip_close>:

int
lwip_close(int s)
{
 1828fc8:	defffb04 	addi	sp,sp,-20
 1828fcc:	dfc00415 	stw	ra,16(sp)
 1828fd0:	df000315 	stw	fp,12(sp)
 1828fd4:	df000304 	addi	fp,sp,12
 1828fd8:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;
  int is_tcp = 0;
 1828fdc:	e03ffd15 	stw	zero,-12(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
 1828fe0:	e13fff17 	ldw	r4,-4(fp)
 1828fe4:	18288400 	call	1828840 <get_socket>
 1828fe8:	e0bffe15 	stw	r2,-8(fp)
  if (!sock) {
 1828fec:	e0bffe17 	ldw	r2,-8(fp)
 1828ff0:	1000021e 	bne	r2,zero,1828ffc <lwip_close+0x34>
    return -1;
 1828ff4:	00bfffc4 	movi	r2,-1
 1828ff8:	00001106 	br	1829040 <lwip_close+0x78>
  }

  if(sock->conn != NULL) {
 1828ffc:	e0bffe17 	ldw	r2,-8(fp)
 1829000:	10800017 	ldw	r2,0(r2)
 1829004:	10000626 	beq	r2,zero,1829020 <lwip_close+0x58>
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
 1829008:	e0bffe17 	ldw	r2,-8(fp)
 182900c:	10800017 	ldw	r2,0(r2)
 1829010:	10800017 	ldw	r2,0(r2)
 1829014:	10800420 	cmpeqi	r2,r2,16
 1829018:	10803fcc 	andi	r2,r2,255
 182901c:	e0bffd15 	stw	r2,-12(fp)
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
 1829020:	e0bffe17 	ldw	r2,-8(fp)
 1829024:	10800017 	ldw	r2,0(r2)
 1829028:	1009883a 	mov	r4,r2
 182902c:	18394c00 	call	18394c0 <netconn_delete>

  free_socket(sock, is_tcp);
 1829030:	e17ffd17 	ldw	r5,-12(fp)
 1829034:	e13ffe17 	ldw	r4,-8(fp)
 1829038:	1828ad80 	call	1828ad8 <free_socket>
  set_errno(0);
  return 0;
 182903c:	0005883a 	mov	r2,zero
}
 1829040:	e037883a 	mov	sp,fp
 1829044:	dfc00117 	ldw	ra,4(sp)
 1829048:	df000017 	ldw	fp,0(sp)
 182904c:	dec00204 	addi	sp,sp,8
 1829050:	f800283a 	ret

01829054 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
 1829054:	defff604 	addi	sp,sp,-40
 1829058:	dfc00915 	stw	ra,36(sp)
 182905c:	df000815 	stw	fp,32(sp)
 1829060:	df000804 	addi	fp,sp,32
 1829064:	e13ffd15 	stw	r4,-12(fp)
 1829068:	e17ffe15 	stw	r5,-8(fp)
 182906c:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
 1829070:	e13ffd17 	ldw	r4,-12(fp)
 1829074:	18288400 	call	1828840 <get_socket>
 1829078:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 182907c:	e0bff917 	ldw	r2,-28(fp)
 1829080:	1000021e 	bne	r2,zero,182908c <lwip_connect+0x38>
    return -1;
 1829084:	00bfffc4 	movi	r2,-1
 1829088:	00004c06 	br	18291bc <lwip_connect+0x168>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 182908c:	e0bfff17 	ldw	r2,-4(fp)
 1829090:	10800418 	cmpnei	r2,r2,16
 1829094:	1000081e 	bne	r2,zero,18290b8 <lwip_connect+0x64>
 1829098:	e0bffe17 	ldw	r2,-8(fp)
 182909c:	10800043 	ldbu	r2,1(r2)
 18290a0:	10803fcc 	andi	r2,r2,255
 18290a4:	10800098 	cmpnei	r2,r2,2
 18290a8:	1000031e 	bne	r2,zero,18290b8 <lwip_connect+0x64>
 18290ac:	e0bffe17 	ldw	r2,-8(fp)
 18290b0:	108000cc 	andi	r2,r2,3
 18290b4:	10000926 	beq	r2,zero,18290dc <lwip_connect+0x88>
 18290b8:	01c06134 	movhi	r7,388
 18290bc:	39c77104 	addi	r7,r7,7620
 18290c0:	01807ac4 	movi	r6,491
 18290c4:	01406134 	movhi	r5,388
 18290c8:	29478a04 	addi	r5,r5,7720
 18290cc:	01006134 	movhi	r4,388
 18290d0:	21077e04 	addi	r4,r4,7672
 18290d4:	1800c180 	call	1800c18 <printf>
 18290d8:	003fff06 	br	18290d8 <__ram_exceptions_end+0xff818c94>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
 18290dc:	e0bffe17 	ldw	r2,-8(fp)
 18290e0:	e0bffa15 	stw	r2,-24(fp)

  if (name_in->sin_family == AF_UNSPEC) {
 18290e4:	e0bffa17 	ldw	r2,-24(fp)
 18290e8:	10800043 	ldbu	r2,1(r2)
 18290ec:	10803fcc 	andi	r2,r2,255
 18290f0:	1000061e 	bne	r2,zero,182910c <lwip_connect+0xb8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
 18290f4:	e0bff917 	ldw	r2,-28(fp)
 18290f8:	10800017 	ldw	r2,0(r2)
 18290fc:	1009883a 	mov	r4,r2
 1829100:	183980c0 	call	183980c <netconn_disconnect>
 1829104:	e0bff805 	stb	r2,-32(fp)
 1829108:	00001506 	br	1829160 <lwip_connect+0x10c>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
 182910c:	e0bffa17 	ldw	r2,-24(fp)
 1829110:	10800117 	ldw	r2,4(r2)
 1829114:	e0bffc15 	stw	r2,-16(fp)
    remote_port = name_in->sin_port;
 1829118:	e0bffa17 	ldw	r2,-24(fp)
 182911c:	1080008b 	ldhu	r2,2(r2)
 1829120:	e0bffb0d 	sth	r2,-20(fp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
 1829124:	e0bff917 	ldw	r2,-28(fp)
 1829128:	10c00017 	ldw	r3,0(r2)
 182912c:	e0bffb0b 	ldhu	r2,-20(fp)
 1829130:	1004d23a 	srli	r2,r2,8
 1829134:	1009883a 	mov	r4,r2
 1829138:	e0bffb0b 	ldhu	r2,-20(fp)
 182913c:	1004923a 	slli	r2,r2,8
 1829140:	2084b03a 	or	r2,r4,r2
 1829144:	113fffcc 	andi	r4,r2,65535
 1829148:	e0bffc04 	addi	r2,fp,-16
 182914c:	200d883a 	mov	r6,r4
 1829150:	100b883a 	mov	r5,r2
 1829154:	1809883a 	mov	r4,r3
 1829158:	18397340 	call	1839734 <netconn_connect>
 182915c:	e0bff805 	stb	r2,-32(fp)
  }

  if (err != ERR_OK) {
 1829160:	e0bff807 	ldb	r2,-32(fp)
 1829164:	10001226 	beq	r2,zero,18291b0 <lwip_connect+0x15c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 1829168:	e0bff807 	ldb	r2,-32(fp)
 182916c:	0085c83a 	sub	r2,zero,r2
 1829170:	10800428 	cmpgeui	r2,r2,16
 1829174:	1000091e 	bne	r2,zero,182919c <lwip_connect+0x148>
 1829178:	e0bff807 	ldb	r2,-32(fp)
 182917c:	0087c83a 	sub	r3,zero,r2
 1829180:	00806134 	movhi	r2,388
 1829184:	10876104 	addi	r2,r2,7556
 1829188:	18c7883a 	add	r3,r3,r3
 182918c:	18c7883a 	add	r3,r3,r3
 1829190:	10c5883a 	add	r2,r2,r3
 1829194:	10800017 	ldw	r2,0(r2)
 1829198:	00000106 	br	18291a0 <lwip_connect+0x14c>
 182919c:	00800144 	movi	r2,5
 18291a0:	e0fff917 	ldw	r3,-28(fp)
 18291a4:	18800415 	stw	r2,16(r3)
    return -1;
 18291a8:	00bfffc4 	movi	r2,-1
 18291ac:	00000306 	br	18291bc <lwip_connect+0x168>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 18291b0:	e0bff917 	ldw	r2,-28(fp)
 18291b4:	10000415 	stw	zero,16(r2)
  return 0;
 18291b8:	0005883a 	mov	r2,zero
}
 18291bc:	e037883a 	mov	sp,fp
 18291c0:	dfc00117 	ldw	ra,4(sp)
 18291c4:	df000017 	ldw	fp,0(sp)
 18291c8:	dec00204 	addi	sp,sp,8
 18291cc:	f800283a 	ret

018291d0 <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
 18291d0:	defffa04 	addi	sp,sp,-24
 18291d4:	dfc00515 	stw	ra,20(sp)
 18291d8:	df000415 	stw	fp,16(sp)
 18291dc:	df000404 	addi	fp,sp,16
 18291e0:	e13ffe15 	stw	r4,-8(fp)
 18291e4:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
 18291e8:	e13ffe17 	ldw	r4,-8(fp)
 18291ec:	18288400 	call	1828840 <get_socket>
 18291f0:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
 18291f4:	e0bffc17 	ldw	r2,-16(fp)
 18291f8:	1000021e 	bne	r2,zero,1829204 <lwip_listen+0x34>
    return -1;
 18291fc:	00bfffc4 	movi	r2,-1
 1829200:	00003206 	br	18292cc <lwip_listen+0xfc>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
 1829204:	e0bfff17 	ldw	r2,-4(fp)
 1829208:	10803fc8 	cmpgei	r2,r2,255
 182920c:	1000041e 	bne	r2,zero,1829220 <lwip_listen+0x50>
 1829210:	e0bfff17 	ldw	r2,-4(fp)
 1829214:	1000030e 	bge	r2,zero,1829224 <lwip_listen+0x54>
 1829218:	0005883a 	mov	r2,zero
 182921c:	00000106 	br	1829224 <lwip_listen+0x54>
 1829220:	00803fc4 	movi	r2,255
 1829224:	e0bfff15 	stw	r2,-4(fp)

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
 1829228:	e0bffc17 	ldw	r2,-16(fp)
 182922c:	10c00017 	ldw	r3,0(r2)
 1829230:	e0bfff17 	ldw	r2,-4(fp)
 1829234:	10803fcc 	andi	r2,r2,255
 1829238:	100b883a 	mov	r5,r2
 182923c:	1809883a 	mov	r4,r3
 1829240:	18398c80 	call	18398c8 <netconn_listen_with_backlog>
 1829244:	e0bffd05 	stb	r2,-12(fp)

  if (err != ERR_OK) {
 1829248:	e0bffd07 	ldb	r2,-12(fp)
 182924c:	10001c26 	beq	r2,zero,18292c0 <lwip_listen+0xf0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 1829250:	e0bffc17 	ldw	r2,-16(fp)
 1829254:	10800017 	ldw	r2,0(r2)
 1829258:	10800017 	ldw	r2,0(r2)
 182925c:	10800420 	cmpeqi	r2,r2,16
 1829260:	1000051e 	bne	r2,zero,1829278 <lwip_listen+0xa8>
      sock_set_errno(sock, EOPNOTSUPP);
 1829264:	e0bffc17 	ldw	r2,-16(fp)
 1829268:	00c017c4 	movi	r3,95
 182926c:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 1829270:	008017c4 	movi	r2,95
 1829274:	00001506 	br	18292cc <lwip_listen+0xfc>
    }
    sock_set_errno(sock, err_to_errno(err));
 1829278:	e0bffd07 	ldb	r2,-12(fp)
 182927c:	0085c83a 	sub	r2,zero,r2
 1829280:	10800428 	cmpgeui	r2,r2,16
 1829284:	1000091e 	bne	r2,zero,18292ac <lwip_listen+0xdc>
 1829288:	e0bffd07 	ldb	r2,-12(fp)
 182928c:	0087c83a 	sub	r3,zero,r2
 1829290:	00806134 	movhi	r2,388
 1829294:	10876104 	addi	r2,r2,7556
 1829298:	18c7883a 	add	r3,r3,r3
 182929c:	18c7883a 	add	r3,r3,r3
 18292a0:	10c5883a 	add	r2,r2,r3
 18292a4:	10800017 	ldw	r2,0(r2)
 18292a8:	00000106 	br	18292b0 <lwip_listen+0xe0>
 18292ac:	00800144 	movi	r2,5
 18292b0:	e0fffc17 	ldw	r3,-16(fp)
 18292b4:	18800415 	stw	r2,16(r3)
    return -1;
 18292b8:	00bfffc4 	movi	r2,-1
 18292bc:	00000306 	br	18292cc <lwip_listen+0xfc>
  }

  sock_set_errno(sock, 0);
 18292c0:	e0bffc17 	ldw	r2,-16(fp)
 18292c4:	10000415 	stw	zero,16(r2)
  return 0;
 18292c8:	0005883a 	mov	r2,zero
}
 18292cc:	e037883a 	mov	sp,fp
 18292d0:	dfc00117 	ldw	ra,4(sp)
 18292d4:	df000017 	ldw	fp,0(sp)
 18292d8:	dec00204 	addi	sp,sp,8
 18292dc:	f800283a 	ret

018292e0 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
 18292e0:	deffec04 	addi	sp,sp,-80
 18292e4:	dfc01315 	stw	ra,76(sp)
 18292e8:	df001215 	stw	fp,72(sp)
 18292ec:	df001204 	addi	fp,sp,72
 18292f0:	e13ffc15 	stw	r4,-16(fp)
 18292f4:	e17ffd15 	stw	r5,-12(fp)
 18292f8:	e1bffe15 	stw	r6,-8(fp)
 18292fc:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock;
  void             *buf = NULL;
 1829300:	e03ff515 	stw	zero,-44(fp)
  struct pbuf      *p;
  u16_t            buflen, copylen;
  int              off = 0;
 1829304:	e03ff015 	stw	zero,-64(fp)
  ip_addr_t        *addr;
  u16_t            port;
  u8_t             done = 0;
 1829308:	e03ff205 	stb	zero,-56(fp)
  err_t            err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
 182930c:	e13ffc17 	ldw	r4,-16(fp)
 1829310:	18288400 	call	1828840 <get_socket>
 1829314:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 1829318:	e0bff317 	ldw	r2,-52(fp)
 182931c:	1000021e 	bne	r2,zero,1829328 <lwip_recvfrom+0x48>
    return -1;
 1829320:	00bfffc4 	movi	r2,-1
 1829324:	00011f06 	br	18297a4 <lwip_recvfrom+0x4c4>
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
 1829328:	e0bff317 	ldw	r2,-52(fp)
 182932c:	10800117 	ldw	r2,4(r2)
 1829330:	10000426 	beq	r2,zero,1829344 <lwip_recvfrom+0x64>
      buf = sock->lastdata;
 1829334:	e0bff317 	ldw	r2,-52(fp)
 1829338:	10800117 	ldw	r2,4(r2)
 182933c:	e0bff515 	stw	r2,-44(fp)
 1829340:	00005c06 	br	18294b4 <lwip_recvfrom+0x1d4>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 1829344:	e0bfff17 	ldw	r2,-4(fp)
 1829348:	1080020c 	andi	r2,r2,8
 182934c:	1000061e 	bne	r2,zero,1829368 <lwip_recvfrom+0x88>
 1829350:	e0bff317 	ldw	r2,-52(fp)
 1829354:	10800017 	ldw	r2,0(r2)
 1829358:	10800903 	ldbu	r2,36(r2)
 182935c:	10803fcc 	andi	r2,r2,255
 1829360:	1080008c 	andi	r2,r2,2
 1829364:	10001726 	beq	r2,zero,18293c4 <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
 1829368:	e0bff317 	ldw	r2,-52(fp)
 182936c:	1080028b 	ldhu	r2,10(r2)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 1829370:	10bfffcc 	andi	r2,r2,65535
 1829374:	10a0001c 	xori	r2,r2,32768
 1829378:	10a00004 	addi	r2,r2,-32768
 182937c:	00801116 	blt	zero,r2,18293c4 <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
        if (off > 0) {
 1829380:	e0bff017 	ldw	r2,-64(fp)
 1829384:	00800a0e 	bge	zero,r2,18293b0 <lwip_recvfrom+0xd0>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 1829388:	e0bff317 	ldw	r2,-52(fp)
 182938c:	10800017 	ldw	r2,0(r2)
 1829390:	e0fff017 	ldw	r3,-64(fp)
 1829394:	180b883a 	mov	r5,r3
 1829398:	1009883a 	mov	r4,r2
 182939c:	183a03c0 	call	183a03c <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 18293a0:	e0bff317 	ldw	r2,-52(fp)
 18293a4:	10000415 	stw	zero,16(r2)
          return off;
 18293a8:	e0bff017 	ldw	r2,-64(fp)
 18293ac:	0000fd06 	br	18297a4 <lwip_recvfrom+0x4c4>
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
 18293b0:	e0bff317 	ldw	r2,-52(fp)
 18293b4:	00c002c4 	movi	r3,11
 18293b8:	10c00415 	stw	r3,16(r2)
        return -1;
 18293bc:	00bfffc4 	movi	r2,-1
 18293c0:	0000f806 	br	18297a4 <lwip_recvfrom+0x4c4>
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
 18293c4:	e0bff317 	ldw	r2,-52(fp)
 18293c8:	10800017 	ldw	r2,0(r2)
 18293cc:	10800017 	ldw	r2,0(r2)
 18293d0:	10800418 	cmpnei	r2,r2,16
 18293d4:	1000081e 	bne	r2,zero,18293f8 <lwip_recvfrom+0x118>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 18293d8:	e0bff317 	ldw	r2,-52(fp)
 18293dc:	10800017 	ldw	r2,0(r2)
 18293e0:	e0fff504 	addi	r3,fp,-44
 18293e4:	180b883a 	mov	r5,r3
 18293e8:	1009883a 	mov	r4,r2
 18293ec:	1839e200 	call	1839e20 <netconn_recv_tcp_pbuf>
 18293f0:	e0bff245 	stb	r2,-55(fp)
 18293f4:	00000706 	br	1829414 <lwip_recvfrom+0x134>
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
 18293f8:	e0bff317 	ldw	r2,-52(fp)
 18293fc:	10800017 	ldw	r2,0(r2)
 1829400:	e0fff504 	addi	r3,fp,-44
 1829404:	180b883a 	mov	r5,r3
 1829408:	1009883a 	mov	r4,r2
 182940c:	1839e940 	call	1839e94 <netconn_recv>
 1829410:	e0bff245 	stb	r2,-55(fp)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
 1829414:	e0bff247 	ldb	r2,-55(fp)
 1829418:	10002326 	beq	r2,zero,18294a8 <lwip_recvfrom+0x1c8>
        if (off > 0) {
 182941c:	e0bff017 	ldw	r2,-64(fp)
 1829420:	00800a0e 	bge	zero,r2,182944c <lwip_recvfrom+0x16c>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 1829424:	e0bff317 	ldw	r2,-52(fp)
 1829428:	10800017 	ldw	r2,0(r2)
 182942c:	e0fff017 	ldw	r3,-64(fp)
 1829430:	180b883a 	mov	r5,r3
 1829434:	1009883a 	mov	r4,r2
 1829438:	183a03c0 	call	183a03c <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 182943c:	e0bff317 	ldw	r2,-52(fp)
 1829440:	10000415 	stw	zero,16(r2)
          return off;
 1829444:	e0bff017 	ldw	r2,-64(fp)
 1829448:	0000d606 	br	18297a4 <lwip_recvfrom+0x4c4>
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
 182944c:	e0bff247 	ldb	r2,-55(fp)
 1829450:	0085c83a 	sub	r2,zero,r2
 1829454:	10800428 	cmpgeui	r2,r2,16
 1829458:	1000091e 	bne	r2,zero,1829480 <lwip_recvfrom+0x1a0>
 182945c:	e0bff247 	ldb	r2,-55(fp)
 1829460:	0087c83a 	sub	r3,zero,r2
 1829464:	00806134 	movhi	r2,388
 1829468:	10876104 	addi	r2,r2,7556
 182946c:	18c7883a 	add	r3,r3,r3
 1829470:	18c7883a 	add	r3,r3,r3
 1829474:	10c5883a 	add	r2,r2,r3
 1829478:	10800017 	ldw	r2,0(r2)
 182947c:	00000106 	br	1829484 <lwip_recvfrom+0x1a4>
 1829480:	00800144 	movi	r2,5
 1829484:	e0fff317 	ldw	r3,-52(fp)
 1829488:	18800415 	stw	r2,16(r3)
        if (err == ERR_CLSD) {
 182948c:	e0bff247 	ldb	r2,-55(fp)
 1829490:	10bffd18 	cmpnei	r2,r2,-12
 1829494:	1000021e 	bne	r2,zero,18294a0 <lwip_recvfrom+0x1c0>
          return 0;
 1829498:	0005883a 	mov	r2,zero
 182949c:	0000c106 	br	18297a4 <lwip_recvfrom+0x4c4>
        } else {
          return -1;
 18294a0:	00bfffc4 	movi	r2,-1
 18294a4:	0000bf06 	br	18297a4 <lwip_recvfrom+0x4c4>
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
 18294a8:	e0fff517 	ldw	r3,-44(fp)
 18294ac:	e0bff317 	ldw	r2,-52(fp)
 18294b0:	10c00115 	stw	r3,4(r2)
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 18294b4:	e0bff317 	ldw	r2,-52(fp)
 18294b8:	10800017 	ldw	r2,0(r2)
 18294bc:	10800017 	ldw	r2,0(r2)
 18294c0:	10800418 	cmpnei	r2,r2,16
 18294c4:	1000031e 	bne	r2,zero,18294d4 <lwip_recvfrom+0x1f4>
      p = (struct pbuf *)buf;
 18294c8:	e0bff517 	ldw	r2,-44(fp)
 18294cc:	e0bfee15 	stw	r2,-72(fp)
 18294d0:	00000306 	br	18294e0 <lwip_recvfrom+0x200>
    } else {
      p = ((struct netbuf *)buf)->p;
 18294d4:	e0bff517 	ldw	r2,-44(fp)
 18294d8:	10800017 	ldw	r2,0(r2)
 18294dc:	e0bfee15 	stw	r2,-72(fp)
    }
    buflen = p->tot_len;
 18294e0:	e0bfee17 	ldw	r2,-72(fp)
 18294e4:	1080020b 	ldhu	r2,8(r2)
 18294e8:	e0bff40d 	sth	r2,-48(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
 18294ec:	e0bff317 	ldw	r2,-52(fp)
 18294f0:	1080020b 	ldhu	r2,8(r2)
 18294f4:	e0fff40b 	ldhu	r3,-48(fp)
 18294f8:	1885c83a 	sub	r2,r3,r2
 18294fc:	e0bff40d 	sth	r2,-48(fp)

    if (len > buflen) {
 1829500:	e0fff40b 	ldhu	r3,-48(fp)
 1829504:	e0bffe17 	ldw	r2,-8(fp)
 1829508:	1880032e 	bgeu	r3,r2,1829518 <lwip_recvfrom+0x238>
      copylen = buflen;
 182950c:	e0bff40b 	ldhu	r2,-48(fp)
 1829510:	e0bfef0d 	sth	r2,-68(fp)
 1829514:	00000206 	br	1829520 <lwip_recvfrom+0x240>
    } else {
      copylen = (u16_t)len;
 1829518:	e0bffe17 	ldw	r2,-8(fp)
 182951c:	e0bfef0d 	sth	r2,-68(fp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 1829520:	e0bff017 	ldw	r2,-64(fp)
 1829524:	e0fffd17 	ldw	r3,-12(fp)
 1829528:	1887883a 	add	r3,r3,r2
 182952c:	e13fef0b 	ldhu	r4,-68(fp)
 1829530:	e0bff317 	ldw	r2,-52(fp)
 1829534:	1080020b 	ldhu	r2,8(r2)
 1829538:	10bfffcc 	andi	r2,r2,65535
 182953c:	100f883a 	mov	r7,r2
 1829540:	200d883a 	mov	r6,r4
 1829544:	180b883a 	mov	r5,r3
 1829548:	e13fee17 	ldw	r4,-72(fp)
 182954c:	181b2a80 	call	181b2a8 <pbuf_copy_partial>

    off += copylen;
 1829550:	e0bfef0b 	ldhu	r2,-68(fp)
 1829554:	e0fff017 	ldw	r3,-64(fp)
 1829558:	1885883a 	add	r2,r3,r2
 182955c:	e0bff015 	stw	r2,-64(fp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 1829560:	e0bff317 	ldw	r2,-52(fp)
 1829564:	10800017 	ldw	r2,0(r2)
 1829568:	10800017 	ldw	r2,0(r2)
 182956c:	10800418 	cmpnei	r2,r2,16
 1829570:	1000171e 	bne	r2,zero,18295d0 <lwip_recvfrom+0x2f0>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
 1829574:	e0bfef0b 	ldhu	r2,-68(fp)
 1829578:	e0fffe17 	ldw	r3,-8(fp)
 182957c:	1885c83a 	sub	r2,r3,r2
 1829580:	e0bffe15 	stw	r2,-8(fp)
      if ( (len <= 0) || 
 1829584:	e0bffe17 	ldw	r2,-8(fp)
 1829588:	10000e26 	beq	r2,zero,18295c4 <lwip_recvfrom+0x2e4>
           (p->flags & PBUF_FLAG_PUSH) || 
 182958c:	e0bfee17 	ldw	r2,-72(fp)
 1829590:	10800343 	ldbu	r2,13(r2)
 1829594:	10803fcc 	andi	r2,r2,255
 1829598:	1080004c 	andi	r2,r2,1
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
 182959c:	1000091e 	bne	r2,zero,18295c4 <lwip_recvfrom+0x2e4>
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
 18295a0:	e0bff317 	ldw	r2,-52(fp)
 18295a4:	1080028b 	ldhu	r2,10(r2)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
 18295a8:	10bfffcc 	andi	r2,r2,65535
 18295ac:	10a0001c 	xori	r2,r2,32768
 18295b0:	10a00004 	addi	r2,r2,-32768
 18295b4:	0080030e 	bge	zero,r2,18295c4 <lwip_recvfrom+0x2e4>
           (sock->rcvevent <= 0) || 
           ((flags & MSG_PEEK)!=0)) {
 18295b8:	e0bfff17 	ldw	r2,-4(fp)
 18295bc:	1080004c 	andi	r2,r2,1
    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
 18295c0:	10000526 	beq	r2,zero,18295d8 <lwip_recvfrom+0x2f8>
           ((flags & MSG_PEEK)!=0)) {
        done = 1;
 18295c4:	00800044 	movi	r2,1
 18295c8:	e0bff205 	stb	r2,-56(fp)
 18295cc:	00000206 	br	18295d8 <lwip_recvfrom+0x2f8>
      }
    } else {
      done = 1;
 18295d0:	00800044 	movi	r2,1
 18295d4:	e0bff205 	stb	r2,-56(fp)
    }

    /* Check to see from where the data was.*/
    if (done) {
 18295d8:	e0bff203 	ldbu	r2,-56(fp)
 18295dc:	10003d26 	beq	r2,zero,18296d4 <lwip_recvfrom+0x3f4>
      ip_addr_t fromaddr;
      if (from && fromlen) {
 18295e0:	e0800217 	ldw	r2,8(fp)
 18295e4:	10003b26 	beq	r2,zero,18296d4 <lwip_recvfrom+0x3f4>
 18295e8:	e0800317 	ldw	r2,12(fp)
 18295ec:	10003926 	beq	r2,zero,18296d4 <lwip_recvfrom+0x3f4>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
 18295f0:	e0bff317 	ldw	r2,-52(fp)
 18295f4:	10800017 	ldw	r2,0(r2)
 18295f8:	10800017 	ldw	r2,0(r2)
 18295fc:	10800418 	cmpnei	r2,r2,16
 1829600:	10000b1e 	bne	r2,zero,1829630 <lwip_recvfrom+0x350>
          addr = &fromaddr;
 1829604:	e0bff704 	addi	r2,fp,-36
 1829608:	e0bff115 	stw	r2,-60(fp)
          netconn_getaddr(sock->conn, addr, &port, 0);
 182960c:	e0bff317 	ldw	r2,-52(fp)
 1829610:	10800017 	ldw	r2,0(r2)
 1829614:	e0fff604 	addi	r3,fp,-40
 1829618:	000f883a 	mov	r7,zero
 182961c:	180d883a 	mov	r6,r3
 1829620:	e17ff117 	ldw	r5,-60(fp)
 1829624:	1009883a 	mov	r4,r2
 1829628:	18395200 	call	1839520 <netconn_getaddr>
 182962c:	00000606 	br	1829648 <lwip_recvfrom+0x368>
        } else {
          addr = netbuf_fromaddr((struct netbuf *)buf);
 1829630:	e0bff517 	ldw	r2,-44(fp)
 1829634:	10800204 	addi	r2,r2,8
 1829638:	e0bff115 	stw	r2,-60(fp)
          port = netbuf_fromport((struct netbuf *)buf);
 182963c:	e0bff517 	ldw	r2,-44(fp)
 1829640:	1080030b 	ldhu	r2,12(r2)
 1829644:	e0bff60d 	sth	r2,-40(fp)
        }

        memset(&sin, 0, sizeof(sin));
 1829648:	e0bff804 	addi	r2,fp,-32
 182964c:	01800404 	movi	r6,16
 1829650:	000b883a 	mov	r5,zero
 1829654:	1009883a 	mov	r4,r2
 1829658:	18061d40 	call	18061d4 <memset>
        sin.sin_len = sizeof(sin);
 182965c:	00800404 	movi	r2,16
 1829660:	e0bff805 	stb	r2,-32(fp)
        sin.sin_family = AF_INET;
 1829664:	00800084 	movi	r2,2
 1829668:	e0bff845 	stb	r2,-31(fp)
        sin.sin_port = htons(port);
 182966c:	e0bff60b 	ldhu	r2,-40(fp)
 1829670:	10bfffcc 	andi	r2,r2,65535
 1829674:	1004d23a 	srli	r2,r2,8
 1829678:	1007883a 	mov	r3,r2
 182967c:	e0bff60b 	ldhu	r2,-40(fp)
 1829680:	10bfffcc 	andi	r2,r2,65535
 1829684:	1004923a 	slli	r2,r2,8
 1829688:	1884b03a 	or	r2,r3,r2
 182968c:	e0bff88d 	sth	r2,-30(fp)
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
 1829690:	e0bff117 	ldw	r2,-60(fp)
 1829694:	10800017 	ldw	r2,0(r2)
 1829698:	e0bff915 	stw	r2,-28(fp)

        if (*fromlen > sizeof(sin)) {
 182969c:	e0800317 	ldw	r2,12(fp)
 18296a0:	10800017 	ldw	r2,0(r2)
 18296a4:	10800470 	cmpltui	r2,r2,17
 18296a8:	1000031e 	bne	r2,zero,18296b8 <lwip_recvfrom+0x3d8>
          *fromlen = sizeof(sin);
 18296ac:	e0800317 	ldw	r2,12(fp)
 18296b0:	00c00404 	movi	r3,16
 18296b4:	10c00015 	stw	r3,0(r2)
        }

        MEMCPY(from, &sin, *fromlen);
 18296b8:	e0800317 	ldw	r2,12(fp)
 18296bc:	10c00017 	ldw	r3,0(r2)
 18296c0:	e0bff804 	addi	r2,fp,-32
 18296c4:	180d883a 	mov	r6,r3
 18296c8:	100b883a 	mov	r5,r2
 18296cc:	e1000217 	ldw	r4,8(fp)
 18296d0:	180608c0 	call	180608c <memcpy>
#endif /*  SOCKETS_DEBUG */
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
 18296d4:	e0bfff17 	ldw	r2,-4(fp)
 18296d8:	1080004c 	andi	r2,r2,1
 18296dc:	1000241e 	bne	r2,zero,1829770 <lwip_recvfrom+0x490>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
 18296e0:	e0bff317 	ldw	r2,-52(fp)
 18296e4:	10800017 	ldw	r2,0(r2)
 18296e8:	10800017 	ldw	r2,0(r2)
 18296ec:	10800418 	cmpnei	r2,r2,16
 18296f0:	10000f1e 	bne	r2,zero,1829730 <lwip_recvfrom+0x450>
 18296f4:	e0fff40b 	ldhu	r3,-48(fp)
 18296f8:	e0bfef0b 	ldhu	r2,-68(fp)
 18296fc:	1885c83a 	sub	r2,r3,r2
 1829700:	00800b0e 	bge	zero,r2,1829730 <lwip_recvfrom+0x450>
        sock->lastdata = buf;
 1829704:	e0fff517 	ldw	r3,-44(fp)
 1829708:	e0bff317 	ldw	r2,-52(fp)
 182970c:	10c00115 	stw	r3,4(r2)
        sock->lastoffset += copylen;
 1829710:	e0bff317 	ldw	r2,-52(fp)
 1829714:	10c0020b 	ldhu	r3,8(r2)
 1829718:	e0bfef0b 	ldhu	r2,-68(fp)
 182971c:	1885883a 	add	r2,r3,r2
 1829720:	1007883a 	mov	r3,r2
 1829724:	e0bff317 	ldw	r2,-52(fp)
 1829728:	10c0020d 	sth	r3,8(r2)
 182972c:	00001006 	br	1829770 <lwip_recvfrom+0x490>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 1829730:	e0bff317 	ldw	r2,-52(fp)
 1829734:	10000115 	stw	zero,4(r2)
        sock->lastoffset = 0;
 1829738:	e0bff317 	ldw	r2,-52(fp)
 182973c:	1000020d 	sth	zero,8(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
 1829740:	e0bff317 	ldw	r2,-52(fp)
 1829744:	10800017 	ldw	r2,0(r2)
 1829748:	10800017 	ldw	r2,0(r2)
 182974c:	10800418 	cmpnei	r2,r2,16
 1829750:	1000041e 	bne	r2,zero,1829764 <lwip_recvfrom+0x484>
          pbuf_free((struct pbuf *)buf);
 1829754:	e0bff517 	ldw	r2,-44(fp)
 1829758:	1009883a 	mov	r4,r2
 182975c:	181aca40 	call	181aca4 <pbuf_free>
 1829760:	00000306 	br	1829770 <lwip_recvfrom+0x490>
        } else {
          netbuf_delete((struct netbuf *)buf);
 1829764:	e0bff517 	ldw	r2,-44(fp)
 1829768:	1009883a 	mov	r4,r2
 182976c:	183ca5c0 	call	183ca5c <netbuf_delete>
        }
      }
    }
  } while (!done);
 1829770:	e0bff203 	ldbu	r2,-56(fp)
 1829774:	103eec26 	beq	r2,zero,1829328 <__ram_exceptions_end+0xff818ee4>

  if (off > 0) {
 1829778:	e0bff017 	ldw	r2,-64(fp)
 182977c:	0080060e 	bge	zero,r2,1829798 <lwip_recvfrom+0x4b8>
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
 1829780:	e0bff317 	ldw	r2,-52(fp)
 1829784:	10800017 	ldw	r2,0(r2)
 1829788:	e0fff017 	ldw	r3,-64(fp)
 182978c:	180b883a 	mov	r5,r3
 1829790:	1009883a 	mov	r4,r2
 1829794:	183a03c0 	call	183a03c <netconn_recved>
  }
  sock_set_errno(sock, 0);
 1829798:	e0bff317 	ldw	r2,-52(fp)
 182979c:	10000415 	stw	zero,16(r2)
  return off;
 18297a0:	e0bff017 	ldw	r2,-64(fp)
}
 18297a4:	e037883a 	mov	sp,fp
 18297a8:	dfc00117 	ldw	ra,4(sp)
 18297ac:	df000017 	ldw	fp,0(sp)
 18297b0:	dec00204 	addi	sp,sp,8
 18297b4:	f800283a 	ret

018297b8 <lwip_read>:

int
lwip_read(int s, void *mem, size_t len)
{
 18297b8:	defff904 	addi	sp,sp,-28
 18297bc:	dfc00615 	stw	ra,24(sp)
 18297c0:	df000515 	stw	fp,20(sp)
 18297c4:	df000504 	addi	fp,sp,20
 18297c8:	e13ffd15 	stw	r4,-12(fp)
 18297cc:	e17ffe15 	stw	r5,-8(fp)
 18297d0:	e1bfff15 	stw	r6,-4(fp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 18297d4:	d8000115 	stw	zero,4(sp)
 18297d8:	d8000015 	stw	zero,0(sp)
 18297dc:	000f883a 	mov	r7,zero
 18297e0:	e1bfff17 	ldw	r6,-4(fp)
 18297e4:	e17ffe17 	ldw	r5,-8(fp)
 18297e8:	e13ffd17 	ldw	r4,-12(fp)
 18297ec:	18292e00 	call	18292e0 <lwip_recvfrom>
}
 18297f0:	e037883a 	mov	sp,fp
 18297f4:	dfc00117 	ldw	ra,4(sp)
 18297f8:	df000017 	ldw	fp,0(sp)
 18297fc:	dec00204 	addi	sp,sp,8
 1829800:	f800283a 	ret

01829804 <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
 1829804:	defff804 	addi	sp,sp,-32
 1829808:	dfc00715 	stw	ra,28(sp)
 182980c:	df000615 	stw	fp,24(sp)
 1829810:	df000604 	addi	fp,sp,24
 1829814:	e13ffc15 	stw	r4,-16(fp)
 1829818:	e17ffd15 	stw	r5,-12(fp)
 182981c:	e1bffe15 	stw	r6,-8(fp)
 1829820:	e1ffff15 	stw	r7,-4(fp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 1829824:	d8000115 	stw	zero,4(sp)
 1829828:	d8000015 	stw	zero,0(sp)
 182982c:	e1ffff17 	ldw	r7,-4(fp)
 1829830:	e1bffe17 	ldw	r6,-8(fp)
 1829834:	e17ffd17 	ldw	r5,-12(fp)
 1829838:	e13ffc17 	ldw	r4,-16(fp)
 182983c:	18292e00 	call	18292e0 <lwip_recvfrom>
}
 1829840:	e037883a 	mov	sp,fp
 1829844:	dfc00117 	ldw	ra,4(sp)
 1829848:	df000017 	ldw	fp,0(sp)
 182984c:	dec00204 	addi	sp,sp,8
 1829850:	f800283a 	ret

01829854 <lwip_send>:

int
lwip_send(int s, const void *data, size_t size, int flags)
{
 1829854:	defff504 	addi	sp,sp,-44
 1829858:	dfc00a15 	stw	ra,40(sp)
 182985c:	df000915 	stw	fp,36(sp)
 1829860:	df000904 	addi	fp,sp,36
 1829864:	e13ffc15 	stw	r4,-16(fp)
 1829868:	e17ffd15 	stw	r5,-12(fp)
 182986c:	e1bffe15 	stw	r6,-8(fp)
 1829870:	e1ffff15 	stw	r7,-4(fp)
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
 1829874:	e13ffc17 	ldw	r4,-16(fp)
 1829878:	18288400 	call	1828840 <get_socket>
 182987c:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 1829880:	e0bff917 	ldw	r2,-28(fp)
 1829884:	1000021e 	bne	r2,zero,1829890 <lwip_send+0x3c>
    return -1;
 1829888:	00bfffc4 	movi	r2,-1
 182988c:	00003d06 	br	1829984 <lwip_send+0x130>
  }

  if (sock->conn->type != NETCONN_TCP) {
 1829890:	e0bff917 	ldw	r2,-28(fp)
 1829894:	10800017 	ldw	r2,0(r2)
 1829898:	10800017 	ldw	r2,0(r2)
 182989c:	10800420 	cmpeqi	r2,r2,16
 18298a0:	1000081e 	bne	r2,zero,18298c4 <lwip_send+0x70>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
 18298a4:	d8000115 	stw	zero,4(sp)
 18298a8:	d8000015 	stw	zero,0(sp)
 18298ac:	e1ffff17 	ldw	r7,-4(fp)
 18298b0:	e1bffe17 	ldw	r6,-8(fp)
 18298b4:	e17ffd17 	ldw	r5,-12(fp)
 18298b8:	e13ffc17 	ldw	r4,-16(fp)
 18298bc:	18299980 	call	1829998 <lwip_sendto>
 18298c0:	00003006 	br	1829984 <lwip_send+0x130>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 18298c4:	e0bfff17 	ldw	r2,-4(fp)
 18298c8:	1080040c 	andi	r2,r2,16
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 18298cc:	10000226 	beq	r2,zero,18298d8 <lwip_send+0x84>
 18298d0:	008000c4 	movi	r2,3
 18298d4:	00000106 	br	18298dc <lwip_send+0x88>
 18298d8:	00800044 	movi	r2,1
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
 18298dc:	e0ffff17 	ldw	r3,-4(fp)
 18298e0:	18c0020c 	andi	r3,r3,8
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 18298e4:	18000226 	beq	r3,zero,18298f0 <lwip_send+0x9c>
 18298e8:	00c00104 	movi	r3,4
 18298ec:	00000106 	br	18298f4 <lwip_send+0xa0>
 18298f0:	0007883a 	mov	r3,zero
 18298f4:	10c4b03a 	or	r2,r2,r3
 18298f8:	e0bffa05 	stb	r2,-24(fp)
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
 18298fc:	e03ffb15 	stw	zero,-20(fp)
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
 1829900:	e0bff917 	ldw	r2,-28(fp)
 1829904:	10c00017 	ldw	r3,0(r2)
 1829908:	e13ffa03 	ldbu	r4,-24(fp)
 182990c:	e0bffb04 	addi	r2,fp,-20
 1829910:	d8800015 	stw	r2,0(sp)
 1829914:	200f883a 	mov	r7,r4
 1829918:	e1bffe17 	ldw	r6,-8(fp)
 182991c:	e17ffd17 	ldw	r5,-12(fp)
 1829920:	1809883a 	mov	r4,r3
 1829924:	183a2040 	call	183a204 <netconn_write_partly>
 1829928:	e0bffa45 	stb	r2,-23(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
 182992c:	e0bffa47 	ldb	r2,-23(fp)
 1829930:	0085c83a 	sub	r2,zero,r2
 1829934:	10800428 	cmpgeui	r2,r2,16
 1829938:	1000091e 	bne	r2,zero,1829960 <lwip_send+0x10c>
 182993c:	e0bffa47 	ldb	r2,-23(fp)
 1829940:	0087c83a 	sub	r3,zero,r2
 1829944:	00806134 	movhi	r2,388
 1829948:	10876104 	addi	r2,r2,7556
 182994c:	18c7883a 	add	r3,r3,r3
 1829950:	18c7883a 	add	r3,r3,r3
 1829954:	10c5883a 	add	r2,r2,r3
 1829958:	10800017 	ldw	r2,0(r2)
 182995c:	00000106 	br	1829964 <lwip_send+0x110>
 1829960:	00800144 	movi	r2,5
 1829964:	e0fff917 	ldw	r3,-28(fp)
 1829968:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? (int)written : -1);
 182996c:	e0bffa47 	ldb	r2,-23(fp)
 1829970:	1000021e 	bne	r2,zero,182997c <lwip_send+0x128>
 1829974:	e0bffb17 	ldw	r2,-20(fp)
 1829978:	00000206 	br	1829984 <lwip_send+0x130>
 182997c:	00bfffc4 	movi	r2,-1
 1829980:	0001883a 	nop
}
 1829984:	e037883a 	mov	sp,fp
 1829988:	dfc00117 	ldw	ra,4(sp)
 182998c:	df000017 	ldw	fp,0(sp)
 1829990:	dec00204 	addi	sp,sp,8
 1829994:	f800283a 	ret

01829998 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
 1829998:	defff004 	addi	sp,sp,-64
 182999c:	dfc00f15 	stw	ra,60(sp)
 18299a0:	df000e15 	stw	fp,56(sp)
 18299a4:	df000e04 	addi	fp,sp,56
 18299a8:	e13ffc15 	stw	r4,-16(fp)
 18299ac:	e17ffd15 	stw	r5,-12(fp)
 18299b0:	e1bffe15 	stw	r6,-8(fp)
 18299b4:	e1ffff15 	stw	r7,-4(fp)
  u16_t remote_port;
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
#endif

  sock = get_socket(s);
 18299b8:	e13ffc17 	ldw	r4,-16(fp)
 18299bc:	18288400 	call	1828840 <get_socket>
 18299c0:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 18299c4:	e0bff317 	ldw	r2,-52(fp)
 18299c8:	1000021e 	bne	r2,zero,18299d4 <lwip_sendto+0x3c>
    return -1;
 18299cc:	00bfffc4 	movi	r2,-1
 18299d0:	00006a06 	br	1829b7c <lwip_sendto+0x1e4>
  }

  if (sock->conn->type == NETCONN_TCP) {
 18299d4:	e0bff317 	ldw	r2,-52(fp)
 18299d8:	10800017 	ldw	r2,0(r2)
 18299dc:	10800017 	ldw	r2,0(r2)
 18299e0:	10800418 	cmpnei	r2,r2,16
 18299e4:	1000061e 	bne	r2,zero,1829a00 <lwip_sendto+0x68>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
 18299e8:	e1ffff17 	ldw	r7,-4(fp)
 18299ec:	e1bffe17 	ldw	r6,-8(fp)
 18299f0:	e17ffd17 	ldw	r5,-12(fp)
 18299f4:	e13ffc17 	ldw	r4,-16(fp)
 18299f8:	18298540 	call	1829854 <lwip_send>
 18299fc:	00005f06 	br	1829b7c <lwip_sendto+0x1e4>
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  short_size = (u16_t)size;
 1829a00:	e0bffe17 	ldw	r2,-8(fp)
 1829a04:	e0bff40d 	sth	r2,-48(fp)
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 1829a08:	e0800217 	ldw	r2,8(fp)
 1829a0c:	1000021e 	bne	r2,zero,1829a18 <lwip_sendto+0x80>
 1829a10:	e0800317 	ldw	r2,12(fp)
 1829a14:	10001426 	beq	r2,zero,1829a68 <lwip_sendto+0xd0>
 1829a18:	e0800317 	ldw	r2,12(fp)
 1829a1c:	10800418 	cmpnei	r2,r2,16
 1829a20:	1000081e 	bne	r2,zero,1829a44 <lwip_sendto+0xac>
 1829a24:	e0800217 	ldw	r2,8(fp)
 1829a28:	10800043 	ldbu	r2,1(r2)
 1829a2c:	10803fcc 	andi	r2,r2,255
 1829a30:	10800098 	cmpnei	r2,r2,2
 1829a34:	1000031e 	bne	r2,zero,1829a44 <lwip_sendto+0xac>
 1829a38:	e0800217 	ldw	r2,8(fp)
 1829a3c:	108000cc 	andi	r2,r2,3
 1829a40:	10000926 	beq	r2,zero,1829a68 <lwip_sendto+0xd0>
 1829a44:	01c06134 	movhi	r7,388
 1829a48:	39c77104 	addi	r7,r7,7620
 1829a4c:	0180cf44 	movi	r6,829
 1829a50:	01406134 	movhi	r5,388
 1829a54:	29479204 	addi	r5,r5,7752
 1829a58:	01006134 	movhi	r4,388
 1829a5c:	21077e04 	addi	r4,r4,7672
 1829a60:	1800c180 	call	1800c18 <printf>
 1829a64:	003fff06 	br	1829a64 <__ram_exceptions_end+0xff819620>
             ((tolen == sizeof(struct sockaddr_in)) &&
             ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  to_in = (const struct sockaddr_in *)(void*)to;
 1829a68:	e0800217 	ldw	r2,8(fp)
 1829a6c:	e0bff515 	stw	r2,-44(fp)
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
 1829a70:	e03ff815 	stw	zero,-32(fp)
 1829a74:	e0bff817 	ldw	r2,-32(fp)
 1829a78:	e0bff715 	stw	r2,-36(fp)
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
 1829a7c:	e03ffa85 	stb	zero,-22(fp)
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
 1829a80:	e0800217 	ldw	r2,8(fp)
 1829a84:	10001126 	beq	r2,zero,1829acc <lwip_sendto+0x134>
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
 1829a88:	e0bff517 	ldw	r2,-44(fp)
 1829a8c:	10800117 	ldw	r2,4(r2)
 1829a90:	e0bff915 	stw	r2,-28(fp)
    remote_port           = ntohs(to_in->sin_port);
 1829a94:	e0bff517 	ldw	r2,-44(fp)
 1829a98:	1080008b 	ldhu	r2,2(r2)
 1829a9c:	10bfffcc 	andi	r2,r2,65535
 1829aa0:	1004d23a 	srli	r2,r2,8
 1829aa4:	1007883a 	mov	r3,r2
 1829aa8:	e0bff517 	ldw	r2,-44(fp)
 1829aac:	1080008b 	ldhu	r2,2(r2)
 1829ab0:	10bfffcc 	andi	r2,r2,65535
 1829ab4:	1004923a 	slli	r2,r2,8
 1829ab8:	1884b03a 	or	r2,r3,r2
 1829abc:	e0bff60d 	sth	r2,-40(fp)
    netbuf_fromport(&buf) = remote_port;
 1829ac0:	e0bff60b 	ldhu	r2,-40(fp)
 1829ac4:	e0bffa0d 	sth	r2,-24(fp)
 1829ac8:	00000306 	br	1829ad8 <lwip_sendto+0x140>
  } else {
    remote_port           = 0;
 1829acc:	e03ff60d 	sth	zero,-40(fp)
    ip_addr_set_any(&buf.addr);
 1829ad0:	e03ff915 	stw	zero,-28(fp)
    netbuf_fromport(&buf) = 0;
 1829ad4:	e03ffa0d 	sth	zero,-24(fp)
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 1829ad8:	e0fff40b 	ldhu	r3,-48(fp)
 1829adc:	e0bff704 	addi	r2,fp,-36
 1829ae0:	180d883a 	mov	r6,r3
 1829ae4:	e17ffd17 	ldw	r5,-12(fp)
 1829ae8:	1009883a 	mov	r4,r2
 1829aec:	183cc240 	call	183cc24 <netbuf_ref>
 1829af0:	e0bff205 	stb	r2,-56(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
 1829af4:	e0bff207 	ldb	r2,-56(fp)
 1829af8:	1000071e 	bne	r2,zero,1829b18 <lwip_sendto+0x180>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
 1829afc:	e0bff317 	ldw	r2,-52(fp)
 1829b00:	10800017 	ldw	r2,0(r2)
 1829b04:	e0fff704 	addi	r3,fp,-36
 1829b08:	180b883a 	mov	r5,r3
 1829b0c:	1009883a 	mov	r4,r2
 1829b10:	183a13c0 	call	183a13c <netconn_send>
 1829b14:	e0bff205 	stb	r2,-56(fp)
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
 1829b18:	e0bff704 	addi	r2,fp,-36
 1829b1c:	1009883a 	mov	r4,r2
 1829b20:	183cb980 	call	183cb98 <netbuf_free>
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
 1829b24:	e0bff207 	ldb	r2,-56(fp)
 1829b28:	0085c83a 	sub	r2,zero,r2
 1829b2c:	10800428 	cmpgeui	r2,r2,16
 1829b30:	1000091e 	bne	r2,zero,1829b58 <lwip_sendto+0x1c0>
 1829b34:	e0bff207 	ldb	r2,-56(fp)
 1829b38:	0087c83a 	sub	r3,zero,r2
 1829b3c:	00806134 	movhi	r2,388
 1829b40:	10876104 	addi	r2,r2,7556
 1829b44:	18c7883a 	add	r3,r3,r3
 1829b48:	18c7883a 	add	r3,r3,r3
 1829b4c:	10c5883a 	add	r2,r2,r3
 1829b50:	10800017 	ldw	r2,0(r2)
 1829b54:	00000106 	br	1829b5c <lwip_sendto+0x1c4>
 1829b58:	00800144 	movi	r2,5
 1829b5c:	e0fff317 	ldw	r3,-52(fp)
 1829b60:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? short_size : -1);
 1829b64:	e0bff207 	ldb	r2,-56(fp)
 1829b68:	1000021e 	bne	r2,zero,1829b74 <lwip_sendto+0x1dc>
 1829b6c:	e0bff40b 	ldhu	r2,-48(fp)
 1829b70:	00000206 	br	1829b7c <lwip_sendto+0x1e4>
 1829b74:	00bfffc4 	movi	r2,-1
 1829b78:	0001883a 	nop
}
 1829b7c:	e037883a 	mov	sp,fp
 1829b80:	dfc00117 	ldw	ra,4(sp)
 1829b84:	df000017 	ldw	fp,0(sp)
 1829b88:	dec00204 	addi	sp,sp,8
 1829b8c:	f800283a 	ret

01829b90 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
 1829b90:	defff904 	addi	sp,sp,-28
 1829b94:	dfc00615 	stw	ra,24(sp)
 1829b98:	df000515 	stw	fp,20(sp)
 1829b9c:	df000504 	addi	fp,sp,20
 1829ba0:	e13ffd15 	stw	r4,-12(fp)
 1829ba4:	e17ffe15 	stw	r5,-8(fp)
 1829ba8:	e1bfff15 	stw	r6,-4(fp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
 1829bac:	e0bffe17 	ldw	r2,-8(fp)
 1829bb0:	10c000a0 	cmpeqi	r3,r2,2
 1829bb4:	18000e1e 	bne	r3,zero,1829bf0 <lwip_socket+0x60>
 1829bb8:	10c000e0 	cmpeqi	r3,r2,3
 1829bbc:	1800031e 	bne	r3,zero,1829bcc <lwip_socket+0x3c>
 1829bc0:	10800060 	cmpeqi	r2,r2,1
 1829bc4:	1000171e 	bne	r2,zero,1829c24 <lwip_socket+0x94>
 1829bc8:	00002506 	br	1829c60 <lwip_socket+0xd0>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
 1829bcc:	e0bfff17 	ldw	r2,-4(fp)
 1829bd0:	10803fcc 	andi	r2,r2,255
 1829bd4:	018060f4 	movhi	r6,387
 1829bd8:	31a95f04 	addi	r6,r6,-23172
 1829bdc:	100b883a 	mov	r5,r2
 1829be0:	01001004 	movi	r4,64
 1829be4:	18394040 	call	1839404 <netconn_new_with_proto_and_callback>
 1829be8:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
 1829bec:	00001f06 	br	1829c6c <lwip_socket+0xdc>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
 1829bf0:	e0bfff17 	ldw	r2,-4(fp)
 1829bf4:	10802218 	cmpnei	r2,r2,136
 1829bf8:	1000021e 	bne	r2,zero,1829c04 <lwip_socket+0x74>
 1829bfc:	00800844 	movi	r2,33
 1829c00:	00000106 	br	1829c08 <lwip_socket+0x78>
 1829c04:	00800804 	movi	r2,32
 1829c08:	018060f4 	movhi	r6,387
 1829c0c:	31a95f04 	addi	r6,r6,-23172
 1829c10:	000b883a 	mov	r5,zero
 1829c14:	1009883a 	mov	r4,r2
 1829c18:	18394040 	call	1839404 <netconn_new_with_proto_and_callback>
 1829c1c:	e0bffb15 	stw	r2,-20(fp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
 1829c20:	00001206 	br	1829c6c <lwip_socket+0xdc>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
 1829c24:	018060f4 	movhi	r6,387
 1829c28:	31a95f04 	addi	r6,r6,-23172
 1829c2c:	000b883a 	mov	r5,zero
 1829c30:	01000404 	movi	r4,16
 1829c34:	18394040 	call	1839404 <netconn_new_with_proto_and_callback>
 1829c38:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
 1829c3c:	e0bffb17 	ldw	r2,-20(fp)
 1829c40:	10000926 	beq	r2,zero,1829c68 <lwip_socket+0xd8>
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
 1829c44:	e0bffb17 	ldw	r2,-20(fp)
 1829c48:	10800903 	ldbu	r2,36(r2)
 1829c4c:	10800214 	ori	r2,r2,8
 1829c50:	1007883a 	mov	r3,r2
 1829c54:	e0bffb17 	ldw	r2,-20(fp)
 1829c58:	10c00905 	stb	r3,36(r2)
    }
    break;
 1829c5c:	00000206 	br	1829c68 <lwip_socket+0xd8>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
 1829c60:	00bfffc4 	movi	r2,-1
 1829c64:	00001706 	br	1829cc4 <lwip_socket+0x134>
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
    }
    break;
 1829c68:	0001883a 	nop
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
 1829c6c:	e0bffb17 	ldw	r2,-20(fp)
 1829c70:	1000021e 	bne	r2,zero,1829c7c <lwip_socket+0xec>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
 1829c74:	00bfffc4 	movi	r2,-1
 1829c78:	00001206 	br	1829cc4 <lwip_socket+0x134>
  }

  i = alloc_socket(conn, 0);
 1829c7c:	000b883a 	mov	r5,zero
 1829c80:	e13ffb17 	ldw	r4,-20(fp)
 1829c84:	18289380 	call	1828938 <alloc_socket>
 1829c88:	e0bffc15 	stw	r2,-16(fp)

  if (i == -1) {
 1829c8c:	e0bffc17 	ldw	r2,-16(fp)
 1829c90:	10bfffd8 	cmpnei	r2,r2,-1
 1829c94:	1000041e 	bne	r2,zero,1829ca8 <lwip_socket+0x118>
    netconn_delete(conn);
 1829c98:	e13ffb17 	ldw	r4,-20(fp)
 1829c9c:	18394c00 	call	18394c0 <netconn_delete>
    set_errno(ENFILE);
    return -1;
 1829ca0:	00bfffc4 	movi	r2,-1
 1829ca4:	00000706 	br	1829cc4 <lwip_socket+0x134>
  }

  i += LWIP_SOCKET_OFFSET;
 1829ca8:	e0bffc17 	ldw	r2,-16(fp)
 1829cac:	10800804 	addi	r2,r2,32
 1829cb0:	e0bffc15 	stw	r2,-16(fp)

  conn->socket = i;
 1829cb4:	e0bffb17 	ldw	r2,-20(fp)
 1829cb8:	e0fffc17 	ldw	r3,-16(fp)
 1829cbc:	10c00715 	stw	r3,28(r2)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
 1829cc0:	e0bffc17 	ldw	r2,-16(fp)
}
 1829cc4:	e037883a 	mov	sp,fp
 1829cc8:	dfc00117 	ldw	ra,4(sp)
 1829ccc:	df000017 	ldw	fp,0(sp)
 1829cd0:	dec00204 	addi	sp,sp,8
 1829cd4:	f800283a 	ret

01829cd8 <lwip_write>:

int
lwip_write(int s, const void *data, size_t size)
{
 1829cd8:	defffb04 	addi	sp,sp,-20
 1829cdc:	dfc00415 	stw	ra,16(sp)
 1829ce0:	df000315 	stw	fp,12(sp)
 1829ce4:	df000304 	addi	fp,sp,12
 1829ce8:	e13ffd15 	stw	r4,-12(fp)
 1829cec:	e17ffe15 	stw	r5,-8(fp)
 1829cf0:	e1bfff15 	stw	r6,-4(fp)
  return lwip_send(s, data, size, 0);
 1829cf4:	000f883a 	mov	r7,zero
 1829cf8:	e1bfff17 	ldw	r6,-4(fp)
 1829cfc:	e17ffe17 	ldw	r5,-8(fp)
 1829d00:	e13ffd17 	ldw	r4,-12(fp)
 1829d04:	18298540 	call	1829854 <lwip_send>
}
 1829d08:	e037883a 	mov	sp,fp
 1829d0c:	dfc00117 	ldw	ra,4(sp)
 1829d10:	df000017 	ldw	fp,0(sp)
 1829d14:	dec00204 	addi	sp,sp,8
 1829d18:	f800283a 	ret

01829d1c <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
 1829d1c:	deffe804 	addi	sp,sp,-96
 1829d20:	dfc01715 	stw	ra,92(sp)
 1829d24:	df001615 	stw	fp,88(sp)
 1829d28:	df001604 	addi	fp,sp,88
 1829d2c:	e13ffc15 	stw	r4,-16(fp)
 1829d30:	e17ffd15 	stw	r5,-12(fp)
 1829d34:	e1bffe15 	stw	r6,-8(fp)
 1829d38:	e1ffff15 	stw	r7,-4(fp)
  int i, nready = 0;
 1829d3c:	e03feb15 	stw	zero,-84(fp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
 1829d40:	e0bff604 	addi	r2,fp,-40
 1829d44:	e0bfed15 	stw	r2,-76(fp)
 1829d48:	e03fec15 	stw	zero,-80(fp)
 1829d4c:	00000706 	br	1829d6c <lwip_selscan+0x50>
 1829d50:	e0bfed17 	ldw	r2,-76(fp)
 1829d54:	10c00044 	addi	r3,r2,1
 1829d58:	e0ffed15 	stw	r3,-76(fp)
 1829d5c:	10000005 	stb	zero,0(r2)
 1829d60:	e0bfec17 	ldw	r2,-80(fp)
 1829d64:	10800044 	addi	r2,r2,1
 1829d68:	e0bfec15 	stw	r2,-80(fp)
 1829d6c:	e0bfec17 	ldw	r2,-80(fp)
 1829d70:	10800230 	cmpltui	r2,r2,8
 1829d74:	103ff61e 	bne	r2,zero,1829d50 <__ram_exceptions_end+0xff81990c>
  FD_ZERO(&lwriteset);
 1829d78:	e0bff804 	addi	r2,fp,-32
 1829d7c:	e0bfef15 	stw	r2,-68(fp)
 1829d80:	e03fee15 	stw	zero,-72(fp)
 1829d84:	00000706 	br	1829da4 <lwip_selscan+0x88>
 1829d88:	e0bfef17 	ldw	r2,-68(fp)
 1829d8c:	10c00044 	addi	r3,r2,1
 1829d90:	e0ffef15 	stw	r3,-68(fp)
 1829d94:	10000005 	stb	zero,0(r2)
 1829d98:	e0bfee17 	ldw	r2,-72(fp)
 1829d9c:	10800044 	addi	r2,r2,1
 1829da0:	e0bfee15 	stw	r2,-72(fp)
 1829da4:	e0bfee17 	ldw	r2,-72(fp)
 1829da8:	10800230 	cmpltui	r2,r2,8
 1829dac:	103ff61e 	bne	r2,zero,1829d88 <__ram_exceptions_end+0xff819944>
  FD_ZERO(&lexceptset);
 1829db0:	e0bffa04 	addi	r2,fp,-24
 1829db4:	e0bff115 	stw	r2,-60(fp)
 1829db8:	e03ff015 	stw	zero,-64(fp)
 1829dbc:	00000706 	br	1829ddc <lwip_selscan+0xc0>
 1829dc0:	e0bff117 	ldw	r2,-60(fp)
 1829dc4:	10c00044 	addi	r3,r2,1
 1829dc8:	e0fff115 	stw	r3,-60(fp)
 1829dcc:	10000005 	stb	zero,0(r2)
 1829dd0:	e0bff017 	ldw	r2,-64(fp)
 1829dd4:	10800044 	addi	r2,r2,1
 1829dd8:	e0bff015 	stw	r2,-64(fp)
 1829ddc:	e0bff017 	ldw	r2,-64(fp)
 1829de0:	10800230 	cmpltui	r2,r2,8
 1829de4:	103ff61e 	bne	r2,zero,1829dc0 <__ram_exceptions_end+0xff81997c>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 1829de8:	00800804 	movi	r2,32
 1829dec:	e0bfea15 	stw	r2,-88(fp)
 1829df0:	00009206 	br	182a03c <lwip_selscan+0x320>
    void* lastdata = NULL;
 1829df4:	e03ff215 	stw	zero,-56(fp)
    s16_t rcvevent = 0;
 1829df8:	e03ff30d 	sth	zero,-52(fp)
    u16_t sendevent = 0;
 1829dfc:	e03ff38d 	sth	zero,-50(fp)
    u16_t errevent = 0;
 1829e00:	e03ff40d 	sth	zero,-48(fp)
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
 1829e04:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1829e08:	10000126 	beq	r2,zero,1829e10 <lwip_selscan+0xf4>
 1829e0c:	181103c0 	call	181103c <vTaskEnterCritical>
    sock = tryget_socket(i);
 1829e10:	e13fea17 	ldw	r4,-88(fp)
 1829e14:	18288b80 	call	18288b8 <tryget_socket>
 1829e18:	e0bff515 	stw	r2,-44(fp)
    if (sock != NULL) {
 1829e1c:	e0bff517 	ldw	r2,-44(fp)
 1829e20:	10000c26 	beq	r2,zero,1829e54 <lwip_selscan+0x138>
      lastdata = sock->lastdata;
 1829e24:	e0bff517 	ldw	r2,-44(fp)
 1829e28:	10800117 	ldw	r2,4(r2)
 1829e2c:	e0bff215 	stw	r2,-56(fp)
      rcvevent = sock->rcvevent;
 1829e30:	e0bff517 	ldw	r2,-44(fp)
 1829e34:	1080028b 	ldhu	r2,10(r2)
 1829e38:	e0bff30d 	sth	r2,-52(fp)
      sendevent = sock->sendevent;
 1829e3c:	e0bff517 	ldw	r2,-44(fp)
 1829e40:	1080030b 	ldhu	r2,12(r2)
 1829e44:	e0bff38d 	sth	r2,-50(fp)
      errevent = sock->errevent;
 1829e48:	e0bff517 	ldw	r2,-44(fp)
 1829e4c:	1080038b 	ldhu	r2,14(r2)
 1829e50:	e0bff40d 	sth	r2,-48(fp)
    }
    SYS_ARCH_UNPROTECT(lev);
 1829e54:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1829e58:	10000126 	beq	r2,zero,1829e60 <lwip_selscan+0x144>
 1829e5c:	18110840 	call	1811084 <vTaskExitCritical>
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 1829e60:	e0bffd17 	ldw	r2,-12(fp)
 1829e64:	10002626 	beq	r2,zero,1829f00 <lwip_selscan+0x1e4>
 1829e68:	e0bfea17 	ldw	r2,-88(fp)
 1829e6c:	1004d17a 	srli	r2,r2,5
 1829e70:	e0fffd17 	ldw	r3,-12(fp)
 1829e74:	1085883a 	add	r2,r2,r2
 1829e78:	1085883a 	add	r2,r2,r2
 1829e7c:	1885883a 	add	r2,r3,r2
 1829e80:	10c00017 	ldw	r3,0(r2)
 1829e84:	e0bfea17 	ldw	r2,-88(fp)
 1829e88:	108007cc 	andi	r2,r2,31
 1829e8c:	1885d83a 	sra	r2,r3,r2
 1829e90:	1080004c 	andi	r2,r2,1
 1829e94:	10001a26 	beq	r2,zero,1829f00 <lwip_selscan+0x1e4>
 1829e98:	e0bff217 	ldw	r2,-56(fp)
 1829e9c:	1000021e 	bne	r2,zero,1829ea8 <lwip_selscan+0x18c>
 1829ea0:	e0bff30f 	ldh	r2,-52(fp)
 1829ea4:	0080160e 	bge	zero,r2,1829f00 <lwip_selscan+0x1e4>
      FD_SET(i, &lreadset);
 1829ea8:	e0bfea17 	ldw	r2,-88(fp)
 1829eac:	1004d17a 	srli	r2,r2,5
 1829eb0:	1087883a 	add	r3,r2,r2
 1829eb4:	18c7883a 	add	r3,r3,r3
 1829eb8:	e13fea04 	addi	r4,fp,-88
 1829ebc:	20c7883a 	add	r3,r4,r3
 1829ec0:	18c00c04 	addi	r3,r3,48
 1829ec4:	19000017 	ldw	r4,0(r3)
 1829ec8:	e0ffea17 	ldw	r3,-88(fp)
 1829ecc:	18c007cc 	andi	r3,r3,31
 1829ed0:	01400044 	movi	r5,1
 1829ed4:	28c6983a 	sll	r3,r5,r3
 1829ed8:	20c6b03a 	or	r3,r4,r3
 1829edc:	1085883a 	add	r2,r2,r2
 1829ee0:	1085883a 	add	r2,r2,r2
 1829ee4:	e13fea04 	addi	r4,fp,-88
 1829ee8:	2085883a 	add	r2,r4,r2
 1829eec:	10800c04 	addi	r2,r2,48
 1829ef0:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
 1829ef4:	e0bfeb17 	ldw	r2,-84(fp)
 1829ef8:	10800044 	addi	r2,r2,1
 1829efc:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
 1829f00:	e0bffe17 	ldw	r2,-8(fp)
 1829f04:	10002426 	beq	r2,zero,1829f98 <lwip_selscan+0x27c>
 1829f08:	e0bfea17 	ldw	r2,-88(fp)
 1829f0c:	1004d17a 	srli	r2,r2,5
 1829f10:	e0fffe17 	ldw	r3,-8(fp)
 1829f14:	1085883a 	add	r2,r2,r2
 1829f18:	1085883a 	add	r2,r2,r2
 1829f1c:	1885883a 	add	r2,r3,r2
 1829f20:	10c00017 	ldw	r3,0(r2)
 1829f24:	e0bfea17 	ldw	r2,-88(fp)
 1829f28:	108007cc 	andi	r2,r2,31
 1829f2c:	1885d83a 	sra	r2,r3,r2
 1829f30:	1080004c 	andi	r2,r2,1
 1829f34:	10001826 	beq	r2,zero,1829f98 <lwip_selscan+0x27c>
 1829f38:	e0bff38b 	ldhu	r2,-50(fp)
 1829f3c:	10001626 	beq	r2,zero,1829f98 <lwip_selscan+0x27c>
      FD_SET(i, &lwriteset);
 1829f40:	e0bfea17 	ldw	r2,-88(fp)
 1829f44:	1004d17a 	srli	r2,r2,5
 1829f48:	1087883a 	add	r3,r2,r2
 1829f4c:	18c7883a 	add	r3,r3,r3
 1829f50:	e13fea04 	addi	r4,fp,-88
 1829f54:	20c7883a 	add	r3,r4,r3
 1829f58:	18c00e04 	addi	r3,r3,56
 1829f5c:	19000017 	ldw	r4,0(r3)
 1829f60:	e0ffea17 	ldw	r3,-88(fp)
 1829f64:	18c007cc 	andi	r3,r3,31
 1829f68:	01400044 	movi	r5,1
 1829f6c:	28c6983a 	sll	r3,r5,r3
 1829f70:	20c6b03a 	or	r3,r4,r3
 1829f74:	1085883a 	add	r2,r2,r2
 1829f78:	1085883a 	add	r2,r2,r2
 1829f7c:	e13fea04 	addi	r4,fp,-88
 1829f80:	2085883a 	add	r2,r4,r2
 1829f84:	10800e04 	addi	r2,r2,56
 1829f88:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
 1829f8c:	e0bfeb17 	ldw	r2,-84(fp)
 1829f90:	10800044 	addi	r2,r2,1
 1829f94:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
 1829f98:	e0bfff17 	ldw	r2,-4(fp)
 1829f9c:	10002426 	beq	r2,zero,182a030 <lwip_selscan+0x314>
 1829fa0:	e0bfea17 	ldw	r2,-88(fp)
 1829fa4:	1004d17a 	srli	r2,r2,5
 1829fa8:	e0ffff17 	ldw	r3,-4(fp)
 1829fac:	1085883a 	add	r2,r2,r2
 1829fb0:	1085883a 	add	r2,r2,r2
 1829fb4:	1885883a 	add	r2,r3,r2
 1829fb8:	10c00017 	ldw	r3,0(r2)
 1829fbc:	e0bfea17 	ldw	r2,-88(fp)
 1829fc0:	108007cc 	andi	r2,r2,31
 1829fc4:	1885d83a 	sra	r2,r3,r2
 1829fc8:	1080004c 	andi	r2,r2,1
 1829fcc:	10001826 	beq	r2,zero,182a030 <lwip_selscan+0x314>
 1829fd0:	e0bff40b 	ldhu	r2,-48(fp)
 1829fd4:	10001626 	beq	r2,zero,182a030 <lwip_selscan+0x314>
      FD_SET(i, &lexceptset);
 1829fd8:	e0bfea17 	ldw	r2,-88(fp)
 1829fdc:	1004d17a 	srli	r2,r2,5
 1829fe0:	1087883a 	add	r3,r2,r2
 1829fe4:	18c7883a 	add	r3,r3,r3
 1829fe8:	e13fea04 	addi	r4,fp,-88
 1829fec:	20c7883a 	add	r3,r4,r3
 1829ff0:	18c01004 	addi	r3,r3,64
 1829ff4:	19000017 	ldw	r4,0(r3)
 1829ff8:	e0ffea17 	ldw	r3,-88(fp)
 1829ffc:	18c007cc 	andi	r3,r3,31
 182a000:	01400044 	movi	r5,1
 182a004:	28c6983a 	sll	r3,r5,r3
 182a008:	20c6b03a 	or	r3,r4,r3
 182a00c:	1085883a 	add	r2,r2,r2
 182a010:	1085883a 	add	r2,r2,r2
 182a014:	e13fea04 	addi	r4,fp,-88
 182a018:	2085883a 	add	r2,r4,r2
 182a01c:	10801004 	addi	r2,r2,64
 182a020:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
 182a024:	e0bfeb17 	ldw	r2,-84(fp)
 182a028:	10800044 	addi	r2,r2,1
 182a02c:	e0bfeb15 	stw	r2,-84(fp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 182a030:	e0bfea17 	ldw	r2,-88(fp)
 182a034:	10800044 	addi	r2,r2,1
 182a038:	e0bfea15 	stw	r2,-88(fp)
 182a03c:	e0ffea17 	ldw	r3,-88(fp)
 182a040:	e0bffc17 	ldw	r2,-16(fp)
 182a044:	18bf6b16 	blt	r3,r2,1829df4 <__ram_exceptions_end+0xff8199b0>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
 182a048:	e0800217 	ldw	r2,8(fp)
 182a04c:	e0fff617 	ldw	r3,-40(fp)
 182a050:	10c00015 	stw	r3,0(r2)
 182a054:	e0fff717 	ldw	r3,-36(fp)
 182a058:	10c00115 	stw	r3,4(r2)
  *writeset_out = lwriteset;
 182a05c:	e0800317 	ldw	r2,12(fp)
 182a060:	e0fff817 	ldw	r3,-32(fp)
 182a064:	10c00015 	stw	r3,0(r2)
 182a068:	e0fff917 	ldw	r3,-28(fp)
 182a06c:	10c00115 	stw	r3,4(r2)
  *exceptset_out = lexceptset;
 182a070:	e0800417 	ldw	r2,16(fp)
 182a074:	e0fffa17 	ldw	r3,-24(fp)
 182a078:	10c00015 	stw	r3,0(r2)
 182a07c:	e0fffb17 	ldw	r3,-20(fp)
 182a080:	10c00115 	stw	r3,4(r2)

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
 182a084:	e0bfeb17 	ldw	r2,-84(fp)
}
 182a088:	e037883a 	mov	sp,fp
 182a08c:	dfc00117 	ldw	ra,4(sp)
 182a090:	df000017 	ldw	fp,0(sp)
 182a094:	dec00204 	addi	sp,sp,8
 182a098:	f800283a 	ret

0182a09c <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
 182a09c:	deffe204 	addi	sp,sp,-120
 182a0a0:	dfc01d15 	stw	ra,116(sp)
 182a0a4:	df001c15 	stw	fp,112(sp)
 182a0a8:	dc001b15 	stw	r16,108(sp)
 182a0ac:	df001c04 	addi	fp,sp,112
 182a0b0:	e13ffb15 	stw	r4,-20(fp)
 182a0b4:	e17ffc15 	stw	r5,-16(fp)
 182a0b8:	e1bffd15 	stw	r6,-12(fp)
 182a0bc:	e1fffe15 	stw	r7,-8(fp)
  u32_t waitres = 0;
 182a0c0:	e03fe715 	stw	zero,-100(fp)
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 182a0c4:	e0bff204 	addi	r2,fp,-56
 182a0c8:	d8800215 	stw	r2,8(sp)
 182a0cc:	e0bff004 	addi	r2,fp,-64
 182a0d0:	d8800115 	stw	r2,4(sp)
 182a0d4:	e0bfee04 	addi	r2,fp,-72
 182a0d8:	d8800015 	stw	r2,0(sp)
 182a0dc:	e1fffe17 	ldw	r7,-8(fp)
 182a0e0:	e1bffd17 	ldw	r6,-12(fp)
 182a0e4:	e17ffc17 	ldw	r5,-16(fp)
 182a0e8:	e13ffb17 	ldw	r4,-20(fp)
 182a0ec:	1829d1c0 	call	1829d1c <lwip_selscan>
 182a0f0:	e0bfe815 	stw	r2,-96(fp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
 182a0f4:	e0bfe817 	ldw	r2,-96(fp)
 182a0f8:	1001041e 	bne	r2,zero,182a50c <lwip_select+0x470>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
 182a0fc:	e0800217 	ldw	r2,8(fp)
 182a100:	10000626 	beq	r2,zero,182a11c <lwip_select+0x80>
 182a104:	e0800217 	ldw	r2,8(fp)
 182a108:	10800017 	ldw	r2,0(r2)
 182a10c:	1000031e 	bne	r2,zero,182a11c <lwip_select+0x80>
 182a110:	e0800217 	ldw	r2,8(fp)
 182a114:	10800117 	ldw	r2,4(r2)
 182a118:	1000f926 	beq	r2,zero,182a500 <lwip_select+0x464>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
 182a11c:	e03ff415 	stw	zero,-48(fp)
    select_cb.prev = NULL;
 182a120:	e03ff515 	stw	zero,-44(fp)
    select_cb.readset = readset;
 182a124:	e0bffc17 	ldw	r2,-16(fp)
 182a128:	e0bff615 	stw	r2,-40(fp)
    select_cb.writeset = writeset;
 182a12c:	e0bffd17 	ldw	r2,-12(fp)
 182a130:	e0bff715 	stw	r2,-36(fp)
    select_cb.exceptset = exceptset;
 182a134:	e0bffe17 	ldw	r2,-8(fp)
 182a138:	e0bff815 	stw	r2,-32(fp)
    select_cb.sem_signalled = 0;
 182a13c:	e03ff915 	stw	zero,-28(fp)
    err = sys_sem_new(&select_cb.sem, 0);
 182a140:	e0bff404 	addi	r2,fp,-48
 182a144:	10800604 	addi	r2,r2,24
 182a148:	000b883a 	mov	r5,zero
 182a14c:	1009883a 	mov	r4,r2
 182a150:	1814f380 	call	1814f38 <sys_sem_new>
 182a154:	e0bfeb05 	stb	r2,-84(fp)
    if (err != ERR_OK) {
 182a158:	e0bfeb07 	ldb	r2,-84(fp)
 182a15c:	10000226 	beq	r2,zero,182a168 <lwip_select+0xcc>
      /* failed to create semaphore */
      set_errno(ENOMEM);
      return -1;
 182a160:	00bfffc4 	movi	r2,-1
 182a164:	0000ff06 	br	182a564 <lwip_select+0x4c8>
    }

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
 182a168:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a16c:	10000126 	beq	r2,zero,182a174 <lwip_select+0xd8>
 182a170:	181103c0 	call	181103c <vTaskEnterCritical>

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
 182a174:	d0a80b17 	ldw	r2,-24532(gp)
 182a178:	e0bff415 	stw	r2,-48(fp)
    if (select_cb_list != NULL) {
 182a17c:	d0a80b17 	ldw	r2,-24532(gp)
 182a180:	10000326 	beq	r2,zero,182a190 <lwip_select+0xf4>
      select_cb_list->prev = &select_cb;
 182a184:	d0a80b17 	ldw	r2,-24532(gp)
 182a188:	e0fff404 	addi	r3,fp,-48
 182a18c:	10c00115 	stw	r3,4(r2)
    }
    select_cb_list = &select_cb;
 182a190:	e0bff404 	addi	r2,fp,-48
 182a194:	d0a80b15 	stw	r2,-24532(gp)
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 182a198:	d0a80c17 	ldw	r2,-24528(gp)
 182a19c:	10800044 	addi	r2,r2,1
 182a1a0:	d0a80c15 	stw	r2,-24528(gp)

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
 182a1a4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a1a8:	10000126 	beq	r2,zero,182a1b0 <lwip_select+0x114>
 182a1ac:	18110840 	call	1811084 <vTaskExitCritical>

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 182a1b0:	00800804 	movi	r2,32
 182a1b4:	e0bfea15 	stw	r2,-88(fp)
 182a1b8:	00003b06 	br	182a2a8 <lwip_select+0x20c>
      if ((readset && FD_ISSET(i, readset)) ||
 182a1bc:	e0bffc17 	ldw	r2,-16(fp)
 182a1c0:	10000c26 	beq	r2,zero,182a1f4 <lwip_select+0x158>
 182a1c4:	e0bfea17 	ldw	r2,-88(fp)
 182a1c8:	1004d17a 	srli	r2,r2,5
 182a1cc:	e0fffc17 	ldw	r3,-16(fp)
 182a1d0:	1085883a 	add	r2,r2,r2
 182a1d4:	1085883a 	add	r2,r2,r2
 182a1d8:	1885883a 	add	r2,r3,r2
 182a1dc:	10c00017 	ldw	r3,0(r2)
 182a1e0:	e0bfea17 	ldw	r2,-88(fp)
 182a1e4:	108007cc 	andi	r2,r2,31
 182a1e8:	1885d83a 	sra	r2,r3,r2
 182a1ec:	1080004c 	andi	r2,r2,1
 182a1f0:	10001c1e 	bne	r2,zero,182a264 <lwip_select+0x1c8>
 182a1f4:	e0bffd17 	ldw	r2,-12(fp)
 182a1f8:	10000c26 	beq	r2,zero,182a22c <lwip_select+0x190>
          (writeset && FD_ISSET(i, writeset)) ||
 182a1fc:	e0bfea17 	ldw	r2,-88(fp)
 182a200:	1004d17a 	srli	r2,r2,5
 182a204:	e0fffd17 	ldw	r3,-12(fp)
 182a208:	1085883a 	add	r2,r2,r2
 182a20c:	1085883a 	add	r2,r2,r2
 182a210:	1885883a 	add	r2,r3,r2
 182a214:	10c00017 	ldw	r3,0(r2)
 182a218:	e0bfea17 	ldw	r2,-88(fp)
 182a21c:	108007cc 	andi	r2,r2,31
 182a220:	1885d83a 	sra	r2,r3,r2
 182a224:	1080004c 	andi	r2,r2,1
 182a228:	10000e1e 	bne	r2,zero,182a264 <lwip_select+0x1c8>
 182a22c:	e0bffe17 	ldw	r2,-8(fp)
 182a230:	10001a26 	beq	r2,zero,182a29c <lwip_select+0x200>
          (exceptset && FD_ISSET(i, exceptset))) {
 182a234:	e0bfea17 	ldw	r2,-88(fp)
 182a238:	1004d17a 	srli	r2,r2,5
 182a23c:	e0fffe17 	ldw	r3,-8(fp)
 182a240:	1085883a 	add	r2,r2,r2
 182a244:	1085883a 	add	r2,r2,r2
 182a248:	1885883a 	add	r2,r3,r2
 182a24c:	10c00017 	ldw	r3,0(r2)
 182a250:	e0bfea17 	ldw	r2,-88(fp)
 182a254:	108007cc 	andi	r2,r2,31
 182a258:	1885d83a 	sra	r2,r3,r2
 182a25c:	1080004c 	andi	r2,r2,1
 182a260:	10000e26 	beq	r2,zero,182a29c <lwip_select+0x200>
        struct lwip_sock *sock = tryget_socket(i);
 182a264:	e13fea17 	ldw	r4,-88(fp)
 182a268:	18288b80 	call	18288b8 <tryget_socket>
 182a26c:	e0bfec15 	stw	r2,-80(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 182a270:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a274:	10000126 	beq	r2,zero,182a27c <lwip_select+0x1e0>
 182a278:	181103c0 	call	181103c <vTaskEnterCritical>
        sock->select_waiting++;
 182a27c:	e0bfec17 	ldw	r2,-80(fp)
 182a280:	10800517 	ldw	r2,20(r2)
 182a284:	10c00044 	addi	r3,r2,1
 182a288:	e0bfec17 	ldw	r2,-80(fp)
 182a28c:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
        SYS_ARCH_UNPROTECT(lev);
 182a290:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a294:	10000126 	beq	r2,zero,182a29c <lwip_select+0x200>
 182a298:	18110840 	call	1811084 <vTaskExitCritical>

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 182a29c:	e0bfea17 	ldw	r2,-88(fp)
 182a2a0:	10800044 	addi	r2,r2,1
 182a2a4:	e0bfea15 	stw	r2,-88(fp)
 182a2a8:	e0ffea17 	ldw	r3,-88(fp)
 182a2ac:	e0bffb17 	ldw	r2,-20(fp)
 182a2b0:	18bfc216 	blt	r3,r2,182a1bc <__ram_exceptions_end+0xff819d78>
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 182a2b4:	e0bff204 	addi	r2,fp,-56
 182a2b8:	d8800215 	stw	r2,8(sp)
 182a2bc:	e0bff004 	addi	r2,fp,-64
 182a2c0:	d8800115 	stw	r2,4(sp)
 182a2c4:	e0bfee04 	addi	r2,fp,-72
 182a2c8:	d8800015 	stw	r2,0(sp)
 182a2cc:	e1fffe17 	ldw	r7,-8(fp)
 182a2d0:	e1bffd17 	ldw	r6,-12(fp)
 182a2d4:	e17ffc17 	ldw	r5,-16(fp)
 182a2d8:	e13ffb17 	ldw	r4,-20(fp)
 182a2dc:	1829d1c0 	call	1829d1c <lwip_selscan>
 182a2e0:	e0bfe815 	stw	r2,-96(fp)
    if (!nready) {
 182a2e4:	e0bfe817 	ldw	r2,-96(fp)
 182a2e8:	1000191e 	bne	r2,zero,182a350 <lwip_select+0x2b4>
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
 182a2ec:	e0800217 	ldw	r2,8(fp)
 182a2f0:	1000021e 	bne	r2,zero,182a2fc <lwip_select+0x260>
        /* Wait forever */
        msectimeout = 0;
 182a2f4:	e03fe915 	stw	zero,-92(fp)
 182a2f8:	00000f06 	br	182a338 <lwip_select+0x29c>
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
 182a2fc:	e0800217 	ldw	r2,8(fp)
 182a300:	10800017 	ldw	r2,0(r2)
 182a304:	1400fa24 	muli	r16,r2,1000
 182a308:	e0800217 	ldw	r2,8(fp)
 182a30c:	10800117 	ldw	r2,4(r2)
 182a310:	10807d04 	addi	r2,r2,500
 182a314:	0140fa04 	movi	r5,1000
 182a318:	1009883a 	mov	r4,r2
 182a31c:	180ac180 	call	180ac18 <__divsi3>
 182a320:	8085883a 	add	r2,r16,r2
 182a324:	e0bfe915 	stw	r2,-92(fp)
        if (msectimeout == 0) {
 182a328:	e0bfe917 	ldw	r2,-92(fp)
 182a32c:	1000021e 	bne	r2,zero,182a338 <lwip_select+0x29c>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
 182a330:	00800044 	movi	r2,1
 182a334:	e0bfe915 	stw	r2,-92(fp)
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 182a338:	e0bff404 	addi	r2,fp,-48
 182a33c:	10800604 	addi	r2,r2,24
 182a340:	e17fe917 	ldw	r5,-92(fp)
 182a344:	1009883a 	mov	r4,r2
 182a348:	18150bc0 	call	18150bc <sys_arch_sem_wait>
 182a34c:	e0bfe715 	stw	r2,-100(fp)
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 182a350:	00800804 	movi	r2,32
 182a354:	e0bfea15 	stw	r2,-88(fp)
 182a358:	00003b06 	br	182a448 <lwip_select+0x3ac>
      if ((readset && FD_ISSET(i, readset)) ||
 182a35c:	e0bffc17 	ldw	r2,-16(fp)
 182a360:	10000c26 	beq	r2,zero,182a394 <lwip_select+0x2f8>
 182a364:	e0bfea17 	ldw	r2,-88(fp)
 182a368:	1004d17a 	srli	r2,r2,5
 182a36c:	e0fffc17 	ldw	r3,-16(fp)
 182a370:	1085883a 	add	r2,r2,r2
 182a374:	1085883a 	add	r2,r2,r2
 182a378:	1885883a 	add	r2,r3,r2
 182a37c:	10c00017 	ldw	r3,0(r2)
 182a380:	e0bfea17 	ldw	r2,-88(fp)
 182a384:	108007cc 	andi	r2,r2,31
 182a388:	1885d83a 	sra	r2,r3,r2
 182a38c:	1080004c 	andi	r2,r2,1
 182a390:	10001c1e 	bne	r2,zero,182a404 <lwip_select+0x368>
 182a394:	e0bffd17 	ldw	r2,-12(fp)
 182a398:	10000c26 	beq	r2,zero,182a3cc <lwip_select+0x330>
          (writeset && FD_ISSET(i, writeset)) ||
 182a39c:	e0bfea17 	ldw	r2,-88(fp)
 182a3a0:	1004d17a 	srli	r2,r2,5
 182a3a4:	e0fffd17 	ldw	r3,-12(fp)
 182a3a8:	1085883a 	add	r2,r2,r2
 182a3ac:	1085883a 	add	r2,r2,r2
 182a3b0:	1885883a 	add	r2,r3,r2
 182a3b4:	10c00017 	ldw	r3,0(r2)
 182a3b8:	e0bfea17 	ldw	r2,-88(fp)
 182a3bc:	108007cc 	andi	r2,r2,31
 182a3c0:	1885d83a 	sra	r2,r3,r2
 182a3c4:	1080004c 	andi	r2,r2,1
 182a3c8:	10000e1e 	bne	r2,zero,182a404 <lwip_select+0x368>
 182a3cc:	e0bffe17 	ldw	r2,-8(fp)
 182a3d0:	10001a26 	beq	r2,zero,182a43c <lwip_select+0x3a0>
          (exceptset && FD_ISSET(i, exceptset))) {
 182a3d4:	e0bfea17 	ldw	r2,-88(fp)
 182a3d8:	1004d17a 	srli	r2,r2,5
 182a3dc:	e0fffe17 	ldw	r3,-8(fp)
 182a3e0:	1085883a 	add	r2,r2,r2
 182a3e4:	1085883a 	add	r2,r2,r2
 182a3e8:	1885883a 	add	r2,r3,r2
 182a3ec:	10c00017 	ldw	r3,0(r2)
 182a3f0:	e0bfea17 	ldw	r2,-88(fp)
 182a3f4:	108007cc 	andi	r2,r2,31
 182a3f8:	1885d83a 	sra	r2,r3,r2
 182a3fc:	1080004c 	andi	r2,r2,1
 182a400:	10000e26 	beq	r2,zero,182a43c <lwip_select+0x3a0>
        struct lwip_sock *sock = tryget_socket(i);
 182a404:	e13fea17 	ldw	r4,-88(fp)
 182a408:	18288b80 	call	18288b8 <tryget_socket>
 182a40c:	e0bfed15 	stw	r2,-76(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 182a410:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a414:	10000126 	beq	r2,zero,182a41c <lwip_select+0x380>
 182a418:	181103c0 	call	181103c <vTaskEnterCritical>
        sock->select_waiting--;
 182a41c:	e0bfed17 	ldw	r2,-76(fp)
 182a420:	10800517 	ldw	r2,20(r2)
 182a424:	10ffffc4 	addi	r3,r2,-1
 182a428:	e0bfed17 	ldw	r2,-76(fp)
 182a42c:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
 182a430:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a434:	10000126 	beq	r2,zero,182a43c <lwip_select+0x3a0>
 182a438:	18110840 	call	1811084 <vTaskExitCritical>
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 182a43c:	e0bfea17 	ldw	r2,-88(fp)
 182a440:	10800044 	addi	r2,r2,1
 182a444:	e0bfea15 	stw	r2,-88(fp)
 182a448:	e0ffea17 	ldw	r3,-88(fp)
 182a44c:	e0bffb17 	ldw	r2,-20(fp)
 182a450:	18bfc216 	blt	r3,r2,182a35c <__ram_exceptions_end+0xff819f18>
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
 182a454:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a458:	10000126 	beq	r2,zero,182a460 <lwip_select+0x3c4>
 182a45c:	181103c0 	call	181103c <vTaskEnterCritical>
    if (select_cb.next != NULL) {
 182a460:	e0bff417 	ldw	r2,-48(fp)
 182a464:	10000326 	beq	r2,zero,182a474 <lwip_select+0x3d8>
      select_cb.next->prev = select_cb.prev;
 182a468:	e0bff417 	ldw	r2,-48(fp)
 182a46c:	e0fff517 	ldw	r3,-44(fp)
 182a470:	10c00115 	stw	r3,4(r2)
    }
    if (select_cb_list == &select_cb) {
 182a474:	d0e80b17 	ldw	r3,-24532(gp)
 182a478:	e0bff404 	addi	r2,fp,-48
 182a47c:	1880031e 	bne	r3,r2,182a48c <lwip_select+0x3f0>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
 182a480:	e0bff417 	ldw	r2,-48(fp)
 182a484:	d0a80b15 	stw	r2,-24532(gp)
 182a488:	00000306 	br	182a498 <lwip_select+0x3fc>
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
      select_cb.prev->next = select_cb.next;
 182a48c:	e0bff517 	ldw	r2,-44(fp)
 182a490:	e0fff417 	ldw	r3,-48(fp)
 182a494:	10c00015 	stw	r3,0(r2)
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 182a498:	d0a80c17 	ldw	r2,-24528(gp)
 182a49c:	10800044 	addi	r2,r2,1
 182a4a0:	d0a80c15 	stw	r2,-24528(gp)
    SYS_ARCH_UNPROTECT(lev);
 182a4a4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a4a8:	10000126 	beq	r2,zero,182a4b0 <lwip_select+0x414>
 182a4ac:	18110840 	call	1811084 <vTaskExitCritical>

    sys_sem_free(&select_cb.sem);
 182a4b0:	e0bff404 	addi	r2,fp,-48
 182a4b4:	10800604 	addi	r2,r2,24
 182a4b8:	1009883a 	mov	r4,r2
 182a4bc:	181501c0 	call	181501c <sys_sem_free>
    if (waitres == SYS_ARCH_TIMEOUT)  {
 182a4c0:	e0bfe717 	ldw	r2,-100(fp)
 182a4c4:	10bfffd8 	cmpnei	r2,r2,-1
 182a4c8:	10000f26 	beq	r2,zero,182a508 <lwip_select+0x46c>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 182a4cc:	e0bff204 	addi	r2,fp,-56
 182a4d0:	d8800215 	stw	r2,8(sp)
 182a4d4:	e0bff004 	addi	r2,fp,-64
 182a4d8:	d8800115 	stw	r2,4(sp)
 182a4dc:	e0bfee04 	addi	r2,fp,-72
 182a4e0:	d8800015 	stw	r2,0(sp)
 182a4e4:	e1fffe17 	ldw	r7,-8(fp)
 182a4e8:	e1bffd17 	ldw	r6,-12(fp)
 182a4ec:	e17ffc17 	ldw	r5,-16(fp)
 182a4f0:	e13ffb17 	ldw	r4,-20(fp)
 182a4f4:	1829d1c0 	call	1829d1c <lwip_selscan>
 182a4f8:	e0bfe815 	stw	r2,-96(fp)
 182a4fc:	00000306 	br	182a50c <lwip_select+0x470>
  if (!nready) {
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
 182a500:	0001883a 	nop
 182a504:	00000106 	br	182a50c <lwip_select+0x470>
    if (waitres == SYS_ARCH_TIMEOUT)  {
      /* Timeout */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
 182a508:	0001883a 	nop
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  set_errno(0);
  if (readset) {
 182a50c:	e0bffc17 	ldw	r2,-16(fp)
 182a510:	10000526 	beq	r2,zero,182a528 <lwip_select+0x48c>
    *readset = lreadset;
 182a514:	e0bffc17 	ldw	r2,-16(fp)
 182a518:	e0ffee17 	ldw	r3,-72(fp)
 182a51c:	10c00015 	stw	r3,0(r2)
 182a520:	e0ffef17 	ldw	r3,-68(fp)
 182a524:	10c00115 	stw	r3,4(r2)
  }
  if (writeset) {
 182a528:	e0bffd17 	ldw	r2,-12(fp)
 182a52c:	10000526 	beq	r2,zero,182a544 <lwip_select+0x4a8>
    *writeset = lwriteset;
 182a530:	e0bffd17 	ldw	r2,-12(fp)
 182a534:	e0fff017 	ldw	r3,-64(fp)
 182a538:	10c00015 	stw	r3,0(r2)
 182a53c:	e0fff117 	ldw	r3,-60(fp)
 182a540:	10c00115 	stw	r3,4(r2)
  }
  if (exceptset) {
 182a544:	e0bffe17 	ldw	r2,-8(fp)
 182a548:	10000526 	beq	r2,zero,182a560 <lwip_select+0x4c4>
    *exceptset = lexceptset;
 182a54c:	e0bffe17 	ldw	r2,-8(fp)
 182a550:	e0fff217 	ldw	r3,-56(fp)
 182a554:	10c00015 	stw	r3,0(r2)
 182a558:	e0fff317 	ldw	r3,-52(fp)
 182a55c:	10c00115 	stw	r3,4(r2)
  }


  return nready;
 182a560:	e0bfe817 	ldw	r2,-96(fp)
}
 182a564:	e6ffff04 	addi	sp,fp,-4
 182a568:	dfc00217 	ldw	ra,8(sp)
 182a56c:	df000117 	ldw	fp,4(sp)
 182a570:	dc000017 	ldw	r16,0(sp)
 182a574:	dec00304 	addi	sp,sp,12
 182a578:	f800283a 	ret

0182a57c <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
 182a57c:	defff604 	addi	sp,sp,-40
 182a580:	dfc00915 	stw	ra,36(sp)
 182a584:	df000815 	stw	fp,32(sp)
 182a588:	df000804 	addi	fp,sp,32
 182a58c:	e13ffd15 	stw	r4,-12(fp)
 182a590:	e17ffe15 	stw	r5,-8(fp)
 182a594:	3005883a 	mov	r2,r6
 182a598:	e0bfff0d 	sth	r2,-4(fp)
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
 182a59c:	e0bffd17 	ldw	r2,-12(fp)
 182a5a0:	1000d526 	beq	r2,zero,182a8f8 <event_callback+0x37c>
    s = conn->socket;
 182a5a4:	e0bffd17 	ldw	r2,-12(fp)
 182a5a8:	10800717 	ldw	r2,28(r2)
 182a5ac:	e0bff815 	stw	r2,-32(fp)
    if (s < 0) {
 182a5b0:	e0bff817 	ldw	r2,-32(fp)
 182a5b4:	1000170e 	bge	r2,zero,182a614 <event_callback+0x98>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 182a5b8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a5bc:	10000126 	beq	r2,zero,182a5c4 <event_callback+0x48>
 182a5c0:	181103c0 	call	181103c <vTaskEnterCritical>
      if (conn->socket < 0) {
 182a5c4:	e0bffd17 	ldw	r2,-12(fp)
 182a5c8:	10800717 	ldw	r2,28(r2)
 182a5cc:	10000b0e 	bge	r2,zero,182a5fc <event_callback+0x80>
        if (evt == NETCONN_EVT_RCVPLUS) {
 182a5d0:	e0bffe17 	ldw	r2,-8(fp)
 182a5d4:	1000051e 	bne	r2,zero,182a5ec <event_callback+0x70>
          conn->socket--;
 182a5d8:	e0bffd17 	ldw	r2,-12(fp)
 182a5dc:	10800717 	ldw	r2,28(r2)
 182a5e0:	10ffffc4 	addi	r3,r2,-1
 182a5e4:	e0bffd17 	ldw	r2,-12(fp)
 182a5e8:	10c00715 	stw	r3,28(r2)
        }
        SYS_ARCH_UNPROTECT(lev);
 182a5ec:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a5f0:	1000c326 	beq	r2,zero,182a900 <event_callback+0x384>
 182a5f4:	18110840 	call	1811084 <vTaskExitCritical>
        return;
 182a5f8:	0000c106 	br	182a900 <event_callback+0x384>
      }
      s = conn->socket;
 182a5fc:	e0bffd17 	ldw	r2,-12(fp)
 182a600:	10800717 	ldw	r2,28(r2)
 182a604:	e0bff815 	stw	r2,-32(fp)
      SYS_ARCH_UNPROTECT(lev);
 182a608:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a60c:	10000126 	beq	r2,zero,182a614 <event_callback+0x98>
 182a610:	18110840 	call	1811084 <vTaskExitCritical>
    }

    sock = get_socket(s);
 182a614:	e13ff817 	ldw	r4,-32(fp)
 182a618:	18288400 	call	1828840 <get_socket>
 182a61c:	e0bffb15 	stw	r2,-20(fp)
    if (!sock) {
 182a620:	e0bffb17 	ldw	r2,-20(fp)
 182a624:	1000b826 	beq	r2,zero,182a908 <event_callback+0x38c>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
 182a628:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a62c:	10000126 	beq	r2,zero,182a634 <event_callback+0xb8>
 182a630:	181103c0 	call	181103c <vTaskEnterCritical>
  /* Set event as required */
  switch (evt) {
 182a634:	e0bffe17 	ldw	r2,-8(fp)
 182a638:	10800168 	cmpgeui	r2,r2,5
 182a63c:	1000251e 	bne	r2,zero,182a6d4 <event_callback+0x158>
 182a640:	e0bffe17 	ldw	r2,-8(fp)
 182a644:	100690ba 	slli	r3,r2,2
 182a648:	008060f4 	movhi	r2,387
 182a64c:	10a99704 	addi	r2,r2,-22948
 182a650:	1885883a 	add	r2,r3,r2
 182a654:	10800017 	ldw	r2,0(r2)
 182a658:	1000683a 	jmp	r2
 182a65c:	0182a670 	cmpltui	r6,zero,2713
 182a660:	0182a68c 	andi	r6,zero,2714
 182a664:	0182a6a8 	cmpgeui	r6,zero,2714
 182a668:	0182a6b8 	rdprs	r6,zero,2714
 182a66c:	0182a6c4 	movi	r6,2715
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
 182a670:	e0bffb17 	ldw	r2,-20(fp)
 182a674:	1080028b 	ldhu	r2,10(r2)
 182a678:	10800044 	addi	r2,r2,1
 182a67c:	1007883a 	mov	r3,r2
 182a680:	e0bffb17 	ldw	r2,-20(fp)
 182a684:	10c0028d 	sth	r3,10(r2)
      break;
 182a688:	00001306 	br	182a6d8 <event_callback+0x15c>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
 182a68c:	e0bffb17 	ldw	r2,-20(fp)
 182a690:	1080028b 	ldhu	r2,10(r2)
 182a694:	10bfffc4 	addi	r2,r2,-1
 182a698:	1007883a 	mov	r3,r2
 182a69c:	e0bffb17 	ldw	r2,-20(fp)
 182a6a0:	10c0028d 	sth	r3,10(r2)
      break;
 182a6a4:	00000c06 	br	182a6d8 <event_callback+0x15c>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
 182a6a8:	e0bffb17 	ldw	r2,-20(fp)
 182a6ac:	00c00044 	movi	r3,1
 182a6b0:	10c0030d 	sth	r3,12(r2)
      break;
 182a6b4:	00000806 	br	182a6d8 <event_callback+0x15c>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 182a6b8:	e0bffb17 	ldw	r2,-20(fp)
 182a6bc:	1000030d 	sth	zero,12(r2)
      break;
 182a6c0:	00000506 	br	182a6d8 <event_callback+0x15c>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
 182a6c4:	e0bffb17 	ldw	r2,-20(fp)
 182a6c8:	00c00044 	movi	r3,1
 182a6cc:	10c0038d 	sth	r3,14(r2)
      break;
 182a6d0:	00000106 	br	182a6d8 <event_callback+0x15c>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
 182a6d4:	0001883a 	nop
  }

  if (sock->select_waiting == 0) {
 182a6d8:	e0bffb17 	ldw	r2,-20(fp)
 182a6dc:	10800517 	ldw	r2,20(r2)
 182a6e0:	1000041e 	bne	r2,zero,182a6f4 <event_callback+0x178>
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
 182a6e4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a6e8:	10008926 	beq	r2,zero,182a910 <event_callback+0x394>
 182a6ec:	18110840 	call	1811084 <vTaskExitCritical>
    return;
 182a6f0:	00008706 	br	182a910 <event_callback+0x394>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 182a6f4:	d0a80b17 	ldw	r2,-24532(gp)
 182a6f8:	e0bff915 	stw	r2,-28(fp)
 182a6fc:	00007806 	br	182a8e0 <event_callback+0x364>
    if (scb->sem_signalled == 0) {
 182a700:	e0bff917 	ldw	r2,-28(fp)
 182a704:	10800517 	ldw	r2,20(r2)
 182a708:	1000521e 	bne	r2,zero,182a854 <event_callback+0x2d8>
      /* semaphore not signalled yet */
      int do_signal = 0;
 182a70c:	e03ffa15 	stw	zero,-24(fp)
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
 182a710:	e0bffb17 	ldw	r2,-20(fp)
 182a714:	1080028b 	ldhu	r2,10(r2)
 182a718:	10bfffcc 	andi	r2,r2,65535
 182a71c:	10a0001c 	xori	r2,r2,32768
 182a720:	10a00004 	addi	r2,r2,-32768
 182a724:	0080120e 	bge	zero,r2,182a770 <event_callback+0x1f4>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 182a728:	e0bff917 	ldw	r2,-28(fp)
 182a72c:	10800217 	ldw	r2,8(r2)
 182a730:	10000f26 	beq	r2,zero,182a770 <event_callback+0x1f4>
 182a734:	e0bff917 	ldw	r2,-28(fp)
 182a738:	10c00217 	ldw	r3,8(r2)
 182a73c:	e0bff817 	ldw	r2,-32(fp)
 182a740:	1004d17a 	srli	r2,r2,5
 182a744:	1085883a 	add	r2,r2,r2
 182a748:	1085883a 	add	r2,r2,r2
 182a74c:	1885883a 	add	r2,r3,r2
 182a750:	10c00017 	ldw	r3,0(r2)
 182a754:	e0bff817 	ldw	r2,-32(fp)
 182a758:	108007cc 	andi	r2,r2,31
 182a75c:	1885d83a 	sra	r2,r3,r2
 182a760:	1080004c 	andi	r2,r2,1
 182a764:	10000226 	beq	r2,zero,182a770 <event_callback+0x1f4>
          do_signal = 1;
 182a768:	00800044 	movi	r2,1
 182a76c:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->sendevent != 0) {
 182a770:	e0bffb17 	ldw	r2,-20(fp)
 182a774:	1080030b 	ldhu	r2,12(r2)
 182a778:	10bfffcc 	andi	r2,r2,65535
 182a77c:	10001426 	beq	r2,zero,182a7d0 <event_callback+0x254>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
 182a780:	e0bffa17 	ldw	r2,-24(fp)
 182a784:	1000121e 	bne	r2,zero,182a7d0 <event_callback+0x254>
 182a788:	e0bff917 	ldw	r2,-28(fp)
 182a78c:	10800317 	ldw	r2,12(r2)
 182a790:	10000f26 	beq	r2,zero,182a7d0 <event_callback+0x254>
 182a794:	e0bff917 	ldw	r2,-28(fp)
 182a798:	10c00317 	ldw	r3,12(r2)
 182a79c:	e0bff817 	ldw	r2,-32(fp)
 182a7a0:	1004d17a 	srli	r2,r2,5
 182a7a4:	1085883a 	add	r2,r2,r2
 182a7a8:	1085883a 	add	r2,r2,r2
 182a7ac:	1885883a 	add	r2,r3,r2
 182a7b0:	10c00017 	ldw	r3,0(r2)
 182a7b4:	e0bff817 	ldw	r2,-32(fp)
 182a7b8:	108007cc 	andi	r2,r2,31
 182a7bc:	1885d83a 	sra	r2,r3,r2
 182a7c0:	1080004c 	andi	r2,r2,1
 182a7c4:	10000226 	beq	r2,zero,182a7d0 <event_callback+0x254>
          do_signal = 1;
 182a7c8:	00800044 	movi	r2,1
 182a7cc:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->errevent != 0) {
 182a7d0:	e0bffb17 	ldw	r2,-20(fp)
 182a7d4:	1080038b 	ldhu	r2,14(r2)
 182a7d8:	10bfffcc 	andi	r2,r2,65535
 182a7dc:	10001426 	beq	r2,zero,182a830 <event_callback+0x2b4>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
 182a7e0:	e0bffa17 	ldw	r2,-24(fp)
 182a7e4:	1000121e 	bne	r2,zero,182a830 <event_callback+0x2b4>
 182a7e8:	e0bff917 	ldw	r2,-28(fp)
 182a7ec:	10800417 	ldw	r2,16(r2)
 182a7f0:	10000f26 	beq	r2,zero,182a830 <event_callback+0x2b4>
 182a7f4:	e0bff917 	ldw	r2,-28(fp)
 182a7f8:	10c00417 	ldw	r3,16(r2)
 182a7fc:	e0bff817 	ldw	r2,-32(fp)
 182a800:	1004d17a 	srli	r2,r2,5
 182a804:	1085883a 	add	r2,r2,r2
 182a808:	1085883a 	add	r2,r2,r2
 182a80c:	1885883a 	add	r2,r3,r2
 182a810:	10c00017 	ldw	r3,0(r2)
 182a814:	e0bff817 	ldw	r2,-32(fp)
 182a818:	108007cc 	andi	r2,r2,31
 182a81c:	1885d83a 	sra	r2,r3,r2
 182a820:	1080004c 	andi	r2,r2,1
 182a824:	10000226 	beq	r2,zero,182a830 <event_callback+0x2b4>
          do_signal = 1;
 182a828:	00800044 	movi	r2,1
 182a82c:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (do_signal) {
 182a830:	e0bffa17 	ldw	r2,-24(fp)
 182a834:	10000726 	beq	r2,zero,182a854 <event_callback+0x2d8>
        scb->sem_signalled = 1;
 182a838:	e0bff917 	ldw	r2,-28(fp)
 182a83c:	00c00044 	movi	r3,1
 182a840:	10c00515 	stw	r3,20(r2)
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
 182a844:	e0bff917 	ldw	r2,-28(fp)
 182a848:	10800604 	addi	r2,r2,24
 182a84c:	1009883a 	mov	r4,r2
 182a850:	18150740 	call	1815074 <sys_sem_signal>
      }
    }

    if ((scb->next) && (scb->next < 0x00800000 || scb->next > 0x00ffffff))
 182a854:	e0bff917 	ldw	r2,-28(fp)
 182a858:	10800017 	ldw	r2,0(r2)
 182a85c:	10000a26 	beq	r2,zero,182a888 <event_callback+0x30c>
 182a860:	e0bff917 	ldw	r2,-28(fp)
 182a864:	10c00017 	ldw	r3,0(r2)
 182a868:	00802034 	movhi	r2,128
 182a86c:	18800436 	bltu	r3,r2,182a880 <event_callback+0x304>
 182a870:	e0bff917 	ldw	r2,-28(fp)
 182a874:	10c00017 	ldw	r3,0(r2)
 182a878:	00804034 	movhi	r2,256
 182a87c:	18800236 	bltu	r3,r2,182a888 <event_callback+0x30c>
    {
    	NIOS2_BREAK();
 182a880:	003da03a 	break	0
 182a884:	00000706 	br	182a8a4 <event_callback+0x328>
    }
    else if (scb < 0x00800000 || scb > 0x00ffffff)
 182a888:	e0fff917 	ldw	r3,-28(fp)
 182a88c:	00802034 	movhi	r2,128
 182a890:	18800336 	bltu	r3,r2,182a8a0 <event_callback+0x324>
 182a894:	e0fff917 	ldw	r3,-28(fp)
 182a898:	00804034 	movhi	r2,256
 182a89c:	18800136 	bltu	r3,r2,182a8a4 <event_callback+0x328>
    {
    	NIOS2_BREAK();
 182a8a0:	003da03a 	break	0
    }

    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
 182a8a4:	d0a80c17 	ldw	r2,-24528(gp)
 182a8a8:	e0bffc15 	stw	r2,-16(fp)
    SYS_ARCH_UNPROTECT(lev);
 182a8ac:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a8b0:	10000126 	beq	r2,zero,182a8b8 <event_callback+0x33c>
 182a8b4:	18110840 	call	1811084 <vTaskExitCritical>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
 182a8b8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a8bc:	10000126 	beq	r2,zero,182a8c4 <event_callback+0x348>
 182a8c0:	181103c0 	call	181103c <vTaskEnterCritical>
    if (last_select_cb_ctr != select_cb_ctr) {
 182a8c4:	d0a80c17 	ldw	r2,-24528(gp)
 182a8c8:	e0fffc17 	ldw	r3,-16(fp)
 182a8cc:	18800126 	beq	r3,r2,182a8d4 <event_callback+0x358>
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
 182a8d0:	003f8806 	br	182a6f4 <__ram_exceptions_end+0xff81a2b0>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 182a8d4:	e0bff917 	ldw	r2,-28(fp)
 182a8d8:	10800017 	ldw	r2,0(r2)
 182a8dc:	e0bff915 	stw	r2,-28(fp)
 182a8e0:	e0bff917 	ldw	r2,-28(fp)
 182a8e4:	103f861e 	bne	r2,zero,182a700 <__ram_exceptions_end+0xff81a2bc>
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
 182a8e8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 182a8ec:	10000926 	beq	r2,zero,182a914 <event_callback+0x398>
 182a8f0:	18110840 	call	1811084 <vTaskExitCritical>
 182a8f4:	00000706 	br	182a914 <event_callback+0x398>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
 182a8f8:	0001883a 	nop
 182a8fc:	00000506 	br	182a914 <event_callback+0x398>
      if (conn->socket < 0) {
        if (evt == NETCONN_EVT_RCVPLUS) {
          conn->socket--;
        }
        SYS_ARCH_UNPROTECT(lev);
        return;
 182a900:	0001883a 	nop
 182a904:	00000306 	br	182a914 <event_callback+0x398>
      SYS_ARCH_UNPROTECT(lev);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
 182a908:	0001883a 	nop
 182a90c:	00000106 	br	182a914 <event_callback+0x398>
  }

  if (sock->select_waiting == 0) {
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
    return;
 182a910:	0001883a 	nop
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
 182a914:	e037883a 	mov	sp,fp
 182a918:	dfc00117 	ldw	ra,4(sp)
 182a91c:	df000017 	ldw	fp,0(sp)
 182a920:	dec00204 	addi	sp,sp,8
 182a924:	f800283a 	ret

0182a928 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
 182a928:	defff904 	addi	sp,sp,-28
 182a92c:	dfc00615 	stw	ra,24(sp)
 182a930:	df000515 	stw	fp,20(sp)
 182a934:	df000504 	addi	fp,sp,20
 182a938:	e13ffe15 	stw	r4,-8(fp)
 182a93c:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
 182a940:	e03ffb05 	stb	zero,-20(fp)
 182a944:	e03ffb45 	stb	zero,-19(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
 182a948:	e13ffe17 	ldw	r4,-8(fp)
 182a94c:	18288400 	call	1828840 <get_socket>
 182a950:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
 182a954:	e0bffc17 	ldw	r2,-16(fp)
 182a958:	1000021e 	bne	r2,zero,182a964 <lwip_shutdown+0x3c>
    return -1;
 182a95c:	00bfffc4 	movi	r2,-1
 182a960:	00004906 	br	182aa88 <lwip_shutdown+0x160>
  }

  if (sock->conn != NULL) {
 182a964:	e0bffc17 	ldw	r2,-16(fp)
 182a968:	10800017 	ldw	r2,0(r2)
 182a96c:	10000a26 	beq	r2,zero,182a998 <lwip_shutdown+0x70>
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 182a970:	e0bffc17 	ldw	r2,-16(fp)
 182a974:	10800017 	ldw	r2,0(r2)
 182a978:	10800017 	ldw	r2,0(r2)
 182a97c:	10800420 	cmpeqi	r2,r2,16
 182a980:	10000a1e 	bne	r2,zero,182a9ac <lwip_shutdown+0x84>
      sock_set_errno(sock, EOPNOTSUPP);
 182a984:	e0bffc17 	ldw	r2,-16(fp)
 182a988:	00c017c4 	movi	r3,95
 182a98c:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 182a990:	008017c4 	movi	r2,95
 182a994:	00003c06 	br	182aa88 <lwip_shutdown+0x160>
    }
  } else {
    sock_set_errno(sock, ENOTCONN);
 182a998:	e0bffc17 	ldw	r2,-16(fp)
 182a99c:	00c02004 	movi	r3,128
 182a9a0:	10c00415 	stw	r3,16(r2)
    return ENOTCONN;
 182a9a4:	00802004 	movi	r2,128
 182a9a8:	00003706 	br	182aa88 <lwip_shutdown+0x160>
  }

  if (how == SHUT_RD) {
 182a9ac:	e0bfff17 	ldw	r2,-4(fp)
 182a9b0:	1000031e 	bne	r2,zero,182a9c0 <lwip_shutdown+0x98>
    shut_rx = 1;
 182a9b4:	00800044 	movi	r2,1
 182a9b8:	e0bffb05 	stb	r2,-20(fp)
 182a9bc:	00001306 	br	182aa0c <lwip_shutdown+0xe4>
  } else if (how == SHUT_WR) {
 182a9c0:	e0bfff17 	ldw	r2,-4(fp)
 182a9c4:	10800058 	cmpnei	r2,r2,1
 182a9c8:	1000031e 	bne	r2,zero,182a9d8 <lwip_shutdown+0xb0>
    shut_tx = 1;
 182a9cc:	00800044 	movi	r2,1
 182a9d0:	e0bffb45 	stb	r2,-19(fp)
 182a9d4:	00000d06 	br	182aa0c <lwip_shutdown+0xe4>
  } else if(how == SHUT_RDWR) {
 182a9d8:	e0bfff17 	ldw	r2,-4(fp)
 182a9dc:	10800098 	cmpnei	r2,r2,2
 182a9e0:	1000051e 	bne	r2,zero,182a9f8 <lwip_shutdown+0xd0>
    shut_rx = 1;
 182a9e4:	00800044 	movi	r2,1
 182a9e8:	e0bffb05 	stb	r2,-20(fp)
    shut_tx = 1;
 182a9ec:	00800044 	movi	r2,1
 182a9f0:	e0bffb45 	stb	r2,-19(fp)
 182a9f4:	00000506 	br	182aa0c <lwip_shutdown+0xe4>
  } else {
    sock_set_errno(sock, EINVAL);
 182a9f8:	e0bffc17 	ldw	r2,-16(fp)
 182a9fc:	00c00584 	movi	r3,22
 182aa00:	10c00415 	stw	r3,16(r2)
    return EINVAL;
 182aa04:	00800584 	movi	r2,22
 182aa08:	00001f06 	br	182aa88 <lwip_shutdown+0x160>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
 182aa0c:	e0bffc17 	ldw	r2,-16(fp)
 182aa10:	10800017 	ldw	r2,0(r2)
 182aa14:	e0fffb03 	ldbu	r3,-20(fp)
 182aa18:	e13ffb43 	ldbu	r4,-19(fp)
 182aa1c:	200d883a 	mov	r6,r4
 182aa20:	180b883a 	mov	r5,r3
 182aa24:	1009883a 	mov	r4,r2
 182aa28:	183a4a80 	call	183a4a8 <netconn_shutdown>
 182aa2c:	e0bffd05 	stb	r2,-12(fp)

  sock_set_errno(sock, err_to_errno(err));
 182aa30:	e0bffd07 	ldb	r2,-12(fp)
 182aa34:	0085c83a 	sub	r2,zero,r2
 182aa38:	10800428 	cmpgeui	r2,r2,16
 182aa3c:	1000091e 	bne	r2,zero,182aa64 <lwip_shutdown+0x13c>
 182aa40:	e0bffd07 	ldb	r2,-12(fp)
 182aa44:	0087c83a 	sub	r3,zero,r2
 182aa48:	00806134 	movhi	r2,388
 182aa4c:	10876104 	addi	r2,r2,7556
 182aa50:	18c7883a 	add	r3,r3,r3
 182aa54:	18c7883a 	add	r3,r3,r3
 182aa58:	10c5883a 	add	r2,r2,r3
 182aa5c:	10800017 	ldw	r2,0(r2)
 182aa60:	00000106 	br	182aa68 <lwip_shutdown+0x140>
 182aa64:	00800144 	movi	r2,5
 182aa68:	e0fffc17 	ldw	r3,-16(fp)
 182aa6c:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? 0 : -1);
 182aa70:	e0bffd07 	ldb	r2,-12(fp)
 182aa74:	1000021e 	bne	r2,zero,182aa80 <lwip_shutdown+0x158>
 182aa78:	0005883a 	mov	r2,zero
 182aa7c:	00000106 	br	182aa84 <lwip_shutdown+0x15c>
 182aa80:	00bfffc4 	movi	r2,-1
 182aa84:	0001883a 	nop
}
 182aa88:	e037883a 	mov	sp,fp
 182aa8c:	dfc00117 	ldw	ra,4(sp)
 182aa90:	df000017 	ldw	fp,0(sp)
 182aa94:	dec00204 	addi	sp,sp,8
 182aa98:	f800283a 	ret

0182aa9c <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
 182aa9c:	defff404 	addi	sp,sp,-48
 182aaa0:	dfc00b15 	stw	ra,44(sp)
 182aaa4:	df000a15 	stw	fp,40(sp)
 182aaa8:	df000a04 	addi	fp,sp,40
 182aaac:	e13ffc15 	stw	r4,-16(fp)
 182aab0:	e17ffd15 	stw	r5,-12(fp)
 182aab4:	e1bffe15 	stw	r6,-8(fp)
 182aab8:	3805883a 	mov	r2,r7
 182aabc:	e0bfff05 	stb	r2,-4(fp)
  struct lwip_sock *sock;
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
 182aac0:	e13ffc17 	ldw	r4,-16(fp)
 182aac4:	18288400 	call	1828840 <get_socket>
 182aac8:	e0bff615 	stw	r2,-40(fp)
  if (!sock) {
 182aacc:	e0bff617 	ldw	r2,-40(fp)
 182aad0:	1000021e 	bne	r2,zero,182aadc <lwip_getaddrname+0x40>
    return -1;
 182aad4:	00bfffc4 	movi	r2,-1
 182aad8:	00003006 	br	182ab9c <lwip_getaddrname+0x100>
  }

  memset(&sin, 0, sizeof(sin));
 182aadc:	e0bff704 	addi	r2,fp,-36
 182aae0:	01800404 	movi	r6,16
 182aae4:	000b883a 	mov	r5,zero
 182aae8:	1009883a 	mov	r4,r2
 182aaec:	18061d40 	call	18061d4 <memset>
  sin.sin_len = sizeof(sin);
 182aaf0:	00800404 	movi	r2,16
 182aaf4:	e0bff705 	stb	r2,-36(fp)
  sin.sin_family = AF_INET;
 182aaf8:	00800084 	movi	r2,2
 182aafc:	e0bff745 	stb	r2,-35(fp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
 182ab00:	e0bff617 	ldw	r2,-40(fp)
 182ab04:	10c00017 	ldw	r3,0(r2)
 182ab08:	e17fff03 	ldbu	r5,-4(fp)
 182ab0c:	e0bff704 	addi	r2,fp,-36
 182ab10:	11000084 	addi	r4,r2,2
 182ab14:	e0bffb04 	addi	r2,fp,-20
 182ab18:	280f883a 	mov	r7,r5
 182ab1c:	200d883a 	mov	r6,r4
 182ab20:	100b883a 	mov	r5,r2
 182ab24:	1809883a 	mov	r4,r3
 182ab28:	18395200 	call	1839520 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
 182ab2c:	e0bff78b 	ldhu	r2,-34(fp)
 182ab30:	10bfffcc 	andi	r2,r2,65535
 182ab34:	1004d23a 	srli	r2,r2,8
 182ab38:	1007883a 	mov	r3,r2
 182ab3c:	e0bff78b 	ldhu	r2,-34(fp)
 182ab40:	10bfffcc 	andi	r2,r2,65535
 182ab44:	1004923a 	slli	r2,r2,8
 182ab48:	1884b03a 	or	r2,r3,r2
 182ab4c:	e0bff78d 	sth	r2,-34(fp)
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 182ab50:	e0bffb17 	ldw	r2,-20(fp)
 182ab54:	e0bff815 	stw	r2,-32(fp)

  if (*namelen > sizeof(sin)) {
 182ab58:	e0bffe17 	ldw	r2,-8(fp)
 182ab5c:	10800017 	ldw	r2,0(r2)
 182ab60:	10800470 	cmpltui	r2,r2,17
 182ab64:	1000031e 	bne	r2,zero,182ab74 <lwip_getaddrname+0xd8>
    *namelen = sizeof(sin);
 182ab68:	e0bffe17 	ldw	r2,-8(fp)
 182ab6c:	00c00404 	movi	r3,16
 182ab70:	10c00015 	stw	r3,0(r2)
  }

  MEMCPY(name, &sin, *namelen);
 182ab74:	e0bffe17 	ldw	r2,-8(fp)
 182ab78:	10c00017 	ldw	r3,0(r2)
 182ab7c:	e0bff704 	addi	r2,fp,-36
 182ab80:	180d883a 	mov	r6,r3
 182ab84:	100b883a 	mov	r5,r2
 182ab88:	e13ffd17 	ldw	r4,-12(fp)
 182ab8c:	180608c0 	call	180608c <memcpy>
  sock_set_errno(sock, 0);
 182ab90:	e0bff617 	ldw	r2,-40(fp)
 182ab94:	10000415 	stw	zero,16(r2)
  return 0;
 182ab98:	0005883a 	mov	r2,zero
}
 182ab9c:	e037883a 	mov	sp,fp
 182aba0:	dfc00117 	ldw	ra,4(sp)
 182aba4:	df000017 	ldw	fp,0(sp)
 182aba8:	dec00204 	addi	sp,sp,8
 182abac:	f800283a 	ret

0182abb0 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
 182abb0:	defffb04 	addi	sp,sp,-20
 182abb4:	dfc00415 	stw	ra,16(sp)
 182abb8:	df000315 	stw	fp,12(sp)
 182abbc:	df000304 	addi	fp,sp,12
 182abc0:	e13ffd15 	stw	r4,-12(fp)
 182abc4:	e17ffe15 	stw	r5,-8(fp)
 182abc8:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 0);
 182abcc:	000f883a 	mov	r7,zero
 182abd0:	e1bfff17 	ldw	r6,-4(fp)
 182abd4:	e17ffe17 	ldw	r5,-8(fp)
 182abd8:	e13ffd17 	ldw	r4,-12(fp)
 182abdc:	182aa9c0 	call	182aa9c <lwip_getaddrname>
}
 182abe0:	e037883a 	mov	sp,fp
 182abe4:	dfc00117 	ldw	ra,4(sp)
 182abe8:	df000017 	ldw	fp,0(sp)
 182abec:	dec00204 	addi	sp,sp,8
 182abf0:	f800283a 	ret

0182abf4 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
 182abf4:	defffb04 	addi	sp,sp,-20
 182abf8:	dfc00415 	stw	ra,16(sp)
 182abfc:	df000315 	stw	fp,12(sp)
 182ac00:	df000304 	addi	fp,sp,12
 182ac04:	e13ffd15 	stw	r4,-12(fp)
 182ac08:	e17ffe15 	stw	r5,-8(fp)
 182ac0c:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 1);
 182ac10:	01c00044 	movi	r7,1
 182ac14:	e1bfff17 	ldw	r6,-4(fp)
 182ac18:	e17ffe17 	ldw	r5,-8(fp)
 182ac1c:	e13ffd17 	ldw	r4,-12(fp)
 182ac20:	182aa9c0 	call	182aa9c <lwip_getaddrname>
}
 182ac24:	e037883a 	mov	sp,fp
 182ac28:	dfc00117 	ldw	ra,4(sp)
 182ac2c:	df000017 	ldw	fp,0(sp)
 182ac30:	dec00204 	addi	sp,sp,8
 182ac34:	f800283a 	ret

0182ac38 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 182ac38:	defff204 	addi	sp,sp,-56
 182ac3c:	dfc00d15 	stw	ra,52(sp)
 182ac40:	df000c15 	stw	fp,48(sp)
 182ac44:	df000c04 	addi	fp,sp,48
 182ac48:	e13ffc15 	stw	r4,-16(fp)
 182ac4c:	e17ffd15 	stw	r5,-12(fp)
 182ac50:	e1bffe15 	stw	r6,-8(fp)
 182ac54:	e1ffff15 	stw	r7,-4(fp)
  err_t err = ERR_OK;
 182ac58:	e03ff405 	stb	zero,-48(fp)
  struct lwip_sock *sock = get_socket(s);
 182ac5c:	e13ffc17 	ldw	r4,-16(fp)
 182ac60:	18288400 	call	1828840 <get_socket>
 182ac64:	e0bff515 	stw	r2,-44(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
 182ac68:	e0bff517 	ldw	r2,-44(fp)
 182ac6c:	1000021e 	bne	r2,zero,182ac78 <lwip_getsockopt+0x40>
    return -1;
 182ac70:	00bfffc4 	movi	r2,-1
 182ac74:	00009c06 	br	182aee8 <lwip_getsockopt+0x2b0>
  }

  if ((NULL == optval) || (NULL == optlen)) {
 182ac78:	e0bfff17 	ldw	r2,-4(fp)
 182ac7c:	10000226 	beq	r2,zero,182ac88 <lwip_getsockopt+0x50>
 182ac80:	e0800217 	ldw	r2,8(fp)
 182ac84:	1000051e 	bne	r2,zero,182ac9c <lwip_getsockopt+0x64>
    sock_set_errno(sock, EFAULT);
 182ac88:	e0bff517 	ldw	r2,-44(fp)
 182ac8c:	00c00384 	movi	r3,14
 182ac90:	10c00415 	stw	r3,16(r2)
    return -1;
 182ac94:	00bfffc4 	movi	r2,-1
 182ac98:	00009306 	br	182aee8 <lwip_getsockopt+0x2b0>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 182ac9c:	e0bffd17 	ldw	r2,-12(fp)
 182aca0:	10c001a0 	cmpeqi	r3,r2,6
 182aca4:	18004d1e 	bne	r3,zero,182addc <lwip_getsockopt+0x1a4>
 182aca8:	10c3ffe0 	cmpeqi	r3,r2,4095
 182acac:	1800021e 	bne	r3,zero,182acb8 <lwip_getsockopt+0x80>
 182acb0:	10003a26 	beq	r2,zero,182ad9c <lwip_getsockopt+0x164>
 182acb4:	00006006 	br	182ae38 <lwip_getsockopt+0x200>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182acb8:	e0bffe17 	ldw	r2,-8(fp)
 182acbc:	10c00820 	cmpeqi	r3,r2,32
 182acc0:	1800131e 	bne	r3,zero,182ad10 <lwip_getsockopt+0xd8>
 182acc4:	10c00848 	cmpgei	r3,r2,33
 182acc8:	1800071e 	bne	r3,zero,182ace8 <lwip_getsockopt+0xb0>
 182accc:	10c00120 	cmpeqi	r3,r2,4
 182acd0:	18000f1e 	bne	r3,zero,182ad10 <lwip_getsockopt+0xd8>
 182acd4:	10c00220 	cmpeqi	r3,r2,8
 182acd8:	18000d1e 	bne	r3,zero,182ad10 <lwip_getsockopt+0xd8>
 182acdc:	108000a0 	cmpeqi	r2,r2,2
 182ace0:	10000b1e 	bne	r2,zero,182ad10 <lwip_getsockopt+0xd8>
 182ace4:	00002606 	br	182ad80 <lwip_getsockopt+0x148>
 182ace8:	10c40248 	cmpgei	r3,r2,4105
 182acec:	1800051e 	bne	r3,zero,182ad04 <lwip_getsockopt+0xcc>
 182acf0:	10c40188 	cmpgei	r3,r2,4102
 182acf4:	1800061e 	bne	r3,zero,182ad10 <lwip_getsockopt+0xd8>
 182acf8:	10808020 	cmpeqi	r2,r2,512
 182acfc:	1000041e 	bne	r2,zero,182ad10 <lwip_getsockopt+0xd8>
 182ad00:	00001f06 	br	182ad80 <lwip_getsockopt+0x148>
 182ad04:	108402a0 	cmpeqi	r2,r2,4106
 182ad08:	1000081e 	bne	r2,zero,182ad2c <lwip_getsockopt+0xf4>
 182ad0c:	00001c06 	br	182ad80 <lwip_getsockopt+0x148>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
 182ad10:	e0800217 	ldw	r2,8(fp)
 182ad14:	10800017 	ldw	r2,0(r2)
 182ad18:	10800128 	cmpgeui	r2,r2,4
 182ad1c:	10001b1e 	bne	r2,zero,182ad8c <lwip_getsockopt+0x154>
        err = EINVAL;
 182ad20:	00800584 	movi	r2,22
 182ad24:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 182ad28:	00001806 	br	182ad8c <lwip_getsockopt+0x154>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
 182ad2c:	e0800217 	ldw	r2,8(fp)
 182ad30:	10800017 	ldw	r2,0(r2)
 182ad34:	10800128 	cmpgeui	r2,r2,4
 182ad38:	1000021e 	bne	r2,zero,182ad44 <lwip_getsockopt+0x10c>
        err = EINVAL;
 182ad3c:	00800584 	movi	r2,22
 182ad40:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 182ad44:	e0bff517 	ldw	r2,-44(fp)
 182ad48:	10800017 	ldw	r2,0(r2)
 182ad4c:	10800017 	ldw	r2,0(r2)
 182ad50:	10800818 	cmpnei	r2,r2,32
 182ad54:	1000071e 	bne	r2,zero,182ad74 <lwip_getsockopt+0x13c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 182ad58:	e0bff517 	ldw	r2,-44(fp)
 182ad5c:	10800017 	ldw	r2,0(r2)
 182ad60:	10800217 	ldw	r2,8(r2)
 182ad64:	10800403 	ldbu	r2,16(r2)
 182ad68:	10803fcc 	andi	r2,r2,255
 182ad6c:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 182ad70:	10000826 	beq	r2,zero,182ad94 <lwip_getsockopt+0x15c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
 182ad74:	00801a84 	movi	r2,106
 182ad78:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
 182ad7c:	00000506 	br	182ad94 <lwip_getsockopt+0x15c>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 182ad80:	00801b44 	movi	r2,109
 182ad84:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182ad88:	00002d06 	br	182ae40 <lwip_getsockopt+0x208>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 182ad8c:	0001883a 	nop
 182ad90:	00002b06 	br	182ae40 <lwip_getsockopt+0x208>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
 182ad94:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182ad98:	00002906 	br	182ae40 <lwip_getsockopt+0x208>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 182ad9c:	e0bffe17 	ldw	r2,-8(fp)
 182ada0:	10bfffc4 	addi	r2,r2,-1
 182ada4:	108000a8 	cmpgeui	r2,r2,2
 182ada8:	1000071e 	bne	r2,zero,182adc8 <lwip_getsockopt+0x190>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
 182adac:	e0800217 	ldw	r2,8(fp)
 182adb0:	10800017 	ldw	r2,0(r2)
 182adb4:	10800128 	cmpgeui	r2,r2,4
 182adb8:	1000061e 	bne	r2,zero,182add4 <lwip_getsockopt+0x19c>
        err = EINVAL;
 182adbc:	00800584 	movi	r2,22
 182adc0:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 182adc4:	00000306 	br	182add4 <lwip_getsockopt+0x19c>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 182adc8:	00801b44 	movi	r2,109
 182adcc:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182add0:	00001b06 	br	182ae40 <lwip_getsockopt+0x208>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 182add4:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182add8:	00001906 	br	182ae40 <lwip_getsockopt+0x208>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
 182addc:	e0800217 	ldw	r2,8(fp)
 182ade0:	10800017 	ldw	r2,0(r2)
 182ade4:	10800128 	cmpgeui	r2,r2,4
 182ade8:	1000031e 	bne	r2,zero,182adf8 <lwip_getsockopt+0x1c0>
      err = EINVAL;
 182adec:	00800584 	movi	r2,22
 182adf0:	e0bff405 	stb	r2,-48(fp)
      break;
 182adf4:	00001206 	br	182ae40 <lwip_getsockopt+0x208>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 182adf8:	e0bff517 	ldw	r2,-44(fp)
 182adfc:	10800017 	ldw	r2,0(r2)
 182ae00:	10800017 	ldw	r2,0(r2)
 182ae04:	10800420 	cmpeqi	r2,r2,16
 182ae08:	1000021e 	bne	r2,zero,182ae14 <lwip_getsockopt+0x1dc>
      return 0;
 182ae0c:	0005883a 	mov	r2,zero
 182ae10:	00003506 	br	182aee8 <lwip_getsockopt+0x2b0>

    switch (optname) {
 182ae14:	e0bffe17 	ldw	r2,-8(fp)
 182ae18:	10bfffc4 	addi	r2,r2,-1
 182ae1c:	10800168 	cmpgeui	r2,r2,5
 182ae20:	10000326 	beq	r2,zero,182ae30 <lwip_getsockopt+0x1f8>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 182ae24:	00801b44 	movi	r2,109
 182ae28:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182ae2c:	00000406 	br	182ae40 <lwip_getsockopt+0x208>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
 182ae30:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182ae34:	00000206 	br	182ae40 <lwip_getsockopt+0x208>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
 182ae38:	00801b44 	movi	r2,109
 182ae3c:	e0bff405 	stb	r2,-48(fp)
  }  /* switch */

   
  if (err != ERR_OK) {
 182ae40:	e0bff407 	ldb	r2,-48(fp)
 182ae44:	10000526 	beq	r2,zero,182ae5c <lwip_getsockopt+0x224>
    sock_set_errno(sock, err);
 182ae48:	e0fff407 	ldb	r3,-48(fp)
 182ae4c:	e0bff517 	ldw	r2,-44(fp)
 182ae50:	10c00415 	stw	r3,16(r2)
    return -1;
 182ae54:	00bfffc4 	movi	r2,-1
 182ae58:	00002306 	br	182aee8 <lwip_getsockopt+0x2b0>
  }

  /* Now do the actual option processing */
  data.sock = sock;
 182ae5c:	e0bff517 	ldw	r2,-44(fp)
 182ae60:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 182ae64:	e0bffd17 	ldw	r2,-12(fp)
 182ae68:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
 182ae6c:	e0bffe17 	ldw	r2,-8(fp)
 182ae70:	e0bff815 	stw	r2,-32(fp)
  data.optval = optval;
 182ae74:	e0bfff17 	ldw	r2,-4(fp)
 182ae78:	e0bff915 	stw	r2,-28(fp)
  data.optlen = optlen;
 182ae7c:	e0800217 	ldw	r2,8(fp)
 182ae80:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
 182ae84:	e0bff403 	ldbu	r2,-48(fp)
 182ae88:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_getsockopt_internal, &data);
 182ae8c:	e0bff604 	addi	r2,fp,-40
 182ae90:	01800044 	movi	r6,1
 182ae94:	100b883a 	mov	r5,r2
 182ae98:	010060f4 	movhi	r4,387
 182ae9c:	212bbf04 	addi	r4,r4,-20740
 182aea0:	182bd1c0 	call	182bd1c <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 182aea4:	e0bff517 	ldw	r2,-44(fp)
 182aea8:	10800017 	ldw	r2,0(r2)
 182aeac:	10800404 	addi	r2,r2,16
 182aeb0:	000b883a 	mov	r5,zero
 182aeb4:	1009883a 	mov	r4,r2
 182aeb8:	18150bc0 	call	18150bc <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
 182aebc:	e0bffb03 	ldbu	r2,-20(fp)
 182aec0:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
 182aec4:	e0fff407 	ldb	r3,-48(fp)
 182aec8:	e0bff517 	ldw	r2,-44(fp)
 182aecc:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
 182aed0:	e0bff407 	ldb	r2,-48(fp)
 182aed4:	10000226 	beq	r2,zero,182aee0 <lwip_getsockopt+0x2a8>
 182aed8:	00bfffc4 	movi	r2,-1
 182aedc:	00000206 	br	182aee8 <lwip_getsockopt+0x2b0>
 182aee0:	0005883a 	mov	r2,zero
 182aee4:	0001883a 	nop
}
 182aee8:	e037883a 	mov	sp,fp
 182aeec:	dfc00117 	ldw	ra,4(sp)
 182aef0:	df000017 	ldw	fp,0(sp)
 182aef4:	dec00204 	addi	sp,sp,8
 182aef8:	f800283a 	ret

0182aefc <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
 182aefc:	defff804 	addi	sp,sp,-32
 182af00:	dfc00715 	stw	ra,28(sp)
 182af04:	df000615 	stw	fp,24(sp)
 182af08:	df000604 	addi	fp,sp,24
 182af0c:	e13fff15 	stw	r4,-4(fp)
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
 182af10:	e0bfff17 	ldw	r2,-4(fp)
 182af14:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
 182af18:	e0bffa17 	ldw	r2,-24(fp)
 182af1c:	10800017 	ldw	r2,0(r2)
 182af20:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
 182af24:	e0bffa17 	ldw	r2,-24(fp)
 182af28:	10800117 	ldw	r2,4(r2)
 182af2c:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
 182af30:	e0bffa17 	ldw	r2,-24(fp)
 182af34:	10800217 	ldw	r2,8(r2)
 182af38:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
 182af3c:	e0bffa17 	ldw	r2,-24(fp)
 182af40:	10800317 	ldw	r2,12(r2)
 182af44:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
 182af48:	e0bffc17 	ldw	r2,-16(fp)
 182af4c:	10c001a0 	cmpeqi	r3,r2,6
 182af50:	18009b1e 	bne	r3,zero,182b1c0 <lwip_getsockopt_internal+0x2c4>
 182af54:	10c3ffe0 	cmpeqi	r3,r2,4095
 182af58:	1800021e 	bne	r3,zero,182af64 <lwip_getsockopt_internal+0x68>
 182af5c:	10008126 	beq	r2,zero,182b164 <lwip_getsockopt_internal+0x268>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
 182af60:	0000da06 	br	182b2cc <lwip_getsockopt_internal+0x3d0>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182af64:	e0bffd17 	ldw	r2,-12(fp)
 182af68:	10c08020 	cmpeqi	r3,r2,512
 182af6c:	18001a1e 	bne	r3,zero,182afd8 <lwip_getsockopt_internal+0xdc>
 182af70:	10c08048 	cmpgei	r3,r2,513
 182af74:	18000c1e 	bne	r3,zero,182afa8 <lwip_getsockopt_internal+0xac>
 182af78:	10c00120 	cmpeqi	r3,r2,4
 182af7c:	1800161e 	bne	r3,zero,182afd8 <lwip_getsockopt_internal+0xdc>
 182af80:	10c00148 	cmpgei	r3,r2,5
 182af84:	1800031e 	bne	r3,zero,182af94 <lwip_getsockopt_internal+0x98>
 182af88:	108000a0 	cmpeqi	r2,r2,2
 182af8c:	1000121e 	bne	r2,zero,182afd8 <lwip_getsockopt_internal+0xdc>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182af90:	00007306 	br	182b160 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182af94:	10c00220 	cmpeqi	r3,r2,8
 182af98:	18000f1e 	bne	r3,zero,182afd8 <lwip_getsockopt_internal+0xdc>
 182af9c:	10800820 	cmpeqi	r2,r2,32
 182afa0:	10000d1e 	bne	r2,zero,182afd8 <lwip_getsockopt_internal+0xdc>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182afa4:	00006e06 	br	182b160 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182afa8:	10c401e0 	cmpeqi	r3,r2,4103
 182afac:	1800331e 	bne	r3,zero,182b07c <lwip_getsockopt_internal+0x180>
 182afb0:	10c40208 	cmpgei	r3,r2,4104
 182afb4:	1800031e 	bne	r3,zero,182afc4 <lwip_getsockopt_internal+0xc8>
 182afb8:	108401a0 	cmpeqi	r2,r2,4102
 182afbc:	1000571e 	bne	r2,zero,182b11c <lwip_getsockopt_internal+0x220>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182afc0:	00006706 	br	182b160 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182afc4:	10c40220 	cmpeqi	r3,r2,4104
 182afc8:	18000d1e 	bne	r3,zero,182b000 <lwip_getsockopt_internal+0x104>
 182afcc:	108402a0 	cmpeqi	r2,r2,4106
 182afd0:	1000581e 	bne	r2,zero,182b134 <lwip_getsockopt_internal+0x238>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182afd4:	00006206 	br	182b160 <lwip_getsockopt_internal+0x264>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
 182afd8:	e0bffb17 	ldw	r2,-20(fp)
 182afdc:	10800017 	ldw	r2,0(r2)
 182afe0:	10800217 	ldw	r2,8(r2)
 182afe4:	10800203 	ldbu	r2,8(r2)
 182afe8:	10c03fcc 	andi	r3,r2,255
 182afec:	e0bffd17 	ldw	r2,-12(fp)
 182aff0:	1886703a 	and	r3,r3,r2
 182aff4:	e0bffe17 	ldw	r2,-8(fp)
 182aff8:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
 182affc:	00005806 	br	182b160 <lwip_getsockopt_internal+0x264>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
 182b000:	e0bffb17 	ldw	r2,-20(fp)
 182b004:	10800017 	ldw	r2,0(r2)
 182b008:	10800017 	ldw	r2,0(r2)
 182b00c:	10803c0c 	andi	r2,r2,240
 182b010:	10c00820 	cmpeqi	r3,r2,32
 182b014:	18000d1e 	bne	r3,zero,182b04c <lwip_getsockopt_internal+0x150>
 182b018:	10c01020 	cmpeqi	r3,r2,64
 182b01c:	1800031e 	bne	r3,zero,182b02c <lwip_getsockopt_internal+0x130>
 182b020:	10800420 	cmpeqi	r2,r2,16
 182b024:	1000051e 	bne	r2,zero,182b03c <lwip_getsockopt_internal+0x140>
 182b028:	00000c06 	br	182b05c <lwip_getsockopt_internal+0x160>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
 182b02c:	e0bffe17 	ldw	r2,-8(fp)
 182b030:	00c000c4 	movi	r3,3
 182b034:	10c00015 	stw	r3,0(r2)
        break;
 182b038:	00000f06 	br	182b078 <lwip_getsockopt_internal+0x17c>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
 182b03c:	e0bffe17 	ldw	r2,-8(fp)
 182b040:	00c00044 	movi	r3,1
 182b044:	10c00015 	stw	r3,0(r2)
        break;
 182b048:	00000b06 	br	182b078 <lwip_getsockopt_internal+0x17c>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
 182b04c:	e0bffe17 	ldw	r2,-8(fp)
 182b050:	00c00084 	movi	r3,2
 182b054:	10c00015 	stw	r3,0(r2)
        break;
 182b058:	00000706 	br	182b078 <lwip_getsockopt_internal+0x17c>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
 182b05c:	e0bffb17 	ldw	r2,-20(fp)
 182b060:	10800017 	ldw	r2,0(r2)
 182b064:	10800017 	ldw	r2,0(r2)
 182b068:	1007883a 	mov	r3,r2
 182b06c:	e0bffe17 	ldw	r2,-8(fp)
 182b070:	10c00015 	stw	r3,0(r2)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
 182b074:	00003a06 	br	182b160 <lwip_getsockopt_internal+0x264>
 182b078:	00003906 	br	182b160 <lwip_getsockopt_internal+0x264>

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
 182b07c:	e0bffb17 	ldw	r2,-20(fp)
 182b080:	10800417 	ldw	r2,16(r2)
 182b084:	10000426 	beq	r2,zero,182b098 <lwip_getsockopt_internal+0x19c>
 182b088:	e0bffb17 	ldw	r2,-20(fp)
 182b08c:	10800417 	ldw	r2,16(r2)
 182b090:	10801dd8 	cmpnei	r2,r2,119
 182b094:	10001a1e 	bne	r2,zero,182b100 <lwip_getsockopt_internal+0x204>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
 182b098:	e0bffb17 	ldw	r2,-20(fp)
 182b09c:	10800017 	ldw	r2,0(r2)
 182b0a0:	10800303 	ldbu	r2,12(r2)
 182b0a4:	10803fcc 	andi	r2,r2,255
 182b0a8:	1080201c 	xori	r2,r2,128
 182b0ac:	10bfe004 	addi	r2,r2,-128
 182b0b0:	0085c83a 	sub	r2,zero,r2
 182b0b4:	10800428 	cmpgeui	r2,r2,16
 182b0b8:	10000e1e 	bne	r2,zero,182b0f4 <lwip_getsockopt_internal+0x1f8>
 182b0bc:	e0bffb17 	ldw	r2,-20(fp)
 182b0c0:	10800017 	ldw	r2,0(r2)
 182b0c4:	10800303 	ldbu	r2,12(r2)
 182b0c8:	10803fcc 	andi	r2,r2,255
 182b0cc:	1080201c 	xori	r2,r2,128
 182b0d0:	10bfe004 	addi	r2,r2,-128
 182b0d4:	0087c83a 	sub	r3,zero,r2
 182b0d8:	00806134 	movhi	r2,388
 182b0dc:	10876104 	addi	r2,r2,7556
 182b0e0:	18c7883a 	add	r3,r3,r3
 182b0e4:	18c7883a 	add	r3,r3,r3
 182b0e8:	10c5883a 	add	r2,r2,r3
 182b0ec:	10800017 	ldw	r2,0(r2)
 182b0f0:	00000106 	br	182b0f8 <lwip_getsockopt_internal+0x1fc>
 182b0f4:	00800144 	movi	r2,5
 182b0f8:	e0fffb17 	ldw	r3,-20(fp)
 182b0fc:	18800415 	stw	r2,16(r3)
      } 
      *(int *)optval = sock->err;
 182b100:	e0bffb17 	ldw	r2,-20(fp)
 182b104:	10c00417 	ldw	r3,16(r2)
 182b108:	e0bffe17 	ldw	r2,-8(fp)
 182b10c:	10c00015 	stw	r3,0(r2)
      sock->err = 0;
 182b110:	e0bffb17 	ldw	r2,-20(fp)
 182b114:	10000415 	stw	zero,16(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
 182b118:	00001106 	br	182b160 <lwip_getsockopt_internal+0x264>
      *(int *)optval = netconn_get_sendtimeout(sock->conn);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      *(int *)optval = netconn_get_recvtimeout(sock->conn);
 182b11c:	e0bffb17 	ldw	r2,-20(fp)
 182b120:	10800017 	ldw	r2,0(r2)
 182b124:	10c00817 	ldw	r3,32(r2)
 182b128:	e0bffe17 	ldw	r2,-8(fp)
 182b12c:	10c00015 	stw	r3,0(r2)
      break;
 182b130:	00000b06 	br	182b160 <lwip_getsockopt_internal+0x264>
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
 182b134:	e0bffb17 	ldw	r2,-20(fp)
 182b138:	10800017 	ldw	r2,0(r2)
 182b13c:	10800217 	ldw	r2,8(r2)
 182b140:	10800403 	ldbu	r2,16(r2)
 182b144:	10803fcc 	andi	r2,r2,255
 182b148:	1080004c 	andi	r2,r2,1
 182b14c:	1004c03a 	cmpne	r2,r2,zero
 182b150:	10c03fcc 	andi	r3,r2,255
 182b154:	e0bffe17 	ldw	r2,-8(fp)
 182b158:	10c00015 	stw	r3,0(r2)
      break;
 182b15c:	0001883a 	nop
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 182b160:	00005a06 	br	182b2cc <lwip_getsockopt_internal+0x3d0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 182b164:	e0bffd17 	ldw	r2,-12(fp)
 182b168:	10c00060 	cmpeqi	r3,r2,1
 182b16c:	18000b1e 	bne	r3,zero,182b19c <lwip_getsockopt_internal+0x2a0>
 182b170:	108000a0 	cmpeqi	r2,r2,2
 182b174:	1000011e 	bne	r2,zero,182b17c <lwip_getsockopt_internal+0x280>
                  s, *(int *)optval));
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b178:	00001006 	br	182b1bc <lwip_getsockopt_internal+0x2c0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
 182b17c:	e0bffb17 	ldw	r2,-20(fp)
 182b180:	10800017 	ldw	r2,0(r2)
 182b184:	10800217 	ldw	r2,8(r2)
 182b188:	10800283 	ldbu	r2,10(r2)
 182b18c:	10c03fcc 	andi	r3,r2,255
 182b190:	e0bffe17 	ldw	r2,-8(fp)
 182b194:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
 182b198:	00000806 	br	182b1bc <lwip_getsockopt_internal+0x2c0>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
 182b19c:	e0bffb17 	ldw	r2,-20(fp)
 182b1a0:	10800017 	ldw	r2,0(r2)
 182b1a4:	10800217 	ldw	r2,8(r2)
 182b1a8:	10800243 	ldbu	r2,9(r2)
 182b1ac:	10c03fcc 	andi	r3,r2,255
 182b1b0:	e0bffe17 	ldw	r2,-8(fp)
 182b1b4:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
 182b1b8:	0001883a 	nop
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 182b1bc:	00004306 	br	182b2cc <lwip_getsockopt_internal+0x3d0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 182b1c0:	e0bffd17 	ldw	r2,-12(fp)
 182b1c4:	108001a8 	cmpgeui	r2,r2,6
 182b1c8:	10003e1e 	bne	r2,zero,182b2c4 <lwip_getsockopt_internal+0x3c8>
 182b1cc:	e0bffd17 	ldw	r2,-12(fp)
 182b1d0:	100690ba 	slli	r3,r2,2
 182b1d4:	008060f4 	movhi	r2,387
 182b1d8:	10ac7a04 	addi	r2,r2,-19992
 182b1dc:	1885883a 	add	r2,r3,r2
 182b1e0:	10800017 	ldw	r2,0(r2)
 182b1e4:	1000683a 	jmp	r2
 182b1e8:	0182b2c4 	movi	r6,2763
 182b1ec:	0182b200 	call	182b20 <__alt_mem_tse_descriptor_memory_0+0x182b20>
 182b1f0:	0182b22c 	andhi	r6,zero,2760
 182b1f4:	0182b24c 	andi	r6,zero,2761
 182b1f8:	0182b278 	rdprs	r6,zero,2761
 182b1fc:	0182b2a4 	muli	r6,zero,2762
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
 182b200:	e0bffb17 	ldw	r2,-20(fp)
 182b204:	10800017 	ldw	r2,0(r2)
 182b208:	10800217 	ldw	r2,8(r2)
 182b20c:	10800883 	ldbu	r2,34(r2)
 182b210:	10803fcc 	andi	r2,r2,255
 182b214:	1080100c 	andi	r2,r2,64
 182b218:	1004c03a 	cmpne	r2,r2,zero
 182b21c:	10c03fcc 	andi	r3,r2,255
 182b220:	e0bffe17 	ldw	r2,-8(fp)
 182b224:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
 182b228:	00002706 	br	182b2c8 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
 182b22c:	e0bffb17 	ldw	r2,-20(fp)
 182b230:	10800017 	ldw	r2,0(r2)
 182b234:	10800217 	ldw	r2,8(r2)
 182b238:	10802517 	ldw	r2,148(r2)
 182b23c:	1007883a 	mov	r3,r2
 182b240:	e0bffe17 	ldw	r2,-8(fp)
 182b244:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
 182b248:	00001f06 	br	182b2c8 <lwip_getsockopt_internal+0x3cc>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
 182b24c:	e0bffb17 	ldw	r2,-20(fp)
 182b250:	10800017 	ldw	r2,0(r2)
 182b254:	10800217 	ldw	r2,8(r2)
 182b258:	10802517 	ldw	r2,148(r2)
 182b25c:	0140fa04 	movi	r5,1000
 182b260:	1009883a 	mov	r4,r2
 182b264:	180ad100 	call	180ad10 <__udivsi3>
 182b268:	1007883a 	mov	r3,r2
 182b26c:	e0bffe17 	ldw	r2,-8(fp)
 182b270:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
                  s, *(int *)optval));
      break;
 182b274:	00001406 	br	182b2c8 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPINTVL:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
 182b278:	e0bffb17 	ldw	r2,-20(fp)
 182b27c:	10800017 	ldw	r2,0(r2)
 182b280:	10800217 	ldw	r2,8(r2)
 182b284:	10802617 	ldw	r2,152(r2)
 182b288:	0140fa04 	movi	r5,1000
 182b28c:	1009883a 	mov	r4,r2
 182b290:	180ad100 	call	180ad10 <__udivsi3>
 182b294:	1007883a 	mov	r3,r2
 182b298:	e0bffe17 	ldw	r2,-8(fp)
 182b29c:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
                  s, *(int *)optval));
      break;
 182b2a0:	00000906 	br	182b2c8 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPCNT:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
 182b2a4:	e0bffb17 	ldw	r2,-20(fp)
 182b2a8:	10800017 	ldw	r2,0(r2)
 182b2ac:	10800217 	ldw	r2,8(r2)
 182b2b0:	10802717 	ldw	r2,156(r2)
 182b2b4:	1007883a 	mov	r3,r2
 182b2b8:	e0bffe17 	ldw	r2,-8(fp)
 182b2bc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
 182b2c0:	00000106 	br	182b2c8 <lwip_getsockopt_internal+0x3cc>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b2c4:	0001883a 	nop
    }  /* switch (optname) */
    break;
 182b2c8:	0001883a 	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 182b2cc:	e0bffb17 	ldw	r2,-20(fp)
 182b2d0:	10800017 	ldw	r2,0(r2)
 182b2d4:	10800404 	addi	r2,r2,16
 182b2d8:	1009883a 	mov	r4,r2
 182b2dc:	18150740 	call	1815074 <sys_sem_signal>
}
 182b2e0:	0001883a 	nop
 182b2e4:	e037883a 	mov	sp,fp
 182b2e8:	dfc00117 	ldw	ra,4(sp)
 182b2ec:	df000017 	ldw	fp,0(sp)
 182b2f0:	dec00204 	addi	sp,sp,8
 182b2f4:	f800283a 	ret

0182b2f8 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 182b2f8:	defff204 	addi	sp,sp,-56
 182b2fc:	dfc00d15 	stw	ra,52(sp)
 182b300:	df000c15 	stw	fp,48(sp)
 182b304:	df000c04 	addi	fp,sp,48
 182b308:	e13ffc15 	stw	r4,-16(fp)
 182b30c:	e17ffd15 	stw	r5,-12(fp)
 182b310:	e1bffe15 	stw	r6,-8(fp)
 182b314:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 182b318:	e13ffc17 	ldw	r4,-16(fp)
 182b31c:	18288400 	call	1828840 <get_socket>
 182b320:	e0bff515 	stw	r2,-44(fp)
  err_t err = ERR_OK;
 182b324:	e03ff405 	stb	zero,-48(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
 182b328:	e0bff517 	ldw	r2,-44(fp)
 182b32c:	1000021e 	bne	r2,zero,182b338 <lwip_setsockopt+0x40>
    return -1;
 182b330:	00bfffc4 	movi	r2,-1
 182b334:	00009006 	br	182b578 <lwip_setsockopt+0x280>
  }

  if (NULL == optval) {
 182b338:	e0bfff17 	ldw	r2,-4(fp)
 182b33c:	1000051e 	bne	r2,zero,182b354 <lwip_setsockopt+0x5c>
    sock_set_errno(sock, EFAULT);
 182b340:	e0bff517 	ldw	r2,-44(fp)
 182b344:	00c00384 	movi	r3,14
 182b348:	10c00415 	stw	r3,16(r2)
    return -1;
 182b34c:	00bfffc4 	movi	r2,-1
 182b350:	00008906 	br	182b578 <lwip_setsockopt+0x280>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 182b354:	e0bffd17 	ldw	r2,-12(fp)
 182b358:	10c001a0 	cmpeqi	r3,r2,6
 182b35c:	1800441e 	bne	r3,zero,182b470 <lwip_setsockopt+0x178>
 182b360:	10c3ffe0 	cmpeqi	r3,r2,4095
 182b364:	1800021e 	bne	r3,zero,182b370 <lwip_setsockopt+0x78>
 182b368:	10003226 	beq	r2,zero,182b434 <lwip_setsockopt+0x13c>
 182b36c:	00005606 	br	182b4c8 <lwip_setsockopt+0x1d0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182b370:	e0bffe17 	ldw	r2,-8(fp)
 182b374:	10c00820 	cmpeqi	r3,r2,32
 182b378:	18000d1e 	bne	r3,zero,182b3b0 <lwip_setsockopt+0xb8>
 182b37c:	10c00848 	cmpgei	r3,r2,33
 182b380:	1800051e 	bne	r3,zero,182b398 <lwip_setsockopt+0xa0>
 182b384:	10c00120 	cmpeqi	r3,r2,4
 182b388:	1800091e 	bne	r3,zero,182b3b0 <lwip_setsockopt+0xb8>
 182b38c:	10800220 	cmpeqi	r2,r2,8
 182b390:	1000071e 	bne	r2,zero,182b3b0 <lwip_setsockopt+0xb8>
 182b394:	00002006 	br	182b418 <lwip_setsockopt+0x120>
 182b398:	10c401a0 	cmpeqi	r3,r2,4102
 182b39c:	1800041e 	bne	r3,zero,182b3b0 <lwip_setsockopt+0xb8>
 182b3a0:	10c402a0 	cmpeqi	r3,r2,4106
 182b3a4:	1800081e 	bne	r3,zero,182b3c8 <lwip_setsockopt+0xd0>
 182b3a8:	10808020 	cmpeqi	r2,r2,512
 182b3ac:	10001a26 	beq	r2,zero,182b418 <lwip_setsockopt+0x120>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
 182b3b0:	e0800217 	ldw	r2,8(fp)
 182b3b4:	10800128 	cmpgeui	r2,r2,4
 182b3b8:	10001a1e 	bne	r2,zero,182b424 <lwip_setsockopt+0x12c>
        err = EINVAL;
 182b3bc:	00800584 	movi	r2,22
 182b3c0:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 182b3c4:	00001706 	br	182b424 <lwip_setsockopt+0x12c>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
 182b3c8:	e0800217 	ldw	r2,8(fp)
 182b3cc:	10800128 	cmpgeui	r2,r2,4
 182b3d0:	1000021e 	bne	r2,zero,182b3dc <lwip_setsockopt+0xe4>
        err = EINVAL;
 182b3d4:	00800584 	movi	r2,22
 182b3d8:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 182b3dc:	e0bff517 	ldw	r2,-44(fp)
 182b3e0:	10800017 	ldw	r2,0(r2)
 182b3e4:	10800017 	ldw	r2,0(r2)
 182b3e8:	10800818 	cmpnei	r2,r2,32
 182b3ec:	1000071e 	bne	r2,zero,182b40c <lwip_setsockopt+0x114>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 182b3f0:	e0bff517 	ldw	r2,-44(fp)
 182b3f4:	10800017 	ldw	r2,0(r2)
 182b3f8:	10800217 	ldw	r2,8(r2)
 182b3fc:	10800403 	ldbu	r2,16(r2)
 182b400:	10803fcc 	andi	r2,r2,255
 182b404:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 182b408:	10000826 	beq	r2,zero,182b42c <lwip_setsockopt+0x134>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
 182b40c:	00801a84 	movi	r2,106
 182b410:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
 182b414:	00000506 	br	182b42c <lwip_setsockopt+0x134>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
 182b418:	00801b44 	movi	r2,109
 182b41c:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182b420:	00002b06 	br	182b4d0 <lwip_setsockopt+0x1d8>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 182b424:	0001883a 	nop
 182b428:	00002906 	br	182b4d0 <lwip_setsockopt+0x1d8>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
 182b42c:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182b430:	00002706 	br	182b4d0 <lwip_setsockopt+0x1d8>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 182b434:	e0bffe17 	ldw	r2,-8(fp)
 182b438:	10bfffc4 	addi	r2,r2,-1
 182b43c:	108000a8 	cmpgeui	r2,r2,2
 182b440:	1000061e 	bne	r2,zero,182b45c <lwip_setsockopt+0x164>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
 182b444:	e0800217 	ldw	r2,8(fp)
 182b448:	10800128 	cmpgeui	r2,r2,4
 182b44c:	1000061e 	bne	r2,zero,182b468 <lwip_setsockopt+0x170>
        err = EINVAL;
 182b450:	00800584 	movi	r2,22
 182b454:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 182b458:	00000306 	br	182b468 <lwip_setsockopt+0x170>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
 182b45c:	00801b44 	movi	r2,109
 182b460:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182b464:	00001a06 	br	182b4d0 <lwip_setsockopt+0x1d8>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 182b468:	0001883a 	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182b46c:	00001806 	br	182b4d0 <lwip_setsockopt+0x1d8>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
 182b470:	e0800217 	ldw	r2,8(fp)
 182b474:	10800128 	cmpgeui	r2,r2,4
 182b478:	1000031e 	bne	r2,zero,182b488 <lwip_setsockopt+0x190>
      err = EINVAL;
 182b47c:	00800584 	movi	r2,22
 182b480:	e0bff405 	stb	r2,-48(fp)
      break;
 182b484:	00001206 	br	182b4d0 <lwip_setsockopt+0x1d8>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 182b488:	e0bff517 	ldw	r2,-44(fp)
 182b48c:	10800017 	ldw	r2,0(r2)
 182b490:	10800017 	ldw	r2,0(r2)
 182b494:	10800420 	cmpeqi	r2,r2,16
 182b498:	1000021e 	bne	r2,zero,182b4a4 <lwip_setsockopt+0x1ac>
      return 0;
 182b49c:	0005883a 	mov	r2,zero
 182b4a0:	00003506 	br	182b578 <lwip_setsockopt+0x280>

    switch (optname) {
 182b4a4:	e0bffe17 	ldw	r2,-8(fp)
 182b4a8:	10bfffc4 	addi	r2,r2,-1
 182b4ac:	10800168 	cmpgeui	r2,r2,5
 182b4b0:	10000326 	beq	r2,zero,182b4c0 <lwip_setsockopt+0x1c8>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
 182b4b4:	00801b44 	movi	r2,109
 182b4b8:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 182b4bc:	00000406 	br	182b4d0 <lwip_setsockopt+0x1d8>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
 182b4c0:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 182b4c4:	00000206 	br	182b4d0 <lwip_setsockopt+0x1d8>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
 182b4c8:	00801b44 	movi	r2,109
 182b4cc:	e0bff405 	stb	r2,-48(fp)
  }  /* switch (level) */


  if (err != ERR_OK) {
 182b4d0:	e0bff407 	ldb	r2,-48(fp)
 182b4d4:	10000526 	beq	r2,zero,182b4ec <lwip_setsockopt+0x1f4>
    sock_set_errno(sock, err);
 182b4d8:	e0fff407 	ldb	r3,-48(fp)
 182b4dc:	e0bff517 	ldw	r2,-44(fp)
 182b4e0:	10c00415 	stw	r3,16(r2)
    return -1;
 182b4e4:	00bfffc4 	movi	r2,-1
 182b4e8:	00002306 	br	182b578 <lwip_setsockopt+0x280>
  }


  /* Now do the actual option processing */
  data.sock = sock;
 182b4ec:	e0bff517 	ldw	r2,-44(fp)
 182b4f0:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 182b4f4:	e0bffd17 	ldw	r2,-12(fp)
 182b4f8:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
 182b4fc:	e0bffe17 	ldw	r2,-8(fp)
 182b500:	e0bff815 	stw	r2,-32(fp)
  data.optval = (void*)optval;
 182b504:	e0bfff17 	ldw	r2,-4(fp)
 182b508:	e0bff915 	stw	r2,-28(fp)
  data.optlen = &optlen;
 182b50c:	e0800204 	addi	r2,fp,8
 182b510:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
 182b514:	e0bff403 	ldbu	r2,-48(fp)
 182b518:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_setsockopt_internal, &data);
 182b51c:	e0bff604 	addi	r2,fp,-40
 182b520:	01800044 	movi	r6,1
 182b524:	100b883a 	mov	r5,r2
 182b528:	010060f4 	movhi	r4,387
 182b52c:	212d6304 	addi	r4,r4,-19060
 182b530:	182bd1c0 	call	182bd1c <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 182b534:	e0bff517 	ldw	r2,-44(fp)
 182b538:	10800017 	ldw	r2,0(r2)
 182b53c:	10800404 	addi	r2,r2,16
 182b540:	000b883a 	mov	r5,zero
 182b544:	1009883a 	mov	r4,r2
 182b548:	18150bc0 	call	18150bc <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
 182b54c:	e0bffb03 	ldbu	r2,-20(fp)
 182b550:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
 182b554:	e0fff407 	ldb	r3,-48(fp)
 182b558:	e0bff517 	ldw	r2,-44(fp)
 182b55c:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
 182b560:	e0bff407 	ldb	r2,-48(fp)
 182b564:	10000226 	beq	r2,zero,182b570 <lwip_setsockopt+0x278>
 182b568:	00bfffc4 	movi	r2,-1
 182b56c:	00000206 	br	182b578 <lwip_setsockopt+0x280>
 182b570:	0005883a 	mov	r2,zero
 182b574:	0001883a 	nop
}
 182b578:	e037883a 	mov	sp,fp
 182b57c:	dfc00117 	ldw	ra,4(sp)
 182b580:	df000017 	ldw	fp,0(sp)
 182b584:	dec00204 	addi	sp,sp,8
 182b588:	f800283a 	ret

0182b58c <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
 182b58c:	defff804 	addi	sp,sp,-32
 182b590:	dfc00715 	stw	ra,28(sp)
 182b594:	df000615 	stw	fp,24(sp)
 182b598:	df000604 	addi	fp,sp,24
 182b59c:	e13fff15 	stw	r4,-4(fp)
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
 182b5a0:	e0bfff17 	ldw	r2,-4(fp)
 182b5a4:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
 182b5a8:	e0bffa17 	ldw	r2,-24(fp)
 182b5ac:	10800017 	ldw	r2,0(r2)
 182b5b0:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
 182b5b4:	e0bffa17 	ldw	r2,-24(fp)
 182b5b8:	10800117 	ldw	r2,4(r2)
 182b5bc:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
 182b5c0:	e0bffa17 	ldw	r2,-24(fp)
 182b5c4:	10800217 	ldw	r2,8(r2)
 182b5c8:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
 182b5cc:	e0bffa17 	ldw	r2,-24(fp)
 182b5d0:	10800317 	ldw	r2,12(r2)
 182b5d4:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
 182b5d8:	e0bffc17 	ldw	r2,-16(fp)
 182b5dc:	10c001a0 	cmpeqi	r3,r2,6
 182b5e0:	1800651e 	bne	r3,zero,182b778 <lwip_setsockopt_internal+0x1ec>
 182b5e4:	10c3ffe0 	cmpeqi	r3,r2,4095
 182b5e8:	1800021e 	bne	r3,zero,182b5f4 <lwip_setsockopt_internal+0x68>
 182b5ec:	10004d26 	beq	r2,zero,182b724 <lwip_setsockopt_internal+0x198>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
 182b5f0:	0000a906 	br	182b898 <lwip_setsockopt_internal+0x30c>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182b5f4:	e0bffd17 	ldw	r2,-12(fp)
 182b5f8:	10c00820 	cmpeqi	r3,r2,32
 182b5fc:	18000e1e 	bne	r3,zero,182b638 <lwip_setsockopt_internal+0xac>
 182b600:	10c00848 	cmpgei	r3,r2,33
 182b604:	1800051e 	bne	r3,zero,182b61c <lwip_setsockopt_internal+0x90>
 182b608:	10c00120 	cmpeqi	r3,r2,4
 182b60c:	18000a1e 	bne	r3,zero,182b638 <lwip_setsockopt_internal+0xac>
 182b610:	10800220 	cmpeqi	r2,r2,8
 182b614:	1000081e 	bne	r2,zero,182b638 <lwip_setsockopt_internal+0xac>
      }
      break;
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b618:	00004106 	br	182b720 <lwip_setsockopt_internal+0x194>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 182b61c:	10c401a0 	cmpeqi	r3,r2,4102
 182b620:	1800211e 	bne	r3,zero,182b6a8 <lwip_setsockopt_internal+0x11c>
 182b624:	10c402a0 	cmpeqi	r3,r2,4106
 182b628:	1800251e 	bne	r3,zero,182b6c0 <lwip_setsockopt_internal+0x134>
 182b62c:	10808020 	cmpeqi	r2,r2,512
 182b630:	1000011e 	bne	r2,zero,182b638 <lwip_setsockopt_internal+0xac>
      }
      break;
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b634:	00003a06 	br	182b720 <lwip_setsockopt_internal+0x194>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
 182b638:	e0bffe17 	ldw	r2,-8(fp)
 182b63c:	10800017 	ldw	r2,0(r2)
 182b640:	10000c26 	beq	r2,zero,182b674 <lwip_setsockopt_internal+0xe8>
        ip_set_option(sock->conn->pcb.ip, optname);
 182b644:	e0bffb17 	ldw	r2,-20(fp)
 182b648:	10800017 	ldw	r2,0(r2)
 182b64c:	10800217 	ldw	r2,8(r2)
 182b650:	e0fffb17 	ldw	r3,-20(fp)
 182b654:	18c00017 	ldw	r3,0(r3)
 182b658:	18c00217 	ldw	r3,8(r3)
 182b65c:	18c00203 	ldbu	r3,8(r3)
 182b660:	1809883a 	mov	r4,r3
 182b664:	e0fffd17 	ldw	r3,-12(fp)
 182b668:	20c6b03a 	or	r3,r4,r3
 182b66c:	10c00205 	stb	r3,8(r2)
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
 182b670:	00002b06 	br	182b720 <lwip_setsockopt_internal+0x194>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        ip_set_option(sock->conn->pcb.ip, optname);
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
 182b674:	e0bffb17 	ldw	r2,-20(fp)
 182b678:	10800017 	ldw	r2,0(r2)
 182b67c:	10800217 	ldw	r2,8(r2)
 182b680:	e0fffb17 	ldw	r3,-20(fp)
 182b684:	18c00017 	ldw	r3,0(r3)
 182b688:	18c00217 	ldw	r3,8(r3)
 182b68c:	18c00203 	ldbu	r3,8(r3)
 182b690:	1809883a 	mov	r4,r3
 182b694:	e0fffd17 	ldw	r3,-12(fp)
 182b698:	00c6303a 	nor	r3,zero,r3
 182b69c:	20c6703a 	and	r3,r4,r3
 182b6a0:	10c00205 	stb	r3,8(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
 182b6a4:	00001e06 	br	182b720 <lwip_setsockopt_internal+0x194>
      netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      netconn_set_recvtimeout(sock->conn, *(int*)optval);
 182b6a8:	e0bffb17 	ldw	r2,-20(fp)
 182b6ac:	10800017 	ldw	r2,0(r2)
 182b6b0:	e0fffe17 	ldw	r3,-8(fp)
 182b6b4:	18c00017 	ldw	r3,0(r3)
 182b6b8:	10c00815 	stw	r3,32(r2)
      break;
 182b6bc:	00001806 	br	182b720 <lwip_setsockopt_internal+0x194>
      netconn_set_recvbufsize(sock->conn, *(int*)optval);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
 182b6c0:	e0bffe17 	ldw	r2,-8(fp)
 182b6c4:	10800017 	ldw	r2,0(r2)
 182b6c8:	10000a26 	beq	r2,zero,182b6f4 <lwip_setsockopt_internal+0x168>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
 182b6cc:	e0bffb17 	ldw	r2,-20(fp)
 182b6d0:	10800017 	ldw	r2,0(r2)
 182b6d4:	10800217 	ldw	r2,8(r2)
 182b6d8:	e0fffb17 	ldw	r3,-20(fp)
 182b6dc:	18c00017 	ldw	r3,0(r3)
 182b6e0:	18c00217 	ldw	r3,8(r3)
 182b6e4:	18c00403 	ldbu	r3,16(r3)
 182b6e8:	18c00054 	ori	r3,r3,1
 182b6ec:	10c00405 	stb	r3,16(r2)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
 182b6f0:	00000a06 	br	182b71c <lwip_setsockopt_internal+0x190>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
 182b6f4:	e0bffb17 	ldw	r2,-20(fp)
 182b6f8:	10800017 	ldw	r2,0(r2)
 182b6fc:	10800217 	ldw	r2,8(r2)
 182b700:	e0fffb17 	ldw	r3,-20(fp)
 182b704:	18c00017 	ldw	r3,0(r3)
 182b708:	18c00217 	ldw	r3,8(r3)
 182b70c:	19000403 	ldbu	r4,16(r3)
 182b710:	00ffff84 	movi	r3,-2
 182b714:	20c6703a 	and	r3,r4,r3
 182b718:	10c00405 	stb	r3,16(r2)
      }
      break;
 182b71c:	0001883a 	nop
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 182b720:	00005d06 	br	182b898 <lwip_setsockopt_internal+0x30c>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 182b724:	e0bffd17 	ldw	r2,-12(fp)
 182b728:	10c00060 	cmpeqi	r3,r2,1
 182b72c:	18000a1e 	bne	r3,zero,182b758 <lwip_setsockopt_internal+0x1cc>
 182b730:	108000a0 	cmpeqi	r2,r2,2
 182b734:	1000011e 	bne	r2,zero,182b73c <lwip_setsockopt_internal+0x1b0>
      }
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b738:	00000e06 	br	182b774 <lwip_setsockopt_internal+0x1e8>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
 182b73c:	e0bffb17 	ldw	r2,-20(fp)
 182b740:	10800017 	ldw	r2,0(r2)
 182b744:	10800217 	ldw	r2,8(r2)
 182b748:	e0fffe17 	ldw	r3,-8(fp)
 182b74c:	18c00017 	ldw	r3,0(r3)
 182b750:	10c00285 	stb	r3,10(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
 182b754:	00000706 	br	182b774 <lwip_setsockopt_internal+0x1e8>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
 182b758:	e0bffb17 	ldw	r2,-20(fp)
 182b75c:	10800017 	ldw	r2,0(r2)
 182b760:	10800217 	ldw	r2,8(r2)
 182b764:	e0fffe17 	ldw	r3,-8(fp)
 182b768:	18c00017 	ldw	r3,0(r3)
 182b76c:	10c00245 	stb	r3,9(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
 182b770:	0001883a 	nop
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 182b774:	00004806 	br	182b898 <lwip_setsockopt_internal+0x30c>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 182b778:	e0bffd17 	ldw	r2,-12(fp)
 182b77c:	108001a8 	cmpgeui	r2,r2,6
 182b780:	1000431e 	bne	r2,zero,182b890 <lwip_setsockopt_internal+0x304>
 182b784:	e0bffd17 	ldw	r2,-12(fp)
 182b788:	100690ba 	slli	r3,r2,2
 182b78c:	008060f4 	movhi	r2,387
 182b790:	10ade804 	addi	r2,r2,-18528
 182b794:	1885883a 	add	r2,r3,r2
 182b798:	10800017 	ldw	r2,0(r2)
 182b79c:	1000683a 	jmp	r2
 182b7a0:	0182b890 	cmplti	r6,zero,2786
 182b7a4:	0182b7b8 	rdprs	r6,zero,2782
 182b7a8:	0182b818 	cmpnei	r6,zero,2784
 182b7ac:	0182b834 	movhi	r6,2784
 182b7b0:	0182b854 	movui	r6,2785
 182b7b4:	0182b874 	movhi	r6,2785
    case TCP_NODELAY:
      if (*(int*)optval) {
 182b7b8:	e0bffe17 	ldw	r2,-8(fp)
 182b7bc:	10800017 	ldw	r2,0(r2)
 182b7c0:	10000a26 	beq	r2,zero,182b7ec <lwip_setsockopt_internal+0x260>
        tcp_nagle_disable(sock->conn->pcb.tcp);
 182b7c4:	e0bffb17 	ldw	r2,-20(fp)
 182b7c8:	10800017 	ldw	r2,0(r2)
 182b7cc:	10800217 	ldw	r2,8(r2)
 182b7d0:	e0fffb17 	ldw	r3,-20(fp)
 182b7d4:	18c00017 	ldw	r3,0(r3)
 182b7d8:	18c00217 	ldw	r3,8(r3)
 182b7dc:	18c00883 	ldbu	r3,34(r3)
 182b7e0:	18c01014 	ori	r3,r3,64
 182b7e4:	10c00885 	stb	r3,34(r2)
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
 182b7e8:	00002a06 	br	182b894 <lwip_setsockopt_internal+0x308>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        tcp_nagle_disable(sock->conn->pcb.tcp);
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
 182b7ec:	e0bffb17 	ldw	r2,-20(fp)
 182b7f0:	10800017 	ldw	r2,0(r2)
 182b7f4:	10800217 	ldw	r2,8(r2)
 182b7f8:	e0fffb17 	ldw	r3,-20(fp)
 182b7fc:	18c00017 	ldw	r3,0(r3)
 182b800:	18c00217 	ldw	r3,8(r3)
 182b804:	19000883 	ldbu	r4,34(r3)
 182b808:	00ffefc4 	movi	r3,-65
 182b80c:	20c6703a 	and	r3,r4,r3
 182b810:	10c00885 	stb	r3,34(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
 182b814:	00001f06 	br	182b894 <lwip_setsockopt_internal+0x308>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
 182b818:	e0bffb17 	ldw	r2,-20(fp)
 182b81c:	10800017 	ldw	r2,0(r2)
 182b820:	10800217 	ldw	r2,8(r2)
 182b824:	e0fffe17 	ldw	r3,-8(fp)
 182b828:	18c00017 	ldw	r3,0(r3)
 182b82c:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
 182b830:	00001806 	br	182b894 <lwip_setsockopt_internal+0x308>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
 182b834:	e0bffb17 	ldw	r2,-20(fp)
 182b838:	10800017 	ldw	r2,0(r2)
 182b83c:	10800217 	ldw	r2,8(r2)
 182b840:	e0fffe17 	ldw	r3,-8(fp)
 182b844:	18c00017 	ldw	r3,0(r3)
 182b848:	18c0fa24 	muli	r3,r3,1000
 182b84c:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
 182b850:	00001006 	br	182b894 <lwip_setsockopt_internal+0x308>
    case TCP_KEEPINTVL:
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
 182b854:	e0bffb17 	ldw	r2,-20(fp)
 182b858:	10800017 	ldw	r2,0(r2)
 182b85c:	10800217 	ldw	r2,8(r2)
 182b860:	e0fffe17 	ldw	r3,-8(fp)
 182b864:	18c00017 	ldw	r3,0(r3)
 182b868:	18c0fa24 	muli	r3,r3,1000
 182b86c:	10c02615 	stw	r3,152(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_intvl));
      break;
 182b870:	00000806 	br	182b894 <lwip_setsockopt_internal+0x308>
    case TCP_KEEPCNT:
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
 182b874:	e0bffb17 	ldw	r2,-20(fp)
 182b878:	10800017 	ldw	r2,0(r2)
 182b87c:	10800217 	ldw	r2,8(r2)
 182b880:	e0fffe17 	ldw	r3,-8(fp)
 182b884:	18c00017 	ldw	r3,0(r3)
 182b888:	10c02715 	stw	r3,156(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
 182b88c:	00000106 	br	182b894 <lwip_setsockopt_internal+0x308>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 182b890:	0001883a 	nop
    }  /* switch (optname) */
    break;
 182b894:	0001883a 	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 182b898:	e0bffb17 	ldw	r2,-20(fp)
 182b89c:	10800017 	ldw	r2,0(r2)
 182b8a0:	10800404 	addi	r2,r2,16
 182b8a4:	1009883a 	mov	r4,r2
 182b8a8:	18150740 	call	1815074 <sys_sem_signal>
}
 182b8ac:	0001883a 	nop
 182b8b0:	e037883a 	mov	sp,fp
 182b8b4:	dfc00117 	ldw	ra,4(sp)
 182b8b8:	df000017 	ldw	fp,0(sp)
 182b8bc:	dec00204 	addi	sp,sp,8
 182b8c0:	f800283a 	ret

0182b8c4 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
 182b8c4:	defff904 	addi	sp,sp,-28
 182b8c8:	dfc00615 	stw	ra,24(sp)
 182b8cc:	df000515 	stw	fp,20(sp)
 182b8d0:	df000504 	addi	fp,sp,20
 182b8d4:	e13ffd15 	stw	r4,-12(fp)
 182b8d8:	e17ffe15 	stw	r5,-8(fp)
 182b8dc:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 182b8e0:	e13ffd17 	ldw	r4,-12(fp)
 182b8e4:	18288400 	call	1828840 <get_socket>
 182b8e8:	e0bffc15 	stw	r2,-16(fp)
#if LWIP_SO_RCVBUF
  u16_t buflen = 0;
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
 182b8ec:	e0bffc17 	ldw	r2,-16(fp)
 182b8f0:	1000021e 	bne	r2,zero,182b8fc <lwip_ioctl+0x38>
    return -1;
 182b8f4:	00bfffc4 	movi	r2,-1
 182b8f8:	00002606 	br	182b994 <lwip_ioctl+0xd0>
  }

  switch (cmd) {
 182b8fc:	e0fffe17 	ldw	r3,-8(fp)
 182b900:	00a00134 	movhi	r2,32772
 182b904:	10999f84 	addi	r2,r2,26238
 182b908:	18801e1e 	bne	r3,r2,182b984 <lwip_ioctl+0xc0>
    sock_set_errno(sock, 0);
    return 0;
#endif /* LWIP_SO_RCVBUF */

  case FIONBIO:
    val = 0;
 182b90c:	e03ffb05 	stb	zero,-20(fp)
    if (argp && *(u32_t*)argp) {
 182b910:	e0bfff17 	ldw	r2,-4(fp)
 182b914:	10000526 	beq	r2,zero,182b92c <lwip_ioctl+0x68>
 182b918:	e0bfff17 	ldw	r2,-4(fp)
 182b91c:	10800017 	ldw	r2,0(r2)
 182b920:	10000226 	beq	r2,zero,182b92c <lwip_ioctl+0x68>
      val = 1;
 182b924:	00800044 	movi	r2,1
 182b928:	e0bffb05 	stb	r2,-20(fp)
    }
    netconn_set_nonblocking(sock->conn, val);
 182b92c:	e0bffb03 	ldbu	r2,-20(fp)
 182b930:	10000826 	beq	r2,zero,182b954 <lwip_ioctl+0x90>
 182b934:	e0bffc17 	ldw	r2,-16(fp)
 182b938:	10800017 	ldw	r2,0(r2)
 182b93c:	e0fffc17 	ldw	r3,-16(fp)
 182b940:	18c00017 	ldw	r3,0(r3)
 182b944:	18c00903 	ldbu	r3,36(r3)
 182b948:	18c00094 	ori	r3,r3,2
 182b94c:	10c00905 	stb	r3,36(r2)
 182b950:	00000806 	br	182b974 <lwip_ioctl+0xb0>
 182b954:	e0bffc17 	ldw	r2,-16(fp)
 182b958:	10800017 	ldw	r2,0(r2)
 182b95c:	e0fffc17 	ldw	r3,-16(fp)
 182b960:	18c00017 	ldw	r3,0(r3)
 182b964:	19000903 	ldbu	r4,36(r3)
 182b968:	00ffff44 	movi	r3,-3
 182b96c:	20c6703a 	and	r3,r4,r3
 182b970:	10c00905 	stb	r3,36(r2)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
 182b974:	e0bffc17 	ldw	r2,-16(fp)
 182b978:	10000415 	stw	zero,16(r2)
    return 0;
 182b97c:	0005883a 	mov	r2,zero
 182b980:	00000406 	br	182b994 <lwip_ioctl+0xd0>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
 182b984:	e0bffc17 	ldw	r2,-16(fp)
 182b988:	00c01604 	movi	r3,88
 182b98c:	10c00415 	stw	r3,16(r2)
    return -1;
 182b990:	00bfffc4 	movi	r2,-1
  } /* switch (cmd) */
}
 182b994:	e037883a 	mov	sp,fp
 182b998:	dfc00117 	ldw	ra,4(sp)
 182b99c:	df000017 	ldw	fp,0(sp)
 182b9a0:	dec00204 	addi	sp,sp,8
 182b9a4:	f800283a 	ret

0182b9a8 <lwip_fcntl>:
 * Currently only the commands F_GETFL and F_SETFL are implemented.
 * Only the flag O_NONBLOCK is implemented.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
 182b9a8:	defff904 	addi	sp,sp,-28
 182b9ac:	dfc00615 	stw	ra,24(sp)
 182b9b0:	df000515 	stw	fp,20(sp)
 182b9b4:	df000504 	addi	fp,sp,20
 182b9b8:	e13ffd15 	stw	r4,-12(fp)
 182b9bc:	e17ffe15 	stw	r5,-8(fp)
 182b9c0:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 182b9c4:	e13ffd17 	ldw	r4,-12(fp)
 182b9c8:	18288400 	call	1828840 <get_socket>
 182b9cc:	e0bffc15 	stw	r2,-16(fp)
  int ret = -1;
 182b9d0:	00bfffc4 	movi	r2,-1
 182b9d4:	e0bffb15 	stw	r2,-20(fp)

  if (!sock || !sock->conn) {
 182b9d8:	e0bffc17 	ldw	r2,-16(fp)
 182b9dc:	10000326 	beq	r2,zero,182b9ec <lwip_fcntl+0x44>
 182b9e0:	e0bffc17 	ldw	r2,-16(fp)
 182b9e4:	10800017 	ldw	r2,0(r2)
 182b9e8:	1000021e 	bne	r2,zero,182b9f4 <lwip_fcntl+0x4c>
    return -1;
 182b9ec:	00bfffc4 	movi	r2,-1
 182b9f0:	00002906 	br	182ba98 <lwip_fcntl+0xf0>
  }

  switch (cmd) {
 182b9f4:	e0bffe17 	ldw	r2,-8(fp)
 182b9f8:	10c000e0 	cmpeqi	r3,r2,3
 182b9fc:	1800031e 	bne	r3,zero,182ba0c <lwip_fcntl+0x64>
 182ba00:	10800120 	cmpeqi	r2,r2,4
 182ba04:	10000a1e 	bne	r2,zero,182ba30 <lwip_fcntl+0x88>
      ret = 0;
    }
    break;
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
 182ba08:	00002206 	br	182ba94 <lwip_fcntl+0xec>
    return -1;
  }

  switch (cmd) {
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
 182ba0c:	e0bffc17 	ldw	r2,-16(fp)
 182ba10:	10800017 	ldw	r2,0(r2)
 182ba14:	10800903 	ldbu	r2,36(r2)
 182ba18:	10803fcc 	andi	r2,r2,255
 182ba1c:	1080008c 	andi	r2,r2,2
 182ba20:	1004c03a 	cmpne	r2,r2,zero
 182ba24:	10803fcc 	andi	r2,r2,255
 182ba28:	e0bffb15 	stw	r2,-20(fp)
    break;
 182ba2c:	00001906 	br	182ba94 <lwip_fcntl+0xec>
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
 182ba30:	e0ffff17 	ldw	r3,-4(fp)
 182ba34:	00bfff84 	movi	r2,-2
 182ba38:	1884703a 	and	r2,r3,r2
 182ba3c:	1000141e 	bne	r2,zero,182ba90 <lwip_fcntl+0xe8>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
 182ba40:	e0bfff17 	ldw	r2,-4(fp)
 182ba44:	1080004c 	andi	r2,r2,1
 182ba48:	10000826 	beq	r2,zero,182ba6c <lwip_fcntl+0xc4>
 182ba4c:	e0bffc17 	ldw	r2,-16(fp)
 182ba50:	10800017 	ldw	r2,0(r2)
 182ba54:	e0fffc17 	ldw	r3,-16(fp)
 182ba58:	18c00017 	ldw	r3,0(r3)
 182ba5c:	18c00903 	ldbu	r3,36(r3)
 182ba60:	18c00094 	ori	r3,r3,2
 182ba64:	10c00905 	stb	r3,36(r2)
 182ba68:	00000806 	br	182ba8c <lwip_fcntl+0xe4>
 182ba6c:	e0bffc17 	ldw	r2,-16(fp)
 182ba70:	10800017 	ldw	r2,0(r2)
 182ba74:	e0fffc17 	ldw	r3,-16(fp)
 182ba78:	18c00017 	ldw	r3,0(r3)
 182ba7c:	19000903 	ldbu	r4,36(r3)
 182ba80:	00ffff44 	movi	r3,-3
 182ba84:	20c6703a 	and	r3,r4,r3
 182ba88:	10c00905 	stb	r3,36(r2)
      ret = 0;
 182ba8c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 182ba90:	0001883a 	nop
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
  }
  return ret;
 182ba94:	e0bffb17 	ldw	r2,-20(fp)
}
 182ba98:	e037883a 	mov	sp,fp
 182ba9c:	dfc00117 	ldw	ra,4(sp)
 182baa0:	df000017 	ldw	fp,0(sp)
 182baa4:	dec00204 	addi	sp,sp,8
 182baa8:	f800283a 	ret

0182baac <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 182baac:	defffc04 	addi	sp,sp,-16
 182bab0:	dfc00315 	stw	ra,12(sp)
 182bab4:	df000215 	stw	fp,8(sp)
 182bab8:	df000204 	addi	fp,sp,8
 182babc:	e13fff15 	stw	r4,-4(fp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 182bac0:	d0a80d17 	ldw	r2,-24524(gp)
 182bac4:	10000426 	beq	r2,zero,182bad8 <tcpip_thread+0x2c>
    tcpip_init_done(tcpip_init_done_arg);
 182bac8:	d0a80d17 	ldw	r2,-24524(gp)
 182bacc:	d0e80e17 	ldw	r3,-24520(gp)
 182bad0:	1809883a 	mov	r4,r3
 182bad4:	103ee83a 	callr	r2
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
 182bad8:	e17ffe04 	addi	r5,fp,-8
 182badc:	d1280f04 	addi	r4,gp,-24516
 182bae0:	1821ae40 	call	1821ae4 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
 182bae4:	e0bffe17 	ldw	r2,-8(fp)
 182bae8:	10800017 	ldw	r2,0(r2)
 182baec:	10c001a8 	cmpgeui	r3,r2,6
 182baf0:	18005c1e 	bne	r3,zero,182bc64 <tcpip_thread+0x1b8>
 182baf4:	100690ba 	slli	r3,r2,2
 182baf8:	008060f4 	movhi	r2,387
 182bafc:	10aec304 	addi	r2,r2,-17652
 182bb00:	1885883a 	add	r2,r3,r2
 182bb04:	10800017 	ldw	r2,0(r2)
 182bb08:	1000683a 	jmp	r2
 182bb0c:	0182bb24 	muli	r6,zero,2796
 182bb10:	0182bb48 	cmpgei	r6,zero,2797
 182bb14:	0182bbb0 	cmpltui	r6,zero,2798
 182bb18:	0182bbec 	andhi	r6,zero,2799
 182bb1c:	0182bc1c 	xori	r6,zero,2800
 182bb20:	0182bc48 	cmpgei	r6,zero,2801
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
 182bb24:	e0bffe17 	ldw	r2,-8(fp)
 182bb28:	10800217 	ldw	r2,8(r2)
 182bb2c:	10800017 	ldw	r2,0(r2)
 182bb30:	e0fffe17 	ldw	r3,-8(fp)
 182bb34:	18c00217 	ldw	r3,8(r3)
 182bb38:	18c00104 	addi	r3,r3,4
 182bb3c:	1809883a 	mov	r4,r3
 182bb40:	103ee83a 	callr	r2
      break;
 182bb44:	00004806 	br	182bc68 <tcpip_thread+0x1bc>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 182bb48:	e0bffe17 	ldw	r2,-8(fp)
 182bb4c:	10800317 	ldw	r2,12(r2)
 182bb50:	10800e43 	ldbu	r2,57(r2)
 182bb54:	10803fcc 	andi	r2,r2,255
 182bb58:	1080180c 	andi	r2,r2,96
 182bb5c:	10000826 	beq	r2,zero,182bb80 <tcpip_thread+0xd4>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 182bb60:	e0bffe17 	ldw	r2,-8(fp)
 182bb64:	10c00217 	ldw	r3,8(r2)
 182bb68:	e0bffe17 	ldw	r2,-8(fp)
 182bb6c:	10800317 	ldw	r2,12(r2)
 182bb70:	100b883a 	mov	r5,r2
 182bb74:	1809883a 	mov	r4,r3
 182bb78:	18244f80 	call	18244f8 <ethernet_input>
 182bb7c:	00000706 	br	182bb9c <tcpip_thread+0xf0>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
 182bb80:	e0bffe17 	ldw	r2,-8(fp)
 182bb84:	10c00217 	ldw	r3,8(r2)
 182bb88:	e0bffe17 	ldw	r2,-8(fp)
 182bb8c:	10800317 	ldw	r2,12(r2)
 182bb90:	100b883a 	mov	r5,r2
 182bb94:	1809883a 	mov	r4,r3
 182bb98:	18323300 	call	1832330 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 182bb9c:	e0bffe17 	ldw	r2,-8(fp)
 182bba0:	100b883a 	mov	r5,r2
 182bba4:	01000284 	movi	r4,10
 182bba8:	1834b240 	call	1834b24 <memp_free>
      break;
 182bbac:	00002e06 	br	182bc68 <tcpip_thread+0x1bc>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
 182bbb0:	e0bffe17 	ldw	r2,-8(fp)
 182bbb4:	10c00217 	ldw	r3,8(r2)
 182bbb8:	e0bffe17 	ldw	r2,-8(fp)
 182bbbc:	11000317 	ldw	r4,12(r2)
 182bbc0:	e0bffe17 	ldw	r2,-8(fp)
 182bbc4:	10800417 	ldw	r2,16(r2)
 182bbc8:	100d883a 	mov	r6,r2
 182bbcc:	200b883a 	mov	r5,r4
 182bbd0:	1809883a 	mov	r4,r3
 182bbd4:	18218740 	call	1821874 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 182bbd8:	e0bffe17 	ldw	r2,-8(fp)
 182bbdc:	100b883a 	mov	r5,r2
 182bbe0:	01000244 	movi	r4,9
 182bbe4:	1834b240 	call	1834b24 <memp_free>
      break;
 182bbe8:	00001f06 	br	182bc68 <tcpip_thread+0x1bc>
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
 182bbec:	e0bffe17 	ldw	r2,-8(fp)
 182bbf0:	10c00317 	ldw	r3,12(r2)
 182bbf4:	e0bffe17 	ldw	r2,-8(fp)
 182bbf8:	10800417 	ldw	r2,16(r2)
 182bbfc:	100b883a 	mov	r5,r2
 182bc00:	1809883a 	mov	r4,r3
 182bc04:	18219f00 	call	18219f0 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 182bc08:	e0bffe17 	ldw	r2,-8(fp)
 182bc0c:	100b883a 	mov	r5,r2
 182bc10:	01000244 	movi	r4,9
 182bc14:	1834b240 	call	1834b24 <memp_free>
      break;
 182bc18:	00001306 	br	182bc68 <tcpip_thread+0x1bc>
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 182bc1c:	e0bffe17 	ldw	r2,-8(fp)
 182bc20:	10800217 	ldw	r2,8(r2)
 182bc24:	e0fffe17 	ldw	r3,-8(fp)
 182bc28:	18c00317 	ldw	r3,12(r3)
 182bc2c:	1809883a 	mov	r4,r3
 182bc30:	103ee83a 	callr	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 182bc34:	e0bffe17 	ldw	r2,-8(fp)
 182bc38:	100b883a 	mov	r5,r2
 182bc3c:	01000244 	movi	r4,9
 182bc40:	1834b240 	call	1834b24 <memp_free>
      break;
 182bc44:	00000806 	br	182bc68 <tcpip_thread+0x1bc>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 182bc48:	e0bffe17 	ldw	r2,-8(fp)
 182bc4c:	10800217 	ldw	r2,8(r2)
 182bc50:	e0fffe17 	ldw	r3,-8(fp)
 182bc54:	18c00317 	ldw	r3,12(r3)
 182bc58:	1809883a 	mov	r4,r3
 182bc5c:	103ee83a 	callr	r2
      break;
 182bc60:	00000106 	br	182bc68 <tcpip_thread+0x1bc>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
 182bc64:	0001883a 	nop
    }
  }
 182bc68:	003f9b06 	br	182bad8 <__ram_exceptions_end+0xff81b694>

0182bc6c <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 182bc6c:	defffb04 	addi	sp,sp,-20
 182bc70:	dfc00415 	stw	ra,16(sp)
 182bc74:	df000315 	stw	fp,12(sp)
 182bc78:	df000304 	addi	fp,sp,12
 182bc7c:	e13ffe15 	stw	r4,-8(fp)
 182bc80:	e17fff15 	stw	r5,-4(fp)
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 182bc84:	d0a80f17 	ldw	r2,-24516(gp)
 182bc88:	1000021e 	bne	r2,zero,182bc94 <tcpip_input+0x28>
    return ERR_VAL;
 182bc8c:	00bffe84 	movi	r2,-6
 182bc90:	00001d06 	br	182bd08 <tcpip_input+0x9c>
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 182bc94:	01000284 	movi	r4,10
 182bc98:	18349580 	call	1834958 <memp_malloc>
 182bc9c:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 182bca0:	e0bffd17 	ldw	r2,-12(fp)
 182bca4:	1000021e 	bne	r2,zero,182bcb0 <tcpip_input+0x44>
    return ERR_MEM;
 182bca8:	00bfffc4 	movi	r2,-1
 182bcac:	00001606 	br	182bd08 <tcpip_input+0x9c>
  }

  msg->type = TCPIP_MSG_INPKT;
 182bcb0:	e0bffd17 	ldw	r2,-12(fp)
 182bcb4:	00c00044 	movi	r3,1
 182bcb8:	10c00015 	stw	r3,0(r2)
  msg->msg.inp.p = p;
 182bcbc:	e0bffd17 	ldw	r2,-12(fp)
 182bcc0:	e0fffe17 	ldw	r3,-8(fp)
 182bcc4:	10c00215 	stw	r3,8(r2)
  msg->msg.inp.netif = inp;
 182bcc8:	e0bffd17 	ldw	r2,-12(fp)
 182bccc:	e0ffff17 	ldw	r3,-4(fp)
 182bcd0:	10c00315 	stw	r3,12(r2)
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 182bcd4:	e17ffd17 	ldw	r5,-12(fp)
 182bcd8:	d1280f04 	addi	r4,gp,-24516
 182bcdc:	18154d40 	call	18154d4 <sys_mbox_trypost>
 182bce0:	10803fcc 	andi	r2,r2,255
 182bce4:	1080201c 	xori	r2,r2,128
 182bce8:	10bfe004 	addi	r2,r2,-128
 182bcec:	10000526 	beq	r2,zero,182bd04 <tcpip_input+0x98>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 182bcf0:	e17ffd17 	ldw	r5,-12(fp)
 182bcf4:	01000284 	movi	r4,10
 182bcf8:	1834b240 	call	1834b24 <memp_free>
    return ERR_MEM;
 182bcfc:	00bfffc4 	movi	r2,-1
 182bd00:	00000106 	br	182bd08 <tcpip_input+0x9c>
  }
  return ERR_OK;
 182bd04:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 182bd08:	e037883a 	mov	sp,fp
 182bd0c:	dfc00117 	ldw	ra,4(sp)
 182bd10:	df000017 	ldw	fp,0(sp)
 182bd14:	dec00204 	addi	sp,sp,8
 182bd18:	f800283a 	ret

0182bd1c <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 182bd1c:	defffa04 	addi	sp,sp,-24
 182bd20:	dfc00515 	stw	ra,20(sp)
 182bd24:	df000415 	stw	fp,16(sp)
 182bd28:	df000404 	addi	fp,sp,16
 182bd2c:	e13ffd15 	stw	r4,-12(fp)
 182bd30:	e17ffe15 	stw	r5,-8(fp)
 182bd34:	3005883a 	mov	r2,r6
 182bd38:	e0bfff05 	stb	r2,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 182bd3c:	d0a80f17 	ldw	r2,-24516(gp)
 182bd40:	10002426 	beq	r2,zero,182bdd4 <tcpip_callback_with_block+0xb8>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 182bd44:	01000244 	movi	r4,9
 182bd48:	18349580 	call	1834958 <memp_malloc>
 182bd4c:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
 182bd50:	e0bffc17 	ldw	r2,-16(fp)
 182bd54:	1000021e 	bne	r2,zero,182bd60 <tcpip_callback_with_block+0x44>
      return ERR_MEM;
 182bd58:	00bfffc4 	movi	r2,-1
 182bd5c:	00001e06 	br	182bdd8 <tcpip_callback_with_block+0xbc>
    }

    msg->type = TCPIP_MSG_CALLBACK;
 182bd60:	e0bffc17 	ldw	r2,-16(fp)
 182bd64:	00c00104 	movi	r3,4
 182bd68:	10c00015 	stw	r3,0(r2)
    msg->msg.cb.function = function;
 182bd6c:	e0bffc17 	ldw	r2,-16(fp)
 182bd70:	e0fffd17 	ldw	r3,-12(fp)
 182bd74:	10c00215 	stw	r3,8(r2)
    msg->msg.cb.ctx = ctx;
 182bd78:	e0bffc17 	ldw	r2,-16(fp)
 182bd7c:	e0fffe17 	ldw	r3,-8(fp)
 182bd80:	10c00315 	stw	r3,12(r2)
    if (block) {
 182bd84:	e0bfff03 	ldbu	r2,-4(fp)
 182bd88:	10000426 	beq	r2,zero,182bd9c <tcpip_callback_with_block+0x80>
      sys_mbox_post(&mbox, msg);
 182bd8c:	e17ffc17 	ldw	r5,-16(fp)
 182bd90:	d1280f04 	addi	r4,gp,-24516
 182bd94:	18154840 	call	1815484 <sys_mbox_post>
 182bd98:	00000c06 	br	182bdcc <tcpip_callback_with_block+0xb0>
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 182bd9c:	e17ffc17 	ldw	r5,-16(fp)
 182bda0:	d1280f04 	addi	r4,gp,-24516
 182bda4:	18154d40 	call	18154d4 <sys_mbox_trypost>
 182bda8:	10803fcc 	andi	r2,r2,255
 182bdac:	1080201c 	xori	r2,r2,128
 182bdb0:	10bfe004 	addi	r2,r2,-128
 182bdb4:	10000526 	beq	r2,zero,182bdcc <tcpip_callback_with_block+0xb0>
        memp_free(MEMP_TCPIP_MSG_API, msg);
 182bdb8:	e17ffc17 	ldw	r5,-16(fp)
 182bdbc:	01000244 	movi	r4,9
 182bdc0:	1834b240 	call	1834b24 <memp_free>
        return ERR_MEM;
 182bdc4:	00bfffc4 	movi	r2,-1
 182bdc8:	00000306 	br	182bdd8 <tcpip_callback_with_block+0xbc>
      }
    }
    return ERR_OK;
 182bdcc:	0005883a 	mov	r2,zero
 182bdd0:	00000106 	br	182bdd8 <tcpip_callback_with_block+0xbc>
  }
  return ERR_VAL;
 182bdd4:	00bffe84 	movi	r2,-6
}
 182bdd8:	e037883a 	mov	sp,fp
 182bddc:	dfc00117 	ldw	ra,4(sp)
 182bde0:	df000017 	ldw	fp,0(sp)
 182bde4:	dec00204 	addi	sp,sp,8
 182bde8:	f800283a 	ret

0182bdec <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 182bdec:	defffa04 	addi	sp,sp,-24
 182bdf0:	dfc00515 	stw	ra,20(sp)
 182bdf4:	df000415 	stw	fp,16(sp)
 182bdf8:	df000404 	addi	fp,sp,16
 182bdfc:	e13ffd15 	stw	r4,-12(fp)
 182be00:	e17ffe15 	stw	r5,-8(fp)
 182be04:	e1bfff15 	stw	r6,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 182be08:	d0a80f17 	ldw	r2,-24516(gp)
 182be0c:	10001826 	beq	r2,zero,182be70 <tcpip_timeout+0x84>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 182be10:	01000244 	movi	r4,9
 182be14:	18349580 	call	1834958 <memp_malloc>
 182be18:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
 182be1c:	e0bffc17 	ldw	r2,-16(fp)
 182be20:	1000021e 	bne	r2,zero,182be2c <tcpip_timeout+0x40>
      return ERR_MEM;
 182be24:	00bfffc4 	movi	r2,-1
 182be28:	00001206 	br	182be74 <tcpip_timeout+0x88>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
 182be2c:	e0bffc17 	ldw	r2,-16(fp)
 182be30:	00c00084 	movi	r3,2
 182be34:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.msecs = msecs;
 182be38:	e0bffc17 	ldw	r2,-16(fp)
 182be3c:	e0fffd17 	ldw	r3,-12(fp)
 182be40:	10c00215 	stw	r3,8(r2)
    msg->msg.tmo.h = h;
 182be44:	e0bffc17 	ldw	r2,-16(fp)
 182be48:	e0fffe17 	ldw	r3,-8(fp)
 182be4c:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
 182be50:	e0bffc17 	ldw	r2,-16(fp)
 182be54:	e0ffff17 	ldw	r3,-4(fp)
 182be58:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
 182be5c:	e17ffc17 	ldw	r5,-16(fp)
 182be60:	d1280f04 	addi	r4,gp,-24516
 182be64:	18154840 	call	1815484 <sys_mbox_post>
    return ERR_OK;
 182be68:	0005883a 	mov	r2,zero
 182be6c:	00000106 	br	182be74 <tcpip_timeout+0x88>
  }
  return ERR_VAL;
 182be70:	00bffe84 	movi	r2,-6
}
 182be74:	e037883a 	mov	sp,fp
 182be78:	dfc00117 	ldw	ra,4(sp)
 182be7c:	df000017 	ldw	fp,0(sp)
 182be80:	dec00204 	addi	sp,sp,8
 182be84:	f800283a 	ret

0182be88 <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 182be88:	defffb04 	addi	sp,sp,-20
 182be8c:	dfc00415 	stw	ra,16(sp)
 182be90:	df000315 	stw	fp,12(sp)
 182be94:	df000304 	addi	fp,sp,12
 182be98:	e13ffe15 	stw	r4,-8(fp)
 182be9c:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 182bea0:	d0a80f17 	ldw	r2,-24516(gp)
 182bea4:	10001526 	beq	r2,zero,182befc <tcpip_untimeout+0x74>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 182bea8:	01000244 	movi	r4,9
 182beac:	18349580 	call	1834958 <memp_malloc>
 182beb0:	e0bffd15 	stw	r2,-12(fp)
    if (msg == NULL) {
 182beb4:	e0bffd17 	ldw	r2,-12(fp)
 182beb8:	1000021e 	bne	r2,zero,182bec4 <tcpip_untimeout+0x3c>
      return ERR_MEM;
 182bebc:	00bfffc4 	movi	r2,-1
 182bec0:	00000f06 	br	182bf00 <tcpip_untimeout+0x78>
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
 182bec4:	e0bffd17 	ldw	r2,-12(fp)
 182bec8:	00c000c4 	movi	r3,3
 182becc:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.h = h;
 182bed0:	e0bffd17 	ldw	r2,-12(fp)
 182bed4:	e0fffe17 	ldw	r3,-8(fp)
 182bed8:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
 182bedc:	e0bffd17 	ldw	r2,-12(fp)
 182bee0:	e0ffff17 	ldw	r3,-4(fp)
 182bee4:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
 182bee8:	e17ffd17 	ldw	r5,-12(fp)
 182beec:	d1280f04 	addi	r4,gp,-24516
 182bef0:	18154840 	call	1815484 <sys_mbox_post>
    return ERR_OK;
 182bef4:	0005883a 	mov	r2,zero
 182bef8:	00000106 	br	182bf00 <tcpip_untimeout+0x78>
  }
  return ERR_VAL;
 182befc:	00bffe84 	movi	r2,-6
}
 182bf00:	e037883a 	mov	sp,fp
 182bf04:	dfc00117 	ldw	ra,4(sp)
 182bf08:	df000017 	ldw	fp,0(sp)
 182bf0c:	dec00204 	addi	sp,sp,8
 182bf10:	f800283a 	ret

0182bf14 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 182bf14:	defff804 	addi	sp,sp,-32
 182bf18:	dfc00715 	stw	ra,28(sp)
 182bf1c:	df000615 	stw	fp,24(sp)
 182bf20:	df000604 	addi	fp,sp,24
 182bf24:	e13fff15 	stw	r4,-4(fp)
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
 182bf28:	d0a80f17 	ldw	r2,-24516(gp)
 182bf2c:	10000f26 	beq	r2,zero,182bf6c <tcpip_apimsg+0x58>
    msg.type = TCPIP_MSG_API;
 182bf30:	e03ffa15 	stw	zero,-24(fp)
    msg.msg.apimsg = apimsg;
 182bf34:	e0bfff17 	ldw	r2,-4(fp)
 182bf38:	e0bffc15 	stw	r2,-16(fp)
    sys_mbox_post(&mbox, &msg);
 182bf3c:	e17ffa04 	addi	r5,fp,-24
 182bf40:	d1280f04 	addi	r4,gp,-24516
 182bf44:	18154840 	call	1815484 <sys_mbox_post>
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
 182bf48:	e0bfff17 	ldw	r2,-4(fp)
 182bf4c:	10800117 	ldw	r2,4(r2)
 182bf50:	10800404 	addi	r2,r2,16
 182bf54:	000b883a 	mov	r5,zero
 182bf58:	1009883a 	mov	r4,r2
 182bf5c:	18150bc0 	call	18150bc <sys_arch_sem_wait>
    return apimsg->msg.err;
 182bf60:	e0bfff17 	ldw	r2,-4(fp)
 182bf64:	10800203 	ldbu	r2,8(r2)
 182bf68:	00000106 	br	182bf70 <tcpip_apimsg+0x5c>
  }
  return ERR_VAL;
 182bf6c:	00bffe84 	movi	r2,-6
}
 182bf70:	e037883a 	mov	sp,fp
 182bf74:	dfc00117 	ldw	ra,4(sp)
 182bf78:	df000017 	ldw	fp,0(sp)
 182bf7c:	dec00204 	addi	sp,sp,8
 182bf80:	f800283a 	ret

0182bf84 <tcpip_callbackmsg_new>:
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 182bf84:	defffb04 	addi	sp,sp,-20
 182bf88:	dfc00415 	stw	ra,16(sp)
 182bf8c:	df000315 	stw	fp,12(sp)
 182bf90:	df000304 	addi	fp,sp,12
 182bf94:	e13ffe15 	stw	r4,-8(fp)
 182bf98:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 182bf9c:	01000244 	movi	r4,9
 182bfa0:	18349580 	call	1834958 <memp_malloc>
 182bfa4:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 182bfa8:	e0bffd17 	ldw	r2,-12(fp)
 182bfac:	1000021e 	bne	r2,zero,182bfb8 <tcpip_callbackmsg_new+0x34>
    return NULL;
 182bfb0:	0005883a 	mov	r2,zero
 182bfb4:	00000a06 	br	182bfe0 <tcpip_callbackmsg_new+0x5c>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 182bfb8:	e0bffd17 	ldw	r2,-12(fp)
 182bfbc:	00c00144 	movi	r3,5
 182bfc0:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
 182bfc4:	e0bffd17 	ldw	r2,-12(fp)
 182bfc8:	e0fffe17 	ldw	r3,-8(fp)
 182bfcc:	10c00215 	stw	r3,8(r2)
  msg->msg.cb.ctx = ctx;
 182bfd0:	e0bffd17 	ldw	r2,-12(fp)
 182bfd4:	e0ffff17 	ldw	r3,-4(fp)
 182bfd8:	10c00315 	stw	r3,12(r2)
  return (struct tcpip_callback_msg*)msg;
 182bfdc:	e0bffd17 	ldw	r2,-12(fp)
}
 182bfe0:	e037883a 	mov	sp,fp
 182bfe4:	dfc00117 	ldw	ra,4(sp)
 182bfe8:	df000017 	ldw	fp,0(sp)
 182bfec:	dec00204 	addi	sp,sp,8
 182bff0:	f800283a 	ret

0182bff4 <tcpip_callbackmsg_delete>:
 * Free a callback message allocated by tcpip_callbackmsg_new().
 *
 * @param msg the message to free
 */
void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
 182bff4:	defffd04 	addi	sp,sp,-12
 182bff8:	dfc00215 	stw	ra,8(sp)
 182bffc:	df000115 	stw	fp,4(sp)
 182c000:	df000104 	addi	fp,sp,4
 182c004:	e13fff15 	stw	r4,-4(fp)
  memp_free(MEMP_TCPIP_MSG_API, msg);
 182c008:	e17fff17 	ldw	r5,-4(fp)
 182c00c:	01000244 	movi	r4,9
 182c010:	1834b240 	call	1834b24 <memp_free>
}
 182c014:	0001883a 	nop
 182c018:	e037883a 	mov	sp,fp
 182c01c:	dfc00117 	ldw	ra,4(sp)
 182c020:	df000017 	ldw	fp,0(sp)
 182c024:	dec00204 	addi	sp,sp,8
 182c028:	f800283a 	ret

0182c02c <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
 182c02c:	defffd04 	addi	sp,sp,-12
 182c030:	dfc00215 	stw	ra,8(sp)
 182c034:	df000115 	stw	fp,4(sp)
 182c038:	df000104 	addi	fp,sp,4
 182c03c:	e13fff15 	stw	r4,-4(fp)
  if (!sys_mbox_valid(&mbox)) {
 182c040:	d0a80f17 	ldw	r2,-24516(gp)
 182c044:	1000021e 	bne	r2,zero,182c050 <tcpip_trycallback+0x24>
    return ERR_VAL;
 182c048:	00bffe84 	movi	r2,-6
 182c04c:	00000306 	br	182c05c <tcpip_trycallback+0x30>
  }
  return sys_mbox_trypost(&mbox, msg);
 182c050:	e17fff17 	ldw	r5,-4(fp)
 182c054:	d1280f04 	addi	r4,gp,-24516
 182c058:	18154d40 	call	18154d4 <sys_mbox_trypost>
}
 182c05c:	e037883a 	mov	sp,fp
 182c060:	dfc00117 	ldw	ra,4(sp)
 182c064:	df000017 	ldw	fp,0(sp)
 182c068:	dec00204 	addi	sp,sp,8
 182c06c:	f800283a 	ret

0182c070 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 182c070:	defffb04 	addi	sp,sp,-20
 182c074:	dfc00415 	stw	ra,16(sp)
 182c078:	df000315 	stw	fp,12(sp)
 182c07c:	df000304 	addi	fp,sp,12
 182c080:	e13ffe15 	stw	r4,-8(fp)
 182c084:	e17fff15 	stw	r5,-4(fp)
  lwip_init();
 182c088:	18311740 	call	1831174 <lwip_init>

  tcpip_init_done = initfunc;
 182c08c:	e0bffe17 	ldw	r2,-8(fp)
 182c090:	d0a80d15 	stw	r2,-24524(gp)
  tcpip_init_done_arg = arg;
 182c094:	e0bfff17 	ldw	r2,-4(fp)
 182c098:	d0a80e15 	stw	r2,-24520(gp)
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 182c09c:	01440004 	movi	r5,4096
 182c0a0:	d1280f04 	addi	r4,gp,-24516
 182c0a4:	18153440 	call	1815344 <sys_mbox_new>
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 182c0a8:	008000c4 	movi	r2,3
 182c0ac:	d8800015 	stw	r2,0(sp)
 182c0b0:	01c80004 	movi	r7,8192
 182c0b4:	000d883a 	mov	r6,zero
 182c0b8:	014060f4 	movhi	r5,387
 182c0bc:	296eab04 	addi	r5,r5,-17748
 182c0c0:	01006134 	movhi	r4,388
 182c0c4:	21079a04 	addi	r4,r4,7784
 182c0c8:	181569c0 	call	181569c <sys_thread_new>
}
 182c0cc:	0001883a 	nop
 182c0d0:	e037883a 	mov	sp,fp
 182c0d4:	dfc00117 	ldw	ra,4(sp)
 182c0d8:	df000017 	ldw	fp,0(sp)
 182c0dc:	dec00204 	addi	sp,sp,8
 182c0e0:	f800283a 	ret

0182c0e4 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
 182c0e4:	defffc04 	addi	sp,sp,-16
 182c0e8:	dfc00315 	stw	ra,12(sp)
 182c0ec:	df000215 	stw	fp,8(sp)
 182c0f0:	df000204 	addi	fp,sp,8
 182c0f4:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q = (struct pbuf *)p;
 182c0f8:	e0bfff17 	ldw	r2,-4(fp)
 182c0fc:	e0bffe15 	stw	r2,-8(fp)
  pbuf_free(q);
 182c100:	e13ffe17 	ldw	r4,-8(fp)
 182c104:	181aca40 	call	181aca4 <pbuf_free>
}
 182c108:	0001883a 	nop
 182c10c:	e037883a 	mov	sp,fp
 182c110:	dfc00117 	ldw	ra,4(sp)
 182c114:	df000017 	ldw	fp,0(sp)
 182c118:	dec00204 	addi	sp,sp,8
 182c11c:	f800283a 	ret

0182c120 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
 182c120:	defffd04 	addi	sp,sp,-12
 182c124:	dfc00215 	stw	ra,8(sp)
 182c128:	df000115 	stw	fp,4(sp)
 182c12c:	df000104 	addi	fp,sp,4
 182c130:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
 182c134:	000d883a 	mov	r6,zero
 182c138:	e17fff17 	ldw	r5,-4(fp)
 182c13c:	010060f4 	movhi	r4,387
 182c140:	21303904 	addi	r4,r4,-16156
 182c144:	182bd1c0 	call	182bd1c <tcpip_callback_with_block>
}
 182c148:	e037883a 	mov	sp,fp
 182c14c:	dfc00117 	ldw	ra,4(sp)
 182c150:	df000017 	ldw	fp,0(sp)
 182c154:	dec00204 	addi	sp,sp,8
 182c158:	f800283a 	ret

0182c15c <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
 182c15c:	defffd04 	addi	sp,sp,-12
 182c160:	dfc00215 	stw	ra,8(sp)
 182c164:	df000115 	stw	fp,4(sp)
 182c168:	df000104 	addi	fp,sp,4
 182c16c:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(mem_free, m, 0);
 182c170:	000d883a 	mov	r6,zero
 182c174:	e17fff17 	ldw	r5,-4(fp)
 182c178:	010060b4 	movhi	r4,386
 182c17c:	2124f704 	addi	r4,r4,-27684
 182c180:	182bd1c0 	call	182bd1c <tcpip_callback_with_block>
}
 182c184:	e037883a 	mov	sp,fp
 182c188:	dfc00117 	ldw	ra,4(sp)
 182c18c:	df000017 	ldw	fp,0(sp)
 182c190:	dec00204 	addi	sp,sp,8
 182c194:	f800283a 	ret

0182c198 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 182c198:	defffb04 	addi	sp,sp,-20
 182c19c:	df000115 	stw	fp,4(sp)
 182c1a0:	df000104 	addi	fp,sp,4
 182c1a4:	e13fff15 	stw	r4,-4(fp)
 182c1a8:	e1400115 	stw	r5,4(fp)
 182c1ac:	e1800215 	stw	r6,8(fp)
 182c1b0:	e1c00315 	stw	r7,12(fp)
 182c1b4:	0001883a 	nop
 182c1b8:	e037883a 	mov	sp,fp
 182c1bc:	df000017 	ldw	fp,0(sp)
 182c1c0:	dec00404 	addi	sp,sp,16
 182c1c4:	f800283a 	ret

0182c1c8 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 182c1c8:	defffb04 	addi	sp,sp,-20
 182c1cc:	df000415 	stw	fp,16(sp)
 182c1d0:	df000404 	addi	fp,sp,16
 182c1d4:	e13ffc15 	stw	r4,-16(fp)
 182c1d8:	e17ffd15 	stw	r5,-12(fp)
 182c1dc:	e1bffe15 	stw	r6,-8(fp)
 182c1e0:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 182c1e4:	e0fffd17 	ldw	r3,-12(fp)
 182c1e8:	e0bffc17 	ldw	r2,-16(fp)
 182c1ec:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 182c1f0:	e0fffe17 	ldw	r3,-8(fp)
 182c1f4:	e0bffc17 	ldw	r2,-16(fp)
 182c1f8:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 182c1fc:	e0ffff17 	ldw	r3,-4(fp)
 182c200:	e0bffc17 	ldw	r2,-16(fp)
 182c204:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 182c208:	e0c00117 	ldw	r3,4(fp)
 182c20c:	e0bffc17 	ldw	r2,-16(fp)
 182c210:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 182c214:	0005883a 	mov	r2,zero
}
 182c218:	e037883a 	mov	sp,fp
 182c21c:	df000017 	ldw	fp,0(sp)
 182c220:	dec00104 	addi	sp,sp,4
 182c224:	f800283a 	ret

0182c228 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 182c228:	defffa04 	addi	sp,sp,-24
 182c22c:	dfc00515 	stw	ra,20(sp)
 182c230:	df000415 	stw	fp,16(sp)
 182c234:	df000404 	addi	fp,sp,16
 182c238:	e13ffe15 	stw	r4,-8(fp)
 182c23c:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 182c240:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 182c244:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 182c248:	00000b06 	br	182c278 <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 182c24c:	e0fffc17 	ldw	r3,-16(fp)
 182c250:	18800044 	addi	r2,r3,1
 182c254:	e0bffc15 	stw	r2,-16(fp)
 182c258:	008003f4 	movhi	r2,15
 182c25c:	10909004 	addi	r2,r2,16960
 182c260:	1880051e 	bne	r3,r2,182c278 <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 182c264:	01006134 	movhi	r4,388
 182c268:	21079e04 	addi	r4,r4,7800
 182c26c:	183d2fc0 	call	183d2fc <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 182c270:	00bffa84 	movi	r2,-22
 182c274:	00002006 	br	182c2f8 <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 182c278:	e0bffe17 	ldw	r2,-8(fp)
 182c27c:	10800117 	ldw	r2,4(r2)
 182c280:	10800317 	ldw	r2,12(r2)
 182c284:	10800037 	ldwio	r2,0(r2)
 182c288:	1080040c 	andi	r2,r2,16
 182c28c:	103fef1e 	bne	r2,zero,182c24c <__ram_exceptions_end+0xff81be08>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 182c290:	e0bffe17 	ldw	r2,-8(fp)
 182c294:	10800117 	ldw	r2,4(r2)
 182c298:	10800317 	ldw	r2,12(r2)
 182c29c:	10800404 	addi	r2,r2,16
 182c2a0:	0007883a 	mov	r3,zero
 182c2a4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 182c2a8:	e0bffe17 	ldw	r2,-8(fp)
 182c2ac:	10800117 	ldw	r2,4(r2)
 182c2b0:	10800317 	ldw	r2,12(r2)
 182c2b4:	00c03fc4 	movi	r3,255
 182c2b8:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 182c2bc:	e0bffe17 	ldw	r2,-8(fp)
 182c2c0:	10800117 	ldw	r2,4(r2)
 182c2c4:	e17fff17 	ldw	r5,-4(fp)
 182c2c8:	1009883a 	mov	r4,r2
 182c2cc:	1825aa80 	call	1825aa8 <alt_avalon_sgdma_do_sync_transfer>
 182c2d0:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 182c2d4:	e0bffd03 	ldbu	r2,-12(fp)
 182c2d8:	10000226 	beq	r2,zero,182c2e4 <tse_mac_sTxWrite+0xbc>
    return -1;
 182c2dc:	00bfffc4 	movi	r2,-1
 182c2e0:	00000506 	br	182c2f8 <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 182c2e4:	e0bfff17 	ldw	r2,-4(fp)
 182c2e8:	10800704 	addi	r2,r2,28
 182c2ec:	10800037 	ldwio	r2,0(r2)
 182c2f0:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 182c2f4:	e0bffd8b 	ldhu	r2,-10(fp)
}
 182c2f8:	e037883a 	mov	sp,fp
 182c2fc:	dfc00117 	ldw	ra,4(sp)
 182c300:	df000017 	ldw	fp,0(sp)
 182c304:	dec00204 	addi	sp,sp,8
 182c308:	f800283a 	ret

0182c30c <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 182c30c:	defffa04 	addi	sp,sp,-24
 182c310:	dfc00515 	stw	ra,20(sp)
 182c314:	df000415 	stw	fp,16(sp)
 182c318:	df000404 	addi	fp,sp,16
 182c31c:	e13ffe15 	stw	r4,-8(fp)
 182c320:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 182c324:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 182c328:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 182c32c:	00000b06 	br	182c35c <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 182c330:	e0fffc17 	ldw	r3,-16(fp)
 182c334:	18800044 	addi	r2,r3,1
 182c338:	e0bffc15 	stw	r2,-16(fp)
 182c33c:	008003f4 	movhi	r2,15
 182c340:	10909004 	addi	r2,r2,16960
 182c344:	1880051e 	bne	r3,r2,182c35c <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 182c348:	01006134 	movhi	r4,388
 182c34c:	2107a504 	addi	r4,r4,7828
 182c350:	183d2fc0 	call	183d2fc <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 182c354:	00bffa84 	movi	r2,-22
 182c358:	00001106 	br	182c3a0 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 182c35c:	e0bffe17 	ldw	r2,-8(fp)
 182c360:	10800217 	ldw	r2,8(r2)
 182c364:	10800317 	ldw	r2,12(r2)
 182c368:	10800037 	ldwio	r2,0(r2)
 182c36c:	1080040c 	andi	r2,r2,16
 182c370:	103fef1e 	bne	r2,zero,182c330 <__ram_exceptions_end+0xff81beec>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 182c374:	e0bffe17 	ldw	r2,-8(fp)
 182c378:	10800217 	ldw	r2,8(r2)
 182c37c:	e17fff17 	ldw	r5,-4(fp)
 182c380:	1009883a 	mov	r4,r2
 182c384:	18259840 	call	1825984 <alt_avalon_sgdma_do_async_transfer>
 182c388:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 182c38c:	e0bffd03 	ldbu	r2,-12(fp)
 182c390:	10000226 	beq	r2,zero,182c39c <tse_mac_aRxRead+0x90>
    return -1;
 182c394:	00bfffc4 	movi	r2,-1
 182c398:	00000106 	br	182c3a0 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 182c39c:	0005883a 	mov	r2,zero
}
 182c3a0:	e037883a 	mov	sp,fp
 182c3a4:	dfc00117 	ldw	ra,4(sp)
 182c3a8:	df000017 	ldw	fp,0(sp)
 182c3ac:	dec00204 	addi	sp,sp,8
 182c3b0:	f800283a 	ret

0182c3b4 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 182c3b4:	defffc04 	addi	sp,sp,-16
 182c3b8:	df000315 	stw	fp,12(sp)
 182c3bc:	df000304 	addi	fp,sp,12
 182c3c0:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 182c3c4:	e0bfff17 	ldw	r2,-4(fp)
 182c3c8:	10800204 	addi	r2,r2,8
 182c3cc:	10800037 	ldwio	r2,0(r2)
 182c3d0:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 182c3d4:	e0bfff17 	ldw	r2,-4(fp)
 182c3d8:	10800204 	addi	r2,r2,8
 182c3dc:	00c80204 	movi	r3,8200
 182c3e0:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 182c3e4:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 182c3e8:	00000306 	br	182c3f8 <tse_mac_SwReset+0x44>
 182c3ec:	e0bffd17 	ldw	r2,-12(fp)
 182c3f0:	10800044 	addi	r2,r2,1
 182c3f4:	e0bffd15 	stw	r2,-12(fp)
 182c3f8:	e0bfff17 	ldw	r2,-4(fp)
 182c3fc:	10800204 	addi	r2,r2,8
 182c400:	10800037 	ldwio	r2,0(r2)
 182c404:	1088000c 	andi	r2,r2,8192
 182c408:	10000326 	beq	r2,zero,182c418 <tse_mac_SwReset+0x64>
 182c40c:	e0bffd17 	ldw	r2,-12(fp)
 182c410:	1089c410 	cmplti	r2,r2,10000
 182c414:	103ff51e 	bne	r2,zero,182c3ec <__ram_exceptions_end+0xff81bfa8>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 182c418:	e0bfff17 	ldw	r2,-4(fp)
 182c41c:	10800204 	addi	r2,r2,8
 182c420:	e0fffe17 	ldw	r3,-8(fp)
 182c424:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 182c428:	0005883a 	mov	r2,zero
}
 182c42c:	e037883a 	mov	sp,fp
 182c430:	df000017 	ldw	fp,0(sp)
 182c434:	dec00104 	addi	sp,sp,4
 182c438:	f800283a 	ret

0182c43c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 182c43c:	defffd04 	addi	sp,sp,-12
 182c440:	df000215 	stw	fp,8(sp)
 182c444:	df000204 	addi	fp,sp,8
 182c448:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 182c44c:	e0bfff17 	ldw	r2,-4(fp)
 182c450:	10800204 	addi	r2,r2,8
 182c454:	10800037 	ldwio	r2,0(r2)
 182c458:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 182c45c:	e0fffe17 	ldw	r3,-8(fp)
 182c460:	00bffdc4 	movi	r2,-9
 182c464:	1884703a 	and	r2,r3,r2
 182c468:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 182c46c:	e0bfff17 	ldw	r2,-4(fp)
 182c470:	10800204 	addi	r2,r2,8
 182c474:	e0fffe17 	ldw	r3,-8(fp)
 182c478:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 182c47c:	0005883a 	mov	r2,zero
}
 182c480:	e037883a 	mov	sp,fp
 182c484:	df000017 	ldw	fp,0(sp)
 182c488:	dec00104 	addi	sp,sp,4
 182c48c:	f800283a 	ret

0182c490 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 182c490:	defffd04 	addi	sp,sp,-12
 182c494:	df000215 	stw	fp,8(sp)
 182c498:	df000204 	addi	fp,sp,8
 182c49c:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 182c4a0:	e0bfff17 	ldw	r2,-4(fp)
 182c4a4:	10800204 	addi	r2,r2,8
 182c4a8:	10800037 	ldwio	r2,0(r2)
 182c4ac:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 182c4b0:	e0bffe17 	ldw	r2,-8(fp)
 182c4b4:	10800214 	ori	r2,r2,8
 182c4b8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 182c4bc:	e0bfff17 	ldw	r2,-4(fp)
 182c4c0:	10800204 	addi	r2,r2,8
 182c4c4:	e0fffe17 	ldw	r3,-8(fp)
 182c4c8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 182c4cc:	0005883a 	mov	r2,zero
}
 182c4d0:	e037883a 	mov	sp,fp
 182c4d4:	df000017 	ldw	fp,0(sp)
 182c4d8:	dec00104 	addi	sp,sp,4
 182c4dc:	f800283a 	ret

0182c4e0 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 182c4e0:	defffb04 	addi	sp,sp,-20
 182c4e4:	dfc00415 	stw	ra,16(sp)
 182c4e8:	df000315 	stw	fp,12(sp)
 182c4ec:	dc000215 	stw	r16,8(sp)
 182c4f0:	df000304 	addi	fp,sp,12
 182c4f4:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 182c4f8:	e03ffd15 	stw	zero,-12(fp)
 182c4fc:	00002906 	br	182c5a4 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 182c500:	008061f4 	movhi	r2,391
 182c504:	10aab904 	addi	r2,r2,-21788
 182c508:	e0fffd17 	ldw	r3,-12(fp)
 182c50c:	18c7883a 	add	r3,r3,r3
 182c510:	18c7883a 	add	r3,r3,r3
 182c514:	10c5883a 	add	r2,r2,r3
 182c518:	10800017 	ldw	r2,0(r2)
 182c51c:	10c01417 	ldw	r3,80(r2)
 182c520:	e0bffe17 	ldw	r2,-8(fp)
 182c524:	10801417 	ldw	r2,80(r2)
 182c528:	18801b1e 	bne	r3,r2,182c598 <alt_tse_phy_add_profile+0xb8>
 182c52c:	008061f4 	movhi	r2,391
 182c530:	10aab904 	addi	r2,r2,-21788
 182c534:	e0fffd17 	ldw	r3,-12(fp)
 182c538:	18c7883a 	add	r3,r3,r3
 182c53c:	18c7883a 	add	r3,r3,r3
 182c540:	10c5883a 	add	r2,r2,r3
 182c544:	10800017 	ldw	r2,0(r2)
 182c548:	10c01503 	ldbu	r3,84(r2)
 182c54c:	e0bffe17 	ldw	r2,-8(fp)
 182c550:	10801503 	ldbu	r2,84(r2)
 182c554:	18c03fcc 	andi	r3,r3,255
 182c558:	10803fcc 	andi	r2,r2,255
 182c55c:	18800e1e 	bne	r3,r2,182c598 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 182c560:	e0bffe17 	ldw	r2,-8(fp)
 182c564:	10801417 	ldw	r2,80(r2)
 182c568:	1007883a 	mov	r3,r2
 182c56c:	e0bffe17 	ldw	r2,-8(fp)
 182c570:	10801503 	ldbu	r2,84(r2)
 182c574:	10803fcc 	andi	r2,r2,255
 182c578:	100d883a 	mov	r6,r2
 182c57c:	180b883a 	mov	r5,r3
 182c580:	01006134 	movhi	r4,388
 182c584:	2107ac04 	addi	r4,r4,7856
 182c588:	1800c180 	call	1800c18 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 182c58c:	01006134 	movhi	r4,388
 182c590:	2107c004 	addi	r4,r4,7936
 182c594:	183d2fc0 	call	183d2fc <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 182c598:	e0bffd17 	ldw	r2,-12(fp)
 182c59c:	10800044 	addi	r2,r2,1
 182c5a0:	e0bffd15 	stw	r2,-12(fp)
 182c5a4:	d0a81003 	ldbu	r2,-24512(gp)
 182c5a8:	10803fcc 	andi	r2,r2,255
 182c5ac:	e0fffd17 	ldw	r3,-12(fp)
 182c5b0:	18bfd316 	blt	r3,r2,182c500 <__ram_exceptions_end+0xff81c0bc>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 182c5b4:	d0a81003 	ldbu	r2,-24512(gp)
 182c5b8:	14003fcc 	andi	r16,r2,255
 182c5bc:	01001904 	movi	r4,100
 182c5c0:	183d0300 	call	183d030 <malloc>
 182c5c4:	1009883a 	mov	r4,r2
 182c5c8:	008061f4 	movhi	r2,391
 182c5cc:	10aab904 	addi	r2,r2,-21788
 182c5d0:	8407883a 	add	r3,r16,r16
 182c5d4:	18c7883a 	add	r3,r3,r3
 182c5d8:	10c5883a 	add	r2,r2,r3
 182c5dc:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 182c5e0:	d0a81003 	ldbu	r2,-24512(gp)
 182c5e4:	10c03fcc 	andi	r3,r2,255
 182c5e8:	008061f4 	movhi	r2,391
 182c5ec:	10aab904 	addi	r2,r2,-21788
 182c5f0:	18c7883a 	add	r3,r3,r3
 182c5f4:	18c7883a 	add	r3,r3,r3
 182c5f8:	10c5883a 	add	r2,r2,r3
 182c5fc:	10800017 	ldw	r2,0(r2)
 182c600:	1000081e 	bne	r2,zero,182c624 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 182c604:	d0a81003 	ldbu	r2,-24512(gp)
 182c608:	10803fcc 	andi	r2,r2,255
 182c60c:	100b883a 	mov	r5,r2
 182c610:	01006134 	movhi	r4,388
 182c614:	2107d804 	addi	r4,r4,8032
 182c618:	1800c180 	call	1800c18 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 182c61c:	00bfffc4 	movi	r2,-1
 182c620:	00002206 	br	182c6ac <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 182c624:	d0a81003 	ldbu	r2,-24512(gp)
 182c628:	10c03fcc 	andi	r3,r2,255
 182c62c:	008061f4 	movhi	r2,391
 182c630:	10aab904 	addi	r2,r2,-21788
 182c634:	18c7883a 	add	r3,r3,r3
 182c638:	18c7883a 	add	r3,r3,r3
 182c63c:	10c5883a 	add	r2,r2,r3
 182c640:	10c00017 	ldw	r3,0(r2)
 182c644:	e0bffe17 	ldw	r2,-8(fp)
 182c648:	1009883a 	mov	r4,r2
 182c64c:	00801904 	movi	r2,100
 182c650:	100d883a 	mov	r6,r2
 182c654:	200b883a 	mov	r5,r4
 182c658:	1809883a 	mov	r4,r3
 182c65c:	180608c0 	call	180608c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 182c660:	d0a81003 	ldbu	r2,-24512(gp)
 182c664:	10c03fcc 	andi	r3,r2,255
 182c668:	008061f4 	movhi	r2,391
 182c66c:	10aab904 	addi	r2,r2,-21788
 182c670:	18c7883a 	add	r3,r3,r3
 182c674:	18c7883a 	add	r3,r3,r3
 182c678:	10c5883a 	add	r2,r2,r3
 182c67c:	10800017 	ldw	r2,0(r2)
 182c680:	1007883a 	mov	r3,r2
 182c684:	e0bffe17 	ldw	r2,-8(fp)
 182c688:	100b883a 	mov	r5,r2
 182c68c:	1809883a 	mov	r4,r3
 182c690:	183d4cc0 	call	183d4cc <strcpy>
    
    phy_profile_count++;
 182c694:	d0a81003 	ldbu	r2,-24512(gp)
 182c698:	10800044 	addi	r2,r2,1
 182c69c:	d0a81005 	stb	r2,-24512(gp)
    
    return phy_profile_count - 1;
 182c6a0:	d0a81003 	ldbu	r2,-24512(gp)
 182c6a4:	10803fcc 	andi	r2,r2,255
 182c6a8:	10bfffc4 	addi	r2,r2,-1
}
 182c6ac:	e6ffff04 	addi	sp,fp,-4
 182c6b0:	dfc00217 	ldw	ra,8(sp)
 182c6b4:	df000117 	ldw	fp,4(sp)
 182c6b8:	dc000017 	ldw	r16,0(sp)
 182c6bc:	dec00304 	addi	sp,sp,12
 182c6c0:	f800283a 	ret

0182c6c4 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 182c6c4:	defff204 	addi	sp,sp,-56
 182c6c8:	dfc00d15 	stw	ra,52(sp)
 182c6cc:	df000c15 	stw	fp,48(sp)
 182c6d0:	dc000b15 	stw	r16,44(sp)
 182c6d4:	df000c04 	addi	fp,sp,48
 182c6d8:	e13ffb15 	stw	r4,-20(fp)
 182c6dc:	e17ffc15 	stw	r5,-16(fp)
 182c6e0:	e1bffd15 	stw	r6,-12(fp)
 182c6e4:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 182c6e8:	e0bffb17 	ldw	r2,-20(fp)
 182c6ec:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 182c6f0:	e0bffc17 	ldw	r2,-16(fp)
 182c6f4:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 182c6f8:	e0bffd17 	ldw	r2,-12(fp)
 182c6fc:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 182c700:	e0bffe17 	ldw	r2,-8(fp)
 182c704:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 182c708:	e0800217 	ldw	r2,8(fp)
 182c70c:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 182c710:	e0bffa17 	ldw	r2,-24(fp)
 182c714:	10800303 	ldbu	r2,12(r2)
 182c718:	10803fcc 	andi	r2,r2,255
 182c71c:	1000031e 	bne	r2,zero,182c72c <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 182c720:	00800044 	movi	r2,1
 182c724:	e0bff515 	stw	r2,-44(fp)
 182c728:	00000e06 	br	182c764 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 182c72c:	e0bffa17 	ldw	r2,-24(fp)
 182c730:	10800303 	ldbu	r2,12(r2)
 182c734:	10803fcc 	andi	r2,r2,255
 182c738:	10000526 	beq	r2,zero,182c750 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 182c73c:	e0bffa17 	ldw	r2,-24(fp)
 182c740:	10800303 	ldbu	r2,12(r2)
 182c744:	10803fcc 	andi	r2,r2,255
 182c748:	e0bff515 	stw	r2,-44(fp)
 182c74c:	00000506 	br	182c764 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 182c750:	01006134 	movhi	r4,388
 182c754:	2107e704 	addi	r4,r4,8092
 182c758:	183d2fc0 	call	183d2fc <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182c75c:	00bfffc4 	movi	r2,-1
 182c760:	00025106 	br	182d0a8 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 182c764:	e03ff415 	stw	zero,-48(fp)
 182c768:	00024b06 	br	182d098 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 182c76c:	d0a81083 	ldbu	r2,-24510(gp)
 182c770:	10803fcc 	andi	r2,r2,255
 182c774:	1080201c 	xori	r2,r2,128
 182c778:	10bfe004 	addi	r2,r2,-128
 182c77c:	10800210 	cmplti	r2,r2,8
 182c780:	10000c1e 	bne	r2,zero,182c7b4 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 182c784:	01006134 	movhi	r4,388
 182c788:	2107f304 	addi	r4,r4,8140
 182c78c:	183d2fc0 	call	183d2fc <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 182c790:	d0a81083 	ldbu	r2,-24510(gp)
 182c794:	10803fcc 	andi	r2,r2,255
 182c798:	1080201c 	xori	r2,r2,128
 182c79c:	10bfe004 	addi	r2,r2,-128
 182c7a0:	100d883a 	mov	r6,r2
 182c7a4:	01400204 	movi	r5,8
 182c7a8:	01006134 	movhi	r4,388
 182c7ac:	21080304 	addi	r4,r4,8204
 182c7b0:	1800c180 	call	1800c18 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 182c7b4:	e0bffa17 	ldw	r2,-24(fp)
 182c7b8:	1000081e 	bne	r2,zero,182c7dc <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 182c7bc:	01006134 	movhi	r4,388
 182c7c0:	21081204 	addi	r4,r4,8264
 182c7c4:	183d2fc0 	call	183d2fc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 182c7c8:	01006134 	movhi	r4,388
 182c7cc:	21081c04 	addi	r4,r4,8304
 182c7d0:	183d2fc0 	call	183d2fc <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182c7d4:	00bfffc4 	movi	r2,-1
 182c7d8:	00023306 	br	182d0a8 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 182c7dc:	d0a81083 	ldbu	r2,-24510(gp)
 182c7e0:	11003fcc 	andi	r4,r2,255
 182c7e4:	2100201c 	xori	r4,r4,128
 182c7e8:	213fe004 	addi	r4,r4,-128
 182c7ec:	e0bffa17 	ldw	r2,-24(fp)
 182c7f0:	10800017 	ldw	r2,0(r2)
 182c7f4:	e0fff417 	ldw	r3,-48(fp)
 182c7f8:	180692ba 	slli	r3,r3,10
 182c7fc:	10c7883a 	add	r3,r2,r3
 182c800:	00806134 	movhi	r2,388
 182c804:	1096c404 	addi	r2,r2,23312
 182c808:	21001224 	muli	r4,r4,72
 182c80c:	1105883a 	add	r2,r2,r4
 182c810:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 182c814:	d0a81083 	ldbu	r2,-24510(gp)
 182c818:	11003fcc 	andi	r4,r2,255
 182c81c:	2100201c 	xori	r4,r4,128
 182c820:	213fe004 	addi	r4,r4,-128
 182c824:	e0bffa17 	ldw	r2,-24(fp)
 182c828:	10c0010b 	ldhu	r3,4(r2)
 182c82c:	00806134 	movhi	r2,388
 182c830:	1096c404 	addi	r2,r2,23312
 182c834:	21001224 	muli	r4,r4,72
 182c838:	1105883a 	add	r2,r2,r4
 182c83c:	10800104 	addi	r2,r2,4
 182c840:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 182c844:	d0a81083 	ldbu	r2,-24510(gp)
 182c848:	11003fcc 	andi	r4,r2,255
 182c84c:	2100201c 	xori	r4,r4,128
 182c850:	213fe004 	addi	r4,r4,-128
 182c854:	e0bffa17 	ldw	r2,-24(fp)
 182c858:	10c0018b 	ldhu	r3,6(r2)
 182c85c:	00806134 	movhi	r2,388
 182c860:	1096c404 	addi	r2,r2,23312
 182c864:	21001224 	muli	r4,r4,72
 182c868:	1105883a 	add	r2,r2,r4
 182c86c:	10800184 	addi	r2,r2,6
 182c870:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 182c874:	d0a81083 	ldbu	r2,-24510(gp)
 182c878:	11003fcc 	andi	r4,r2,255
 182c87c:	2100201c 	xori	r4,r4,128
 182c880:	213fe004 	addi	r4,r4,-128
 182c884:	e0bffa17 	ldw	r2,-24(fp)
 182c888:	10c00203 	ldbu	r3,8(r2)
 182c88c:	00806134 	movhi	r2,388
 182c890:	1096c404 	addi	r2,r2,23312
 182c894:	21001224 	muli	r4,r4,72
 182c898:	1105883a 	add	r2,r2,r4
 182c89c:	10800204 	addi	r2,r2,8
 182c8a0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 182c8a4:	d0a81083 	ldbu	r2,-24510(gp)
 182c8a8:	11003fcc 	andi	r4,r2,255
 182c8ac:	2100201c 	xori	r4,r4,128
 182c8b0:	213fe004 	addi	r4,r4,-128
 182c8b4:	e0bffa17 	ldw	r2,-24(fp)
 182c8b8:	10c00243 	ldbu	r3,9(r2)
 182c8bc:	00806134 	movhi	r2,388
 182c8c0:	1096c404 	addi	r2,r2,23312
 182c8c4:	21001224 	muli	r4,r4,72
 182c8c8:	1105883a 	add	r2,r2,r4
 182c8cc:	10800244 	addi	r2,r2,9
 182c8d0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 182c8d4:	d0a81083 	ldbu	r2,-24510(gp)
 182c8d8:	11003fcc 	andi	r4,r2,255
 182c8dc:	2100201c 	xori	r4,r4,128
 182c8e0:	213fe004 	addi	r4,r4,-128
 182c8e4:	e0bffa17 	ldw	r2,-24(fp)
 182c8e8:	10c00283 	ldbu	r3,10(r2)
 182c8ec:	00806134 	movhi	r2,388
 182c8f0:	1096c404 	addi	r2,r2,23312
 182c8f4:	21001224 	muli	r4,r4,72
 182c8f8:	1105883a 	add	r2,r2,r4
 182c8fc:	10800284 	addi	r2,r2,10
 182c900:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 182c904:	d0a81083 	ldbu	r2,-24510(gp)
 182c908:	11003fcc 	andi	r4,r2,255
 182c90c:	2100201c 	xori	r4,r4,128
 182c910:	213fe004 	addi	r4,r4,-128
 182c914:	e0bffa17 	ldw	r2,-24(fp)
 182c918:	10c002c3 	ldbu	r3,11(r2)
 182c91c:	00806134 	movhi	r2,388
 182c920:	1096c404 	addi	r2,r2,23312
 182c924:	21001224 	muli	r4,r4,72
 182c928:	1105883a 	add	r2,r2,r4
 182c92c:	108002c4 	addi	r2,r2,11
 182c930:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 182c934:	d0a81083 	ldbu	r2,-24510(gp)
 182c938:	11003fcc 	andi	r4,r2,255
 182c93c:	2100201c 	xori	r4,r4,128
 182c940:	213fe004 	addi	r4,r4,-128
 182c944:	e0bffa17 	ldw	r2,-24(fp)
 182c948:	10c00303 	ldbu	r3,12(r2)
 182c94c:	00806134 	movhi	r2,388
 182c950:	1096c404 	addi	r2,r2,23312
 182c954:	21001224 	muli	r4,r4,72
 182c958:	1105883a 	add	r2,r2,r4
 182c95c:	10800304 	addi	r2,r2,12
 182c960:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 182c964:	d0a81083 	ldbu	r2,-24510(gp)
 182c968:	11003fcc 	andi	r4,r2,255
 182c96c:	2100201c 	xori	r4,r4,128
 182c970:	213fe004 	addi	r4,r4,-128
 182c974:	e0bffa17 	ldw	r2,-24(fp)
 182c978:	10c00343 	ldbu	r3,13(r2)
 182c97c:	00806134 	movhi	r2,388
 182c980:	1096c404 	addi	r2,r2,23312
 182c984:	21001224 	muli	r4,r4,72
 182c988:	1105883a 	add	r2,r2,r4
 182c98c:	10800344 	addi	r2,r2,13
 182c990:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 182c994:	d0a81083 	ldbu	r2,-24510(gp)
 182c998:	11003fcc 	andi	r4,r2,255
 182c99c:	2100201c 	xori	r4,r4,128
 182c9a0:	213fe004 	addi	r4,r4,-128
 182c9a4:	e0bffa17 	ldw	r2,-24(fp)
 182c9a8:	10c00383 	ldbu	r3,14(r2)
 182c9ac:	00806134 	movhi	r2,388
 182c9b0:	1096c404 	addi	r2,r2,23312
 182c9b4:	21001224 	muli	r4,r4,72
 182c9b8:	1105883a 	add	r2,r2,r4
 182c9bc:	10800384 	addi	r2,r2,14
 182c9c0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 182c9c4:	d0a81083 	ldbu	r2,-24510(gp)
 182c9c8:	11003fcc 	andi	r4,r2,255
 182c9cc:	2100201c 	xori	r4,r4,128
 182c9d0:	213fe004 	addi	r4,r4,-128
 182c9d4:	e0bffa17 	ldw	r2,-24(fp)
 182c9d8:	10c003c3 	ldbu	r3,15(r2)
 182c9dc:	00806134 	movhi	r2,388
 182c9e0:	1096c404 	addi	r2,r2,23312
 182c9e4:	21001224 	muli	r4,r4,72
 182c9e8:	1105883a 	add	r2,r2,r4
 182c9ec:	108003c4 	addi	r2,r2,15
 182c9f0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 182c9f4:	d0a81083 	ldbu	r2,-24510(gp)
 182c9f8:	11003fcc 	andi	r4,r2,255
 182c9fc:	2100201c 	xori	r4,r4,128
 182ca00:	213fe004 	addi	r4,r4,-128
 182ca04:	e0bffa17 	ldw	r2,-24(fp)
 182ca08:	10c00403 	ldbu	r3,16(r2)
 182ca0c:	00806134 	movhi	r2,388
 182ca10:	1096c404 	addi	r2,r2,23312
 182ca14:	21001224 	muli	r4,r4,72
 182ca18:	1105883a 	add	r2,r2,r4
 182ca1c:	10800404 	addi	r2,r2,16
 182ca20:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 182ca24:	e0bff617 	ldw	r2,-40(fp)
 182ca28:	10000d1e 	bne	r2,zero,182ca60 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 182ca2c:	01006134 	movhi	r4,388
 182ca30:	21082e04 	addi	r4,r4,8376
 182ca34:	183d2fc0 	call	183d2fc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 182ca38:	d0a81083 	ldbu	r2,-24510(gp)
 182ca3c:	10803fcc 	andi	r2,r2,255
 182ca40:	1080201c 	xori	r2,r2,128
 182ca44:	10bfe004 	addi	r2,r2,-128
 182ca48:	100b883a 	mov	r5,r2
 182ca4c:	01006134 	movhi	r4,388
 182ca50:	21083904 	addi	r4,r4,8420
 182ca54:	1800c180 	call	1800c18 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182ca58:	00bfffc4 	movi	r2,-1
 182ca5c:	00019206 	br	182d0a8 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 182ca60:	d0a81083 	ldbu	r2,-24510(gp)
 182ca64:	14003fcc 	andi	r16,r2,255
 182ca68:	8400201c 	xori	r16,r16,128
 182ca6c:	843fe004 	addi	r16,r16,-128
 182ca70:	e0bff617 	ldw	r2,-40(fp)
 182ca74:	10800017 	ldw	r2,0(r2)
 182ca78:	1009883a 	mov	r4,r2
 182ca7c:	18075d80 	call	18075d8 <strlen>
 182ca80:	10800044 	addi	r2,r2,1
 182ca84:	1009883a 	mov	r4,r2
 182ca88:	183d0300 	call	183d030 <malloc>
 182ca8c:	1009883a 	mov	r4,r2
 182ca90:	00806134 	movhi	r2,388
 182ca94:	1096c404 	addi	r2,r2,23312
 182ca98:	80c01224 	muli	r3,r16,72
 182ca9c:	10c5883a 	add	r2,r2,r3
 182caa0:	10800504 	addi	r2,r2,20
 182caa4:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 182caa8:	d0a81083 	ldbu	r2,-24510(gp)
 182caac:	10c03fcc 	andi	r3,r2,255
 182cab0:	18c0201c 	xori	r3,r3,128
 182cab4:	18ffe004 	addi	r3,r3,-128
 182cab8:	00806134 	movhi	r2,388
 182cabc:	1096c404 	addi	r2,r2,23312
 182cac0:	18c01224 	muli	r3,r3,72
 182cac4:	10c5883a 	add	r2,r2,r3
 182cac8:	10800504 	addi	r2,r2,20
 182cacc:	10800017 	ldw	r2,0(r2)
 182cad0:	10000a1e 	bne	r2,zero,182cafc <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 182cad4:	d0a81083 	ldbu	r2,-24510(gp)
 182cad8:	10803fcc 	andi	r2,r2,255
 182cadc:	1080201c 	xori	r2,r2,128
 182cae0:	10bfe004 	addi	r2,r2,-128
 182cae4:	100b883a 	mov	r5,r2
 182cae8:	01006134 	movhi	r4,388
 182caec:	21085104 	addi	r4,r4,8516
 182caf0:	1800c180 	call	1800c18 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 182caf4:	00bfffc4 	movi	r2,-1
 182caf8:	00016b06 	br	182d0a8 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 182cafc:	d0a81083 	ldbu	r2,-24510(gp)
 182cb00:	10c03fcc 	andi	r3,r2,255
 182cb04:	18c0201c 	xori	r3,r3,128
 182cb08:	18ffe004 	addi	r3,r3,-128
 182cb0c:	00806134 	movhi	r2,388
 182cb10:	1096c404 	addi	r2,r2,23312
 182cb14:	18c01224 	muli	r3,r3,72
 182cb18:	10c5883a 	add	r2,r2,r3
 182cb1c:	10800504 	addi	r2,r2,20
 182cb20:	10c00017 	ldw	r3,0(r2)
 182cb24:	e0bff617 	ldw	r2,-40(fp)
 182cb28:	10800017 	ldw	r2,0(r2)
 182cb2c:	100b883a 	mov	r5,r2
 182cb30:	1809883a 	mov	r4,r3
 182cb34:	183d4cc0 	call	183d4cc <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 182cb38:	d0a81083 	ldbu	r2,-24510(gp)
 182cb3c:	14003fcc 	andi	r16,r2,255
 182cb40:	8400201c 	xori	r16,r16,128
 182cb44:	843fe004 	addi	r16,r16,-128
 182cb48:	e0bff617 	ldw	r2,-40(fp)
 182cb4c:	10800117 	ldw	r2,4(r2)
 182cb50:	1009883a 	mov	r4,r2
 182cb54:	18075d80 	call	18075d8 <strlen>
 182cb58:	10800044 	addi	r2,r2,1
 182cb5c:	1009883a 	mov	r4,r2
 182cb60:	183d0300 	call	183d030 <malloc>
 182cb64:	1009883a 	mov	r4,r2
 182cb68:	00806134 	movhi	r2,388
 182cb6c:	1096c404 	addi	r2,r2,23312
 182cb70:	80c01224 	muli	r3,r16,72
 182cb74:	10c5883a 	add	r2,r2,r3
 182cb78:	10800604 	addi	r2,r2,24
 182cb7c:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 182cb80:	d0a81083 	ldbu	r2,-24510(gp)
 182cb84:	10c03fcc 	andi	r3,r2,255
 182cb88:	18c0201c 	xori	r3,r3,128
 182cb8c:	18ffe004 	addi	r3,r3,-128
 182cb90:	00806134 	movhi	r2,388
 182cb94:	1096c404 	addi	r2,r2,23312
 182cb98:	18c01224 	muli	r3,r3,72
 182cb9c:	10c5883a 	add	r2,r2,r3
 182cba0:	10800604 	addi	r2,r2,24
 182cba4:	10800017 	ldw	r2,0(r2)
 182cba8:	10000a1e 	bne	r2,zero,182cbd4 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 182cbac:	d0a81083 	ldbu	r2,-24510(gp)
 182cbb0:	10803fcc 	andi	r2,r2,255
 182cbb4:	1080201c 	xori	r2,r2,128
 182cbb8:	10bfe004 	addi	r2,r2,-128
 182cbbc:	100b883a 	mov	r5,r2
 182cbc0:	01006134 	movhi	r4,388
 182cbc4:	21086404 	addi	r4,r4,8592
 182cbc8:	1800c180 	call	1800c18 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 182cbcc:	00bfffc4 	movi	r2,-1
 182cbd0:	00013506 	br	182d0a8 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 182cbd4:	d0a81083 	ldbu	r2,-24510(gp)
 182cbd8:	10c03fcc 	andi	r3,r2,255
 182cbdc:	18c0201c 	xori	r3,r3,128
 182cbe0:	18ffe004 	addi	r3,r3,-128
 182cbe4:	00806134 	movhi	r2,388
 182cbe8:	1096c404 	addi	r2,r2,23312
 182cbec:	18c01224 	muli	r3,r3,72
 182cbf0:	10c5883a 	add	r2,r2,r3
 182cbf4:	10800604 	addi	r2,r2,24
 182cbf8:	10c00017 	ldw	r3,0(r2)
 182cbfc:	e0bff617 	ldw	r2,-40(fp)
 182cc00:	10800117 	ldw	r2,4(r2)
 182cc04:	100b883a 	mov	r5,r2
 182cc08:	1809883a 	mov	r4,r3
 182cc0c:	183d4cc0 	call	183d4cc <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 182cc10:	d0a81083 	ldbu	r2,-24510(gp)
 182cc14:	11003fcc 	andi	r4,r2,255
 182cc18:	2100201c 	xori	r4,r4,128
 182cc1c:	213fe004 	addi	r4,r4,-128
 182cc20:	e0bff617 	ldw	r2,-40(fp)
 182cc24:	10c0020b 	ldhu	r3,8(r2)
 182cc28:	00806134 	movhi	r2,388
 182cc2c:	1096c404 	addi	r2,r2,23312
 182cc30:	21001224 	muli	r4,r4,72
 182cc34:	1105883a 	add	r2,r2,r4
 182cc38:	10800704 	addi	r2,r2,28
 182cc3c:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 182cc40:	e0bff717 	ldw	r2,-36(fp)
 182cc44:	1000151e 	bne	r2,zero,182cc9c <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 182cc48:	d0a81083 	ldbu	r2,-24510(gp)
 182cc4c:	10c03fcc 	andi	r3,r2,255
 182cc50:	18c0201c 	xori	r3,r3,128
 182cc54:	18ffe004 	addi	r3,r3,-128
 182cc58:	00806134 	movhi	r2,388
 182cc5c:	1096c404 	addi	r2,r2,23312
 182cc60:	18c01224 	muli	r3,r3,72
 182cc64:	10c5883a 	add	r2,r2,r3
 182cc68:	10800784 	addi	r2,r2,30
 182cc6c:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 182cc70:	d0a81083 	ldbu	r2,-24510(gp)
 182cc74:	10c03fcc 	andi	r3,r2,255
 182cc78:	18c0201c 	xori	r3,r3,128
 182cc7c:	18ffe004 	addi	r3,r3,-128
 182cc80:	00806134 	movhi	r2,388
 182cc84:	1096c404 	addi	r2,r2,23312
 182cc88:	18c01224 	muli	r3,r3,72
 182cc8c:	10c5883a 	add	r2,r2,r3
 182cc90:	10800804 	addi	r2,r2,32
 182cc94:	10000015 	stw	zero,0(r2)
 182cc98:	00001806 	br	182ccfc <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 182cc9c:	d0a81083 	ldbu	r2,-24510(gp)
 182cca0:	11003fcc 	andi	r4,r2,255
 182cca4:	2100201c 	xori	r4,r4,128
 182cca8:	213fe004 	addi	r4,r4,-128
 182ccac:	e0bff717 	ldw	r2,-36(fp)
 182ccb0:	10c00003 	ldbu	r3,0(r2)
 182ccb4:	00806134 	movhi	r2,388
 182ccb8:	1096c404 	addi	r2,r2,23312
 182ccbc:	21001224 	muli	r4,r4,72
 182ccc0:	1105883a 	add	r2,r2,r4
 182ccc4:	10800784 	addi	r2,r2,30
 182ccc8:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 182cccc:	d0a81083 	ldbu	r2,-24510(gp)
 182ccd0:	11003fcc 	andi	r4,r2,255
 182ccd4:	2100201c 	xori	r4,r4,128
 182ccd8:	213fe004 	addi	r4,r4,-128
 182ccdc:	e0bff717 	ldw	r2,-36(fp)
 182cce0:	10c00117 	ldw	r3,4(r2)
 182cce4:	00806134 	movhi	r2,388
 182cce8:	1096c404 	addi	r2,r2,23312
 182ccec:	21001224 	muli	r4,r4,72
 182ccf0:	1105883a 	add	r2,r2,r4
 182ccf4:	10800804 	addi	r2,r2,32
 182ccf8:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 182ccfc:	e0bff817 	ldw	r2,-32(fp)
 182cd00:	1000471e 	bne	r2,zero,182ce20 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 182cd04:	d0a81083 	ldbu	r2,-24510(gp)
 182cd08:	10c03fcc 	andi	r3,r2,255
 182cd0c:	18c0201c 	xori	r3,r3,128
 182cd10:	18ffe004 	addi	r3,r3,-128
 182cd14:	00806134 	movhi	r2,388
 182cd18:	1096c404 	addi	r2,r2,23312
 182cd1c:	18c01224 	muli	r3,r3,72
 182cd20:	10c5883a 	add	r2,r2,r3
 182cd24:	10800904 	addi	r2,r2,36
 182cd28:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 182cd2c:	d0a81083 	ldbu	r2,-24510(gp)
 182cd30:	10c03fcc 	andi	r3,r2,255
 182cd34:	18c0201c 	xori	r3,r3,128
 182cd38:	18ffe004 	addi	r3,r3,-128
 182cd3c:	00806134 	movhi	r2,388
 182cd40:	1096c404 	addi	r2,r2,23312
 182cd44:	18c01224 	muli	r3,r3,72
 182cd48:	10c5883a 	add	r2,r2,r3
 182cd4c:	10800a04 	addi	r2,r2,40
 182cd50:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 182cd54:	d0a81083 	ldbu	r2,-24510(gp)
 182cd58:	10c03fcc 	andi	r3,r2,255
 182cd5c:	18c0201c 	xori	r3,r3,128
 182cd60:	18ffe004 	addi	r3,r3,-128
 182cd64:	00806134 	movhi	r2,388
 182cd68:	1096c404 	addi	r2,r2,23312
 182cd6c:	18c01224 	muli	r3,r3,72
 182cd70:	10c5883a 	add	r2,r2,r3
 182cd74:	10800b04 	addi	r2,r2,44
 182cd78:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 182cd7c:	d0a81083 	ldbu	r2,-24510(gp)
 182cd80:	10c03fcc 	andi	r3,r2,255
 182cd84:	18c0201c 	xori	r3,r3,128
 182cd88:	18ffe004 	addi	r3,r3,-128
 182cd8c:	00806134 	movhi	r2,388
 182cd90:	1096c404 	addi	r2,r2,23312
 182cd94:	18c01224 	muli	r3,r3,72
 182cd98:	10c5883a 	add	r2,r2,r3
 182cd9c:	10800c04 	addi	r2,r2,48
 182cda0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 182cda4:	d0a81083 	ldbu	r2,-24510(gp)
 182cda8:	10c03fcc 	andi	r3,r2,255
 182cdac:	18c0201c 	xori	r3,r3,128
 182cdb0:	18ffe004 	addi	r3,r3,-128
 182cdb4:	00806134 	movhi	r2,388
 182cdb8:	1096c404 	addi	r2,r2,23312
 182cdbc:	18c01224 	muli	r3,r3,72
 182cdc0:	10c5883a 	add	r2,r2,r3
 182cdc4:	10800d04 	addi	r2,r2,52
 182cdc8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 182cdcc:	d0a81083 	ldbu	r2,-24510(gp)
 182cdd0:	10c03fcc 	andi	r3,r2,255
 182cdd4:	18c0201c 	xori	r3,r3,128
 182cdd8:	18ffe004 	addi	r3,r3,-128
 182cddc:	00806134 	movhi	r2,388
 182cde0:	1096c404 	addi	r2,r2,23312
 182cde4:	18c01224 	muli	r3,r3,72
 182cde8:	10c5883a 	add	r2,r2,r3
 182cdec:	10800e04 	addi	r2,r2,56
 182cdf0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 182cdf4:	d0a81083 	ldbu	r2,-24510(gp)
 182cdf8:	10c03fcc 	andi	r3,r2,255
 182cdfc:	18c0201c 	xori	r3,r3,128
 182ce00:	18ffe004 	addi	r3,r3,-128
 182ce04:	00806134 	movhi	r2,388
 182ce08:	1096c404 	addi	r2,r2,23312
 182ce0c:	18c01224 	muli	r3,r3,72
 182ce10:	10c5883a 	add	r2,r2,r3
 182ce14:	10800f04 	addi	r2,r2,60
 182ce18:	10000015 	stw	zero,0(r2)
 182ce1c:	00005406 	br	182cf70 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 182ce20:	d0a81083 	ldbu	r2,-24510(gp)
 182ce24:	11003fcc 	andi	r4,r2,255
 182ce28:	2100201c 	xori	r4,r4,128
 182ce2c:	213fe004 	addi	r4,r4,-128
 182ce30:	e0bff817 	ldw	r2,-32(fp)
 182ce34:	10c00003 	ldbu	r3,0(r2)
 182ce38:	00806134 	movhi	r2,388
 182ce3c:	1096c404 	addi	r2,r2,23312
 182ce40:	21001224 	muli	r4,r4,72
 182ce44:	1105883a 	add	r2,r2,r4
 182ce48:	10800904 	addi	r2,r2,36
 182ce4c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 182ce50:	d0a81083 	ldbu	r2,-24510(gp)
 182ce54:	11003fcc 	andi	r4,r2,255
 182ce58:	2100201c 	xori	r4,r4,128
 182ce5c:	213fe004 	addi	r4,r4,-128
 182ce60:	e0bff817 	ldw	r2,-32(fp)
 182ce64:	10c00117 	ldw	r3,4(r2)
 182ce68:	00806134 	movhi	r2,388
 182ce6c:	1096c404 	addi	r2,r2,23312
 182ce70:	21001224 	muli	r4,r4,72
 182ce74:	1105883a 	add	r2,r2,r4
 182ce78:	10800a04 	addi	r2,r2,40
 182ce7c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 182ce80:	d0a81083 	ldbu	r2,-24510(gp)
 182ce84:	11003fcc 	andi	r4,r2,255
 182ce88:	2100201c 	xori	r4,r4,128
 182ce8c:	213fe004 	addi	r4,r4,-128
 182ce90:	e0bff817 	ldw	r2,-32(fp)
 182ce94:	10c00217 	ldw	r3,8(r2)
 182ce98:	00806134 	movhi	r2,388
 182ce9c:	1096c404 	addi	r2,r2,23312
 182cea0:	21001224 	muli	r4,r4,72
 182cea4:	1105883a 	add	r2,r2,r4
 182cea8:	10800b04 	addi	r2,r2,44
 182ceac:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 182ceb0:	d0a81083 	ldbu	r2,-24510(gp)
 182ceb4:	11003fcc 	andi	r4,r2,255
 182ceb8:	2100201c 	xori	r4,r4,128
 182cebc:	213fe004 	addi	r4,r4,-128
 182cec0:	e0bff817 	ldw	r2,-32(fp)
 182cec4:	10c00317 	ldw	r3,12(r2)
 182cec8:	00806134 	movhi	r2,388
 182cecc:	1096c404 	addi	r2,r2,23312
 182ced0:	21001224 	muli	r4,r4,72
 182ced4:	1105883a 	add	r2,r2,r4
 182ced8:	10800c04 	addi	r2,r2,48
 182cedc:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 182cee0:	d0a81083 	ldbu	r2,-24510(gp)
 182cee4:	11003fcc 	andi	r4,r2,255
 182cee8:	2100201c 	xori	r4,r4,128
 182ceec:	213fe004 	addi	r4,r4,-128
 182cef0:	e0bff817 	ldw	r2,-32(fp)
 182cef4:	10c00417 	ldw	r3,16(r2)
 182cef8:	00806134 	movhi	r2,388
 182cefc:	1096c404 	addi	r2,r2,23312
 182cf00:	21001224 	muli	r4,r4,72
 182cf04:	1105883a 	add	r2,r2,r4
 182cf08:	10800d04 	addi	r2,r2,52
 182cf0c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 182cf10:	d0a81083 	ldbu	r2,-24510(gp)
 182cf14:	11003fcc 	andi	r4,r2,255
 182cf18:	2100201c 	xori	r4,r4,128
 182cf1c:	213fe004 	addi	r4,r4,-128
 182cf20:	e0bff817 	ldw	r2,-32(fp)
 182cf24:	10c00517 	ldw	r3,20(r2)
 182cf28:	00806134 	movhi	r2,388
 182cf2c:	1096c404 	addi	r2,r2,23312
 182cf30:	21001224 	muli	r4,r4,72
 182cf34:	1105883a 	add	r2,r2,r4
 182cf38:	10800e04 	addi	r2,r2,56
 182cf3c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 182cf40:	d0a81083 	ldbu	r2,-24510(gp)
 182cf44:	11003fcc 	andi	r4,r2,255
 182cf48:	2100201c 	xori	r4,r4,128
 182cf4c:	213fe004 	addi	r4,r4,-128
 182cf50:	e0bff817 	ldw	r2,-32(fp)
 182cf54:	10c00617 	ldw	r3,24(r2)
 182cf58:	00806134 	movhi	r2,388
 182cf5c:	1096c404 	addi	r2,r2,23312
 182cf60:	21001224 	muli	r4,r4,72
 182cf64:	1105883a 	add	r2,r2,r4
 182cf68:	10800f04 	addi	r2,r2,60
 182cf6c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 182cf70:	e0bff917 	ldw	r2,-28(fp)
 182cf74:	1000161e 	bne	r2,zero,182cfd0 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 182cf78:	d0a81083 	ldbu	r2,-24510(gp)
 182cf7c:	10c03fcc 	andi	r3,r2,255
 182cf80:	18c0201c 	xori	r3,r3,128
 182cf84:	18ffe004 	addi	r3,r3,-128
 182cf88:	00806134 	movhi	r2,388
 182cf8c:	1096c404 	addi	r2,r2,23312
 182cf90:	18c01224 	muli	r3,r3,72
 182cf94:	10c5883a 	add	r2,r2,r3
 182cf98:	10801004 	addi	r2,r2,64
 182cf9c:	00ffffc4 	movi	r3,-1
 182cfa0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 182cfa4:	d0a81083 	ldbu	r2,-24510(gp)
 182cfa8:	10c03fcc 	andi	r3,r2,255
 182cfac:	18c0201c 	xori	r3,r3,128
 182cfb0:	18ffe004 	addi	r3,r3,-128
 182cfb4:	00806134 	movhi	r2,388
 182cfb8:	1096c404 	addi	r2,r2,23312
 182cfbc:	18c01224 	muli	r3,r3,72
 182cfc0:	10c5883a 	add	r2,r2,r3
 182cfc4:	10801104 	addi	r2,r2,68
 182cfc8:	10000015 	stw	zero,0(r2)
 182cfcc:	00001806 	br	182d030 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 182cfd0:	d0a81083 	ldbu	r2,-24510(gp)
 182cfd4:	11003fcc 	andi	r4,r2,255
 182cfd8:	2100201c 	xori	r4,r4,128
 182cfdc:	213fe004 	addi	r4,r4,-128
 182cfe0:	e0bff917 	ldw	r2,-28(fp)
 182cfe4:	10c00017 	ldw	r3,0(r2)
 182cfe8:	00806134 	movhi	r2,388
 182cfec:	1096c404 	addi	r2,r2,23312
 182cff0:	21001224 	muli	r4,r4,72
 182cff4:	1105883a 	add	r2,r2,r4
 182cff8:	10801004 	addi	r2,r2,64
 182cffc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 182d000:	d0a81083 	ldbu	r2,-24510(gp)
 182d004:	11003fcc 	andi	r4,r2,255
 182d008:	2100201c 	xori	r4,r4,128
 182d00c:	213fe004 	addi	r4,r4,-128
 182d010:	e0bff917 	ldw	r2,-28(fp)
 182d014:	10c00117 	ldw	r3,4(r2)
 182d018:	00806134 	movhi	r2,388
 182d01c:	1096c404 	addi	r2,r2,23312
 182d020:	21001224 	muli	r4,r4,72
 182d024:	1105883a 	add	r2,r2,r4
 182d028:	10801104 	addi	r2,r2,68
 182d02c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 182d030:	e0bff617 	ldw	r2,-40(fp)
 182d034:	10800304 	addi	r2,r2,12
 182d038:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 182d03c:	e0bff717 	ldw	r2,-36(fp)
 182d040:	10000326 	beq	r2,zero,182d050 <alt_tse_system_add_sys+0x98c>
 182d044:	e0bff717 	ldw	r2,-36(fp)
 182d048:	10800204 	addi	r2,r2,8
 182d04c:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 182d050:	e0bff817 	ldw	r2,-32(fp)
 182d054:	10000326 	beq	r2,zero,182d064 <alt_tse_system_add_sys+0x9a0>
 182d058:	e0bff817 	ldw	r2,-32(fp)
 182d05c:	10800704 	addi	r2,r2,28
 182d060:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 182d064:	e0bff917 	ldw	r2,-28(fp)
 182d068:	10000326 	beq	r2,zero,182d078 <alt_tse_system_add_sys+0x9b4>
 182d06c:	e0bff917 	ldw	r2,-28(fp)
 182d070:	10800204 	addi	r2,r2,8
 182d074:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 182d078:	d0a81083 	ldbu	r2,-24510(gp)
 182d07c:	10800044 	addi	r2,r2,1
 182d080:	d0a81085 	stb	r2,-24510(gp)
		max_mac_system = tse_system_count;
 182d084:	d0a81083 	ldbu	r2,-24510(gp)
 182d088:	d0a01d05 	stb	r2,-32652(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 182d08c:	e0bff417 	ldw	r2,-48(fp)
 182d090:	10800044 	addi	r2,r2,1
 182d094:	e0bff415 	stw	r2,-48(fp)
 182d098:	e0fff417 	ldw	r3,-48(fp)
 182d09c:	e0bff517 	ldw	r2,-44(fp)
 182d0a0:	18bdb216 	blt	r3,r2,182c76c <__ram_exceptions_end+0xff81c328>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 182d0a4:	0005883a 	mov	r2,zero
	
}
 182d0a8:	e6ffff04 	addi	sp,fp,-4
 182d0ac:	dfc00217 	ldw	ra,8(sp)
 182d0b0:	df000117 	ldw	fp,4(sp)
 182d0b4:	dc000017 	ldw	r16,0(sp)
 182d0b8:	dec00304 	addi	sp,sp,12
 182d0bc:	f800283a 	ret

0182d0c0 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 182d0c0:	defff904 	addi	sp,sp,-28
 182d0c4:	dfc00615 	stw	ra,24(sp)
 182d0c8:	df000515 	stw	fp,20(sp)
 182d0cc:	df000504 	addi	fp,sp,20
 182d0d0:	e13ffe15 	stw	r4,-8(fp)
 182d0d4:	2805883a 	mov	r2,r5
 182d0d8:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 182d0dc:	e03ffb15 	stw	zero,-20(fp)
 182d0e0:	00004806 	br	182d204 <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 182d0e4:	e0bffb17 	ldw	r2,-20(fp)
 182d0e8:	1085883a 	add	r2,r2,r2
 182d0ec:	1085883a 	add	r2,r2,r2
 182d0f0:	1007883a 	mov	r3,r2
 182d0f4:	e0bffe17 	ldw	r2,-8(fp)
 182d0f8:	10c5883a 	add	r2,r2,r3
 182d0fc:	10800017 	ldw	r2,0(r2)
 182d100:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 182d104:	e0bffd17 	ldw	r2,-12(fp)
 182d108:	1000081e 	bne	r2,zero,182d12c <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 182d10c:	01006134 	movhi	r4,388
 182d110:	21081204 	addi	r4,r4,8264
 182d114:	183d2fc0 	call	183d2fc <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 182d118:	01006134 	movhi	r4,388
 182d11c:	21087704 	addi	r4,r4,8668
 182d120:	183d2fc0 	call	183d2fc <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182d124:	00bfffc4 	movi	r2,-1
 182d128:	00003a06 	br	182d214 <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 182d12c:	e03ffc15 	stw	zero,-16(fp)
 182d130:	00002d06 	br	182d1e8 <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 182d134:	e0bffd17 	ldw	r2,-12(fp)
 182d138:	10c00017 	ldw	r3,0(r2)
 182d13c:	00806134 	movhi	r2,388
 182d140:	1096c404 	addi	r2,r2,23312
 182d144:	e13ffc17 	ldw	r4,-16(fp)
 182d148:	21001224 	muli	r4,r4,72
 182d14c:	1105883a 	add	r2,r2,r4
 182d150:	10800017 	ldw	r2,0(r2)
 182d154:	1880211e 	bne	r3,r2,182d1dc <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 182d158:	00806134 	movhi	r2,388
 182d15c:	1096c404 	addi	r2,r2,23312
 182d160:	e0fffc17 	ldw	r3,-16(fp)
 182d164:	18c01224 	muli	r3,r3,72
 182d168:	10c5883a 	add	r2,r2,r3
 182d16c:	108002c4 	addi	r2,r2,11
 182d170:	10800003 	ldbu	r2,0(r2)
 182d174:	10803fcc 	andi	r2,r2,255
 182d178:	10000826 	beq	r2,zero,182d19c <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 182d17c:	01006134 	movhi	r4,388
 182d180:	21088b04 	addi	r4,r4,8748
 182d184:	183d2fc0 	call	183d2fc <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 182d188:	01006134 	movhi	r4,388
 182d18c:	21089c04 	addi	r4,r4,8816
 182d190:	183d2fc0 	call	183d2fc <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182d194:	00bfffc4 	movi	r2,-1
 182d198:	00001e06 	br	182d214 <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 182d19c:	00806134 	movhi	r2,388
 182d1a0:	1096c404 	addi	r2,r2,23312
 182d1a4:	e0fffc17 	ldw	r3,-16(fp)
 182d1a8:	18c01224 	muli	r3,r3,72
 182d1ac:	10c5883a 	add	r2,r2,r3
 182d1b0:	10800344 	addi	r2,r2,13
 182d1b4:	00c00044 	movi	r3,1
 182d1b8:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 182d1bc:	00806134 	movhi	r2,388
 182d1c0:	1096c404 	addi	r2,r2,23312
 182d1c4:	e0fffc17 	ldw	r3,-16(fp)
 182d1c8:	18c01224 	muli	r3,r3,72
 182d1cc:	10c5883a 	add	r2,r2,r3
 182d1d0:	10800384 	addi	r2,r2,14
 182d1d4:	e0ffff03 	ldbu	r3,-4(fp)
 182d1d8:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 182d1dc:	e0bffc17 	ldw	r2,-16(fp)
 182d1e0:	10800044 	addi	r2,r2,1
 182d1e4:	e0bffc15 	stw	r2,-16(fp)
 182d1e8:	d0a01d03 	ldbu	r2,-32652(gp)
 182d1ec:	10803fcc 	andi	r2,r2,255
 182d1f0:	e0fffc17 	ldw	r3,-16(fp)
 182d1f4:	18bfcf16 	blt	r3,r2,182d134 <__ram_exceptions_end+0xff81ccf0>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 182d1f8:	e0bffb17 	ldw	r2,-20(fp)
 182d1fc:	10800044 	addi	r2,r2,1
 182d200:	e0bffb15 	stw	r2,-20(fp)
 182d204:	e0bfff03 	ldbu	r2,-4(fp)
 182d208:	e0fffb17 	ldw	r3,-20(fp)
 182d20c:	18bfb516 	blt	r3,r2,182d0e4 <__ram_exceptions_end+0xff81cca0>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 182d210:	0005883a 	mov	r2,zero
}
 182d214:	e037883a 	mov	sp,fp
 182d218:	dfc00117 	ldw	ra,4(sp)
 182d21c:	df000017 	ldw	fp,0(sp)
 182d220:	dec00204 	addi	sp,sp,8
 182d224:	f800283a 	ret

0182d228 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 182d228:	defffc04 	addi	sp,sp,-16
 182d22c:	dfc00315 	stw	ra,12(sp)
 182d230:	df000215 	stw	fp,8(sp)
 182d234:	df000204 	addi	fp,sp,8
 182d238:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 182d23c:	e13fff17 	ldw	r4,-4(fp)
 182d240:	182d4100 	call	182d410 <alt_tse_get_mac_info>
 182d244:	10800317 	ldw	r2,12(r2)
 182d248:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 182d24c:	e13ffe17 	ldw	r4,-8(fp)
 182d250:	18305d00 	call	18305d0 <alt_tse_phy_get_common_speed>
}
 182d254:	e037883a 	mov	sp,fp
 182d258:	dfc00117 	ldw	ra,4(sp)
 182d25c:	df000017 	ldw	fp,0(sp)
 182d260:	dec00204 	addi	sp,sp,8
 182d264:	f800283a 	ret

0182d268 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 182d268:	defffb04 	addi	sp,sp,-20
 182d26c:	dfc00415 	stw	ra,16(sp)
 182d270:	df000315 	stw	fp,12(sp)
 182d274:	df000304 	addi	fp,sp,12
 182d278:	e13ffe15 	stw	r4,-8(fp)
 182d27c:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 182d280:	e13ffe17 	ldw	r4,-8(fp)
 182d284:	182d4100 	call	182d410 <alt_tse_get_mac_info>
 182d288:	10800317 	ldw	r2,12(r2)
 182d28c:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 182d290:	e17fff17 	ldw	r5,-4(fp)
 182d294:	e13ffd17 	ldw	r4,-12(fp)
 182d298:	18308f80 	call	18308f8 <alt_tse_phy_set_common_speed>
}
 182d29c:	e037883a 	mov	sp,fp
 182d2a0:	dfc00117 	ldw	ra,4(sp)
 182d2a4:	df000017 	ldw	fp,0(sp)
 182d2a8:	dec00204 	addi	sp,sp,8
 182d2ac:	f800283a 	ret

0182d2b0 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 182d2b0:	defffd04 	addi	sp,sp,-12
 182d2b4:	df000215 	stw	fp,8(sp)
 182d2b8:	df000204 	addi	fp,sp,8
 182d2bc:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 182d2c0:	e03ffe15 	stw	zero,-8(fp)
 182d2c4:	00000c06 	br	182d2f8 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 182d2c8:	e0bffe17 	ldw	r2,-8(fp)
 182d2cc:	10c01224 	muli	r3,r2,72
 182d2d0:	00806134 	movhi	r2,388
 182d2d4:	1096c404 	addi	r2,r2,23312
 182d2d8:	1887883a 	add	r3,r3,r2
 182d2dc:	e0bfff17 	ldw	r2,-4(fp)
 182d2e0:	1880021e 	bne	r3,r2,182d2ec <alt_tse_get_system_index+0x3c>
            return i;
 182d2e4:	e0bffe17 	ldw	r2,-8(fp)
 182d2e8:	00000806 	br	182d30c <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 182d2ec:	e0bffe17 	ldw	r2,-8(fp)
 182d2f0:	10800044 	addi	r2,r2,1
 182d2f4:	e0bffe15 	stw	r2,-8(fp)
 182d2f8:	d0a01d03 	ldbu	r2,-32652(gp)
 182d2fc:	10803fcc 	andi	r2,r2,255
 182d300:	e0fffe17 	ldw	r3,-8(fp)
 182d304:	18bff016 	blt	r3,r2,182d2c8 <__ram_exceptions_end+0xff81ce84>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 182d308:	00bfffc4 	movi	r2,-1
}
 182d30c:	e037883a 	mov	sp,fp
 182d310:	df000017 	ldw	fp,0(sp)
 182d314:	dec00104 	addi	sp,sp,4
 182d318:	f800283a 	ret

0182d31c <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 182d31c:	defffd04 	addi	sp,sp,-12
 182d320:	df000215 	stw	fp,8(sp)
 182d324:	df000204 	addi	fp,sp,8
 182d328:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 182d32c:	e03ffe15 	stw	zero,-8(fp)
 182d330:	00000e06 	br	182d36c <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 182d334:	008061f4 	movhi	r2,391
 182d338:	10aab104 	addi	r2,r2,-21820
 182d33c:	e0fffe17 	ldw	r3,-8(fp)
 182d340:	18c7883a 	add	r3,r3,r3
 182d344:	18c7883a 	add	r3,r3,r3
 182d348:	10c5883a 	add	r2,r2,r3
 182d34c:	10c00017 	ldw	r3,0(r2)
 182d350:	e0bfff17 	ldw	r2,-4(fp)
 182d354:	1880021e 	bne	r3,r2,182d360 <alt_tse_get_mac_group_index+0x44>
            return i;
 182d358:	e0bffe17 	ldw	r2,-8(fp)
 182d35c:	00000806 	br	182d380 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 182d360:	e0bffe17 	ldw	r2,-8(fp)
 182d364:	10800044 	addi	r2,r2,1
 182d368:	e0bffe15 	stw	r2,-8(fp)
 182d36c:	d0a81043 	ldbu	r2,-24511(gp)
 182d370:	10803fcc 	andi	r2,r2,255
 182d374:	e0fffe17 	ldw	r3,-8(fp)
 182d378:	18bfee16 	blt	r3,r2,182d334 <__ram_exceptions_end+0xff81cef0>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 182d37c:	00bfffc4 	movi	r2,-1
}
 182d380:	e037883a 	mov	sp,fp
 182d384:	df000017 	ldw	fp,0(sp)
 182d388:	dec00104 	addi	sp,sp,4
 182d38c:	f800283a 	ret

0182d390 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 182d390:	defffd04 	addi	sp,sp,-12
 182d394:	df000215 	stw	fp,8(sp)
 182d398:	df000204 	addi	fp,sp,8
 182d39c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 182d3a0:	e03ffe15 	stw	zero,-8(fp)
 182d3a4:	00000f06 	br	182d3e4 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 182d3a8:	e0bfff17 	ldw	r2,-4(fp)
 182d3ac:	10c00317 	ldw	r3,12(r2)
 182d3b0:	e0bffe17 	ldw	r2,-8(fp)
 182d3b4:	10800044 	addi	r2,r2,1
 182d3b8:	1085883a 	add	r2,r2,r2
 182d3bc:	1085883a 	add	r2,r2,r2
 182d3c0:	1885883a 	add	r2,r3,r2
 182d3c4:	10c00017 	ldw	r3,0(r2)
 182d3c8:	e0bfff17 	ldw	r2,-4(fp)
 182d3cc:	1880021e 	bne	r3,r2,182d3d8 <alt_tse_get_mac_info_index+0x48>
            return i;
 182d3d0:	e0bffe17 	ldw	r2,-8(fp)
 182d3d4:	00000a06 	br	182d400 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 182d3d8:	e0bffe17 	ldw	r2,-8(fp)
 182d3dc:	10800044 	addi	r2,r2,1
 182d3e0:	e0bffe15 	stw	r2,-8(fp)
 182d3e4:	e0bfff17 	ldw	r2,-4(fp)
 182d3e8:	10800317 	ldw	r2,12(r2)
 182d3ec:	10800003 	ldbu	r2,0(r2)
 182d3f0:	10803fcc 	andi	r2,r2,255
 182d3f4:	e0fffe17 	ldw	r3,-8(fp)
 182d3f8:	18bfeb16 	blt	r3,r2,182d3a8 <__ram_exceptions_end+0xff81cf64>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 182d3fc:	00bfffc4 	movi	r2,-1
}
 182d400:	e037883a 	mov	sp,fp
 182d404:	df000017 	ldw	fp,0(sp)
 182d408:	dec00104 	addi	sp,sp,4
 182d40c:	f800283a 	ret

0182d410 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 182d410:	defffa04 	addi	sp,sp,-24
 182d414:	df000515 	stw	fp,20(sp)
 182d418:	df000504 	addi	fp,sp,20
 182d41c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 182d420:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 182d424:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 182d428:	e03ffb15 	stw	zero,-20(fp)
 182d42c:	00002506 	br	182d4c4 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 182d430:	008061f4 	movhi	r2,391
 182d434:	10aab104 	addi	r2,r2,-21820
 182d438:	e0fffb17 	ldw	r3,-20(fp)
 182d43c:	18c7883a 	add	r3,r3,r3
 182d440:	18c7883a 	add	r3,r3,r3
 182d444:	10c5883a 	add	r2,r2,r3
 182d448:	10800017 	ldw	r2,0(r2)
 182d44c:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 182d450:	e03ffc15 	stw	zero,-16(fp)
 182d454:	00001306 	br	182d4a4 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 182d458:	e0fffd17 	ldw	r3,-12(fp)
 182d45c:	e0bffc17 	ldw	r2,-16(fp)
 182d460:	10800044 	addi	r2,r2,1
 182d464:	1085883a 	add	r2,r2,r2
 182d468:	1085883a 	add	r2,r2,r2
 182d46c:	1885883a 	add	r2,r3,r2
 182d470:	10800017 	ldw	r2,0(r2)
 182d474:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 182d478:	e0bffe17 	ldw	r2,-8(fp)
 182d47c:	10800217 	ldw	r2,8(r2)
 182d480:	10800017 	ldw	r2,0(r2)
 182d484:	1007883a 	mov	r3,r2
 182d488:	e0bfff17 	ldw	r2,-4(fp)
 182d48c:	1880021e 	bne	r3,r2,182d498 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 182d490:	e0bffe17 	ldw	r2,-8(fp)
 182d494:	00001006 	br	182d4d8 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 182d498:	e0bffc17 	ldw	r2,-16(fp)
 182d49c:	10800044 	addi	r2,r2,1
 182d4a0:	e0bffc15 	stw	r2,-16(fp)
 182d4a4:	e0bffd17 	ldw	r2,-12(fp)
 182d4a8:	10800003 	ldbu	r2,0(r2)
 182d4ac:	10803fcc 	andi	r2,r2,255
 182d4b0:	e0fffc17 	ldw	r3,-16(fp)
 182d4b4:	18bfe816 	blt	r3,r2,182d458 <__ram_exceptions_end+0xff81d014>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 182d4b8:	e0bffb17 	ldw	r2,-20(fp)
 182d4bc:	10800044 	addi	r2,r2,1
 182d4c0:	e0bffb15 	stw	r2,-20(fp)
 182d4c4:	d0a81043 	ldbu	r2,-24511(gp)
 182d4c8:	10803fcc 	andi	r2,r2,255
 182d4cc:	e0fffb17 	ldw	r3,-20(fp)
 182d4d0:	18bfd716 	blt	r3,r2,182d430 <__ram_exceptions_end+0xff81cfec>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 182d4d4:	0005883a 	mov	r2,zero
}
 182d4d8:	e037883a 	mov	sp,fp
 182d4dc:	df000017 	ldw	fp,0(sp)
 182d4e0:	dec00104 	addi	sp,sp,4
 182d4e4:	f800283a 	ret

0182d4e8 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 182d4e8:	defffc04 	addi	sp,sp,-16
 182d4ec:	df000315 	stw	fp,12(sp)
 182d4f0:	df000304 	addi	fp,sp,12
 182d4f4:	e13ffe15 	stw	r4,-8(fp)
 182d4f8:	2805883a 	mov	r2,r5
 182d4fc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 182d500:	e0bffe17 	ldw	r2,-8(fp)
 182d504:	10800204 	addi	r2,r2,8
 182d508:	10800037 	ldwio	r2,0(r2)
 182d50c:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 182d510:	e0bfff03 	ldbu	r2,-4(fp)
 182d514:	10800098 	cmpnei	r2,r2,2
 182d518:	1000091e 	bne	r2,zero,182d540 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 182d51c:	e0bffd17 	ldw	r2,-12(fp)
 182d520:	10800214 	ori	r2,r2,8
 182d524:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 182d528:	e0fffd17 	ldw	r3,-12(fp)
 182d52c:	00bf8034 	movhi	r2,65024
 182d530:	10bfffc4 	addi	r2,r2,-1
 182d534:	1884703a 	and	r2,r3,r2
 182d538:	e0bffd15 	stw	r2,-12(fp)
 182d53c:	00001906 	br	182d5a4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 182d540:	e0bfff03 	ldbu	r2,-4(fp)
 182d544:	10800058 	cmpnei	r2,r2,1
 182d548:	10000a1e 	bne	r2,zero,182d574 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 182d54c:	e0fffd17 	ldw	r3,-12(fp)
 182d550:	00bffdc4 	movi	r2,-9
 182d554:	1884703a 	and	r2,r3,r2
 182d558:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 182d55c:	e0fffd17 	ldw	r3,-12(fp)
 182d560:	00bf8034 	movhi	r2,65024
 182d564:	10bfffc4 	addi	r2,r2,-1
 182d568:	1884703a 	and	r2,r3,r2
 182d56c:	e0bffd15 	stw	r2,-12(fp)
 182d570:	00000c06 	br	182d5a4 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 182d574:	e0bfff03 	ldbu	r2,-4(fp)
 182d578:	1000081e 	bne	r2,zero,182d59c <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 182d57c:	e0fffd17 	ldw	r3,-12(fp)
 182d580:	00bffdc4 	movi	r2,-9
 182d584:	1884703a 	and	r2,r3,r2
 182d588:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 182d58c:	e0bffd17 	ldw	r2,-12(fp)
 182d590:	10808034 	orhi	r2,r2,512
 182d594:	e0bffd15 	stw	r2,-12(fp)
 182d598:	00000206 	br	182d5a4 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 182d59c:	00bffd84 	movi	r2,-10
 182d5a0:	00000506 	br	182d5b8 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 182d5a4:	e0bffe17 	ldw	r2,-8(fp)
 182d5a8:	10800204 	addi	r2,r2,8
 182d5ac:	e0fffd17 	ldw	r3,-12(fp)
 182d5b0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 182d5b4:	0005883a 	mov	r2,zero
}
 182d5b8:	e037883a 	mov	sp,fp
 182d5bc:	df000017 	ldw	fp,0(sp)
 182d5c0:	dec00104 	addi	sp,sp,4
 182d5c4:	f800283a 	ret

0182d5c8 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 182d5c8:	defffc04 	addi	sp,sp,-16
 182d5cc:	df000315 	stw	fp,12(sp)
 182d5d0:	df000304 	addi	fp,sp,12
 182d5d4:	e13ffe15 	stw	r4,-8(fp)
 182d5d8:	2805883a 	mov	r2,r5
 182d5dc:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 182d5e0:	e0bffe17 	ldw	r2,-8(fp)
 182d5e4:	10800204 	addi	r2,r2,8
 182d5e8:	10800037 	ldwio	r2,0(r2)
 182d5ec:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 182d5f0:	e0bfff03 	ldbu	r2,-4(fp)
 182d5f4:	1000041e 	bne	r2,zero,182d608 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 182d5f8:	e0bffd17 	ldw	r2,-12(fp)
 182d5fc:	10810014 	ori	r2,r2,1024
 182d600:	e0bffd15 	stw	r2,-12(fp)
 182d604:	00000a06 	br	182d630 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 182d608:	e0bfff03 	ldbu	r2,-4(fp)
 182d60c:	10800058 	cmpnei	r2,r2,1
 182d610:	1000051e 	bne	r2,zero,182d628 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 182d614:	e0fffd17 	ldw	r3,-12(fp)
 182d618:	00beffc4 	movi	r2,-1025
 182d61c:	1884703a 	and	r2,r3,r2
 182d620:	e0bffd15 	stw	r2,-12(fp)
 182d624:	00000206 	br	182d630 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 182d628:	00bffd84 	movi	r2,-10
 182d62c:	00000506 	br	182d644 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 182d630:	e0bffe17 	ldw	r2,-8(fp)
 182d634:	10800204 	addi	r2,r2,8
 182d638:	e0fffd17 	ldw	r3,-12(fp)
 182d63c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 182d640:	0005883a 	mov	r2,zero

}
 182d644:	e037883a 	mov	sp,fp
 182d648:	df000017 	ldw	fp,0(sp)
 182d64c:	dec00104 	addi	sp,sp,4
 182d650:	f800283a 	ret

0182d654 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 182d654:	defff404 	addi	sp,sp,-48
 182d658:	dfc00b15 	stw	ra,44(sp)
 182d65c:	df000a15 	stw	fp,40(sp)
 182d660:	df000a04 	addi	fp,sp,40
 182d664:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182d668:	00800044 	movi	r2,1
 182d66c:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 182d670:	00800044 	movi	r2,1
 182d674:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 182d678:	e0bff743 	ldbu	r2,-35(fp)
 182d67c:	10c0004c 	andi	r3,r2,1
 182d680:	e0bff703 	ldbu	r2,-36(fp)
 182d684:	10800098 	cmpnei	r2,r2,2
 182d688:	1000021e 	bne	r2,zero,182d694 <getPHYSpeed+0x40>
 182d68c:	00800084 	movi	r2,2
 182d690:	00000106 	br	182d698 <getPHYSpeed+0x44>
 182d694:	0005883a 	mov	r2,zero
 182d698:	1886b03a 	or	r3,r3,r2
 182d69c:	e0bff703 	ldbu	r2,-36(fp)
 182d6a0:	10800058 	cmpnei	r2,r2,1
 182d6a4:	1000021e 	bne	r2,zero,182d6b0 <getPHYSpeed+0x5c>
 182d6a8:	00800104 	movi	r2,4
 182d6ac:	00000106 	br	182d6b4 <getPHYSpeed+0x60>
 182d6b0:	0005883a 	mov	r2,zero
 182d6b4:	1886b03a 	or	r3,r3,r2
 182d6b8:	e0bff703 	ldbu	r2,-36(fp)
 182d6bc:	1000021e 	bne	r2,zero,182d6c8 <getPHYSpeed+0x74>
 182d6c0:	00800204 	movi	r2,8
 182d6c4:	00000106 	br	182d6cc <getPHYSpeed+0x78>
 182d6c8:	0005883a 	mov	r2,zero
 182d6cc:	1886b03a 	or	r3,r3,r2
 182d6d0:	e0bff703 	ldbu	r2,-36(fp)
 182d6d4:	108000d8 	cmpnei	r2,r2,3
 182d6d8:	1000021e 	bne	r2,zero,182d6e4 <getPHYSpeed+0x90>
 182d6dc:	00800074 	movhi	r2,1
 182d6e0:	00000106 	br	182d6e8 <getPHYSpeed+0x94>
 182d6e4:	0005883a 	mov	r2,zero
 182d6e8:	1884b03a 	or	r2,r3,r2
 182d6ec:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 182d6f0:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 182d6f4:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 182d6f8:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 182d6fc:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 182d700:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 182d704:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 182d708:	d0a810c3 	ldbu	r2,-24509(gp)
 182d70c:	10803fcc 	andi	r2,r2,255
 182d710:	1000031e 	bne	r2,zero,182d720 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 182d714:	182f6480 	call	182f648 <alt_tse_phy_init>
        is_init = 1;
 182d718:	00800044 	movi	r2,1
 182d71c:	d0a810c5 	stb	r2,-24509(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 182d720:	e13fff17 	ldw	r4,-4(fp)
 182d724:	182d4100 	call	182d410 <alt_tse_get_mac_info>
 182d728:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 182d72c:	e0bffa17 	ldw	r2,-24(fp)
 182d730:	1000481e 	bne	r2,zero,182d854 <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182d734:	00800044 	movi	r2,1
 182d738:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182d73c:	00800044 	movi	r2,1
 182d740:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 182d744:	e0bff743 	ldbu	r2,-35(fp)
 182d748:	10c0004c 	andi	r3,r2,1
 182d74c:	e0bff703 	ldbu	r2,-36(fp)
 182d750:	10800098 	cmpnei	r2,r2,2
 182d754:	1000021e 	bne	r2,zero,182d760 <getPHYSpeed+0x10c>
 182d758:	00800084 	movi	r2,2
 182d75c:	00000106 	br	182d764 <getPHYSpeed+0x110>
 182d760:	0005883a 	mov	r2,zero
 182d764:	1886b03a 	or	r3,r3,r2
 182d768:	e0bff703 	ldbu	r2,-36(fp)
 182d76c:	10800058 	cmpnei	r2,r2,1
 182d770:	1000021e 	bne	r2,zero,182d77c <getPHYSpeed+0x128>
 182d774:	00800104 	movi	r2,4
 182d778:	00000106 	br	182d780 <getPHYSpeed+0x12c>
 182d77c:	0005883a 	mov	r2,zero
 182d780:	1886b03a 	or	r3,r3,r2
 182d784:	e0bff703 	ldbu	r2,-36(fp)
 182d788:	1000021e 	bne	r2,zero,182d794 <getPHYSpeed+0x140>
 182d78c:	00800204 	movi	r2,8
 182d790:	00000106 	br	182d798 <getPHYSpeed+0x144>
 182d794:	0005883a 	mov	r2,zero
 182d798:	1886b03a 	or	r3,r3,r2
 182d79c:	e0bff703 	ldbu	r2,-36(fp)
 182d7a0:	108000d8 	cmpnei	r2,r2,3
 182d7a4:	1000021e 	bne	r2,zero,182d7b0 <getPHYSpeed+0x15c>
 182d7a8:	00800074 	movhi	r2,1
 182d7ac:	00000106 	br	182d7b4 <getPHYSpeed+0x160>
 182d7b0:	0005883a 	mov	r2,zero
 182d7b4:	1884b03a 	or	r2,r3,r2
 182d7b8:	10802034 	orhi	r2,r2,128
 182d7bc:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 182d7c0:	e0bff703 	ldbu	r2,-36(fp)
 182d7c4:	108000a0 	cmpeqi	r2,r2,2
 182d7c8:	10000e1e 	bne	r2,zero,182d804 <getPHYSpeed+0x1b0>
 182d7cc:	e0bff703 	ldbu	r2,-36(fp)
 182d7d0:	10800060 	cmpeqi	r2,r2,1
 182d7d4:	1000081e 	bne	r2,zero,182d7f8 <getPHYSpeed+0x1a4>
 182d7d8:	e0bff703 	ldbu	r2,-36(fp)
 182d7dc:	1000031e 	bne	r2,zero,182d7ec <getPHYSpeed+0x198>
 182d7e0:	00806134 	movhi	r2,388
 182d7e4:	1088ab04 	addi	r2,r2,8876
 182d7e8:	00000806 	br	182d80c <getPHYSpeed+0x1b8>
 182d7ec:	00806134 	movhi	r2,388
 182d7f0:	1088ac04 	addi	r2,r2,8880
 182d7f4:	00000506 	br	182d80c <getPHYSpeed+0x1b8>
 182d7f8:	00806134 	movhi	r2,388
 182d7fc:	1088ae04 	addi	r2,r2,8888
 182d800:	00000206 	br	182d80c <getPHYSpeed+0x1b8>
 182d804:	00806134 	movhi	r2,388
 182d808:	1088af04 	addi	r2,r2,8892
 182d80c:	e0fff743 	ldbu	r3,-35(fp)
 182d810:	18c00058 	cmpnei	r3,r3,1
 182d814:	1800031e 	bne	r3,zero,182d824 <getPHYSpeed+0x1d0>
 182d818:	00c06134 	movhi	r3,388
 182d81c:	18c8b104 	addi	r3,r3,8900
 182d820:	00000206 	br	182d82c <getPHYSpeed+0x1d8>
 182d824:	00c06134 	movhi	r3,388
 182d828:	18c8b304 	addi	r3,r3,8908
 182d82c:	180d883a 	mov	r6,r3
 182d830:	100b883a 	mov	r5,r2
 182d834:	01006134 	movhi	r4,388
 182d838:	2108b504 	addi	r4,r4,8916
 182d83c:	1800c180 	call	1800c18 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 182d840:	01006134 	movhi	r4,388
 182d844:	2108cd04 	addi	r4,r4,9012
 182d848:	183d2fc0 	call	183d2fc <puts>
        return result;
 182d84c:	e0bff817 	ldw	r2,-32(fp)
 182d850:	00021a06 	br	182e0bc <getPHYSpeed+0xa68>
    }
    
    pphy = pmac_info->pphy_info;
 182d854:	e0bffa17 	ldw	r2,-24(fp)
 182d858:	10800117 	ldw	r2,4(r2)
 182d85c:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 182d860:	e0bffa17 	ldw	r2,-24(fp)
 182d864:	10800317 	ldw	r2,12(r2)
 182d868:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 182d86c:	e0bffa17 	ldw	r2,-24(fp)
 182d870:	10800217 	ldw	r2,8(r2)
 182d874:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182d878:	e13ffa17 	ldw	r4,-24(fp)
 182d87c:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182d880:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 182d884:	e13ffb17 	ldw	r4,-20(fp)
 182d888:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182d88c:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 182d890:	e0bffb17 	ldw	r2,-20(fp)
 182d894:	10800117 	ldw	r2,4(r2)
 182d898:	10800217 	ldw	r2,8(r2)
 182d89c:	10800203 	ldbu	r2,8(r2)
 182d8a0:	10803fcc 	andi	r2,r2,255
 182d8a4:	10005a1e 	bne	r2,zero,182da10 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182d8a8:	00800044 	movi	r2,1
 182d8ac:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182d8b0:	00800044 	movi	r2,1
 182d8b4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 182d8b8:	e0bff743 	ldbu	r2,-35(fp)
 182d8bc:	10c0004c 	andi	r3,r2,1
 182d8c0:	e0bff703 	ldbu	r2,-36(fp)
 182d8c4:	10800098 	cmpnei	r2,r2,2
 182d8c8:	1000021e 	bne	r2,zero,182d8d4 <getPHYSpeed+0x280>
 182d8cc:	00800084 	movi	r2,2
 182d8d0:	00000106 	br	182d8d8 <getPHYSpeed+0x284>
 182d8d4:	0005883a 	mov	r2,zero
 182d8d8:	1886b03a 	or	r3,r3,r2
 182d8dc:	e0bff703 	ldbu	r2,-36(fp)
 182d8e0:	10800058 	cmpnei	r2,r2,1
 182d8e4:	1000021e 	bne	r2,zero,182d8f0 <getPHYSpeed+0x29c>
 182d8e8:	00800104 	movi	r2,4
 182d8ec:	00000106 	br	182d8f4 <getPHYSpeed+0x2a0>
 182d8f0:	0005883a 	mov	r2,zero
 182d8f4:	1886b03a 	or	r3,r3,r2
 182d8f8:	e0bff703 	ldbu	r2,-36(fp)
 182d8fc:	1000021e 	bne	r2,zero,182d908 <getPHYSpeed+0x2b4>
 182d900:	00800204 	movi	r2,8
 182d904:	00000106 	br	182d90c <getPHYSpeed+0x2b8>
 182d908:	0005883a 	mov	r2,zero
 182d90c:	1886b03a 	or	r3,r3,r2
 182d910:	e0bff703 	ldbu	r2,-36(fp)
 182d914:	108000d8 	cmpnei	r2,r2,3
 182d918:	1000021e 	bne	r2,zero,182d924 <getPHYSpeed+0x2d0>
 182d91c:	00800074 	movhi	r2,1
 182d920:	00000106 	br	182d928 <getPHYSpeed+0x2d4>
 182d924:	0005883a 	mov	r2,zero
 182d928:	1884b03a 	or	r2,r3,r2
 182d92c:	10801034 	orhi	r2,r2,64
 182d930:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 182d934:	010003f4 	movhi	r4,15
 182d938:	21109004 	addi	r4,r4,16960
 182d93c:	18132900 	call	1813290 <usleep>
        if(psys->tse_phy_cfg) {
 182d940:	e0bffc17 	ldw	r2,-16(fp)
 182d944:	10801117 	ldw	r2,68(r2)
 182d948:	10000d26 	beq	r2,zero,182d980 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 182d94c:	e0bffd47 	ldb	r2,-11(fp)
 182d950:	e0fffd07 	ldb	r3,-12(fp)
 182d954:	180d883a 	mov	r6,r3
 182d958:	100b883a 	mov	r5,r2
 182d95c:	01006134 	movhi	r4,388
 182d960:	2108de04 	addi	r4,r4,9080
 182d964:	1800c180 	call	1800c18 <printf>
        	result = psys->tse_phy_cfg(pmac);
 182d968:	e0bffc17 	ldw	r2,-16(fp)
 182d96c:	10801117 	ldw	r2,68(r2)
 182d970:	e13fff17 	ldw	r4,-4(fp)
 182d974:	103ee83a 	callr	r2
 182d978:	e0bff815 	stw	r2,-32(fp)
 182d97c:	00002206 	br	182da08 <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 182d980:	e13ffd47 	ldb	r4,-11(fp)
 182d984:	e0bff703 	ldbu	r2,-36(fp)
 182d988:	108000a0 	cmpeqi	r2,r2,2
 182d98c:	10000e1e 	bne	r2,zero,182d9c8 <getPHYSpeed+0x374>
 182d990:	e0bff703 	ldbu	r2,-36(fp)
 182d994:	10800060 	cmpeqi	r2,r2,1
 182d998:	1000081e 	bne	r2,zero,182d9bc <getPHYSpeed+0x368>
 182d99c:	e0bff703 	ldbu	r2,-36(fp)
 182d9a0:	1000031e 	bne	r2,zero,182d9b0 <getPHYSpeed+0x35c>
 182d9a4:	00806134 	movhi	r2,388
 182d9a8:	1088ab04 	addi	r2,r2,8876
 182d9ac:	00000806 	br	182d9d0 <getPHYSpeed+0x37c>
 182d9b0:	00806134 	movhi	r2,388
 182d9b4:	1088ac04 	addi	r2,r2,8880
 182d9b8:	00000506 	br	182d9d0 <getPHYSpeed+0x37c>
 182d9bc:	00806134 	movhi	r2,388
 182d9c0:	1088ae04 	addi	r2,r2,8888
 182d9c4:	00000206 	br	182d9d0 <getPHYSpeed+0x37c>
 182d9c8:	00806134 	movhi	r2,388
 182d9cc:	1088af04 	addi	r2,r2,8892
 182d9d0:	e0fff743 	ldbu	r3,-35(fp)
 182d9d4:	18c00058 	cmpnei	r3,r3,1
 182d9d8:	1800031e 	bne	r3,zero,182d9e8 <getPHYSpeed+0x394>
 182d9dc:	00c06134 	movhi	r3,388
 182d9e0:	18c8b104 	addi	r3,r3,8900
 182d9e4:	00000206 	br	182d9f0 <getPHYSpeed+0x39c>
 182d9e8:	00c06134 	movhi	r3,388
 182d9ec:	18c8b304 	addi	r3,r3,8908
 182d9f0:	180f883a 	mov	r7,r3
 182d9f4:	100d883a 	mov	r6,r2
 182d9f8:	200b883a 	mov	r5,r4
 182d9fc:	01006134 	movhi	r4,388
 182da00:	2108f004 	addi	r4,r4,9152
 182da04:	1800c180 	call	1800c18 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 182da08:	e0bff817 	ldw	r2,-32(fp)
 182da0c:	0001ab06 	br	182e0bc <getPHYSpeed+0xa68>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182da10:	e0bffb17 	ldw	r2,-20(fp)
 182da14:	10800117 	ldw	r2,4(r2)
 182da18:	10800217 	ldw	r2,8(r2)
 182da1c:	10800017 	ldw	r2,0(r2)
 182da20:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 182da24:	e0bff917 	ldw	r2,-28(fp)
 182da28:	1000491e 	bne	r2,zero,182db50 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182da2c:	00800044 	movi	r2,1
 182da30:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182da34:	00800044 	movi	r2,1
 182da38:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 182da3c:	e0bff743 	ldbu	r2,-35(fp)
 182da40:	10c0004c 	andi	r3,r2,1
 182da44:	e0bff703 	ldbu	r2,-36(fp)
 182da48:	10800098 	cmpnei	r2,r2,2
 182da4c:	1000021e 	bne	r2,zero,182da58 <getPHYSpeed+0x404>
 182da50:	00800084 	movi	r2,2
 182da54:	00000106 	br	182da5c <getPHYSpeed+0x408>
 182da58:	0005883a 	mov	r2,zero
 182da5c:	1886b03a 	or	r3,r3,r2
 182da60:	e0bff703 	ldbu	r2,-36(fp)
 182da64:	10800058 	cmpnei	r2,r2,1
 182da68:	1000021e 	bne	r2,zero,182da74 <getPHYSpeed+0x420>
 182da6c:	00800104 	movi	r2,4
 182da70:	00000106 	br	182da78 <getPHYSpeed+0x424>
 182da74:	0005883a 	mov	r2,zero
 182da78:	1886b03a 	or	r3,r3,r2
 182da7c:	e0bff703 	ldbu	r2,-36(fp)
 182da80:	1000021e 	bne	r2,zero,182da8c <getPHYSpeed+0x438>
 182da84:	00800204 	movi	r2,8
 182da88:	00000106 	br	182da90 <getPHYSpeed+0x43c>
 182da8c:	0005883a 	mov	r2,zero
 182da90:	1886b03a 	or	r3,r3,r2
 182da94:	e0bff703 	ldbu	r2,-36(fp)
 182da98:	108000d8 	cmpnei	r2,r2,3
 182da9c:	1000021e 	bne	r2,zero,182daa8 <getPHYSpeed+0x454>
 182daa0:	00800074 	movhi	r2,1
 182daa4:	00000106 	br	182daac <getPHYSpeed+0x458>
 182daa8:	0005883a 	mov	r2,zero
 182daac:	1884b03a 	or	r2,r3,r2
 182dab0:	10800834 	orhi	r2,r2,32
 182dab4:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 182dab8:	e13ffd47 	ldb	r4,-11(fp)
 182dabc:	e17ffd07 	ldb	r5,-12(fp)
 182dac0:	e0bff703 	ldbu	r2,-36(fp)
 182dac4:	108000a0 	cmpeqi	r2,r2,2
 182dac8:	10000e1e 	bne	r2,zero,182db04 <getPHYSpeed+0x4b0>
 182dacc:	e0bff703 	ldbu	r2,-36(fp)
 182dad0:	10800060 	cmpeqi	r2,r2,1
 182dad4:	1000081e 	bne	r2,zero,182daf8 <getPHYSpeed+0x4a4>
 182dad8:	e0bff703 	ldbu	r2,-36(fp)
 182dadc:	1000031e 	bne	r2,zero,182daec <getPHYSpeed+0x498>
 182dae0:	00806134 	movhi	r2,388
 182dae4:	1088ab04 	addi	r2,r2,8876
 182dae8:	00000806 	br	182db0c <getPHYSpeed+0x4b8>
 182daec:	00806134 	movhi	r2,388
 182daf0:	1088ac04 	addi	r2,r2,8880
 182daf4:	00000506 	br	182db0c <getPHYSpeed+0x4b8>
 182daf8:	00806134 	movhi	r2,388
 182dafc:	1088ae04 	addi	r2,r2,8888
 182db00:	00000206 	br	182db0c <getPHYSpeed+0x4b8>
 182db04:	00806134 	movhi	r2,388
 182db08:	1088af04 	addi	r2,r2,8892
 182db0c:	e0fff743 	ldbu	r3,-35(fp)
 182db10:	18c00058 	cmpnei	r3,r3,1
 182db14:	1800031e 	bne	r3,zero,182db24 <getPHYSpeed+0x4d0>
 182db18:	00c06134 	movhi	r3,388
 182db1c:	18c8b104 	addi	r3,r3,8900
 182db20:	00000206 	br	182db2c <getPHYSpeed+0x4d8>
 182db24:	00c06134 	movhi	r3,388
 182db28:	18c8b304 	addi	r3,r3,8908
 182db2c:	d8c00015 	stw	r3,0(sp)
 182db30:	100f883a 	mov	r7,r2
 182db34:	280d883a 	mov	r6,r5
 182db38:	200b883a 	mov	r5,r4
 182db3c:	01006134 	movhi	r4,388
 182db40:	21090204 	addi	r4,r4,9224
 182db44:	1800c180 	call	1800c18 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 182db48:	e0bff817 	ldw	r2,-32(fp)
 182db4c:	00015b06 	br	182e0bc <getPHYSpeed+0xa68>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 182db50:	e0bffa17 	ldw	r2,-24(fp)
 182db54:	10800003 	ldbu	r2,0(r2)
 182db58:	10803fcc 	andi	r2,r2,255
 182db5c:	10800058 	cmpnei	r2,r2,1
 182db60:	1000071e 	bne	r2,zero,182db80 <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
 182db64:	000b883a 	mov	r5,zero
 182db68:	e13ff917 	ldw	r4,-28(fp)
 182db6c:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 182db70:	017e0034 	movhi	r5,63488
 182db74:	e13ff917 	ldw	r4,-28(fp)
 182db78:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
 182db7c:	00000e06 	br	182dbb8 <getPHYSpeed+0x564>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 182db80:	e0bffa17 	ldw	r2,-24(fp)
 182db84:	10800003 	ldbu	r2,0(r2)
 182db88:	10803fcc 	andi	r2,r2,255
 182db8c:	10800098 	cmpnei	r2,r2,2
 182db90:	1000091e 	bne	r2,zero,182dbb8 <getPHYSpeed+0x564>
			alt_tse_phy_set_adv_100(pphy, 0);
 182db94:	000b883a 	mov	r5,zero
 182db98:	e13ff917 	ldw	r4,-28(fp)
 182db9c:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 182dba0:	000b883a 	mov	r5,zero
 182dba4:	e13ff917 	ldw	r4,-28(fp)
 182dba8:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 182dbac:	017e0034 	movhi	r5,63488
 182dbb0:	e13ff917 	ldw	r4,-28(fp)
 182dbb4:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 182dbb8:	017e0034 	movhi	r5,63488
 182dbbc:	e13ff917 	ldw	r4,-28(fp)
 182dbc0:	182f91c0 	call	182f91c <alt_tse_phy_check_link>
 182dbc4:	10bfffd8 	cmpnei	r2,r2,-1
 182dbc8:	1000491e 	bne	r2,zero,182dcf0 <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182dbcc:	00800044 	movi	r2,1
 182dbd0:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182dbd4:	00800044 	movi	r2,1
 182dbd8:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 182dbdc:	e0bff743 	ldbu	r2,-35(fp)
 182dbe0:	10c0004c 	andi	r3,r2,1
 182dbe4:	e0bff703 	ldbu	r2,-36(fp)
 182dbe8:	10800098 	cmpnei	r2,r2,2
 182dbec:	1000021e 	bne	r2,zero,182dbf8 <getPHYSpeed+0x5a4>
 182dbf0:	00800084 	movi	r2,2
 182dbf4:	00000106 	br	182dbfc <getPHYSpeed+0x5a8>
 182dbf8:	0005883a 	mov	r2,zero
 182dbfc:	1886b03a 	or	r3,r3,r2
 182dc00:	e0bff703 	ldbu	r2,-36(fp)
 182dc04:	10800058 	cmpnei	r2,r2,1
 182dc08:	1000021e 	bne	r2,zero,182dc14 <getPHYSpeed+0x5c0>
 182dc0c:	00800104 	movi	r2,4
 182dc10:	00000106 	br	182dc18 <getPHYSpeed+0x5c4>
 182dc14:	0005883a 	mov	r2,zero
 182dc18:	1886b03a 	or	r3,r3,r2
 182dc1c:	e0bff703 	ldbu	r2,-36(fp)
 182dc20:	1000021e 	bne	r2,zero,182dc2c <getPHYSpeed+0x5d8>
 182dc24:	00800204 	movi	r2,8
 182dc28:	00000106 	br	182dc30 <getPHYSpeed+0x5dc>
 182dc2c:	0005883a 	mov	r2,zero
 182dc30:	1886b03a 	or	r3,r3,r2
 182dc34:	e0bff703 	ldbu	r2,-36(fp)
 182dc38:	108000d8 	cmpnei	r2,r2,3
 182dc3c:	1000021e 	bne	r2,zero,182dc48 <getPHYSpeed+0x5f4>
 182dc40:	00800074 	movhi	r2,1
 182dc44:	00000106 	br	182dc4c <getPHYSpeed+0x5f8>
 182dc48:	0005883a 	mov	r2,zero
 182dc4c:	1884b03a 	or	r2,r3,r2
 182dc50:	10800234 	orhi	r2,r2,8
 182dc54:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 182dc58:	e13ffd47 	ldb	r4,-11(fp)
 182dc5c:	e17ffd07 	ldb	r5,-12(fp)
 182dc60:	e0bff703 	ldbu	r2,-36(fp)
 182dc64:	108000a0 	cmpeqi	r2,r2,2
 182dc68:	10000e1e 	bne	r2,zero,182dca4 <getPHYSpeed+0x650>
 182dc6c:	e0bff703 	ldbu	r2,-36(fp)
 182dc70:	10800060 	cmpeqi	r2,r2,1
 182dc74:	1000081e 	bne	r2,zero,182dc98 <getPHYSpeed+0x644>
 182dc78:	e0bff703 	ldbu	r2,-36(fp)
 182dc7c:	1000031e 	bne	r2,zero,182dc8c <getPHYSpeed+0x638>
 182dc80:	00806134 	movhi	r2,388
 182dc84:	1088ab04 	addi	r2,r2,8876
 182dc88:	00000806 	br	182dcac <getPHYSpeed+0x658>
 182dc8c:	00806134 	movhi	r2,388
 182dc90:	1088ac04 	addi	r2,r2,8880
 182dc94:	00000506 	br	182dcac <getPHYSpeed+0x658>
 182dc98:	00806134 	movhi	r2,388
 182dc9c:	1088ae04 	addi	r2,r2,8888
 182dca0:	00000206 	br	182dcac <getPHYSpeed+0x658>
 182dca4:	00806134 	movhi	r2,388
 182dca8:	1088af04 	addi	r2,r2,8892
 182dcac:	e0fff743 	ldbu	r3,-35(fp)
 182dcb0:	18c00058 	cmpnei	r3,r3,1
 182dcb4:	1800031e 	bne	r3,zero,182dcc4 <getPHYSpeed+0x670>
 182dcb8:	00c06134 	movhi	r3,388
 182dcbc:	18c8b104 	addi	r3,r3,8900
 182dcc0:	00000206 	br	182dccc <getPHYSpeed+0x678>
 182dcc4:	00c06134 	movhi	r3,388
 182dcc8:	18c8b304 	addi	r3,r3,8908
 182dccc:	d8c00015 	stw	r3,0(sp)
 182dcd0:	100f883a 	mov	r7,r2
 182dcd4:	280d883a 	mov	r6,r5
 182dcd8:	200b883a 	mov	r5,r4
 182dcdc:	01006134 	movhi	r4,388
 182dce0:	21091304 	addi	r4,r4,9292
 182dce4:	1800c180 	call	1800c18 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 182dce8:	e0bff817 	ldw	r2,-32(fp)
 182dcec:	0000f306 	br	182e0bc <getPHYSpeed+0xa68>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 182dcf0:	e0bffe17 	ldw	r2,-8(fp)
 182dcf4:	10801004 	addi	r2,r2,64
 182dcf8:	e0fff917 	ldw	r3,-28(fp)
 182dcfc:	18c00003 	ldbu	r3,0(r3)
 182dd00:	18c03fcc 	andi	r3,r3,255
 182dd04:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 182dd08:	d8000015 	stw	zero,0(sp)
 182dd0c:	01c00044 	movi	r7,1
 182dd10:	01800384 	movi	r6,14
 182dd14:	000b883a 	mov	r5,zero
 182dd18:	e13ff917 	ldw	r4,-28(fp)
 182dd1c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 182dd20:	e0bff917 	ldw	r2,-28(fp)
 182dd24:	10800517 	ldw	r2,20(r2)
 182dd28:	10002b1e 	bne	r2,zero,182ddd8 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 182dd2c:	e0bffd47 	ldb	r2,-11(fp)
 182dd30:	e0fffd07 	ldb	r3,-12(fp)
 182dd34:	180d883a 	mov	r6,r3
 182dd38:	100b883a 	mov	r5,r2
 182dd3c:	01006134 	movhi	r4,388
 182dd40:	21092704 	addi	r4,r4,9372
 182dd44:	1800c180 	call	1800c18 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182dd48:	00800044 	movi	r2,1
 182dd4c:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182dd50:	00800044 	movi	r2,1
 182dd54:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 182dd58:	e0bff743 	ldbu	r2,-35(fp)
 182dd5c:	10c0004c 	andi	r3,r2,1
 182dd60:	e0bff703 	ldbu	r2,-36(fp)
 182dd64:	10800098 	cmpnei	r2,r2,2
 182dd68:	1000021e 	bne	r2,zero,182dd74 <getPHYSpeed+0x720>
 182dd6c:	00800084 	movi	r2,2
 182dd70:	00000106 	br	182dd78 <getPHYSpeed+0x724>
 182dd74:	0005883a 	mov	r2,zero
 182dd78:	1886b03a 	or	r3,r3,r2
 182dd7c:	e0bff703 	ldbu	r2,-36(fp)
 182dd80:	10800058 	cmpnei	r2,r2,1
 182dd84:	1000021e 	bne	r2,zero,182dd90 <getPHYSpeed+0x73c>
 182dd88:	00800104 	movi	r2,4
 182dd8c:	00000106 	br	182dd94 <getPHYSpeed+0x740>
 182dd90:	0005883a 	mov	r2,zero
 182dd94:	1886b03a 	or	r3,r3,r2
 182dd98:	e0bff703 	ldbu	r2,-36(fp)
 182dd9c:	1000021e 	bne	r2,zero,182dda8 <getPHYSpeed+0x754>
 182dda0:	00800204 	movi	r2,8
 182dda4:	00000106 	br	182ddac <getPHYSpeed+0x758>
 182dda8:	0005883a 	mov	r2,zero
 182ddac:	1886b03a 	or	r3,r3,r2
 182ddb0:	e0bff703 	ldbu	r2,-36(fp)
 182ddb4:	108000d8 	cmpnei	r2,r2,3
 182ddb8:	1000021e 	bne	r2,zero,182ddc4 <getPHYSpeed+0x770>
 182ddbc:	00800074 	movhi	r2,1
 182ddc0:	00000106 	br	182ddc8 <getPHYSpeed+0x774>
 182ddc4:	0005883a 	mov	r2,zero
 182ddc8:	1884b03a 	or	r2,r3,r2
 182ddcc:	10800134 	orhi	r2,r2,4
 182ddd0:	e0bff815 	stw	r2,-32(fp)
 182ddd4:	00009406 	br	182e028 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 182ddd8:	e0bff917 	ldw	r2,-28(fp)
 182dddc:	10800517 	ldw	r2,20(r2)
 182dde0:	10801817 	ldw	r2,96(r2)
 182dde4:	10002626 	beq	r2,zero,182de80 <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 182dde8:	e0bff917 	ldw	r2,-28(fp)
 182ddec:	10800517 	ldw	r2,20(r2)
 182ddf0:	10801817 	ldw	r2,96(r2)
 182ddf4:	e13ffe17 	ldw	r4,-8(fp)
 182ddf8:	103ee83a 	callr	r2
 182ddfc:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 182de00:	e0bff817 	ldw	r2,-32(fp)
 182de04:	1080008c 	andi	r2,r2,2
 182de08:	10000c1e 	bne	r2,zero,182de3c <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 182de0c:	e0bff817 	ldw	r2,-32(fp)
 182de10:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 182de14:	1000071e 	bne	r2,zero,182de34 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 182de18:	e0bff817 	ldw	r2,-32(fp)
 182de1c:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 182de20:	10000226 	beq	r2,zero,182de2c <getPHYSpeed+0x7d8>
 182de24:	0005883a 	mov	r2,zero
 182de28:	00000506 	br	182de40 <getPHYSpeed+0x7ec>
 182de2c:	008000c4 	movi	r2,3
 182de30:	00000306 	br	182de40 <getPHYSpeed+0x7ec>
 182de34:	00800044 	movi	r2,1
 182de38:	00000106 	br	182de40 <getPHYSpeed+0x7ec>
 182de3c:	00800084 	movi	r2,2
 182de40:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 182de44:	e0bff817 	ldw	r2,-32(fp)
 182de48:	1080004c 	andi	r2,r2,1
 182de4c:	1004c03a 	cmpne	r2,r2,zero
 182de50:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 182de54:	e0bff817 	ldw	r2,-32(fp)
 182de58:	1080006c 	andhi	r2,r2,1
 182de5c:	10007226 	beq	r2,zero,182e028 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 182de60:	e0bffd47 	ldb	r2,-11(fp)
 182de64:	e0fffd07 	ldb	r3,-12(fp)
 182de68:	180d883a 	mov	r6,r3
 182de6c:	100b883a 	mov	r5,r2
 182de70:	01006134 	movhi	r4,388
 182de74:	21093504 	addi	r4,r4,9428
 182de78:	1800c180 	call	1800c18 <printf>
 182de7c:	00006a06 	br	182e028 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 182de80:	e0bff917 	ldw	r2,-28(fp)
 182de84:	10800517 	ldw	r2,20(r2)
 182de88:	10801583 	ldbu	r2,86(r2)
 182de8c:	10803fcc 	andi	r2,r2,255
 182de90:	10002b1e 	bne	r2,zero,182df40 <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 182de94:	e0bffd47 	ldb	r2,-11(fp)
 182de98:	e0fffd07 	ldb	r3,-12(fp)
 182de9c:	180d883a 	mov	r6,r3
 182dea0:	100b883a 	mov	r5,r2
 182dea4:	01006134 	movhi	r4,388
 182dea8:	21094204 	addi	r4,r4,9480
 182deac:	1800c180 	call	1800c18 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 182deb0:	00800044 	movi	r2,1
 182deb4:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 182deb8:	00800044 	movi	r2,1
 182debc:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 182dec0:	e0bff743 	ldbu	r2,-35(fp)
 182dec4:	10c0004c 	andi	r3,r2,1
 182dec8:	e0bff703 	ldbu	r2,-36(fp)
 182decc:	10800098 	cmpnei	r2,r2,2
 182ded0:	1000021e 	bne	r2,zero,182dedc <getPHYSpeed+0x888>
 182ded4:	00800084 	movi	r2,2
 182ded8:	00000106 	br	182dee0 <getPHYSpeed+0x88c>
 182dedc:	0005883a 	mov	r2,zero
 182dee0:	1886b03a 	or	r3,r3,r2
 182dee4:	e0bff703 	ldbu	r2,-36(fp)
 182dee8:	10800058 	cmpnei	r2,r2,1
 182deec:	1000021e 	bne	r2,zero,182def8 <getPHYSpeed+0x8a4>
 182def0:	00800104 	movi	r2,4
 182def4:	00000106 	br	182defc <getPHYSpeed+0x8a8>
 182def8:	0005883a 	mov	r2,zero
 182defc:	1886b03a 	or	r3,r3,r2
 182df00:	e0bff703 	ldbu	r2,-36(fp)
 182df04:	1000021e 	bne	r2,zero,182df10 <getPHYSpeed+0x8bc>
 182df08:	00800204 	movi	r2,8
 182df0c:	00000106 	br	182df14 <getPHYSpeed+0x8c0>
 182df10:	0005883a 	mov	r2,zero
 182df14:	1886b03a 	or	r3,r3,r2
 182df18:	e0bff703 	ldbu	r2,-36(fp)
 182df1c:	108000d8 	cmpnei	r2,r2,3
 182df20:	1000021e 	bne	r2,zero,182df2c <getPHYSpeed+0x8d8>
 182df24:	00800074 	movhi	r2,1
 182df28:	00000106 	br	182df30 <getPHYSpeed+0x8dc>
 182df2c:	0005883a 	mov	r2,zero
 182df30:	1884b03a 	or	r2,r3,r2
 182df34:	108000b4 	orhi	r2,r2,2
 182df38:	e0bff815 	stw	r2,-32(fp)
 182df3c:	00003a06 	br	182e028 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 182df40:	e0bff917 	ldw	r2,-28(fp)
 182df44:	10800517 	ldw	r2,20(r2)
 182df48:	10801583 	ldbu	r2,86(r2)
 182df4c:	10c03fcc 	andi	r3,r2,255
 182df50:	e0bff917 	ldw	r2,-28(fp)
 182df54:	10800517 	ldw	r2,20(r2)
 182df58:	108015c3 	ldbu	r2,87(r2)
 182df5c:	10803fcc 	andi	r2,r2,255
 182df60:	01c00084 	movi	r7,2
 182df64:	100d883a 	mov	r6,r2
 182df68:	180b883a 	mov	r5,r3
 182df6c:	e13ff917 	ldw	r4,-28(fp)
 182df70:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182df74:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 182df78:	e0bff917 	ldw	r2,-28(fp)
 182df7c:	10800517 	ldw	r2,20(r2)
 182df80:	10801583 	ldbu	r2,86(r2)
 182df84:	10c03fcc 	andi	r3,r2,255
 182df88:	e0bff917 	ldw	r2,-28(fp)
 182df8c:	10800517 	ldw	r2,20(r2)
 182df90:	10801603 	ldbu	r2,88(r2)
 182df94:	10803fcc 	andi	r2,r2,255
 182df98:	01c00044 	movi	r7,1
 182df9c:	100d883a 	mov	r6,r2
 182dfa0:	180b883a 	mov	r5,r3
 182dfa4:	e13ff917 	ldw	r4,-28(fp)
 182dfa8:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182dfac:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 182dfb0:	e0bff743 	ldbu	r2,-35(fp)
 182dfb4:	10c0004c 	andi	r3,r2,1
 182dfb8:	e0bff703 	ldbu	r2,-36(fp)
 182dfbc:	10800098 	cmpnei	r2,r2,2
 182dfc0:	1000021e 	bne	r2,zero,182dfcc <getPHYSpeed+0x978>
 182dfc4:	00800084 	movi	r2,2
 182dfc8:	00000106 	br	182dfd0 <getPHYSpeed+0x97c>
 182dfcc:	0005883a 	mov	r2,zero
 182dfd0:	1886b03a 	or	r3,r3,r2
 182dfd4:	e0bff703 	ldbu	r2,-36(fp)
 182dfd8:	10800058 	cmpnei	r2,r2,1
 182dfdc:	1000021e 	bne	r2,zero,182dfe8 <getPHYSpeed+0x994>
 182dfe0:	00800104 	movi	r2,4
 182dfe4:	00000106 	br	182dfec <getPHYSpeed+0x998>
 182dfe8:	0005883a 	mov	r2,zero
 182dfec:	1886b03a 	or	r3,r3,r2
 182dff0:	e0bff703 	ldbu	r2,-36(fp)
 182dff4:	1000021e 	bne	r2,zero,182e000 <getPHYSpeed+0x9ac>
 182dff8:	00800204 	movi	r2,8
 182dffc:	00000106 	br	182e004 <getPHYSpeed+0x9b0>
 182e000:	0005883a 	mov	r2,zero
 182e004:	1886b03a 	or	r3,r3,r2
 182e008:	e0bff703 	ldbu	r2,-36(fp)
 182e00c:	108000d8 	cmpnei	r2,r2,3
 182e010:	1000021e 	bne	r2,zero,182e01c <getPHYSpeed+0x9c8>
 182e014:	00800074 	movhi	r2,1
 182e018:	00000106 	br	182e020 <getPHYSpeed+0x9cc>
 182e01c:	0005883a 	mov	r2,zero
 182e020:	1884b03a 	or	r2,r3,r2
 182e024:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 182e028:	e13ffd47 	ldb	r4,-11(fp)
 182e02c:	e17ffd07 	ldb	r5,-12(fp)
 182e030:	e0bff703 	ldbu	r2,-36(fp)
 182e034:	108000a0 	cmpeqi	r2,r2,2
 182e038:	10000e1e 	bne	r2,zero,182e074 <getPHYSpeed+0xa20>
 182e03c:	e0bff703 	ldbu	r2,-36(fp)
 182e040:	10800060 	cmpeqi	r2,r2,1
 182e044:	1000081e 	bne	r2,zero,182e068 <getPHYSpeed+0xa14>
 182e048:	e0bff703 	ldbu	r2,-36(fp)
 182e04c:	1000031e 	bne	r2,zero,182e05c <getPHYSpeed+0xa08>
 182e050:	00806134 	movhi	r2,388
 182e054:	1088ab04 	addi	r2,r2,8876
 182e058:	00000806 	br	182e07c <getPHYSpeed+0xa28>
 182e05c:	00806134 	movhi	r2,388
 182e060:	1088ac04 	addi	r2,r2,8880
 182e064:	00000506 	br	182e07c <getPHYSpeed+0xa28>
 182e068:	00806134 	movhi	r2,388
 182e06c:	1088ae04 	addi	r2,r2,8888
 182e070:	00000206 	br	182e07c <getPHYSpeed+0xa28>
 182e074:	00806134 	movhi	r2,388
 182e078:	1088af04 	addi	r2,r2,8892
 182e07c:	e0fff743 	ldbu	r3,-35(fp)
 182e080:	18c00058 	cmpnei	r3,r3,1
 182e084:	1800031e 	bne	r3,zero,182e094 <getPHYSpeed+0xa40>
 182e088:	00c06134 	movhi	r3,388
 182e08c:	18c8b104 	addi	r3,r3,8900
 182e090:	00000206 	br	182e09c <getPHYSpeed+0xa48>
 182e094:	00c06134 	movhi	r3,388
 182e098:	18c8b304 	addi	r3,r3,8908
 182e09c:	d8c00015 	stw	r3,0(sp)
 182e0a0:	100f883a 	mov	r7,r2
 182e0a4:	280d883a 	mov	r6,r5
 182e0a8:	200b883a 	mov	r5,r4
 182e0ac:	01006134 	movhi	r4,388
 182e0b0:	21095904 	addi	r4,r4,9572
 182e0b4:	1800c180 	call	1800c18 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 182e0b8:	e0bff817 	ldw	r2,-32(fp)
}
 182e0bc:	e037883a 	mov	sp,fp
 182e0c0:	dfc00117 	ldw	ra,4(sp)
 182e0c4:	df000017 	ldw	fp,0(sp)
 182e0c8:	dec00204 	addi	sp,sp,8
 182e0cc:	f800283a 	ret

0182e0d0 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 182e0d0:	defffd04 	addi	sp,sp,-12
 182e0d4:	df000215 	stw	fp,8(sp)
 182e0d8:	df000204 	addi	fp,sp,8
 182e0dc:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182e0e0:	e0bfff17 	ldw	r2,-4(fp)
 182e0e4:	10800617 	ldw	r2,24(r2)
 182e0e8:	10800317 	ldw	r2,12(r2)
 182e0ec:	10800117 	ldw	r2,4(r2)
 182e0f0:	10800217 	ldw	r2,8(r2)
 182e0f4:	10800017 	ldw	r2,0(r2)
 182e0f8:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 182e0fc:	e0bffe17 	ldw	r2,-8(fp)
 182e100:	10801004 	addi	r2,r2,64
 182e104:	10800037 	ldwio	r2,0(r2)
}
 182e108:	e037883a 	mov	sp,fp
 182e10c:	df000017 	ldw	fp,0(sp)
 182e110:	dec00104 	addi	sp,sp,4
 182e114:	f800283a 	ret

0182e118 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 182e118:	defffc04 	addi	sp,sp,-16
 182e11c:	df000315 	stw	fp,12(sp)
 182e120:	df000304 	addi	fp,sp,12
 182e124:	e13ffe15 	stw	r4,-8(fp)
 182e128:	2805883a 	mov	r2,r5
 182e12c:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182e130:	e0bffe17 	ldw	r2,-8(fp)
 182e134:	10800617 	ldw	r2,24(r2)
 182e138:	10800317 	ldw	r2,12(r2)
 182e13c:	10800117 	ldw	r2,4(r2)
 182e140:	10800217 	ldw	r2,8(r2)
 182e144:	10800017 	ldw	r2,0(r2)
 182e148:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 182e14c:	e0bffd17 	ldw	r2,-12(fp)
 182e150:	10801004 	addi	r2,r2,64
 182e154:	e0ffff03 	ldbu	r3,-4(fp)
 182e158:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 182e15c:	0005883a 	mov	r2,zero
}
 182e160:	e037883a 	mov	sp,fp
 182e164:	df000017 	ldw	fp,0(sp)
 182e168:	dec00104 	addi	sp,sp,4
 182e16c:	f800283a 	ret

0182e170 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 182e170:	defff604 	addi	sp,sp,-40
 182e174:	df000915 	stw	fp,36(sp)
 182e178:	df000904 	addi	fp,sp,36
 182e17c:	e13ffb15 	stw	r4,-20(fp)
 182e180:	3009883a 	mov	r4,r6
 182e184:	3807883a 	mov	r3,r7
 182e188:	e0800117 	ldw	r2,4(fp)
 182e18c:	e17ffc05 	stb	r5,-16(fp)
 182e190:	e13ffd05 	stb	r4,-12(fp)
 182e194:	e0fffe05 	stb	r3,-8(fp)
 182e198:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182e19c:	e0bffb17 	ldw	r2,-20(fp)
 182e1a0:	10800617 	ldw	r2,24(r2)
 182e1a4:	10800317 	ldw	r2,12(r2)
 182e1a8:	10800117 	ldw	r2,4(r2)
 182e1ac:	10800217 	ldw	r2,8(r2)
 182e1b0:	10800017 	ldw	r2,0(r2)
 182e1b4:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 182e1b8:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 182e1bc:	e03ff815 	stw	zero,-32(fp)
 182e1c0:	00000906 	br	182e1e8 <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 182e1c4:	e0bff70b 	ldhu	r2,-36(fp)
 182e1c8:	1085883a 	add	r2,r2,r2
 182e1cc:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 182e1d0:	e0bff70b 	ldhu	r2,-36(fp)
 182e1d4:	10800054 	ori	r2,r2,1
 182e1d8:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 182e1dc:	e0bff817 	ldw	r2,-32(fp)
 182e1e0:	10800044 	addi	r2,r2,1
 182e1e4:	e0bff815 	stw	r2,-32(fp)
 182e1e8:	e0bffe03 	ldbu	r2,-8(fp)
 182e1ec:	e0fff817 	ldw	r3,-32(fp)
 182e1f0:	18bff416 	blt	r3,r2,182e1c4 <__ram_exceptions_end+0xff81dd80>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 182e1f4:	e0fff70b 	ldhu	r3,-36(fp)
 182e1f8:	e0bffd03 	ldbu	r2,-12(fp)
 182e1fc:	1884983a 	sll	r2,r3,r2
 182e200:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 182e204:	e0bff917 	ldw	r2,-28(fp)
 182e208:	10c0a004 	addi	r3,r2,640
 182e20c:	e0bffc03 	ldbu	r2,-16(fp)
 182e210:	1085883a 	add	r2,r2,r2
 182e214:	1085883a 	add	r2,r2,r2
 182e218:	1885883a 	add	r2,r3,r2
 182e21c:	10800037 	ldwio	r2,0(r2)
 182e220:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 182e224:	e0bff70b 	ldhu	r2,-36(fp)
 182e228:	0084303a 	nor	r2,zero,r2
 182e22c:	1007883a 	mov	r3,r2
 182e230:	e0bffa0b 	ldhu	r2,-24(fp)
 182e234:	1884703a 	and	r2,r3,r2
 182e238:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 182e23c:	e0ffff0b 	ldhu	r3,-4(fp)
 182e240:	e0bffd03 	ldbu	r2,-12(fp)
 182e244:	1884983a 	sll	r2,r3,r2
 182e248:	1007883a 	mov	r3,r2
 182e24c:	e0bff70b 	ldhu	r2,-36(fp)
 182e250:	1884703a 	and	r2,r3,r2
 182e254:	1007883a 	mov	r3,r2
 182e258:	e0bffa0b 	ldhu	r2,-24(fp)
 182e25c:	1884b03a 	or	r2,r3,r2
 182e260:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 182e264:	e0bff917 	ldw	r2,-28(fp)
 182e268:	10c0a004 	addi	r3,r2,640
 182e26c:	e0bffc03 	ldbu	r2,-16(fp)
 182e270:	1085883a 	add	r2,r2,r2
 182e274:	1085883a 	add	r2,r2,r2
 182e278:	1885883a 	add	r2,r3,r2
 182e27c:	e0fffa0b 	ldhu	r3,-24(fp)
 182e280:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 182e284:	0005883a 	mov	r2,zero
    
}
 182e288:	e037883a 	mov	sp,fp
 182e28c:	df000017 	ldw	fp,0(sp)
 182e290:	dec00104 	addi	sp,sp,4
 182e294:	f800283a 	ret

0182e298 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 182e298:	defff704 	addi	sp,sp,-36
 182e29c:	df000815 	stw	fp,32(sp)
 182e2a0:	df000804 	addi	fp,sp,32
 182e2a4:	e13ffc15 	stw	r4,-16(fp)
 182e2a8:	2809883a 	mov	r4,r5
 182e2ac:	3007883a 	mov	r3,r6
 182e2b0:	3805883a 	mov	r2,r7
 182e2b4:	e13ffd05 	stb	r4,-12(fp)
 182e2b8:	e0fffe05 	stb	r3,-8(fp)
 182e2bc:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182e2c0:	e0bffc17 	ldw	r2,-16(fp)
 182e2c4:	10800617 	ldw	r2,24(r2)
 182e2c8:	10800317 	ldw	r2,12(r2)
 182e2cc:	10800117 	ldw	r2,4(r2)
 182e2d0:	10800217 	ldw	r2,8(r2)
 182e2d4:	10800017 	ldw	r2,0(r2)
 182e2d8:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 182e2dc:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 182e2e0:	e03ff915 	stw	zero,-28(fp)
 182e2e4:	00000906 	br	182e30c <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 182e2e8:	e0bff817 	ldw	r2,-32(fp)
 182e2ec:	1085883a 	add	r2,r2,r2
 182e2f0:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 182e2f4:	e0bff817 	ldw	r2,-32(fp)
 182e2f8:	10800054 	ori	r2,r2,1
 182e2fc:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 182e300:	e0bff917 	ldw	r2,-28(fp)
 182e304:	10800044 	addi	r2,r2,1
 182e308:	e0bff915 	stw	r2,-28(fp)
 182e30c:	e0bfff03 	ldbu	r2,-4(fp)
 182e310:	e0fff917 	ldw	r3,-28(fp)
 182e314:	18bff416 	blt	r3,r2,182e2e8 <__ram_exceptions_end+0xff81dea4>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 182e318:	e0bffa17 	ldw	r2,-24(fp)
 182e31c:	10c0a004 	addi	r3,r2,640
 182e320:	e0bffd03 	ldbu	r2,-12(fp)
 182e324:	1085883a 	add	r2,r2,r2
 182e328:	1085883a 	add	r2,r2,r2
 182e32c:	1885883a 	add	r2,r3,r2
 182e330:	10800037 	ldwio	r2,0(r2)
 182e334:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 182e338:	e0fffb0b 	ldhu	r3,-20(fp)
 182e33c:	e0bffe03 	ldbu	r2,-8(fp)
 182e340:	1885d83a 	sra	r2,r3,r2
 182e344:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 182e348:	e0fffb0b 	ldhu	r3,-20(fp)
 182e34c:	e0bff817 	ldw	r2,-32(fp)
 182e350:	1884703a 	and	r2,r3,r2
}
 182e354:	e037883a 	mov	sp,fp
 182e358:	df000017 	ldw	fp,0(sp)
 182e35c:	dec00104 	addi	sp,sp,4
 182e360:	f800283a 	ret

0182e364 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 182e364:	deff9a04 	addi	sp,sp,-408
 182e368:	dfc06515 	stw	ra,404(sp)
 182e36c:	df006415 	stw	fp,400(sp)
 182e370:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 182e374:	e0ff9c04 	addi	r3,fp,-400
 182e378:	00801904 	movi	r2,100
 182e37c:	100d883a 	mov	r6,r2
 182e380:	000b883a 	mov	r5,zero
 182e384:	1809883a 	mov	r4,r3
 182e388:	18061d40 	call	18061d4 <memset>
 182e38c:	009d9cb4 	movhi	r2,30322
 182e390:	10985344 	addi	r2,r2,24909
 182e394:	e0bf9c15 	stw	r2,-400(fp)
 182e398:	00881b34 	movhi	r2,8300
 182e39c:	109b1944 	addi	r2,r2,27749
 182e3a0:	e0bf9d15 	stw	r2,-396(fp)
 182e3a4:	008c5174 	movhi	r2,12613
 182e3a8:	108e0e04 	addi	r2,r2,14392
 182e3ac:	e0bf9e15 	stw	r2,-392(fp)
 182e3b0:	00800c74 	movhi	r2,49
 182e3b4:	108c4c44 	addi	r2,r2,12593
 182e3b8:	e0bf9f15 	stw	r2,-388(fp)
 182e3bc:	e0bfa004 	addi	r2,fp,-384
 182e3c0:	00c01004 	movi	r3,64
 182e3c4:	180d883a 	mov	r6,r3
 182e3c8:	000b883a 	mov	r5,zero
 182e3cc:	1009883a 	mov	r4,r2
 182e3d0:	18061d40 	call	18061d4 <memset>
 182e3d4:	009410c4 	movi	r2,20547
 182e3d8:	e0bfb015 	stw	r2,-320(fp)
 182e3dc:	00800304 	movi	r2,12
 182e3e0:	e0bfb105 	stb	r2,-316(fp)
 182e3e4:	00800084 	movi	r2,2
 182e3e8:	e0bfb145 	stb	r2,-315(fp)
 182e3ec:	00800444 	movi	r2,17
 182e3f0:	e0bfb185 	stb	r2,-314(fp)
 182e3f4:	00800384 	movi	r2,14
 182e3f8:	e0bfb1c5 	stb	r2,-313(fp)
 182e3fc:	00800344 	movi	r2,13
 182e400:	e0bfb205 	stb	r2,-312(fp)
 182e404:	00800284 	movi	r2,10
 182e408:	e0bfb245 	stb	r2,-311(fp)
 182e40c:	008060f4 	movhi	r2,387
 182e410:	10836b04 	addi	r2,r2,3500
 182e414:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 182e418:	e0bfb504 	addi	r2,fp,-300
 182e41c:	00c01904 	movi	r3,100
 182e420:	180d883a 	mov	r6,r3
 182e424:	000b883a 	mov	r5,zero
 182e428:	1009883a 	mov	r4,r2
 182e42c:	18061d40 	call	18061d4 <memset>
 182e430:	009d9cb4 	movhi	r2,30322
 182e434:	10985344 	addi	r2,r2,24909
 182e438:	e0bfb515 	stw	r2,-300(fp)
 182e43c:	00881b34 	movhi	r2,8300
 182e440:	109b1944 	addi	r2,r2,27749
 182e444:	e0bfb615 	stw	r2,-296(fp)
 182e448:	00991874 	movhi	r2,25697
 182e44c:	109d5444 	addi	r2,r2,30033
 182e450:	e0bfb715 	stw	r2,-292(fp)
 182e454:	00965234 	movhi	r2,22856
 182e458:	10940804 	addi	r2,r2,20512
 182e45c:	e0bfb815 	stw	r2,-288(fp)
 182e460:	00914e34 	movhi	r2,17720
 182e464:	108e0804 	addi	r2,r2,14368
 182e468:	e0bfb915 	stw	r2,-284(fp)
 182e46c:	008d4d34 	movhi	r2,13620
 182e470:	108c4c44 	addi	r2,r2,12593
 182e474:	e0bfba15 	stw	r2,-280(fp)
 182e478:	e03fbb15 	stw	zero,-276(fp)
 182e47c:	e03fbc15 	stw	zero,-272(fp)
 182e480:	e03fbd15 	stw	zero,-268(fp)
 182e484:	e03fbe15 	stw	zero,-264(fp)
 182e488:	e03fbf15 	stw	zero,-260(fp)
 182e48c:	e03fc015 	stw	zero,-256(fp)
 182e490:	e03fc115 	stw	zero,-252(fp)
 182e494:	e03fc215 	stw	zero,-248(fp)
 182e498:	e03fc315 	stw	zero,-244(fp)
 182e49c:	e03fc415 	stw	zero,-240(fp)
 182e4a0:	e03fc515 	stw	zero,-236(fp)
 182e4a4:	e03fc615 	stw	zero,-232(fp)
 182e4a8:	e03fc715 	stw	zero,-228(fp)
 182e4ac:	e03fc815 	stw	zero,-224(fp)
 182e4b0:	009410c4 	movi	r2,20547
 182e4b4:	e0bfc915 	stw	r2,-220(fp)
 182e4b8:	00800344 	movi	r2,13
 182e4bc:	e0bfca05 	stb	r2,-216(fp)
 182e4c0:	00800084 	movi	r2,2
 182e4c4:	e0bfca45 	stb	r2,-215(fp)
 182e4c8:	00800444 	movi	r2,17
 182e4cc:	e0bfca85 	stb	r2,-214(fp)
 182e4d0:	00800384 	movi	r2,14
 182e4d4:	e0bfcac5 	stb	r2,-213(fp)
 182e4d8:	00800344 	movi	r2,13
 182e4dc:	e0bfcb05 	stb	r2,-212(fp)
 182e4e0:	00800284 	movi	r2,10
 182e4e4:	e0bfcb45 	stb	r2,-211(fp)
 182e4e8:	008060f4 	movhi	r2,387
 182e4ec:	10836b04 	addi	r2,r2,3500
 182e4f0:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 182e4f4:	e0bfce04 	addi	r2,fp,-200
 182e4f8:	00c01904 	movi	r3,100
 182e4fc:	180d883a 	mov	r6,r3
 182e500:	000b883a 	mov	r5,zero
 182e504:	1009883a 	mov	r4,r2
 182e508:	18061d40 	call	18061d4 <memset>
 182e50c:	009a5d34 	movhi	r2,26996
 182e510:	10985384 	addi	r2,r2,24910
 182e514:	e0bfce15 	stw	r2,-200(fp)
 182e518:	009b1874 	movhi	r2,27745
 182e51c:	109b9bc4 	addi	r2,r2,28271
 182e520:	e0bfcf15 	stw	r2,-196(fp)
 182e524:	008e1434 	movhi	r2,14416
 182e528:	10910804 	addi	r2,r2,17440
 182e52c:	e0bfd015 	stw	r2,-192(fp)
 182e530:	008d4db4 	movhi	r2,13622
 182e534:	108e0cc4 	addi	r2,r2,14387
 182e538:	e0bfd115 	stw	r2,-188(fp)
 182e53c:	e03fd215 	stw	zero,-184(fp)
 182e540:	e0bfd304 	addi	r2,fp,-180
 182e544:	00c00f04 	movi	r3,60
 182e548:	180d883a 	mov	r6,r3
 182e54c:	000b883a 	mov	r5,zero
 182e550:	1009883a 	mov	r4,r2
 182e554:	18061d40 	call	18061d4 <memset>
 182e558:	00800234 	movhi	r2,8
 182e55c:	108005c4 	addi	r2,r2,23
 182e560:	e0bfe215 	stw	r2,-120(fp)
 182e564:	008001c4 	movi	r2,7
 182e568:	e0bfe305 	stb	r2,-116(fp)
 182e56c:	00800284 	movi	r2,10
 182e570:	e0bfe345 	stb	r2,-115(fp)
 182e574:	00800444 	movi	r2,17
 182e578:	e0bfe385 	stb	r2,-114(fp)
 182e57c:	008000c4 	movi	r2,3
 182e580:	e0bfe3c5 	stb	r2,-113(fp)
 182e584:	00800044 	movi	r2,1
 182e588:	e0bfe405 	stb	r2,-112(fp)
 182e58c:	00800084 	movi	r2,2
 182e590:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 182e594:	00806134 	movhi	r2,388
 182e598:	10896504 	addi	r2,r2,9620
 182e59c:	e0ffe704 	addi	r3,fp,-100
 182e5a0:	1009883a 	mov	r4,r2
 182e5a4:	00801904 	movi	r2,100
 182e5a8:	100d883a 	mov	r6,r2
 182e5ac:	200b883a 	mov	r5,r4
 182e5b0:	1809883a 	mov	r4,r3
 182e5b4:	180608c0 	call	180608c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 182e5b8:	e13f9c04 	addi	r4,fp,-400
 182e5bc:	182c4e00 	call	182c4e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 182e5c0:	e0bfb504 	addi	r2,fp,-300
 182e5c4:	1009883a 	mov	r4,r2
 182e5c8:	182c4e00 	call	182c4e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 182e5cc:	e0bfce04 	addi	r2,fp,-200
 182e5d0:	1009883a 	mov	r4,r2
 182e5d4:	182c4e00 	call	182c4e0 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 182e5d8:	e0bfe704 	addi	r2,fp,-100
 182e5dc:	1009883a 	mov	r4,r2
 182e5e0:	182c4e00 	call	182c4e0 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 182e5e4:	d0a81003 	ldbu	r2,-24512(gp)
 182e5e8:	10803fcc 	andi	r2,r2,255
}
 182e5ec:	e037883a 	mov	sp,fp
 182e5f0:	dfc00117 	ldw	ra,4(sp)
 182e5f4:	df000017 	ldw	fp,0(sp)
 182e5f8:	dec00204 	addi	sp,sp,8
 182e5fc:	f800283a 	ret

0182e600 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 182e600:	defffd04 	addi	sp,sp,-12
 182e604:	dfc00215 	stw	ra,8(sp)
 182e608:	df000115 	stw	fp,4(sp)
 182e60c:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 182e610:	d0a81003 	ldbu	r2,-24512(gp)
 182e614:	10803fcc 	andi	r2,r2,255
 182e618:	100b883a 	mov	r5,r2
 182e61c:	01006134 	movhi	r4,388
 182e620:	21097e04 	addi	r4,r4,9720
 182e624:	182c1980 	call	182c198 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 182e628:	e03fff05 	stb	zero,-4(fp)
 182e62c:	00006d06 	br	182e7e4 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 182e630:	e0bfff07 	ldb	r2,-4(fp)
 182e634:	100b883a 	mov	r5,r2
 182e638:	01006134 	movhi	r4,388
 182e63c:	21098d04 	addi	r4,r4,9780
 182e640:	182c1980 	call	182c198 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 182e644:	e0ffff07 	ldb	r3,-4(fp)
 182e648:	008061f4 	movhi	r2,391
 182e64c:	10aab904 	addi	r2,r2,-21788
 182e650:	18c7883a 	add	r3,r3,r3
 182e654:	18c7883a 	add	r3,r3,r3
 182e658:	10c5883a 	add	r2,r2,r3
 182e65c:	10800017 	ldw	r2,0(r2)
 182e660:	100b883a 	mov	r5,r2
 182e664:	01006134 	movhi	r4,388
 182e668:	21099204 	addi	r4,r4,9800
 182e66c:	182c1980 	call	182c198 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 182e670:	e0ffff07 	ldb	r3,-4(fp)
 182e674:	008061f4 	movhi	r2,391
 182e678:	10aab904 	addi	r2,r2,-21788
 182e67c:	18c7883a 	add	r3,r3,r3
 182e680:	18c7883a 	add	r3,r3,r3
 182e684:	10c5883a 	add	r2,r2,r3
 182e688:	10800017 	ldw	r2,0(r2)
 182e68c:	10801417 	ldw	r2,80(r2)
 182e690:	100b883a 	mov	r5,r2
 182e694:	01006134 	movhi	r4,388
 182e698:	21099804 	addi	r4,r4,9824
 182e69c:	182c1980 	call	182c198 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 182e6a0:	e0ffff07 	ldb	r3,-4(fp)
 182e6a4:	008061f4 	movhi	r2,391
 182e6a8:	10aab904 	addi	r2,r2,-21788
 182e6ac:	18c7883a 	add	r3,r3,r3
 182e6b0:	18c7883a 	add	r3,r3,r3
 182e6b4:	10c5883a 	add	r2,r2,r3
 182e6b8:	10800017 	ldw	r2,0(r2)
 182e6bc:	10801503 	ldbu	r2,84(r2)
 182e6c0:	10803fcc 	andi	r2,r2,255
 182e6c4:	100b883a 	mov	r5,r2
 182e6c8:	01006134 	movhi	r4,388
 182e6cc:	21099f04 	addi	r4,r4,9852
 182e6d0:	182c1980 	call	182c198 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 182e6d4:	e0ffff07 	ldb	r3,-4(fp)
 182e6d8:	008061f4 	movhi	r2,391
 182e6dc:	10aab904 	addi	r2,r2,-21788
 182e6e0:	18c7883a 	add	r3,r3,r3
 182e6e4:	18c7883a 	add	r3,r3,r3
 182e6e8:	10c5883a 	add	r2,r2,r3
 182e6ec:	10800017 	ldw	r2,0(r2)
 182e6f0:	10801543 	ldbu	r2,85(r2)
 182e6f4:	10803fcc 	andi	r2,r2,255
 182e6f8:	100b883a 	mov	r5,r2
 182e6fc:	01006134 	movhi	r4,388
 182e700:	2109a604 	addi	r4,r4,9880
 182e704:	182c1980 	call	182c198 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 182e708:	e0ffff07 	ldb	r3,-4(fp)
 182e70c:	008061f4 	movhi	r2,391
 182e710:	10aab904 	addi	r2,r2,-21788
 182e714:	18c7883a 	add	r3,r3,r3
 182e718:	18c7883a 	add	r3,r3,r3
 182e71c:	10c5883a 	add	r2,r2,r3
 182e720:	10800017 	ldw	r2,0(r2)
 182e724:	10801583 	ldbu	r2,86(r2)
 182e728:	10803fcc 	andi	r2,r2,255
 182e72c:	100b883a 	mov	r5,r2
 182e730:	01006134 	movhi	r4,388
 182e734:	2109ad04 	addi	r4,r4,9908
 182e738:	182c1980 	call	182c198 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 182e73c:	e0ffff07 	ldb	r3,-4(fp)
 182e740:	008061f4 	movhi	r2,391
 182e744:	10aab904 	addi	r2,r2,-21788
 182e748:	18c7883a 	add	r3,r3,r3
 182e74c:	18c7883a 	add	r3,r3,r3
 182e750:	10c5883a 	add	r2,r2,r3
 182e754:	10800017 	ldw	r2,0(r2)
 182e758:	108015c3 	ldbu	r2,87(r2)
 182e75c:	10803fcc 	andi	r2,r2,255
 182e760:	100b883a 	mov	r5,r2
 182e764:	01006134 	movhi	r4,388
 182e768:	2109b404 	addi	r4,r4,9936
 182e76c:	182c1980 	call	182c198 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 182e770:	e0ffff07 	ldb	r3,-4(fp)
 182e774:	008061f4 	movhi	r2,391
 182e778:	10aab904 	addi	r2,r2,-21788
 182e77c:	18c7883a 	add	r3,r3,r3
 182e780:	18c7883a 	add	r3,r3,r3
 182e784:	10c5883a 	add	r2,r2,r3
 182e788:	10800017 	ldw	r2,0(r2)
 182e78c:	10801603 	ldbu	r2,88(r2)
 182e790:	10803fcc 	andi	r2,r2,255
 182e794:	100b883a 	mov	r5,r2
 182e798:	01006134 	movhi	r4,388
 182e79c:	2109ba04 	addi	r4,r4,9960
 182e7a0:	182c1980 	call	182c198 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 182e7a4:	e0ffff07 	ldb	r3,-4(fp)
 182e7a8:	008061f4 	movhi	r2,391
 182e7ac:	10aab904 	addi	r2,r2,-21788
 182e7b0:	18c7883a 	add	r3,r3,r3
 182e7b4:	18c7883a 	add	r3,r3,r3
 182e7b8:	10c5883a 	add	r2,r2,r3
 182e7bc:	10800017 	ldw	r2,0(r2)
 182e7c0:	10801643 	ldbu	r2,89(r2)
 182e7c4:	10803fcc 	andi	r2,r2,255
 182e7c8:	100b883a 	mov	r5,r2
 182e7cc:	01006134 	movhi	r4,388
 182e7d0:	2109c004 	addi	r4,r4,9984
 182e7d4:	182c1980 	call	182c198 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 182e7d8:	e0bfff03 	ldbu	r2,-4(fp)
 182e7dc:	10800044 	addi	r2,r2,1
 182e7e0:	e0bfff05 	stb	r2,-4(fp)
 182e7e4:	e0ffff07 	ldb	r3,-4(fp)
 182e7e8:	d0a81003 	ldbu	r2,-24512(gp)
 182e7ec:	10803fcc 	andi	r2,r2,255
 182e7f0:	18bf8f16 	blt	r3,r2,182e630 <__ram_exceptions_end+0xff81e1ec>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 182e7f4:	d0a81003 	ldbu	r2,-24512(gp)
 182e7f8:	10803fcc 	andi	r2,r2,255
}
 182e7fc:	e037883a 	mov	sp,fp
 182e800:	dfc00117 	ldw	ra,4(sp)
 182e804:	df000017 	ldw	fp,0(sp)
 182e808:	dec00204 	addi	sp,sp,8
 182e80c:	f800283a 	ret

0182e810 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 182e810:	defffa04 	addi	sp,sp,-24
 182e814:	dfc00515 	stw	ra,20(sp)
 182e818:	df000415 	stw	fp,16(sp)
 182e81c:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 182e820:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 182e824:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 182e828:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 182e82c:	d0281045 	stb	zero,-24511(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 182e830:	e03ffc05 	stb	zero,-16(fp)
 182e834:	00019506 	br	182ee8c <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 182e838:	e0bffc07 	ldb	r2,-16(fp)
 182e83c:	10c01224 	muli	r3,r2,72
 182e840:	00806134 	movhi	r2,388
 182e844:	1096c404 	addi	r2,r2,23312
 182e848:	1885883a 	add	r2,r3,r2
 182e84c:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 182e850:	e0bfff17 	ldw	r2,-4(fp)
 182e854:	10800517 	ldw	r2,20(r2)
 182e858:	10018926 	beq	r2,zero,182ee80 <alt_tse_mac_group_init+0x670>
 182e85c:	e0bfff17 	ldw	r2,-4(fp)
 182e860:	10800617 	ldw	r2,24(r2)
 182e864:	10018626 	beq	r2,zero,182ee80 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 182e868:	d0a81043 	ldbu	r2,-24511(gp)
 182e86c:	10c03fcc 	andi	r3,r2,255
 182e870:	e0bfff17 	ldw	r2,-4(fp)
 182e874:	10800017 	ldw	r2,0(r2)
 182e878:	100d883a 	mov	r6,r2
 182e87c:	180b883a 	mov	r5,r3
 182e880:	01006134 	movhi	r4,388
 182e884:	2109c604 	addi	r4,r4,10008
 182e888:	1800c180 	call	1800c18 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 182e88c:	01000904 	movi	r4,36
 182e890:	183d0300 	call	183d030 <malloc>
 182e894:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 182e898:	e0bffd17 	ldw	r2,-12(fp)
 182e89c:	1000081e 	bne	r2,zero,182e8c0 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 182e8a0:	d0a81043 	ldbu	r2,-24511(gp)
 182e8a4:	10803fcc 	andi	r2,r2,255
 182e8a8:	100b883a 	mov	r5,r2
 182e8ac:	01006134 	movhi	r4,388
 182e8b0:	2109d204 	addi	r4,r4,10056
 182e8b4:	1800c180 	call	1800c18 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 182e8b8:	00bfffc4 	movi	r2,-1
 182e8bc:	00017806 	br	182eea0 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 182e8c0:	e0bfff17 	ldw	r2,-4(fp)
 182e8c4:	108002c3 	ldbu	r2,11(r2)
 182e8c8:	10803fcc 	andi	r2,r2,255
 182e8cc:	10001226 	beq	r2,zero,182e918 <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 182e8d0:	e0bfff17 	ldw	r2,-4(fp)
 182e8d4:	10c00303 	ldbu	r3,12(r2)
 182e8d8:	e0bffd17 	ldw	r2,-12(fp)
 182e8dc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 182e8e0:	01006134 	movhi	r4,388
 182e8e4:	2109e004 	addi	r4,r4,10112
 182e8e8:	182c1980 	call	182c198 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 182e8ec:	e0bffd17 	ldw	r2,-12(fp)
 182e8f0:	10800003 	ldbu	r2,0(r2)
 182e8f4:	10803fcc 	andi	r2,r2,255
 182e8f8:	100b883a 	mov	r5,r2
 182e8fc:	01006134 	movhi	r4,388
 182e900:	2109eb04 	addi	r4,r4,10156
 182e904:	182c1980 	call	182c198 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 182e908:	01006134 	movhi	r4,388
 182e90c:	2109f604 	addi	r4,r4,10200
 182e910:	182c1980 	call	182c198 <no_printf>
 182e914:	00001f06 	br	182e994 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 182e918:	e0bfff17 	ldw	r2,-4(fp)
 182e91c:	10800343 	ldbu	r2,13(r2)
 182e920:	10803fcc 	andi	r2,r2,255
 182e924:	10001226 	beq	r2,zero,182e970 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 182e928:	e0bfff17 	ldw	r2,-4(fp)
 182e92c:	10c00383 	ldbu	r3,14(r2)
 182e930:	e0bffd17 	ldw	r2,-12(fp)
 182e934:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 182e938:	01006134 	movhi	r4,388
 182e93c:	210a0104 	addi	r4,r4,10244
 182e940:	182c1980 	call	182c198 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 182e944:	01006134 	movhi	r4,388
 182e948:	2109f604 	addi	r4,r4,10200
 182e94c:	182c1980 	call	182c198 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 182e950:	e0bffd17 	ldw	r2,-12(fp)
 182e954:	10800003 	ldbu	r2,0(r2)
 182e958:	10803fcc 	andi	r2,r2,255
 182e95c:	100b883a 	mov	r5,r2
 182e960:	01006134 	movhi	r4,388
 182e964:	210a0c04 	addi	r4,r4,10288
 182e968:	182c1980 	call	182c198 <no_printf>
 182e96c:	00000906 	br	182e994 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 182e970:	e0bffd17 	ldw	r2,-12(fp)
 182e974:	00c00044 	movi	r3,1
 182e978:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 182e97c:	01006134 	movhi	r4,388
 182e980:	210a0104 	addi	r4,r4,10244
 182e984:	182c1980 	call	182c198 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 182e988:	01006134 	movhi	r4,388
 182e98c:	210a1704 	addi	r4,r4,10332
 182e990:	182c1980 	call	182c198 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 182e994:	e03ffc45 	stb	zero,-15(fp)
 182e998:	00012206 	br	182ee24 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 182e99c:	01000404 	movi	r4,16
 182e9a0:	183d0300 	call	183d030 <malloc>
 182e9a4:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 182e9a8:	e0bffe17 	ldw	r2,-8(fp)
 182e9ac:	10000a1e 	bne	r2,zero,182e9d8 <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 182e9b0:	d0a81043 	ldbu	r2,-24511(gp)
 182e9b4:	10803fcc 	andi	r2,r2,255
 182e9b8:	e0fffc47 	ldb	r3,-15(fp)
 182e9bc:	180d883a 	mov	r6,r3
 182e9c0:	100b883a 	mov	r5,r2
 182e9c4:	01006134 	movhi	r4,388
 182e9c8:	210a2204 	addi	r4,r4,10376
 182e9cc:	1800c180 	call	1800c18 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 182e9d0:	00bfffc4 	movi	r2,-1
 182e9d4:	00013206 	br	182eea0 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 182e9d8:	e0bffe17 	ldw	r2,-8(fp)
 182e9dc:	e0fffd17 	ldw	r3,-12(fp)
 182e9e0:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 182e9e4:	e0bffe17 	ldw	r2,-8(fp)
 182e9e8:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 182e9ec:	e0fffc07 	ldb	r3,-16(fp)
 182e9f0:	e0bffc47 	ldb	r2,-15(fp)
 182e9f4:	1885883a 	add	r2,r3,r2
 182e9f8:	10c01224 	muli	r3,r2,72
 182e9fc:	00806134 	movhi	r2,388
 182ea00:	1096c404 	addi	r2,r2,23312
 182ea04:	1887883a 	add	r3,r3,r2
 182ea08:	e0bffe17 	ldw	r2,-8(fp)
 182ea0c:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 182ea10:	e0bffe17 	ldw	r2,-8(fp)
 182ea14:	10800217 	ldw	r2,8(r2)
 182ea18:	10800517 	ldw	r2,20(r2)
 182ea1c:	10000426 	beq	r2,zero,182ea30 <alt_tse_mac_group_init+0x220>
 182ea20:	e0bffe17 	ldw	r2,-8(fp)
 182ea24:	10800217 	ldw	r2,8(r2)
 182ea28:	10800617 	ldw	r2,24(r2)
 182ea2c:	1000091e 	bne	r2,zero,182ea54 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 182ea30:	e0fffc07 	ldb	r3,-16(fp)
 182ea34:	e0bffc47 	ldb	r2,-15(fp)
 182ea38:	1885883a 	add	r2,r3,r2
 182ea3c:	100b883a 	mov	r5,r2
 182ea40:	01006134 	movhi	r4,388
 182ea44:	210a3404 	addi	r4,r4,10448
 182ea48:	1800c180 	call	1800c18 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 182ea4c:	00bfffc4 	movi	r2,-1
 182ea50:	00011306 	br	182eea0 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 182ea54:	e0bffe17 	ldw	r2,-8(fp)
 182ea58:	10800217 	ldw	r2,8(r2)
 182ea5c:	10800243 	ldbu	r2,9(r2)
 182ea60:	10803fcc 	andi	r2,r2,255
 182ea64:	10000d26 	beq	r2,zero,182ea9c <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 182ea68:	e0bffe17 	ldw	r2,-8(fp)
 182ea6c:	10800217 	ldw	r2,8(r2)
 182ea70:	10800283 	ldbu	r2,10(r2)
 182ea74:	10803fcc 	andi	r2,r2,255
 182ea78:	10000426 	beq	r2,zero,182ea8c <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 182ea7c:	e0bffe17 	ldw	r2,-8(fp)
 182ea80:	00c00084 	movi	r3,2
 182ea84:	10c00005 	stb	r3,0(r2)
 182ea88:	00000606 	br	182eaa4 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 182ea8c:	e0bffe17 	ldw	r2,-8(fp)
 182ea90:	00c00044 	movi	r3,1
 182ea94:	10c00005 	stb	r3,0(r2)
 182ea98:	00000206 	br	182eaa4 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 182ea9c:	e0bffe17 	ldw	r2,-8(fp)
 182eaa0:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 182eaa4:	e0bffe17 	ldw	r2,-8(fp)
 182eaa8:	10800217 	ldw	r2,8(r2)
 182eaac:	10800343 	ldbu	r2,13(r2)
 182eab0:	10803fcc 	andi	r2,r2,255
 182eab4:	10006626 	beq	r2,zero,182ec50 <alt_tse_mac_group_init+0x440>
 182eab8:	e0bffe17 	ldw	r2,-8(fp)
 182eabc:	10800217 	ldw	r2,8(r2)
 182eac0:	108002c3 	ldbu	r2,11(r2)
 182eac4:	10803fcc 	andi	r2,r2,255
 182eac8:	1000611e 	bne	r2,zero,182ec50 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 182eacc:	e0fffc47 	ldb	r3,-15(fp)
 182ead0:	e0bffe17 	ldw	r2,-8(fp)
 182ead4:	10800217 	ldw	r2,8(r2)
 182ead8:	10800017 	ldw	r2,0(r2)
 182eadc:	100d883a 	mov	r6,r2
 182eae0:	180b883a 	mov	r5,r3
 182eae4:	01006134 	movhi	r4,388
 182eae8:	210a4304 	addi	r4,r4,10508
 182eaec:	182c1980 	call	182c198 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 182eaf0:	e13ffc47 	ldb	r4,-15(fp)
 182eaf4:	e0fffc07 	ldb	r3,-16(fp)
 182eaf8:	e0bffc47 	ldb	r2,-15(fp)
 182eafc:	1885883a 	add	r2,r3,r2
 182eb00:	100d883a 	mov	r6,r2
 182eb04:	200b883a 	mov	r5,r4
 182eb08:	01006134 	movhi	r4,388
 182eb0c:	210a4f04 	addi	r4,r4,10556
 182eb10:	182c1980 	call	182c198 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 182eb14:	e0bffe17 	ldw	r2,-8(fp)
 182eb18:	10800003 	ldbu	r2,0(r2)
 182eb1c:	10803fcc 	andi	r2,r2,255
 182eb20:	10c00060 	cmpeqi	r3,r2,1
 182eb24:	18000c1e 	bne	r3,zero,182eb58 <alt_tse_mac_group_init+0x348>
 182eb28:	10c000a0 	cmpeqi	r3,r2,2
 182eb2c:	1800021e 	bne	r3,zero,182eb38 <alt_tse_mac_group_init+0x328>
 182eb30:	10001126 	beq	r2,zero,182eb78 <alt_tse_mac_group_init+0x368>
 182eb34:	00001806 	br	182eb98 <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 182eb38:	e0bffc47 	ldb	r2,-15(fp)
 182eb3c:	01806134 	movhi	r6,388
 182eb40:	318a5e04 	addi	r6,r6,10616
 182eb44:	100b883a 	mov	r5,r2
 182eb48:	01006134 	movhi	r4,388
 182eb4c:	210a6304 	addi	r4,r4,10636
 182eb50:	182c1980 	call	182c198 <no_printf>
                            break;
 182eb54:	00001806 	br	182ebb8 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 182eb58:	e0bffc47 	ldb	r2,-15(fp)
 182eb5c:	01806134 	movhi	r6,388
 182eb60:	318a6e04 	addi	r6,r6,10680
 182eb64:	100b883a 	mov	r5,r2
 182eb68:	01006134 	movhi	r4,388
 182eb6c:	210a6304 	addi	r4,r4,10636
 182eb70:	182c1980 	call	182c198 <no_printf>
                            break;
 182eb74:	00001006 	br	182ebb8 <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 182eb78:	e0bffc47 	ldb	r2,-15(fp)
 182eb7c:	01806134 	movhi	r6,388
 182eb80:	318a7404 	addi	r6,r6,10704
 182eb84:	100b883a 	mov	r5,r2
 182eb88:	01006134 	movhi	r4,388
 182eb8c:	210a6304 	addi	r4,r4,10636
 182eb90:	182c1980 	call	182c198 <no_printf>
                            break;
 182eb94:	00000806 	br	182ebb8 <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 182eb98:	e0bffc47 	ldb	r2,-15(fp)
 182eb9c:	01806134 	movhi	r6,388
 182eba0:	3188ac04 	addi	r6,r6,8880
 182eba4:	100b883a 	mov	r5,r2
 182eba8:	01006134 	movhi	r4,388
 182ebac:	210a6304 	addi	r4,r4,10636
 182ebb0:	182c1980 	call	182c198 <no_printf>
                            break;
 182ebb4:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 182ebb8:	e0bffe17 	ldw	r2,-8(fp)
 182ebbc:	10800217 	ldw	r2,8(r2)
 182ebc0:	108003c3 	ldbu	r2,15(r2)
 182ebc4:	10803fcc 	andi	r2,r2,255
 182ebc8:	10008b26 	beq	r2,zero,182edf8 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 182ebcc:	e0fffc47 	ldb	r3,-15(fp)
 182ebd0:	e0bffe17 	ldw	r2,-8(fp)
 182ebd4:	10800217 	ldw	r2,8(r2)
 182ebd8:	108003c3 	ldbu	r2,15(r2)
 182ebdc:	10803fcc 	andi	r2,r2,255
 182ebe0:	10000326 	beq	r2,zero,182ebf0 <alt_tse_mac_group_init+0x3e0>
 182ebe4:	00806134 	movhi	r2,388
 182ebe8:	108a7b04 	addi	r2,r2,10732
 182ebec:	00000206 	br	182ebf8 <alt_tse_mac_group_init+0x3e8>
 182ebf0:	00806134 	movhi	r2,388
 182ebf4:	108a7c04 	addi	r2,r2,10736
 182ebf8:	100d883a 	mov	r6,r2
 182ebfc:	180b883a 	mov	r5,r3
 182ec00:	01006134 	movhi	r4,388
 182ec04:	210a7d04 	addi	r4,r4,10740
 182ec08:	182c1980 	call	182c198 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 182ec0c:	e0fffc47 	ldb	r3,-15(fp)
 182ec10:	e0bffe17 	ldw	r2,-8(fp)
 182ec14:	10800217 	ldw	r2,8(r2)
 182ec18:	10800403 	ldbu	r2,16(r2)
 182ec1c:	10803fcc 	andi	r2,r2,255
 182ec20:	10000326 	beq	r2,zero,182ec30 <alt_tse_mac_group_init+0x420>
 182ec24:	00806134 	movhi	r2,388
 182ec28:	108a7b04 	addi	r2,r2,10732
 182ec2c:	00000206 	br	182ec38 <alt_tse_mac_group_init+0x428>
 182ec30:	00806134 	movhi	r2,388
 182ec34:	108a7c04 	addi	r2,r2,10736
 182ec38:	100d883a 	mov	r6,r2
 182ec3c:	180b883a 	mov	r5,r3
 182ec40:	01006134 	movhi	r4,388
 182ec44:	210a8804 	addi	r4,r4,10784
 182ec48:	182c1980 	call	182c198 <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 182ec4c:	00006a06 	br	182edf8 <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 182ec50:	e0bffc47 	ldb	r2,-15(fp)
 182ec54:	1000421e 	bne	r2,zero,182ed60 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 182ec58:	e0bffe17 	ldw	r2,-8(fp)
 182ec5c:	10800003 	ldbu	r2,0(r2)
 182ec60:	10803fcc 	andi	r2,r2,255
 182ec64:	10c00060 	cmpeqi	r3,r2,1
 182ec68:	18000a1e 	bne	r3,zero,182ec94 <alt_tse_mac_group_init+0x484>
 182ec6c:	10c000a0 	cmpeqi	r3,r2,2
 182ec70:	1800021e 	bne	r3,zero,182ec7c <alt_tse_mac_group_init+0x46c>
 182ec74:	10000d26 	beq	r2,zero,182ecac <alt_tse_mac_group_init+0x49c>
 182ec78:	00001206 	br	182ecc4 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 182ec7c:	01406134 	movhi	r5,388
 182ec80:	294a5e04 	addi	r5,r5,10616
 182ec84:	01006134 	movhi	r4,388
 182ec88:	210a9304 	addi	r4,r4,10828
 182ec8c:	182c1980 	call	182c198 <no_printf>
	                            break;
 182ec90:	00001206 	br	182ecdc <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 182ec94:	01406134 	movhi	r5,388
 182ec98:	294a6e04 	addi	r5,r5,10680
 182ec9c:	01006134 	movhi	r4,388
 182eca0:	210a9304 	addi	r4,r4,10828
 182eca4:	182c1980 	call	182c198 <no_printf>
	                            break;
 182eca8:	00000c06 	br	182ecdc <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 182ecac:	01406134 	movhi	r5,388
 182ecb0:	294a7404 	addi	r5,r5,10704
 182ecb4:	01006134 	movhi	r4,388
 182ecb8:	210a9304 	addi	r4,r4,10828
 182ecbc:	182c1980 	call	182c198 <no_printf>
	                            break;
 182ecc0:	00000606 	br	182ecdc <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 182ecc4:	01406134 	movhi	r5,388
 182ecc8:	2948ac04 	addi	r5,r5,8880
 182eccc:	01006134 	movhi	r4,388
 182ecd0:	210a9304 	addi	r4,r4,10828
 182ecd4:	182c1980 	call	182c198 <no_printf>
                                    break;
 182ecd8:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 182ecdc:	e0bffe17 	ldw	r2,-8(fp)
 182ece0:	10800217 	ldw	r2,8(r2)
 182ece4:	108003c3 	ldbu	r2,15(r2)
 182ece8:	10803fcc 	andi	r2,r2,255
 182ecec:	10001c26 	beq	r2,zero,182ed60 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 182ecf0:	e0bffe17 	ldw	r2,-8(fp)
 182ecf4:	10800217 	ldw	r2,8(r2)
 182ecf8:	108003c3 	ldbu	r2,15(r2)
 182ecfc:	10803fcc 	andi	r2,r2,255
 182ed00:	10000326 	beq	r2,zero,182ed10 <alt_tse_mac_group_init+0x500>
 182ed04:	00806134 	movhi	r2,388
 182ed08:	108a7b04 	addi	r2,r2,10732
 182ed0c:	00000206 	br	182ed18 <alt_tse_mac_group_init+0x508>
 182ed10:	00806134 	movhi	r2,388
 182ed14:	108a7c04 	addi	r2,r2,10736
 182ed18:	100b883a 	mov	r5,r2
 182ed1c:	01006134 	movhi	r4,388
 182ed20:	210a9e04 	addi	r4,r4,10872
 182ed24:	182c1980 	call	182c198 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 182ed28:	e0bffe17 	ldw	r2,-8(fp)
 182ed2c:	10800217 	ldw	r2,8(r2)
 182ed30:	10800403 	ldbu	r2,16(r2)
 182ed34:	10803fcc 	andi	r2,r2,255
 182ed38:	10000326 	beq	r2,zero,182ed48 <alt_tse_mac_group_init+0x538>
 182ed3c:	00806134 	movhi	r2,388
 182ed40:	108a7b04 	addi	r2,r2,10732
 182ed44:	00000206 	br	182ed50 <alt_tse_mac_group_init+0x540>
 182ed48:	00806134 	movhi	r2,388
 182ed4c:	108a7c04 	addi	r2,r2,10736
 182ed50:	100b883a 	mov	r5,r2
 182ed54:	01006134 	movhi	r4,388
 182ed58:	210aa904 	addi	r4,r4,10916
 182ed5c:	182c1980 	call	182c198 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 182ed60:	e0bffe17 	ldw	r2,-8(fp)
 182ed64:	10800217 	ldw	r2,8(r2)
 182ed68:	108002c3 	ldbu	r2,11(r2)
 182ed6c:	10803fcc 	andi	r2,r2,255
 182ed70:	10001326 	beq	r2,zero,182edc0 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 182ed74:	e0fffc47 	ldb	r3,-15(fp)
 182ed78:	e0bffe17 	ldw	r2,-8(fp)
 182ed7c:	10800217 	ldw	r2,8(r2)
 182ed80:	10800017 	ldw	r2,0(r2)
 182ed84:	100d883a 	mov	r6,r2
 182ed88:	180b883a 	mov	r5,r3
 182ed8c:	01006134 	movhi	r4,388
 182ed90:	210ab404 	addi	r4,r4,10960
 182ed94:	182c1980 	call	182c198 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 182ed98:	e13ffc47 	ldb	r4,-15(fp)
 182ed9c:	e0fffc07 	ldb	r3,-16(fp)
 182eda0:	e0bffc47 	ldb	r2,-15(fp)
 182eda4:	1885883a 	add	r2,r3,r2
 182eda8:	100d883a 	mov	r6,r2
 182edac:	200b883a 	mov	r5,r4
 182edb0:	01006134 	movhi	r4,388
 182edb4:	210ac004 	addi	r4,r4,11008
 182edb8:	182c1980 	call	182c198 <no_printf>
 182edbc:	00000e06 	br	182edf8 <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 182edc0:	e0bffe17 	ldw	r2,-8(fp)
 182edc4:	10800217 	ldw	r2,8(r2)
 182edc8:	10800017 	ldw	r2,0(r2)
 182edcc:	100b883a 	mov	r5,r2
 182edd0:	01006134 	movhi	r4,388
 182edd4:	210acf04 	addi	r4,r4,11068
 182edd8:	182c1980 	call	182c198 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 182eddc:	e0fffc07 	ldb	r3,-16(fp)
 182ede0:	e0bffc47 	ldb	r2,-15(fp)
 182ede4:	1885883a 	add	r2,r3,r2
 182ede8:	100b883a 	mov	r5,r2
 182edec:	01006134 	movhi	r4,388
 182edf0:	210adb04 	addi	r4,r4,11116
 182edf4:	182c1980 	call	182c198 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 182edf8:	e0bffc47 	ldb	r2,-15(fp)
 182edfc:	e0fffd17 	ldw	r3,-12(fp)
 182ee00:	10800044 	addi	r2,r2,1
 182ee04:	1085883a 	add	r2,r2,r2
 182ee08:	1085883a 	add	r2,r2,r2
 182ee0c:	1885883a 	add	r2,r3,r2
 182ee10:	e0fffe17 	ldw	r3,-8(fp)
 182ee14:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 182ee18:	e0bffc43 	ldbu	r2,-15(fp)
 182ee1c:	10800044 	addi	r2,r2,1
 182ee20:	e0bffc45 	stb	r2,-15(fp)
 182ee24:	e0fffc47 	ldb	r3,-15(fp)
 182ee28:	e0bffd17 	ldw	r2,-12(fp)
 182ee2c:	10800003 	ldbu	r2,0(r2)
 182ee30:	10803fcc 	andi	r2,r2,255
 182ee34:	18bed916 	blt	r3,r2,182e99c <__ram_exceptions_end+0xff81e558>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 182ee38:	d0a81043 	ldbu	r2,-24511(gp)
 182ee3c:	10c03fcc 	andi	r3,r2,255
 182ee40:	008061f4 	movhi	r2,391
 182ee44:	10aab104 	addi	r2,r2,-21820
 182ee48:	18c7883a 	add	r3,r3,r3
 182ee4c:	18c7883a 	add	r3,r3,r3
 182ee50:	10c5883a 	add	r2,r2,r3
 182ee54:	e0fffd17 	ldw	r3,-12(fp)
 182ee58:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 182ee5c:	d0a81043 	ldbu	r2,-24511(gp)
 182ee60:	10800044 	addi	r2,r2,1
 182ee64:	d0a81045 	stb	r2,-24511(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 182ee68:	e0bffd17 	ldw	r2,-12(fp)
 182ee6c:	10c00003 	ldbu	r3,0(r2)
 182ee70:	e0bffc03 	ldbu	r2,-16(fp)
 182ee74:	1885883a 	add	r2,r3,r2
 182ee78:	10bfffc4 	addi	r2,r2,-1
 182ee7c:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 182ee80:	e0bffc03 	ldbu	r2,-16(fp)
 182ee84:	10800044 	addi	r2,r2,1
 182ee88:	e0bffc05 	stb	r2,-16(fp)
 182ee8c:	e0fffc07 	ldb	r3,-16(fp)
 182ee90:	d0a01d03 	ldbu	r2,-32652(gp)
 182ee94:	10803fcc 	andi	r2,r2,255
 182ee98:	18be6716 	blt	r3,r2,182e838 <__ram_exceptions_end+0xff81e3f4>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 182ee9c:	0005883a 	mov	r2,zero
}
 182eea0:	e037883a 	mov	sp,fp
 182eea4:	dfc00117 	ldw	ra,4(sp)
 182eea8:	df000017 	ldw	fp,0(sp)
 182eeac:	dec00204 	addi	sp,sp,8
 182eeb0:	f800283a 	ret

0182eeb4 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 182eeb4:	deffed04 	addi	sp,sp,-76
 182eeb8:	dfc01215 	stw	ra,72(sp)
 182eebc:	df001115 	stw	fp,68(sp)
 182eec0:	df001104 	addi	fp,sp,68
 182eec4:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 182eec8:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 182eecc:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 182eed0:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 182eed4:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 182eed8:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 182eedc:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 182eee0:	e0bfff17 	ldw	r2,-4(fp)
 182eee4:	10800117 	ldw	r2,4(r2)
 182eee8:	10800217 	ldw	r2,8(r2)
 182eeec:	10800017 	ldw	r2,0(r2)
 182eef0:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 182eef4:	e0bff917 	ldw	r2,-28(fp)
 182eef8:	10801004 	addi	r2,r2,64
 182eefc:	10800037 	ldwio	r2,0(r2)
 182ef00:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 182ef04:	e13fff17 	ldw	r4,-4(fp)
 182ef08:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182ef0c:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 182ef10:	00800044 	movi	r2,1
 182ef14:	e0bff005 	stb	r2,-64(fp)
 182ef18:	0000ca06 	br	182f244 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 182ef1c:	e0bff917 	ldw	r2,-28(fp)
 182ef20:	10801004 	addi	r2,r2,64
 182ef24:	e0fff003 	ldbu	r3,-64(fp)
 182ef28:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 182ef2c:	e0bff917 	ldw	r2,-28(fp)
 182ef30:	1080a204 	addi	r2,r2,648
 182ef34:	10800037 	ldwio	r2,0(r2)
 182ef38:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 182ef3c:	e0bff917 	ldw	r2,-28(fp)
 182ef40:	1080a304 	addi	r2,r2,652
 182ef44:	10800037 	ldwio	r2,0(r2)
 182ef48:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 182ef4c:	e0fffc17 	ldw	r3,-16(fp)
 182ef50:	e0bff517 	ldw	r2,-44(fp)
 182ef54:	1880b826 	beq	r3,r2,182f238 <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 182ef58:	01000704 	movi	r4,28
 182ef5c:	183d0300 	call	183d030 <malloc>
 182ef60:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 182ef64:	e0bff617 	ldw	r2,-40(fp)
 182ef68:	1000091e 	bne	r2,zero,182ef90 <alt_tse_mac_get_phy+0xdc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 182ef6c:	e0bffb07 	ldb	r2,-20(fp)
 182ef70:	e0fff407 	ldb	r3,-48(fp)
 182ef74:	180d883a 	mov	r6,r3
 182ef78:	100b883a 	mov	r5,r2
 182ef7c:	01006134 	movhi	r4,388
 182ef80:	210aea04 	addi	r4,r4,11176
 182ef84:	1800c180 	call	1800c18 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 182ef88:	00bfffc4 	movi	r2,-1
 182ef8c:	0000cd06 	br	182f2c4 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 182ef90:	e0bff617 	ldw	r2,-40(fp)
 182ef94:	e0fff003 	ldbu	r3,-64(fp)
 182ef98:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 182ef9c:	e0bffc17 	ldw	r2,-16(fp)
 182efa0:	100691ba 	slli	r3,r2,6
 182efa4:	e0bff517 	ldw	r2,-44(fp)
 182efa8:	1005d2ba 	srai	r2,r2,10
 182efac:	10800fcc 	andi	r2,r2,63
 182efb0:	1884b03a 	or	r2,r3,r2
 182efb4:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 182efb8:	e0bff517 	ldw	r2,-44(fp)
 182efbc:	1005d13a 	srai	r2,r2,4
 182efc0:	10800fcc 	andi	r2,r2,63
 182efc4:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 182efc8:	e0bff517 	ldw	r2,-44(fp)
 182efcc:	108003cc 	andi	r2,r2,15
 182efd0:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 182efd4:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 182efd8:	e03ff115 	stw	zero,-60(fp)
 182efdc:	00003406 	br	182f0b0 <alt_tse_mac_get_phy+0x1fc>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 182efe0:	008061f4 	movhi	r2,391
 182efe4:	10aab904 	addi	r2,r2,-21788
 182efe8:	e0fff117 	ldw	r3,-60(fp)
 182efec:	18c7883a 	add	r3,r3,r3
 182eff0:	18c7883a 	add	r3,r3,r3
 182eff4:	10c5883a 	add	r2,r2,r3
 182eff8:	10800017 	ldw	r2,0(r2)
 182effc:	10c01417 	ldw	r3,80(r2)
 182f000:	e0bffd17 	ldw	r2,-12(fp)
 182f004:	1880271e 	bne	r3,r2,182f0a4 <alt_tse_mac_get_phy+0x1f0>
 182f008:	008061f4 	movhi	r2,391
 182f00c:	10aab904 	addi	r2,r2,-21788
 182f010:	e0fff117 	ldw	r3,-60(fp)
 182f014:	18c7883a 	add	r3,r3,r3
 182f018:	18c7883a 	add	r3,r3,r3
 182f01c:	10c5883a 	add	r2,r2,r3
 182f020:	10800017 	ldw	r2,0(r2)
 182f024:	10801503 	ldbu	r2,84(r2)
 182f028:	10c03fcc 	andi	r3,r2,255
 182f02c:	e0bffe03 	ldbu	r2,-8(fp)
 182f030:	18801c1e 	bne	r3,r2,182f0a4 <alt_tse_mac_get_phy+0x1f0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 182f034:	008061f4 	movhi	r2,391
 182f038:	10aab904 	addi	r2,r2,-21788
 182f03c:	e0fff117 	ldw	r3,-60(fp)
 182f040:	18c7883a 	add	r3,r3,r3
 182f044:	18c7883a 	add	r3,r3,r3
 182f048:	10c5883a 	add	r2,r2,r3
 182f04c:	10c00017 	ldw	r3,0(r2)
 182f050:	e0bff617 	ldw	r2,-40(fp)
 182f054:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 182f058:	008061f4 	movhi	r2,391
 182f05c:	10aab904 	addi	r2,r2,-21788
 182f060:	e0fff117 	ldw	r3,-60(fp)
 182f064:	18c7883a 	add	r3,r3,r3
 182f068:	18c7883a 	add	r3,r3,r3
 182f06c:	10c5883a 	add	r2,r2,r3
 182f070:	10800017 	ldw	r2,0(r2)
 182f074:	1009883a 	mov	r4,r2
 182f078:	e0bff003 	ldbu	r2,-64(fp)
 182f07c:	e0fffb07 	ldb	r3,-20(fp)
 182f080:	180f883a 	mov	r7,r3
 182f084:	100d883a 	mov	r6,r2
 182f088:	200b883a 	mov	r5,r4
 182f08c:	01006134 	movhi	r4,388
 182f090:	210af904 	addi	r4,r4,11236
 182f094:	1800c180 	call	1800c18 <printf>
                    is_phy_in_profile = 1;
 182f098:	00800044 	movi	r2,1
 182f09c:	e0bff205 	stb	r2,-56(fp)
                    break;
 182f0a0:	00000706 	br	182f0c0 <alt_tse_mac_get_phy+0x20c>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 182f0a4:	e0bff117 	ldw	r2,-60(fp)
 182f0a8:	10800044 	addi	r2,r2,1
 182f0ac:	e0bff115 	stw	r2,-60(fp)
 182f0b0:	d0a81003 	ldbu	r2,-24512(gp)
 182f0b4:	10803fcc 	andi	r2,r2,255
 182f0b8:	e0fff117 	ldw	r3,-60(fp)
 182f0bc:	18bfc816 	blt	r3,r2,182efe0 <__ram_exceptions_end+0xff81eb9c>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 182f0c0:	e0bff203 	ldbu	r2,-56(fp)
 182f0c4:	10000f1e 	bne	r2,zero,182f104 <alt_tse_mac_get_phy+0x250>
                pphy->pphy_profile = 0;
 182f0c8:	e0bff617 	ldw	r2,-40(fp)
 182f0cc:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 182f0d0:	e0bff003 	ldbu	r2,-64(fp)
 182f0d4:	e0fffb07 	ldb	r3,-20(fp)
 182f0d8:	180d883a 	mov	r6,r3
 182f0dc:	100b883a 	mov	r5,r2
 182f0e0:	01006134 	movhi	r4,388
 182f0e4:	210b0904 	addi	r4,r4,11300
 182f0e8:	1800c180 	call	1800c18 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 182f0ec:	01006134 	movhi	r4,388
 182f0f0:	210b1a04 	addi	r4,r4,11368
 182f0f4:	183d2fc0 	call	183d2fc <puts>
                return_value++;
 182f0f8:	e0bff317 	ldw	r2,-52(fp)
 182f0fc:	10800044 	addi	r2,r2,1
 182f100:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 182f104:	e0bffd17 	ldw	r2,-12(fp)
 182f108:	100b883a 	mov	r5,r2
 182f10c:	01006134 	movhi	r4,388
 182f110:	210b2704 	addi	r4,r4,11420
 182f114:	182c1980 	call	182c198 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 182f118:	e0bffe03 	ldbu	r2,-8(fp)
 182f11c:	100b883a 	mov	r5,r2
 182f120:	01006134 	movhi	r4,388
 182f124:	210b3204 	addi	r4,r4,11464
 182f128:	182c1980 	call	182c198 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 182f12c:	e0bffe43 	ldbu	r2,-7(fp)
 182f130:	100b883a 	mov	r5,r2
 182f134:	01006134 	movhi	r4,388
 182f138:	210b3d04 	addi	r4,r4,11508
 182f13c:	182c1980 	call	182c198 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 182f140:	e17ff617 	ldw	r5,-40(fp)
 182f144:	e13fff17 	ldw	r4,-4(fp)
 182f148:	182f2d80 	call	182f2d8 <alt_tse_mac_associate_phy>
 182f14c:	1000341e 	bne	r2,zero,182f220 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 182f150:	e0bff617 	ldw	r2,-40(fp)
 182f154:	10800617 	ldw	r2,24(r2)
 182f158:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 182f15c:	e0bff717 	ldw	r2,-36(fp)
 182f160:	10800217 	ldw	r2,8(r2)
 182f164:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 182f168:	d8000015 	stw	zero,0(sp)
 182f16c:	01c00044 	movi	r7,1
 182f170:	01800384 	movi	r6,14
 182f174:	000b883a 	mov	r5,zero
 182f178:	e13ff617 	ldw	r4,-40(fp)
 182f17c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 182f180:	01400044 	movi	r5,1
 182f184:	e13ff617 	ldw	r4,-40(fp)
 182f188:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 182f18c:	01400044 	movi	r5,1
 182f190:	e13ff617 	ldw	r4,-40(fp)
 182f194:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 182f198:	01400044 	movi	r5,1
 182f19c:	e13ff617 	ldw	r4,-40(fp)
 182f1a0:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 182f1a4:	017e0034 	movhi	r5,63488
 182f1a8:	e13ff617 	ldw	r4,-40(fp)
 182f1ac:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 182f1b0:	e0bff617 	ldw	r2,-40(fp)
 182f1b4:	10800517 	ldw	r2,20(r2)
 182f1b8:	10000f26 	beq	r2,zero,182f1f8 <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 182f1bc:	e0bff617 	ldw	r2,-40(fp)
 182f1c0:	10800517 	ldw	r2,20(r2)
 182f1c4:	10801717 	ldw	r2,92(r2)
 182f1c8:	10000b26 	beq	r2,zero,182f1f8 <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 182f1cc:	e0bff617 	ldw	r2,-40(fp)
 182f1d0:	10800517 	ldw	r2,20(r2)
 182f1d4:	100b883a 	mov	r5,r2
 182f1d8:	01006134 	movhi	r4,388
 182f1dc:	210b4804 	addi	r4,r4,11552
 182f1e0:	182c1980 	call	182c198 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 182f1e4:	e0bff617 	ldw	r2,-40(fp)
 182f1e8:	10800517 	ldw	r2,20(r2)
 182f1ec:	10801717 	ldw	r2,92(r2)
 182f1f0:	e13ff917 	ldw	r4,-28(fp)
 182f1f4:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 182f1f8:	e0bff817 	ldw	r2,-32(fp)
 182f1fc:	10801117 	ldw	r2,68(r2)
 182f200:	10000726 	beq	r2,zero,182f220 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 182f204:	01006134 	movhi	r4,388
 182f208:	210b5604 	addi	r4,r4,11608
 182f20c:	182c1980 	call	182c198 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 182f210:	e0bff817 	ldw	r2,-32(fp)
 182f214:	10801117 	ldw	r2,68(r2)
 182f218:	e13ff917 	ldw	r4,-28(fp)
 182f21c:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 182f220:	01006134 	movhi	r4,388
 182f224:	210b6404 	addi	r4,r4,11664
 182f228:	182c1980 	call	182c198 <no_printf>
	            
            phy_info_count++;
 182f22c:	e0bff403 	ldbu	r2,-48(fp)
 182f230:	10800044 	addi	r2,r2,1
 182f234:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 182f238:	e0bff003 	ldbu	r2,-64(fp)
 182f23c:	10800044 	addi	r2,r2,1
 182f240:	e0bff005 	stb	r2,-64(fp)
 182f244:	e0bff003 	ldbu	r2,-64(fp)
 182f248:	10800830 	cmpltui	r2,r2,32
 182f24c:	103f331e 	bne	r2,zero,182ef1c <__ram_exceptions_end+0xff81ead8>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 182f250:	e0bfff17 	ldw	r2,-4(fp)
 182f254:	10800003 	ldbu	r2,0(r2)
 182f258:	10c03fcc 	andi	r3,r2,255
 182f25c:	e0bff407 	ldb	r2,-48(fp)
 182f260:	18801326 	beq	r3,r2,182f2b0 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 182f264:	e0bff407 	ldb	r2,-48(fp)
 182f268:	1000061e 	bne	r2,zero,182f284 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 182f26c:	e0bffb07 	ldb	r2,-20(fp)
 182f270:	100b883a 	mov	r5,r2
 182f274:	01006134 	movhi	r4,388
 182f278:	210b6504 	addi	r4,r4,11668
 182f27c:	1800c180 	call	1800c18 <printf>
 182f280:	00000b06 	br	182f2b0 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 182f284:	e0fffb07 	ldb	r3,-20(fp)
 182f288:	e13ff407 	ldb	r4,-48(fp)
 182f28c:	e0bfff17 	ldw	r2,-4(fp)
 182f290:	10800003 	ldbu	r2,0(r2)
 182f294:	10803fcc 	andi	r2,r2,255
 182f298:	100f883a 	mov	r7,r2
 182f29c:	200d883a 	mov	r6,r4
 182f2a0:	180b883a 	mov	r5,r3
 182f2a4:	01006134 	movhi	r4,388
 182f2a8:	210b7104 	addi	r4,r4,11716
 182f2ac:	1800c180 	call	1800c18 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 182f2b0:	e0bff917 	ldw	r2,-28(fp)
 182f2b4:	10801004 	addi	r2,r2,64
 182f2b8:	e0fffa17 	ldw	r3,-24(fp)
 182f2bc:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 182f2c0:	e0bff317 	ldw	r2,-52(fp)
}
 182f2c4:	e037883a 	mov	sp,fp
 182f2c8:	dfc00117 	ldw	ra,4(sp)
 182f2cc:	df000017 	ldw	fp,0(sp)
 182f2d0:	dec00204 	addi	sp,sp,8
 182f2d4:	f800283a 	ret

0182f2d8 <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 182f2d8:	defff604 	addi	sp,sp,-40
 182f2dc:	dfc00915 	stw	ra,36(sp)
 182f2e0:	df000815 	stw	fp,32(sp)
 182f2e4:	df000804 	addi	fp,sp,32
 182f2e8:	e13ffe15 	stw	r4,-8(fp)
 182f2ec:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 182f2f0:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 182f2f4:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 182f2f8:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 182f2fc:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 182f300:	e13ffe17 	ldw	r4,-8(fp)
 182f304:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182f308:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 182f30c:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 182f310:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 182f314:	e03ff815 	stw	zero,-32(fp)
 182f318:	00002c06 	br	182f3cc <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 182f31c:	e0fffe17 	ldw	r3,-8(fp)
 182f320:	e0bff817 	ldw	r2,-32(fp)
 182f324:	10800044 	addi	r2,r2,1
 182f328:	1085883a 	add	r2,r2,r2
 182f32c:	1085883a 	add	r2,r2,r2
 182f330:	1885883a 	add	r2,r3,r2
 182f334:	10800017 	ldw	r2,0(r2)
 182f338:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 182f33c:	e0bffc17 	ldw	r2,-16(fp)
 182f340:	10800217 	ldw	r2,8(r2)
 182f344:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 182f348:	e0bffb17 	ldw	r2,-20(fp)
 182f34c:	10c01017 	ldw	r3,64(r2)
 182f350:	e0bfff17 	ldw	r2,-4(fp)
 182f354:	10800003 	ldbu	r2,0(r2)
 182f358:	10803fcc 	andi	r2,r2,255
 182f35c:	1880181e 	bne	r3,r2,182f3c0 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182f360:	e13ffc17 	ldw	r4,-16(fp)
 182f364:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182f368:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 182f36c:	e13ffb17 	ldw	r4,-20(fp)
 182f370:	182d2b00 	call	182d2b0 <alt_tse_get_system_index>
 182f374:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 182f378:	e0bffc17 	ldw	r2,-16(fp)
 182f37c:	e0ffff17 	ldw	r3,-4(fp)
 182f380:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 182f384:	e0bfff17 	ldw	r2,-4(fp)
 182f388:	e0fffc17 	ldw	r3,-16(fp)
 182f38c:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 182f390:	e0bffd47 	ldb	r2,-11(fp)
 182f394:	e0fffd07 	ldb	r3,-12(fp)
 182f398:	e13ffd87 	ldb	r4,-10(fp)
 182f39c:	200f883a 	mov	r7,r4
 182f3a0:	180d883a 	mov	r6,r3
 182f3a4:	100b883a 	mov	r5,r2
 182f3a8:	01006134 	movhi	r4,388
 182f3ac:	210b9004 	addi	r4,r4,11840
 182f3b0:	1800c180 	call	1800c18 <printf>
            is_mapped = 1;
 182f3b4:	00800044 	movi	r2,1
 182f3b8:	e0bffa05 	stb	r2,-24(fp)
            break;
 182f3bc:	00000806 	br	182f3e0 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 182f3c0:	e0bff817 	ldw	r2,-32(fp)
 182f3c4:	10800044 	addi	r2,r2,1
 182f3c8:	e0bff815 	stw	r2,-32(fp)
 182f3cc:	e0bffe17 	ldw	r2,-8(fp)
 182f3d0:	10800003 	ldbu	r2,0(r2)
 182f3d4:	10803fcc 	andi	r2,r2,255
 182f3d8:	e0fff817 	ldw	r3,-32(fp)
 182f3dc:	18bfcf16 	blt	r3,r2,182f31c <__ram_exceptions_end+0xff81eed8>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 182f3e0:	e0bffa03 	ldbu	r2,-24(fp)
 182f3e4:	10003d1e 	bne	r2,zero,182f4dc <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 182f3e8:	e03ff815 	stw	zero,-32(fp)
 182f3ec:	00003606 	br	182f4c8 <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 182f3f0:	e0fffe17 	ldw	r3,-8(fp)
 182f3f4:	e0bff817 	ldw	r2,-32(fp)
 182f3f8:	10800044 	addi	r2,r2,1
 182f3fc:	1085883a 	add	r2,r2,r2
 182f400:	1085883a 	add	r2,r2,r2
 182f404:	1885883a 	add	r2,r3,r2
 182f408:	10800017 	ldw	r2,0(r2)
 182f40c:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 182f410:	e0bffc17 	ldw	r2,-16(fp)
 182f414:	10800217 	ldw	r2,8(r2)
 182f418:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 182f41c:	e0bffb17 	ldw	r2,-20(fp)
 182f420:	10800517 	ldw	r2,20(r2)
 182f424:	10002426 	beq	r2,zero,182f4b8 <alt_tse_mac_associate_phy+0x1e0>
 182f428:	e0bffb17 	ldw	r2,-20(fp)
 182f42c:	10800617 	ldw	r2,24(r2)
 182f430:	10002126 	beq	r2,zero,182f4b8 <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 182f434:	e0bffb17 	ldw	r2,-20(fp)
 182f438:	10801017 	ldw	r2,64(r2)
 182f43c:	10bfffd8 	cmpnei	r2,r2,-1
 182f440:	10001e1e 	bne	r2,zero,182f4bc <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182f444:	e13ffc17 	ldw	r4,-16(fp)
 182f448:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182f44c:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 182f450:	e13ffb17 	ldw	r4,-20(fp)
 182f454:	182d2b00 	call	182d2b0 <alt_tse_get_system_index>
 182f458:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 182f45c:	e0bffc17 	ldw	r2,-16(fp)
 182f460:	e0ffff17 	ldw	r3,-4(fp)
 182f464:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 182f468:	e0bfff17 	ldw	r2,-4(fp)
 182f46c:	e0fffc17 	ldw	r3,-16(fp)
 182f470:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 182f474:	e0bfff17 	ldw	r2,-4(fp)
 182f478:	10800003 	ldbu	r2,0(r2)
 182f47c:	10c03fcc 	andi	r3,r2,255
 182f480:	e0bffb17 	ldw	r2,-20(fp)
 182f484:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 182f488:	e0bffd47 	ldb	r2,-11(fp)
 182f48c:	e0fffd07 	ldb	r3,-12(fp)
 182f490:	e13ffd87 	ldb	r4,-10(fp)
 182f494:	200f883a 	mov	r7,r4
 182f498:	180d883a 	mov	r6,r3
 182f49c:	100b883a 	mov	r5,r2
 182f4a0:	01006134 	movhi	r4,388
 182f4a4:	210ba004 	addi	r4,r4,11904
 182f4a8:	1800c180 	call	1800c18 <printf>
                is_mapped = 1;
 182f4ac:	00800044 	movi	r2,1
 182f4b0:	e0bffa05 	stb	r2,-24(fp)
                break;
 182f4b4:	00000906 	br	182f4dc <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 182f4b8:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 182f4bc:	e0bff817 	ldw	r2,-32(fp)
 182f4c0:	10800044 	addi	r2,r2,1
 182f4c4:	e0bff815 	stw	r2,-32(fp)
 182f4c8:	e0bffe17 	ldw	r2,-8(fp)
 182f4cc:	10800003 	ldbu	r2,0(r2)
 182f4d0:	10803fcc 	andi	r2,r2,255
 182f4d4:	e0fff817 	ldw	r3,-32(fp)
 182f4d8:	18bfc516 	blt	r3,r2,182f3f0 <__ram_exceptions_end+0xff81efac>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 182f4dc:	e0bffa03 	ldbu	r2,-24(fp)
 182f4e0:	1000091e 	bne	r2,zero,182f508 <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 182f4e4:	e0bfff17 	ldw	r2,-4(fp)
 182f4e8:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 182f4ec:	e0bffd47 	ldb	r2,-11(fp)
 182f4f0:	100b883a 	mov	r5,r2
 182f4f4:	01006134 	movhi	r4,388
 182f4f8:	210bb104 	addi	r4,r4,11972
 182f4fc:	1800c180 	call	1800c18 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 182f500:	00bfffc4 	movi	r2,-1
 182f504:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 182f508:	e0bff917 	ldw	r2,-28(fp)
}
 182f50c:	e037883a 	mov	sp,fp
 182f510:	dfc00117 	ldw	ra,4(sp)
 182f514:	df000017 	ldw	fp,0(sp)
 182f518:	dec00204 	addi	sp,sp,8
 182f51c:	f800283a 	ret

0182f520 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 182f520:	defff804 	addi	sp,sp,-32
 182f524:	dfc00715 	stw	ra,28(sp)
 182f528:	df000615 	stw	fp,24(sp)
 182f52c:	df000604 	addi	fp,sp,24
 182f530:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 182f534:	e0bfff17 	ldw	r2,-4(fp)
 182f538:	10800217 	ldw	r2,8(r2)
 182f53c:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 182f540:	e0bffa17 	ldw	r2,-24(fp)
 182f544:	10800017 	ldw	r2,0(r2)
 182f548:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 182f54c:	e0bfff17 	ldw	r2,-4(fp)
 182f550:	10800317 	ldw	r2,12(r2)
 182f554:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182f558:	e13fff17 	ldw	r4,-4(fp)
 182f55c:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182f560:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 182f564:	e13ffc17 	ldw	r4,-16(fp)
 182f568:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182f56c:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 182f570:	e0bffa17 	ldw	r2,-24(fp)
 182f574:	108003c3 	ldbu	r2,15(r2)
 182f578:	10803fcc 	andi	r2,r2,255
 182f57c:	10002c26 	beq	r2,zero,182f630 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 182f580:	e0bffd47 	ldb	r2,-11(fp)
 182f584:	e0fffd07 	ldb	r3,-12(fp)
 182f588:	180d883a 	mov	r6,r3
 182f58c:	100b883a 	mov	r5,r2
 182f590:	01006134 	movhi	r4,388
 182f594:	210be204 	addi	r4,r4,12168
 182f598:	1800c180 	call	1800c18 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 182f59c:	e0bffb17 	ldw	r2,-20(fp)
 182f5a0:	10808004 	addi	r2,r2,512
 182f5a4:	10801404 	addi	r2,r2,80
 182f5a8:	10800037 	ldwio	r2,0(r2)
 182f5ac:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 182f5b0:	e0bffa17 	ldw	r2,-24(fp)
 182f5b4:	10800403 	ldbu	r2,16(r2)
 182f5b8:	10803fcc 	andi	r2,r2,255
 182f5bc:	10000e26 	beq	r2,zero,182f5f8 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 182f5c0:	e0bffd47 	ldb	r2,-11(fp)
 182f5c4:	e0fffd07 	ldb	r3,-12(fp)
 182f5c8:	180d883a 	mov	r6,r3
 182f5cc:	100b883a 	mov	r5,r2
 182f5d0:	01006134 	movhi	r4,388
 182f5d4:	210bf004 	addi	r4,r4,12224
 182f5d8:	1800c180 	call	1800c18 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 182f5dc:	e0bffb17 	ldw	r2,-20(fp)
 182f5e0:	10808004 	addi	r2,r2,512
 182f5e4:	10801404 	addi	r2,r2,80
 182f5e8:	e0fffe17 	ldw	r3,-8(fp)
 182f5ec:	18c000d4 	ori	r3,r3,3
 182f5f0:	10c00035 	stwio	r3,0(r2)
 182f5f4:	00000e06 	br	182f630 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 182f5f8:	e0bffd47 	ldb	r2,-11(fp)
 182f5fc:	e0fffd07 	ldb	r3,-12(fp)
 182f600:	180d883a 	mov	r6,r3
 182f604:	100b883a 	mov	r5,r2
 182f608:	01006134 	movhi	r4,388
 182f60c:	210bfc04 	addi	r4,r4,12272
 182f610:	1800c180 	call	1800c18 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 182f614:	e0bffb17 	ldw	r2,-20(fp)
 182f618:	10808004 	addi	r2,r2,512
 182f61c:	10801404 	addi	r2,r2,80
 182f620:	e13ffe17 	ldw	r4,-8(fp)
 182f624:	00ffff04 	movi	r3,-4
 182f628:	20c6703a 	and	r3,r4,r3
 182f62c:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 182f630:	0005883a 	mov	r2,zero
}
 182f634:	e037883a 	mov	sp,fp
 182f638:	dfc00117 	ldw	ra,4(sp)
 182f63c:	df000017 	ldw	fp,0(sp)
 182f640:	dec00204 	addi	sp,sp,8
 182f644:	f800283a 	ret

0182f648 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 182f648:	defffb04 	addi	sp,sp,-20
 182f64c:	dfc00415 	stw	ra,16(sp)
 182f650:	df000315 	stw	fp,12(sp)
 182f654:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 182f658:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 182f65c:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 182f660:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 182f664:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 182f668:	182e3640 	call	182e364 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 182f66c:	182e6000 	call	182e600 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 182f670:	182e8100 	call	182e810 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 182f674:	e03ffd05 	stb	zero,-12(fp)
 182f678:	00002f06 	br	182f738 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 182f67c:	e0fffd07 	ldb	r3,-12(fp)
 182f680:	008061f4 	movhi	r2,391
 182f684:	10aab104 	addi	r2,r2,-21820
 182f688:	18c7883a 	add	r3,r3,r3
 182f68c:	18c7883a 	add	r3,r3,r3
 182f690:	10c5883a 	add	r2,r2,r3
 182f694:	10800017 	ldw	r2,0(r2)
 182f698:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 182f69c:	e0bffe17 	ldw	r2,-8(fp)
 182f6a0:	10800117 	ldw	r2,4(r2)
 182f6a4:	10800217 	ldw	r2,8(r2)
 182f6a8:	10800203 	ldbu	r2,8(r2)
 182f6ac:	10803fcc 	andi	r2,r2,255
 182f6b0:	10000326 	beq	r2,zero,182f6c0 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 182f6b4:	e13ffe17 	ldw	r4,-8(fp)
 182f6b8:	182eeb40 	call	182eeb4 <alt_tse_mac_get_phy>
 182f6bc:	00000706 	br	182f6dc <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 182f6c0:	e0bffd07 	ldb	r2,-12(fp)
 182f6c4:	e0fffd47 	ldb	r3,-11(fp)
 182f6c8:	180d883a 	mov	r6,r3
 182f6cc:	100b883a 	mov	r5,r2
 182f6d0:	01006134 	movhi	r4,388
 182f6d4:	210c0804 	addi	r4,r4,12320
 182f6d8:	1800c180 	call	1800c18 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 182f6dc:	e03ffd45 	stb	zero,-11(fp)
 182f6e0:	00000d06 	br	182f718 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 182f6e4:	e0bffd47 	ldb	r2,-11(fp)
 182f6e8:	e0fffe17 	ldw	r3,-8(fp)
 182f6ec:	10800044 	addi	r2,r2,1
 182f6f0:	1085883a 	add	r2,r2,r2
 182f6f4:	1085883a 	add	r2,r2,r2
 182f6f8:	1885883a 	add	r2,r3,r2
 182f6fc:	10800017 	ldw	r2,0(r2)
 182f700:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 182f704:	e13fff17 	ldw	r4,-4(fp)
 182f708:	182f5200 	call	182f520 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 182f70c:	e0bffd43 	ldbu	r2,-11(fp)
 182f710:	10800044 	addi	r2,r2,1
 182f714:	e0bffd45 	stb	r2,-11(fp)
 182f718:	e0fffd47 	ldb	r3,-11(fp)
 182f71c:	e0bffe17 	ldw	r2,-8(fp)
 182f720:	10800003 	ldbu	r2,0(r2)
 182f724:	10803fcc 	andi	r2,r2,255
 182f728:	18bfee16 	blt	r3,r2,182f6e4 <__ram_exceptions_end+0xff81f2a0>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 182f72c:	e0bffd03 	ldbu	r2,-12(fp)
 182f730:	10800044 	addi	r2,r2,1
 182f734:	e0bffd05 	stb	r2,-12(fp)
 182f738:	e0fffd07 	ldb	r3,-12(fp)
 182f73c:	d0a81043 	ldbu	r2,-24511(gp)
 182f740:	10803fcc 	andi	r2,r2,255
 182f744:	18bfcd16 	blt	r3,r2,182f67c <__ram_exceptions_end+0xff81f238>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 182f748:	0005883a 	mov	r2,zero
}
 182f74c:	e037883a 	mov	sp,fp
 182f750:	dfc00117 	ldw	ra,4(sp)
 182f754:	df000017 	ldw	fp,0(sp)
 182f758:	dec00204 	addi	sp,sp,8
 182f75c:	f800283a 	ret

0182f760 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 182f760:	defff704 	addi	sp,sp,-36
 182f764:	dfc00815 	stw	ra,32(sp)
 182f768:	df000715 	stw	fp,28(sp)
 182f76c:	df000704 	addi	fp,sp,28
 182f770:	e13ffe15 	stw	r4,-8(fp)
 182f774:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 182f778:	e0bffe17 	ldw	r2,-8(fp)
 182f77c:	10800617 	ldw	r2,24(r2)
 182f780:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 182f784:	e0bffb17 	ldw	r2,-20(fp)
 182f788:	10800317 	ldw	r2,12(r2)
 182f78c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182f790:	e13ffb17 	ldw	r4,-20(fp)
 182f794:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182f798:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 182f79c:	e13ffc17 	ldw	r4,-16(fp)
 182f7a0:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182f7a4:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 182f7a8:	e13ffe17 	ldw	r4,-8(fp)
 182f7ac:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 182f7b0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 182f7b4:	e0bffe17 	ldw	r2,-8(fp)
 182f7b8:	10800003 	ldbu	r2,0(r2)
 182f7bc:	10803fcc 	andi	r2,r2,255
 182f7c0:	100b883a 	mov	r5,r2
 182f7c4:	e13ffe17 	ldw	r4,-8(fp)
 182f7c8:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 182f7cc:	01c00044 	movi	r7,1
 182f7d0:	018000c4 	movi	r6,3
 182f7d4:	01400044 	movi	r5,1
 182f7d8:	e13ffe17 	ldw	r4,-8(fp)
 182f7dc:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182f7e0:	10000d1e 	bne	r2,zero,182f818 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 182f7e4:	e0bffd47 	ldb	r2,-11(fp)
 182f7e8:	e0fffd07 	ldb	r3,-12(fp)
 182f7ec:	180d883a 	mov	r6,r3
 182f7f0:	100b883a 	mov	r5,r2
 182f7f4:	01006134 	movhi	r4,388
 182f7f8:	210c1e04 	addi	r4,r4,12408
 182f7fc:	1800c180 	call	1800c18 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182f800:	e0bffd83 	ldbu	r2,-10(fp)
 182f804:	100b883a 	mov	r5,r2
 182f808:	e13ffe17 	ldw	r4,-8(fp)
 182f80c:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 182f810:	00bfff84 	movi	r2,-2
 182f814:	00003c06 	br	182f908 <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 182f818:	00800044 	movi	r2,1
 182f81c:	d8800015 	stw	r2,0(sp)
 182f820:	01c00044 	movi	r7,1
 182f824:	01800304 	movi	r6,12
 182f828:	000b883a 	mov	r5,zero
 182f82c:	e13ffe17 	ldw	r4,-8(fp)
 182f830:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 182f834:	00800044 	movi	r2,1
 182f838:	d8800015 	stw	r2,0(sp)
 182f83c:	01c00044 	movi	r7,1
 182f840:	01800244 	movi	r6,9
 182f844:	000b883a 	mov	r5,zero
 182f848:	e13ffe17 	ldw	r4,-8(fp)
 182f84c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 182f850:	e0bffd47 	ldb	r2,-11(fp)
 182f854:	e0fffd07 	ldb	r3,-12(fp)
 182f858:	180d883a 	mov	r6,r3
 182f85c:	100b883a 	mov	r5,r2
 182f860:	01006134 	movhi	r4,388
 182f864:	210c2e04 	addi	r4,r4,12472
 182f868:	1800c180 	call	1800c18 <printf>
    
    alt_32 timeout = 0;
 182f86c:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 182f870:	00001306 	br	182f8c0 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 182f874:	e0bffa17 	ldw	r2,-24(fp)
 182f878:	10c00044 	addi	r3,r2,1
 182f87c:	e0fffa15 	stw	r3,-24(fp)
 182f880:	1007883a 	mov	r3,r2
 182f884:	e0bfff17 	ldw	r2,-4(fp)
 182f888:	10c00d2e 	bgeu	r2,r3,182f8c0 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 182f88c:	e0bffd47 	ldb	r2,-11(fp)
 182f890:	e0fffd07 	ldb	r3,-12(fp)
 182f894:	180d883a 	mov	r6,r3
 182f898:	100b883a 	mov	r5,r2
 182f89c:	01006134 	movhi	r4,388
 182f8a0:	210c4004 	addi	r4,r4,12544
 182f8a4:	1800c180 	call	1800c18 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182f8a8:	e0bffd83 	ldbu	r2,-10(fp)
 182f8ac:	100b883a 	mov	r5,r2
 182f8b0:	e13ffe17 	ldw	r4,-8(fp)
 182f8b4:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 182f8b8:	00bfffc4 	movi	r2,-1
 182f8bc:	00001206 	br	182f908 <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 182f8c0:	01c00044 	movi	r7,1
 182f8c4:	01800144 	movi	r6,5
 182f8c8:	01400044 	movi	r5,1
 182f8cc:	e13ffe17 	ldw	r4,-8(fp)
 182f8d0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182f8d4:	103fe726 	beq	r2,zero,182f874 <__ram_exceptions_end+0xff81f430>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 182f8d8:	e0bffd47 	ldb	r2,-11(fp)
 182f8dc:	e0fffd07 	ldb	r3,-12(fp)
 182f8e0:	180d883a 	mov	r6,r3
 182f8e4:	100b883a 	mov	r5,r2
 182f8e8:	01006134 	movhi	r4,388
 182f8ec:	210c4c04 	addi	r4,r4,12592
 182f8f0:	1800c180 	call	1800c18 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182f8f4:	e0bffd83 	ldbu	r2,-10(fp)
 182f8f8:	100b883a 	mov	r5,r2
 182f8fc:	e13ffe17 	ldw	r4,-8(fp)
 182f900:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 182f904:	0005883a 	mov	r2,zero
}
 182f908:	e037883a 	mov	sp,fp
 182f90c:	dfc00117 	ldw	ra,4(sp)
 182f910:	df000017 	ldw	fp,0(sp)
 182f914:	dec00204 	addi	sp,sp,8
 182f918:	f800283a 	ret

0182f91c <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 182f91c:	defff904 	addi	sp,sp,-28
 182f920:	dfc00615 	stw	ra,24(sp)
 182f924:	df000515 	stw	fp,20(sp)
 182f928:	df000504 	addi	fp,sp,20
 182f92c:	e13ffe15 	stw	r4,-8(fp)
 182f930:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 182f934:	e0bffe17 	ldw	r2,-8(fp)
 182f938:	10800617 	ldw	r2,24(r2)
 182f93c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 182f940:	e0bffb17 	ldw	r2,-20(fp)
 182f944:	10800317 	ldw	r2,12(r2)
 182f948:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182f94c:	e13ffb17 	ldw	r4,-20(fp)
 182f950:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182f954:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 182f958:	e13ffc17 	ldw	r4,-16(fp)
 182f95c:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182f960:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 182f964:	e13ffe17 	ldw	r4,-8(fp)
 182f968:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 182f96c:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 182f970:	e0bffe17 	ldw	r2,-8(fp)
 182f974:	10800003 	ldbu	r2,0(r2)
 182f978:	10803fcc 	andi	r2,r2,255
 182f97c:	100b883a 	mov	r5,r2
 182f980:	e13ffe17 	ldw	r4,-8(fp)
 182f984:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 182f988:	e0bffd47 	ldb	r2,-11(fp)
 182f98c:	e0fffd07 	ldb	r3,-12(fp)
 182f990:	180d883a 	mov	r6,r3
 182f994:	100b883a 	mov	r5,r2
 182f998:	01006134 	movhi	r4,388
 182f99c:	210c5804 	addi	r4,r4,12640
 182f9a0:	1800c180 	call	1800c18 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 182f9a4:	01c00044 	movi	r7,1
 182f9a8:	01800384 	movi	r6,14
 182f9ac:	000b883a 	mov	r5,zero
 182f9b0:	e13ffe17 	ldw	r4,-8(fp)
 182f9b4:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182f9b8:	1000061e 	bne	r2,zero,182f9d4 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 182f9bc:	01c00044 	movi	r7,1
 182f9c0:	01800144 	movi	r6,5
 182f9c4:	01400044 	movi	r5,1
 182f9c8:	e13ffe17 	ldw	r4,-8(fp)
 182f9cc:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 182f9d0:	1000191e 	bne	r2,zero,182fa38 <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 182f9d4:	e0bffd47 	ldb	r2,-11(fp)
 182f9d8:	e0fffd07 	ldb	r3,-12(fp)
 182f9dc:	180d883a 	mov	r6,r3
 182f9e0:	100b883a 	mov	r5,r2
 182f9e4:	01006134 	movhi	r4,388
 182f9e8:	210c6304 	addi	r4,r4,12684
 182f9ec:	1800c180 	call	1800c18 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 182f9f0:	e17fff17 	ldw	r5,-4(fp)
 182f9f4:	e13ffe17 	ldw	r4,-8(fp)
 182f9f8:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
 182f9fc:	10bfffd8 	cmpnei	r2,r2,-1
 182fa00:	10000d1e 	bne	r2,zero,182fa38 <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 182fa04:	e0bffd47 	ldb	r2,-11(fp)
 182fa08:	e0fffd07 	ldb	r3,-12(fp)
 182fa0c:	180d883a 	mov	r6,r3
 182fa10:	100b883a 	mov	r5,r2
 182fa14:	01006134 	movhi	r4,388
 182fa18:	210c7704 	addi	r4,r4,12764
 182fa1c:	1800c180 	call	1800c18 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182fa20:	e0bffd83 	ldbu	r2,-10(fp)
 182fa24:	100b883a 	mov	r5,r2
 182fa28:	e13ffe17 	ldw	r4,-8(fp)
 182fa2c:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 182fa30:	00bfffc4 	movi	r2,-1
 182fa34:	00000c06 	br	182fa68 <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 182fa38:	e0bffd47 	ldb	r2,-11(fp)
 182fa3c:	e0fffd07 	ldb	r3,-12(fp)
 182fa40:	180d883a 	mov	r6,r3
 182fa44:	100b883a 	mov	r5,r2
 182fa48:	01006134 	movhi	r4,388
 182fa4c:	210c8404 	addi	r4,r4,12816
 182fa50:	1800c180 	call	1800c18 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182fa54:	e0bffd83 	ldbu	r2,-10(fp)
 182fa58:	100b883a 	mov	r5,r2
 182fa5c:	e13ffe17 	ldw	r4,-8(fp)
 182fa60:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 182fa64:	0005883a 	mov	r2,zero
}
 182fa68:	e037883a 	mov	sp,fp
 182fa6c:	dfc00117 	ldw	ra,4(sp)
 182fa70:	df000017 	ldw	fp,0(sp)
 182fa74:	dec00204 	addi	sp,sp,8
 182fa78:	f800283a 	ret

0182fa7c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 182fa7c:	defff904 	addi	sp,sp,-28
 182fa80:	dfc00615 	stw	ra,24(sp)
 182fa84:	df000515 	stw	fp,20(sp)
 182fa88:	df000504 	addi	fp,sp,20
 182fa8c:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 182fa90:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 182fa94:	e0bfff17 	ldw	r2,-4(fp)
 182fa98:	10800617 	ldw	r2,24(r2)
 182fa9c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 182faa0:	e0bffc17 	ldw	r2,-16(fp)
 182faa4:	10800317 	ldw	r2,12(r2)
 182faa8:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 182faac:	e13ffc17 	ldw	r4,-16(fp)
 182fab0:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 182fab4:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 182fab8:	e13ffd17 	ldw	r4,-12(fp)
 182fabc:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 182fac0:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 182fac4:	e13fff17 	ldw	r4,-4(fp)
 182fac8:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 182facc:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 182fad0:	e0bfff17 	ldw	r2,-4(fp)
 182fad4:	10800003 	ldbu	r2,0(r2)
 182fad8:	10803fcc 	andi	r2,r2,255
 182fadc:	100b883a 	mov	r5,r2
 182fae0:	e13fff17 	ldw	r4,-4(fp)
 182fae4:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 182fae8:	01c00044 	movi	r7,1
 182faec:	018000c4 	movi	r6,3
 182faf0:	01400044 	movi	r5,1
 182faf4:	e13fff17 	ldw	r4,-4(fp)
 182faf8:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fafc:	10000d1e 	bne	r2,zero,182fb34 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 182fb00:	e0bffe47 	ldb	r2,-7(fp)
 182fb04:	e0fffe07 	ldb	r3,-8(fp)
 182fb08:	180d883a 	mov	r6,r3
 182fb0c:	100b883a 	mov	r5,r2
 182fb10:	01006134 	movhi	r4,388
 182fb14:	210c1e04 	addi	r4,r4,12408
 182fb18:	1800c180 	call	1800c18 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182fb1c:	e0bffe83 	ldbu	r2,-6(fp)
 182fb20:	100b883a 	mov	r5,r2
 182fb24:	e13fff17 	ldw	r4,-4(fp)
 182fb28:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 182fb2c:	00bfff84 	movi	r2,-2
 182fb30:	00013206 	br	182fffc <alt_tse_phy_get_cap+0x580>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 182fb34:	017e0034 	movhi	r5,63488
 182fb38:	e13fff17 	ldw	r4,-4(fp)
 182fb3c:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 182fb40:	01c00044 	movi	r7,1
 182fb44:	01800144 	movi	r6,5
 182fb48:	01400044 	movi	r5,1
 182fb4c:	e13fff17 	ldw	r4,-4(fp)
 182fb50:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fb54:	1000021e 	bne	r2,zero,182fb60 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 182fb58:	00bfffc4 	movi	r2,-1
 182fb5c:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 182fb60:	01c00044 	movi	r7,1
 182fb64:	018003c4 	movi	r6,15
 182fb68:	014003c4 	movi	r5,15
 182fb6c:	e13fff17 	ldw	r4,-4(fp)
 182fb70:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fb74:	1007883a 	mov	r3,r2
 182fb78:	e0bfff17 	ldw	r2,-4(fp)
 182fb7c:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 182fb80:	01c00044 	movi	r7,1
 182fb84:	01800384 	movi	r6,14
 182fb88:	014003c4 	movi	r5,15
 182fb8c:	e13fff17 	ldw	r4,-4(fp)
 182fb90:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fb94:	1007883a 	mov	r3,r2
 182fb98:	e0bfff17 	ldw	r2,-4(fp)
 182fb9c:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 182fba0:	01c00044 	movi	r7,1
 182fba4:	01800344 	movi	r6,13
 182fba8:	014003c4 	movi	r5,15
 182fbac:	e13fff17 	ldw	r4,-4(fp)
 182fbb0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fbb4:	1007883a 	mov	r3,r2
 182fbb8:	e0bfff17 	ldw	r2,-4(fp)
 182fbbc:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 182fbc0:	01c00044 	movi	r7,1
 182fbc4:	01800304 	movi	r6,12
 182fbc8:	014003c4 	movi	r5,15
 182fbcc:	e13fff17 	ldw	r4,-4(fp)
 182fbd0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fbd4:	1007883a 	mov	r3,r2
 182fbd8:	e0bfff17 	ldw	r2,-4(fp)
 182fbdc:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 182fbe0:	01c00044 	movi	r7,1
 182fbe4:	018003c4 	movi	r6,15
 182fbe8:	01400044 	movi	r5,1
 182fbec:	e13fff17 	ldw	r4,-4(fp)
 182fbf0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fbf4:	1007883a 	mov	r3,r2
 182fbf8:	e0bfff17 	ldw	r2,-4(fp)
 182fbfc:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 182fc00:	01c00044 	movi	r7,1
 182fc04:	01800384 	movi	r6,14
 182fc08:	01400044 	movi	r5,1
 182fc0c:	e13fff17 	ldw	r4,-4(fp)
 182fc10:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fc14:	1007883a 	mov	r3,r2
 182fc18:	e0bfff17 	ldw	r2,-4(fp)
 182fc1c:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 182fc20:	01c00044 	movi	r7,1
 182fc24:	01800344 	movi	r6,13
 182fc28:	01400044 	movi	r5,1
 182fc2c:	e13fff17 	ldw	r4,-4(fp)
 182fc30:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fc34:	1007883a 	mov	r3,r2
 182fc38:	e0bfff17 	ldw	r2,-4(fp)
 182fc3c:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 182fc40:	01c00044 	movi	r7,1
 182fc44:	01800284 	movi	r6,10
 182fc48:	01400044 	movi	r5,1
 182fc4c:	e13fff17 	ldw	r4,-4(fp)
 182fc50:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fc54:	1007883a 	mov	r3,r2
 182fc58:	e0bfff17 	ldw	r2,-4(fp)
 182fc5c:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 182fc60:	01c00044 	movi	r7,1
 182fc64:	01800244 	movi	r6,9
 182fc68:	01400044 	movi	r5,1
 182fc6c:	e13fff17 	ldw	r4,-4(fp)
 182fc70:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fc74:	1007883a 	mov	r3,r2
 182fc78:	e0bfff17 	ldw	r2,-4(fp)
 182fc7c:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 182fc80:	01c00044 	movi	r7,1
 182fc84:	01800304 	movi	r6,12
 182fc88:	01400044 	movi	r5,1
 182fc8c:	e13fff17 	ldw	r4,-4(fp)
 182fc90:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fc94:	1007883a 	mov	r3,r2
 182fc98:	e0bfff17 	ldw	r2,-4(fp)
 182fc9c:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 182fca0:	01c00044 	movi	r7,1
 182fca4:	018002c4 	movi	r6,11
 182fca8:	01400044 	movi	r5,1
 182fcac:	e13fff17 	ldw	r4,-4(fp)
 182fcb0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fcb4:	1007883a 	mov	r3,r2
 182fcb8:	e0bfff17 	ldw	r2,-4(fp)
 182fcbc:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 182fcc0:	01c00044 	movi	r7,1
 182fcc4:	018002c4 	movi	r6,11
 182fcc8:	01400284 	movi	r5,10
 182fccc:	e13fff17 	ldw	r4,-4(fp)
 182fcd0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fcd4:	1007883a 	mov	r3,r2
 182fcd8:	e0bfff17 	ldw	r2,-4(fp)
 182fcdc:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 182fce0:	01c00044 	movi	r7,1
 182fce4:	01800284 	movi	r6,10
 182fce8:	01400284 	movi	r5,10
 182fcec:	e13fff17 	ldw	r4,-4(fp)
 182fcf0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fcf4:	1007883a 	mov	r3,r2
 182fcf8:	e0bfff17 	ldw	r2,-4(fp)
 182fcfc:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 182fd00:	01c00044 	movi	r7,1
 182fd04:	01800244 	movi	r6,9
 182fd08:	01400144 	movi	r5,5
 182fd0c:	e13fff17 	ldw	r4,-4(fp)
 182fd10:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fd14:	1007883a 	mov	r3,r2
 182fd18:	e0bfff17 	ldw	r2,-4(fp)
 182fd1c:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 182fd20:	01c00044 	movi	r7,1
 182fd24:	01800204 	movi	r6,8
 182fd28:	01400144 	movi	r5,5
 182fd2c:	e13fff17 	ldw	r4,-4(fp)
 182fd30:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fd34:	1007883a 	mov	r3,r2
 182fd38:	e0bfff17 	ldw	r2,-4(fp)
 182fd3c:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 182fd40:	01c00044 	movi	r7,1
 182fd44:	018001c4 	movi	r6,7
 182fd48:	01400144 	movi	r5,5
 182fd4c:	e13fff17 	ldw	r4,-4(fp)
 182fd50:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fd54:	1007883a 	mov	r3,r2
 182fd58:	e0bfff17 	ldw	r2,-4(fp)
 182fd5c:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 182fd60:	01c00044 	movi	r7,1
 182fd64:	01800184 	movi	r6,6
 182fd68:	01400144 	movi	r5,5
 182fd6c:	e13fff17 	ldw	r4,-4(fp)
 182fd70:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fd74:	1007883a 	mov	r3,r2
 182fd78:	e0bfff17 	ldw	r2,-4(fp)
 182fd7c:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 182fd80:	01c00044 	movi	r7,1
 182fd84:	01800144 	movi	r6,5
 182fd88:	01400144 	movi	r5,5
 182fd8c:	e13fff17 	ldw	r4,-4(fp)
 182fd90:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 182fd94:	1007883a 	mov	r3,r2
 182fd98:	e0bfff17 	ldw	r2,-4(fp)
 182fd9c:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 182fda0:	e0bffe47 	ldb	r2,-7(fp)
 182fda4:	e0fffe07 	ldb	r3,-8(fp)
 182fda8:	180d883a 	mov	r6,r3
 182fdac:	100b883a 	mov	r5,r2
 182fdb0:	01006134 	movhi	r4,388
 182fdb4:	210c8f04 	addi	r4,r4,12860
 182fdb8:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 182fdbc:	e0bfff17 	ldw	r2,-4(fp)
 182fdc0:	10800043 	ldbu	r2,1(r2)
 182fdc4:	10803fcc 	andi	r2,r2,255
 182fdc8:	100b883a 	mov	r5,r2
 182fdcc:	01006134 	movhi	r4,388
 182fdd0:	210c9a04 	addi	r4,r4,12904
 182fdd4:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 182fdd8:	e0bfff17 	ldw	r2,-4(fp)
 182fddc:	10800083 	ldbu	r2,2(r2)
 182fde0:	10803fcc 	andi	r2,r2,255
 182fde4:	100b883a 	mov	r5,r2
 182fde8:	01006134 	movhi	r4,388
 182fdec:	210ca404 	addi	r4,r4,12944
 182fdf0:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 182fdf4:	e0bfff17 	ldw	r2,-4(fp)
 182fdf8:	108000c3 	ldbu	r2,3(r2)
 182fdfc:	10803fcc 	andi	r2,r2,255
 182fe00:	100b883a 	mov	r5,r2
 182fe04:	01006134 	movhi	r4,388
 182fe08:	210cae04 	addi	r4,r4,12984
 182fe0c:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 182fe10:	e0bfff17 	ldw	r2,-4(fp)
 182fe14:	10800103 	ldbu	r2,4(r2)
 182fe18:	10803fcc 	andi	r2,r2,255
 182fe1c:	100b883a 	mov	r5,r2
 182fe20:	01006134 	movhi	r4,388
 182fe24:	210cb804 	addi	r4,r4,13024
 182fe28:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 182fe2c:	e0bfff17 	ldw	r2,-4(fp)
 182fe30:	10800143 	ldbu	r2,5(r2)
 182fe34:	10803fcc 	andi	r2,r2,255
 182fe38:	100b883a 	mov	r5,r2
 182fe3c:	01006134 	movhi	r4,388
 182fe40:	210cc204 	addi	r4,r4,13064
 182fe44:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 182fe48:	e0bfff17 	ldw	r2,-4(fp)
 182fe4c:	10800183 	ldbu	r2,6(r2)
 182fe50:	10803fcc 	andi	r2,r2,255
 182fe54:	100b883a 	mov	r5,r2
 182fe58:	01006134 	movhi	r4,388
 182fe5c:	210ccc04 	addi	r4,r4,13104
 182fe60:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 182fe64:	e0bfff17 	ldw	r2,-4(fp)
 182fe68:	108001c3 	ldbu	r2,7(r2)
 182fe6c:	10803fcc 	andi	r2,r2,255
 182fe70:	100b883a 	mov	r5,r2
 182fe74:	01006134 	movhi	r4,388
 182fe78:	210cd604 	addi	r4,r4,13144
 182fe7c:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 182fe80:	e0bfff17 	ldw	r2,-4(fp)
 182fe84:	10800203 	ldbu	r2,8(r2)
 182fe88:	10803fcc 	andi	r2,r2,255
 182fe8c:	100b883a 	mov	r5,r2
 182fe90:	01006134 	movhi	r4,388
 182fe94:	210ce004 	addi	r4,r4,13184
 182fe98:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 182fe9c:	e0bfff17 	ldw	r2,-4(fp)
 182fea0:	10800243 	ldbu	r2,9(r2)
 182fea4:	10803fcc 	andi	r2,r2,255
 182fea8:	100b883a 	mov	r5,r2
 182feac:	01006134 	movhi	r4,388
 182feb0:	210cea04 	addi	r4,r4,13224
 182feb4:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 182feb8:	e0bfff17 	ldw	r2,-4(fp)
 182febc:	10800283 	ldbu	r2,10(r2)
 182fec0:	10803fcc 	andi	r2,r2,255
 182fec4:	100b883a 	mov	r5,r2
 182fec8:	01006134 	movhi	r4,388
 182fecc:	210cf404 	addi	r4,r4,13264
 182fed0:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 182fed4:	e0bfff17 	ldw	r2,-4(fp)
 182fed8:	108002c3 	ldbu	r2,11(r2)
 182fedc:	10803fcc 	andi	r2,r2,255
 182fee0:	100b883a 	mov	r5,r2
 182fee4:	01006134 	movhi	r4,388
 182fee8:	210cfe04 	addi	r4,r4,13304
 182feec:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "\n");
 182fef0:	01006134 	movhi	r4,388
 182fef4:	210b6404 	addi	r4,r4,11664
 182fef8:	182c1980 	call	182c198 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 182fefc:	e0bffe47 	ldb	r2,-7(fp)
 182ff00:	e0fffe07 	ldb	r3,-8(fp)
 182ff04:	180d883a 	mov	r6,r3
 182ff08:	100b883a 	mov	r5,r2
 182ff0c:	01006134 	movhi	r4,388
 182ff10:	210d0804 	addi	r4,r4,13344
 182ff14:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 182ff18:	e0bfff17 	ldw	r2,-4(fp)
 182ff1c:	10800303 	ldbu	r2,12(r2)
 182ff20:	10803fcc 	andi	r2,r2,255
 182ff24:	100b883a 	mov	r5,r2
 182ff28:	01006134 	movhi	r4,388
 182ff2c:	210cae04 	addi	r4,r4,12984
 182ff30:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 182ff34:	e0bfff17 	ldw	r2,-4(fp)
 182ff38:	10800343 	ldbu	r2,13(r2)
 182ff3c:	10803fcc 	andi	r2,r2,255
 182ff40:	100b883a 	mov	r5,r2
 182ff44:	01006134 	movhi	r4,388
 182ff48:	210cb804 	addi	r4,r4,13024
 182ff4c:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 182ff50:	e0bfff17 	ldw	r2,-4(fp)
 182ff54:	10800383 	ldbu	r2,14(r2)
 182ff58:	10803fcc 	andi	r2,r2,255
 182ff5c:	100b883a 	mov	r5,r2
 182ff60:	01006134 	movhi	r4,388
 182ff64:	210cc204 	addi	r4,r4,13064
 182ff68:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 182ff6c:	e0bfff17 	ldw	r2,-4(fp)
 182ff70:	108003c3 	ldbu	r2,15(r2)
 182ff74:	10803fcc 	andi	r2,r2,255
 182ff78:	100b883a 	mov	r5,r2
 182ff7c:	01006134 	movhi	r4,388
 182ff80:	210d1504 	addi	r4,r4,13396
 182ff84:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 182ff88:	e0bfff17 	ldw	r2,-4(fp)
 182ff8c:	10800403 	ldbu	r2,16(r2)
 182ff90:	10803fcc 	andi	r2,r2,255
 182ff94:	100b883a 	mov	r5,r2
 182ff98:	01006134 	movhi	r4,388
 182ff9c:	210d1f04 	addi	r4,r4,13436
 182ffa0:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 182ffa4:	e0bfff17 	ldw	r2,-4(fp)
 182ffa8:	10800443 	ldbu	r2,17(r2)
 182ffac:	10803fcc 	andi	r2,r2,255
 182ffb0:	100b883a 	mov	r5,r2
 182ffb4:	01006134 	movhi	r4,388
 182ffb8:	210d2904 	addi	r4,r4,13476
 182ffbc:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 182ffc0:	e0bfff17 	ldw	r2,-4(fp)
 182ffc4:	10800483 	ldbu	r2,18(r2)
 182ffc8:	10803fcc 	andi	r2,r2,255
 182ffcc:	100b883a 	mov	r5,r2
 182ffd0:	01006134 	movhi	r4,388
 182ffd4:	210d3304 	addi	r4,r4,13516
 182ffd8:	182c1980 	call	182c198 <no_printf>
    tse_dprintf(6, "\n");
 182ffdc:	01006134 	movhi	r4,388
 182ffe0:	210b6404 	addi	r4,r4,11664
 182ffe4:	182c1980 	call	182c198 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 182ffe8:	e0bffe83 	ldbu	r2,-6(fp)
 182ffec:	100b883a 	mov	r5,r2
 182fff0:	e13fff17 	ldw	r4,-4(fp)
 182fff4:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 182fff8:	e0bffb17 	ldw	r2,-20(fp)
    
}
 182fffc:	e037883a 	mov	sp,fp
 1830000:	dfc00117 	ldw	ra,4(sp)
 1830004:	df000017 	ldw	fp,0(sp)
 1830008:	dec00204 	addi	sp,sp,8
 183000c:	f800283a 	ret

01830010 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 1830010:	defff804 	addi	sp,sp,-32
 1830014:	dfc00715 	stw	ra,28(sp)
 1830018:	df000615 	stw	fp,24(sp)
 183001c:	df000604 	addi	fp,sp,24
 1830020:	e13ffe15 	stw	r4,-8(fp)
 1830024:	2805883a 	mov	r2,r5
 1830028:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 183002c:	e0bffe17 	ldw	r2,-8(fp)
 1830030:	10800617 	ldw	r2,24(r2)
 1830034:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 1830038:	e0bffb17 	ldw	r2,-20(fp)
 183003c:	10800317 	ldw	r2,12(r2)
 1830040:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 1830044:	e13ffb17 	ldw	r4,-20(fp)
 1830048:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 183004c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 1830050:	e13ffc17 	ldw	r4,-16(fp)
 1830054:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 1830058:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 183005c:	e13ffe17 	ldw	r4,-8(fp)
 1830060:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 1830064:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 1830068:	e0bffe17 	ldw	r2,-8(fp)
 183006c:	10800003 	ldbu	r2,0(r2)
 1830070:	10803fcc 	andi	r2,r2,255
 1830074:	100b883a 	mov	r5,r2
 1830078:	e13ffe17 	ldw	r4,-8(fp)
 183007c:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 1830080:	e0bfff03 	ldbu	r2,-4(fp)
 1830084:	10002d26 	beq	r2,zero,183013c <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 1830088:	01c00044 	movi	r7,1
 183008c:	01800344 	movi	r6,13
 1830090:	014003c4 	movi	r5,15
 1830094:	e13ffe17 	ldw	r4,-8(fp)
 1830098:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 183009c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 18300a0:	e0bffdc3 	ldbu	r2,-9(fp)
 18300a4:	d8800015 	stw	r2,0(sp)
 18300a8:	01c00044 	movi	r7,1
 18300ac:	01800244 	movi	r6,9
 18300b0:	01400244 	movi	r5,9
 18300b4:	e13ffe17 	ldw	r4,-8(fp)
 18300b8:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 18300bc:	e0bffd47 	ldb	r2,-11(fp)
 18300c0:	e0fffd07 	ldb	r3,-12(fp)
 18300c4:	e13ffdc3 	ldbu	r4,-9(fp)
 18300c8:	200f883a 	mov	r7,r4
 18300cc:	180d883a 	mov	r6,r3
 18300d0:	100b883a 	mov	r5,r2
 18300d4:	01006134 	movhi	r4,388
 18300d8:	210d3d04 	addi	r4,r4,13556
 18300dc:	182c1980 	call	182c198 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 18300e0:	01c00044 	movi	r7,1
 18300e4:	01800304 	movi	r6,12
 18300e8:	014003c4 	movi	r5,15
 18300ec:	e13ffe17 	ldw	r4,-8(fp)
 18300f0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 18300f4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 18300f8:	e0bffdc3 	ldbu	r2,-9(fp)
 18300fc:	d8800015 	stw	r2,0(sp)
 1830100:	01c00044 	movi	r7,1
 1830104:	01800204 	movi	r6,8
 1830108:	01400244 	movi	r5,9
 183010c:	e13ffe17 	ldw	r4,-8(fp)
 1830110:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 1830114:	e0bffd47 	ldb	r2,-11(fp)
 1830118:	e0fffd07 	ldb	r3,-12(fp)
 183011c:	e13ffdc3 	ldbu	r4,-9(fp)
 1830120:	200f883a 	mov	r7,r4
 1830124:	180d883a 	mov	r6,r3
 1830128:	100b883a 	mov	r5,r2
 183012c:	01006134 	movhi	r4,388
 1830130:	210d5004 	addi	r4,r4,13632
 1830134:	182c1980 	call	182c198 <no_printf>
 1830138:	00001c06 	br	18301ac <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 183013c:	d8000015 	stw	zero,0(sp)
 1830140:	01c00044 	movi	r7,1
 1830144:	01800244 	movi	r6,9
 1830148:	01400244 	movi	r5,9
 183014c:	e13ffe17 	ldw	r4,-8(fp)
 1830150:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 1830154:	e0bffd47 	ldb	r2,-11(fp)
 1830158:	e0fffd07 	ldb	r3,-12(fp)
 183015c:	000f883a 	mov	r7,zero
 1830160:	180d883a 	mov	r6,r3
 1830164:	100b883a 	mov	r5,r2
 1830168:	01006134 	movhi	r4,388
 183016c:	210d3d04 	addi	r4,r4,13556
 1830170:	182c1980 	call	182c198 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 1830174:	d8000015 	stw	zero,0(sp)
 1830178:	01c00044 	movi	r7,1
 183017c:	01800204 	movi	r6,8
 1830180:	01400244 	movi	r5,9
 1830184:	e13ffe17 	ldw	r4,-8(fp)
 1830188:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 183018c:	e0bffd47 	ldb	r2,-11(fp)
 1830190:	e0fffd07 	ldb	r3,-12(fp)
 1830194:	000f883a 	mov	r7,zero
 1830198:	180d883a 	mov	r6,r3
 183019c:	100b883a 	mov	r5,r2
 18301a0:	01006134 	movhi	r4,388
 18301a4:	210d6304 	addi	r4,r4,13708
 18301a8:	182c1980 	call	182c198 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 18301ac:	e0bffd83 	ldbu	r2,-10(fp)
 18301b0:	100b883a 	mov	r5,r2
 18301b4:	e13ffe17 	ldw	r4,-8(fp)
 18301b8:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 18301bc:	0005883a 	mov	r2,zero
}
 18301c0:	e037883a 	mov	sp,fp
 18301c4:	dfc00117 	ldw	ra,4(sp)
 18301c8:	df000017 	ldw	fp,0(sp)
 18301cc:	dec00204 	addi	sp,sp,8
 18301d0:	f800283a 	ret

018301d4 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 18301d4:	defff804 	addi	sp,sp,-32
 18301d8:	dfc00715 	stw	ra,28(sp)
 18301dc:	df000615 	stw	fp,24(sp)
 18301e0:	df000604 	addi	fp,sp,24
 18301e4:	e13ffe15 	stw	r4,-8(fp)
 18301e8:	2805883a 	mov	r2,r5
 18301ec:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 18301f0:	e0bffe17 	ldw	r2,-8(fp)
 18301f4:	10800617 	ldw	r2,24(r2)
 18301f8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 18301fc:	e0bffb17 	ldw	r2,-20(fp)
 1830200:	10800317 	ldw	r2,12(r2)
 1830204:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 1830208:	e13ffb17 	ldw	r4,-20(fp)
 183020c:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 1830210:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 1830214:	e13ffc17 	ldw	r4,-16(fp)
 1830218:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 183021c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 1830220:	e13ffe17 	ldw	r4,-8(fp)
 1830224:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 1830228:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 183022c:	e0bffe17 	ldw	r2,-8(fp)
 1830230:	10800003 	ldbu	r2,0(r2)
 1830234:	10803fcc 	andi	r2,r2,255
 1830238:	100b883a 	mov	r5,r2
 183023c:	e13ffe17 	ldw	r4,-8(fp)
 1830240:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 1830244:	e0bfff03 	ldbu	r2,-4(fp)
 1830248:	10004326 	beq	r2,zero,1830358 <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 183024c:	01c00044 	movi	r7,1
 1830250:	018003c4 	movi	r6,15
 1830254:	01400044 	movi	r5,1
 1830258:	e13ffe17 	ldw	r4,-8(fp)
 183025c:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830260:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 1830264:	e0bffdc3 	ldbu	r2,-9(fp)
 1830268:	d8800015 	stw	r2,0(sp)
 183026c:	01c00044 	movi	r7,1
 1830270:	01800244 	movi	r6,9
 1830274:	01400104 	movi	r5,4
 1830278:	e13ffe17 	ldw	r4,-8(fp)
 183027c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 1830280:	e0bffd47 	ldb	r2,-11(fp)
 1830284:	e0fffd07 	ldb	r3,-12(fp)
 1830288:	e13ffdc3 	ldbu	r4,-9(fp)
 183028c:	200f883a 	mov	r7,r4
 1830290:	180d883a 	mov	r6,r3
 1830294:	100b883a 	mov	r5,r2
 1830298:	01006134 	movhi	r4,388
 183029c:	210d7504 	addi	r4,r4,13780
 18302a0:	182c1980 	call	182c198 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 18302a4:	01c00044 	movi	r7,1
 18302a8:	01800384 	movi	r6,14
 18302ac:	01400044 	movi	r5,1
 18302b0:	e13ffe17 	ldw	r4,-8(fp)
 18302b4:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 18302b8:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 18302bc:	e0bffdc3 	ldbu	r2,-9(fp)
 18302c0:	d8800015 	stw	r2,0(sp)
 18302c4:	01c00044 	movi	r7,1
 18302c8:	01800204 	movi	r6,8
 18302cc:	01400104 	movi	r5,4
 18302d0:	e13ffe17 	ldw	r4,-8(fp)
 18302d4:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 18302d8:	e0bffd47 	ldb	r2,-11(fp)
 18302dc:	e0fffd07 	ldb	r3,-12(fp)
 18302e0:	e13ffdc3 	ldbu	r4,-9(fp)
 18302e4:	200f883a 	mov	r7,r4
 18302e8:	180d883a 	mov	r6,r3
 18302ec:	100b883a 	mov	r5,r2
 18302f0:	01006134 	movhi	r4,388
 18302f4:	210d8504 	addi	r4,r4,13844
 18302f8:	182c1980 	call	182c198 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 18302fc:	01c00044 	movi	r7,1
 1830300:	01800344 	movi	r6,13
 1830304:	01400044 	movi	r5,1
 1830308:	e13ffe17 	ldw	r4,-8(fp)
 183030c:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830310:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 1830314:	e0bffdc3 	ldbu	r2,-9(fp)
 1830318:	d8800015 	stw	r2,0(sp)
 183031c:	01c00044 	movi	r7,1
 1830320:	018001c4 	movi	r6,7
 1830324:	01400104 	movi	r5,4
 1830328:	e13ffe17 	ldw	r4,-8(fp)
 183032c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 1830330:	e0bffd47 	ldb	r2,-11(fp)
 1830334:	e0fffd07 	ldb	r3,-12(fp)
 1830338:	e13ffdc3 	ldbu	r4,-9(fp)
 183033c:	200f883a 	mov	r7,r4
 1830340:	180d883a 	mov	r6,r3
 1830344:	100b883a 	mov	r5,r2
 1830348:	01006134 	movhi	r4,388
 183034c:	210d9804 	addi	r4,r4,13920
 1830350:	182c1980 	call	182c198 <no_printf>
 1830354:	00002a06 	br	1830400 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 1830358:	d8000015 	stw	zero,0(sp)
 183035c:	01c00044 	movi	r7,1
 1830360:	01800244 	movi	r6,9
 1830364:	01400104 	movi	r5,4
 1830368:	e13ffe17 	ldw	r4,-8(fp)
 183036c:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 1830370:	e0bffd47 	ldb	r2,-11(fp)
 1830374:	e0fffd07 	ldb	r3,-12(fp)
 1830378:	000f883a 	mov	r7,zero
 183037c:	180d883a 	mov	r6,r3
 1830380:	100b883a 	mov	r5,r2
 1830384:	01006134 	movhi	r4,388
 1830388:	210d7504 	addi	r4,r4,13780
 183038c:	182c1980 	call	182c198 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 1830390:	d8000015 	stw	zero,0(sp)
 1830394:	01c00044 	movi	r7,1
 1830398:	01800204 	movi	r6,8
 183039c:	01400104 	movi	r5,4
 18303a0:	e13ffe17 	ldw	r4,-8(fp)
 18303a4:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 18303a8:	e0bffd47 	ldb	r2,-11(fp)
 18303ac:	e0fffd07 	ldb	r3,-12(fp)
 18303b0:	000f883a 	mov	r7,zero
 18303b4:	180d883a 	mov	r6,r3
 18303b8:	100b883a 	mov	r5,r2
 18303bc:	01006134 	movhi	r4,388
 18303c0:	210d8504 	addi	r4,r4,13844
 18303c4:	182c1980 	call	182c198 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 18303c8:	d8000015 	stw	zero,0(sp)
 18303cc:	01c00044 	movi	r7,1
 18303d0:	018001c4 	movi	r6,7
 18303d4:	01400104 	movi	r5,4
 18303d8:	e13ffe17 	ldw	r4,-8(fp)
 18303dc:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 18303e0:	e0bffd47 	ldb	r2,-11(fp)
 18303e4:	e0fffd07 	ldb	r3,-12(fp)
 18303e8:	000f883a 	mov	r7,zero
 18303ec:	180d883a 	mov	r6,r3
 18303f0:	100b883a 	mov	r5,r2
 18303f4:	01006134 	movhi	r4,388
 18303f8:	210d9804 	addi	r4,r4,13920
 18303fc:	182c1980 	call	182c198 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 1830400:	e0bffd83 	ldbu	r2,-10(fp)
 1830404:	100b883a 	mov	r5,r2
 1830408:	e13ffe17 	ldw	r4,-8(fp)
 183040c:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 1830410:	0005883a 	mov	r2,zero
}
 1830414:	e037883a 	mov	sp,fp
 1830418:	dfc00117 	ldw	ra,4(sp)
 183041c:	df000017 	ldw	fp,0(sp)
 1830420:	dec00204 	addi	sp,sp,8
 1830424:	f800283a 	ret

01830428 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 1830428:	defff504 	addi	sp,sp,-44
 183042c:	dfc00a15 	stw	ra,40(sp)
 1830430:	df000915 	stw	fp,36(sp)
 1830434:	df000904 	addi	fp,sp,36
 1830438:	e13ffe15 	stw	r4,-8(fp)
 183043c:	2805883a 	mov	r2,r5
 1830440:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 1830444:	e0bffe17 	ldw	r2,-8(fp)
 1830448:	10800617 	ldw	r2,24(r2)
 183044c:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 1830450:	e0bff817 	ldw	r2,-32(fp)
 1830454:	10800317 	ldw	r2,12(r2)
 1830458:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 183045c:	e13ff817 	ldw	r4,-32(fp)
 1830460:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 1830464:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 1830468:	e13ff917 	ldw	r4,-28(fp)
 183046c:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 1830470:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 1830474:	e13ffe17 	ldw	r4,-8(fp)
 1830478:	182e0d00 	call	182e0d0 <alt_tse_phy_rd_mdio_addr>
 183047c:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 1830480:	e0bffe17 	ldw	r2,-8(fp)
 1830484:	10800003 	ldbu	r2,0(r2)
 1830488:	10803fcc 	andi	r2,r2,255
 183048c:	100b883a 	mov	r5,r2
 1830490:	e13ffe17 	ldw	r4,-8(fp)
 1830494:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 1830498:	e0bfff03 	ldbu	r2,-4(fp)
 183049c:	10002926 	beq	r2,zero,1830544 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 18304a0:	01c00044 	movi	r7,1
 18304a4:	01800304 	movi	r6,12
 18304a8:	01400044 	movi	r5,1
 18304ac:	e13ffe17 	ldw	r4,-8(fp)
 18304b0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 18304b4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 18304b8:	e0bffd03 	ldbu	r2,-12(fp)
 18304bc:	d8800015 	stw	r2,0(sp)
 18304c0:	01c00044 	movi	r7,1
 18304c4:	01800184 	movi	r6,6
 18304c8:	01400104 	movi	r5,4
 18304cc:	e13ffe17 	ldw	r4,-8(fp)
 18304d0:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 18304d4:	e0bffd03 	ldbu	r2,-12(fp)
 18304d8:	100f883a 	mov	r7,r2
 18304dc:	e1bffa17 	ldw	r6,-24(fp)
 18304e0:	e17ffb17 	ldw	r5,-20(fp)
 18304e4:	01006134 	movhi	r4,388
 18304e8:	210dab04 	addi	r4,r4,13996
 18304ec:	182c1980 	call	182c198 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 18304f0:	01c00044 	movi	r7,1
 18304f4:	018002c4 	movi	r6,11
 18304f8:	01400044 	movi	r5,1
 18304fc:	e13ffe17 	ldw	r4,-8(fp)
 1830500:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830504:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 1830508:	e0bffd03 	ldbu	r2,-12(fp)
 183050c:	d8800015 	stw	r2,0(sp)
 1830510:	01c00044 	movi	r7,1
 1830514:	01800144 	movi	r6,5
 1830518:	01400104 	movi	r5,4
 183051c:	e13ffe17 	ldw	r4,-8(fp)
 1830520:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 1830524:	e0bffd03 	ldbu	r2,-12(fp)
 1830528:	100f883a 	mov	r7,r2
 183052c:	e1bffa17 	ldw	r6,-24(fp)
 1830530:	e17ffb17 	ldw	r5,-20(fp)
 1830534:	01006134 	movhi	r4,388
 1830538:	210dbe04 	addi	r4,r4,14072
 183053c:	182c1980 	call	182c198 <no_printf>
 1830540:	00001806 	br	18305a4 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 1830544:	d8000015 	stw	zero,0(sp)
 1830548:	01c00044 	movi	r7,1
 183054c:	01800184 	movi	r6,6
 1830550:	01400104 	movi	r5,4
 1830554:	e13ffe17 	ldw	r4,-8(fp)
 1830558:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 183055c:	000f883a 	mov	r7,zero
 1830560:	e1bffa17 	ldw	r6,-24(fp)
 1830564:	e17ffb17 	ldw	r5,-20(fp)
 1830568:	01006134 	movhi	r4,388
 183056c:	210dab04 	addi	r4,r4,13996
 1830570:	182c1980 	call	182c198 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 1830574:	d8000015 	stw	zero,0(sp)
 1830578:	01c00044 	movi	r7,1
 183057c:	01800144 	movi	r6,5
 1830580:	01400104 	movi	r5,4
 1830584:	e13ffe17 	ldw	r4,-8(fp)
 1830588:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 183058c:	000f883a 	mov	r7,zero
 1830590:	e1bffa17 	ldw	r6,-24(fp)
 1830594:	e17ffb17 	ldw	r5,-20(fp)
 1830598:	01006134 	movhi	r4,388
 183059c:	210dbe04 	addi	r4,r4,14072
 18305a0:	182c1980 	call	182c198 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 18305a4:	e0bffc17 	ldw	r2,-16(fp)
 18305a8:	10803fcc 	andi	r2,r2,255
 18305ac:	100b883a 	mov	r5,r2
 18305b0:	e13ffe17 	ldw	r4,-8(fp)
 18305b4:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 18305b8:	0005883a 	mov	r2,zero
}
 18305bc:	e037883a 	mov	sp,fp
 18305c0:	dfc00117 	ldw	ra,4(sp)
 18305c4:	df000017 	ldw	fp,0(sp)
 18305c8:	dec00204 	addi	sp,sp,8
 18305cc:	f800283a 	ret

018305d0 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 18305d0:	defff604 	addi	sp,sp,-40
 18305d4:	dfc00915 	stw	ra,36(sp)
 18305d8:	df000815 	stw	fp,32(sp)
 18305dc:	df000804 	addi	fp,sp,32
 18305e0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 18305e4:	00800044 	movi	r2,1
 18305e8:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 18305ec:	00800044 	movi	r2,1
 18305f0:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 18305f4:	00800044 	movi	r2,1
 18305f8:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 18305fc:	00800044 	movi	r2,1
 1830600:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 1830604:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 1830608:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 183060c:	e13fff17 	ldw	r4,-4(fp)
 1830610:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 1830614:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 1830618:	e03ff815 	stw	zero,-32(fp)
 183061c:	00001c06 	br	1830690 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 1830620:	e0ffff17 	ldw	r3,-4(fp)
 1830624:	e0bff817 	ldw	r2,-32(fp)
 1830628:	10800044 	addi	r2,r2,1
 183062c:	1085883a 	add	r2,r2,r2
 1830630:	1085883a 	add	r2,r2,r2
 1830634:	1885883a 	add	r2,r3,r2
 1830638:	10800017 	ldw	r2,0(r2)
 183063c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 1830640:	e0bffc17 	ldw	r2,-16(fp)
 1830644:	10800117 	ldw	r2,4(r2)
 1830648:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 183064c:	e0bffd17 	ldw	r2,-12(fp)
 1830650:	10000926 	beq	r2,zero,1830678 <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 1830654:	01400044 	movi	r5,1
 1830658:	e13ffd17 	ldw	r4,-12(fp)
 183065c:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 1830660:	01400044 	movi	r5,1
 1830664:	e13ffd17 	ldw	r4,-12(fp)
 1830668:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 183066c:	01400044 	movi	r5,1
 1830670:	e13ffd17 	ldw	r4,-12(fp)
 1830674:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 1830678:	01006134 	movhi	r4,388
 183067c:	210b6404 	addi	r4,r4,11664
 1830680:	182c1980 	call	182c198 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 1830684:	e0bff817 	ldw	r2,-32(fp)
 1830688:	10800044 	addi	r2,r2,1
 183068c:	e0bff815 	stw	r2,-32(fp)
 1830690:	e0bfff17 	ldw	r2,-4(fp)
 1830694:	10800003 	ldbu	r2,0(r2)
 1830698:	10803fcc 	andi	r2,r2,255
 183069c:	e0fff817 	ldw	r3,-32(fp)
 18306a0:	18bfdf16 	blt	r3,r2,1830620 <__ram_exceptions_end+0xff8201dc>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 18306a4:	e03ff815 	stw	zero,-32(fp)
 18306a8:	00005606 	br	1830804 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 18306ac:	e0ffff17 	ldw	r3,-4(fp)
 18306b0:	e0bff817 	ldw	r2,-32(fp)
 18306b4:	10800044 	addi	r2,r2,1
 18306b8:	1085883a 	add	r2,r2,r2
 18306bc:	1085883a 	add	r2,r2,r2
 18306c0:	1885883a 	add	r2,r3,r2
 18306c4:	10800017 	ldw	r2,0(r2)
 18306c8:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 18306cc:	e0bffc17 	ldw	r2,-16(fp)
 18306d0:	10800117 	ldw	r2,4(r2)
 18306d4:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 18306d8:	e0bffd17 	ldw	r2,-12(fp)
 18306dc:	10004326 	beq	r2,zero,18307ec <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 18306e0:	e13ffd17 	ldw	r4,-12(fp)
 18306e4:	182fa7c0 	call	182fa7c <alt_tse_phy_get_cap>
 18306e8:	1000421e 	bne	r2,zero,18307f4 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 18306ec:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 18306f0:	e0bffc17 	ldw	r2,-16(fp)
 18306f4:	10800003 	ldbu	r2,0(r2)
 18306f8:	10803fcc 	andi	r2,r2,255
 18306fc:	10800058 	cmpnei	r2,r2,1
 1830700:	1000021e 	bne	r2,zero,183070c <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 1830704:	e03ff905 	stb	zero,-28(fp)
 1830708:	00000706 	br	1830728 <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 183070c:	e0bffc17 	ldw	r2,-16(fp)
 1830710:	10800003 	ldbu	r2,0(r2)
 1830714:	10803fcc 	andi	r2,r2,255
 1830718:	10800098 	cmpnei	r2,r2,2
 183071c:	1000021e 	bne	r2,zero,1830728 <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 1830720:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 1830724:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 1830728:	e0bffd17 	ldw	r2,-12(fp)
 183072c:	10c000c3 	ldbu	r3,3(r2)
 1830730:	e0bffd17 	ldw	r2,-12(fp)
 1830734:	10800303 	ldbu	r2,12(r2)
 1830738:	1884703a 	and	r2,r3,r2
 183073c:	1007883a 	mov	r3,r2
 1830740:	e0bff903 	ldbu	r2,-28(fp)
 1830744:	1884703a 	and	r2,r3,r2
 1830748:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 183074c:	e0bffd17 	ldw	r2,-12(fp)
 1830750:	10c00183 	ldbu	r3,6(r2)
 1830754:	e0bffd17 	ldw	r2,-12(fp)
 1830758:	108003c3 	ldbu	r2,15(r2)
 183075c:	1884703a 	and	r2,r3,r2
 1830760:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 1830764:	e0bffd17 	ldw	r2,-12(fp)
 1830768:	10c001c3 	ldbu	r3,7(r2)
 183076c:	e0bffd17 	ldw	r2,-12(fp)
 1830770:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 1830774:	1884703a 	and	r2,r3,r2
 1830778:	2084b03a 	or	r2,r4,r2
 183077c:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 1830780:	e0bffd17 	ldw	r2,-12(fp)
 1830784:	10c00143 	ldbu	r3,5(r2)
 1830788:	e0bffd17 	ldw	r2,-12(fp)
 183078c:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 1830790:	1884703a 	and	r2,r3,r2
 1830794:	2084b03a 	or	r2,r4,r2
 1830798:	1007883a 	mov	r3,r2
 183079c:	e0bff943 	ldbu	r2,-27(fp)
 18307a0:	1884703a 	and	r2,r3,r2
 18307a4:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 18307a8:	e0bffd17 	ldw	r2,-12(fp)
 18307ac:	10c00283 	ldbu	r3,10(r2)
 18307b0:	e0bffd17 	ldw	r2,-12(fp)
 18307b4:	10800443 	ldbu	r2,17(r2)
 18307b8:	1884703a 	and	r2,r3,r2
 18307bc:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 18307c0:	e0bffd17 	ldw	r2,-12(fp)
 18307c4:	10c002c3 	ldbu	r3,11(r2)
 18307c8:	e0bffd17 	ldw	r2,-12(fp)
 18307cc:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 18307d0:	1884703a 	and	r2,r3,r2
 18307d4:	2084b03a 	or	r2,r4,r2
 18307d8:	1007883a 	mov	r3,r2
 18307dc:	e0bff983 	ldbu	r2,-26(fp)
 18307e0:	1884703a 	and	r2,r3,r2
 18307e4:	e0bff985 	stb	r2,-26(fp)
 18307e8:	00000306 	br	18307f8 <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 18307ec:	0001883a 	nop
 18307f0:	00000106 	br	18307f8 <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 18307f4:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 18307f8:	e0bff817 	ldw	r2,-32(fp)
 18307fc:	10800044 	addi	r2,r2,1
 1830800:	e0bff815 	stw	r2,-32(fp)
 1830804:	e0bfff17 	ldw	r2,-4(fp)
 1830808:	10800003 	ldbu	r2,0(r2)
 183080c:	10803fcc 	andi	r2,r2,255
 1830810:	e0fff817 	ldw	r3,-32(fp)
 1830814:	18bfa516 	blt	r3,r2,18306ac <__ram_exceptions_end+0xff820268>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 1830818:	e0bffb03 	ldbu	r2,-20(fp)
 183081c:	10800058 	cmpnei	r2,r2,1
 1830820:	1000081e 	bne	r2,zero,1830844 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 1830824:	00bfffc4 	movi	r2,-1
 1830828:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 183082c:	e0bffe07 	ldb	r2,-8(fp)
 1830830:	100b883a 	mov	r5,r2
 1830834:	01006134 	movhi	r4,388
 1830838:	210dd104 	addi	r4,r4,14148
 183083c:	1800c180 	call	1800c18 <printf>
 1830840:	00002706 	br	18308e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 1830844:	e0bff903 	ldbu	r2,-28(fp)
 1830848:	10000926 	beq	r2,zero,1830870 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 183084c:	00800084 	movi	r2,2
 1830850:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 1830854:	e0bffe07 	ldb	r2,-8(fp)
 1830858:	0180fa04 	movi	r6,1000
 183085c:	100b883a 	mov	r5,r2
 1830860:	01006134 	movhi	r4,388
 1830864:	210de304 	addi	r4,r4,14220
 1830868:	1800c180 	call	1800c18 <printf>
 183086c:	00001c06 	br	18308e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 1830870:	e0bff943 	ldbu	r2,-27(fp)
 1830874:	10000926 	beq	r2,zero,183089c <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 1830878:	00800044 	movi	r2,1
 183087c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 1830880:	e0bffe07 	ldb	r2,-8(fp)
 1830884:	01801904 	movi	r6,100
 1830888:	100b883a 	mov	r5,r2
 183088c:	01006134 	movhi	r4,388
 1830890:	210de304 	addi	r4,r4,14220
 1830894:	1800c180 	call	1800c18 <printf>
 1830898:	00001106 	br	18308e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 183089c:	e0bff983 	ldbu	r2,-26(fp)
 18308a0:	10000826 	beq	r2,zero,18308c4 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 18308a4:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 18308a8:	e0bffe07 	ldb	r2,-8(fp)
 18308ac:	01800284 	movi	r6,10
 18308b0:	100b883a 	mov	r5,r2
 18308b4:	01006134 	movhi	r4,388
 18308b8:	210de304 	addi	r4,r4,14220
 18308bc:	1800c180 	call	1800c18 <printf>
 18308c0:	00000706 	br	18308e0 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 18308c4:	00bfffc4 	movi	r2,-1
 18308c8:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 18308cc:	e0bffe07 	ldb	r2,-8(fp)
 18308d0:	100b883a 	mov	r5,r2
 18308d4:	01006134 	movhi	r4,388
 18308d8:	210df004 	addi	r4,r4,14272
 18308dc:	1800c180 	call	1800c18 <printf>

    return common_speed;
 18308e0:	e0bffa17 	ldw	r2,-24(fp)
}
 18308e4:	e037883a 	mov	sp,fp
 18308e8:	dfc00117 	ldw	ra,4(sp)
 18308ec:	df000017 	ldw	fp,0(sp)
 18308f0:	dec00204 	addi	sp,sp,8
 18308f4:	f800283a 	ret

018308f8 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 18308f8:	defff004 	addi	sp,sp,-64
 18308fc:	dfc00f15 	stw	ra,60(sp)
 1830900:	df000e15 	stw	fp,56(sp)
 1830904:	dc400d15 	stw	r17,52(sp)
 1830908:	dc000c15 	stw	r16,48(sp)
 183090c:	df000e04 	addi	fp,sp,56
 1830910:	e13ffc15 	stw	r4,-16(fp)
 1830914:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 1830918:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 183091c:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 1830920:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 1830924:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 1830928:	e13ffc17 	ldw	r4,-16(fp)
 183092c:	182d31c0 	call	182d31c <alt_tse_get_mac_group_index>
 1830930:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 1830934:	e0bffc17 	ldw	r2,-16(fp)
 1830938:	10800117 	ldw	r2,4(r2)
 183093c:	10800217 	ldw	r2,8(r2)
 1830940:	10800017 	ldw	r2,0(r2)
 1830944:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 1830948:	e0bff917 	ldw	r2,-28(fp)
 183094c:	10801004 	addi	r2,r2,64
 1830950:	10800037 	ldwio	r2,0(r2)
 1830954:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 1830958:	e0bffd17 	ldw	r2,-12(fp)
 183095c:	10000316 	blt	r2,zero,183096c <alt_tse_phy_set_common_speed+0x74>
 1830960:	e0bffd17 	ldw	r2,-12(fp)
 1830964:	108000d0 	cmplti	r2,r2,3
 1830968:	10000c1e 	bne	r2,zero,183099c <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 183096c:	e0bff847 	ldb	r2,-31(fp)
 1830970:	e1bffd17 	ldw	r6,-12(fp)
 1830974:	100b883a 	mov	r5,r2
 1830978:	01006134 	movhi	r4,388
 183097c:	210dfd04 	addi	r4,r4,14324
 1830980:	1800c180 	call	1800c18 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 1830984:	e0bff917 	ldw	r2,-28(fp)
 1830988:	10801004 	addi	r2,r2,64
 183098c:	e0fffa17 	ldw	r3,-24(fp)
 1830990:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 1830994:	00bfffc4 	movi	r2,-1
 1830998:	0000fd06 	br	1830d90 <alt_tse_phy_set_common_speed+0x498>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 183099c:	e03ff315 	stw	zero,-52(fp)
 18309a0:	0000db06 	br	1830d10 <alt_tse_phy_set_common_speed+0x418>
        pmac_info = pmac_group->pmac_info[i];
 18309a4:	e0fffc17 	ldw	r3,-16(fp)
 18309a8:	e0bff317 	ldw	r2,-52(fp)
 18309ac:	10800044 	addi	r2,r2,1
 18309b0:	1085883a 	add	r2,r2,r2
 18309b4:	1085883a 	add	r2,r2,r2
 18309b8:	1885883a 	add	r2,r3,r2
 18309bc:	10800017 	ldw	r2,0(r2)
 18309c0:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 18309c4:	e13ff617 	ldw	r4,-40(fp)
 18309c8:	182d3900 	call	182d390 <alt_tse_get_mac_info_index>
 18309cc:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 18309d0:	e0bff617 	ldw	r2,-40(fp)
 18309d4:	10800117 	ldw	r2,4(r2)
 18309d8:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 18309dc:	e0bff517 	ldw	r2,-44(fp)
 18309e0:	1000c726 	beq	r2,zero,1830d00 <alt_tse_phy_set_common_speed+0x408>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 18309e4:	e0bff617 	ldw	r2,-40(fp)
 18309e8:	10800217 	ldw	r2,8(r2)
 18309ec:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 18309f0:	e0bff517 	ldw	r2,-44(fp)
 18309f4:	10800003 	ldbu	r2,0(r2)
 18309f8:	10803fcc 	andi	r2,r2,255
 18309fc:	100b883a 	mov	r5,r2
 1830a00:	e13ff517 	ldw	r4,-44(fp)
 1830a04:	182e1180 	call	182e118 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 1830a08:	e0bff517 	ldw	r2,-44(fp)
 1830a0c:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 1830a10:	10803fcc 	andi	r2,r2,255
 1830a14:	10000c1e 	bne	r2,zero,1830a48 <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 1830a18:	e0bff517 	ldw	r2,-44(fp)
 1830a1c:	10800103 	ldbu	r2,4(r2)
 1830a20:	10803fcc 	andi	r2,r2,255
 1830a24:	1000081e 	bne	r2,zero,1830a48 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 1830a28:	e0bff517 	ldw	r2,-44(fp)
 1830a2c:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 1830a30:	10803fcc 	andi	r2,r2,255
 1830a34:	1000041e 	bne	r2,zero,1830a48 <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 1830a38:	e0bff517 	ldw	r2,-44(fp)
 1830a3c:	10800083 	ldbu	r2,2(r2)
 1830a40:	10803fcc 	andi	r2,r2,255
 1830a44:	10000226 	beq	r2,zero,1830a50 <alt_tse_phy_set_common_speed+0x158>
 1830a48:	00800044 	movi	r2,1
 1830a4c:	00000106 	br	1830a54 <alt_tse_phy_set_common_speed+0x15c>
 1830a50:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 1830a54:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 1830a58:	e0bffb03 	ldbu	r2,-20(fp)
 1830a5c:	1000101e 	bne	r2,zero,1830aa0 <alt_tse_phy_set_common_speed+0x1a8>
 1830a60:	e0bffd17 	ldw	r2,-12(fp)
 1830a64:	10800098 	cmpnei	r2,r2,2
 1830a68:	10000d1e 	bne	r2,zero,1830aa0 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 1830a6c:	e0bff847 	ldb	r2,-31(fp)
 1830a70:	e0fff807 	ldb	r3,-32(fp)
 1830a74:	180d883a 	mov	r6,r3
 1830a78:	100b883a 	mov	r5,r2
 1830a7c:	01006134 	movhi	r4,388
 1830a80:	210e1104 	addi	r4,r4,14404
 1830a84:	1800c180 	call	1800c18 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 1830a88:	e0bff917 	ldw	r2,-28(fp)
 1830a8c:	10801004 	addi	r2,r2,64
 1830a90:	e0fffa17 	ldw	r3,-24(fp)
 1830a94:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 1830a98:	00bfffc4 	movi	r2,-1
 1830a9c:	0000bc06 	br	1830d90 <alt_tse_phy_set_common_speed+0x498>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 1830aa0:	01c00044 	movi	r7,1
 1830aa4:	018000c4 	movi	r6,3
 1830aa8:	01400044 	movi	r5,1
 1830aac:	e13ff517 	ldw	r4,-44(fp)
 1830ab0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830ab4:	1000141e 	bne	r2,zero,1830b08 <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 1830ab8:	e0bffb03 	ldbu	r2,-20(fp)
 1830abc:	10000926 	beq	r2,zero,1830ae4 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 1830ac0:	e0bffd17 	ldw	r2,-12(fp)
 1830ac4:	1005d07a 	srai	r2,r2,1
 1830ac8:	10bfffcc 	andi	r2,r2,65535
 1830acc:	d8800015 	stw	r2,0(sp)
 1830ad0:	01c00044 	movi	r7,1
 1830ad4:	01800184 	movi	r6,6
 1830ad8:	000b883a 	mov	r5,zero
 1830adc:	e13ff517 	ldw	r4,-44(fp)
 1830ae0:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 1830ae4:	e0bffd17 	ldw	r2,-12(fp)
 1830ae8:	10bfffcc 	andi	r2,r2,65535
 1830aec:	d8800015 	stw	r2,0(sp)
 1830af0:	01c00044 	movi	r7,1
 1830af4:	01800344 	movi	r6,13
 1830af8:	000b883a 	mov	r5,zero
 1830afc:	e13ff517 	ldw	r4,-44(fp)
 1830b00:	182e1700 	call	182e170 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 1830b04:	00007f06 	br	1830d04 <alt_tse_phy_set_common_speed+0x40c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 1830b08:	e0bffd17 	ldw	r2,-12(fp)
 1830b0c:	10800098 	cmpnei	r2,r2,2
 1830b10:	10000a1e 	bne	r2,zero,1830b3c <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 1830b14:	01400044 	movi	r5,1
 1830b18:	e13ff517 	ldw	r4,-44(fp)
 1830b1c:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 1830b20:	01400044 	movi	r5,1
 1830b24:	e13ff517 	ldw	r4,-44(fp)
 1830b28:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 1830b2c:	01400044 	movi	r5,1
 1830b30:	e13ff517 	ldw	r4,-44(fp)
 1830b34:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
 1830b38:	00002206 	br	1830bc4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 1830b3c:	e0bffd17 	ldw	r2,-12(fp)
 1830b40:	10800058 	cmpnei	r2,r2,1
 1830b44:	10000a1e 	bne	r2,zero,1830b70 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 1830b48:	000b883a 	mov	r5,zero
 1830b4c:	e13ff517 	ldw	r4,-44(fp)
 1830b50:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 1830b54:	01400044 	movi	r5,1
 1830b58:	e13ff517 	ldw	r4,-44(fp)
 1830b5c:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 1830b60:	01400044 	movi	r5,1
 1830b64:	e13ff517 	ldw	r4,-44(fp)
 1830b68:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
 1830b6c:	00001506 	br	1830bc4 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 1830b70:	e0bffd17 	ldw	r2,-12(fp)
 1830b74:	10000a1e 	bne	r2,zero,1830ba0 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 1830b78:	000b883a 	mov	r5,zero
 1830b7c:	e13ff517 	ldw	r4,-44(fp)
 1830b80:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 1830b84:	000b883a 	mov	r5,zero
 1830b88:	e13ff517 	ldw	r4,-44(fp)
 1830b8c:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 1830b90:	01400044 	movi	r5,1
 1830b94:	e13ff517 	ldw	r4,-44(fp)
 1830b98:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
 1830b9c:	00000906 	br	1830bc4 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 1830ba0:	000b883a 	mov	r5,zero
 1830ba4:	e13ff517 	ldw	r4,-44(fp)
 1830ba8:	18300100 	call	1830010 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 1830bac:	000b883a 	mov	r5,zero
 1830bb0:	e13ff517 	ldw	r4,-44(fp)
 1830bb4:	18301d40 	call	18301d4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 1830bb8:	000b883a 	mov	r5,zero
 1830bbc:	e13ff517 	ldw	r4,-44(fp)
 1830bc0:	18304280 	call	1830428 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 1830bc4:	01c00044 	movi	r7,1
 1830bc8:	01800144 	movi	r6,5
 1830bcc:	01400044 	movi	r5,1
 1830bd0:	e13ff517 	ldw	r4,-44(fp)
 1830bd4:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830bd8:	10800058 	cmpnei	r2,r2,1
 1830bdc:	10003a1e 	bne	r2,zero,1830cc8 <alt_tse_phy_set_common_speed+0x3d0>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 1830be0:	e0bffb03 	ldbu	r2,-20(fp)
 1830be4:	10000f26 	beq	r2,zero,1830c24 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 1830be8:	e0bff517 	ldw	r2,-44(fp)
 1830bec:	10800517 	ldw	r2,20(r2)
 1830bf0:	10801583 	ldbu	r2,86(r2)
 1830bf4:	10c03fcc 	andi	r3,r2,255
 1830bf8:	e0bff517 	ldw	r2,-44(fp)
 1830bfc:	10800517 	ldw	r2,20(r2)
 1830c00:	108015c3 	ldbu	r2,87(r2)
 1830c04:	10803fcc 	andi	r2,r2,255
 1830c08:	01c00084 	movi	r7,2
 1830c0c:	100d883a 	mov	r6,r2
 1830c10:	180b883a 	mov	r5,r3
 1830c14:	e13ff517 	ldw	r4,-44(fp)
 1830c18:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830c1c:	e0bff405 	stb	r2,-48(fp)
 1830c20:	00000e06 	br	1830c5c <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 1830c24:	e0bff517 	ldw	r2,-44(fp)
 1830c28:	10800517 	ldw	r2,20(r2)
 1830c2c:	10801583 	ldbu	r2,86(r2)
 1830c30:	10c03fcc 	andi	r3,r2,255
 1830c34:	e0bff517 	ldw	r2,-44(fp)
 1830c38:	10800517 	ldw	r2,20(r2)
 1830c3c:	108015c3 	ldbu	r2,87(r2)
 1830c40:	10803fcc 	andi	r2,r2,255
 1830c44:	01c00044 	movi	r7,1
 1830c48:	100d883a 	mov	r6,r2
 1830c4c:	180b883a 	mov	r5,r3
 1830c50:	e13ff517 	ldw	r4,-44(fp)
 1830c54:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830c58:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 1830c5c:	e0fff403 	ldbu	r3,-48(fp)
 1830c60:	e0bffd17 	ldw	r2,-12(fp)
 1830c64:	18800326 	beq	r3,r2,1830c74 <alt_tse_phy_set_common_speed+0x37c>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 1830c68:	017e0034 	movhi	r5,63488
 1830c6c:	e13ff517 	ldw	r4,-44(fp)
 1830c70:	182f7600 	call	182f760 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 1830c74:	e0bff517 	ldw	r2,-44(fp)
 1830c78:	10800517 	ldw	r2,20(r2)
 1830c7c:	10801583 	ldbu	r2,86(r2)
 1830c80:	10c03fcc 	andi	r3,r2,255
 1830c84:	e0bff517 	ldw	r2,-44(fp)
 1830c88:	10800517 	ldw	r2,20(r2)
 1830c8c:	10801603 	ldbu	r2,88(r2)
 1830c90:	10803fcc 	andi	r2,r2,255
 1830c94:	01c00044 	movi	r7,1
 1830c98:	100d883a 	mov	r6,r2
 1830c9c:	180b883a 	mov	r5,r3
 1830ca0:	e13ff517 	ldw	r4,-44(fp)
 1830ca4:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830ca8:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 1830cac:	e0bff717 	ldw	r2,-36(fp)
 1830cb0:	10800017 	ldw	r2,0(r2)
 1830cb4:	1007883a 	mov	r3,r2
 1830cb8:	e0bffb43 	ldbu	r2,-19(fp)
 1830cbc:	100b883a 	mov	r5,r2
 1830cc0:	1809883a 	mov	r4,r3
 1830cc4:	182d5c80 	call	182d5c8 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 1830cc8:	e43ff847 	ldb	r16,-31(fp)
 1830ccc:	e47ff807 	ldb	r17,-32(fp)
 1830cd0:	01c00404 	movi	r7,16
 1830cd4:	000d883a 	mov	r6,zero
 1830cd8:	01400044 	movi	r5,1
 1830cdc:	e13ff517 	ldw	r4,-44(fp)
 1830ce0:	182e2980 	call	182e298 <alt_tse_phy_rd_mdio_reg>
 1830ce4:	100f883a 	mov	r7,r2
 1830ce8:	880d883a 	mov	r6,r17
 1830cec:	800b883a 	mov	r5,r16
 1830cf0:	01006134 	movhi	r4,388
 1830cf4:	210e2804 	addi	r4,r4,14496
 1830cf8:	1800c180 	call	1800c18 <printf>
 1830cfc:	00000106 	br	1830d04 <alt_tse_phy_set_common_speed+0x40c>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 1830d00:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 1830d04:	e0bff317 	ldw	r2,-52(fp)
 1830d08:	10800044 	addi	r2,r2,1
 1830d0c:	e0bff315 	stw	r2,-52(fp)
 1830d10:	e0bffc17 	ldw	r2,-16(fp)
 1830d14:	10800003 	ldbu	r2,0(r2)
 1830d18:	10803fcc 	andi	r2,r2,255
 1830d1c:	e0fff317 	ldw	r3,-52(fp)
 1830d20:	18bf2016 	blt	r3,r2,18309a4 <__ram_exceptions_end+0xff820560>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 1830d24:	e0fff847 	ldb	r3,-31(fp)
 1830d28:	e0bffd17 	ldw	r2,-12(fp)
 1830d2c:	108000a0 	cmpeqi	r2,r2,2
 1830d30:	1000071e 	bne	r2,zero,1830d50 <alt_tse_phy_set_common_speed+0x458>
 1830d34:	e0bffd17 	ldw	r2,-12(fp)
 1830d38:	10800058 	cmpnei	r2,r2,1
 1830d3c:	1000021e 	bne	r2,zero,1830d48 <alt_tse_phy_set_common_speed+0x450>
 1830d40:	00801904 	movi	r2,100
 1830d44:	00000306 	br	1830d54 <alt_tse_phy_set_common_speed+0x45c>
 1830d48:	00800284 	movi	r2,10
 1830d4c:	00000106 	br	1830d54 <alt_tse_phy_set_common_speed+0x45c>
 1830d50:	0080fa04 	movi	r2,1000
 1830d54:	100d883a 	mov	r6,r2
 1830d58:	180b883a 	mov	r5,r3
 1830d5c:	01006134 	movhi	r4,388
 1830d60:	210e3404 	addi	r4,r4,14544
 1830d64:	1800c180 	call	1800c18 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 1830d68:	e0bffd17 	ldw	r2,-12(fp)
 1830d6c:	10803fcc 	andi	r2,r2,255
 1830d70:	100b883a 	mov	r5,r2
 1830d74:	e13ff917 	ldw	r4,-28(fp)
 1830d78:	182d4e80 	call	182d4e8 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 1830d7c:	e0bff917 	ldw	r2,-28(fp)
 1830d80:	10801004 	addi	r2,r2,64
 1830d84:	e0fffa17 	ldw	r3,-24(fp)
 1830d88:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 1830d8c:	e0bffd17 	ldw	r2,-12(fp)
}
 1830d90:	e6fffe04 	addi	sp,fp,-8
 1830d94:	dfc00317 	ldw	ra,12(sp)
 1830d98:	df000217 	ldw	fp,8(sp)
 1830d9c:	dc400117 	ldw	r17,4(sp)
 1830da0:	dc000017 	ldw	r16,0(sp)
 1830da4:	dec00404 	addi	sp,sp,16
 1830da8:	f800283a 	ret

01830dac <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 1830dac:	defffc04 	addi	sp,sp,-16
 1830db0:	dfc00315 	stw	ra,12(sp)
 1830db4:	df000215 	stw	fp,8(sp)
 1830db8:	df000204 	addi	fp,sp,8
 1830dbc:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & 1<<5) == 0) {
 1830dc0:	e0bfff17 	ldw	r2,-4(fp)
 1830dc4:	1080a104 	addi	r2,r2,644
 1830dc8:	10800037 	ldwio	r2,0(r2)
 1830dcc:	1080080c 	andi	r2,r2,32
 1830dd0:	1000161e 	bne	r2,zero,1830e2c <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 1830dd4:	01006134 	movhi	r4,388
 1830dd8:	210e4504 	addi	r4,r4,14612
 1830ddc:	183d2fc0 	call	183d2fc <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 1830de0:	e0bfff17 	ldw	r2,-4(fp)
 1830de4:	1080a004 	addi	r2,r2,640
 1830de8:	10801004 	addi	r2,r2,64
 1830dec:	00c01e04 	movi	r3,120
 1830df0:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 1830df4:	01006134 	movhi	r4,388
 1830df8:	210e4e04 	addi	r4,r4,14648
 1830dfc:	183d2fc0 	call	183d2fc <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 1830e00:	e0bfff17 	ldw	r2,-4(fp)
 1830e04:	1080a004 	addi	r2,r2,640
 1830e08:	10800037 	ldwio	r2,0(r2)
 1830e0c:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);        
 1830e10:	e0bfff17 	ldw	r2,-4(fp)
 1830e14:	1080a004 	addi	r2,r2,640
 1830e18:	e13ffe0b 	ldhu	r4,-8(fp)
 1830e1c:	00e00004 	movi	r3,-32768
 1830e20:	20c6b03a 	or	r3,r4,r3
 1830e24:	18ffffcc 	andi	r3,r3,65535
 1830e28:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 1830e2c:	0005883a 	mov	r2,zero
}
 1830e30:	e037883a 	mov	sp,fp
 1830e34:	dfc00117 	ldw	ra,4(sp)
 1830e38:	df000017 	ldw	fp,0(sp)
 1830e3c:	dec00204 	addi	sp,sp,8
 1830e40:	f800283a 	ret

01830e44 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 1830e44:	defffc04 	addi	sp,sp,-16
 1830e48:	dfc00315 	stw	ra,12(sp)
 1830e4c:	df000215 	stw	fp,8(sp)
 1830e50:	df000204 	addi	fp,sp,8
 1830e54:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 1830e58:	e0bfff17 	ldw	r2,-4(fp)
 1830e5c:	1080bb04 	addi	r2,r2,748
 1830e60:	10800037 	ldwio	r2,0(r2)
 1830e64:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 1830e68:	e0fffe0b 	ldhu	r3,-8(fp)
 1830e6c:	00bffc04 	movi	r2,-16
 1830e70:	1884703a 	and	r2,r3,r2
 1830e74:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 1830e78:	01006134 	movhi	r4,388
 1830e7c:	210e5304 	addi	r4,r4,14668
 1830e80:	183d2fc0 	call	183d2fc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 1830e84:	e0bfff17 	ldw	r2,-4(fp)
 1830e88:	1080bb04 	addi	r2,r2,748
 1830e8c:	e0fffe0b 	ldhu	r3,-8(fp)
 1830e90:	18c003d4 	ori	r3,r3,15
 1830e94:	18ffffcc 	andi	r3,r3,65535
 1830e98:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 1830e9c:	01006134 	movhi	r4,388
 1830ea0:	210e5f04 	addi	r4,r4,14716
 1830ea4:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 1830ea8:	e0bfff17 	ldw	r2,-4(fp)
 1830eac:	1080b404 	addi	r2,r2,720
 1830eb0:	10800037 	ldwio	r2,0(r2)
 1830eb4:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 1830eb8:	e0fffe0b 	ldhu	r3,-8(fp)
 1830ebc:	00bfdf44 	movi	r2,-131
 1830ec0:	1884703a 	and	r2,r3,r2
 1830ec4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 1830ec8:	e0bfff17 	ldw	r2,-4(fp)
 1830ecc:	1080b404 	addi	r2,r2,720
 1830ed0:	e0fffe0b 	ldhu	r3,-8(fp)
 1830ed4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 1830ed8:	01006134 	movhi	r4,388
 1830edc:	210e4e04 	addi	r4,r4,14648
 1830ee0:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 1830ee4:	e0bfff17 	ldw	r2,-4(fp)
 1830ee8:	1080a004 	addi	r2,r2,640
 1830eec:	10800037 	ldwio	r2,0(r2)
 1830ef0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 1830ef4:	e0bfff17 	ldw	r2,-4(fp)
 1830ef8:	1080a004 	addi	r2,r2,640
 1830efc:	e13ffe0b 	ldhu	r4,-8(fp)
 1830f00:	00e00004 	movi	r3,-32768
 1830f04:	20c6b03a 	or	r3,r4,r3
 1830f08:	18ffffcc 	andi	r3,r3,65535
 1830f0c:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 1830f10:	00800044 	movi	r2,1
}
 1830f14:	e037883a 	mov	sp,fp
 1830f18:	dfc00117 	ldw	ra,4(sp)
 1830f1c:	df000017 	ldw	fp,0(sp)
 1830f20:	dec00204 	addi	sp,sp,8
 1830f24:	f800283a 	ret

01830f28 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 1830f28:	defffc04 	addi	sp,sp,-16
 1830f2c:	dfc00315 	stw	ra,12(sp)
 1830f30:	df000215 	stw	fp,8(sp)
 1830f34:	df000204 	addi	fp,sp,8
 1830f38:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 1830f3c:	e0bfff17 	ldw	r2,-4(fp)
 1830f40:	1080bb04 	addi	r2,r2,748
 1830f44:	10800037 	ldwio	r2,0(r2)
 1830f48:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 1830f4c:	e0fffe0b 	ldhu	r3,-8(fp)
 1830f50:	00bffc04 	movi	r2,-16
 1830f54:	1884703a 	and	r2,r3,r2
 1830f58:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 1830f5c:	01006134 	movhi	r4,388
 1830f60:	210e6904 	addi	r4,r4,14756
 1830f64:	183d2fc0 	call	183d2fc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 1830f68:	e0bfff17 	ldw	r2,-4(fp)
 1830f6c:	1080bb04 	addi	r2,r2,748
 1830f70:	e0fffe0b 	ldhu	r3,-8(fp)
 1830f74:	18c00114 	ori	r3,r3,4
 1830f78:	18ffffcc 	andi	r3,r3,65535
 1830f7c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 1830f80:	01006134 	movhi	r4,388
 1830f84:	210e5f04 	addi	r4,r4,14716
 1830f88:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 1830f8c:	e0bfff17 	ldw	r2,-4(fp)
 1830f90:	1080b404 	addi	r2,r2,720
 1830f94:	10800037 	ldwio	r2,0(r2)
 1830f98:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 1830f9c:	e0fffe0b 	ldhu	r3,-8(fp)
 1830fa0:	00bfdf44 	movi	r2,-131
 1830fa4:	1884703a 	and	r2,r3,r2
 1830fa8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 1830fac:	e0bfff17 	ldw	r2,-4(fp)
 1830fb0:	1080b404 	addi	r2,r2,720
 1830fb4:	e0fffe0b 	ldhu	r3,-8(fp)
 1830fb8:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 1830fbc:	01006134 	movhi	r4,388
 1830fc0:	210e4e04 	addi	r4,r4,14648
 1830fc4:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 1830fc8:	e0bfff17 	ldw	r2,-4(fp)
 1830fcc:	1080a004 	addi	r2,r2,640
 1830fd0:	10800037 	ldwio	r2,0(r2)
 1830fd4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 1830fd8:	e0bfff17 	ldw	r2,-4(fp)
 1830fdc:	1080a004 	addi	r2,r2,640
 1830fe0:	e13ffe0b 	ldhu	r4,-8(fp)
 1830fe4:	00e00004 	movi	r3,-32768
 1830fe8:	20c6b03a 	or	r3,r4,r3
 1830fec:	18ffffcc 	andi	r3,r3,65535
 1830ff0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 1830ff4:	00800044 	movi	r2,1
}
 1830ff8:	e037883a 	mov	sp,fp
 1830ffc:	dfc00117 	ldw	ra,4(sp)
 1831000:	df000017 	ldw	fp,0(sp)
 1831004:	dec00204 	addi	sp,sp,8
 1831008:	f800283a 	ret

0183100c <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 183100c:	defffc04 	addi	sp,sp,-16
 1831010:	dfc00315 	stw	ra,12(sp)
 1831014:	df000215 	stw	fp,8(sp)
 1831018:	df000204 	addi	fp,sp,8
 183101c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 1831020:	e0bfff17 	ldw	r2,-4(fp)
 1831024:	1080bb04 	addi	r2,r2,748
 1831028:	10800037 	ldwio	r2,0(r2)
 183102c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 1831030:	e0fffe0b 	ldhu	r3,-8(fp)
 1831034:	00bffc04 	movi	r2,-16
 1831038:	1884703a 	and	r2,r3,r2
 183103c:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 1831040:	01006134 	movhi	r4,388
 1831044:	210e7e04 	addi	r4,r4,14840
 1831048:	183d2fc0 	call	183d2fc <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 183104c:	e0bfff17 	ldw	r2,-4(fp)
 1831050:	1080bb04 	addi	r2,r2,748
 1831054:	e0fffe0b 	ldhu	r3,-8(fp)
 1831058:	18c002d4 	ori	r3,r3,11
 183105c:	18ffffcc 	andi	r3,r3,65535
 1831060:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 1831064:	01006134 	movhi	r4,388
 1831068:	210e8d04 	addi	r4,r4,14900
 183106c:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 1831070:	e0bfff17 	ldw	r2,-4(fp)
 1831074:	1080b404 	addi	r2,r2,720
 1831078:	10800037 	ldwio	r2,0(r2)
 183107c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 1831080:	e0fffe0b 	ldhu	r3,-8(fp)
 1831084:	00bfdf44 	movi	r2,-131
 1831088:	1884703a 	and	r2,r3,r2
 183108c:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 1831090:	e0bffe0b 	ldhu	r2,-8(fp)
 1831094:	10802094 	ori	r2,r2,130
 1831098:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 183109c:	e0bfff17 	ldw	r2,-4(fp)
 18310a0:	1080b404 	addi	r2,r2,720
 18310a4:	e0fffe0b 	ldhu	r3,-8(fp)
 18310a8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 18310ac:	01006134 	movhi	r4,388
 18310b0:	210e4e04 	addi	r4,r4,14648
 18310b4:	183d2fc0 	call	183d2fc <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 18310b8:	e0bfff17 	ldw	r2,-4(fp)
 18310bc:	1080a004 	addi	r2,r2,640
 18310c0:	10800037 	ldwio	r2,0(r2)
 18310c4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 18310c8:	e0bfff17 	ldw	r2,-4(fp)
 18310cc:	1080a004 	addi	r2,r2,640
 18310d0:	e13ffe0b 	ldhu	r4,-8(fp)
 18310d4:	00e00004 	movi	r3,-32768
 18310d8:	20c6b03a 	or	r3,r4,r3
 18310dc:	18ffffcc 	andi	r3,r3,65535
 18310e0:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 18310e4:	00800044 	movi	r2,1
    
}
 18310e8:	e037883a 	mov	sp,fp
 18310ec:	dfc00117 	ldw	ra,4(sp)
 18310f0:	df000017 	ldw	fp,0(sp)
 18310f4:	dec00204 	addi	sp,sp,8
 18310f8:	f800283a 	ret

018310fc <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 18310fc:	defffc04 	addi	sp,sp,-16
 1831100:	df000315 	stw	fp,12(sp)
 1831104:	df000304 	addi	fp,sp,12
 1831108:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 183110c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 1831110:	e0bfff17 	ldw	r2,-4(fp)
 1831114:	1080b004 	addi	r2,r2,704
 1831118:	10800037 	ldwio	r2,0(r2)
 183111c:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 1831120:	e0bffe17 	ldw	r2,-8(fp)
 1831124:	1080008c 	andi	r2,r2,2
 1831128:	10000426 	beq	r2,zero,183113c <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 183112c:	e0bffd17 	ldw	r2,-12(fp)
 1831130:	10800214 	ori	r2,r2,8
 1831134:	e0bffd15 	stw	r2,-12(fp)
 1831138:	00000306 	br	1831148 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 183113c:	e0bffd17 	ldw	r2,-12(fp)
 1831140:	10800114 	ori	r2,r2,4
 1831144:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 1831148:	e0bffe17 	ldw	r2,-8(fp)
 183114c:	1080010c 	andi	r2,r2,4
 1831150:	10000326 	beq	r2,zero,1831160 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 1831154:	e0bffd17 	ldw	r2,-12(fp)
 1831158:	10800054 	ori	r2,r2,1
 183115c:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 1831160:	e0bffd17 	ldw	r2,-12(fp)
}
 1831164:	e037883a 	mov	sp,fp
 1831168:	df000017 	ldw	fp,0(sp)
 183116c:	dec00104 	addi	sp,sp,4
 1831170:	f800283a 	ret

01831174 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 1831174:	defffe04 	addi	sp,sp,-8
 1831178:	dfc00115 	stw	ra,4(sp)
 183117c:	df000015 	stw	fp,0(sp)
 1831180:	d839883a 	mov	fp,sp
  /* Modules initialization */
  stats_init();
 1831184:	181ba6c0 	call	181ba6c <stats_init>
#if !NO_SYS
  sys_init();
 1831188:	1814ec40 	call	1814ec4 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 183118c:	18193240 	call	1819324 <mem_init>
  memp_init();
 1831190:	18347940 	call	1834794 <memp_init>
  pbuf_init();
  netif_init();
 1831194:	1819b980 	call	1819b98 <netif_init>
#if LWIP_SOCKET
  lwip_socket_init();
 1831198:	18288200 	call	1828820 <lwip_socket_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 183119c:	1821bf80 	call	1821bf8 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 18311a0:	181ba8c0 	call	181ba8c <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 18311a4:	18217fc0 	call	18217fc <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 18311a8:	0001883a 	nop
 18311ac:	e037883a 	mov	sp,fp
 18311b0:	dfc00117 	ldw	ra,4(sp)
 18311b4:	df000017 	ldw	fp,0(sp)
 18311b8:	dec00204 	addi	sp,sp,8
 18311bc:	f800283a 	ret

018311c0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 18311c0:	defff304 	addi	sp,sp,-52
 18311c4:	dfc00c15 	stw	ra,48(sp)
 18311c8:	df000b15 	stw	fp,44(sp)
 18311cc:	df000b04 	addi	fp,sp,44
 18311d0:	e13ffe15 	stw	r4,-8(fp)
 18311d4:	e17fff15 	stw	r5,-4(fp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
 18311d8:	008061f4 	movhi	r2,391
 18311dc:	10a9d404 	addi	r2,r2,-22704
 18311e0:	10803117 	ldw	r2,196(r2)
 18311e4:	10c00044 	addi	r3,r2,1
 18311e8:	008061f4 	movhi	r2,391
 18311ec:	10a9d404 	addi	r2,r2,-22704
 18311f0:	10c03115 	stw	r3,196(r2)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
 18311f4:	e0bffe17 	ldw	r2,-8(fp)
 18311f8:	10800117 	ldw	r2,4(r2)
 18311fc:	e0bff815 	stw	r2,-32(fp)
  hlen = IPH_HL(iphdr) * 4;
 1831200:	e0bff817 	ldw	r2,-32(fp)
 1831204:	10800003 	ldbu	r2,0(r2)
 1831208:	10803fcc 	andi	r2,r2,255
 183120c:	108003cc 	andi	r2,r2,15
 1831210:	1085883a 	add	r2,r2,r2
 1831214:	1085883a 	add	r2,r2,r2
 1831218:	e0bffa0d 	sth	r2,-24(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 183121c:	e0bffa0b 	ldhu	r2,-24(fp)
 1831220:	0085c83a 	sub	r2,zero,r2
 1831224:	10bfffcc 	andi	r2,r2,65535
 1831228:	10a0001c 	xori	r2,r2,32768
 183122c:	10a00004 	addi	r2,r2,-32768
 1831230:	100b883a 	mov	r5,r2
 1831234:	e13ffe17 	ldw	r4,-8(fp)
 1831238:	181aaf40 	call	181aaf4 <pbuf_header>
 183123c:	10803fcc 	andi	r2,r2,255
 1831240:	10013c1e 	bne	r2,zero,1831734 <icmp_input+0x574>
 1831244:	e0bffe17 	ldw	r2,-8(fp)
 1831248:	1080020b 	ldhu	r2,8(r2)
 183124c:	10bfffcc 	andi	r2,r2,65535
 1831250:	10800130 	cmpltui	r2,r2,4
 1831254:	1001371e 	bne	r2,zero,1831734 <icmp_input+0x574>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 1831258:	e0bffe17 	ldw	r2,-8(fp)
 183125c:	10800117 	ldw	r2,4(r2)
 1831260:	10800003 	ldbu	r2,0(r2)
 1831264:	e0bffa85 	stb	r2,-22(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 1831268:	e0bffa83 	ldbu	r2,-22(fp)
 183126c:	10012a26 	beq	r2,zero,1831718 <icmp_input+0x558>
 1831270:	10800220 	cmpeqi	r2,r2,8
 1831274:	10011926 	beq	r2,zero,18316dc <icmp_input+0x51c>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
 1831278:	00800044 	movi	r2,1
 183127c:	e0bff915 	stw	r2,-28(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 1831280:	d0a81417 	ldw	r2,-24496(gp)
 1831284:	10803c0c 	andi	r2,r2,240
 1831288:	10803818 	cmpnei	r2,r2,224
 183128c:	1000011e 	bne	r2,zero,1831294 <icmp_input+0xd4>
        accepted = 0;
 1831290:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 1831294:	d0a81417 	ldw	r2,-24496(gp)
 1831298:	e17fff17 	ldw	r5,-4(fp)
 183129c:	1009883a 	mov	r4,r2
 18312a0:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 18312a4:	10803fcc 	andi	r2,r2,255
 18312a8:	10000126 	beq	r2,zero,18312b0 <icmp_input+0xf0>
        accepted = 0;
 18312ac:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
 18312b0:	e0bff917 	ldw	r2,-28(fp)
 18312b4:	10000a1e 	bne	r2,zero,18312e0 <icmp_input+0x120>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
 18312b8:	008061f4 	movhi	r2,391
 18312bc:	10a9d404 	addi	r2,r2,-22704
 18312c0:	10803a17 	ldw	r2,232(r2)
 18312c4:	10c00044 	addi	r3,r2,1
 18312c8:	008061f4 	movhi	r2,391
 18312cc:	10a9d404 	addi	r2,r2,-22704
 18312d0:	10c03a15 	stw	r3,232(r2)
        pbuf_free(p);
 18312d4:	e13ffe17 	ldw	r4,-8(fp)
 18312d8:	181aca40 	call	181aca4 <pbuf_free>
        return;
 18312dc:	00013206 	br	18317a8 <icmp_input+0x5e8>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 18312e0:	e0bffe17 	ldw	r2,-8(fp)
 18312e4:	1080020b 	ldhu	r2,8(r2)
 18312e8:	10bfffcc 	andi	r2,r2,65535
 18312ec:	10800228 	cmpgeui	r2,r2,8
 18312f0:	10010f26 	beq	r2,zero,1831730 <icmp_input+0x570>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 18312f4:	e13ffe17 	ldw	r4,-8(fp)
 18312f8:	18320dc0 	call	18320dc <inet_chksum_pbuf>
 18312fc:	10bfffcc 	andi	r2,r2,65535
 1831300:	10000a26 	beq	r2,zero,183132c <icmp_input+0x16c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
 1831304:	e13ffe17 	ldw	r4,-8(fp)
 1831308:	181aca40 	call	181aca4 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 183130c:	008061f4 	movhi	r2,391
 1831310:	10a9d404 	addi	r2,r2,-22704
 1831314:	10803417 	ldw	r2,208(r2)
 1831318:	10c00044 	addi	r3,r2,1
 183131c:	008061f4 	movhi	r2,391
 1831320:	10a9d404 	addi	r2,r2,-22704
 1831324:	10c03415 	stw	r3,208(r2)
      snmp_inc_icmpinerrors();
      return;
 1831328:	00011f06 	br	18317a8 <icmp_input+0x5e8>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 183132c:	01400904 	movi	r5,36
 1831330:	e13ffe17 	ldw	r4,-8(fp)
 1831334:	181aaf40 	call	181aaf4 <pbuf_header>
 1831338:	10803fcc 	andi	r2,r2,255
 183133c:	10002926 	beq	r2,zero,18313e4 <icmp_input+0x224>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 1831340:	e0bffa0f 	ldh	r2,-24(fp)
 1831344:	100b883a 	mov	r5,r2
 1831348:	e13ffe17 	ldw	r4,-8(fp)
 183134c:	181aaf40 	call	181aaf4 <pbuf_header>
 1831350:	10803fcc 	andi	r2,r2,255
 1831354:	1001011e 	bne	r2,zero,183175c <icmp_input+0x59c>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 1831358:	e0bffe17 	ldw	r2,-8(fp)
 183135c:	1080020b 	ldhu	r2,8(r2)
 1831360:	10bfffcc 	andi	r2,r2,65535
 1831364:	000d883a 	mov	r6,zero
 1831368:	100b883a 	mov	r5,r2
 183136c:	01000084 	movi	r4,2
 1831370:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1831374:	e0bffb15 	stw	r2,-20(fp)
      if (r == NULL) {
 1831378:	e0bffb17 	ldw	r2,-20(fp)
 183137c:	1000f926 	beq	r2,zero,1831764 <icmp_input+0x5a4>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 1831380:	e17ffe17 	ldw	r5,-8(fp)
 1831384:	e13ffb17 	ldw	r4,-20(fp)
 1831388:	181b04c0 	call	181b04c <pbuf_copy>
 183138c:	10803fcc 	andi	r2,r2,255
 1831390:	1080201c 	xori	r2,r2,128
 1831394:	10bfe004 	addi	r2,r2,-128
 1831398:	1000f41e 	bne	r2,zero,183176c <icmp_input+0x5ac>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 183139c:	e0bffb17 	ldw	r2,-20(fp)
 18313a0:	10800117 	ldw	r2,4(r2)
 18313a4:	e0bff815 	stw	r2,-32(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 18313a8:	e0bffa0b 	ldhu	r2,-24(fp)
 18313ac:	0085c83a 	sub	r2,zero,r2
 18313b0:	10bfffcc 	andi	r2,r2,65535
 18313b4:	10a0001c 	xori	r2,r2,32768
 18313b8:	10a00004 	addi	r2,r2,-32768
 18313bc:	100b883a 	mov	r5,r2
 18313c0:	e13ffb17 	ldw	r4,-20(fp)
 18313c4:	181aaf40 	call	181aaf4 <pbuf_header>
 18313c8:	10803fcc 	andi	r2,r2,255
 18313cc:	1000e91e 	bne	r2,zero,1831774 <icmp_input+0x5b4>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 18313d0:	e13ffe17 	ldw	r4,-8(fp)
 18313d4:	181aca40 	call	181aca4 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
 18313d8:	e0bffb17 	ldw	r2,-20(fp)
 18313dc:	e0bffe15 	stw	r2,-8(fp)
 18313e0:	00000506 	br	18313f8 <icmp_input+0x238>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 18313e4:	017ff704 	movi	r5,-36
 18313e8:	e13ffe17 	ldw	r4,-8(fp)
 18313ec:	181aaf40 	call	181aaf4 <pbuf_header>
 18313f0:	10803fcc 	andi	r2,r2,255
 18313f4:	1000e11e 	bne	r2,zero,183177c <icmp_input+0x5bc>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 18313f8:	e0bffe17 	ldw	r2,-8(fp)
 18313fc:	10800117 	ldw	r2,4(r2)
 1831400:	e0bffc15 	stw	r2,-16(fp)
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 1831404:	d0e81417 	ldw	r3,-24496(gp)
 1831408:	e0bff817 	ldw	r2,-32(fp)
 183140c:	19803fcc 	andi	r6,r3,255
 1831410:	11000303 	ldbu	r4,12(r2)
 1831414:	2008703a 	and	r4,r4,zero
 1831418:	200b883a 	mov	r5,r4
 183141c:	3009883a 	mov	r4,r6
 1831420:	2908b03a 	or	r4,r5,r4
 1831424:	11000305 	stb	r4,12(r2)
 1831428:	1808d23a 	srli	r4,r3,8
 183142c:	21803fcc 	andi	r6,r4,255
 1831430:	11000343 	ldbu	r4,13(r2)
 1831434:	2008703a 	and	r4,r4,zero
 1831438:	200b883a 	mov	r5,r4
 183143c:	3009883a 	mov	r4,r6
 1831440:	2908b03a 	or	r4,r5,r4
 1831444:	11000345 	stb	r4,13(r2)
 1831448:	1808d43a 	srli	r4,r3,16
 183144c:	21803fcc 	andi	r6,r4,255
 1831450:	11000383 	ldbu	r4,14(r2)
 1831454:	2008703a 	and	r4,r4,zero
 1831458:	200b883a 	mov	r5,r4
 183145c:	3009883a 	mov	r4,r6
 1831460:	2908b03a 	or	r4,r5,r4
 1831464:	11000385 	stb	r4,14(r2)
 1831468:	180ad63a 	srli	r5,r3,24
 183146c:	10c003c3 	ldbu	r3,15(r2)
 1831470:	1806703a 	and	r3,r3,zero
 1831474:	1809883a 	mov	r4,r3
 1831478:	2807883a 	mov	r3,r5
 183147c:	20c6b03a 	or	r3,r4,r3
 1831480:	10c003c5 	stb	r3,15(r2)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 1831484:	d0e81217 	ldw	r3,-24504(gp)
 1831488:	e0bff817 	ldw	r2,-32(fp)
 183148c:	19803fcc 	andi	r6,r3,255
 1831490:	11000403 	ldbu	r4,16(r2)
 1831494:	2008703a 	and	r4,r4,zero
 1831498:	200b883a 	mov	r5,r4
 183149c:	3009883a 	mov	r4,r6
 18314a0:	2908b03a 	or	r4,r5,r4
 18314a4:	11000405 	stb	r4,16(r2)
 18314a8:	1808d23a 	srli	r4,r3,8
 18314ac:	21803fcc 	andi	r6,r4,255
 18314b0:	11000443 	ldbu	r4,17(r2)
 18314b4:	2008703a 	and	r4,r4,zero
 18314b8:	200b883a 	mov	r5,r4
 18314bc:	3009883a 	mov	r4,r6
 18314c0:	2908b03a 	or	r4,r5,r4
 18314c4:	11000445 	stb	r4,17(r2)
 18314c8:	1808d43a 	srli	r4,r3,16
 18314cc:	21803fcc 	andi	r6,r4,255
 18314d0:	11000483 	ldbu	r4,18(r2)
 18314d4:	2008703a 	and	r4,r4,zero
 18314d8:	200b883a 	mov	r5,r4
 18314dc:	3009883a 	mov	r4,r6
 18314e0:	2908b03a 	or	r4,r5,r4
 18314e4:	11000485 	stb	r4,18(r2)
 18314e8:	180ad63a 	srli	r5,r3,24
 18314ec:	10c004c3 	ldbu	r3,19(r2)
 18314f0:	1806703a 	and	r3,r3,zero
 18314f4:	1809883a 	mov	r4,r3
 18314f8:	2807883a 	mov	r3,r5
 18314fc:	20c6b03a 	or	r3,r4,r3
 1831500:	10c004c5 	stb	r3,19(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 1831504:	e0bffc17 	ldw	r2,-16(fp)
 1831508:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 183150c:	e0bffc17 	ldw	r2,-16(fp)
 1831510:	10c00083 	ldbu	r3,2(r2)
 1831514:	108000c3 	ldbu	r2,3(r2)
 1831518:	1004923a 	slli	r2,r2,8
 183151c:	10c4b03a 	or	r2,r2,r3
 1831520:	10bfffcc 	andi	r2,r2,65535
 1831524:	10bffdf0 	cmpltui	r2,r2,65527
 1831528:	10001a1e 	bne	r2,zero,1831594 <icmp_input+0x3d4>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 183152c:	e0bffc17 	ldw	r2,-16(fp)
 1831530:	10c00083 	ldbu	r3,2(r2)
 1831534:	108000c3 	ldbu	r2,3(r2)
 1831538:	1004923a 	slli	r2,r2,8
 183153c:	10c4b03a 	or	r2,r2,r3
 1831540:	10800244 	addi	r2,r2,9
 1831544:	100d883a 	mov	r6,r2
 1831548:	e0bffc17 	ldw	r2,-16(fp)
 183154c:	30ffffcc 	andi	r3,r6,65535
 1831550:	19403fcc 	andi	r5,r3,255
 1831554:	10c00083 	ldbu	r3,2(r2)
 1831558:	1806703a 	and	r3,r3,zero
 183155c:	1809883a 	mov	r4,r3
 1831560:	2807883a 	mov	r3,r5
 1831564:	20c6b03a 	or	r3,r4,r3
 1831568:	10c00085 	stb	r3,2(r2)
 183156c:	30ffffcc 	andi	r3,r6,65535
 1831570:	1806d23a 	srli	r3,r3,8
 1831574:	197fffcc 	andi	r5,r3,65535
 1831578:	10c000c3 	ldbu	r3,3(r2)
 183157c:	1806703a 	and	r3,r3,zero
 1831580:	1809883a 	mov	r4,r3
 1831584:	2807883a 	mov	r3,r5
 1831588:	20c6b03a 	or	r3,r4,r3
 183158c:	10c000c5 	stb	r3,3(r2)
 1831590:	00001906 	br	18315f8 <icmp_input+0x438>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 1831594:	e0bffc17 	ldw	r2,-16(fp)
 1831598:	10c00083 	ldbu	r3,2(r2)
 183159c:	108000c3 	ldbu	r2,3(r2)
 18315a0:	1004923a 	slli	r2,r2,8
 18315a4:	10c4b03a 	or	r2,r2,r3
 18315a8:	10800204 	addi	r2,r2,8
 18315ac:	100d883a 	mov	r6,r2
 18315b0:	e0bffc17 	ldw	r2,-16(fp)
 18315b4:	30ffffcc 	andi	r3,r6,65535
 18315b8:	19403fcc 	andi	r5,r3,255
 18315bc:	10c00083 	ldbu	r3,2(r2)
 18315c0:	1806703a 	and	r3,r3,zero
 18315c4:	1809883a 	mov	r4,r3
 18315c8:	2807883a 	mov	r3,r5
 18315cc:	20c6b03a 	or	r3,r4,r3
 18315d0:	10c00085 	stb	r3,2(r2)
 18315d4:	30ffffcc 	andi	r3,r6,65535
 18315d8:	1806d23a 	srli	r3,r3,8
 18315dc:	197fffcc 	andi	r5,r3,65535
 18315e0:	10c000c3 	ldbu	r3,3(r2)
 18315e4:	1806703a 	and	r3,r3,zero
 18315e8:	1809883a 	mov	r4,r3
 18315ec:	2807883a 	mov	r3,r5
 18315f0:	20c6b03a 	or	r3,r4,r3
 18315f4:	10c000c5 	stb	r3,3(r2)
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 18315f8:	e0bff817 	ldw	r2,-32(fp)
 18315fc:	00c01004 	movi	r3,64
 1831600:	10c00205 	stb	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
 1831604:	e0bff817 	ldw	r2,-32(fp)
 1831608:	10c00283 	ldbu	r3,10(r2)
 183160c:	1806703a 	and	r3,r3,zero
 1831610:	10c00285 	stb	r3,10(r2)
 1831614:	10c002c3 	ldbu	r3,11(r2)
 1831618:	1806703a 	and	r3,r3,zero
 183161c:	10c002c5 	stb	r3,11(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 1831620:	01400504 	movi	r5,20
 1831624:	e13ff817 	ldw	r4,-32(fp)
 1831628:	18320980 	call	1832098 <inet_chksum>
 183162c:	100d883a 	mov	r6,r2
 1831630:	e0bff817 	ldw	r2,-32(fp)
 1831634:	30ffffcc 	andi	r3,r6,65535
 1831638:	19403fcc 	andi	r5,r3,255
 183163c:	10c00283 	ldbu	r3,10(r2)
 1831640:	1806703a 	and	r3,r3,zero
 1831644:	1809883a 	mov	r4,r3
 1831648:	2807883a 	mov	r3,r5
 183164c:	20c6b03a 	or	r3,r4,r3
 1831650:	10c00285 	stb	r3,10(r2)
 1831654:	30ffffcc 	andi	r3,r6,65535
 1831658:	1806d23a 	srli	r3,r3,8
 183165c:	197fffcc 	andi	r5,r3,65535
 1831660:	10c002c3 	ldbu	r3,11(r2)
 1831664:	1806703a 	and	r3,r3,zero
 1831668:	1809883a 	mov	r4,r3
 183166c:	2807883a 	mov	r3,r5
 1831670:	20c6b03a 	or	r3,r4,r3
 1831674:	10c002c5 	stb	r3,11(r2)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
 1831678:	008061f4 	movhi	r2,391
 183167c:	10a9d404 	addi	r2,r2,-22704
 1831680:	10803017 	ldw	r2,192(r2)
 1831684:	10c00044 	addi	r3,r2,1
 1831688:	008061f4 	movhi	r2,391
 183168c:	10a9d404 	addi	r2,r2,-22704
 1831690:	10c03015 	stw	r3,192(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 1831694:	e0bffa0f 	ldh	r2,-24(fp)
 1831698:	100b883a 	mov	r5,r2
 183169c:	e13ffe17 	ldw	r4,-8(fp)
 18316a0:	181aaf40 	call	181aaf4 <pbuf_header>
 18316a4:	10803fcc 	andi	r2,r2,255
 18316a8:	10001d1e 	bne	r2,zero,1831720 <icmp_input+0x560>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 18316ac:	e0bfff17 	ldw	r2,-4(fp)
 18316b0:	d8800215 	stw	r2,8(sp)
 18316b4:	00800044 	movi	r2,1
 18316b8:	d8800115 	stw	r2,4(sp)
 18316bc:	d8000015 	stw	zero,0(sp)
 18316c0:	01c01004 	movi	r7,64
 18316c4:	000d883a 	mov	r6,zero
 18316c8:	d1681404 	addi	r5,gp,-24496
 18316cc:	e13ffe17 	ldw	r4,-8(fp)
 18316d0:	183286c0 	call	183286c <ip_output_if>
 18316d4:	e0bffd05 	stb	r2,-12(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 18316d8:	00001106 	br	1831720 <icmp_input+0x560>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
 18316dc:	008061f4 	movhi	r2,391
 18316e0:	10a9d404 	addi	r2,r2,-22704
 18316e4:	10803817 	ldw	r2,224(r2)
 18316e8:	10c00044 	addi	r3,r2,1
 18316ec:	008061f4 	movhi	r2,391
 18316f0:	10a9d404 	addi	r2,r2,-22704
 18316f4:	10c03815 	stw	r3,224(r2)
    ICMP_STATS_INC(icmp.drop);
 18316f8:	008061f4 	movhi	r2,391
 18316fc:	10a9d404 	addi	r2,r2,-22704
 1831700:	10803317 	ldw	r2,204(r2)
 1831704:	10c00044 	addi	r3,r2,1
 1831708:	008061f4 	movhi	r2,391
 183170c:	10a9d404 	addi	r2,r2,-22704
 1831710:	10c03315 	stw	r3,204(r2)
 1831714:	00000306 	br	1831724 <icmp_input+0x564>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
 1831718:	0001883a 	nop
 183171c:	00000106 	br	1831724 <icmp_input+0x564>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 1831720:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 1831724:	e13ffe17 	ldw	r4,-8(fp)
 1831728:	181aca40 	call	181aca4 <pbuf_free>
  return;
 183172c:	00001e06 	br	18317a8 <icmp_input+0x5e8>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
 1831730:	0001883a 	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 1831734:	e13ffe17 	ldw	r4,-8(fp)
 1831738:	181aca40 	call	181aca4 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 183173c:	008061f4 	movhi	r2,391
 1831740:	10a9d404 	addi	r2,r2,-22704
 1831744:	10803517 	ldw	r2,212(r2)
 1831748:	10c00044 	addi	r3,r2,1
 183174c:	008061f4 	movhi	r2,391
 1831750:	10a9d404 	addi	r2,r2,-22704
 1831754:	10c03515 	stw	r3,212(r2)
  snmp_inc_icmpinerrors();
  return;
 1831758:	00001306 	br	18317a8 <icmp_input+0x5e8>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
 183175c:	0001883a 	nop
 1831760:	00000706 	br	1831780 <icmp_input+0x5c0>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
 1831764:	0001883a 	nop
 1831768:	00000506 	br	1831780 <icmp_input+0x5c0>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
 183176c:	0001883a 	nop
 1831770:	00000306 	br	1831780 <icmp_input+0x5c0>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 1831774:	0001883a 	nop
 1831778:	00000106 	br	1831780 <icmp_input+0x5c0>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 183177c:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 1831780:	e13ffe17 	ldw	r4,-8(fp)
 1831784:	181aca40 	call	181aca4 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 1831788:	008061f4 	movhi	r2,391
 183178c:	10a9d404 	addi	r2,r2,-22704
 1831790:	10803a17 	ldw	r2,232(r2)
 1831794:	10c00044 	addi	r3,r2,1
 1831798:	008061f4 	movhi	r2,391
 183179c:	10a9d404 	addi	r2,r2,-22704
 18317a0:	10c03a15 	stw	r3,232(r2)
  snmp_inc_icmpinerrors();
  return;
 18317a4:	0001883a 	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 18317a8:	e037883a 	mov	sp,fp
 18317ac:	dfc00117 	ldw	ra,4(sp)
 18317b0:	df000017 	ldw	fp,0(sp)
 18317b4:	dec00204 	addi	sp,sp,8
 18317b8:	f800283a 	ret

018317bc <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 18317bc:	defffc04 	addi	sp,sp,-16
 18317c0:	dfc00315 	stw	ra,12(sp)
 18317c4:	df000215 	stw	fp,8(sp)
 18317c8:	df000204 	addi	fp,sp,8
 18317cc:	e13ffe15 	stw	r4,-8(fp)
 18317d0:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
 18317d4:	e0bfff17 	ldw	r2,-4(fp)
 18317d8:	10803fcc 	andi	r2,r2,255
 18317dc:	100d883a 	mov	r6,r2
 18317e0:	014000c4 	movi	r5,3
 18317e4:	e13ffe17 	ldw	r4,-8(fp)
 18317e8:	183184c0 	call	183184c <icmp_send_response>
}
 18317ec:	0001883a 	nop
 18317f0:	e037883a 	mov	sp,fp
 18317f4:	dfc00117 	ldw	ra,4(sp)
 18317f8:	df000017 	ldw	fp,0(sp)
 18317fc:	dec00204 	addi	sp,sp,8
 1831800:	f800283a 	ret

01831804 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 1831804:	defffc04 	addi	sp,sp,-16
 1831808:	dfc00315 	stw	ra,12(sp)
 183180c:	df000215 	stw	fp,8(sp)
 1831810:	df000204 	addi	fp,sp,8
 1831814:	e13ffe15 	stw	r4,-8(fp)
 1831818:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
 183181c:	e0bfff17 	ldw	r2,-4(fp)
 1831820:	10803fcc 	andi	r2,r2,255
 1831824:	100d883a 	mov	r6,r2
 1831828:	014002c4 	movi	r5,11
 183182c:	e13ffe17 	ldw	r4,-8(fp)
 1831830:	183184c0 	call	183184c <icmp_send_response>
}
 1831834:	0001883a 	nop
 1831838:	e037883a 	mov	sp,fp
 183183c:	dfc00117 	ldw	ra,4(sp)
 1831840:	df000017 	ldw	fp,0(sp)
 1831844:	dec00204 	addi	sp,sp,8
 1831848:	f800283a 	ret

0183184c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 183184c:	defff504 	addi	sp,sp,-44
 1831850:	dfc00a15 	stw	ra,40(sp)
 1831854:	df000915 	stw	fp,36(sp)
 1831858:	df000904 	addi	fp,sp,36
 183185c:	e13ffd15 	stw	r4,-12(fp)
 1831860:	2807883a 	mov	r3,r5
 1831864:	3005883a 	mov	r2,r6
 1831868:	e0fffe05 	stb	r3,-8(fp)
 183186c:	e0bfff05 	stb	r2,-4(fp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 1831870:	000d883a 	mov	r6,zero
 1831874:	01400904 	movi	r5,36
 1831878:	01000044 	movi	r4,1
 183187c:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1831880:	e0bff915 	stw	r2,-28(fp)
                 PBUF_RAM);
  if (q == NULL) {
 1831884:	e0bff917 	ldw	r2,-28(fp)
 1831888:	10006226 	beq	r2,zero,1831a14 <icmp_send_response+0x1c8>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 183188c:	e0bffd17 	ldw	r2,-12(fp)
 1831890:	10800117 	ldw	r2,4(r2)
 1831894:	e0bffa15 	stw	r2,-24(fp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 1831898:	e0bff917 	ldw	r2,-28(fp)
 183189c:	10800117 	ldw	r2,4(r2)
 18318a0:	e0bffb15 	stw	r2,-20(fp)
  icmphdr->type = type;
 18318a4:	e0bffb17 	ldw	r2,-20(fp)
 18318a8:	e0fffe03 	ldbu	r3,-8(fp)
 18318ac:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
 18318b0:	e0bffb17 	ldw	r2,-20(fp)
 18318b4:	e0ffff03 	ldbu	r3,-4(fp)
 18318b8:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
 18318bc:	e0bffb17 	ldw	r2,-20(fp)
 18318c0:	10c00103 	ldbu	r3,4(r2)
 18318c4:	1806703a 	and	r3,r3,zero
 18318c8:	10c00105 	stb	r3,4(r2)
 18318cc:	10c00143 	ldbu	r3,5(r2)
 18318d0:	1806703a 	and	r3,r3,zero
 18318d4:	10c00145 	stb	r3,5(r2)
  icmphdr->seqno = 0;
 18318d8:	e0bffb17 	ldw	r2,-20(fp)
 18318dc:	10c00183 	ldbu	r3,6(r2)
 18318e0:	1806703a 	and	r3,r3,zero
 18318e4:	10c00185 	stb	r3,6(r2)
 18318e8:	10c001c3 	ldbu	r3,7(r2)
 18318ec:	1806703a 	and	r3,r3,zero
 18318f0:	10c001c5 	stb	r3,7(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 18318f4:	e0bff917 	ldw	r2,-28(fp)
 18318f8:	10800117 	ldw	r2,4(r2)
 18318fc:	10c00204 	addi	r3,r2,8
 1831900:	e0bffd17 	ldw	r2,-12(fp)
 1831904:	10800117 	ldw	r2,4(r2)
 1831908:	01800704 	movi	r6,28
 183190c:	100b883a 	mov	r5,r2
 1831910:	1809883a 	mov	r4,r3
 1831914:	180608c0 	call	180608c <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 1831918:	e0bffb17 	ldw	r2,-20(fp)
 183191c:	10c00083 	ldbu	r3,2(r2)
 1831920:	1806703a 	and	r3,r3,zero
 1831924:	10c00085 	stb	r3,2(r2)
 1831928:	10c000c3 	ldbu	r3,3(r2)
 183192c:	1806703a 	and	r3,r3,zero
 1831930:	10c000c5 	stb	r3,3(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 1831934:	e0bff917 	ldw	r2,-28(fp)
 1831938:	1080028b 	ldhu	r2,10(r2)
 183193c:	10bfffcc 	andi	r2,r2,65535
 1831940:	100b883a 	mov	r5,r2
 1831944:	e13ffb17 	ldw	r4,-20(fp)
 1831948:	18320980 	call	1832098 <inet_chksum>
 183194c:	100d883a 	mov	r6,r2
 1831950:	e0bffb17 	ldw	r2,-20(fp)
 1831954:	30ffffcc 	andi	r3,r6,65535
 1831958:	19403fcc 	andi	r5,r3,255
 183195c:	10c00083 	ldbu	r3,2(r2)
 1831960:	1806703a 	and	r3,r3,zero
 1831964:	1809883a 	mov	r4,r3
 1831968:	2807883a 	mov	r3,r5
 183196c:	20c6b03a 	or	r3,r4,r3
 1831970:	10c00085 	stb	r3,2(r2)
 1831974:	30ffffcc 	andi	r3,r6,65535
 1831978:	1806d23a 	srli	r3,r3,8
 183197c:	197fffcc 	andi	r5,r3,65535
 1831980:	10c000c3 	ldbu	r3,3(r2)
 1831984:	1806703a 	and	r3,r3,zero
 1831988:	1809883a 	mov	r4,r3
 183198c:	2807883a 	mov	r3,r5
 1831990:	20c6b03a 	or	r3,r4,r3
 1831994:	10c000c5 	stb	r3,3(r2)
  ICMP_STATS_INC(icmp.xmit);
 1831998:	008061f4 	movhi	r2,391
 183199c:	10a9d404 	addi	r2,r2,-22704
 18319a0:	10803017 	ldw	r2,192(r2)
 18319a4:	10c00044 	addi	r3,r2,1
 18319a8:	008061f4 	movhi	r2,391
 18319ac:	10a9d404 	addi	r2,r2,-22704
 18319b0:	10c03015 	stw	r3,192(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 18319b4:	e0bffa17 	ldw	r2,-24(fp)
 18319b8:	10c00303 	ldbu	r3,12(r2)
 18319bc:	11000343 	ldbu	r4,13(r2)
 18319c0:	2008923a 	slli	r4,r4,8
 18319c4:	20c6b03a 	or	r3,r4,r3
 18319c8:	11000383 	ldbu	r4,14(r2)
 18319cc:	2008943a 	slli	r4,r4,16
 18319d0:	20c6b03a 	or	r3,r4,r3
 18319d4:	108003c3 	ldbu	r2,15(r2)
 18319d8:	1004963a 	slli	r2,r2,24
 18319dc:	10c4b03a 	or	r2,r2,r3
 18319e0:	e0bffc15 	stw	r2,-16(fp)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 18319e4:	e0fffc04 	addi	r3,fp,-16
 18319e8:	00800044 	movi	r2,1
 18319ec:	d8800115 	stw	r2,4(sp)
 18319f0:	d8000015 	stw	zero,0(sp)
 18319f4:	01c01004 	movi	r7,64
 18319f8:	180d883a 	mov	r6,r3
 18319fc:	000b883a 	mov	r5,zero
 1831a00:	e13ff917 	ldw	r4,-28(fp)
 1831a04:	1832eb80 	call	1832eb8 <ip_output>
  pbuf_free(q);
 1831a08:	e13ff917 	ldw	r4,-28(fp)
 1831a0c:	181aca40 	call	181aca4 <pbuf_free>
 1831a10:	00000106 	br	1831a18 <icmp_send_response+0x1cc>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
 1831a14:	0001883a 	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
 1831a18:	e037883a 	mov	sp,fp
 1831a1c:	dfc00117 	ldw	ra,4(sp)
 1831a20:	df000017 	ldw	fp,0(sp)
 1831a24:	dec00204 	addi	sp,sp,8
 1831a28:	f800283a 	ret

01831a2c <lwip_standard_chksum>:
 * by Curt McDowell, Broadcom Corp. December 8th, 2005
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 1831a2c:	defff604 	addi	sp,sp,-40
 1831a30:	df000915 	stw	fp,36(sp)
 1831a34:	df000904 	addi	fp,sp,36
 1831a38:	e13ffe15 	stw	r4,-8(fp)
 1831a3c:	e17fff15 	stw	r5,-4(fp)
  u8_t *pb = (u8_t *)dataptr;
 1831a40:	e0bffe17 	ldw	r2,-8(fp)
 1831a44:	e0bff715 	stw	r2,-36(fp)
  u16_t *ps, t = 0;
 1831a48:	e03ffd0d 	sth	zero,-12(fp)
  u32_t *pl;
  u32_t sum = 0, tmp;
 1831a4c:	e03ffa15 	stw	zero,-24(fp)
  /* starts at odd byte address? */
  int odd = ((mem_ptr_t)pb & 1);
 1831a50:	e0bff717 	ldw	r2,-36(fp)
 1831a54:	1080004c 	andi	r2,r2,1
 1831a58:	e0bffc15 	stw	r2,-16(fp)

  if (odd && len > 0) {
 1831a5c:	e0bffc17 	ldw	r2,-16(fp)
 1831a60:	10000c26 	beq	r2,zero,1831a94 <lwip_standard_chksum+0x68>
 1831a64:	e0bfff17 	ldw	r2,-4(fp)
 1831a68:	00800a0e 	bge	zero,r2,1831a94 <lwip_standard_chksum+0x68>
    ((u8_t *)&t)[1] = *pb++;
 1831a6c:	e0bffd04 	addi	r2,fp,-12
 1831a70:	10800044 	addi	r2,r2,1
 1831a74:	e0fff717 	ldw	r3,-36(fp)
 1831a78:	19000044 	addi	r4,r3,1
 1831a7c:	e13ff715 	stw	r4,-36(fp)
 1831a80:	18c00003 	ldbu	r3,0(r3)
 1831a84:	10c00005 	stb	r3,0(r2)
    len--;
 1831a88:	e0bfff17 	ldw	r2,-4(fp)
 1831a8c:	10bfffc4 	addi	r2,r2,-1
 1831a90:	e0bfff15 	stw	r2,-4(fp)
  }

  ps = (u16_t *)pb;
 1831a94:	e0bff717 	ldw	r2,-36(fp)
 1831a98:	e0bff815 	stw	r2,-32(fp)

  if (((mem_ptr_t)ps & 3) && len > 1) {
 1831a9c:	e0bff817 	ldw	r2,-32(fp)
 1831aa0:	108000cc 	andi	r2,r2,3
 1831aa4:	10000e26 	beq	r2,zero,1831ae0 <lwip_standard_chksum+0xb4>
 1831aa8:	e0bfff17 	ldw	r2,-4(fp)
 1831aac:	10800090 	cmplti	r2,r2,2
 1831ab0:	10000b1e 	bne	r2,zero,1831ae0 <lwip_standard_chksum+0xb4>
    sum += *ps++;
 1831ab4:	e0bff817 	ldw	r2,-32(fp)
 1831ab8:	10c00084 	addi	r3,r2,2
 1831abc:	e0fff815 	stw	r3,-32(fp)
 1831ac0:	1080000b 	ldhu	r2,0(r2)
 1831ac4:	10bfffcc 	andi	r2,r2,65535
 1831ac8:	e0fffa17 	ldw	r3,-24(fp)
 1831acc:	1885883a 	add	r2,r3,r2
 1831ad0:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 1831ad4:	e0bfff17 	ldw	r2,-4(fp)
 1831ad8:	10bfff84 	addi	r2,r2,-2
 1831adc:	e0bfff15 	stw	r2,-4(fp)
  }

  pl = (u32_t *)ps;
 1831ae0:	e0bff817 	ldw	r2,-32(fp)
 1831ae4:	e0bff915 	stw	r2,-28(fp)

  while (len > 7)  {
 1831ae8:	00001d06 	br	1831b60 <lwip_standard_chksum+0x134>
    tmp = sum + *pl++;          /* ping */
 1831aec:	e0bff917 	ldw	r2,-28(fp)
 1831af0:	10c00104 	addi	r3,r2,4
 1831af4:	e0fff915 	stw	r3,-28(fp)
 1831af8:	10c00017 	ldw	r3,0(r2)
 1831afc:	e0bffa17 	ldw	r2,-24(fp)
 1831b00:	1885883a 	add	r2,r3,r2
 1831b04:	e0bffb15 	stw	r2,-20(fp)
    if (tmp < sum) {
 1831b08:	e0fffb17 	ldw	r3,-20(fp)
 1831b0c:	e0bffa17 	ldw	r2,-24(fp)
 1831b10:	1880032e 	bgeu	r3,r2,1831b20 <lwip_standard_chksum+0xf4>
      tmp++;                    /* add back carry */
 1831b14:	e0bffb17 	ldw	r2,-20(fp)
 1831b18:	10800044 	addi	r2,r2,1
 1831b1c:	e0bffb15 	stw	r2,-20(fp)
    }

    sum = tmp + *pl++;          /* pong */
 1831b20:	e0bff917 	ldw	r2,-28(fp)
 1831b24:	10c00104 	addi	r3,r2,4
 1831b28:	e0fff915 	stw	r3,-28(fp)
 1831b2c:	10c00017 	ldw	r3,0(r2)
 1831b30:	e0bffb17 	ldw	r2,-20(fp)
 1831b34:	1885883a 	add	r2,r3,r2
 1831b38:	e0bffa15 	stw	r2,-24(fp)
    if (sum < tmp) {
 1831b3c:	e0fffa17 	ldw	r3,-24(fp)
 1831b40:	e0bffb17 	ldw	r2,-20(fp)
 1831b44:	1880032e 	bgeu	r3,r2,1831b54 <lwip_standard_chksum+0x128>
      sum++;                    /* add back carry */
 1831b48:	e0bffa17 	ldw	r2,-24(fp)
 1831b4c:	10800044 	addi	r2,r2,1
 1831b50:	e0bffa15 	stw	r2,-24(fp)
    }

    len -= 8;
 1831b54:	e0bfff17 	ldw	r2,-4(fp)
 1831b58:	10bffe04 	addi	r2,r2,-8
 1831b5c:	e0bfff15 	stw	r2,-4(fp)
    len -= 2;
  }

  pl = (u32_t *)ps;

  while (len > 7)  {
 1831b60:	e0bfff17 	ldw	r2,-4(fp)
 1831b64:	10800208 	cmpgei	r2,r2,8
 1831b68:	103fe01e 	bne	r2,zero,1831aec <__ram_exceptions_end+0xff8216a8>

    len -= 8;
  }

  /* make room in upper bits */
  sum = FOLD_U32T(sum);
 1831b6c:	e0bffa17 	ldw	r2,-24(fp)
 1831b70:	1006d43a 	srli	r3,r2,16
 1831b74:	e0bffa17 	ldw	r2,-24(fp)
 1831b78:	10bfffcc 	andi	r2,r2,65535
 1831b7c:	1885883a 	add	r2,r3,r2
 1831b80:	e0bffa15 	stw	r2,-24(fp)

  ps = (u16_t *)pl;
 1831b84:	e0bff917 	ldw	r2,-28(fp)
 1831b88:	e0bff815 	stw	r2,-32(fp)

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 1831b8c:	00000b06 	br	1831bbc <lwip_standard_chksum+0x190>
    sum += *ps++;
 1831b90:	e0bff817 	ldw	r2,-32(fp)
 1831b94:	10c00084 	addi	r3,r2,2
 1831b98:	e0fff815 	stw	r3,-32(fp)
 1831b9c:	1080000b 	ldhu	r2,0(r2)
 1831ba0:	10bfffcc 	andi	r2,r2,65535
 1831ba4:	e0fffa17 	ldw	r3,-24(fp)
 1831ba8:	1885883a 	add	r2,r3,r2
 1831bac:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 1831bb0:	e0bfff17 	ldw	r2,-4(fp)
 1831bb4:	10bfff84 	addi	r2,r2,-2
 1831bb8:	e0bfff15 	stw	r2,-4(fp)
  sum = FOLD_U32T(sum);

  ps = (u16_t *)pl;

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 1831bbc:	e0bfff17 	ldw	r2,-4(fp)
 1831bc0:	10800088 	cmpgei	r2,r2,2
 1831bc4:	103ff21e 	bne	r2,zero,1831b90 <__ram_exceptions_end+0xff82174c>
    sum += *ps++;
    len -= 2;
  }

  /* dangling tail byte remaining? */
  if (len > 0) {                /* include odd byte */
 1831bc8:	e0bfff17 	ldw	r2,-4(fp)
 1831bcc:	0080040e 	bge	zero,r2,1831be0 <lwip_standard_chksum+0x1b4>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 1831bd0:	e0bffd04 	addi	r2,fp,-12
 1831bd4:	e0fff817 	ldw	r3,-32(fp)
 1831bd8:	18c00003 	ldbu	r3,0(r3)
 1831bdc:	10c00005 	stb	r3,0(r2)
  }

  sum += t;                     /* add end bytes */
 1831be0:	e0bffd0b 	ldhu	r2,-12(fp)
 1831be4:	10bfffcc 	andi	r2,r2,65535
 1831be8:	e0fffa17 	ldw	r3,-24(fp)
 1831bec:	1885883a 	add	r2,r3,r2
 1831bf0:	e0bffa15 	stw	r2,-24(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 1831bf4:	e0bffa17 	ldw	r2,-24(fp)
 1831bf8:	1006d43a 	srli	r3,r2,16
 1831bfc:	e0bffa17 	ldw	r2,-24(fp)
 1831c00:	10bfffcc 	andi	r2,r2,65535
 1831c04:	1885883a 	add	r2,r3,r2
 1831c08:	e0bffa15 	stw	r2,-24(fp)
  sum = FOLD_U32T(sum);
 1831c0c:	e0bffa17 	ldw	r2,-24(fp)
 1831c10:	1006d43a 	srli	r3,r2,16
 1831c14:	e0bffa17 	ldw	r2,-24(fp)
 1831c18:	10bfffcc 	andi	r2,r2,65535
 1831c1c:	1885883a 	add	r2,r3,r2
 1831c20:	e0bffa15 	stw	r2,-24(fp)

  if (odd) {
 1831c24:	e0bffc17 	ldw	r2,-16(fp)
 1831c28:	10000826 	beq	r2,zero,1831c4c <lwip_standard_chksum+0x220>
    sum = SWAP_BYTES_IN_WORD(sum);
 1831c2c:	e0bffa17 	ldw	r2,-24(fp)
 1831c30:	10bfc00c 	andi	r2,r2,65280
 1831c34:	1006d23a 	srli	r3,r2,8
 1831c38:	e0bffa17 	ldw	r2,-24(fp)
 1831c3c:	1004923a 	slli	r2,r2,8
 1831c40:	10bfffcc 	andi	r2,r2,65535
 1831c44:	1884b03a 	or	r2,r3,r2
 1831c48:	e0bffa15 	stw	r2,-24(fp)
  }

  return (u16_t)sum;
 1831c4c:	e0bffa17 	ldw	r2,-24(fp)
}
 1831c50:	e037883a 	mov	sp,fp
 1831c54:	df000017 	ldw	fp,0(sp)
 1831c58:	dec00104 	addi	sp,sp,4
 1831c5c:	f800283a 	ret

01831c60 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 1831c60:	defff504 	addi	sp,sp,-44
 1831c64:	dfc00a15 	stw	ra,40(sp)
 1831c68:	df000915 	stw	fp,36(sp)
 1831c6c:	df000904 	addi	fp,sp,36
 1831c70:	e13ffb15 	stw	r4,-20(fp)
 1831c74:	e17ffc15 	stw	r5,-16(fp)
 1831c78:	e1bffd15 	stw	r6,-12(fp)
 1831c7c:	3807883a 	mov	r3,r7
 1831c80:	e0800217 	ldw	r2,8(fp)
 1831c84:	e0fffe05 	stb	r3,-8(fp)
 1831c88:	e0bfff0d 	sth	r2,-4(fp)
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 1831c8c:	e03ff715 	stw	zero,-36(fp)
  swapped = 0;
 1831c90:	e03ff905 	stb	zero,-28(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 1831c94:	e0bffb17 	ldw	r2,-20(fp)
 1831c98:	e0bff815 	stw	r2,-32(fp)
 1831c9c:	00002606 	br	1831d38 <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 1831ca0:	e0bff817 	ldw	r2,-32(fp)
 1831ca4:	10c00117 	ldw	r3,4(r2)
 1831ca8:	e0bff817 	ldw	r2,-32(fp)
 1831cac:	1080028b 	ldhu	r2,10(r2)
 1831cb0:	10bfffcc 	andi	r2,r2,65535
 1831cb4:	100b883a 	mov	r5,r2
 1831cb8:	1809883a 	mov	r4,r3
 1831cbc:	1831a2c0 	call	1831a2c <lwip_standard_chksum>
 1831cc0:	10bfffcc 	andi	r2,r2,65535
 1831cc4:	e0fff717 	ldw	r3,-36(fp)
 1831cc8:	1885883a 	add	r2,r3,r2
 1831ccc:	e0bff715 	stw	r2,-36(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 1831cd0:	e0bff717 	ldw	r2,-36(fp)
 1831cd4:	1006d43a 	srli	r3,r2,16
 1831cd8:	e0bff717 	ldw	r2,-36(fp)
 1831cdc:	10bfffcc 	andi	r2,r2,65535
 1831ce0:	1885883a 	add	r2,r3,r2
 1831ce4:	e0bff715 	stw	r2,-36(fp)
    if (q->len % 2 != 0) {
 1831ce8:	e0bff817 	ldw	r2,-32(fp)
 1831cec:	1080028b 	ldhu	r2,10(r2)
 1831cf0:	1080004c 	andi	r2,r2,1
 1831cf4:	10bfffcc 	andi	r2,r2,65535
 1831cf8:	10000c26 	beq	r2,zero,1831d2c <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
 1831cfc:	e0bff903 	ldbu	r2,-28(fp)
 1831d00:	00c00044 	movi	r3,1
 1831d04:	1885c83a 	sub	r2,r3,r2
 1831d08:	e0bff905 	stb	r2,-28(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 1831d0c:	e0bff717 	ldw	r2,-36(fp)
 1831d10:	10bfc00c 	andi	r2,r2,65280
 1831d14:	1006d23a 	srli	r3,r2,8
 1831d18:	e0bff717 	ldw	r2,-36(fp)
 1831d1c:	1004923a 	slli	r2,r2,8
 1831d20:	10bfffcc 	andi	r2,r2,65535
 1831d24:	1884b03a 	or	r2,r3,r2
 1831d28:	e0bff715 	stw	r2,-36(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 1831d2c:	e0bff817 	ldw	r2,-32(fp)
 1831d30:	10800017 	ldw	r2,0(r2)
 1831d34:	e0bff815 	stw	r2,-32(fp)
 1831d38:	e0bff817 	ldw	r2,-32(fp)
 1831d3c:	103fd81e 	bne	r2,zero,1831ca0 <__ram_exceptions_end+0xff82185c>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 1831d40:	e0bff903 	ldbu	r2,-28(fp)
 1831d44:	10000826 	beq	r2,zero,1831d68 <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
 1831d48:	e0bff717 	ldw	r2,-36(fp)
 1831d4c:	10bfc00c 	andi	r2,r2,65280
 1831d50:	1006d23a 	srli	r3,r2,8
 1831d54:	e0bff717 	ldw	r2,-36(fp)
 1831d58:	1004923a 	slli	r2,r2,8
 1831d5c:	10bfffcc 	andi	r2,r2,65535
 1831d60:	1884b03a 	or	r2,r3,r2
 1831d64:	e0bff715 	stw	r2,-36(fp)
  }
  addr = ip4_addr_get_u32(src);
 1831d68:	e0bffc17 	ldw	r2,-16(fp)
 1831d6c:	10800017 	ldw	r2,0(r2)
 1831d70:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
 1831d74:	e0bffa17 	ldw	r2,-24(fp)
 1831d78:	10bfffcc 	andi	r2,r2,65535
 1831d7c:	e0fff717 	ldw	r3,-36(fp)
 1831d80:	1885883a 	add	r2,r3,r2
 1831d84:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
 1831d88:	e0bffa17 	ldw	r2,-24(fp)
 1831d8c:	1004d43a 	srli	r2,r2,16
 1831d90:	e0fff717 	ldw	r3,-36(fp)
 1831d94:	1885883a 	add	r2,r3,r2
 1831d98:	e0bff715 	stw	r2,-36(fp)
  addr = ip4_addr_get_u32(dest);
 1831d9c:	e0bffd17 	ldw	r2,-12(fp)
 1831da0:	10800017 	ldw	r2,0(r2)
 1831da4:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
 1831da8:	e0bffa17 	ldw	r2,-24(fp)
 1831dac:	10bfffcc 	andi	r2,r2,65535
 1831db0:	e0fff717 	ldw	r3,-36(fp)
 1831db4:	1885883a 	add	r2,r3,r2
 1831db8:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
 1831dbc:	e0bffa17 	ldw	r2,-24(fp)
 1831dc0:	1004d43a 	srli	r2,r2,16
 1831dc4:	e0fff717 	ldw	r3,-36(fp)
 1831dc8:	1885883a 	add	r2,r3,r2
 1831dcc:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons((u16_t)proto);
 1831dd0:	e0bffe03 	ldbu	r2,-8(fp)
 1831dd4:	1004923a 	slli	r2,r2,8
 1831dd8:	1007883a 	mov	r3,r2
 1831ddc:	e0bff717 	ldw	r2,-36(fp)
 1831de0:	10c5883a 	add	r2,r2,r3
 1831de4:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons(proto_len);
 1831de8:	e0bfff0b 	ldhu	r2,-4(fp)
 1831dec:	1004d23a 	srli	r2,r2,8
 1831df0:	10ffffcc 	andi	r3,r2,65535
 1831df4:	e0bfff0b 	ldhu	r2,-4(fp)
 1831df8:	1004923a 	slli	r2,r2,8
 1831dfc:	10bfffcc 	andi	r2,r2,65535
 1831e00:	1884b03a 	or	r2,r3,r2
 1831e04:	1007883a 	mov	r3,r2
 1831e08:	e0bff717 	ldw	r2,-36(fp)
 1831e0c:	10c5883a 	add	r2,r2,r3
 1831e10:	e0bff715 	stw	r2,-36(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 1831e14:	e0bff717 	ldw	r2,-36(fp)
 1831e18:	1006d43a 	srli	r3,r2,16
 1831e1c:	e0bff717 	ldw	r2,-36(fp)
 1831e20:	10bfffcc 	andi	r2,r2,65535
 1831e24:	1885883a 	add	r2,r3,r2
 1831e28:	e0bff715 	stw	r2,-36(fp)
  acc = FOLD_U32T(acc);
 1831e2c:	e0bff717 	ldw	r2,-36(fp)
 1831e30:	1006d43a 	srli	r3,r2,16
 1831e34:	e0bff717 	ldw	r2,-36(fp)
 1831e38:	10bfffcc 	andi	r2,r2,65535
 1831e3c:	1885883a 	add	r2,r3,r2
 1831e40:	e0bff715 	stw	r2,-36(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 1831e44:	e0bff717 	ldw	r2,-36(fp)
 1831e48:	0084303a 	nor	r2,zero,r2
}
 1831e4c:	e037883a 	mov	sp,fp
 1831e50:	dfc00117 	ldw	ra,4(sp)
 1831e54:	df000017 	ldw	fp,0(sp)
 1831e58:	dec00204 	addi	sp,sp,8
 1831e5c:	f800283a 	ret

01831e60 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
 1831e60:	defff404 	addi	sp,sp,-48
 1831e64:	dfc00b15 	stw	ra,44(sp)
 1831e68:	df000a15 	stw	fp,40(sp)
 1831e6c:	df000a04 	addi	fp,sp,40
 1831e70:	e13ffa15 	stw	r4,-24(fp)
 1831e74:	e17ffb15 	stw	r5,-20(fp)
 1831e78:	e1bffc15 	stw	r6,-16(fp)
 1831e7c:	3809883a 	mov	r4,r7
 1831e80:	e0c00217 	ldw	r3,8(fp)
 1831e84:	e0800317 	ldw	r2,12(fp)
 1831e88:	e13ffd05 	stb	r4,-12(fp)
 1831e8c:	e0fffe0d 	sth	r3,-8(fp)
 1831e90:	e0bfff0d 	sth	r2,-4(fp)
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
 1831e94:	e03ff615 	stw	zero,-40(fp)
  swapped = 0;
 1831e98:	e03ff805 	stb	zero,-32(fp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 1831e9c:	e0bffa17 	ldw	r2,-24(fp)
 1831ea0:	e0bff715 	stw	r2,-36(fp)
 1831ea4:	00003006 	br	1831f68 <inet_chksum_pseudo_partial+0x108>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
 1831ea8:	e0bff717 	ldw	r2,-36(fp)
 1831eac:	1080028b 	ldhu	r2,10(r2)
 1831eb0:	e0bff88d 	sth	r2,-30(fp)
    if (chklen > chksum_len) {
 1831eb4:	e0bff88b 	ldhu	r2,-30(fp)
 1831eb8:	e0ffff0b 	ldhu	r3,-4(fp)
 1831ebc:	1880022e 	bgeu	r3,r2,1831ec8 <inet_chksum_pseudo_partial+0x68>
      chklen = chksum_len;
 1831ec0:	e0bfff0b 	ldhu	r2,-4(fp)
 1831ec4:	e0bff88d 	sth	r2,-30(fp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 1831ec8:	e0bff717 	ldw	r2,-36(fp)
 1831ecc:	10800117 	ldw	r2,4(r2)
 1831ed0:	e0fff88b 	ldhu	r3,-30(fp)
 1831ed4:	180b883a 	mov	r5,r3
 1831ed8:	1009883a 	mov	r4,r2
 1831edc:	1831a2c0 	call	1831a2c <lwip_standard_chksum>
 1831ee0:	10bfffcc 	andi	r2,r2,65535
 1831ee4:	e0fff617 	ldw	r3,-40(fp)
 1831ee8:	1885883a 	add	r2,r3,r2
 1831eec:	e0bff615 	stw	r2,-40(fp)
    chksum_len -= chklen;
 1831ef0:	e0ffff0b 	ldhu	r3,-4(fp)
 1831ef4:	e0bff88b 	ldhu	r2,-30(fp)
 1831ef8:	1885c83a 	sub	r2,r3,r2
 1831efc:	e0bfff0d 	sth	r2,-4(fp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 1831f00:	e0bff617 	ldw	r2,-40(fp)
 1831f04:	1006d43a 	srli	r3,r2,16
 1831f08:	e0bff617 	ldw	r2,-40(fp)
 1831f0c:	10bfffcc 	andi	r2,r2,65535
 1831f10:	1885883a 	add	r2,r3,r2
 1831f14:	e0bff615 	stw	r2,-40(fp)
    if (q->len % 2 != 0) {
 1831f18:	e0bff717 	ldw	r2,-36(fp)
 1831f1c:	1080028b 	ldhu	r2,10(r2)
 1831f20:	1080004c 	andi	r2,r2,1
 1831f24:	10bfffcc 	andi	r2,r2,65535
 1831f28:	10000c26 	beq	r2,zero,1831f5c <inet_chksum_pseudo_partial+0xfc>
      swapped = 1 - swapped;
 1831f2c:	e0bff803 	ldbu	r2,-32(fp)
 1831f30:	00c00044 	movi	r3,1
 1831f34:	1885c83a 	sub	r2,r3,r2
 1831f38:	e0bff805 	stb	r2,-32(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 1831f3c:	e0bff617 	ldw	r2,-40(fp)
 1831f40:	10bfc00c 	andi	r2,r2,65280
 1831f44:	1006d23a 	srli	r3,r2,8
 1831f48:	e0bff617 	ldw	r2,-40(fp)
 1831f4c:	1004923a 	slli	r2,r2,8
 1831f50:	10bfffcc 	andi	r2,r2,65535
 1831f54:	1884b03a 	or	r2,r3,r2
 1831f58:	e0bff615 	stw	r2,-40(fp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 1831f5c:	e0bff717 	ldw	r2,-36(fp)
 1831f60:	10800017 	ldw	r2,0(r2)
 1831f64:	e0bff715 	stw	r2,-36(fp)
 1831f68:	e0bff717 	ldw	r2,-36(fp)
 1831f6c:	10000226 	beq	r2,zero,1831f78 <inet_chksum_pseudo_partial+0x118>
 1831f70:	e0bfff0b 	ldhu	r2,-4(fp)
 1831f74:	103fcc1e 	bne	r2,zero,1831ea8 <__ram_exceptions_end+0xff821a64>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 1831f78:	e0bff803 	ldbu	r2,-32(fp)
 1831f7c:	10000826 	beq	r2,zero,1831fa0 <inet_chksum_pseudo_partial+0x140>
    acc = SWAP_BYTES_IN_WORD(acc);
 1831f80:	e0bff617 	ldw	r2,-40(fp)
 1831f84:	10bfc00c 	andi	r2,r2,65280
 1831f88:	1006d23a 	srli	r3,r2,8
 1831f8c:	e0bff617 	ldw	r2,-40(fp)
 1831f90:	1004923a 	slli	r2,r2,8
 1831f94:	10bfffcc 	andi	r2,r2,65535
 1831f98:	1884b03a 	or	r2,r3,r2
 1831f9c:	e0bff615 	stw	r2,-40(fp)
  }
  addr = ip4_addr_get_u32(src);
 1831fa0:	e0bffb17 	ldw	r2,-20(fp)
 1831fa4:	10800017 	ldw	r2,0(r2)
 1831fa8:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
 1831fac:	e0bff917 	ldw	r2,-28(fp)
 1831fb0:	10bfffcc 	andi	r2,r2,65535
 1831fb4:	e0fff617 	ldw	r3,-40(fp)
 1831fb8:	1885883a 	add	r2,r3,r2
 1831fbc:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
 1831fc0:	e0bff917 	ldw	r2,-28(fp)
 1831fc4:	1004d43a 	srli	r2,r2,16
 1831fc8:	e0fff617 	ldw	r3,-40(fp)
 1831fcc:	1885883a 	add	r2,r3,r2
 1831fd0:	e0bff615 	stw	r2,-40(fp)
  addr = ip4_addr_get_u32(dest);
 1831fd4:	e0bffc17 	ldw	r2,-16(fp)
 1831fd8:	10800017 	ldw	r2,0(r2)
 1831fdc:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
 1831fe0:	e0bff917 	ldw	r2,-28(fp)
 1831fe4:	10bfffcc 	andi	r2,r2,65535
 1831fe8:	e0fff617 	ldw	r3,-40(fp)
 1831fec:	1885883a 	add	r2,r3,r2
 1831ff0:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
 1831ff4:	e0bff917 	ldw	r2,-28(fp)
 1831ff8:	1004d43a 	srli	r2,r2,16
 1831ffc:	e0fff617 	ldw	r3,-40(fp)
 1832000:	1885883a 	add	r2,r3,r2
 1832004:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons((u16_t)proto);
 1832008:	e0bffd03 	ldbu	r2,-12(fp)
 183200c:	1004923a 	slli	r2,r2,8
 1832010:	1007883a 	mov	r3,r2
 1832014:	e0bff617 	ldw	r2,-40(fp)
 1832018:	10c5883a 	add	r2,r2,r3
 183201c:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons(proto_len);
 1832020:	e0bffe0b 	ldhu	r2,-8(fp)
 1832024:	1004d23a 	srli	r2,r2,8
 1832028:	10ffffcc 	andi	r3,r2,65535
 183202c:	e0bffe0b 	ldhu	r2,-8(fp)
 1832030:	1004923a 	slli	r2,r2,8
 1832034:	10bfffcc 	andi	r2,r2,65535
 1832038:	1884b03a 	or	r2,r3,r2
 183203c:	1007883a 	mov	r3,r2
 1832040:	e0bff617 	ldw	r2,-40(fp)
 1832044:	10c5883a 	add	r2,r2,r3
 1832048:	e0bff615 	stw	r2,-40(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 183204c:	e0bff617 	ldw	r2,-40(fp)
 1832050:	1006d43a 	srli	r3,r2,16
 1832054:	e0bff617 	ldw	r2,-40(fp)
 1832058:	10bfffcc 	andi	r2,r2,65535
 183205c:	1885883a 	add	r2,r3,r2
 1832060:	e0bff615 	stw	r2,-40(fp)
  acc = FOLD_U32T(acc);
 1832064:	e0bff617 	ldw	r2,-40(fp)
 1832068:	1006d43a 	srli	r3,r2,16
 183206c:	e0bff617 	ldw	r2,-40(fp)
 1832070:	10bfffcc 	andi	r2,r2,65535
 1832074:	1885883a 	add	r2,r3,r2
 1832078:	e0bff615 	stw	r2,-40(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 183207c:	e0bff617 	ldw	r2,-40(fp)
 1832080:	0084303a 	nor	r2,zero,r2
}
 1832084:	e037883a 	mov	sp,fp
 1832088:	dfc00117 	ldw	ra,4(sp)
 183208c:	df000017 	ldw	fp,0(sp)
 1832090:	dec00204 	addi	sp,sp,8
 1832094:	f800283a 	ret

01832098 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 1832098:	defffc04 	addi	sp,sp,-16
 183209c:	dfc00315 	stw	ra,12(sp)
 18320a0:	df000215 	stw	fp,8(sp)
 18320a4:	df000204 	addi	fp,sp,8
 18320a8:	e13ffe15 	stw	r4,-8(fp)
 18320ac:	2805883a 	mov	r2,r5
 18320b0:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
 18320b4:	e0bfff0b 	ldhu	r2,-4(fp)
 18320b8:	100b883a 	mov	r5,r2
 18320bc:	e13ffe17 	ldw	r4,-8(fp)
 18320c0:	1831a2c0 	call	1831a2c <lwip_standard_chksum>
 18320c4:	0084303a 	nor	r2,zero,r2
}
 18320c8:	e037883a 	mov	sp,fp
 18320cc:	dfc00117 	ldw	ra,4(sp)
 18320d0:	df000017 	ldw	fp,0(sp)
 18320d4:	dec00204 	addi	sp,sp,8
 18320d8:	f800283a 	ret

018320dc <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 18320dc:	defffa04 	addi	sp,sp,-24
 18320e0:	dfc00515 	stw	ra,20(sp)
 18320e4:	df000415 	stw	fp,16(sp)
 18320e8:	df000404 	addi	fp,sp,16
 18320ec:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 18320f0:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
 18320f4:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
 18320f8:	e0bfff17 	ldw	r2,-4(fp)
 18320fc:	e0bffd15 	stw	r2,-12(fp)
 1832100:	00002606 	br	183219c <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
 1832104:	e0bffd17 	ldw	r2,-12(fp)
 1832108:	10c00117 	ldw	r3,4(r2)
 183210c:	e0bffd17 	ldw	r2,-12(fp)
 1832110:	1080028b 	ldhu	r2,10(r2)
 1832114:	10bfffcc 	andi	r2,r2,65535
 1832118:	100b883a 	mov	r5,r2
 183211c:	1809883a 	mov	r4,r3
 1832120:	1831a2c0 	call	1831a2c <lwip_standard_chksum>
 1832124:	10bfffcc 	andi	r2,r2,65535
 1832128:	e0fffc17 	ldw	r3,-16(fp)
 183212c:	1885883a 	add	r2,r3,r2
 1832130:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
 1832134:	e0bffc17 	ldw	r2,-16(fp)
 1832138:	1006d43a 	srli	r3,r2,16
 183213c:	e0bffc17 	ldw	r2,-16(fp)
 1832140:	10bfffcc 	andi	r2,r2,65535
 1832144:	1885883a 	add	r2,r3,r2
 1832148:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
 183214c:	e0bffd17 	ldw	r2,-12(fp)
 1832150:	1080028b 	ldhu	r2,10(r2)
 1832154:	1080004c 	andi	r2,r2,1
 1832158:	10bfffcc 	andi	r2,r2,65535
 183215c:	10000c26 	beq	r2,zero,1832190 <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
 1832160:	e0bffe03 	ldbu	r2,-8(fp)
 1832164:	00c00044 	movi	r3,1
 1832168:	1885c83a 	sub	r2,r3,r2
 183216c:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 1832170:	e0bffc17 	ldw	r2,-16(fp)
 1832174:	10bfc00c 	andi	r2,r2,65280
 1832178:	1006d23a 	srli	r3,r2,8
 183217c:	e0bffc17 	ldw	r2,-16(fp)
 1832180:	1004923a 	slli	r2,r2,8
 1832184:	10bfffcc 	andi	r2,r2,65535
 1832188:	1884b03a 	or	r2,r3,r2
 183218c:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 1832190:	e0bffd17 	ldw	r2,-12(fp)
 1832194:	10800017 	ldw	r2,0(r2)
 1832198:	e0bffd15 	stw	r2,-12(fp)
 183219c:	e0bffd17 	ldw	r2,-12(fp)
 18321a0:	103fd81e 	bne	r2,zero,1832104 <__ram_exceptions_end+0xff821cc0>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 18321a4:	e0bffe03 	ldbu	r2,-8(fp)
 18321a8:	10000826 	beq	r2,zero,18321cc <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
 18321ac:	e0bffc17 	ldw	r2,-16(fp)
 18321b0:	10bfc00c 	andi	r2,r2,65280
 18321b4:	1006d23a 	srli	r3,r2,8
 18321b8:	e0bffc17 	ldw	r2,-16(fp)
 18321bc:	1004923a 	slli	r2,r2,8
 18321c0:	10bfffcc 	andi	r2,r2,65535
 18321c4:	1884b03a 	or	r2,r3,r2
 18321c8:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
 18321cc:	e0bffc17 	ldw	r2,-16(fp)
 18321d0:	0084303a 	nor	r2,zero,r2
}
 18321d4:	e037883a 	mov	sp,fp
 18321d8:	dfc00117 	ldw	ra,4(sp)
 18321dc:	df000017 	ldw	fp,0(sp)
 18321e0:	dec00204 	addi	sp,sp,8
 18321e4:	f800283a 	ret

018321e8 <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 18321e8:	defffb04 	addi	sp,sp,-20
 18321ec:	dfc00415 	stw	ra,16(sp)
 18321f0:	df000315 	stw	fp,12(sp)
 18321f4:	df000304 	addi	fp,sp,12
 18321f8:	e13ffd15 	stw	r4,-12(fp)
 18321fc:	e17ffe15 	stw	r5,-8(fp)
 1832200:	3005883a 	mov	r2,r6
 1832204:	e0bfff0d 	sth	r2,-4(fp)
  MEMCPY(dst, src, len);
 1832208:	e0bfff0b 	ldhu	r2,-4(fp)
 183220c:	100d883a 	mov	r6,r2
 1832210:	e17ffe17 	ldw	r5,-8(fp)
 1832214:	e13ffd17 	ldw	r4,-12(fp)
 1832218:	180608c0 	call	180608c <memcpy>
  return LWIP_CHKSUM(dst, len);
 183221c:	e0bfff0b 	ldhu	r2,-4(fp)
 1832220:	100b883a 	mov	r5,r2
 1832224:	e13ffd17 	ldw	r4,-12(fp)
 1832228:	1831a2c0 	call	1831a2c <lwip_standard_chksum>
}
 183222c:	e037883a 	mov	sp,fp
 1832230:	dfc00117 	ldw	ra,4(sp)
 1832234:	df000017 	ldw	fp,0(sp)
 1832238:	dec00204 	addi	sp,sp,8
 183223c:	f800283a 	ret

01832240 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *src, ip_addr_t *dest)
{
 1832240:	defffc04 	addi	sp,sp,-16
 1832244:	df000315 	stw	fp,12(sp)
 1832248:	df000304 	addi	fp,sp,12
 183224c:	e13ffe15 	stw	r4,-8(fp)
 1832250:	e17fff15 	stw	r5,-4(fp)
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 1832254:	d0a7f317 	ldw	r2,-24628(gp)
 1832258:	e0bffd15 	stw	r2,-12(fp)
 183225c:	00001d06 	br	18322d4 <ip_route+0x94>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 1832260:	e0bffd17 	ldw	r2,-12(fp)
 1832264:	10800e43 	ldbu	r2,57(r2)
 1832268:	10803fcc 	andi	r2,r2,255
 183226c:	1080004c 	andi	r2,r2,1
 1832270:	10001526 	beq	r2,zero,18322c8 <ip_route+0x88>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 1832274:	e0bfff17 	ldw	r2,-4(fp)
 1832278:	10c00017 	ldw	r3,0(r2)
 183227c:	e0bffd17 	ldw	r2,-12(fp)
 1832280:	10800117 	ldw	r2,4(r2)
 1832284:	1886f03a 	xor	r3,r3,r2
 1832288:	e0bffd17 	ldw	r2,-12(fp)
 183228c:	10800217 	ldw	r2,8(r2)
 1832290:	1884703a 	and	r2,r3,r2
 1832294:	10000c1e 	bne	r2,zero,18322c8 <ip_route+0x88>
        if (!src || !src->addr || ip_addr_cmp(src, &(netif->ip_addr))) {
 1832298:	e0bffe17 	ldw	r2,-8(fp)
 183229c:	10000826 	beq	r2,zero,18322c0 <ip_route+0x80>
 18322a0:	e0bffe17 	ldw	r2,-8(fp)
 18322a4:	10800017 	ldw	r2,0(r2)
 18322a8:	10000526 	beq	r2,zero,18322c0 <ip_route+0x80>
 18322ac:	e0bffe17 	ldw	r2,-8(fp)
 18322b0:	10c00017 	ldw	r3,0(r2)
 18322b4:	e0bffd17 	ldw	r2,-12(fp)
 18322b8:	10800117 	ldw	r2,4(r2)
 18322bc:	1880021e 	bne	r3,r2,18322c8 <ip_route+0x88>
        /* return netif on which to forward IP packet */
        return netif;
 18322c0:	e0bffd17 	ldw	r2,-12(fp)
 18322c4:	00001606 	br	1832320 <ip_route+0xe0>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 18322c8:	e0bffd17 	ldw	r2,-12(fp)
 18322cc:	10800017 	ldw	r2,0(r2)
 18322d0:	e0bffd15 	stw	r2,-12(fp)
 18322d4:	e0bffd17 	ldw	r2,-12(fp)
 18322d8:	103fe11e 	bne	r2,zero,1832260 <__ram_exceptions_end+0xff821e1c>
        return netif;
      }
    }
  }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 18322dc:	d0a7f417 	ldw	r2,-24624(gp)
 18322e0:	10000526 	beq	r2,zero,18322f8 <ip_route+0xb8>
 18322e4:	d0a7f417 	ldw	r2,-24624(gp)
 18322e8:	10800e43 	ldbu	r2,57(r2)
 18322ec:	10803fcc 	andi	r2,r2,255
 18322f0:	1080004c 	andi	r2,r2,1
 18322f4:	1000091e 	bne	r2,zero,183231c <ip_route+0xdc>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 18322f8:	008061f4 	movhi	r2,391
 18322fc:	10a9d404 	addi	r2,r2,-22704
 1832300:	10802b17 	ldw	r2,172(r2)
 1832304:	10c00044 	addi	r3,r2,1
 1832308:	008061f4 	movhi	r2,391
 183230c:	10a9d404 	addi	r2,r2,-22704
 1832310:	10c02b15 	stw	r3,172(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
 1832314:	0005883a 	mov	r2,zero
 1832318:	00000106 	br	1832320 <ip_route+0xe0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
 183231c:	d0a7f417 	ldw	r2,-24624(gp)
}
 1832320:	e037883a 	mov	sp,fp
 1832324:	df000017 	ldw	fp,0(sp)
 1832328:	dec00104 	addi	sp,sp,4
 183232c:	f800283a 	ret

01832330 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 1832330:	defff604 	addi	sp,sp,-40
 1832334:	dfc00915 	stw	ra,36(sp)
 1832338:	df000815 	stw	fp,32(sp)
 183233c:	df000804 	addi	fp,sp,32
 1832340:	e13ffe15 	stw	r4,-8(fp)
 1832344:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
 1832348:	00800044 	movi	r2,1
 183234c:	e0bffa15 	stw	r2,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 1832350:	008061f4 	movhi	r2,391
 1832354:	10a9d404 	addi	r2,r2,-22704
 1832358:	10802517 	ldw	r2,148(r2)
 183235c:	10c00044 	addi	r3,r2,1
 1832360:	008061f4 	movhi	r2,391
 1832364:	10a9d404 	addi	r2,r2,-22704
 1832368:	10c02515 	stw	r3,148(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 183236c:	e0bffe17 	ldw	r2,-8(fp)
 1832370:	10800117 	ldw	r2,4(r2)
 1832374:	e0bff815 	stw	r2,-32(fp)
  if (IPH_V(iphdr) != 4) {
 1832378:	e0bff817 	ldw	r2,-32(fp)
 183237c:	10800003 	ldbu	r2,0(r2)
 1832380:	10803fcc 	andi	r2,r2,255
 1832384:	1004d13a 	srli	r2,r2,4
 1832388:	10803fcc 	andi	r2,r2,255
 183238c:	10800120 	cmpeqi	r2,r2,4
 1832390:	1000121e 	bne	r2,zero,18323dc <ip_input+0xac>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 1832394:	e13ffe17 	ldw	r4,-8(fp)
 1832398:	181aca40 	call	181aca4 <pbuf_free>
    IP_STATS_INC(ip.err);
 183239c:	008061f4 	movhi	r2,391
 18323a0:	10a9d404 	addi	r2,r2,-22704
 18323a4:	10802e17 	ldw	r2,184(r2)
 18323a8:	10c00044 	addi	r3,r2,1
 18323ac:	008061f4 	movhi	r2,391
 18323b0:	10a9d404 	addi	r2,r2,-22704
 18323b4:	10c02e15 	stw	r3,184(r2)
    IP_STATS_INC(ip.drop);
 18323b8:	008061f4 	movhi	r2,391
 18323bc:	10a9d404 	addi	r2,r2,-22704
 18323c0:	10802717 	ldw	r2,156(r2)
 18323c4:	10c00044 	addi	r3,r2,1
 18323c8:	008061f4 	movhi	r2,391
 18323cc:	10a9d404 	addi	r2,r2,-22704
 18323d0:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 18323d4:	0005883a 	mov	r2,zero
 18323d8:	00011f06 	br	1832858 <ip_input+0x528>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 18323dc:	e0bff817 	ldw	r2,-32(fp)
 18323e0:	10800003 	ldbu	r2,0(r2)
 18323e4:	10803fcc 	andi	r2,r2,255
 18323e8:	108003cc 	andi	r2,r2,15
 18323ec:	e0bffc0d 	sth	r2,-16(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 18323f0:	e0bffc0b 	ldhu	r2,-16(fp)
 18323f4:	1085883a 	add	r2,r2,r2
 18323f8:	1085883a 	add	r2,r2,r2
 18323fc:	e0bffc0d 	sth	r2,-16(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 1832400:	e0bff817 	ldw	r2,-32(fp)
 1832404:	10c00083 	ldbu	r3,2(r2)
 1832408:	108000c3 	ldbu	r2,3(r2)
 183240c:	1004923a 	slli	r2,r2,8
 1832410:	10c4b03a 	or	r2,r2,r3
 1832414:	10bfffcc 	andi	r2,r2,65535
 1832418:	1004d23a 	srli	r2,r2,8
 183241c:	1009883a 	mov	r4,r2
 1832420:	e0bff817 	ldw	r2,-32(fp)
 1832424:	10c00083 	ldbu	r3,2(r2)
 1832428:	108000c3 	ldbu	r2,3(r2)
 183242c:	1004923a 	slli	r2,r2,8
 1832430:	10c4b03a 	or	r2,r2,r3
 1832434:	10bfffcc 	andi	r2,r2,65535
 1832438:	1004923a 	slli	r2,r2,8
 183243c:	2084b03a 	or	r2,r4,r2
 1832440:	e0bffc8d 	sth	r2,-14(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 1832444:	e0bffe17 	ldw	r2,-8(fp)
 1832448:	1080028b 	ldhu	r2,10(r2)
 183244c:	10ffffcc 	andi	r3,r2,65535
 1832450:	e0bffc0b 	ldhu	r2,-16(fp)
 1832454:	18800536 	bltu	r3,r2,183246c <ip_input+0x13c>
 1832458:	e0bffe17 	ldw	r2,-8(fp)
 183245c:	1080020b 	ldhu	r2,8(r2)
 1832460:	10ffffcc 	andi	r3,r2,65535
 1832464:	e0bffc8b 	ldhu	r2,-14(fp)
 1832468:	1880122e 	bgeu	r3,r2,18324b4 <ip_input+0x184>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 183246c:	e13ffe17 	ldw	r4,-8(fp)
 1832470:	181aca40 	call	181aca4 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 1832474:	008061f4 	movhi	r2,391
 1832478:	10a9d404 	addi	r2,r2,-22704
 183247c:	10802917 	ldw	r2,164(r2)
 1832480:	10c00044 	addi	r3,r2,1
 1832484:	008061f4 	movhi	r2,391
 1832488:	10a9d404 	addi	r2,r2,-22704
 183248c:	10c02915 	stw	r3,164(r2)
    IP_STATS_INC(ip.drop);
 1832490:	008061f4 	movhi	r2,391
 1832494:	10a9d404 	addi	r2,r2,-22704
 1832498:	10802717 	ldw	r2,156(r2)
 183249c:	10c00044 	addi	r3,r2,1
 18324a0:	008061f4 	movhi	r2,391
 18324a4:	10a9d404 	addi	r2,r2,-22704
 18324a8:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
 18324ac:	0005883a 	mov	r2,zero
 18324b0:	0000e906 	br	1832858 <ip_input+0x528>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 18324b4:	e0bffc0b 	ldhu	r2,-16(fp)
 18324b8:	100b883a 	mov	r5,r2
 18324bc:	e13ff817 	ldw	r4,-32(fp)
 18324c0:	18320980 	call	1832098 <inet_chksum>
 18324c4:	10bfffcc 	andi	r2,r2,65535
 18324c8:	10001226 	beq	r2,zero,1832514 <ip_input+0x1e4>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
 18324cc:	e13ffe17 	ldw	r4,-8(fp)
 18324d0:	181aca40 	call	181aca4 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 18324d4:	008061f4 	movhi	r2,391
 18324d8:	10a9d404 	addi	r2,r2,-22704
 18324dc:	10802817 	ldw	r2,160(r2)
 18324e0:	10c00044 	addi	r3,r2,1
 18324e4:	008061f4 	movhi	r2,391
 18324e8:	10a9d404 	addi	r2,r2,-22704
 18324ec:	10c02815 	stw	r3,160(r2)
    IP_STATS_INC(ip.drop);
 18324f0:	008061f4 	movhi	r2,391
 18324f4:	10a9d404 	addi	r2,r2,-22704
 18324f8:	10802717 	ldw	r2,156(r2)
 18324fc:	10c00044 	addi	r3,r2,1
 1832500:	008061f4 	movhi	r2,391
 1832504:	10a9d404 	addi	r2,r2,-22704
 1832508:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 183250c:	0005883a 	mov	r2,zero
 1832510:	0000d106 	br	1832858 <ip_input+0x528>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 1832514:	e0bffc8b 	ldhu	r2,-14(fp)
 1832518:	100b883a 	mov	r5,r2
 183251c:	e13ffe17 	ldw	r4,-8(fp)
 1832520:	181a9940 	call	181a994 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 1832524:	e0bff817 	ldw	r2,-32(fp)
 1832528:	10c00403 	ldbu	r3,16(r2)
 183252c:	11000443 	ldbu	r4,17(r2)
 1832530:	2008923a 	slli	r4,r4,8
 1832534:	20c6b03a 	or	r3,r4,r3
 1832538:	11000483 	ldbu	r4,18(r2)
 183253c:	2008943a 	slli	r4,r4,16
 1832540:	20c6b03a 	or	r3,r4,r3
 1832544:	108004c3 	ldbu	r2,19(r2)
 1832548:	1004963a 	slli	r2,r2,24
 183254c:	10c4b03a 	or	r2,r2,r3
 1832550:	d0a81415 	stw	r2,-24496(gp)
  ip_addr_copy(current_iphdr_src, iphdr->src);
 1832554:	e0bff817 	ldw	r2,-32(fp)
 1832558:	10c00303 	ldbu	r3,12(r2)
 183255c:	11000343 	ldbu	r4,13(r2)
 1832560:	2008923a 	slli	r4,r4,8
 1832564:	20c6b03a 	or	r3,r4,r3
 1832568:	11000383 	ldbu	r4,14(r2)
 183256c:	2008943a 	slli	r4,r4,16
 1832570:	20c6b03a 	or	r3,r4,r3
 1832574:	108003c3 	ldbu	r2,15(r2)
 1832578:	1004963a 	slli	r2,r2,24
 183257c:	10c4b03a 	or	r2,r2,r3
 1832580:	d0a81215 	stw	r2,-24504(gp)
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 1832584:	00800044 	movi	r2,1
 1832588:	e0bffb15 	stw	r2,-20(fp)
    netif = inp;
 183258c:	e0bfff17 	ldw	r2,-4(fp)
 1832590:	e0bff915 	stw	r2,-28(fp)
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 1832594:	e0bff917 	ldw	r2,-28(fp)
 1832598:	10800e43 	ldbu	r2,57(r2)
 183259c:	10803fcc 	andi	r2,r2,255
 18325a0:	1080004c 	andi	r2,r2,1
 18325a4:	10001026 	beq	r2,zero,18325e8 <ip_input+0x2b8>
 18325a8:	e0bff917 	ldw	r2,-28(fp)
 18325ac:	10800104 	addi	r2,r2,4
 18325b0:	10000d26 	beq	r2,zero,18325e8 <ip_input+0x2b8>
 18325b4:	e0bff917 	ldw	r2,-28(fp)
 18325b8:	10800117 	ldw	r2,4(r2)
 18325bc:	10000a26 	beq	r2,zero,18325e8 <ip_input+0x2b8>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 18325c0:	d0e81417 	ldw	r3,-24496(gp)
 18325c4:	e0bff917 	ldw	r2,-28(fp)
 18325c8:	10800117 	ldw	r2,4(r2)
 18325cc:	18801726 	beq	r3,r2,183262c <ip_input+0x2fc>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 18325d0:	d0a81417 	ldw	r2,-24496(gp)
 18325d4:	e17ff917 	ldw	r5,-28(fp)
 18325d8:	1009883a 	mov	r4,r2
 18325dc:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 18325e0:	10803fcc 	andi	r2,r2,255
 18325e4:	1000111e 	bne	r2,zero,183262c <ip_input+0x2fc>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 18325e8:	e0bffb17 	ldw	r2,-20(fp)
 18325ec:	10000426 	beq	r2,zero,1832600 <ip_input+0x2d0>
        first = 0;
 18325f0:	e03ffb15 	stw	zero,-20(fp)
        netif = netif_list;
 18325f4:	d0a7f317 	ldw	r2,-24628(gp)
 18325f8:	e0bff915 	stw	r2,-28(fp)
 18325fc:	00000306 	br	183260c <ip_input+0x2dc>
      } else {
        netif = netif->next;
 1832600:	e0bff917 	ldw	r2,-28(fp)
 1832604:	10800017 	ldw	r2,0(r2)
 1832608:	e0bff915 	stw	r2,-28(fp)
      }
      if (netif == inp) {
 183260c:	e0fff917 	ldw	r3,-28(fp)
 1832610:	e0bfff17 	ldw	r2,-4(fp)
 1832614:	1880031e 	bne	r3,r2,1832624 <ip_input+0x2f4>
        netif = netif->next;
 1832618:	e0bff917 	ldw	r2,-28(fp)
 183261c:	10800017 	ldw	r2,0(r2)
 1832620:	e0bff915 	stw	r2,-28(fp)
      }
    } while(netif != NULL);
 1832624:	e0bff917 	ldw	r2,-28(fp)
 1832628:	103fda1e 	bne	r2,zero,1832594 <__ram_exceptions_end+0xff822150>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
 183262c:	e0bff917 	ldw	r2,-28(fp)
 1832630:	1000141e 	bne	r2,zero,1832684 <ip_input+0x354>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 1832634:	e0bff817 	ldw	r2,-32(fp)
 1832638:	10800243 	ldbu	r2,9(r2)
 183263c:	10803fcc 	andi	r2,r2,255
 1832640:	10800458 	cmpnei	r2,r2,17
 1832644:	10000f1e 	bne	r2,zero,1832684 <ip_input+0x354>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
 1832648:	e0bffc0b 	ldhu	r2,-16(fp)
 183264c:	e0fff817 	ldw	r3,-32(fp)
 1832650:	1885883a 	add	r2,r3,r2
 1832654:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 1832658:	e0bffd17 	ldw	r2,-12(fp)
 183265c:	10c00083 	ldbu	r3,2(r2)
 1832660:	108000c3 	ldbu	r2,3(r2)
 1832664:	1004923a 	slli	r2,r2,8
 1832668:	10c4b03a 	or	r2,r2,r3
 183266c:	10bfffcc 	andi	r2,r2,65535
 1832670:	10910018 	cmpnei	r2,r2,17408
 1832674:	1000031e 	bne	r2,zero,1832684 <ip_input+0x354>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
 1832678:	e0bfff17 	ldw	r2,-4(fp)
 183267c:	e0bff915 	stw	r2,-28(fp)
        check_ip_src = 0;
 1832680:	e03ffa15 	stw	zero,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 1832684:	e0bffa17 	ldw	r2,-24(fp)
 1832688:	10001726 	beq	r2,zero,18326e8 <ip_input+0x3b8>
 183268c:	d0a81217 	ldw	r2,-24504(gp)
 1832690:	10001526 	beq	r2,zero,18326e8 <ip_input+0x3b8>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 1832694:	d0a81217 	ldw	r2,-24504(gp)
 1832698:	e17fff17 	ldw	r5,-4(fp)
 183269c:	1009883a 	mov	r4,r2
 18326a0:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 18326a4:	10803fcc 	andi	r2,r2,255
 18326a8:	1000041e 	bne	r2,zero,18326bc <ip_input+0x38c>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 18326ac:	d0a81217 	ldw	r2,-24504(gp)
 18326b0:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 18326b4:	10803818 	cmpnei	r2,r2,224
 18326b8:	10000b1e 	bne	r2,zero,18326e8 <ip_input+0x3b8>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 18326bc:	e13ffe17 	ldw	r4,-8(fp)
 18326c0:	181aca40 	call	181aca4 <pbuf_free>
      IP_STATS_INC(ip.drop);
 18326c4:	008061f4 	movhi	r2,391
 18326c8:	10a9d404 	addi	r2,r2,-22704
 18326cc:	10802717 	ldw	r2,156(r2)
 18326d0:	10c00044 	addi	r3,r2,1
 18326d4:	008061f4 	movhi	r2,391
 18326d8:	10a9d404 	addi	r2,r2,-22704
 18326dc:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 18326e0:	0005883a 	mov	r2,zero
 18326e4:	00005c06 	br	1832858 <ip_input+0x528>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 18326e8:	e0bff917 	ldw	r2,-28(fp)
 18326ec:	1000041e 	bne	r2,zero,1832700 <ip_input+0x3d0>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 18326f0:	e13ffe17 	ldw	r4,-8(fp)
 18326f4:	181aca40 	call	181aca4 <pbuf_free>
    return ERR_OK;
 18326f8:	0005883a 	mov	r2,zero
 18326fc:	00005606 	br	1832858 <ip_input+0x528>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 1832700:	e0bff817 	ldw	r2,-32(fp)
 1832704:	10c00183 	ldbu	r3,6(r2)
 1832708:	108001c3 	ldbu	r2,7(r2)
 183270c:	1004923a 	slli	r2,r2,8
 1832710:	10c4b03a 	or	r2,r2,r3
 1832714:	10bfffcc 	andi	r2,r2,65535
 1832718:	10bfcfcc 	andi	r2,r2,65343
 183271c:	10000a26 	beq	r2,zero,1832748 <ip_input+0x418>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 1832720:	e13ffe17 	ldw	r4,-8(fp)
 1832724:	1833c400 	call	1833c40 <ip_reass>
 1832728:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 183272c:	e0bffe17 	ldw	r2,-8(fp)
 1832730:	1000021e 	bne	r2,zero,183273c <ip_input+0x40c>
      return ERR_OK;
 1832734:	0005883a 	mov	r2,zero
 1832738:	00004706 	br	1832858 <ip_input+0x528>
    }
    iphdr = (struct ip_hdr *)p->payload;
 183273c:	e0bffe17 	ldw	r2,-8(fp)
 1832740:	10800117 	ldw	r2,4(r2)
 1832744:	e0bff815 	stw	r2,-32(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 1832748:	e0bfff17 	ldw	r2,-4(fp)
 183274c:	d0a81315 	stw	r2,-24500(gp)
  current_header = iphdr;
 1832750:	e0bff817 	ldw	r2,-32(fp)
 1832754:	d0a81515 	stw	r2,-24492(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 1832758:	e17fff17 	ldw	r5,-4(fp)
 183275c:	e13ffe17 	ldw	r4,-8(fp)
 1832760:	1834c0c0 	call	1834c0c <raw_input>
 1832764:	10803fcc 	andi	r2,r2,255
 1832768:	1000361e 	bne	r2,zero,1832844 <ip_input+0x514>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 183276c:	e0bff817 	ldw	r2,-32(fp)
 1832770:	10800243 	ldbu	r2,9(r2)
 1832774:	10803fcc 	andi	r2,r2,255
 1832778:	10c001a0 	cmpeqi	r3,r2,6
 183277c:	1800091e 	bne	r3,zero,18327a4 <ip_input+0x474>
 1832780:	10c00460 	cmpeqi	r3,r2,17
 1832784:	1800031e 	bne	r3,zero,1832794 <ip_input+0x464>
 1832788:	10800060 	cmpeqi	r2,r2,1
 183278c:	1000091e 	bne	r2,zero,18327b4 <ip_input+0x484>
 1832790:	00000c06 	br	18327c4 <ip_input+0x494>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 1832794:	e17fff17 	ldw	r5,-4(fp)
 1832798:	e13ffe17 	ldw	r4,-8(fp)
 183279c:	1821cb40 	call	1821cb4 <udp_input>
      break;
 18327a0:	00002806 	br	1832844 <ip_input+0x514>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 18327a4:	e17fff17 	ldw	r5,-4(fp)
 18327a8:	e13ffe17 	ldw	r4,-8(fp)
 18327ac:	18351640 	call	1835164 <tcp_input>
      break;
 18327b0:	00002406 	br	1832844 <ip_input+0x514>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 18327b4:	e17fff17 	ldw	r5,-4(fp)
 18327b8:	e13ffe17 	ldw	r4,-8(fp)
 18327bc:	18311c00 	call	18311c0 <icmp_input>
      break;
 18327c0:	00002006 	br	1832844 <ip_input+0x514>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 18327c4:	d0a81417 	ldw	r2,-24496(gp)
 18327c8:	e17fff17 	ldw	r5,-4(fp)
 18327cc:	1009883a 	mov	r4,r2
 18327d0:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 18327d4:	10803fcc 	andi	r2,r2,255
 18327d8:	10000a1e 	bne	r2,zero,1832804 <ip_input+0x4d4>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 18327dc:	d0a81417 	ldw	r2,-24496(gp)
 18327e0:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 18327e4:	10803820 	cmpeqi	r2,r2,224
 18327e8:	1000061e 	bne	r2,zero,1832804 <ip_input+0x4d4>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 18327ec:	e0bffe17 	ldw	r2,-8(fp)
 18327f0:	e0fff817 	ldw	r3,-32(fp)
 18327f4:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 18327f8:	01400084 	movi	r5,2
 18327fc:	e13ffe17 	ldw	r4,-8(fp)
 1832800:	18317bc0 	call	18317bc <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 1832804:	e13ffe17 	ldw	r4,-8(fp)
 1832808:	181aca40 	call	181aca4 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
 183280c:	008061f4 	movhi	r2,391
 1832810:	10a9d404 	addi	r2,r2,-22704
 1832814:	10802c17 	ldw	r2,176(r2)
 1832818:	10c00044 	addi	r3,r2,1
 183281c:	008061f4 	movhi	r2,391
 1832820:	10a9d404 	addi	r2,r2,-22704
 1832824:	10c02c15 	stw	r3,176(r2)
      IP_STATS_INC(ip.drop);
 1832828:	008061f4 	movhi	r2,391
 183282c:	10a9d404 	addi	r2,r2,-22704
 1832830:	10802717 	ldw	r2,156(r2)
 1832834:	10c00044 	addi	r3,r2,1
 1832838:	008061f4 	movhi	r2,391
 183283c:	10a9d404 	addi	r2,r2,-22704
 1832840:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 1832844:	d0281315 	stw	zero,-24500(gp)
  current_header = NULL;
 1832848:	d0281515 	stw	zero,-24492(gp)
  ip_addr_set_any(&current_iphdr_src);
 183284c:	d0281215 	stw	zero,-24504(gp)
  ip_addr_set_any(&current_iphdr_dest);
 1832850:	d0281415 	stw	zero,-24496(gp)

  return ERR_OK;
 1832854:	0005883a 	mov	r2,zero
}
 1832858:	e037883a 	mov	sp,fp
 183285c:	dfc00117 	ldw	ra,4(sp)
 1832860:	df000017 	ldw	fp,0(sp)
 1832864:	dec00204 	addi	sp,sp,8
 1832868:	f800283a 	ret

0183286c <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 183286c:	defff404 	addi	sp,sp,-48
 1832870:	dfc00b15 	stw	ra,44(sp)
 1832874:	df000a15 	stw	fp,40(sp)
 1832878:	df000a04 	addi	fp,sp,40
 183287c:	e13ffa15 	stw	r4,-24(fp)
 1832880:	e17ffb15 	stw	r5,-20(fp)
 1832884:	e1bffc15 	stw	r6,-16(fp)
 1832888:	3809883a 	mov	r4,r7
 183288c:	e0c00217 	ldw	r3,8(fp)
 1832890:	e0800317 	ldw	r2,12(fp)
 1832894:	e13ffd05 	stb	r4,-12(fp)
 1832898:	e0fffe05 	stb	r3,-8(fp)
 183289c:	e0bfff05 	stb	r2,-4(fp)
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 18328a0:	e03ff615 	stw	zero,-40(fp)
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 18328a4:	e0bffc17 	ldw	r2,-16(fp)
 18328a8:	10015026 	beq	r2,zero,1832dec <ip_output_if+0x580>
    u16_t ip_hlen = IP_HLEN;
 18328ac:	00800504 	movi	r2,20
 18328b0:	e0bff70d 	sth	r2,-36(fp)
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 18328b4:	01400504 	movi	r5,20
 18328b8:	e13ffa17 	ldw	r4,-24(fp)
 18328bc:	181aaf40 	call	181aaf4 <pbuf_header>
 18328c0:	10803fcc 	andi	r2,r2,255
 18328c4:	10000926 	beq	r2,zero,18328ec <ip_output_if+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
 18328c8:	008061f4 	movhi	r2,391
 18328cc:	10a9d404 	addi	r2,r2,-22704
 18328d0:	10802e17 	ldw	r2,184(r2)
 18328d4:	10c00044 	addi	r3,r2,1
 18328d8:	008061f4 	movhi	r2,391
 18328dc:	10a9d404 	addi	r2,r2,-22704
 18328e0:	10c02e15 	stw	r3,184(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 18328e4:	00bfff84 	movi	r2,-2
 18328e8:	00016e06 	br	1832ea4 <ip_output_if+0x638>
    }

    iphdr = (struct ip_hdr *)p->payload;
 18328ec:	e0bffa17 	ldw	r2,-24(fp)
 18328f0:	10800117 	ldw	r2,4(r2)
 18328f4:	e0bff815 	stw	r2,-32(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 18328f8:	e0bff817 	ldw	r2,-32(fp)
 18328fc:	e0fffd03 	ldbu	r3,-12(fp)
 1832900:	10c00205 	stb	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
 1832904:	e0bff817 	ldw	r2,-32(fp)
 1832908:	e0ffff03 	ldbu	r3,-4(fp)
 183290c:	10c00245 	stb	r3,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 1832910:	e0bfff03 	ldbu	r2,-4(fp)
 1832914:	1006923a 	slli	r3,r2,8
 1832918:	e0bffd03 	ldbu	r2,-12(fp)
 183291c:	1884b03a 	or	r2,r3,r2
 1832920:	1007883a 	mov	r3,r2
 1832924:	e0bff617 	ldw	r2,-40(fp)
 1832928:	10c5883a 	add	r2,r2,r3
 183292c:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 1832930:	e0bffc17 	ldw	r2,-16(fp)
 1832934:	10c00017 	ldw	r3,0(r2)
 1832938:	e0bff817 	ldw	r2,-32(fp)
 183293c:	19803fcc 	andi	r6,r3,255
 1832940:	11000403 	ldbu	r4,16(r2)
 1832944:	2008703a 	and	r4,r4,zero
 1832948:	200b883a 	mov	r5,r4
 183294c:	3009883a 	mov	r4,r6
 1832950:	2908b03a 	or	r4,r5,r4
 1832954:	11000405 	stb	r4,16(r2)
 1832958:	1808d23a 	srli	r4,r3,8
 183295c:	21803fcc 	andi	r6,r4,255
 1832960:	11000443 	ldbu	r4,17(r2)
 1832964:	2008703a 	and	r4,r4,zero
 1832968:	200b883a 	mov	r5,r4
 183296c:	3009883a 	mov	r4,r6
 1832970:	2908b03a 	or	r4,r5,r4
 1832974:	11000445 	stb	r4,17(r2)
 1832978:	1808d43a 	srli	r4,r3,16
 183297c:	21803fcc 	andi	r6,r4,255
 1832980:	11000483 	ldbu	r4,18(r2)
 1832984:	2008703a 	and	r4,r4,zero
 1832988:	200b883a 	mov	r5,r4
 183298c:	3009883a 	mov	r4,r6
 1832990:	2908b03a 	or	r4,r5,r4
 1832994:	11000485 	stb	r4,18(r2)
 1832998:	180ad63a 	srli	r5,r3,24
 183299c:	10c004c3 	ldbu	r3,19(r2)
 18329a0:	1806703a 	and	r3,r3,zero
 18329a4:	1809883a 	mov	r4,r3
 18329a8:	2807883a 	mov	r3,r5
 18329ac:	20c6b03a 	or	r3,r4,r3
 18329b0:	10c004c5 	stb	r3,19(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 18329b4:	e0bff817 	ldw	r2,-32(fp)
 18329b8:	10c00403 	ldbu	r3,16(r2)
 18329bc:	11000443 	ldbu	r4,17(r2)
 18329c0:	2008923a 	slli	r4,r4,8
 18329c4:	20c6b03a 	or	r3,r4,r3
 18329c8:	11000483 	ldbu	r4,18(r2)
 18329cc:	2008943a 	slli	r4,r4,16
 18329d0:	20c6b03a 	or	r3,r4,r3
 18329d4:	108004c3 	ldbu	r2,19(r2)
 18329d8:	1004963a 	slli	r2,r2,24
 18329dc:	10c4b03a 	or	r2,r2,r3
 18329e0:	10bfffcc 	andi	r2,r2,65535
 18329e4:	e0fff617 	ldw	r3,-40(fp)
 18329e8:	1885883a 	add	r2,r3,r2
 18329ec:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 18329f0:	e0bff817 	ldw	r2,-32(fp)
 18329f4:	10c00403 	ldbu	r3,16(r2)
 18329f8:	11000443 	ldbu	r4,17(r2)
 18329fc:	2008923a 	slli	r4,r4,8
 1832a00:	20c6b03a 	or	r3,r4,r3
 1832a04:	11000483 	ldbu	r4,18(r2)
 1832a08:	2008943a 	slli	r4,r4,16
 1832a0c:	20c6b03a 	or	r3,r4,r3
 1832a10:	108004c3 	ldbu	r2,19(r2)
 1832a14:	1004963a 	slli	r2,r2,24
 1832a18:	10c4b03a 	or	r2,r2,r3
 1832a1c:	1004d43a 	srli	r2,r2,16
 1832a20:	e0fff617 	ldw	r3,-40(fp)
 1832a24:	1885883a 	add	r2,r3,r2
 1832a28:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 1832a2c:	e0bff70b 	ldhu	r2,-36(fp)
 1832a30:	1004d0ba 	srli	r2,r2,2
 1832a34:	10801014 	ori	r2,r2,64
 1832a38:	1007883a 	mov	r3,r2
 1832a3c:	e0bff817 	ldw	r2,-32(fp)
 1832a40:	10c00005 	stb	r3,0(r2)
    IPH_TOS_SET(iphdr, tos);
 1832a44:	e0bff817 	ldw	r2,-32(fp)
 1832a48:	e0fffe03 	ldbu	r3,-8(fp)
 1832a4c:	10c00045 	stb	r3,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 1832a50:	e0bffe03 	ldbu	r2,-8(fp)
 1832a54:	1006923a 	slli	r3,r2,8
 1832a58:	e0bff817 	ldw	r2,-32(fp)
 1832a5c:	10800003 	ldbu	r2,0(r2)
 1832a60:	10803fcc 	andi	r2,r2,255
 1832a64:	1884b03a 	or	r2,r3,r2
 1832a68:	1007883a 	mov	r3,r2
 1832a6c:	e0bff617 	ldw	r2,-40(fp)
 1832a70:	10c5883a 	add	r2,r2,r3
 1832a74:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 1832a78:	e0bffa17 	ldw	r2,-24(fp)
 1832a7c:	1080020b 	ldhu	r2,8(r2)
 1832a80:	10bfffcc 	andi	r2,r2,65535
 1832a84:	1004d23a 	srli	r2,r2,8
 1832a88:	1007883a 	mov	r3,r2
 1832a8c:	e0bffa17 	ldw	r2,-24(fp)
 1832a90:	1080020b 	ldhu	r2,8(r2)
 1832a94:	10bfffcc 	andi	r2,r2,65535
 1832a98:	1004923a 	slli	r2,r2,8
 1832a9c:	1884b03a 	or	r2,r3,r2
 1832aa0:	100d883a 	mov	r6,r2
 1832aa4:	e0bff817 	ldw	r2,-32(fp)
 1832aa8:	30ffffcc 	andi	r3,r6,65535
 1832aac:	19403fcc 	andi	r5,r3,255
 1832ab0:	10c00083 	ldbu	r3,2(r2)
 1832ab4:	1806703a 	and	r3,r3,zero
 1832ab8:	1809883a 	mov	r4,r3
 1832abc:	2807883a 	mov	r3,r5
 1832ac0:	20c6b03a 	or	r3,r4,r3
 1832ac4:	10c00085 	stb	r3,2(r2)
 1832ac8:	30ffffcc 	andi	r3,r6,65535
 1832acc:	1806d23a 	srli	r3,r3,8
 1832ad0:	197fffcc 	andi	r5,r3,65535
 1832ad4:	10c000c3 	ldbu	r3,3(r2)
 1832ad8:	1806703a 	and	r3,r3,zero
 1832adc:	1809883a 	mov	r4,r3
 1832ae0:	2807883a 	mov	r3,r5
 1832ae4:	20c6b03a 	or	r3,r4,r3
 1832ae8:	10c000c5 	stb	r3,3(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 1832aec:	e0bff817 	ldw	r2,-32(fp)
 1832af0:	10c00083 	ldbu	r3,2(r2)
 1832af4:	108000c3 	ldbu	r2,3(r2)
 1832af8:	1004923a 	slli	r2,r2,8
 1832afc:	10c4b03a 	or	r2,r2,r3
 1832b00:	10bfffcc 	andi	r2,r2,65535
 1832b04:	e0fff617 	ldw	r3,-40(fp)
 1832b08:	1885883a 	add	r2,r3,r2
 1832b0c:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 1832b10:	e0bff817 	ldw	r2,-32(fp)
 1832b14:	10c00183 	ldbu	r3,6(r2)
 1832b18:	1806703a 	and	r3,r3,zero
 1832b1c:	10c00185 	stb	r3,6(r2)
 1832b20:	10c001c3 	ldbu	r3,7(r2)
 1832b24:	1806703a 	and	r3,r3,zero
 1832b28:	10c001c5 	stb	r3,7(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
 1832b2c:	d0a8110b 	ldhu	r2,-24508(gp)
 1832b30:	10bfffcc 	andi	r2,r2,65535
 1832b34:	1004d23a 	srli	r2,r2,8
 1832b38:	1007883a 	mov	r3,r2
 1832b3c:	d0a8110b 	ldhu	r2,-24508(gp)
 1832b40:	10bfffcc 	andi	r2,r2,65535
 1832b44:	1004923a 	slli	r2,r2,8
 1832b48:	1884b03a 	or	r2,r3,r2
 1832b4c:	100d883a 	mov	r6,r2
 1832b50:	e0bff817 	ldw	r2,-32(fp)
 1832b54:	30ffffcc 	andi	r3,r6,65535
 1832b58:	19403fcc 	andi	r5,r3,255
 1832b5c:	10c00103 	ldbu	r3,4(r2)
 1832b60:	1806703a 	and	r3,r3,zero
 1832b64:	1809883a 	mov	r4,r3
 1832b68:	2807883a 	mov	r3,r5
 1832b6c:	20c6b03a 	or	r3,r4,r3
 1832b70:	10c00105 	stb	r3,4(r2)
 1832b74:	30ffffcc 	andi	r3,r6,65535
 1832b78:	1806d23a 	srli	r3,r3,8
 1832b7c:	197fffcc 	andi	r5,r3,65535
 1832b80:	10c00143 	ldbu	r3,5(r2)
 1832b84:	1806703a 	and	r3,r3,zero
 1832b88:	1809883a 	mov	r4,r3
 1832b8c:	2807883a 	mov	r3,r5
 1832b90:	20c6b03a 	or	r3,r4,r3
 1832b94:	10c00145 	stb	r3,5(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 1832b98:	e0bff817 	ldw	r2,-32(fp)
 1832b9c:	10c00103 	ldbu	r3,4(r2)
 1832ba0:	10800143 	ldbu	r2,5(r2)
 1832ba4:	1004923a 	slli	r2,r2,8
 1832ba8:	10c4b03a 	or	r2,r2,r3
 1832bac:	10bfffcc 	andi	r2,r2,65535
 1832bb0:	e0fff617 	ldw	r3,-40(fp)
 1832bb4:	1885883a 	add	r2,r3,r2
 1832bb8:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 1832bbc:	d0a8110b 	ldhu	r2,-24508(gp)
 1832bc0:	10800044 	addi	r2,r2,1
 1832bc4:	d0a8110d 	sth	r2,-24508(gp)

    if (ip_addr_isany(src)) {
 1832bc8:	e0bffb17 	ldw	r2,-20(fp)
 1832bcc:	10000326 	beq	r2,zero,1832bdc <ip_output_if+0x370>
 1832bd0:	e0bffb17 	ldw	r2,-20(fp)
 1832bd4:	10800017 	ldw	r2,0(r2)
 1832bd8:	1000221e 	bne	r2,zero,1832c64 <ip_output_if+0x3f8>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 1832bdc:	e0800417 	ldw	r2,16(fp)
 1832be0:	10c00117 	ldw	r3,4(r2)
 1832be4:	e0bff817 	ldw	r2,-32(fp)
 1832be8:	19803fcc 	andi	r6,r3,255
 1832bec:	11000303 	ldbu	r4,12(r2)
 1832bf0:	2008703a 	and	r4,r4,zero
 1832bf4:	200b883a 	mov	r5,r4
 1832bf8:	3009883a 	mov	r4,r6
 1832bfc:	2908b03a 	or	r4,r5,r4
 1832c00:	11000305 	stb	r4,12(r2)
 1832c04:	1808d23a 	srli	r4,r3,8
 1832c08:	21803fcc 	andi	r6,r4,255
 1832c0c:	11000343 	ldbu	r4,13(r2)
 1832c10:	2008703a 	and	r4,r4,zero
 1832c14:	200b883a 	mov	r5,r4
 1832c18:	3009883a 	mov	r4,r6
 1832c1c:	2908b03a 	or	r4,r5,r4
 1832c20:	11000345 	stb	r4,13(r2)
 1832c24:	1808d43a 	srli	r4,r3,16
 1832c28:	21803fcc 	andi	r6,r4,255
 1832c2c:	11000383 	ldbu	r4,14(r2)
 1832c30:	2008703a 	and	r4,r4,zero
 1832c34:	200b883a 	mov	r5,r4
 1832c38:	3009883a 	mov	r4,r6
 1832c3c:	2908b03a 	or	r4,r5,r4
 1832c40:	11000385 	stb	r4,14(r2)
 1832c44:	180ad63a 	srli	r5,r3,24
 1832c48:	10c003c3 	ldbu	r3,15(r2)
 1832c4c:	1806703a 	and	r3,r3,zero
 1832c50:	1809883a 	mov	r4,r3
 1832c54:	2807883a 	mov	r3,r5
 1832c58:	20c6b03a 	or	r3,r4,r3
 1832c5c:	10c003c5 	stb	r3,15(r2)
 1832c60:	00002106 	br	1832ce8 <ip_output_if+0x47c>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
 1832c64:	e0bffb17 	ldw	r2,-20(fp)
 1832c68:	10c00017 	ldw	r3,0(r2)
 1832c6c:	e0bff817 	ldw	r2,-32(fp)
 1832c70:	19803fcc 	andi	r6,r3,255
 1832c74:	11000303 	ldbu	r4,12(r2)
 1832c78:	2008703a 	and	r4,r4,zero
 1832c7c:	200b883a 	mov	r5,r4
 1832c80:	3009883a 	mov	r4,r6
 1832c84:	2908b03a 	or	r4,r5,r4
 1832c88:	11000305 	stb	r4,12(r2)
 1832c8c:	1808d23a 	srli	r4,r3,8
 1832c90:	21803fcc 	andi	r6,r4,255
 1832c94:	11000343 	ldbu	r4,13(r2)
 1832c98:	2008703a 	and	r4,r4,zero
 1832c9c:	200b883a 	mov	r5,r4
 1832ca0:	3009883a 	mov	r4,r6
 1832ca4:	2908b03a 	or	r4,r5,r4
 1832ca8:	11000345 	stb	r4,13(r2)
 1832cac:	1808d43a 	srli	r4,r3,16
 1832cb0:	21803fcc 	andi	r6,r4,255
 1832cb4:	11000383 	ldbu	r4,14(r2)
 1832cb8:	2008703a 	and	r4,r4,zero
 1832cbc:	200b883a 	mov	r5,r4
 1832cc0:	3009883a 	mov	r4,r6
 1832cc4:	2908b03a 	or	r4,r5,r4
 1832cc8:	11000385 	stb	r4,14(r2)
 1832ccc:	180ad63a 	srli	r5,r3,24
 1832cd0:	10c003c3 	ldbu	r3,15(r2)
 1832cd4:	1806703a 	and	r3,r3,zero
 1832cd8:	1809883a 	mov	r4,r3
 1832cdc:	2807883a 	mov	r3,r5
 1832ce0:	20c6b03a 	or	r3,r4,r3
 1832ce4:	10c003c5 	stb	r3,15(r2)
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 1832ce8:	e0bff817 	ldw	r2,-32(fp)
 1832cec:	10c00303 	ldbu	r3,12(r2)
 1832cf0:	11000343 	ldbu	r4,13(r2)
 1832cf4:	2008923a 	slli	r4,r4,8
 1832cf8:	20c6b03a 	or	r3,r4,r3
 1832cfc:	11000383 	ldbu	r4,14(r2)
 1832d00:	2008943a 	slli	r4,r4,16
 1832d04:	20c6b03a 	or	r3,r4,r3
 1832d08:	108003c3 	ldbu	r2,15(r2)
 1832d0c:	1004963a 	slli	r2,r2,24
 1832d10:	10c4b03a 	or	r2,r2,r3
 1832d14:	10bfffcc 	andi	r2,r2,65535
 1832d18:	e0fff617 	ldw	r3,-40(fp)
 1832d1c:	1885883a 	add	r2,r3,r2
 1832d20:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 1832d24:	e0bff817 	ldw	r2,-32(fp)
 1832d28:	10c00303 	ldbu	r3,12(r2)
 1832d2c:	11000343 	ldbu	r4,13(r2)
 1832d30:	2008923a 	slli	r4,r4,8
 1832d34:	20c6b03a 	or	r3,r4,r3
 1832d38:	11000383 	ldbu	r4,14(r2)
 1832d3c:	2008943a 	slli	r4,r4,16
 1832d40:	20c6b03a 	or	r3,r4,r3
 1832d44:	108003c3 	ldbu	r2,15(r2)
 1832d48:	1004963a 	slli	r2,r2,24
 1832d4c:	10c4b03a 	or	r2,r2,r3
 1832d50:	1004d43a 	srli	r2,r2,16
 1832d54:	e0fff617 	ldw	r3,-40(fp)
 1832d58:	1885883a 	add	r2,r3,r2
 1832d5c:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 1832d60:	e0bff617 	ldw	r2,-40(fp)
 1832d64:	1006d43a 	srli	r3,r2,16
 1832d68:	e0bff617 	ldw	r2,-40(fp)
 1832d6c:	10bfffcc 	andi	r2,r2,65535
 1832d70:	1885883a 	add	r2,r3,r2
 1832d74:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + chk_sum;
 1832d78:	e0bff617 	ldw	r2,-40(fp)
 1832d7c:	1004d43a 	srli	r2,r2,16
 1832d80:	e0fff617 	ldw	r3,-40(fp)
 1832d84:	1885883a 	add	r2,r3,r2
 1832d88:	e0bff615 	stw	r2,-40(fp)
    chk_sum = ~chk_sum;
 1832d8c:	e0bff617 	ldw	r2,-40(fp)
 1832d90:	0084303a 	nor	r2,zero,r2
 1832d94:	e0bff615 	stw	r2,-40(fp)
    iphdr->_chksum = chk_sum; /* network order */
 1832d98:	e0bff617 	ldw	r2,-40(fp)
 1832d9c:	100d883a 	mov	r6,r2
 1832da0:	e0bff817 	ldw	r2,-32(fp)
 1832da4:	30ffffcc 	andi	r3,r6,65535
 1832da8:	19403fcc 	andi	r5,r3,255
 1832dac:	10c00283 	ldbu	r3,10(r2)
 1832db0:	1806703a 	and	r3,r3,zero
 1832db4:	1809883a 	mov	r4,r3
 1832db8:	2807883a 	mov	r3,r5
 1832dbc:	20c6b03a 	or	r3,r4,r3
 1832dc0:	10c00285 	stb	r3,10(r2)
 1832dc4:	30ffffcc 	andi	r3,r6,65535
 1832dc8:	1806d23a 	srli	r3,r3,8
 1832dcc:	197fffcc 	andi	r5,r3,65535
 1832dd0:	10c002c3 	ldbu	r3,11(r2)
 1832dd4:	1806703a 	and	r3,r3,zero
 1832dd8:	1809883a 	mov	r4,r3
 1832ddc:	2807883a 	mov	r3,r5
 1832de0:	20c6b03a 	or	r3,r4,r3
 1832de4:	10c002c5 	stb	r3,11(r2)
 1832de8:	00001106 	br	1832e30 <ip_output_if+0x5c4>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
 1832dec:	e0bffa17 	ldw	r2,-24(fp)
 1832df0:	10800117 	ldw	r2,4(r2)
 1832df4:	e0bff815 	stw	r2,-32(fp)
    ip_addr_copy(dest_addr, iphdr->dest);
 1832df8:	e0bff817 	ldw	r2,-32(fp)
 1832dfc:	10c00403 	ldbu	r3,16(r2)
 1832e00:	11000443 	ldbu	r4,17(r2)
 1832e04:	2008923a 	slli	r4,r4,8
 1832e08:	20c6b03a 	or	r3,r4,r3
 1832e0c:	11000483 	ldbu	r4,18(r2)
 1832e10:	2008943a 	slli	r4,r4,16
 1832e14:	20c6b03a 	or	r3,r4,r3
 1832e18:	108004c3 	ldbu	r2,19(r2)
 1832e1c:	1004963a 	slli	r2,r2,24
 1832e20:	10c4b03a 	or	r2,r2,r3
 1832e24:	e0bff915 	stw	r2,-28(fp)
    dest = &dest_addr;
 1832e28:	e0bff904 	addi	r2,fp,-28
 1832e2c:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
 1832e30:	008061f4 	movhi	r2,391
 1832e34:	10a9d404 	addi	r2,r2,-22704
 1832e38:	10802417 	ldw	r2,144(r2)
 1832e3c:	10c00044 	addi	r3,r2,1
 1832e40:	008061f4 	movhi	r2,391
 1832e44:	10a9d404 	addi	r2,r2,-22704
 1832e48:	10c02415 	stw	r3,144(r2)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 1832e4c:	e0800417 	ldw	r2,16(fp)
 1832e50:	10800c0b 	ldhu	r2,48(r2)
 1832e54:	10bfffcc 	andi	r2,r2,65535
 1832e58:	10000c26 	beq	r2,zero,1832e8c <ip_output_if+0x620>
 1832e5c:	e0bffa17 	ldw	r2,-24(fp)
 1832e60:	1100020b 	ldhu	r4,8(r2)
 1832e64:	e0800417 	ldw	r2,16(fp)
 1832e68:	10c00c0b 	ldhu	r3,48(r2)
 1832e6c:	20bfffcc 	andi	r2,r4,65535
 1832e70:	18ffffcc 	andi	r3,r3,65535
 1832e74:	1880052e 	bgeu	r3,r2,1832e8c <ip_output_if+0x620>
    return ip_frag(p, netif, dest);
 1832e78:	e1bffc17 	ldw	r6,-16(fp)
 1832e7c:	e1400417 	ldw	r5,16(fp)
 1832e80:	e13ffa17 	ldw	r4,-24(fp)
 1832e84:	18343080 	call	1834308 <ip_frag>
 1832e88:	00000606 	br	1832ea4 <ip_output_if+0x638>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 1832e8c:	e0800417 	ldw	r2,16(fp)
 1832e90:	10800517 	ldw	r2,20(r2)
 1832e94:	e1bffc17 	ldw	r6,-16(fp)
 1832e98:	e17ffa17 	ldw	r5,-24(fp)
 1832e9c:	e1000417 	ldw	r4,16(fp)
 1832ea0:	103ee83a 	callr	r2
}
 1832ea4:	e037883a 	mov	sp,fp
 1832ea8:	dfc00117 	ldw	ra,4(sp)
 1832eac:	df000017 	ldw	fp,0(sp)
 1832eb0:	dec00204 	addi	sp,sp,8
 1832eb4:	f800283a 	ret

01832eb8 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 1832eb8:	defff404 	addi	sp,sp,-48
 1832ebc:	dfc00b15 	stw	ra,44(sp)
 1832ec0:	df000a15 	stw	fp,40(sp)
 1832ec4:	df000a04 	addi	fp,sp,40
 1832ec8:	e13ffa15 	stw	r4,-24(fp)
 1832ecc:	e17ffb15 	stw	r5,-20(fp)
 1832ed0:	e1bffc15 	stw	r6,-16(fp)
 1832ed4:	3809883a 	mov	r4,r7
 1832ed8:	e0c00217 	ldw	r3,8(fp)
 1832edc:	e0800317 	ldw	r2,12(fp)
 1832ee0:	e13ffd05 	stb	r4,-12(fp)
 1832ee4:	e0fffe05 	stb	r3,-8(fp)
 1832ee8:	e0bfff05 	stb	r2,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
 1832eec:	e17ffc17 	ldw	r5,-16(fp)
 1832ef0:	e13ffb17 	ldw	r4,-20(fp)
 1832ef4:	18322400 	call	1832240 <ip_route>
 1832ef8:	e0bff915 	stw	r2,-28(fp)
 1832efc:	e0bff917 	ldw	r2,-28(fp)
 1832f00:	1000091e 	bne	r2,zero,1832f28 <ip_output+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 1832f04:	008061f4 	movhi	r2,391
 1832f08:	10a9d404 	addi	r2,r2,-22704
 1832f0c:	10802b17 	ldw	r2,172(r2)
 1832f10:	10c00044 	addi	r3,r2,1
 1832f14:	008061f4 	movhi	r2,391
 1832f18:	10a9d404 	addi	r2,r2,-22704
 1832f1c:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 1832f20:	00bfff04 	movi	r2,-4
 1832f24:	00000c06 	br	1832f58 <ip_output+0xa0>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 1832f28:	e17ffd03 	ldbu	r5,-12(fp)
 1832f2c:	e0bffe03 	ldbu	r2,-8(fp)
 1832f30:	e0ffff03 	ldbu	r3,-4(fp)
 1832f34:	e13ff917 	ldw	r4,-28(fp)
 1832f38:	d9000215 	stw	r4,8(sp)
 1832f3c:	d8c00115 	stw	r3,4(sp)
 1832f40:	d8800015 	stw	r2,0(sp)
 1832f44:	280f883a 	mov	r7,r5
 1832f48:	e1bffc17 	ldw	r6,-16(fp)
 1832f4c:	e17ffb17 	ldw	r5,-20(fp)
 1832f50:	e13ffa17 	ldw	r4,-24(fp)
 1832f54:	183286c0 	call	183286c <ip_output_if>
}
 1832f58:	e037883a 	mov	sp,fp
 1832f5c:	dfc00117 	ldw	ra,4(sp)
 1832f60:	df000017 	ldw	fp,0(sp)
 1832f64:	dec00204 	addi	sp,sp,8
 1832f68:	f800283a 	ret

01832f6c <ip_output_hinted>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output_hinted(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint)
{
 1832f6c:	defff304 	addi	sp,sp,-52
 1832f70:	dfc00c15 	stw	ra,48(sp)
 1832f74:	df000b15 	stw	fp,44(sp)
 1832f78:	df000b04 	addi	fp,sp,44
 1832f7c:	e13ffa15 	stw	r4,-24(fp)
 1832f80:	e17ffb15 	stw	r5,-20(fp)
 1832f84:	e1bffc15 	stw	r6,-16(fp)
 1832f88:	3809883a 	mov	r4,r7
 1832f8c:	e0c00217 	ldw	r3,8(fp)
 1832f90:	e0800317 	ldw	r2,12(fp)
 1832f94:	e13ffd05 	stb	r4,-12(fp)
 1832f98:	e0fffe05 	stb	r3,-8(fp)
 1832f9c:	e0bfff05 	stb	r2,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
 1832fa0:	e17ffc17 	ldw	r5,-16(fp)
 1832fa4:	e13ffb17 	ldw	r4,-20(fp)
 1832fa8:	18322400 	call	1832240 <ip_route>
 1832fac:	e0bff815 	stw	r2,-32(fp)
 1832fb0:	e0bff817 	ldw	r2,-32(fp)
 1832fb4:	1000091e 	bne	r2,zero,1832fdc <ip_output_hinted+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 1832fb8:	008061f4 	movhi	r2,391
 1832fbc:	10a9d404 	addi	r2,r2,-22704
 1832fc0:	10802b17 	ldw	r2,172(r2)
 1832fc4:	10c00044 	addi	r3,r2,1
 1832fc8:	008061f4 	movhi	r2,391
 1832fcc:	10a9d404 	addi	r2,r2,-22704
 1832fd0:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 1832fd4:	00bfff04 	movi	r2,-4
 1832fd8:	00001306 	br	1833028 <ip_output_hinted+0xbc>
  }


  NETIF_SET_HWADDRHINT(netif, addr_hint);
 1832fdc:	e0bff817 	ldw	r2,-32(fp)
 1832fe0:	e0c00417 	ldw	r3,16(fp)
 1832fe4:	10c01015 	stw	r3,64(r2)
  err = ip_output_if(p, src, dest, ttl, tos, proto, netif);
 1832fe8:	e17ffd03 	ldbu	r5,-12(fp)
 1832fec:	e0bffe03 	ldbu	r2,-8(fp)
 1832ff0:	e0ffff03 	ldbu	r3,-4(fp)
 1832ff4:	e13ff817 	ldw	r4,-32(fp)
 1832ff8:	d9000215 	stw	r4,8(sp)
 1832ffc:	d8c00115 	stw	r3,4(sp)
 1833000:	d8800015 	stw	r2,0(sp)
 1833004:	280f883a 	mov	r7,r5
 1833008:	e1bffc17 	ldw	r6,-16(fp)
 183300c:	e17ffb17 	ldw	r5,-20(fp)
 1833010:	e13ffa17 	ldw	r4,-24(fp)
 1833014:	183286c0 	call	183286c <ip_output_if>
 1833018:	e0bff905 	stb	r2,-28(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
 183301c:	e0bff817 	ldw	r2,-32(fp)
 1833020:	10001015 	stw	zero,64(r2)

  return err;
 1833024:	e0bff903 	ldbu	r2,-28(fp)
}
 1833028:	e037883a 	mov	sp,fp
 183302c:	dfc00117 	ldw	ra,4(sp)
 1833030:	df000017 	ldw	fp,0(sp)
 1833034:	dec00204 	addi	sp,sp,8
 1833038:	f800283a 	ret

0183303c <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 183303c:	defffb04 	addi	sp,sp,-20
 1833040:	dfc00415 	stw	ra,16(sp)
 1833044:	df000315 	stw	fp,12(sp)
 1833048:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
 183304c:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
 1833050:	d0a81617 	ldw	r2,-24488(gp)
 1833054:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
 1833058:	00001806 	br	18330bc <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 183305c:	e0bffd17 	ldw	r2,-12(fp)
 1833060:	108007c3 	ldbu	r2,31(r2)
 1833064:	10803fcc 	andi	r2,r2,255
 1833068:	10000c26 	beq	r2,zero,183309c <ip_reass_tmr+0x60>
      r->timer--;
 183306c:	e0bffd17 	ldw	r2,-12(fp)
 1833070:	108007c3 	ldbu	r2,31(r2)
 1833074:	10bfffc4 	addi	r2,r2,-1
 1833078:	1007883a 	mov	r3,r2
 183307c:	e0bffd17 	ldw	r2,-12(fp)
 1833080:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
 1833084:	e0bffd17 	ldw	r2,-12(fp)
 1833088:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
 183308c:	e0bffd17 	ldw	r2,-12(fp)
 1833090:	10800017 	ldw	r2,0(r2)
 1833094:	e0bffd15 	stw	r2,-12(fp)
 1833098:	00000806 	br	18330bc <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
 183309c:	e0bffd17 	ldw	r2,-12(fp)
 18330a0:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
 18330a4:	e0bffd17 	ldw	r2,-12(fp)
 18330a8:	10800017 	ldw	r2,0(r2)
 18330ac:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 18330b0:	e17ffe17 	ldw	r5,-8(fp)
 18330b4:	e13fff17 	ldw	r4,-4(fp)
 18330b8:	18330dc0 	call	18330dc <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 18330bc:	e0bffd17 	ldw	r2,-12(fp)
 18330c0:	103fe61e 	bne	r2,zero,183305c <__ram_exceptions_end+0xff822c18>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
 18330c4:	0001883a 	nop
 18330c8:	e037883a 	mov	sp,fp
 18330cc:	dfc00117 	ldw	ra,4(sp)
 18330d0:	df000017 	ldw	fp,0(sp)
 18330d4:	dec00204 	addi	sp,sp,8
 18330d8:	f800283a 	ret

018330dc <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 18330dc:	defff704 	addi	sp,sp,-36
 18330e0:	dfc00815 	stw	ra,32(sp)
 18330e4:	df000715 	stw	fp,28(sp)
 18330e8:	df000704 	addi	fp,sp,28
 18330ec:	e13ffe15 	stw	r4,-8(fp)
 18330f0:	e17fff15 	stw	r5,-4(fp)
  u16_t pbufs_freed = 0;
 18330f4:	e03ff90d 	sth	zero,-28(fp)
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 18330f8:	e0bffe17 	ldw	r2,-8(fp)
 18330fc:	10800117 	ldw	r2,4(r2)
 1833100:	10800117 	ldw	r2,4(r2)
 1833104:	e0bffb15 	stw	r2,-20(fp)
  if (iprh->start == 0) {
 1833108:	e0bffb17 	ldw	r2,-20(fp)
 183310c:	10c00103 	ldbu	r3,4(r2)
 1833110:	10800143 	ldbu	r2,5(r2)
 1833114:	1004923a 	slli	r2,r2,8
 1833118:	10c4b03a 	or	r2,r2,r3
 183311c:	10bfffcc 	andi	r2,r2,65535
 1833120:	1000251e 	bne	r2,zero,18331b8 <ip_reass_free_complete_datagram+0xdc>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 1833124:	e0bffe17 	ldw	r2,-8(fp)
 1833128:	10800117 	ldw	r2,4(r2)
 183312c:	e0bffa15 	stw	r2,-24(fp)
    ipr->p = iprh->next_pbuf;
 1833130:	e0bffb17 	ldw	r2,-20(fp)
 1833134:	10c00003 	ldbu	r3,0(r2)
 1833138:	11000043 	ldbu	r4,1(r2)
 183313c:	2008923a 	slli	r4,r4,8
 1833140:	20c6b03a 	or	r3,r4,r3
 1833144:	11000083 	ldbu	r4,2(r2)
 1833148:	2008943a 	slli	r4,r4,16
 183314c:	20c6b03a 	or	r3,r4,r3
 1833150:	108000c3 	ldbu	r2,3(r2)
 1833154:	1004963a 	slli	r2,r2,24
 1833158:	10c4b03a 	or	r2,r2,r3
 183315c:	1007883a 	mov	r3,r2
 1833160:	e0bffe17 	ldw	r2,-8(fp)
 1833164:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 1833168:	e0bffa17 	ldw	r2,-24(fp)
 183316c:	10c00117 	ldw	r3,4(r2)
 1833170:	e0bffe17 	ldw	r2,-8(fp)
 1833174:	10800204 	addi	r2,r2,8
 1833178:	01800504 	movi	r6,20
 183317c:	100b883a 	mov	r5,r2
 1833180:	1809883a 	mov	r4,r3
 1833184:	180608c0 	call	180608c <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 1833188:	01400044 	movi	r5,1
 183318c:	e13ffa17 	ldw	r4,-24(fp)
 1833190:	18318040 	call	1831804 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 1833194:	e13ffa17 	ldw	r4,-24(fp)
 1833198:	181ade80 	call	181ade8 <pbuf_clen>
 183319c:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 18331a0:	e0fffc03 	ldbu	r3,-16(fp)
 18331a4:	e0bff90b 	ldhu	r2,-28(fp)
 18331a8:	1885883a 	add	r2,r3,r2
 18331ac:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(p);
 18331b0:	e13ffa17 	ldw	r4,-24(fp)
 18331b4:	181aca40 	call	181aca4 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 18331b8:	e0bffe17 	ldw	r2,-8(fp)
 18331bc:	10800117 	ldw	r2,4(r2)
 18331c0:	e0bffa15 	stw	r2,-24(fp)
  while (p != NULL) {
 18331c4:	00001a06 	br	1833230 <ip_reass_free_complete_datagram+0x154>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 18331c8:	e0bffa17 	ldw	r2,-24(fp)
 18331cc:	10800117 	ldw	r2,4(r2)
 18331d0:	e0bffb15 	stw	r2,-20(fp)
    pcur = p;
 18331d4:	e0bffa17 	ldw	r2,-24(fp)
 18331d8:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 18331dc:	e0bffb17 	ldw	r2,-20(fp)
 18331e0:	10c00003 	ldbu	r3,0(r2)
 18331e4:	11000043 	ldbu	r4,1(r2)
 18331e8:	2008923a 	slli	r4,r4,8
 18331ec:	20c6b03a 	or	r3,r4,r3
 18331f0:	11000083 	ldbu	r4,2(r2)
 18331f4:	2008943a 	slli	r4,r4,16
 18331f8:	20c6b03a 	or	r3,r4,r3
 18331fc:	108000c3 	ldbu	r2,3(r2)
 1833200:	1004963a 	slli	r2,r2,24
 1833204:	10c4b03a 	or	r2,r2,r3
 1833208:	e0bffa15 	stw	r2,-24(fp)
    clen = pbuf_clen(pcur);
 183320c:	e13ffd17 	ldw	r4,-12(fp)
 1833210:	181ade80 	call	181ade8 <pbuf_clen>
 1833214:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 1833218:	e0fffc03 	ldbu	r3,-16(fp)
 183321c:	e0bff90b 	ldhu	r2,-28(fp)
 1833220:	1885883a 	add	r2,r3,r2
 1833224:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(pcur);
 1833228:	e13ffd17 	ldw	r4,-12(fp)
 183322c:	181aca40 	call	181aca4 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 1833230:	e0bffa17 	ldw	r2,-24(fp)
 1833234:	103fe41e 	bne	r2,zero,18331c8 <__ram_exceptions_end+0xff822d84>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 1833238:	e17fff17 	ldw	r5,-4(fp)
 183323c:	e13ffe17 	ldw	r4,-8(fp)
 1833240:	18334d80 	call	18334d8 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 1833244:	d0e8170b 	ldhu	r3,-24484(gp)
 1833248:	e0bff90b 	ldhu	r2,-28(fp)
 183324c:	1885c83a 	sub	r2,r3,r2
 1833250:	d0a8170d 	sth	r2,-24484(gp)

  return pbufs_freed;
 1833254:	e0bff90b 	ldhu	r2,-28(fp)
}
 1833258:	e037883a 	mov	sp,fp
 183325c:	dfc00117 	ldw	ra,4(sp)
 1833260:	df000017 	ldw	fp,0(sp)
 1833264:	dec00204 	addi	sp,sp,8
 1833268:	f800283a 	ret

0183326c <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 183326c:	defff604 	addi	sp,sp,-40
 1833270:	dfc00915 	stw	ra,36(sp)
 1833274:	df000815 	stw	fp,32(sp)
 1833278:	df000804 	addi	fp,sp,32
 183327c:	e13ffe15 	stw	r4,-8(fp)
 1833280:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 1833284:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 1833288:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
 183328c:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
 1833290:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
 1833294:	d0a81617 	ldw	r2,-24488(gp)
 1833298:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
 183329c:	00003f06 	br	183339c <ip_reass_remove_oldest_datagram+0x130>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 18332a0:	e0bff817 	ldw	r2,-32(fp)
 18332a4:	10c00517 	ldw	r3,20(r2)
 18332a8:	e0bffe17 	ldw	r2,-8(fp)
 18332ac:	11000303 	ldbu	r4,12(r2)
 18332b0:	11400343 	ldbu	r5,13(r2)
 18332b4:	280a923a 	slli	r5,r5,8
 18332b8:	2908b03a 	or	r4,r5,r4
 18332bc:	11400383 	ldbu	r5,14(r2)
 18332c0:	280a943a 	slli	r5,r5,16
 18332c4:	2908b03a 	or	r4,r5,r4
 18332c8:	108003c3 	ldbu	r2,15(r2)
 18332cc:	1004963a 	slli	r2,r2,24
 18332d0:	1104b03a 	or	r2,r2,r4
 18332d4:	1880181e 	bne	r3,r2,1833338 <ip_reass_remove_oldest_datagram+0xcc>
 18332d8:	e0bff817 	ldw	r2,-32(fp)
 18332dc:	10c00617 	ldw	r3,24(r2)
 18332e0:	e0bffe17 	ldw	r2,-8(fp)
 18332e4:	11000403 	ldbu	r4,16(r2)
 18332e8:	11400443 	ldbu	r5,17(r2)
 18332ec:	280a923a 	slli	r5,r5,8
 18332f0:	2908b03a 	or	r4,r5,r4
 18332f4:	11400483 	ldbu	r5,18(r2)
 18332f8:	280a943a 	slli	r5,r5,16
 18332fc:	2908b03a 	or	r4,r5,r4
 1833300:	108004c3 	ldbu	r2,19(r2)
 1833304:	1004963a 	slli	r2,r2,24
 1833308:	1104b03a 	or	r2,r2,r4
 183330c:	18800a1e 	bne	r3,r2,1833338 <ip_reass_remove_oldest_datagram+0xcc>
 1833310:	e0bff817 	ldw	r2,-32(fp)
 1833314:	1100030b 	ldhu	r4,12(r2)
 1833318:	e0bffe17 	ldw	r2,-8(fp)
 183331c:	10c00103 	ldbu	r3,4(r2)
 1833320:	10800143 	ldbu	r2,5(r2)
 1833324:	1004923a 	slli	r2,r2,8
 1833328:	10c4b03a 	or	r2,r2,r3
 183332c:	20ffffcc 	andi	r3,r4,65535
 1833330:	10bfffcc 	andi	r2,r2,65535
 1833334:	18801126 	beq	r3,r2,183337c <ip_reass_remove_oldest_datagram+0x110>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 1833338:	e0bffc17 	ldw	r2,-16(fp)
 183333c:	10800044 	addi	r2,r2,1
 1833340:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
 1833344:	e0bff917 	ldw	r2,-28(fp)
 1833348:	1000031e 	bne	r2,zero,1833358 <ip_reass_remove_oldest_datagram+0xec>
          oldest = r;
 183334c:	e0bff817 	ldw	r2,-32(fp)
 1833350:	e0bff915 	stw	r2,-28(fp)
 1833354:	00000906 	br	183337c <ip_reass_remove_oldest_datagram+0x110>
        } else if (r->timer <= oldest->timer) {
 1833358:	e0bff817 	ldw	r2,-32(fp)
 183335c:	110007c3 	ldbu	r4,31(r2)
 1833360:	e0bff917 	ldw	r2,-28(fp)
 1833364:	10c007c3 	ldbu	r3,31(r2)
 1833368:	20803fcc 	andi	r2,r4,255
 183336c:	18c03fcc 	andi	r3,r3,255
 1833370:	18800236 	bltu	r3,r2,183337c <ip_reass_remove_oldest_datagram+0x110>
          /* older than the previous oldest */
          oldest = r;
 1833374:	e0bff817 	ldw	r2,-32(fp)
 1833378:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
 183337c:	e0bff817 	ldw	r2,-32(fp)
 1833380:	10800017 	ldw	r2,0(r2)
 1833384:	10000226 	beq	r2,zero,1833390 <ip_reass_remove_oldest_datagram+0x124>
        prev = r;
 1833388:	e0bff817 	ldw	r2,-32(fp)
 183338c:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
 1833390:	e0bff817 	ldw	r2,-32(fp)
 1833394:	10800017 	ldw	r2,0(r2)
 1833398:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
 183339c:	e0bff817 	ldw	r2,-32(fp)
 18333a0:	103fbf1e 	bne	r2,zero,18332a0 <__ram_exceptions_end+0xff822e5c>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 18333a4:	e0bff917 	ldw	r2,-28(fp)
 18333a8:	10000826 	beq	r2,zero,18333cc <ip_reass_remove_oldest_datagram+0x160>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 18333ac:	e17ffa17 	ldw	r5,-24(fp)
 18333b0:	e13ff917 	ldw	r4,-28(fp)
 18333b4:	18330dc0 	call	18330dc <ip_reass_free_complete_datagram>
 18333b8:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
 18333bc:	e0fffb17 	ldw	r3,-20(fp)
 18333c0:	e0bffd17 	ldw	r2,-12(fp)
 18333c4:	1885883a 	add	r2,r3,r2
 18333c8:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 18333cc:	e0fffb17 	ldw	r3,-20(fp)
 18333d0:	e0bfff17 	ldw	r2,-4(fp)
 18333d4:	1880030e 	bge	r3,r2,18333e4 <ip_reass_remove_oldest_datagram+0x178>
 18333d8:	e0bffc17 	ldw	r2,-16(fp)
 18333dc:	10800088 	cmpgei	r2,r2,2
 18333e0:	103fa91e 	bne	r2,zero,1833288 <__ram_exceptions_end+0xff822e44>
  return pbufs_freed;
 18333e4:	e0bffb17 	ldw	r2,-20(fp)
}
 18333e8:	e037883a 	mov	sp,fp
 18333ec:	dfc00117 	ldw	ra,4(sp)
 18333f0:	df000017 	ldw	fp,0(sp)
 18333f4:	dec00204 	addi	sp,sp,8
 18333f8:	f800283a 	ret

018333fc <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 18333fc:	defffb04 	addi	sp,sp,-20
 1833400:	dfc00415 	stw	ra,16(sp)
 1833404:	df000315 	stw	fp,12(sp)
 1833408:	df000304 	addi	fp,sp,12
 183340c:	e13ffe15 	stw	r4,-8(fp)
 1833410:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1833414:	01000144 	movi	r4,5
 1833418:	18349580 	call	1834958 <memp_malloc>
 183341c:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
 1833420:	e0bffd17 	ldw	r2,-12(fp)
 1833424:	1000141e 	bne	r2,zero,1833478 <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 1833428:	e17fff17 	ldw	r5,-4(fp)
 183342c:	e13ffe17 	ldw	r4,-8(fp)
 1833430:	183326c0 	call	183326c <ip_reass_remove_oldest_datagram>
 1833434:	1007883a 	mov	r3,r2
 1833438:	e0bfff17 	ldw	r2,-4(fp)
 183343c:	18800316 	blt	r3,r2,183344c <ip_reass_enqueue_new_datagram+0x50>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1833440:	01000144 	movi	r4,5
 1833444:	18349580 	call	1834958 <memp_malloc>
 1833448:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
 183344c:	e0bffd17 	ldw	r2,-12(fp)
 1833450:	1000091e 	bne	r2,zero,1833478 <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
 1833454:	008061f4 	movhi	r2,391
 1833458:	10a9d404 	addi	r2,r2,-22704
 183345c:	10801e17 	ldw	r2,120(r2)
 1833460:	10c00044 	addi	r3,r2,1
 1833464:	008061f4 	movhi	r2,391
 1833468:	10a9d404 	addi	r2,r2,-22704
 183346c:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
 1833470:	0005883a 	mov	r2,zero
 1833474:	00001306 	br	18334c4 <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 1833478:	01800804 	movi	r6,32
 183347c:	000b883a 	mov	r5,zero
 1833480:	e13ffd17 	ldw	r4,-12(fp)
 1833484:	18061d40 	call	18061d4 <memset>
  ipr->timer = IP_REASS_MAXAGE;
 1833488:	e0bffd17 	ldw	r2,-12(fp)
 183348c:	00c000c4 	movi	r3,3
 1833490:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 1833494:	d0e81617 	ldw	r3,-24488(gp)
 1833498:	e0bffd17 	ldw	r2,-12(fp)
 183349c:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
 18334a0:	e0bffd17 	ldw	r2,-12(fp)
 18334a4:	d0a81615 	stw	r2,-24488(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 18334a8:	e0bffd17 	ldw	r2,-12(fp)
 18334ac:	10800204 	addi	r2,r2,8
 18334b0:	01800504 	movi	r6,20
 18334b4:	e17ffe17 	ldw	r5,-8(fp)
 18334b8:	1009883a 	mov	r4,r2
 18334bc:	180608c0 	call	180608c <memcpy>
  return ipr;
 18334c0:	e0bffd17 	ldw	r2,-12(fp)
}
 18334c4:	e037883a 	mov	sp,fp
 18334c8:	dfc00117 	ldw	ra,4(sp)
 18334cc:	df000017 	ldw	fp,0(sp)
 18334d0:	dec00204 	addi	sp,sp,8
 18334d4:	f800283a 	ret

018334d8 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 18334d8:	defffc04 	addi	sp,sp,-16
 18334dc:	dfc00315 	stw	ra,12(sp)
 18334e0:	df000215 	stw	fp,8(sp)
 18334e4:	df000204 	addi	fp,sp,8
 18334e8:	e13ffe15 	stw	r4,-8(fp)
 18334ec:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 18334f0:	d0e81617 	ldw	r3,-24488(gp)
 18334f4:	e0bffe17 	ldw	r2,-8(fp)
 18334f8:	1880041e 	bne	r3,r2,183350c <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 18334fc:	e0bffe17 	ldw	r2,-8(fp)
 1833500:	10800017 	ldw	r2,0(r2)
 1833504:	d0a81615 	stw	r2,-24488(gp)
 1833508:	00000406 	br	183351c <ip_reass_dequeue_datagram+0x44>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 183350c:	e0bffe17 	ldw	r2,-8(fp)
 1833510:	10c00017 	ldw	r3,0(r2)
 1833514:	e0bfff17 	ldw	r2,-4(fp)
 1833518:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 183351c:	e17ffe17 	ldw	r5,-8(fp)
 1833520:	01000144 	movi	r4,5
 1833524:	1834b240 	call	1834b24 <memp_free>
}
 1833528:	0001883a 	nop
 183352c:	e037883a 	mov	sp,fp
 1833530:	dfc00117 	ldw	ra,4(sp)
 1833534:	df000017 	ldw	fp,0(sp)
 1833538:	dec00204 	addi	sp,sp,8
 183353c:	f800283a 	ret

01833540 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
 1833540:	defff504 	addi	sp,sp,-44
 1833544:	dfc00a15 	stw	ra,40(sp)
 1833548:	df000915 	stw	fp,36(sp)
 183354c:	df000904 	addi	fp,sp,36
 1833550:	e13ffe15 	stw	r4,-8(fp)
 1833554:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
 1833558:	e03ff715 	stw	zero,-36(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
 183355c:	00800044 	movi	r2,1
 1833560:	e0bff915 	stw	r2,-28(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 1833564:	e0bfff17 	ldw	r2,-4(fp)
 1833568:	10800117 	ldw	r2,4(r2)
 183356c:	e0bffa15 	stw	r2,-24(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 1833570:	e0bffa17 	ldw	r2,-24(fp)
 1833574:	10c00083 	ldbu	r3,2(r2)
 1833578:	108000c3 	ldbu	r2,3(r2)
 183357c:	1004923a 	slli	r2,r2,8
 1833580:	10c4b03a 	or	r2,r2,r3
 1833584:	10bfffcc 	andi	r2,r2,65535
 1833588:	1004d23a 	srli	r2,r2,8
 183358c:	1009883a 	mov	r4,r2
 1833590:	e0bffa17 	ldw	r2,-24(fp)
 1833594:	10c00083 	ldbu	r3,2(r2)
 1833598:	108000c3 	ldbu	r2,3(r2)
 183359c:	1004923a 	slli	r2,r2,8
 18335a0:	10c4b03a 	or	r2,r2,r3
 18335a4:	10bfffcc 	andi	r2,r2,65535
 18335a8:	1004923a 	slli	r2,r2,8
 18335ac:	2084b03a 	or	r2,r4,r2
 18335b0:	1007883a 	mov	r3,r2
 18335b4:	e0bffa17 	ldw	r2,-24(fp)
 18335b8:	10800003 	ldbu	r2,0(r2)
 18335bc:	10803fcc 	andi	r2,r2,255
 18335c0:	108003cc 	andi	r2,r2,15
 18335c4:	1085883a 	add	r2,r2,r2
 18335c8:	1085883a 	add	r2,r2,r2
 18335cc:	1885c83a 	sub	r2,r3,r2
 18335d0:	e0bffb0d 	sth	r2,-20(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 18335d4:	e0bffa17 	ldw	r2,-24(fp)
 18335d8:	10c00183 	ldbu	r3,6(r2)
 18335dc:	108001c3 	ldbu	r2,7(r2)
 18335e0:	1004923a 	slli	r2,r2,8
 18335e4:	10c4b03a 	or	r2,r2,r3
 18335e8:	10bfffcc 	andi	r2,r2,65535
 18335ec:	1004d23a 	srli	r2,r2,8
 18335f0:	10ffffcc 	andi	r3,r2,65535
 18335f4:	e0bffa17 	ldw	r2,-24(fp)
 18335f8:	11000183 	ldbu	r4,6(r2)
 18335fc:	108001c3 	ldbu	r2,7(r2)
 1833600:	1004923a 	slli	r2,r2,8
 1833604:	1104b03a 	or	r2,r2,r4
 1833608:	10bfffcc 	andi	r2,r2,65535
 183360c:	1004923a 	slli	r2,r2,8
 1833610:	10bfffcc 	andi	r2,r2,65535
 1833614:	1884b03a 	or	r2,r3,r2
 1833618:	1087ffcc 	andi	r2,r2,8191
 183361c:	100490fa 	slli	r2,r2,3
 1833620:	e0bffb8d 	sth	r2,-18(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 1833624:	e0bfff17 	ldw	r2,-4(fp)
 1833628:	10800117 	ldw	r2,4(r2)
 183362c:	e0bffc15 	stw	r2,-16(fp)
  iprh->next_pbuf = NULL;
 1833630:	e0bffc17 	ldw	r2,-16(fp)
 1833634:	10c00003 	ldbu	r3,0(r2)
 1833638:	1806703a 	and	r3,r3,zero
 183363c:	10c00005 	stb	r3,0(r2)
 1833640:	10c00043 	ldbu	r3,1(r2)
 1833644:	1806703a 	and	r3,r3,zero
 1833648:	10c00045 	stb	r3,1(r2)
 183364c:	10c00083 	ldbu	r3,2(r2)
 1833650:	1806703a 	and	r3,r3,zero
 1833654:	10c00085 	stb	r3,2(r2)
 1833658:	10c000c3 	ldbu	r3,3(r2)
 183365c:	1806703a 	and	r3,r3,zero
 1833660:	10c000c5 	stb	r3,3(r2)
  iprh->start = offset;
 1833664:	e0bffc17 	ldw	r2,-16(fp)
 1833668:	e0fffb8b 	ldhu	r3,-18(fp)
 183366c:	19403fcc 	andi	r5,r3,255
 1833670:	10c00103 	ldbu	r3,4(r2)
 1833674:	1806703a 	and	r3,r3,zero
 1833678:	1809883a 	mov	r4,r3
 183367c:	2807883a 	mov	r3,r5
 1833680:	20c6b03a 	or	r3,r4,r3
 1833684:	10c00105 	stb	r3,4(r2)
 1833688:	e0fffb8b 	ldhu	r3,-18(fp)
 183368c:	1806d23a 	srli	r3,r3,8
 1833690:	197fffcc 	andi	r5,r3,65535
 1833694:	10c00143 	ldbu	r3,5(r2)
 1833698:	1806703a 	and	r3,r3,zero
 183369c:	1809883a 	mov	r4,r3
 18336a0:	2807883a 	mov	r3,r5
 18336a4:	20c6b03a 	or	r3,r4,r3
 18336a8:	10c00145 	stb	r3,5(r2)
  iprh->end = offset + len;
 18336ac:	e0fffb8b 	ldhu	r3,-18(fp)
 18336b0:	e0bffb0b 	ldhu	r2,-20(fp)
 18336b4:	1885883a 	add	r2,r3,r2
 18336b8:	100d883a 	mov	r6,r2
 18336bc:	e0bffc17 	ldw	r2,-16(fp)
 18336c0:	30ffffcc 	andi	r3,r6,65535
 18336c4:	19403fcc 	andi	r5,r3,255
 18336c8:	10c00183 	ldbu	r3,6(r2)
 18336cc:	1806703a 	and	r3,r3,zero
 18336d0:	1809883a 	mov	r4,r3
 18336d4:	2807883a 	mov	r3,r5
 18336d8:	20c6b03a 	or	r3,r4,r3
 18336dc:	10c00185 	stb	r3,6(r2)
 18336e0:	30ffffcc 	andi	r3,r6,65535
 18336e4:	1806d23a 	srli	r3,r3,8
 18336e8:	197fffcc 	andi	r5,r3,65535
 18336ec:	10c001c3 	ldbu	r3,7(r2)
 18336f0:	1806703a 	and	r3,r3,zero
 18336f4:	1809883a 	mov	r4,r3
 18336f8:	2807883a 	mov	r3,r5
 18336fc:	20c6b03a 	or	r3,r4,r3
 1833700:	10c001c5 	stb	r3,7(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 1833704:	e0bffe17 	ldw	r2,-8(fp)
 1833708:	10800117 	ldw	r2,4(r2)
 183370c:	e0bff815 	stw	r2,-32(fp)
 1833710:	0000b606 	br	18339ec <ip_reass_chain_frag_into_datagram_and_validate+0x4ac>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 1833714:	e0bff817 	ldw	r2,-32(fp)
 1833718:	10800117 	ldw	r2,4(r2)
 183371c:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
 1833720:	e0bffc17 	ldw	r2,-16(fp)
 1833724:	10c00103 	ldbu	r3,4(r2)
 1833728:	10800143 	ldbu	r2,5(r2)
 183372c:	1004923a 	slli	r2,r2,8
 1833730:	10c4b03a 	or	r2,r2,r3
 1833734:	1009883a 	mov	r4,r2
 1833738:	e0bffd17 	ldw	r2,-12(fp)
 183373c:	10c00103 	ldbu	r3,4(r2)
 1833740:	10800143 	ldbu	r2,5(r2)
 1833744:	1004923a 	slli	r2,r2,8
 1833748:	10c4b03a 	or	r2,r2,r3
 183374c:	20ffffcc 	andi	r3,r4,65535
 1833750:	10bfffcc 	andi	r2,r2,65535
 1833754:	18806a2e 	bgeu	r3,r2,1833900 <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 1833758:	e0bffc17 	ldw	r2,-16(fp)
 183375c:	e0fff817 	ldw	r3,-32(fp)
 1833760:	19403fcc 	andi	r5,r3,255
 1833764:	10c00003 	ldbu	r3,0(r2)
 1833768:	1806703a 	and	r3,r3,zero
 183376c:	1809883a 	mov	r4,r3
 1833770:	2807883a 	mov	r3,r5
 1833774:	20c6b03a 	or	r3,r4,r3
 1833778:	10c00005 	stb	r3,0(r2)
 183377c:	e0fff817 	ldw	r3,-32(fp)
 1833780:	1806d23a 	srli	r3,r3,8
 1833784:	19403fcc 	andi	r5,r3,255
 1833788:	10c00043 	ldbu	r3,1(r2)
 183378c:	1806703a 	and	r3,r3,zero
 1833790:	1809883a 	mov	r4,r3
 1833794:	2807883a 	mov	r3,r5
 1833798:	20c6b03a 	or	r3,r4,r3
 183379c:	10c00045 	stb	r3,1(r2)
 18337a0:	e0fff817 	ldw	r3,-32(fp)
 18337a4:	1806d43a 	srli	r3,r3,16
 18337a8:	19403fcc 	andi	r5,r3,255
 18337ac:	10c00083 	ldbu	r3,2(r2)
 18337b0:	1806703a 	and	r3,r3,zero
 18337b4:	1809883a 	mov	r4,r3
 18337b8:	2807883a 	mov	r3,r5
 18337bc:	20c6b03a 	or	r3,r4,r3
 18337c0:	10c00085 	stb	r3,2(r2)
 18337c4:	e0fff817 	ldw	r3,-32(fp)
 18337c8:	180ad63a 	srli	r5,r3,24
 18337cc:	10c000c3 	ldbu	r3,3(r2)
 18337d0:	1806703a 	and	r3,r3,zero
 18337d4:	1809883a 	mov	r4,r3
 18337d8:	2807883a 	mov	r3,r5
 18337dc:	20c6b03a 	or	r3,r4,r3
 18337e0:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev != NULL) {
 18337e4:	e0bff717 	ldw	r2,-36(fp)
 18337e8:	10004126 	beq	r2,zero,18338f0 <ip_reass_chain_frag_into_datagram_and_validate+0x3b0>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 18337ec:	e0bffc17 	ldw	r2,-16(fp)
 18337f0:	10c00103 	ldbu	r3,4(r2)
 18337f4:	10800143 	ldbu	r2,5(r2)
 18337f8:	1004923a 	slli	r2,r2,8
 18337fc:	10c4b03a 	or	r2,r2,r3
 1833800:	1009883a 	mov	r4,r2
 1833804:	e0bff717 	ldw	r2,-36(fp)
 1833808:	10c00183 	ldbu	r3,6(r2)
 183380c:	108001c3 	ldbu	r2,7(r2)
 1833810:	1004923a 	slli	r2,r2,8
 1833814:	10c4b03a 	or	r2,r2,r3
 1833818:	20ffffcc 	andi	r3,r4,65535
 183381c:	10bfffcc 	andi	r2,r2,65535
 1833820:	1880f936 	bltu	r3,r2,1833c08 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
 1833824:	e0bffc17 	ldw	r2,-16(fp)
 1833828:	10c00183 	ldbu	r3,6(r2)
 183382c:	108001c3 	ldbu	r2,7(r2)
 1833830:	1004923a 	slli	r2,r2,8
 1833834:	10c4b03a 	or	r2,r2,r3
 1833838:	1009883a 	mov	r4,r2
 183383c:	e0bffd17 	ldw	r2,-12(fp)
 1833840:	10c00103 	ldbu	r3,4(r2)
 1833844:	10800143 	ldbu	r2,5(r2)
 1833848:	1004923a 	slli	r2,r2,8
 183384c:	10c4b03a 	or	r2,r2,r3
 1833850:	1007883a 	mov	r3,r2
 1833854:	20bfffcc 	andi	r2,r4,65535
 1833858:	18ffffcc 	andi	r3,r3,65535
 183385c:	1880ea36 	bltu	r3,r2,1833c08 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 1833860:	e0bff717 	ldw	r2,-36(fp)
 1833864:	e0ffff17 	ldw	r3,-4(fp)
 1833868:	19403fcc 	andi	r5,r3,255
 183386c:	10c00003 	ldbu	r3,0(r2)
 1833870:	1806703a 	and	r3,r3,zero
 1833874:	1809883a 	mov	r4,r3
 1833878:	2807883a 	mov	r3,r5
 183387c:	20c6b03a 	or	r3,r4,r3
 1833880:	10c00005 	stb	r3,0(r2)
 1833884:	e0ffff17 	ldw	r3,-4(fp)
 1833888:	1806d23a 	srli	r3,r3,8
 183388c:	19403fcc 	andi	r5,r3,255
 1833890:	10c00043 	ldbu	r3,1(r2)
 1833894:	1806703a 	and	r3,r3,zero
 1833898:	1809883a 	mov	r4,r3
 183389c:	2807883a 	mov	r3,r5
 18338a0:	20c6b03a 	or	r3,r4,r3
 18338a4:	10c00045 	stb	r3,1(r2)
 18338a8:	e0ffff17 	ldw	r3,-4(fp)
 18338ac:	1806d43a 	srli	r3,r3,16
 18338b0:	19403fcc 	andi	r5,r3,255
 18338b4:	10c00083 	ldbu	r3,2(r2)
 18338b8:	1806703a 	and	r3,r3,zero
 18338bc:	1809883a 	mov	r4,r3
 18338c0:	2807883a 	mov	r3,r5
 18338c4:	20c6b03a 	or	r3,r4,r3
 18338c8:	10c00085 	stb	r3,2(r2)
 18338cc:	e0ffff17 	ldw	r3,-4(fp)
 18338d0:	180ad63a 	srli	r5,r3,24
 18338d4:	10c000c3 	ldbu	r3,3(r2)
 18338d8:	1806703a 	and	r3,r3,zero
 18338dc:	1809883a 	mov	r4,r3
 18338e0:	2807883a 	mov	r3,r5
 18338e4:	20c6b03a 	or	r3,r4,r3
 18338e8:	10c000c5 	stb	r3,3(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 18338ec:	00004106 	br	18339f4 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 18338f0:	e0bffe17 	ldw	r2,-8(fp)
 18338f4:	e0ffff17 	ldw	r3,-4(fp)
 18338f8:	10c00115 	stw	r3,4(r2)
      }
      break;
 18338fc:	00003d06 	br	18339f4 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
    } else if(iprh->start == iprh_tmp->start) {
 1833900:	e0bffc17 	ldw	r2,-16(fp)
 1833904:	10c00103 	ldbu	r3,4(r2)
 1833908:	10800143 	ldbu	r2,5(r2)
 183390c:	1004923a 	slli	r2,r2,8
 1833910:	10c4b03a 	or	r2,r2,r3
 1833914:	1009883a 	mov	r4,r2
 1833918:	e0bffd17 	ldw	r2,-12(fp)
 183391c:	10c00103 	ldbu	r3,4(r2)
 1833920:	10800143 	ldbu	r2,5(r2)
 1833924:	1004923a 	slli	r2,r2,8
 1833928:	10c4b03a 	or	r2,r2,r3
 183392c:	20ffffcc 	andi	r3,r4,65535
 1833930:	10bfffcc 	andi	r2,r2,65535
 1833934:	1880b126 	beq	r3,r2,1833bfc <ip_reass_chain_frag_into_datagram_and_validate+0x6bc>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 1833938:	e0bffc17 	ldw	r2,-16(fp)
 183393c:	10c00103 	ldbu	r3,4(r2)
 1833940:	10800143 	ldbu	r2,5(r2)
 1833944:	1004923a 	slli	r2,r2,8
 1833948:	10c4b03a 	or	r2,r2,r3
 183394c:	1009883a 	mov	r4,r2
 1833950:	e0bffd17 	ldw	r2,-12(fp)
 1833954:	10c00183 	ldbu	r3,6(r2)
 1833958:	108001c3 	ldbu	r2,7(r2)
 183395c:	1004923a 	slli	r2,r2,8
 1833960:	10c4b03a 	or	r2,r2,r3
 1833964:	20ffffcc 	andi	r3,r4,65535
 1833968:	10bfffcc 	andi	r2,r2,65535
 183396c:	1880a536 	bltu	r3,r2,1833c04 <ip_reass_chain_frag_into_datagram_and_validate+0x6c4>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 1833970:	e0bff717 	ldw	r2,-36(fp)
 1833974:	10000f26 	beq	r2,zero,18339b4 <ip_reass_chain_frag_into_datagram_and_validate+0x474>
        if (iprh_prev->end != iprh_tmp->start) {
 1833978:	e0bff717 	ldw	r2,-36(fp)
 183397c:	10c00183 	ldbu	r3,6(r2)
 1833980:	108001c3 	ldbu	r2,7(r2)
 1833984:	1004923a 	slli	r2,r2,8
 1833988:	10c4b03a 	or	r2,r2,r3
 183398c:	1009883a 	mov	r4,r2
 1833990:	e0bffd17 	ldw	r2,-12(fp)
 1833994:	10c00103 	ldbu	r3,4(r2)
 1833998:	10800143 	ldbu	r2,5(r2)
 183399c:	1004923a 	slli	r2,r2,8
 18339a0:	10c4b03a 	or	r2,r2,r3
 18339a4:	20ffffcc 	andi	r3,r4,65535
 18339a8:	10bfffcc 	andi	r2,r2,65535
 18339ac:	18800126 	beq	r3,r2,18339b4 <ip_reass_chain_frag_into_datagram_and_validate+0x474>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 18339b0:	e03ff915 	stw	zero,-28(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 18339b4:	e0bffd17 	ldw	r2,-12(fp)
 18339b8:	10c00003 	ldbu	r3,0(r2)
 18339bc:	11000043 	ldbu	r4,1(r2)
 18339c0:	2008923a 	slli	r4,r4,8
 18339c4:	20c6b03a 	or	r3,r4,r3
 18339c8:	11000083 	ldbu	r4,2(r2)
 18339cc:	2008943a 	slli	r4,r4,16
 18339d0:	20c6b03a 	or	r3,r4,r3
 18339d4:	108000c3 	ldbu	r2,3(r2)
 18339d8:	1004963a 	slli	r2,r2,24
 18339dc:	10c4b03a 	or	r2,r2,r3
 18339e0:	e0bff815 	stw	r2,-32(fp)
    iprh_prev = iprh_tmp;
 18339e4:	e0bffd17 	ldw	r2,-12(fp)
 18339e8:	e0bff715 	stw	r2,-36(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 18339ec:	e0bff817 	ldw	r2,-32(fp)
 18339f0:	103f481e 	bne	r2,zero,1833714 <__ram_exceptions_end+0xff8232d0>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 18339f4:	e0bff817 	ldw	r2,-32(fp)
 18339f8:	1000381e 	bne	r2,zero,1833adc <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
    if (iprh_prev != NULL) {
 18339fc:	e0bff717 	ldw	r2,-36(fp)
 1833a00:	10003326 	beq	r2,zero,1833ad0 <ip_reass_chain_frag_into_datagram_and_validate+0x590>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 1833a04:	e0bff717 	ldw	r2,-36(fp)
 1833a08:	e0ffff17 	ldw	r3,-4(fp)
 1833a0c:	19403fcc 	andi	r5,r3,255
 1833a10:	10c00003 	ldbu	r3,0(r2)
 1833a14:	1806703a 	and	r3,r3,zero
 1833a18:	1809883a 	mov	r4,r3
 1833a1c:	2807883a 	mov	r3,r5
 1833a20:	20c6b03a 	or	r3,r4,r3
 1833a24:	10c00005 	stb	r3,0(r2)
 1833a28:	e0ffff17 	ldw	r3,-4(fp)
 1833a2c:	1806d23a 	srli	r3,r3,8
 1833a30:	19403fcc 	andi	r5,r3,255
 1833a34:	10c00043 	ldbu	r3,1(r2)
 1833a38:	1806703a 	and	r3,r3,zero
 1833a3c:	1809883a 	mov	r4,r3
 1833a40:	2807883a 	mov	r3,r5
 1833a44:	20c6b03a 	or	r3,r4,r3
 1833a48:	10c00045 	stb	r3,1(r2)
 1833a4c:	e0ffff17 	ldw	r3,-4(fp)
 1833a50:	1806d43a 	srli	r3,r3,16
 1833a54:	19403fcc 	andi	r5,r3,255
 1833a58:	10c00083 	ldbu	r3,2(r2)
 1833a5c:	1806703a 	and	r3,r3,zero
 1833a60:	1809883a 	mov	r4,r3
 1833a64:	2807883a 	mov	r3,r5
 1833a68:	20c6b03a 	or	r3,r4,r3
 1833a6c:	10c00085 	stb	r3,2(r2)
 1833a70:	e0ffff17 	ldw	r3,-4(fp)
 1833a74:	180ad63a 	srli	r5,r3,24
 1833a78:	10c000c3 	ldbu	r3,3(r2)
 1833a7c:	1806703a 	and	r3,r3,zero
 1833a80:	1809883a 	mov	r4,r3
 1833a84:	2807883a 	mov	r3,r5
 1833a88:	20c6b03a 	or	r3,r4,r3
 1833a8c:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev->end != iprh->start) {
 1833a90:	e0bff717 	ldw	r2,-36(fp)
 1833a94:	10c00183 	ldbu	r3,6(r2)
 1833a98:	108001c3 	ldbu	r2,7(r2)
 1833a9c:	1004923a 	slli	r2,r2,8
 1833aa0:	10c4b03a 	or	r2,r2,r3
 1833aa4:	1009883a 	mov	r4,r2
 1833aa8:	e0bffc17 	ldw	r2,-16(fp)
 1833aac:	10c00103 	ldbu	r3,4(r2)
 1833ab0:	10800143 	ldbu	r2,5(r2)
 1833ab4:	1004923a 	slli	r2,r2,8
 1833ab8:	10c4b03a 	or	r2,r2,r3
 1833abc:	20ffffcc 	andi	r3,r4,65535
 1833ac0:	10bfffcc 	andi	r2,r2,65535
 1833ac4:	18800526 	beq	r3,r2,1833adc <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
        valid = 0;
 1833ac8:	e03ff915 	stw	zero,-28(fp)
 1833acc:	00000306 	br	1833adc <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 1833ad0:	e0bffe17 	ldw	r2,-8(fp)
 1833ad4:	e0ffff17 	ldw	r3,-4(fp)
 1833ad8:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 1833adc:	e0bffe17 	ldw	r2,-8(fp)
 1833ae0:	10800783 	ldbu	r2,30(r2)
 1833ae4:	10803fcc 	andi	r2,r2,255
 1833ae8:	1080004c 	andi	r2,r2,1
 1833aec:	10004126 	beq	r2,zero,1833bf4 <ip_reass_chain_frag_into_datagram_and_validate+0x6b4>
    /* and had no wholes so far */
    if (valid) {
 1833af0:	e0bff917 	ldw	r2,-28(fp)
 1833af4:	10003d26 	beq	r2,zero,1833bec <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 1833af8:	e0bffe17 	ldw	r2,-8(fp)
 1833afc:	10800117 	ldw	r2,4(r2)
 1833b00:	10800117 	ldw	r2,4(r2)
 1833b04:	10c00103 	ldbu	r3,4(r2)
 1833b08:	10800143 	ldbu	r2,5(r2)
 1833b0c:	1004923a 	slli	r2,r2,8
 1833b10:	10c4b03a 	or	r2,r2,r3
 1833b14:	10bfffcc 	andi	r2,r2,65535
 1833b18:	10000226 	beq	r2,zero,1833b24 <ip_reass_chain_frag_into_datagram_and_validate+0x5e4>
        valid = 0;
 1833b1c:	e03ff915 	stw	zero,-28(fp)
 1833b20:	00003206 	br	1833bec <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
 1833b24:	e0bffc17 	ldw	r2,-16(fp)
 1833b28:	e0bff715 	stw	r2,-36(fp)
        q = iprh->next_pbuf;
 1833b2c:	e0bffc17 	ldw	r2,-16(fp)
 1833b30:	10c00003 	ldbu	r3,0(r2)
 1833b34:	11000043 	ldbu	r4,1(r2)
 1833b38:	2008923a 	slli	r4,r4,8
 1833b3c:	20c6b03a 	or	r3,r4,r3
 1833b40:	11000083 	ldbu	r4,2(r2)
 1833b44:	2008943a 	slli	r4,r4,16
 1833b48:	20c6b03a 	or	r3,r4,r3
 1833b4c:	108000c3 	ldbu	r2,3(r2)
 1833b50:	1004963a 	slli	r2,r2,24
 1833b54:	10c4b03a 	or	r2,r2,r3
 1833b58:	e0bff815 	stw	r2,-32(fp)
        while (q != NULL) {
 1833b5c:	00002106 	br	1833be4 <ip_reass_chain_frag_into_datagram_and_validate+0x6a4>
          iprh = (struct ip_reass_helper*)q->payload;
 1833b60:	e0bff817 	ldw	r2,-32(fp)
 1833b64:	10800117 	ldw	r2,4(r2)
 1833b68:	e0bffc15 	stw	r2,-16(fp)
          if (iprh_prev->end != iprh->start) {
 1833b6c:	e0bff717 	ldw	r2,-36(fp)
 1833b70:	10c00183 	ldbu	r3,6(r2)
 1833b74:	108001c3 	ldbu	r2,7(r2)
 1833b78:	1004923a 	slli	r2,r2,8
 1833b7c:	10c4b03a 	or	r2,r2,r3
 1833b80:	1009883a 	mov	r4,r2
 1833b84:	e0bffc17 	ldw	r2,-16(fp)
 1833b88:	10c00103 	ldbu	r3,4(r2)
 1833b8c:	10800143 	ldbu	r2,5(r2)
 1833b90:	1004923a 	slli	r2,r2,8
 1833b94:	10c4b03a 	or	r2,r2,r3
 1833b98:	20ffffcc 	andi	r3,r4,65535
 1833b9c:	10bfffcc 	andi	r2,r2,65535
 1833ba0:	18800226 	beq	r3,r2,1833bac <ip_reass_chain_frag_into_datagram_and_validate+0x66c>
            valid = 0;
 1833ba4:	e03ff915 	stw	zero,-28(fp)
            break;
 1833ba8:	00001006 	br	1833bec <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
          }
          iprh_prev = iprh;
 1833bac:	e0bffc17 	ldw	r2,-16(fp)
 1833bb0:	e0bff715 	stw	r2,-36(fp)
          q = iprh->next_pbuf;
 1833bb4:	e0bffc17 	ldw	r2,-16(fp)
 1833bb8:	10c00003 	ldbu	r3,0(r2)
 1833bbc:	11000043 	ldbu	r4,1(r2)
 1833bc0:	2008923a 	slli	r4,r4,8
 1833bc4:	20c6b03a 	or	r3,r4,r3
 1833bc8:	11000083 	ldbu	r4,2(r2)
 1833bcc:	2008943a 	slli	r4,r4,16
 1833bd0:	20c6b03a 	or	r3,r4,r3
 1833bd4:	108000c3 	ldbu	r2,3(r2)
 1833bd8:	1004963a 	slli	r2,r2,24
 1833bdc:	10c4b03a 	or	r2,r2,r3
 1833be0:	e0bff815 	stw	r2,-32(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 1833be4:	e0bff817 	ldw	r2,-32(fp)
 1833be8:	103fdd1e 	bne	r2,zero,1833b60 <__ram_exceptions_end+0xff82371c>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
 1833bec:	e0bff917 	ldw	r2,-28(fp)
 1833bf0:	00000e06 	br	1833c2c <ip_reass_chain_frag_into_datagram_and_validate+0x6ec>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
 1833bf4:	0005883a 	mov	r2,zero
 1833bf8:	00000c06 	br	1833c2c <ip_reass_chain_frag_into_datagram_and_validate+0x6ec>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
 1833bfc:	0001883a 	nop
 1833c00:	00000106 	br	1833c08 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
 1833c04:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 1833c08:	e13fff17 	ldw	r4,-4(fp)
 1833c0c:	181ade80 	call	181ade8 <pbuf_clen>
 1833c10:	d0e8170b 	ldhu	r3,-24484(gp)
 1833c14:	10803fcc 	andi	r2,r2,255
 1833c18:	1885c83a 	sub	r2,r3,r2
 1833c1c:	d0a8170d 	sth	r2,-24484(gp)
  pbuf_free(new_p);
 1833c20:	e13fff17 	ldw	r4,-4(fp)
 1833c24:	181aca40 	call	181aca4 <pbuf_free>
  return 0;
 1833c28:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
 1833c2c:	e037883a 	mov	sp,fp
 1833c30:	dfc00117 	ldw	ra,4(sp)
 1833c34:	df000017 	ldw	fp,0(sp)
 1833c38:	dec00204 	addi	sp,sp,8
 1833c3c:	f800283a 	ret

01833c40 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 1833c40:	defff604 	addi	sp,sp,-40
 1833c44:	dfc00915 	stw	ra,36(sp)
 1833c48:	df000815 	stw	fp,32(sp)
 1833c4c:	df000804 	addi	fp,sp,32
 1833c50:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
 1833c54:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
 1833c58:	008061f4 	movhi	r2,391
 1833c5c:	10a9d404 	addi	r2,r2,-22704
 1833c60:	10801917 	ldw	r2,100(r2)
 1833c64:	10c00044 	addi	r3,r2,1
 1833c68:	008061f4 	movhi	r2,391
 1833c6c:	10a9d404 	addi	r2,r2,-22704
 1833c70:	10c01915 	stw	r3,100(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 1833c74:	e0bfff17 	ldw	r2,-4(fp)
 1833c78:	10800117 	ldw	r2,4(r2)
 1833c7c:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 1833c80:	e0bffb17 	ldw	r2,-20(fp)
 1833c84:	10800003 	ldbu	r2,0(r2)
 1833c88:	10803fcc 	andi	r2,r2,255
 1833c8c:	108003cc 	andi	r2,r2,15
 1833c90:	1085883a 	add	r2,r2,r2
 1833c94:	1085883a 	add	r2,r2,r2
 1833c98:	10800520 	cmpeqi	r2,r2,20
 1833c9c:	1000081e 	bne	r2,zero,1833cc0 <ip_reass+0x80>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
 1833ca0:	008061f4 	movhi	r2,391
 1833ca4:	10a9d404 	addi	r2,r2,-22704
 1833ca8:	10802217 	ldw	r2,136(r2)
 1833cac:	10c00044 	addi	r3,r2,1
 1833cb0:	008061f4 	movhi	r2,391
 1833cb4:	10a9d404 	addi	r2,r2,-22704
 1833cb8:	10c02215 	stw	r3,136(r2)
    goto nullreturn;
 1833cbc:	00015406 	br	1834210 <ip_reass+0x5d0>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 1833cc0:	e0bffb17 	ldw	r2,-20(fp)
 1833cc4:	10c00183 	ldbu	r3,6(r2)
 1833cc8:	108001c3 	ldbu	r2,7(r2)
 1833ccc:	1004923a 	slli	r2,r2,8
 1833cd0:	10c4b03a 	or	r2,r2,r3
 1833cd4:	10bfffcc 	andi	r2,r2,65535
 1833cd8:	1004d23a 	srli	r2,r2,8
 1833cdc:	10ffffcc 	andi	r3,r2,65535
 1833ce0:	e0bffb17 	ldw	r2,-20(fp)
 1833ce4:	11000183 	ldbu	r4,6(r2)
 1833ce8:	108001c3 	ldbu	r2,7(r2)
 1833cec:	1004923a 	slli	r2,r2,8
 1833cf0:	1104b03a 	or	r2,r2,r4
 1833cf4:	10bfffcc 	andi	r2,r2,65535
 1833cf8:	1004923a 	slli	r2,r2,8
 1833cfc:	10bfffcc 	andi	r2,r2,65535
 1833d00:	1884b03a 	or	r2,r3,r2
 1833d04:	1087ffcc 	andi	r2,r2,8191
 1833d08:	100490fa 	slli	r2,r2,3
 1833d0c:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 1833d10:	e0bffb17 	ldw	r2,-20(fp)
 1833d14:	10c00083 	ldbu	r3,2(r2)
 1833d18:	108000c3 	ldbu	r2,3(r2)
 1833d1c:	1004923a 	slli	r2,r2,8
 1833d20:	10c4b03a 	or	r2,r2,r3
 1833d24:	10bfffcc 	andi	r2,r2,65535
 1833d28:	1004d23a 	srli	r2,r2,8
 1833d2c:	1009883a 	mov	r4,r2
 1833d30:	e0bffb17 	ldw	r2,-20(fp)
 1833d34:	10c00083 	ldbu	r3,2(r2)
 1833d38:	108000c3 	ldbu	r2,3(r2)
 1833d3c:	1004923a 	slli	r2,r2,8
 1833d40:	10c4b03a 	or	r2,r2,r3
 1833d44:	10bfffcc 	andi	r2,r2,65535
 1833d48:	1004923a 	slli	r2,r2,8
 1833d4c:	2084b03a 	or	r2,r4,r2
 1833d50:	1007883a 	mov	r3,r2
 1833d54:	e0bffb17 	ldw	r2,-20(fp)
 1833d58:	10800003 	ldbu	r2,0(r2)
 1833d5c:	10803fcc 	andi	r2,r2,255
 1833d60:	108003cc 	andi	r2,r2,15
 1833d64:	1085883a 	add	r2,r2,r2
 1833d68:	1085883a 	add	r2,r2,r2
 1833d6c:	1885c83a 	sub	r2,r3,r2
 1833d70:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 1833d74:	e13fff17 	ldw	r4,-4(fp)
 1833d78:	181ade80 	call	181ade8 <pbuf_clen>
 1833d7c:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 1833d80:	d0a8170b 	ldhu	r2,-24484(gp)
 1833d84:	10ffffcc 	andi	r3,r2,65535
 1833d88:	e0bffd03 	ldbu	r2,-12(fp)
 1833d8c:	1885883a 	add	r2,r3,r2
 1833d90:	108002d0 	cmplti	r2,r2,11
 1833d94:	1000131e 	bne	r2,zero,1833de4 <ip_reass+0x1a4>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 1833d98:	e0bffd03 	ldbu	r2,-12(fp)
 1833d9c:	100b883a 	mov	r5,r2
 1833da0:	e13ffb17 	ldw	r4,-20(fp)
 1833da4:	183326c0 	call	183326c <ip_reass_remove_oldest_datagram>
 1833da8:	10000626 	beq	r2,zero,1833dc4 <ip_reass+0x184>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 1833dac:	d0a8170b 	ldhu	r2,-24484(gp)
 1833db0:	10ffffcc 	andi	r3,r2,65535
 1833db4:	e0bffd03 	ldbu	r2,-12(fp)
 1833db8:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 1833dbc:	108002d0 	cmplti	r2,r2,11
 1833dc0:	1000081e 	bne	r2,zero,1833de4 <ip_reass+0x1a4>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
 1833dc4:	008061f4 	movhi	r2,391
 1833dc8:	10a9d404 	addi	r2,r2,-22704
 1833dcc:	10801e17 	ldw	r2,120(r2)
 1833dd0:	10c00044 	addi	r3,r2,1
 1833dd4:	008061f4 	movhi	r2,391
 1833dd8:	10a9d404 	addi	r2,r2,-22704
 1833ddc:	10c01e15 	stw	r3,120(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
 1833de0:	00010b06 	br	1834210 <ip_reass+0x5d0>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 1833de4:	d0a81617 	ldw	r2,-24488(gp)
 1833de8:	e0bff915 	stw	r2,-28(fp)
 1833dec:	00003306 	br	1833ebc <ip_reass+0x27c>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 1833df0:	e0bff917 	ldw	r2,-28(fp)
 1833df4:	10c00517 	ldw	r3,20(r2)
 1833df8:	e0bffb17 	ldw	r2,-20(fp)
 1833dfc:	11000303 	ldbu	r4,12(r2)
 1833e00:	11400343 	ldbu	r5,13(r2)
 1833e04:	280a923a 	slli	r5,r5,8
 1833e08:	2908b03a 	or	r4,r5,r4
 1833e0c:	11400383 	ldbu	r5,14(r2)
 1833e10:	280a943a 	slli	r5,r5,16
 1833e14:	2908b03a 	or	r4,r5,r4
 1833e18:	108003c3 	ldbu	r2,15(r2)
 1833e1c:	1004963a 	slli	r2,r2,24
 1833e20:	1104b03a 	or	r2,r2,r4
 1833e24:	1880201e 	bne	r3,r2,1833ea8 <ip_reass+0x268>
 1833e28:	e0bff917 	ldw	r2,-28(fp)
 1833e2c:	10c00617 	ldw	r3,24(r2)
 1833e30:	e0bffb17 	ldw	r2,-20(fp)
 1833e34:	11000403 	ldbu	r4,16(r2)
 1833e38:	11400443 	ldbu	r5,17(r2)
 1833e3c:	280a923a 	slli	r5,r5,8
 1833e40:	2908b03a 	or	r4,r5,r4
 1833e44:	11400483 	ldbu	r5,18(r2)
 1833e48:	280a943a 	slli	r5,r5,16
 1833e4c:	2908b03a 	or	r4,r5,r4
 1833e50:	108004c3 	ldbu	r2,19(r2)
 1833e54:	1004963a 	slli	r2,r2,24
 1833e58:	1104b03a 	or	r2,r2,r4
 1833e5c:	1880121e 	bne	r3,r2,1833ea8 <ip_reass+0x268>
 1833e60:	e0bff917 	ldw	r2,-28(fp)
 1833e64:	1100030b 	ldhu	r4,12(r2)
 1833e68:	e0bffb17 	ldw	r2,-20(fp)
 1833e6c:	10c00103 	ldbu	r3,4(r2)
 1833e70:	10800143 	ldbu	r2,5(r2)
 1833e74:	1004923a 	slli	r2,r2,8
 1833e78:	10c4b03a 	or	r2,r2,r3
 1833e7c:	20ffffcc 	andi	r3,r4,65535
 1833e80:	10bfffcc 	andi	r2,r2,65535
 1833e84:	1880081e 	bne	r3,r2,1833ea8 <ip_reass+0x268>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
 1833e88:	008061f4 	movhi	r2,391
 1833e8c:	10a9d404 	addi	r2,r2,-22704
 1833e90:	10802317 	ldw	r2,140(r2)
 1833e94:	10c00044 	addi	r3,r2,1
 1833e98:	008061f4 	movhi	r2,391
 1833e9c:	10a9d404 	addi	r2,r2,-22704
 1833ea0:	10c02315 	stw	r3,140(r2)
      break;
 1833ea4:	00000706 	br	1833ec4 <ip_reass+0x284>
    }
    ipr_prev = ipr;
 1833ea8:	e0bff917 	ldw	r2,-28(fp)
 1833eac:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 1833eb0:	e0bff917 	ldw	r2,-28(fp)
 1833eb4:	10800017 	ldw	r2,0(r2)
 1833eb8:	e0bff915 	stw	r2,-28(fp)
 1833ebc:	e0bff917 	ldw	r2,-28(fp)
 1833ec0:	103fcb1e 	bne	r2,zero,1833df0 <__ram_exceptions_end+0xff8239ac>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
 1833ec4:	e0bff917 	ldw	r2,-28(fp)
 1833ec8:	1000081e 	bne	r2,zero,1833eec <ip_reass+0x2ac>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 1833ecc:	e0bffd03 	ldbu	r2,-12(fp)
 1833ed0:	100b883a 	mov	r5,r2
 1833ed4:	e13ffb17 	ldw	r4,-20(fp)
 1833ed8:	18333fc0 	call	18333fc <ip_reass_enqueue_new_datagram>
 1833edc:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
 1833ee0:	e0bff917 	ldw	r2,-28(fp)
 1833ee4:	1000271e 	bne	r2,zero,1833f84 <ip_reass+0x344>
      goto nullreturn;
 1833ee8:	0000c906 	br	1834210 <ip_reass+0x5d0>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 1833eec:	e0bffb17 	ldw	r2,-20(fp)
 1833ef0:	10c00183 	ldbu	r3,6(r2)
 1833ef4:	108001c3 	ldbu	r2,7(r2)
 1833ef8:	1004923a 	slli	r2,r2,8
 1833efc:	10c4b03a 	or	r2,r2,r3
 1833f00:	10bfffcc 	andi	r2,r2,65535
 1833f04:	1004d23a 	srli	r2,r2,8
 1833f08:	10ffffcc 	andi	r3,r2,65535
 1833f0c:	e0bffb17 	ldw	r2,-20(fp)
 1833f10:	11000183 	ldbu	r4,6(r2)
 1833f14:	108001c3 	ldbu	r2,7(r2)
 1833f18:	1004923a 	slli	r2,r2,8
 1833f1c:	1104b03a 	or	r2,r2,r4
 1833f20:	10bfffcc 	andi	r2,r2,65535
 1833f24:	1004923a 	slli	r2,r2,8
 1833f28:	10bfffcc 	andi	r2,r2,65535
 1833f2c:	1884b03a 	or	r2,r3,r2
 1833f30:	1087ffcc 	andi	r2,r2,8191
 1833f34:	1000131e 	bne	r2,zero,1833f84 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 1833f38:	e0bff917 	ldw	r2,-28(fp)
 1833f3c:	1080038b 	ldhu	r2,14(r2)
 1833f40:	10bfffcc 	andi	r2,r2,65535
 1833f44:	1004d23a 	srli	r2,r2,8
 1833f48:	10ffffcc 	andi	r3,r2,65535
 1833f4c:	e0bff917 	ldw	r2,-28(fp)
 1833f50:	1080038b 	ldhu	r2,14(r2)
 1833f54:	10bfffcc 	andi	r2,r2,65535
 1833f58:	1004923a 	slli	r2,r2,8
 1833f5c:	10bfffcc 	andi	r2,r2,65535
 1833f60:	1884b03a 	or	r2,r3,r2
 1833f64:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 1833f68:	10000626 	beq	r2,zero,1833f84 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 1833f6c:	e0bff917 	ldw	r2,-28(fp)
 1833f70:	10800204 	addi	r2,r2,8
 1833f74:	01800504 	movi	r6,20
 1833f78:	e17ffb17 	ldw	r5,-20(fp)
 1833f7c:	1009883a 	mov	r4,r2
 1833f80:	180608c0 	call	180608c <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 1833f84:	e0fffd03 	ldbu	r3,-12(fp)
 1833f88:	d0a8170b 	ldhu	r2,-24484(gp)
 1833f8c:	1885883a 	add	r2,r3,r2
 1833f90:	d0a8170d 	sth	r2,-24484(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 1833f94:	e0bffb17 	ldw	r2,-20(fp)
 1833f98:	10c00183 	ldbu	r3,6(r2)
 1833f9c:	108001c3 	ldbu	r2,7(r2)
 1833fa0:	1004923a 	slli	r2,r2,8
 1833fa4:	10c4b03a 	or	r2,r2,r3
 1833fa8:	10bfffcc 	andi	r2,r2,65535
 1833fac:	1080080c 	andi	r2,r2,32
 1833fb0:	10000c1e 	bne	r2,zero,1833fe4 <ip_reass+0x3a4>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 1833fb4:	e0bff917 	ldw	r2,-28(fp)
 1833fb8:	10800783 	ldbu	r2,30(r2)
 1833fbc:	10800054 	ori	r2,r2,1
 1833fc0:	1007883a 	mov	r3,r2
 1833fc4:	e0bff917 	ldw	r2,-28(fp)
 1833fc8:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
 1833fcc:	e0fffc0b 	ldhu	r3,-16(fp)
 1833fd0:	e0bffc8b 	ldhu	r2,-14(fp)
 1833fd4:	1885883a 	add	r2,r3,r2
 1833fd8:	1007883a 	mov	r3,r2
 1833fdc:	e0bff917 	ldw	r2,-28(fp)
 1833fe0:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
 1833fe4:	e17fff17 	ldw	r5,-4(fp)
 1833fe8:	e13ff917 	ldw	r4,-28(fp)
 1833fec:	18335400 	call	1833540 <ip_reass_chain_frag_into_datagram_and_validate>
 1833ff0:	10008526 	beq	r2,zero,1834208 <ip_reass+0x5c8>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 1833ff4:	e0bff917 	ldw	r2,-28(fp)
 1833ff8:	1080070b 	ldhu	r2,28(r2)
 1833ffc:	10800504 	addi	r2,r2,20
 1834000:	1007883a 	mov	r3,r2
 1834004:	e0bff917 	ldw	r2,-28(fp)
 1834008:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 183400c:	e0bff917 	ldw	r2,-28(fp)
 1834010:	10800117 	ldw	r2,4(r2)
 1834014:	10800117 	ldw	r2,4(r2)
 1834018:	10c00003 	ldbu	r3,0(r2)
 183401c:	11000043 	ldbu	r4,1(r2)
 1834020:	2008923a 	slli	r4,r4,8
 1834024:	20c6b03a 	or	r3,r4,r3
 1834028:	11000083 	ldbu	r4,2(r2)
 183402c:	2008943a 	slli	r4,r4,16
 1834030:	20c6b03a 	or	r3,r4,r3
 1834034:	108000c3 	ldbu	r2,3(r2)
 1834038:	1004963a 	slli	r2,r2,24
 183403c:	10c4b03a 	or	r2,r2,r3
 1834040:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
 1834044:	e0bff917 	ldw	r2,-28(fp)
 1834048:	10800117 	ldw	r2,4(r2)
 183404c:	10800117 	ldw	r2,4(r2)
 1834050:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 1834054:	e0bff917 	ldw	r2,-28(fp)
 1834058:	10800204 	addi	r2,r2,8
 183405c:	01800504 	movi	r6,20
 1834060:	100b883a 	mov	r5,r2
 1834064:	e13ffb17 	ldw	r4,-20(fp)
 1834068:	180608c0 	call	180608c <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 183406c:	e0bff917 	ldw	r2,-28(fp)
 1834070:	1080070b 	ldhu	r2,28(r2)
 1834074:	10bfffcc 	andi	r2,r2,65535
 1834078:	1004d23a 	srli	r2,r2,8
 183407c:	1007883a 	mov	r3,r2
 1834080:	e0bff917 	ldw	r2,-28(fp)
 1834084:	1080070b 	ldhu	r2,28(r2)
 1834088:	10bfffcc 	andi	r2,r2,65535
 183408c:	1004923a 	slli	r2,r2,8
 1834090:	1884b03a 	or	r2,r3,r2
 1834094:	100d883a 	mov	r6,r2
 1834098:	e0bffb17 	ldw	r2,-20(fp)
 183409c:	30ffffcc 	andi	r3,r6,65535
 18340a0:	19403fcc 	andi	r5,r3,255
 18340a4:	10c00083 	ldbu	r3,2(r2)
 18340a8:	1806703a 	and	r3,r3,zero
 18340ac:	1809883a 	mov	r4,r3
 18340b0:	2807883a 	mov	r3,r5
 18340b4:	20c6b03a 	or	r3,r4,r3
 18340b8:	10c00085 	stb	r3,2(r2)
 18340bc:	30ffffcc 	andi	r3,r6,65535
 18340c0:	1806d23a 	srli	r3,r3,8
 18340c4:	197fffcc 	andi	r5,r3,65535
 18340c8:	10c000c3 	ldbu	r3,3(r2)
 18340cc:	1806703a 	and	r3,r3,zero
 18340d0:	1809883a 	mov	r4,r3
 18340d4:	2807883a 	mov	r3,r5
 18340d8:	20c6b03a 	or	r3,r4,r3
 18340dc:	10c000c5 	stb	r3,3(r2)
    IPH_OFFSET_SET(fraghdr, 0);
 18340e0:	e0bffb17 	ldw	r2,-20(fp)
 18340e4:	10c00183 	ldbu	r3,6(r2)
 18340e8:	1806703a 	and	r3,r3,zero
 18340ec:	10c00185 	stb	r3,6(r2)
 18340f0:	10c001c3 	ldbu	r3,7(r2)
 18340f4:	1806703a 	and	r3,r3,zero
 18340f8:	10c001c5 	stb	r3,7(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
 18340fc:	e0bffb17 	ldw	r2,-20(fp)
 1834100:	10c00283 	ldbu	r3,10(r2)
 1834104:	1806703a 	and	r3,r3,zero
 1834108:	10c00285 	stb	r3,10(r2)
 183410c:	10c002c3 	ldbu	r3,11(r2)
 1834110:	1806703a 	and	r3,r3,zero
 1834114:	10c002c5 	stb	r3,11(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 1834118:	01400504 	movi	r5,20
 183411c:	e13ffb17 	ldw	r4,-20(fp)
 1834120:	18320980 	call	1832098 <inet_chksum>
 1834124:	100d883a 	mov	r6,r2
 1834128:	e0bffb17 	ldw	r2,-20(fp)
 183412c:	30ffffcc 	andi	r3,r6,65535
 1834130:	19403fcc 	andi	r5,r3,255
 1834134:	10c00283 	ldbu	r3,10(r2)
 1834138:	1806703a 	and	r3,r3,zero
 183413c:	1809883a 	mov	r4,r3
 1834140:	2807883a 	mov	r3,r5
 1834144:	20c6b03a 	or	r3,r4,r3
 1834148:	10c00285 	stb	r3,10(r2)
 183414c:	30ffffcc 	andi	r3,r6,65535
 1834150:	1806d23a 	srli	r3,r3,8
 1834154:	197fffcc 	andi	r5,r3,65535
 1834158:	10c002c3 	ldbu	r3,11(r2)
 183415c:	1806703a 	and	r3,r3,zero
 1834160:	1809883a 	mov	r4,r3
 1834164:	2807883a 	mov	r3,r5
 1834168:	20c6b03a 	or	r3,r4,r3
 183416c:	10c002c5 	stb	r3,11(r2)

    p = ipr->p;
 1834170:	e0bff917 	ldw	r2,-28(fp)
 1834174:	10800117 	ldw	r2,4(r2)
 1834178:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 183417c:	00001506 	br	18341d4 <ip_reass+0x594>
      iprh = (struct ip_reass_helper*)r->payload;
 1834180:	e0bff817 	ldw	r2,-32(fp)
 1834184:	10800117 	ldw	r2,4(r2)
 1834188:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 183418c:	017ffb04 	movi	r5,-20
 1834190:	e13ff817 	ldw	r4,-32(fp)
 1834194:	181aaf40 	call	181aaf4 <pbuf_header>
      pbuf_cat(p, r);
 1834198:	e17ff817 	ldw	r5,-32(fp)
 183419c:	e13fff17 	ldw	r4,-4(fp)
 18341a0:	181ae980 	call	181ae98 <pbuf_cat>
      r = iprh->next_pbuf;
 18341a4:	e0bffe17 	ldw	r2,-8(fp)
 18341a8:	10c00003 	ldbu	r3,0(r2)
 18341ac:	11000043 	ldbu	r4,1(r2)
 18341b0:	2008923a 	slli	r4,r4,8
 18341b4:	20c6b03a 	or	r3,r4,r3
 18341b8:	11000083 	ldbu	r4,2(r2)
 18341bc:	2008943a 	slli	r4,r4,16
 18341c0:	20c6b03a 	or	r3,r4,r3
 18341c4:	108000c3 	ldbu	r2,3(r2)
 18341c8:	1004963a 	slli	r2,r2,24
 18341cc:	10c4b03a 	or	r2,r2,r3
 18341d0:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 18341d4:	e0bff817 	ldw	r2,-32(fp)
 18341d8:	103fe91e 	bne	r2,zero,1834180 <__ram_exceptions_end+0xff823d3c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 18341dc:	e17ffa17 	ldw	r5,-24(fp)
 18341e0:	e13ff917 	ldw	r4,-28(fp)
 18341e4:	18334d80 	call	18334d8 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 18341e8:	e13fff17 	ldw	r4,-4(fp)
 18341ec:	181ade80 	call	181ade8 <pbuf_clen>
 18341f0:	d0e8170b 	ldhu	r3,-24484(gp)
 18341f4:	10803fcc 	andi	r2,r2,255
 18341f8:	1885c83a 	sub	r2,r3,r2
 18341fc:	d0a8170d 	sth	r2,-24484(gp)

    /* Return the pbuf chain */
    return p;
 1834200:	e0bfff17 	ldw	r2,-4(fp)
 1834204:	00000c06 	br	1834238 <ip_reass+0x5f8>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 1834208:	0005883a 	mov	r2,zero
 183420c:	00000a06 	br	1834238 <ip_reass+0x5f8>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
 1834210:	008061f4 	movhi	r2,391
 1834214:	10a9d404 	addi	r2,r2,-22704
 1834218:	10801b17 	ldw	r2,108(r2)
 183421c:	10c00044 	addi	r3,r2,1
 1834220:	008061f4 	movhi	r2,391
 1834224:	10a9d404 	addi	r2,r2,-22704
 1834228:	10c01b15 	stw	r3,108(r2)
  pbuf_free(p);
 183422c:	e13fff17 	ldw	r4,-4(fp)
 1834230:	181aca40 	call	181aca4 <pbuf_free>
  return NULL;
 1834234:	0005883a 	mov	r2,zero
}
 1834238:	e037883a 	mov	sp,fp
 183423c:	dfc00117 	ldw	ra,4(sp)
 1834240:	df000017 	ldw	fp,0(sp)
 1834244:	dec00204 	addi	sp,sp,8
 1834248:	f800283a 	ret

0183424c <ip_frag_alloc_pbuf_custom_ref>:

#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
 183424c:	defffe04 	addi	sp,sp,-8
 1834250:	dfc00115 	stw	ra,4(sp)
 1834254:	df000015 	stw	fp,0(sp)
 1834258:	d839883a 	mov	fp,sp
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 183425c:	01000184 	movi	r4,6
 1834260:	18349580 	call	1834958 <memp_malloc>
}
 1834264:	e037883a 	mov	sp,fp
 1834268:	dfc00117 	ldw	ra,4(sp)
 183426c:	df000017 	ldw	fp,0(sp)
 1834270:	dec00204 	addi	sp,sp,8
 1834274:	f800283a 	ret

01834278 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 1834278:	defffd04 	addi	sp,sp,-12
 183427c:	dfc00215 	stw	ra,8(sp)
 1834280:	df000115 	stw	fp,4(sp)
 1834284:	df000104 	addi	fp,sp,4
 1834288:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 183428c:	e17fff17 	ldw	r5,-4(fp)
 1834290:	01000184 	movi	r4,6
 1834294:	1834b240 	call	1834b24 <memp_free>
}
 1834298:	0001883a 	nop
 183429c:	e037883a 	mov	sp,fp
 18342a0:	dfc00117 	ldw	ra,4(sp)
 18342a4:	df000017 	ldw	fp,0(sp)
 18342a8:	dec00204 	addi	sp,sp,8
 18342ac:	f800283a 	ret

018342b0 <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 18342b0:	defffc04 	addi	sp,sp,-16
 18342b4:	dfc00315 	stw	ra,12(sp)
 18342b8:	df000215 	stw	fp,8(sp)
 18342bc:	df000204 	addi	fp,sp,8
 18342c0:	e13fff15 	stw	r4,-4(fp)
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
 18342c4:	e0bfff17 	ldw	r2,-4(fp)
 18342c8:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 18342cc:	e0bffe17 	ldw	r2,-8(fp)
 18342d0:	10800517 	ldw	r2,20(r2)
 18342d4:	10000426 	beq	r2,zero,18342e8 <ipfrag_free_pbuf_custom+0x38>
    pbuf_free(pcr->original);
 18342d8:	e0bffe17 	ldw	r2,-8(fp)
 18342dc:	10800517 	ldw	r2,20(r2)
 18342e0:	1009883a 	mov	r4,r2
 18342e4:	181aca40 	call	181aca4 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 18342e8:	e13ffe17 	ldw	r4,-8(fp)
 18342ec:	18342780 	call	1834278 <ip_frag_free_pbuf_custom_ref>
}
 18342f0:	0001883a 	nop
 18342f4:	e037883a 	mov	sp,fp
 18342f8:	dfc00117 	ldw	ra,4(sp)
 18342fc:	df000017 	ldw	fp,0(sp)
 1834300:	dec00204 	addi	sp,sp,8
 1834304:	f800283a 	ret

01834308 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 1834308:	deffee04 	addi	sp,sp,-72
 183430c:	dfc01115 	stw	ra,68(sp)
 1834310:	df001015 	stw	fp,64(sp)
 1834314:	df001004 	addi	fp,sp,64
 1834318:	e13ffd15 	stw	r4,-12(fp)
 183431c:	e17ffe15 	stw	r5,-8(fp)
 1834320:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 1834324:	e0bffe17 	ldw	r2,-8(fp)
 1834328:	10800c0b 	ldhu	r2,48(r2)
 183432c:	e0bff50d 	sth	r2,-44(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
 1834330:	00800504 	movi	r2,20
 1834334:	e0bff30d 	sth	r2,-52(fp)
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
  u16_t newpbuflen = 0;
 1834338:	e03ff40d 	sth	zero,-48(fp)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 183433c:	e0bffd17 	ldw	r2,-12(fp)
 1834340:	10800117 	ldw	r2,4(r2)
 1834344:	e0bff615 	stw	r2,-40(fp)
  iphdr = original_iphdr;
 1834348:	e0bff617 	ldw	r2,-40(fp)
 183434c:	e0bff715 	stw	r2,-36(fp)
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 1834350:	e0bff717 	ldw	r2,-36(fp)
 1834354:	10c00183 	ldbu	r3,6(r2)
 1834358:	108001c3 	ldbu	r2,7(r2)
 183435c:	1004923a 	slli	r2,r2,8
 1834360:	10c4b03a 	or	r2,r2,r3
 1834364:	10bfffcc 	andi	r2,r2,65535
 1834368:	1004d23a 	srli	r2,r2,8
 183436c:	1009883a 	mov	r4,r2
 1834370:	e0bff717 	ldw	r2,-36(fp)
 1834374:	10c00183 	ldbu	r3,6(r2)
 1834378:	108001c3 	ldbu	r2,7(r2)
 183437c:	1004923a 	slli	r2,r2,8
 1834380:	10c4b03a 	or	r2,r2,r3
 1834384:	10bfffcc 	andi	r2,r2,65535
 1834388:	1004923a 	slli	r2,r2,8
 183438c:	2084b03a 	or	r2,r4,r2
 1834390:	e0bff38d 	sth	r2,-50(fp)
  ofo = tmp & IP_OFFMASK;
 1834394:	e0bff38b 	ldhu	r2,-50(fp)
 1834398:	1087ffcc 	andi	r2,r2,8191
 183439c:	e0bff28d 	sth	r2,-54(fp)
  omf = tmp & IP_MF;
 18343a0:	e0bff38b 	ldhu	r2,-50(fp)
 18343a4:	1088000c 	andi	r2,r2,8192
 18343a8:	e0bff80d 	sth	r2,-32(fp)

  left = p->tot_len - IP_HLEN;
 18343ac:	e0bffd17 	ldw	r2,-12(fp)
 18343b0:	1080020b 	ldhu	r2,8(r2)
 18343b4:	10bffb04 	addi	r2,r2,-20
 18343b8:	e0bff20d 	sth	r2,-56(fp)

  nfb = (mtu - IP_HLEN) / 8;
 18343bc:	e0bff50b 	ldhu	r2,-44(fp)
 18343c0:	10bffb04 	addi	r2,r2,-20
 18343c4:	1000010e 	bge	r2,zero,18343cc <ip_frag+0xc4>
 18343c8:	108001c4 	addi	r2,r2,7
 18343cc:	1005d0fa 	srai	r2,r2,3
 18343d0:	e0bff88d 	sth	r2,-30(fp)

  while (left) {
 18343d4:	0000e706 	br	1834774 <ip_frag+0x46c>
    last = (left <= mtu - IP_HLEN);
 18343d8:	e0bff20b 	ldhu	r2,-56(fp)
 18343dc:	e0fff50b 	ldhu	r3,-44(fp)
 18343e0:	18fffb04 	addi	r3,r3,-20
 18343e4:	1884403a 	cmpge	r2,r3,r2
 18343e8:	10803fcc 	andi	r2,r2,255
 18343ec:	e0bff90d 	sth	r2,-28(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 18343f0:	e0bff28b 	ldhu	r2,-54(fp)
 18343f4:	1087ffcc 	andi	r2,r2,8191
 18343f8:	1007883a 	mov	r3,r2
 18343fc:	e0bff80b 	ldhu	r2,-32(fp)
 1834400:	1884b03a 	or	r2,r3,r2
 1834404:	e0bff38d 	sth	r2,-50(fp)
    if (!last) {
 1834408:	e0bff90b 	ldhu	r2,-28(fp)
 183440c:	1000031e 	bne	r2,zero,183441c <ip_frag+0x114>
      tmp = tmp | IP_MF;
 1834410:	e0bff38b 	ldhu	r2,-50(fp)
 1834414:	10880014 	ori	r2,r2,8192
 1834418:	e0bff38d 	sth	r2,-50(fp)
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 183441c:	e0bff90b 	ldhu	r2,-28(fp)
 1834420:	1000031e 	bne	r2,zero,1834430 <ip_frag+0x128>
 1834424:	e0bff88b 	ldhu	r2,-30(fp)
 1834428:	100490fa 	slli	r2,r2,3
 183442c:	00000106 	br	1834434 <ip_frag+0x12c>
 1834430:	e0bff20b 	ldhu	r2,-56(fp)
 1834434:	e0bff98d 	sth	r2,-26(fp)
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 1834438:	000d883a 	mov	r6,zero
 183443c:	01400504 	movi	r5,20
 1834440:	01000084 	movi	r4,2
 1834444:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1834448:	e0bffa15 	stw	r2,-24(fp)
    if (rambuf == NULL) {
 183444c:	e0bffa17 	ldw	r2,-24(fp)
 1834450:	1000021e 	bne	r2,zero,183445c <ip_frag+0x154>
      return ERR_MEM;
 1834454:	00bfffc4 	movi	r2,-1
 1834458:	0000c906 	br	1834780 <ip_frag+0x478>
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 183445c:	e0bffa17 	ldw	r2,-24(fp)
 1834460:	10800117 	ldw	r2,4(r2)
 1834464:	01800504 	movi	r6,20
 1834468:	e17ff617 	ldw	r5,-40(fp)
 183446c:	1009883a 	mov	r4,r2
 1834470:	180608c0 	call	180608c <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
 1834474:	e0bffa17 	ldw	r2,-24(fp)
 1834478:	10800117 	ldw	r2,4(r2)
 183447c:	e0bff715 	stw	r2,-36(fp)

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 1834480:	e0bffd17 	ldw	r2,-12(fp)
 1834484:	10c00117 	ldw	r3,4(r2)
 1834488:	e0bff30b 	ldhu	r2,-52(fp)
 183448c:	1887883a 	add	r3,r3,r2
 1834490:	e0bffd17 	ldw	r2,-12(fp)
 1834494:	10c00115 	stw	r3,4(r2)
    p->len -= poff;
 1834498:	e0bffd17 	ldw	r2,-12(fp)
 183449c:	10c0028b 	ldhu	r3,10(r2)
 18344a0:	e0bff30b 	ldhu	r2,-52(fp)
 18344a4:	1885c83a 	sub	r2,r3,r2
 18344a8:	1007883a 	mov	r3,r2
 18344ac:	e0bffd17 	ldw	r2,-12(fp)
 18344b0:	10c0028d 	sth	r3,10(r2)

    left_to_copy = cop;
 18344b4:	e0bff98b 	ldhu	r2,-26(fp)
 18344b8:	e0bff48d 	sth	r2,-46(fp)
    while (left_to_copy) {
 18344bc:	00004006 	br	18345c0 <ip_frag+0x2b8>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 18344c0:	e0bffd17 	ldw	r2,-12(fp)
 18344c4:	1080028b 	ldhu	r2,10(r2)
 18344c8:	e17ff48b 	ldhu	r5,-46(fp)
 18344cc:	10ffffcc 	andi	r3,r2,65535
 18344d0:	293fffcc 	andi	r4,r5,65535
 18344d4:	20c0012e 	bgeu	r4,r3,18344dc <ip_frag+0x1d4>
 18344d8:	2805883a 	mov	r2,r5
 18344dc:	e0bff40d 	sth	r2,-48(fp)
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 18344e0:	e0bff40b 	ldhu	r2,-48(fp)
 18344e4:	1000041e 	bne	r2,zero,18344f8 <ip_frag+0x1f0>
        p = p->next;
 18344e8:	e0bffd17 	ldw	r2,-12(fp)
 18344ec:	10800017 	ldw	r2,0(r2)
 18344f0:	e0bffd15 	stw	r2,-12(fp)
        continue;
 18344f4:	00003206 	br	18345c0 <ip_frag+0x2b8>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 18344f8:	183424c0 	call	183424c <ip_frag_alloc_pbuf_custom_ref>
 18344fc:	e0bffb15 	stw	r2,-20(fp)
      if (pcr == NULL) {
 1834500:	e0bffb17 	ldw	r2,-20(fp)
 1834504:	1000041e 	bne	r2,zero,1834518 <ip_frag+0x210>
        pbuf_free(rambuf);
 1834508:	e13ffa17 	ldw	r4,-24(fp)
 183450c:	181aca40 	call	181aca4 <pbuf_free>
        return ERR_MEM;
 1834510:	00bfffc4 	movi	r2,-1
 1834514:	00009a06 	br	1834780 <ip_frag+0x478>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 1834518:	e13ff40b 	ldhu	r4,-48(fp)
 183451c:	e17ffb17 	ldw	r5,-20(fp)
 1834520:	e0bffd17 	ldw	r2,-12(fp)
 1834524:	10800117 	ldw	r2,4(r2)
 1834528:	e0fff40b 	ldhu	r3,-48(fp)
 183452c:	d8c00115 	stw	r3,4(sp)
 1834530:	d8800015 	stw	r2,0(sp)
 1834534:	280f883a 	mov	r7,r5
 1834538:	01800084 	movi	r6,2
 183453c:	200b883a 	mov	r5,r4
 1834540:	010000c4 	movi	r4,3
 1834544:	181a8540 	call	181a854 <pbuf_alloced_custom>
 1834548:	e0bffc15 	stw	r2,-16(fp)
      if (newpbuf == NULL) {
 183454c:	e0bffc17 	ldw	r2,-16(fp)
 1834550:	1000061e 	bne	r2,zero,183456c <ip_frag+0x264>
        ip_frag_free_pbuf_custom_ref(pcr);
 1834554:	e13ffb17 	ldw	r4,-20(fp)
 1834558:	18342780 	call	1834278 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 183455c:	e13ffa17 	ldw	r4,-24(fp)
 1834560:	181aca40 	call	181aca4 <pbuf_free>
        return ERR_MEM;
 1834564:	00bfffc4 	movi	r2,-1
 1834568:	00008506 	br	1834780 <ip_frag+0x478>
      }
      pbuf_ref(p);
 183456c:	e13ffd17 	ldw	r4,-12(fp)
 1834570:	181ae340 	call	181ae34 <pbuf_ref>
      pcr->original = p;
 1834574:	e0bffb17 	ldw	r2,-20(fp)
 1834578:	e0fffd17 	ldw	r3,-12(fp)
 183457c:	10c00515 	stw	r3,20(r2)
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 1834580:	e0fffb17 	ldw	r3,-20(fp)
 1834584:	008060f4 	movhi	r2,387
 1834588:	1090ac04 	addi	r2,r2,17072
 183458c:	18800415 	stw	r2,16(r3)

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 1834590:	e17ffc17 	ldw	r5,-16(fp)
 1834594:	e13ffa17 	ldw	r4,-24(fp)
 1834598:	181ae980 	call	181ae98 <pbuf_cat>
      left_to_copy -= newpbuflen;
 183459c:	e0fff48b 	ldhu	r3,-46(fp)
 18345a0:	e0bff40b 	ldhu	r2,-48(fp)
 18345a4:	1885c83a 	sub	r2,r3,r2
 18345a8:	e0bff48d 	sth	r2,-46(fp)
      if (left_to_copy) {
 18345ac:	e0bff48b 	ldhu	r2,-46(fp)
 18345b0:	10000326 	beq	r2,zero,18345c0 <ip_frag+0x2b8>
        p = p->next;
 18345b4:	e0bffd17 	ldw	r2,-12(fp)
 18345b8:	10800017 	ldw	r2,0(r2)
 18345bc:	e0bffd15 	stw	r2,-12(fp)
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
 18345c0:	e0bff48b 	ldhu	r2,-46(fp)
 18345c4:	103fbe1e 	bne	r2,zero,18344c0 <__ram_exceptions_end+0xff82407c>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
 18345c8:	e0bff40b 	ldhu	r2,-48(fp)
 18345cc:	e0bff30d 	sth	r2,-52(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 18345d0:	e0bff38b 	ldhu	r2,-50(fp)
 18345d4:	1004d23a 	srli	r2,r2,8
 18345d8:	1007883a 	mov	r3,r2
 18345dc:	e0bff38b 	ldhu	r2,-50(fp)
 18345e0:	1004923a 	slli	r2,r2,8
 18345e4:	1884b03a 	or	r2,r3,r2
 18345e8:	100d883a 	mov	r6,r2
 18345ec:	e0bff717 	ldw	r2,-36(fp)
 18345f0:	30ffffcc 	andi	r3,r6,65535
 18345f4:	19403fcc 	andi	r5,r3,255
 18345f8:	10c00183 	ldbu	r3,6(r2)
 18345fc:	1806703a 	and	r3,r3,zero
 1834600:	1809883a 	mov	r4,r3
 1834604:	2807883a 	mov	r3,r5
 1834608:	20c6b03a 	or	r3,r4,r3
 183460c:	10c00185 	stb	r3,6(r2)
 1834610:	30ffffcc 	andi	r3,r6,65535
 1834614:	1806d23a 	srli	r3,r3,8
 1834618:	197fffcc 	andi	r5,r3,65535
 183461c:	10c001c3 	ldbu	r3,7(r2)
 1834620:	1806703a 	and	r3,r3,zero
 1834624:	1809883a 	mov	r4,r3
 1834628:	2807883a 	mov	r3,r5
 183462c:	20c6b03a 	or	r3,r4,r3
 1834630:	10c001c5 	stb	r3,7(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 1834634:	e0bff98b 	ldhu	r2,-26(fp)
 1834638:	10800504 	addi	r2,r2,20
 183463c:	10bfc00c 	andi	r2,r2,65280
 1834640:	1005d23a 	srai	r2,r2,8
 1834644:	1007883a 	mov	r3,r2
 1834648:	e0bff98b 	ldhu	r2,-26(fp)
 183464c:	10800504 	addi	r2,r2,20
 1834650:	1004923a 	slli	r2,r2,8
 1834654:	1884b03a 	or	r2,r3,r2
 1834658:	100d883a 	mov	r6,r2
 183465c:	e0bff717 	ldw	r2,-36(fp)
 1834660:	30ffffcc 	andi	r3,r6,65535
 1834664:	19403fcc 	andi	r5,r3,255
 1834668:	10c00083 	ldbu	r3,2(r2)
 183466c:	1806703a 	and	r3,r3,zero
 1834670:	1809883a 	mov	r4,r3
 1834674:	2807883a 	mov	r3,r5
 1834678:	20c6b03a 	or	r3,r4,r3
 183467c:	10c00085 	stb	r3,2(r2)
 1834680:	30ffffcc 	andi	r3,r6,65535
 1834684:	1806d23a 	srli	r3,r3,8
 1834688:	197fffcc 	andi	r5,r3,65535
 183468c:	10c000c3 	ldbu	r3,3(r2)
 1834690:	1806703a 	and	r3,r3,zero
 1834694:	1809883a 	mov	r4,r3
 1834698:	2807883a 	mov	r3,r5
 183469c:	20c6b03a 	or	r3,r4,r3
 18346a0:	10c000c5 	stb	r3,3(r2)
    IPH_CHKSUM_SET(iphdr, 0);
 18346a4:	e0bff717 	ldw	r2,-36(fp)
 18346a8:	10c00283 	ldbu	r3,10(r2)
 18346ac:	1806703a 	and	r3,r3,zero
 18346b0:	10c00285 	stb	r3,10(r2)
 18346b4:	10c002c3 	ldbu	r3,11(r2)
 18346b8:	1806703a 	and	r3,r3,zero
 18346bc:	10c002c5 	stb	r3,11(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 18346c0:	01400504 	movi	r5,20
 18346c4:	e13ff717 	ldw	r4,-36(fp)
 18346c8:	18320980 	call	1832098 <inet_chksum>
 18346cc:	100d883a 	mov	r6,r2
 18346d0:	e0bff717 	ldw	r2,-36(fp)
 18346d4:	30ffffcc 	andi	r3,r6,65535
 18346d8:	19403fcc 	andi	r5,r3,255
 18346dc:	10c00283 	ldbu	r3,10(r2)
 18346e0:	1806703a 	and	r3,r3,zero
 18346e4:	1809883a 	mov	r4,r3
 18346e8:	2807883a 	mov	r3,r5
 18346ec:	20c6b03a 	or	r3,r4,r3
 18346f0:	10c00285 	stb	r3,10(r2)
 18346f4:	30ffffcc 	andi	r3,r6,65535
 18346f8:	1806d23a 	srli	r3,r3,8
 18346fc:	197fffcc 	andi	r5,r3,65535
 1834700:	10c002c3 	ldbu	r3,11(r2)
 1834704:	1806703a 	and	r3,r3,zero
 1834708:	1809883a 	mov	r4,r3
 183470c:	2807883a 	mov	r3,r5
 1834710:	20c6b03a 	or	r3,r4,r3
 1834714:	10c002c5 	stb	r3,11(r2)
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 1834718:	e0bffe17 	ldw	r2,-8(fp)
 183471c:	10800517 	ldw	r2,20(r2)
 1834720:	e1bfff17 	ldw	r6,-4(fp)
 1834724:	e17ffa17 	ldw	r5,-24(fp)
 1834728:	e13ffe17 	ldw	r4,-8(fp)
 183472c:	103ee83a 	callr	r2
    IPFRAG_STATS_INC(ip_frag.xmit);
 1834730:	008061f4 	movhi	r2,391
 1834734:	10a9d404 	addi	r2,r2,-22704
 1834738:	10801817 	ldw	r2,96(r2)
 183473c:	10c00044 	addi	r3,r2,1
 1834740:	008061f4 	movhi	r2,391
 1834744:	10a9d404 	addi	r2,r2,-22704
 1834748:	10c01815 	stw	r3,96(r2)
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 183474c:	e13ffa17 	ldw	r4,-24(fp)
 1834750:	181aca40 	call	181aca4 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 1834754:	e0fff20b 	ldhu	r3,-56(fp)
 1834758:	e0bff98b 	ldhu	r2,-26(fp)
 183475c:	1885c83a 	sub	r2,r3,r2
 1834760:	e0bff20d 	sth	r2,-56(fp)
    ofo += nfb;
 1834764:	e0fff28b 	ldhu	r3,-54(fp)
 1834768:	e0bff88b 	ldhu	r2,-30(fp)
 183476c:	1885883a 	add	r2,r3,r2
 1834770:	e0bff28d 	sth	r2,-54(fp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 1834774:	e0bff20b 	ldhu	r2,-56(fp)
 1834778:	103f171e 	bne	r2,zero,18343d8 <__ram_exceptions_end+0xff823f94>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 183477c:	0005883a 	mov	r2,zero
}
 1834780:	e037883a 	mov	sp,fp
 1834784:	dfc00117 	ldw	ra,4(sp)
 1834788:	df000017 	ldw	fp,0(sp)
 183478c:	dec00204 	addi	sp,sp,8
 1834790:	f800283a 	ret

01834794 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 1834794:	defffd04 	addi	sp,sp,-12
 1834798:	df000215 	stw	fp,8(sp)
 183479c:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 18347a0:	e03fff0d 	sth	zero,-4(fp)
 18347a4:	00002606 	br	1834840 <memp_init+0xac>
    MEMP_STATS_AVAIL(used, i, 0);
 18347a8:	e0ffff0b 	ldhu	r3,-4(fp)
 18347ac:	008061f4 	movhi	r2,391
 18347b0:	10a9d404 	addi	r2,r2,-22704
 18347b4:	18c00584 	addi	r3,r3,22
 18347b8:	1806913a 	slli	r3,r3,4
 18347bc:	10c5883a 	add	r2,r2,r3
 18347c0:	10800084 	addi	r2,r2,2
 18347c4:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
 18347c8:	e0ffff0b 	ldhu	r3,-4(fp)
 18347cc:	008061f4 	movhi	r2,391
 18347d0:	10a9d404 	addi	r2,r2,-22704
 18347d4:	1806913a 	slli	r3,r3,4
 18347d8:	10c5883a 	add	r2,r2,r3
 18347dc:	10805904 	addi	r2,r2,356
 18347e0:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
 18347e4:	e0ffff0b 	ldhu	r3,-4(fp)
 18347e8:	008061f4 	movhi	r2,391
 18347ec:	10a9d404 	addi	r2,r2,-22704
 18347f0:	1806913a 	slli	r3,r3,4
 18347f4:	10c5883a 	add	r2,r2,r3
 18347f8:	10805a04 	addi	r2,r2,360
 18347fc:	10000015 	stw	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 1834800:	e13fff0b 	ldhu	r4,-4(fp)
 1834804:	e0ffff0b 	ldhu	r3,-4(fp)
 1834808:	00806134 	movhi	r2,388
 183480c:	108e9e84 	addi	r2,r2,14970
 1834810:	18c7883a 	add	r3,r3,r3
 1834814:	10c5883a 	add	r2,r2,r3
 1834818:	10c0000b 	ldhu	r3,0(r2)
 183481c:	008061f4 	movhi	r2,391
 1834820:	10a9d404 	addi	r2,r2,-22704
 1834824:	21000584 	addi	r4,r4,22
 1834828:	2008913a 	slli	r4,r4,4
 183482c:	1105883a 	add	r2,r2,r4
 1834830:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 1834834:	e0bfff0b 	ldhu	r2,-4(fp)
 1834838:	10800044 	addi	r2,r2,1
 183483c:	e0bfff0d 	sth	r2,-4(fp)
 1834840:	e0bfff0b 	ldhu	r2,-4(fp)
 1834844:	108003f0 	cmpltui	r2,r2,15
 1834848:	103fd71e 	bne	r2,zero,18347a8 <__ram_exceptions_end+0xff824364>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 183484c:	00806174 	movhi	r2,389
 1834850:	10a14704 	addi	r2,r2,-31460
 1834854:	10c000c4 	addi	r3,r2,3
 1834858:	00bfff04 	movi	r2,-4
 183485c:	1884703a 	and	r2,r3,r2
 1834860:	e0bffe15 	stw	r2,-8(fp)
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 1834864:	e03fff0d 	sth	zero,-4(fp)
 1834868:	00003306 	br	1834938 <memp_init+0x1a4>
    memp_tab[i] = NULL;
 183486c:	e0ffff0b 	ldhu	r3,-4(fp)
 1834870:	00806174 	movhi	r2,389
 1834874:	10a13804 	addi	r2,r2,-31520
 1834878:	18c7883a 	add	r3,r3,r3
 183487c:	18c7883a 	add	r3,r3,r3
 1834880:	10c5883a 	add	r2,r2,r3
 1834884:	10000015 	stw	zero,0(r2)
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 1834888:	e03fff8d 	sth	zero,-2(fp)
 183488c:	00001e06 	br	1834908 <memp_init+0x174>
      memp->next = memp_tab[i];
 1834890:	e0ffff0b 	ldhu	r3,-4(fp)
 1834894:	00806174 	movhi	r2,389
 1834898:	10a13804 	addi	r2,r2,-31520
 183489c:	18c7883a 	add	r3,r3,r3
 18348a0:	18c7883a 	add	r3,r3,r3
 18348a4:	10c5883a 	add	r2,r2,r3
 18348a8:	10c00017 	ldw	r3,0(r2)
 18348ac:	e0bffe17 	ldw	r2,-8(fp)
 18348b0:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
 18348b4:	e0ffff0b 	ldhu	r3,-4(fp)
 18348b8:	00806174 	movhi	r2,389
 18348bc:	10a13804 	addi	r2,r2,-31520
 18348c0:	18c7883a 	add	r3,r3,r3
 18348c4:	18c7883a 	add	r3,r3,r3
 18348c8:	10c5883a 	add	r2,r2,r3
 18348cc:	e0fffe17 	ldw	r3,-8(fp)
 18348d0:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 18348d4:	e0ffff0b 	ldhu	r3,-4(fp)
 18348d8:	00806134 	movhi	r2,388
 18348dc:	108e9704 	addi	r2,r2,14940
 18348e0:	18c7883a 	add	r3,r3,r3
 18348e4:	10c5883a 	add	r2,r2,r3
 18348e8:	1080000b 	ldhu	r2,0(r2)
 18348ec:	10bfffcc 	andi	r2,r2,65535
 18348f0:	e0fffe17 	ldw	r3,-8(fp)
 18348f4:	1885883a 	add	r2,r3,r2
 18348f8:	e0bffe15 	stw	r2,-8(fp)
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 18348fc:	e0bfff8b 	ldhu	r2,-2(fp)
 1834900:	10800044 	addi	r2,r2,1
 1834904:	e0bfff8d 	sth	r2,-2(fp)
 1834908:	e0ffff0b 	ldhu	r3,-4(fp)
 183490c:	00806134 	movhi	r2,388
 1834910:	108e9e84 	addi	r2,r2,14970
 1834914:	18c7883a 	add	r3,r3,r3
 1834918:	10c5883a 	add	r2,r2,r3
 183491c:	1080000b 	ldhu	r2,0(r2)
 1834920:	10bfffcc 	andi	r2,r2,65535
 1834924:	e0ffff8b 	ldhu	r3,-2(fp)
 1834928:	18bfd936 	bltu	r3,r2,1834890 <__ram_exceptions_end+0xff82444c>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 183492c:	e0bfff0b 	ldhu	r2,-4(fp)
 1834930:	10800044 	addi	r2,r2,1
 1834934:	e0bfff0d 	sth	r2,-4(fp)
 1834938:	e0bfff0b 	ldhu	r2,-4(fp)
 183493c:	108003f0 	cmpltui	r2,r2,15
 1834940:	103fca1e 	bne	r2,zero,183486c <__ram_exceptions_end+0xff824428>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 1834944:	0001883a 	nop
 1834948:	e037883a 	mov	sp,fp
 183494c:	df000017 	ldw	fp,0(sp)
 1834950:	dec00104 	addi	sp,sp,4
 1834954:	f800283a 	ret

01834958 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 1834958:	defffc04 	addi	sp,sp,-16
 183495c:	dfc00315 	stw	ra,12(sp)
 1834960:	df000215 	stw	fp,8(sp)
 1834964:	df000204 	addi	fp,sp,8
 1834968:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 183496c:	e0bfff17 	ldw	r2,-4(fp)
 1834970:	108003f0 	cmpltui	r2,r2,15
 1834974:	1000091e 	bne	r2,zero,183499c <memp_malloc+0x44>
 1834978:	01c06134 	movhi	r7,388
 183497c:	39cea604 	addi	r7,r7,15000
 1834980:	01806384 	movi	r6,398
 1834984:	01406134 	movhi	r5,388
 1834988:	294eac04 	addi	r5,r5,15024
 183498c:	01006134 	movhi	r4,388
 1834990:	210eb404 	addi	r4,r4,15056
 1834994:	1800c180 	call	1800c18 <printf>
 1834998:	003fff06 	br	1834998 <__ram_exceptions_end+0xff824554>

  SYS_ARCH_PROTECT(old_level);
 183499c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18349a0:	10000126 	beq	r2,zero,18349a8 <memp_malloc+0x50>
 18349a4:	181103c0 	call	181103c <vTaskEnterCritical>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 18349a8:	00806174 	movhi	r2,389
 18349ac:	10a13804 	addi	r2,r2,-31520
 18349b0:	e0ffff17 	ldw	r3,-4(fp)
 18349b4:	18c7883a 	add	r3,r3,r3
 18349b8:	18c7883a 	add	r3,r3,r3
 18349bc:	10c5883a 	add	r2,r2,r3
 18349c0:	10800017 	ldw	r2,0(r2)
 18349c4:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
 18349c8:	e0bffe17 	ldw	r2,-8(fp)
 18349cc:	10003d26 	beq	r2,zero,1834ac4 <memp_malloc+0x16c>
    memp_tab[type] = memp->next;
 18349d0:	e0bffe17 	ldw	r2,-8(fp)
 18349d4:	11000017 	ldw	r4,0(r2)
 18349d8:	00806174 	movhi	r2,389
 18349dc:	10a13804 	addi	r2,r2,-31520
 18349e0:	e0ffff17 	ldw	r3,-4(fp)
 18349e4:	18c7883a 	add	r3,r3,r3
 18349e8:	18c7883a 	add	r3,r3,r3
 18349ec:	10c5883a 	add	r2,r2,r3
 18349f0:	11000015 	stw	r4,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 18349f4:	008061f4 	movhi	r2,391
 18349f8:	10a9d404 	addi	r2,r2,-22704
 18349fc:	e0ffff17 	ldw	r3,-4(fp)
 1834a00:	18c00584 	addi	r3,r3,22
 1834a04:	1806913a 	slli	r3,r3,4
 1834a08:	10c5883a 	add	r2,r2,r3
 1834a0c:	10800084 	addi	r2,r2,2
 1834a10:	1080000b 	ldhu	r2,0(r2)
 1834a14:	10800044 	addi	r2,r2,1
 1834a18:	1009883a 	mov	r4,r2
 1834a1c:	008061f4 	movhi	r2,391
 1834a20:	10a9d404 	addi	r2,r2,-22704
 1834a24:	e0ffff17 	ldw	r3,-4(fp)
 1834a28:	18c00584 	addi	r3,r3,22
 1834a2c:	1806913a 	slli	r3,r3,4
 1834a30:	10c5883a 	add	r2,r2,r3
 1834a34:	10800084 	addi	r2,r2,2
 1834a38:	1100000d 	sth	r4,0(r2)
 1834a3c:	008061f4 	movhi	r2,391
 1834a40:	10a9d404 	addi	r2,r2,-22704
 1834a44:	e0ffff17 	ldw	r3,-4(fp)
 1834a48:	1806913a 	slli	r3,r3,4
 1834a4c:	10c5883a 	add	r2,r2,r3
 1834a50:	10805904 	addi	r2,r2,356
 1834a54:	1100000b 	ldhu	r4,0(r2)
 1834a58:	008061f4 	movhi	r2,391
 1834a5c:	10a9d404 	addi	r2,r2,-22704
 1834a60:	e0ffff17 	ldw	r3,-4(fp)
 1834a64:	18c00584 	addi	r3,r3,22
 1834a68:	1806913a 	slli	r3,r3,4
 1834a6c:	10c5883a 	add	r2,r2,r3
 1834a70:	10800084 	addi	r2,r2,2
 1834a74:	1080000b 	ldhu	r2,0(r2)
 1834a78:	20ffffcc 	andi	r3,r4,65535
 1834a7c:	10bfffcc 	andi	r2,r2,65535
 1834a80:	18801f2e 	bgeu	r3,r2,1834b00 <memp_malloc+0x1a8>
 1834a84:	008061f4 	movhi	r2,391
 1834a88:	10a9d404 	addi	r2,r2,-22704
 1834a8c:	e0ffff17 	ldw	r3,-4(fp)
 1834a90:	18c00584 	addi	r3,r3,22
 1834a94:	1806913a 	slli	r3,r3,4
 1834a98:	10c5883a 	add	r2,r2,r3
 1834a9c:	10800084 	addi	r2,r2,2
 1834aa0:	10c0000b 	ldhu	r3,0(r2)
 1834aa4:	008061f4 	movhi	r2,391
 1834aa8:	10a9d404 	addi	r2,r2,-22704
 1834aac:	e13fff17 	ldw	r4,-4(fp)
 1834ab0:	2008913a 	slli	r4,r4,4
 1834ab4:	1105883a 	add	r2,r2,r4
 1834ab8:	10805904 	addi	r2,r2,356
 1834abc:	10c0000d 	sth	r3,0(r2)
 1834ac0:	00000f06 	br	1834b00 <memp_malloc+0x1a8>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
 1834ac4:	008061f4 	movhi	r2,391
 1834ac8:	10a9d404 	addi	r2,r2,-22704
 1834acc:	e0ffff17 	ldw	r3,-4(fp)
 1834ad0:	1806913a 	slli	r3,r3,4
 1834ad4:	10c5883a 	add	r2,r2,r3
 1834ad8:	10805a04 	addi	r2,r2,360
 1834adc:	10800017 	ldw	r2,0(r2)
 1834ae0:	10c00044 	addi	r3,r2,1
 1834ae4:	008061f4 	movhi	r2,391
 1834ae8:	10a9d404 	addi	r2,r2,-22704
 1834aec:	e13fff17 	ldw	r4,-4(fp)
 1834af0:	2008913a 	slli	r4,r4,4
 1834af4:	1105883a 	add	r2,r2,r4
 1834af8:	10805a04 	addi	r2,r2,360
 1834afc:	10c00015 	stw	r3,0(r2)
  }

  SYS_ARCH_UNPROTECT(old_level);
 1834b00:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1834b04:	10000126 	beq	r2,zero,1834b0c <memp_malloc+0x1b4>
 1834b08:	18110840 	call	1811084 <vTaskExitCritical>

  return memp;
 1834b0c:	e0bffe17 	ldw	r2,-8(fp)
}
 1834b10:	e037883a 	mov	sp,fp
 1834b14:	dfc00117 	ldw	ra,4(sp)
 1834b18:	df000017 	ldw	fp,0(sp)
 1834b1c:	dec00204 	addi	sp,sp,8
 1834b20:	f800283a 	ret

01834b24 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 1834b24:	defffb04 	addi	sp,sp,-20
 1834b28:	dfc00415 	stw	ra,16(sp)
 1834b2c:	df000315 	stw	fp,12(sp)
 1834b30:	df000304 	addi	fp,sp,12
 1834b34:	e13ffe15 	stw	r4,-8(fp)
 1834b38:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 1834b3c:	e0bfff17 	ldw	r2,-4(fp)
 1834b40:	10002c26 	beq	r2,zero,1834bf4 <memp_free+0xd0>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
 1834b44:	e0bfff17 	ldw	r2,-4(fp)
 1834b48:	e0bffd15 	stw	r2,-12(fp)

  SYS_ARCH_PROTECT(old_level);
 1834b4c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1834b50:	10000126 	beq	r2,zero,1834b58 <memp_free+0x34>
 1834b54:	181103c0 	call	181103c <vTaskEnterCritical>
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 1834b58:	008061f4 	movhi	r2,391
 1834b5c:	10a9d404 	addi	r2,r2,-22704
 1834b60:	e0fffe17 	ldw	r3,-8(fp)
 1834b64:	18c00584 	addi	r3,r3,22
 1834b68:	1806913a 	slli	r3,r3,4
 1834b6c:	10c5883a 	add	r2,r2,r3
 1834b70:	10800084 	addi	r2,r2,2
 1834b74:	1080000b 	ldhu	r2,0(r2)
 1834b78:	10bfffc4 	addi	r2,r2,-1
 1834b7c:	1009883a 	mov	r4,r2
 1834b80:	008061f4 	movhi	r2,391
 1834b84:	10a9d404 	addi	r2,r2,-22704
 1834b88:	e0fffe17 	ldw	r3,-8(fp)
 1834b8c:	18c00584 	addi	r3,r3,22
 1834b90:	1806913a 	slli	r3,r3,4
 1834b94:	10c5883a 	add	r2,r2,r3
 1834b98:	10800084 	addi	r2,r2,2
 1834b9c:	1100000d 	sth	r4,0(r2)
  
  memp->next = memp_tab[type]; 
 1834ba0:	00806174 	movhi	r2,389
 1834ba4:	10a13804 	addi	r2,r2,-31520
 1834ba8:	e0fffe17 	ldw	r3,-8(fp)
 1834bac:	18c7883a 	add	r3,r3,r3
 1834bb0:	18c7883a 	add	r3,r3,r3
 1834bb4:	10c5883a 	add	r2,r2,r3
 1834bb8:	10c00017 	ldw	r3,0(r2)
 1834bbc:	e0bffd17 	ldw	r2,-12(fp)
 1834bc0:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
 1834bc4:	00806174 	movhi	r2,389
 1834bc8:	10a13804 	addi	r2,r2,-31520
 1834bcc:	e0fffe17 	ldw	r3,-8(fp)
 1834bd0:	18c7883a 	add	r3,r3,r3
 1834bd4:	18c7883a 	add	r3,r3,r3
 1834bd8:	10c5883a 	add	r2,r2,r3
 1834bdc:	e0fffd17 	ldw	r3,-12(fp)
 1834be0:	10c00015 	stw	r3,0(r2)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 1834be4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1834be8:	10000326 	beq	r2,zero,1834bf8 <memp_free+0xd4>
 1834bec:	18110840 	call	1811084 <vTaskExitCritical>
 1834bf0:	00000106 	br	1834bf8 <memp_free+0xd4>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
 1834bf4:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 1834bf8:	e037883a 	mov	sp,fp
 1834bfc:	dfc00117 	ldw	ra,4(sp)
 1834c00:	df000017 	ldw	fp,0(sp)
 1834c04:	dec00204 	addi	sp,sp,8
 1834c08:	f800283a 	ret

01834c0c <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 1834c0c:	defff704 	addi	sp,sp,-36
 1834c10:	dfc00815 	stw	ra,32(sp)
 1834c14:	df000715 	stw	fp,28(sp)
 1834c18:	df000704 	addi	fp,sp,28
 1834c1c:	e13ffe15 	stw	r4,-8(fp)
 1834c20:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
 1834c24:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
 1834c28:	e0bffe17 	ldw	r2,-8(fp)
 1834c2c:	10800117 	ldw	r2,4(r2)
 1834c30:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
 1834c34:	e0bffc17 	ldw	r2,-16(fp)
 1834c38:	10800243 	ldbu	r2,9(r2)
 1834c3c:	10803fcc 	andi	r2,r2,255
 1834c40:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
 1834c44:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
 1834c48:	d0a81817 	ldw	r2,-24480(gp)
 1834c4c:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 1834c50:	00002f06 	br	1834d10 <raw_input+0x104>
    if ((pcb->protocol == proto) &&
 1834c54:	e0bff917 	ldw	r2,-28(fp)
 1834c58:	10800403 	ldbu	r2,16(r2)
 1834c5c:	10c03fcc 	andi	r3,r2,255
 1834c60:	e0bffd0f 	ldh	r2,-12(fp)
 1834c64:	1880251e 	bne	r3,r2,1834cfc <raw_input+0xf0>
        (ip_addr_isany(&pcb->local_ip) ||
 1834c68:	e0bff917 	ldw	r2,-28(fp)
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
 1834c6c:	10000726 	beq	r2,zero,1834c8c <raw_input+0x80>
        (ip_addr_isany(&pcb->local_ip) ||
 1834c70:	e0bff917 	ldw	r2,-28(fp)
 1834c74:	10800017 	ldw	r2,0(r2)
 1834c78:	10000426 	beq	r2,zero,1834c8c <raw_input+0x80>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 1834c7c:	e0bff917 	ldw	r2,-28(fp)
 1834c80:	10c00017 	ldw	r3,0(r2)
 1834c84:	d0a81417 	ldw	r2,-24496(gp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
 1834c88:	18801c1e 	bne	r3,r2,1834cfc <raw_input+0xf0>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 1834c8c:	e0bff917 	ldw	r2,-28(fp)
 1834c90:	10800517 	ldw	r2,20(r2)
 1834c94:	10001926 	beq	r2,zero,1834cfc <raw_input+0xf0>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 1834c98:	e0bff917 	ldw	r2,-28(fp)
 1834c9c:	10800517 	ldw	r2,20(r2)
 1834ca0:	e0fff917 	ldw	r3,-28(fp)
 1834ca4:	18c00617 	ldw	r3,24(r3)
 1834ca8:	d1e81204 	addi	r7,gp,-24504
 1834cac:	e1bffe17 	ldw	r6,-8(fp)
 1834cb0:	e17ff917 	ldw	r5,-28(fp)
 1834cb4:	1809883a 	mov	r4,r3
 1834cb8:	103ee83a 	callr	r2
 1834cbc:	10803fcc 	andi	r2,r2,255
 1834cc0:	10000e26 	beq	r2,zero,1834cfc <raw_input+0xf0>
            /* receive function ate the packet */
            p = NULL;
 1834cc4:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
 1834cc8:	00800044 	movi	r2,1
 1834ccc:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
 1834cd0:	e0bffa17 	ldw	r2,-24(fp)
 1834cd4:	10000926 	beq	r2,zero,1834cfc <raw_input+0xf0>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 1834cd8:	e0bff917 	ldw	r2,-28(fp)
 1834cdc:	10c00317 	ldw	r3,12(r2)
 1834ce0:	e0bffa17 	ldw	r2,-24(fp)
 1834ce4:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
 1834ce8:	d0e81817 	ldw	r3,-24480(gp)
 1834cec:	e0bff917 	ldw	r2,-28(fp)
 1834cf0:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
 1834cf4:	e0bff917 	ldw	r2,-28(fp)
 1834cf8:	d0a81815 	stw	r2,-24480(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
 1834cfc:	e0bff917 	ldw	r2,-28(fp)
 1834d00:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
 1834d04:	e0bff917 	ldw	r2,-28(fp)
 1834d08:	10800317 	ldw	r2,12(r2)
 1834d0c:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 1834d10:	e0bffb03 	ldbu	r2,-20(fp)
 1834d14:	1000021e 	bne	r2,zero,1834d20 <raw_input+0x114>
 1834d18:	e0bff917 	ldw	r2,-28(fp)
 1834d1c:	103fcd1e 	bne	r2,zero,1834c54 <__ram_exceptions_end+0xff824810>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
 1834d20:	e0bffb03 	ldbu	r2,-20(fp)
}
 1834d24:	e037883a 	mov	sp,fp
 1834d28:	dfc00117 	ldw	ra,4(sp)
 1834d2c:	df000017 	ldw	fp,0(sp)
 1834d30:	dec00204 	addi	sp,sp,8
 1834d34:	f800283a 	ret

01834d38 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
 1834d38:	defffd04 	addi	sp,sp,-12
 1834d3c:	df000215 	stw	fp,8(sp)
 1834d40:	df000204 	addi	fp,sp,8
 1834d44:	e13ffe15 	stw	r4,-8(fp)
 1834d48:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
 1834d4c:	e0bfff17 	ldw	r2,-4(fp)
 1834d50:	10000326 	beq	r2,zero,1834d60 <raw_bind+0x28>
 1834d54:	e0bfff17 	ldw	r2,-4(fp)
 1834d58:	10800017 	ldw	r2,0(r2)
 1834d5c:	00000106 	br	1834d64 <raw_bind+0x2c>
 1834d60:	0005883a 	mov	r2,zero
 1834d64:	e0fffe17 	ldw	r3,-8(fp)
 1834d68:	18800015 	stw	r2,0(r3)
  return ERR_OK;
 1834d6c:	0005883a 	mov	r2,zero
}
 1834d70:	e037883a 	mov	sp,fp
 1834d74:	df000017 	ldw	fp,0(sp)
 1834d78:	dec00104 	addi	sp,sp,4
 1834d7c:	f800283a 	ret

01834d80 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
 1834d80:	defffd04 	addi	sp,sp,-12
 1834d84:	df000215 	stw	fp,8(sp)
 1834d88:	df000204 	addi	fp,sp,8
 1834d8c:	e13ffe15 	stw	r4,-8(fp)
 1834d90:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
 1834d94:	e0bfff17 	ldw	r2,-4(fp)
 1834d98:	10000326 	beq	r2,zero,1834da8 <raw_connect+0x28>
 1834d9c:	e0bfff17 	ldw	r2,-4(fp)
 1834da0:	10800017 	ldw	r2,0(r2)
 1834da4:	00000106 	br	1834dac <raw_connect+0x2c>
 1834da8:	0005883a 	mov	r2,zero
 1834dac:	e0fffe17 	ldw	r3,-8(fp)
 1834db0:	18800115 	stw	r2,4(r3)
  return ERR_OK;
 1834db4:	0005883a 	mov	r2,zero
}
 1834db8:	e037883a 	mov	sp,fp
 1834dbc:	df000017 	ldw	fp,0(sp)
 1834dc0:	dec00104 	addi	sp,sp,4
 1834dc4:	f800283a 	ret

01834dc8 <raw_recv>:
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
 1834dc8:	defffc04 	addi	sp,sp,-16
 1834dcc:	df000315 	stw	fp,12(sp)
 1834dd0:	df000304 	addi	fp,sp,12
 1834dd4:	e13ffd15 	stw	r4,-12(fp)
 1834dd8:	e17ffe15 	stw	r5,-8(fp)
 1834ddc:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
 1834de0:	e0bffd17 	ldw	r2,-12(fp)
 1834de4:	e0fffe17 	ldw	r3,-8(fp)
 1834de8:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
 1834dec:	e0bffd17 	ldw	r2,-12(fp)
 1834df0:	e0ffff17 	ldw	r3,-4(fp)
 1834df4:	10c00615 	stw	r3,24(r2)
}
 1834df8:	0001883a 	nop
 1834dfc:	e037883a 	mov	sp,fp
 1834e00:	df000017 	ldw	fp,0(sp)
 1834e04:	dec00104 	addi	sp,sp,4
 1834e08:	f800283a 	ret

01834e0c <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
 1834e0c:	defff404 	addi	sp,sp,-48
 1834e10:	dfc00b15 	stw	ra,44(sp)
 1834e14:	df000a15 	stw	fp,40(sp)
 1834e18:	df000a04 	addi	fp,sp,40
 1834e1c:	e13ffd15 	stw	r4,-12(fp)
 1834e20:	e17ffe15 	stw	r5,-8(fp)
 1834e24:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 1834e28:	01400504 	movi	r5,20
 1834e2c:	e13ffe17 	ldw	r4,-8(fp)
 1834e30:	181aaf40 	call	181aaf4 <pbuf_header>
 1834e34:	10803fcc 	andi	r2,r2,255
 1834e38:	10001126 	beq	r2,zero,1834e80 <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 1834e3c:	000d883a 	mov	r6,zero
 1834e40:	000b883a 	mov	r5,zero
 1834e44:	01000044 	movi	r4,1
 1834e48:	181a4e80 	call	181a4e8 <pbuf_alloc>
 1834e4c:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 1834e50:	e0bffa17 	ldw	r2,-24(fp)
 1834e54:	1000021e 	bne	r2,zero,1834e60 <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 1834e58:	00bfffc4 	movi	r2,-1
 1834e5c:	00004806 	br	1834f80 <raw_sendto+0x174>
    }
    if (p->tot_len != 0) {
 1834e60:	e0bffe17 	ldw	r2,-8(fp)
 1834e64:	1080020b 	ldhu	r2,8(r2)
 1834e68:	10bfffcc 	andi	r2,r2,65535
 1834e6c:	10000d26 	beq	r2,zero,1834ea4 <raw_sendto+0x98>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
 1834e70:	e17ffe17 	ldw	r5,-8(fp)
 1834e74:	e13ffa17 	ldw	r4,-24(fp)
 1834e78:	181af6c0 	call	181af6c <pbuf_chain>
 1834e7c:	00000906 	br	1834ea4 <raw_sendto+0x98>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
 1834e80:	e0bffe17 	ldw	r2,-8(fp)
 1834e84:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
 1834e88:	017ffb04 	movi	r5,-20
 1834e8c:	e13ffa17 	ldw	r4,-24(fp)
 1834e90:	181aaf40 	call	181aaf4 <pbuf_header>
 1834e94:	10803fcc 	andi	r2,r2,255
 1834e98:	10000226 	beq	r2,zero,1834ea4 <raw_sendto+0x98>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
 1834e9c:	00bfffc4 	movi	r2,-1
 1834ea0:	00003706 	br	1834f80 <raw_sendto+0x174>
    }
  }

  if ((netif = ip_route((struct ip_pcb*)pcb, ipaddr)) == NULL) {
 1834ea4:	e17fff17 	ldw	r5,-4(fp)
 1834ea8:	e13ffd17 	ldw	r4,-12(fp)
 1834eac:	18322400 	call	1832240 <ip_route>
 1834eb0:	e0bffb15 	stw	r2,-20(fp)
 1834eb4:	e0bffb17 	ldw	r2,-20(fp)
 1834eb8:	1000071e 	bne	r2,zero,1834ed8 <raw_sendto+0xcc>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
 1834ebc:	e0fffa17 	ldw	r3,-24(fp)
 1834ec0:	e0bffe17 	ldw	r2,-8(fp)
 1834ec4:	18800226 	beq	r3,r2,1834ed0 <raw_sendto+0xc4>
      pbuf_free(q);
 1834ec8:	e13ffa17 	ldw	r4,-24(fp)
 1834ecc:	181aca40 	call	181aca4 <pbuf_free>
    }
    return ERR_RTE;
 1834ed0:	00bfff04 	movi	r2,-4
 1834ed4:	00002a06 	br	1834f80 <raw_sendto+0x174>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
 1834ed8:	e0bffd17 	ldw	r2,-12(fp)
 1834edc:	10000326 	beq	r2,zero,1834eec <raw_sendto+0xe0>
 1834ee0:	e0bffd17 	ldw	r2,-12(fp)
 1834ee4:	10800017 	ldw	r2,0(r2)
 1834ee8:	1000041e 	bne	r2,zero,1834efc <raw_sendto+0xf0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 1834eec:	e0bffb17 	ldw	r2,-20(fp)
 1834ef0:	10800104 	addi	r2,r2,4
 1834ef4:	e0bff915 	stw	r2,-28(fp)
 1834ef8:	00000206 	br	1834f04 <raw_sendto+0xf8>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 1834efc:	e0bffd17 	ldw	r2,-12(fp)
 1834f00:	e0bff915 	stw	r2,-28(fp)
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 1834f04:	e0bffd17 	ldw	r2,-12(fp)
 1834f08:	10c002c4 	addi	r3,r2,11
 1834f0c:	e0bffb17 	ldw	r2,-20(fp)
 1834f10:	10c01015 	stw	r3,64(r2)
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 1834f14:	e0bffd17 	ldw	r2,-12(fp)
 1834f18:	10800283 	ldbu	r2,10(r2)
 1834f1c:	11403fcc 	andi	r5,r2,255
 1834f20:	e0bffd17 	ldw	r2,-12(fp)
 1834f24:	10800243 	ldbu	r2,9(r2)
 1834f28:	10803fcc 	andi	r2,r2,255
 1834f2c:	e0fffd17 	ldw	r3,-12(fp)
 1834f30:	18c00403 	ldbu	r3,16(r3)
 1834f34:	18c03fcc 	andi	r3,r3,255
 1834f38:	e13ffb17 	ldw	r4,-20(fp)
 1834f3c:	d9000215 	stw	r4,8(sp)
 1834f40:	d8c00115 	stw	r3,4(sp)
 1834f44:	d8800015 	stw	r2,0(sp)
 1834f48:	280f883a 	mov	r7,r5
 1834f4c:	e1bfff17 	ldw	r6,-4(fp)
 1834f50:	e17ff917 	ldw	r5,-28(fp)
 1834f54:	e13ffa17 	ldw	r4,-24(fp)
 1834f58:	183286c0 	call	183286c <ip_output_if>
 1834f5c:	e0bffc05 	stb	r2,-16(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
 1834f60:	e0bffb17 	ldw	r2,-20(fp)
 1834f64:	10001015 	stw	zero,64(r2)

  /* did we chain a header earlier? */
  if (q != p) {
 1834f68:	e0fffa17 	ldw	r3,-24(fp)
 1834f6c:	e0bffe17 	ldw	r2,-8(fp)
 1834f70:	18800226 	beq	r3,r2,1834f7c <raw_sendto+0x170>
    /* free the header */
    pbuf_free(q);
 1834f74:	e13ffa17 	ldw	r4,-24(fp)
 1834f78:	181aca40 	call	181aca4 <pbuf_free>
  }
  return err;
 1834f7c:	e0bffc03 	ldbu	r2,-16(fp)
}
 1834f80:	e037883a 	mov	sp,fp
 1834f84:	dfc00117 	ldw	ra,4(sp)
 1834f88:	df000017 	ldw	fp,0(sp)
 1834f8c:	dec00204 	addi	sp,sp,8
 1834f90:	f800283a 	ret

01834f94 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
 1834f94:	defffc04 	addi	sp,sp,-16
 1834f98:	dfc00315 	stw	ra,12(sp)
 1834f9c:	df000215 	stw	fp,8(sp)
 1834fa0:	df000204 	addi	fp,sp,8
 1834fa4:	e13ffe15 	stw	r4,-8(fp)
 1834fa8:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
 1834fac:	e0bffe17 	ldw	r2,-8(fp)
 1834fb0:	10800104 	addi	r2,r2,4
 1834fb4:	100d883a 	mov	r6,r2
 1834fb8:	e17fff17 	ldw	r5,-4(fp)
 1834fbc:	e13ffe17 	ldw	r4,-8(fp)
 1834fc0:	1834e0c0 	call	1834e0c <raw_sendto>
}
 1834fc4:	e037883a 	mov	sp,fp
 1834fc8:	dfc00117 	ldw	ra,4(sp)
 1834fcc:	df000017 	ldw	fp,0(sp)
 1834fd0:	dec00204 	addi	sp,sp,8
 1834fd4:	f800283a 	ret

01834fd8 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 1834fd8:	defffc04 	addi	sp,sp,-16
 1834fdc:	dfc00315 	stw	ra,12(sp)
 1834fe0:	df000215 	stw	fp,8(sp)
 1834fe4:	df000204 	addi	fp,sp,8
 1834fe8:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 1834fec:	d0e81817 	ldw	r3,-24480(gp)
 1834ff0:	e0bfff17 	ldw	r2,-4(fp)
 1834ff4:	1880041e 	bne	r3,r2,1835008 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 1834ff8:	d0a81817 	ldw	r2,-24480(gp)
 1834ffc:	10800317 	ldw	r2,12(r2)
 1835000:	d0a81815 	stw	r2,-24480(gp)
 1835004:	00001306 	br	1835054 <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1835008:	d0a81817 	ldw	r2,-24480(gp)
 183500c:	e0bffe15 	stw	r2,-8(fp)
 1835010:	00000e06 	br	183504c <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 1835014:	e0bffe17 	ldw	r2,-8(fp)
 1835018:	10800317 	ldw	r2,12(r2)
 183501c:	10000826 	beq	r2,zero,1835040 <raw_remove+0x68>
 1835020:	e0bffe17 	ldw	r2,-8(fp)
 1835024:	10c00317 	ldw	r3,12(r2)
 1835028:	e0bfff17 	ldw	r2,-4(fp)
 183502c:	1880041e 	bne	r3,r2,1835040 <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 1835030:	e0bfff17 	ldw	r2,-4(fp)
 1835034:	10c00317 	ldw	r3,12(r2)
 1835038:	e0bffe17 	ldw	r2,-8(fp)
 183503c:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 1835040:	e0bffe17 	ldw	r2,-8(fp)
 1835044:	10800317 	ldw	r2,12(r2)
 1835048:	e0bffe15 	stw	r2,-8(fp)
 183504c:	e0bffe17 	ldw	r2,-8(fp)
 1835050:	103ff01e 	bne	r2,zero,1835014 <__ram_exceptions_end+0xff824bd0>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 1835054:	e17fff17 	ldw	r5,-4(fp)
 1835058:	0009883a 	mov	r4,zero
 183505c:	1834b240 	call	1834b24 <memp_free>
}
 1835060:	0001883a 	nop
 1835064:	e037883a 	mov	sp,fp
 1835068:	dfc00117 	ldw	ra,4(sp)
 183506c:	df000017 	ldw	fp,0(sp)
 1835070:	dec00204 	addi	sp,sp,8
 1835074:	f800283a 	ret

01835078 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 1835078:	defffc04 	addi	sp,sp,-16
 183507c:	dfc00315 	stw	ra,12(sp)
 1835080:	df000215 	stw	fp,8(sp)
 1835084:	df000204 	addi	fp,sp,8
 1835088:	2005883a 	mov	r2,r4
 183508c:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 1835090:	0009883a 	mov	r4,zero
 1835094:	18349580 	call	1834958 <memp_malloc>
 1835098:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 183509c:	e0bffe17 	ldw	r2,-8(fp)
 18350a0:	10000f26 	beq	r2,zero,18350e0 <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 18350a4:	01800704 	movi	r6,28
 18350a8:	000b883a 	mov	r5,zero
 18350ac:	e13ffe17 	ldw	r4,-8(fp)
 18350b0:	18061d40 	call	18061d4 <memset>
    pcb->protocol = proto;
 18350b4:	e0bffe17 	ldw	r2,-8(fp)
 18350b8:	e0ffff03 	ldbu	r3,-4(fp)
 18350bc:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
 18350c0:	e0bffe17 	ldw	r2,-8(fp)
 18350c4:	00c01004 	movi	r3,64
 18350c8:	10c00285 	stb	r3,10(r2)
    pcb->next = raw_pcbs;
 18350cc:	d0e81817 	ldw	r3,-24480(gp)
 18350d0:	e0bffe17 	ldw	r2,-8(fp)
 18350d4:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
 18350d8:	e0bffe17 	ldw	r2,-8(fp)
 18350dc:	d0a81815 	stw	r2,-24480(gp)
  }
  return pcb;
 18350e0:	e0bffe17 	ldw	r2,-8(fp)
}
 18350e4:	e037883a 	mov	sp,fp
 18350e8:	dfc00117 	ldw	ra,4(sp)
 18350ec:	df000017 	ldw	fp,0(sp)
 18350f0:	dec00204 	addi	sp,sp,8
 18350f4:	f800283a 	ret

018350f8 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
 18350f8:	defffb04 	addi	sp,sp,-20
 18350fc:	dfc00415 	stw	ra,16(sp)
 1835100:	df000315 	stw	fp,12(sp)
 1835104:	df000304 	addi	fp,sp,12
 1835108:	e13fff15 	stw	r4,-4(fp)
  if (ms > 0) {
 183510c:	e0bfff17 	ldw	r2,-4(fp)
 1835110:	10000e26 	beq	r2,zero,183514c <sys_msleep+0x54>
    sys_sem_t delaysem;
    err_t err = sys_sem_new(&delaysem, 0);
 1835114:	e0bffe04 	addi	r2,fp,-8
 1835118:	000b883a 	mov	r5,zero
 183511c:	1009883a 	mov	r4,r2
 1835120:	1814f380 	call	1814f38 <sys_sem_new>
 1835124:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 1835128:	e0bffd07 	ldb	r2,-12(fp)
 183512c:	1000071e 	bne	r2,zero,183514c <sys_msleep+0x54>
      sys_arch_sem_wait(&delaysem, ms);
 1835130:	e0bffe04 	addi	r2,fp,-8
 1835134:	e17fff17 	ldw	r5,-4(fp)
 1835138:	1009883a 	mov	r4,r2
 183513c:	18150bc0 	call	18150bc <sys_arch_sem_wait>
      sys_sem_free(&delaysem);
 1835140:	e0bffe04 	addi	r2,fp,-8
 1835144:	1009883a 	mov	r4,r2
 1835148:	181501c0 	call	181501c <sys_sem_free>
    }
  }
}
 183514c:	0001883a 	nop
 1835150:	e037883a 	mov	sp,fp
 1835154:	dfc00117 	ldw	ra,4(sp)
 1835158:	df000017 	ldw	fp,0(sp)
 183515c:	dec00204 	addi	sp,sp,8
 1835160:	f800283a 	ret

01835164 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 1835164:	defff404 	addi	sp,sp,-48
 1835168:	dfc00b15 	stw	ra,44(sp)
 183516c:	df000a15 	stw	fp,40(sp)
 1835170:	df000a04 	addi	fp,sp,40
 1835174:	e13ffe15 	stw	r4,-8(fp)
 1835178:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 183517c:	e03ffb15 	stw	zero,-20(fp)
  struct tcp_pcb_listen *lpcb_any = NULL;
 1835180:	e03ffc15 	stw	zero,-16(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 1835184:	008061f4 	movhi	r2,391
 1835188:	10a9d404 	addi	r2,r2,-22704
 183518c:	10804917 	ldw	r2,292(r2)
 1835190:	10c00044 	addi	r3,r2,1
 1835194:	008061f4 	movhi	r2,391
 1835198:	10a9d404 	addi	r2,r2,-22704
 183519c:	10c04915 	stw	r3,292(r2)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 18351a0:	e0bffe17 	ldw	r2,-8(fp)
 18351a4:	10800117 	ldw	r2,4(r2)
 18351a8:	d0a81a15 	stw	r2,-24472(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 18351ac:	e0bffe17 	ldw	r2,-8(fp)
 18351b0:	10c00117 	ldw	r3,4(r2)
 18351b4:	d0a81a17 	ldw	r2,-24472(gp)
 18351b8:	10800003 	ldbu	r2,0(r2)
 18351bc:	10803fcc 	andi	r2,r2,255
 18351c0:	108003cc 	andi	r2,r2,15
 18351c4:	1085883a 	add	r2,r2,r2
 18351c8:	1085883a 	add	r2,r2,r2
 18351cc:	1885883a 	add	r2,r3,r2
 18351d0:	d0a81915 	stw	r2,-24476(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 18351d4:	d0a81a17 	ldw	r2,-24472(gp)
 18351d8:	10800003 	ldbu	r2,0(r2)
 18351dc:	10803fcc 	andi	r2,r2,255
 18351e0:	108003cc 	andi	r2,r2,15
 18351e4:	1085883a 	add	r2,r2,r2
 18351e8:	1085883a 	add	r2,r2,r2
 18351ec:	0085c83a 	sub	r2,zero,r2
 18351f0:	10bfffcc 	andi	r2,r2,65535
 18351f4:	10a0001c 	xori	r2,r2,32768
 18351f8:	10a00004 	addi	r2,r2,-32768
 18351fc:	100b883a 	mov	r5,r2
 1835200:	e13ffe17 	ldw	r4,-8(fp)
 1835204:	181aaf40 	call	181aaf4 <pbuf_header>
 1835208:	10803fcc 	andi	r2,r2,255
 183520c:	1000051e 	bne	r2,zero,1835224 <tcp_input+0xc0>
 1835210:	e0bffe17 	ldw	r2,-8(fp)
 1835214:	1080020b 	ldhu	r2,8(r2)
 1835218:	10bfffcc 	andi	r2,r2,65535
 183521c:	10800528 	cmpgeui	r2,r2,20
 1835220:	1000081e 	bne	r2,zero,1835244 <tcp_input+0xe0>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
 1835224:	008061f4 	movhi	r2,391
 1835228:	10a9d404 	addi	r2,r2,-22704
 183522c:	10804d17 	ldw	r2,308(r2)
 1835230:	10c00044 	addi	r3,r2,1
 1835234:	008061f4 	movhi	r2,391
 1835238:	10a9d404 	addi	r2,r2,-22704
 183523c:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 1835240:	00035706 	br	1835fa0 <tcp_input+0xe3c>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 1835244:	d0a81417 	ldw	r2,-24496(gp)
 1835248:	e17fff17 	ldw	r5,-4(fp)
 183524c:	1009883a 	mov	r4,r2
 1835250:	1818a600 	call	1818a60 <ip4_addr_isbroadcast>
 1835254:	10803fcc 	andi	r2,r2,255
 1835258:	1000041e 	bne	r2,zero,183526c <tcp_input+0x108>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 183525c:	d0a81417 	ldw	r2,-24496(gp)
 1835260:	10803c0c 	andi	r2,r2,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 1835264:	10803818 	cmpnei	r2,r2,224
 1835268:	1000081e 	bne	r2,zero,183528c <tcp_input+0x128>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
 183526c:	008061f4 	movhi	r2,391
 1835270:	10a9d404 	addi	r2,r2,-22704
 1835274:	10805017 	ldw	r2,320(r2)
 1835278:	10c00044 	addi	r3,r2,1
 183527c:	008061f4 	movhi	r2,391
 1835280:	10a9d404 	addi	r2,r2,-22704
 1835284:	10c05015 	stw	r3,320(r2)
    goto dropped;
 1835288:	00034506 	br	1835fa0 <tcp_input+0xe3c>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len) != 0) {
 183528c:	e0bffe17 	ldw	r2,-8(fp)
 1835290:	1080020b 	ldhu	r2,8(r2)
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 1835294:	10bfffcc 	andi	r2,r2,65535
 1835298:	d8800015 	stw	r2,0(sp)
 183529c:	01c00184 	movi	r7,6
 18352a0:	d1a81404 	addi	r6,gp,-24496
 18352a4:	d1681204 	addi	r5,gp,-24504
 18352a8:	e13ffe17 	ldw	r4,-8(fp)
 18352ac:	1831c600 	call	1831c60 <inet_chksum_pseudo>
 18352b0:	10bfffcc 	andi	r2,r2,65535
 18352b4:	10000826 	beq	r2,zero,18352d8 <tcp_input+0x174>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
 18352b8:	008061f4 	movhi	r2,391
 18352bc:	10a9d404 	addi	r2,r2,-22704
 18352c0:	10804c17 	ldw	r2,304(r2)
 18352c4:	10c00044 	addi	r3,r2,1
 18352c8:	008061f4 	movhi	r2,391
 18352cc:	10a9d404 	addi	r2,r2,-22704
 18352d0:	10c04c15 	stw	r3,304(r2)
    goto dropped;
 18352d4:	00033206 	br	1835fa0 <tcp_input+0xe3c>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 18352d8:	d0a81917 	ldw	r2,-24476(gp)
 18352dc:	10c00303 	ldbu	r3,12(r2)
 18352e0:	10800343 	ldbu	r2,13(r2)
 18352e4:	1004923a 	slli	r2,r2,8
 18352e8:	10c4b03a 	or	r2,r2,r3
 18352ec:	10bfffcc 	andi	r2,r2,65535
 18352f0:	1004d23a 	srli	r2,r2,8
 18352f4:	10ffffcc 	andi	r3,r2,65535
 18352f8:	d0a81917 	ldw	r2,-24476(gp)
 18352fc:	11000303 	ldbu	r4,12(r2)
 1835300:	10800343 	ldbu	r2,13(r2)
 1835304:	1004923a 	slli	r2,r2,8
 1835308:	1104b03a 	or	r2,r2,r4
 183530c:	10bfffcc 	andi	r2,r2,65535
 1835310:	1004923a 	slli	r2,r2,8
 1835314:	10bfffcc 	andi	r2,r2,65535
 1835318:	1884b03a 	or	r2,r3,r2
 183531c:	1005d33a 	srai	r2,r2,12
 1835320:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
 1835324:	e0bffd43 	ldbu	r2,-11(fp)
 1835328:	10bfff24 	muli	r2,r2,-4
 183532c:	10bfffcc 	andi	r2,r2,65535
 1835330:	10a0001c 	xori	r2,r2,32768
 1835334:	10a00004 	addi	r2,r2,-32768
 1835338:	100b883a 	mov	r5,r2
 183533c:	e13ffe17 	ldw	r4,-8(fp)
 1835340:	181aaf40 	call	181aaf4 <pbuf_header>
 1835344:	10803fcc 	andi	r2,r2,255
 1835348:	10000826 	beq	r2,zero,183536c <tcp_input+0x208>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
 183534c:	008061f4 	movhi	r2,391
 1835350:	10a9d404 	addi	r2,r2,-22704
 1835354:	10804d17 	ldw	r2,308(r2)
 1835358:	10c00044 	addi	r3,r2,1
 183535c:	008061f4 	movhi	r2,391
 1835360:	10a9d404 	addi	r2,r2,-22704
 1835364:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 1835368:	00030d06 	br	1835fa0 <tcp_input+0xe3c>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 183536c:	d0a81917 	ldw	r2,-24476(gp)
 1835370:	d0e81917 	ldw	r3,-24476(gp)
 1835374:	19000003 	ldbu	r4,0(r3)
 1835378:	18c00043 	ldbu	r3,1(r3)
 183537c:	1806923a 	slli	r3,r3,8
 1835380:	1906b03a 	or	r3,r3,r4
 1835384:	18ffffcc 	andi	r3,r3,65535
 1835388:	1806d23a 	srli	r3,r3,8
 183538c:	180b883a 	mov	r5,r3
 1835390:	d0e81917 	ldw	r3,-24476(gp)
 1835394:	19000003 	ldbu	r4,0(r3)
 1835398:	18c00043 	ldbu	r3,1(r3)
 183539c:	1806923a 	slli	r3,r3,8
 18353a0:	1906b03a 	or	r3,r3,r4
 18353a4:	18ffffcc 	andi	r3,r3,65535
 18353a8:	1806923a 	slli	r3,r3,8
 18353ac:	28c6b03a 	or	r3,r5,r3
 18353b0:	180d883a 	mov	r6,r3
 18353b4:	30ffffcc 	andi	r3,r6,65535
 18353b8:	19403fcc 	andi	r5,r3,255
 18353bc:	10c00003 	ldbu	r3,0(r2)
 18353c0:	1806703a 	and	r3,r3,zero
 18353c4:	1809883a 	mov	r4,r3
 18353c8:	2807883a 	mov	r3,r5
 18353cc:	20c6b03a 	or	r3,r4,r3
 18353d0:	10c00005 	stb	r3,0(r2)
 18353d4:	30ffffcc 	andi	r3,r6,65535
 18353d8:	1806d23a 	srli	r3,r3,8
 18353dc:	197fffcc 	andi	r5,r3,65535
 18353e0:	10c00043 	ldbu	r3,1(r2)
 18353e4:	1806703a 	and	r3,r3,zero
 18353e8:	1809883a 	mov	r4,r3
 18353ec:	2807883a 	mov	r3,r5
 18353f0:	20c6b03a 	or	r3,r4,r3
 18353f4:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
 18353f8:	d0a81917 	ldw	r2,-24476(gp)
 18353fc:	d0e81917 	ldw	r3,-24476(gp)
 1835400:	19000083 	ldbu	r4,2(r3)
 1835404:	18c000c3 	ldbu	r3,3(r3)
 1835408:	1806923a 	slli	r3,r3,8
 183540c:	1906b03a 	or	r3,r3,r4
 1835410:	18ffffcc 	andi	r3,r3,65535
 1835414:	1806d23a 	srli	r3,r3,8
 1835418:	180b883a 	mov	r5,r3
 183541c:	d0e81917 	ldw	r3,-24476(gp)
 1835420:	19000083 	ldbu	r4,2(r3)
 1835424:	18c000c3 	ldbu	r3,3(r3)
 1835428:	1806923a 	slli	r3,r3,8
 183542c:	1906b03a 	or	r3,r3,r4
 1835430:	18ffffcc 	andi	r3,r3,65535
 1835434:	1806923a 	slli	r3,r3,8
 1835438:	28c6b03a 	or	r3,r5,r3
 183543c:	180d883a 	mov	r6,r3
 1835440:	30ffffcc 	andi	r3,r6,65535
 1835444:	19403fcc 	andi	r5,r3,255
 1835448:	10c00083 	ldbu	r3,2(r2)
 183544c:	1806703a 	and	r3,r3,zero
 1835450:	1809883a 	mov	r4,r3
 1835454:	2807883a 	mov	r3,r5
 1835458:	20c6b03a 	or	r3,r4,r3
 183545c:	10c00085 	stb	r3,2(r2)
 1835460:	30ffffcc 	andi	r3,r6,65535
 1835464:	1806d23a 	srli	r3,r3,8
 1835468:	197fffcc 	andi	r5,r3,65535
 183546c:	10c000c3 	ldbu	r3,3(r2)
 1835470:	1806703a 	and	r3,r3,zero
 1835474:	1809883a 	mov	r4,r3
 1835478:	2807883a 	mov	r3,r5
 183547c:	20c6b03a 	or	r3,r4,r3
 1835480:	10c000c5 	stb	r3,3(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 1835484:	d0a81917 	ldw	r2,-24476(gp)
 1835488:	d0e81917 	ldw	r3,-24476(gp)
 183548c:	19000103 	ldbu	r4,4(r3)
 1835490:	19400143 	ldbu	r5,5(r3)
 1835494:	280a923a 	slli	r5,r5,8
 1835498:	2908b03a 	or	r4,r5,r4
 183549c:	19400183 	ldbu	r5,6(r3)
 18354a0:	280a943a 	slli	r5,r5,16
 18354a4:	2908b03a 	or	r4,r5,r4
 18354a8:	18c001c3 	ldbu	r3,7(r3)
 18354ac:	1806963a 	slli	r3,r3,24
 18354b0:	1906b03a 	or	r3,r3,r4
 18354b4:	1808d63a 	srli	r4,r3,24
 18354b8:	d0e81917 	ldw	r3,-24476(gp)
 18354bc:	19400103 	ldbu	r5,4(r3)
 18354c0:	19800143 	ldbu	r6,5(r3)
 18354c4:	300c923a 	slli	r6,r6,8
 18354c8:	314ab03a 	or	r5,r6,r5
 18354cc:	19800183 	ldbu	r6,6(r3)
 18354d0:	300c943a 	slli	r6,r6,16
 18354d4:	314ab03a 	or	r5,r6,r5
 18354d8:	18c001c3 	ldbu	r3,7(r3)
 18354dc:	1806963a 	slli	r3,r3,24
 18354e0:	1946b03a 	or	r3,r3,r5
 18354e4:	1806d23a 	srli	r3,r3,8
 18354e8:	18ffc00c 	andi	r3,r3,65280
 18354ec:	20c8b03a 	or	r4,r4,r3
 18354f0:	d0e81917 	ldw	r3,-24476(gp)
 18354f4:	19400103 	ldbu	r5,4(r3)
 18354f8:	19800143 	ldbu	r6,5(r3)
 18354fc:	300c923a 	slli	r6,r6,8
 1835500:	314ab03a 	or	r5,r6,r5
 1835504:	19800183 	ldbu	r6,6(r3)
 1835508:	300c943a 	slli	r6,r6,16
 183550c:	314ab03a 	or	r5,r6,r5
 1835510:	18c001c3 	ldbu	r3,7(r3)
 1835514:	1806963a 	slli	r3,r3,24
 1835518:	1946b03a 	or	r3,r3,r5
 183551c:	18ffc00c 	andi	r3,r3,65280
 1835520:	1806923a 	slli	r3,r3,8
 1835524:	20c8b03a 	or	r4,r4,r3
 1835528:	d0e81917 	ldw	r3,-24476(gp)
 183552c:	19400103 	ldbu	r5,4(r3)
 1835530:	19800143 	ldbu	r6,5(r3)
 1835534:	300c923a 	slli	r6,r6,8
 1835538:	314ab03a 	or	r5,r6,r5
 183553c:	19800183 	ldbu	r6,6(r3)
 1835540:	300c943a 	slli	r6,r6,16
 1835544:	314ab03a 	or	r5,r6,r5
 1835548:	18c001c3 	ldbu	r3,7(r3)
 183554c:	1806963a 	slli	r3,r3,24
 1835550:	1946b03a 	or	r3,r3,r5
 1835554:	1806963a 	slli	r3,r3,24
 1835558:	20c6b03a 	or	r3,r4,r3
 183555c:	19803fcc 	andi	r6,r3,255
 1835560:	11000103 	ldbu	r4,4(r2)
 1835564:	2008703a 	and	r4,r4,zero
 1835568:	200b883a 	mov	r5,r4
 183556c:	3009883a 	mov	r4,r6
 1835570:	2908b03a 	or	r4,r5,r4
 1835574:	11000105 	stb	r4,4(r2)
 1835578:	1808d23a 	srli	r4,r3,8
 183557c:	21803fcc 	andi	r6,r4,255
 1835580:	11000143 	ldbu	r4,5(r2)
 1835584:	2008703a 	and	r4,r4,zero
 1835588:	200b883a 	mov	r5,r4
 183558c:	3009883a 	mov	r4,r6
 1835590:	2908b03a 	or	r4,r5,r4
 1835594:	11000145 	stb	r4,5(r2)
 1835598:	1808d43a 	srli	r4,r3,16
 183559c:	21803fcc 	andi	r6,r4,255
 18355a0:	11000183 	ldbu	r4,6(r2)
 18355a4:	2008703a 	and	r4,r4,zero
 18355a8:	200b883a 	mov	r5,r4
 18355ac:	3009883a 	mov	r4,r6
 18355b0:	2908b03a 	or	r4,r5,r4
 18355b4:	11000185 	stb	r4,6(r2)
 18355b8:	180ad63a 	srli	r5,r3,24
 18355bc:	10c001c3 	ldbu	r3,7(r2)
 18355c0:	1806703a 	and	r3,r3,zero
 18355c4:	1809883a 	mov	r4,r3
 18355c8:	2807883a 	mov	r3,r5
 18355cc:	20c6b03a 	or	r3,r4,r3
 18355d0:	10c001c5 	stb	r3,7(r2)
 18355d4:	10c00103 	ldbu	r3,4(r2)
 18355d8:	11000143 	ldbu	r4,5(r2)
 18355dc:	2008923a 	slli	r4,r4,8
 18355e0:	20c6b03a 	or	r3,r4,r3
 18355e4:	11000183 	ldbu	r4,6(r2)
 18355e8:	2008943a 	slli	r4,r4,16
 18355ec:	20c6b03a 	or	r3,r4,r3
 18355f0:	108001c3 	ldbu	r2,7(r2)
 18355f4:	1004963a 	slli	r2,r2,24
 18355f8:	10c4b03a 	or	r2,r2,r3
 18355fc:	d0a81b15 	stw	r2,-24468(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 1835600:	d0a81917 	ldw	r2,-24476(gp)
 1835604:	d0e81917 	ldw	r3,-24476(gp)
 1835608:	19000203 	ldbu	r4,8(r3)
 183560c:	19400243 	ldbu	r5,9(r3)
 1835610:	280a923a 	slli	r5,r5,8
 1835614:	2908b03a 	or	r4,r5,r4
 1835618:	19400283 	ldbu	r5,10(r3)
 183561c:	280a943a 	slli	r5,r5,16
 1835620:	2908b03a 	or	r4,r5,r4
 1835624:	18c002c3 	ldbu	r3,11(r3)
 1835628:	1806963a 	slli	r3,r3,24
 183562c:	1906b03a 	or	r3,r3,r4
 1835630:	1808d63a 	srli	r4,r3,24
 1835634:	d0e81917 	ldw	r3,-24476(gp)
 1835638:	19400203 	ldbu	r5,8(r3)
 183563c:	19800243 	ldbu	r6,9(r3)
 1835640:	300c923a 	slli	r6,r6,8
 1835644:	314ab03a 	or	r5,r6,r5
 1835648:	19800283 	ldbu	r6,10(r3)
 183564c:	300c943a 	slli	r6,r6,16
 1835650:	314ab03a 	or	r5,r6,r5
 1835654:	18c002c3 	ldbu	r3,11(r3)
 1835658:	1806963a 	slli	r3,r3,24
 183565c:	1946b03a 	or	r3,r3,r5
 1835660:	1806d23a 	srli	r3,r3,8
 1835664:	18ffc00c 	andi	r3,r3,65280
 1835668:	20c8b03a 	or	r4,r4,r3
 183566c:	d0e81917 	ldw	r3,-24476(gp)
 1835670:	19400203 	ldbu	r5,8(r3)
 1835674:	19800243 	ldbu	r6,9(r3)
 1835678:	300c923a 	slli	r6,r6,8
 183567c:	314ab03a 	or	r5,r6,r5
 1835680:	19800283 	ldbu	r6,10(r3)
 1835684:	300c943a 	slli	r6,r6,16
 1835688:	314ab03a 	or	r5,r6,r5
 183568c:	18c002c3 	ldbu	r3,11(r3)
 1835690:	1806963a 	slli	r3,r3,24
 1835694:	1946b03a 	or	r3,r3,r5
 1835698:	18ffc00c 	andi	r3,r3,65280
 183569c:	1806923a 	slli	r3,r3,8
 18356a0:	20c8b03a 	or	r4,r4,r3
 18356a4:	d0e81917 	ldw	r3,-24476(gp)
 18356a8:	19400203 	ldbu	r5,8(r3)
 18356ac:	19800243 	ldbu	r6,9(r3)
 18356b0:	300c923a 	slli	r6,r6,8
 18356b4:	314ab03a 	or	r5,r6,r5
 18356b8:	19800283 	ldbu	r6,10(r3)
 18356bc:	300c943a 	slli	r6,r6,16
 18356c0:	314ab03a 	or	r5,r6,r5
 18356c4:	18c002c3 	ldbu	r3,11(r3)
 18356c8:	1806963a 	slli	r3,r3,24
 18356cc:	1946b03a 	or	r3,r3,r5
 18356d0:	1806963a 	slli	r3,r3,24
 18356d4:	20c6b03a 	or	r3,r4,r3
 18356d8:	19803fcc 	andi	r6,r3,255
 18356dc:	11000203 	ldbu	r4,8(r2)
 18356e0:	2008703a 	and	r4,r4,zero
 18356e4:	200b883a 	mov	r5,r4
 18356e8:	3009883a 	mov	r4,r6
 18356ec:	2908b03a 	or	r4,r5,r4
 18356f0:	11000205 	stb	r4,8(r2)
 18356f4:	1808d23a 	srli	r4,r3,8
 18356f8:	21803fcc 	andi	r6,r4,255
 18356fc:	11000243 	ldbu	r4,9(r2)
 1835700:	2008703a 	and	r4,r4,zero
 1835704:	200b883a 	mov	r5,r4
 1835708:	3009883a 	mov	r4,r6
 183570c:	2908b03a 	or	r4,r5,r4
 1835710:	11000245 	stb	r4,9(r2)
 1835714:	1808d43a 	srli	r4,r3,16
 1835718:	21803fcc 	andi	r6,r4,255
 183571c:	11000283 	ldbu	r4,10(r2)
 1835720:	2008703a 	and	r4,r4,zero
 1835724:	200b883a 	mov	r5,r4
 1835728:	3009883a 	mov	r4,r6
 183572c:	2908b03a 	or	r4,r5,r4
 1835730:	11000285 	stb	r4,10(r2)
 1835734:	180ad63a 	srli	r5,r3,24
 1835738:	10c002c3 	ldbu	r3,11(r2)
 183573c:	1806703a 	and	r3,r3,zero
 1835740:	1809883a 	mov	r4,r3
 1835744:	2807883a 	mov	r3,r5
 1835748:	20c6b03a 	or	r3,r4,r3
 183574c:	10c002c5 	stb	r3,11(r2)
 1835750:	10c00203 	ldbu	r3,8(r2)
 1835754:	11000243 	ldbu	r4,9(r2)
 1835758:	2008923a 	slli	r4,r4,8
 183575c:	20c6b03a 	or	r3,r4,r3
 1835760:	11000283 	ldbu	r4,10(r2)
 1835764:	2008943a 	slli	r4,r4,16
 1835768:	20c6b03a 	or	r3,r4,r3
 183576c:	108002c3 	ldbu	r2,11(r2)
 1835770:	1004963a 	slli	r2,r2,24
 1835774:	10c4b03a 	or	r2,r2,r3
 1835778:	d0a81c15 	stw	r2,-24464(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
 183577c:	d0a81917 	ldw	r2,-24476(gp)
 1835780:	d0e81917 	ldw	r3,-24476(gp)
 1835784:	19000383 	ldbu	r4,14(r3)
 1835788:	18c003c3 	ldbu	r3,15(r3)
 183578c:	1806923a 	slli	r3,r3,8
 1835790:	1906b03a 	or	r3,r3,r4
 1835794:	18ffffcc 	andi	r3,r3,65535
 1835798:	1806d23a 	srli	r3,r3,8
 183579c:	180b883a 	mov	r5,r3
 18357a0:	d0e81917 	ldw	r3,-24476(gp)
 18357a4:	19000383 	ldbu	r4,14(r3)
 18357a8:	18c003c3 	ldbu	r3,15(r3)
 18357ac:	1806923a 	slli	r3,r3,8
 18357b0:	1906b03a 	or	r3,r3,r4
 18357b4:	18ffffcc 	andi	r3,r3,65535
 18357b8:	1806923a 	slli	r3,r3,8
 18357bc:	28c6b03a 	or	r3,r5,r3
 18357c0:	180d883a 	mov	r6,r3
 18357c4:	30ffffcc 	andi	r3,r6,65535
 18357c8:	19403fcc 	andi	r5,r3,255
 18357cc:	10c00383 	ldbu	r3,14(r2)
 18357d0:	1806703a 	and	r3,r3,zero
 18357d4:	1809883a 	mov	r4,r3
 18357d8:	2807883a 	mov	r3,r5
 18357dc:	20c6b03a 	or	r3,r4,r3
 18357e0:	10c00385 	stb	r3,14(r2)
 18357e4:	30ffffcc 	andi	r3,r6,65535
 18357e8:	1806d23a 	srli	r3,r3,8
 18357ec:	197fffcc 	andi	r5,r3,65535
 18357f0:	10c003c3 	ldbu	r3,15(r2)
 18357f4:	1806703a 	and	r3,r3,zero
 18357f8:	1809883a 	mov	r4,r3
 18357fc:	2807883a 	mov	r3,r5
 1835800:	20c6b03a 	or	r3,r4,r3
 1835804:	10c003c5 	stb	r3,15(r2)

  flags = TCPH_FLAGS(tcphdr);
 1835808:	d0a81917 	ldw	r2,-24476(gp)
 183580c:	10c00303 	ldbu	r3,12(r2)
 1835810:	10800343 	ldbu	r2,13(r2)
 1835814:	1004923a 	slli	r2,r2,8
 1835818:	10c4b03a 	or	r2,r2,r3
 183581c:	10bfffcc 	andi	r2,r2,65535
 1835820:	1004d23a 	srli	r2,r2,8
 1835824:	1009883a 	mov	r4,r2
 1835828:	d0a81917 	ldw	r2,-24476(gp)
 183582c:	10c00303 	ldbu	r3,12(r2)
 1835830:	10800343 	ldbu	r2,13(r2)
 1835834:	1004923a 	slli	r2,r2,8
 1835838:	10c4b03a 	or	r2,r2,r3
 183583c:	10bfffcc 	andi	r2,r2,65535
 1835840:	1004923a 	slli	r2,r2,8
 1835844:	2084b03a 	or	r2,r4,r2
 1835848:	10800fcc 	andi	r2,r2,63
 183584c:	d0a81d05 	stb	r2,-24460(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 1835850:	e0bffe17 	ldw	r2,-8(fp)
 1835854:	10c0020b 	ldhu	r3,8(r2)
 1835858:	d0a81d03 	ldbu	r2,-24460(gp)
 183585c:	10803fcc 	andi	r2,r2,255
 1835860:	108000cc 	andi	r2,r2,3
 1835864:	1004c03a 	cmpne	r2,r2,zero
 1835868:	10803fcc 	andi	r2,r2,255
 183586c:	1885883a 	add	r2,r3,r2
 1835870:	d0a81d8d 	sth	r2,-24458(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 1835874:	e03ff915 	stw	zero,-28(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 1835878:	d0a7f717 	ldw	r2,-24612(gp)
 183587c:	e0bff815 	stw	r2,-32(fp)
 1835880:	00002d06 	br	1835938 <tcp_input+0x7d4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 1835884:	e0bff817 	ldw	r2,-32(fp)
 1835888:	1100080b 	ldhu	r4,32(r2)
 183588c:	d0a81917 	ldw	r2,-24476(gp)
 1835890:	10c00003 	ldbu	r3,0(r2)
 1835894:	10800043 	ldbu	r2,1(r2)
 1835898:	1004923a 	slli	r2,r2,8
 183589c:	10c4b03a 	or	r2,r2,r3
 18358a0:	20ffffcc 	andi	r3,r4,65535
 18358a4:	10bfffcc 	andi	r2,r2,65535
 18358a8:	18801e1e 	bne	r3,r2,1835924 <tcp_input+0x7c0>
       pcb->local_port == tcphdr->dest &&
 18358ac:	e0bff817 	ldw	r2,-32(fp)
 18358b0:	1100078b 	ldhu	r4,30(r2)
 18358b4:	d0a81917 	ldw	r2,-24476(gp)
 18358b8:	10c00083 	ldbu	r3,2(r2)
 18358bc:	108000c3 	ldbu	r2,3(r2)
 18358c0:	1004923a 	slli	r2,r2,8
 18358c4:	10c4b03a 	or	r2,r2,r3
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 18358c8:	20ffffcc 	andi	r3,r4,65535
 18358cc:	10bfffcc 	andi	r2,r2,65535
 18358d0:	1880141e 	bne	r3,r2,1835924 <tcp_input+0x7c0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 18358d4:	e0bff817 	ldw	r2,-32(fp)
 18358d8:	10c00117 	ldw	r3,4(r2)
 18358dc:	d0a81217 	ldw	r2,-24504(gp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
 18358e0:	1880101e 	bne	r3,r2,1835924 <tcp_input+0x7c0>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 18358e4:	e0bff817 	ldw	r2,-32(fp)
 18358e8:	10c00017 	ldw	r3,0(r2)
 18358ec:	d0a81417 	ldw	r2,-24496(gp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 18358f0:	18800c1e 	bne	r3,r2,1835924 <tcp_input+0x7c0>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 18358f4:	e0bff917 	ldw	r2,-28(fp)
 18358f8:	10001226 	beq	r2,zero,1835944 <tcp_input+0x7e0>
        prev->next = pcb->next;
 18358fc:	e0bff817 	ldw	r2,-32(fp)
 1835900:	10c00317 	ldw	r3,12(r2)
 1835904:	e0bff917 	ldw	r2,-28(fp)
 1835908:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
 183590c:	d0e7f717 	ldw	r3,-24612(gp)
 1835910:	e0bff817 	ldw	r2,-32(fp)
 1835914:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
 1835918:	e0bff817 	ldw	r2,-32(fp)
 183591c:	d0a7f715 	stw	r2,-24612(gp)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 1835920:	00000806 	br	1835944 <tcp_input+0x7e0>
    }
    prev = pcb;
 1835924:	e0bff817 	ldw	r2,-32(fp)
 1835928:	e0bff915 	stw	r2,-28(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 183592c:	e0bff817 	ldw	r2,-32(fp)
 1835930:	10800317 	ldw	r2,12(r2)
 1835934:	e0bff815 	stw	r2,-32(fp)
 1835938:	e0bff817 	ldw	r2,-32(fp)
 183593c:	103fd11e 	bne	r2,zero,1835884 <__ram_exceptions_end+0xff825440>
 1835940:	00000106 	br	1835948 <tcp_input+0x7e4>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 1835944:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
 1835948:	e0bff817 	ldw	r2,-32(fp)
 183594c:	1000651e 	bne	r2,zero,1835ae4 <tcp_input+0x980>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 1835950:	d0a7fc17 	ldw	r2,-24592(gp)
 1835954:	e0bff815 	stw	r2,-32(fp)
 1835958:	00002406 	br	18359ec <tcp_input+0x888>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 183595c:	e0bff817 	ldw	r2,-32(fp)
 1835960:	1100080b 	ldhu	r4,32(r2)
 1835964:	d0a81917 	ldw	r2,-24476(gp)
 1835968:	10c00003 	ldbu	r3,0(r2)
 183596c:	10800043 	ldbu	r2,1(r2)
 1835970:	1004923a 	slli	r2,r2,8
 1835974:	10c4b03a 	or	r2,r2,r3
 1835978:	20ffffcc 	andi	r3,r4,65535
 183597c:	10bfffcc 	andi	r2,r2,65535
 1835980:	1880171e 	bne	r3,r2,18359e0 <tcp_input+0x87c>
         pcb->local_port == tcphdr->dest &&
 1835984:	e0bff817 	ldw	r2,-32(fp)
 1835988:	1100078b 	ldhu	r4,30(r2)
 183598c:	d0a81917 	ldw	r2,-24476(gp)
 1835990:	10c00083 	ldbu	r3,2(r2)
 1835994:	108000c3 	ldbu	r2,3(r2)
 1835998:	1004923a 	slli	r2,r2,8
 183599c:	10c4b03a 	or	r2,r2,r3
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 18359a0:	20ffffcc 	andi	r3,r4,65535
 18359a4:	10bfffcc 	andi	r2,r2,65535
 18359a8:	18800d1e 	bne	r3,r2,18359e0 <tcp_input+0x87c>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 18359ac:	e0bff817 	ldw	r2,-32(fp)
 18359b0:	10c00117 	ldw	r3,4(r2)
 18359b4:	d0a81217 	ldw	r2,-24504(gp)
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
 18359b8:	1880091e 	bne	r3,r2,18359e0 <tcp_input+0x87c>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 18359bc:	e0bff817 	ldw	r2,-32(fp)
 18359c0:	10c00017 	ldw	r3,0(r2)
 18359c4:	d0a81417 	ldw	r2,-24496(gp)
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 18359c8:	1880051e 	bne	r3,r2,18359e0 <tcp_input+0x87c>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
 18359cc:	e13ff817 	ldw	r4,-32(fp)
 18359d0:	18362c80 	call	18362c8 <tcp_timewait_input>
        pbuf_free(p);
 18359d4:	e13ffe17 	ldw	r4,-8(fp)
 18359d8:	181aca40 	call	181aca4 <pbuf_free>
        return;
 18359dc:	00017b06 	br	1835fcc <tcp_input+0xe68>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 18359e0:	e0bff817 	ldw	r2,-32(fp)
 18359e4:	10800317 	ldw	r2,12(r2)
 18359e8:	e0bff815 	stw	r2,-32(fp)
 18359ec:	e0bff817 	ldw	r2,-32(fp)
 18359f0:	103fda1e 	bne	r2,zero,183595c <__ram_exceptions_end+0xff825518>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 18359f4:	e03ff915 	stw	zero,-28(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 18359f8:	d0a7f917 	ldw	r2,-24604(gp)
 18359fc:	e0bffa15 	stw	r2,-24(fp)
 1835a00:	00001c06 	br	1835a74 <tcp_input+0x910>
      if (lpcb->local_port == tcphdr->dest) {
 1835a04:	e0bffa17 	ldw	r2,-24(fp)
 1835a08:	1100078b 	ldhu	r4,30(r2)
 1835a0c:	d0a81917 	ldw	r2,-24476(gp)
 1835a10:	10c00083 	ldbu	r3,2(r2)
 1835a14:	108000c3 	ldbu	r2,3(r2)
 1835a18:	1004923a 	slli	r2,r2,8
 1835a1c:	10c4b03a 	or	r2,r2,r3
 1835a20:	20ffffcc 	andi	r3,r4,65535
 1835a24:	10bfffcc 	andi	r2,r2,65535
 1835a28:	18800d1e 	bne	r3,r2,1835a60 <tcp_input+0x8fc>
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
 1835a2c:	e0bffa17 	ldw	r2,-24(fp)
 1835a30:	10c00017 	ldw	r3,0(r2)
 1835a34:	d0a81417 	ldw	r2,-24496(gp)
 1835a38:	18801126 	beq	r3,r2,1835a80 <tcp_input+0x91c>
          /* found an exact match */
          break;
        } else if(ip_addr_isany(&(lpcb->local_ip))) {
 1835a3c:	e0bffa17 	ldw	r2,-24(fp)
 1835a40:	10000326 	beq	r2,zero,1835a50 <tcp_input+0x8ec>
 1835a44:	e0bffa17 	ldw	r2,-24(fp)
 1835a48:	10800017 	ldw	r2,0(r2)
 1835a4c:	1000041e 	bne	r2,zero,1835a60 <tcp_input+0x8fc>
          /* found an ANY-match */
          lpcb_any = lpcb;
 1835a50:	e0bffa17 	ldw	r2,-24(fp)
 1835a54:	e0bffc15 	stw	r2,-16(fp)
          lpcb_prev = prev;
 1835a58:	e0bff917 	ldw	r2,-28(fp)
 1835a5c:	e0bffb15 	stw	r2,-20(fp)
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
 1835a60:	e0bffa17 	ldw	r2,-24(fp)
 1835a64:	e0bff915 	stw	r2,-28(fp)
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 1835a68:	e0bffa17 	ldw	r2,-24(fp)
 1835a6c:	10800317 	ldw	r2,12(r2)
 1835a70:	e0bffa15 	stw	r2,-24(fp)
 1835a74:	e0bffa17 	ldw	r2,-24(fp)
 1835a78:	103fe21e 	bne	r2,zero,1835a04 <__ram_exceptions_end+0xff8255c0>
 1835a7c:	00000106 	br	1835a84 <tcp_input+0x920>
      if (lpcb->local_port == tcphdr->dest) {
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
          /* found an exact match */
          break;
 1835a80:	0001883a 	nop
      }
      prev = (struct tcp_pcb *)lpcb;
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 1835a84:	e0bffa17 	ldw	r2,-24(fp)
 1835a88:	1000041e 	bne	r2,zero,1835a9c <tcp_input+0x938>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 1835a8c:	e0bffc17 	ldw	r2,-16(fp)
 1835a90:	e0bffa15 	stw	r2,-24(fp)
      prev = lpcb_prev;
 1835a94:	e0bffb17 	ldw	r2,-20(fp)
 1835a98:	e0bff915 	stw	r2,-28(fp)
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 1835a9c:	e0bffa17 	ldw	r2,-24(fp)
 1835aa0:	10001026 	beq	r2,zero,1835ae4 <tcp_input+0x980>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 1835aa4:	e0bff917 	ldw	r2,-28(fp)
 1835aa8:	10000926 	beq	r2,zero,1835ad0 <tcp_input+0x96c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 1835aac:	e0bffa17 	ldw	r2,-24(fp)
 1835ab0:	10c00317 	ldw	r3,12(r2)
 1835ab4:	e0bff917 	ldw	r2,-28(fp)
 1835ab8:	10c00315 	stw	r3,12(r2)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 1835abc:	d0e7f917 	ldw	r3,-24604(gp)
 1835ac0:	e0bffa17 	ldw	r2,-24(fp)
 1835ac4:	10c00315 	stw	r3,12(r2)
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 1835ac8:	e0bffa17 	ldw	r2,-24(fp)
 1835acc:	d0a7f915 	stw	r2,-24604(gp)
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
 1835ad0:	e13ffa17 	ldw	r4,-24(fp)
 1835ad4:	1835fe00 	call	1835fe0 <tcp_listen_input>
      pbuf_free(p);
 1835ad8:	e13ffe17 	ldw	r4,-8(fp)
 1835adc:	181aca40 	call	181aca4 <pbuf_free>
      return;
 1835ae0:	00013a06 	br	1835fcc <tcp_input+0xe68>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
 1835ae4:	e0bff817 	ldw	r2,-32(fp)
 1835ae8:	1000f226 	beq	r2,zero,1835eb4 <tcp_input+0xd50>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 1835aec:	008061b4 	movhi	r2,390
 1835af0:	1089a304 	addi	r2,r2,9868
 1835af4:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
 1835af8:	e0bffe17 	ldw	r2,-8(fp)
 1835afc:	10c0020b 	ldhu	r3,8(r2)
 1835b00:	008061b4 	movhi	r2,390
 1835b04:	1089a304 	addi	r2,r2,9868
 1835b08:	10c0020d 	sth	r3,8(r2)
    inseg.p = p;
 1835b0c:	008061b4 	movhi	r2,390
 1835b10:	1089a304 	addi	r2,r2,9868
 1835b14:	e0fffe17 	ldw	r3,-8(fp)
 1835b18:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
 1835b1c:	d0e81917 	ldw	r3,-24476(gp)
 1835b20:	008061b4 	movhi	r2,390
 1835b24:	1089a304 	addi	r2,r2,9868
 1835b28:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
 1835b2c:	d0281f15 	stw	zero,-24452(gp)
    recv_flags = 0;
 1835b30:	d0281e05 	stb	zero,-24456(gp)

    if (flags & TCP_PSH) {
 1835b34:	d0a81d03 	ldbu	r2,-24460(gp)
 1835b38:	10803fcc 	andi	r2,r2,255
 1835b3c:	1080020c 	andi	r2,r2,8
 1835b40:	10000626 	beq	r2,zero,1835b5c <tcp_input+0x9f8>
      p->flags |= PBUF_FLAG_PUSH;
 1835b44:	e0bffe17 	ldw	r2,-8(fp)
 1835b48:	10800343 	ldbu	r2,13(r2)
 1835b4c:	10800054 	ori	r2,r2,1
 1835b50:	1007883a 	mov	r3,r2
 1835b54:	e0bffe17 	ldw	r2,-8(fp)
 1835b58:	10c00345 	stb	r3,13(r2)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 1835b5c:	e0bff817 	ldw	r2,-32(fp)
 1835b60:	10801f17 	ldw	r2,124(r2)
 1835b64:	10001526 	beq	r2,zero,1835bbc <tcp_input+0xa58>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 1835b68:	e13ff817 	ldw	r4,-32(fp)
 1835b6c:	181d3c80 	call	181d3c8 <tcp_process_refused_data>
 1835b70:	10803fcc 	andi	r2,r2,255
 1835b74:	1080201c 	xori	r2,r2,128
 1835b78:	10bfe004 	addi	r2,r2,-128
 1835b7c:	10bffda0 	cmpeqi	r2,r2,-10
 1835b80:	1000061e 	bne	r2,zero,1835b9c <tcp_input+0xa38>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 1835b84:	e0bff817 	ldw	r2,-32(fp)
 1835b88:	10801f17 	ldw	r2,124(r2)
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 1835b8c:	10000b26 	beq	r2,zero,1835bbc <tcp_input+0xa58>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 1835b90:	d0a81d8b 	ldhu	r2,-24458(gp)
 1835b94:	10bfffcc 	andi	r2,r2,65535
 1835b98:	10000826 	beq	r2,zero,1835bbc <tcp_input+0xa58>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
 1835b9c:	008061f4 	movhi	r2,391
 1835ba0:	10a9d404 	addi	r2,r2,-22704
 1835ba4:	10804b17 	ldw	r2,300(r2)
 1835ba8:	10c00044 	addi	r3,r2,1
 1835bac:	008061f4 	movhi	r2,391
 1835bb0:	10a9d404 	addi	r2,r2,-22704
 1835bb4:	10c04b15 	stw	r3,300(r2)
        snmp_inc_tcpinerrs();
        goto aborted;
 1835bb8:	0000af06 	br	1835e78 <tcp_input+0xd14>
      }
    }
    tcp_input_pcb = pcb;
 1835bbc:	e0bff817 	ldw	r2,-32(fp)
 1835bc0:	d0a82015 	stw	r2,-24448(gp)
    err = tcp_process(pcb);
 1835bc4:	e13ff817 	ldw	r4,-32(fp)
 1835bc8:	18364040 	call	1836404 <tcp_process>
 1835bcc:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 1835bd0:	e0bffd07 	ldb	r2,-12(fp)
 1835bd4:	10bffda0 	cmpeqi	r2,r2,-10
 1835bd8:	1000a71e 	bne	r2,zero,1835e78 <tcp_input+0xd14>
      if (recv_flags & TF_RESET) {
 1835bdc:	d0a81e03 	ldbu	r2,-24456(gp)
 1835be0:	10803fcc 	andi	r2,r2,255
 1835be4:	1080020c 	andi	r2,r2,8
 1835be8:	10001126 	beq	r2,zero,1835c30 <tcp_input+0xacc>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 1835bec:	e0bff817 	ldw	r2,-32(fp)
 1835bf0:	10802417 	ldw	r2,144(r2)
 1835bf4:	10000726 	beq	r2,zero,1835c14 <tcp_input+0xab0>
 1835bf8:	e0bff817 	ldw	r2,-32(fp)
 1835bfc:	10802417 	ldw	r2,144(r2)
 1835c00:	e0fff817 	ldw	r3,-32(fp)
 1835c04:	18c00417 	ldw	r3,16(r3)
 1835c08:	017ffd44 	movi	r5,-11
 1835c0c:	1809883a 	mov	r4,r3
 1835c10:	103ee83a 	callr	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 1835c14:	e17ff817 	ldw	r5,-32(fp)
 1835c18:	d127f704 	addi	r4,gp,-24612
 1835c1c:	181dd380 	call	181dd38 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 1835c20:	e17ff817 	ldw	r5,-32(fp)
 1835c24:	01000084 	movi	r4,2
 1835c28:	1834b240 	call	1834b24 <memp_free>
 1835c2c:	00009206 	br	1835e78 <tcp_input+0xd14>
      } else if (recv_flags & TF_CLOSED) {
 1835c30:	d0a81e03 	ldbu	r2,-24456(gp)
 1835c34:	10803fcc 	andi	r2,r2,255
 1835c38:	1080040c 	andi	r2,r2,16
 1835c3c:	10001626 	beq	r2,zero,1835c98 <tcp_input+0xb34>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
 1835c40:	e0bff817 	ldw	r2,-32(fp)
 1835c44:	10800883 	ldbu	r2,34(r2)
 1835c48:	10803fcc 	andi	r2,r2,255
 1835c4c:	1080040c 	andi	r2,r2,16
 1835c50:	10000a1e 	bne	r2,zero,1835c7c <tcp_input+0xb18>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 1835c54:	e0bff817 	ldw	r2,-32(fp)
 1835c58:	10802417 	ldw	r2,144(r2)
 1835c5c:	10000726 	beq	r2,zero,1835c7c <tcp_input+0xb18>
 1835c60:	e0bff817 	ldw	r2,-32(fp)
 1835c64:	10802417 	ldw	r2,144(r2)
 1835c68:	e0fff817 	ldw	r3,-32(fp)
 1835c6c:	18c00417 	ldw	r3,16(r3)
 1835c70:	017ffd04 	movi	r5,-12
 1835c74:	1809883a 	mov	r4,r3
 1835c78:	103ee83a 	callr	r2
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 1835c7c:	e17ff817 	ldw	r5,-32(fp)
 1835c80:	d127f704 	addi	r4,gp,-24612
 1835c84:	181dd380 	call	181dd38 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 1835c88:	e17ff817 	ldw	r5,-32(fp)
 1835c8c:	01000084 	movi	r4,2
 1835c90:	1834b240 	call	1834b24 <memp_free>
 1835c94:	00007806 	br	1835e78 <tcp_input+0xd14>
      } else {
        err = ERR_OK;
 1835c98:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 1835c9c:	e0bff817 	ldw	r2,-32(fp)
 1835ca0:	10801a0b 	ldhu	r2,104(r2)
 1835ca4:	10bfffcc 	andi	r2,r2,65535
 1835ca8:	10001326 	beq	r2,zero,1835cf8 <tcp_input+0xb94>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 1835cac:	e0bff817 	ldw	r2,-32(fp)
 1835cb0:	10802017 	ldw	r2,128(r2)
 1835cb4:	10000c26 	beq	r2,zero,1835ce8 <tcp_input+0xb84>
 1835cb8:	e0bff817 	ldw	r2,-32(fp)
 1835cbc:	10802017 	ldw	r2,128(r2)
 1835cc0:	e0fff817 	ldw	r3,-32(fp)
 1835cc4:	19000417 	ldw	r4,16(r3)
 1835cc8:	e0fff817 	ldw	r3,-32(fp)
 1835ccc:	18c01a0b 	ldhu	r3,104(r3)
 1835cd0:	18ffffcc 	andi	r3,r3,65535
 1835cd4:	180d883a 	mov	r6,r3
 1835cd8:	e17ff817 	ldw	r5,-32(fp)
 1835cdc:	103ee83a 	callr	r2
 1835ce0:	e0bffd05 	stb	r2,-12(fp)
 1835ce4:	00000106 	br	1835cec <tcp_input+0xb88>
 1835ce8:	e03ffd05 	stb	zero,-12(fp)
          if (err == ERR_ABRT) {
 1835cec:	e0bffd07 	ldb	r2,-12(fp)
 1835cf0:	10bffd98 	cmpnei	r2,r2,-10
 1835cf4:	10005b26 	beq	r2,zero,1835e64 <tcp_input+0xd00>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
 1835cf8:	d0a81f17 	ldw	r2,-24452(gp)
 1835cfc:	10002926 	beq	r2,zero,1835da4 <tcp_input+0xc40>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
 1835d00:	e0bff817 	ldw	r2,-32(fp)
 1835d04:	10800883 	ldbu	r2,34(r2)
 1835d08:	10803fcc 	andi	r2,r2,255
 1835d0c:	1080040c 	andi	r2,r2,16
 1835d10:	10000626 	beq	r2,zero,1835d2c <tcp_input+0xbc8>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 1835d14:	d0a81f17 	ldw	r2,-24452(gp)
 1835d18:	1009883a 	mov	r4,r2
 1835d1c:	181aca40 	call	181aca4 <pbuf_free>
            tcp_abort(pcb);
 1835d20:	e13ff817 	ldw	r4,-32(fp)
 1835d24:	181c0f00 	call	181c0f0 <tcp_abort>
            goto aborted;
 1835d28:	00005306 	br	1835e78 <tcp_input+0xd14>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 1835d2c:	e0bff817 	ldw	r2,-32(fp)
 1835d30:	10802117 	ldw	r2,132(r2)
 1835d34:	10000c26 	beq	r2,zero,1835d68 <tcp_input+0xc04>
 1835d38:	e0bff817 	ldw	r2,-32(fp)
 1835d3c:	10802117 	ldw	r2,132(r2)
 1835d40:	e0fff817 	ldw	r3,-32(fp)
 1835d44:	18c00417 	ldw	r3,16(r3)
 1835d48:	d1281f17 	ldw	r4,-24452(gp)
 1835d4c:	000f883a 	mov	r7,zero
 1835d50:	200d883a 	mov	r6,r4
 1835d54:	e17ff817 	ldw	r5,-32(fp)
 1835d58:	1809883a 	mov	r4,r3
 1835d5c:	103ee83a 	callr	r2
 1835d60:	e0bffd05 	stb	r2,-12(fp)
 1835d64:	00000706 	br	1835d84 <tcp_input+0xc20>
 1835d68:	d0a81f17 	ldw	r2,-24452(gp)
 1835d6c:	000f883a 	mov	r7,zero
 1835d70:	100d883a 	mov	r6,r2
 1835d74:	e17ff817 	ldw	r5,-32(fp)
 1835d78:	0009883a 	mov	r4,zero
 1835d7c:	181d6680 	call	181d668 <tcp_recv_null>
 1835d80:	e0bffd05 	stb	r2,-12(fp)
          if (err == ERR_ABRT) {
 1835d84:	e0bffd07 	ldb	r2,-12(fp)
 1835d88:	10bffd98 	cmpnei	r2,r2,-10
 1835d8c:	10003726 	beq	r2,zero,1835e6c <tcp_input+0xd08>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 1835d90:	e0bffd07 	ldb	r2,-12(fp)
 1835d94:	10000326 	beq	r2,zero,1835da4 <tcp_input+0xc40>
            pcb->refused_data = recv_data;
 1835d98:	d0e81f17 	ldw	r3,-24452(gp)
 1835d9c:	e0bff817 	ldw	r2,-32(fp)
 1835da0:	10c01f15 	stw	r3,124(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 1835da4:	d0a81e03 	ldbu	r2,-24456(gp)
 1835da8:	10803fcc 	andi	r2,r2,255
 1835dac:	1080080c 	andi	r2,r2,32
 1835db0:	10002826 	beq	r2,zero,1835e54 <tcp_input+0xcf0>
          if (pcb->refused_data != NULL) {
 1835db4:	e0bff817 	ldw	r2,-32(fp)
 1835db8:	10801f17 	ldw	r2,124(r2)
 1835dbc:	10000826 	beq	r2,zero,1835de0 <tcp_input+0xc7c>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 1835dc0:	e0bff817 	ldw	r2,-32(fp)
 1835dc4:	10801f17 	ldw	r2,124(r2)
 1835dc8:	e0fff817 	ldw	r3,-32(fp)
 1835dcc:	18c01f17 	ldw	r3,124(r3)
 1835dd0:	18c00343 	ldbu	r3,13(r3)
 1835dd4:	18c00814 	ori	r3,r3,32
 1835dd8:	10c00345 	stb	r3,13(r2)
 1835ddc:	00001d06 	br	1835e54 <tcp_input+0xcf0>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 1835de0:	e0bff817 	ldw	r2,-32(fp)
 1835de4:	10800c0b 	ldhu	r2,48(r2)
 1835de8:	10bfffcc 	andi	r2,r2,65535
 1835dec:	10880020 	cmpeqi	r2,r2,8192
 1835df0:	1000061e 	bne	r2,zero,1835e0c <tcp_input+0xca8>
              pcb->rcv_wnd++;
 1835df4:	e0bff817 	ldw	r2,-32(fp)
 1835df8:	10800c0b 	ldhu	r2,48(r2)
 1835dfc:	10800044 	addi	r2,r2,1
 1835e00:	1007883a 	mov	r3,r2
 1835e04:	e0bff817 	ldw	r2,-32(fp)
 1835e08:	10c00c0d 	sth	r3,48(r2)
            }
            TCP_EVENT_CLOSED(pcb, err);
 1835e0c:	e0bff817 	ldw	r2,-32(fp)
 1835e10:	10802117 	ldw	r2,132(r2)
 1835e14:	10000b26 	beq	r2,zero,1835e44 <tcp_input+0xce0>
 1835e18:	e0bff817 	ldw	r2,-32(fp)
 1835e1c:	10802117 	ldw	r2,132(r2)
 1835e20:	e0fff817 	ldw	r3,-32(fp)
 1835e24:	18c00417 	ldw	r3,16(r3)
 1835e28:	000f883a 	mov	r7,zero
 1835e2c:	000d883a 	mov	r6,zero
 1835e30:	e17ff817 	ldw	r5,-32(fp)
 1835e34:	1809883a 	mov	r4,r3
 1835e38:	103ee83a 	callr	r2
 1835e3c:	e0bffd05 	stb	r2,-12(fp)
 1835e40:	00000106 	br	1835e48 <tcp_input+0xce4>
 1835e44:	e03ffd05 	stb	zero,-12(fp)
            if (err == ERR_ABRT) {
 1835e48:	e0bffd07 	ldb	r2,-12(fp)
 1835e4c:	10bffd98 	cmpnei	r2,r2,-10
 1835e50:	10000826 	beq	r2,zero,1835e74 <tcp_input+0xd10>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 1835e54:	d0282015 	stw	zero,-24448(gp)
        /* Try to send something out. */
        tcp_output(pcb);
 1835e58:	e13ff817 	ldw	r4,-32(fp)
 1835e5c:	181f8bc0 	call	181f8bc <tcp_output>
 1835e60:	00000506 	br	1835e78 <tcp_input+0xd14>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
 1835e64:	0001883a 	nop
 1835e68:	00000306 	br	1835e78 <tcp_input+0xd14>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
 1835e6c:	0001883a 	nop
 1835e70:	00000106 	br	1835e78 <tcp_input+0xd14>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
 1835e74:	0001883a 	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 1835e78:	d0282015 	stw	zero,-24448(gp)
    recv_data = NULL;
 1835e7c:	d0281f15 	stw	zero,-24452(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 1835e80:	008061b4 	movhi	r2,390
 1835e84:	1089a304 	addi	r2,r2,9868
 1835e88:	10800117 	ldw	r2,4(r2)
 1835e8c:	10004e26 	beq	r2,zero,1835fc8 <tcp_input+0xe64>
    {
      pbuf_free(inseg.p);
 1835e90:	008061b4 	movhi	r2,390
 1835e94:	1089a304 	addi	r2,r2,9868
 1835e98:	10800117 	ldw	r2,4(r2)
 1835e9c:	1009883a 	mov	r4,r2
 1835ea0:	181aca40 	call	181aca4 <pbuf_free>
      inseg.p = NULL;
 1835ea4:	008061b4 	movhi	r2,390
 1835ea8:	1089a304 	addi	r2,r2,9868
 1835eac:	10000115 	stw	zero,4(r2)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 1835eb0:	00004506 	br	1835fc8 <tcp_input+0xe64>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 1835eb4:	d0a81917 	ldw	r2,-24476(gp)
 1835eb8:	10c00303 	ldbu	r3,12(r2)
 1835ebc:	10800343 	ldbu	r2,13(r2)
 1835ec0:	1004923a 	slli	r2,r2,8
 1835ec4:	10c4b03a 	or	r2,r2,r3
 1835ec8:	10bfffcc 	andi	r2,r2,65535
 1835ecc:	1004d23a 	srli	r2,r2,8
 1835ed0:	10ffffcc 	andi	r3,r2,65535
 1835ed4:	d0a81917 	ldw	r2,-24476(gp)
 1835ed8:	11000303 	ldbu	r4,12(r2)
 1835edc:	10800343 	ldbu	r2,13(r2)
 1835ee0:	1004923a 	slli	r2,r2,8
 1835ee4:	1104b03a 	or	r2,r2,r4
 1835ee8:	10bfffcc 	andi	r2,r2,65535
 1835eec:	1004923a 	slli	r2,r2,8
 1835ef0:	10bfffcc 	andi	r2,r2,65535
 1835ef4:	1884b03a 	or	r2,r3,r2
 1835ef8:	1080010c 	andi	r2,r2,4
 1835efc:	1000251e 	bne	r2,zero,1835f94 <tcp_input+0xe30>
      TCP_STATS_INC(tcp.proterr);
 1835f00:	008061f4 	movhi	r2,391
 1835f04:	10a9d404 	addi	r2,r2,-22704
 1835f08:	10805017 	ldw	r2,320(r2)
 1835f0c:	10c00044 	addi	r3,r2,1
 1835f10:	008061f4 	movhi	r2,391
 1835f14:	10a9d404 	addi	r2,r2,-22704
 1835f18:	10c05015 	stw	r3,320(r2)
      TCP_STATS_INC(tcp.drop);
 1835f1c:	008061f4 	movhi	r2,391
 1835f20:	10a9d404 	addi	r2,r2,-22704
 1835f24:	10804b17 	ldw	r2,300(r2)
 1835f28:	10c00044 	addi	r3,r2,1
 1835f2c:	008061f4 	movhi	r2,391
 1835f30:	10a9d404 	addi	r2,r2,-22704
 1835f34:	10c04b15 	stw	r3,300(r2)
      tcp_rst(ackno, seqno + tcplen,
 1835f38:	d2281c17 	ldw	r8,-24464(gp)
 1835f3c:	d0a81d8b 	ldhu	r2,-24458(gp)
 1835f40:	10ffffcc 	andi	r3,r2,65535
 1835f44:	d0a81b17 	ldw	r2,-24468(gp)
 1835f48:	188b883a 	add	r5,r3,r2
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 1835f4c:	d0a81917 	ldw	r2,-24476(gp)
 1835f50:	10c00083 	ldbu	r3,2(r2)
 1835f54:	108000c3 	ldbu	r2,3(r2)
 1835f58:	1004923a 	slli	r2,r2,8
 1835f5c:	10c4b03a 	or	r2,r2,r3
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 1835f60:	10ffffcc 	andi	r3,r2,65535
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 1835f64:	d0a81917 	ldw	r2,-24476(gp)
 1835f68:	11000003 	ldbu	r4,0(r2)
 1835f6c:	10800043 	ldbu	r2,1(r2)
 1835f70:	1004923a 	slli	r2,r2,8
 1835f74:	1104b03a 	or	r2,r2,r4
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 1835f78:	10bfffcc 	andi	r2,r2,65535
 1835f7c:	d8800115 	stw	r2,4(sp)
 1835f80:	d8c00015 	stw	r3,0(sp)
 1835f84:	d1e81204 	addi	r7,gp,-24504
 1835f88:	d1a81404 	addi	r6,gp,-24496
 1835f8c:	4009883a 	mov	r4,r8
 1835f90:	18209680 	call	1820968 <tcp_rst>
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
 1835f94:	e13ffe17 	ldw	r4,-8(fp)
 1835f98:	181aca40 	call	181aca4 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 1835f9c:	00000a06 	br	1835fc8 <tcp_input+0xe64>
dropped:
  TCP_STATS_INC(tcp.drop);
 1835fa0:	008061f4 	movhi	r2,391
 1835fa4:	10a9d404 	addi	r2,r2,-22704
 1835fa8:	10804b17 	ldw	r2,300(r2)
 1835fac:	10c00044 	addi	r3,r2,1
 1835fb0:	008061f4 	movhi	r2,391
 1835fb4:	10a9d404 	addi	r2,r2,-22704
 1835fb8:	10c04b15 	stw	r3,300(r2)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 1835fbc:	e13ffe17 	ldw	r4,-8(fp)
 1835fc0:	181aca40 	call	181aca4 <pbuf_free>
 1835fc4:	00000106 	br	1835fcc <tcp_input+0xe68>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 1835fc8:	0001883a 	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 1835fcc:	e037883a 	mov	sp,fp
 1835fd0:	dfc00117 	ldw	ra,4(sp)
 1835fd4:	df000017 	ldw	fp,0(sp)
 1835fd8:	dec00204 	addi	sp,sp,8
 1835fdc:	f800283a 	ret

01835fe0 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 1835fe0:	defff904 	addi	sp,sp,-28
 1835fe4:	dfc00615 	stw	ra,24(sp)
 1835fe8:	df000515 	stw	fp,20(sp)
 1835fec:	df000504 	addi	fp,sp,20
 1835ff0:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
 1835ff4:	d0a81d03 	ldbu	r2,-24460(gp)
 1835ff8:	10803fcc 	andi	r2,r2,255
 1835ffc:	1080010c 	andi	r2,r2,4
 1836000:	10000226 	beq	r2,zero,183600c <tcp_listen_input+0x2c>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
 1836004:	0005883a 	mov	r2,zero
 1836008:	0000aa06 	br	18362b4 <tcp_listen_input+0x2d4>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 183600c:	d0a81d03 	ldbu	r2,-24460(gp)
 1836010:	10803fcc 	andi	r2,r2,255
 1836014:	1080040c 	andi	r2,r2,16
 1836018:	10001826 	beq	r2,zero,183607c <tcp_listen_input+0x9c>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 183601c:	d2281c17 	ldw	r8,-24464(gp)
 1836020:	d0a81d8b 	ldhu	r2,-24458(gp)
 1836024:	10ffffcc 	andi	r3,r2,65535
 1836028:	d0a81b17 	ldw	r2,-24468(gp)
 183602c:	188b883a 	add	r5,r3,r2
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 1836030:	d0a81917 	ldw	r2,-24476(gp)
 1836034:	10c00083 	ldbu	r3,2(r2)
 1836038:	108000c3 	ldbu	r2,3(r2)
 183603c:	1004923a 	slli	r2,r2,8
 1836040:	10c4b03a 	or	r2,r2,r3
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 1836044:	10ffffcc 	andi	r3,r2,65535
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 1836048:	d0a81917 	ldw	r2,-24476(gp)
 183604c:	11000003 	ldbu	r4,0(r2)
 1836050:	10800043 	ldbu	r2,1(r2)
 1836054:	1004923a 	slli	r2,r2,8
 1836058:	1104b03a 	or	r2,r2,r4
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 183605c:	10bfffcc 	andi	r2,r2,65535
 1836060:	d8800115 	stw	r2,4(sp)
 1836064:	d8c00015 	stw	r3,0(sp)
 1836068:	d1e81204 	addi	r7,gp,-24504
 183606c:	d1a81404 	addi	r6,gp,-24496
 1836070:	4009883a 	mov	r4,r8
 1836074:	18209680 	call	1820968 <tcp_rst>
 1836078:	00008d06 	br	18362b0 <tcp_listen_input+0x2d0>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 183607c:	d0a81d03 	ldbu	r2,-24460(gp)
 1836080:	10803fcc 	andi	r2,r2,255
 1836084:	1080008c 	andi	r2,r2,2
 1836088:	10008926 	beq	r2,zero,18362b0 <tcp_listen_input+0x2d0>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
 183608c:	e0bfff17 	ldw	r2,-4(fp)
 1836090:	10c00843 	ldbu	r3,33(r2)
 1836094:	e0bfff17 	ldw	r2,-4(fp)
 1836098:	10800803 	ldbu	r2,32(r2)
 183609c:	18c03fcc 	andi	r3,r3,255
 18360a0:	10803fcc 	andi	r2,r2,255
 18360a4:	18800236 	bltu	r3,r2,18360b0 <tcp_listen_input+0xd0>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
 18360a8:	00bffd84 	movi	r2,-10
 18360ac:	00008106 	br	18362b4 <tcp_listen_input+0x2d4>
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 18360b0:	e0bfff17 	ldw	r2,-4(fp)
 18360b4:	10800703 	ldbu	r2,28(r2)
 18360b8:	10803fcc 	andi	r2,r2,255
 18360bc:	1009883a 	mov	r4,r2
 18360c0:	181d8500 	call	181d850 <tcp_alloc>
 18360c4:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 18360c8:	e0bffd17 	ldw	r2,-12(fp)
 18360cc:	1000091e 	bne	r2,zero,18360f4 <tcp_listen_input+0x114>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
 18360d0:	008061f4 	movhi	r2,391
 18360d4:	10a9d404 	addi	r2,r2,-22704
 18360d8:	10804e17 	ldw	r2,312(r2)
 18360dc:	10c00044 	addi	r3,r2,1
 18360e0:	008061f4 	movhi	r2,391
 18360e4:	10a9d404 	addi	r2,r2,-22704
 18360e8:	10c04e15 	stw	r3,312(r2)
      return ERR_MEM;
 18360ec:	00bfffc4 	movi	r2,-1
 18360f0:	00007006 	br	18362b4 <tcp_listen_input+0x2d4>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
 18360f4:	e0bfff17 	ldw	r2,-4(fp)
 18360f8:	10800843 	ldbu	r2,33(r2)
 18360fc:	10800044 	addi	r2,r2,1
 1836100:	1007883a 	mov	r3,r2
 1836104:	e0bfff17 	ldw	r2,-4(fp)
 1836108:	10c00845 	stb	r3,33(r2)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 183610c:	d0e81417 	ldw	r3,-24496(gp)
 1836110:	e0bffd17 	ldw	r2,-12(fp)
 1836114:	10c00015 	stw	r3,0(r2)
    npcb->local_port = pcb->local_port;
 1836118:	e0bfff17 	ldw	r2,-4(fp)
 183611c:	10c0078b 	ldhu	r3,30(r2)
 1836120:	e0bffd17 	ldw	r2,-12(fp)
 1836124:	10c0078d 	sth	r3,30(r2)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 1836128:	d0e81217 	ldw	r3,-24504(gp)
 183612c:	e0bffd17 	ldw	r2,-12(fp)
 1836130:	10c00115 	stw	r3,4(r2)
    npcb->remote_port = tcphdr->src;
 1836134:	d0a81917 	ldw	r2,-24476(gp)
 1836138:	10c00003 	ldbu	r3,0(r2)
 183613c:	10800043 	ldbu	r2,1(r2)
 1836140:	1004923a 	slli	r2,r2,8
 1836144:	10c4b03a 	or	r2,r2,r3
 1836148:	1007883a 	mov	r3,r2
 183614c:	e0bffd17 	ldw	r2,-12(fp)
 1836150:	10c0080d 	sth	r3,32(r2)
    npcb->state = SYN_RCVD;
 1836154:	e0bffd17 	ldw	r2,-12(fp)
 1836158:	00c000c4 	movi	r3,3
 183615c:	10c00615 	stw	r3,24(r2)
    npcb->rcv_nxt = seqno + 1;
 1836160:	d0a81b17 	ldw	r2,-24468(gp)
 1836164:	10c00044 	addi	r3,r2,1
 1836168:	e0bffd17 	ldw	r2,-12(fp)
 183616c:	10c00b15 	stw	r3,44(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 1836170:	e0bffd17 	ldw	r2,-12(fp)
 1836174:	10c00b17 	ldw	r3,44(r2)
 1836178:	e0bffd17 	ldw	r2,-12(fp)
 183617c:	10c00d15 	stw	r3,52(r2)
    npcb->snd_wnd = tcphdr->wnd;
 1836180:	d0a81917 	ldw	r2,-24476(gp)
 1836184:	10c00383 	ldbu	r3,14(r2)
 1836188:	108003c3 	ldbu	r2,15(r2)
 183618c:	1004923a 	slli	r2,r2,8
 1836190:	10c4b03a 	or	r2,r2,r3
 1836194:	1007883a 	mov	r3,r2
 1836198:	e0bffd17 	ldw	r2,-12(fp)
 183619c:	10c0190d 	sth	r3,100(r2)
    npcb->snd_wnd_max = tcphdr->wnd;
 18361a0:	d0a81917 	ldw	r2,-24476(gp)
 18361a4:	10c00383 	ldbu	r3,14(r2)
 18361a8:	108003c3 	ldbu	r2,15(r2)
 18361ac:	1004923a 	slli	r2,r2,8
 18361b0:	10c4b03a 	or	r2,r2,r3
 18361b4:	1007883a 	mov	r3,r2
 18361b8:	e0bffd17 	ldw	r2,-12(fp)
 18361bc:	10c0198d 	sth	r3,102(r2)
    npcb->ssthresh = npcb->snd_wnd;
 18361c0:	e0bffd17 	ldw	r2,-12(fp)
 18361c4:	10c0190b 	ldhu	r3,100(r2)
 18361c8:	e0bffd17 	ldw	r2,-12(fp)
 18361cc:	10c0148d 	sth	r3,82(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 18361d0:	d0a81b17 	ldw	r2,-24468(gp)
 18361d4:	10ffffc4 	addi	r3,r2,-1
 18361d8:	e0bffd17 	ldw	r2,-12(fp)
 18361dc:	10c01615 	stw	r3,88(r2)
    npcb->callback_arg = pcb->callback_arg;
 18361e0:	e0bfff17 	ldw	r2,-4(fp)
 18361e4:	10c00417 	ldw	r3,16(r2)
 18361e8:	e0bffd17 	ldw	r2,-12(fp)
 18361ec:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 18361f0:	e0bfff17 	ldw	r2,-4(fp)
 18361f4:	10c00517 	ldw	r3,20(r2)
 18361f8:	e0bffd17 	ldw	r2,-12(fp)
 18361fc:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 1836200:	e0bfff17 	ldw	r2,-4(fp)
 1836204:	10c00203 	ldbu	r3,8(r2)
 1836208:	00bfe304 	movi	r2,-116
 183620c:	1884703a 	and	r2,r3,r2
 1836210:	1007883a 	mov	r3,r2
 1836214:	e0bffd17 	ldw	r2,-12(fp)
 1836218:	10c00205 	stb	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 183621c:	d0e7f717 	ldw	r3,-24612(gp)
 1836220:	e0bffd17 	ldw	r2,-12(fp)
 1836224:	10c00315 	stw	r3,12(r2)
 1836228:	e0bffd17 	ldw	r2,-12(fp)
 183622c:	d0a7f715 	stw	r2,-24612(gp)
 1836230:	18216900 	call	1821690 <tcp_timer_needed>
 1836234:	00800044 	movi	r2,1
 1836238:	d0a7f685 	stb	r2,-24614(gp)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 183623c:	e13ffd17 	ldw	r4,-12(fp)
 1836240:	183914c0 	call	183914c <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->local_ip), &(npcb->remote_ip));
 1836244:	e0bffd17 	ldw	r2,-12(fp)
 1836248:	10800e8b 	ldhu	r2,58(r2)
 183624c:	10ffffcc 	andi	r3,r2,65535
 1836250:	e13ffd17 	ldw	r4,-12(fp)
 1836254:	e0bffd17 	ldw	r2,-12(fp)
 1836258:	10800104 	addi	r2,r2,4
 183625c:	100d883a 	mov	r6,r2
 1836260:	200b883a 	mov	r5,r4
 1836264:	1809883a 	mov	r4,r3
 1836268:	181de740 	call	181de74 <tcp_eff_send_mss>
 183626c:	1007883a 	mov	r3,r2
 1836270:	e0bffd17 	ldw	r2,-12(fp)
 1836274:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 1836278:	01400484 	movi	r5,18
 183627c:	e13ffd17 	ldw	r4,-12(fp)
 1836280:	181f4380 	call	181f438 <tcp_enqueue_flags>
 1836284:	e0bffe05 	stb	r2,-8(fp)
    if (rc != ERR_OK) {
 1836288:	e0bffe07 	ldb	r2,-8(fp)
 183628c:	10000526 	beq	r2,zero,18362a4 <tcp_listen_input+0x2c4>
      tcp_abandon(npcb, 0);
 1836290:	000b883a 	mov	r5,zero
 1836294:	e13ffd17 	ldw	r4,-12(fp)
 1836298:	181bf900 	call	181bf90 <tcp_abandon>
      return rc;
 183629c:	e0bffe03 	ldbu	r2,-8(fp)
 18362a0:	00000406 	br	18362b4 <tcp_listen_input+0x2d4>
    }
    return tcp_output(npcb);
 18362a4:	e13ffd17 	ldw	r4,-12(fp)
 18362a8:	181f8bc0 	call	181f8bc <tcp_output>
 18362ac:	00000106 	br	18362b4 <tcp_listen_input+0x2d4>
  }
  return ERR_OK;
 18362b0:	0005883a 	mov	r2,zero
}
 18362b4:	e037883a 	mov	sp,fp
 18362b8:	dfc00117 	ldw	ra,4(sp)
 18362bc:	df000017 	ldw	fp,0(sp)
 18362c0:	dec00204 	addi	sp,sp,8
 18362c4:	f800283a 	ret

018362c8 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
 18362c8:	defffb04 	addi	sp,sp,-20
 18362cc:	dfc00415 	stw	ra,16(sp)
 18362d0:	df000315 	stw	fp,12(sp)
 18362d4:	df000304 	addi	fp,sp,12
 18362d8:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 18362dc:	d0a81d03 	ldbu	r2,-24460(gp)
 18362e0:	10803fcc 	andi	r2,r2,255
 18362e4:	1080010c 	andi	r2,r2,4
 18362e8:	10000226 	beq	r2,zero,18362f4 <tcp_timewait_input+0x2c>
    return ERR_OK;
 18362ec:	0005883a 	mov	r2,zero
 18362f0:	00003f06 	br	18363f0 <tcp_timewait_input+0x128>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 18362f4:	d0a81d03 	ldbu	r2,-24460(gp)
 18362f8:	10803fcc 	andi	r2,r2,255
 18362fc:	1080008c 	andi	r2,r2,2
 1836300:	10002726 	beq	r2,zero,18363a0 <tcp_timewait_input+0xd8>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 1836304:	d0e81b17 	ldw	r3,-24468(gp)
 1836308:	e0bfff17 	ldw	r2,-4(fp)
 183630c:	10800b17 	ldw	r2,44(r2)
 1836310:	1885c83a 	sub	r2,r3,r2
 1836314:	10002916 	blt	r2,zero,18363bc <tcp_timewait_input+0xf4>
 1836318:	d0e81b17 	ldw	r3,-24468(gp)
 183631c:	e0bfff17 	ldw	r2,-4(fp)
 1836320:	11000b17 	ldw	r4,44(r2)
 1836324:	e0bfff17 	ldw	r2,-4(fp)
 1836328:	10800c0b 	ldhu	r2,48(r2)
 183632c:	10bfffcc 	andi	r2,r2,65535
 1836330:	2085883a 	add	r2,r4,r2
 1836334:	1885c83a 	sub	r2,r3,r2
 1836338:	00802016 	blt	zero,r2,18363bc <tcp_timewait_input+0xf4>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 183633c:	d2281c17 	ldw	r8,-24464(gp)
 1836340:	d0a81d8b 	ldhu	r2,-24458(gp)
 1836344:	10ffffcc 	andi	r3,r2,65535
 1836348:	d0a81b17 	ldw	r2,-24468(gp)
 183634c:	188b883a 	add	r5,r3,r2
        tcphdr->dest, tcphdr->src);
 1836350:	d0a81917 	ldw	r2,-24476(gp)
 1836354:	10c00083 	ldbu	r3,2(r2)
 1836358:	108000c3 	ldbu	r2,3(r2)
 183635c:	1004923a 	slli	r2,r2,8
 1836360:	10c4b03a 	or	r2,r2,r3
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 1836364:	10ffffcc 	andi	r3,r2,65535
        tcphdr->dest, tcphdr->src);
 1836368:	d0a81917 	ldw	r2,-24476(gp)
 183636c:	11000003 	ldbu	r4,0(r2)
 1836370:	10800043 	ldbu	r2,1(r2)
 1836374:	1004923a 	slli	r2,r2,8
 1836378:	1104b03a 	or	r2,r2,r4
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 183637c:	10bfffcc 	andi	r2,r2,65535
 1836380:	d8800115 	stw	r2,4(sp)
 1836384:	d8c00015 	stw	r3,0(sp)
 1836388:	d1e81204 	addi	r7,gp,-24504
 183638c:	d1a81404 	addi	r6,gp,-24496
 1836390:	4009883a 	mov	r4,r8
 1836394:	18209680 	call	1820968 <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
 1836398:	0005883a 	mov	r2,zero
 183639c:	00001406 	br	18363f0 <tcp_timewait_input+0x128>
    }
  } else if (flags & TCP_FIN) {
 18363a0:	d0a81d03 	ldbu	r2,-24460(gp)
 18363a4:	10803fcc 	andi	r2,r2,255
 18363a8:	1080004c 	andi	r2,r2,1
 18363ac:	10000326 	beq	r2,zero,18363bc <tcp_timewait_input+0xf4>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 18363b0:	d0e7f817 	ldw	r3,-24608(gp)
 18363b4:	e0bfff17 	ldw	r2,-4(fp)
 18363b8:	10c00a15 	stw	r3,40(r2)
  }

  if ((tcplen > 0))  {
 18363bc:	d0a81d8b 	ldhu	r2,-24458(gp)
 18363c0:	10bfffcc 	andi	r2,r2,65535
 18363c4:	10000926 	beq	r2,zero,18363ec <tcp_timewait_input+0x124>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 18363c8:	e0bfff17 	ldw	r2,-4(fp)
 18363cc:	10800883 	ldbu	r2,34(r2)
 18363d0:	10800094 	ori	r2,r2,2
 18363d4:	1007883a 	mov	r3,r2
 18363d8:	e0bfff17 	ldw	r2,-4(fp)
 18363dc:	10c00885 	stb	r3,34(r2)
    return tcp_output(pcb);
 18363e0:	e13fff17 	ldw	r4,-4(fp)
 18363e4:	181f8bc0 	call	181f8bc <tcp_output>
 18363e8:	00000106 	br	18363f0 <tcp_timewait_input+0x128>
  }
  return ERR_OK;
 18363ec:	0005883a 	mov	r2,zero
}
 18363f0:	e037883a 	mov	sp,fp
 18363f4:	dfc00117 	ldw	ra,4(sp)
 18363f8:	df000017 	ldw	fp,0(sp)
 18363fc:	dec00204 	addi	sp,sp,8
 1836400:	f800283a 	ret

01836404 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 1836404:	defff804 	addi	sp,sp,-32
 1836408:	dfc00715 	stw	ra,28(sp)
 183640c:	df000615 	stw	fp,24(sp)
 1836410:	df000604 	addi	fp,sp,24
 1836414:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 1836418:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
 183641c:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 1836420:	d0a81d03 	ldbu	r2,-24460(gp)
 1836424:	10803fcc 	andi	r2,r2,255
 1836428:	1080010c 	andi	r2,r2,4
 183642c:	10002b26 	beq	r2,zero,18364dc <tcp_process+0xd8>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 1836430:	e0bfff17 	ldw	r2,-4(fp)
 1836434:	10800617 	ldw	r2,24(r2)
 1836438:	10800098 	cmpnei	r2,r2,2
 183643c:	1000071e 	bne	r2,zero,183645c <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
 1836440:	e0bfff17 	ldw	r2,-4(fp)
 1836444:	10c01517 	ldw	r3,84(r2)
 1836448:	d0a81c17 	ldw	r2,-24464(gp)
 183644c:	1880131e 	bne	r3,r2,183649c <tcp_process+0x98>
        acceptable = 1;
 1836450:	00800044 	movi	r2,1
 1836454:	e0bffc05 	stb	r2,-16(fp)
 1836458:	00001006 	br	183649c <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 183645c:	d0e81b17 	ldw	r3,-24468(gp)
 1836460:	e0bfff17 	ldw	r2,-4(fp)
 1836464:	10800b17 	ldw	r2,44(r2)
 1836468:	1885c83a 	sub	r2,r3,r2
 183646c:	10000b16 	blt	r2,zero,183649c <tcp_process+0x98>
 1836470:	d0e81b17 	ldw	r3,-24468(gp)
 1836474:	e0bfff17 	ldw	r2,-4(fp)
 1836478:	11000b17 	ldw	r4,44(r2)
 183647c:	e0bfff17 	ldw	r2,-4(fp)
 1836480:	10800c0b 	ldhu	r2,48(r2)
 1836484:	10bfffcc 	andi	r2,r2,65535
 1836488:	2085883a 	add	r2,r4,r2
 183648c:	1885c83a 	sub	r2,r3,r2
 1836490:	00800216 	blt	zero,r2,183649c <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
 1836494:	00800044 	movi	r2,1
 1836498:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
 183649c:	e0bffc03 	ldbu	r2,-16(fp)
 18364a0:	10000c26 	beq	r2,zero,18364d4 <tcp_process+0xd0>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 18364a4:	d0a81e03 	ldbu	r2,-24456(gp)
 18364a8:	10800214 	ori	r2,r2,8
 18364ac:	d0a81e05 	stb	r2,-24456(gp)
      pcb->flags &= ~TF_ACK_DELAY;
 18364b0:	e0bfff17 	ldw	r2,-4(fp)
 18364b4:	10c00883 	ldbu	r3,34(r2)
 18364b8:	00bfff84 	movi	r2,-2
 18364bc:	1884703a 	and	r2,r3,r2
 18364c0:	1007883a 	mov	r3,r2
 18364c4:	e0bfff17 	ldw	r2,-4(fp)
 18364c8:	10c00885 	stb	r3,34(r2)
      return ERR_RST;
 18364cc:	00bffd44 	movi	r2,-11
 18364d0:	00027406 	br	1836ea4 <tcp_process+0xaa0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
 18364d4:	0005883a 	mov	r2,zero
 18364d8:	00027206 	br	1836ea4 <tcp_process+0xaa0>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 18364dc:	d0a81d03 	ldbu	r2,-24460(gp)
 18364e0:	10803fcc 	andi	r2,r2,255
 18364e4:	1080008c 	andi	r2,r2,2
 18364e8:	10001026 	beq	r2,zero,183652c <tcp_process+0x128>
 18364ec:	e0bfff17 	ldw	r2,-4(fp)
 18364f0:	10800617 	ldw	r2,24(r2)
 18364f4:	108000a0 	cmpeqi	r2,r2,2
 18364f8:	10000c1e 	bne	r2,zero,183652c <tcp_process+0x128>
 18364fc:	e0bfff17 	ldw	r2,-4(fp)
 1836500:	10800617 	ldw	r2,24(r2)
 1836504:	108000e0 	cmpeqi	r2,r2,3
 1836508:	1000081e 	bne	r2,zero,183652c <tcp_process+0x128>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 183650c:	e0bfff17 	ldw	r2,-4(fp)
 1836510:	10800883 	ldbu	r2,34(r2)
 1836514:	10800094 	ori	r2,r2,2
 1836518:	1007883a 	mov	r3,r2
 183651c:	e0bfff17 	ldw	r2,-4(fp)
 1836520:	10c00885 	stb	r3,34(r2)
    return ERR_OK;
 1836524:	0005883a 	mov	r2,zero
 1836528:	00025e06 	br	1836ea4 <tcp_process+0xaa0>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 183652c:	e0bfff17 	ldw	r2,-4(fp)
 1836530:	10800883 	ldbu	r2,34(r2)
 1836534:	10803fcc 	andi	r2,r2,255
 1836538:	1080040c 	andi	r2,r2,16
 183653c:	1000031e 	bne	r2,zero,183654c <tcp_process+0x148>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 1836540:	d0e7f817 	ldw	r3,-24608(gp)
 1836544:	e0bfff17 	ldw	r2,-4(fp)
 1836548:	10c00a15 	stw	r3,40(r2)
  }
  pcb->keep_cnt_sent = 0;
 183654c:	e0bfff17 	ldw	r2,-4(fp)
 1836550:	10002885 	stb	zero,162(r2)

  tcp_parseopt(pcb);
 1836554:	e13fff17 	ldw	r4,-4(fp)
 1836558:	183914c0 	call	183914c <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 183655c:	e0bfff17 	ldw	r2,-4(fp)
 1836560:	10800617 	ldw	r2,24(r2)
 1836564:	10c002a8 	cmpgeui	r3,r2,10
 1836568:	18023e1e 	bne	r3,zero,1836e64 <tcp_process+0xa60>
 183656c:	100690ba 	slli	r3,r2,2
 1836570:	008060f4 	movhi	r2,387
 1836574:	10996104 	addi	r2,r2,25988
 1836578:	1885883a 	add	r2,r3,r2
 183657c:	10800017 	ldw	r2,0(r2)
 1836580:	1000683a 	jmp	r2
 1836584:	01836e64 	muli	r6,zero,3513
 1836588:	01836e64 	muli	r6,zero,3513
 183658c:	018365ac 	andhi	r6,zero,3478
 1836590:	0183692c 	andhi	r6,zero,3492
 1836594:	01836b0c 	andi	r6,zero,3500
 1836598:	01836b4c 	andi	r6,zero,3501
 183659c:	01836c94 	movui	r6,3506
 18365a0:	01836b0c 	andi	r6,zero,3500
 18365a4:	01836d64 	muli	r6,zero,3509
 18365a8:	01836e2c 	andhi	r6,zero,3512
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 18365ac:	d0a81d03 	ldbu	r2,-24460(gp)
 18365b0:	10803fcc 	andi	r2,r2,255
 18365b4:	1080040c 	andi	r2,r2,16
 18365b8:	1000c026 	beq	r2,zero,18368bc <tcp_process+0x4b8>
 18365bc:	d0a81d03 	ldbu	r2,-24460(gp)
 18365c0:	10803fcc 	andi	r2,r2,255
 18365c4:	1080008c 	andi	r2,r2,2
 18365c8:	1000bc26 	beq	r2,zero,18368bc <tcp_process+0x4b8>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 18365cc:	e0bfff17 	ldw	r2,-4(fp)
 18365d0:	10801d17 	ldw	r2,116(r2)
 18365d4:	10800417 	ldw	r2,16(r2)
 18365d8:	10c00103 	ldbu	r3,4(r2)
 18365dc:	11000143 	ldbu	r4,5(r2)
 18365e0:	2008923a 	slli	r4,r4,8
 18365e4:	20c6b03a 	or	r3,r4,r3
 18365e8:	11000183 	ldbu	r4,6(r2)
 18365ec:	2008943a 	slli	r4,r4,16
 18365f0:	20c6b03a 	or	r3,r4,r3
 18365f4:	108001c3 	ldbu	r2,7(r2)
 18365f8:	1004963a 	slli	r2,r2,24
 18365fc:	10c4b03a 	or	r2,r2,r3
 1836600:	1006d63a 	srli	r3,r2,24
 1836604:	e0bfff17 	ldw	r2,-4(fp)
 1836608:	10801d17 	ldw	r2,116(r2)
 183660c:	10800417 	ldw	r2,16(r2)
 1836610:	11000103 	ldbu	r4,4(r2)
 1836614:	11400143 	ldbu	r5,5(r2)
 1836618:	280a923a 	slli	r5,r5,8
 183661c:	2908b03a 	or	r4,r5,r4
 1836620:	11400183 	ldbu	r5,6(r2)
 1836624:	280a943a 	slli	r5,r5,16
 1836628:	2908b03a 	or	r4,r5,r4
 183662c:	108001c3 	ldbu	r2,7(r2)
 1836630:	1004963a 	slli	r2,r2,24
 1836634:	1104b03a 	or	r2,r2,r4
 1836638:	1004d23a 	srli	r2,r2,8
 183663c:	10bfc00c 	andi	r2,r2,65280
 1836640:	1886b03a 	or	r3,r3,r2
 1836644:	e0bfff17 	ldw	r2,-4(fp)
 1836648:	10801d17 	ldw	r2,116(r2)
 183664c:	10800417 	ldw	r2,16(r2)
 1836650:	11000103 	ldbu	r4,4(r2)
 1836654:	11400143 	ldbu	r5,5(r2)
 1836658:	280a923a 	slli	r5,r5,8
 183665c:	2908b03a 	or	r4,r5,r4
 1836660:	11400183 	ldbu	r5,6(r2)
 1836664:	280a943a 	slli	r5,r5,16
 1836668:	2908b03a 	or	r4,r5,r4
 183666c:	108001c3 	ldbu	r2,7(r2)
 1836670:	1004963a 	slli	r2,r2,24
 1836674:	1104b03a 	or	r2,r2,r4
 1836678:	10bfc00c 	andi	r2,r2,65280
 183667c:	1004923a 	slli	r2,r2,8
 1836680:	1886b03a 	or	r3,r3,r2
 1836684:	e0bfff17 	ldw	r2,-4(fp)
 1836688:	10801d17 	ldw	r2,116(r2)
 183668c:	10800417 	ldw	r2,16(r2)
 1836690:	11000103 	ldbu	r4,4(r2)
 1836694:	11400143 	ldbu	r5,5(r2)
 1836698:	280a923a 	slli	r5,r5,8
 183669c:	2908b03a 	or	r4,r5,r4
 18366a0:	11400183 	ldbu	r5,6(r2)
 18366a4:	280a943a 	slli	r5,r5,16
 18366a8:	2908b03a 	or	r4,r5,r4
 18366ac:	108001c3 	ldbu	r2,7(r2)
 18366b0:	1004963a 	slli	r2,r2,24
 18366b4:	1104b03a 	or	r2,r2,r4
 18366b8:	1004963a 	slli	r2,r2,24
 18366bc:	1884b03a 	or	r2,r3,r2
 18366c0:	10c00044 	addi	r3,r2,1
 18366c4:	d0a81c17 	ldw	r2,-24464(gp)
 18366c8:	18807c1e 	bne	r3,r2,18368bc <tcp_process+0x4b8>
      pcb->snd_buf++;
 18366cc:	e0bfff17 	ldw	r2,-4(fp)
 18366d0:	10801a8b 	ldhu	r2,106(r2)
 18366d4:	10800044 	addi	r2,r2,1
 18366d8:	1007883a 	mov	r3,r2
 18366dc:	e0bfff17 	ldw	r2,-4(fp)
 18366e0:	10c01a8d 	sth	r3,106(r2)
      pcb->rcv_nxt = seqno + 1;
 18366e4:	d0a81b17 	ldw	r2,-24468(gp)
 18366e8:	10c00044 	addi	r3,r2,1
 18366ec:	e0bfff17 	ldw	r2,-4(fp)
 18366f0:	10c00b15 	stw	r3,44(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 18366f4:	e0bfff17 	ldw	r2,-4(fp)
 18366f8:	10c00b17 	ldw	r3,44(r2)
 18366fc:	e0bfff17 	ldw	r2,-4(fp)
 1836700:	10c00d15 	stw	r3,52(r2)
      pcb->lastack = ackno;
 1836704:	d0e81c17 	ldw	r3,-24464(gp)
 1836708:	e0bfff17 	ldw	r2,-4(fp)
 183670c:	10c01315 	stw	r3,76(r2)
      pcb->snd_wnd = tcphdr->wnd;
 1836710:	d0a81917 	ldw	r2,-24476(gp)
 1836714:	10c00383 	ldbu	r3,14(r2)
 1836718:	108003c3 	ldbu	r2,15(r2)
 183671c:	1004923a 	slli	r2,r2,8
 1836720:	10c4b03a 	or	r2,r2,r3
 1836724:	1007883a 	mov	r3,r2
 1836728:	e0bfff17 	ldw	r2,-4(fp)
 183672c:	10c0190d 	sth	r3,100(r2)
      pcb->snd_wnd_max = tcphdr->wnd;
 1836730:	d0a81917 	ldw	r2,-24476(gp)
 1836734:	10c00383 	ldbu	r3,14(r2)
 1836738:	108003c3 	ldbu	r2,15(r2)
 183673c:	1004923a 	slli	r2,r2,8
 1836740:	10c4b03a 	or	r2,r2,r3
 1836744:	1007883a 	mov	r3,r2
 1836748:	e0bfff17 	ldw	r2,-4(fp)
 183674c:	10c0198d 	sth	r3,102(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 1836750:	d0a81b17 	ldw	r2,-24468(gp)
 1836754:	10ffffc4 	addi	r3,r2,-1
 1836758:	e0bfff17 	ldw	r2,-4(fp)
 183675c:	10c01615 	stw	r3,88(r2)
      pcb->state = ESTABLISHED;
 1836760:	e0bfff17 	ldw	r2,-4(fp)
 1836764:	00c00104 	movi	r3,4
 1836768:	10c00615 	stw	r3,24(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), &(pcb->remote_ip));
 183676c:	e0bfff17 	ldw	r2,-4(fp)
 1836770:	10800e8b 	ldhu	r2,58(r2)
 1836774:	10ffffcc 	andi	r3,r2,65535
 1836778:	e13fff17 	ldw	r4,-4(fp)
 183677c:	e0bfff17 	ldw	r2,-4(fp)
 1836780:	10800104 	addi	r2,r2,4
 1836784:	100d883a 	mov	r6,r2
 1836788:	200b883a 	mov	r5,r4
 183678c:	1809883a 	mov	r4,r3
 1836790:	181de740 	call	181de74 <tcp_eff_send_mss>
 1836794:	1007883a 	mov	r3,r2
 1836798:	e0bfff17 	ldw	r2,-4(fp)
 183679c:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 18367a0:	e0bfff17 	ldw	r2,-4(fp)
 18367a4:	10800e8b 	ldhu	r2,58(r2)
 18367a8:	108002a4 	muli	r2,r2,10
 18367ac:	1007883a 	mov	r3,r2
 18367b0:	e0bfff17 	ldw	r2,-4(fp)
 18367b4:	10c0148d 	sth	r3,82(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 18367b8:	e0bfff17 	ldw	r2,-4(fp)
 18367bc:	1080140b 	ldhu	r2,80(r2)
 18367c0:	10bfffcc 	andi	r2,r2,65535
 18367c4:	10800058 	cmpnei	r2,r2,1
 18367c8:	1000041e 	bne	r2,zero,18367dc <tcp_process+0x3d8>
 18367cc:	e0bfff17 	ldw	r2,-4(fp)
 18367d0:	10800e8b 	ldhu	r2,58(r2)
 18367d4:	1085883a 	add	r2,r2,r2
 18367d8:	00000206 	br	18367e4 <tcp_process+0x3e0>
 18367dc:	e0bfff17 	ldw	r2,-4(fp)
 18367e0:	10800e8b 	ldhu	r2,58(r2)
 18367e4:	e0ffff17 	ldw	r3,-4(fp)
 18367e8:	1880140d 	sth	r2,80(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 18367ec:	e0bfff17 	ldw	r2,-4(fp)
 18367f0:	10801b0b 	ldhu	r2,108(r2)
 18367f4:	10bfffc4 	addi	r2,r2,-1
 18367f8:	1007883a 	mov	r3,r2
 18367fc:	e0bfff17 	ldw	r2,-4(fp)
 1836800:	10c01b0d 	sth	r3,108(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 1836804:	e0bfff17 	ldw	r2,-4(fp)
 1836808:	10801d17 	ldw	r2,116(r2)
 183680c:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
 1836810:	e0bffd17 	ldw	r2,-12(fp)
 1836814:	10c00017 	ldw	r3,0(r2)
 1836818:	e0bfff17 	ldw	r2,-4(fp)
 183681c:	10c01d15 	stw	r3,116(r2)
      tcp_seg_free(rseg);
 1836820:	e13ffd17 	ldw	r4,-12(fp)
 1836824:	181d56c0 	call	181d56c <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 1836828:	e0bfff17 	ldw	r2,-4(fp)
 183682c:	10801d17 	ldw	r2,116(r2)
 1836830:	1000041e 	bne	r2,zero,1836844 <tcp_process+0x440>
        pcb->rtime = -1;
 1836834:	e0bfff17 	ldw	r2,-4(fp)
 1836838:	00ffffc4 	movi	r3,-1
 183683c:	10c00e0d 	sth	r3,56(r2)
 1836840:	00000406 	br	1836854 <tcp_process+0x450>
      else {
        pcb->rtime = 0;
 1836844:	e0bfff17 	ldw	r2,-4(fp)
 1836848:	10000e0d 	sth	zero,56(r2)
        pcb->nrtx = 0;
 183684c:	e0bfff17 	ldw	r2,-4(fp)
 1836850:	10001285 	stb	zero,74(r2)
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 1836854:	e0bfff17 	ldw	r2,-4(fp)
 1836858:	10802217 	ldw	r2,136(r2)
 183685c:	10000a26 	beq	r2,zero,1836888 <tcp_process+0x484>
 1836860:	e0bfff17 	ldw	r2,-4(fp)
 1836864:	10802217 	ldw	r2,136(r2)
 1836868:	e0ffff17 	ldw	r3,-4(fp)
 183686c:	18c00417 	ldw	r3,16(r3)
 1836870:	000d883a 	mov	r6,zero
 1836874:	e17fff17 	ldw	r5,-4(fp)
 1836878:	1809883a 	mov	r4,r3
 183687c:	103ee83a 	callr	r2
 1836880:	e0bffc45 	stb	r2,-15(fp)
 1836884:	00000106 	br	183688c <tcp_process+0x488>
 1836888:	e03ffc45 	stb	zero,-15(fp)
      if (err == ERR_ABRT) {
 183688c:	e0bffc47 	ldb	r2,-15(fp)
 1836890:	10bffd98 	cmpnei	r2,r2,-10
 1836894:	1000021e 	bne	r2,zero,18368a0 <tcp_process+0x49c>
        return ERR_ABRT;
 1836898:	00bffd84 	movi	r2,-10
 183689c:	00018106 	br	1836ea4 <tcp_process+0xaa0>
      }
      tcp_ack_now(pcb);
 18368a0:	e0bfff17 	ldw	r2,-4(fp)
 18368a4:	10800883 	ldbu	r2,34(r2)
 18368a8:	10800094 	ori	r2,r2,2
 18368ac:	1007883a 	mov	r3,r2
 18368b0:	e0bfff17 	ldw	r2,-4(fp)
 18368b4:	10c00885 	stb	r3,34(r2)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
 18368b8:	00016c06 	br	1836e6c <tcp_process+0xa68>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 18368bc:	d0a81d03 	ldbu	r2,-24460(gp)
 18368c0:	10803fcc 	andi	r2,r2,255
 18368c4:	1080040c 	andi	r2,r2,16
 18368c8:	10016826 	beq	r2,zero,1836e6c <tcp_process+0xa68>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 18368cc:	d2281c17 	ldw	r8,-24464(gp)
 18368d0:	d0a81d8b 	ldhu	r2,-24458(gp)
 18368d4:	10ffffcc 	andi	r3,r2,65535
 18368d8:	d0a81b17 	ldw	r2,-24468(gp)
 18368dc:	188b883a 	add	r5,r3,r2
        tcphdr->dest, tcphdr->src);
 18368e0:	d0a81917 	ldw	r2,-24476(gp)
 18368e4:	10c00083 	ldbu	r3,2(r2)
 18368e8:	108000c3 	ldbu	r2,3(r2)
 18368ec:	1004923a 	slli	r2,r2,8
 18368f0:	10c4b03a 	or	r2,r2,r3
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 18368f4:	10ffffcc 	andi	r3,r2,65535
        tcphdr->dest, tcphdr->src);
 18368f8:	d0a81917 	ldw	r2,-24476(gp)
 18368fc:	11000003 	ldbu	r4,0(r2)
 1836900:	10800043 	ldbu	r2,1(r2)
 1836904:	1004923a 	slli	r2,r2,8
 1836908:	1104b03a 	or	r2,r2,r4
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 183690c:	10bfffcc 	andi	r2,r2,65535
 1836910:	d8800115 	stw	r2,4(sp)
 1836914:	d8c00015 	stw	r3,0(sp)
 1836918:	d1e81204 	addi	r7,gp,-24504
 183691c:	d1a81404 	addi	r6,gp,-24496
 1836920:	4009883a 	mov	r4,r8
 1836924:	18209680 	call	1820968 <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
 1836928:	00015006 	br	1836e6c <tcp_process+0xa68>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 183692c:	d0a81d03 	ldbu	r2,-24460(gp)
 1836930:	10803fcc 	andi	r2,r2,255
 1836934:	1080040c 	andi	r2,r2,16
 1836938:	10006626 	beq	r2,zero,1836ad4 <tcp_process+0x6d0>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 183693c:	d0e81c17 	ldw	r3,-24464(gp)
 1836940:	e0bfff17 	ldw	r2,-4(fp)
 1836944:	10801317 	ldw	r2,76(r2)
 1836948:	1885c83a 	sub	r2,r3,r2
 183694c:	10bfffc4 	addi	r2,r2,-1
 1836950:	10004816 	blt	r2,zero,1836a74 <tcp_process+0x670>
 1836954:	d0e81c17 	ldw	r3,-24464(gp)
 1836958:	e0bfff17 	ldw	r2,-4(fp)
 183695c:	10801517 	ldw	r2,84(r2)
 1836960:	1885c83a 	sub	r2,r3,r2
 1836964:	00804316 	blt	zero,r2,1836a74 <tcp_process+0x670>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 1836968:	e0bfff17 	ldw	r2,-4(fp)
 183696c:	00c00104 	movi	r3,4
 1836970:	10c00615 	stw	r3,24(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 1836974:	e0bfff17 	ldw	r2,-4(fp)
 1836978:	10800517 	ldw	r2,20(r2)
 183697c:	10000a26 	beq	r2,zero,18369a8 <tcp_process+0x5a4>
 1836980:	e0bfff17 	ldw	r2,-4(fp)
 1836984:	10800517 	ldw	r2,20(r2)
 1836988:	e0ffff17 	ldw	r3,-4(fp)
 183698c:	18c00417 	ldw	r3,16(r3)
 1836990:	000d883a 	mov	r6,zero
 1836994:	e17fff17 	ldw	r5,-4(fp)
 1836998:	1809883a 	mov	r4,r3
 183699c:	103ee83a 	callr	r2
 18369a0:	e0bffc45 	stb	r2,-15(fp)
 18369a4:	00000206 	br	18369b0 <tcp_process+0x5ac>
 18369a8:	00bffc84 	movi	r2,-14
 18369ac:	e0bffc45 	stb	r2,-15(fp)
        if (err != ERR_OK) {
 18369b0:	e0bffc47 	ldb	r2,-15(fp)
 18369b4:	10000726 	beq	r2,zero,18369d4 <tcp_process+0x5d0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
 18369b8:	e0bffc47 	ldb	r2,-15(fp)
 18369bc:	10bffda0 	cmpeqi	r2,r2,-10
 18369c0:	1000021e 	bne	r2,zero,18369cc <tcp_process+0x5c8>
            tcp_abort(pcb);
 18369c4:	e13fff17 	ldw	r4,-4(fp)
 18369c8:	181c0f00 	call	181c0f0 <tcp_abort>
          }
          return ERR_ABRT;
 18369cc:	00bffd84 	movi	r2,-10
 18369d0:	00013406 	br	1836ea4 <tcp_process+0xaa0>
        }
        old_cwnd = pcb->cwnd;
 18369d4:	e0bfff17 	ldw	r2,-4(fp)
 18369d8:	1080140b 	ldhu	r2,80(r2)
 18369dc:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 18369e0:	e13fff17 	ldw	r4,-4(fp)
 18369e4:	18371580 	call	1837158 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 18369e8:	e0bfff17 	ldw	r2,-4(fp)
 18369ec:	10801a0b 	ldhu	r2,104(r2)
 18369f0:	10bfffcc 	andi	r2,r2,65535
 18369f4:	10000626 	beq	r2,zero,1836a10 <tcp_process+0x60c>
          pcb->acked--;
 18369f8:	e0bfff17 	ldw	r2,-4(fp)
 18369fc:	10801a0b 	ldhu	r2,104(r2)
 1836a00:	10bfffc4 	addi	r2,r2,-1
 1836a04:	1007883a 	mov	r3,r2
 1836a08:	e0bfff17 	ldw	r2,-4(fp)
 1836a0c:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 1836a10:	e0bffe0b 	ldhu	r2,-8(fp)
 1836a14:	10800058 	cmpnei	r2,r2,1
 1836a18:	1000041e 	bne	r2,zero,1836a2c <tcp_process+0x628>
 1836a1c:	e0bfff17 	ldw	r2,-4(fp)
 1836a20:	10800e8b 	ldhu	r2,58(r2)
 1836a24:	1085883a 	add	r2,r2,r2
 1836a28:	00000206 	br	1836a34 <tcp_process+0x630>
 1836a2c:	e0bfff17 	ldw	r2,-4(fp)
 1836a30:	10800e8b 	ldhu	r2,58(r2)
 1836a34:	e0ffff17 	ldw	r3,-4(fp)
 1836a38:	1880140d 	sth	r2,80(r3)

        if (recv_flags & TF_GOT_FIN) {
 1836a3c:	d0a81e03 	ldbu	r2,-24456(gp)
 1836a40:	10803fcc 	andi	r2,r2,255
 1836a44:	1080080c 	andi	r2,r2,32
 1836a48:	10002e26 	beq	r2,zero,1836b04 <tcp_process+0x700>
          tcp_ack_now(pcb);
 1836a4c:	e0bfff17 	ldw	r2,-4(fp)
 1836a50:	10800883 	ldbu	r2,34(r2)
 1836a54:	10800094 	ori	r2,r2,2
 1836a58:	1007883a 	mov	r3,r2
 1836a5c:	e0bfff17 	ldw	r2,-4(fp)
 1836a60:	10c00885 	stb	r3,34(r2)
          pcb->state = CLOSE_WAIT;
 1836a64:	e0bfff17 	ldw	r2,-4(fp)
 1836a68:	00c001c4 	movi	r3,7
 1836a6c:	10c00615 	stw	r3,24(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 1836a70:	00002406 	br	1836b04 <tcp_process+0x700>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 1836a74:	d2281c17 	ldw	r8,-24464(gp)
 1836a78:	d0a81d8b 	ldhu	r2,-24458(gp)
 1836a7c:	10ffffcc 	andi	r3,r2,65535
 1836a80:	d0a81b17 	ldw	r2,-24468(gp)
 1836a84:	188b883a 	add	r5,r3,r2
                tcphdr->dest, tcphdr->src);
 1836a88:	d0a81917 	ldw	r2,-24476(gp)
 1836a8c:	10c00083 	ldbu	r3,2(r2)
 1836a90:	108000c3 	ldbu	r2,3(r2)
 1836a94:	1004923a 	slli	r2,r2,8
 1836a98:	10c4b03a 	or	r2,r2,r3
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 1836a9c:	10ffffcc 	andi	r3,r2,65535
                tcphdr->dest, tcphdr->src);
 1836aa0:	d0a81917 	ldw	r2,-24476(gp)
 1836aa4:	11000003 	ldbu	r4,0(r2)
 1836aa8:	10800043 	ldbu	r2,1(r2)
 1836aac:	1004923a 	slli	r2,r2,8
 1836ab0:	1104b03a 	or	r2,r2,r4
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 1836ab4:	10bfffcc 	andi	r2,r2,65535
 1836ab8:	d8800115 	stw	r2,4(sp)
 1836abc:	d8c00015 	stw	r3,0(sp)
 1836ac0:	d1e81204 	addi	r7,gp,-24504
 1836ac4:	d1a81404 	addi	r6,gp,-24496
 1836ac8:	4009883a 	mov	r4,r8
 1836acc:	18209680 	call	1820968 <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 1836ad0:	0000e806 	br	1836e74 <tcp_process+0xa70>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 1836ad4:	d0a81d03 	ldbu	r2,-24460(gp)
 1836ad8:	10803fcc 	andi	r2,r2,255
 1836adc:	1080008c 	andi	r2,r2,2
 1836ae0:	1000e426 	beq	r2,zero,1836e74 <tcp_process+0xa70>
 1836ae4:	e0bfff17 	ldw	r2,-4(fp)
 1836ae8:	10800b17 	ldw	r2,44(r2)
 1836aec:	10ffffc4 	addi	r3,r2,-1
 1836af0:	d0a81b17 	ldw	r2,-24468(gp)
 1836af4:	1880df1e 	bne	r3,r2,1836e74 <tcp_process+0xa70>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 1836af8:	e13fff17 	ldw	r4,-4(fp)
 1836afc:	1820de80 	call	1820de8 <tcp_rexmit>
    }
    break;
 1836b00:	0000dc06 	br	1836e74 <tcp_process+0xa70>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 1836b04:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 1836b08:	0000da06 	br	1836e74 <tcp_process+0xa70>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 1836b0c:	e13fff17 	ldw	r4,-4(fp)
 1836b10:	18371580 	call	1837158 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 1836b14:	d0a81e03 	ldbu	r2,-24456(gp)
 1836b18:	10803fcc 	andi	r2,r2,255
 1836b1c:	1080080c 	andi	r2,r2,32
 1836b20:	1000d626 	beq	r2,zero,1836e7c <tcp_process+0xa78>
      tcp_ack_now(pcb);
 1836b24:	e0bfff17 	ldw	r2,-4(fp)
 1836b28:	10800883 	ldbu	r2,34(r2)
 1836b2c:	10800094 	ori	r2,r2,2
 1836b30:	1007883a 	mov	r3,r2
 1836b34:	e0bfff17 	ldw	r2,-4(fp)
 1836b38:	10c00885 	stb	r3,34(r2)
      pcb->state = CLOSE_WAIT;
 1836b3c:	e0bfff17 	ldw	r2,-4(fp)
 1836b40:	00c001c4 	movi	r3,7
 1836b44:	10c00615 	stw	r3,24(r2)
    }
    break;
 1836b48:	0000cc06 	br	1836e7c <tcp_process+0xa78>
  case FIN_WAIT_1:
    tcp_receive(pcb);
 1836b4c:	e13fff17 	ldw	r4,-4(fp)
 1836b50:	18371580 	call	1837158 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 1836b54:	d0a81e03 	ldbu	r2,-24456(gp)
 1836b58:	10803fcc 	andi	r2,r2,255
 1836b5c:	1080080c 	andi	r2,r2,32
 1836b60:	10004026 	beq	r2,zero,1836c64 <tcp_process+0x860>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 1836b64:	d0a81d03 	ldbu	r2,-24460(gp)
 1836b68:	10803fcc 	andi	r2,r2,255
 1836b6c:	1080040c 	andi	r2,r2,16
 1836b70:	10003226 	beq	r2,zero,1836c3c <tcp_process+0x838>
 1836b74:	e0bfff17 	ldw	r2,-4(fp)
 1836b78:	10c01517 	ldw	r3,84(r2)
 1836b7c:	d0a81c17 	ldw	r2,-24464(gp)
 1836b80:	18802e1e 	bne	r3,r2,1836c3c <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 1836b84:	e0bfff17 	ldw	r2,-4(fp)
 1836b88:	10800883 	ldbu	r2,34(r2)
 1836b8c:	10800094 	ori	r2,r2,2
 1836b90:	1007883a 	mov	r3,r2
 1836b94:	e0bfff17 	ldw	r2,-4(fp)
 1836b98:	10c00885 	stb	r3,34(r2)
        tcp_pcb_purge(pcb);
 1836b9c:	e13fff17 	ldw	r4,-4(fp)
 1836ba0:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 1836ba4:	d0e7f717 	ldw	r3,-24612(gp)
 1836ba8:	e0bfff17 	ldw	r2,-4(fp)
 1836bac:	1880041e 	bne	r3,r2,1836bc0 <tcp_process+0x7bc>
 1836bb0:	d0a7f717 	ldw	r2,-24612(gp)
 1836bb4:	10800317 	ldw	r2,12(r2)
 1836bb8:	d0a7f715 	stw	r2,-24612(gp)
 1836bbc:	00001106 	br	1836c04 <tcp_process+0x800>
 1836bc0:	d0a7f717 	ldw	r2,-24612(gp)
 1836bc4:	d0a7fa15 	stw	r2,-24600(gp)
 1836bc8:	00000c06 	br	1836bfc <tcp_process+0x7f8>
 1836bcc:	d0a7fa17 	ldw	r2,-24600(gp)
 1836bd0:	10c00317 	ldw	r3,12(r2)
 1836bd4:	e0bfff17 	ldw	r2,-4(fp)
 1836bd8:	1880051e 	bne	r3,r2,1836bf0 <tcp_process+0x7ec>
 1836bdc:	d0a7fa17 	ldw	r2,-24600(gp)
 1836be0:	e0ffff17 	ldw	r3,-4(fp)
 1836be4:	18c00317 	ldw	r3,12(r3)
 1836be8:	10c00315 	stw	r3,12(r2)
 1836bec:	00000506 	br	1836c04 <tcp_process+0x800>
 1836bf0:	d0a7fa17 	ldw	r2,-24600(gp)
 1836bf4:	10800317 	ldw	r2,12(r2)
 1836bf8:	d0a7fa15 	stw	r2,-24600(gp)
 1836bfc:	d0a7fa17 	ldw	r2,-24600(gp)
 1836c00:	103ff21e 	bne	r2,zero,1836bcc <__ram_exceptions_end+0xff826788>
 1836c04:	e0bfff17 	ldw	r2,-4(fp)
 1836c08:	10000315 	stw	zero,12(r2)
 1836c0c:	00800044 	movi	r2,1
 1836c10:	d0a7f685 	stb	r2,-24614(gp)
        pcb->state = TIME_WAIT;
 1836c14:	e0bfff17 	ldw	r2,-4(fp)
 1836c18:	00c00284 	movi	r3,10
 1836c1c:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 1836c20:	d0e7fc17 	ldw	r3,-24592(gp)
 1836c24:	e0bfff17 	ldw	r2,-4(fp)
 1836c28:	10c00315 	stw	r3,12(r2)
 1836c2c:	e0bfff17 	ldw	r2,-4(fp)
 1836c30:	d0a7fc15 	stw	r2,-24592(gp)
 1836c34:	18216900 	call	1821690 <tcp_timer_needed>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 1836c38:	00009206 	br	1836e84 <tcp_process+0xa80>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 1836c3c:	e0bfff17 	ldw	r2,-4(fp)
 1836c40:	10800883 	ldbu	r2,34(r2)
 1836c44:	10800094 	ori	r2,r2,2
 1836c48:	1007883a 	mov	r3,r2
 1836c4c:	e0bfff17 	ldw	r2,-4(fp)
 1836c50:	10c00885 	stb	r3,34(r2)
        pcb->state = CLOSING;
 1836c54:	e0bfff17 	ldw	r2,-4(fp)
 1836c58:	00c00204 	movi	r3,8
 1836c5c:	10c00615 	stw	r3,24(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 1836c60:	00008806 	br	1836e84 <tcp_process+0xa80>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 1836c64:	d0a81d03 	ldbu	r2,-24460(gp)
 1836c68:	10803fcc 	andi	r2,r2,255
 1836c6c:	1080040c 	andi	r2,r2,16
 1836c70:	10008426 	beq	r2,zero,1836e84 <tcp_process+0xa80>
 1836c74:	e0bfff17 	ldw	r2,-4(fp)
 1836c78:	10c01517 	ldw	r3,84(r2)
 1836c7c:	d0a81c17 	ldw	r2,-24464(gp)
 1836c80:	1880801e 	bne	r3,r2,1836e84 <tcp_process+0xa80>
      pcb->state = FIN_WAIT_2;
 1836c84:	e0bfff17 	ldw	r2,-4(fp)
 1836c88:	00c00184 	movi	r3,6
 1836c8c:	10c00615 	stw	r3,24(r2)
    }
    break;
 1836c90:	00007c06 	br	1836e84 <tcp_process+0xa80>
  case FIN_WAIT_2:
    tcp_receive(pcb);
 1836c94:	e13fff17 	ldw	r4,-4(fp)
 1836c98:	18371580 	call	1837158 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 1836c9c:	d0a81e03 	ldbu	r2,-24456(gp)
 1836ca0:	10803fcc 	andi	r2,r2,255
 1836ca4:	1080080c 	andi	r2,r2,32
 1836ca8:	10007826 	beq	r2,zero,1836e8c <tcp_process+0xa88>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 1836cac:	e0bfff17 	ldw	r2,-4(fp)
 1836cb0:	10800883 	ldbu	r2,34(r2)
 1836cb4:	10800094 	ori	r2,r2,2
 1836cb8:	1007883a 	mov	r3,r2
 1836cbc:	e0bfff17 	ldw	r2,-4(fp)
 1836cc0:	10c00885 	stb	r3,34(r2)
      tcp_pcb_purge(pcb);
 1836cc4:	e13fff17 	ldw	r4,-4(fp)
 1836cc8:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 1836ccc:	d0e7f717 	ldw	r3,-24612(gp)
 1836cd0:	e0bfff17 	ldw	r2,-4(fp)
 1836cd4:	1880041e 	bne	r3,r2,1836ce8 <tcp_process+0x8e4>
 1836cd8:	d0a7f717 	ldw	r2,-24612(gp)
 1836cdc:	10800317 	ldw	r2,12(r2)
 1836ce0:	d0a7f715 	stw	r2,-24612(gp)
 1836ce4:	00001106 	br	1836d2c <tcp_process+0x928>
 1836ce8:	d0a7f717 	ldw	r2,-24612(gp)
 1836cec:	d0a7fa15 	stw	r2,-24600(gp)
 1836cf0:	00000c06 	br	1836d24 <tcp_process+0x920>
 1836cf4:	d0a7fa17 	ldw	r2,-24600(gp)
 1836cf8:	10c00317 	ldw	r3,12(r2)
 1836cfc:	e0bfff17 	ldw	r2,-4(fp)
 1836d00:	1880051e 	bne	r3,r2,1836d18 <tcp_process+0x914>
 1836d04:	d0a7fa17 	ldw	r2,-24600(gp)
 1836d08:	e0ffff17 	ldw	r3,-4(fp)
 1836d0c:	18c00317 	ldw	r3,12(r3)
 1836d10:	10c00315 	stw	r3,12(r2)
 1836d14:	00000506 	br	1836d2c <tcp_process+0x928>
 1836d18:	d0a7fa17 	ldw	r2,-24600(gp)
 1836d1c:	10800317 	ldw	r2,12(r2)
 1836d20:	d0a7fa15 	stw	r2,-24600(gp)
 1836d24:	d0a7fa17 	ldw	r2,-24600(gp)
 1836d28:	103ff21e 	bne	r2,zero,1836cf4 <__ram_exceptions_end+0xff8268b0>
 1836d2c:	e0bfff17 	ldw	r2,-4(fp)
 1836d30:	10000315 	stw	zero,12(r2)
 1836d34:	00800044 	movi	r2,1
 1836d38:	d0a7f685 	stb	r2,-24614(gp)
      pcb->state = TIME_WAIT;
 1836d3c:	e0bfff17 	ldw	r2,-4(fp)
 1836d40:	00c00284 	movi	r3,10
 1836d44:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
 1836d48:	d0e7fc17 	ldw	r3,-24592(gp)
 1836d4c:	e0bfff17 	ldw	r2,-4(fp)
 1836d50:	10c00315 	stw	r3,12(r2)
 1836d54:	e0bfff17 	ldw	r2,-4(fp)
 1836d58:	d0a7fc15 	stw	r2,-24592(gp)
 1836d5c:	18216900 	call	1821690 <tcp_timer_needed>
    }
    break;
 1836d60:	00004a06 	br	1836e8c <tcp_process+0xa88>
  case CLOSING:
    tcp_receive(pcb);
 1836d64:	e13fff17 	ldw	r4,-4(fp)
 1836d68:	18371580 	call	1837158 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 1836d6c:	d0a81d03 	ldbu	r2,-24460(gp)
 1836d70:	10803fcc 	andi	r2,r2,255
 1836d74:	1080040c 	andi	r2,r2,16
 1836d78:	10004626 	beq	r2,zero,1836e94 <tcp_process+0xa90>
 1836d7c:	e0bfff17 	ldw	r2,-4(fp)
 1836d80:	10c01517 	ldw	r3,84(r2)
 1836d84:	d0a81c17 	ldw	r2,-24464(gp)
 1836d88:	1880421e 	bne	r3,r2,1836e94 <tcp_process+0xa90>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 1836d8c:	e13fff17 	ldw	r4,-4(fp)
 1836d90:	181dbc80 	call	181dbc8 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 1836d94:	d0e7f717 	ldw	r3,-24612(gp)
 1836d98:	e0bfff17 	ldw	r2,-4(fp)
 1836d9c:	1880041e 	bne	r3,r2,1836db0 <tcp_process+0x9ac>
 1836da0:	d0a7f717 	ldw	r2,-24612(gp)
 1836da4:	10800317 	ldw	r2,12(r2)
 1836da8:	d0a7f715 	stw	r2,-24612(gp)
 1836dac:	00001106 	br	1836df4 <tcp_process+0x9f0>
 1836db0:	d0a7f717 	ldw	r2,-24612(gp)
 1836db4:	d0a7fa15 	stw	r2,-24600(gp)
 1836db8:	00000c06 	br	1836dec <tcp_process+0x9e8>
 1836dbc:	d0a7fa17 	ldw	r2,-24600(gp)
 1836dc0:	10c00317 	ldw	r3,12(r2)
 1836dc4:	e0bfff17 	ldw	r2,-4(fp)
 1836dc8:	1880051e 	bne	r3,r2,1836de0 <tcp_process+0x9dc>
 1836dcc:	d0a7fa17 	ldw	r2,-24600(gp)
 1836dd0:	e0ffff17 	ldw	r3,-4(fp)
 1836dd4:	18c00317 	ldw	r3,12(r3)
 1836dd8:	10c00315 	stw	r3,12(r2)
 1836ddc:	00000506 	br	1836df4 <tcp_process+0x9f0>
 1836de0:	d0a7fa17 	ldw	r2,-24600(gp)
 1836de4:	10800317 	ldw	r2,12(r2)
 1836de8:	d0a7fa15 	stw	r2,-24600(gp)
 1836dec:	d0a7fa17 	ldw	r2,-24600(gp)
 1836df0:	103ff21e 	bne	r2,zero,1836dbc <__ram_exceptions_end+0xff826978>
 1836df4:	e0bfff17 	ldw	r2,-4(fp)
 1836df8:	10000315 	stw	zero,12(r2)
 1836dfc:	00800044 	movi	r2,1
 1836e00:	d0a7f685 	stb	r2,-24614(gp)
      pcb->state = TIME_WAIT;
 1836e04:	e0bfff17 	ldw	r2,-4(fp)
 1836e08:	00c00284 	movi	r3,10
 1836e0c:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
 1836e10:	d0e7fc17 	ldw	r3,-24592(gp)
 1836e14:	e0bfff17 	ldw	r2,-4(fp)
 1836e18:	10c00315 	stw	r3,12(r2)
 1836e1c:	e0bfff17 	ldw	r2,-4(fp)
 1836e20:	d0a7fc15 	stw	r2,-24592(gp)
 1836e24:	18216900 	call	1821690 <tcp_timer_needed>
    }
    break;
 1836e28:	00001a06 	br	1836e94 <tcp_process+0xa90>
  case LAST_ACK:
    tcp_receive(pcb);
 1836e2c:	e13fff17 	ldw	r4,-4(fp)
 1836e30:	18371580 	call	1837158 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 1836e34:	d0a81d03 	ldbu	r2,-24460(gp)
 1836e38:	10803fcc 	andi	r2,r2,255
 1836e3c:	1080040c 	andi	r2,r2,16
 1836e40:	10001626 	beq	r2,zero,1836e9c <tcp_process+0xa98>
 1836e44:	e0bfff17 	ldw	r2,-4(fp)
 1836e48:	10c01517 	ldw	r3,84(r2)
 1836e4c:	d0a81c17 	ldw	r2,-24464(gp)
 1836e50:	1880121e 	bne	r3,r2,1836e9c <tcp_process+0xa98>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 1836e54:	d0a81e03 	ldbu	r2,-24456(gp)
 1836e58:	10800414 	ori	r2,r2,16
 1836e5c:	d0a81e05 	stb	r2,-24456(gp)
    }
    break;
 1836e60:	00000e06 	br	1836e9c <tcp_process+0xa98>
  default:
    break;
 1836e64:	0001883a 	nop
 1836e68:	00000d06 	br	1836ea0 <tcp_process+0xa9c>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
 1836e6c:	0001883a 	nop
 1836e70:	00000b06 	br	1836ea0 <tcp_process+0xa9c>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 1836e74:	0001883a 	nop
 1836e78:	00000906 	br	1836ea0 <tcp_process+0xa9c>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
 1836e7c:	0001883a 	nop
 1836e80:	00000706 	br	1836ea0 <tcp_process+0xa9c>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 1836e84:	0001883a 	nop
 1836e88:	00000506 	br	1836ea0 <tcp_process+0xa9c>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 1836e8c:	0001883a 	nop
 1836e90:	00000306 	br	1836ea0 <tcp_process+0xa9c>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 1836e94:	0001883a 	nop
 1836e98:	00000106 	br	1836ea0 <tcp_process+0xa9c>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
 1836e9c:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
 1836ea0:	0005883a 	mov	r2,zero
}
 1836ea4:	e037883a 	mov	sp,fp
 1836ea8:	dfc00117 	ldw	ra,4(sp)
 1836eac:	df000017 	ldw	fp,0(sp)
 1836eb0:	dec00204 	addi	sp,sp,8
 1836eb4:	f800283a 	ret

01836eb8 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 1836eb8:	defffb04 	addi	sp,sp,-20
 1836ebc:	dfc00415 	stw	ra,16(sp)
 1836ec0:	df000315 	stw	fp,12(sp)
 1836ec4:	df000304 	addi	fp,sp,12
 1836ec8:	e13ffe15 	stw	r4,-8(fp)
 1836ecc:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 1836ed0:	e0bffe17 	ldw	r2,-8(fp)
 1836ed4:	10800417 	ldw	r2,16(r2)
 1836ed8:	10c00303 	ldbu	r3,12(r2)
 1836edc:	10800343 	ldbu	r2,13(r2)
 1836ee0:	1004923a 	slli	r2,r2,8
 1836ee4:	10c4b03a 	or	r2,r2,r3
 1836ee8:	10bfffcc 	andi	r2,r2,65535
 1836eec:	1004d23a 	srli	r2,r2,8
 1836ef0:	10ffffcc 	andi	r3,r2,65535
 1836ef4:	e0bffe17 	ldw	r2,-8(fp)
 1836ef8:	10800417 	ldw	r2,16(r2)
 1836efc:	11000303 	ldbu	r4,12(r2)
 1836f00:	10800343 	ldbu	r2,13(r2)
 1836f04:	1004923a 	slli	r2,r2,8
 1836f08:	1104b03a 	or	r2,r2,r4
 1836f0c:	10bfffcc 	andi	r2,r2,65535
 1836f10:	1004923a 	slli	r2,r2,8
 1836f14:	10bfffcc 	andi	r2,r2,65535
 1836f18:	1884b03a 	or	r2,r3,r2
 1836f1c:	1080004c 	andi	r2,r2,1
 1836f20:	10003b26 	beq	r2,zero,1837010 <tcp_oos_insert_segment+0x158>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 1836f24:	e13fff17 	ldw	r4,-4(fp)
 1836f28:	181d5180 	call	181d518 <tcp_segs_free>
    next = NULL;
 1836f2c:	e03fff15 	stw	zero,-4(fp)
 1836f30:	00008006 	br	1837134 <tcp_oos_insert_segment+0x27c>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 1836f34:	e0bfff17 	ldw	r2,-4(fp)
 1836f38:	10800417 	ldw	r2,16(r2)
 1836f3c:	10c00303 	ldbu	r3,12(r2)
 1836f40:	10800343 	ldbu	r2,13(r2)
 1836f44:	1004923a 	slli	r2,r2,8
 1836f48:	10c4b03a 	or	r2,r2,r3
 1836f4c:	10bfffcc 	andi	r2,r2,65535
 1836f50:	1004d23a 	srli	r2,r2,8
 1836f54:	10ffffcc 	andi	r3,r2,65535
 1836f58:	e0bfff17 	ldw	r2,-4(fp)
 1836f5c:	10800417 	ldw	r2,16(r2)
 1836f60:	11000303 	ldbu	r4,12(r2)
 1836f64:	10800343 	ldbu	r2,13(r2)
 1836f68:	1004923a 	slli	r2,r2,8
 1836f6c:	1104b03a 	or	r2,r2,r4
 1836f70:	10bfffcc 	andi	r2,r2,65535
 1836f74:	1004923a 	slli	r2,r2,8
 1836f78:	10bfffcc 	andi	r2,r2,65535
 1836f7c:	1884b03a 	or	r2,r3,r2
 1836f80:	1080004c 	andi	r2,r2,1
 1836f84:	10001b26 	beq	r2,zero,1836ff4 <tcp_oos_insert_segment+0x13c>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 1836f88:	e0bffe17 	ldw	r2,-8(fp)
 1836f8c:	10800417 	ldw	r2,16(r2)
 1836f90:	e0fffe17 	ldw	r3,-8(fp)
 1836f94:	18c00417 	ldw	r3,16(r3)
 1836f98:	19000303 	ldbu	r4,12(r3)
 1836f9c:	18c00343 	ldbu	r3,13(r3)
 1836fa0:	1806923a 	slli	r3,r3,8
 1836fa4:	1906b03a 	or	r3,r3,r4
 1836fa8:	18c04014 	ori	r3,r3,256
 1836fac:	180d883a 	mov	r6,r3
 1836fb0:	30ffffcc 	andi	r3,r6,65535
 1836fb4:	19403fcc 	andi	r5,r3,255
 1836fb8:	10c00303 	ldbu	r3,12(r2)
 1836fbc:	1806703a 	and	r3,r3,zero
 1836fc0:	1809883a 	mov	r4,r3
 1836fc4:	2807883a 	mov	r3,r5
 1836fc8:	20c6b03a 	or	r3,r4,r3
 1836fcc:	10c00305 	stb	r3,12(r2)
 1836fd0:	30ffffcc 	andi	r3,r6,65535
 1836fd4:	1806d23a 	srli	r3,r3,8
 1836fd8:	197fffcc 	andi	r5,r3,65535
 1836fdc:	10c00343 	ldbu	r3,13(r2)
 1836fe0:	1806703a 	and	r3,r3,zero
 1836fe4:	1809883a 	mov	r4,r3
 1836fe8:	2807883a 	mov	r3,r5
 1836fec:	20c6b03a 	or	r3,r4,r3
 1836ff0:	10c00345 	stb	r3,13(r2)
      }
      old_seg = next;
 1836ff4:	e0bfff17 	ldw	r2,-4(fp)
 1836ff8:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
 1836ffc:	e0bfff17 	ldw	r2,-4(fp)
 1837000:	10800017 	ldw	r2,0(r2)
 1837004:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
 1837008:	e13ffd17 	ldw	r4,-12(fp)
 183700c:	181d56c0 	call	181d56c <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 1837010:	e0bfff17 	ldw	r2,-4(fp)
 1837014:	10001826 	beq	r2,zero,1837078 <tcp_oos_insert_segment+0x1c0>
           TCP_SEQ_GEQ((seqno + cseg->len),
 1837018:	e0bffe17 	ldw	r2,-8(fp)
 183701c:	1080020b 	ldhu	r2,8(r2)
 1837020:	10ffffcc 	andi	r3,r2,65535
 1837024:	d0a81b17 	ldw	r2,-24468(gp)
 1837028:	1887883a 	add	r3,r3,r2
 183702c:	e0bfff17 	ldw	r2,-4(fp)
 1837030:	10800417 	ldw	r2,16(r2)
 1837034:	11000103 	ldbu	r4,4(r2)
 1837038:	11400143 	ldbu	r5,5(r2)
 183703c:	280a923a 	slli	r5,r5,8
 1837040:	2908b03a 	or	r4,r5,r4
 1837044:	11400183 	ldbu	r5,6(r2)
 1837048:	280a943a 	slli	r5,r5,16
 183704c:	2908b03a 	or	r4,r5,r4
 1837050:	108001c3 	ldbu	r2,7(r2)
 1837054:	1004963a 	slli	r2,r2,24
 1837058:	1104b03a 	or	r2,r2,r4
 183705c:	1009883a 	mov	r4,r2
 1837060:	e0bfff17 	ldw	r2,-4(fp)
 1837064:	1080020b 	ldhu	r2,8(r2)
 1837068:	10bfffcc 	andi	r2,r2,65535
 183706c:	2085883a 	add	r2,r4,r2
 1837070:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 1837074:	103faf0e 	bge	r2,zero,1836f34 <__ram_exceptions_end+0xff826af0>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 1837078:	e0bfff17 	ldw	r2,-4(fp)
 183707c:	10002d26 	beq	r2,zero,1837134 <tcp_oos_insert_segment+0x27c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 1837080:	e0bffe17 	ldw	r2,-8(fp)
 1837084:	1080020b 	ldhu	r2,8(r2)
 1837088:	10ffffcc 	andi	r3,r2,65535
 183708c:	d0a81b17 	ldw	r2,-24468(gp)
 1837090:	1887883a 	add	r3,r3,r2
 1837094:	e0bfff17 	ldw	r2,-4(fp)
 1837098:	10800417 	ldw	r2,16(r2)
 183709c:	11000103 	ldbu	r4,4(r2)
 18370a0:	11400143 	ldbu	r5,5(r2)
 18370a4:	280a923a 	slli	r5,r5,8
 18370a8:	2908b03a 	or	r4,r5,r4
 18370ac:	11400183 	ldbu	r5,6(r2)
 18370b0:	280a943a 	slli	r5,r5,16
 18370b4:	2908b03a 	or	r4,r5,r4
 18370b8:	108001c3 	ldbu	r2,7(r2)
 18370bc:	1004963a 	slli	r2,r2,24
 18370c0:	1104b03a 	or	r2,r2,r4
 18370c4:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 18370c8:	00801a0e 	bge	zero,r2,1837134 <tcp_oos_insert_segment+0x27c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 18370cc:	e0bfff17 	ldw	r2,-4(fp)
 18370d0:	10800417 	ldw	r2,16(r2)
 18370d4:	10c00103 	ldbu	r3,4(r2)
 18370d8:	11000143 	ldbu	r4,5(r2)
 18370dc:	2008923a 	slli	r4,r4,8
 18370e0:	20c6b03a 	or	r3,r4,r3
 18370e4:	11000183 	ldbu	r4,6(r2)
 18370e8:	2008943a 	slli	r4,r4,16
 18370ec:	20c6b03a 	or	r3,r4,r3
 18370f0:	108001c3 	ldbu	r2,7(r2)
 18370f4:	1004963a 	slli	r2,r2,24
 18370f8:	10c4b03a 	or	r2,r2,r3
 18370fc:	1007883a 	mov	r3,r2
 1837100:	d0a81b17 	ldw	r2,-24468(gp)
 1837104:	1885c83a 	sub	r2,r3,r2
 1837108:	1007883a 	mov	r3,r2
 183710c:	e0bffe17 	ldw	r2,-8(fp)
 1837110:	10c0020d 	sth	r3,8(r2)
      pbuf_realloc(cseg->p, cseg->len);
 1837114:	e0bffe17 	ldw	r2,-8(fp)
 1837118:	10c00117 	ldw	r3,4(r2)
 183711c:	e0bffe17 	ldw	r2,-8(fp)
 1837120:	1080020b 	ldhu	r2,8(r2)
 1837124:	10bfffcc 	andi	r2,r2,65535
 1837128:	100b883a 	mov	r5,r2
 183712c:	1809883a 	mov	r4,r3
 1837130:	181a9940 	call	181a994 <pbuf_realloc>
    }
  }
  cseg->next = next;
 1837134:	e0bffe17 	ldw	r2,-8(fp)
 1837138:	e0ffff17 	ldw	r3,-4(fp)
 183713c:	10c00015 	stw	r3,0(r2)
}
 1837140:	0001883a 	nop
 1837144:	e037883a 	mov	sp,fp
 1837148:	dfc00117 	ldw	ra,4(sp)
 183714c:	df000017 	ldw	fp,0(sp)
 1837150:	dec00204 	addi	sp,sp,8
 1837154:	f800283a 	ret

01837158 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 1837158:	defff204 	addi	sp,sp,-56
 183715c:	dfc00d15 	stw	ra,52(sp)
 1837160:	df000c15 	stw	fp,48(sp)
 1837164:	dc000b15 	stw	r16,44(sp)
 1837168:	df000c04 	addi	fp,sp,48
 183716c:	e13ffe15 	stw	r4,-8(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
 1837170:	e03ff915 	stw	zero,-28(fp)
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 1837174:	d0a81d03 	ldbu	r2,-24460(gp)
 1837178:	10803fcc 	andi	r2,r2,255
 183717c:	1080040c 	andi	r2,r2,16
 1837180:	1002ab26 	beq	r2,zero,1837c30 <tcp_receive+0xad8>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 1837184:	e0bffe17 	ldw	r2,-8(fp)
 1837188:	1080190b 	ldhu	r2,100(r2)
 183718c:	10ffffcc 	andi	r3,r2,65535
 1837190:	e0bffe17 	ldw	r2,-8(fp)
 1837194:	10801717 	ldw	r2,92(r2)
 1837198:	1885883a 	add	r2,r3,r2
 183719c:	e0bffa15 	stw	r2,-24(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 18371a0:	e0bffe17 	ldw	r2,-8(fp)
 18371a4:	10c01617 	ldw	r3,88(r2)
 18371a8:	d0a81b17 	ldw	r2,-24468(gp)
 18371ac:	1885c83a 	sub	r2,r3,r2
 18371b0:	10001816 	blt	r2,zero,1837214 <tcp_receive+0xbc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 18371b4:	e0bffe17 	ldw	r2,-8(fp)
 18371b8:	10c01617 	ldw	r3,88(r2)
 18371bc:	d0a81b17 	ldw	r2,-24468(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 18371c0:	1880051e 	bne	r3,r2,18371d8 <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 18371c4:	e0bffe17 	ldw	r2,-8(fp)
 18371c8:	10c01717 	ldw	r3,92(r2)
 18371cc:	d0a81c17 	ldw	r2,-24464(gp)
 18371d0:	1885c83a 	sub	r2,r3,r2
 18371d4:	10000f16 	blt	r2,zero,1837214 <tcp_receive+0xbc>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 18371d8:	e0bffe17 	ldw	r2,-8(fp)
 18371dc:	10c01717 	ldw	r3,92(r2)
 18371e0:	d0a81c17 	ldw	r2,-24464(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 18371e4:	18803f1e 	bne	r3,r2,18372e4 <tcp_receive+0x18c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 18371e8:	d0a81917 	ldw	r2,-24476(gp)
 18371ec:	10c00383 	ldbu	r3,14(r2)
 18371f0:	108003c3 	ldbu	r2,15(r2)
 18371f4:	1004923a 	slli	r2,r2,8
 18371f8:	10c4b03a 	or	r2,r2,r3
 18371fc:	1009883a 	mov	r4,r2
 1837200:	e0bffe17 	ldw	r2,-8(fp)
 1837204:	10c0190b 	ldhu	r3,100(r2)
 1837208:	20bfffcc 	andi	r2,r4,65535
 183720c:	18ffffcc 	andi	r3,r3,65535
 1837210:	1880342e 	bgeu	r3,r2,18372e4 <tcp_receive+0x18c>
      pcb->snd_wnd = tcphdr->wnd;
 1837214:	d0a81917 	ldw	r2,-24476(gp)
 1837218:	10c00383 	ldbu	r3,14(r2)
 183721c:	108003c3 	ldbu	r2,15(r2)
 1837220:	1004923a 	slli	r2,r2,8
 1837224:	10c4b03a 	or	r2,r2,r3
 1837228:	1007883a 	mov	r3,r2
 183722c:	e0bffe17 	ldw	r2,-8(fp)
 1837230:	10c0190d 	sth	r3,100(r2)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 1837234:	e0bffe17 	ldw	r2,-8(fp)
 1837238:	1100198b 	ldhu	r4,102(r2)
 183723c:	d0a81917 	ldw	r2,-24476(gp)
 1837240:	10c00383 	ldbu	r3,14(r2)
 1837244:	108003c3 	ldbu	r2,15(r2)
 1837248:	1004923a 	slli	r2,r2,8
 183724c:	10c4b03a 	or	r2,r2,r3
 1837250:	20ffffcc 	andi	r3,r4,65535
 1837254:	10bfffcc 	andi	r2,r2,65535
 1837258:	1880082e 	bgeu	r3,r2,183727c <tcp_receive+0x124>
        pcb->snd_wnd_max = tcphdr->wnd;
 183725c:	d0a81917 	ldw	r2,-24476(gp)
 1837260:	10c00383 	ldbu	r3,14(r2)
 1837264:	108003c3 	ldbu	r2,15(r2)
 1837268:	1004923a 	slli	r2,r2,8
 183726c:	10c4b03a 	or	r2,r2,r3
 1837270:	1007883a 	mov	r3,r2
 1837274:	e0bffe17 	ldw	r2,-8(fp)
 1837278:	10c0198d 	sth	r3,102(r2)
      }
      pcb->snd_wl1 = seqno;
 183727c:	d0e81b17 	ldw	r3,-24468(gp)
 1837280:	e0bffe17 	ldw	r2,-8(fp)
 1837284:	10c01615 	stw	r3,88(r2)
      pcb->snd_wl2 = ackno;
 1837288:	d0e81c17 	ldw	r3,-24464(gp)
 183728c:	e0bffe17 	ldw	r2,-8(fp)
 1837290:	10c01715 	stw	r3,92(r2)
      if (pcb->snd_wnd == 0) {
 1837294:	e0bffe17 	ldw	r2,-8(fp)
 1837298:	1080190b 	ldhu	r2,100(r2)
 183729c:	10bfffcc 	andi	r2,r2,65535
 18372a0:	10000a1e 	bne	r2,zero,18372cc <tcp_receive+0x174>
        if (pcb->persist_backoff == 0) {
 18372a4:	e0bffe17 	ldw	r2,-8(fp)
 18372a8:	10802843 	ldbu	r2,161(r2)
 18372ac:	10803fcc 	andi	r2,r2,255
 18372b0:	10000c1e 	bne	r2,zero,18372e4 <tcp_receive+0x18c>
          /* start persist timer */
          pcb->persist_cnt = 0;
 18372b4:	e0bffe17 	ldw	r2,-8(fp)
 18372b8:	10002805 	stb	zero,160(r2)
          pcb->persist_backoff = 1;
 18372bc:	e0bffe17 	ldw	r2,-8(fp)
 18372c0:	00c00044 	movi	r3,1
 18372c4:	10c02845 	stb	r3,161(r2)
 18372c8:	00000606 	br	18372e4 <tcp_receive+0x18c>
        }
      } else if (pcb->persist_backoff > 0) {
 18372cc:	e0bffe17 	ldw	r2,-8(fp)
 18372d0:	10802843 	ldbu	r2,161(r2)
 18372d4:	10803fcc 	andi	r2,r2,255
 18372d8:	10000226 	beq	r2,zero,18372e4 <tcp_receive+0x18c>
        /* stop persist timer */
          pcb->persist_backoff = 0;
 18372dc:	e0bffe17 	ldw	r2,-8(fp)
 18372e0:	10002845 	stb	zero,161(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 18372e4:	d0e81c17 	ldw	r3,-24464(gp)
 18372e8:	e0bffe17 	ldw	r2,-8(fp)
 18372ec:	10801317 	ldw	r2,76(r2)
 18372f0:	1885c83a 	sub	r2,r3,r2
 18372f4:	00804d16 	blt	zero,r2,183742c <tcp_receive+0x2d4>
      pcb->acked = 0;
 18372f8:	e0bffe17 	ldw	r2,-8(fp)
 18372fc:	10001a0d 	sth	zero,104(r2)
      /* Clause 2 */
      if (tcplen == 0) {
 1837300:	d0a81d8b 	ldhu	r2,-24458(gp)
 1837304:	10bfffcc 	andi	r2,r2,65535
 1837308:	1000431e 	bne	r2,zero,1837418 <tcp_receive+0x2c0>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 183730c:	e0bffe17 	ldw	r2,-8(fp)
 1837310:	10c01717 	ldw	r3,92(r2)
 1837314:	e0bffe17 	ldw	r2,-8(fp)
 1837318:	1080190b 	ldhu	r2,100(r2)
 183731c:	10bfffcc 	andi	r2,r2,65535
 1837320:	1887883a 	add	r3,r3,r2
 1837324:	e0bffa17 	ldw	r2,-24(fp)
 1837328:	18803b1e 	bne	r3,r2,1837418 <tcp_receive+0x2c0>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 183732c:	e0bffe17 	ldw	r2,-8(fp)
 1837330:	10800e0b 	ldhu	r2,56(r2)
 1837334:	10bfffcc 	andi	r2,r2,65535
 1837338:	10a0001c 	xori	r2,r2,32768
 183733c:	10a00004 	addi	r2,r2,-32768
 1837340:	10003516 	blt	r2,zero,1837418 <tcp_receive+0x2c0>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 1837344:	e0bffe17 	ldw	r2,-8(fp)
 1837348:	10c01317 	ldw	r3,76(r2)
 183734c:	d0a81c17 	ldw	r2,-24464(gp)
 1837350:	1880311e 	bne	r3,r2,1837418 <tcp_receive+0x2c0>
              found_dupack = 1;
 1837354:	00800044 	movi	r2,1
 1837358:	e0bff915 	stw	r2,-28(fp)
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 183735c:	e0bffe17 	ldw	r2,-8(fp)
 1837360:	108012c3 	ldbu	r2,75(r2)
 1837364:	10800044 	addi	r2,r2,1
 1837368:	1009883a 	mov	r4,r2
 183736c:	e0bffe17 	ldw	r2,-8(fp)
 1837370:	10c012c3 	ldbu	r3,75(r2)
 1837374:	20803fcc 	andi	r2,r4,255
 1837378:	18c03fcc 	andi	r3,r3,255
 183737c:	1880062e 	bgeu	r3,r2,1837398 <tcp_receive+0x240>
                ++pcb->dupacks;
 1837380:	e0bffe17 	ldw	r2,-8(fp)
 1837384:	108012c3 	ldbu	r2,75(r2)
 1837388:	10800044 	addi	r2,r2,1
 183738c:	1007883a 	mov	r3,r2
 1837390:	e0bffe17 	ldw	r2,-8(fp)
 1837394:	10c012c5 	stb	r3,75(r2)
              }
              if (pcb->dupacks > 3) {
 1837398:	e0bffe17 	ldw	r2,-8(fp)
 183739c:	108012c3 	ldbu	r2,75(r2)
 18373a0:	10803fcc 	andi	r2,r2,255
 18373a4:	10800130 	cmpltui	r2,r2,4
 18373a8:	1000141e 	bne	r2,zero,18373fc <tcp_receive+0x2a4>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 18373ac:	e0bffe17 	ldw	r2,-8(fp)
 18373b0:	10c0140b 	ldhu	r3,80(r2)
 18373b4:	e0bffe17 	ldw	r2,-8(fp)
 18373b8:	10800e8b 	ldhu	r2,58(r2)
 18373bc:	1885883a 	add	r2,r3,r2
 18373c0:	1009883a 	mov	r4,r2
 18373c4:	e0bffe17 	ldw	r2,-8(fp)
 18373c8:	10c0140b 	ldhu	r3,80(r2)
 18373cc:	20bfffcc 	andi	r2,r4,65535
 18373d0:	18ffffcc 	andi	r3,r3,65535
 18373d4:	1880102e 	bgeu	r3,r2,1837418 <tcp_receive+0x2c0>
                  pcb->cwnd += pcb->mss;
 18373d8:	e0bffe17 	ldw	r2,-8(fp)
 18373dc:	10c0140b 	ldhu	r3,80(r2)
 18373e0:	e0bffe17 	ldw	r2,-8(fp)
 18373e4:	10800e8b 	ldhu	r2,58(r2)
 18373e8:	1885883a 	add	r2,r3,r2
 18373ec:	1007883a 	mov	r3,r2
 18373f0:	e0bffe17 	ldw	r2,-8(fp)
 18373f4:	10c0140d 	sth	r3,80(r2)
 18373f8:	00000706 	br	1837418 <tcp_receive+0x2c0>
                }
              } else if (pcb->dupacks == 3) {
 18373fc:	e0bffe17 	ldw	r2,-8(fp)
 1837400:	108012c3 	ldbu	r2,75(r2)
 1837404:	10803fcc 	andi	r2,r2,255
 1837408:	108000d8 	cmpnei	r2,r2,3
 183740c:	1000021e 	bne	r2,zero,1837418 <tcp_receive+0x2c0>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 1837410:	e13ffe17 	ldw	r4,-8(fp)
 1837414:	18210900 	call	1821090 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 1837418:	e0bff917 	ldw	r2,-28(fp)
 183741c:	10015a1e 	bne	r2,zero,1837988 <tcp_receive+0x830>
        pcb->dupacks = 0;
 1837420:	e0bffe17 	ldw	r2,-8(fp)
 1837424:	100012c5 	stb	zero,75(r2)
 1837428:	00015706 	br	1837988 <tcp_receive+0x830>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 183742c:	d0e81c17 	ldw	r3,-24464(gp)
 1837430:	e0bffe17 	ldw	r2,-8(fp)
 1837434:	10801317 	ldw	r2,76(r2)
 1837438:	1885c83a 	sub	r2,r3,r2
 183743c:	10bfffc4 	addi	r2,r2,-1
 1837440:	10011416 	blt	r2,zero,1837894 <tcp_receive+0x73c>
 1837444:	d0e81c17 	ldw	r3,-24464(gp)
 1837448:	e0bffe17 	ldw	r2,-8(fp)
 183744c:	10801517 	ldw	r2,84(r2)
 1837450:	1885c83a 	sub	r2,r3,r2
 1837454:	00810f16 	blt	zero,r2,1837894 <tcp_receive+0x73c>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 1837458:	e0bffe17 	ldw	r2,-8(fp)
 183745c:	10800883 	ldbu	r2,34(r2)
 1837460:	10803fcc 	andi	r2,r2,255
 1837464:	1080010c 	andi	r2,r2,4
 1837468:	10000b26 	beq	r2,zero,1837498 <tcp_receive+0x340>
        pcb->flags &= ~TF_INFR;
 183746c:	e0bffe17 	ldw	r2,-8(fp)
 1837470:	10c00883 	ldbu	r3,34(r2)
 1837474:	00bffec4 	movi	r2,-5
 1837478:	1884703a 	and	r2,r3,r2
 183747c:	1007883a 	mov	r3,r2
 1837480:	e0bffe17 	ldw	r2,-8(fp)
 1837484:	10c00885 	stb	r3,34(r2)
        pcb->cwnd = pcb->ssthresh;
 1837488:	e0bffe17 	ldw	r2,-8(fp)
 183748c:	10c0148b 	ldhu	r3,82(r2)
 1837490:	e0bffe17 	ldw	r2,-8(fp)
 1837494:	10c0140d 	sth	r3,80(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 1837498:	e0bffe17 	ldw	r2,-8(fp)
 183749c:	10001285 	stb	zero,74(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 18374a0:	e0bffe17 	ldw	r2,-8(fp)
 18374a4:	1080110b 	ldhu	r2,68(r2)
 18374a8:	10bfffcc 	andi	r2,r2,65535
 18374ac:	10a0001c 	xori	r2,r2,32768
 18374b0:	10a00004 	addi	r2,r2,-32768
 18374b4:	1005d0fa 	srai	r2,r2,3
 18374b8:	1007883a 	mov	r3,r2
 18374bc:	e0bffe17 	ldw	r2,-8(fp)
 18374c0:	1080118b 	ldhu	r2,70(r2)
 18374c4:	1885883a 	add	r2,r3,r2
 18374c8:	1007883a 	mov	r3,r2
 18374cc:	e0bffe17 	ldw	r2,-8(fp)
 18374d0:	10c0120d 	sth	r3,72(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 18374d4:	d0a81c17 	ldw	r2,-24464(gp)
 18374d8:	1007883a 	mov	r3,r2
 18374dc:	e0bffe17 	ldw	r2,-8(fp)
 18374e0:	10801317 	ldw	r2,76(r2)
 18374e4:	1885c83a 	sub	r2,r3,r2
 18374e8:	1007883a 	mov	r3,r2
 18374ec:	e0bffe17 	ldw	r2,-8(fp)
 18374f0:	10c01a0d 	sth	r3,104(r2)

      pcb->snd_buf += pcb->acked;
 18374f4:	e0bffe17 	ldw	r2,-8(fp)
 18374f8:	10c01a8b 	ldhu	r3,106(r2)
 18374fc:	e0bffe17 	ldw	r2,-8(fp)
 1837500:	10801a0b 	ldhu	r2,104(r2)
 1837504:	1885883a 	add	r2,r3,r2
 1837508:	1007883a 	mov	r3,r2
 183750c:	e0bffe17 	ldw	r2,-8(fp)
 1837510:	10c01a8d 	sth	r3,106(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 1837514:	e0bffe17 	ldw	r2,-8(fp)
 1837518:	100012c5 	stb	zero,75(r2)
      pcb->lastack = ackno;
 183751c:	d0e81c17 	ldw	r3,-24464(gp)
 1837520:	e0bffe17 	ldw	r2,-8(fp)
 1837524:	10c01315 	stw	r3,76(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 1837528:	e0bffe17 	ldw	r2,-8(fp)
 183752c:	10800617 	ldw	r2,24(r2)
 1837530:	10800130 	cmpltui	r2,r2,4
 1837534:	10006a1e 	bne	r2,zero,18376e0 <tcp_receive+0x588>
        if (pcb->cwnd < pcb->ssthresh) {
 1837538:	e0bffe17 	ldw	r2,-8(fp)
 183753c:	10c0140b 	ldhu	r3,80(r2)
 1837540:	e0bffe17 	ldw	r2,-8(fp)
 1837544:	1080148b 	ldhu	r2,82(r2)
 1837548:	18ffffcc 	andi	r3,r3,65535
 183754c:	10bfffcc 	andi	r2,r2,65535
 1837550:	1880142e 	bgeu	r3,r2,18375a4 <tcp_receive+0x44c>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 1837554:	e0bffe17 	ldw	r2,-8(fp)
 1837558:	10c0140b 	ldhu	r3,80(r2)
 183755c:	e0bffe17 	ldw	r2,-8(fp)
 1837560:	10800e8b 	ldhu	r2,58(r2)
 1837564:	1885883a 	add	r2,r3,r2
 1837568:	1009883a 	mov	r4,r2
 183756c:	e0bffe17 	ldw	r2,-8(fp)
 1837570:	10c0140b 	ldhu	r3,80(r2)
 1837574:	20bfffcc 	andi	r2,r4,65535
 1837578:	18ffffcc 	andi	r3,r3,65535
 183757c:	1880582e 	bgeu	r3,r2,18376e0 <tcp_receive+0x588>
            pcb->cwnd += pcb->mss;
 1837580:	e0bffe17 	ldw	r2,-8(fp)
 1837584:	10c0140b 	ldhu	r3,80(r2)
 1837588:	e0bffe17 	ldw	r2,-8(fp)
 183758c:	10800e8b 	ldhu	r2,58(r2)
 1837590:	1885883a 	add	r2,r3,r2
 1837594:	1007883a 	mov	r3,r2
 1837598:	e0bffe17 	ldw	r2,-8(fp)
 183759c:	10c0140d 	sth	r3,80(r2)
 18375a0:	00004f06 	br	18376e0 <tcp_receive+0x588>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 18375a4:	e0bffe17 	ldw	r2,-8(fp)
 18375a8:	1400140b 	ldhu	r16,80(r2)
 18375ac:	e0bffe17 	ldw	r2,-8(fp)
 18375b0:	10800e8b 	ldhu	r2,58(r2)
 18375b4:	10ffffcc 	andi	r3,r2,65535
 18375b8:	e0bffe17 	ldw	r2,-8(fp)
 18375bc:	10800e8b 	ldhu	r2,58(r2)
 18375c0:	10bfffcc 	andi	r2,r2,65535
 18375c4:	1887383a 	mul	r3,r3,r2
 18375c8:	e0bffe17 	ldw	r2,-8(fp)
 18375cc:	1080140b 	ldhu	r2,80(r2)
 18375d0:	10bfffcc 	andi	r2,r2,65535
 18375d4:	100b883a 	mov	r5,r2
 18375d8:	1809883a 	mov	r4,r3
 18375dc:	180ac180 	call	180ac18 <__divsi3>
 18375e0:	8085883a 	add	r2,r16,r2
 18375e4:	e0bffb0d 	sth	r2,-20(fp)
          if (new_cwnd > pcb->cwnd) {
 18375e8:	e0bffe17 	ldw	r2,-8(fp)
 18375ec:	1080140b 	ldhu	r2,80(r2)
 18375f0:	10ffffcc 	andi	r3,r2,65535
 18375f4:	e0bffb0b 	ldhu	r2,-20(fp)
 18375f8:	1880392e 	bgeu	r3,r2,18376e0 <tcp_receive+0x588>
            pcb->cwnd = new_cwnd;
 18375fc:	e0bffe17 	ldw	r2,-8(fp)
 1837600:	e0fffb0b 	ldhu	r3,-20(fp)
 1837604:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 1837608:	00003506 	br	18376e0 <tcp_receive+0x588>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 183760c:	e0bffe17 	ldw	r2,-8(fp)
 1837610:	10801d17 	ldw	r2,116(r2)
 1837614:	e0bff415 	stw	r2,-48(fp)
        pcb->unacked = pcb->unacked->next;
 1837618:	e0bffe17 	ldw	r2,-8(fp)
 183761c:	10801d17 	ldw	r2,116(r2)
 1837620:	10c00017 	ldw	r3,0(r2)
 1837624:	e0bffe17 	ldw	r2,-8(fp)
 1837628:	10c01d15 	stw	r3,116(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 183762c:	e0bffe17 	ldw	r2,-8(fp)
 1837630:	10801a0b 	ldhu	r2,104(r2)
 1837634:	10bfffcc 	andi	r2,r2,65535
 1837638:	10001b26 	beq	r2,zero,18376a8 <tcp_receive+0x550>
 183763c:	e0bff417 	ldw	r2,-48(fp)
 1837640:	10800417 	ldw	r2,16(r2)
 1837644:	10c00303 	ldbu	r3,12(r2)
 1837648:	10800343 	ldbu	r2,13(r2)
 183764c:	1004923a 	slli	r2,r2,8
 1837650:	10c4b03a 	or	r2,r2,r3
 1837654:	10bfffcc 	andi	r2,r2,65535
 1837658:	1004d23a 	srli	r2,r2,8
 183765c:	10ffffcc 	andi	r3,r2,65535
 1837660:	e0bff417 	ldw	r2,-48(fp)
 1837664:	10800417 	ldw	r2,16(r2)
 1837668:	11000303 	ldbu	r4,12(r2)
 183766c:	10800343 	ldbu	r2,13(r2)
 1837670:	1004923a 	slli	r2,r2,8
 1837674:	1104b03a 	or	r2,r2,r4
 1837678:	10bfffcc 	andi	r2,r2,65535
 183767c:	1004923a 	slli	r2,r2,8
 1837680:	10bfffcc 	andi	r2,r2,65535
 1837684:	1884b03a 	or	r2,r3,r2
 1837688:	1080004c 	andi	r2,r2,1
 183768c:	10000626 	beq	r2,zero,18376a8 <tcp_receive+0x550>
          pcb->acked--;
 1837690:	e0bffe17 	ldw	r2,-8(fp)
 1837694:	10801a0b 	ldhu	r2,104(r2)
 1837698:	10bfffc4 	addi	r2,r2,-1
 183769c:	1007883a 	mov	r3,r2
 18376a0:	e0bffe17 	ldw	r2,-8(fp)
 18376a4:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 18376a8:	e0bff417 	ldw	r2,-48(fp)
 18376ac:	10800117 	ldw	r2,4(r2)
 18376b0:	1009883a 	mov	r4,r2
 18376b4:	181ade80 	call	181ade8 <pbuf_clen>
 18376b8:	1009883a 	mov	r4,r2
 18376bc:	e0bffe17 	ldw	r2,-8(fp)
 18376c0:	10c01b0b 	ldhu	r3,108(r2)
 18376c4:	20803fcc 	andi	r2,r4,255
 18376c8:	1885c83a 	sub	r2,r3,r2
 18376cc:	1007883a 	mov	r3,r2
 18376d0:	e0bffe17 	ldw	r2,-8(fp)
 18376d4:	10c01b0d 	sth	r3,108(r2)
        tcp_seg_free(next);
 18376d8:	e13ff417 	ldw	r4,-48(fp)
 18376dc:	181d56c0 	call	181d56c <tcp_seg_free>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 18376e0:	e0bffe17 	ldw	r2,-8(fp)
 18376e4:	10801d17 	ldw	r2,116(r2)
 18376e8:	10005e26 	beq	r2,zero,1837864 <tcp_receive+0x70c>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 18376ec:	e0bffe17 	ldw	r2,-8(fp)
 18376f0:	10801d17 	ldw	r2,116(r2)
 18376f4:	10800417 	ldw	r2,16(r2)
 18376f8:	10c00103 	ldbu	r3,4(r2)
 18376fc:	11000143 	ldbu	r4,5(r2)
 1837700:	2008923a 	slli	r4,r4,8
 1837704:	20c6b03a 	or	r3,r4,r3
 1837708:	11000183 	ldbu	r4,6(r2)
 183770c:	2008943a 	slli	r4,r4,16
 1837710:	20c6b03a 	or	r3,r4,r3
 1837714:	108001c3 	ldbu	r2,7(r2)
 1837718:	1004963a 	slli	r2,r2,24
 183771c:	10c4b03a 	or	r2,r2,r3
 1837720:	1006d63a 	srli	r3,r2,24
 1837724:	e0bffe17 	ldw	r2,-8(fp)
 1837728:	10801d17 	ldw	r2,116(r2)
 183772c:	10800417 	ldw	r2,16(r2)
 1837730:	11000103 	ldbu	r4,4(r2)
 1837734:	11400143 	ldbu	r5,5(r2)
 1837738:	280a923a 	slli	r5,r5,8
 183773c:	2908b03a 	or	r4,r5,r4
 1837740:	11400183 	ldbu	r5,6(r2)
 1837744:	280a943a 	slli	r5,r5,16
 1837748:	2908b03a 	or	r4,r5,r4
 183774c:	108001c3 	ldbu	r2,7(r2)
 1837750:	1004963a 	slli	r2,r2,24
 1837754:	1104b03a 	or	r2,r2,r4
 1837758:	1004d23a 	srli	r2,r2,8
 183775c:	10bfc00c 	andi	r2,r2,65280
 1837760:	1886b03a 	or	r3,r3,r2
 1837764:	e0bffe17 	ldw	r2,-8(fp)
 1837768:	10801d17 	ldw	r2,116(r2)
 183776c:	10800417 	ldw	r2,16(r2)
 1837770:	11000103 	ldbu	r4,4(r2)
 1837774:	11400143 	ldbu	r5,5(r2)
 1837778:	280a923a 	slli	r5,r5,8
 183777c:	2908b03a 	or	r4,r5,r4
 1837780:	11400183 	ldbu	r5,6(r2)
 1837784:	280a943a 	slli	r5,r5,16
 1837788:	2908b03a 	or	r4,r5,r4
 183778c:	108001c3 	ldbu	r2,7(r2)
 1837790:	1004963a 	slli	r2,r2,24
 1837794:	1104b03a 	or	r2,r2,r4
 1837798:	10bfc00c 	andi	r2,r2,65280
 183779c:	1004923a 	slli	r2,r2,8
 18377a0:	1886b03a 	or	r3,r3,r2
 18377a4:	e0bffe17 	ldw	r2,-8(fp)
 18377a8:	10801d17 	ldw	r2,116(r2)
 18377ac:	10800417 	ldw	r2,16(r2)
 18377b0:	11000103 	ldbu	r4,4(r2)
 18377b4:	11400143 	ldbu	r5,5(r2)
 18377b8:	280a923a 	slli	r5,r5,8
 18377bc:	2908b03a 	or	r4,r5,r4
 18377c0:	11400183 	ldbu	r5,6(r2)
 18377c4:	280a943a 	slli	r5,r5,16
 18377c8:	2908b03a 	or	r4,r5,r4
 18377cc:	108001c3 	ldbu	r2,7(r2)
 18377d0:	1004963a 	slli	r2,r2,24
 18377d4:	1104b03a 	or	r2,r2,r4
 18377d8:	1004963a 	slli	r2,r2,24
 18377dc:	1886b03a 	or	r3,r3,r2
 18377e0:	e0bffe17 	ldw	r2,-8(fp)
 18377e4:	10801d17 	ldw	r2,116(r2)
 18377e8:	1080020b 	ldhu	r2,8(r2)
 18377ec:	113fffcc 	andi	r4,r2,65535
 18377f0:	e0bffe17 	ldw	r2,-8(fp)
 18377f4:	10801d17 	ldw	r2,116(r2)
 18377f8:	10800417 	ldw	r2,16(r2)
 18377fc:	11400303 	ldbu	r5,12(r2)
 1837800:	10800343 	ldbu	r2,13(r2)
 1837804:	1004923a 	slli	r2,r2,8
 1837808:	1144b03a 	or	r2,r2,r5
 183780c:	10bfffcc 	andi	r2,r2,65535
 1837810:	1004d23a 	srli	r2,r2,8
 1837814:	117fffcc 	andi	r5,r2,65535
 1837818:	e0bffe17 	ldw	r2,-8(fp)
 183781c:	10801d17 	ldw	r2,116(r2)
 1837820:	10800417 	ldw	r2,16(r2)
 1837824:	11800303 	ldbu	r6,12(r2)
 1837828:	10800343 	ldbu	r2,13(r2)
 183782c:	1004923a 	slli	r2,r2,8
 1837830:	1184b03a 	or	r2,r2,r6
 1837834:	10bfffcc 	andi	r2,r2,65535
 1837838:	1004923a 	slli	r2,r2,8
 183783c:	10bfffcc 	andi	r2,r2,65535
 1837840:	2884b03a 	or	r2,r5,r2
 1837844:	108000cc 	andi	r2,r2,3
 1837848:	1004c03a 	cmpne	r2,r2,zero
 183784c:	10803fcc 	andi	r2,r2,255
 1837850:	2085883a 	add	r2,r4,r2
 1837854:	1887883a 	add	r3,r3,r2
 1837858:	d0a81c17 	ldw	r2,-24464(gp)
 183785c:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 1837860:	00bf6a0e 	bge	zero,r2,183760c <__ram_exceptions_end+0xff8271c8>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 1837864:	e0bffe17 	ldw	r2,-8(fp)
 1837868:	10801d17 	ldw	r2,116(r2)
 183786c:	1000041e 	bne	r2,zero,1837880 <tcp_receive+0x728>
        pcb->rtime = -1;
 1837870:	e0bffe17 	ldw	r2,-8(fp)
 1837874:	00ffffc4 	movi	r3,-1
 1837878:	10c00e0d 	sth	r3,56(r2)
 183787c:	00000206 	br	1837888 <tcp_receive+0x730>
      else
        pcb->rtime = 0;
 1837880:	e0bffe17 	ldw	r2,-8(fp)
 1837884:	10000e0d 	sth	zero,56(r2)

      pcb->polltmr = 0;
 1837888:	e0bffe17 	ldw	r2,-8(fp)
 183788c:	100008c5 	stb	zero,35(r2)
 1837890:	00000206 	br	183789c <tcp_receive+0x744>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 1837894:	e0bffe17 	ldw	r2,-8(fp)
 1837898:	10001a0d 	sth	zero,104(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 183789c:	00003a06 	br	1837988 <tcp_receive+0x830>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 18378a0:	e0bffe17 	ldw	r2,-8(fp)
 18378a4:	10801c17 	ldw	r2,112(r2)
 18378a8:	e0bff415 	stw	r2,-48(fp)
      pcb->unsent = pcb->unsent->next;
 18378ac:	e0bffe17 	ldw	r2,-8(fp)
 18378b0:	10801c17 	ldw	r2,112(r2)
 18378b4:	10c00017 	ldw	r3,0(r2)
 18378b8:	e0bffe17 	ldw	r2,-8(fp)
 18378bc:	10c01c15 	stw	r3,112(r2)
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 18378c0:	e0bffe17 	ldw	r2,-8(fp)
 18378c4:	10801c17 	ldw	r2,112(r2)
 18378c8:	1000021e 	bne	r2,zero,18378d4 <tcp_receive+0x77c>
        pcb->unsent_oversize = 0;
 18378cc:	e0bffe17 	ldw	r2,-8(fp)
 18378d0:	10001b8d 	sth	zero,110(r2)
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 18378d4:	e0bffe17 	ldw	r2,-8(fp)
 18378d8:	10801a0b 	ldhu	r2,104(r2)
 18378dc:	10bfffcc 	andi	r2,r2,65535
 18378e0:	10001b26 	beq	r2,zero,1837950 <tcp_receive+0x7f8>
 18378e4:	e0bff417 	ldw	r2,-48(fp)
 18378e8:	10800417 	ldw	r2,16(r2)
 18378ec:	10c00303 	ldbu	r3,12(r2)
 18378f0:	10800343 	ldbu	r2,13(r2)
 18378f4:	1004923a 	slli	r2,r2,8
 18378f8:	10c4b03a 	or	r2,r2,r3
 18378fc:	10bfffcc 	andi	r2,r2,65535
 1837900:	1004d23a 	srli	r2,r2,8
 1837904:	10ffffcc 	andi	r3,r2,65535
 1837908:	e0bff417 	ldw	r2,-48(fp)
 183790c:	10800417 	ldw	r2,16(r2)
 1837910:	11000303 	ldbu	r4,12(r2)
 1837914:	10800343 	ldbu	r2,13(r2)
 1837918:	1004923a 	slli	r2,r2,8
 183791c:	1104b03a 	or	r2,r2,r4
 1837920:	10bfffcc 	andi	r2,r2,65535
 1837924:	1004923a 	slli	r2,r2,8
 1837928:	10bfffcc 	andi	r2,r2,65535
 183792c:	1884b03a 	or	r2,r3,r2
 1837930:	1080004c 	andi	r2,r2,1
 1837934:	10000626 	beq	r2,zero,1837950 <tcp_receive+0x7f8>
        pcb->acked--;
 1837938:	e0bffe17 	ldw	r2,-8(fp)
 183793c:	10801a0b 	ldhu	r2,104(r2)
 1837940:	10bfffc4 	addi	r2,r2,-1
 1837944:	1007883a 	mov	r3,r2
 1837948:	e0bffe17 	ldw	r2,-8(fp)
 183794c:	10c01a0d 	sth	r3,104(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 1837950:	e0bff417 	ldw	r2,-48(fp)
 1837954:	10800117 	ldw	r2,4(r2)
 1837958:	1009883a 	mov	r4,r2
 183795c:	181ade80 	call	181ade8 <pbuf_clen>
 1837960:	1009883a 	mov	r4,r2
 1837964:	e0bffe17 	ldw	r2,-8(fp)
 1837968:	10c01b0b 	ldhu	r3,108(r2)
 183796c:	20803fcc 	andi	r2,r4,255
 1837970:	1885c83a 	sub	r2,r3,r2
 1837974:	1007883a 	mov	r3,r2
 1837978:	e0bffe17 	ldw	r2,-8(fp)
 183797c:	10c01b0d 	sth	r3,108(r2)
      tcp_seg_free(next);
 1837980:	e13ff417 	ldw	r4,-48(fp)
 1837984:	181d56c0 	call	181d56c <tcp_seg_free>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 1837988:	e0bffe17 	ldw	r2,-8(fp)
 183798c:	10801c17 	ldw	r2,112(r2)
 1837990:	10006326 	beq	r2,zero,1837b20 <tcp_receive+0x9c8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 1837994:	d0e81c17 	ldw	r3,-24464(gp)
 1837998:	e0bffe17 	ldw	r2,-8(fp)
 183799c:	10801c17 	ldw	r2,112(r2)
 18379a0:	10800417 	ldw	r2,16(r2)
 18379a4:	11000103 	ldbu	r4,4(r2)
 18379a8:	11400143 	ldbu	r5,5(r2)
 18379ac:	280a923a 	slli	r5,r5,8
 18379b0:	2908b03a 	or	r4,r5,r4
 18379b4:	11400183 	ldbu	r5,6(r2)
 18379b8:	280a943a 	slli	r5,r5,16
 18379bc:	2908b03a 	or	r4,r5,r4
 18379c0:	108001c3 	ldbu	r2,7(r2)
 18379c4:	1004963a 	slli	r2,r2,24
 18379c8:	1104b03a 	or	r2,r2,r4
 18379cc:	1008d63a 	srli	r4,r2,24
 18379d0:	e0bffe17 	ldw	r2,-8(fp)
 18379d4:	10801c17 	ldw	r2,112(r2)
 18379d8:	10800417 	ldw	r2,16(r2)
 18379dc:	11400103 	ldbu	r5,4(r2)
 18379e0:	11800143 	ldbu	r6,5(r2)
 18379e4:	300c923a 	slli	r6,r6,8
 18379e8:	314ab03a 	or	r5,r6,r5
 18379ec:	11800183 	ldbu	r6,6(r2)
 18379f0:	300c943a 	slli	r6,r6,16
 18379f4:	314ab03a 	or	r5,r6,r5
 18379f8:	108001c3 	ldbu	r2,7(r2)
 18379fc:	1004963a 	slli	r2,r2,24
 1837a00:	1144b03a 	or	r2,r2,r5
 1837a04:	1004d23a 	srli	r2,r2,8
 1837a08:	10bfc00c 	andi	r2,r2,65280
 1837a0c:	2088b03a 	or	r4,r4,r2
 1837a10:	e0bffe17 	ldw	r2,-8(fp)
 1837a14:	10801c17 	ldw	r2,112(r2)
 1837a18:	10800417 	ldw	r2,16(r2)
 1837a1c:	11400103 	ldbu	r5,4(r2)
 1837a20:	11800143 	ldbu	r6,5(r2)
 1837a24:	300c923a 	slli	r6,r6,8
 1837a28:	314ab03a 	or	r5,r6,r5
 1837a2c:	11800183 	ldbu	r6,6(r2)
 1837a30:	300c943a 	slli	r6,r6,16
 1837a34:	314ab03a 	or	r5,r6,r5
 1837a38:	108001c3 	ldbu	r2,7(r2)
 1837a3c:	1004963a 	slli	r2,r2,24
 1837a40:	1144b03a 	or	r2,r2,r5
 1837a44:	10bfc00c 	andi	r2,r2,65280
 1837a48:	1004923a 	slli	r2,r2,8
 1837a4c:	2088b03a 	or	r4,r4,r2
 1837a50:	e0bffe17 	ldw	r2,-8(fp)
 1837a54:	10801c17 	ldw	r2,112(r2)
 1837a58:	10800417 	ldw	r2,16(r2)
 1837a5c:	11400103 	ldbu	r5,4(r2)
 1837a60:	11800143 	ldbu	r6,5(r2)
 1837a64:	300c923a 	slli	r6,r6,8
 1837a68:	314ab03a 	or	r5,r6,r5
 1837a6c:	11800183 	ldbu	r6,6(r2)
 1837a70:	300c943a 	slli	r6,r6,16
 1837a74:	314ab03a 	or	r5,r6,r5
 1837a78:	108001c3 	ldbu	r2,7(r2)
 1837a7c:	1004963a 	slli	r2,r2,24
 1837a80:	1144b03a 	or	r2,r2,r5
 1837a84:	1004963a 	slli	r2,r2,24
 1837a88:	2088b03a 	or	r4,r4,r2
 1837a8c:	e0bffe17 	ldw	r2,-8(fp)
 1837a90:	10801c17 	ldw	r2,112(r2)
 1837a94:	1080020b 	ldhu	r2,8(r2)
 1837a98:	117fffcc 	andi	r5,r2,65535
 1837a9c:	e0bffe17 	ldw	r2,-8(fp)
 1837aa0:	10801c17 	ldw	r2,112(r2)
 1837aa4:	10800417 	ldw	r2,16(r2)
 1837aa8:	11800303 	ldbu	r6,12(r2)
 1837aac:	10800343 	ldbu	r2,13(r2)
 1837ab0:	1004923a 	slli	r2,r2,8
 1837ab4:	1184b03a 	or	r2,r2,r6
 1837ab8:	10bfffcc 	andi	r2,r2,65535
 1837abc:	1004d23a 	srli	r2,r2,8
 1837ac0:	11bfffcc 	andi	r6,r2,65535
 1837ac4:	e0bffe17 	ldw	r2,-8(fp)
 1837ac8:	10801c17 	ldw	r2,112(r2)
 1837acc:	10800417 	ldw	r2,16(r2)
 1837ad0:	11c00303 	ldbu	r7,12(r2)
 1837ad4:	10800343 	ldbu	r2,13(r2)
 1837ad8:	1004923a 	slli	r2,r2,8
 1837adc:	11c4b03a 	or	r2,r2,r7
 1837ae0:	10bfffcc 	andi	r2,r2,65535
 1837ae4:	1004923a 	slli	r2,r2,8
 1837ae8:	10bfffcc 	andi	r2,r2,65535
 1837aec:	3084b03a 	or	r2,r6,r2
 1837af0:	108000cc 	andi	r2,r2,3
 1837af4:	1004c03a 	cmpne	r2,r2,zero
 1837af8:	10803fcc 	andi	r2,r2,255
 1837afc:	2885883a 	add	r2,r5,r2
 1837b00:	2085883a 	add	r2,r4,r2
 1837b04:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 1837b08:	10000516 	blt	r2,zero,1837b20 <tcp_receive+0x9c8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 1837b0c:	d0e81c17 	ldw	r3,-24464(gp)
 1837b10:	e0bffe17 	ldw	r2,-8(fp)
 1837b14:	10801517 	ldw	r2,84(r2)
 1837b18:	1885c83a 	sub	r2,r3,r2
 1837b1c:	00bf600e 	bge	zero,r2,18378a0 <__ram_exceptions_end+0xff82745c>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 1837b20:	e0bffe17 	ldw	r2,-8(fp)
 1837b24:	10800f17 	ldw	r2,60(r2)
 1837b28:	10004126 	beq	r2,zero,1837c30 <tcp_receive+0xad8>
 1837b2c:	e0bffe17 	ldw	r2,-8(fp)
 1837b30:	10c01017 	ldw	r3,64(r2)
 1837b34:	d0a81c17 	ldw	r2,-24464(gp)
 1837b38:	1885c83a 	sub	r2,r3,r2
 1837b3c:	10003c0e 	bge	r2,zero,1837c30 <tcp_receive+0xad8>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 1837b40:	d0a7f817 	ldw	r2,-24608(gp)
 1837b44:	1007883a 	mov	r3,r2
 1837b48:	e0bffe17 	ldw	r2,-8(fp)
 1837b4c:	10800f17 	ldw	r2,60(r2)
 1837b50:	1885c83a 	sub	r2,r3,r2
 1837b54:	e0bff80d 	sth	r2,-32(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 1837b58:	e0bff80b 	ldhu	r2,-32(fp)
 1837b5c:	e0fffe17 	ldw	r3,-8(fp)
 1837b60:	18c0110b 	ldhu	r3,68(r3)
 1837b64:	18ffffcc 	andi	r3,r3,65535
 1837b68:	18e0001c 	xori	r3,r3,32768
 1837b6c:	18e00004 	addi	r3,r3,-32768
 1837b70:	1807d0fa 	srai	r3,r3,3
 1837b74:	10c5c83a 	sub	r2,r2,r3
 1837b78:	e0bff80d 	sth	r2,-32(fp)
      pcb->sa += m;
 1837b7c:	e0bffe17 	ldw	r2,-8(fp)
 1837b80:	1080110b 	ldhu	r2,68(r2)
 1837b84:	1007883a 	mov	r3,r2
 1837b88:	e0bff80b 	ldhu	r2,-32(fp)
 1837b8c:	1885883a 	add	r2,r3,r2
 1837b90:	1007883a 	mov	r3,r2
 1837b94:	e0bffe17 	ldw	r2,-8(fp)
 1837b98:	10c0110d 	sth	r3,68(r2)
      if (m < 0) {
 1837b9c:	e0bff80f 	ldh	r2,-32(fp)
 1837ba0:	1000030e 	bge	r2,zero,1837bb0 <tcp_receive+0xa58>
        m = -m;
 1837ba4:	e0bff80b 	ldhu	r2,-32(fp)
 1837ba8:	0085c83a 	sub	r2,zero,r2
 1837bac:	e0bff80d 	sth	r2,-32(fp)
      }
      m = m - (pcb->sv >> 2);
 1837bb0:	e0bff80b 	ldhu	r2,-32(fp)
 1837bb4:	e0fffe17 	ldw	r3,-8(fp)
 1837bb8:	18c0118b 	ldhu	r3,70(r3)
 1837bbc:	18ffffcc 	andi	r3,r3,65535
 1837bc0:	18e0001c 	xori	r3,r3,32768
 1837bc4:	18e00004 	addi	r3,r3,-32768
 1837bc8:	1807d0ba 	srai	r3,r3,2
 1837bcc:	10c5c83a 	sub	r2,r2,r3
 1837bd0:	e0bff80d 	sth	r2,-32(fp)
      pcb->sv += m;
 1837bd4:	e0bffe17 	ldw	r2,-8(fp)
 1837bd8:	1080118b 	ldhu	r2,70(r2)
 1837bdc:	1007883a 	mov	r3,r2
 1837be0:	e0bff80b 	ldhu	r2,-32(fp)
 1837be4:	1885883a 	add	r2,r3,r2
 1837be8:	1007883a 	mov	r3,r2
 1837bec:	e0bffe17 	ldw	r2,-8(fp)
 1837bf0:	10c0118d 	sth	r3,70(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 1837bf4:	e0bffe17 	ldw	r2,-8(fp)
 1837bf8:	1080110b 	ldhu	r2,68(r2)
 1837bfc:	10bfffcc 	andi	r2,r2,65535
 1837c00:	10a0001c 	xori	r2,r2,32768
 1837c04:	10a00004 	addi	r2,r2,-32768
 1837c08:	1005d0fa 	srai	r2,r2,3
 1837c0c:	1007883a 	mov	r3,r2
 1837c10:	e0bffe17 	ldw	r2,-8(fp)
 1837c14:	1080118b 	ldhu	r2,70(r2)
 1837c18:	1885883a 	add	r2,r3,r2
 1837c1c:	1007883a 	mov	r3,r2
 1837c20:	e0bffe17 	ldw	r2,-8(fp)
 1837c24:	10c0120d 	sth	r3,72(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 1837c28:	e0bffe17 	ldw	r2,-8(fp)
 1837c2c:	10000f15 	stw	zero,60(r2)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 1837c30:	d0a81d8b 	ldhu	r2,-24458(gp)
 1837c34:	10bfffcc 	andi	r2,r2,65535
 1837c38:	10052726 	beq	r2,zero,18390d8 <tcp_receive+0x1f80>
 1837c3c:	e0bffe17 	ldw	r2,-8(fp)
 1837c40:	10800617 	ldw	r2,24(r2)
 1837c44:	108001e8 	cmpgeui	r2,r2,7
 1837c48:	1005231e 	bne	r2,zero,18390d8 <tcp_receive+0x1f80>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 1837c4c:	e0bffe17 	ldw	r2,-8(fp)
 1837c50:	10c00b17 	ldw	r3,44(r2)
 1837c54:	d0a81b17 	ldw	r2,-24468(gp)
 1837c58:	1885c83a 	sub	r2,r3,r2
 1837c5c:	10bfffc4 	addi	r2,r2,-1
 1837c60:	10007b16 	blt	r2,zero,1837e50 <tcp_receive+0xcf8>
 1837c64:	e0bffe17 	ldw	r2,-8(fp)
 1837c68:	10c00b17 	ldw	r3,44(r2)
 1837c6c:	d0a81d8b 	ldhu	r2,-24458(gp)
 1837c70:	113fffcc 	andi	r4,r2,65535
 1837c74:	d0a81b17 	ldw	r2,-24468(gp)
 1837c78:	2085883a 	add	r2,r4,r2
 1837c7c:	1885c83a 	sub	r2,r3,r2
 1837c80:	10800044 	addi	r2,r2,1
 1837c84:	00807216 	blt	zero,r2,1837e50 <tcp_receive+0xcf8>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 1837c88:	e0bffe17 	ldw	r2,-8(fp)
 1837c8c:	10c00b17 	ldw	r3,44(r2)
 1837c90:	d0a81b17 	ldw	r2,-24468(gp)
 1837c94:	1885c83a 	sub	r2,r3,r2
 1837c98:	e0bff715 	stw	r2,-36(fp)
      p = inseg.p;
 1837c9c:	008061b4 	movhi	r2,390
 1837ca0:	1089a304 	addi	r2,r2,9868
 1837ca4:	10800117 	ldw	r2,4(r2)
 1837ca8:	e0bff615 	stw	r2,-40(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 1837cac:	008061b4 	movhi	r2,390
 1837cb0:	1089a304 	addi	r2,r2,9868
 1837cb4:	10800117 	ldw	r2,4(r2)
 1837cb8:	1080028b 	ldhu	r2,10(r2)
 1837cbc:	10ffffcc 	andi	r3,r2,65535
 1837cc0:	e0bff717 	ldw	r2,-36(fp)
 1837cc4:	1880240e 	bge	r3,r2,1837d58 <tcp_receive+0xc00>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 1837cc8:	008061b4 	movhi	r2,390
 1837ccc:	1089a304 	addi	r2,r2,9868
 1837cd0:	10800117 	ldw	r2,4(r2)
 1837cd4:	1080020b 	ldhu	r2,8(r2)
 1837cd8:	e0fff717 	ldw	r3,-36(fp)
 1837cdc:	10c5c83a 	sub	r2,r2,r3
 1837ce0:	e0bffb8d 	sth	r2,-18(fp)
        while (p->len < off) {
 1837ce4:	00000e06 	br	1837d20 <tcp_receive+0xbc8>
          off -= p->len;
 1837ce8:	e0bff617 	ldw	r2,-40(fp)
 1837cec:	1080028b 	ldhu	r2,10(r2)
 1837cf0:	10bfffcc 	andi	r2,r2,65535
 1837cf4:	e0fff717 	ldw	r3,-36(fp)
 1837cf8:	1885c83a 	sub	r2,r3,r2
 1837cfc:	e0bff715 	stw	r2,-36(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 1837d00:	e0bff617 	ldw	r2,-40(fp)
 1837d04:	e0fffb8b 	ldhu	r3,-18(fp)
 1837d08:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
 1837d0c:	e0bff617 	ldw	r2,-40(fp)
 1837d10:	1000028d 	sth	zero,10(r2)
          p = p->next;
 1837d14:	e0bff617 	ldw	r2,-40(fp)
 1837d18:	10800017 	ldw	r2,0(r2)
 1837d1c:	e0bff615 	stw	r2,-40(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 1837d20:	e0bff617 	ldw	r2,-40(fp)
 1837d24:	1080028b 	ldhu	r2,10(r2)
 1837d28:	10ffffcc 	andi	r3,r2,65535
 1837d2c:	e0bff717 	ldw	r2,-36(fp)
 1837d30:	18bfed16 	blt	r3,r2,1837ce8 <__ram_exceptions_end+0xff8278a4>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 1837d34:	e0bff717 	ldw	r2,-36(fp)
 1837d38:	0085c83a 	sub	r2,zero,r2
 1837d3c:	10bfffcc 	andi	r2,r2,65535
 1837d40:	10a0001c 	xori	r2,r2,32768
 1837d44:	10a00004 	addi	r2,r2,-32768
 1837d48:	100b883a 	mov	r5,r2
 1837d4c:	e13ff617 	ldw	r4,-40(fp)
 1837d50:	181aaf40 	call	181aaf4 <pbuf_header>
 1837d54:	00000b06 	br	1837d84 <tcp_receive+0xc2c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 1837d58:	008061b4 	movhi	r2,390
 1837d5c:	1089a304 	addi	r2,r2,9868
 1837d60:	10800117 	ldw	r2,4(r2)
 1837d64:	e0fff717 	ldw	r3,-36(fp)
 1837d68:	00c7c83a 	sub	r3,zero,r3
 1837d6c:	18ffffcc 	andi	r3,r3,65535
 1837d70:	18e0001c 	xori	r3,r3,32768
 1837d74:	18e00004 	addi	r3,r3,-32768
 1837d78:	180b883a 	mov	r5,r3
 1837d7c:	1009883a 	mov	r4,r2
 1837d80:	181aaf40 	call	181aaf4 <pbuf_header>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 1837d84:	008061b4 	movhi	r2,390
 1837d88:	1089a304 	addi	r2,r2,9868
 1837d8c:	1080020b 	ldhu	r2,8(r2)
 1837d90:	d0e81b17 	ldw	r3,-24468(gp)
 1837d94:	1809883a 	mov	r4,r3
 1837d98:	e0fffe17 	ldw	r3,-8(fp)
 1837d9c:	18c00b17 	ldw	r3,44(r3)
 1837da0:	20c7c83a 	sub	r3,r4,r3
 1837da4:	10c5883a 	add	r2,r2,r3
 1837da8:	1007883a 	mov	r3,r2
 1837dac:	008061b4 	movhi	r2,390
 1837db0:	1089a304 	addi	r2,r2,9868
 1837db4:	10c0020d 	sth	r3,8(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 1837db8:	008061b4 	movhi	r2,390
 1837dbc:	1089a304 	addi	r2,r2,9868
 1837dc0:	10800417 	ldw	r2,16(r2)
 1837dc4:	e0fffe17 	ldw	r3,-8(fp)
 1837dc8:	18c00b17 	ldw	r3,44(r3)
 1837dcc:	d0e81b15 	stw	r3,-24468(gp)
 1837dd0:	d0e81b17 	ldw	r3,-24468(gp)
 1837dd4:	19803fcc 	andi	r6,r3,255
 1837dd8:	11000103 	ldbu	r4,4(r2)
 1837ddc:	2008703a 	and	r4,r4,zero
 1837de0:	200b883a 	mov	r5,r4
 1837de4:	3009883a 	mov	r4,r6
 1837de8:	2908b03a 	or	r4,r5,r4
 1837dec:	11000105 	stb	r4,4(r2)
 1837df0:	1808d23a 	srli	r4,r3,8
 1837df4:	21803fcc 	andi	r6,r4,255
 1837df8:	11000143 	ldbu	r4,5(r2)
 1837dfc:	2008703a 	and	r4,r4,zero
 1837e00:	200b883a 	mov	r5,r4
 1837e04:	3009883a 	mov	r4,r6
 1837e08:	2908b03a 	or	r4,r5,r4
 1837e0c:	11000145 	stb	r4,5(r2)
 1837e10:	1808d43a 	srli	r4,r3,16
 1837e14:	21803fcc 	andi	r6,r4,255
 1837e18:	11000183 	ldbu	r4,6(r2)
 1837e1c:	2008703a 	and	r4,r4,zero
 1837e20:	200b883a 	mov	r5,r4
 1837e24:	3009883a 	mov	r4,r6
 1837e28:	2908b03a 	or	r4,r5,r4
 1837e2c:	11000185 	stb	r4,6(r2)
 1837e30:	180ad63a 	srli	r5,r3,24
 1837e34:	10c001c3 	ldbu	r3,7(r2)
 1837e38:	1806703a 	and	r3,r3,zero
 1837e3c:	1809883a 	mov	r4,r3
 1837e40:	2807883a 	mov	r3,r5
 1837e44:	20c6b03a 	or	r3,r4,r3
 1837e48:	10c001c5 	stb	r3,7(r2)
 1837e4c:	00000b06 	br	1837e7c <tcp_receive+0xd24>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 1837e50:	d0e81b17 	ldw	r3,-24468(gp)
 1837e54:	e0bffe17 	ldw	r2,-8(fp)
 1837e58:	10800b17 	ldw	r2,44(r2)
 1837e5c:	1885c83a 	sub	r2,r3,r2
 1837e60:	1000060e 	bge	r2,zero,1837e7c <tcp_receive+0xd24>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 1837e64:	e0bffe17 	ldw	r2,-8(fp)
 1837e68:	10800883 	ldbu	r2,34(r2)
 1837e6c:	10800094 	ori	r2,r2,2
 1837e70:	1007883a 	mov	r3,r2
 1837e74:	e0bffe17 	ldw	r2,-8(fp)
 1837e78:	10c00885 	stb	r3,34(r2)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 1837e7c:	d0e81b17 	ldw	r3,-24468(gp)
 1837e80:	e0bffe17 	ldw	r2,-8(fp)
 1837e84:	10800b17 	ldw	r2,44(r2)
 1837e88:	1885c83a 	sub	r2,r3,r2
 1837e8c:	10048e16 	blt	r2,zero,18390c8 <tcp_receive+0x1f70>
 1837e90:	d0e81b17 	ldw	r3,-24468(gp)
 1837e94:	e0bffe17 	ldw	r2,-8(fp)
 1837e98:	11000b17 	ldw	r4,44(r2)
 1837e9c:	e0bffe17 	ldw	r2,-8(fp)
 1837ea0:	10800c0b 	ldhu	r2,48(r2)
 1837ea4:	10bfffcc 	andi	r2,r2,65535
 1837ea8:	2085883a 	add	r2,r4,r2
 1837eac:	1885c83a 	sub	r2,r3,r2
 1837eb0:	10800044 	addi	r2,r2,1
 1837eb4:	00848416 	blt	zero,r2,18390c8 <tcp_receive+0x1f70>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 1837eb8:	e0bffe17 	ldw	r2,-8(fp)
 1837ebc:	10c00b17 	ldw	r3,44(r2)
 1837ec0:	d0a81b17 	ldw	r2,-24468(gp)
 1837ec4:	1882cd1e 	bne	r3,r2,18389fc <tcp_receive+0x18a4>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 1837ec8:	008061b4 	movhi	r2,390
 1837ecc:	1089a304 	addi	r2,r2,9868
 1837ed0:	10c0020b 	ldhu	r3,8(r2)
 1837ed4:	008061b4 	movhi	r2,390
 1837ed8:	1089a304 	addi	r2,r2,9868
 1837edc:	10800417 	ldw	r2,16(r2)
 1837ee0:	11000303 	ldbu	r4,12(r2)
 1837ee4:	10800343 	ldbu	r2,13(r2)
 1837ee8:	1004923a 	slli	r2,r2,8
 1837eec:	1104b03a 	or	r2,r2,r4
 1837ef0:	10bfffcc 	andi	r2,r2,65535
 1837ef4:	1004d23a 	srli	r2,r2,8
 1837ef8:	113fffcc 	andi	r4,r2,65535
 1837efc:	008061b4 	movhi	r2,390
 1837f00:	1089a304 	addi	r2,r2,9868
 1837f04:	10800417 	ldw	r2,16(r2)
 1837f08:	11400303 	ldbu	r5,12(r2)
 1837f0c:	10800343 	ldbu	r2,13(r2)
 1837f10:	1004923a 	slli	r2,r2,8
 1837f14:	1144b03a 	or	r2,r2,r5
 1837f18:	10bfffcc 	andi	r2,r2,65535
 1837f1c:	1004923a 	slli	r2,r2,8
 1837f20:	10bfffcc 	andi	r2,r2,65535
 1837f24:	2084b03a 	or	r2,r4,r2
 1837f28:	108000cc 	andi	r2,r2,3
 1837f2c:	1004c03a 	cmpne	r2,r2,zero
 1837f30:	10803fcc 	andi	r2,r2,255
 1837f34:	1885883a 	add	r2,r3,r2
 1837f38:	d0a81d8d 	sth	r2,-24458(gp)

        if (tcplen > pcb->rcv_wnd) {
 1837f3c:	e0bffe17 	ldw	r2,-8(fp)
 1837f40:	10c00c0b 	ldhu	r3,48(r2)
 1837f44:	d0a81d8b 	ldhu	r2,-24458(gp)
 1837f48:	18ffffcc 	andi	r3,r3,65535
 1837f4c:	10bfffcc 	andi	r2,r2,65535
 1837f50:	1880992e 	bgeu	r3,r2,18381b8 <tcp_receive+0x1060>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 1837f54:	008061b4 	movhi	r2,390
 1837f58:	1089a304 	addi	r2,r2,9868
 1837f5c:	10800417 	ldw	r2,16(r2)
 1837f60:	10c00303 	ldbu	r3,12(r2)
 1837f64:	10800343 	ldbu	r2,13(r2)
 1837f68:	1004923a 	slli	r2,r2,8
 1837f6c:	10c4b03a 	or	r2,r2,r3
 1837f70:	10bfffcc 	andi	r2,r2,65535
 1837f74:	1004d23a 	srli	r2,r2,8
 1837f78:	10ffffcc 	andi	r3,r2,65535
 1837f7c:	008061b4 	movhi	r2,390
 1837f80:	1089a304 	addi	r2,r2,9868
 1837f84:	10800417 	ldw	r2,16(r2)
 1837f88:	11000303 	ldbu	r4,12(r2)
 1837f8c:	10800343 	ldbu	r2,13(r2)
 1837f90:	1004923a 	slli	r2,r2,8
 1837f94:	1104b03a 	or	r2,r2,r4
 1837f98:	10bfffcc 	andi	r2,r2,65535
 1837f9c:	1004923a 	slli	r2,r2,8
 1837fa0:	10bfffcc 	andi	r2,r2,65535
 1837fa4:	1884b03a 	or	r2,r3,r2
 1837fa8:	1080004c 	andi	r2,r2,1
 1837fac:	10003726 	beq	r2,zero,183808c <tcp_receive+0xf34>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 1837fb0:	008061b4 	movhi	r2,390
 1837fb4:	1089a304 	addi	r2,r2,9868
 1837fb8:	10800417 	ldw	r2,16(r2)
 1837fbc:	00c061b4 	movhi	r3,390
 1837fc0:	18c9a304 	addi	r3,r3,9868
 1837fc4:	18c00417 	ldw	r3,16(r3)
 1837fc8:	19000303 	ldbu	r4,12(r3)
 1837fcc:	18c00343 	ldbu	r3,13(r3)
 1837fd0:	1806923a 	slli	r3,r3,8
 1837fd4:	1906b03a 	or	r3,r3,r4
 1837fd8:	1809883a 	mov	r4,r3
 1837fdc:	00f03fc4 	movi	r3,-16129
 1837fe0:	20c6703a 	and	r3,r4,r3
 1837fe4:	180b883a 	mov	r5,r3
 1837fe8:	00c061b4 	movhi	r3,390
 1837fec:	18c9a304 	addi	r3,r3,9868
 1837ff0:	18c00417 	ldw	r3,16(r3)
 1837ff4:	19000303 	ldbu	r4,12(r3)
 1837ff8:	18c00343 	ldbu	r3,13(r3)
 1837ffc:	1806923a 	slli	r3,r3,8
 1838000:	1906b03a 	or	r3,r3,r4
 1838004:	18ffffcc 	andi	r3,r3,65535
 1838008:	1806d23a 	srli	r3,r3,8
 183800c:	180d883a 	mov	r6,r3
 1838010:	00c061b4 	movhi	r3,390
 1838014:	18c9a304 	addi	r3,r3,9868
 1838018:	18c00417 	ldw	r3,16(r3)
 183801c:	19000303 	ldbu	r4,12(r3)
 1838020:	18c00343 	ldbu	r3,13(r3)
 1838024:	1806923a 	slli	r3,r3,8
 1838028:	1906b03a 	or	r3,r3,r4
 183802c:	18ffffcc 	andi	r3,r3,65535
 1838030:	1806923a 	slli	r3,r3,8
 1838034:	30c6b03a 	or	r3,r6,r3
 1838038:	18c00f8c 	andi	r3,r3,62
 183803c:	1806923a 	slli	r3,r3,8
 1838040:	28c6b03a 	or	r3,r5,r3
 1838044:	180d883a 	mov	r6,r3
 1838048:	30ffffcc 	andi	r3,r6,65535
 183804c:	19403fcc 	andi	r5,r3,255
 1838050:	10c00303 	ldbu	r3,12(r2)
 1838054:	1806703a 	and	r3,r3,zero
 1838058:	1809883a 	mov	r4,r3
 183805c:	2807883a 	mov	r3,r5
 1838060:	20c6b03a 	or	r3,r4,r3
 1838064:	10c00305 	stb	r3,12(r2)
 1838068:	30ffffcc 	andi	r3,r6,65535
 183806c:	1806d23a 	srli	r3,r3,8
 1838070:	197fffcc 	andi	r5,r3,65535
 1838074:	10c00343 	ldbu	r3,13(r2)
 1838078:	1806703a 	and	r3,r3,zero
 183807c:	1809883a 	mov	r4,r3
 1838080:	2807883a 	mov	r3,r5
 1838084:	20c6b03a 	or	r3,r4,r3
 1838088:	10c00345 	stb	r3,13(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 183808c:	e0bffe17 	ldw	r2,-8(fp)
 1838090:	10c00c0b 	ldhu	r3,48(r2)
 1838094:	008061b4 	movhi	r2,390
 1838098:	1089a304 	addi	r2,r2,9868
 183809c:	10c0020d 	sth	r3,8(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 18380a0:	008061b4 	movhi	r2,390
 18380a4:	1089a304 	addi	r2,r2,9868
 18380a8:	10800417 	ldw	r2,16(r2)
 18380ac:	10c00303 	ldbu	r3,12(r2)
 18380b0:	10800343 	ldbu	r2,13(r2)
 18380b4:	1004923a 	slli	r2,r2,8
 18380b8:	10c4b03a 	or	r2,r2,r3
 18380bc:	10bfffcc 	andi	r2,r2,65535
 18380c0:	1004d23a 	srli	r2,r2,8
 18380c4:	10ffffcc 	andi	r3,r2,65535
 18380c8:	008061b4 	movhi	r2,390
 18380cc:	1089a304 	addi	r2,r2,9868
 18380d0:	10800417 	ldw	r2,16(r2)
 18380d4:	11000303 	ldbu	r4,12(r2)
 18380d8:	10800343 	ldbu	r2,13(r2)
 18380dc:	1004923a 	slli	r2,r2,8
 18380e0:	1104b03a 	or	r2,r2,r4
 18380e4:	10bfffcc 	andi	r2,r2,65535
 18380e8:	1004923a 	slli	r2,r2,8
 18380ec:	10bfffcc 	andi	r2,r2,65535
 18380f0:	1884b03a 	or	r2,r3,r2
 18380f4:	1080008c 	andi	r2,r2,2
 18380f8:	10000826 	beq	r2,zero,183811c <tcp_receive+0xfc4>
            inseg.len -= 1;
 18380fc:	008061b4 	movhi	r2,390
 1838100:	1089a304 	addi	r2,r2,9868
 1838104:	1080020b 	ldhu	r2,8(r2)
 1838108:	10bfffc4 	addi	r2,r2,-1
 183810c:	1007883a 	mov	r3,r2
 1838110:	008061b4 	movhi	r2,390
 1838114:	1089a304 	addi	r2,r2,9868
 1838118:	10c0020d 	sth	r3,8(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
 183811c:	008061b4 	movhi	r2,390
 1838120:	1089a304 	addi	r2,r2,9868
 1838124:	10c00117 	ldw	r3,4(r2)
 1838128:	008061b4 	movhi	r2,390
 183812c:	1089a304 	addi	r2,r2,9868
 1838130:	1080020b 	ldhu	r2,8(r2)
 1838134:	10bfffcc 	andi	r2,r2,65535
 1838138:	100b883a 	mov	r5,r2
 183813c:	1809883a 	mov	r4,r3
 1838140:	181a9940 	call	181a994 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 1838144:	008061b4 	movhi	r2,390
 1838148:	1089a304 	addi	r2,r2,9868
 183814c:	10c0020b 	ldhu	r3,8(r2)
 1838150:	008061b4 	movhi	r2,390
 1838154:	1089a304 	addi	r2,r2,9868
 1838158:	10800417 	ldw	r2,16(r2)
 183815c:	11000303 	ldbu	r4,12(r2)
 1838160:	10800343 	ldbu	r2,13(r2)
 1838164:	1004923a 	slli	r2,r2,8
 1838168:	1104b03a 	or	r2,r2,r4
 183816c:	10bfffcc 	andi	r2,r2,65535
 1838170:	1004d23a 	srli	r2,r2,8
 1838174:	113fffcc 	andi	r4,r2,65535
 1838178:	008061b4 	movhi	r2,390
 183817c:	1089a304 	addi	r2,r2,9868
 1838180:	10800417 	ldw	r2,16(r2)
 1838184:	11400303 	ldbu	r5,12(r2)
 1838188:	10800343 	ldbu	r2,13(r2)
 183818c:	1004923a 	slli	r2,r2,8
 1838190:	1144b03a 	or	r2,r2,r5
 1838194:	10bfffcc 	andi	r2,r2,65535
 1838198:	1004923a 	slli	r2,r2,8
 183819c:	10bfffcc 	andi	r2,r2,65535
 18381a0:	2084b03a 	or	r2,r4,r2
 18381a4:	108000cc 	andi	r2,r2,3
 18381a8:	1004c03a 	cmpne	r2,r2,zero
 18381ac:	10803fcc 	andi	r2,r2,255
 18381b0:	1885883a 	add	r2,r3,r2
 18381b4:	d0a81d8d 	sth	r2,-24458(gp)
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 18381b8:	e0bffe17 	ldw	r2,-8(fp)
 18381bc:	10801e17 	ldw	r2,120(r2)
 18381c0:	10012026 	beq	r2,zero,1838644 <tcp_receive+0x14ec>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 18381c4:	008061b4 	movhi	r2,390
 18381c8:	1089a304 	addi	r2,r2,9868
 18381cc:	10800417 	ldw	r2,16(r2)
 18381d0:	10c00303 	ldbu	r3,12(r2)
 18381d4:	10800343 	ldbu	r2,13(r2)
 18381d8:	1004923a 	slli	r2,r2,8
 18381dc:	10c4b03a 	or	r2,r2,r3
 18381e0:	10bfffcc 	andi	r2,r2,65535
 18381e4:	1004d23a 	srli	r2,r2,8
 18381e8:	10ffffcc 	andi	r3,r2,65535
 18381ec:	008061b4 	movhi	r2,390
 18381f0:	1089a304 	addi	r2,r2,9868
 18381f4:	10800417 	ldw	r2,16(r2)
 18381f8:	11000303 	ldbu	r4,12(r2)
 18381fc:	10800343 	ldbu	r2,13(r2)
 1838200:	1004923a 	slli	r2,r2,8
 1838204:	1104b03a 	or	r2,r2,r4
 1838208:	10bfffcc 	andi	r2,r2,65535
 183820c:	1004923a 	slli	r2,r2,8
 1838210:	10bfffcc 	andi	r2,r2,65535
 1838214:	1884b03a 	or	r2,r3,r2
 1838218:	1080004c 	andi	r2,r2,1
 183821c:	10000f26 	beq	r2,zero,183825c <tcp_receive+0x1104>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 1838220:	00000a06 	br	183824c <tcp_receive+0x10f4>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 1838224:	e0bffe17 	ldw	r2,-8(fp)
 1838228:	10801e17 	ldw	r2,120(r2)
 183822c:	e0bffc15 	stw	r2,-16(fp)
              pcb->ooseq = pcb->ooseq->next;
 1838230:	e0bffe17 	ldw	r2,-8(fp)
 1838234:	10801e17 	ldw	r2,120(r2)
 1838238:	10c00017 	ldw	r3,0(r2)
 183823c:	e0bffe17 	ldw	r2,-8(fp)
 1838240:	10c01e15 	stw	r3,120(r2)
              tcp_seg_free(old_ooseq);
 1838244:	e13ffc17 	ldw	r4,-16(fp)
 1838248:	181d56c0 	call	181d56c <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 183824c:	e0bffe17 	ldw	r2,-8(fp)
 1838250:	10801e17 	ldw	r2,120(r2)
 1838254:	103ff31e 	bne	r2,zero,1838224 <__ram_exceptions_end+0xff827de0>
 1838258:	0000fa06 	br	1838644 <tcp_receive+0x14ec>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
 183825c:	e0bffe17 	ldw	r2,-8(fp)
 1838260:	10801e17 	ldw	r2,120(r2)
 1838264:	e0bff415 	stw	r2,-48(fp)
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 1838268:	00006d06 	br	1838420 <tcp_receive+0x12c8>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 183826c:	e0bff417 	ldw	r2,-48(fp)
 1838270:	10800417 	ldw	r2,16(r2)
 1838274:	10c00303 	ldbu	r3,12(r2)
 1838278:	10800343 	ldbu	r2,13(r2)
 183827c:	1004923a 	slli	r2,r2,8
 1838280:	10c4b03a 	or	r2,r2,r3
 1838284:	10bfffcc 	andi	r2,r2,65535
 1838288:	1004d23a 	srli	r2,r2,8
 183828c:	10ffffcc 	andi	r3,r2,65535
 1838290:	e0bff417 	ldw	r2,-48(fp)
 1838294:	10800417 	ldw	r2,16(r2)
 1838298:	11000303 	ldbu	r4,12(r2)
 183829c:	10800343 	ldbu	r2,13(r2)
 18382a0:	1004923a 	slli	r2,r2,8
 18382a4:	1104b03a 	or	r2,r2,r4
 18382a8:	10bfffcc 	andi	r2,r2,65535
 18382ac:	1004923a 	slli	r2,r2,8
 18382b0:	10bfffcc 	andi	r2,r2,65535
 18382b4:	1884b03a 	or	r2,r3,r2
 18382b8:	1080004c 	andi	r2,r2,1
 18382bc:	10005126 	beq	r2,zero,1838404 <tcp_receive+0x12ac>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 18382c0:	008061b4 	movhi	r2,390
 18382c4:	1089a304 	addi	r2,r2,9868
 18382c8:	10800417 	ldw	r2,16(r2)
 18382cc:	10c00303 	ldbu	r3,12(r2)
 18382d0:	10800343 	ldbu	r2,13(r2)
 18382d4:	1004923a 	slli	r2,r2,8
 18382d8:	10c4b03a 	or	r2,r2,r3
 18382dc:	10bfffcc 	andi	r2,r2,65535
 18382e0:	1004d23a 	srli	r2,r2,8
 18382e4:	10ffffcc 	andi	r3,r2,65535
 18382e8:	008061b4 	movhi	r2,390
 18382ec:	1089a304 	addi	r2,r2,9868
 18382f0:	10800417 	ldw	r2,16(r2)
 18382f4:	11000303 	ldbu	r4,12(r2)
 18382f8:	10800343 	ldbu	r2,13(r2)
 18382fc:	1004923a 	slli	r2,r2,8
 1838300:	1104b03a 	or	r2,r2,r4
 1838304:	10bfffcc 	andi	r2,r2,65535
 1838308:	1004923a 	slli	r2,r2,8
 183830c:	10bfffcc 	andi	r2,r2,65535
 1838310:	1884b03a 	or	r2,r3,r2
 1838314:	1080008c 	andi	r2,r2,2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 1838318:	10003a1e 	bne	r2,zero,1838404 <tcp_receive+0x12ac>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 183831c:	008061b4 	movhi	r2,390
 1838320:	1089a304 	addi	r2,r2,9868
 1838324:	10800417 	ldw	r2,16(r2)
 1838328:	00c061b4 	movhi	r3,390
 183832c:	18c9a304 	addi	r3,r3,9868
 1838330:	18c00417 	ldw	r3,16(r3)
 1838334:	19000303 	ldbu	r4,12(r3)
 1838338:	18c00343 	ldbu	r3,13(r3)
 183833c:	1806923a 	slli	r3,r3,8
 1838340:	1906b03a 	or	r3,r3,r4
 1838344:	18c04014 	ori	r3,r3,256
 1838348:	180d883a 	mov	r6,r3
 183834c:	30ffffcc 	andi	r3,r6,65535
 1838350:	19403fcc 	andi	r5,r3,255
 1838354:	10c00303 	ldbu	r3,12(r2)
 1838358:	1806703a 	and	r3,r3,zero
 183835c:	1809883a 	mov	r4,r3
 1838360:	2807883a 	mov	r3,r5
 1838364:	20c6b03a 	or	r3,r4,r3
 1838368:	10c00305 	stb	r3,12(r2)
 183836c:	30ffffcc 	andi	r3,r6,65535
 1838370:	1806d23a 	srli	r3,r3,8
 1838374:	197fffcc 	andi	r5,r3,65535
 1838378:	10c00343 	ldbu	r3,13(r2)
 183837c:	1806703a 	and	r3,r3,zero
 1838380:	1809883a 	mov	r4,r3
 1838384:	2807883a 	mov	r3,r5
 1838388:	20c6b03a 	or	r3,r4,r3
 183838c:	10c00345 	stb	r3,13(r2)
                tcplen = TCP_TCPLEN(&inseg);
 1838390:	008061b4 	movhi	r2,390
 1838394:	1089a304 	addi	r2,r2,9868
 1838398:	10c0020b 	ldhu	r3,8(r2)
 183839c:	008061b4 	movhi	r2,390
 18383a0:	1089a304 	addi	r2,r2,9868
 18383a4:	10800417 	ldw	r2,16(r2)
 18383a8:	11000303 	ldbu	r4,12(r2)
 18383ac:	10800343 	ldbu	r2,13(r2)
 18383b0:	1004923a 	slli	r2,r2,8
 18383b4:	1104b03a 	or	r2,r2,r4
 18383b8:	10bfffcc 	andi	r2,r2,65535
 18383bc:	1004d23a 	srli	r2,r2,8
 18383c0:	113fffcc 	andi	r4,r2,65535
 18383c4:	008061b4 	movhi	r2,390
 18383c8:	1089a304 	addi	r2,r2,9868
 18383cc:	10800417 	ldw	r2,16(r2)
 18383d0:	11400303 	ldbu	r5,12(r2)
 18383d4:	10800343 	ldbu	r2,13(r2)
 18383d8:	1004923a 	slli	r2,r2,8
 18383dc:	1144b03a 	or	r2,r2,r5
 18383e0:	10bfffcc 	andi	r2,r2,65535
 18383e4:	1004923a 	slli	r2,r2,8
 18383e8:	10bfffcc 	andi	r2,r2,65535
 18383ec:	2084b03a 	or	r2,r4,r2
 18383f0:	108000cc 	andi	r2,r2,3
 18383f4:	1004c03a 	cmpne	r2,r2,zero
 18383f8:	10803fcc 	andi	r2,r2,255
 18383fc:	1885883a 	add	r2,r3,r2
 1838400:	d0a81d8d 	sth	r2,-24458(gp)
              }
              prev = next;
 1838404:	e0bff417 	ldw	r2,-48(fp)
 1838408:	e0bff515 	stw	r2,-44(fp)
              next = next->next;
 183840c:	e0bff417 	ldw	r2,-48(fp)
 1838410:	10800017 	ldw	r2,0(r2)
 1838414:	e0bff415 	stw	r2,-48(fp)
              tcp_seg_free(prev);
 1838418:	e13ff517 	ldw	r4,-44(fp)
 183841c:	181d56c0 	call	181d56c <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 1838420:	e0bff417 	ldw	r2,-48(fp)
 1838424:	10001726 	beq	r2,zero,1838484 <tcp_receive+0x132c>
                   TCP_SEQ_GEQ(seqno + tcplen,
 1838428:	d0a81d8b 	ldhu	r2,-24458(gp)
 183842c:	10ffffcc 	andi	r3,r2,65535
 1838430:	d0a81b17 	ldw	r2,-24468(gp)
 1838434:	1887883a 	add	r3,r3,r2
 1838438:	e0bff417 	ldw	r2,-48(fp)
 183843c:	10800417 	ldw	r2,16(r2)
 1838440:	11000103 	ldbu	r4,4(r2)
 1838444:	11400143 	ldbu	r5,5(r2)
 1838448:	280a923a 	slli	r5,r5,8
 183844c:	2908b03a 	or	r4,r5,r4
 1838450:	11400183 	ldbu	r5,6(r2)
 1838454:	280a943a 	slli	r5,r5,16
 1838458:	2908b03a 	or	r4,r5,r4
 183845c:	108001c3 	ldbu	r2,7(r2)
 1838460:	1004963a 	slli	r2,r2,24
 1838464:	1104b03a 	or	r2,r2,r4
 1838468:	1009883a 	mov	r4,r2
 183846c:	e0bff417 	ldw	r2,-48(fp)
 1838470:	1080020b 	ldhu	r2,8(r2)
 1838474:	10bfffcc 	andi	r2,r2,65535
 1838478:	2085883a 	add	r2,r4,r2
 183847c:	1885c83a 	sub	r2,r3,r2
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 1838480:	103f7a0e 	bge	r2,zero,183826c <__ram_exceptions_end+0xff827e28>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 1838484:	e0bff417 	ldw	r2,-48(fp)
 1838488:	10006b26 	beq	r2,zero,1838638 <tcp_receive+0x14e0>
                TCP_SEQ_GT(seqno + tcplen,
 183848c:	d0a81d8b 	ldhu	r2,-24458(gp)
 1838490:	10ffffcc 	andi	r3,r2,65535
 1838494:	d0a81b17 	ldw	r2,-24468(gp)
 1838498:	1887883a 	add	r3,r3,r2
 183849c:	e0bff417 	ldw	r2,-48(fp)
 18384a0:	10800417 	ldw	r2,16(r2)
 18384a4:	11000103 	ldbu	r4,4(r2)
 18384a8:	11400143 	ldbu	r5,5(r2)
 18384ac:	280a923a 	slli	r5,r5,8
 18384b0:	2908b03a 	or	r4,r5,r4
 18384b4:	11400183 	ldbu	r5,6(r2)
 18384b8:	280a943a 	slli	r5,r5,16
 18384bc:	2908b03a 	or	r4,r5,r4
 18384c0:	108001c3 	ldbu	r2,7(r2)
 18384c4:	1004963a 	slli	r2,r2,24
 18384c8:	1104b03a 	or	r2,r2,r4
 18384cc:	1885c83a 	sub	r2,r3,r2
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 18384d0:	0080590e 	bge	zero,r2,1838638 <tcp_receive+0x14e0>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 18384d4:	e0bff417 	ldw	r2,-48(fp)
 18384d8:	10800417 	ldw	r2,16(r2)
 18384dc:	10c00103 	ldbu	r3,4(r2)
 18384e0:	11000143 	ldbu	r4,5(r2)
 18384e4:	2008923a 	slli	r4,r4,8
 18384e8:	20c6b03a 	or	r3,r4,r3
 18384ec:	11000183 	ldbu	r4,6(r2)
 18384f0:	2008943a 	slli	r4,r4,16
 18384f4:	20c6b03a 	or	r3,r4,r3
 18384f8:	108001c3 	ldbu	r2,7(r2)
 18384fc:	1004963a 	slli	r2,r2,24
 1838500:	10c4b03a 	or	r2,r2,r3
 1838504:	1007883a 	mov	r3,r2
 1838508:	d0a81b17 	ldw	r2,-24468(gp)
 183850c:	1885c83a 	sub	r2,r3,r2
 1838510:	1007883a 	mov	r3,r2
 1838514:	008061b4 	movhi	r2,390
 1838518:	1089a304 	addi	r2,r2,9868
 183851c:	10c0020d 	sth	r3,8(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 1838520:	008061b4 	movhi	r2,390
 1838524:	1089a304 	addi	r2,r2,9868
 1838528:	10800417 	ldw	r2,16(r2)
 183852c:	10c00303 	ldbu	r3,12(r2)
 1838530:	10800343 	ldbu	r2,13(r2)
 1838534:	1004923a 	slli	r2,r2,8
 1838538:	10c4b03a 	or	r2,r2,r3
 183853c:	10bfffcc 	andi	r2,r2,65535
 1838540:	1004d23a 	srli	r2,r2,8
 1838544:	10ffffcc 	andi	r3,r2,65535
 1838548:	008061b4 	movhi	r2,390
 183854c:	1089a304 	addi	r2,r2,9868
 1838550:	10800417 	ldw	r2,16(r2)
 1838554:	11000303 	ldbu	r4,12(r2)
 1838558:	10800343 	ldbu	r2,13(r2)
 183855c:	1004923a 	slli	r2,r2,8
 1838560:	1104b03a 	or	r2,r2,r4
 1838564:	10bfffcc 	andi	r2,r2,65535
 1838568:	1004923a 	slli	r2,r2,8
 183856c:	10bfffcc 	andi	r2,r2,65535
 1838570:	1884b03a 	or	r2,r3,r2
 1838574:	1080008c 	andi	r2,r2,2
 1838578:	10000826 	beq	r2,zero,183859c <tcp_receive+0x1444>
                inseg.len -= 1;
 183857c:	008061b4 	movhi	r2,390
 1838580:	1089a304 	addi	r2,r2,9868
 1838584:	1080020b 	ldhu	r2,8(r2)
 1838588:	10bfffc4 	addi	r2,r2,-1
 183858c:	1007883a 	mov	r3,r2
 1838590:	008061b4 	movhi	r2,390
 1838594:	1089a304 	addi	r2,r2,9868
 1838598:	10c0020d 	sth	r3,8(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
 183859c:	008061b4 	movhi	r2,390
 18385a0:	1089a304 	addi	r2,r2,9868
 18385a4:	10c00117 	ldw	r3,4(r2)
 18385a8:	008061b4 	movhi	r2,390
 18385ac:	1089a304 	addi	r2,r2,9868
 18385b0:	1080020b 	ldhu	r2,8(r2)
 18385b4:	10bfffcc 	andi	r2,r2,65535
 18385b8:	100b883a 	mov	r5,r2
 18385bc:	1809883a 	mov	r4,r3
 18385c0:	181a9940 	call	181a994 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 18385c4:	008061b4 	movhi	r2,390
 18385c8:	1089a304 	addi	r2,r2,9868
 18385cc:	10c0020b 	ldhu	r3,8(r2)
 18385d0:	008061b4 	movhi	r2,390
 18385d4:	1089a304 	addi	r2,r2,9868
 18385d8:	10800417 	ldw	r2,16(r2)
 18385dc:	11000303 	ldbu	r4,12(r2)
 18385e0:	10800343 	ldbu	r2,13(r2)
 18385e4:	1004923a 	slli	r2,r2,8
 18385e8:	1104b03a 	or	r2,r2,r4
 18385ec:	10bfffcc 	andi	r2,r2,65535
 18385f0:	1004d23a 	srli	r2,r2,8
 18385f4:	113fffcc 	andi	r4,r2,65535
 18385f8:	008061b4 	movhi	r2,390
 18385fc:	1089a304 	addi	r2,r2,9868
 1838600:	10800417 	ldw	r2,16(r2)
 1838604:	11400303 	ldbu	r5,12(r2)
 1838608:	10800343 	ldbu	r2,13(r2)
 183860c:	1004923a 	slli	r2,r2,8
 1838610:	1144b03a 	or	r2,r2,r5
 1838614:	10bfffcc 	andi	r2,r2,65535
 1838618:	1004923a 	slli	r2,r2,8
 183861c:	10bfffcc 	andi	r2,r2,65535
 1838620:	2084b03a 	or	r2,r4,r2
 1838624:	108000cc 	andi	r2,r2,3
 1838628:	1004c03a 	cmpne	r2,r2,zero
 183862c:	10803fcc 	andi	r2,r2,255
 1838630:	1885883a 	add	r2,r3,r2
 1838634:	d0a81d8d 	sth	r2,-24458(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 1838638:	e0bffe17 	ldw	r2,-8(fp)
 183863c:	e0fff417 	ldw	r3,-48(fp)
 1838640:	10c01e15 	stw	r3,120(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 1838644:	d0a81d8b 	ldhu	r2,-24458(gp)
 1838648:	10ffffcc 	andi	r3,r2,65535
 183864c:	d0a81b17 	ldw	r2,-24468(gp)
 1838650:	1887883a 	add	r3,r3,r2
 1838654:	e0bffe17 	ldw	r2,-8(fp)
 1838658:	10c00b15 	stw	r3,44(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 183865c:	e0bffe17 	ldw	r2,-8(fp)
 1838660:	10c00c0b 	ldhu	r3,48(r2)
 1838664:	d0a81d8b 	ldhu	r2,-24458(gp)
 1838668:	1885c83a 	sub	r2,r3,r2
 183866c:	1007883a 	mov	r3,r2
 1838670:	e0bffe17 	ldw	r2,-8(fp)
 1838674:	10c00c0d 	sth	r3,48(r2)

        tcp_update_rcv_ann_wnd(pcb);
 1838678:	e13ffe17 	ldw	r4,-8(fp)
 183867c:	181c5900 	call	181c590 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 1838680:	008061b4 	movhi	r2,390
 1838684:	1089a304 	addi	r2,r2,9868
 1838688:	10800117 	ldw	r2,4(r2)
 183868c:	1080020b 	ldhu	r2,8(r2)
 1838690:	10bfffcc 	andi	r2,r2,65535
 1838694:	10000726 	beq	r2,zero,18386b4 <tcp_receive+0x155c>
          recv_data = inseg.p;
 1838698:	008061b4 	movhi	r2,390
 183869c:	1089a304 	addi	r2,r2,9868
 18386a0:	10800117 	ldw	r2,4(r2)
 18386a4:	d0a81f15 	stw	r2,-24452(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 18386a8:	008061b4 	movhi	r2,390
 18386ac:	1089a304 	addi	r2,r2,9868
 18386b0:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 18386b4:	008061b4 	movhi	r2,390
 18386b8:	1089a304 	addi	r2,r2,9868
 18386bc:	10800417 	ldw	r2,16(r2)
 18386c0:	10c00303 	ldbu	r3,12(r2)
 18386c4:	10800343 	ldbu	r2,13(r2)
 18386c8:	1004923a 	slli	r2,r2,8
 18386cc:	10c4b03a 	or	r2,r2,r3
 18386d0:	10bfffcc 	andi	r2,r2,65535
 18386d4:	1004d23a 	srli	r2,r2,8
 18386d8:	10ffffcc 	andi	r3,r2,65535
 18386dc:	008061b4 	movhi	r2,390
 18386e0:	1089a304 	addi	r2,r2,9868
 18386e4:	10800417 	ldw	r2,16(r2)
 18386e8:	11000303 	ldbu	r4,12(r2)
 18386ec:	10800343 	ldbu	r2,13(r2)
 18386f0:	1004923a 	slli	r2,r2,8
 18386f4:	1104b03a 	or	r2,r2,r4
 18386f8:	10bfffcc 	andi	r2,r2,65535
 18386fc:	1004923a 	slli	r2,r2,8
 1838700:	10bfffcc 	andi	r2,r2,65535
 1838704:	1884b03a 	or	r2,r3,r2
 1838708:	1080004c 	andi	r2,r2,1
 183870c:	10008d26 	beq	r2,zero,1838944 <tcp_receive+0x17ec>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 1838710:	d0a81e03 	ldbu	r2,-24456(gp)
 1838714:	10800814 	ori	r2,r2,32
 1838718:	d0a81e05 	stb	r2,-24456(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 183871c:	00008906 	br	1838944 <tcp_receive+0x17ec>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
 1838720:	e0bffe17 	ldw	r2,-8(fp)
 1838724:	10801e17 	ldw	r2,120(r2)
 1838728:	e0bffd15 	stw	r2,-12(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
 183872c:	e0bffe17 	ldw	r2,-8(fp)
 1838730:	10801e17 	ldw	r2,120(r2)
 1838734:	10800417 	ldw	r2,16(r2)
 1838738:	10c00103 	ldbu	r3,4(r2)
 183873c:	11000143 	ldbu	r4,5(r2)
 1838740:	2008923a 	slli	r4,r4,8
 1838744:	20c6b03a 	or	r3,r4,r3
 1838748:	11000183 	ldbu	r4,6(r2)
 183874c:	2008943a 	slli	r4,r4,16
 1838750:	20c6b03a 	or	r3,r4,r3
 1838754:	108001c3 	ldbu	r2,7(r2)
 1838758:	1004963a 	slli	r2,r2,24
 183875c:	10c4b03a 	or	r2,r2,r3
 1838760:	d0a81b15 	stw	r2,-24468(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 1838764:	e0bffe17 	ldw	r2,-8(fp)
 1838768:	10c00b17 	ldw	r3,44(r2)
 183876c:	e0bffd17 	ldw	r2,-12(fp)
 1838770:	1080020b 	ldhu	r2,8(r2)
 1838774:	113fffcc 	andi	r4,r2,65535
 1838778:	e0bffd17 	ldw	r2,-12(fp)
 183877c:	10800417 	ldw	r2,16(r2)
 1838780:	11400303 	ldbu	r5,12(r2)
 1838784:	10800343 	ldbu	r2,13(r2)
 1838788:	1004923a 	slli	r2,r2,8
 183878c:	1144b03a 	or	r2,r2,r5
 1838790:	10bfffcc 	andi	r2,r2,65535
 1838794:	1004d23a 	srli	r2,r2,8
 1838798:	117fffcc 	andi	r5,r2,65535
 183879c:	e0bffd17 	ldw	r2,-12(fp)
 18387a0:	10800417 	ldw	r2,16(r2)
 18387a4:	11800303 	ldbu	r6,12(r2)
 18387a8:	10800343 	ldbu	r2,13(r2)
 18387ac:	1004923a 	slli	r2,r2,8
 18387b0:	1184b03a 	or	r2,r2,r6
 18387b4:	10bfffcc 	andi	r2,r2,65535
 18387b8:	1004923a 	slli	r2,r2,8
 18387bc:	10bfffcc 	andi	r2,r2,65535
 18387c0:	2884b03a 	or	r2,r5,r2
 18387c4:	108000cc 	andi	r2,r2,3
 18387c8:	1004c03a 	cmpne	r2,r2,zero
 18387cc:	10803fcc 	andi	r2,r2,255
 18387d0:	2085883a 	add	r2,r4,r2
 18387d4:	1887883a 	add	r3,r3,r2
 18387d8:	e0bffe17 	ldw	r2,-8(fp)
 18387dc:	10c00b15 	stw	r3,44(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 18387e0:	e0bffe17 	ldw	r2,-8(fp)
 18387e4:	10c00c0b 	ldhu	r3,48(r2)
 18387e8:	e0bffd17 	ldw	r2,-12(fp)
 18387ec:	1100020b 	ldhu	r4,8(r2)
 18387f0:	e0bffd17 	ldw	r2,-12(fp)
 18387f4:	10800417 	ldw	r2,16(r2)
 18387f8:	11400303 	ldbu	r5,12(r2)
 18387fc:	10800343 	ldbu	r2,13(r2)
 1838800:	1004923a 	slli	r2,r2,8
 1838804:	1144b03a 	or	r2,r2,r5
 1838808:	10bfffcc 	andi	r2,r2,65535
 183880c:	1004d23a 	srli	r2,r2,8
 1838810:	117fffcc 	andi	r5,r2,65535
 1838814:	e0bffd17 	ldw	r2,-12(fp)
 1838818:	10800417 	ldw	r2,16(r2)
 183881c:	11800303 	ldbu	r6,12(r2)
 1838820:	10800343 	ldbu	r2,13(r2)
 1838824:	1004923a 	slli	r2,r2,8
 1838828:	1184b03a 	or	r2,r2,r6
 183882c:	10bfffcc 	andi	r2,r2,65535
 1838830:	1004923a 	slli	r2,r2,8
 1838834:	10bfffcc 	andi	r2,r2,65535
 1838838:	2884b03a 	or	r2,r5,r2
 183883c:	108000cc 	andi	r2,r2,3
 1838840:	1004c03a 	cmpne	r2,r2,zero
 1838844:	10803fcc 	andi	r2,r2,255
 1838848:	2085883a 	add	r2,r4,r2
 183884c:	1885c83a 	sub	r2,r3,r2
 1838850:	1007883a 	mov	r3,r2
 1838854:	e0bffe17 	ldw	r2,-8(fp)
 1838858:	10c00c0d 	sth	r3,48(r2)

          tcp_update_rcv_ann_wnd(pcb);
 183885c:	e13ffe17 	ldw	r4,-8(fp)
 1838860:	181c5900 	call	181c590 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 1838864:	e0bffd17 	ldw	r2,-12(fp)
 1838868:	10800117 	ldw	r2,4(r2)
 183886c:	1080020b 	ldhu	r2,8(r2)
 1838870:	10bfffcc 	andi	r2,r2,65535
 1838874:	10000e26 	beq	r2,zero,18388b0 <tcp_receive+0x1758>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
 1838878:	d0a81f17 	ldw	r2,-24452(gp)
 183887c:	10000726 	beq	r2,zero,183889c <tcp_receive+0x1744>
              pbuf_cat(recv_data, cseg->p);
 1838880:	d0e81f17 	ldw	r3,-24452(gp)
 1838884:	e0bffd17 	ldw	r2,-12(fp)
 1838888:	10800117 	ldw	r2,4(r2)
 183888c:	100b883a 	mov	r5,r2
 1838890:	1809883a 	mov	r4,r3
 1838894:	181ae980 	call	181ae98 <pbuf_cat>
 1838898:	00000306 	br	18388a8 <tcp_receive+0x1750>
            } else {
              recv_data = cseg->p;
 183889c:	e0bffd17 	ldw	r2,-12(fp)
 18388a0:	10800117 	ldw	r2,4(r2)
 18388a4:	d0a81f15 	stw	r2,-24452(gp)
            }
            cseg->p = NULL;
 18388a8:	e0bffd17 	ldw	r2,-12(fp)
 18388ac:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 18388b0:	e0bffd17 	ldw	r2,-12(fp)
 18388b4:	10800417 	ldw	r2,16(r2)
 18388b8:	10c00303 	ldbu	r3,12(r2)
 18388bc:	10800343 	ldbu	r2,13(r2)
 18388c0:	1004923a 	slli	r2,r2,8
 18388c4:	10c4b03a 	or	r2,r2,r3
 18388c8:	10bfffcc 	andi	r2,r2,65535
 18388cc:	1004d23a 	srli	r2,r2,8
 18388d0:	10ffffcc 	andi	r3,r2,65535
 18388d4:	e0bffd17 	ldw	r2,-12(fp)
 18388d8:	10800417 	ldw	r2,16(r2)
 18388dc:	11000303 	ldbu	r4,12(r2)
 18388e0:	10800343 	ldbu	r2,13(r2)
 18388e4:	1004923a 	slli	r2,r2,8
 18388e8:	1104b03a 	or	r2,r2,r4
 18388ec:	10bfffcc 	andi	r2,r2,65535
 18388f0:	1004923a 	slli	r2,r2,8
 18388f4:	10bfffcc 	andi	r2,r2,65535
 18388f8:	1884b03a 	or	r2,r3,r2
 18388fc:	1080004c 	andi	r2,r2,1
 1838900:	10000a26 	beq	r2,zero,183892c <tcp_receive+0x17d4>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 1838904:	d0a81e03 	ldbu	r2,-24456(gp)
 1838908:	10800814 	ori	r2,r2,32
 183890c:	d0a81e05 	stb	r2,-24456(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 1838910:	e0bffe17 	ldw	r2,-8(fp)
 1838914:	10800617 	ldw	r2,24(r2)
 1838918:	10800118 	cmpnei	r2,r2,4
 183891c:	1000031e 	bne	r2,zero,183892c <tcp_receive+0x17d4>
              pcb->state = CLOSE_WAIT;
 1838920:	e0bffe17 	ldw	r2,-8(fp)
 1838924:	00c001c4 	movi	r3,7
 1838928:	10c00615 	stw	r3,24(r2)
            } 
          }

          pcb->ooseq = cseg->next;
 183892c:	e0bffd17 	ldw	r2,-12(fp)
 1838930:	10c00017 	ldw	r3,0(r2)
 1838934:	e0bffe17 	ldw	r2,-8(fp)
 1838938:	10c01e15 	stw	r3,120(r2)
          tcp_seg_free(cseg);
 183893c:	e13ffd17 	ldw	r4,-12(fp)
 1838940:	181d56c0 	call	181d56c <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 1838944:	e0bffe17 	ldw	r2,-8(fp)
 1838948:	10801e17 	ldw	r2,120(r2)
 183894c:	10001126 	beq	r2,zero,1838994 <tcp_receive+0x183c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 1838950:	e0bffe17 	ldw	r2,-8(fp)
 1838954:	10801e17 	ldw	r2,120(r2)
 1838958:	10800417 	ldw	r2,16(r2)
 183895c:	10c00103 	ldbu	r3,4(r2)
 1838960:	11000143 	ldbu	r4,5(r2)
 1838964:	2008923a 	slli	r4,r4,8
 1838968:	20c6b03a 	or	r3,r4,r3
 183896c:	11000183 	ldbu	r4,6(r2)
 1838970:	2008943a 	slli	r4,r4,16
 1838974:	20c6b03a 	or	r3,r4,r3
 1838978:	108001c3 	ldbu	r2,7(r2)
 183897c:	1004963a 	slli	r2,r2,24
 1838980:	10c4b03a 	or	r2,r2,r3
 1838984:	1007883a 	mov	r3,r2
 1838988:	e0bffe17 	ldw	r2,-8(fp)
 183898c:	10800b17 	ldw	r2,44(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 1838990:	18bf6326 	beq	r3,r2,1838720 <__ram_exceptions_end+0xff8282dc>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 1838994:	e0bffe17 	ldw	r2,-8(fp)
 1838998:	10800883 	ldbu	r2,34(r2)
 183899c:	10803fcc 	andi	r2,r2,255
 18389a0:	1080004c 	andi	r2,r2,1
 18389a4:	10000e26 	beq	r2,zero,18389e0 <tcp_receive+0x1888>
 18389a8:	e0bffe17 	ldw	r2,-8(fp)
 18389ac:	10c00883 	ldbu	r3,34(r2)
 18389b0:	00bfff84 	movi	r2,-2
 18389b4:	1884703a 	and	r2,r3,r2
 18389b8:	1007883a 	mov	r3,r2
 18389bc:	e0bffe17 	ldw	r2,-8(fp)
 18389c0:	10c00885 	stb	r3,34(r2)
 18389c4:	e0bffe17 	ldw	r2,-8(fp)
 18389c8:	10800883 	ldbu	r2,34(r2)
 18389cc:	10800094 	ori	r2,r2,2
 18389d0:	1007883a 	mov	r3,r2
 18389d4:	e0bffe17 	ldw	r2,-8(fp)
 18389d8:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 18389dc:	0001bd06 	br	18390d4 <tcp_receive+0x1f7c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 18389e0:	e0bffe17 	ldw	r2,-8(fp)
 18389e4:	10800883 	ldbu	r2,34(r2)
 18389e8:	10800054 	ori	r2,r2,1
 18389ec:	1007883a 	mov	r3,r2
 18389f0:	e0bffe17 	ldw	r2,-8(fp)
 18389f4:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 18389f8:	0001b606 	br	18390d4 <tcp_receive+0x1f7c>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 18389fc:	e13ffe17 	ldw	r4,-8(fp)
 1838a00:	181f7200 	call	181f720 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 1838a04:	e0bffe17 	ldw	r2,-8(fp)
 1838a08:	10801e17 	ldw	r2,120(r2)
 1838a0c:	1000071e 	bne	r2,zero,1838a2c <tcp_receive+0x18d4>
          pcb->ooseq = tcp_seg_copy(&inseg);
 1838a10:	010061b4 	movhi	r4,390
 1838a14:	2109a304 	addi	r4,r4,9868
 1838a18:	181d6000 	call	181d600 <tcp_seg_copy>
 1838a1c:	1007883a 	mov	r3,r2
 1838a20:	e0bffe17 	ldw	r2,-8(fp)
 1838a24:	10c01e15 	stw	r3,120(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 1838a28:	0001aa06 	br	18390d4 <tcp_receive+0x1f7c>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
 1838a2c:	e03ff515 	stw	zero,-44(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
 1838a30:	e0bffe17 	ldw	r2,-8(fp)
 1838a34:	10801e17 	ldw	r2,120(r2)
 1838a38:	e0bff415 	stw	r2,-48(fp)
 1838a3c:	00019306 	br	183908c <tcp_receive+0x1f34>
            if (seqno == next->tcphdr->seqno) {
 1838a40:	e0bff417 	ldw	r2,-48(fp)
 1838a44:	10800417 	ldw	r2,16(r2)
 1838a48:	10c00103 	ldbu	r3,4(r2)
 1838a4c:	11000143 	ldbu	r4,5(r2)
 1838a50:	2008923a 	slli	r4,r4,8
 1838a54:	20c6b03a 	or	r3,r4,r3
 1838a58:	11000183 	ldbu	r4,6(r2)
 1838a5c:	2008943a 	slli	r4,r4,16
 1838a60:	20c6b03a 	or	r3,r4,r3
 1838a64:	108001c3 	ldbu	r2,7(r2)
 1838a68:	1004963a 	slli	r2,r2,24
 1838a6c:	10c4b03a 	or	r2,r2,r3
 1838a70:	1007883a 	mov	r3,r2
 1838a74:	d0a81b17 	ldw	r2,-24468(gp)
 1838a78:	18801b1e 	bne	r3,r2,1838ae8 <tcp_receive+0x1990>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 1838a7c:	008061b4 	movhi	r2,390
 1838a80:	1089a304 	addi	r2,r2,9868
 1838a84:	1100020b 	ldhu	r4,8(r2)
 1838a88:	e0bff417 	ldw	r2,-48(fp)
 1838a8c:	10c0020b 	ldhu	r3,8(r2)
 1838a90:	20bfffcc 	andi	r2,r4,65535
 1838a94:	18ffffcc 	andi	r3,r3,65535
 1838a98:	18817f2e 	bgeu	r3,r2,1839098 <tcp_receive+0x1f40>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
 1838a9c:	010061b4 	movhi	r4,390
 1838aa0:	2109a304 	addi	r4,r4,9868
 1838aa4:	181d6000 	call	181d600 <tcp_seg_copy>
 1838aa8:	e0bffd15 	stw	r2,-12(fp)
                if (cseg != NULL) {
 1838aac:	e0bffd17 	ldw	r2,-12(fp)
 1838ab0:	10017b26 	beq	r2,zero,18390a0 <tcp_receive+0x1f48>
                  if (prev != NULL) {
 1838ab4:	e0bff517 	ldw	r2,-44(fp)
 1838ab8:	10000426 	beq	r2,zero,1838acc <tcp_receive+0x1974>
                    prev->next = cseg;
 1838abc:	e0bff517 	ldw	r2,-44(fp)
 1838ac0:	e0fffd17 	ldw	r3,-12(fp)
 1838ac4:	10c00015 	stw	r3,0(r2)
 1838ac8:	00000306 	br	1838ad8 <tcp_receive+0x1980>
                  } else {
                    pcb->ooseq = cseg;
 1838acc:	e0bffe17 	ldw	r2,-8(fp)
 1838ad0:	e0fffd17 	ldw	r3,-12(fp)
 1838ad4:	10c01e15 	stw	r3,120(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
 1838ad8:	e17ff417 	ldw	r5,-48(fp)
 1838adc:	e13ffd17 	ldw	r4,-12(fp)
 1838ae0:	1836eb80 	call	1836eb8 <tcp_oos_insert_segment>
                }
                break;
 1838ae4:	00016e06 	br	18390a0 <tcp_receive+0x1f48>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 1838ae8:	e0bff517 	ldw	r2,-44(fp)
 1838aec:	10001c1e 	bne	r2,zero,1838b60 <tcp_receive+0x1a08>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 1838af0:	d0e81b17 	ldw	r3,-24468(gp)
 1838af4:	e0bff417 	ldw	r2,-48(fp)
 1838af8:	10800417 	ldw	r2,16(r2)
 1838afc:	11000103 	ldbu	r4,4(r2)
 1838b00:	11400143 	ldbu	r5,5(r2)
 1838b04:	280a923a 	slli	r5,r5,8
 1838b08:	2908b03a 	or	r4,r5,r4
 1838b0c:	11400183 	ldbu	r5,6(r2)
 1838b10:	280a943a 	slli	r5,r5,16
 1838b14:	2908b03a 	or	r4,r5,r4
 1838b18:	108001c3 	ldbu	r2,7(r2)
 1838b1c:	1004963a 	slli	r2,r2,24
 1838b20:	1104b03a 	or	r2,r2,r4
 1838b24:	1885c83a 	sub	r2,r3,r2
 1838b28:	1000680e 	bge	r2,zero,1838ccc <tcp_receive+0x1b74>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
 1838b2c:	010061b4 	movhi	r4,390
 1838b30:	2109a304 	addi	r4,r4,9868
 1838b34:	181d6000 	call	181d600 <tcp_seg_copy>
 1838b38:	e0bffd15 	stw	r2,-12(fp)
                  if (cseg != NULL) {
 1838b3c:	e0bffd17 	ldw	r2,-12(fp)
 1838b40:	10015926 	beq	r2,zero,18390a8 <tcp_receive+0x1f50>
                    pcb->ooseq = cseg;
 1838b44:	e0bffe17 	ldw	r2,-8(fp)
 1838b48:	e0fffd17 	ldw	r3,-12(fp)
 1838b4c:	10c01e15 	stw	r3,120(r2)
                    tcp_oos_insert_segment(cseg, next);
 1838b50:	e17ff417 	ldw	r5,-48(fp)
 1838b54:	e13ffd17 	ldw	r4,-12(fp)
 1838b58:	1836eb80 	call	1836eb8 <tcp_oos_insert_segment>
                  }
                  break;
 1838b5c:	00015206 	br	18390a8 <tcp_receive+0x1f50>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 1838b60:	d0e81b17 	ldw	r3,-24468(gp)
 1838b64:	e0bff517 	ldw	r2,-44(fp)
 1838b68:	10800417 	ldw	r2,16(r2)
 1838b6c:	11000103 	ldbu	r4,4(r2)
 1838b70:	11400143 	ldbu	r5,5(r2)
 1838b74:	280a923a 	slli	r5,r5,8
 1838b78:	2908b03a 	or	r4,r5,r4
 1838b7c:	11400183 	ldbu	r5,6(r2)
 1838b80:	280a943a 	slli	r5,r5,16
 1838b84:	2908b03a 	or	r4,r5,r4
 1838b88:	108001c3 	ldbu	r2,7(r2)
 1838b8c:	1004963a 	slli	r2,r2,24
 1838b90:	1104b03a 	or	r2,r2,r4
 1838b94:	1885c83a 	sub	r2,r3,r2
 1838b98:	10bfffc4 	addi	r2,r2,-1
 1838b9c:	10004b16 	blt	r2,zero,1838ccc <tcp_receive+0x1b74>
 1838ba0:	d0e81b17 	ldw	r3,-24468(gp)
 1838ba4:	e0bff417 	ldw	r2,-48(fp)
 1838ba8:	10800417 	ldw	r2,16(r2)
 1838bac:	11000103 	ldbu	r4,4(r2)
 1838bb0:	11400143 	ldbu	r5,5(r2)
 1838bb4:	280a923a 	slli	r5,r5,8
 1838bb8:	2908b03a 	or	r4,r5,r4
 1838bbc:	11400183 	ldbu	r5,6(r2)
 1838bc0:	280a943a 	slli	r5,r5,16
 1838bc4:	2908b03a 	or	r4,r5,r4
 1838bc8:	108001c3 	ldbu	r2,7(r2)
 1838bcc:	1004963a 	slli	r2,r2,24
 1838bd0:	1104b03a 	or	r2,r2,r4
 1838bd4:	1885c83a 	sub	r2,r3,r2
 1838bd8:	10800044 	addi	r2,r2,1
 1838bdc:	00803b16 	blt	zero,r2,1838ccc <tcp_receive+0x1b74>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
 1838be0:	010061b4 	movhi	r4,390
 1838be4:	2109a304 	addi	r4,r4,9868
 1838be8:	181d6000 	call	181d600 <tcp_seg_copy>
 1838bec:	e0bffd15 	stw	r2,-12(fp)
                  if (cseg != NULL) {
 1838bf0:	e0bffd17 	ldw	r2,-12(fp)
 1838bf4:	10012e26 	beq	r2,zero,18390b0 <tcp_receive+0x1f58>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 1838bf8:	e0bff517 	ldw	r2,-44(fp)
 1838bfc:	10800417 	ldw	r2,16(r2)
 1838c00:	10c00103 	ldbu	r3,4(r2)
 1838c04:	11000143 	ldbu	r4,5(r2)
 1838c08:	2008923a 	slli	r4,r4,8
 1838c0c:	20c6b03a 	or	r3,r4,r3
 1838c10:	11000183 	ldbu	r4,6(r2)
 1838c14:	2008943a 	slli	r4,r4,16
 1838c18:	20c6b03a 	or	r3,r4,r3
 1838c1c:	108001c3 	ldbu	r2,7(r2)
 1838c20:	1004963a 	slli	r2,r2,24
 1838c24:	10c4b03a 	or	r2,r2,r3
 1838c28:	1007883a 	mov	r3,r2
 1838c2c:	e0bff517 	ldw	r2,-44(fp)
 1838c30:	1080020b 	ldhu	r2,8(r2)
 1838c34:	10bfffcc 	andi	r2,r2,65535
 1838c38:	1887883a 	add	r3,r3,r2
 1838c3c:	d0a81b17 	ldw	r2,-24468(gp)
 1838c40:	1885c83a 	sub	r2,r3,r2
 1838c44:	00801a0e 	bge	zero,r2,1838cb0 <tcp_receive+0x1b58>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 1838c48:	d0a81b17 	ldw	r2,-24468(gp)
 1838c4c:	100b883a 	mov	r5,r2
 1838c50:	e0bff517 	ldw	r2,-44(fp)
 1838c54:	10800417 	ldw	r2,16(r2)
 1838c58:	10c00103 	ldbu	r3,4(r2)
 1838c5c:	11000143 	ldbu	r4,5(r2)
 1838c60:	2008923a 	slli	r4,r4,8
 1838c64:	20c6b03a 	or	r3,r4,r3
 1838c68:	11000183 	ldbu	r4,6(r2)
 1838c6c:	2008943a 	slli	r4,r4,16
 1838c70:	20c6b03a 	or	r3,r4,r3
 1838c74:	108001c3 	ldbu	r2,7(r2)
 1838c78:	1004963a 	slli	r2,r2,24
 1838c7c:	10c4b03a 	or	r2,r2,r3
 1838c80:	2885c83a 	sub	r2,r5,r2
 1838c84:	1007883a 	mov	r3,r2
 1838c88:	e0bff517 	ldw	r2,-44(fp)
 1838c8c:	10c0020d 	sth	r3,8(r2)
                      pbuf_realloc(prev->p, prev->len);
 1838c90:	e0bff517 	ldw	r2,-44(fp)
 1838c94:	10c00117 	ldw	r3,4(r2)
 1838c98:	e0bff517 	ldw	r2,-44(fp)
 1838c9c:	1080020b 	ldhu	r2,8(r2)
 1838ca0:	10bfffcc 	andi	r2,r2,65535
 1838ca4:	100b883a 	mov	r5,r2
 1838ca8:	1809883a 	mov	r4,r3
 1838cac:	181a9940 	call	181a994 <pbuf_realloc>
                    }
                    prev->next = cseg;
 1838cb0:	e0bff517 	ldw	r2,-44(fp)
 1838cb4:	e0fffd17 	ldw	r3,-12(fp)
 1838cb8:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
 1838cbc:	e17ff417 	ldw	r5,-48(fp)
 1838cc0:	e13ffd17 	ldw	r4,-12(fp)
 1838cc4:	1836eb80 	call	1836eb8 <tcp_oos_insert_segment>
                  }
                  break;
 1838cc8:	0000f906 	br	18390b0 <tcp_receive+0x1f58>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 1838ccc:	e0bff417 	ldw	r2,-48(fp)
 1838cd0:	10800017 	ldw	r2,0(r2)
 1838cd4:	1000e81e 	bne	r2,zero,1839078 <tcp_receive+0x1f20>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 1838cd8:	d0e81b17 	ldw	r3,-24468(gp)
 1838cdc:	e0bff417 	ldw	r2,-48(fp)
 1838ce0:	10800417 	ldw	r2,16(r2)
 1838ce4:	11000103 	ldbu	r4,4(r2)
 1838ce8:	11400143 	ldbu	r5,5(r2)
 1838cec:	280a923a 	slli	r5,r5,8
 1838cf0:	2908b03a 	or	r4,r5,r4
 1838cf4:	11400183 	ldbu	r5,6(r2)
 1838cf8:	280a943a 	slli	r5,r5,16
 1838cfc:	2908b03a 	or	r4,r5,r4
 1838d00:	108001c3 	ldbu	r2,7(r2)
 1838d04:	1004963a 	slli	r2,r2,24
 1838d08:	1104b03a 	or	r2,r2,r4
 1838d0c:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 1838d10:	0080d90e 	bge	zero,r2,1839078 <tcp_receive+0x1f20>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 1838d14:	e0bff417 	ldw	r2,-48(fp)
 1838d18:	10800417 	ldw	r2,16(r2)
 1838d1c:	10c00303 	ldbu	r3,12(r2)
 1838d20:	10800343 	ldbu	r2,13(r2)
 1838d24:	1004923a 	slli	r2,r2,8
 1838d28:	10c4b03a 	or	r2,r2,r3
 1838d2c:	10bfffcc 	andi	r2,r2,65535
 1838d30:	1004d23a 	srli	r2,r2,8
 1838d34:	10ffffcc 	andi	r3,r2,65535
 1838d38:	e0bff417 	ldw	r2,-48(fp)
 1838d3c:	10800417 	ldw	r2,16(r2)
 1838d40:	11000303 	ldbu	r4,12(r2)
 1838d44:	10800343 	ldbu	r2,13(r2)
 1838d48:	1004923a 	slli	r2,r2,8
 1838d4c:	1104b03a 	or	r2,r2,r4
 1838d50:	10bfffcc 	andi	r2,r2,65535
 1838d54:	1004923a 	slli	r2,r2,8
 1838d58:	10bfffcc 	andi	r2,r2,65535
 1838d5c:	1884b03a 	or	r2,r3,r2
 1838d60:	1080004c 	andi	r2,r2,1
 1838d64:	1000d41e 	bne	r2,zero,18390b8 <tcp_receive+0x1f60>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 1838d68:	010061b4 	movhi	r4,390
 1838d6c:	2109a304 	addi	r4,r4,9868
 1838d70:	181d6000 	call	181d600 <tcp_seg_copy>
 1838d74:	1007883a 	mov	r3,r2
 1838d78:	e0bff417 	ldw	r2,-48(fp)
 1838d7c:	10c00015 	stw	r3,0(r2)
                if (next->next != NULL) {
 1838d80:	e0bff417 	ldw	r2,-48(fp)
 1838d84:	10800017 	ldw	r2,0(r2)
 1838d88:	1000cd26 	beq	r2,zero,18390c0 <tcp_receive+0x1f68>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 1838d8c:	e0bff417 	ldw	r2,-48(fp)
 1838d90:	10800417 	ldw	r2,16(r2)
 1838d94:	10c00103 	ldbu	r3,4(r2)
 1838d98:	11000143 	ldbu	r4,5(r2)
 1838d9c:	2008923a 	slli	r4,r4,8
 1838da0:	20c6b03a 	or	r3,r4,r3
 1838da4:	11000183 	ldbu	r4,6(r2)
 1838da8:	2008943a 	slli	r4,r4,16
 1838dac:	20c6b03a 	or	r3,r4,r3
 1838db0:	108001c3 	ldbu	r2,7(r2)
 1838db4:	1004963a 	slli	r2,r2,24
 1838db8:	10c4b03a 	or	r2,r2,r3
 1838dbc:	1007883a 	mov	r3,r2
 1838dc0:	e0bff417 	ldw	r2,-48(fp)
 1838dc4:	1080020b 	ldhu	r2,8(r2)
 1838dc8:	10bfffcc 	andi	r2,r2,65535
 1838dcc:	1887883a 	add	r3,r3,r2
 1838dd0:	d0a81b17 	ldw	r2,-24468(gp)
 1838dd4:	1885c83a 	sub	r2,r3,r2
 1838dd8:	00801a0e 	bge	zero,r2,1838e44 <tcp_receive+0x1cec>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 1838ddc:	d0a81b17 	ldw	r2,-24468(gp)
 1838de0:	100b883a 	mov	r5,r2
 1838de4:	e0bff417 	ldw	r2,-48(fp)
 1838de8:	10800417 	ldw	r2,16(r2)
 1838dec:	10c00103 	ldbu	r3,4(r2)
 1838df0:	11000143 	ldbu	r4,5(r2)
 1838df4:	2008923a 	slli	r4,r4,8
 1838df8:	20c6b03a 	or	r3,r4,r3
 1838dfc:	11000183 	ldbu	r4,6(r2)
 1838e00:	2008943a 	slli	r4,r4,16
 1838e04:	20c6b03a 	or	r3,r4,r3
 1838e08:	108001c3 	ldbu	r2,7(r2)
 1838e0c:	1004963a 	slli	r2,r2,24
 1838e10:	10c4b03a 	or	r2,r2,r3
 1838e14:	2885c83a 	sub	r2,r5,r2
 1838e18:	1007883a 	mov	r3,r2
 1838e1c:	e0bff417 	ldw	r2,-48(fp)
 1838e20:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->p, next->len);
 1838e24:	e0bff417 	ldw	r2,-48(fp)
 1838e28:	10c00117 	ldw	r3,4(r2)
 1838e2c:	e0bff417 	ldw	r2,-48(fp)
 1838e30:	1080020b 	ldhu	r2,8(r2)
 1838e34:	10bfffcc 	andi	r2,r2,65535
 1838e38:	100b883a 	mov	r5,r2
 1838e3c:	1809883a 	mov	r4,r3
 1838e40:	181a9940 	call	181a994 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 1838e44:	d0a81d8b 	ldhu	r2,-24458(gp)
 1838e48:	10ffffcc 	andi	r3,r2,65535
 1838e4c:	d0a81b17 	ldw	r2,-24468(gp)
 1838e50:	1885883a 	add	r2,r3,r2
 1838e54:	e0fffe17 	ldw	r3,-8(fp)
 1838e58:	19000b17 	ldw	r4,44(r3)
 1838e5c:	e0fffe17 	ldw	r3,-8(fp)
 1838e60:	18c00c0b 	ldhu	r3,48(r3)
 1838e64:	18ffffcc 	andi	r3,r3,65535
 1838e68:	20c7883a 	add	r3,r4,r3
 1838e6c:	1880942e 	bgeu	r3,r2,18390c0 <tcp_receive+0x1f68>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 1838e70:	e0bff417 	ldw	r2,-48(fp)
 1838e74:	10800017 	ldw	r2,0(r2)
 1838e78:	10800417 	ldw	r2,16(r2)
 1838e7c:	10c00303 	ldbu	r3,12(r2)
 1838e80:	10800343 	ldbu	r2,13(r2)
 1838e84:	1004923a 	slli	r2,r2,8
 1838e88:	10c4b03a 	or	r2,r2,r3
 1838e8c:	10bfffcc 	andi	r2,r2,65535
 1838e90:	1004d23a 	srli	r2,r2,8
 1838e94:	10ffffcc 	andi	r3,r2,65535
 1838e98:	e0bff417 	ldw	r2,-48(fp)
 1838e9c:	10800017 	ldw	r2,0(r2)
 1838ea0:	10800417 	ldw	r2,16(r2)
 1838ea4:	11000303 	ldbu	r4,12(r2)
 1838ea8:	10800343 	ldbu	r2,13(r2)
 1838eac:	1004923a 	slli	r2,r2,8
 1838eb0:	1104b03a 	or	r2,r2,r4
 1838eb4:	10bfffcc 	andi	r2,r2,65535
 1838eb8:	1004923a 	slli	r2,r2,8
 1838ebc:	10bfffcc 	andi	r2,r2,65535
 1838ec0:	1884b03a 	or	r2,r3,r2
 1838ec4:	1080004c 	andi	r2,r2,1
 1838ec8:	10003726 	beq	r2,zero,1838fa8 <tcp_receive+0x1e50>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 1838ecc:	e0bff417 	ldw	r2,-48(fp)
 1838ed0:	10800017 	ldw	r2,0(r2)
 1838ed4:	10800417 	ldw	r2,16(r2)
 1838ed8:	e0fff417 	ldw	r3,-48(fp)
 1838edc:	18c00017 	ldw	r3,0(r3)
 1838ee0:	18c00417 	ldw	r3,16(r3)
 1838ee4:	19000303 	ldbu	r4,12(r3)
 1838ee8:	18c00343 	ldbu	r3,13(r3)
 1838eec:	1806923a 	slli	r3,r3,8
 1838ef0:	1906b03a 	or	r3,r3,r4
 1838ef4:	1809883a 	mov	r4,r3
 1838ef8:	00f03fc4 	movi	r3,-16129
 1838efc:	20c6703a 	and	r3,r4,r3
 1838f00:	180b883a 	mov	r5,r3
 1838f04:	e0fff417 	ldw	r3,-48(fp)
 1838f08:	18c00017 	ldw	r3,0(r3)
 1838f0c:	18c00417 	ldw	r3,16(r3)
 1838f10:	19000303 	ldbu	r4,12(r3)
 1838f14:	18c00343 	ldbu	r3,13(r3)
 1838f18:	1806923a 	slli	r3,r3,8
 1838f1c:	1906b03a 	or	r3,r3,r4
 1838f20:	18ffffcc 	andi	r3,r3,65535
 1838f24:	1806d23a 	srli	r3,r3,8
 1838f28:	180d883a 	mov	r6,r3
 1838f2c:	e0fff417 	ldw	r3,-48(fp)
 1838f30:	18c00017 	ldw	r3,0(r3)
 1838f34:	18c00417 	ldw	r3,16(r3)
 1838f38:	19000303 	ldbu	r4,12(r3)
 1838f3c:	18c00343 	ldbu	r3,13(r3)
 1838f40:	1806923a 	slli	r3,r3,8
 1838f44:	1906b03a 	or	r3,r3,r4
 1838f48:	18ffffcc 	andi	r3,r3,65535
 1838f4c:	1806923a 	slli	r3,r3,8
 1838f50:	30c6b03a 	or	r3,r6,r3
 1838f54:	18c00f8c 	andi	r3,r3,62
 1838f58:	1806923a 	slli	r3,r3,8
 1838f5c:	28c6b03a 	or	r3,r5,r3
 1838f60:	180d883a 	mov	r6,r3
 1838f64:	30ffffcc 	andi	r3,r6,65535
 1838f68:	19403fcc 	andi	r5,r3,255
 1838f6c:	10c00303 	ldbu	r3,12(r2)
 1838f70:	1806703a 	and	r3,r3,zero
 1838f74:	1809883a 	mov	r4,r3
 1838f78:	2807883a 	mov	r3,r5
 1838f7c:	20c6b03a 	or	r3,r4,r3
 1838f80:	10c00305 	stb	r3,12(r2)
 1838f84:	30ffffcc 	andi	r3,r6,65535
 1838f88:	1806d23a 	srli	r3,r3,8
 1838f8c:	197fffcc 	andi	r5,r3,65535
 1838f90:	10c00343 	ldbu	r3,13(r2)
 1838f94:	1806703a 	and	r3,r3,zero
 1838f98:	1809883a 	mov	r4,r3
 1838f9c:	2807883a 	mov	r3,r5
 1838fa0:	20c6b03a 	or	r3,r4,r3
 1838fa4:	10c00345 	stb	r3,13(r2)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 1838fa8:	e0bff417 	ldw	r2,-48(fp)
 1838fac:	10800017 	ldw	r2,0(r2)
 1838fb0:	e0fffe17 	ldw	r3,-8(fp)
 1838fb4:	18c00b17 	ldw	r3,44(r3)
 1838fb8:	1809883a 	mov	r4,r3
 1838fbc:	e0fffe17 	ldw	r3,-8(fp)
 1838fc0:	18c00c0b 	ldhu	r3,48(r3)
 1838fc4:	20c7883a 	add	r3,r4,r3
 1838fc8:	1809883a 	mov	r4,r3
 1838fcc:	d0e81b17 	ldw	r3,-24468(gp)
 1838fd0:	20c7c83a 	sub	r3,r4,r3
 1838fd4:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
 1838fd8:	e0bff417 	ldw	r2,-48(fp)
 1838fdc:	10800017 	ldw	r2,0(r2)
 1838fe0:	10c00117 	ldw	r3,4(r2)
 1838fe4:	e0bff417 	ldw	r2,-48(fp)
 1838fe8:	10800017 	ldw	r2,0(r2)
 1838fec:	1080020b 	ldhu	r2,8(r2)
 1838ff0:	10bfffcc 	andi	r2,r2,65535
 1838ff4:	100b883a 	mov	r5,r2
 1838ff8:	1809883a 	mov	r4,r3
 1838ffc:	181a9940 	call	181a994 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 1839000:	e0bff417 	ldw	r2,-48(fp)
 1839004:	10800017 	ldw	r2,0(r2)
 1839008:	10c0020b 	ldhu	r3,8(r2)
 183900c:	e0bff417 	ldw	r2,-48(fp)
 1839010:	10800017 	ldw	r2,0(r2)
 1839014:	10800417 	ldw	r2,16(r2)
 1839018:	11000303 	ldbu	r4,12(r2)
 183901c:	10800343 	ldbu	r2,13(r2)
 1839020:	1004923a 	slli	r2,r2,8
 1839024:	1104b03a 	or	r2,r2,r4
 1839028:	10bfffcc 	andi	r2,r2,65535
 183902c:	1004d23a 	srli	r2,r2,8
 1839030:	113fffcc 	andi	r4,r2,65535
 1839034:	e0bff417 	ldw	r2,-48(fp)
 1839038:	10800017 	ldw	r2,0(r2)
 183903c:	10800417 	ldw	r2,16(r2)
 1839040:	11400303 	ldbu	r5,12(r2)
 1839044:	10800343 	ldbu	r2,13(r2)
 1839048:	1004923a 	slli	r2,r2,8
 183904c:	1144b03a 	or	r2,r2,r5
 1839050:	10bfffcc 	andi	r2,r2,65535
 1839054:	1004923a 	slli	r2,r2,8
 1839058:	10bfffcc 	andi	r2,r2,65535
 183905c:	2084b03a 	or	r2,r4,r2
 1839060:	108000cc 	andi	r2,r2,3
 1839064:	1004c03a 	cmpne	r2,r2,zero
 1839068:	10803fcc 	andi	r2,r2,255
 183906c:	1885883a 	add	r2,r3,r2
 1839070:	d0a81d8d 	sth	r2,-24458(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 1839074:	00001206 	br	18390c0 <tcp_receive+0x1f68>
              }
            }
            prev = next;
 1839078:	e0bff417 	ldw	r2,-48(fp)
 183907c:	e0bff515 	stw	r2,-44(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
 1839080:	e0bff417 	ldw	r2,-48(fp)
 1839084:	10800017 	ldw	r2,0(r2)
 1839088:	e0bff415 	stw	r2,-48(fp)
 183908c:	e0bff417 	ldw	r2,-48(fp)
 1839090:	103e6b1e 	bne	r2,zero,1838a40 <__ram_exceptions_end+0xff8285fc>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 1839094:	00000f06 	br	18390d4 <tcp_receive+0x1f7c>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
 1839098:	0001883a 	nop
 183909c:	00000d06 	br	18390d4 <tcp_receive+0x1f7c>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
 18390a0:	0001883a 	nop
 18390a4:	00000b06 	br	18390d4 <tcp_receive+0x1f7c>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 18390a8:	0001883a 	nop
 18390ac:	00000906 	br	18390d4 <tcp_receive+0x1f7c>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 18390b0:	0001883a 	nop
 18390b4:	00000706 	br	18390d4 <tcp_receive+0x1f7c>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
 18390b8:	0001883a 	nop
 18390bc:	00000506 	br	18390d4 <tcp_receive+0x1f7c>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 18390c0:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 18390c4:	00000306 	br	18390d4 <tcp_receive+0x1f7c>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 18390c8:	e13ffe17 	ldw	r4,-8(fp)
 18390cc:	181f7200 	call	181f720 <tcp_send_empty_ack>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 18390d0:	00001706 	br	1839130 <tcp_receive+0x1fd8>
 18390d4:	00001606 	br	1839130 <tcp_receive+0x1fd8>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 18390d8:	d0e81b17 	ldw	r3,-24468(gp)
 18390dc:	e0bffe17 	ldw	r2,-8(fp)
 18390e0:	10800b17 	ldw	r2,44(r2)
 18390e4:	1885c83a 	sub	r2,r3,r2
 18390e8:	10000a16 	blt	r2,zero,1839114 <tcp_receive+0x1fbc>
 18390ec:	d0e81b17 	ldw	r3,-24468(gp)
 18390f0:	e0bffe17 	ldw	r2,-8(fp)
 18390f4:	11000b17 	ldw	r4,44(r2)
 18390f8:	e0bffe17 	ldw	r2,-8(fp)
 18390fc:	10800c0b 	ldhu	r2,48(r2)
 1839100:	10bfffcc 	andi	r2,r2,65535
 1839104:	2085883a 	add	r2,r4,r2
 1839108:	1885c83a 	sub	r2,r3,r2
 183910c:	10800044 	addi	r2,r2,1
 1839110:	0080070e 	bge	zero,r2,1839130 <tcp_receive+0x1fd8>
      tcp_ack_now(pcb);
 1839114:	e0bffe17 	ldw	r2,-8(fp)
 1839118:	10800883 	ldbu	r2,34(r2)
 183911c:	10800094 	ori	r2,r2,2
 1839120:	1007883a 	mov	r3,r2
 1839124:	e0bffe17 	ldw	r2,-8(fp)
 1839128:	10c00885 	stb	r3,34(r2)
    }
  }
}
 183912c:	00000006 	br	1839130 <tcp_receive+0x1fd8>
 1839130:	0001883a 	nop
 1839134:	e6ffff04 	addi	sp,fp,-4
 1839138:	dfc00217 	ldw	ra,8(sp)
 183913c:	df000117 	ldw	fp,4(sp)
 1839140:	dc000017 	ldw	r16,0(sp)
 1839144:	dec00304 	addi	sp,sp,12
 1839148:	f800283a 	ret

0183914c <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 183914c:	defffa04 	addi	sp,sp,-24
 1839150:	df000515 	stw	fp,20(sp)
 1839154:	df000504 	addi	fp,sp,20
 1839158:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 183915c:	d0a81917 	ldw	r2,-24476(gp)
 1839160:	10800504 	addi	r2,r2,20
 1839164:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 1839168:	d0a81917 	ldw	r2,-24476(gp)
 183916c:	10c00303 	ldbu	r3,12(r2)
 1839170:	10800343 	ldbu	r2,13(r2)
 1839174:	1004923a 	slli	r2,r2,8
 1839178:	10c4b03a 	or	r2,r2,r3
 183917c:	10bfffcc 	andi	r2,r2,65535
 1839180:	1004d23a 	srli	r2,r2,8
 1839184:	10ffffcc 	andi	r3,r2,65535
 1839188:	d0a81917 	ldw	r2,-24476(gp)
 183918c:	11000303 	ldbu	r4,12(r2)
 1839190:	10800343 	ldbu	r2,13(r2)
 1839194:	1004923a 	slli	r2,r2,8
 1839198:	1104b03a 	or	r2,r2,r4
 183919c:	10bfffcc 	andi	r2,r2,65535
 18391a0:	1004923a 	slli	r2,r2,8
 18391a4:	10bfffcc 	andi	r2,r2,65535
 18391a8:	1884b03a 	or	r2,r3,r2
 18391ac:	1005d33a 	srai	r2,r2,12
 18391b0:	10800190 	cmplti	r2,r2,6
 18391b4:	10006b1e 	bne	r2,zero,1839364 <tcp_parseopt+0x218>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 18391b8:	d0a81917 	ldw	r2,-24476(gp)
 18391bc:	10c00303 	ldbu	r3,12(r2)
 18391c0:	10800343 	ldbu	r2,13(r2)
 18391c4:	1004923a 	slli	r2,r2,8
 18391c8:	10c4b03a 	or	r2,r2,r3
 18391cc:	10bfffcc 	andi	r2,r2,65535
 18391d0:	1004d23a 	srli	r2,r2,8
 18391d4:	10ffffcc 	andi	r3,r2,65535
 18391d8:	d0a81917 	ldw	r2,-24476(gp)
 18391dc:	11000303 	ldbu	r4,12(r2)
 18391e0:	10800343 	ldbu	r2,13(r2)
 18391e4:	1004923a 	slli	r2,r2,8
 18391e8:	1104b03a 	or	r2,r2,r4
 18391ec:	10bfffcc 	andi	r2,r2,65535
 18391f0:	1004923a 	slli	r2,r2,8
 18391f4:	10bfffcc 	andi	r2,r2,65535
 18391f8:	1884b03a 	or	r2,r3,r2
 18391fc:	1005d33a 	srai	r2,r2,12
 1839200:	10bffec4 	addi	r2,r2,-5
 1839204:	1085883a 	add	r2,r2,r2
 1839208:	1085883a 	add	r2,r2,r2
 183920c:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
 1839210:	e03ffb0d 	sth	zero,-20(fp)
 1839214:	00004a06 	br	1839340 <tcp_parseopt+0x1f4>
      opt = opts[c];
 1839218:	e0bffb0b 	ldhu	r2,-20(fp)
 183921c:	e0fffc17 	ldw	r3,-16(fp)
 1839220:	1885883a 	add	r2,r3,r2
 1839224:	10800003 	ldbu	r2,0(r2)
 1839228:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
 183922c:	e0bffd83 	ldbu	r2,-10(fp)
 1839230:	10c00060 	cmpeqi	r3,r2,1
 1839234:	1800041e 	bne	r3,zero,1839248 <tcp_parseopt+0xfc>
 1839238:	10c000a0 	cmpeqi	r3,r2,2
 183923c:	1800061e 	bne	r3,zero,1839258 <tcp_parseopt+0x10c>
 1839240:	10004326 	beq	r2,zero,1839350 <tcp_parseopt+0x204>
 1839244:	00002e06 	br	1839300 <tcp_parseopt+0x1b4>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 1839248:	e0bffb0b 	ldhu	r2,-20(fp)
 183924c:	10800044 	addi	r2,r2,1
 1839250:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
 1839254:	00003a06 	br	1839340 <tcp_parseopt+0x1f4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 1839258:	e0bffb0b 	ldhu	r2,-20(fp)
 183925c:	10800044 	addi	r2,r2,1
 1839260:	e0fffc17 	ldw	r3,-16(fp)
 1839264:	1885883a 	add	r2,r3,r2
 1839268:	10800003 	ldbu	r2,0(r2)
 183926c:	10803fcc 	andi	r2,r2,255
 1839270:	10800118 	cmpnei	r2,r2,4
 1839274:	1000381e 	bne	r2,zero,1839358 <tcp_parseopt+0x20c>
 1839278:	e0bffb0b 	ldhu	r2,-20(fp)
 183927c:	10800104 	addi	r2,r2,4
 1839280:	e0fffd0b 	ldhu	r3,-12(fp)
 1839284:	18803416 	blt	r3,r2,1839358 <tcp_parseopt+0x20c>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 1839288:	e0bffb0b 	ldhu	r2,-20(fp)
 183928c:	10800084 	addi	r2,r2,2
 1839290:	e0fffc17 	ldw	r3,-16(fp)
 1839294:	1885883a 	add	r2,r3,r2
 1839298:	10800003 	ldbu	r2,0(r2)
 183929c:	10803fcc 	andi	r2,r2,255
 18392a0:	1004923a 	slli	r2,r2,8
 18392a4:	1009883a 	mov	r4,r2
 18392a8:	e0bffb0b 	ldhu	r2,-20(fp)
 18392ac:	108000c4 	addi	r2,r2,3
 18392b0:	e0fffc17 	ldw	r3,-16(fp)
 18392b4:	1885883a 	add	r2,r3,r2
 18392b8:	10800003 	ldbu	r2,0(r2)
 18392bc:	10803fcc 	andi	r2,r2,255
 18392c0:	2084b03a 	or	r2,r4,r2
 18392c4:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 18392c8:	e0bffe0b 	ldhu	r2,-8(fp)
 18392cc:	10816d68 	cmpgeui	r2,r2,1461
 18392d0:	1000041e 	bne	r2,zero,18392e4 <tcp_parseopt+0x198>
 18392d4:	e0bffe0b 	ldhu	r2,-8(fp)
 18392d8:	10000226 	beq	r2,zero,18392e4 <tcp_parseopt+0x198>
 18392dc:	e0bffe0b 	ldhu	r2,-8(fp)
 18392e0:	00000106 	br	18392e8 <tcp_parseopt+0x19c>
 18392e4:	00816d04 	movi	r2,1460
 18392e8:	e0ffff17 	ldw	r3,-4(fp)
 18392ec:	18800e8d 	sth	r2,58(r3)
        /* Advance to next option */
        c += 0x04;
 18392f0:	e0bffb0b 	ldhu	r2,-20(fp)
 18392f4:	10800104 	addi	r2,r2,4
 18392f8:	e0bffb0d 	sth	r2,-20(fp)
        break;
 18392fc:	00001006 	br	1839340 <tcp_parseopt+0x1f4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 1839300:	e0bffb0b 	ldhu	r2,-20(fp)
 1839304:	10800044 	addi	r2,r2,1
 1839308:	e0fffc17 	ldw	r3,-16(fp)
 183930c:	1885883a 	add	r2,r3,r2
 1839310:	10800003 	ldbu	r2,0(r2)
 1839314:	10803fcc 	andi	r2,r2,255
 1839318:	10001126 	beq	r2,zero,1839360 <tcp_parseopt+0x214>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 183931c:	e0bffb0b 	ldhu	r2,-20(fp)
 1839320:	10800044 	addi	r2,r2,1
 1839324:	e0fffc17 	ldw	r3,-16(fp)
 1839328:	1885883a 	add	r2,r3,r2
 183932c:	10800003 	ldbu	r2,0(r2)
 1839330:	10c03fcc 	andi	r3,r2,255
 1839334:	e0bffb0b 	ldhu	r2,-20(fp)
 1839338:	1885883a 	add	r2,r3,r2
 183933c:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 1839340:	e0fffb0b 	ldhu	r3,-20(fp)
 1839344:	e0bffd0b 	ldhu	r2,-12(fp)
 1839348:	18bfb336 	bltu	r3,r2,1839218 <__ram_exceptions_end+0xff828dd4>
 183934c:	00000506 	br	1839364 <tcp_parseopt+0x218>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
 1839350:	0001883a 	nop
 1839354:	00000306 	br	1839364 <tcp_parseopt+0x218>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
 1839358:	0001883a 	nop
 183935c:	00000106 	br	1839364 <tcp_parseopt+0x218>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
 1839360:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
 1839364:	e037883a 	mov	sp,fp
 1839368:	df000017 	ldw	fp,0(sp)
 183936c:	dec00104 	addi	sp,sp,4
 1839370:	f800283a 	ret

01839374 <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 1839374:	defffb04 	addi	sp,sp,-20
 1839378:	df000415 	stw	fp,16(sp)
 183937c:	df000404 	addi	fp,sp,16
 1839380:	e13ffe15 	stw	r4,-8(fp)
 1839384:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 1839388:	e0bfff17 	ldw	r2,-4(fp)
 183938c:	10900070 	cmpltui	r2,r2,16385
 1839390:	1000021e 	bne	r2,zero,183939c <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 1839394:	00900004 	movi	r2,16384
 1839398:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 183939c:	e0fffe17 	ldw	r3,-8(fp)
 18393a0:	e0bfff17 	ldw	r2,-4(fp)
 18393a4:	1885883a 	add	r2,r3,r2
 18393a8:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 18393ac:	e0bffe17 	ldw	r2,-8(fp)
 18393b0:	e0bffc15 	stw	r2,-16(fp)
 18393b4:	00000506 	br	18393cc <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 18393b8:	e0bffc17 	ldw	r2,-16(fp)
 18393bc:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 18393c0:	e0bffc17 	ldw	r2,-16(fp)
 18393c4:	10800804 	addi	r2,r2,32
 18393c8:	e0bffc15 	stw	r2,-16(fp)
 18393cc:	e0fffc17 	ldw	r3,-16(fp)
 18393d0:	e0bffd17 	ldw	r2,-12(fp)
 18393d4:	18bff836 	bltu	r3,r2,18393b8 <__ram_exceptions_end+0xff828f74>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 18393d8:	e0bffe17 	ldw	r2,-8(fp)
 18393dc:	108007cc 	andi	r2,r2,31
 18393e0:	10000226 	beq	r2,zero,18393ec <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 18393e4:	e0bffc17 	ldw	r2,-16(fp)
 18393e8:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 18393ec:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 18393f0:	0001883a 	nop
 18393f4:	e037883a 	mov	sp,fp
 18393f8:	df000017 	ldw	fp,0(sp)
 18393fc:	dec00104 	addi	sp,sp,4
 1839400:	f800283a 	ret

01839404 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
 1839404:	defff404 	addi	sp,sp,-48
 1839408:	dfc00b15 	stw	ra,44(sp)
 183940c:	df000a15 	stw	fp,40(sp)
 1839410:	df000a04 	addi	fp,sp,40
 1839414:	e13ffd15 	stw	r4,-12(fp)
 1839418:	2805883a 	mov	r2,r5
 183941c:	e1bfff15 	stw	r6,-4(fp)
 1839420:	e0bffe05 	stb	r2,-8(fp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
 1839424:	e17fff17 	ldw	r5,-4(fp)
 1839428:	e13ffd17 	ldw	r4,-12(fp)
 183942c:	183b0900 	call	183b090 <netconn_alloc>
 1839430:	e0bff615 	stw	r2,-40(fp)
  if (conn != NULL) {
 1839434:	e0bff617 	ldw	r2,-40(fp)
 1839438:	10001b26 	beq	r2,zero,18394a8 <netconn_new_with_proto_and_callback+0xa4>
    msg.function = do_newconn;
 183943c:	00806134 	movhi	r2,388
 1839440:	10ac0c04 	addi	r2,r2,-20432
 1839444:	e0bff715 	stw	r2,-36(fp)
    msg.msg.msg.n.proto = proto;
 1839448:	e0bffe03 	ldbu	r2,-8(fp)
 183944c:	e0bffa05 	stb	r2,-24(fp)
    msg.msg.conn = conn;
 1839450:	e0bff617 	ldw	r2,-40(fp)
 1839454:	e0bff815 	stw	r2,-32(fp)
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 1839458:	e0bff704 	addi	r2,fp,-36
 183945c:	1009883a 	mov	r4,r2
 1839460:	182bf140 	call	182bf14 <tcpip_apimsg>
 1839464:	10803fcc 	andi	r2,r2,255
 1839468:	1080201c 	xori	r2,r2,128
 183946c:	10bfe004 	addi	r2,r2,-128
 1839470:	10000d26 	beq	r2,zero,18394a8 <netconn_new_with_proto_and_callback+0xa4>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
 1839474:	e0bff617 	ldw	r2,-40(fp)
 1839478:	10800404 	addi	r2,r2,16
 183947c:	1009883a 	mov	r4,r2
 1839480:	181501c0 	call	181501c <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 1839484:	e0bff617 	ldw	r2,-40(fp)
 1839488:	10800504 	addi	r2,r2,20
 183948c:	1009883a 	mov	r4,r2
 1839490:	18154140 	call	1815414 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 1839494:	e17ff617 	ldw	r5,-40(fp)
 1839498:	01000204 	movi	r4,8
 183949c:	1834b240 	call	1834b24 <memp_free>
      return NULL;
 18394a0:	0005883a 	mov	r2,zero
 18394a4:	00000106 	br	18394ac <netconn_new_with_proto_and_callback+0xa8>
    }
  }
  return conn;
 18394a8:	e0bff617 	ldw	r2,-40(fp)
}
 18394ac:	e037883a 	mov	sp,fp
 18394b0:	dfc00117 	ldw	ra,4(sp)
 18394b4:	df000017 	ldw	fp,0(sp)
 18394b8:	dec00204 	addi	sp,sp,8
 18394bc:	f800283a 	ret

018394c0 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
 18394c0:	defff704 	addi	sp,sp,-36
 18394c4:	dfc00815 	stw	ra,32(sp)
 18394c8:	df000715 	stw	fp,28(sp)
 18394cc:	df000704 	addi	fp,sp,28
 18394d0:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 18394d4:	e0bfff17 	ldw	r2,-4(fp)
 18394d8:	1000021e 	bne	r2,zero,18394e4 <netconn_delete+0x24>
    return ERR_OK;
 18394dc:	0005883a 	mov	r2,zero
 18394e0:	00000a06 	br	183950c <netconn_delete+0x4c>
  }

  msg.function = do_delconn;
 18394e4:	00806134 	movhi	r2,388
 18394e8:	10ad8604 	addi	r2,r2,-18920
 18394ec:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
 18394f0:	e0bfff17 	ldw	r2,-4(fp)
 18394f4:	e0bffa15 	stw	r2,-24(fp)
  tcpip_apimsg(&msg);
 18394f8:	e13ff904 	addi	r4,fp,-28
 18394fc:	182bf140 	call	182bf14 <tcpip_apimsg>

  netconn_free(conn);
 1839500:	e13fff17 	ldw	r4,-4(fp)
 1839504:	183b1bc0 	call	183b1bc <netconn_free>

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
 1839508:	0005883a 	mov	r2,zero
}
 183950c:	e037883a 	mov	sp,fp
 1839510:	dfc00117 	ldw	ra,4(sp)
 1839514:	df000017 	ldw	fp,0(sp)
 1839518:	dec00204 	addi	sp,sp,8
 183951c:	f800283a 	ret

01839520 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
 1839520:	defff304 	addi	sp,sp,-52
 1839524:	dfc00c15 	stw	ra,48(sp)
 1839528:	df000b15 	stw	fp,44(sp)
 183952c:	df000b04 	addi	fp,sp,44
 1839530:	e13ffc15 	stw	r4,-16(fp)
 1839534:	e17ffd15 	stw	r5,-12(fp)
 1839538:	e1bffe15 	stw	r6,-8(fp)
 183953c:	3805883a 	mov	r2,r7
 1839540:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 1839544:	e0bffc17 	ldw	r2,-16(fp)
 1839548:	1000091e 	bne	r2,zero,1839570 <netconn_getaddr+0x50>
 183954c:	01c06134 	movhi	r7,388
 1839550:	39cec004 	addi	r7,r7,15104
 1839554:	01802304 	movi	r6,140
 1839558:	01406134 	movhi	r5,388
 183955c:	294ec604 	addi	r5,r5,15128
 1839560:	01006134 	movhi	r4,388
 1839564:	210ece04 	addi	r4,r4,15160
 1839568:	1800c180 	call	1800c18 <printf>
 183956c:	003fff06 	br	183956c <__ram_exceptions_end+0xff829128>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 1839570:	e0bffd17 	ldw	r2,-12(fp)
 1839574:	1000091e 	bne	r2,zero,183959c <netconn_getaddr+0x7c>
 1839578:	01c06134 	movhi	r7,388
 183957c:	39cec004 	addi	r7,r7,15104
 1839580:	01802344 	movi	r6,141
 1839584:	01406134 	movhi	r5,388
 1839588:	294eda04 	addi	r5,r5,15208
 183958c:	01006134 	movhi	r4,388
 1839590:	210ece04 	addi	r4,r4,15160
 1839594:	1800c180 	call	1800c18 <printf>
 1839598:	003fff06 	br	1839598 <__ram_exceptions_end+0xff829154>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 183959c:	e0bffe17 	ldw	r2,-8(fp)
 18395a0:	1000091e 	bne	r2,zero,18395c8 <netconn_getaddr+0xa8>
 18395a4:	01c06134 	movhi	r7,388
 18395a8:	39cec004 	addi	r7,r7,15104
 18395ac:	01802384 	movi	r6,142
 18395b0:	01406134 	movhi	r5,388
 18395b4:	294ee204 	addi	r5,r5,15240
 18395b8:	01006134 	movhi	r4,388
 18395bc:	210ece04 	addi	r4,r4,15160
 18395c0:	1800c180 	call	1800c18 <printf>
 18395c4:	003fff06 	br	18395c4 <__ram_exceptions_end+0xff829180>

  msg.function = do_getaddr;
 18395c8:	00806134 	movhi	r2,388
 18395cc:	10b1b804 	addi	r2,r2,-14624
 18395d0:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
 18395d4:	e0bffc17 	ldw	r2,-16(fp)
 18395d8:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.ad.ipaddr = addr;
 18395dc:	e0bffd17 	ldw	r2,-12(fp)
 18395e0:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.ad.port = port;
 18395e4:	e0bffe17 	ldw	r2,-8(fp)
 18395e8:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.ad.local = local;
 18395ec:	e0bfff03 	ldbu	r2,-4(fp)
 18395f0:	e0bffb05 	stb	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 18395f4:	e0bff604 	addi	r2,fp,-40
 18395f8:	1009883a 	mov	r4,r2
 18395fc:	182bf140 	call	182bf14 <tcpip_apimsg>
 1839600:	e0bff505 	stb	r2,-44(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 1839604:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839608:	10000126 	beq	r2,zero,1839610 <netconn_getaddr+0xf0>
 183960c:	181103c0 	call	181103c <vTaskEnterCritical>
 1839610:	e0bffc17 	ldw	r2,-16(fp)
 1839614:	10800303 	ldbu	r2,12(r2)
 1839618:	10803fcc 	andi	r2,r2,255
 183961c:	1080201c 	xori	r2,r2,128
 1839620:	10bfe004 	addi	r2,r2,-128
 1839624:	10bffdd0 	cmplti	r2,r2,-9
 1839628:	1000031e 	bne	r2,zero,1839638 <netconn_getaddr+0x118>
 183962c:	e0bffc17 	ldw	r2,-16(fp)
 1839630:	e0fff503 	ldbu	r3,-44(fp)
 1839634:	10c00305 	stb	r3,12(r2)
 1839638:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183963c:	10000126 	beq	r2,zero,1839644 <netconn_getaddr+0x124>
 1839640:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 1839644:	e0bff503 	ldbu	r2,-44(fp)
}
 1839648:	e037883a 	mov	sp,fp
 183964c:	dfc00117 	ldw	ra,4(sp)
 1839650:	df000017 	ldw	fp,0(sp)
 1839654:	dec00204 	addi	sp,sp,8
 1839658:	f800283a 	ret

0183965c <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 183965c:	defff404 	addi	sp,sp,-48
 1839660:	dfc00b15 	stw	ra,44(sp)
 1839664:	df000a15 	stw	fp,40(sp)
 1839668:	df000a04 	addi	fp,sp,40
 183966c:	e13ffd15 	stw	r4,-12(fp)
 1839670:	e17ffe15 	stw	r5,-8(fp)
 1839674:	3005883a 	mov	r2,r6
 1839678:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 183967c:	e0bffd17 	ldw	r2,-12(fp)
 1839680:	1000091e 	bne	r2,zero,18396a8 <netconn_bind+0x4c>
 1839684:	01c06134 	movhi	r7,388
 1839688:	39cec004 	addi	r7,r7,15104
 183968c:	01802ac4 	movi	r6,171
 1839690:	01406134 	movhi	r5,388
 1839694:	294eea04 	addi	r5,r5,15272
 1839698:	01006134 	movhi	r4,388
 183969c:	210ece04 	addi	r4,r4,15160
 18396a0:	1800c180 	call	1800c18 <printf>
 18396a4:	003fff06 	br	18396a4 <__ram_exceptions_end+0xff829260>

  msg.function = do_bind;
 18396a8:	00806134 	movhi	r2,388
 18396ac:	10adfb04 	addi	r2,r2,-18452
 18396b0:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
 18396b4:	e0bffd17 	ldw	r2,-12(fp)
 18396b8:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
 18396bc:	e0bffe17 	ldw	r2,-8(fp)
 18396c0:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
 18396c4:	e0bfff0b 	ldhu	r2,-4(fp)
 18396c8:	e0bffb0d 	sth	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 18396cc:	e0bff704 	addi	r2,fp,-36
 18396d0:	1009883a 	mov	r4,r2
 18396d4:	182bf140 	call	182bf14 <tcpip_apimsg>
 18396d8:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 18396dc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18396e0:	10000126 	beq	r2,zero,18396e8 <netconn_bind+0x8c>
 18396e4:	181103c0 	call	181103c <vTaskEnterCritical>
 18396e8:	e0bffd17 	ldw	r2,-12(fp)
 18396ec:	10800303 	ldbu	r2,12(r2)
 18396f0:	10803fcc 	andi	r2,r2,255
 18396f4:	1080201c 	xori	r2,r2,128
 18396f8:	10bfe004 	addi	r2,r2,-128
 18396fc:	10bffdd0 	cmplti	r2,r2,-9
 1839700:	1000031e 	bne	r2,zero,1839710 <netconn_bind+0xb4>
 1839704:	e0bffd17 	ldw	r2,-12(fp)
 1839708:	e0fff603 	ldbu	r3,-40(fp)
 183970c:	10c00305 	stb	r3,12(r2)
 1839710:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839714:	10000126 	beq	r2,zero,183971c <netconn_bind+0xc0>
 1839718:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 183971c:	e0bff603 	ldbu	r2,-40(fp)
}
 1839720:	e037883a 	mov	sp,fp
 1839724:	dfc00117 	ldw	ra,4(sp)
 1839728:	df000017 	ldw	fp,0(sp)
 183972c:	dec00204 	addi	sp,sp,8
 1839730:	f800283a 	ret

01839734 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 1839734:	defff404 	addi	sp,sp,-48
 1839738:	dfc00b15 	stw	ra,44(sp)
 183973c:	df000a15 	stw	fp,40(sp)
 1839740:	df000a04 	addi	fp,sp,40
 1839744:	e13ffd15 	stw	r4,-12(fp)
 1839748:	e17ffe15 	stw	r5,-8(fp)
 183974c:	3005883a 	mov	r2,r6
 1839750:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 1839754:	e0bffd17 	ldw	r2,-12(fp)
 1839758:	1000091e 	bne	r2,zero,1839780 <netconn_connect+0x4c>
 183975c:	01c06134 	movhi	r7,388
 1839760:	39cec004 	addi	r7,r7,15104
 1839764:	01803144 	movi	r6,197
 1839768:	01406134 	movhi	r5,388
 183976c:	294ef104 	addi	r5,r5,15300
 1839770:	01006134 	movhi	r4,388
 1839774:	210ece04 	addi	r4,r4,15160
 1839778:	1800c180 	call	1800c18 <printf>
 183977c:	003fff06 	br	183977c <__ram_exceptions_end+0xff829338>

  msg.function = do_connect;
 1839780:	00806134 	movhi	r2,388
 1839784:	10aeac04 	addi	r2,r2,-17744
 1839788:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
 183978c:	e0bffd17 	ldw	r2,-12(fp)
 1839790:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
 1839794:	e0bffe17 	ldw	r2,-8(fp)
 1839798:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
 183979c:	e0bfff0b 	ldhu	r2,-4(fp)
 18397a0:	e0bffb0d 	sth	r2,-20(fp)
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
 18397a4:	e0bff704 	addi	r2,fp,-36
 18397a8:	1009883a 	mov	r4,r2
 18397ac:	182bf140 	call	182bf14 <tcpip_apimsg>
 18397b0:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 18397b4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18397b8:	10000126 	beq	r2,zero,18397c0 <netconn_connect+0x8c>
 18397bc:	181103c0 	call	181103c <vTaskEnterCritical>
 18397c0:	e0bffd17 	ldw	r2,-12(fp)
 18397c4:	10800303 	ldbu	r2,12(r2)
 18397c8:	10803fcc 	andi	r2,r2,255
 18397cc:	1080201c 	xori	r2,r2,128
 18397d0:	10bfe004 	addi	r2,r2,-128
 18397d4:	10bffdd0 	cmplti	r2,r2,-9
 18397d8:	1000031e 	bne	r2,zero,18397e8 <netconn_connect+0xb4>
 18397dc:	e0bffd17 	ldw	r2,-12(fp)
 18397e0:	e0fff603 	ldbu	r3,-40(fp)
 18397e4:	10c00305 	stb	r3,12(r2)
 18397e8:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18397ec:	10000126 	beq	r2,zero,18397f4 <netconn_connect+0xc0>
 18397f0:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 18397f4:	e0bff603 	ldbu	r2,-40(fp)
}
 18397f8:	e037883a 	mov	sp,fp
 18397fc:	dfc00117 	ldw	ra,4(sp)
 1839800:	df000017 	ldw	fp,0(sp)
 1839804:	dec00204 	addi	sp,sp,8
 1839808:	f800283a 	ret

0183980c <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
 183980c:	defff604 	addi	sp,sp,-40
 1839810:	dfc00915 	stw	ra,36(sp)
 1839814:	df000815 	stw	fp,32(sp)
 1839818:	df000804 	addi	fp,sp,32
 183981c:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 1839820:	e0bfff17 	ldw	r2,-4(fp)
 1839824:	1000091e 	bne	r2,zero,183984c <netconn_disconnect+0x40>
 1839828:	01c06134 	movhi	r7,388
 183982c:	39cec004 	addi	r7,r7,15104
 1839830:	01803784 	movi	r6,222
 1839834:	01406134 	movhi	r5,388
 1839838:	294ef904 	addi	r5,r5,15332
 183983c:	01006134 	movhi	r4,388
 1839840:	210ece04 	addi	r4,r4,15160
 1839844:	1800c180 	call	1800c18 <printf>
 1839848:	003fff06 	br	1839848 <__ram_exceptions_end+0xff829404>

  msg.function = do_disconnect;
 183984c:	00806134 	movhi	r2,388
 1839850:	10af3f04 	addi	r2,r2,-17156
 1839854:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
 1839858:	e0bfff17 	ldw	r2,-4(fp)
 183985c:	e0bffa15 	stw	r2,-24(fp)
  err = TCPIP_APIMSG(&msg);
 1839860:	e0bff904 	addi	r2,fp,-28
 1839864:	1009883a 	mov	r4,r2
 1839868:	182bf140 	call	182bf14 <tcpip_apimsg>
 183986c:	e0bff805 	stb	r2,-32(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 1839870:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839874:	10000126 	beq	r2,zero,183987c <netconn_disconnect+0x70>
 1839878:	181103c0 	call	181103c <vTaskEnterCritical>
 183987c:	e0bfff17 	ldw	r2,-4(fp)
 1839880:	10800303 	ldbu	r2,12(r2)
 1839884:	10803fcc 	andi	r2,r2,255
 1839888:	1080201c 	xori	r2,r2,128
 183988c:	10bfe004 	addi	r2,r2,-128
 1839890:	10bffdd0 	cmplti	r2,r2,-9
 1839894:	1000031e 	bne	r2,zero,18398a4 <netconn_disconnect+0x98>
 1839898:	e0bfff17 	ldw	r2,-4(fp)
 183989c:	e0fff803 	ldbu	r3,-32(fp)
 18398a0:	10c00305 	stb	r3,12(r2)
 18398a4:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 18398a8:	10000126 	beq	r2,zero,18398b0 <netconn_disconnect+0xa4>
 18398ac:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 18398b0:	e0bff803 	ldbu	r2,-32(fp)
}
 18398b4:	e037883a 	mov	sp,fp
 18398b8:	dfc00117 	ldw	ra,4(sp)
 18398bc:	df000017 	ldw	fp,0(sp)
 18398c0:	dec00204 	addi	sp,sp,8
 18398c4:	f800283a 	ret

018398c8 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 18398c8:	defff504 	addi	sp,sp,-44
 18398cc:	dfc00a15 	stw	ra,40(sp)
 18398d0:	df000915 	stw	fp,36(sp)
 18398d4:	df000904 	addi	fp,sp,36
 18398d8:	e13ffe15 	stw	r4,-8(fp)
 18398dc:	2805883a 	mov	r2,r5
 18398e0:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 18398e4:	e0bffe17 	ldw	r2,-8(fp)
 18398e8:	1000091e 	bne	r2,zero,1839910 <netconn_listen_with_backlog+0x48>
 18398ec:	01c06134 	movhi	r7,388
 18398f0:	39cec004 	addi	r7,r7,15104
 18398f4:	01803e84 	movi	r6,250
 18398f8:	01406134 	movhi	r5,388
 18398fc:	294f0204 	addi	r5,r5,15368
 1839900:	01006134 	movhi	r4,388
 1839904:	210ece04 	addi	r4,r4,15160
 1839908:	1800c180 	call	1800c18 <printf>
 183990c:	003fff06 	br	183990c <__ram_exceptions_end+0xff8294c8>

  msg.function = do_listen;
 1839910:	00806134 	movhi	r2,388
 1839914:	10af6004 	addi	r2,r2,-17024
 1839918:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 183991c:	e0bffe17 	ldw	r2,-8(fp)
 1839920:	e0bff915 	stw	r2,-28(fp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
 1839924:	e0bfff03 	ldbu	r2,-4(fp)
 1839928:	e0bffb05 	stb	r2,-20(fp)
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 183992c:	e0bff804 	addi	r2,fp,-32
 1839930:	1009883a 	mov	r4,r2
 1839934:	182bf140 	call	182bf14 <tcpip_apimsg>
 1839938:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 183993c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839940:	10000126 	beq	r2,zero,1839948 <netconn_listen_with_backlog+0x80>
 1839944:	181103c0 	call	181103c <vTaskEnterCritical>
 1839948:	e0bffe17 	ldw	r2,-8(fp)
 183994c:	10800303 	ldbu	r2,12(r2)
 1839950:	10803fcc 	andi	r2,r2,255
 1839954:	1080201c 	xori	r2,r2,128
 1839958:	10bfe004 	addi	r2,r2,-128
 183995c:	10bffdd0 	cmplti	r2,r2,-9
 1839960:	1000031e 	bne	r2,zero,1839970 <netconn_listen_with_backlog+0xa8>
 1839964:	e0bffe17 	ldw	r2,-8(fp)
 1839968:	e0fff703 	ldbu	r3,-36(fp)
 183996c:	10c00305 	stb	r3,12(r2)
 1839970:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839974:	10000126 	beq	r2,zero,183997c <netconn_listen_with_backlog+0xb4>
 1839978:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 183997c:	e0bff703 	ldbu	r2,-36(fp)
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 1839980:	e037883a 	mov	sp,fp
 1839984:	dfc00117 	ldw	ra,4(sp)
 1839988:	df000017 	ldw	fp,0(sp)
 183998c:	dec00204 	addi	sp,sp,8
 1839990:	f800283a 	ret

01839994 <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 1839994:	defff404 	addi	sp,sp,-48
 1839998:	dfc00b15 	stw	ra,44(sp)
 183999c:	df000a15 	stw	fp,40(sp)
 18399a0:	df000a04 	addi	fp,sp,40
 18399a4:	e13ffe15 	stw	r4,-8(fp)
 18399a8:	e17fff15 	stw	r5,-4(fp)
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 18399ac:	e0bfff17 	ldw	r2,-4(fp)
 18399b0:	1000091e 	bne	r2,zero,18399d8 <netconn_accept+0x44>
 18399b4:	01c06134 	movhi	r7,388
 18399b8:	39cec004 	addi	r7,r7,15104
 18399bc:	01804784 	movi	r6,286
 18399c0:	01406134 	movhi	r5,388
 18399c4:	294f0a04 	addi	r5,r5,15400
 18399c8:	01006134 	movhi	r4,388
 18399cc:	210ece04 	addi	r4,r4,15160
 18399d0:	1800c180 	call	1800c18 <printf>
 18399d4:	003fff06 	br	18399d4 <__ram_exceptions_end+0xff829590>
  *new_conn = NULL;
 18399d8:	e0bfff17 	ldw	r2,-4(fp)
 18399dc:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 18399e0:	e0bffe17 	ldw	r2,-8(fp)
 18399e4:	1000091e 	bne	r2,zero,1839a0c <netconn_accept+0x78>
 18399e8:	01c06134 	movhi	r7,388
 18399ec:	39cec004 	addi	r7,r7,15104
 18399f0:	01804804 	movi	r6,288
 18399f4:	01406134 	movhi	r5,388
 18399f8:	294f1204 	addi	r5,r5,15432
 18399fc:	01006134 	movhi	r4,388
 1839a00:	210ece04 	addi	r4,r4,15160
 1839a04:	1800c180 	call	1800c18 <printf>
 1839a08:	003fff06 	br	1839a08 <__ram_exceptions_end+0xff8295c4>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 1839a0c:	e0bffe17 	ldw	r2,-8(fp)
 1839a10:	10800617 	ldw	r2,24(r2)
 1839a14:	1000091e 	bne	r2,zero,1839a3c <netconn_accept+0xa8>
 1839a18:	01c06134 	movhi	r7,388
 1839a1c:	39cec004 	addi	r7,r7,15104
 1839a20:	01804844 	movi	r6,289
 1839a24:	01406134 	movhi	r5,388
 1839a28:	294f1a04 	addi	r5,r5,15464
 1839a2c:	01006134 	movhi	r4,388
 1839a30:	210ece04 	addi	r4,r4,15160
 1839a34:	1800c180 	call	1800c18 <printf>
 1839a38:	003fff06 	br	1839a38 <__ram_exceptions_end+0xff8295f4>

  err = conn->last_err;
 1839a3c:	e0bffe17 	ldw	r2,-8(fp)
 1839a40:	10800303 	ldbu	r2,12(r2)
 1839a44:	e0bff605 	stb	r2,-40(fp)
  if (ERR_IS_FATAL(err)) {
 1839a48:	e0bff607 	ldb	r2,-40(fp)
 1839a4c:	10bffdc8 	cmpgei	r2,r2,-9
 1839a50:	1000021e 	bne	r2,zero,1839a5c <netconn_accept+0xc8>
    /* don't recv on fatal errors: this might block the application task
       waiting on acceptmbox forever! */
    return err;
 1839a54:	e0bff603 	ldbu	r2,-40(fp)
 1839a58:	00004706 	br	1839b78 <netconn_accept+0x1e4>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 1839a5c:	e0bffe17 	ldw	r2,-8(fp)
 1839a60:	10c00604 	addi	r3,r2,24
 1839a64:	e0bffe17 	ldw	r2,-8(fp)
 1839a68:	10800817 	ldw	r2,32(r2)
 1839a6c:	1009883a 	mov	r4,r2
 1839a70:	e0bff704 	addi	r2,fp,-36
 1839a74:	200d883a 	mov	r6,r4
 1839a78:	100b883a 	mov	r5,r2
 1839a7c:	1809883a 	mov	r4,r3
 1839a80:	18155340 	call	1815534 <sys_arch_mbox_fetch>
 1839a84:	10bfffd8 	cmpnei	r2,r2,-1
 1839a88:	1000121e 	bne	r2,zero,1839ad4 <netconn_accept+0x140>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
 1839a8c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839a90:	10000126 	beq	r2,zero,1839a98 <netconn_accept+0x104>
 1839a94:	181103c0 	call	181103c <vTaskEnterCritical>
 1839a98:	e0bffe17 	ldw	r2,-8(fp)
 1839a9c:	10800303 	ldbu	r2,12(r2)
 1839aa0:	10803fcc 	andi	r2,r2,255
 1839aa4:	1080201c 	xori	r2,r2,128
 1839aa8:	10bfe004 	addi	r2,r2,-128
 1839aac:	10bffdd0 	cmplti	r2,r2,-9
 1839ab0:	1000031e 	bne	r2,zero,1839ac0 <netconn_accept+0x12c>
 1839ab4:	e0bffe17 	ldw	r2,-8(fp)
 1839ab8:	00ffff44 	movi	r3,-3
 1839abc:	10c00305 	stb	r3,12(r2)
 1839ac0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839ac4:	10000126 	beq	r2,zero,1839acc <netconn_accept+0x138>
 1839ac8:	18110840 	call	1811084 <vTaskExitCritical>
    return ERR_TIMEOUT;
 1839acc:	00bfff44 	movi	r2,-3
 1839ad0:	00002906 	br	1839b78 <netconn_accept+0x1e4>
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 1839ad4:	e0bffe17 	ldw	r2,-8(fp)
 1839ad8:	10800c17 	ldw	r2,48(r2)
 1839adc:	10000626 	beq	r2,zero,1839af8 <netconn_accept+0x164>
 1839ae0:	e0bffe17 	ldw	r2,-8(fp)
 1839ae4:	10800c17 	ldw	r2,48(r2)
 1839ae8:	000d883a 	mov	r6,zero
 1839aec:	01400044 	movi	r5,1
 1839af0:	e13ffe17 	ldw	r4,-8(fp)
 1839af4:	103ee83a 	callr	r2

  if (newconn == NULL) {
 1839af8:	e0bff717 	ldw	r2,-36(fp)
 1839afc:	1000121e 	bne	r2,zero,1839b48 <netconn_accept+0x1b4>
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 1839b00:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839b04:	10000126 	beq	r2,zero,1839b0c <netconn_accept+0x178>
 1839b08:	181103c0 	call	181103c <vTaskEnterCritical>
 1839b0c:	e0bffe17 	ldw	r2,-8(fp)
 1839b10:	10800303 	ldbu	r2,12(r2)
 1839b14:	10803fcc 	andi	r2,r2,255
 1839b18:	1080201c 	xori	r2,r2,128
 1839b1c:	10bfe004 	addi	r2,r2,-128
 1839b20:	10bffdd0 	cmplti	r2,r2,-9
 1839b24:	1000031e 	bne	r2,zero,1839b34 <netconn_accept+0x1a0>
 1839b28:	e0bffe17 	ldw	r2,-8(fp)
 1839b2c:	00fffd84 	movi	r3,-10
 1839b30:	10c00305 	stb	r3,12(r2)
 1839b34:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839b38:	10000126 	beq	r2,zero,1839b40 <netconn_accept+0x1ac>
 1839b3c:	18110840 	call	1811084 <vTaskExitCritical>
    return ERR_ABRT;
 1839b40:	00bffd84 	movi	r2,-10
 1839b44:	00000c06 	br	1839b78 <netconn_accept+0x1e4>
  }
#if TCP_LISTEN_BACKLOG
  /* Let the stack know that we have accepted the connection. */
  msg.function = do_recv;
 1839b48:	00806134 	movhi	r2,388
 1839b4c:	10b07104 	addi	r2,r2,-15932
 1839b50:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 1839b54:	e0bffe17 	ldw	r2,-8(fp)
 1839b58:	e0bff915 	stw	r2,-28(fp)
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
 1839b5c:	e0bff804 	addi	r2,fp,-32
 1839b60:	1009883a 	mov	r4,r2
 1839b64:	182bf140 	call	182bf14 <tcpip_apimsg>
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 1839b68:	e0fff717 	ldw	r3,-36(fp)
 1839b6c:	e0bfff17 	ldw	r2,-4(fp)
 1839b70:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 1839b74:	0005883a 	mov	r2,zero
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 1839b78:	e037883a 	mov	sp,fp
 1839b7c:	dfc00117 	ldw	ra,4(sp)
 1839b80:	df000017 	ldw	fp,0(sp)
 1839b84:	dec00204 	addi	sp,sp,8
 1839b88:	f800283a 	ret

01839b8c <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 1839b8c:	defff404 	addi	sp,sp,-48
 1839b90:	dfc00b15 	stw	ra,44(sp)
 1839b94:	df000a15 	stw	fp,40(sp)
 1839b98:	df000a04 	addi	fp,sp,40
 1839b9c:	e13ffe15 	stw	r4,-8(fp)
 1839ba0:	e17fff15 	stw	r5,-4(fp)
  void *buf = NULL;
 1839ba4:	e03ff715 	stw	zero,-36(fp)
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 1839ba8:	e0bfff17 	ldw	r2,-4(fp)
 1839bac:	1000091e 	bne	r2,zero,1839bd4 <netconn_recv_data+0x48>
 1839bb0:	01c06134 	movhi	r7,388
 1839bb4:	39cec004 	addi	r7,r7,15104
 1839bb8:	018057c4 	movi	r6,351
 1839bbc:	01406134 	movhi	r5,388
 1839bc0:	294f2304 	addi	r5,r5,15500
 1839bc4:	01006134 	movhi	r4,388
 1839bc8:	210ece04 	addi	r4,r4,15160
 1839bcc:	1800c180 	call	1800c18 <printf>
 1839bd0:	003fff06 	br	1839bd0 <__ram_exceptions_end+0xff82978c>
  *new_buf = NULL;
 1839bd4:	e0bfff17 	ldw	r2,-4(fp)
 1839bd8:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 1839bdc:	e0bffe17 	ldw	r2,-8(fp)
 1839be0:	1000091e 	bne	r2,zero,1839c08 <netconn_recv_data+0x7c>
 1839be4:	01c06134 	movhi	r7,388
 1839be8:	39cec004 	addi	r7,r7,15104
 1839bec:	01805844 	movi	r6,353
 1839bf0:	01406134 	movhi	r5,388
 1839bf4:	294f2b04 	addi	r5,r5,15532
 1839bf8:	01006134 	movhi	r4,388
 1839bfc:	210ece04 	addi	r4,r4,15160
 1839c00:	1800c180 	call	1800c18 <printf>
 1839c04:	003fff06 	br	1839c04 <__ram_exceptions_end+0xff8297c0>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 1839c08:	e0bffe17 	ldw	r2,-8(fp)
 1839c0c:	10800517 	ldw	r2,20(r2)
 1839c10:	1000091e 	bne	r2,zero,1839c38 <netconn_recv_data+0xac>
 1839c14:	01c06134 	movhi	r7,388
 1839c18:	39cec004 	addi	r7,r7,15104
 1839c1c:	01805884 	movi	r6,354
 1839c20:	01406134 	movhi	r5,388
 1839c24:	294f3204 	addi	r5,r5,15560
 1839c28:	01006134 	movhi	r4,388
 1839c2c:	210ece04 	addi	r4,r4,15160
 1839c30:	1800c180 	call	1800c18 <printf>
 1839c34:	003fff06 	br	1839c34 <__ram_exceptions_end+0xff8297f0>

  err = conn->last_err;
 1839c38:	e0bffe17 	ldw	r2,-8(fp)
 1839c3c:	10800303 	ldbu	r2,12(r2)
 1839c40:	e0bff685 	stb	r2,-38(fp)
  if (ERR_IS_FATAL(err)) {
 1839c44:	e0bff687 	ldb	r2,-38(fp)
 1839c48:	10bffdc8 	cmpgei	r2,r2,-9
 1839c4c:	1000021e 	bne	r2,zero,1839c58 <netconn_recv_data+0xcc>
    /* don't recv on fatal errors: this might block the application task
       waiting on recvmbox forever! */
    /* @todo: this does not allow us to fetch data that has been put into recvmbox
       before the fatal error occurred - is that a problem? */
    return err;
 1839c50:	e0bff683 	ldbu	r2,-38(fp)
 1839c54:	00006d06 	br	1839e0c <netconn_recv_data+0x280>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 1839c58:	e0bffe17 	ldw	r2,-8(fp)
 1839c5c:	10c00504 	addi	r3,r2,20
 1839c60:	e0bffe17 	ldw	r2,-8(fp)
 1839c64:	10800817 	ldw	r2,32(r2)
 1839c68:	1009883a 	mov	r4,r2
 1839c6c:	e0bff704 	addi	r2,fp,-36
 1839c70:	200d883a 	mov	r6,r4
 1839c74:	100b883a 	mov	r5,r2
 1839c78:	1809883a 	mov	r4,r3
 1839c7c:	18155340 	call	1815534 <sys_arch_mbox_fetch>
 1839c80:	10bfffd8 	cmpnei	r2,r2,-1
 1839c84:	1000121e 	bne	r2,zero,1839cd0 <netconn_recv_data+0x144>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
 1839c88:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839c8c:	10000126 	beq	r2,zero,1839c94 <netconn_recv_data+0x108>
 1839c90:	181103c0 	call	181103c <vTaskEnterCritical>
 1839c94:	e0bffe17 	ldw	r2,-8(fp)
 1839c98:	10800303 	ldbu	r2,12(r2)
 1839c9c:	10803fcc 	andi	r2,r2,255
 1839ca0:	1080201c 	xori	r2,r2,128
 1839ca4:	10bfe004 	addi	r2,r2,-128
 1839ca8:	10bffdd0 	cmplti	r2,r2,-9
 1839cac:	1000031e 	bne	r2,zero,1839cbc <netconn_recv_data+0x130>
 1839cb0:	e0bffe17 	ldw	r2,-8(fp)
 1839cb4:	00ffff44 	movi	r3,-3
 1839cb8:	10c00305 	stb	r3,12(r2)
 1839cbc:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839cc0:	10000126 	beq	r2,zero,1839cc8 <netconn_recv_data+0x13c>
 1839cc4:	18110840 	call	1811084 <vTaskExitCritical>
    return ERR_TIMEOUT;
 1839cc8:	00bfff44 	movi	r2,-3
 1839ccc:	00004f06 	br	1839e0c <netconn_recv_data+0x280>
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 1839cd0:	e0bffe17 	ldw	r2,-8(fp)
 1839cd4:	10800017 	ldw	r2,0(r2)
 1839cd8:	10800418 	cmpnei	r2,r2,16
 1839cdc:	1000391e 	bne	r2,zero,1839dc4 <netconn_recv_data+0x238>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 1839ce0:	e0bffe17 	ldw	r2,-8(fp)
 1839ce4:	10800903 	ldbu	r2,36(r2)
 1839ce8:	10803fcc 	andi	r2,r2,255
 1839cec:	1080020c 	andi	r2,r2,8
 1839cf0:	10000226 	beq	r2,zero,1839cfc <netconn_recv_data+0x170>
 1839cf4:	e0bff717 	ldw	r2,-36(fp)
 1839cf8:	1000111e 	bne	r2,zero,1839d40 <netconn_recv_data+0x1b4>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 1839cfc:	00806134 	movhi	r2,388
 1839d00:	10b07104 	addi	r2,r2,-15932
 1839d04:	e0bff815 	stw	r2,-32(fp)
      msg.msg.conn = conn;
 1839d08:	e0bffe17 	ldw	r2,-8(fp)
 1839d0c:	e0bff915 	stw	r2,-28(fp)
      if (buf != NULL) {
 1839d10:	e0bff717 	ldw	r2,-36(fp)
 1839d14:	10000526 	beq	r2,zero,1839d2c <netconn_recv_data+0x1a0>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 1839d18:	e0bff717 	ldw	r2,-36(fp)
 1839d1c:	1080020b 	ldhu	r2,8(r2)
 1839d20:	10bfffcc 	andi	r2,r2,65535
 1839d24:	e0bffb15 	stw	r2,-20(fp)
 1839d28:	00000206 	br	1839d34 <netconn_recv_data+0x1a8>
      } else {
        msg.msg.msg.r.len = 1;
 1839d2c:	00800044 	movi	r2,1
 1839d30:	e0bffb15 	stw	r2,-20(fp)
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
 1839d34:	e0bff804 	addi	r2,fp,-32
 1839d38:	1009883a 	mov	r4,r2
 1839d3c:	182bf140 	call	182bf14 <tcpip_apimsg>
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
 1839d40:	e0bff717 	ldw	r2,-36(fp)
 1839d44:	10001b1e 	bne	r2,zero,1839db4 <netconn_recv_data+0x228>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 1839d48:	e0bffe17 	ldw	r2,-8(fp)
 1839d4c:	10800c17 	ldw	r2,48(r2)
 1839d50:	10000626 	beq	r2,zero,1839d6c <netconn_recv_data+0x1e0>
 1839d54:	e0bffe17 	ldw	r2,-8(fp)
 1839d58:	10800c17 	ldw	r2,48(r2)
 1839d5c:	000d883a 	mov	r6,zero
 1839d60:	01400044 	movi	r5,1
 1839d64:	e13ffe17 	ldw	r4,-8(fp)
 1839d68:	103ee83a 	callr	r2
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
 1839d6c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839d70:	10000126 	beq	r2,zero,1839d78 <netconn_recv_data+0x1ec>
 1839d74:	181103c0 	call	181103c <vTaskEnterCritical>
 1839d78:	e0bffe17 	ldw	r2,-8(fp)
 1839d7c:	10800303 	ldbu	r2,12(r2)
 1839d80:	10803fcc 	andi	r2,r2,255
 1839d84:	1080201c 	xori	r2,r2,128
 1839d88:	10bfe004 	addi	r2,r2,-128
 1839d8c:	10bffdd0 	cmplti	r2,r2,-9
 1839d90:	1000031e 	bne	r2,zero,1839da0 <netconn_recv_data+0x214>
 1839d94:	e0bffe17 	ldw	r2,-8(fp)
 1839d98:	00fffd04 	movi	r3,-12
 1839d9c:	10c00305 	stb	r3,12(r2)
 1839da0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839da4:	10000126 	beq	r2,zero,1839dac <netconn_recv_data+0x220>
 1839da8:	18110840 	call	1811084 <vTaskExitCritical>
      return ERR_CLSD;
 1839dac:	00bffd04 	movi	r2,-12
 1839db0:	00001606 	br	1839e0c <netconn_recv_data+0x280>
    }
    len = ((struct pbuf *)buf)->tot_len;
 1839db4:	e0bff717 	ldw	r2,-36(fp)
 1839db8:	1080020b 	ldhu	r2,8(r2)
 1839dbc:	e0bff60d 	sth	r2,-40(fp)
 1839dc0:	00000406 	br	1839dd4 <netconn_recv_data+0x248>
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
    len = netbuf_len((struct netbuf *)buf);
 1839dc4:	e0bff717 	ldw	r2,-36(fp)
 1839dc8:	10800017 	ldw	r2,0(r2)
 1839dcc:	1080020b 	ldhu	r2,8(r2)
 1839dd0:	e0bff60d 	sth	r2,-40(fp)

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 1839dd4:	e0bffe17 	ldw	r2,-8(fp)
 1839dd8:	10800c17 	ldw	r2,48(r2)
 1839ddc:	10000726 	beq	r2,zero,1839dfc <netconn_recv_data+0x270>
 1839de0:	e0bffe17 	ldw	r2,-8(fp)
 1839de4:	10800c17 	ldw	r2,48(r2)
 1839de8:	e0fff60b 	ldhu	r3,-40(fp)
 1839dec:	180d883a 	mov	r6,r3
 1839df0:	01400044 	movi	r5,1
 1839df4:	e13ffe17 	ldw	r4,-8(fp)
 1839df8:	103ee83a 	callr	r2

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 1839dfc:	e0fff717 	ldw	r3,-36(fp)
 1839e00:	e0bfff17 	ldw	r2,-4(fp)
 1839e04:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 1839e08:	0005883a 	mov	r2,zero
}
 1839e0c:	e037883a 	mov	sp,fp
 1839e10:	dfc00117 	ldw	ra,4(sp)
 1839e14:	df000017 	ldw	fp,0(sp)
 1839e18:	dec00204 	addi	sp,sp,8
 1839e1c:	f800283a 	ret

01839e20 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
 1839e20:	defffc04 	addi	sp,sp,-16
 1839e24:	dfc00315 	stw	ra,12(sp)
 1839e28:	df000215 	stw	fp,8(sp)
 1839e2c:	df000204 	addi	fp,sp,8
 1839e30:	e13ffe15 	stw	r4,-8(fp)
 1839e34:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 1839e38:	e0bffe17 	ldw	r2,-8(fp)
 1839e3c:	10000426 	beq	r2,zero,1839e50 <netconn_recv_tcp_pbuf+0x30>
 1839e40:	e0bffe17 	ldw	r2,-8(fp)
 1839e44:	10800017 	ldw	r2,0(r2)
 1839e48:	10800420 	cmpeqi	r2,r2,16
 1839e4c:	1000091e 	bne	r2,zero,1839e74 <netconn_recv_tcp_pbuf+0x54>
 1839e50:	01c06134 	movhi	r7,388
 1839e54:	39cec004 	addi	r7,r7,15104
 1839e58:	01806e04 	movi	r6,440
 1839e5c:	01406134 	movhi	r5,388
 1839e60:	294f2b04 	addi	r5,r5,15532
 1839e64:	01006134 	movhi	r4,388
 1839e68:	210ece04 	addi	r4,r4,15160
 1839e6c:	1800c180 	call	1800c18 <printf>
 1839e70:	003fff06 	br	1839e70 <__ram_exceptions_end+0xff829a2c>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
 1839e74:	e17fff17 	ldw	r5,-4(fp)
 1839e78:	e13ffe17 	ldw	r4,-8(fp)
 1839e7c:	1839b8c0 	call	1839b8c <netconn_recv_data>
}
 1839e80:	e037883a 	mov	sp,fp
 1839e84:	dfc00117 	ldw	ra,4(sp)
 1839e88:	df000017 	ldw	fp,0(sp)
 1839e8c:	dec00204 	addi	sp,sp,8
 1839e90:	f800283a 	ret

01839e94 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 1839e94:	defff904 	addi	sp,sp,-28
 1839e98:	dfc00615 	stw	ra,24(sp)
 1839e9c:	df000515 	stw	fp,20(sp)
 1839ea0:	df000504 	addi	fp,sp,20
 1839ea4:	e13ffe15 	stw	r4,-8(fp)
 1839ea8:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct netbuf *buf = NULL;
 1839eac:	e03ffb15 	stw	zero,-20(fp)
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 1839eb0:	e0bfff17 	ldw	r2,-4(fp)
 1839eb4:	1000091e 	bne	r2,zero,1839edc <netconn_recv+0x48>
 1839eb8:	01c06134 	movhi	r7,388
 1839ebc:	39cec004 	addi	r7,r7,15104
 1839ec0:	01807344 	movi	r6,461
 1839ec4:	01406134 	movhi	r5,388
 1839ec8:	294f2304 	addi	r5,r5,15500
 1839ecc:	01006134 	movhi	r4,388
 1839ed0:	210ece04 	addi	r4,r4,15160
 1839ed4:	1800c180 	call	1800c18 <printf>
 1839ed8:	003fff06 	br	1839ed8 <__ram_exceptions_end+0xff829a94>
  *new_buf = NULL;
 1839edc:	e0bfff17 	ldw	r2,-4(fp)
 1839ee0:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 1839ee4:	e0bffe17 	ldw	r2,-8(fp)
 1839ee8:	1000091e 	bne	r2,zero,1839f10 <netconn_recv+0x7c>
 1839eec:	01c06134 	movhi	r7,388
 1839ef0:	39cec004 	addi	r7,r7,15104
 1839ef4:	018073c4 	movi	r6,463
 1839ef8:	01406134 	movhi	r5,388
 1839efc:	294f2b04 	addi	r5,r5,15532
 1839f00:	01006134 	movhi	r4,388
 1839f04:	210ece04 	addi	r4,r4,15160
 1839f08:	1800c180 	call	1800c18 <printf>
 1839f0c:	003fff06 	br	1839f0c <__ram_exceptions_end+0xff829ac8>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 1839f10:	e0bffe17 	ldw	r2,-8(fp)
 1839f14:	10800517 	ldw	r2,20(r2)
 1839f18:	1000091e 	bne	r2,zero,1839f40 <netconn_recv+0xac>
 1839f1c:	01c06134 	movhi	r7,388
 1839f20:	39cec004 	addi	r7,r7,15104
 1839f24:	01807404 	movi	r6,464
 1839f28:	01406134 	movhi	r5,388
 1839f2c:	294f3204 	addi	r5,r5,15560
 1839f30:	01006134 	movhi	r4,388
 1839f34:	210ece04 	addi	r4,r4,15160
 1839f38:	1800c180 	call	1800c18 <printf>
 1839f3c:	003fff06 	br	1839f3c <__ram_exceptions_end+0xff829af8>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 1839f40:	e0bffe17 	ldw	r2,-8(fp)
 1839f44:	10800017 	ldw	r2,0(r2)
 1839f48:	10800418 	cmpnei	r2,r2,16
 1839f4c:	1000331e 	bne	r2,zero,183a01c <netconn_recv+0x188>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 1839f50:	e03ffd15 	stw	zero,-12(fp)
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 1839f54:	010001c4 	movi	r4,7
 1839f58:	18349580 	call	1834958 <memp_malloc>
 1839f5c:	e0bffb15 	stw	r2,-20(fp)
    if (buf == NULL) {
 1839f60:	e0bffb17 	ldw	r2,-20(fp)
 1839f64:	1000121e 	bne	r2,zero,1839fb0 <netconn_recv+0x11c>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
 1839f68:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839f6c:	10000126 	beq	r2,zero,1839f74 <netconn_recv+0xe0>
 1839f70:	181103c0 	call	181103c <vTaskEnterCritical>
 1839f74:	e0bffe17 	ldw	r2,-8(fp)
 1839f78:	10800303 	ldbu	r2,12(r2)
 1839f7c:	10803fcc 	andi	r2,r2,255
 1839f80:	1080201c 	xori	r2,r2,128
 1839f84:	10bfe004 	addi	r2,r2,-128
 1839f88:	10bffdd0 	cmplti	r2,r2,-9
 1839f8c:	1000031e 	bne	r2,zero,1839f9c <netconn_recv+0x108>
 1839f90:	e0bffe17 	ldw	r2,-8(fp)
 1839f94:	00ffffc4 	movi	r3,-1
 1839f98:	10c00305 	stb	r3,12(r2)
 1839f9c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 1839fa0:	10000126 	beq	r2,zero,1839fa8 <netconn_recv+0x114>
 1839fa4:	18110840 	call	1811084 <vTaskExitCritical>
      return ERR_MEM;
 1839fa8:	00bfffc4 	movi	r2,-1
 1839fac:	00001e06 	br	183a028 <netconn_recv+0x194>
    }

    err = netconn_recv_data(conn, (void **)&p);
 1839fb0:	e0bffd04 	addi	r2,fp,-12
 1839fb4:	100b883a 	mov	r5,r2
 1839fb8:	e13ffe17 	ldw	r4,-8(fp)
 1839fbc:	1839b8c0 	call	1839b8c <netconn_recv_data>
 1839fc0:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 1839fc4:	e0bffc07 	ldb	r2,-16(fp)
 1839fc8:	10000526 	beq	r2,zero,1839fe0 <netconn_recv+0x14c>
      memp_free(MEMP_NETBUF, buf);
 1839fcc:	e17ffb17 	ldw	r5,-20(fp)
 1839fd0:	010001c4 	movi	r4,7
 1839fd4:	1834b240 	call	1834b24 <memp_free>
      return err;
 1839fd8:	e0bffc03 	ldbu	r2,-16(fp)
 1839fdc:	00001206 	br	183a028 <netconn_recv+0x194>
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 1839fe0:	e0fffd17 	ldw	r3,-12(fp)
 1839fe4:	e0bffb17 	ldw	r2,-20(fp)
 1839fe8:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 1839fec:	e0fffd17 	ldw	r3,-12(fp)
 1839ff0:	e0bffb17 	ldw	r2,-20(fp)
 1839ff4:	10c00115 	stw	r3,4(r2)
    buf->port = 0;
 1839ff8:	e0bffb17 	ldw	r2,-20(fp)
 1839ffc:	1000030d 	sth	zero,12(r2)
    ip_addr_set_any(&buf->addr);
 183a000:	e0bffb17 	ldw	r2,-20(fp)
 183a004:	10000215 	stw	zero,8(r2)
    *new_buf = buf;
 183a008:	e0bfff17 	ldw	r2,-4(fp)
 183a00c:	e0fffb17 	ldw	r3,-20(fp)
 183a010:	10c00015 	stw	r3,0(r2)
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
 183a014:	0005883a 	mov	r2,zero
 183a018:	00000306 	br	183a028 <netconn_recv+0x194>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
 183a01c:	e17fff17 	ldw	r5,-4(fp)
 183a020:	e13ffe17 	ldw	r4,-8(fp)
 183a024:	1839b8c0 	call	1839b8c <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 183a028:	e037883a 	mov	sp,fp
 183a02c:	dfc00117 	ldw	ra,4(sp)
 183a030:	df000017 	ldw	fp,0(sp)
 183a034:	dec00204 	addi	sp,sp,8
 183a038:	f800283a 	ret

0183a03c <netconn_recved>:
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
 183a03c:	defff604 	addi	sp,sp,-40
 183a040:	dfc00915 	stw	ra,36(sp)
 183a044:	df000815 	stw	fp,32(sp)
 183a048:	df000804 	addi	fp,sp,32
 183a04c:	e13ffe15 	stw	r4,-8(fp)
 183a050:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 183a054:	e0bffe17 	ldw	r2,-8(fp)
 183a058:	10001226 	beq	r2,zero,183a0a4 <netconn_recved+0x68>
 183a05c:	e0bffe17 	ldw	r2,-8(fp)
 183a060:	10800017 	ldw	r2,0(r2)
 183a064:	10800418 	cmpnei	r2,r2,16
 183a068:	10000e1e 	bne	r2,zero,183a0a4 <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
 183a06c:	e0bffe17 	ldw	r2,-8(fp)
 183a070:	10800903 	ldbu	r2,36(r2)
 183a074:	10803fcc 	andi	r2,r2,255
 183a078:	1080020c 	andi	r2,r2,8
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 183a07c:	10000926 	beq	r2,zero,183a0a4 <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
 183a080:	00806134 	movhi	r2,388
 183a084:	10b07104 	addi	r2,r2,-15932
 183a088:	e0bff815 	stw	r2,-32(fp)
    msg.msg.conn = conn;
 183a08c:	e0bffe17 	ldw	r2,-8(fp)
 183a090:	e0bff915 	stw	r2,-28(fp)
    msg.msg.msg.r.len = length;
 183a094:	e0bfff17 	ldw	r2,-4(fp)
 183a098:	e0bffb15 	stw	r2,-20(fp)
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
 183a09c:	e13ff804 	addi	r4,fp,-32
 183a0a0:	182bf140 	call	182bf14 <tcpip_apimsg>
  }
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
 183a0a4:	0001883a 	nop
 183a0a8:	e037883a 	mov	sp,fp
 183a0ac:	dfc00117 	ldw	ra,4(sp)
 183a0b0:	df000017 	ldw	fp,0(sp)
 183a0b4:	dec00204 	addi	sp,sp,8
 183a0b8:	f800283a 	ret

0183a0bc <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
{
 183a0bc:	defffa04 	addi	sp,sp,-24
 183a0c0:	dfc00515 	stw	ra,20(sp)
 183a0c4:	df000415 	stw	fp,16(sp)
 183a0c8:	df000404 	addi	fp,sp,16
 183a0cc:	e13ffc15 	stw	r4,-16(fp)
 183a0d0:	e17ffd15 	stw	r5,-12(fp)
 183a0d4:	e1bffe15 	stw	r6,-8(fp)
 183a0d8:	3805883a 	mov	r2,r7
 183a0dc:	e0bfff0d 	sth	r2,-4(fp)
  if (buf != NULL) {
 183a0e0:	e0bffd17 	ldw	r2,-12(fp)
 183a0e4:	10000f26 	beq	r2,zero,183a124 <netconn_sendto+0x68>
    ip_addr_set(&buf->addr, addr);
 183a0e8:	e0bffe17 	ldw	r2,-8(fp)
 183a0ec:	10000326 	beq	r2,zero,183a0fc <netconn_sendto+0x40>
 183a0f0:	e0bffe17 	ldw	r2,-8(fp)
 183a0f4:	10800017 	ldw	r2,0(r2)
 183a0f8:	00000106 	br	183a100 <netconn_sendto+0x44>
 183a0fc:	0005883a 	mov	r2,zero
 183a100:	e0fffd17 	ldw	r3,-12(fp)
 183a104:	18800215 	stw	r2,8(r3)
    buf->port = port;
 183a108:	e0bffd17 	ldw	r2,-12(fp)
 183a10c:	e0ffff0b 	ldhu	r3,-4(fp)
 183a110:	10c0030d 	sth	r3,12(r2)
    return netconn_send(conn, buf);
 183a114:	e17ffd17 	ldw	r5,-12(fp)
 183a118:	e13ffc17 	ldw	r4,-16(fp)
 183a11c:	183a13c0 	call	183a13c <netconn_send>
 183a120:	00000106 	br	183a128 <netconn_sendto+0x6c>
  }
  return ERR_VAL;
 183a124:	00bffe84 	movi	r2,-6
}
 183a128:	e037883a 	mov	sp,fp
 183a12c:	dfc00117 	ldw	ra,4(sp)
 183a130:	df000017 	ldw	fp,0(sp)
 183a134:	dec00204 	addi	sp,sp,8
 183a138:	f800283a 	ret

0183a13c <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
 183a13c:	defff504 	addi	sp,sp,-44
 183a140:	dfc00a15 	stw	ra,40(sp)
 183a144:	df000915 	stw	fp,36(sp)
 183a148:	df000904 	addi	fp,sp,36
 183a14c:	e13ffe15 	stw	r4,-8(fp)
 183a150:	e17fff15 	stw	r5,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 183a154:	e0bffe17 	ldw	r2,-8(fp)
 183a158:	1000091e 	bne	r2,zero,183a180 <netconn_send+0x44>
 183a15c:	01c06134 	movhi	r7,388
 183a160:	39cec004 	addi	r7,r7,15104
 183a164:	01808f04 	movi	r6,572
 183a168:	01406134 	movhi	r5,388
 183a16c:	294f3b04 	addi	r5,r5,15596
 183a170:	01006134 	movhi	r4,388
 183a174:	210ece04 	addi	r4,r4,15160
 183a178:	1800c180 	call	1800c18 <printf>
 183a17c:	003fff06 	br	183a17c <__ram_exceptions_end+0xff829d38>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
 183a180:	00806134 	movhi	r2,388
 183a184:	10afe004 	addi	r2,r2,-16512
 183a188:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 183a18c:	e0bffe17 	ldw	r2,-8(fp)
 183a190:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.b = buf;
 183a194:	e0bfff17 	ldw	r2,-4(fp)
 183a198:	e0bffb15 	stw	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 183a19c:	e0bff804 	addi	r2,fp,-32
 183a1a0:	1009883a 	mov	r4,r2
 183a1a4:	182bf140 	call	182bf14 <tcpip_apimsg>
 183a1a8:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 183a1ac:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a1b0:	10000126 	beq	r2,zero,183a1b8 <netconn_send+0x7c>
 183a1b4:	181103c0 	call	181103c <vTaskEnterCritical>
 183a1b8:	e0bffe17 	ldw	r2,-8(fp)
 183a1bc:	10800303 	ldbu	r2,12(r2)
 183a1c0:	10803fcc 	andi	r2,r2,255
 183a1c4:	1080201c 	xori	r2,r2,128
 183a1c8:	10bfe004 	addi	r2,r2,-128
 183a1cc:	10bffdd0 	cmplti	r2,r2,-9
 183a1d0:	1000031e 	bne	r2,zero,183a1e0 <netconn_send+0xa4>
 183a1d4:	e0bffe17 	ldw	r2,-8(fp)
 183a1d8:	e0fff703 	ldbu	r3,-36(fp)
 183a1dc:	10c00305 	stb	r3,12(r2)
 183a1e0:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a1e4:	10000126 	beq	r2,zero,183a1ec <netconn_send+0xb0>
 183a1e8:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 183a1ec:	e0bff703 	ldbu	r2,-36(fp)
}
 183a1f0:	e037883a 	mov	sp,fp
 183a1f4:	dfc00117 	ldw	ra,4(sp)
 183a1f8:	df000017 	ldw	fp,0(sp)
 183a1fc:	dec00204 	addi	sp,sp,8
 183a200:	f800283a 	ret

0183a204 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 183a204:	defff304 	addi	sp,sp,-52
 183a208:	dfc00c15 	stw	ra,48(sp)
 183a20c:	df000b15 	stw	fp,44(sp)
 183a210:	df000b04 	addi	fp,sp,44
 183a214:	e13ffc15 	stw	r4,-16(fp)
 183a218:	e17ffd15 	stw	r5,-12(fp)
 183a21c:	e1bffe15 	stw	r6,-8(fp)
 183a220:	3805883a 	mov	r2,r7
 183a224:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 183a228:	e0bffc17 	ldw	r2,-16(fp)
 183a22c:	1000091e 	bne	r2,zero,183a254 <netconn_write_partly+0x50>
 183a230:	01c06134 	movhi	r7,388
 183a234:	39cec004 	addi	r7,r7,15104
 183a238:	01809744 	movi	r6,605
 183a23c:	01406134 	movhi	r5,388
 183a240:	294f4204 	addi	r5,r5,15624
 183a244:	01006134 	movhi	r4,388
 183a248:	210ece04 	addi	r4,r4,15160
 183a24c:	1800c180 	call	1800c18 <printf>
 183a250:	003fff06 	br	183a250 <__ram_exceptions_end+0xff829e0c>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 183a254:	e0bffc17 	ldw	r2,-16(fp)
 183a258:	10800017 	ldw	r2,0(r2)
 183a25c:	10800420 	cmpeqi	r2,r2,16
 183a260:	1000091e 	bne	r2,zero,183a288 <netconn_write_partly+0x84>
 183a264:	01c06134 	movhi	r7,388
 183a268:	39cec004 	addi	r7,r7,15104
 183a26c:	01809784 	movi	r6,606
 183a270:	01406134 	movhi	r5,388
 183a274:	294f4904 	addi	r5,r5,15652
 183a278:	01006134 	movhi	r4,388
 183a27c:	210ece04 	addi	r4,r4,15160
 183a280:	1800c180 	call	1800c18 <printf>
 183a284:	003fff06 	br	183a284 <__ram_exceptions_end+0xff829e40>
  if (size == 0) {
 183a288:	e0bffe17 	ldw	r2,-8(fp)
 183a28c:	1000021e 	bne	r2,zero,183a298 <netconn_write_partly+0x94>
    return ERR_OK;
 183a290:	0005883a 	mov	r2,zero
 183a294:	00003f06 	br	183a394 <netconn_write_partly+0x190>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 183a298:	e0bffc17 	ldw	r2,-16(fp)
 183a29c:	10800903 	ldbu	r2,36(r2)
 183a2a0:	10803fcc 	andi	r2,r2,255
 183a2a4:	1080008c 	andi	r2,r2,2
 183a2a8:	1000031e 	bne	r2,zero,183a2b8 <netconn_write_partly+0xb4>
 183a2ac:	e0bfff03 	ldbu	r2,-4(fp)
 183a2b0:	1080010c 	andi	r2,r2,4
 183a2b4:	10000226 	beq	r2,zero,183a2c0 <netconn_write_partly+0xbc>
 183a2b8:	00800044 	movi	r2,1
 183a2bc:	00000106 	br	183a2c4 <netconn_write_partly+0xc0>
 183a2c0:	0005883a 	mov	r2,zero
 183a2c4:	e0bff505 	stb	r2,-44(fp)
  if (dontblock && !bytes_written) {
 183a2c8:	e0bff503 	ldbu	r2,-44(fp)
 183a2cc:	10000426 	beq	r2,zero,183a2e0 <netconn_write_partly+0xdc>
 183a2d0:	e0800217 	ldw	r2,8(fp)
 183a2d4:	1000021e 	bne	r2,zero,183a2e0 <netconn_write_partly+0xdc>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 183a2d8:	00bffe84 	movi	r2,-6
 183a2dc:	00002d06 	br	183a394 <netconn_write_partly+0x190>
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 183a2e0:	00806134 	movhi	r2,388
 183a2e4:	10b17304 	addi	r2,r2,-14900
 183a2e8:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
 183a2ec:	e0bffc17 	ldw	r2,-16(fp)
 183a2f0:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.w.dataptr = dataptr;
 183a2f4:	e0bffd17 	ldw	r2,-12(fp)
 183a2f8:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.w.apiflags = apiflags;
 183a2fc:	e0bfff03 	ldbu	r2,-4(fp)
 183a300:	e0bffb05 	stb	r2,-20(fp)
  msg.msg.msg.w.len = size;
 183a304:	e0bffe17 	ldw	r2,-8(fp)
 183a308:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 183a30c:	e0bff604 	addi	r2,fp,-40
 183a310:	1009883a 	mov	r4,r2
 183a314:	182bf140 	call	182bf14 <tcpip_apimsg>
 183a318:	e0bff545 	stb	r2,-43(fp)
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 183a31c:	e0bff547 	ldb	r2,-43(fp)
 183a320:	10000b1e 	bne	r2,zero,183a350 <netconn_write_partly+0x14c>
 183a324:	e0800217 	ldw	r2,8(fp)
 183a328:	10000926 	beq	r2,zero,183a350 <netconn_write_partly+0x14c>
    if (dontblock
 183a32c:	e0bff503 	ldbu	r2,-44(fp)
 183a330:	10000426 	beq	r2,zero,183a344 <netconn_write_partly+0x140>
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
 183a334:	e0fffa17 	ldw	r3,-24(fp)
 183a338:	e0800217 	ldw	r2,8(fp)
 183a33c:	10c00015 	stw	r3,0(r2)
 183a340:	00000306 	br	183a350 <netconn_write_partly+0x14c>
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
 183a344:	e0800217 	ldw	r2,8(fp)
 183a348:	e0fffe17 	ldw	r3,-8(fp)
 183a34c:	10c00015 	stw	r3,0(r2)
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
 183a350:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a354:	10000126 	beq	r2,zero,183a35c <netconn_write_partly+0x158>
 183a358:	181103c0 	call	181103c <vTaskEnterCritical>
 183a35c:	e0bffc17 	ldw	r2,-16(fp)
 183a360:	10800303 	ldbu	r2,12(r2)
 183a364:	10803fcc 	andi	r2,r2,255
 183a368:	1080201c 	xori	r2,r2,128
 183a36c:	10bfe004 	addi	r2,r2,-128
 183a370:	10bffdd0 	cmplti	r2,r2,-9
 183a374:	1000031e 	bne	r2,zero,183a384 <netconn_write_partly+0x180>
 183a378:	e0bffc17 	ldw	r2,-16(fp)
 183a37c:	e0fff543 	ldbu	r3,-43(fp)
 183a380:	10c00305 	stb	r3,12(r2)
 183a384:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a388:	10000126 	beq	r2,zero,183a390 <netconn_write_partly+0x18c>
 183a38c:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 183a390:	e0bff543 	ldbu	r2,-43(fp)
}
 183a394:	e037883a 	mov	sp,fp
 183a398:	dfc00117 	ldw	ra,4(sp)
 183a39c:	df000017 	ldw	fp,0(sp)
 183a3a0:	dec00204 	addi	sp,sp,8
 183a3a4:	f800283a 	ret

0183a3a8 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 183a3a8:	defff504 	addi	sp,sp,-44
 183a3ac:	dfc00a15 	stw	ra,40(sp)
 183a3b0:	df000915 	stw	fp,36(sp)
 183a3b4:	df000904 	addi	fp,sp,36
 183a3b8:	e13ffe15 	stw	r4,-8(fp)
 183a3bc:	2805883a 	mov	r2,r5
 183a3c0:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 183a3c4:	e0bffe17 	ldw	r2,-8(fp)
 183a3c8:	1000091e 	bne	r2,zero,183a3f0 <netconn_close_shutdown+0x48>
 183a3cc:	01c06134 	movhi	r7,388
 183a3d0:	39cec004 	addi	r7,r7,15104
 183a3d4:	0180a704 	movi	r6,668
 183a3d8:	01406134 	movhi	r5,388
 183a3dc:	294f5204 	addi	r5,r5,15688
 183a3e0:	01006134 	movhi	r4,388
 183a3e4:	210ece04 	addi	r4,r4,15160
 183a3e8:	1800c180 	call	1800c18 <printf>
 183a3ec:	003fff06 	br	183a3ec <__ram_exceptions_end+0xff829fa8>

  msg.function = do_close;
 183a3f0:	00806134 	movhi	r2,388
 183a3f4:	10b22e04 	addi	r2,r2,-14152
 183a3f8:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 183a3fc:	e0bffe17 	ldw	r2,-8(fp)
 183a400:	e0bff915 	stw	r2,-28(fp)
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
 183a404:	e0bfff03 	ldbu	r2,-4(fp)
 183a408:	e0bffb05 	stb	r2,-20(fp)
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 183a40c:	e0bff804 	addi	r2,fp,-32
 183a410:	1009883a 	mov	r4,r2
 183a414:	182bf140 	call	182bf14 <tcpip_apimsg>
 183a418:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 183a41c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a420:	10000126 	beq	r2,zero,183a428 <netconn_close_shutdown+0x80>
 183a424:	181103c0 	call	181103c <vTaskEnterCritical>
 183a428:	e0bffe17 	ldw	r2,-8(fp)
 183a42c:	10800303 	ldbu	r2,12(r2)
 183a430:	10803fcc 	andi	r2,r2,255
 183a434:	1080201c 	xori	r2,r2,128
 183a438:	10bfe004 	addi	r2,r2,-128
 183a43c:	10bffdd0 	cmplti	r2,r2,-9
 183a440:	1000031e 	bne	r2,zero,183a450 <netconn_close_shutdown+0xa8>
 183a444:	e0bffe17 	ldw	r2,-8(fp)
 183a448:	e0fff703 	ldbu	r3,-36(fp)
 183a44c:	10c00305 	stb	r3,12(r2)
 183a450:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a454:	10000126 	beq	r2,zero,183a45c <netconn_close_shutdown+0xb4>
 183a458:	18110840 	call	1811084 <vTaskExitCritical>
  return err;
 183a45c:	e0bff703 	ldbu	r2,-36(fp)
}
 183a460:	e037883a 	mov	sp,fp
 183a464:	dfc00117 	ldw	ra,4(sp)
 183a468:	df000017 	ldw	fp,0(sp)
 183a46c:	dec00204 	addi	sp,sp,8
 183a470:	f800283a 	ret

0183a474 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
 183a474:	defffd04 	addi	sp,sp,-12
 183a478:	dfc00215 	stw	ra,8(sp)
 183a47c:	df000115 	stw	fp,4(sp)
 183a480:	df000104 	addi	fp,sp,4
 183a484:	e13fff15 	stw	r4,-4(fp)
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 183a488:	014000c4 	movi	r5,3
 183a48c:	e13fff17 	ldw	r4,-4(fp)
 183a490:	183a3a80 	call	183a3a8 <netconn_close_shutdown>
}
 183a494:	e037883a 	mov	sp,fp
 183a498:	dfc00117 	ldw	ra,4(sp)
 183a49c:	df000017 	ldw	fp,0(sp)
 183a4a0:	dec00204 	addi	sp,sp,8
 183a4a4:	f800283a 	ret

0183a4a8 <netconn_shutdown>:
 * @param conn the TCP netconn to shut down
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
 183a4a8:	defffb04 	addi	sp,sp,-20
 183a4ac:	dfc00415 	stw	ra,16(sp)
 183a4b0:	df000315 	stw	fp,12(sp)
 183a4b4:	df000304 	addi	fp,sp,12
 183a4b8:	e13ffd15 	stw	r4,-12(fp)
 183a4bc:	2807883a 	mov	r3,r5
 183a4c0:	3005883a 	mov	r2,r6
 183a4c4:	e0fffe05 	stb	r3,-8(fp)
 183a4c8:	e0bfff05 	stb	r2,-4(fp)
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
 183a4cc:	e0bffe03 	ldbu	r2,-8(fp)
 183a4d0:	1004c03a 	cmpne	r2,r2,zero
 183a4d4:	1007883a 	mov	r3,r2
 183a4d8:	e0bfff03 	ldbu	r2,-4(fp)
 183a4dc:	10000226 	beq	r2,zero,183a4e8 <netconn_shutdown+0x40>
 183a4e0:	00800084 	movi	r2,2
 183a4e4:	00000106 	br	183a4ec <netconn_shutdown+0x44>
 183a4e8:	0005883a 	mov	r2,zero
 183a4ec:	1884b03a 	or	r2,r3,r2
 183a4f0:	10803fcc 	andi	r2,r2,255
 183a4f4:	100b883a 	mov	r5,r2
 183a4f8:	e13ffd17 	ldw	r4,-12(fp)
 183a4fc:	183a3a80 	call	183a3a8 <netconn_close_shutdown>
}
 183a500:	e037883a 	mov	sp,fp
 183a504:	dfc00117 	ldw	ra,4(sp)
 183a508:	df000017 	ldw	fp,0(sp)
 183a50c:	dec00204 	addi	sp,sp,8
 183a510:	f800283a 	ret

0183a514 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
 183a514:	defff604 	addi	sp,sp,-40
 183a518:	dfc00915 	stw	ra,36(sp)
 183a51c:	df000815 	stw	fp,32(sp)
 183a520:	df000804 	addi	fp,sp,32
 183a524:	e13ffc15 	stw	r4,-16(fp)
 183a528:	e17ffd15 	stw	r5,-12(fp)
 183a52c:	e1bffe15 	stw	r6,-8(fp)
 183a530:	e1ffff15 	stw	r7,-4(fp)
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
 183a534:	e0bffc17 	ldw	r2,-16(fp)
 183a538:	e0bff915 	stw	r2,-28(fp)

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 183a53c:	e0bff917 	ldw	r2,-28(fp)
 183a540:	10004a26 	beq	r2,zero,183a66c <recv_raw+0x158>
 183a544:	e0bff917 	ldw	r2,-28(fp)
 183a548:	10800517 	ldw	r2,20(r2)
 183a54c:	10004726 	beq	r2,zero,183a66c <recv_raw+0x158>
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 183a550:	e0bffe17 	ldw	r2,-8(fp)
 183a554:	1080020b 	ldhu	r2,8(r2)
 183a558:	10bfffcc 	andi	r2,r2,65535
 183a55c:	000d883a 	mov	r6,zero
 183a560:	100b883a 	mov	r5,r2
 183a564:	010000c4 	movi	r4,3
 183a568:	181a4e80 	call	181a4e8 <pbuf_alloc>
 183a56c:	e0bff815 	stw	r2,-32(fp)
    if(q != NULL) {
 183a570:	e0bff817 	ldw	r2,-32(fp)
 183a574:	10000a26 	beq	r2,zero,183a5a0 <recv_raw+0x8c>
      if (pbuf_copy(q, p) != ERR_OK) {
 183a578:	e17ffe17 	ldw	r5,-8(fp)
 183a57c:	e13ff817 	ldw	r4,-32(fp)
 183a580:	181b04c0 	call	181b04c <pbuf_copy>
 183a584:	10803fcc 	andi	r2,r2,255
 183a588:	1080201c 	xori	r2,r2,128
 183a58c:	10bfe004 	addi	r2,r2,-128
 183a590:	10000326 	beq	r2,zero,183a5a0 <recv_raw+0x8c>
        pbuf_free(q);
 183a594:	e13ff817 	ldw	r4,-32(fp)
 183a598:	181aca40 	call	181aca4 <pbuf_free>
        q = NULL;
 183a59c:	e03ff815 	stw	zero,-32(fp)
      }
    }

    if (q != NULL) {
 183a5a0:	e0bff817 	ldw	r2,-32(fp)
 183a5a4:	10003126 	beq	r2,zero,183a66c <recv_raw+0x158>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 183a5a8:	010001c4 	movi	r4,7
 183a5ac:	18349580 	call	1834958 <memp_malloc>
 183a5b0:	e0bffa15 	stw	r2,-24(fp)
      if (buf == NULL) {
 183a5b4:	e0bffa17 	ldw	r2,-24(fp)
 183a5b8:	1000041e 	bne	r2,zero,183a5cc <recv_raw+0xb8>
        pbuf_free(q);
 183a5bc:	e13ff817 	ldw	r4,-32(fp)
 183a5c0:	181aca40 	call	181aca4 <pbuf_free>
        return 0;
 183a5c4:	0005883a 	mov	r2,zero
 183a5c8:	00002906 	br	183a670 <recv_raw+0x15c>
      }

      buf->p = q;
 183a5cc:	e0bffa17 	ldw	r2,-24(fp)
 183a5d0:	e0fff817 	ldw	r3,-32(fp)
 183a5d4:	10c00015 	stw	r3,0(r2)
      buf->ptr = q;
 183a5d8:	e0bffa17 	ldw	r2,-24(fp)
 183a5dc:	e0fff817 	ldw	r3,-32(fp)
 183a5e0:	10c00115 	stw	r3,4(r2)
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 183a5e4:	d0e81217 	ldw	r3,-24504(gp)
 183a5e8:	e0bffa17 	ldw	r2,-24(fp)
 183a5ec:	10c00215 	stw	r3,8(r2)
      buf->port = pcb->protocol;
 183a5f0:	e0bffd17 	ldw	r2,-12(fp)
 183a5f4:	10800403 	ldbu	r2,16(r2)
 183a5f8:	10c03fcc 	andi	r3,r2,255
 183a5fc:	e0bffa17 	ldw	r2,-24(fp)
 183a600:	10c0030d 	sth	r3,12(r2)

      len = q->tot_len;
 183a604:	e0bff817 	ldw	r2,-32(fp)
 183a608:	1080020b 	ldhu	r2,8(r2)
 183a60c:	e0bffb0d 	sth	r2,-20(fp)
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 183a610:	e0bff917 	ldw	r2,-28(fp)
 183a614:	10800504 	addi	r2,r2,20
 183a618:	e17ffa17 	ldw	r5,-24(fp)
 183a61c:	1009883a 	mov	r4,r2
 183a620:	18154d40 	call	18154d4 <sys_mbox_trypost>
 183a624:	10803fcc 	andi	r2,r2,255
 183a628:	1080201c 	xori	r2,r2,128
 183a62c:	10bfe004 	addi	r2,r2,-128
 183a630:	10000426 	beq	r2,zero,183a644 <recv_raw+0x130>
        netbuf_delete(buf);
 183a634:	e13ffa17 	ldw	r4,-24(fp)
 183a638:	183ca5c0 	call	183ca5c <netbuf_delete>
        return 0;
 183a63c:	0005883a 	mov	r2,zero
 183a640:	00000b06 	br	183a670 <recv_raw+0x15c>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 183a644:	e0bff917 	ldw	r2,-28(fp)
 183a648:	10800c17 	ldw	r2,48(r2)
 183a64c:	10000726 	beq	r2,zero,183a66c <recv_raw+0x158>
 183a650:	e0bff917 	ldw	r2,-28(fp)
 183a654:	10800c17 	ldw	r2,48(r2)
 183a658:	e0fffb0b 	ldhu	r3,-20(fp)
 183a65c:	180d883a 	mov	r6,r3
 183a660:	000b883a 	mov	r5,zero
 183a664:	e13ff917 	ldw	r4,-28(fp)
 183a668:	103ee83a 	callr	r2
      }
    }
  }

  return 0; /* do not eat the packet */
 183a66c:	0005883a 	mov	r2,zero
}
 183a670:	e037883a 	mov	sp,fp
 183a674:	dfc00117 	ldw	ra,4(sp)
 183a678:	df000017 	ldw	fp,0(sp)
 183a67c:	dec00204 	addi	sp,sp,8
 183a680:	f800283a 	ret

0183a684 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
 183a684:	defff604 	addi	sp,sp,-40
 183a688:	dfc00915 	stw	ra,36(sp)
 183a68c:	df000815 	stw	fp,32(sp)
 183a690:	df000804 	addi	fp,sp,32
 183a694:	e13ffb15 	stw	r4,-20(fp)
 183a698:	e17ffc15 	stw	r5,-16(fp)
 183a69c:	e1bffd15 	stw	r6,-12(fp)
 183a6a0:	e1fffe15 	stw	r7,-8(fp)
 183a6a4:	e0800217 	ldw	r2,8(fp)
 183a6a8:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
 183a6ac:	e0bffb17 	ldw	r2,-20(fp)
 183a6b0:	e0bff815 	stw	r2,-32(fp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
 183a6b4:	e0bff817 	ldw	r2,-32(fp)
 183a6b8:	10000326 	beq	r2,zero,183a6c8 <recv_udp+0x44>
 183a6bc:	e0bff817 	ldw	r2,-32(fp)
 183a6c0:	10800517 	ldw	r2,20(r2)
 183a6c4:	1000031e 	bne	r2,zero,183a6d4 <recv_udp+0x50>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 183a6c8:	e13ffd17 	ldw	r4,-12(fp)
 183a6cc:	181aca40 	call	181aca4 <pbuf_free>
    return;
 183a6d0:	00003206 	br	183a79c <recv_udp+0x118>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 183a6d4:	010001c4 	movi	r4,7
 183a6d8:	18349580 	call	1834958 <memp_malloc>
 183a6dc:	e0bff915 	stw	r2,-28(fp)
  if (buf == NULL) {
 183a6e0:	e0bff917 	ldw	r2,-28(fp)
 183a6e4:	1000031e 	bne	r2,zero,183a6f4 <recv_udp+0x70>
    pbuf_free(p);
 183a6e8:	e13ffd17 	ldw	r4,-12(fp)
 183a6ec:	181aca40 	call	181aca4 <pbuf_free>
    return;
 183a6f0:	00002a06 	br	183a79c <recv_udp+0x118>
  } else {
    buf->p = p;
 183a6f4:	e0bff917 	ldw	r2,-28(fp)
 183a6f8:	e0fffd17 	ldw	r3,-12(fp)
 183a6fc:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 183a700:	e0bff917 	ldw	r2,-28(fp)
 183a704:	e0fffd17 	ldw	r3,-12(fp)
 183a708:	10c00115 	stw	r3,4(r2)
    ip_addr_set(&buf->addr, addr);
 183a70c:	e0bffe17 	ldw	r2,-8(fp)
 183a710:	10000326 	beq	r2,zero,183a720 <recv_udp+0x9c>
 183a714:	e0bffe17 	ldw	r2,-8(fp)
 183a718:	10800017 	ldw	r2,0(r2)
 183a71c:	00000106 	br	183a724 <recv_udp+0xa0>
 183a720:	0005883a 	mov	r2,zero
 183a724:	e0fff917 	ldw	r3,-28(fp)
 183a728:	18800215 	stw	r2,8(r3)
    buf->port = port;
 183a72c:	e0bff917 	ldw	r2,-28(fp)
 183a730:	e0ffff0b 	ldhu	r3,-4(fp)
 183a734:	10c0030d 	sth	r3,12(r2)
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 183a738:	e0bffd17 	ldw	r2,-12(fp)
 183a73c:	1080020b 	ldhu	r2,8(r2)
 183a740:	e0bffa0d 	sth	r2,-24(fp)
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 183a744:	e0bff817 	ldw	r2,-32(fp)
 183a748:	10800504 	addi	r2,r2,20
 183a74c:	e17ff917 	ldw	r5,-28(fp)
 183a750:	1009883a 	mov	r4,r2
 183a754:	18154d40 	call	18154d4 <sys_mbox_trypost>
 183a758:	10803fcc 	andi	r2,r2,255
 183a75c:	1080201c 	xori	r2,r2,128
 183a760:	10bfe004 	addi	r2,r2,-128
 183a764:	10000326 	beq	r2,zero,183a774 <recv_udp+0xf0>
    netbuf_delete(buf);
 183a768:	e13ff917 	ldw	r4,-28(fp)
 183a76c:	183ca5c0 	call	183ca5c <netbuf_delete>
    return;
 183a770:	00000a06 	br	183a79c <recv_udp+0x118>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 183a774:	e0bff817 	ldw	r2,-32(fp)
 183a778:	10800c17 	ldw	r2,48(r2)
 183a77c:	10000726 	beq	r2,zero,183a79c <recv_udp+0x118>
 183a780:	e0bff817 	ldw	r2,-32(fp)
 183a784:	10800c17 	ldw	r2,48(r2)
 183a788:	e0fffa0b 	ldhu	r3,-24(fp)
 183a78c:	180d883a 	mov	r6,r3
 183a790:	000b883a 	mov	r5,zero
 183a794:	e13ff817 	ldw	r4,-32(fp)
 183a798:	103ee83a 	callr	r2
  }
}
 183a79c:	e037883a 	mov	sp,fp
 183a7a0:	dfc00117 	ldw	ra,4(sp)
 183a7a4:	df000017 	ldw	fp,0(sp)
 183a7a8:	dec00204 	addi	sp,sp,8
 183a7ac:	f800283a 	ret

0183a7b0 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 183a7b0:	defff804 	addi	sp,sp,-32
 183a7b4:	dfc00715 	stw	ra,28(sp)
 183a7b8:	df000615 	stw	fp,24(sp)
 183a7bc:	df000604 	addi	fp,sp,24
 183a7c0:	e13ffc15 	stw	r4,-16(fp)
 183a7c4:	e17ffd15 	stw	r5,-12(fp)
 183a7c8:	e1bffe15 	stw	r6,-8(fp)
 183a7cc:	3805883a 	mov	r2,r7
 183a7d0:	e0bfff05 	stb	r2,-4(fp)
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
 183a7d4:	e0bffc17 	ldw	r2,-16(fp)
 183a7d8:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 183a7dc:	e0bffb17 	ldw	r2,-20(fp)
 183a7e0:	1000021e 	bne	r2,zero,183a7ec <recv_tcp+0x3c>
    return ERR_VAL;
 183a7e4:	00bffe84 	movi	r2,-6
 183a7e8:	00003c06 	br	183a8dc <recv_tcp+0x12c>
  }

  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if (!sys_mbox_valid(&conn->recvmbox)) {
 183a7ec:	e0bffb17 	ldw	r2,-20(fp)
 183a7f0:	10800517 	ldw	r2,20(r2)
 183a7f4:	10000c1e 	bne	r2,zero,183a828 <recv_tcp+0x78>
    /* recvmbox already deleted */
    if (p != NULL) {
 183a7f8:	e0bffe17 	ldw	r2,-8(fp)
 183a7fc:	10000826 	beq	r2,zero,183a820 <recv_tcp+0x70>
      tcp_recved(pcb, p->tot_len);
 183a800:	e0bffe17 	ldw	r2,-8(fp)
 183a804:	1080020b 	ldhu	r2,8(r2)
 183a808:	10bfffcc 	andi	r2,r2,65535
 183a80c:	100b883a 	mov	r5,r2
 183a810:	e13ffd17 	ldw	r4,-12(fp)
 183a814:	181c6800 	call	181c680 <tcp_recved>
      pbuf_free(p);
 183a818:	e13ffe17 	ldw	r4,-8(fp)
 183a81c:	181aca40 	call	181aca4 <pbuf_free>
    }
    return ERR_OK;
 183a820:	0005883a 	mov	r2,zero
 183a824:	00002d06 	br	183a8dc <recv_tcp+0x12c>
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
 183a828:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a82c:	10000126 	beq	r2,zero,183a834 <recv_tcp+0x84>
 183a830:	181103c0 	call	181103c <vTaskEnterCritical>
 183a834:	e0bffb17 	ldw	r2,-20(fp)
 183a838:	10800303 	ldbu	r2,12(r2)
 183a83c:	10803fcc 	andi	r2,r2,255
 183a840:	1080201c 	xori	r2,r2,128
 183a844:	10bfe004 	addi	r2,r2,-128
 183a848:	10bffdd0 	cmplti	r2,r2,-9
 183a84c:	1000031e 	bne	r2,zero,183a85c <recv_tcp+0xac>
 183a850:	e0bffb17 	ldw	r2,-20(fp)
 183a854:	e0ffff03 	ldbu	r3,-4(fp)
 183a858:	10c00305 	stb	r3,12(r2)
 183a85c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183a860:	10000126 	beq	r2,zero,183a868 <recv_tcp+0xb8>
 183a864:	18110840 	call	1811084 <vTaskExitCritical>

  if (p != NULL) {
 183a868:	e0bffe17 	ldw	r2,-8(fp)
 183a86c:	10000426 	beq	r2,zero,183a880 <recv_tcp+0xd0>
    len = p->tot_len;
 183a870:	e0bffe17 	ldw	r2,-8(fp)
 183a874:	1080020b 	ldhu	r2,8(r2)
 183a878:	e0bffa0d 	sth	r2,-24(fp)
 183a87c:	00000106 	br	183a884 <recv_tcp+0xd4>
  } else {
    len = 0;
 183a880:	e03ffa0d 	sth	zero,-24(fp)
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 183a884:	e0bffb17 	ldw	r2,-20(fp)
 183a888:	10800504 	addi	r2,r2,20
 183a88c:	e17ffe17 	ldw	r5,-8(fp)
 183a890:	1009883a 	mov	r4,r2
 183a894:	18154d40 	call	18154d4 <sys_mbox_trypost>
 183a898:	10803fcc 	andi	r2,r2,255
 183a89c:	1080201c 	xori	r2,r2,128
 183a8a0:	10bfe004 	addi	r2,r2,-128
 183a8a4:	10000226 	beq	r2,zero,183a8b0 <recv_tcp+0x100>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
 183a8a8:	00bfffc4 	movi	r2,-1
 183a8ac:	00000b06 	br	183a8dc <recv_tcp+0x12c>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 183a8b0:	e0bffb17 	ldw	r2,-20(fp)
 183a8b4:	10800c17 	ldw	r2,48(r2)
 183a8b8:	10000726 	beq	r2,zero,183a8d8 <recv_tcp+0x128>
 183a8bc:	e0bffb17 	ldw	r2,-20(fp)
 183a8c0:	10800c17 	ldw	r2,48(r2)
 183a8c4:	e0fffa0b 	ldhu	r3,-24(fp)
 183a8c8:	180d883a 	mov	r6,r3
 183a8cc:	000b883a 	mov	r5,zero
 183a8d0:	e13ffb17 	ldw	r4,-20(fp)
 183a8d4:	103ee83a 	callr	r2
  }

  return ERR_OK;
 183a8d8:	0005883a 	mov	r2,zero
}
 183a8dc:	e037883a 	mov	sp,fp
 183a8e0:	dfc00117 	ldw	ra,4(sp)
 183a8e4:	df000017 	ldw	fp,0(sp)
 183a8e8:	dec00204 	addi	sp,sp,8
 183a8ec:	f800283a 	ret

0183a8f0 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 183a8f0:	defffb04 	addi	sp,sp,-20
 183a8f4:	dfc00415 	stw	ra,16(sp)
 183a8f8:	df000315 	stw	fp,12(sp)
 183a8fc:	df000304 	addi	fp,sp,12
 183a900:	e13ffe15 	stw	r4,-8(fp)
 183a904:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 183a908:	e0bffe17 	ldw	r2,-8(fp)
 183a90c:	e0bffd15 	stw	r2,-12(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
 183a910:	e0bffd17 	ldw	r2,-12(fp)
 183a914:	10800117 	ldw	r2,4(r2)
 183a918:	10800058 	cmpnei	r2,r2,1
 183a91c:	1000031e 	bne	r2,zero,183a92c <poll_tcp+0x3c>
    do_writemore(conn);
 183a920:	e13ffd17 	ldw	r4,-12(fp)
 183a924:	183c2c00 	call	183c2c0 <do_writemore>
 183a928:	00000606 	br	183a944 <poll_tcp+0x54>
  } else if (conn->state == NETCONN_CLOSE) {
 183a92c:	e0bffd17 	ldw	r2,-12(fp)
 183a930:	10800117 	ldw	r2,4(r2)
 183a934:	10800118 	cmpnei	r2,r2,4
 183a938:	1000021e 	bne	r2,zero,183a944 <poll_tcp+0x54>
    do_close_internal(conn);
 183a93c:	e13ffd17 	ldw	r4,-12(fp)
 183a940:	183b3880 	call	183b388 <do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 183a944:	e0bffd17 	ldw	r2,-12(fp)
 183a948:	10800903 	ldbu	r2,36(r2)
 183a94c:	10803fcc 	andi	r2,r2,255
 183a950:	1080040c 	andi	r2,r2,16
 183a954:	10001f26 	beq	r2,zero,183a9d4 <poll_tcp+0xe4>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 183a958:	e0bffd17 	ldw	r2,-12(fp)
 183a95c:	10800217 	ldw	r2,8(r2)
 183a960:	10001c26 	beq	r2,zero,183a9d4 <poll_tcp+0xe4>
 183a964:	e0bffd17 	ldw	r2,-12(fp)
 183a968:	10800217 	ldw	r2,8(r2)
 183a96c:	10801a8b 	ldhu	r2,106(r2)
 183a970:	10bfffcc 	andi	r2,r2,65535
 183a974:	10816d70 	cmpltui	r2,r2,1461
 183a978:	1000161e 	bne	r2,zero,183a9d4 <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 183a97c:	e0bffd17 	ldw	r2,-12(fp)
 183a980:	10800217 	ldw	r2,8(r2)
 183a984:	10801b0b 	ldhu	r2,108(r2)

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 183a988:	10bfffcc 	andi	r2,r2,65535
 183a98c:	10800128 	cmpgeui	r2,r2,4
 183a990:	1000101e 	bne	r2,zero,183a9d4 <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 183a994:	e0bffd17 	ldw	r2,-12(fp)
 183a998:	10c00903 	ldbu	r3,36(r2)
 183a99c:	00bffbc4 	movi	r2,-17
 183a9a0:	1884703a 	and	r2,r3,r2
 183a9a4:	1007883a 	mov	r3,r2
 183a9a8:	e0bffd17 	ldw	r2,-12(fp)
 183a9ac:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 183a9b0:	e0bffd17 	ldw	r2,-12(fp)
 183a9b4:	10800c17 	ldw	r2,48(r2)
 183a9b8:	10000626 	beq	r2,zero,183a9d4 <poll_tcp+0xe4>
 183a9bc:	e0bffd17 	ldw	r2,-12(fp)
 183a9c0:	10800c17 	ldw	r2,48(r2)
 183a9c4:	000d883a 	mov	r6,zero
 183a9c8:	01400084 	movi	r5,2
 183a9cc:	e13ffd17 	ldw	r4,-12(fp)
 183a9d0:	103ee83a 	callr	r2
    }
  }

  return ERR_OK;
 183a9d4:	0005883a 	mov	r2,zero
}
 183a9d8:	e037883a 	mov	sp,fp
 183a9dc:	dfc00117 	ldw	ra,4(sp)
 183a9e0:	df000017 	ldw	fp,0(sp)
 183a9e4:	dec00204 	addi	sp,sp,8
 183a9e8:	f800283a 	ret

0183a9ec <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 183a9ec:	defffa04 	addi	sp,sp,-24
 183a9f0:	dfc00515 	stw	ra,20(sp)
 183a9f4:	df000415 	stw	fp,16(sp)
 183a9f8:	df000404 	addi	fp,sp,16
 183a9fc:	e13ffd15 	stw	r4,-12(fp)
 183aa00:	e17ffe15 	stw	r5,-8(fp)
 183aa04:	3005883a 	mov	r2,r6
 183aa08:	e0bfff0d 	sth	r2,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 183aa0c:	e0bffd17 	ldw	r2,-12(fp)
 183aa10:	e0bffc15 	stw	r2,-16(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn) {
 183aa14:	e0bffc17 	ldw	r2,-16(fp)
 183aa18:	10002d26 	beq	r2,zero,183aad0 <sent_tcp+0xe4>
  if (conn->state == NETCONN_WRITE) {
 183aa1c:	e0bffc17 	ldw	r2,-16(fp)
 183aa20:	10800117 	ldw	r2,4(r2)
 183aa24:	10800058 	cmpnei	r2,r2,1
 183aa28:	1000031e 	bne	r2,zero,183aa38 <sent_tcp+0x4c>
    do_writemore(conn);
 183aa2c:	e13ffc17 	ldw	r4,-16(fp)
 183aa30:	183c2c00 	call	183c2c0 <do_writemore>
 183aa34:	00000606 	br	183aa50 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
 183aa38:	e0bffc17 	ldw	r2,-16(fp)
 183aa3c:	10800117 	ldw	r2,4(r2)
 183aa40:	10800118 	cmpnei	r2,r2,4
 183aa44:	1000021e 	bne	r2,zero,183aa50 <sent_tcp+0x64>
    do_close_internal(conn);
 183aa48:	e13ffc17 	ldw	r4,-16(fp)
 183aa4c:	183b3880 	call	183b388 <do_close_internal>
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 183aa50:	e0bffc17 	ldw	r2,-16(fp)
 183aa54:	10800217 	ldw	r2,8(r2)
 183aa58:	10001d26 	beq	r2,zero,183aad0 <sent_tcp+0xe4>
 183aa5c:	e0bffc17 	ldw	r2,-16(fp)
 183aa60:	10800217 	ldw	r2,8(r2)
 183aa64:	10801a8b 	ldhu	r2,106(r2)
 183aa68:	10bfffcc 	andi	r2,r2,65535
 183aa6c:	10816d70 	cmpltui	r2,r2,1461
 183aa70:	1000171e 	bne	r2,zero,183aad0 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 183aa74:	e0bffc17 	ldw	r2,-16(fp)
 183aa78:	10800217 	ldw	r2,8(r2)
 183aa7c:	10801b0b 	ldhu	r2,108(r2)
    do_close_internal(conn);
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 183aa80:	10bfffcc 	andi	r2,r2,65535
 183aa84:	10800128 	cmpgeui	r2,r2,4
 183aa88:	1000111e 	bne	r2,zero,183aad0 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 183aa8c:	e0bffc17 	ldw	r2,-16(fp)
 183aa90:	10c00903 	ldbu	r3,36(r2)
 183aa94:	00bffbc4 	movi	r2,-17
 183aa98:	1884703a 	and	r2,r3,r2
 183aa9c:	1007883a 	mov	r3,r2
 183aaa0:	e0bffc17 	ldw	r2,-16(fp)
 183aaa4:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 183aaa8:	e0bffc17 	ldw	r2,-16(fp)
 183aaac:	10800c17 	ldw	r2,48(r2)
 183aab0:	10000726 	beq	r2,zero,183aad0 <sent_tcp+0xe4>
 183aab4:	e0bffc17 	ldw	r2,-16(fp)
 183aab8:	10800c17 	ldw	r2,48(r2)
 183aabc:	e0ffff0b 	ldhu	r3,-4(fp)
 183aac0:	180d883a 	mov	r6,r3
 183aac4:	01400084 	movi	r5,2
 183aac8:	e13ffc17 	ldw	r4,-16(fp)
 183aacc:	103ee83a 	callr	r2
    }
  }
  
  return ERR_OK;
 183aad0:	0005883a 	mov	r2,zero
}
 183aad4:	e037883a 	mov	sp,fp
 183aad8:	dfc00117 	ldw	ra,4(sp)
 183aadc:	df000017 	ldw	fp,0(sp)
 183aae0:	dec00204 	addi	sp,sp,8
 183aae4:	f800283a 	ret

0183aae8 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
 183aae8:	defff904 	addi	sp,sp,-28
 183aaec:	dfc00615 	stw	ra,24(sp)
 183aaf0:	df000515 	stw	fp,20(sp)
 183aaf4:	df000504 	addi	fp,sp,20
 183aaf8:	e13ffe15 	stw	r4,-8(fp)
 183aafc:	2805883a 	mov	r2,r5
 183ab00:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
 183ab04:	e0bffe17 	ldw	r2,-8(fp)
 183ab08:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
 183ab0c:	e0bffb17 	ldw	r2,-20(fp)
 183ab10:	10000215 	stw	zero,8(r2)

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
 183ab14:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183ab18:	10000126 	beq	r2,zero,183ab20 <err_tcp+0x38>
 183ab1c:	181103c0 	call	181103c <vTaskEnterCritical>
  conn->last_err = err;
 183ab20:	e0bffb17 	ldw	r2,-20(fp)
 183ab24:	e0ffff03 	ldbu	r3,-4(fp)
 183ab28:	10c00305 	stb	r3,12(r2)
  SYS_ARCH_UNPROTECT(lev);
 183ab2c:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183ab30:	10000126 	beq	r2,zero,183ab38 <err_tcp+0x50>
 183ab34:	18110840 	call	1811084 <vTaskExitCritical>

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
 183ab38:	e0bffb17 	ldw	r2,-20(fp)
 183ab3c:	10800117 	ldw	r2,4(r2)
 183ab40:	e0bffc15 	stw	r2,-16(fp)
  conn->state = NETCONN_NONE;
 183ab44:	e0bffb17 	ldw	r2,-20(fp)
 183ab48:	10000115 	stw	zero,4(r2)

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 183ab4c:	e0bffb17 	ldw	r2,-20(fp)
 183ab50:	10800c17 	ldw	r2,48(r2)
 183ab54:	10000626 	beq	r2,zero,183ab70 <err_tcp+0x88>
 183ab58:	e0bffb17 	ldw	r2,-20(fp)
 183ab5c:	10800c17 	ldw	r2,48(r2)
 183ab60:	000d883a 	mov	r6,zero
 183ab64:	01400104 	movi	r5,4
 183ab68:	e13ffb17 	ldw	r4,-20(fp)
 183ab6c:	103ee83a 	callr	r2
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 183ab70:	e0bffb17 	ldw	r2,-20(fp)
 183ab74:	10800c17 	ldw	r2,48(r2)
 183ab78:	10000626 	beq	r2,zero,183ab94 <err_tcp+0xac>
 183ab7c:	e0bffb17 	ldw	r2,-20(fp)
 183ab80:	10800c17 	ldw	r2,48(r2)
 183ab84:	000d883a 	mov	r6,zero
 183ab88:	000b883a 	mov	r5,zero
 183ab8c:	e13ffb17 	ldw	r4,-20(fp)
 183ab90:	103ee83a 	callr	r2
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 183ab94:	e0bffb17 	ldw	r2,-20(fp)
 183ab98:	10800c17 	ldw	r2,48(r2)
 183ab9c:	10000626 	beq	r2,zero,183abb8 <err_tcp+0xd0>
 183aba0:	e0bffb17 	ldw	r2,-20(fp)
 183aba4:	10800c17 	ldw	r2,48(r2)
 183aba8:	000d883a 	mov	r6,zero
 183abac:	01400084 	movi	r5,2
 183abb0:	e13ffb17 	ldw	r4,-20(fp)
 183abb4:	103ee83a 	callr	r2

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
 183abb8:	e0bffb17 	ldw	r2,-20(fp)
 183abbc:	10800517 	ldw	r2,20(r2)
 183abc0:	10000526 	beq	r2,zero,183abd8 <err_tcp+0xf0>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
 183abc4:	e0bffb17 	ldw	r2,-20(fp)
 183abc8:	10800504 	addi	r2,r2,20
 183abcc:	000b883a 	mov	r5,zero
 183abd0:	1009883a 	mov	r4,r2
 183abd4:	18154d40 	call	18154d4 <sys_mbox_trypost>
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
 183abd8:	e0bffb17 	ldw	r2,-20(fp)
 183abdc:	10800617 	ldw	r2,24(r2)
 183abe0:	10000526 	beq	r2,zero,183abf8 <err_tcp+0x110>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 183abe4:	e0bffb17 	ldw	r2,-20(fp)
 183abe8:	10800604 	addi	r2,r2,24
 183abec:	000b883a 	mov	r5,zero
 183abf0:	1009883a 	mov	r4,r2
 183abf4:	18154d40 	call	18154d4 <sys_mbox_trypost>
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 183abf8:	e0bffc17 	ldw	r2,-16(fp)
 183abfc:	10800060 	cmpeqi	r2,r2,1
 183ac00:	1000061e 	bne	r2,zero,183ac1c <err_tcp+0x134>
 183ac04:	e0bffc17 	ldw	r2,-16(fp)
 183ac08:	10800120 	cmpeqi	r2,r2,4
 183ac0c:	1000031e 	bne	r2,zero,183ac1c <err_tcp+0x134>
 183ac10:	e0bffc17 	ldw	r2,-16(fp)
 183ac14:	108000d8 	cmpnei	r2,r2,3
 183ac18:	10001a1e 	bne	r2,zero,183ac84 <err_tcp+0x19c>
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 183ac1c:	e0bffb17 	ldw	r2,-20(fp)
 183ac20:	10800903 	ldbu	r2,36(r2)
 183ac24:	10803fcc 	andi	r2,r2,255
 183ac28:	1080010c 	andi	r2,r2,4
 183ac2c:	1004c03a 	cmpne	r2,r2,zero
 183ac30:	10803fcc 	andi	r2,r2,255
 183ac34:	e0bffd15 	stw	r2,-12(fp)
    SET_NONBLOCKING_CONNECT(conn, 0);
 183ac38:	e0bffb17 	ldw	r2,-20(fp)
 183ac3c:	10c00903 	ldbu	r3,36(r2)
 183ac40:	00bffec4 	movi	r2,-5
 183ac44:	1884703a 	and	r2,r3,r2
 183ac48:	1007883a 	mov	r3,r2
 183ac4c:	e0bffb17 	ldw	r2,-20(fp)
 183ac50:	10c00905 	stb	r3,36(r2)

    if (!was_nonblocking_connect) {
 183ac54:	e0bffd17 	ldw	r2,-12(fp)
 183ac58:	10000a1e 	bne	r2,zero,183ac84 <err_tcp+0x19c>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
 183ac5c:	e0bffb17 	ldw	r2,-20(fp)
 183ac60:	10800b17 	ldw	r2,44(r2)
 183ac64:	e0ffff03 	ldbu	r3,-4(fp)
 183ac68:	10c00105 	stb	r3,4(r2)
      conn->current_msg = NULL;
 183ac6c:	e0bffb17 	ldw	r2,-20(fp)
 183ac70:	10000b15 	stw	zero,44(r2)
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 183ac74:	e0bffb17 	ldw	r2,-20(fp)
 183ac78:	10800404 	addi	r2,r2,16
 183ac7c:	1009883a 	mov	r4,r2
 183ac80:	18150740 	call	1815074 <sys_sem_signal>
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 183ac84:	0001883a 	nop
 183ac88:	e037883a 	mov	sp,fp
 183ac8c:	dfc00117 	ldw	ra,4(sp)
 183ac90:	df000017 	ldw	fp,0(sp)
 183ac94:	dec00204 	addi	sp,sp,8
 183ac98:	f800283a 	ret

0183ac9c <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 183ac9c:	defffc04 	addi	sp,sp,-16
 183aca0:	dfc00315 	stw	ra,12(sp)
 183aca4:	df000215 	stw	fp,8(sp)
 183aca8:	df000204 	addi	fp,sp,8
 183acac:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 183acb0:	e0bfff17 	ldw	r2,-4(fp)
 183acb4:	10800217 	ldw	r2,8(r2)
 183acb8:	e0bffe15 	stw	r2,-8(fp)
  tcp_arg(pcb, conn);
 183acbc:	e17fff17 	ldw	r5,-4(fp)
 183acc0:	e13ffe17 	ldw	r4,-8(fp)
 183acc4:	181da7c0 	call	181da7c <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 183acc8:	01406134 	movhi	r5,388
 183accc:	2969ec04 	addi	r5,r5,-22608
 183acd0:	e13ffe17 	ldw	r4,-8(fp)
 183acd4:	181dab00 	call	181dab0 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 183acd8:	01406134 	movhi	r5,388
 183acdc:	296a7b04 	addi	r5,r5,-22036
 183ace0:	e13ffe17 	ldw	r4,-8(fp)
 183ace4:	181dae40 	call	181dae4 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
 183ace8:	01800104 	movi	r6,4
 183acec:	01406134 	movhi	r5,388
 183acf0:	296a3c04 	addi	r5,r5,-22288
 183acf4:	e13ffe17 	ldw	r4,-8(fp)
 183acf8:	181db800 	call	181db80 <tcp_poll>
  tcp_err(pcb, err_tcp);
 183acfc:	01406134 	movhi	r5,388
 183ad00:	296aba04 	addi	r5,r5,-21784
 183ad04:	e13ffe17 	ldw	r4,-8(fp)
 183ad08:	181db180 	call	181db18 <tcp_err>
}
 183ad0c:	0001883a 	nop
 183ad10:	e037883a 	mov	sp,fp
 183ad14:	dfc00117 	ldw	ra,4(sp)
 183ad18:	df000017 	ldw	fp,0(sp)
 183ad1c:	dec00204 	addi	sp,sp,8
 183ad20:	f800283a 	ret

0183ad24 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 183ad24:	defff804 	addi	sp,sp,-32
 183ad28:	dfc00715 	stw	ra,28(sp)
 183ad2c:	df000615 	stw	fp,24(sp)
 183ad30:	df000604 	addi	fp,sp,24
 183ad34:	e13ffd15 	stw	r4,-12(fp)
 183ad38:	e17ffe15 	stw	r5,-8(fp)
 183ad3c:	3005883a 	mov	r2,r6
 183ad40:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
 183ad44:	e0bffd17 	ldw	r2,-12(fp)
 183ad48:	e0bffa15 	stw	r2,-24(fp)

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 183ad4c:	e0bffa17 	ldw	r2,-24(fp)
 183ad50:	10800617 	ldw	r2,24(r2)
 183ad54:	1000021e 	bne	r2,zero,183ad60 <accept_function+0x3c>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
 183ad58:	00bffe84 	movi	r2,-6
 183ad5c:	00004606 	br	183ae78 <accept_function+0x154>
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
 183ad60:	e0bffa17 	ldw	r2,-24(fp)
 183ad64:	10c00017 	ldw	r3,0(r2)
 183ad68:	e0bffa17 	ldw	r2,-24(fp)
 183ad6c:	10800c17 	ldw	r2,48(r2)
 183ad70:	100b883a 	mov	r5,r2
 183ad74:	1809883a 	mov	r4,r3
 183ad78:	183b0900 	call	183b090 <netconn_alloc>
 183ad7c:	e0bffb15 	stw	r2,-20(fp)
  if (newconn == NULL) {
 183ad80:	e0bffb17 	ldw	r2,-20(fp)
 183ad84:	1000021e 	bne	r2,zero,183ad90 <accept_function+0x6c>
    return ERR_MEM;
 183ad88:	00bfffc4 	movi	r2,-1
 183ad8c:	00003a06 	br	183ae78 <accept_function+0x154>
  }
  newconn->pcb.tcp = newpcb;
 183ad90:	e0bffb17 	ldw	r2,-20(fp)
 183ad94:	e0fffe17 	ldw	r3,-8(fp)
 183ad98:	10c00215 	stw	r3,8(r2)
  setup_tcp(newconn);
 183ad9c:	e13ffb17 	ldw	r4,-20(fp)
 183ada0:	183ac9c0 	call	183ac9c <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
 183ada4:	e0bffb17 	ldw	r2,-20(fp)
 183ada8:	e0ffff03 	ldbu	r3,-4(fp)
 183adac:	10c00305 	stb	r3,12(r2)

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 183adb0:	e0bffa17 	ldw	r2,-24(fp)
 183adb4:	10800604 	addi	r2,r2,24
 183adb8:	e17ffb17 	ldw	r5,-20(fp)
 183adbc:	1009883a 	mov	r4,r2
 183adc0:	18154d40 	call	18154d4 <sys_mbox_trypost>
 183adc4:	10803fcc 	andi	r2,r2,255
 183adc8:	1080201c 	xori	r2,r2,128
 183adcc:	10bfe004 	addi	r2,r2,-128
 183add0:	10001f26 	beq	r2,zero,183ae50 <accept_function+0x12c>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
 183add4:	e0bffb17 	ldw	r2,-20(fp)
 183add8:	10800217 	ldw	r2,8(r2)
 183addc:	e0bffc15 	stw	r2,-16(fp)
    tcp_arg(pcb, NULL);
 183ade0:	000b883a 	mov	r5,zero
 183ade4:	e13ffc17 	ldw	r4,-16(fp)
 183ade8:	181da7c0 	call	181da7c <tcp_arg>
    tcp_recv(pcb, NULL);
 183adec:	000b883a 	mov	r5,zero
 183adf0:	e13ffc17 	ldw	r4,-16(fp)
 183adf4:	181dab00 	call	181dab0 <tcp_recv>
    tcp_sent(pcb, NULL);
 183adf8:	000b883a 	mov	r5,zero
 183adfc:	e13ffc17 	ldw	r4,-16(fp)
 183ae00:	181dae40 	call	181dae4 <tcp_sent>
    tcp_poll(pcb, NULL, 4);
 183ae04:	01800104 	movi	r6,4
 183ae08:	000b883a 	mov	r5,zero
 183ae0c:	e13ffc17 	ldw	r4,-16(fp)
 183ae10:	181db800 	call	181db80 <tcp_poll>
    tcp_err(pcb, NULL);
 183ae14:	000b883a 	mov	r5,zero
 183ae18:	e13ffc17 	ldw	r4,-16(fp)
 183ae1c:	181db180 	call	181db18 <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
 183ae20:	e0bffb17 	ldw	r2,-20(fp)
 183ae24:	10000215 	stw	zero,8(r2)
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 183ae28:	e0bffb17 	ldw	r2,-20(fp)
 183ae2c:	10800504 	addi	r2,r2,20
 183ae30:	1009883a 	mov	r4,r2
 183ae34:	18154140 	call	1815414 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 183ae38:	e0bffb17 	ldw	r2,-20(fp)
 183ae3c:	10000515 	stw	zero,20(r2)
    netconn_free(newconn);
 183ae40:	e13ffb17 	ldw	r4,-20(fp)
 183ae44:	183b1bc0 	call	183b1bc <netconn_free>
    return ERR_MEM;
 183ae48:	00bfffc4 	movi	r2,-1
 183ae4c:	00000a06 	br	183ae78 <accept_function+0x154>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 183ae50:	e0bffa17 	ldw	r2,-24(fp)
 183ae54:	10800c17 	ldw	r2,48(r2)
 183ae58:	10000626 	beq	r2,zero,183ae74 <accept_function+0x150>
 183ae5c:	e0bffa17 	ldw	r2,-24(fp)
 183ae60:	10800c17 	ldw	r2,48(r2)
 183ae64:	000d883a 	mov	r6,zero
 183ae68:	000b883a 	mov	r5,zero
 183ae6c:	e13ffa17 	ldw	r4,-24(fp)
 183ae70:	103ee83a 	callr	r2
  }

  return ERR_OK;
 183ae74:	0005883a 	mov	r2,zero
}
 183ae78:	e037883a 	mov	sp,fp
 183ae7c:	dfc00117 	ldw	ra,4(sp)
 183ae80:	df000017 	ldw	fp,0(sp)
 183ae84:	dec00204 	addi	sp,sp,8
 183ae88:	f800283a 	ret

0183ae8c <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static void
pcb_new(struct api_msg_msg *msg)
{
 183ae8c:	defffc04 	addi	sp,sp,-16
 183ae90:	dfc00315 	stw	ra,12(sp)
 183ae94:	df000215 	stw	fp,8(sp)
 183ae98:	dc000115 	stw	r16,4(sp)
 183ae9c:	df000204 	addi	fp,sp,8
 183aea0:	e13ffe15 	stw	r4,-8(fp)
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 183aea4:	e0bffe17 	ldw	r2,-8(fp)
 183aea8:	10800017 	ldw	r2,0(r2)
 183aeac:	10800017 	ldw	r2,0(r2)
 183aeb0:	10803c0c 	andi	r2,r2,240
 183aeb4:	10c00820 	cmpeqi	r3,r2,32
 183aeb8:	1800201e 	bne	r3,zero,183af3c <pcb_new+0xb0>
 183aebc:	10c01020 	cmpeqi	r3,r2,64
 183aec0:	1800031e 	bne	r3,zero,183aed0 <pcb_new+0x44>
 183aec4:	10800420 	cmpeqi	r2,r2,16
 183aec8:	10003d1e 	bne	r2,zero,183afc0 <pcb_new+0x134>
 183aecc:	00004d06 	br	183b004 <pcb_new+0x178>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
 183aed0:	e0bffe17 	ldw	r2,-8(fp)
 183aed4:	14000017 	ldw	r16,0(r2)
 183aed8:	e0bffe17 	ldw	r2,-8(fp)
 183aedc:	10800203 	ldbu	r2,8(r2)
 183aee0:	10803fcc 	andi	r2,r2,255
 183aee4:	1009883a 	mov	r4,r2
 183aee8:	18350780 	call	1835078 <raw_new>
 183aeec:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.raw == NULL) {
 183aef0:	e0bffe17 	ldw	r2,-8(fp)
 183aef4:	10800017 	ldw	r2,0(r2)
 183aef8:	10800217 	ldw	r2,8(r2)
 183aefc:	1000041e 	bne	r2,zero,183af10 <pcb_new+0x84>
      msg->err = ERR_MEM;
 183af00:	e0bffe17 	ldw	r2,-8(fp)
 183af04:	00ffffc4 	movi	r3,-1
 183af08:	10c00105 	stb	r3,4(r2)
      break;
 183af0c:	00004106 	br	183b014 <pcb_new+0x188>
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
 183af10:	e0bffe17 	ldw	r2,-8(fp)
 183af14:	10800017 	ldw	r2,0(r2)
 183af18:	10c00217 	ldw	r3,8(r2)
 183af1c:	e0bffe17 	ldw	r2,-8(fp)
 183af20:	10800017 	ldw	r2,0(r2)
 183af24:	100d883a 	mov	r6,r2
 183af28:	01406134 	movhi	r5,388
 183af2c:	29694504 	addi	r5,r5,-23276
 183af30:	1809883a 	mov	r4,r3
 183af34:	1834dc80 	call	1834dc8 <raw_recv>
    break;
 183af38:	00003606 	br	183b014 <pcb_new+0x188>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
 183af3c:	e0bffe17 	ldw	r2,-8(fp)
 183af40:	14000017 	ldw	r16,0(r2)
 183af44:	1822c580 	call	1822c58 <udp_new>
 183af48:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.udp == NULL) {
 183af4c:	e0bffe17 	ldw	r2,-8(fp)
 183af50:	10800017 	ldw	r2,0(r2)
 183af54:	10800217 	ldw	r2,8(r2)
 183af58:	1000041e 	bne	r2,zero,183af6c <pcb_new+0xe0>
      msg->err = ERR_MEM;
 183af5c:	e0bffe17 	ldw	r2,-8(fp)
 183af60:	00ffffc4 	movi	r3,-1
 183af64:	10c00105 	stb	r3,4(r2)
      break;
 183af68:	00002a06 	br	183b014 <pcb_new+0x188>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
 183af6c:	e0bffe17 	ldw	r2,-8(fp)
 183af70:	10800017 	ldw	r2,0(r2)
 183af74:	10800017 	ldw	r2,0(r2)
 183af78:	10800898 	cmpnei	r2,r2,34
 183af7c:	1000051e 	bne	r2,zero,183af94 <pcb_new+0x108>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 183af80:	e0bffe17 	ldw	r2,-8(fp)
 183af84:	10800017 	ldw	r2,0(r2)
 183af88:	10800217 	ldw	r2,8(r2)
 183af8c:	00c00044 	movi	r3,1
 183af90:	10c00405 	stb	r3,16(r2)
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 183af94:	e0bffe17 	ldw	r2,-8(fp)
 183af98:	10800017 	ldw	r2,0(r2)
 183af9c:	10c00217 	ldw	r3,8(r2)
 183afa0:	e0bffe17 	ldw	r2,-8(fp)
 183afa4:	10800017 	ldw	r2,0(r2)
 183afa8:	100d883a 	mov	r6,r2
 183afac:	01406134 	movhi	r5,388
 183afb0:	2969a104 	addi	r5,r5,-22908
 183afb4:	1809883a 	mov	r4,r3
 183afb8:	1822b740 	call	1822b74 <udp_recv>
    break;
 183afbc:	00001506 	br	183b014 <pcb_new+0x188>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
 183afc0:	e0bffe17 	ldw	r2,-8(fp)
 183afc4:	14000017 	ldw	r16,0(r2)
 183afc8:	181da500 	call	181da50 <tcp_new>
 183afcc:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.tcp == NULL) {
 183afd0:	e0bffe17 	ldw	r2,-8(fp)
 183afd4:	10800017 	ldw	r2,0(r2)
 183afd8:	10800217 	ldw	r2,8(r2)
 183afdc:	1000041e 	bne	r2,zero,183aff0 <pcb_new+0x164>
      msg->err = ERR_MEM;
 183afe0:	e0bffe17 	ldw	r2,-8(fp)
 183afe4:	00ffffc4 	movi	r3,-1
 183afe8:	10c00105 	stb	r3,4(r2)
      break;
 183afec:	00000906 	br	183b014 <pcb_new+0x188>
    }
    setup_tcp(msg->conn);
 183aff0:	e0bffe17 	ldw	r2,-8(fp)
 183aff4:	10800017 	ldw	r2,0(r2)
 183aff8:	1009883a 	mov	r4,r2
 183affc:	183ac9c0 	call	183ac9c <setup_tcp>
    break;
 183b000:	00000406 	br	183b014 <pcb_new+0x188>
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
 183b004:	e0bffe17 	ldw	r2,-8(fp)
 183b008:	00fffe84 	movi	r3,-6
 183b00c:	10c00105 	stb	r3,4(r2)
    break;
 183b010:	0001883a 	nop
  }
}
 183b014:	0001883a 	nop
 183b018:	e6ffff04 	addi	sp,fp,-4
 183b01c:	dfc00217 	ldw	ra,8(sp)
 183b020:	df000117 	ldw	fp,4(sp)
 183b024:	dc000017 	ldw	r16,0(sp)
 183b028:	dec00304 	addi	sp,sp,12
 183b02c:	f800283a 	ret

0183b030 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
 183b030:	defffd04 	addi	sp,sp,-12
 183b034:	dfc00215 	stw	ra,8(sp)
 183b038:	df000115 	stw	fp,4(sp)
 183b03c:	df000104 	addi	fp,sp,4
 183b040:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
 183b044:	e0bfff17 	ldw	r2,-4(fp)
 183b048:	10000105 	stb	zero,4(r2)
  if(msg->conn->pcb.tcp == NULL) {
 183b04c:	e0bfff17 	ldw	r2,-4(fp)
 183b050:	10800017 	ldw	r2,0(r2)
 183b054:	10800217 	ldw	r2,8(r2)
 183b058:	1000021e 	bne	r2,zero,183b064 <do_newconn+0x34>
    pcb_new(msg);
 183b05c:	e13fff17 	ldw	r4,-4(fp)
 183b060:	183ae8c0 	call	183ae8c <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 183b064:	e0bfff17 	ldw	r2,-4(fp)
 183b068:	10800017 	ldw	r2,0(r2)
 183b06c:	10800404 	addi	r2,r2,16
 183b070:	1009883a 	mov	r4,r2
 183b074:	18150740 	call	1815074 <sys_sem_signal>
}
 183b078:	0001883a 	nop
 183b07c:	e037883a 	mov	sp,fp
 183b080:	dfc00117 	ldw	ra,4(sp)
 183b084:	df000017 	ldw	fp,0(sp)
 183b088:	dec00204 	addi	sp,sp,8
 183b08c:	f800283a 	ret

0183b090 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 183b090:	defffa04 	addi	sp,sp,-24
 183b094:	dfc00515 	stw	ra,20(sp)
 183b098:	df000415 	stw	fp,16(sp)
 183b09c:	df000404 	addi	fp,sp,16
 183b0a0:	e13ffe15 	stw	r4,-8(fp)
 183b0a4:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 183b0a8:	01000204 	movi	r4,8
 183b0ac:	18349580 	call	1834958 <memp_malloc>
 183b0b0:	e0bffc15 	stw	r2,-16(fp)
  if (conn == NULL) {
 183b0b4:	e0bffc17 	ldw	r2,-16(fp)
 183b0b8:	1000021e 	bne	r2,zero,183b0c4 <netconn_alloc+0x34>
    return NULL;
 183b0bc:	0005883a 	mov	r2,zero
 183b0c0:	00003906 	br	183b1a8 <netconn_alloc+0x118>
  }

  conn->last_err = ERR_OK;
 183b0c4:	e0bffc17 	ldw	r2,-16(fp)
 183b0c8:	10000305 	stb	zero,12(r2)
  conn->type = t;
 183b0cc:	e0bffc17 	ldw	r2,-16(fp)
 183b0d0:	e0fffe17 	ldw	r3,-8(fp)
 183b0d4:	10c00015 	stw	r3,0(r2)
  conn->pcb.tcp = NULL;
 183b0d8:	e0bffc17 	ldw	r2,-16(fp)
 183b0dc:	10000215 	stw	zero,8(r2)

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
 183b0e0:	00840004 	movi	r2,4096
 183b0e4:	e0bffd15 	stw	r2,-12(fp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 183b0e8:	e0bffc17 	ldw	r2,-16(fp)
 183b0ec:	10800404 	addi	r2,r2,16
 183b0f0:	000b883a 	mov	r5,zero
 183b0f4:	1009883a 	mov	r4,r2
 183b0f8:	1814f380 	call	1814f38 <sys_sem_new>
 183b0fc:	10803fcc 	andi	r2,r2,255
 183b100:	1080201c 	xori	r2,r2,128
 183b104:	10bfe004 	addi	r2,r2,-128
 183b108:	1000221e 	bne	r2,zero,183b194 <netconn_alloc+0x104>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 183b10c:	e0bffc17 	ldw	r2,-16(fp)
 183b110:	10800504 	addi	r2,r2,20
 183b114:	e17ffd17 	ldw	r5,-12(fp)
 183b118:	1009883a 	mov	r4,r2
 183b11c:	18153440 	call	1815344 <sys_mbox_new>
 183b120:	10803fcc 	andi	r2,r2,255
 183b124:	1080201c 	xori	r2,r2,128
 183b128:	10bfe004 	addi	r2,r2,-128
 183b12c:	10000526 	beq	r2,zero,183b144 <netconn_alloc+0xb4>
    sys_sem_free(&conn->op_completed);
 183b130:	e0bffc17 	ldw	r2,-16(fp)
 183b134:	10800404 	addi	r2,r2,16
 183b138:	1009883a 	mov	r4,r2
 183b13c:	181501c0 	call	181501c <sys_sem_free>
    goto free_and_return;
 183b140:	00001506 	br	183b198 <netconn_alloc+0x108>
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
 183b144:	e0bffc17 	ldw	r2,-16(fp)
 183b148:	10000615 	stw	zero,24(r2)
#endif
  conn->state        = NETCONN_NONE;
 183b14c:	e0bffc17 	ldw	r2,-16(fp)
 183b150:	10000115 	stw	zero,4(r2)
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 183b154:	e0bffc17 	ldw	r2,-16(fp)
 183b158:	00ffffc4 	movi	r3,-1
 183b15c:	10c00715 	stw	r3,28(r2)
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
 183b160:	e0bffc17 	ldw	r2,-16(fp)
 183b164:	e0ffff17 	ldw	r3,-4(fp)
 183b168:	10c00c15 	stw	r3,48(r2)
#if LWIP_TCP
  conn->current_msg  = NULL;
 183b16c:	e0bffc17 	ldw	r2,-16(fp)
 183b170:	10000b15 	stw	zero,44(r2)
  conn->write_offset = 0;
 183b174:	e0bffc17 	ldw	r2,-16(fp)
 183b178:	10000a15 	stw	zero,40(r2)
#endif /* LWIP_TCP */
#if LWIP_SO_SNDTIMEO
  conn->send_timeout = 0;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
 183b17c:	e0bffc17 	ldw	r2,-16(fp)
 183b180:	10000815 	stw	zero,32(r2)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
 183b184:	e0bffc17 	ldw	r2,-16(fp)
 183b188:	10000905 	stb	zero,36(r2)
  return conn;
 183b18c:	e0bffc17 	ldw	r2,-16(fp)
 183b190:	00000506 	br	183b1a8 <netconn_alloc+0x118>
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
 183b194:	0001883a 	nop
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
 183b198:	e17ffc17 	ldw	r5,-16(fp)
 183b19c:	01000204 	movi	r4,8
 183b1a0:	1834b240 	call	1834b24 <memp_free>
  return NULL;
 183b1a4:	0005883a 	mov	r2,zero
}
 183b1a8:	e037883a 	mov	sp,fp
 183b1ac:	dfc00117 	ldw	ra,4(sp)
 183b1b0:	df000017 	ldw	fp,0(sp)
 183b1b4:	dec00204 	addi	sp,sp,8
 183b1b8:	f800283a 	ret

0183b1bc <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 183b1bc:	defffd04 	addi	sp,sp,-12
 183b1c0:	dfc00215 	stw	ra,8(sp)
 183b1c4:	df000115 	stw	fp,4(sp)
 183b1c8:	df000104 	addi	fp,sp,4
 183b1cc:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
 183b1d0:	e0bfff17 	ldw	r2,-4(fp)
 183b1d4:	10800404 	addi	r2,r2,16
 183b1d8:	1009883a 	mov	r4,r2
 183b1dc:	181501c0 	call	181501c <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 183b1e0:	e0bfff17 	ldw	r2,-4(fp)
 183b1e4:	10000415 	stw	zero,16(r2)

  memp_free(MEMP_NETCONN, conn);
 183b1e8:	e17fff17 	ldw	r5,-4(fp)
 183b1ec:	01000204 	movi	r4,8
 183b1f0:	1834b240 	call	1834b24 <memp_free>
}
 183b1f4:	0001883a 	nop
 183b1f8:	e037883a 	mov	sp,fp
 183b1fc:	dfc00117 	ldw	ra,4(sp)
 183b200:	df000017 	ldw	fp,0(sp)
 183b204:	dec00204 	addi	sp,sp,8
 183b208:	f800283a 	ret

0183b20c <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 183b20c:	defffa04 	addi	sp,sp,-24
 183b210:	dfc00515 	stw	ra,20(sp)
 183b214:	df000415 	stw	fp,16(sp)
 183b218:	df000404 	addi	fp,sp,16
 183b21c:	e13fff15 	stw	r4,-4(fp)
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 183b220:	e0bfff17 	ldw	r2,-4(fp)
 183b224:	10800517 	ldw	r2,20(r2)
 183b228:	10002826 	beq	r2,zero,183b2cc <netconn_drain+0xc0>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 183b22c:	00001906 	br	183b294 <netconn_drain+0x88>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
 183b230:	e0bfff17 	ldw	r2,-4(fp)
 183b234:	10800017 	ldw	r2,0(r2)
 183b238:	10800418 	cmpnei	r2,r2,16
 183b23c:	1000121e 	bne	r2,zero,183b288 <netconn_drain+0x7c>
        if(mem != NULL) {
 183b240:	e0bffe17 	ldw	r2,-8(fp)
 183b244:	10001326 	beq	r2,zero,183b294 <netconn_drain+0x88>
          p = (struct pbuf*)mem;
 183b248:	e0bffe17 	ldw	r2,-8(fp)
 183b24c:	e0bffc15 	stw	r2,-16(fp)
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
 183b250:	e0bfff17 	ldw	r2,-4(fp)
 183b254:	10800217 	ldw	r2,8(r2)
 183b258:	10000826 	beq	r2,zero,183b27c <netconn_drain+0x70>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 183b25c:	e0bfff17 	ldw	r2,-4(fp)
 183b260:	10c00217 	ldw	r3,8(r2)
 183b264:	e0bffc17 	ldw	r2,-16(fp)
 183b268:	1080020b 	ldhu	r2,8(r2)
 183b26c:	10bfffcc 	andi	r2,r2,65535
 183b270:	100b883a 	mov	r5,r2
 183b274:	1809883a 	mov	r4,r3
 183b278:	181c6800 	call	181c680 <tcp_recved>
          }
          pbuf_free(p);
 183b27c:	e13ffc17 	ldw	r4,-16(fp)
 183b280:	181aca40 	call	181aca4 <pbuf_free>
 183b284:	00000306 	br	183b294 <netconn_drain+0x88>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
 183b288:	e0bffe17 	ldw	r2,-8(fp)
 183b28c:	1009883a 	mov	r4,r2
 183b290:	183ca5c0 	call	183ca5c <netbuf_delete>

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 183b294:	e0bfff17 	ldw	r2,-4(fp)
 183b298:	10800504 	addi	r2,r2,20
 183b29c:	e0fffe04 	addi	r3,fp,-8
 183b2a0:	180b883a 	mov	r5,r3
 183b2a4:	1009883a 	mov	r4,r2
 183b2a8:	18156340 	call	1815634 <sys_arch_mbox_tryfetch>
 183b2ac:	10bfffd8 	cmpnei	r2,r2,-1
 183b2b0:	103fdf1e 	bne	r2,zero,183b230 <__ram_exceptions_end+0xff82adec>
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(&conn->recvmbox);
 183b2b4:	e0bfff17 	ldw	r2,-4(fp)
 183b2b8:	10800504 	addi	r2,r2,20
 183b2bc:	1009883a 	mov	r4,r2
 183b2c0:	18154140 	call	1815414 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 183b2c4:	e0bfff17 	ldw	r2,-4(fp)
 183b2c8:	10000515 	stw	zero,20(r2)
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
 183b2cc:	e0bfff17 	ldw	r2,-4(fp)
 183b2d0:	10800617 	ldw	r2,24(r2)
 183b2d4:	10002626 	beq	r2,zero,183b370 <netconn_drain+0x164>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 183b2d8:	00001706 	br	183b338 <netconn_drain+0x12c>
      struct netconn *newconn = (struct netconn *)mem;
 183b2dc:	e0bffe17 	ldw	r2,-8(fp)
 183b2e0:	e0bffd15 	stw	r2,-12(fp)
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 183b2e4:	e0bfff17 	ldw	r2,-4(fp)
 183b2e8:	10800217 	ldw	r2,8(r2)
 183b2ec:	10000526 	beq	r2,zero,183b304 <netconn_drain+0xf8>
        tcp_accepted(conn->pcb.tcp);
 183b2f0:	e0bfff17 	ldw	r2,-4(fp)
 183b2f4:	10800217 	ldw	r2,8(r2)
 183b2f8:	10c00843 	ldbu	r3,33(r2)
 183b2fc:	18ffffc4 	addi	r3,r3,-1
 183b300:	10c00845 	stb	r3,33(r2)
      }
      /* drain recvmbox */
      netconn_drain(newconn);
 183b304:	e13ffd17 	ldw	r4,-12(fp)
 183b308:	183b20c0 	call	183b20c <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
 183b30c:	e0bffd17 	ldw	r2,-12(fp)
 183b310:	10800217 	ldw	r2,8(r2)
 183b314:	10000626 	beq	r2,zero,183b330 <netconn_drain+0x124>
        tcp_abort(newconn->pcb.tcp);
 183b318:	e0bffd17 	ldw	r2,-12(fp)
 183b31c:	10800217 	ldw	r2,8(r2)
 183b320:	1009883a 	mov	r4,r2
 183b324:	181c0f00 	call	181c0f0 <tcp_abort>
        newconn->pcb.tcp = NULL;
 183b328:	e0bffd17 	ldw	r2,-12(fp)
 183b32c:	10000215 	stw	zero,8(r2)
      }
      netconn_free(newconn);
 183b330:	e13ffd17 	ldw	r4,-12(fp)
 183b334:	183b1bc0 	call	183b1bc <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 183b338:	e0bfff17 	ldw	r2,-4(fp)
 183b33c:	10800604 	addi	r2,r2,24
 183b340:	e0fffe04 	addi	r3,fp,-8
 183b344:	180b883a 	mov	r5,r3
 183b348:	1009883a 	mov	r4,r2
 183b34c:	18156340 	call	1815634 <sys_arch_mbox_tryfetch>
 183b350:	10bfffd8 	cmpnei	r2,r2,-1
 183b354:	103fe11e 	bne	r2,zero,183b2dc <__ram_exceptions_end+0xff82ae98>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
 183b358:	e0bfff17 	ldw	r2,-4(fp)
 183b35c:	10800604 	addi	r2,r2,24
 183b360:	1009883a 	mov	r4,r2
 183b364:	18154140 	call	1815414 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 183b368:	e0bfff17 	ldw	r2,-4(fp)
 183b36c:	10000615 	stw	zero,24(r2)
  }
#endif /* LWIP_TCP */
}
 183b370:	0001883a 	nop
 183b374:	e037883a 	mov	sp,fp
 183b378:	dfc00117 	ldw	ra,4(sp)
 183b37c:	df000017 	ldw	fp,0(sp)
 183b380:	dec00204 	addi	sp,sp,8
 183b384:	f800283a 	ret

0183b388 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
 183b388:	defffb04 	addi	sp,sp,-20
 183b38c:	dfc00415 	stw	ra,16(sp)
 183b390:	df000315 	stw	fp,12(sp)
 183b394:	df000304 	addi	fp,sp,12
 183b398:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
 183b39c:	e0bfff17 	ldw	r2,-4(fp)
 183b3a0:	10800b17 	ldw	r2,44(r2)
 183b3a4:	10800203 	ldbu	r2,8(r2)
 183b3a8:	e0bffd45 	stb	r2,-11(fp)
  shut_rx = shut & NETCONN_SHUT_RD;
 183b3ac:	e0bffd43 	ldbu	r2,-11(fp)
 183b3b0:	1080004c 	andi	r2,r2,1
 183b3b4:	e0bffd85 	stb	r2,-10(fp)
  shut_tx = shut & NETCONN_SHUT_WR;
 183b3b8:	e0bffd43 	ldbu	r2,-11(fp)
 183b3bc:	1080008c 	andi	r2,r2,2
 183b3c0:	e0bffdc5 	stb	r2,-9(fp)
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;
 183b3c4:	e0bffd43 	ldbu	r2,-11(fp)
 183b3c8:	108000e0 	cmpeqi	r2,r2,3
 183b3cc:	e0bffe05 	stb	r2,-8(fp)

  /* Set back some callback pointers */
  if (close) {
 183b3d0:	e0bffe03 	ldbu	r2,-8(fp)
 183b3d4:	10000526 	beq	r2,zero,183b3ec <do_close_internal+0x64>
    tcp_arg(conn->pcb.tcp, NULL);
 183b3d8:	e0bfff17 	ldw	r2,-4(fp)
 183b3dc:	10800217 	ldw	r2,8(r2)
 183b3e0:	000b883a 	mov	r5,zero
 183b3e4:	1009883a 	mov	r4,r2
 183b3e8:	181da7c0 	call	181da7c <tcp_arg>
  }
  if (conn->pcb.tcp->state == LISTEN) {
 183b3ec:	e0bfff17 	ldw	r2,-4(fp)
 183b3f0:	10800217 	ldw	r2,8(r2)
 183b3f4:	10800617 	ldw	r2,24(r2)
 183b3f8:	10800058 	cmpnei	r2,r2,1
 183b3fc:	1000061e 	bne	r2,zero,183b418 <do_close_internal+0x90>
    tcp_accept(conn->pcb.tcp, NULL);
 183b400:	e0bfff17 	ldw	r2,-4(fp)
 183b404:	10800217 	ldw	r2,8(r2)
 183b408:	000b883a 	mov	r5,zero
 183b40c:	1009883a 	mov	r4,r2
 183b410:	181db4c0 	call	181db4c <tcp_accept>
 183b414:	00002006 	br	183b498 <do_close_internal+0x110>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
 183b418:	e0bffd83 	ldbu	r2,-10(fp)
 183b41c:	10000a26 	beq	r2,zero,183b448 <do_close_internal+0xc0>
      tcp_recv(conn->pcb.tcp, NULL);
 183b420:	e0bfff17 	ldw	r2,-4(fp)
 183b424:	10800217 	ldw	r2,8(r2)
 183b428:	000b883a 	mov	r5,zero
 183b42c:	1009883a 	mov	r4,r2
 183b430:	181dab00 	call	181dab0 <tcp_recv>
      tcp_accept(conn->pcb.tcp, NULL);
 183b434:	e0bfff17 	ldw	r2,-4(fp)
 183b438:	10800217 	ldw	r2,8(r2)
 183b43c:	000b883a 	mov	r5,zero
 183b440:	1009883a 	mov	r4,r2
 183b444:	181db4c0 	call	181db4c <tcp_accept>
    }
    if (shut_tx) {
 183b448:	e0bffdc3 	ldbu	r2,-9(fp)
 183b44c:	10000526 	beq	r2,zero,183b464 <do_close_internal+0xdc>
      tcp_sent(conn->pcb.tcp, NULL);
 183b450:	e0bfff17 	ldw	r2,-4(fp)
 183b454:	10800217 	ldw	r2,8(r2)
 183b458:	000b883a 	mov	r5,zero
 183b45c:	1009883a 	mov	r4,r2
 183b460:	181dae40 	call	181dae4 <tcp_sent>
    }
    if (close) {
 183b464:	e0bffe03 	ldbu	r2,-8(fp)
 183b468:	10000b26 	beq	r2,zero,183b498 <do_close_internal+0x110>
      tcp_poll(conn->pcb.tcp, NULL, 4);
 183b46c:	e0bfff17 	ldw	r2,-4(fp)
 183b470:	10800217 	ldw	r2,8(r2)
 183b474:	01800104 	movi	r6,4
 183b478:	000b883a 	mov	r5,zero
 183b47c:	1009883a 	mov	r4,r2
 183b480:	181db800 	call	181db80 <tcp_poll>
      tcp_err(conn->pcb.tcp, NULL);
 183b484:	e0bfff17 	ldw	r2,-4(fp)
 183b488:	10800217 	ldw	r2,8(r2)
 183b48c:	000b883a 	mov	r5,zero
 183b490:	1009883a 	mov	r4,r2
 183b494:	181db180 	call	181db18 <tcp_err>
    }
  }
  /* Try to close the connection */
  if (close) {
 183b498:	e0bffe03 	ldbu	r2,-8(fp)
 183b49c:	10000626 	beq	r2,zero,183b4b8 <do_close_internal+0x130>
    err = tcp_close(conn->pcb.tcp);
 183b4a0:	e0bfff17 	ldw	r2,-4(fp)
 183b4a4:	10800217 	ldw	r2,8(r2)
 183b4a8:	1009883a 	mov	r4,r2
 183b4ac:	181be440 	call	181be44 <tcp_close>
 183b4b0:	e0bffd05 	stb	r2,-12(fp)
 183b4b4:	00000906 	br	183b4dc <do_close_internal+0x154>
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
 183b4b8:	e0bfff17 	ldw	r2,-4(fp)
 183b4bc:	10800217 	ldw	r2,8(r2)
 183b4c0:	e0fffd83 	ldbu	r3,-10(fp)
 183b4c4:	e13ffdc3 	ldbu	r4,-9(fp)
 183b4c8:	200d883a 	mov	r6,r4
 183b4cc:	180b883a 	mov	r5,r3
 183b4d0:	1009883a 	mov	r4,r2
 183b4d4:	181bea00 	call	181bea0 <tcp_shutdown>
 183b4d8:	e0bffd05 	stb	r2,-12(fp)
  }
  if (err == ERR_OK) {
 183b4dc:	e0bffd07 	ldb	r2,-12(fp)
 183b4e0:	10002f1e 	bne	r2,zero,183b5a0 <do_close_internal+0x218>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 183b4e4:	e0bfff17 	ldw	r2,-4(fp)
 183b4e8:	10800b17 	ldw	r2,44(r2)
 183b4ec:	10000105 	stb	zero,4(r2)
    conn->current_msg = NULL;
 183b4f0:	e0bfff17 	ldw	r2,-4(fp)
 183b4f4:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
 183b4f8:	e0bfff17 	ldw	r2,-4(fp)
 183b4fc:	10000115 	stw	zero,4(r2)
    if (close) {
 183b500:	e0bffe03 	ldbu	r2,-8(fp)
 183b504:	10000b26 	beq	r2,zero,183b534 <do_close_internal+0x1ac>
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
 183b508:	e0bfff17 	ldw	r2,-4(fp)
 183b50c:	10000215 	stw	zero,8(r2)
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 183b510:	e0bfff17 	ldw	r2,-4(fp)
 183b514:	10800c17 	ldw	r2,48(r2)
 183b518:	10000626 	beq	r2,zero,183b534 <do_close_internal+0x1ac>
 183b51c:	e0bfff17 	ldw	r2,-4(fp)
 183b520:	10800c17 	ldw	r2,48(r2)
 183b524:	000d883a 	mov	r6,zero
 183b528:	01400104 	movi	r5,4
 183b52c:	e13fff17 	ldw	r4,-4(fp)
 183b530:	103ee83a 	callr	r2
    }
    if (shut_rx) {
 183b534:	e0bffd83 	ldbu	r2,-10(fp)
 183b538:	10000926 	beq	r2,zero,183b560 <do_close_internal+0x1d8>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 183b53c:	e0bfff17 	ldw	r2,-4(fp)
 183b540:	10800c17 	ldw	r2,48(r2)
 183b544:	10000626 	beq	r2,zero,183b560 <do_close_internal+0x1d8>
 183b548:	e0bfff17 	ldw	r2,-4(fp)
 183b54c:	10800c17 	ldw	r2,48(r2)
 183b550:	000d883a 	mov	r6,zero
 183b554:	000b883a 	mov	r5,zero
 183b558:	e13fff17 	ldw	r4,-4(fp)
 183b55c:	103ee83a 	callr	r2
    }
    if (shut_tx) {
 183b560:	e0bffdc3 	ldbu	r2,-9(fp)
 183b564:	10000926 	beq	r2,zero,183b58c <do_close_internal+0x204>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 183b568:	e0bfff17 	ldw	r2,-4(fp)
 183b56c:	10800c17 	ldw	r2,48(r2)
 183b570:	10000626 	beq	r2,zero,183b58c <do_close_internal+0x204>
 183b574:	e0bfff17 	ldw	r2,-4(fp)
 183b578:	10800c17 	ldw	r2,48(r2)
 183b57c:	000d883a 	mov	r6,zero
 183b580:	01400084 	movi	r5,2
 183b584:	e13fff17 	ldw	r4,-4(fp)
 183b588:	103ee83a 	callr	r2
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 183b58c:	e0bfff17 	ldw	r2,-4(fp)
 183b590:	10800404 	addi	r2,r2,16
 183b594:	1009883a 	mov	r4,r2
 183b598:	18150740 	call	1815074 <sys_sem_signal>
    tcp_arg(conn->pcb.tcp, conn);
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 183b59c:	00001806 	br	183b600 <do_close_internal+0x278>
    sys_sem_signal(&conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
 183b5a0:	e0bfff17 	ldw	r2,-4(fp)
 183b5a4:	10800217 	ldw	r2,8(r2)
 183b5a8:	01406134 	movhi	r5,388
 183b5ac:	296a7b04 	addi	r5,r5,-22036
 183b5b0:	1009883a 	mov	r4,r2
 183b5b4:	181dae40 	call	181dae4 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
 183b5b8:	e0bfff17 	ldw	r2,-4(fp)
 183b5bc:	10800217 	ldw	r2,8(r2)
 183b5c0:	01800104 	movi	r6,4
 183b5c4:	01406134 	movhi	r5,388
 183b5c8:	296a3c04 	addi	r5,r5,-22288
 183b5cc:	1009883a 	mov	r4,r2
 183b5d0:	181db800 	call	181db80 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
 183b5d4:	e0bfff17 	ldw	r2,-4(fp)
 183b5d8:	10800217 	ldw	r2,8(r2)
 183b5dc:	01406134 	movhi	r5,388
 183b5e0:	296aba04 	addi	r5,r5,-21784
 183b5e4:	1009883a 	mov	r4,r2
 183b5e8:	181db180 	call	181db18 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
 183b5ec:	e0bfff17 	ldw	r2,-4(fp)
 183b5f0:	10800217 	ldw	r2,8(r2)
 183b5f4:	e17fff17 	ldw	r5,-4(fp)
 183b5f8:	1009883a 	mov	r4,r2
 183b5fc:	181da7c0 	call	181da7c <tcp_arg>
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 183b600:	0001883a 	nop
 183b604:	e037883a 	mov	sp,fp
 183b608:	dfc00117 	ldw	ra,4(sp)
 183b60c:	df000017 	ldw	fp,0(sp)
 183b610:	dec00204 	addi	sp,sp,8
 183b614:	f800283a 	ret

0183b618 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 183b618:	defffd04 	addi	sp,sp,-12
 183b61c:	dfc00215 	stw	ra,8(sp)
 183b620:	df000115 	stw	fp,4(sp)
 183b624:	df000104 	addi	fp,sp,4
 183b628:	e13fff15 	stw	r4,-4(fp)
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 183b62c:	e0bfff17 	ldw	r2,-4(fp)
 183b630:	10800017 	ldw	r2,0(r2)
 183b634:	10800117 	ldw	r2,4(r2)
 183b638:	10000e26 	beq	r2,zero,183b674 <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
 183b63c:	e0bfff17 	ldw	r2,-4(fp)
 183b640:	10800017 	ldw	r2,0(r2)
 183b644:	10800117 	ldw	r2,4(r2)
 */
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 183b648:	108000a0 	cmpeqi	r2,r2,2
 183b64c:	1000091e 	bne	r2,zero,183b674 <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
     (msg->conn->state != NETCONN_CONNECT)) {
 183b650:	e0bfff17 	ldw	r2,-4(fp)
 183b654:	10800017 	ldw	r2,0(r2)
 183b658:	10800117 	ldw	r2,4(r2)
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     (msg->conn->state != NETCONN_LISTEN) &&
 183b65c:	108000e0 	cmpeqi	r2,r2,3
 183b660:	1000041e 	bne	r2,zero,183b674 <do_delconn+0x5c>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
 183b664:	e0bfff17 	ldw	r2,-4(fp)
 183b668:	00fffec4 	movi	r3,-5
 183b66c:	10c00105 	stb	r3,4(r2)
 183b670:	00005006 	br	183b7b4 <do_delconn+0x19c>
  } else {
    LWIP_ASSERT("blocking connect in progress",
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
 183b674:	e0bfff17 	ldw	r2,-4(fp)
 183b678:	10800017 	ldw	r2,0(r2)
 183b67c:	1009883a 	mov	r4,r2
 183b680:	183b20c0 	call	183b20c <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
 183b684:	e0bfff17 	ldw	r2,-4(fp)
 183b688:	10800017 	ldw	r2,0(r2)
 183b68c:	10800217 	ldw	r2,8(r2)
 183b690:	10002e26 	beq	r2,zero,183b74c <do_delconn+0x134>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 183b694:	e0bfff17 	ldw	r2,-4(fp)
 183b698:	10800017 	ldw	r2,0(r2)
 183b69c:	10800017 	ldw	r2,0(r2)
 183b6a0:	10803c0c 	andi	r2,r2,240
 183b6a4:	10c00820 	cmpeqi	r3,r2,32
 183b6a8:	18000b1e 	bne	r3,zero,183b6d8 <do_delconn+0xc0>
 183b6ac:	10c01020 	cmpeqi	r3,r2,64
 183b6b0:	1800031e 	bne	r3,zero,183b6c0 <do_delconn+0xa8>
 183b6b4:	10800420 	cmpeqi	r2,r2,16
 183b6b8:	1000111e 	bne	r2,zero,183b700 <do_delconn+0xe8>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
#endif /* LWIP_TCP */
      default:
        break;
 183b6bc:	00002006 	br	183b740 <do_delconn+0x128>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
 183b6c0:	e0bfff17 	ldw	r2,-4(fp)
 183b6c4:	10800017 	ldw	r2,0(r2)
 183b6c8:	10800217 	ldw	r2,8(r2)
 183b6cc:	1009883a 	mov	r4,r2
 183b6d0:	1834fd80 	call	1834fd8 <raw_remove>
        break;
 183b6d4:	00001a06 	br	183b740 <do_delconn+0x128>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
 183b6d8:	e0bfff17 	ldw	r2,-4(fp)
 183b6dc:	10800017 	ldw	r2,0(r2)
 183b6e0:	10800217 	ldw	r2,8(r2)
 183b6e4:	10000715 	stw	zero,28(r2)
        udp_remove(msg->conn->pcb.udp);
 183b6e8:	e0bfff17 	ldw	r2,-4(fp)
 183b6ec:	10800017 	ldw	r2,0(r2)
 183b6f0:	10800217 	ldw	r2,8(r2)
 183b6f4:	1009883a 	mov	r4,r2
 183b6f8:	1822bb80 	call	1822bb8 <udp_remove>
        break;
 183b6fc:	00001006 	br	183b740 <do_delconn+0x128>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 183b700:	e0bfff17 	ldw	r2,-4(fp)
 183b704:	10800017 	ldw	r2,0(r2)
 183b708:	00c00104 	movi	r3,4
 183b70c:	10c00115 	stw	r3,4(r2)
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 183b710:	e0bfff17 	ldw	r2,-4(fp)
 183b714:	00c000c4 	movi	r3,3
 183b718:	10c00205 	stb	r3,8(r2)
        msg->conn->current_msg = msg;
 183b71c:	e0bfff17 	ldw	r2,-4(fp)
 183b720:	10800017 	ldw	r2,0(r2)
 183b724:	e0ffff17 	ldw	r3,-4(fp)
 183b728:	10c00b15 	stw	r3,44(r2)
        do_close_internal(msg->conn);
 183b72c:	e0bfff17 	ldw	r2,-4(fp)
 183b730:	10800017 	ldw	r2,0(r2)
 183b734:	1009883a 	mov	r4,r2
 183b738:	183b3880 	call	183b388 <do_close_internal>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
 183b73c:	00002606 	br	183b7d8 <do_delconn+0x1c0>
#endif /* LWIP_TCP */
      default:
        break;
      }
      msg->conn->pcb.tcp = NULL;
 183b740:	e0bfff17 	ldw	r2,-4(fp)
 183b744:	10800017 	ldw	r2,0(r2)
 183b748:	10000215 	stw	zero,8(r2)
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 183b74c:	e0bfff17 	ldw	r2,-4(fp)
 183b750:	10800017 	ldw	r2,0(r2)
 183b754:	10800c17 	ldw	r2,48(r2)
 183b758:	10000926 	beq	r2,zero,183b780 <do_delconn+0x168>
 183b75c:	e0bfff17 	ldw	r2,-4(fp)
 183b760:	10800017 	ldw	r2,0(r2)
 183b764:	10800c17 	ldw	r2,48(r2)
 183b768:	e0ffff17 	ldw	r3,-4(fp)
 183b76c:	18c00017 	ldw	r3,0(r3)
 183b770:	000d883a 	mov	r6,zero
 183b774:	000b883a 	mov	r5,zero
 183b778:	1809883a 	mov	r4,r3
 183b77c:	103ee83a 	callr	r2
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 183b780:	e0bfff17 	ldw	r2,-4(fp)
 183b784:	10800017 	ldw	r2,0(r2)
 183b788:	10800c17 	ldw	r2,48(r2)
 183b78c:	10000926 	beq	r2,zero,183b7b4 <do_delconn+0x19c>
 183b790:	e0bfff17 	ldw	r2,-4(fp)
 183b794:	10800017 	ldw	r2,0(r2)
 183b798:	10800c17 	ldw	r2,48(r2)
 183b79c:	e0ffff17 	ldw	r3,-4(fp)
 183b7a0:	18c00017 	ldw	r3,0(r3)
 183b7a4:	000d883a 	mov	r6,zero
 183b7a8:	01400084 	movi	r5,2
 183b7ac:	1809883a 	mov	r4,r3
 183b7b0:	103ee83a 	callr	r2
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 183b7b4:	e0bfff17 	ldw	r2,-4(fp)
 183b7b8:	10800017 	ldw	r2,0(r2)
 183b7bc:	10800417 	ldw	r2,16(r2)
 183b7c0:	10000526 	beq	r2,zero,183b7d8 <do_delconn+0x1c0>
    sys_sem_signal(&msg->conn->op_completed);
 183b7c4:	e0bfff17 	ldw	r2,-4(fp)
 183b7c8:	10800017 	ldw	r2,0(r2)
 183b7cc:	10800404 	addi	r2,r2,16
 183b7d0:	1009883a 	mov	r4,r2
 183b7d4:	18150740 	call	1815074 <sys_sem_signal>
  }
}
 183b7d8:	e037883a 	mov	sp,fp
 183b7dc:	dfc00117 	ldw	ra,4(sp)
 183b7e0:	df000017 	ldw	fp,0(sp)
 183b7e4:	dec00204 	addi	sp,sp,8
 183b7e8:	f800283a 	ret

0183b7ec <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
 183b7ec:	defffd04 	addi	sp,sp,-12
 183b7f0:	dfc00215 	stw	ra,8(sp)
 183b7f4:	df000115 	stw	fp,4(sp)
 183b7f8:	df000104 	addi	fp,sp,4
 183b7fc:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 183b800:	e0bfff17 	ldw	r2,-4(fp)
 183b804:	10800017 	ldw	r2,0(r2)
 183b808:	10800303 	ldbu	r2,12(r2)
 183b80c:	10803fcc 	andi	r2,r2,255
 183b810:	1080201c 	xori	r2,r2,128
 183b814:	10bfe004 	addi	r2,r2,-128
 183b818:	10bffdc8 	cmpgei	r2,r2,-9
 183b81c:	1000061e 	bne	r2,zero,183b838 <do_bind+0x4c>
    msg->err = msg->conn->last_err;
 183b820:	e0bfff17 	ldw	r2,-4(fp)
 183b824:	10800017 	ldw	r2,0(r2)
 183b828:	10c00303 	ldbu	r3,12(r2)
 183b82c:	e0bfff17 	ldw	r2,-4(fp)
 183b830:	10c00105 	stb	r3,4(r2)
 183b834:	00003e06 	br	183b930 <do_bind+0x144>
  } else {
    msg->err = ERR_VAL;
 183b838:	e0bfff17 	ldw	r2,-4(fp)
 183b83c:	00fffe84 	movi	r3,-6
 183b840:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 183b844:	e0bfff17 	ldw	r2,-4(fp)
 183b848:	10800017 	ldw	r2,0(r2)
 183b84c:	10800217 	ldw	r2,8(r2)
 183b850:	10003726 	beq	r2,zero,183b930 <do_bind+0x144>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 183b854:	e0bfff17 	ldw	r2,-4(fp)
 183b858:	10800017 	ldw	r2,0(r2)
 183b85c:	10800017 	ldw	r2,0(r2)
 183b860:	10803c0c 	andi	r2,r2,240
 183b864:	10c00820 	cmpeqi	r3,r2,32
 183b868:	1800111e 	bne	r3,zero,183b8b0 <do_bind+0xc4>
 183b86c:	10c01020 	cmpeqi	r3,r2,64
 183b870:	1800031e 	bne	r3,zero,183b880 <do_bind+0x94>
 183b874:	10800420 	cmpeqi	r2,r2,16
 183b878:	10001d1e 	bne	r2,zero,183b8f0 <do_bind+0x104>
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
 183b87c:	00002c06 	br	183b930 <do_bind+0x144>
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 183b880:	e0bfff17 	ldw	r2,-4(fp)
 183b884:	10800017 	ldw	r2,0(r2)
 183b888:	10c00217 	ldw	r3,8(r2)
 183b88c:	e0bfff17 	ldw	r2,-4(fp)
 183b890:	10800217 	ldw	r2,8(r2)
 183b894:	100b883a 	mov	r5,r2
 183b898:	1809883a 	mov	r4,r3
 183b89c:	1834d380 	call	1834d38 <raw_bind>
 183b8a0:	1007883a 	mov	r3,r2
 183b8a4:	e0bfff17 	ldw	r2,-4(fp)
 183b8a8:	10c00105 	stb	r3,4(r2)
        break;
 183b8ac:	00002006 	br	183b930 <do_bind+0x144>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 183b8b0:	e0bfff17 	ldw	r2,-4(fp)
 183b8b4:	10800017 	ldw	r2,0(r2)
 183b8b8:	10c00217 	ldw	r3,8(r2)
 183b8bc:	e0bfff17 	ldw	r2,-4(fp)
 183b8c0:	11000217 	ldw	r4,8(r2)
 183b8c4:	e0bfff17 	ldw	r2,-4(fp)
 183b8c8:	1080030b 	ldhu	r2,12(r2)
 183b8cc:	10bfffcc 	andi	r2,r2,65535
 183b8d0:	100d883a 	mov	r6,r2
 183b8d4:	200b883a 	mov	r5,r4
 183b8d8:	1809883a 	mov	r4,r3
 183b8dc:	18228c00 	call	18228c0 <udp_bind>
 183b8e0:	1007883a 	mov	r3,r2
 183b8e4:	e0bfff17 	ldw	r2,-4(fp)
 183b8e8:	10c00105 	stb	r3,4(r2)
        break;
 183b8ec:	00001006 	br	183b930 <do_bind+0x144>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 183b8f0:	e0bfff17 	ldw	r2,-4(fp)
 183b8f4:	10800017 	ldw	r2,0(r2)
 183b8f8:	10c00217 	ldw	r3,8(r2)
 183b8fc:	e0bfff17 	ldw	r2,-4(fp)
 183b900:	11000217 	ldw	r4,8(r2)
 183b904:	e0bfff17 	ldw	r2,-4(fp)
 183b908:	1080030b 	ldhu	r2,12(r2)
 183b90c:	10bfffcc 	andi	r2,r2,65535
 183b910:	100d883a 	mov	r6,r2
 183b914:	200b883a 	mov	r5,r4
 183b918:	1809883a 	mov	r4,r3
 183b91c:	181c1280 	call	181c128 <tcp_bind>
 183b920:	1007883a 	mov	r3,r2
 183b924:	e0bfff17 	ldw	r2,-4(fp)
 183b928:	10c00105 	stb	r3,4(r2)
        break;
 183b92c:	0001883a 	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 183b930:	e0bfff17 	ldw	r2,-4(fp)
 183b934:	10800017 	ldw	r2,0(r2)
 183b938:	10800404 	addi	r2,r2,16
 183b93c:	1009883a 	mov	r4,r2
 183b940:	18150740 	call	1815074 <sys_sem_signal>
}
 183b944:	0001883a 	nop
 183b948:	e037883a 	mov	sp,fp
 183b94c:	dfc00117 	ldw	ra,4(sp)
 183b950:	df000017 	ldw	fp,0(sp)
 183b954:	dec00204 	addi	sp,sp,8
 183b958:	f800283a 	ret

0183b95c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
 183b95c:	defff904 	addi	sp,sp,-28
 183b960:	dfc00615 	stw	ra,24(sp)
 183b964:	df000515 	stw	fp,20(sp)
 183b968:	df000504 	addi	fp,sp,20
 183b96c:	e13ffd15 	stw	r4,-12(fp)
 183b970:	e17ffe15 	stw	r5,-8(fp)
 183b974:	3005883a 	mov	r2,r6
 183b978:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  int was_blocking;

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
 183b97c:	e0bffd17 	ldw	r2,-12(fp)
 183b980:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 183b984:	e0bffb17 	ldw	r2,-20(fp)
 183b988:	1000021e 	bne	r2,zero,183b994 <do_connected+0x38>
    return ERR_VAL;
 183b98c:	00bffe84 	movi	r2,-6
 183b990:	00004206 	br	183ba9c <do_connected+0x140>

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
 183b994:	e0bffb17 	ldw	r2,-20(fp)
 183b998:	10800b17 	ldw	r2,44(r2)
 183b99c:	10000426 	beq	r2,zero,183b9b0 <do_connected+0x54>
    conn->current_msg->err = err;
 183b9a0:	e0bffb17 	ldw	r2,-20(fp)
 183b9a4:	10800b17 	ldw	r2,44(r2)
 183b9a8:	e0ffff03 	ldbu	r3,-4(fp)
 183b9ac:	10c00105 	stb	r3,4(r2)
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
 183b9b0:	e0bffb17 	ldw	r2,-20(fp)
 183b9b4:	10800017 	ldw	r2,0(r2)
 183b9b8:	10800418 	cmpnei	r2,r2,16
 183b9bc:	1000041e 	bne	r2,zero,183b9d0 <do_connected+0x74>
 183b9c0:	e0bfff07 	ldb	r2,-4(fp)
 183b9c4:	1000021e 	bne	r2,zero,183b9d0 <do_connected+0x74>
    setup_tcp(conn);
 183b9c8:	e13ffb17 	ldw	r4,-20(fp)
 183b9cc:	183ac9c0 	call	183ac9c <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 183b9d0:	e0bffb17 	ldw	r2,-20(fp)
 183b9d4:	10800903 	ldbu	r2,36(r2)
 183b9d8:	10803fcc 	andi	r2,r2,255
 183b9dc:	1080010c 	andi	r2,r2,4
 183b9e0:	1005003a 	cmpeq	r2,r2,zero
 183b9e4:	10803fcc 	andi	r2,r2,255
 183b9e8:	e0bffc15 	stw	r2,-16(fp)
  SET_NONBLOCKING_CONNECT(conn, 0);
 183b9ec:	e0bffb17 	ldw	r2,-20(fp)
 183b9f0:	10c00903 	ldbu	r3,36(r2)
 183b9f4:	00bffec4 	movi	r2,-5
 183b9f8:	1884703a 	and	r2,r3,r2
 183b9fc:	1007883a 	mov	r3,r2
 183ba00:	e0bffb17 	ldw	r2,-20(fp)
 183ba04:	10c00905 	stb	r3,36(r2)
  conn->current_msg = NULL;
 183ba08:	e0bffb17 	ldw	r2,-20(fp)
 183ba0c:	10000b15 	stw	zero,44(r2)
  conn->state = NETCONN_NONE;
 183ba10:	e0bffb17 	ldw	r2,-20(fp)
 183ba14:	10000115 	stw	zero,4(r2)
  if (!was_blocking) {
 183ba18:	e0bffc17 	ldw	r2,-16(fp)
 183ba1c:	10000f1e 	bne	r2,zero,183ba5c <do_connected+0x100>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 183ba20:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183ba24:	10000126 	beq	r2,zero,183ba2c <do_connected+0xd0>
 183ba28:	181103c0 	call	181103c <vTaskEnterCritical>
 183ba2c:	e0bffb17 	ldw	r2,-20(fp)
 183ba30:	10800303 	ldbu	r2,12(r2)
 183ba34:	10803fcc 	andi	r2,r2,255
 183ba38:	1080201c 	xori	r2,r2,128
 183ba3c:	10bfe004 	addi	r2,r2,-128
 183ba40:	10bffdd0 	cmplti	r2,r2,-9
 183ba44:	1000021e 	bne	r2,zero,183ba50 <do_connected+0xf4>
 183ba48:	e0bffb17 	ldw	r2,-20(fp)
 183ba4c:	10000305 	stb	zero,12(r2)
 183ba50:	1810c740 	call	1810c74 <xTaskGetSchedulerState>
 183ba54:	10000126 	beq	r2,zero,183ba5c <do_connected+0x100>
 183ba58:	18110840 	call	1811084 <vTaskExitCritical>
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 183ba5c:	e0bffb17 	ldw	r2,-20(fp)
 183ba60:	10800c17 	ldw	r2,48(r2)
 183ba64:	10000626 	beq	r2,zero,183ba80 <do_connected+0x124>
 183ba68:	e0bffb17 	ldw	r2,-20(fp)
 183ba6c:	10800c17 	ldw	r2,48(r2)
 183ba70:	000d883a 	mov	r6,zero
 183ba74:	01400084 	movi	r5,2
 183ba78:	e13ffb17 	ldw	r4,-20(fp)
 183ba7c:	103ee83a 	callr	r2

  if (was_blocking) {
 183ba80:	e0bffc17 	ldw	r2,-16(fp)
 183ba84:	10000426 	beq	r2,zero,183ba98 <do_connected+0x13c>
    sys_sem_signal(&conn->op_completed);
 183ba88:	e0bffb17 	ldw	r2,-20(fp)
 183ba8c:	10800404 	addi	r2,r2,16
 183ba90:	1009883a 	mov	r4,r2
 183ba94:	18150740 	call	1815074 <sys_sem_signal>
  }
  return ERR_OK;
 183ba98:	0005883a 	mov	r2,zero
}
 183ba9c:	e037883a 	mov	sp,fp
 183baa0:	dfc00117 	ldw	ra,4(sp)
 183baa4:	df000017 	ldw	fp,0(sp)
 183baa8:	dec00204 	addi	sp,sp,8
 183baac:	f800283a 	ret

0183bab0 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
 183bab0:	defffc04 	addi	sp,sp,-16
 183bab4:	dfc00315 	stw	ra,12(sp)
 183bab8:	df000215 	stw	fp,8(sp)
 183babc:	df000204 	addi	fp,sp,8
 183bac0:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.tcp == NULL) {
 183bac4:	e0bfff17 	ldw	r2,-4(fp)
 183bac8:	10800017 	ldw	r2,0(r2)
 183bacc:	10800217 	ldw	r2,8(r2)
 183bad0:	1000041e 	bne	r2,zero,183bae4 <do_connect+0x34>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
 183bad4:	e0bfff17 	ldw	r2,-4(fp)
 183bad8:	00fffd04 	movi	r3,-12
 183badc:	10c00105 	stb	r3,4(r2)
 183bae0:	00007c06 	br	183bcd4 <do_connect+0x224>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 183bae4:	e0bfff17 	ldw	r2,-4(fp)
 183bae8:	10800017 	ldw	r2,0(r2)
 183baec:	10800017 	ldw	r2,0(r2)
 183baf0:	10803c0c 	andi	r2,r2,240
 183baf4:	10c00820 	cmpeqi	r3,r2,32
 183baf8:	1800111e 	bne	r3,zero,183bb40 <do_connect+0x90>
 183bafc:	10c01020 	cmpeqi	r3,r2,64
 183bb00:	1800031e 	bne	r3,zero,183bb10 <do_connect+0x60>
 183bb04:	10800420 	cmpeqi	r2,r2,16
 183bb08:	10001d1e 	bne	r2,zero,183bb80 <do_connect+0xd0>
 183bb0c:	00006706 	br	183bcac <do_connect+0x1fc>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 183bb10:	e0bfff17 	ldw	r2,-4(fp)
 183bb14:	10800017 	ldw	r2,0(r2)
 183bb18:	10c00217 	ldw	r3,8(r2)
 183bb1c:	e0bfff17 	ldw	r2,-4(fp)
 183bb20:	10800217 	ldw	r2,8(r2)
 183bb24:	100b883a 	mov	r5,r2
 183bb28:	1809883a 	mov	r4,r3
 183bb2c:	1834d800 	call	1834d80 <raw_connect>
 183bb30:	1007883a 	mov	r3,r2
 183bb34:	e0bfff17 	ldw	r2,-4(fp)
 183bb38:	10c00105 	stb	r3,4(r2)
    break;
 183bb3c:	00006506 	br	183bcd4 <do_connect+0x224>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 183bb40:	e0bfff17 	ldw	r2,-4(fp)
 183bb44:	10800017 	ldw	r2,0(r2)
 183bb48:	10c00217 	ldw	r3,8(r2)
 183bb4c:	e0bfff17 	ldw	r2,-4(fp)
 183bb50:	11000217 	ldw	r4,8(r2)
 183bb54:	e0bfff17 	ldw	r2,-4(fp)
 183bb58:	1080030b 	ldhu	r2,12(r2)
 183bb5c:	10bfffcc 	andi	r2,r2,65535
 183bb60:	100d883a 	mov	r6,r2
 183bb64:	200b883a 	mov	r5,r4
 183bb68:	1809883a 	mov	r4,r3
 183bb6c:	1822a1c0 	call	1822a1c <udp_connect>
 183bb70:	1007883a 	mov	r3,r2
 183bb74:	e0bfff17 	ldw	r2,-4(fp)
 183bb78:	10c00105 	stb	r3,4(r2)
    break;
 183bb7c:	00005506 	br	183bcd4 <do_connect+0x224>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
 183bb80:	e0bfff17 	ldw	r2,-4(fp)
 183bb84:	10800017 	ldw	r2,0(r2)
 183bb88:	10800117 	ldw	r2,4(r2)
 183bb8c:	10000426 	beq	r2,zero,183bba0 <do_connect+0xf0>
      msg->err = ERR_ISCONN;
 183bb90:	e0bfff17 	ldw	r2,-4(fp)
 183bb94:	00fffdc4 	movi	r3,-9
 183bb98:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 183bb9c:	00004c06 	br	183bcd0 <do_connect+0x220>
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
 183bba0:	e0bfff17 	ldw	r2,-4(fp)
 183bba4:	10800017 	ldw	r2,0(r2)
 183bba8:	1009883a 	mov	r4,r2
 183bbac:	183ac9c0 	call	183ac9c <setup_tcp>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
 183bbb0:	e0bfff17 	ldw	r2,-4(fp)
 183bbb4:	10800017 	ldw	r2,0(r2)
 183bbb8:	10c00217 	ldw	r3,8(r2)
 183bbbc:	e0bfff17 	ldw	r2,-4(fp)
 183bbc0:	11000217 	ldw	r4,8(r2)
        msg->msg.bc.port, do_connected);
 183bbc4:	e0bfff17 	ldw	r2,-4(fp)
 183bbc8:	1080030b 	ldhu	r2,12(r2)
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
 183bbcc:	10bfffcc 	andi	r2,r2,65535
 183bbd0:	01c06134 	movhi	r7,388
 183bbd4:	39ee5704 	addi	r7,r7,-18084
 183bbd8:	100d883a 	mov	r6,r2
 183bbdc:	200b883a 	mov	r5,r4
 183bbe0:	1809883a 	mov	r4,r3
 183bbe4:	181c8000 	call	181c800 <tcp_connect>
 183bbe8:	1007883a 	mov	r3,r2
 183bbec:	e0bfff17 	ldw	r2,-4(fp)
 183bbf0:	10c00105 	stb	r3,4(r2)
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
 183bbf4:	e0bfff17 	ldw	r2,-4(fp)
 183bbf8:	10800103 	ldbu	r2,4(r2)
 183bbfc:	10803fcc 	andi	r2,r2,255
 183bc00:	1080201c 	xori	r2,r2,128
 183bc04:	10bfe004 	addi	r2,r2,-128
 183bc08:	1000311e 	bne	r2,zero,183bcd0 <do_connect+0x220>
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 183bc0c:	e0bfff17 	ldw	r2,-4(fp)
 183bc10:	10800017 	ldw	r2,0(r2)
 183bc14:	10800903 	ldbu	r2,36(r2)
 183bc18:	10803fcc 	andi	r2,r2,255
 183bc1c:	1080008c 	andi	r2,r2,2
 183bc20:	1004c03a 	cmpne	r2,r2,zero
 183bc24:	e0bffe05 	stb	r2,-8(fp)
        msg->conn->state = NETCONN_CONNECT;
 183bc28:	e0bfff17 	ldw	r2,-4(fp)
 183bc2c:	10800017 	ldw	r2,0(r2)
 183bc30:	00c000c4 	movi	r3,3
 183bc34:	10c00115 	stw	r3,4(r2)
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 183bc38:	e0bffe03 	ldbu	r2,-8(fp)
 183bc3c:	10000826 	beq	r2,zero,183bc60 <do_connect+0x1b0>
 183bc40:	e0bfff17 	ldw	r2,-4(fp)
 183bc44:	10800017 	ldw	r2,0(r2)
 183bc48:	e0ffff17 	ldw	r3,-4(fp)
 183bc4c:	18c00017 	ldw	r3,0(r3)
 183bc50:	18c00903 	ldbu	r3,36(r3)
 183bc54:	18c00114 	ori	r3,r3,4
 183bc58:	10c00905 	stb	r3,36(r2)
 183bc5c:	00000806 	br	183bc80 <do_connect+0x1d0>
 183bc60:	e0bfff17 	ldw	r2,-4(fp)
 183bc64:	10800017 	ldw	r2,0(r2)
 183bc68:	e0ffff17 	ldw	r3,-4(fp)
 183bc6c:	18c00017 	ldw	r3,0(r3)
 183bc70:	19000903 	ldbu	r4,36(r3)
 183bc74:	00fffec4 	movi	r3,-5
 183bc78:	20c6703a 	and	r3,r4,r3
 183bc7c:	10c00905 	stb	r3,36(r2)
        if (non_blocking) {
 183bc80:	e0bffe03 	ldbu	r2,-8(fp)
 183bc84:	10000426 	beq	r2,zero,183bc98 <do_connect+0x1e8>
          msg->err = ERR_INPROGRESS;
 183bc88:	e0bfff17 	ldw	r2,-4(fp)
 183bc8c:	00fffec4 	movi	r3,-5
 183bc90:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 183bc94:	00000e06 	br	183bcd0 <do_connect+0x220>
        msg->conn->state = NETCONN_CONNECT;
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
        } else {
          msg->conn->current_msg = msg;
 183bc98:	e0bfff17 	ldw	r2,-4(fp)
 183bc9c:	10800017 	ldw	r2,0(r2)
 183bca0:	e0ffff17 	ldw	r3,-4(fp)
 183bca4:	10c00b15 	stw	r3,44(r2)
          /* sys_sem_signal() is called from do_connected (or err_tcp()),
          * when the connection is established! */
          return;
 183bca8:	00000f06 	br	183bce8 <do_connect+0x238>
      }
    }
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 183bcac:	01c06134 	movhi	r7,388
 183bcb0:	39cf5904 	addi	r7,r7,15716
 183bcb4:	01810144 	movi	r6,1029
 183bcb8:	01406134 	movhi	r5,388
 183bcbc:	294f5f04 	addi	r5,r5,15740
 183bcc0:	01006134 	movhi	r4,388
 183bcc4:	210f6504 	addi	r4,r4,15764
 183bcc8:	1800c180 	call	1800c18 <printf>
 183bccc:	003fff06 	br	183bccc <__ram_exceptions_end+0xff82b888>
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 183bcd0:	0001883a 	nop
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 183bcd4:	e0bfff17 	ldw	r2,-4(fp)
 183bcd8:	10800017 	ldw	r2,0(r2)
 183bcdc:	10800404 	addi	r2,r2,16
 183bce0:	1009883a 	mov	r4,r2
 183bce4:	18150740 	call	1815074 <sys_sem_signal>
}
 183bce8:	e037883a 	mov	sp,fp
 183bcec:	dfc00117 	ldw	ra,4(sp)
 183bcf0:	df000017 	ldw	fp,0(sp)
 183bcf4:	dec00204 	addi	sp,sp,8
 183bcf8:	f800283a 	ret

0183bcfc <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
 183bcfc:	defffd04 	addi	sp,sp,-12
 183bd00:	dfc00215 	stw	ra,8(sp)
 183bd04:	df000115 	stw	fp,4(sp)
 183bd08:	df000104 	addi	fp,sp,4
 183bd0c:	e13fff15 	stw	r4,-4(fp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 183bd10:	e0bfff17 	ldw	r2,-4(fp)
 183bd14:	10800017 	ldw	r2,0(r2)
 183bd18:	10800017 	ldw	r2,0(r2)
 183bd1c:	10803c0c 	andi	r2,r2,240
 183bd20:	10800818 	cmpnei	r2,r2,32
 183bd24:	1000081e 	bne	r2,zero,183bd48 <do_disconnect+0x4c>
    udp_disconnect(msg->conn->pcb.udp);
 183bd28:	e0bfff17 	ldw	r2,-4(fp)
 183bd2c:	10800017 	ldw	r2,0(r2)
 183bd30:	10800217 	ldw	r2,8(r2)
 183bd34:	1009883a 	mov	r4,r2
 183bd38:	1822b240 	call	1822b24 <udp_disconnect>
    msg->err = ERR_OK;
 183bd3c:	e0bfff17 	ldw	r2,-4(fp)
 183bd40:	10000105 	stb	zero,4(r2)
 183bd44:	00000306 	br	183bd54 <do_disconnect+0x58>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
 183bd48:	e0bfff17 	ldw	r2,-4(fp)
 183bd4c:	00fffe84 	movi	r3,-6
 183bd50:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 183bd54:	e0bfff17 	ldw	r2,-4(fp)
 183bd58:	10800017 	ldw	r2,0(r2)
 183bd5c:	10800404 	addi	r2,r2,16
 183bd60:	1009883a 	mov	r4,r2
 183bd64:	18150740 	call	1815074 <sys_sem_signal>
}
 183bd68:	0001883a 	nop
 183bd6c:	e037883a 	mov	sp,fp
 183bd70:	dfc00117 	ldw	ra,4(sp)
 183bd74:	df000017 	ldw	fp,0(sp)
 183bd78:	dec00204 	addi	sp,sp,8
 183bd7c:	f800283a 	ret

0183bd80 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
 183bd80:	defffc04 	addi	sp,sp,-16
 183bd84:	dfc00315 	stw	ra,12(sp)
 183bd88:	df000215 	stw	fp,8(sp)
 183bd8c:	df000204 	addi	fp,sp,8
 183bd90:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 183bd94:	e0bfff17 	ldw	r2,-4(fp)
 183bd98:	10800017 	ldw	r2,0(r2)
 183bd9c:	10800303 	ldbu	r2,12(r2)
 183bda0:	10803fcc 	andi	r2,r2,255
 183bda4:	1080201c 	xori	r2,r2,128
 183bda8:	10bfe004 	addi	r2,r2,-128
 183bdac:	10bffdc8 	cmpgei	r2,r2,-9
 183bdb0:	1000061e 	bne	r2,zero,183bdcc <do_listen+0x4c>
    msg->err = msg->conn->last_err;
 183bdb4:	e0bfff17 	ldw	r2,-4(fp)
 183bdb8:	10800017 	ldw	r2,0(r2)
 183bdbc:	10c00303 	ldbu	r3,12(r2)
 183bdc0:	e0bfff17 	ldw	r2,-4(fp)
 183bdc4:	10c00105 	stb	r3,4(r2)
 183bdc8:	00006206 	br	183bf54 <do_listen+0x1d4>
  } else {
    msg->err = ERR_CONN;
 183bdcc:	e0bfff17 	ldw	r2,-4(fp)
 183bdd0:	00fffcc4 	movi	r3,-13
 183bdd4:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 183bdd8:	e0bfff17 	ldw	r2,-4(fp)
 183bddc:	10800017 	ldw	r2,0(r2)
 183bde0:	10800217 	ldw	r2,8(r2)
 183bde4:	10005b26 	beq	r2,zero,183bf54 <do_listen+0x1d4>
      if (msg->conn->type == NETCONN_TCP) {
 183bde8:	e0bfff17 	ldw	r2,-4(fp)
 183bdec:	10800017 	ldw	r2,0(r2)
 183bdf0:	10800017 	ldw	r2,0(r2)
 183bdf4:	10800418 	cmpnei	r2,r2,16
 183bdf8:	1000531e 	bne	r2,zero,183bf48 <do_listen+0x1c8>
        if (msg->conn->state == NETCONN_NONE) {
 183bdfc:	e0bfff17 	ldw	r2,-4(fp)
 183be00:	10800017 	ldw	r2,0(r2)
 183be04:	10800117 	ldw	r2,4(r2)
 183be08:	1000521e 	bne	r2,zero,183bf54 <do_listen+0x1d4>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
 183be0c:	e0bfff17 	ldw	r2,-4(fp)
 183be10:	10800017 	ldw	r2,0(r2)
 183be14:	10c00217 	ldw	r3,8(r2)
 183be18:	e0bfff17 	ldw	r2,-4(fp)
 183be1c:	10800203 	ldbu	r2,8(r2)
 183be20:	10803fcc 	andi	r2,r2,255
 183be24:	100b883a 	mov	r5,r2
 183be28:	1809883a 	mov	r4,r3
 183be2c:	181c3280 	call	181c328 <tcp_listen_with_backlog>
 183be30:	e0bffe15 	stw	r2,-8(fp)
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
 183be34:	e0bffe17 	ldw	r2,-8(fp)
 183be38:	1000041e 	bne	r2,zero,183be4c <do_listen+0xcc>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
 183be3c:	e0bfff17 	ldw	r2,-4(fp)
 183be40:	00ffffc4 	movi	r3,-1
 183be44:	10c00105 	stb	r3,4(r2)
 183be48:	00004206 	br	183bf54 <do_listen+0x1d4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 183be4c:	e0bfff17 	ldw	r2,-4(fp)
 183be50:	10800017 	ldw	r2,0(r2)
 183be54:	10800517 	ldw	r2,20(r2)
 183be58:	10000826 	beq	r2,zero,183be7c <do_listen+0xfc>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
 183be5c:	e0bfff17 	ldw	r2,-4(fp)
 183be60:	10800017 	ldw	r2,0(r2)
 183be64:	10800504 	addi	r2,r2,20
 183be68:	1009883a 	mov	r4,r2
 183be6c:	18154140 	call	1815414 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 183be70:	e0bfff17 	ldw	r2,-4(fp)
 183be74:	10800017 	ldw	r2,0(r2)
 183be78:	10000515 	stw	zero,20(r2)
            }
            msg->err = ERR_OK;
 183be7c:	e0bfff17 	ldw	r2,-4(fp)
 183be80:	10000105 	stb	zero,4(r2)
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 183be84:	e0bfff17 	ldw	r2,-4(fp)
 183be88:	10800017 	ldw	r2,0(r2)
 183be8c:	10800617 	ldw	r2,24(r2)
 183be90:	1000091e 	bne	r2,zero,183beb8 <do_listen+0x138>
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 183be94:	e0bfff17 	ldw	r2,-4(fp)
 183be98:	10800017 	ldw	r2,0(r2)
 183be9c:	10800604 	addi	r2,r2,24
 183bea0:	01420004 	movi	r5,2048
 183bea4:	1009883a 	mov	r4,r2
 183bea8:	18153440 	call	1815344 <sys_mbox_new>
 183beac:	1007883a 	mov	r3,r2
 183beb0:	e0bfff17 	ldw	r2,-4(fp)
 183beb4:	10c00105 	stb	r3,4(r2)
            }
            if (msg->err == ERR_OK) {
 183beb8:	e0bfff17 	ldw	r2,-4(fp)
 183bebc:	10800103 	ldbu	r2,4(r2)
 183bec0:	10803fcc 	andi	r2,r2,255
 183bec4:	1080201c 	xori	r2,r2,128
 183bec8:	10bfe004 	addi	r2,r2,-128
 183becc:	1000181e 	bne	r2,zero,183bf30 <do_listen+0x1b0>
              msg->conn->state = NETCONN_LISTEN;
 183bed0:	e0bfff17 	ldw	r2,-4(fp)
 183bed4:	10800017 	ldw	r2,0(r2)
 183bed8:	00c00084 	movi	r3,2
 183bedc:	10c00115 	stw	r3,4(r2)
              msg->conn->pcb.tcp = lpcb;
 183bee0:	e0bfff17 	ldw	r2,-4(fp)
 183bee4:	10800017 	ldw	r2,0(r2)
 183bee8:	e0fffe17 	ldw	r3,-8(fp)
 183beec:	10c00215 	stw	r3,8(r2)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 183bef0:	e0bfff17 	ldw	r2,-4(fp)
 183bef4:	10800017 	ldw	r2,0(r2)
 183bef8:	10c00217 	ldw	r3,8(r2)
 183befc:	e0bfff17 	ldw	r2,-4(fp)
 183bf00:	10800017 	ldw	r2,0(r2)
 183bf04:	100b883a 	mov	r5,r2
 183bf08:	1809883a 	mov	r4,r3
 183bf0c:	181da7c0 	call	181da7c <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 183bf10:	e0bfff17 	ldw	r2,-4(fp)
 183bf14:	10800017 	ldw	r2,0(r2)
 183bf18:	10800217 	ldw	r2,8(r2)
 183bf1c:	01406134 	movhi	r5,388
 183bf20:	296b4904 	addi	r5,r5,-21212
 183bf24:	1009883a 	mov	r4,r2
 183bf28:	181db4c0 	call	181db4c <tcp_accept>
 183bf2c:	00000906 	br	183bf54 <do_listen+0x1d4>
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
 183bf30:	e13ffe17 	ldw	r4,-8(fp)
 183bf34:	181be440 	call	181be44 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 183bf38:	e0bfff17 	ldw	r2,-4(fp)
 183bf3c:	10800017 	ldw	r2,0(r2)
 183bf40:	10000215 	stw	zero,8(r2)
 183bf44:	00000306 	br	183bf54 <do_listen+0x1d4>
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
 183bf48:	e0bfff17 	ldw	r2,-4(fp)
 183bf4c:	00fffc84 	movi	r3,-14
 183bf50:	10c00105 	stb	r3,4(r2)
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 183bf54:	e0bfff17 	ldw	r2,-4(fp)
 183bf58:	10800017 	ldw	r2,0(r2)
 183bf5c:	10800404 	addi	r2,r2,16
 183bf60:	1009883a 	mov	r4,r2
 183bf64:	18150740 	call	1815074 <sys_sem_signal>
}
 183bf68:	0001883a 	nop
 183bf6c:	e037883a 	mov	sp,fp
 183bf70:	dfc00117 	ldw	ra,4(sp)
 183bf74:	df000017 	ldw	fp,0(sp)
 183bf78:	dec00204 	addi	sp,sp,8
 183bf7c:	f800283a 	ret

0183bf80 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
 183bf80:	defffb04 	addi	sp,sp,-20
 183bf84:	dfc00415 	stw	ra,16(sp)
 183bf88:	df000315 	stw	fp,12(sp)
 183bf8c:	df000304 	addi	fp,sp,12
 183bf90:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 183bf94:	e0bfff17 	ldw	r2,-4(fp)
 183bf98:	10800017 	ldw	r2,0(r2)
 183bf9c:	10800303 	ldbu	r2,12(r2)
 183bfa0:	10803fcc 	andi	r2,r2,255
 183bfa4:	1080201c 	xori	r2,r2,128
 183bfa8:	10bfe004 	addi	r2,r2,-128
 183bfac:	10bffdc8 	cmpgei	r2,r2,-9
 183bfb0:	1000061e 	bne	r2,zero,183bfcc <do_send+0x4c>
    msg->err = msg->conn->last_err;
 183bfb4:	e0bfff17 	ldw	r2,-4(fp)
 183bfb8:	10800017 	ldw	r2,0(r2)
 183bfbc:	10c00303 	ldbu	r3,12(r2)
 183bfc0:	e0bfff17 	ldw	r2,-4(fp)
 183bfc4:	10c00105 	stb	r3,4(r2)
 183bfc8:	00007306 	br	183c198 <do_send+0x218>
  } else {
    msg->err = ERR_CONN;
 183bfcc:	e0bfff17 	ldw	r2,-4(fp)
 183bfd0:	00fffcc4 	movi	r3,-13
 183bfd4:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 183bfd8:	e0bfff17 	ldw	r2,-4(fp)
 183bfdc:	10800017 	ldw	r2,0(r2)
 183bfe0:	10800217 	ldw	r2,8(r2)
 183bfe4:	10006c26 	beq	r2,zero,183c198 <do_send+0x218>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 183bfe8:	e0bfff17 	ldw	r2,-4(fp)
 183bfec:	10800017 	ldw	r2,0(r2)
 183bff0:	10800017 	ldw	r2,0(r2)
 183bff4:	10803c0c 	andi	r2,r2,240
 183bff8:	10c00820 	cmpeqi	r3,r2,32
 183bffc:	1800291e 	bne	r3,zero,183c0a4 <do_send+0x124>
 183c000:	10801020 	cmpeqi	r2,r2,64
 183c004:	1000011e 	bne	r2,zero,183c00c <do_send+0x8c>
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
#endif /* LWIP_UDP */
      default:
        break;
 183c008:	00006306 	br	183c198 <do_send+0x218>
    msg->err = ERR_CONN;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
 183c00c:	e0bfff17 	ldw	r2,-4(fp)
 183c010:	10800217 	ldw	r2,8(r2)
 183c014:	10800204 	addi	r2,r2,8
 183c018:	10000426 	beq	r2,zero,183c02c <do_send+0xac>
 183c01c:	e0bfff17 	ldw	r2,-4(fp)
 183c020:	10800217 	ldw	r2,8(r2)
 183c024:	10800217 	ldw	r2,8(r2)
 183c028:	10000d1e 	bne	r2,zero,183c060 <do_send+0xe0>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
 183c02c:	e0bfff17 	ldw	r2,-4(fp)
 183c030:	10800017 	ldw	r2,0(r2)
 183c034:	10c00217 	ldw	r3,8(r2)
 183c038:	e0bfff17 	ldw	r2,-4(fp)
 183c03c:	10800217 	ldw	r2,8(r2)
 183c040:	10800017 	ldw	r2,0(r2)
 183c044:	100b883a 	mov	r5,r2
 183c048:	1809883a 	mov	r4,r3
 183c04c:	1834f940 	call	1834f94 <raw_send>
 183c050:	1007883a 	mov	r3,r2
 183c054:	e0bfff17 	ldw	r2,-4(fp)
 183c058:	10c00105 	stb	r3,4(r2)
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
        }
        break;
 183c05c:	00004e06 	br	183c198 <do_send+0x218>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
 183c060:	e0bfff17 	ldw	r2,-4(fp)
 183c064:	10800017 	ldw	r2,0(r2)
 183c068:	10c00217 	ldw	r3,8(r2)
 183c06c:	e0bfff17 	ldw	r2,-4(fp)
 183c070:	10800217 	ldw	r2,8(r2)
 183c074:	11000017 	ldw	r4,0(r2)
 183c078:	e0bfff17 	ldw	r2,-4(fp)
 183c07c:	10800217 	ldw	r2,8(r2)
 183c080:	10800204 	addi	r2,r2,8
 183c084:	100d883a 	mov	r6,r2
 183c088:	200b883a 	mov	r5,r4
 183c08c:	1809883a 	mov	r4,r3
 183c090:	1834e0c0 	call	1834e0c <raw_sendto>
 183c094:	1007883a 	mov	r3,r2
 183c098:	e0bfff17 	ldw	r2,-4(fp)
 183c09c:	10c00105 	stb	r3,4(r2)
        }
        break;
 183c0a0:	00003d06 	br	183c198 <do_send+0x218>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
 183c0a4:	e0bfff17 	ldw	r2,-4(fp)
 183c0a8:	10800217 	ldw	r2,8(r2)
 183c0ac:	10800204 	addi	r2,r2,8
 183c0b0:	10000426 	beq	r2,zero,183c0c4 <do_send+0x144>
 183c0b4:	e0bfff17 	ldw	r2,-4(fp)
 183c0b8:	10800217 	ldw	r2,8(r2)
 183c0bc:	10800217 	ldw	r2,8(r2)
 183c0c0:	1000181e 	bne	r2,zero,183c124 <do_send+0x1a4>
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c0c4:	e0bfff17 	ldw	r2,-4(fp)
 183c0c8:	10800017 	ldw	r2,0(r2)
 183c0cc:	10c00217 	ldw	r3,8(r2)
 183c0d0:	e0bfff17 	ldw	r2,-4(fp)
 183c0d4:	10800217 	ldw	r2,8(r2)
 183c0d8:	11000017 	ldw	r4,0(r2)
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 183c0dc:	e0bfff17 	ldw	r2,-4(fp)
 183c0e0:	10800217 	ldw	r2,8(r2)
 183c0e4:	10800383 	ldbu	r2,14(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c0e8:	10803fcc 	andi	r2,r2,255
 183c0ec:	1140008c 	andi	r5,r2,2
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 183c0f0:	e0bfff17 	ldw	r2,-4(fp)
 183c0f4:	10800217 	ldw	r2,8(r2)
 183c0f8:	1080040b 	ldhu	r2,16(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c0fc:	10bfffcc 	andi	r2,r2,65535
 183c100:	100f883a 	mov	r7,r2
 183c104:	280d883a 	mov	r6,r5
 183c108:	200b883a 	mov	r5,r4
 183c10c:	1809883a 	mov	r4,r3
 183c110:	18222880 	call	1822288 <udp_send_chksum>
 183c114:	1007883a 	mov	r3,r2
 183c118:	e0bfff17 	ldw	r2,-4(fp)
 183c11c:	10c00105 	stb	r3,4(r2)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
 183c120:	00001c06 	br	183c194 <do_send+0x214>
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c124:	e0bfff17 	ldw	r2,-4(fp)
 183c128:	10800017 	ldw	r2,0(r2)
 183c12c:	11000217 	ldw	r4,8(r2)
 183c130:	e0bfff17 	ldw	r2,-4(fp)
 183c134:	10800217 	ldw	r2,8(r2)
 183c138:	11400017 	ldw	r5,0(r2)
            &msg->msg.b->addr, msg->msg.b->port,
 183c13c:	e0bfff17 	ldw	r2,-4(fp)
 183c140:	10800217 	ldw	r2,8(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c144:	11800204 	addi	r6,r2,8
            &msg->msg.b->addr, msg->msg.b->port,
 183c148:	e0bfff17 	ldw	r2,-4(fp)
 183c14c:	10800217 	ldw	r2,8(r2)
 183c150:	1080030b 	ldhu	r2,12(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c154:	11ffffcc 	andi	r7,r2,65535
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 183c158:	e0bfff17 	ldw	r2,-4(fp)
 183c15c:	10800217 	ldw	r2,8(r2)
 183c160:	10800383 	ldbu	r2,14(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c164:	10803fcc 	andi	r2,r2,255
 183c168:	1080008c 	andi	r2,r2,2
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 183c16c:	e0ffff17 	ldw	r3,-4(fp)
 183c170:	18c00217 	ldw	r3,8(r3)
 183c174:	18c0040b 	ldhu	r3,16(r3)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 183c178:	18ffffcc 	andi	r3,r3,65535
 183c17c:	d8c00115 	stw	r3,4(sp)
 183c180:	d8800015 	stw	r2,0(sp)
 183c184:	18223540 	call	1822354 <udp_sendto_chksum>
 183c188:	1007883a 	mov	r3,r2
 183c18c:	e0bfff17 	ldw	r2,-4(fp)
 183c190:	10c00105 	stb	r3,4(r2)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
 183c194:	0001883a 	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 183c198:	e0bfff17 	ldw	r2,-4(fp)
 183c19c:	10800017 	ldw	r2,0(r2)
 183c1a0:	10800404 	addi	r2,r2,16
 183c1a4:	1009883a 	mov	r4,r2
 183c1a8:	18150740 	call	1815074 <sys_sem_signal>
}
 183c1ac:	0001883a 	nop
 183c1b0:	e037883a 	mov	sp,fp
 183c1b4:	dfc00117 	ldw	ra,4(sp)
 183c1b8:	df000017 	ldw	fp,0(sp)
 183c1bc:	dec00204 	addi	sp,sp,8
 183c1c0:	f800283a 	ret

0183c1c4 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 183c1c4:	defffb04 	addi	sp,sp,-20
 183c1c8:	dfc00415 	stw	ra,16(sp)
 183c1cc:	df000315 	stw	fp,12(sp)
 183c1d0:	df000304 	addi	fp,sp,12
 183c1d4:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
 183c1d8:	e0bfff17 	ldw	r2,-4(fp)
 183c1dc:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp != NULL) {
 183c1e0:	e0bfff17 	ldw	r2,-4(fp)
 183c1e4:	10800017 	ldw	r2,0(r2)
 183c1e8:	10800217 	ldw	r2,8(r2)
 183c1ec:	10002926 	beq	r2,zero,183c294 <do_recv+0xd0>
    if (msg->conn->type == NETCONN_TCP) {
 183c1f0:	e0bfff17 	ldw	r2,-4(fp)
 183c1f4:	10800017 	ldw	r2,0(r2)
 183c1f8:	10800017 	ldw	r2,0(r2)
 183c1fc:	10800418 	cmpnei	r2,r2,16
 183c200:	1000241e 	bne	r2,zero,183c294 <do_recv+0xd0>
#if TCP_LISTEN_BACKLOG
      if (msg->conn->pcb.tcp->state == LISTEN) {
 183c204:	e0bfff17 	ldw	r2,-4(fp)
 183c208:	10800017 	ldw	r2,0(r2)
 183c20c:	10800217 	ldw	r2,8(r2)
 183c210:	10800617 	ldw	r2,24(r2)
 183c214:	10800058 	cmpnei	r2,r2,1
 183c218:	1000071e 	bne	r2,zero,183c238 <do_recv+0x74>
        tcp_accepted(msg->conn->pcb.tcp);
 183c21c:	e0bfff17 	ldw	r2,-4(fp)
 183c220:	10800017 	ldw	r2,0(r2)
 183c224:	10800217 	ldw	r2,8(r2)
 183c228:	10c00843 	ldbu	r3,33(r2)
 183c22c:	18ffffc4 	addi	r3,r3,-1
 183c230:	10c00845 	stb	r3,33(r2)
 183c234:	00001706 	br	183c294 <do_recv+0xd0>
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
 183c238:	e0bfff17 	ldw	r2,-4(fp)
 183c23c:	10800217 	ldw	r2,8(r2)
 183c240:	e0bffd15 	stw	r2,-12(fp)
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
 183c244:	e0bffd17 	ldw	r2,-12(fp)
 183c248:	00ffffd4 	movui	r3,65535
 183c24c:	18800236 	bltu	r3,r2,183c258 <do_recv+0x94>
 183c250:	e0bffd17 	ldw	r2,-12(fp)
 183c254:	00000106 	br	183c25c <do_recv+0x98>
 183c258:	00bfffc4 	movi	r2,-1
 183c25c:	e0bffe0d 	sth	r2,-8(fp)
          tcp_recved(msg->conn->pcb.tcp, recved);
 183c260:	e0bfff17 	ldw	r2,-4(fp)
 183c264:	10800017 	ldw	r2,0(r2)
 183c268:	10800217 	ldw	r2,8(r2)
 183c26c:	e0fffe0b 	ldhu	r3,-8(fp)
 183c270:	180b883a 	mov	r5,r3
 183c274:	1009883a 	mov	r4,r2
 183c278:	181c6800 	call	181c680 <tcp_recved>
          remaining -= recved;
 183c27c:	e0bffe0b 	ldhu	r2,-8(fp)
 183c280:	e0fffd17 	ldw	r3,-12(fp)
 183c284:	1885c83a 	sub	r2,r3,r2
 183c288:	e0bffd15 	stw	r2,-12(fp)
        }while(remaining != 0);
 183c28c:	e0bffd17 	ldw	r2,-12(fp)
 183c290:	103fec1e 	bne	r2,zero,183c244 <__ram_exceptions_end+0xff82be00>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 183c294:	e0bfff17 	ldw	r2,-4(fp)
 183c298:	10800017 	ldw	r2,0(r2)
 183c29c:	10800404 	addi	r2,r2,16
 183c2a0:	1009883a 	mov	r4,r2
 183c2a4:	18150740 	call	1815074 <sys_sem_signal>
}
 183c2a8:	0001883a 	nop
 183c2ac:	e037883a 	mov	sp,fp
 183c2b0:	dfc00117 	ldw	ra,4(sp)
 183c2b4:	df000017 	ldw	fp,0(sp)
 183c2b8:	dec00204 	addi	sp,sp,8
 183c2bc:	f800283a 	ret

0183c2c0 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 183c2c0:	defff804 	addi	sp,sp,-32
 183c2c4:	dfc00715 	stw	ra,28(sp)
 183c2c8:	df000615 	stw	fp,24(sp)
 183c2cc:	df000604 	addi	fp,sp,24
 183c2d0:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
 183c2d4:	e03ffb05 	stb	zero,-20(fp)
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 183c2d8:	e0bfff17 	ldw	r2,-4(fp)
 183c2dc:	10800903 	ldbu	r2,36(r2)
 183c2e0:	10803fcc 	andi	r2,r2,255
 183c2e4:	1080008c 	andi	r2,r2,2
 183c2e8:	1000061e 	bne	r2,zero,183c304 <do_writemore+0x44>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
 183c2ec:	e0bfff17 	ldw	r2,-4(fp)
 183c2f0:	10800b17 	ldw	r2,44(r2)
 183c2f4:	10800403 	ldbu	r2,16(r2)
 183c2f8:	10803fcc 	andi	r2,r2,255
 183c2fc:	1080010c 	andi	r2,r2,4
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 183c300:	10000226 	beq	r2,zero,183c30c <do_writemore+0x4c>
 183c304:	00800044 	movi	r2,1
 183c308:	00000106 	br	183c310 <do_writemore+0x50>
 183c30c:	0005883a 	mov	r2,zero
 183c310:	e0bffb85 	stb	r2,-18(fp)
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;
 183c314:	e0bfff17 	ldw	r2,-4(fp)
 183c318:	10800b17 	ldw	r2,44(r2)
 183c31c:	10800403 	ldbu	r2,16(r2)
 183c320:	e0bffb45 	stb	r2,-19(fp)
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 183c324:	e0bfff17 	ldw	r2,-4(fp)
 183c328:	10800b17 	ldw	r2,44(r2)
 183c32c:	10c00217 	ldw	r3,8(r2)
 183c330:	e0bfff17 	ldw	r2,-4(fp)
 183c334:	10800a17 	ldw	r2,40(r2)
 183c338:	1885883a 	add	r2,r3,r2
 183c33c:	e0bffc15 	stw	r2,-16(fp)
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 183c340:	e0bfff17 	ldw	r2,-4(fp)
 183c344:	10800b17 	ldw	r2,44(r2)
 183c348:	10c00317 	ldw	r3,12(r2)
 183c34c:	e0bfff17 	ldw	r2,-4(fp)
 183c350:	10800a17 	ldw	r2,40(r2)
 183c354:	1885c83a 	sub	r2,r3,r2
 183c358:	e0bffd15 	stw	r2,-12(fp)
    if (diff > 0xffffUL) { /* max_u16_t */
 183c35c:	e0bffd17 	ldw	r2,-12(fp)
 183c360:	00ffffd4 	movui	r3,65535
 183c364:	1880062e 	bgeu	r3,r2,183c380 <do_writemore+0xc0>
      len = 0xffff;
 183c368:	00bfffc4 	movi	r2,-1
 183c36c:	e0bffa8d 	sth	r2,-22(fp)
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
 183c370:	e0bffb43 	ldbu	r2,-19(fp)
 183c374:	10800094 	ori	r2,r2,2
 183c378:	e0bffb45 	stb	r2,-19(fp)
 183c37c:	00000206 	br	183c388 <do_writemore+0xc8>
    } else {
      len = (u16_t)diff;
 183c380:	e0bffd17 	ldw	r2,-12(fp)
 183c384:	e0bffa8d 	sth	r2,-22(fp)
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 183c388:	e0bfff17 	ldw	r2,-4(fp)
 183c38c:	10800217 	ldw	r2,8(r2)
 183c390:	10801a8b 	ldhu	r2,106(r2)
 183c394:	e0bffe0d 	sth	r2,-8(fp)
    if (available < len) {
 183c398:	e0fffe0b 	ldhu	r3,-8(fp)
 183c39c:	e0bffa8b 	ldhu	r2,-22(fp)
 183c3a0:	18800c2e 	bgeu	r3,r2,183c3d4 <do_writemore+0x114>
      /* don't try to write more than sendbuf */
      len = available;
 183c3a4:	e0bffe0b 	ldhu	r2,-8(fp)
 183c3a8:	e0bffa8d 	sth	r2,-22(fp)
      if (dontblock){ 
 183c3ac:	e0bffb83 	ldbu	r2,-18(fp)
 183c3b0:	10000526 	beq	r2,zero,183c3c8 <do_writemore+0x108>
        if (!len) {
 183c3b4:	e0bffa8b 	ldhu	r2,-22(fp)
 183c3b8:	1000061e 	bne	r2,zero,183c3d4 <do_writemore+0x114>
          err = ERR_WOULDBLOCK;
 183c3bc:	00bffe44 	movi	r2,-7
 183c3c0:	e0bffa05 	stb	r2,-24(fp)
          goto err_mem;
 183c3c4:	00001206 	br	183c410 <do_writemore+0x150>
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
 183c3c8:	e0bffb43 	ldbu	r2,-19(fp)
 183c3cc:	10800094 	ori	r2,r2,2
 183c3d0:	e0bffb45 	stb	r2,-19(fp)
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 183c3d4:	e0bfff17 	ldw	r2,-4(fp)
 183c3d8:	10800217 	ldw	r2,8(r2)
 183c3dc:	e0fffa8b 	ldhu	r3,-22(fp)
 183c3e0:	e13ffb43 	ldbu	r4,-19(fp)
 183c3e4:	200f883a 	mov	r7,r4
 183c3e8:	180d883a 	mov	r6,r3
 183c3ec:	e17ffc17 	ldw	r5,-16(fp)
 183c3f0:	1009883a 	mov	r4,r2
 183c3f4:	181eb080 	call	181eb08 <tcp_write>
 183c3f8:	e0bffa05 	stb	r2,-24(fp)
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 183c3fc:	e0bffa07 	ldb	r2,-24(fp)
 183c400:	10000326 	beq	r2,zero,183c410 <do_writemore+0x150>
 183c404:	e0bffa07 	ldb	r2,-24(fp)
 183c408:	10bfffd8 	cmpnei	r2,r2,-1
 183c40c:	10002e1e 	bne	r2,zero,183c4c8 <do_writemore+0x208>
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 183c410:	e0bffb83 	ldbu	r2,-18(fp)
 183c414:	10001626 	beq	r2,zero,183c470 <do_writemore+0x1b0>
 183c418:	e0fffa8b 	ldhu	r3,-22(fp)
 183c41c:	e0bfff17 	ldw	r2,-4(fp)
 183c420:	10800b17 	ldw	r2,44(r2)
 183c424:	10800317 	ldw	r2,12(r2)
 183c428:	1880112e 	bgeu	r3,r2,183c470 <do_writemore+0x1b0>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 183c42c:	e0bfff17 	ldw	r2,-4(fp)
 183c430:	10800c17 	ldw	r2,48(r2)
 183c434:	10000726 	beq	r2,zero,183c454 <do_writemore+0x194>
 183c438:	e0bfff17 	ldw	r2,-4(fp)
 183c43c:	10800c17 	ldw	r2,48(r2)
 183c440:	e0fffa8b 	ldhu	r3,-22(fp)
 183c444:	180d883a 	mov	r6,r3
 183c448:	014000c4 	movi	r5,3
 183c44c:	e13fff17 	ldw	r4,-4(fp)
 183c450:	103ee83a 	callr	r2
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 183c454:	e0bfff17 	ldw	r2,-4(fp)
 183c458:	10800903 	ldbu	r2,36(r2)
 183c45c:	10800414 	ori	r2,r2,16
 183c460:	1007883a 	mov	r3,r2
 183c464:	e0bfff17 	ldw	r2,-4(fp)
 183c468:	10c00905 	stb	r3,36(r2)
 183c46c:	00001606 	br	183c4c8 <do_writemore+0x208>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 183c470:	e0bfff17 	ldw	r2,-4(fp)
 183c474:	10800217 	ldw	r2,8(r2)
 183c478:	10801a8b 	ldhu	r2,106(r2)
 183c47c:	10bfffcc 	andi	r2,r2,65535
 183c480:	10816d70 	cmpltui	r2,r2,1461
 183c484:	1000061e 	bne	r2,zero,183c4a0 <do_writemore+0x1e0>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
 183c488:	e0bfff17 	ldw	r2,-4(fp)
 183c48c:	10800217 	ldw	r2,8(r2)
 183c490:	10801b0b 	ldhu	r2,108(r2)
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 183c494:	10bfffcc 	andi	r2,r2,65535
 183c498:	10800130 	cmpltui	r2,r2,4
 183c49c:	10000a1e 	bne	r2,zero,183c4c8 <do_writemore+0x208>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 183c4a0:	e0bfff17 	ldw	r2,-4(fp)
 183c4a4:	10800c17 	ldw	r2,48(r2)
 183c4a8:	10000726 	beq	r2,zero,183c4c8 <do_writemore+0x208>
 183c4ac:	e0bfff17 	ldw	r2,-4(fp)
 183c4b0:	10800c17 	ldw	r2,48(r2)
 183c4b4:	e0fffa8b 	ldhu	r3,-22(fp)
 183c4b8:	180d883a 	mov	r6,r3
 183c4bc:	014000c4 	movi	r5,3
 183c4c0:	e13fff17 	ldw	r4,-4(fp)
 183c4c4:	103ee83a 	callr	r2
      }
    }

    if (err == ERR_OK) {
 183c4c8:	e0bffa07 	ldb	r2,-24(fp)
 183c4cc:	10001c1e 	bne	r2,zero,183c540 <do_writemore+0x280>
      conn->write_offset += len;
 183c4d0:	e0bfff17 	ldw	r2,-4(fp)
 183c4d4:	10c00a17 	ldw	r3,40(r2)
 183c4d8:	e0bffa8b 	ldhu	r2,-22(fp)
 183c4dc:	1887883a 	add	r3,r3,r2
 183c4e0:	e0bfff17 	ldw	r2,-4(fp)
 183c4e4:	10c00a15 	stw	r3,40(r2)
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 183c4e8:	e0bfff17 	ldw	r2,-4(fp)
 183c4ec:	10c00a17 	ldw	r3,40(r2)
 183c4f0:	e0bfff17 	ldw	r2,-4(fp)
 183c4f4:	10800b17 	ldw	r2,44(r2)
 183c4f8:	10800317 	ldw	r2,12(r2)
 183c4fc:	18800226 	beq	r3,r2,183c508 <do_writemore+0x248>
 183c500:	e0bffb83 	ldbu	r2,-18(fp)
 183c504:	10000926 	beq	r2,zero,183c52c <do_writemore+0x26c>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
 183c508:	e0bfff17 	ldw	r2,-4(fp)
 183c50c:	10800b17 	ldw	r2,44(r2)
 183c510:	e0ffff17 	ldw	r3,-4(fp)
 183c514:	18c00a17 	ldw	r3,40(r3)
 183c518:	10c00315 	stw	r3,12(r2)
        /* everything was written */
        write_finished = 1;
 183c51c:	00800044 	movi	r2,1
 183c520:	e0bffb05 	stb	r2,-20(fp)
        conn->write_offset = 0;
 183c524:	e0bfff17 	ldw	r2,-4(fp)
 183c528:	10000a15 	stw	zero,40(r2)
      }
      tcp_output(conn->pcb.tcp);
 183c52c:	e0bfff17 	ldw	r2,-4(fp)
 183c530:	10800217 	ldw	r2,8(r2)
 183c534:	1009883a 	mov	r4,r2
 183c538:	181f8bc0 	call	181f8bc <tcp_output>
 183c53c:	00000f06 	br	183c57c <do_writemore+0x2bc>
    } else if ((err == ERR_MEM) && !dontblock) {
 183c540:	e0bffa07 	ldb	r2,-24(fp)
 183c544:	10bfffd8 	cmpnei	r2,r2,-1
 183c548:	1000071e 	bne	r2,zero,183c568 <do_writemore+0x2a8>
 183c54c:	e0bffb83 	ldbu	r2,-18(fp)
 183c550:	1000051e 	bne	r2,zero,183c568 <do_writemore+0x2a8>
      /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
         we do NOT return to the application thread, since ERR_MEM is
         only a temporary error! */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      tcp_output(conn->pcb.tcp);
 183c554:	e0bfff17 	ldw	r2,-4(fp)
 183c558:	10800217 	ldw	r2,8(r2)
 183c55c:	1009883a 	mov	r4,r2
 183c560:	181f8bc0 	call	181f8bc <tcp_output>
 183c564:	00000506 	br	183c57c <do_writemore+0x2bc>
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
 183c568:	00800044 	movi	r2,1
 183c56c:	e0bffb05 	stb	r2,-20(fp)
      conn->current_msg->msg.w.len = 0;
 183c570:	e0bfff17 	ldw	r2,-4(fp)
 183c574:	10800b17 	ldw	r2,44(r2)
 183c578:	10000315 	stw	zero,12(r2)
    }
  }
  if (write_finished) {
 183c57c:	e0bffb03 	ldbu	r2,-20(fp)
 183c580:	10000c26 	beq	r2,zero,183c5b4 <do_writemore+0x2f4>
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 183c584:	e0bfff17 	ldw	r2,-4(fp)
 183c588:	10800b17 	ldw	r2,44(r2)
 183c58c:	e0fffa03 	ldbu	r3,-24(fp)
 183c590:	10c00105 	stb	r3,4(r2)
    conn->current_msg = NULL;
 183c594:	e0bfff17 	ldw	r2,-4(fp)
 183c598:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
 183c59c:	e0bfff17 	ldw	r2,-4(fp)
 183c5a0:	10000115 	stw	zero,4(r2)
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 183c5a4:	e0bfff17 	ldw	r2,-4(fp)
 183c5a8:	10800404 	addi	r2,r2,16
 183c5ac:	1009883a 	mov	r4,r2
 183c5b0:	18150740 	call	1815074 <sys_sem_signal>
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
 183c5b4:	0005883a 	mov	r2,zero
}
 183c5b8:	e037883a 	mov	sp,fp
 183c5bc:	dfc00117 	ldw	ra,4(sp)
 183c5c0:	df000017 	ldw	fp,0(sp)
 183c5c4:	dec00204 	addi	sp,sp,8
 183c5c8:	f800283a 	ret

0183c5cc <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
 183c5cc:	defffd04 	addi	sp,sp,-12
 183c5d0:	dfc00215 	stw	ra,8(sp)
 183c5d4:	df000115 	stw	fp,4(sp)
 183c5d8:	df000104 	addi	fp,sp,4
 183c5dc:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 183c5e0:	e0bfff17 	ldw	r2,-4(fp)
 183c5e4:	10800017 	ldw	r2,0(r2)
 183c5e8:	10800303 	ldbu	r2,12(r2)
 183c5ec:	10803fcc 	andi	r2,r2,255
 183c5f0:	1080201c 	xori	r2,r2,128
 183c5f4:	10bfe004 	addi	r2,r2,-128
 183c5f8:	10bffdc8 	cmpgei	r2,r2,-9
 183c5fc:	1000061e 	bne	r2,zero,183c618 <do_write+0x4c>
    msg->err = msg->conn->last_err;
 183c600:	e0bfff17 	ldw	r2,-4(fp)
 183c604:	10800017 	ldw	r2,0(r2)
 183c608:	10c00303 	ldbu	r3,12(r2)
 183c60c:	e0bfff17 	ldw	r2,-4(fp)
 183c610:	10c00105 	stb	r3,4(r2)
 183c614:	00002806 	br	183c6b8 <do_write+0xec>
  } else {
    if (msg->conn->type == NETCONN_TCP) {
 183c618:	e0bfff17 	ldw	r2,-4(fp)
 183c61c:	10800017 	ldw	r2,0(r2)
 183c620:	10800017 	ldw	r2,0(r2)
 183c624:	10800418 	cmpnei	r2,r2,16
 183c628:	1000201e 	bne	r2,zero,183c6ac <do_write+0xe0>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
 183c62c:	e0bfff17 	ldw	r2,-4(fp)
 183c630:	10800017 	ldw	r2,0(r2)
 183c634:	10800117 	ldw	r2,4(r2)
 183c638:	10000426 	beq	r2,zero,183c64c <do_write+0x80>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
 183c63c:	e0bfff17 	ldw	r2,-4(fp)
 183c640:	00fffec4 	movi	r3,-5
 183c644:	10c00105 	stb	r3,4(r2)
 183c648:	00001b06 	br	183c6b8 <do_write+0xec>
      } else if (msg->conn->pcb.tcp != NULL) {
 183c64c:	e0bfff17 	ldw	r2,-4(fp)
 183c650:	10800017 	ldw	r2,0(r2)
 183c654:	10800217 	ldw	r2,8(r2)
 183c658:	10001026 	beq	r2,zero,183c69c <do_write+0xd0>
        msg->conn->state = NETCONN_WRITE;
 183c65c:	e0bfff17 	ldw	r2,-4(fp)
 183c660:	10800017 	ldw	r2,0(r2)
 183c664:	00c00044 	movi	r3,1
 183c668:	10c00115 	stw	r3,4(r2)
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
 183c66c:	e0bfff17 	ldw	r2,-4(fp)
 183c670:	10800017 	ldw	r2,0(r2)
 183c674:	e0ffff17 	ldw	r3,-4(fp)
 183c678:	10c00b15 	stw	r3,44(r2)
        msg->conn->write_offset = 0;
 183c67c:	e0bfff17 	ldw	r2,-4(fp)
 183c680:	10800017 	ldw	r2,0(r2)
 183c684:	10000a15 	stw	zero,40(r2)
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
 183c688:	e0bfff17 	ldw	r2,-4(fp)
 183c68c:	10800017 	ldw	r2,0(r2)
 183c690:	1009883a 	mov	r4,r2
 183c694:	183c2c00 	call	183c2c0 <do_writemore>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
 183c698:	00000c06 	br	183c6cc <do_write+0x100>
      } else {
        msg->err = ERR_CONN;
 183c69c:	e0bfff17 	ldw	r2,-4(fp)
 183c6a0:	00fffcc4 	movi	r3,-13
 183c6a4:	10c00105 	stb	r3,4(r2)
 183c6a8:	00000306 	br	183c6b8 <do_write+0xec>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
 183c6ac:	e0bfff17 	ldw	r2,-4(fp)
 183c6b0:	00fffe84 	movi	r3,-6
 183c6b4:	10c00105 	stb	r3,4(r2)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
 183c6b8:	e0bfff17 	ldw	r2,-4(fp)
 183c6bc:	10800017 	ldw	r2,0(r2)
 183c6c0:	10800404 	addi	r2,r2,16
 183c6c4:	1009883a 	mov	r4,r2
 183c6c8:	18150740 	call	1815074 <sys_sem_signal>
}
 183c6cc:	e037883a 	mov	sp,fp
 183c6d0:	dfc00117 	ldw	ra,4(sp)
 183c6d4:	df000017 	ldw	fp,0(sp)
 183c6d8:	dec00204 	addi	sp,sp,8
 183c6dc:	f800283a 	ret

0183c6e0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
 183c6e0:	defffd04 	addi	sp,sp,-12
 183c6e4:	dfc00215 	stw	ra,8(sp)
 183c6e8:	df000115 	stw	fp,4(sp)
 183c6ec:	df000104 	addi	fp,sp,4
 183c6f0:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.ip != NULL) {
 183c6f4:	e0bfff17 	ldw	r2,-4(fp)
 183c6f8:	10800017 	ldw	r2,0(r2)
 183c6fc:	10800217 	ldw	r2,8(r2)
 183c700:	10005f26 	beq	r2,zero,183c880 <do_getaddr+0x1a0>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 183c704:	e0bfff17 	ldw	r2,-4(fp)
 183c708:	10800217 	ldw	r2,8(r2)
 183c70c:	e0ffff17 	ldw	r3,-4(fp)
 183c710:	18c00403 	ldbu	r3,16(r3)
 183c714:	18c03fcc 	andi	r3,r3,255
 183c718:	18000626 	beq	r3,zero,183c734 <do_getaddr+0x54>
 183c71c:	e0ffff17 	ldw	r3,-4(fp)
 183c720:	18c00017 	ldw	r3,0(r3)
 183c724:	18c00217 	ldw	r3,8(r3)
 183c728:	18c00017 	ldw	r3,0(r3)
 183c72c:	10c00015 	stw	r3,0(r2)
 183c730:	00000506 	br	183c748 <do_getaddr+0x68>
                             msg->conn->pcb.ip->remote_ip);
 183c734:	e0ffff17 	ldw	r3,-4(fp)
 183c738:	18c00017 	ldw	r3,0(r3)
 183c73c:	18c00217 	ldw	r3,8(r3)
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.ip != NULL) {
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 183c740:	18c00117 	ldw	r3,4(r3)
 183c744:	10c00015 	stw	r3,0(r2)
                             msg->conn->pcb.ip->remote_ip);

    msg->err = ERR_OK;
 183c748:	e0bfff17 	ldw	r2,-4(fp)
 183c74c:	10000105 	stb	zero,4(r2)
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 183c750:	e0bfff17 	ldw	r2,-4(fp)
 183c754:	10800017 	ldw	r2,0(r2)
 183c758:	10800017 	ldw	r2,0(r2)
 183c75c:	10803c0c 	andi	r2,r2,240
 183c760:	10c00820 	cmpeqi	r3,r2,32
 183c764:	1800161e 	bne	r3,zero,183c7c0 <do_getaddr+0xe0>
 183c768:	10c01020 	cmpeqi	r3,r2,64
 183c76c:	1800031e 	bne	r3,zero,183c77c <do_getaddr+0x9c>
 183c770:	10800420 	cmpeqi	r2,r2,16
 183c774:	1000311e 	bne	r2,zero,183c83c <do_getaddr+0x15c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
      break;
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
 183c778:	00004406 	br	183c88c <do_getaddr+0x1ac>

    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
 183c77c:	e0bfff17 	ldw	r2,-4(fp)
 183c780:	10800403 	ldbu	r2,16(r2)
 183c784:	10803fcc 	andi	r2,r2,255
 183c788:	10000926 	beq	r2,zero,183c7b0 <do_getaddr+0xd0>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
 183c78c:	e0bfff17 	ldw	r2,-4(fp)
 183c790:	10800317 	ldw	r2,12(r2)
 183c794:	e0ffff17 	ldw	r3,-4(fp)
 183c798:	18c00017 	ldw	r3,0(r3)
 183c79c:	18c00217 	ldw	r3,8(r3)
 183c7a0:	18c00403 	ldbu	r3,16(r3)
 183c7a4:	18c03fcc 	andi	r3,r3,255
 183c7a8:	10c0000d 	sth	r3,0(r2)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
      }
      break;
 183c7ac:	00003706 	br	183c88c <do_getaddr+0x1ac>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
 183c7b0:	e0bfff17 	ldw	r2,-4(fp)
 183c7b4:	00fffcc4 	movi	r3,-13
 183c7b8:	10c00105 	stb	r3,4(r2)
      }
      break;
 183c7bc:	00003306 	br	183c88c <do_getaddr+0x1ac>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
 183c7c0:	e0bfff17 	ldw	r2,-4(fp)
 183c7c4:	10800403 	ldbu	r2,16(r2)
 183c7c8:	10803fcc 	andi	r2,r2,255
 183c7cc:	10000826 	beq	r2,zero,183c7f0 <do_getaddr+0x110>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
 183c7d0:	e0bfff17 	ldw	r2,-4(fp)
 183c7d4:	10800317 	ldw	r2,12(r2)
 183c7d8:	e0ffff17 	ldw	r3,-4(fp)
 183c7dc:	18c00017 	ldw	r3,0(r3)
 183c7e0:	18c00217 	ldw	r3,8(r3)
 183c7e4:	18c0048b 	ldhu	r3,18(r3)
 183c7e8:	10c0000d 	sth	r3,0(r2)
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
 183c7ec:	00002706 	br	183c88c <do_getaddr+0x1ac>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
 183c7f0:	e0bfff17 	ldw	r2,-4(fp)
 183c7f4:	10800017 	ldw	r2,0(r2)
 183c7f8:	10800217 	ldw	r2,8(r2)
 183c7fc:	10800403 	ldbu	r2,16(r2)
 183c800:	10803fcc 	andi	r2,r2,255
 183c804:	1080010c 	andi	r2,r2,4
 183c808:	1000041e 	bne	r2,zero,183c81c <do_getaddr+0x13c>
          msg->err = ERR_CONN;
 183c80c:	e0bfff17 	ldw	r2,-4(fp)
 183c810:	00fffcc4 	movi	r3,-13
 183c814:	10c00105 	stb	r3,4(r2)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
 183c818:	00001c06 	br	183c88c <do_getaddr+0x1ac>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 183c81c:	e0bfff17 	ldw	r2,-4(fp)
 183c820:	10800317 	ldw	r2,12(r2)
 183c824:	e0ffff17 	ldw	r3,-4(fp)
 183c828:	18c00017 	ldw	r3,0(r3)
 183c82c:	18c00217 	ldw	r3,8(r3)
 183c830:	18c0050b 	ldhu	r3,20(r3)
 183c834:	10c0000d 	sth	r3,0(r2)
        }
      }
      break;
 183c838:	00001406 	br	183c88c <do_getaddr+0x1ac>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
 183c83c:	e0bfff17 	ldw	r2,-4(fp)
 183c840:	10c00317 	ldw	r3,12(r2)
 183c844:	e0bfff17 	ldw	r2,-4(fp)
 183c848:	10800403 	ldbu	r2,16(r2)
 183c84c:	10803fcc 	andi	r2,r2,255
 183c850:	10000526 	beq	r2,zero,183c868 <do_getaddr+0x188>
 183c854:	e0bfff17 	ldw	r2,-4(fp)
 183c858:	10800017 	ldw	r2,0(r2)
 183c85c:	10800217 	ldw	r2,8(r2)
 183c860:	1080078b 	ldhu	r2,30(r2)
 183c864:	00000406 	br	183c878 <do_getaddr+0x198>
 183c868:	e0bfff17 	ldw	r2,-4(fp)
 183c86c:	10800017 	ldw	r2,0(r2)
 183c870:	10800217 	ldw	r2,8(r2)
 183c874:	1080080b 	ldhu	r2,32(r2)
 183c878:	1880000d 	sth	r2,0(r3)
      break;
 183c87c:	00000306 	br	183c88c <do_getaddr+0x1ac>
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
    }
  } else {
    msg->err = ERR_CONN;
 183c880:	e0bfff17 	ldw	r2,-4(fp)
 183c884:	00fffcc4 	movi	r3,-13
 183c888:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 183c88c:	e0bfff17 	ldw	r2,-4(fp)
 183c890:	10800017 	ldw	r2,0(r2)
 183c894:	10800404 	addi	r2,r2,16
 183c898:	1009883a 	mov	r4,r2
 183c89c:	18150740 	call	1815074 <sys_sem_signal>
}
 183c8a0:	0001883a 	nop
 183c8a4:	e037883a 	mov	sp,fp
 183c8a8:	dfc00117 	ldw	ra,4(sp)
 183c8ac:	df000017 	ldw	fp,0(sp)
 183c8b0:	dec00204 	addi	sp,sp,8
 183c8b4:	f800283a 	ret

0183c8b8 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
 183c8b8:	defffd04 	addi	sp,sp,-12
 183c8bc:	dfc00215 	stw	ra,8(sp)
 183c8c0:	df000115 	stw	fp,4(sp)
 183c8c4:	df000104 	addi	fp,sp,4
 183c8c8:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
 183c8cc:	e0bfff17 	ldw	r2,-4(fp)
 183c8d0:	10800017 	ldw	r2,0(r2)
 183c8d4:	10800117 	ldw	r2,4(r2)
 183c8d8:	10000926 	beq	r2,zero,183c900 <do_close+0x48>
 183c8dc:	e0bfff17 	ldw	r2,-4(fp)
 183c8e0:	10800017 	ldw	r2,0(r2)
 183c8e4:	10800117 	ldw	r2,4(r2)
 183c8e8:	108000a0 	cmpeqi	r2,r2,2
 183c8ec:	1000041e 	bne	r2,zero,183c900 <do_close+0x48>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
 183c8f0:	e0bfff17 	ldw	r2,-4(fp)
 183c8f4:	00fffec4 	movi	r3,-5
 183c8f8:	10c00105 	stb	r3,4(r2)
 183c8fc:	00003006 	br	183c9c0 <do_close+0x108>
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
 183c900:	e0bfff17 	ldw	r2,-4(fp)
 183c904:	10800017 	ldw	r2,0(r2)
 183c908:	10800217 	ldw	r2,8(r2)
 183c90c:	10002926 	beq	r2,zero,183c9b4 <do_close+0xfc>
 183c910:	e0bfff17 	ldw	r2,-4(fp)
 183c914:	10800017 	ldw	r2,0(r2)
 183c918:	10800017 	ldw	r2,0(r2)
 183c91c:	10800418 	cmpnei	r2,r2,16
 183c920:	1000241e 	bne	r2,zero,183c9b4 <do_close+0xfc>
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 183c924:	e0bfff17 	ldw	r2,-4(fp)
 183c928:	10800203 	ldbu	r2,8(r2)
 183c92c:	10803fcc 	andi	r2,r2,255
 183c930:	108000e0 	cmpeqi	r2,r2,3
 183c934:	1000091e 	bne	r2,zero,183c95c <do_close+0xa4>
 183c938:	e0bfff17 	ldw	r2,-4(fp)
 183c93c:	10800017 	ldw	r2,0(r2)
 183c940:	10800117 	ldw	r2,4(r2)
 183c944:	10800098 	cmpnei	r2,r2,2
 183c948:	1000041e 	bne	r2,zero,183c95c <do_close+0xa4>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
 183c94c:	e0bfff17 	ldw	r2,-4(fp)
 183c950:	00fffcc4 	movi	r3,-13
 183c954:	10c00105 	stb	r3,4(r2)
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 183c958:	00001906 	br	183c9c0 <do_close+0x108>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 183c95c:	e0bfff17 	ldw	r2,-4(fp)
 183c960:	10800203 	ldbu	r2,8(r2)
 183c964:	10803fcc 	andi	r2,r2,255
 183c968:	1080004c 	andi	r2,r2,1
 183c96c:	10000426 	beq	r2,zero,183c980 <do_close+0xc8>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
 183c970:	e0bfff17 	ldw	r2,-4(fp)
 183c974:	10800017 	ldw	r2,0(r2)
 183c978:	1009883a 	mov	r4,r2
 183c97c:	183b20c0 	call	183b20c <netconn_drain>
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
 183c980:	e0bfff17 	ldw	r2,-4(fp)
 183c984:	10800017 	ldw	r2,0(r2)
 183c988:	00c00104 	movi	r3,4
 183c98c:	10c00115 	stw	r3,4(r2)
      msg->conn->current_msg = msg;
 183c990:	e0bfff17 	ldw	r2,-4(fp)
 183c994:	10800017 	ldw	r2,0(r2)
 183c998:	e0ffff17 	ldw	r3,-4(fp)
 183c99c:	10c00b15 	stw	r3,44(r2)
      do_close_internal(msg->conn);
 183c9a0:	e0bfff17 	ldw	r2,-4(fp)
 183c9a4:	10800017 	ldw	r2,0(r2)
 183c9a8:	1009883a 	mov	r4,r2
 183c9ac:	183b3880 	call	183b388 <do_close_internal>
      /* for tcp netconns, do_close_internal ACKs the message */
      return;
 183c9b0:	00000806 	br	183c9d4 <do_close+0x11c>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
 183c9b4:	e0bfff17 	ldw	r2,-4(fp)
 183c9b8:	00fffe84 	movi	r3,-6
 183c9bc:	10c00105 	stb	r3,4(r2)
  }
  sys_sem_signal(&msg->conn->op_completed);
 183c9c0:	e0bfff17 	ldw	r2,-4(fp)
 183c9c4:	10800017 	ldw	r2,0(r2)
 183c9c8:	10800404 	addi	r2,r2,16
 183c9cc:	1009883a 	mov	r4,r2
 183c9d0:	18150740 	call	1815074 <sys_sem_signal>
}
 183c9d4:	e037883a 	mov	sp,fp
 183c9d8:	dfc00117 	ldw	ra,4(sp)
 183c9dc:	df000017 	ldw	fp,0(sp)
 183c9e0:	dec00204 	addi	sp,sp,8
 183c9e4:	f800283a 	ret

0183c9e8 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
 183c9e8:	defffd04 	addi	sp,sp,-12
 183c9ec:	dfc00215 	stw	ra,8(sp)
 183c9f0:	df000115 	stw	fp,4(sp)
 183c9f4:	df000104 	addi	fp,sp,4
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 183c9f8:	010001c4 	movi	r4,7
 183c9fc:	18349580 	call	1834958 <memp_malloc>
 183ca00:	e0bfff15 	stw	r2,-4(fp)
  if (buf != NULL) {
 183ca04:	e0bfff17 	ldw	r2,-4(fp)
 183ca08:	10000e26 	beq	r2,zero,183ca44 <netbuf_new+0x5c>
    buf->p = NULL;
 183ca0c:	e0bfff17 	ldw	r2,-4(fp)
 183ca10:	10000015 	stw	zero,0(r2)
    buf->ptr = NULL;
 183ca14:	e0bfff17 	ldw	r2,-4(fp)
 183ca18:	10000115 	stw	zero,4(r2)
    ip_addr_set_any(&buf->addr);
 183ca1c:	e0bfff17 	ldw	r2,-4(fp)
 183ca20:	10000215 	stw	zero,8(r2)
    buf->port = 0;
 183ca24:	e0bfff17 	ldw	r2,-4(fp)
 183ca28:	1000030d 	sth	zero,12(r2)
#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
#if LWIP_CHECKSUM_ON_COPY
    buf->flags = 0;
 183ca2c:	e0bfff17 	ldw	r2,-4(fp)
 183ca30:	10000385 	stb	zero,14(r2)
#endif /* LWIP_CHECKSUM_ON_COPY */
    buf->toport_chksum = 0;
 183ca34:	e0bfff17 	ldw	r2,-4(fp)
 183ca38:	1000040d 	sth	zero,16(r2)
#if LWIP_NETBUF_RECVINFO
    ip_addr_set_any(&buf->toaddr);
#endif /* LWIP_NETBUF_RECVINFO */
#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
    return buf;
 183ca3c:	e0bfff17 	ldw	r2,-4(fp)
 183ca40:	00000106 	br	183ca48 <netbuf_new+0x60>
  } else {
    return NULL;
 183ca44:	0005883a 	mov	r2,zero
  }
}
 183ca48:	e037883a 	mov	sp,fp
 183ca4c:	dfc00117 	ldw	ra,4(sp)
 183ca50:	df000017 	ldw	fp,0(sp)
 183ca54:	dec00204 	addi	sp,sp,8
 183ca58:	f800283a 	ret

0183ca5c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 183ca5c:	defffd04 	addi	sp,sp,-12
 183ca60:	dfc00215 	stw	ra,8(sp)
 183ca64:	df000115 	stw	fp,4(sp)
 183ca68:	df000104 	addi	fp,sp,4
 183ca6c:	e13fff15 	stw	r4,-4(fp)
  if (buf != NULL) {
 183ca70:	e0bfff17 	ldw	r2,-4(fp)
 183ca74:	10001026 	beq	r2,zero,183cab8 <netbuf_delete+0x5c>
    if (buf->p != NULL) {
 183ca78:	e0bfff17 	ldw	r2,-4(fp)
 183ca7c:	10800017 	ldw	r2,0(r2)
 183ca80:	10000a26 	beq	r2,zero,183caac <netbuf_delete+0x50>
      pbuf_free(buf->p);
 183ca84:	e0bfff17 	ldw	r2,-4(fp)
 183ca88:	10800017 	ldw	r2,0(r2)
 183ca8c:	1009883a 	mov	r4,r2
 183ca90:	181aca40 	call	181aca4 <pbuf_free>
      buf->p = buf->ptr = NULL;
 183ca94:	e0bfff17 	ldw	r2,-4(fp)
 183ca98:	10000115 	stw	zero,4(r2)
 183ca9c:	e0bfff17 	ldw	r2,-4(fp)
 183caa0:	10c00117 	ldw	r3,4(r2)
 183caa4:	e0bfff17 	ldw	r2,-4(fp)
 183caa8:	10c00015 	stw	r3,0(r2)
    }
    memp_free(MEMP_NETBUF, buf);
 183caac:	e17fff17 	ldw	r5,-4(fp)
 183cab0:	010001c4 	movi	r4,7
 183cab4:	1834b240 	call	1834b24 <memp_free>
  }
}
 183cab8:	0001883a 	nop
 183cabc:	e037883a 	mov	sp,fp
 183cac0:	dfc00117 	ldw	ra,4(sp)
 183cac4:	df000017 	ldw	fp,0(sp)
 183cac8:	dec00204 	addi	sp,sp,8
 183cacc:	f800283a 	ret

0183cad0 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
 183cad0:	defffc04 	addi	sp,sp,-16
 183cad4:	dfc00315 	stw	ra,12(sp)
 183cad8:	df000215 	stw	fp,8(sp)
 183cadc:	df000204 	addi	fp,sp,8
 183cae0:	e13ffe15 	stw	r4,-8(fp)
 183cae4:	2805883a 	mov	r2,r5
 183cae8:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
 183caec:	e0bffe17 	ldw	r2,-8(fp)
 183caf0:	1000091e 	bne	r2,zero,183cb18 <netbuf_alloc+0x48>
 183caf4:	01c06134 	movhi	r7,388
 183caf8:	39cf7104 	addi	r7,r7,15812
 183cafc:	01801b44 	movi	r6,109
 183cb00:	01406134 	movhi	r5,388
 183cb04:	294f7704 	addi	r5,r5,15836
 183cb08:	01006134 	movhi	r4,388
 183cb0c:	210f7e04 	addi	r4,r4,15864
 183cb10:	1800c180 	call	1800c18 <printf>
 183cb14:	003fff06 	br	183cb14 <__ram_exceptions_end+0xff82c6d0>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
 183cb18:	e0bffe17 	ldw	r2,-8(fp)
 183cb1c:	10800017 	ldw	r2,0(r2)
 183cb20:	10000426 	beq	r2,zero,183cb34 <netbuf_alloc+0x64>
    pbuf_free(buf->p);
 183cb24:	e0bffe17 	ldw	r2,-8(fp)
 183cb28:	10800017 	ldw	r2,0(r2)
 183cb2c:	1009883a 	mov	r4,r2
 183cb30:	181aca40 	call	181aca4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
 183cb34:	e0bfff0b 	ldhu	r2,-4(fp)
 183cb38:	000d883a 	mov	r6,zero
 183cb3c:	100b883a 	mov	r5,r2
 183cb40:	0009883a 	mov	r4,zero
 183cb44:	181a4e80 	call	181a4e8 <pbuf_alloc>
 183cb48:	1007883a 	mov	r3,r2
 183cb4c:	e0bffe17 	ldw	r2,-8(fp)
 183cb50:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 183cb54:	e0bffe17 	ldw	r2,-8(fp)
 183cb58:	10800017 	ldw	r2,0(r2)
 183cb5c:	1000021e 	bne	r2,zero,183cb68 <netbuf_alloc+0x98>
     return NULL;
 183cb60:	0005883a 	mov	r2,zero
 183cb64:	00000706 	br	183cb84 <netbuf_alloc+0xb4>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
 183cb68:	e0bffe17 	ldw	r2,-8(fp)
 183cb6c:	10c00017 	ldw	r3,0(r2)
 183cb70:	e0bffe17 	ldw	r2,-8(fp)
 183cb74:	10c00115 	stw	r3,4(r2)
  return buf->p->payload;
 183cb78:	e0bffe17 	ldw	r2,-8(fp)
 183cb7c:	10800017 	ldw	r2,0(r2)
 183cb80:	10800117 	ldw	r2,4(r2)
}
 183cb84:	e037883a 	mov	sp,fp
 183cb88:	dfc00117 	ldw	ra,4(sp)
 183cb8c:	df000017 	ldw	fp,0(sp)
 183cb90:	dec00204 	addi	sp,sp,8
 183cb94:	f800283a 	ret

0183cb98 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 183cb98:	defffd04 	addi	sp,sp,-12
 183cb9c:	dfc00215 	stw	ra,8(sp)
 183cba0:	df000115 	stw	fp,4(sp)
 183cba4:	df000104 	addi	fp,sp,4
 183cba8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 183cbac:	e0bfff17 	ldw	r2,-4(fp)
 183cbb0:	1000091e 	bne	r2,zero,183cbd8 <netbuf_free+0x40>
 183cbb4:	01c06134 	movhi	r7,388
 183cbb8:	39cf7104 	addi	r7,r7,15812
 183cbbc:	01802144 	movi	r6,133
 183cbc0:	01406134 	movhi	r5,388
 183cbc4:	294f8a04 	addi	r5,r5,15912
 183cbc8:	01006134 	movhi	r4,388
 183cbcc:	210f7e04 	addi	r4,r4,15864
 183cbd0:	1800c180 	call	1800c18 <printf>
 183cbd4:	003fff06 	br	183cbd4 <__ram_exceptions_end+0xff82c790>
  if (buf->p != NULL) {
 183cbd8:	e0bfff17 	ldw	r2,-4(fp)
 183cbdc:	10800017 	ldw	r2,0(r2)
 183cbe0:	10000426 	beq	r2,zero,183cbf4 <netbuf_free+0x5c>
    pbuf_free(buf->p);
 183cbe4:	e0bfff17 	ldw	r2,-4(fp)
 183cbe8:	10800017 	ldw	r2,0(r2)
 183cbec:	1009883a 	mov	r4,r2
 183cbf0:	181aca40 	call	181aca4 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
 183cbf4:	e0bfff17 	ldw	r2,-4(fp)
 183cbf8:	10000115 	stw	zero,4(r2)
 183cbfc:	e0bfff17 	ldw	r2,-4(fp)
 183cc00:	10c00117 	ldw	r3,4(r2)
 183cc04:	e0bfff17 	ldw	r2,-4(fp)
 183cc08:	10c00015 	stw	r3,0(r2)
}
 183cc0c:	0001883a 	nop
 183cc10:	e037883a 	mov	sp,fp
 183cc14:	dfc00117 	ldw	ra,4(sp)
 183cc18:	df000017 	ldw	fp,0(sp)
 183cc1c:	dec00204 	addi	sp,sp,8
 183cc20:	f800283a 	ret

0183cc24 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 183cc24:	defffb04 	addi	sp,sp,-20
 183cc28:	dfc00415 	stw	ra,16(sp)
 183cc2c:	df000315 	stw	fp,12(sp)
 183cc30:	df000304 	addi	fp,sp,12
 183cc34:	e13ffd15 	stw	r4,-12(fp)
 183cc38:	e17ffe15 	stw	r5,-8(fp)
 183cc3c:	3005883a 	mov	r2,r6
 183cc40:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 183cc44:	e0bffd17 	ldw	r2,-12(fp)
 183cc48:	1000091e 	bne	r2,zero,183cc70 <netbuf_ref+0x4c>
 183cc4c:	01c06134 	movhi	r7,388
 183cc50:	39cf7104 	addi	r7,r7,15812
 183cc54:	01802604 	movi	r6,152
 183cc58:	01406134 	movhi	r5,388
 183cc5c:	294f9104 	addi	r5,r5,15940
 183cc60:	01006134 	movhi	r4,388
 183cc64:	210f7e04 	addi	r4,r4,15864
 183cc68:	1800c180 	call	1800c18 <printf>
 183cc6c:	003fff06 	br	183cc6c <__ram_exceptions_end+0xff82c828>
  if (buf->p != NULL) {
 183cc70:	e0bffd17 	ldw	r2,-12(fp)
 183cc74:	10800017 	ldw	r2,0(r2)
 183cc78:	10000426 	beq	r2,zero,183cc8c <netbuf_ref+0x68>
    pbuf_free(buf->p);
 183cc7c:	e0bffd17 	ldw	r2,-12(fp)
 183cc80:	10800017 	ldw	r2,0(r2)
 183cc84:	1009883a 	mov	r4,r2
 183cc88:	181aca40 	call	181aca4 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 183cc8c:	01800084 	movi	r6,2
 183cc90:	000b883a 	mov	r5,zero
 183cc94:	0009883a 	mov	r4,zero
 183cc98:	181a4e80 	call	181a4e8 <pbuf_alloc>
 183cc9c:	1007883a 	mov	r3,r2
 183cca0:	e0bffd17 	ldw	r2,-12(fp)
 183cca4:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 183cca8:	e0bffd17 	ldw	r2,-12(fp)
 183ccac:	10800017 	ldw	r2,0(r2)
 183ccb0:	1000041e 	bne	r2,zero,183ccc4 <netbuf_ref+0xa0>
    buf->ptr = NULL;
 183ccb4:	e0bffd17 	ldw	r2,-12(fp)
 183ccb8:	10000115 	stw	zero,4(r2)
    return ERR_MEM;
 183ccbc:	00bfffc4 	movi	r2,-1
 183ccc0:	00001106 	br	183cd08 <netbuf_ref+0xe4>
  }
  buf->p->payload = (void*)dataptr;
 183ccc4:	e0bffd17 	ldw	r2,-12(fp)
 183ccc8:	10800017 	ldw	r2,0(r2)
 183cccc:	e0fffe17 	ldw	r3,-8(fp)
 183ccd0:	10c00115 	stw	r3,4(r2)
  buf->p->len = buf->p->tot_len = size;
 183ccd4:	e0bffd17 	ldw	r2,-12(fp)
 183ccd8:	10c00017 	ldw	r3,0(r2)
 183ccdc:	e0bffd17 	ldw	r2,-12(fp)
 183cce0:	10800017 	ldw	r2,0(r2)
 183cce4:	e13fff0b 	ldhu	r4,-4(fp)
 183cce8:	1100020d 	sth	r4,8(r2)
 183ccec:	1080020b 	ldhu	r2,8(r2)
 183ccf0:	1880028d 	sth	r2,10(r3)
  buf->ptr = buf->p;
 183ccf4:	e0bffd17 	ldw	r2,-12(fp)
 183ccf8:	10c00017 	ldw	r3,0(r2)
 183ccfc:	e0bffd17 	ldw	r2,-12(fp)
 183cd00:	10c00115 	stw	r3,4(r2)
  return ERR_OK;
 183cd04:	0005883a 	mov	r2,zero
}
 183cd08:	e037883a 	mov	sp,fp
 183cd0c:	dfc00117 	ldw	ra,4(sp)
 183cd10:	df000017 	ldw	fp,0(sp)
 183cd14:	dec00204 	addi	sp,sp,8
 183cd18:	f800283a 	ret

0183cd1c <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
 183cd1c:	defffc04 	addi	sp,sp,-16
 183cd20:	dfc00315 	stw	ra,12(sp)
 183cd24:	df000215 	stw	fp,8(sp)
 183cd28:	df000204 	addi	fp,sp,8
 183cd2c:	e13ffe15 	stw	r4,-8(fp)
 183cd30:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
 183cd34:	e0bffe17 	ldw	r2,-8(fp)
 183cd38:	1000091e 	bne	r2,zero,183cd60 <netbuf_chain+0x44>
 183cd3c:	01c06134 	movhi	r7,388
 183cd40:	39cf7104 	addi	r7,r7,15812
 183cd44:	01802c04 	movi	r6,176
 183cd48:	01406134 	movhi	r5,388
 183cd4c:	294f9704 	addi	r5,r5,15964
 183cd50:	01006134 	movhi	r4,388
 183cd54:	210f7e04 	addi	r4,r4,15864
 183cd58:	1800c180 	call	1800c18 <printf>
 183cd5c:	003fff06 	br	183cd5c <__ram_exceptions_end+0xff82c918>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 183cd60:	e0bfff17 	ldw	r2,-4(fp)
 183cd64:	1000091e 	bne	r2,zero,183cd8c <netbuf_chain+0x70>
 183cd68:	01c06134 	movhi	r7,388
 183cd6c:	39cf7104 	addi	r7,r7,15812
 183cd70:	01802c44 	movi	r6,177
 183cd74:	01406134 	movhi	r5,388
 183cd78:	294f9e04 	addi	r5,r5,15992
 183cd7c:	01006134 	movhi	r4,388
 183cd80:	210f7e04 	addi	r4,r4,15864
 183cd84:	1800c180 	call	1800c18 <printf>
 183cd88:	003fff06 	br	183cd88 <__ram_exceptions_end+0xff82c944>
  pbuf_cat(head->p, tail->p);
 183cd8c:	e0bffe17 	ldw	r2,-8(fp)
 183cd90:	10c00017 	ldw	r3,0(r2)
 183cd94:	e0bfff17 	ldw	r2,-4(fp)
 183cd98:	10800017 	ldw	r2,0(r2)
 183cd9c:	100b883a 	mov	r5,r2
 183cda0:	1809883a 	mov	r4,r3
 183cda4:	181ae980 	call	181ae98 <pbuf_cat>
  head->ptr = head->p;
 183cda8:	e0bffe17 	ldw	r2,-8(fp)
 183cdac:	10c00017 	ldw	r3,0(r2)
 183cdb0:	e0bffe17 	ldw	r2,-8(fp)
 183cdb4:	10c00115 	stw	r3,4(r2)
  memp_free(MEMP_NETBUF, tail);
 183cdb8:	e17fff17 	ldw	r5,-4(fp)
 183cdbc:	010001c4 	movi	r4,7
 183cdc0:	1834b240 	call	1834b24 <memp_free>
}
 183cdc4:	0001883a 	nop
 183cdc8:	e037883a 	mov	sp,fp
 183cdcc:	dfc00117 	ldw	ra,4(sp)
 183cdd0:	df000017 	ldw	fp,0(sp)
 183cdd4:	dec00204 	addi	sp,sp,8
 183cdd8:	f800283a 	ret

0183cddc <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 183cddc:	defffb04 	addi	sp,sp,-20
 183cde0:	dfc00415 	stw	ra,16(sp)
 183cde4:	df000315 	stw	fp,12(sp)
 183cde8:	df000304 	addi	fp,sp,12
 183cdec:	e13ffd15 	stw	r4,-12(fp)
 183cdf0:	e17ffe15 	stw	r5,-8(fp)
 183cdf4:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 183cdf8:	e0bffd17 	ldw	r2,-12(fp)
 183cdfc:	1000091e 	bne	r2,zero,183ce24 <netbuf_data+0x48>
 183ce00:	01c06134 	movhi	r7,388
 183ce04:	39cf7104 	addi	r7,r7,15812
 183ce08:	018030c4 	movi	r6,195
 183ce0c:	01406134 	movhi	r5,388
 183ce10:	294fa504 	addi	r5,r5,16020
 183ce14:	01006134 	movhi	r4,388
 183ce18:	210f7e04 	addi	r4,r4,15864
 183ce1c:	1800c180 	call	1800c18 <printf>
 183ce20:	003fff06 	br	183ce20 <__ram_exceptions_end+0xff82c9dc>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 183ce24:	e0bffe17 	ldw	r2,-8(fp)
 183ce28:	1000091e 	bne	r2,zero,183ce50 <netbuf_data+0x74>
 183ce2c:	01c06134 	movhi	r7,388
 183ce30:	39cf7104 	addi	r7,r7,15812
 183ce34:	01803104 	movi	r6,196
 183ce38:	01406134 	movhi	r5,388
 183ce3c:	294fac04 	addi	r5,r5,16048
 183ce40:	01006134 	movhi	r4,388
 183ce44:	210f7e04 	addi	r4,r4,15864
 183ce48:	1800c180 	call	1800c18 <printf>
 183ce4c:	003fff06 	br	183ce4c <__ram_exceptions_end+0xff82ca08>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 183ce50:	e0bfff17 	ldw	r2,-4(fp)
 183ce54:	1000091e 	bne	r2,zero,183ce7c <netbuf_data+0xa0>
 183ce58:	01c06134 	movhi	r7,388
 183ce5c:	39cf7104 	addi	r7,r7,15812
 183ce60:	01803144 	movi	r6,197
 183ce64:	01406134 	movhi	r5,388
 183ce68:	294fb404 	addi	r5,r5,16080
 183ce6c:	01006134 	movhi	r4,388
 183ce70:	210f7e04 	addi	r4,r4,15864
 183ce74:	1800c180 	call	1800c18 <printf>
 183ce78:	003fff06 	br	183ce78 <__ram_exceptions_end+0xff82ca34>

  if (buf->ptr == NULL) {
 183ce7c:	e0bffd17 	ldw	r2,-12(fp)
 183ce80:	10800117 	ldw	r2,4(r2)
 183ce84:	1000021e 	bne	r2,zero,183ce90 <netbuf_data+0xb4>
    return ERR_BUF;
 183ce88:	00bfff84 	movi	r2,-2
 183ce8c:	00000b06 	br	183cebc <netbuf_data+0xe0>
  }
  *dataptr = buf->ptr->payload;
 183ce90:	e0bffd17 	ldw	r2,-12(fp)
 183ce94:	10800117 	ldw	r2,4(r2)
 183ce98:	10c00117 	ldw	r3,4(r2)
 183ce9c:	e0bffe17 	ldw	r2,-8(fp)
 183cea0:	10c00015 	stw	r3,0(r2)
  *len = buf->ptr->len;
 183cea4:	e0bffd17 	ldw	r2,-12(fp)
 183cea8:	10800117 	ldw	r2,4(r2)
 183ceac:	10c0028b 	ldhu	r3,10(r2)
 183ceb0:	e0bfff17 	ldw	r2,-4(fp)
 183ceb4:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 183ceb8:	0005883a 	mov	r2,zero
}
 183cebc:	e037883a 	mov	sp,fp
 183cec0:	dfc00117 	ldw	ra,4(sp)
 183cec4:	df000017 	ldw	fp,0(sp)
 183cec8:	dec00204 	addi	sp,sp,8
 183cecc:	f800283a 	ret

0183ced0 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
 183ced0:	defffd04 	addi	sp,sp,-12
 183ced4:	dfc00215 	stw	ra,8(sp)
 183ced8:	df000115 	stw	fp,4(sp)
 183cedc:	df000104 	addi	fp,sp,4
 183cee0:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 183cee4:	e0bfff17 	ldw	r2,-4(fp)
 183cee8:	1000091e 	bne	r2,zero,183cf10 <netbuf_next+0x40>
 183ceec:	01c06134 	movhi	r7,388
 183cef0:	39cf7104 	addi	r7,r7,15812
 183cef4:	01803704 	movi	r6,220
 183cef8:	01406134 	movhi	r5,388
 183cefc:	294f8a04 	addi	r5,r5,15912
 183cf00:	01006134 	movhi	r4,388
 183cf04:	210f7e04 	addi	r4,r4,15864
 183cf08:	1800c180 	call	1800c18 <printf>
 183cf0c:	003fff06 	br	183cf0c <__ram_exceptions_end+0xff82cac8>
  if (buf->ptr->next == NULL) {
 183cf10:	e0bfff17 	ldw	r2,-4(fp)
 183cf14:	10800117 	ldw	r2,4(r2)
 183cf18:	10800017 	ldw	r2,0(r2)
 183cf1c:	1000021e 	bne	r2,zero,183cf28 <netbuf_next+0x58>
    return -1;
 183cf20:	00bfffc4 	movi	r2,-1
 183cf24:	00000c06 	br	183cf58 <netbuf_next+0x88>
  }
  buf->ptr = buf->ptr->next;
 183cf28:	e0bfff17 	ldw	r2,-4(fp)
 183cf2c:	10800117 	ldw	r2,4(r2)
 183cf30:	10c00017 	ldw	r3,0(r2)
 183cf34:	e0bfff17 	ldw	r2,-4(fp)
 183cf38:	10c00115 	stw	r3,4(r2)
  if (buf->ptr->next == NULL) {
 183cf3c:	e0bfff17 	ldw	r2,-4(fp)
 183cf40:	10800117 	ldw	r2,4(r2)
 183cf44:	10800017 	ldw	r2,0(r2)
 183cf48:	1000021e 	bne	r2,zero,183cf54 <netbuf_next+0x84>
    return 1;
 183cf4c:	00800044 	movi	r2,1
 183cf50:	00000106 	br	183cf58 <netbuf_next+0x88>
  }
  return 0;
 183cf54:	0005883a 	mov	r2,zero
}
 183cf58:	e037883a 	mov	sp,fp
 183cf5c:	dfc00117 	ldw	ra,4(sp)
 183cf60:	df000017 	ldw	fp,0(sp)
 183cf64:	dec00204 	addi	sp,sp,8
 183cf68:	f800283a 	ret

0183cf6c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
 183cf6c:	defffd04 	addi	sp,sp,-12
 183cf70:	dfc00215 	stw	ra,8(sp)
 183cf74:	df000115 	stw	fp,4(sp)
 183cf78:	df000104 	addi	fp,sp,4
 183cf7c:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 183cf80:	e0bfff17 	ldw	r2,-4(fp)
 183cf84:	1000091e 	bne	r2,zero,183cfac <netbuf_first+0x40>
 183cf88:	01c06134 	movhi	r7,388
 183cf8c:	39cf7104 	addi	r7,r7,15812
 183cf90:	01803c44 	movi	r6,241
 183cf94:	01406134 	movhi	r5,388
 183cf98:	294f8a04 	addi	r5,r5,15912
 183cf9c:	01006134 	movhi	r4,388
 183cfa0:	210f7e04 	addi	r4,r4,15864
 183cfa4:	1800c180 	call	1800c18 <printf>
 183cfa8:	003fff06 	br	183cfa8 <__ram_exceptions_end+0xff82cb64>
  buf->ptr = buf->p;
 183cfac:	e0bfff17 	ldw	r2,-4(fp)
 183cfb0:	10c00017 	ldw	r3,0(r2)
 183cfb4:	e0bfff17 	ldw	r2,-4(fp)
 183cfb8:	10c00115 	stw	r3,4(r2)
}
 183cfbc:	0001883a 	nop
 183cfc0:	e037883a 	mov	sp,fp
 183cfc4:	dfc00117 	ldw	ra,4(sp)
 183cfc8:	df000017 	ldw	fp,0(sp)
 183cfcc:	dec00204 	addi	sp,sp,8
 183cfd0:	f800283a 	ret

0183cfd4 <atexit>:
 183cfd4:	200b883a 	mov	r5,r4
 183cfd8:	000f883a 	mov	r7,zero
 183cfdc:	000d883a 	mov	r6,zero
 183cfe0:	0009883a 	mov	r4,zero
 183cfe4:	183f7341 	jmpi	183f734 <__register_exitproc>

0183cfe8 <__errno>:
 183cfe8:	00806134 	movhi	r2,388
 183cfec:	10975504 	addi	r2,r2,23892
 183cff0:	10800017 	ldw	r2,0(r2)
 183cff4:	f800283a 	ret

0183cff8 <exit>:
 183cff8:	defffe04 	addi	sp,sp,-8
 183cffc:	000b883a 	mov	r5,zero
 183d000:	dc000015 	stw	r16,0(sp)
 183d004:	dfc00115 	stw	ra,4(sp)
 183d008:	2021883a 	mov	r16,r4
 183d00c:	183f84c0 	call	183f84c <__call_exitprocs>
 183d010:	00806134 	movhi	r2,388
 183d014:	10975404 	addi	r2,r2,23888
 183d018:	11000017 	ldw	r4,0(r2)
 183d01c:	20800f17 	ldw	r2,60(r4)
 183d020:	10000126 	beq	r2,zero,183d028 <exit+0x30>
 183d024:	103ee83a 	callr	r2
 183d028:	8009883a 	mov	r4,r16
 183d02c:	1840e380 	call	1840e38 <_exit>

0183d030 <malloc>:
 183d030:	00806134 	movhi	r2,388
 183d034:	10975504 	addi	r2,r2,23892
 183d038:	200b883a 	mov	r5,r4
 183d03c:	11000017 	ldw	r4,0(r2)
 183d040:	180579c1 	jmpi	180579c <_malloc_r>

0183d044 <free>:
 183d044:	00806134 	movhi	r2,388
 183d048:	10975504 	addi	r2,r2,23892
 183d04c:	200b883a 	mov	r5,r4
 183d050:	11000017 	ldw	r4,0(r2)
 183d054:	180506c1 	jmpi	180506c <_free_r>

0183d058 <memcmp>:
 183d058:	01c000c4 	movi	r7,3
 183d05c:	3980192e 	bgeu	r7,r6,183d0c4 <memcmp+0x6c>
 183d060:	2144b03a 	or	r2,r4,r5
 183d064:	11c4703a 	and	r2,r2,r7
 183d068:	10000f26 	beq	r2,zero,183d0a8 <memcmp+0x50>
 183d06c:	20800003 	ldbu	r2,0(r4)
 183d070:	28c00003 	ldbu	r3,0(r5)
 183d074:	10c0151e 	bne	r2,r3,183d0cc <memcmp+0x74>
 183d078:	31bfff84 	addi	r6,r6,-2
 183d07c:	01ffffc4 	movi	r7,-1
 183d080:	00000406 	br	183d094 <memcmp+0x3c>
 183d084:	20800003 	ldbu	r2,0(r4)
 183d088:	28c00003 	ldbu	r3,0(r5)
 183d08c:	31bfffc4 	addi	r6,r6,-1
 183d090:	10c00e1e 	bne	r2,r3,183d0cc <memcmp+0x74>
 183d094:	21000044 	addi	r4,r4,1
 183d098:	29400044 	addi	r5,r5,1
 183d09c:	31fff91e 	bne	r6,r7,183d084 <__ram_exceptions_end+0xff82cc40>
 183d0a0:	0005883a 	mov	r2,zero
 183d0a4:	f800283a 	ret
 183d0a8:	20c00017 	ldw	r3,0(r4)
 183d0ac:	28800017 	ldw	r2,0(r5)
 183d0b0:	18bfee1e 	bne	r3,r2,183d06c <__ram_exceptions_end+0xff82cc28>
 183d0b4:	31bfff04 	addi	r6,r6,-4
 183d0b8:	21000104 	addi	r4,r4,4
 183d0bc:	29400104 	addi	r5,r5,4
 183d0c0:	39bff936 	bltu	r7,r6,183d0a8 <__ram_exceptions_end+0xff82cc64>
 183d0c4:	303fe91e 	bne	r6,zero,183d06c <__ram_exceptions_end+0xff82cc28>
 183d0c8:	003ff506 	br	183d0a0 <__ram_exceptions_end+0xff82cc5c>
 183d0cc:	10c5c83a 	sub	r2,r2,r3
 183d0d0:	f800283a 	ret

0183d0d4 <_putc_r>:
 183d0d4:	defffc04 	addi	sp,sp,-16
 183d0d8:	dc000215 	stw	r16,8(sp)
 183d0dc:	dfc00315 	stw	ra,12(sp)
 183d0e0:	2021883a 	mov	r16,r4
 183d0e4:	20000226 	beq	r4,zero,183d0f0 <_putc_r+0x1c>
 183d0e8:	20800e17 	ldw	r2,56(r4)
 183d0ec:	10001b26 	beq	r2,zero,183d15c <_putc_r+0x88>
 183d0f0:	30800217 	ldw	r2,8(r6)
 183d0f4:	10bfffc4 	addi	r2,r2,-1
 183d0f8:	30800215 	stw	r2,8(r6)
 183d0fc:	10000a16 	blt	r2,zero,183d128 <_putc_r+0x54>
 183d100:	30800017 	ldw	r2,0(r6)
 183d104:	11400005 	stb	r5,0(r2)
 183d108:	30800017 	ldw	r2,0(r6)
 183d10c:	10c00044 	addi	r3,r2,1
 183d110:	30c00015 	stw	r3,0(r6)
 183d114:	10800003 	ldbu	r2,0(r2)
 183d118:	dfc00317 	ldw	ra,12(sp)
 183d11c:	dc000217 	ldw	r16,8(sp)
 183d120:	dec00404 	addi	sp,sp,16
 183d124:	f800283a 	ret
 183d128:	30c00617 	ldw	r3,24(r6)
 183d12c:	10c00616 	blt	r2,r3,183d148 <_putc_r+0x74>
 183d130:	30800017 	ldw	r2,0(r6)
 183d134:	00c00284 	movi	r3,10
 183d138:	11400005 	stb	r5,0(r2)
 183d13c:	30800017 	ldw	r2,0(r6)
 183d140:	11400003 	ldbu	r5,0(r2)
 183d144:	28fff11e 	bne	r5,r3,183d10c <__ram_exceptions_end+0xff82ccc8>
 183d148:	8009883a 	mov	r4,r16
 183d14c:	dfc00317 	ldw	ra,12(sp)
 183d150:	dc000217 	ldw	r16,8(sp)
 183d154:	dec00404 	addi	sp,sp,16
 183d158:	1809e281 	jmpi	1809e28 <__swbuf_r>
 183d15c:	d9400015 	stw	r5,0(sp)
 183d160:	d9800115 	stw	r6,4(sp)
 183d164:	1804ef80 	call	1804ef8 <__sinit>
 183d168:	d9800117 	ldw	r6,4(sp)
 183d16c:	d9400017 	ldw	r5,0(sp)
 183d170:	003fdf06 	br	183d0f0 <__ram_exceptions_end+0xff82ccac>

0183d174 <putc>:
 183d174:	00806134 	movhi	r2,388
 183d178:	defffc04 	addi	sp,sp,-16
 183d17c:	10975504 	addi	r2,r2,23892
 183d180:	dc000115 	stw	r16,4(sp)
 183d184:	14000017 	ldw	r16,0(r2)
 183d188:	dc400215 	stw	r17,8(sp)
 183d18c:	dfc00315 	stw	ra,12(sp)
 183d190:	2023883a 	mov	r17,r4
 183d194:	80000226 	beq	r16,zero,183d1a0 <putc+0x2c>
 183d198:	80800e17 	ldw	r2,56(r16)
 183d19c:	10001a26 	beq	r2,zero,183d208 <putc+0x94>
 183d1a0:	28800217 	ldw	r2,8(r5)
 183d1a4:	10bfffc4 	addi	r2,r2,-1
 183d1a8:	28800215 	stw	r2,8(r5)
 183d1ac:	10000b16 	blt	r2,zero,183d1dc <putc+0x68>
 183d1b0:	28800017 	ldw	r2,0(r5)
 183d1b4:	14400005 	stb	r17,0(r2)
 183d1b8:	28800017 	ldw	r2,0(r5)
 183d1bc:	10c00044 	addi	r3,r2,1
 183d1c0:	28c00015 	stw	r3,0(r5)
 183d1c4:	10800003 	ldbu	r2,0(r2)
 183d1c8:	dfc00317 	ldw	ra,12(sp)
 183d1cc:	dc400217 	ldw	r17,8(sp)
 183d1d0:	dc000117 	ldw	r16,4(sp)
 183d1d4:	dec00404 	addi	sp,sp,16
 183d1d8:	f800283a 	ret
 183d1dc:	28c00617 	ldw	r3,24(r5)
 183d1e0:	10c00e16 	blt	r2,r3,183d21c <putc+0xa8>
 183d1e4:	28800017 	ldw	r2,0(r5)
 183d1e8:	01000284 	movi	r4,10
 183d1ec:	14400005 	stb	r17,0(r2)
 183d1f0:	28800017 	ldw	r2,0(r5)
 183d1f4:	10c00003 	ldbu	r3,0(r2)
 183d1f8:	193ff01e 	bne	r3,r4,183d1bc <__ram_exceptions_end+0xff82cd78>
 183d1fc:	280d883a 	mov	r6,r5
 183d200:	180b883a 	mov	r5,r3
 183d204:	00000706 	br	183d224 <putc+0xb0>
 183d208:	8009883a 	mov	r4,r16
 183d20c:	d9400015 	stw	r5,0(sp)
 183d210:	1804ef80 	call	1804ef8 <__sinit>
 183d214:	d9400017 	ldw	r5,0(sp)
 183d218:	003fe106 	br	183d1a0 <__ram_exceptions_end+0xff82cd5c>
 183d21c:	280d883a 	mov	r6,r5
 183d220:	880b883a 	mov	r5,r17
 183d224:	8009883a 	mov	r4,r16
 183d228:	dfc00317 	ldw	ra,12(sp)
 183d22c:	dc400217 	ldw	r17,8(sp)
 183d230:	dc000117 	ldw	r16,4(sp)
 183d234:	dec00404 	addi	sp,sp,16
 183d238:	1809e281 	jmpi	1809e28 <__swbuf_r>

0183d23c <_puts_r>:
 183d23c:	defff604 	addi	sp,sp,-40
 183d240:	dc000715 	stw	r16,28(sp)
 183d244:	2021883a 	mov	r16,r4
 183d248:	2809883a 	mov	r4,r5
 183d24c:	dc400815 	stw	r17,32(sp)
 183d250:	dfc00915 	stw	ra,36(sp)
 183d254:	2823883a 	mov	r17,r5
 183d258:	18075d80 	call	18075d8 <strlen>
 183d25c:	10c00044 	addi	r3,r2,1
 183d260:	d8800115 	stw	r2,4(sp)
 183d264:	00806134 	movhi	r2,388
 183d268:	108fbb04 	addi	r2,r2,16108
 183d26c:	d8800215 	stw	r2,8(sp)
 183d270:	00800044 	movi	r2,1
 183d274:	d8800315 	stw	r2,12(sp)
 183d278:	00800084 	movi	r2,2
 183d27c:	dc400015 	stw	r17,0(sp)
 183d280:	d8c00615 	stw	r3,24(sp)
 183d284:	dec00415 	stw	sp,16(sp)
 183d288:	d8800515 	stw	r2,20(sp)
 183d28c:	80000226 	beq	r16,zero,183d298 <_puts_r+0x5c>
 183d290:	80800e17 	ldw	r2,56(r16)
 183d294:	10001426 	beq	r2,zero,183d2e8 <_puts_r+0xac>
 183d298:	81400217 	ldw	r5,8(r16)
 183d29c:	2880030b 	ldhu	r2,12(r5)
 183d2a0:	10c8000c 	andi	r3,r2,8192
 183d2a4:	1800061e 	bne	r3,zero,183d2c0 <_puts_r+0x84>
 183d2a8:	29001917 	ldw	r4,100(r5)
 183d2ac:	00f7ffc4 	movi	r3,-8193
 183d2b0:	10880014 	ori	r2,r2,8192
 183d2b4:	20c6703a 	and	r3,r4,r3
 183d2b8:	2880030d 	sth	r2,12(r5)
 183d2bc:	28c01915 	stw	r3,100(r5)
 183d2c0:	d9800404 	addi	r6,sp,16
 183d2c4:	8009883a 	mov	r4,r16
 183d2c8:	18091980 	call	1809198 <__sfvwrite_r>
 183d2cc:	1000091e 	bne	r2,zero,183d2f4 <_puts_r+0xb8>
 183d2d0:	00800284 	movi	r2,10
 183d2d4:	dfc00917 	ldw	ra,36(sp)
 183d2d8:	dc400817 	ldw	r17,32(sp)
 183d2dc:	dc000717 	ldw	r16,28(sp)
 183d2e0:	dec00a04 	addi	sp,sp,40
 183d2e4:	f800283a 	ret
 183d2e8:	8009883a 	mov	r4,r16
 183d2ec:	1804ef80 	call	1804ef8 <__sinit>
 183d2f0:	003fe906 	br	183d298 <__ram_exceptions_end+0xff82ce54>
 183d2f4:	00bfffc4 	movi	r2,-1
 183d2f8:	003ff606 	br	183d2d4 <__ram_exceptions_end+0xff82ce90>

0183d2fc <puts>:
 183d2fc:	00806134 	movhi	r2,388
 183d300:	10975504 	addi	r2,r2,23892
 183d304:	200b883a 	mov	r5,r4
 183d308:	11000017 	ldw	r4,0(r2)
 183d30c:	183d23c1 	jmpi	183d23c <_puts_r>

0183d310 <_snprintf_r>:
 183d310:	30003116 	blt	r6,zero,183d3d8 <_snprintf_r+0xc8>
 183d314:	deffe404 	addi	sp,sp,-112
 183d318:	00c08204 	movi	r3,520
 183d31c:	dc001a15 	stw	r16,104(sp)
 183d320:	3005883a 	mov	r2,r6
 183d324:	dfc01b15 	stw	ra,108(sp)
 183d328:	d8c0030d 	sth	r3,12(sp)
 183d32c:	d9400015 	stw	r5,0(sp)
 183d330:	d9400415 	stw	r5,16(sp)
 183d334:	380d883a 	mov	r6,r7
 183d338:	2021883a 	mov	r16,r4
 183d33c:	10001026 	beq	r2,zero,183d380 <_snprintf_r+0x70>
 183d340:	10bfffc4 	addi	r2,r2,-1
 183d344:	d8800215 	stw	r2,8(sp)
 183d348:	d8800515 	stw	r2,20(sp)
 183d34c:	d9c01c04 	addi	r7,sp,112
 183d350:	00bfffc4 	movi	r2,-1
 183d354:	d80b883a 	mov	r5,sp
 183d358:	d880038d 	sth	r2,14(sp)
 183d35c:	183d55c0 	call	183d55c <___svfprintf_internal_r>
 183d360:	00ffffc4 	movi	r3,-1
 183d364:	10c01316 	blt	r2,r3,183d3b4 <_snprintf_r+0xa4>
 183d368:	d8c00017 	ldw	r3,0(sp)
 183d36c:	18000005 	stb	zero,0(r3)
 183d370:	dfc01b17 	ldw	ra,108(sp)
 183d374:	dc001a17 	ldw	r16,104(sp)
 183d378:	dec01c04 	addi	sp,sp,112
 183d37c:	f800283a 	ret
 183d380:	00bfffc4 	movi	r2,-1
 183d384:	d9c01c04 	addi	r7,sp,112
 183d388:	d80b883a 	mov	r5,sp
 183d38c:	d8000215 	stw	zero,8(sp)
 183d390:	d8000515 	stw	zero,20(sp)
 183d394:	d880038d 	sth	r2,14(sp)
 183d398:	183d55c0 	call	183d55c <___svfprintf_internal_r>
 183d39c:	00ffffc4 	movi	r3,-1
 183d3a0:	10c00716 	blt	r2,r3,183d3c0 <_snprintf_r+0xb0>
 183d3a4:	dfc01b17 	ldw	ra,108(sp)
 183d3a8:	dc001a17 	ldw	r16,104(sp)
 183d3ac:	dec01c04 	addi	sp,sp,112
 183d3b0:	f800283a 	ret
 183d3b4:	00c022c4 	movi	r3,139
 183d3b8:	80c00015 	stw	r3,0(r16)
 183d3bc:	003fea06 	br	183d368 <__ram_exceptions_end+0xff82cf24>
 183d3c0:	00c022c4 	movi	r3,139
 183d3c4:	80c00015 	stw	r3,0(r16)
 183d3c8:	dfc01b17 	ldw	ra,108(sp)
 183d3cc:	dc001a17 	ldw	r16,104(sp)
 183d3d0:	dec01c04 	addi	sp,sp,112
 183d3d4:	f800283a 	ret
 183d3d8:	008022c4 	movi	r2,139
 183d3dc:	20800015 	stw	r2,0(r4)
 183d3e0:	00bfffc4 	movi	r2,-1
 183d3e4:	f800283a 	ret

0183d3e8 <snprintf>:
 183d3e8:	deffe304 	addi	sp,sp,-116
 183d3ec:	dfc01b15 	stw	ra,108(sp)
 183d3f0:	dc001a15 	stw	r16,104(sp)
 183d3f4:	d9c01c15 	stw	r7,112(sp)
 183d3f8:	00806134 	movhi	r2,388
 183d3fc:	10975504 	addi	r2,r2,23892
 183d400:	14000017 	ldw	r16,0(r2)
 183d404:	28002d16 	blt	r5,zero,183d4bc <snprintf+0xd4>
 183d408:	00808204 	movi	r2,520
 183d40c:	d880030d 	sth	r2,12(sp)
 183d410:	d9000015 	stw	r4,0(sp)
 183d414:	d9000415 	stw	r4,16(sp)
 183d418:	28001126 	beq	r5,zero,183d460 <snprintf+0x78>
 183d41c:	28bfffc4 	addi	r2,r5,-1
 183d420:	d8800215 	stw	r2,8(sp)
 183d424:	d8800515 	stw	r2,20(sp)
 183d428:	d9c01c04 	addi	r7,sp,112
 183d42c:	00bfffc4 	movi	r2,-1
 183d430:	d80b883a 	mov	r5,sp
 183d434:	8009883a 	mov	r4,r16
 183d438:	d880038d 	sth	r2,14(sp)
 183d43c:	183d55c0 	call	183d55c <___svfprintf_internal_r>
 183d440:	00ffffc4 	movi	r3,-1
 183d444:	10c01416 	blt	r2,r3,183d498 <snprintf+0xb0>
 183d448:	d8c00017 	ldw	r3,0(sp)
 183d44c:	18000005 	stb	zero,0(r3)
 183d450:	dfc01b17 	ldw	ra,108(sp)
 183d454:	dc001a17 	ldw	r16,104(sp)
 183d458:	dec01d04 	addi	sp,sp,116
 183d45c:	f800283a 	ret
 183d460:	00bfffc4 	movi	r2,-1
 183d464:	d9c01c04 	addi	r7,sp,112
 183d468:	d80b883a 	mov	r5,sp
 183d46c:	8009883a 	mov	r4,r16
 183d470:	d8000215 	stw	zero,8(sp)
 183d474:	d8000515 	stw	zero,20(sp)
 183d478:	d880038d 	sth	r2,14(sp)
 183d47c:	183d55c0 	call	183d55c <___svfprintf_internal_r>
 183d480:	00ffffc4 	movi	r3,-1
 183d484:	10c00716 	blt	r2,r3,183d4a4 <snprintf+0xbc>
 183d488:	dfc01b17 	ldw	ra,108(sp)
 183d48c:	dc001a17 	ldw	r16,104(sp)
 183d490:	dec01d04 	addi	sp,sp,116
 183d494:	f800283a 	ret
 183d498:	00c022c4 	movi	r3,139
 183d49c:	80c00015 	stw	r3,0(r16)
 183d4a0:	003fe906 	br	183d448 <__ram_exceptions_end+0xff82d004>
 183d4a4:	00c022c4 	movi	r3,139
 183d4a8:	80c00015 	stw	r3,0(r16)
 183d4ac:	dfc01b17 	ldw	ra,108(sp)
 183d4b0:	dc001a17 	ldw	r16,104(sp)
 183d4b4:	dec01d04 	addi	sp,sp,116
 183d4b8:	f800283a 	ret
 183d4bc:	008022c4 	movi	r2,139
 183d4c0:	80800015 	stw	r2,0(r16)
 183d4c4:	00bfffc4 	movi	r2,-1
 183d4c8:	003fef06 	br	183d488 <__ram_exceptions_end+0xff82d044>

0183d4cc <strcpy>:
 183d4cc:	2906b03a 	or	r3,r5,r4
 183d4d0:	18c000cc 	andi	r3,r3,3
 183d4d4:	2005883a 	mov	r2,r4
 183d4d8:	1800161e 	bne	r3,zero,183d534 <strcpy+0x68>
 183d4dc:	29c00017 	ldw	r7,0(r5)
 183d4e0:	02ffbff4 	movhi	r11,65279
 183d4e4:	5affbfc4 	addi	r11,r11,-257
 183d4e8:	02a02074 	movhi	r10,32897
 183d4ec:	01c6303a 	nor	r3,zero,r7
 183d4f0:	3ac9883a 	add	r4,r7,r11
 183d4f4:	52a02004 	addi	r10,r10,-32640
 183d4f8:	20c6703a 	and	r3,r4,r3
 183d4fc:	1a86703a 	and	r3,r3,r10
 183d500:	18000c1e 	bne	r3,zero,183d534 <strcpy+0x68>
 183d504:	1011883a 	mov	r8,r2
 183d508:	41c00015 	stw	r7,0(r8)
 183d50c:	29400104 	addi	r5,r5,4
 183d510:	29c00017 	ldw	r7,0(r5)
 183d514:	41800104 	addi	r6,r8,4
 183d518:	3011883a 	mov	r8,r6
 183d51c:	3ad3883a 	add	r9,r7,r11
 183d520:	01c6303a 	nor	r3,zero,r7
 183d524:	48c6703a 	and	r3,r9,r3
 183d528:	1a86703a 	and	r3,r3,r10
 183d52c:	183ff626 	beq	r3,zero,183d508 <__ram_exceptions_end+0xff82d0c4>
 183d530:	00000106 	br	183d538 <strcpy+0x6c>
 183d534:	100d883a 	mov	r6,r2
 183d538:	28c00003 	ldbu	r3,0(r5)
 183d53c:	31800044 	addi	r6,r6,1
 183d540:	29400044 	addi	r5,r5,1
 183d544:	30ffffc5 	stb	r3,-1(r6)
 183d548:	18c03fcc 	andi	r3,r3,255
 183d54c:	18c0201c 	xori	r3,r3,128
 183d550:	18ffe004 	addi	r3,r3,-128
 183d554:	183ff81e 	bne	r3,zero,183d538 <__ram_exceptions_end+0xff82d0f4>
 183d558:	f800283a 	ret

0183d55c <___svfprintf_internal_r>:
 183d55c:	deffb704 	addi	sp,sp,-292
 183d560:	dfc04815 	stw	ra,288(sp)
 183d564:	ddc04615 	stw	r23,280(sp)
 183d568:	d9402c15 	stw	r5,176(sp)
 183d56c:	d9003915 	stw	r4,228(sp)
 183d570:	302f883a 	mov	r23,r6
 183d574:	d9c02d15 	stw	r7,180(sp)
 183d578:	df004715 	stw	fp,284(sp)
 183d57c:	dd804515 	stw	r22,276(sp)
 183d580:	dd404415 	stw	r21,272(sp)
 183d584:	dd004315 	stw	r20,268(sp)
 183d588:	dcc04215 	stw	r19,264(sp)
 183d58c:	dc804115 	stw	r18,260(sp)
 183d590:	dc404015 	stw	r17,256(sp)
 183d594:	dc003f15 	stw	r16,252(sp)
 183d598:	18055b00 	call	18055b0 <_localeconv_r>
 183d59c:	10800017 	ldw	r2,0(r2)
 183d5a0:	1009883a 	mov	r4,r2
 183d5a4:	d8803415 	stw	r2,208(sp)
 183d5a8:	18075d80 	call	18075d8 <strlen>
 183d5ac:	d8c02c17 	ldw	r3,176(sp)
 183d5b0:	d8803815 	stw	r2,224(sp)
 183d5b4:	1880030b 	ldhu	r2,12(r3)
 183d5b8:	1080200c 	andi	r2,r2,128
 183d5bc:	10000226 	beq	r2,zero,183d5c8 <___svfprintf_internal_r+0x6c>
 183d5c0:	18800417 	ldw	r2,16(r3)
 183d5c4:	10067f26 	beq	r2,zero,183efc4 <___svfprintf_internal_r+0x1a68>
 183d5c8:	dcc03917 	ldw	r19,228(sp)
 183d5cc:	d8c00404 	addi	r3,sp,16
 183d5d0:	05406134 	movhi	r21,388
 183d5d4:	d9001e04 	addi	r4,sp,120
 183d5d8:	ad4fbc04 	addi	r21,r21,16112
 183d5dc:	d8c01e15 	stw	r3,120(sp)
 183d5e0:	d8002015 	stw	zero,128(sp)
 183d5e4:	d8001f15 	stw	zero,124(sp)
 183d5e8:	d8003315 	stw	zero,204(sp)
 183d5ec:	d8003615 	stw	zero,216(sp)
 183d5f0:	d8003715 	stw	zero,220(sp)
 183d5f4:	1811883a 	mov	r8,r3
 183d5f8:	d8003a15 	stw	zero,232(sp)
 183d5fc:	d8003b15 	stw	zero,236(sp)
 183d600:	d8002f15 	stw	zero,188(sp)
 183d604:	d9002815 	stw	r4,160(sp)
 183d608:	b8800007 	ldb	r2,0(r23)
 183d60c:	10026726 	beq	r2,zero,183dfac <___svfprintf_internal_r+0xa50>
 183d610:	00c00944 	movi	r3,37
 183d614:	b821883a 	mov	r16,r23
 183d618:	10c0021e 	bne	r2,r3,183d624 <___svfprintf_internal_r+0xc8>
 183d61c:	00001406 	br	183d670 <___svfprintf_internal_r+0x114>
 183d620:	10c00326 	beq	r2,r3,183d630 <___svfprintf_internal_r+0xd4>
 183d624:	84000044 	addi	r16,r16,1
 183d628:	80800007 	ldb	r2,0(r16)
 183d62c:	103ffc1e 	bne	r2,zero,183d620 <__ram_exceptions_end+0xff82d1dc>
 183d630:	85e3c83a 	sub	r17,r16,r23
 183d634:	88000e26 	beq	r17,zero,183d670 <___svfprintf_internal_r+0x114>
 183d638:	d8c02017 	ldw	r3,128(sp)
 183d63c:	d8801f17 	ldw	r2,124(sp)
 183d640:	45c00015 	stw	r23,0(r8)
 183d644:	1c47883a 	add	r3,r3,r17
 183d648:	10800044 	addi	r2,r2,1
 183d64c:	d8c02015 	stw	r3,128(sp)
 183d650:	44400115 	stw	r17,4(r8)
 183d654:	d8801f15 	stw	r2,124(sp)
 183d658:	00c001c4 	movi	r3,7
 183d65c:	18809716 	blt	r3,r2,183d8bc <___svfprintf_internal_r+0x360>
 183d660:	42000204 	addi	r8,r8,8
 183d664:	d9402f17 	ldw	r5,188(sp)
 183d668:	2c4b883a 	add	r5,r5,r17
 183d66c:	d9402f15 	stw	r5,188(sp)
 183d670:	80800007 	ldb	r2,0(r16)
 183d674:	10009826 	beq	r2,zero,183d8d8 <___svfprintf_internal_r+0x37c>
 183d678:	84400047 	ldb	r17,1(r16)
 183d67c:	00bfffc4 	movi	r2,-1
 183d680:	85c00044 	addi	r23,r16,1
 183d684:	d8002785 	stb	zero,158(sp)
 183d688:	0007883a 	mov	r3,zero
 183d68c:	000f883a 	mov	r7,zero
 183d690:	d8802915 	stw	r2,164(sp)
 183d694:	d8003115 	stw	zero,196(sp)
 183d698:	0025883a 	mov	r18,zero
 183d69c:	01401604 	movi	r5,88
 183d6a0:	01800244 	movi	r6,9
 183d6a4:	02800a84 	movi	r10,42
 183d6a8:	02401b04 	movi	r9,108
 183d6ac:	bdc00044 	addi	r23,r23,1
 183d6b0:	88bff804 	addi	r2,r17,-32
 183d6b4:	2882f036 	bltu	r5,r2,183e278 <___svfprintf_internal_r+0xd1c>
 183d6b8:	100490ba 	slli	r2,r2,2
 183d6bc:	01006134 	movhi	r4,388
 183d6c0:	2135b404 	addi	r4,r4,-10544
 183d6c4:	1105883a 	add	r2,r2,r4
 183d6c8:	10800017 	ldw	r2,0(r2)
 183d6cc:	1000683a 	jmp	r2
 183d6d0:	0183e1e0 	cmpeqi	r6,zero,3975
 183d6d4:	0183e278 	rdprs	r6,zero,3977
 183d6d8:	0183e278 	rdprs	r6,zero,3977
 183d6dc:	0183e1d4 	movui	r6,3975
 183d6e0:	0183e278 	rdprs	r6,zero,3977
 183d6e4:	0183e278 	rdprs	r6,zero,3977
 183d6e8:	0183e278 	rdprs	r6,zero,3977
 183d6ec:	0183e278 	rdprs	r6,zero,3977
 183d6f0:	0183e278 	rdprs	r6,zero,3977
 183d6f4:	0183e278 	rdprs	r6,zero,3977
 183d6f8:	0183d934 	movhi	r6,3940
 183d6fc:	0183e110 	cmplti	r6,zero,3972
 183d700:	0183e278 	rdprs	r6,zero,3977
 183d704:	0183d844 	movi	r6,3937
 183d708:	0183d95c 	xori	r6,zero,3941
 183d70c:	0183e278 	rdprs	r6,zero,3977
 183d710:	0183d9d0 	cmplti	r6,zero,3943
 183d714:	0183d99c 	xori	r6,zero,3942
 183d718:	0183d99c 	xori	r6,zero,3942
 183d71c:	0183d99c 	xori	r6,zero,3942
 183d720:	0183d99c 	xori	r6,zero,3942
 183d724:	0183d99c 	xori	r6,zero,3942
 183d728:	0183d99c 	xori	r6,zero,3942
 183d72c:	0183d99c 	xori	r6,zero,3942
 183d730:	0183d99c 	xori	r6,zero,3942
 183d734:	0183d99c 	xori	r6,zero,3942
 183d738:	0183e278 	rdprs	r6,zero,3977
 183d73c:	0183e278 	rdprs	r6,zero,3977
 183d740:	0183e278 	rdprs	r6,zero,3977
 183d744:	0183e278 	rdprs	r6,zero,3977
 183d748:	0183e278 	rdprs	r6,zero,3977
 183d74c:	0183e278 	rdprs	r6,zero,3977
 183d750:	0183e278 	rdprs	r6,zero,3977
 183d754:	0183e278 	rdprs	r6,zero,3977
 183d758:	0183e278 	rdprs	r6,zero,3977
 183d75c:	0183e278 	rdprs	r6,zero,3977
 183d760:	0183da88 	cmpgei	r6,zero,3946
 183d764:	0183d9dc 	xori	r6,zero,3943
 183d768:	0183e278 	rdprs	r6,zero,3977
 183d76c:	0183d9dc 	xori	r6,zero,3943
 183d770:	0183e278 	rdprs	r6,zero,3977
 183d774:	0183e278 	rdprs	r6,zero,3977
 183d778:	0183e278 	rdprs	r6,zero,3977
 183d77c:	0183e278 	rdprs	r6,zero,3977
 183d780:	0183da7c 	xorhi	r6,zero,3945
 183d784:	0183e278 	rdprs	r6,zero,3977
 183d788:	0183e278 	rdprs	r6,zero,3977
 183d78c:	0183db44 	movi	r6,3949
 183d790:	0183e278 	rdprs	r6,zero,3977
 183d794:	0183e278 	rdprs	r6,zero,3977
 183d798:	0183e278 	rdprs	r6,zero,3977
 183d79c:	0183e278 	rdprs	r6,zero,3977
 183d7a0:	0183e278 	rdprs	r6,zero,3977
 183d7a4:	0183dfb4 	movhi	r6,3966
 183d7a8:	0183e278 	rdprs	r6,zero,3977
 183d7ac:	0183e278 	rdprs	r6,zero,3977
 183d7b0:	0183e014 	movui	r6,3968
 183d7b4:	0183e278 	rdprs	r6,zero,3977
 183d7b8:	0183e278 	rdprs	r6,zero,3977
 183d7bc:	0183e278 	rdprs	r6,zero,3977
 183d7c0:	0183e278 	rdprs	r6,zero,3977
 183d7c4:	0183e278 	rdprs	r6,zero,3977
 183d7c8:	0183e278 	rdprs	r6,zero,3977
 183d7cc:	0183e278 	rdprs	r6,zero,3977
 183d7d0:	0183e278 	rdprs	r6,zero,3977
 183d7d4:	0183e278 	rdprs	r6,zero,3977
 183d7d8:	0183e278 	rdprs	r6,zero,3977
 183d7dc:	0183e0c4 	movi	r6,3971
 183d7e0:	0183e200 	call	183e20 <__alt_mem_tse_descriptor_memory_0+0x183e20>
 183d7e4:	0183d9dc 	xori	r6,zero,3943
 183d7e8:	0183d9dc 	xori	r6,zero,3943
 183d7ec:	0183d9dc 	xori	r6,zero,3943
 183d7f0:	0183e254 	movui	r6,3977
 183d7f4:	0183e200 	call	183e20 <__alt_mem_tse_descriptor_memory_0+0x183e20>
 183d7f8:	0183e278 	rdprs	r6,zero,3977
 183d7fc:	0183e278 	rdprs	r6,zero,3977
 183d800:	0183e210 	cmplti	r6,zero,3976
 183d804:	0183e278 	rdprs	r6,zero,3977
 183d808:	0183e220 	cmpeqi	r6,zero,3976
 183d80c:	0183e100 	call	183e10 <__alt_mem_tse_descriptor_memory_0+0x183e10>
 183d810:	0183d850 	cmplti	r6,zero,3937
 183d814:	0183e120 	cmpeqi	r6,zero,3972
 183d818:	0183e278 	rdprs	r6,zero,3977
 183d81c:	0183e12c 	andhi	r6,zero,3972
 183d820:	0183e278 	rdprs	r6,zero,3977
 183d824:	0183e188 	cmpgei	r6,zero,3974
 183d828:	0183e278 	rdprs	r6,zero,3977
 183d82c:	0183e278 	rdprs	r6,zero,3977
 183d830:	0183e198 	cmpnei	r6,zero,3974
 183d834:	d9003117 	ldw	r4,196(sp)
 183d838:	d8802d15 	stw	r2,180(sp)
 183d83c:	0109c83a 	sub	r4,zero,r4
 183d840:	d9003115 	stw	r4,196(sp)
 183d844:	94800114 	ori	r18,r18,4
 183d848:	bc400007 	ldb	r17,0(r23)
 183d84c:	003f9706 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183d850:	00800c04 	movi	r2,48
 183d854:	d9002d17 	ldw	r4,180(sp)
 183d858:	d9402917 	ldw	r5,164(sp)
 183d85c:	d8802705 	stb	r2,156(sp)
 183d860:	00801e04 	movi	r2,120
 183d864:	d8802745 	stb	r2,157(sp)
 183d868:	d8002785 	stb	zero,158(sp)
 183d86c:	20c00104 	addi	r3,r4,4
 183d870:	25000017 	ldw	r20,0(r4)
 183d874:	002d883a 	mov	r22,zero
 183d878:	90800094 	ori	r2,r18,2
 183d87c:	28028616 	blt	r5,zero,183e298 <___svfprintf_internal_r+0xd3c>
 183d880:	00bfdfc4 	movi	r2,-129
 183d884:	90a4703a 	and	r18,r18,r2
 183d888:	d8c02d15 	stw	r3,180(sp)
 183d88c:	94800094 	ori	r18,r18,2
 183d890:	a002731e 	bne	r20,zero,183e260 <___svfprintf_internal_r+0xd04>
 183d894:	00806134 	movhi	r2,388
 183d898:	1084e604 	addi	r2,r2,5016
 183d89c:	d8803a15 	stw	r2,232(sp)
 183d8a0:	04401e04 	movi	r17,120
 183d8a4:	d8c02917 	ldw	r3,164(sp)
 183d8a8:	0039883a 	mov	fp,zero
 183d8ac:	1801d526 	beq	r3,zero,183e004 <___svfprintf_internal_r+0xaa8>
 183d8b0:	0029883a 	mov	r20,zero
 183d8b4:	002d883a 	mov	r22,zero
 183d8b8:	0001f106 	br	183e080 <___svfprintf_internal_r+0xb24>
 183d8bc:	d9402c17 	ldw	r5,176(sp)
 183d8c0:	d9801e04 	addi	r6,sp,120
 183d8c4:	9809883a 	mov	r4,r19
 183d8c8:	183f9cc0 	call	183f9cc <__ssprint_r>
 183d8cc:	1000081e 	bne	r2,zero,183d8f0 <___svfprintf_internal_r+0x394>
 183d8d0:	da000404 	addi	r8,sp,16
 183d8d4:	003f6306 	br	183d664 <__ram_exceptions_end+0xff82d220>
 183d8d8:	d8802017 	ldw	r2,128(sp)
 183d8dc:	10000426 	beq	r2,zero,183d8f0 <___svfprintf_internal_r+0x394>
 183d8e0:	d9402c17 	ldw	r5,176(sp)
 183d8e4:	d9003917 	ldw	r4,228(sp)
 183d8e8:	d9801e04 	addi	r6,sp,120
 183d8ec:	183f9cc0 	call	183f9cc <__ssprint_r>
 183d8f0:	d8802c17 	ldw	r2,176(sp)
 183d8f4:	10c0030b 	ldhu	r3,12(r2)
 183d8f8:	d8802f17 	ldw	r2,188(sp)
 183d8fc:	18c0100c 	andi	r3,r3,64
 183d900:	1805f51e 	bne	r3,zero,183f0d8 <___svfprintf_internal_r+0x1b7c>
 183d904:	dfc04817 	ldw	ra,288(sp)
 183d908:	df004717 	ldw	fp,284(sp)
 183d90c:	ddc04617 	ldw	r23,280(sp)
 183d910:	dd804517 	ldw	r22,276(sp)
 183d914:	dd404417 	ldw	r21,272(sp)
 183d918:	dd004317 	ldw	r20,268(sp)
 183d91c:	dcc04217 	ldw	r19,264(sp)
 183d920:	dc804117 	ldw	r18,260(sp)
 183d924:	dc404017 	ldw	r17,256(sp)
 183d928:	dc003f17 	ldw	r16,252(sp)
 183d92c:	dec04904 	addi	sp,sp,292
 183d930:	f800283a 	ret
 183d934:	d8802d17 	ldw	r2,180(sp)
 183d938:	d9002d17 	ldw	r4,180(sp)
 183d93c:	10800017 	ldw	r2,0(r2)
 183d940:	d8803115 	stw	r2,196(sp)
 183d944:	20800104 	addi	r2,r4,4
 183d948:	d9003117 	ldw	r4,196(sp)
 183d94c:	203fb916 	blt	r4,zero,183d834 <__ram_exceptions_end+0xff82d3f0>
 183d950:	d8802d15 	stw	r2,180(sp)
 183d954:	bc400007 	ldb	r17,0(r23)
 183d958:	003f5406 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183d95c:	bc400007 	ldb	r17,0(r23)
 183d960:	bac00044 	addi	r11,r23,1
 183d964:	8a873926 	beq	r17,r10,183f64c <___svfprintf_internal_r+0x20f0>
 183d968:	88bff404 	addi	r2,r17,-48
 183d96c:	0009883a 	mov	r4,zero
 183d970:	30868836 	bltu	r6,r2,183f394 <___svfprintf_internal_r+0x1e38>
 183d974:	5c400007 	ldb	r17,0(r11)
 183d978:	210002a4 	muli	r4,r4,10
 183d97c:	5dc00044 	addi	r23,r11,1
 183d980:	b817883a 	mov	r11,r23
 183d984:	2089883a 	add	r4,r4,r2
 183d988:	88bff404 	addi	r2,r17,-48
 183d98c:	30bff92e 	bgeu	r6,r2,183d974 <__ram_exceptions_end+0xff82d530>
 183d990:	2005d716 	blt	r4,zero,183f0f0 <___svfprintf_internal_r+0x1b94>
 183d994:	d9002915 	stw	r4,164(sp)
 183d998:	003f4506 	br	183d6b0 <__ram_exceptions_end+0xff82d26c>
 183d99c:	b809883a 	mov	r4,r23
 183d9a0:	d8003115 	stw	zero,196(sp)
 183d9a4:	88bff404 	addi	r2,r17,-48
 183d9a8:	0017883a 	mov	r11,zero
 183d9ac:	24400007 	ldb	r17,0(r4)
 183d9b0:	5ac002a4 	muli	r11,r11,10
 183d9b4:	bdc00044 	addi	r23,r23,1
 183d9b8:	b809883a 	mov	r4,r23
 183d9bc:	12d7883a 	add	r11,r2,r11
 183d9c0:	88bff404 	addi	r2,r17,-48
 183d9c4:	30bff92e 	bgeu	r6,r2,183d9ac <__ram_exceptions_end+0xff82d568>
 183d9c8:	dac03115 	stw	r11,196(sp)
 183d9cc:	003f3806 	br	183d6b0 <__ram_exceptions_end+0xff82d26c>
 183d9d0:	94802014 	ori	r18,r18,128
 183d9d4:	bc400007 	ldb	r17,0(r23)
 183d9d8:	003f3406 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183d9dc:	18c03fcc 	andi	r3,r3,255
 183d9e0:	1807471e 	bne	r3,zero,183f700 <___svfprintf_internal_r+0x21a4>
 183d9e4:	9080020c 	andi	r2,r18,8
 183d9e8:	10047d26 	beq	r2,zero,183ebe0 <___svfprintf_internal_r+0x1684>
 183d9ec:	d8c02d17 	ldw	r3,180(sp)
 183d9f0:	d9002d17 	ldw	r4,180(sp)
 183d9f4:	d9402d17 	ldw	r5,180(sp)
 183d9f8:	18c00017 	ldw	r3,0(r3)
 183d9fc:	21000117 	ldw	r4,4(r4)
 183da00:	29400204 	addi	r5,r5,8
 183da04:	d8c03615 	stw	r3,216(sp)
 183da08:	d9003715 	stw	r4,220(sp)
 183da0c:	d9402d15 	stw	r5,180(sp)
 183da10:	d9003617 	ldw	r4,216(sp)
 183da14:	d9403717 	ldw	r5,220(sp)
 183da18:	da003e15 	stw	r8,248(sp)
 183da1c:	04000044 	movi	r16,1
 183da20:	18072f80 	call	18072f8 <__fpclassifyd>
 183da24:	da003e17 	ldw	r8,248(sp)
 183da28:	14044b1e 	bne	r2,r16,183eb58 <___svfprintf_internal_r+0x15fc>
 183da2c:	d9003617 	ldw	r4,216(sp)
 183da30:	d9403717 	ldw	r5,220(sp)
 183da34:	000d883a 	mov	r6,zero
 183da38:	000f883a 	mov	r7,zero
 183da3c:	180c0c40 	call	180c0c4 <__ledf2>
 183da40:	da003e17 	ldw	r8,248(sp)
 183da44:	1005f316 	blt	r2,zero,183f214 <___svfprintf_internal_r+0x1cb8>
 183da48:	df002783 	ldbu	fp,158(sp)
 183da4c:	008011c4 	movi	r2,71
 183da50:	1445590e 	bge	r2,r17,183efb8 <___svfprintf_internal_r+0x1a5c>
 183da54:	04006134 	movhi	r16,388
 183da58:	8404de04 	addi	r16,r16,4984
 183da5c:	00c000c4 	movi	r3,3
 183da60:	00bfdfc4 	movi	r2,-129
 183da64:	d8c02a15 	stw	r3,168(sp)
 183da68:	90a4703a 	and	r18,r18,r2
 183da6c:	d8c02e15 	stw	r3,184(sp)
 183da70:	d8002915 	stw	zero,164(sp)
 183da74:	d8003215 	stw	zero,200(sp)
 183da78:	00006606 	br	183dc14 <___svfprintf_internal_r+0x6b8>
 183da7c:	94800214 	ori	r18,r18,8
 183da80:	bc400007 	ldb	r17,0(r23)
 183da84:	003f0906 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183da88:	18c03fcc 	andi	r3,r3,255
 183da8c:	1807181e 	bne	r3,zero,183f6f0 <___svfprintf_internal_r+0x2194>
 183da90:	94800414 	ori	r18,r18,16
 183da94:	9080080c 	andi	r2,r18,32
 183da98:	10039626 	beq	r2,zero,183e8f4 <___svfprintf_internal_r+0x1398>
 183da9c:	d9402d17 	ldw	r5,180(sp)
 183daa0:	28800117 	ldw	r2,4(r5)
 183daa4:	2d000017 	ldw	r20,0(r5)
 183daa8:	29400204 	addi	r5,r5,8
 183daac:	d9402d15 	stw	r5,180(sp)
 183dab0:	102d883a 	mov	r22,r2
 183dab4:	10039816 	blt	r2,zero,183e918 <___svfprintf_internal_r+0x13bc>
 183dab8:	d9402917 	ldw	r5,164(sp)
 183dabc:	df002783 	ldbu	fp,158(sp)
 183dac0:	2803ab16 	blt	r5,zero,183e970 <___svfprintf_internal_r+0x1414>
 183dac4:	00ffdfc4 	movi	r3,-129
 183dac8:	a584b03a 	or	r2,r20,r22
 183dacc:	90e4703a 	and	r18,r18,r3
 183dad0:	10014a26 	beq	r2,zero,183dffc <___svfprintf_internal_r+0xaa0>
 183dad4:	b0034b26 	beq	r22,zero,183e804 <___svfprintf_internal_r+0x12a8>
 183dad8:	dc402a15 	stw	r17,168(sp)
 183dadc:	dc001e04 	addi	r16,sp,120
 183dae0:	b023883a 	mov	r17,r22
 183dae4:	402d883a 	mov	r22,r8
 183dae8:	a009883a 	mov	r4,r20
 183daec:	880b883a 	mov	r5,r17
 183daf0:	01800284 	movi	r6,10
 183daf4:	000f883a 	mov	r7,zero
 183daf8:	180a6e00 	call	180a6e0 <__umoddi3>
 183dafc:	10800c04 	addi	r2,r2,48
 183db00:	843fffc4 	addi	r16,r16,-1
 183db04:	a009883a 	mov	r4,r20
 183db08:	880b883a 	mov	r5,r17
 183db0c:	80800005 	stb	r2,0(r16)
 183db10:	01800284 	movi	r6,10
 183db14:	000f883a 	mov	r7,zero
 183db18:	180a1680 	call	180a168 <__udivdi3>
 183db1c:	1029883a 	mov	r20,r2
 183db20:	10c4b03a 	or	r2,r2,r3
 183db24:	1823883a 	mov	r17,r3
 183db28:	103fef1e 	bne	r2,zero,183dae8 <__ram_exceptions_end+0xff82d6a4>
 183db2c:	d8c02817 	ldw	r3,160(sp)
 183db30:	dc402a17 	ldw	r17,168(sp)
 183db34:	b011883a 	mov	r8,r22
 183db38:	1c07c83a 	sub	r3,r3,r16
 183db3c:	d8c02e15 	stw	r3,184(sp)
 183db40:	00002e06 	br	183dbfc <___svfprintf_internal_r+0x6a0>
 183db44:	18c03fcc 	andi	r3,r3,255
 183db48:	1806e71e 	bne	r3,zero,183f6e8 <___svfprintf_internal_r+0x218c>
 183db4c:	94800414 	ori	r18,r18,16
 183db50:	9080080c 	andi	r2,r18,32
 183db54:	1002d426 	beq	r2,zero,183e6a8 <___svfprintf_internal_r+0x114c>
 183db58:	d9402d17 	ldw	r5,180(sp)
 183db5c:	d8c02917 	ldw	r3,164(sp)
 183db60:	d8002785 	stb	zero,158(sp)
 183db64:	28800204 	addi	r2,r5,8
 183db68:	2d000017 	ldw	r20,0(r5)
 183db6c:	2d800117 	ldw	r22,4(r5)
 183db70:	18041516 	blt	r3,zero,183ebc8 <___svfprintf_internal_r+0x166c>
 183db74:	013fdfc4 	movi	r4,-129
 183db78:	a586b03a 	or	r3,r20,r22
 183db7c:	d8802d15 	stw	r2,180(sp)
 183db80:	9124703a 	and	r18,r18,r4
 183db84:	1802d51e 	bne	r3,zero,183e6dc <___svfprintf_internal_r+0x1180>
 183db88:	d9402917 	ldw	r5,164(sp)
 183db8c:	0039883a 	mov	fp,zero
 183db90:	2806be26 	beq	r5,zero,183f68c <___svfprintf_internal_r+0x2130>
 183db94:	0029883a 	mov	r20,zero
 183db98:	002d883a 	mov	r22,zero
 183db9c:	dc001e04 	addi	r16,sp,120
 183dba0:	a006d0fa 	srli	r3,r20,3
 183dba4:	b008977a 	slli	r4,r22,29
 183dba8:	b02cd0fa 	srli	r22,r22,3
 183dbac:	a50001cc 	andi	r20,r20,7
 183dbb0:	a0800c04 	addi	r2,r20,48
 183dbb4:	843fffc4 	addi	r16,r16,-1
 183dbb8:	20e8b03a 	or	r20,r4,r3
 183dbbc:	80800005 	stb	r2,0(r16)
 183dbc0:	a586b03a 	or	r3,r20,r22
 183dbc4:	183ff61e 	bne	r3,zero,183dba0 <__ram_exceptions_end+0xff82d75c>
 183dbc8:	90c0004c 	andi	r3,r18,1
 183dbcc:	18013926 	beq	r3,zero,183e0b4 <___svfprintf_internal_r+0xb58>
 183dbd0:	10803fcc 	andi	r2,r2,255
 183dbd4:	1080201c 	xori	r2,r2,128
 183dbd8:	10bfe004 	addi	r2,r2,-128
 183dbdc:	00c00c04 	movi	r3,48
 183dbe0:	10c13426 	beq	r2,r3,183e0b4 <___svfprintf_internal_r+0xb58>
 183dbe4:	80ffffc5 	stb	r3,-1(r16)
 183dbe8:	d8c02817 	ldw	r3,160(sp)
 183dbec:	80bfffc4 	addi	r2,r16,-1
 183dbf0:	1021883a 	mov	r16,r2
 183dbf4:	1887c83a 	sub	r3,r3,r2
 183dbf8:	d8c02e15 	stw	r3,184(sp)
 183dbfc:	d8802e17 	ldw	r2,184(sp)
 183dc00:	d9002917 	ldw	r4,164(sp)
 183dc04:	1100010e 	bge	r2,r4,183dc0c <___svfprintf_internal_r+0x6b0>
 183dc08:	2005883a 	mov	r2,r4
 183dc0c:	d8802a15 	stw	r2,168(sp)
 183dc10:	d8003215 	stw	zero,200(sp)
 183dc14:	e7003fcc 	andi	fp,fp,255
 183dc18:	e700201c 	xori	fp,fp,128
 183dc1c:	e73fe004 	addi	fp,fp,-128
 183dc20:	e0000326 	beq	fp,zero,183dc30 <___svfprintf_internal_r+0x6d4>
 183dc24:	d8c02a17 	ldw	r3,168(sp)
 183dc28:	18c00044 	addi	r3,r3,1
 183dc2c:	d8c02a15 	stw	r3,168(sp)
 183dc30:	90c0008c 	andi	r3,r18,2
 183dc34:	d8c02b15 	stw	r3,172(sp)
 183dc38:	18000326 	beq	r3,zero,183dc48 <___svfprintf_internal_r+0x6ec>
 183dc3c:	d8c02a17 	ldw	r3,168(sp)
 183dc40:	18c00084 	addi	r3,r3,2
 183dc44:	d8c02a15 	stw	r3,168(sp)
 183dc48:	90c0210c 	andi	r3,r18,132
 183dc4c:	d8c03015 	stw	r3,192(sp)
 183dc50:	1801a11e 	bne	r3,zero,183e2d8 <___svfprintf_internal_r+0xd7c>
 183dc54:	d9003117 	ldw	r4,196(sp)
 183dc58:	d8c02a17 	ldw	r3,168(sp)
 183dc5c:	20e9c83a 	sub	r20,r4,r3
 183dc60:	05019d0e 	bge	zero,r20,183e2d8 <___svfprintf_internal_r+0xd7c>
 183dc64:	02400404 	movi	r9,16
 183dc68:	d8c02017 	ldw	r3,128(sp)
 183dc6c:	d8801f17 	ldw	r2,124(sp)
 183dc70:	4d051b0e 	bge	r9,r20,183f0e0 <___svfprintf_internal_r+0x1b84>
 183dc74:	01406134 	movhi	r5,388
 183dc78:	294fc004 	addi	r5,r5,16128
 183dc7c:	dc403c15 	stw	r17,240(sp)
 183dc80:	d9403515 	stw	r5,212(sp)
 183dc84:	a023883a 	mov	r17,r20
 183dc88:	482d883a 	mov	r22,r9
 183dc8c:	9029883a 	mov	r20,r18
 183dc90:	070001c4 	movi	fp,7
 183dc94:	8025883a 	mov	r18,r16
 183dc98:	dc002c17 	ldw	r16,176(sp)
 183dc9c:	00000306 	br	183dcac <___svfprintf_internal_r+0x750>
 183dca0:	8c7ffc04 	addi	r17,r17,-16
 183dca4:	42000204 	addi	r8,r8,8
 183dca8:	b440130e 	bge	r22,r17,183dcf8 <___svfprintf_internal_r+0x79c>
 183dcac:	01006134 	movhi	r4,388
 183dcb0:	18c00404 	addi	r3,r3,16
 183dcb4:	10800044 	addi	r2,r2,1
 183dcb8:	210fc004 	addi	r4,r4,16128
 183dcbc:	41000015 	stw	r4,0(r8)
 183dcc0:	45800115 	stw	r22,4(r8)
 183dcc4:	d8c02015 	stw	r3,128(sp)
 183dcc8:	d8801f15 	stw	r2,124(sp)
 183dccc:	e0bff40e 	bge	fp,r2,183dca0 <__ram_exceptions_end+0xff82d85c>
 183dcd0:	d9801e04 	addi	r6,sp,120
 183dcd4:	800b883a 	mov	r5,r16
 183dcd8:	9809883a 	mov	r4,r19
 183dcdc:	183f9cc0 	call	183f9cc <__ssprint_r>
 183dce0:	103f031e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183dce4:	8c7ffc04 	addi	r17,r17,-16
 183dce8:	d8c02017 	ldw	r3,128(sp)
 183dcec:	d8801f17 	ldw	r2,124(sp)
 183dcf0:	da000404 	addi	r8,sp,16
 183dcf4:	b47fed16 	blt	r22,r17,183dcac <__ram_exceptions_end+0xff82d868>
 183dcf8:	9021883a 	mov	r16,r18
 183dcfc:	a025883a 	mov	r18,r20
 183dd00:	8829883a 	mov	r20,r17
 183dd04:	dc403c17 	ldw	r17,240(sp)
 183dd08:	d9403517 	ldw	r5,212(sp)
 183dd0c:	a0c7883a 	add	r3,r20,r3
 183dd10:	10800044 	addi	r2,r2,1
 183dd14:	41400015 	stw	r5,0(r8)
 183dd18:	45000115 	stw	r20,4(r8)
 183dd1c:	d8c02015 	stw	r3,128(sp)
 183dd20:	d8801f15 	stw	r2,124(sp)
 183dd24:	010001c4 	movi	r4,7
 183dd28:	20829f16 	blt	r4,r2,183e7a8 <___svfprintf_internal_r+0x124c>
 183dd2c:	df002787 	ldb	fp,158(sp)
 183dd30:	42000204 	addi	r8,r8,8
 183dd34:	e0000c26 	beq	fp,zero,183dd68 <___svfprintf_internal_r+0x80c>
 183dd38:	d8801f17 	ldw	r2,124(sp)
 183dd3c:	d9002784 	addi	r4,sp,158
 183dd40:	18c00044 	addi	r3,r3,1
 183dd44:	10800044 	addi	r2,r2,1
 183dd48:	41000015 	stw	r4,0(r8)
 183dd4c:	01000044 	movi	r4,1
 183dd50:	41000115 	stw	r4,4(r8)
 183dd54:	d8c02015 	stw	r3,128(sp)
 183dd58:	d8801f15 	stw	r2,124(sp)
 183dd5c:	010001c4 	movi	r4,7
 183dd60:	20823816 	blt	r4,r2,183e644 <___svfprintf_internal_r+0x10e8>
 183dd64:	42000204 	addi	r8,r8,8
 183dd68:	d8802b17 	ldw	r2,172(sp)
 183dd6c:	10000c26 	beq	r2,zero,183dda0 <___svfprintf_internal_r+0x844>
 183dd70:	d8801f17 	ldw	r2,124(sp)
 183dd74:	d9002704 	addi	r4,sp,156
 183dd78:	18c00084 	addi	r3,r3,2
 183dd7c:	10800044 	addi	r2,r2,1
 183dd80:	41000015 	stw	r4,0(r8)
 183dd84:	01000084 	movi	r4,2
 183dd88:	41000115 	stw	r4,4(r8)
 183dd8c:	d8c02015 	stw	r3,128(sp)
 183dd90:	d8801f15 	stw	r2,124(sp)
 183dd94:	010001c4 	movi	r4,7
 183dd98:	20823216 	blt	r4,r2,183e664 <___svfprintf_internal_r+0x1108>
 183dd9c:	42000204 	addi	r8,r8,8
 183dda0:	d9003017 	ldw	r4,192(sp)
 183dda4:	00802004 	movi	r2,128
 183dda8:	20819726 	beq	r4,r2,183e408 <___svfprintf_internal_r+0xeac>
 183ddac:	d9402917 	ldw	r5,164(sp)
 183ddb0:	d8802e17 	ldw	r2,184(sp)
 183ddb4:	28adc83a 	sub	r22,r5,r2
 183ddb8:	05802f0e 	bge	zero,r22,183de78 <___svfprintf_internal_r+0x91c>
 183ddbc:	07000404 	movi	fp,16
 183ddc0:	d8801f17 	ldw	r2,124(sp)
 183ddc4:	e583c00e 	bge	fp,r22,183ecc8 <___svfprintf_internal_r+0x176c>
 183ddc8:	01406134 	movhi	r5,388
 183ddcc:	294fbc04 	addi	r5,r5,16112
 183ddd0:	dc402915 	stw	r17,164(sp)
 183ddd4:	d9402b15 	stw	r5,172(sp)
 183ddd8:	b023883a 	mov	r17,r22
 183dddc:	050001c4 	movi	r20,7
 183dde0:	902d883a 	mov	r22,r18
 183dde4:	8025883a 	mov	r18,r16
 183dde8:	dc002c17 	ldw	r16,176(sp)
 183ddec:	00000306 	br	183ddfc <___svfprintf_internal_r+0x8a0>
 183ddf0:	8c7ffc04 	addi	r17,r17,-16
 183ddf4:	42000204 	addi	r8,r8,8
 183ddf8:	e440110e 	bge	fp,r17,183de40 <___svfprintf_internal_r+0x8e4>
 183ddfc:	18c00404 	addi	r3,r3,16
 183de00:	10800044 	addi	r2,r2,1
 183de04:	45400015 	stw	r21,0(r8)
 183de08:	47000115 	stw	fp,4(r8)
 183de0c:	d8c02015 	stw	r3,128(sp)
 183de10:	d8801f15 	stw	r2,124(sp)
 183de14:	a0bff60e 	bge	r20,r2,183ddf0 <__ram_exceptions_end+0xff82d9ac>
 183de18:	d9801e04 	addi	r6,sp,120
 183de1c:	800b883a 	mov	r5,r16
 183de20:	9809883a 	mov	r4,r19
 183de24:	183f9cc0 	call	183f9cc <__ssprint_r>
 183de28:	103eb11e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183de2c:	8c7ffc04 	addi	r17,r17,-16
 183de30:	d8c02017 	ldw	r3,128(sp)
 183de34:	d8801f17 	ldw	r2,124(sp)
 183de38:	da000404 	addi	r8,sp,16
 183de3c:	e47fef16 	blt	fp,r17,183ddfc <__ram_exceptions_end+0xff82d9b8>
 183de40:	9021883a 	mov	r16,r18
 183de44:	b025883a 	mov	r18,r22
 183de48:	882d883a 	mov	r22,r17
 183de4c:	dc402917 	ldw	r17,164(sp)
 183de50:	d9002b17 	ldw	r4,172(sp)
 183de54:	1d87883a 	add	r3,r3,r22
 183de58:	10800044 	addi	r2,r2,1
 183de5c:	41000015 	stw	r4,0(r8)
 183de60:	45800115 	stw	r22,4(r8)
 183de64:	d8c02015 	stw	r3,128(sp)
 183de68:	d8801f15 	stw	r2,124(sp)
 183de6c:	010001c4 	movi	r4,7
 183de70:	2081ec16 	blt	r4,r2,183e624 <___svfprintf_internal_r+0x10c8>
 183de74:	42000204 	addi	r8,r8,8
 183de78:	9080400c 	andi	r2,r18,256
 183de7c:	1001181e 	bne	r2,zero,183e2e0 <___svfprintf_internal_r+0xd84>
 183de80:	d9402e17 	ldw	r5,184(sp)
 183de84:	d8801f17 	ldw	r2,124(sp)
 183de88:	44000015 	stw	r16,0(r8)
 183de8c:	1947883a 	add	r3,r3,r5
 183de90:	10800044 	addi	r2,r2,1
 183de94:	41400115 	stw	r5,4(r8)
 183de98:	d8c02015 	stw	r3,128(sp)
 183de9c:	d8801f15 	stw	r2,124(sp)
 183dea0:	010001c4 	movi	r4,7
 183dea4:	2081d116 	blt	r4,r2,183e5ec <___svfprintf_internal_r+0x1090>
 183dea8:	42000204 	addi	r8,r8,8
 183deac:	9480010c 	andi	r18,r18,4
 183deb0:	90003226 	beq	r18,zero,183df7c <___svfprintf_internal_r+0xa20>
 183deb4:	d9403117 	ldw	r5,196(sp)
 183deb8:	d8802a17 	ldw	r2,168(sp)
 183debc:	28a1c83a 	sub	r16,r5,r2
 183dec0:	04002e0e 	bge	zero,r16,183df7c <___svfprintf_internal_r+0xa20>
 183dec4:	04400404 	movi	r17,16
 183dec8:	d8801f17 	ldw	r2,124(sp)
 183decc:	8c04b90e 	bge	r17,r16,183f1b4 <___svfprintf_internal_r+0x1c58>
 183ded0:	01406134 	movhi	r5,388
 183ded4:	294fc004 	addi	r5,r5,16128
 183ded8:	d9403515 	stw	r5,212(sp)
 183dedc:	048001c4 	movi	r18,7
 183dee0:	dd002c17 	ldw	r20,176(sp)
 183dee4:	00000306 	br	183def4 <___svfprintf_internal_r+0x998>
 183dee8:	843ffc04 	addi	r16,r16,-16
 183deec:	42000204 	addi	r8,r8,8
 183def0:	8c00130e 	bge	r17,r16,183df40 <___svfprintf_internal_r+0x9e4>
 183def4:	01006134 	movhi	r4,388
 183def8:	18c00404 	addi	r3,r3,16
 183defc:	10800044 	addi	r2,r2,1
 183df00:	210fc004 	addi	r4,r4,16128
 183df04:	41000015 	stw	r4,0(r8)
 183df08:	44400115 	stw	r17,4(r8)
 183df0c:	d8c02015 	stw	r3,128(sp)
 183df10:	d8801f15 	stw	r2,124(sp)
 183df14:	90bff40e 	bge	r18,r2,183dee8 <__ram_exceptions_end+0xff82daa4>
 183df18:	d9801e04 	addi	r6,sp,120
 183df1c:	a00b883a 	mov	r5,r20
 183df20:	9809883a 	mov	r4,r19
 183df24:	183f9cc0 	call	183f9cc <__ssprint_r>
 183df28:	103e711e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183df2c:	843ffc04 	addi	r16,r16,-16
 183df30:	d8c02017 	ldw	r3,128(sp)
 183df34:	d8801f17 	ldw	r2,124(sp)
 183df38:	da000404 	addi	r8,sp,16
 183df3c:	8c3fed16 	blt	r17,r16,183def4 <__ram_exceptions_end+0xff82dab0>
 183df40:	d9403517 	ldw	r5,212(sp)
 183df44:	1c07883a 	add	r3,r3,r16
 183df48:	10800044 	addi	r2,r2,1
 183df4c:	41400015 	stw	r5,0(r8)
 183df50:	44000115 	stw	r16,4(r8)
 183df54:	d8c02015 	stw	r3,128(sp)
 183df58:	d8801f15 	stw	r2,124(sp)
 183df5c:	010001c4 	movi	r4,7
 183df60:	2080060e 	bge	r4,r2,183df7c <___svfprintf_internal_r+0xa20>
 183df64:	d9402c17 	ldw	r5,176(sp)
 183df68:	d9801e04 	addi	r6,sp,120
 183df6c:	9809883a 	mov	r4,r19
 183df70:	183f9cc0 	call	183f9cc <__ssprint_r>
 183df74:	103e5e1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183df78:	d8c02017 	ldw	r3,128(sp)
 183df7c:	d8803117 	ldw	r2,196(sp)
 183df80:	d9002a17 	ldw	r4,168(sp)
 183df84:	1100010e 	bge	r2,r4,183df8c <___svfprintf_internal_r+0xa30>
 183df88:	2005883a 	mov	r2,r4
 183df8c:	d9402f17 	ldw	r5,188(sp)
 183df90:	288b883a 	add	r5,r5,r2
 183df94:	d9402f15 	stw	r5,188(sp)
 183df98:	18019c1e 	bne	r3,zero,183e60c <___svfprintf_internal_r+0x10b0>
 183df9c:	b8800007 	ldb	r2,0(r23)
 183dfa0:	d8001f15 	stw	zero,124(sp)
 183dfa4:	da000404 	addi	r8,sp,16
 183dfa8:	103d991e 	bne	r2,zero,183d610 <__ram_exceptions_end+0xff82d1cc>
 183dfac:	b821883a 	mov	r16,r23
 183dfb0:	003daf06 	br	183d670 <__ram_exceptions_end+0xff82d22c>
 183dfb4:	18c03fcc 	andi	r3,r3,255
 183dfb8:	1805c71e 	bne	r3,zero,183f6d8 <___svfprintf_internal_r+0x217c>
 183dfbc:	94800414 	ori	r18,r18,16
 183dfc0:	9080080c 	andi	r2,r18,32
 183dfc4:	10020126 	beq	r2,zero,183e7cc <___svfprintf_internal_r+0x1270>
 183dfc8:	d8802d17 	ldw	r2,180(sp)
 183dfcc:	d9002917 	ldw	r4,164(sp)
 183dfd0:	d8002785 	stb	zero,158(sp)
 183dfd4:	10c00204 	addi	r3,r2,8
 183dfd8:	15000017 	ldw	r20,0(r2)
 183dfdc:	15800117 	ldw	r22,4(r2)
 183dfe0:	20038e16 	blt	r4,zero,183ee1c <___svfprintf_internal_r+0x18c0>
 183dfe4:	013fdfc4 	movi	r4,-129
 183dfe8:	a584b03a 	or	r2,r20,r22
 183dfec:	d8c02d15 	stw	r3,180(sp)
 183dff0:	9124703a 	and	r18,r18,r4
 183dff4:	0039883a 	mov	fp,zero
 183dff8:	103eb61e 	bne	r2,zero,183dad4 <__ram_exceptions_end+0xff82d690>
 183dffc:	d8802917 	ldw	r2,164(sp)
 183e000:	1002c81e 	bne	r2,zero,183eb24 <___svfprintf_internal_r+0x15c8>
 183e004:	d8002915 	stw	zero,164(sp)
 183e008:	d8002e15 	stw	zero,184(sp)
 183e00c:	dc001e04 	addi	r16,sp,120
 183e010:	003efa06 	br	183dbfc <__ram_exceptions_end+0xff82d7b8>
 183e014:	18c03fcc 	andi	r3,r3,255
 183e018:	1805ad1e 	bne	r3,zero,183f6d0 <___svfprintf_internal_r+0x2174>
 183e01c:	01406134 	movhi	r5,388
 183e020:	2944e104 	addi	r5,r5,4996
 183e024:	d9403a15 	stw	r5,232(sp)
 183e028:	9080080c 	andi	r2,r18,32
 183e02c:	10006126 	beq	r2,zero,183e1b4 <___svfprintf_internal_r+0xc58>
 183e030:	d8802d17 	ldw	r2,180(sp)
 183e034:	15000017 	ldw	r20,0(r2)
 183e038:	15800117 	ldw	r22,4(r2)
 183e03c:	10800204 	addi	r2,r2,8
 183e040:	d8802d15 	stw	r2,180(sp)
 183e044:	9080004c 	andi	r2,r18,1
 183e048:	10018e26 	beq	r2,zero,183e684 <___svfprintf_internal_r+0x1128>
 183e04c:	a584b03a 	or	r2,r20,r22
 183e050:	10030926 	beq	r2,zero,183ec78 <___svfprintf_internal_r+0x171c>
 183e054:	d8c02917 	ldw	r3,164(sp)
 183e058:	00800c04 	movi	r2,48
 183e05c:	d8802705 	stb	r2,156(sp)
 183e060:	dc402745 	stb	r17,157(sp)
 183e064:	d8002785 	stb	zero,158(sp)
 183e068:	90800094 	ori	r2,r18,2
 183e06c:	18048716 	blt	r3,zero,183f28c <___svfprintf_internal_r+0x1d30>
 183e070:	00bfdfc4 	movi	r2,-129
 183e074:	90a4703a 	and	r18,r18,r2
 183e078:	94800094 	ori	r18,r18,2
 183e07c:	0039883a 	mov	fp,zero
 183e080:	d9003a17 	ldw	r4,232(sp)
 183e084:	dc001e04 	addi	r16,sp,120
 183e088:	a08003cc 	andi	r2,r20,15
 183e08c:	b006973a 	slli	r3,r22,28
 183e090:	2085883a 	add	r2,r4,r2
 183e094:	a028d13a 	srli	r20,r20,4
 183e098:	10800003 	ldbu	r2,0(r2)
 183e09c:	b02cd13a 	srli	r22,r22,4
 183e0a0:	843fffc4 	addi	r16,r16,-1
 183e0a4:	1d28b03a 	or	r20,r3,r20
 183e0a8:	80800005 	stb	r2,0(r16)
 183e0ac:	a584b03a 	or	r2,r20,r22
 183e0b0:	103ff51e 	bne	r2,zero,183e088 <__ram_exceptions_end+0xff82dc44>
 183e0b4:	d8c02817 	ldw	r3,160(sp)
 183e0b8:	1c07c83a 	sub	r3,r3,r16
 183e0bc:	d8c02e15 	stw	r3,184(sp)
 183e0c0:	003ece06 	br	183dbfc <__ram_exceptions_end+0xff82d7b8>
 183e0c4:	d8c02d17 	ldw	r3,180(sp)
 183e0c8:	d9002d17 	ldw	r4,180(sp)
 183e0cc:	d8002785 	stb	zero,158(sp)
 183e0d0:	18800017 	ldw	r2,0(r3)
 183e0d4:	21000104 	addi	r4,r4,4
 183e0d8:	00c00044 	movi	r3,1
 183e0dc:	d8c02a15 	stw	r3,168(sp)
 183e0e0:	d8801405 	stb	r2,80(sp)
 183e0e4:	d9002d15 	stw	r4,180(sp)
 183e0e8:	d8c02e15 	stw	r3,184(sp)
 183e0ec:	d8002915 	stw	zero,164(sp)
 183e0f0:	d8003215 	stw	zero,200(sp)
 183e0f4:	dc001404 	addi	r16,sp,80
 183e0f8:	0039883a 	mov	fp,zero
 183e0fc:	003ecc06 	br	183dc30 <__ram_exceptions_end+0xff82d7ec>
 183e100:	18c03fcc 	andi	r3,r3,255
 183e104:	183e9226 	beq	r3,zero,183db50 <__ram_exceptions_end+0xff82d70c>
 183e108:	d9c02785 	stb	r7,158(sp)
 183e10c:	003e9006 	br	183db50 <__ram_exceptions_end+0xff82d70c>
 183e110:	00c00044 	movi	r3,1
 183e114:	01c00ac4 	movi	r7,43
 183e118:	bc400007 	ldb	r17,0(r23)
 183e11c:	003d6306 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e120:	94800814 	ori	r18,r18,32
 183e124:	bc400007 	ldb	r17,0(r23)
 183e128:	003d6006 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e12c:	d8c02d17 	ldw	r3,180(sp)
 183e130:	d8002785 	stb	zero,158(sp)
 183e134:	1c000017 	ldw	r16,0(r3)
 183e138:	1d000104 	addi	r20,r3,4
 183e13c:	80040f26 	beq	r16,zero,183f17c <___svfprintf_internal_r+0x1c20>
 183e140:	d9002917 	ldw	r4,164(sp)
 183e144:	2003dc16 	blt	r4,zero,183f0b8 <___svfprintf_internal_r+0x1b5c>
 183e148:	200d883a 	mov	r6,r4
 183e14c:	000b883a 	mov	r5,zero
 183e150:	8009883a 	mov	r4,r16
 183e154:	da003e15 	stw	r8,248(sp)
 183e158:	1805fa80 	call	1805fa8 <memchr>
 183e15c:	da003e17 	ldw	r8,248(sp)
 183e160:	10045826 	beq	r2,zero,183f2c4 <___svfprintf_internal_r+0x1d68>
 183e164:	1405c83a 	sub	r2,r2,r16
 183e168:	d8802e15 	stw	r2,184(sp)
 183e16c:	1003d816 	blt	r2,zero,183f0d0 <___svfprintf_internal_r+0x1b74>
 183e170:	df002783 	ldbu	fp,158(sp)
 183e174:	d8802a15 	stw	r2,168(sp)
 183e178:	dd002d15 	stw	r20,180(sp)
 183e17c:	d8002915 	stw	zero,164(sp)
 183e180:	d8003215 	stw	zero,200(sp)
 183e184:	003ea306 	br	183dc14 <__ram_exceptions_end+0xff82d7d0>
 183e188:	18c03fcc 	andi	r3,r3,255
 183e18c:	183f8c26 	beq	r3,zero,183dfc0 <__ram_exceptions_end+0xff82db7c>
 183e190:	d9c02785 	stb	r7,158(sp)
 183e194:	003f8a06 	br	183dfc0 <__ram_exceptions_end+0xff82db7c>
 183e198:	18c03fcc 	andi	r3,r3,255
 183e19c:	1805631e 	bne	r3,zero,183f72c <___svfprintf_internal_r+0x21d0>
 183e1a0:	01406134 	movhi	r5,388
 183e1a4:	2944e604 	addi	r5,r5,5016
 183e1a8:	d9403a15 	stw	r5,232(sp)
 183e1ac:	9080080c 	andi	r2,r18,32
 183e1b0:	103f9f1e 	bne	r2,zero,183e030 <__ram_exceptions_end+0xff82dbec>
 183e1b4:	9080040c 	andi	r2,r18,16
 183e1b8:	10029c26 	beq	r2,zero,183ec2c <___svfprintf_internal_r+0x16d0>
 183e1bc:	d8c02d17 	ldw	r3,180(sp)
 183e1c0:	002d883a 	mov	r22,zero
 183e1c4:	1d000017 	ldw	r20,0(r3)
 183e1c8:	18c00104 	addi	r3,r3,4
 183e1cc:	d8c02d15 	stw	r3,180(sp)
 183e1d0:	003f9c06 	br	183e044 <__ram_exceptions_end+0xff82dc00>
 183e1d4:	94800054 	ori	r18,r18,1
 183e1d8:	bc400007 	ldb	r17,0(r23)
 183e1dc:	003d3306 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e1e0:	38803fcc 	andi	r2,r7,255
 183e1e4:	1080201c 	xori	r2,r2,128
 183e1e8:	10bfe004 	addi	r2,r2,-128
 183e1ec:	1002971e 	bne	r2,zero,183ec4c <___svfprintf_internal_r+0x16f0>
 183e1f0:	00c00044 	movi	r3,1
 183e1f4:	01c00804 	movi	r7,32
 183e1f8:	bc400007 	ldb	r17,0(r23)
 183e1fc:	003d2b06 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e200:	18c03fcc 	andi	r3,r3,255
 183e204:	183e2326 	beq	r3,zero,183da94 <__ram_exceptions_end+0xff82d650>
 183e208:	d9c02785 	stb	r7,158(sp)
 183e20c:	003e2106 	br	183da94 <__ram_exceptions_end+0xff82d650>
 183e210:	bc400007 	ldb	r17,0(r23)
 183e214:	8a430426 	beq	r17,r9,183ee28 <___svfprintf_internal_r+0x18cc>
 183e218:	94800414 	ori	r18,r18,16
 183e21c:	003d2306 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e220:	18c03fcc 	andi	r3,r3,255
 183e224:	18053f1e 	bne	r3,zero,183f724 <___svfprintf_internal_r+0x21c8>
 183e228:	9080080c 	andi	r2,r18,32
 183e22c:	10028926 	beq	r2,zero,183ec54 <___svfprintf_internal_r+0x16f8>
 183e230:	d9402d17 	ldw	r5,180(sp)
 183e234:	d9002f17 	ldw	r4,188(sp)
 183e238:	28800017 	ldw	r2,0(r5)
 183e23c:	2007d7fa 	srai	r3,r4,31
 183e240:	29400104 	addi	r5,r5,4
 183e244:	d9402d15 	stw	r5,180(sp)
 183e248:	11000015 	stw	r4,0(r2)
 183e24c:	10c00115 	stw	r3,4(r2)
 183e250:	003ced06 	br	183d608 <__ram_exceptions_end+0xff82d1c4>
 183e254:	94801014 	ori	r18,r18,64
 183e258:	bc400007 	ldb	r17,0(r23)
 183e25c:	003d1306 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183e260:	01006134 	movhi	r4,388
 183e264:	2104e604 	addi	r4,r4,5016
 183e268:	0039883a 	mov	fp,zero
 183e26c:	d9003a15 	stw	r4,232(sp)
 183e270:	04401e04 	movi	r17,120
 183e274:	003f8206 	br	183e080 <__ram_exceptions_end+0xff82dc3c>
 183e278:	18c03fcc 	andi	r3,r3,255
 183e27c:	1805221e 	bne	r3,zero,183f708 <___svfprintf_internal_r+0x21ac>
 183e280:	883d9526 	beq	r17,zero,183d8d8 <__ram_exceptions_end+0xff82d494>
 183e284:	00c00044 	movi	r3,1
 183e288:	d8c02a15 	stw	r3,168(sp)
 183e28c:	dc401405 	stb	r17,80(sp)
 183e290:	d8002785 	stb	zero,158(sp)
 183e294:	003f9406 	br	183e0e8 <__ram_exceptions_end+0xff82dca4>
 183e298:	01006134 	movhi	r4,388
 183e29c:	2104e604 	addi	r4,r4,5016
 183e2a0:	d9003a15 	stw	r4,232(sp)
 183e2a4:	d8c02d15 	stw	r3,180(sp)
 183e2a8:	1025883a 	mov	r18,r2
 183e2ac:	04401e04 	movi	r17,120
 183e2b0:	a584b03a 	or	r2,r20,r22
 183e2b4:	1000fa1e 	bne	r2,zero,183e6a0 <___svfprintf_internal_r+0x1144>
 183e2b8:	0039883a 	mov	fp,zero
 183e2bc:	00800084 	movi	r2,2
 183e2c0:	10803fcc 	andi	r2,r2,255
 183e2c4:	00c00044 	movi	r3,1
 183e2c8:	10c21626 	beq	r2,r3,183eb24 <___svfprintf_internal_r+0x15c8>
 183e2cc:	00c00084 	movi	r3,2
 183e2d0:	10fe301e 	bne	r2,r3,183db94 <__ram_exceptions_end+0xff82d750>
 183e2d4:	003d7606 	br	183d8b0 <__ram_exceptions_end+0xff82d46c>
 183e2d8:	d8c02017 	ldw	r3,128(sp)
 183e2dc:	003e9506 	br	183dd34 <__ram_exceptions_end+0xff82d8f0>
 183e2e0:	00801944 	movi	r2,101
 183e2e4:	14407c0e 	bge	r2,r17,183e4d8 <___svfprintf_internal_r+0xf7c>
 183e2e8:	d9003617 	ldw	r4,216(sp)
 183e2ec:	d9403717 	ldw	r5,220(sp)
 183e2f0:	000d883a 	mov	r6,zero
 183e2f4:	000f883a 	mov	r7,zero
 183e2f8:	d8c03d15 	stw	r3,244(sp)
 183e2fc:	da003e15 	stw	r8,248(sp)
 183e300:	180bf600 	call	180bf60 <__eqdf2>
 183e304:	d8c03d17 	ldw	r3,244(sp)
 183e308:	da003e17 	ldw	r8,248(sp)
 183e30c:	1000f51e 	bne	r2,zero,183e6e4 <___svfprintf_internal_r+0x1188>
 183e310:	d8801f17 	ldw	r2,124(sp)
 183e314:	01006134 	movhi	r4,388
 183e318:	2104ed04 	addi	r4,r4,5044
 183e31c:	18c00044 	addi	r3,r3,1
 183e320:	10800044 	addi	r2,r2,1
 183e324:	41000015 	stw	r4,0(r8)
 183e328:	01000044 	movi	r4,1
 183e32c:	41000115 	stw	r4,4(r8)
 183e330:	d8c02015 	stw	r3,128(sp)
 183e334:	d8801f15 	stw	r2,124(sp)
 183e338:	010001c4 	movi	r4,7
 183e33c:	20826616 	blt	r4,r2,183ecd8 <___svfprintf_internal_r+0x177c>
 183e340:	42000204 	addi	r8,r8,8
 183e344:	d8802617 	ldw	r2,152(sp)
 183e348:	d9403317 	ldw	r5,204(sp)
 183e34c:	11400216 	blt	r2,r5,183e358 <___svfprintf_internal_r+0xdfc>
 183e350:	9080004c 	andi	r2,r18,1
 183e354:	103ed526 	beq	r2,zero,183deac <__ram_exceptions_end+0xff82da68>
 183e358:	d8803817 	ldw	r2,224(sp)
 183e35c:	d9003417 	ldw	r4,208(sp)
 183e360:	d9403817 	ldw	r5,224(sp)
 183e364:	1887883a 	add	r3,r3,r2
 183e368:	d8801f17 	ldw	r2,124(sp)
 183e36c:	41000015 	stw	r4,0(r8)
 183e370:	41400115 	stw	r5,4(r8)
 183e374:	10800044 	addi	r2,r2,1
 183e378:	d8c02015 	stw	r3,128(sp)
 183e37c:	d8801f15 	stw	r2,124(sp)
 183e380:	010001c4 	movi	r4,7
 183e384:	2082af16 	blt	r4,r2,183ee44 <___svfprintf_internal_r+0x18e8>
 183e388:	42000204 	addi	r8,r8,8
 183e38c:	d8803317 	ldw	r2,204(sp)
 183e390:	143fffc4 	addi	r16,r2,-1
 183e394:	043ec50e 	bge	zero,r16,183deac <__ram_exceptions_end+0xff82da68>
 183e398:	04400404 	movi	r17,16
 183e39c:	d8801f17 	ldw	r2,124(sp)
 183e3a0:	8c00860e 	bge	r17,r16,183e5bc <___svfprintf_internal_r+0x1060>
 183e3a4:	01406134 	movhi	r5,388
 183e3a8:	294fbc04 	addi	r5,r5,16112
 183e3ac:	d9402b15 	stw	r5,172(sp)
 183e3b0:	058001c4 	movi	r22,7
 183e3b4:	dd002c17 	ldw	r20,176(sp)
 183e3b8:	00000306 	br	183e3c8 <___svfprintf_internal_r+0xe6c>
 183e3bc:	42000204 	addi	r8,r8,8
 183e3c0:	843ffc04 	addi	r16,r16,-16
 183e3c4:	8c00800e 	bge	r17,r16,183e5c8 <___svfprintf_internal_r+0x106c>
 183e3c8:	18c00404 	addi	r3,r3,16
 183e3cc:	10800044 	addi	r2,r2,1
 183e3d0:	45400015 	stw	r21,0(r8)
 183e3d4:	44400115 	stw	r17,4(r8)
 183e3d8:	d8c02015 	stw	r3,128(sp)
 183e3dc:	d8801f15 	stw	r2,124(sp)
 183e3e0:	b0bff60e 	bge	r22,r2,183e3bc <__ram_exceptions_end+0xff82df78>
 183e3e4:	d9801e04 	addi	r6,sp,120
 183e3e8:	a00b883a 	mov	r5,r20
 183e3ec:	9809883a 	mov	r4,r19
 183e3f0:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e3f4:	103d3e1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e3f8:	d8c02017 	ldw	r3,128(sp)
 183e3fc:	d8801f17 	ldw	r2,124(sp)
 183e400:	da000404 	addi	r8,sp,16
 183e404:	003fee06 	br	183e3c0 <__ram_exceptions_end+0xff82df7c>
 183e408:	d9403117 	ldw	r5,196(sp)
 183e40c:	d8802a17 	ldw	r2,168(sp)
 183e410:	28adc83a 	sub	r22,r5,r2
 183e414:	05be650e 	bge	zero,r22,183ddac <__ram_exceptions_end+0xff82d968>
 183e418:	07000404 	movi	fp,16
 183e41c:	d8801f17 	ldw	r2,124(sp)
 183e420:	e583a20e 	bge	fp,r22,183f2ac <___svfprintf_internal_r+0x1d50>
 183e424:	01406134 	movhi	r5,388
 183e428:	294fbc04 	addi	r5,r5,16112
 183e42c:	dc403015 	stw	r17,192(sp)
 183e430:	d9402b15 	stw	r5,172(sp)
 183e434:	b023883a 	mov	r17,r22
 183e438:	050001c4 	movi	r20,7
 183e43c:	902d883a 	mov	r22,r18
 183e440:	8025883a 	mov	r18,r16
 183e444:	dc002c17 	ldw	r16,176(sp)
 183e448:	00000306 	br	183e458 <___svfprintf_internal_r+0xefc>
 183e44c:	8c7ffc04 	addi	r17,r17,-16
 183e450:	42000204 	addi	r8,r8,8
 183e454:	e440110e 	bge	fp,r17,183e49c <___svfprintf_internal_r+0xf40>
 183e458:	18c00404 	addi	r3,r3,16
 183e45c:	10800044 	addi	r2,r2,1
 183e460:	45400015 	stw	r21,0(r8)
 183e464:	47000115 	stw	fp,4(r8)
 183e468:	d8c02015 	stw	r3,128(sp)
 183e46c:	d8801f15 	stw	r2,124(sp)
 183e470:	a0bff60e 	bge	r20,r2,183e44c <__ram_exceptions_end+0xff82e008>
 183e474:	d9801e04 	addi	r6,sp,120
 183e478:	800b883a 	mov	r5,r16
 183e47c:	9809883a 	mov	r4,r19
 183e480:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e484:	103d1a1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e488:	8c7ffc04 	addi	r17,r17,-16
 183e48c:	d8c02017 	ldw	r3,128(sp)
 183e490:	d8801f17 	ldw	r2,124(sp)
 183e494:	da000404 	addi	r8,sp,16
 183e498:	e47fef16 	blt	fp,r17,183e458 <__ram_exceptions_end+0xff82e014>
 183e49c:	9021883a 	mov	r16,r18
 183e4a0:	b025883a 	mov	r18,r22
 183e4a4:	882d883a 	mov	r22,r17
 183e4a8:	dc403017 	ldw	r17,192(sp)
 183e4ac:	d9002b17 	ldw	r4,172(sp)
 183e4b0:	1d87883a 	add	r3,r3,r22
 183e4b4:	10800044 	addi	r2,r2,1
 183e4b8:	41000015 	stw	r4,0(r8)
 183e4bc:	45800115 	stw	r22,4(r8)
 183e4c0:	d8c02015 	stw	r3,128(sp)
 183e4c4:	d8801f15 	stw	r2,124(sp)
 183e4c8:	010001c4 	movi	r4,7
 183e4cc:	20819a16 	blt	r4,r2,183eb38 <___svfprintf_internal_r+0x15dc>
 183e4d0:	42000204 	addi	r8,r8,8
 183e4d4:	003e3506 	br	183ddac <__ram_exceptions_end+0xff82d968>
 183e4d8:	d9403317 	ldw	r5,204(sp)
 183e4dc:	00800044 	movi	r2,1
 183e4e0:	18c00044 	addi	r3,r3,1
 183e4e4:	1141710e 	bge	r2,r5,183eaac <___svfprintf_internal_r+0x1550>
 183e4e8:	dc401f17 	ldw	r17,124(sp)
 183e4ec:	00800044 	movi	r2,1
 183e4f0:	40800115 	stw	r2,4(r8)
 183e4f4:	8c400044 	addi	r17,r17,1
 183e4f8:	44000015 	stw	r16,0(r8)
 183e4fc:	d8c02015 	stw	r3,128(sp)
 183e500:	dc401f15 	stw	r17,124(sp)
 183e504:	008001c4 	movi	r2,7
 183e508:	14417416 	blt	r2,r17,183eadc <___svfprintf_internal_r+0x1580>
 183e50c:	42000204 	addi	r8,r8,8
 183e510:	d8803817 	ldw	r2,224(sp)
 183e514:	d9003417 	ldw	r4,208(sp)
 183e518:	8c400044 	addi	r17,r17,1
 183e51c:	10c7883a 	add	r3,r2,r3
 183e520:	40800115 	stw	r2,4(r8)
 183e524:	41000015 	stw	r4,0(r8)
 183e528:	d8c02015 	stw	r3,128(sp)
 183e52c:	dc401f15 	stw	r17,124(sp)
 183e530:	008001c4 	movi	r2,7
 183e534:	14417216 	blt	r2,r17,183eb00 <___svfprintf_internal_r+0x15a4>
 183e538:	45800204 	addi	r22,r8,8
 183e53c:	d9003617 	ldw	r4,216(sp)
 183e540:	d9403717 	ldw	r5,220(sp)
 183e544:	000d883a 	mov	r6,zero
 183e548:	000f883a 	mov	r7,zero
 183e54c:	d8c03d15 	stw	r3,244(sp)
 183e550:	180bf600 	call	180bf60 <__eqdf2>
 183e554:	d8c03d17 	ldw	r3,244(sp)
 183e558:	1000b326 	beq	r2,zero,183e828 <___svfprintf_internal_r+0x12cc>
 183e55c:	d9403317 	ldw	r5,204(sp)
 183e560:	84000044 	addi	r16,r16,1
 183e564:	8c400044 	addi	r17,r17,1
 183e568:	28bfffc4 	addi	r2,r5,-1
 183e56c:	1887883a 	add	r3,r3,r2
 183e570:	b0800115 	stw	r2,4(r22)
 183e574:	b4000015 	stw	r16,0(r22)
 183e578:	d8c02015 	stw	r3,128(sp)
 183e57c:	dc401f15 	stw	r17,124(sp)
 183e580:	008001c4 	movi	r2,7
 183e584:	1440d216 	blt	r2,r17,183e8d0 <___svfprintf_internal_r+0x1374>
 183e588:	b5800204 	addi	r22,r22,8
 183e58c:	d9003b17 	ldw	r4,236(sp)
 183e590:	df0022c4 	addi	fp,sp,139
 183e594:	8c400044 	addi	r17,r17,1
 183e598:	20c7883a 	add	r3,r4,r3
 183e59c:	b7000015 	stw	fp,0(r22)
 183e5a0:	b1000115 	stw	r4,4(r22)
 183e5a4:	d8c02015 	stw	r3,128(sp)
 183e5a8:	dc401f15 	stw	r17,124(sp)
 183e5ac:	008001c4 	movi	r2,7
 183e5b0:	14400e16 	blt	r2,r17,183e5ec <___svfprintf_internal_r+0x1090>
 183e5b4:	b2000204 	addi	r8,r22,8
 183e5b8:	003e3c06 	br	183deac <__ram_exceptions_end+0xff82da68>
 183e5bc:	01006134 	movhi	r4,388
 183e5c0:	210fbc04 	addi	r4,r4,16112
 183e5c4:	d9002b15 	stw	r4,172(sp)
 183e5c8:	d9002b17 	ldw	r4,172(sp)
 183e5cc:	1c07883a 	add	r3,r3,r16
 183e5d0:	44000115 	stw	r16,4(r8)
 183e5d4:	41000015 	stw	r4,0(r8)
 183e5d8:	10800044 	addi	r2,r2,1
 183e5dc:	d8c02015 	stw	r3,128(sp)
 183e5e0:	d8801f15 	stw	r2,124(sp)
 183e5e4:	010001c4 	movi	r4,7
 183e5e8:	20be2f0e 	bge	r4,r2,183dea8 <__ram_exceptions_end+0xff82da64>
 183e5ec:	d9402c17 	ldw	r5,176(sp)
 183e5f0:	d9801e04 	addi	r6,sp,120
 183e5f4:	9809883a 	mov	r4,r19
 183e5f8:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e5fc:	103cbc1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e600:	d8c02017 	ldw	r3,128(sp)
 183e604:	da000404 	addi	r8,sp,16
 183e608:	003e2806 	br	183deac <__ram_exceptions_end+0xff82da68>
 183e60c:	d9402c17 	ldw	r5,176(sp)
 183e610:	d9801e04 	addi	r6,sp,120
 183e614:	9809883a 	mov	r4,r19
 183e618:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e61c:	103e5f26 	beq	r2,zero,183df9c <__ram_exceptions_end+0xff82db58>
 183e620:	003cb306 	br	183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e624:	d9402c17 	ldw	r5,176(sp)
 183e628:	d9801e04 	addi	r6,sp,120
 183e62c:	9809883a 	mov	r4,r19
 183e630:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e634:	103cae1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e638:	d8c02017 	ldw	r3,128(sp)
 183e63c:	da000404 	addi	r8,sp,16
 183e640:	003e0d06 	br	183de78 <__ram_exceptions_end+0xff82da34>
 183e644:	d9402c17 	ldw	r5,176(sp)
 183e648:	d9801e04 	addi	r6,sp,120
 183e64c:	9809883a 	mov	r4,r19
 183e650:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e654:	103ca61e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e658:	d8c02017 	ldw	r3,128(sp)
 183e65c:	da000404 	addi	r8,sp,16
 183e660:	003dc106 	br	183dd68 <__ram_exceptions_end+0xff82d924>
 183e664:	d9402c17 	ldw	r5,176(sp)
 183e668:	d9801e04 	addi	r6,sp,120
 183e66c:	9809883a 	mov	r4,r19
 183e670:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e674:	103c9e1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e678:	d8c02017 	ldw	r3,128(sp)
 183e67c:	da000404 	addi	r8,sp,16
 183e680:	003dc706 	br	183dda0 <__ram_exceptions_end+0xff82d95c>
 183e684:	d8802917 	ldw	r2,164(sp)
 183e688:	d8002785 	stb	zero,158(sp)
 183e68c:	103f0816 	blt	r2,zero,183e2b0 <__ram_exceptions_end+0xff82de6c>
 183e690:	00ffdfc4 	movi	r3,-129
 183e694:	a584b03a 	or	r2,r20,r22
 183e698:	90e4703a 	and	r18,r18,r3
 183e69c:	103c8126 	beq	r2,zero,183d8a4 <__ram_exceptions_end+0xff82d460>
 183e6a0:	0039883a 	mov	fp,zero
 183e6a4:	003e7606 	br	183e080 <__ram_exceptions_end+0xff82dc3c>
 183e6a8:	9080040c 	andi	r2,r18,16
 183e6ac:	10013d26 	beq	r2,zero,183eba4 <___svfprintf_internal_r+0x1648>
 183e6b0:	d9002d17 	ldw	r4,180(sp)
 183e6b4:	d9402917 	ldw	r5,164(sp)
 183e6b8:	d8002785 	stb	zero,158(sp)
 183e6bc:	20800104 	addi	r2,r4,4
 183e6c0:	25000017 	ldw	r20,0(r4)
 183e6c4:	002d883a 	mov	r22,zero
 183e6c8:	28013f16 	blt	r5,zero,183ebc8 <___svfprintf_internal_r+0x166c>
 183e6cc:	00ffdfc4 	movi	r3,-129
 183e6d0:	d8802d15 	stw	r2,180(sp)
 183e6d4:	90e4703a 	and	r18,r18,r3
 183e6d8:	a03d2b26 	beq	r20,zero,183db88 <__ram_exceptions_end+0xff82d744>
 183e6dc:	0039883a 	mov	fp,zero
 183e6e0:	003d2e06 	br	183db9c <__ram_exceptions_end+0xff82d758>
 183e6e4:	dc402617 	ldw	r17,152(sp)
 183e6e8:	0441830e 	bge	zero,r17,183ecf8 <___svfprintf_internal_r+0x179c>
 183e6ec:	dc403217 	ldw	r17,200(sp)
 183e6f0:	d8803317 	ldw	r2,204(sp)
 183e6f4:	1440010e 	bge	r2,r17,183e6fc <___svfprintf_internal_r+0x11a0>
 183e6f8:	1023883a 	mov	r17,r2
 183e6fc:	04400a0e 	bge	zero,r17,183e728 <___svfprintf_internal_r+0x11cc>
 183e700:	d8801f17 	ldw	r2,124(sp)
 183e704:	1c47883a 	add	r3,r3,r17
 183e708:	44000015 	stw	r16,0(r8)
 183e70c:	10800044 	addi	r2,r2,1
 183e710:	44400115 	stw	r17,4(r8)
 183e714:	d8c02015 	stw	r3,128(sp)
 183e718:	d8801f15 	stw	r2,124(sp)
 183e71c:	010001c4 	movi	r4,7
 183e720:	20827516 	blt	r4,r2,183f0f8 <___svfprintf_internal_r+0x1b9c>
 183e724:	42000204 	addi	r8,r8,8
 183e728:	88027b16 	blt	r17,zero,183f118 <___svfprintf_internal_r+0x1bbc>
 183e72c:	d9003217 	ldw	r4,200(sp)
 183e730:	2463c83a 	sub	r17,r4,r17
 183e734:	0440990e 	bge	zero,r17,183e99c <___svfprintf_internal_r+0x1440>
 183e738:	05800404 	movi	r22,16
 183e73c:	d8801f17 	ldw	r2,124(sp)
 183e740:	b441530e 	bge	r22,r17,183ec90 <___svfprintf_internal_r+0x1734>
 183e744:	01006134 	movhi	r4,388
 183e748:	210fbc04 	addi	r4,r4,16112
 183e74c:	d9002b15 	stw	r4,172(sp)
 183e750:	070001c4 	movi	fp,7
 183e754:	dd002c17 	ldw	r20,176(sp)
 183e758:	00000306 	br	183e768 <___svfprintf_internal_r+0x120c>
 183e75c:	42000204 	addi	r8,r8,8
 183e760:	8c7ffc04 	addi	r17,r17,-16
 183e764:	b4414d0e 	bge	r22,r17,183ec9c <___svfprintf_internal_r+0x1740>
 183e768:	18c00404 	addi	r3,r3,16
 183e76c:	10800044 	addi	r2,r2,1
 183e770:	45400015 	stw	r21,0(r8)
 183e774:	45800115 	stw	r22,4(r8)
 183e778:	d8c02015 	stw	r3,128(sp)
 183e77c:	d8801f15 	stw	r2,124(sp)
 183e780:	e0bff60e 	bge	fp,r2,183e75c <__ram_exceptions_end+0xff82e318>
 183e784:	d9801e04 	addi	r6,sp,120
 183e788:	a00b883a 	mov	r5,r20
 183e78c:	9809883a 	mov	r4,r19
 183e790:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e794:	103c561e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e798:	d8c02017 	ldw	r3,128(sp)
 183e79c:	d8801f17 	ldw	r2,124(sp)
 183e7a0:	da000404 	addi	r8,sp,16
 183e7a4:	003fee06 	br	183e760 <__ram_exceptions_end+0xff82e31c>
 183e7a8:	d9402c17 	ldw	r5,176(sp)
 183e7ac:	d9801e04 	addi	r6,sp,120
 183e7b0:	9809883a 	mov	r4,r19
 183e7b4:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e7b8:	103c4d1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e7bc:	d8c02017 	ldw	r3,128(sp)
 183e7c0:	df002787 	ldb	fp,158(sp)
 183e7c4:	da000404 	addi	r8,sp,16
 183e7c8:	003d5a06 	br	183dd34 <__ram_exceptions_end+0xff82d8f0>
 183e7cc:	9080040c 	andi	r2,r18,16
 183e7d0:	10005c26 	beq	r2,zero,183e944 <___svfprintf_internal_r+0x13e8>
 183e7d4:	d9402d17 	ldw	r5,180(sp)
 183e7d8:	d8c02917 	ldw	r3,164(sp)
 183e7dc:	d8002785 	stb	zero,158(sp)
 183e7e0:	28800104 	addi	r2,r5,4
 183e7e4:	2d000017 	ldw	r20,0(r5)
 183e7e8:	002d883a 	mov	r22,zero
 183e7ec:	18005e16 	blt	r3,zero,183e968 <___svfprintf_internal_r+0x140c>
 183e7f0:	00ffdfc4 	movi	r3,-129
 183e7f4:	d8802d15 	stw	r2,180(sp)
 183e7f8:	90e4703a 	and	r18,r18,r3
 183e7fc:	0039883a 	mov	fp,zero
 183e800:	a03dfe26 	beq	r20,zero,183dffc <__ram_exceptions_end+0xff82dbb8>
 183e804:	00800244 	movi	r2,9
 183e808:	153cb336 	bltu	r2,r20,183dad8 <__ram_exceptions_end+0xff82d694>
 183e80c:	a5000c04 	addi	r20,r20,48
 183e810:	dc001dc4 	addi	r16,sp,119
 183e814:	dd001dc5 	stb	r20,119(sp)
 183e818:	d8c02817 	ldw	r3,160(sp)
 183e81c:	1c07c83a 	sub	r3,r3,r16
 183e820:	d8c02e15 	stw	r3,184(sp)
 183e824:	003cf506 	br	183dbfc <__ram_exceptions_end+0xff82d7b8>
 183e828:	d8803317 	ldw	r2,204(sp)
 183e82c:	143fffc4 	addi	r16,r2,-1
 183e830:	043f560e 	bge	zero,r16,183e58c <__ram_exceptions_end+0xff82e148>
 183e834:	07000404 	movi	fp,16
 183e838:	e403530e 	bge	fp,r16,183f588 <___svfprintf_internal_r+0x202c>
 183e83c:	01406134 	movhi	r5,388
 183e840:	294fbc04 	addi	r5,r5,16112
 183e844:	d9402b15 	stw	r5,172(sp)
 183e848:	01c001c4 	movi	r7,7
 183e84c:	dd002c17 	ldw	r20,176(sp)
 183e850:	00000306 	br	183e860 <___svfprintf_internal_r+0x1304>
 183e854:	843ffc04 	addi	r16,r16,-16
 183e858:	b5800204 	addi	r22,r22,8
 183e85c:	e400130e 	bge	fp,r16,183e8ac <___svfprintf_internal_r+0x1350>
 183e860:	18c00404 	addi	r3,r3,16
 183e864:	8c400044 	addi	r17,r17,1
 183e868:	b5400015 	stw	r21,0(r22)
 183e86c:	b7000115 	stw	fp,4(r22)
 183e870:	d8c02015 	stw	r3,128(sp)
 183e874:	dc401f15 	stw	r17,124(sp)
 183e878:	3c7ff60e 	bge	r7,r17,183e854 <__ram_exceptions_end+0xff82e410>
 183e87c:	d9801e04 	addi	r6,sp,120
 183e880:	a00b883a 	mov	r5,r20
 183e884:	9809883a 	mov	r4,r19
 183e888:	d9c03d15 	stw	r7,244(sp)
 183e88c:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e890:	d9c03d17 	ldw	r7,244(sp)
 183e894:	103c161e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e898:	843ffc04 	addi	r16,r16,-16
 183e89c:	d8c02017 	ldw	r3,128(sp)
 183e8a0:	dc401f17 	ldw	r17,124(sp)
 183e8a4:	dd800404 	addi	r22,sp,16
 183e8a8:	e43fed16 	blt	fp,r16,183e860 <__ram_exceptions_end+0xff82e41c>
 183e8ac:	d8802b17 	ldw	r2,172(sp)
 183e8b0:	1c07883a 	add	r3,r3,r16
 183e8b4:	8c400044 	addi	r17,r17,1
 183e8b8:	b0800015 	stw	r2,0(r22)
 183e8bc:	b4000115 	stw	r16,4(r22)
 183e8c0:	d8c02015 	stw	r3,128(sp)
 183e8c4:	dc401f15 	stw	r17,124(sp)
 183e8c8:	008001c4 	movi	r2,7
 183e8cc:	147f2e0e 	bge	r2,r17,183e588 <__ram_exceptions_end+0xff82e144>
 183e8d0:	d9402c17 	ldw	r5,176(sp)
 183e8d4:	d9801e04 	addi	r6,sp,120
 183e8d8:	9809883a 	mov	r4,r19
 183e8dc:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e8e0:	103c031e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e8e4:	d8c02017 	ldw	r3,128(sp)
 183e8e8:	dc401f17 	ldw	r17,124(sp)
 183e8ec:	dd800404 	addi	r22,sp,16
 183e8f0:	003f2606 	br	183e58c <__ram_exceptions_end+0xff82e148>
 183e8f4:	9080040c 	andi	r2,r18,16
 183e8f8:	1000c326 	beq	r2,zero,183ec08 <___svfprintf_internal_r+0x16ac>
 183e8fc:	d8802d17 	ldw	r2,180(sp)
 183e900:	15000017 	ldw	r20,0(r2)
 183e904:	10800104 	addi	r2,r2,4
 183e908:	d8802d15 	stw	r2,180(sp)
 183e90c:	a02dd7fa 	srai	r22,r20,31
 183e910:	b005883a 	mov	r2,r22
 183e914:	103c680e 	bge	r2,zero,183dab8 <__ram_exceptions_end+0xff82d674>
 183e918:	0529c83a 	sub	r20,zero,r20
 183e91c:	a004c03a 	cmpne	r2,r20,zero
 183e920:	05adc83a 	sub	r22,zero,r22
 183e924:	b0adc83a 	sub	r22,r22,r2
 183e928:	d8802917 	ldw	r2,164(sp)
 183e92c:	07000b44 	movi	fp,45
 183e930:	df002785 	stb	fp,158(sp)
 183e934:	10022e16 	blt	r2,zero,183f1f0 <___svfprintf_internal_r+0x1c94>
 183e938:	00bfdfc4 	movi	r2,-129
 183e93c:	90a4703a 	and	r18,r18,r2
 183e940:	003c6406 	br	183dad4 <__ram_exceptions_end+0xff82d690>
 183e944:	9080100c 	andi	r2,r18,64
 183e948:	d8002785 	stb	zero,158(sp)
 183e94c:	10012526 	beq	r2,zero,183ede4 <___svfprintf_internal_r+0x1888>
 183e950:	d9002d17 	ldw	r4,180(sp)
 183e954:	d9402917 	ldw	r5,164(sp)
 183e958:	002d883a 	mov	r22,zero
 183e95c:	20800104 	addi	r2,r4,4
 183e960:	2500000b 	ldhu	r20,0(r4)
 183e964:	283fa20e 	bge	r5,zero,183e7f0 <__ram_exceptions_end+0xff82e3ac>
 183e968:	d8802d15 	stw	r2,180(sp)
 183e96c:	0039883a 	mov	fp,zero
 183e970:	a584b03a 	or	r2,r20,r22
 183e974:	103c571e 	bne	r2,zero,183dad4 <__ram_exceptions_end+0xff82d690>
 183e978:	00800044 	movi	r2,1
 183e97c:	003e5006 	br	183e2c0 <__ram_exceptions_end+0xff82de7c>
 183e980:	d9402c17 	ldw	r5,176(sp)
 183e984:	d9801e04 	addi	r6,sp,120
 183e988:	9809883a 	mov	r4,r19
 183e98c:	183f9cc0 	call	183f9cc <__ssprint_r>
 183e990:	103bd71e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183e994:	d8c02017 	ldw	r3,128(sp)
 183e998:	da000404 	addi	r8,sp,16
 183e99c:	d9003217 	ldw	r4,200(sp)
 183e9a0:	d8802617 	ldw	r2,152(sp)
 183e9a4:	d9403317 	ldw	r5,204(sp)
 183e9a8:	8123883a 	add	r17,r16,r4
 183e9ac:	11400216 	blt	r2,r5,183e9b8 <___svfprintf_internal_r+0x145c>
 183e9b0:	9100004c 	andi	r4,r18,1
 183e9b4:	20000d26 	beq	r4,zero,183e9ec <___svfprintf_internal_r+0x1490>
 183e9b8:	d9003817 	ldw	r4,224(sp)
 183e9bc:	d9403417 	ldw	r5,208(sp)
 183e9c0:	1907883a 	add	r3,r3,r4
 183e9c4:	d9001f17 	ldw	r4,124(sp)
 183e9c8:	41400015 	stw	r5,0(r8)
 183e9cc:	d9403817 	ldw	r5,224(sp)
 183e9d0:	21000044 	addi	r4,r4,1
 183e9d4:	d8c02015 	stw	r3,128(sp)
 183e9d8:	41400115 	stw	r5,4(r8)
 183e9dc:	d9001f15 	stw	r4,124(sp)
 183e9e0:	014001c4 	movi	r5,7
 183e9e4:	2901dc16 	blt	r5,r4,183f158 <___svfprintf_internal_r+0x1bfc>
 183e9e8:	42000204 	addi	r8,r8,8
 183e9ec:	d9003317 	ldw	r4,204(sp)
 183e9f0:	8121883a 	add	r16,r16,r4
 183e9f4:	2085c83a 	sub	r2,r4,r2
 183e9f8:	8461c83a 	sub	r16,r16,r17
 183e9fc:	1400010e 	bge	r2,r16,183ea04 <___svfprintf_internal_r+0x14a8>
 183ea00:	1021883a 	mov	r16,r2
 183ea04:	04000a0e 	bge	zero,r16,183ea30 <___svfprintf_internal_r+0x14d4>
 183ea08:	d9001f17 	ldw	r4,124(sp)
 183ea0c:	1c07883a 	add	r3,r3,r16
 183ea10:	44400015 	stw	r17,0(r8)
 183ea14:	21000044 	addi	r4,r4,1
 183ea18:	44000115 	stw	r16,4(r8)
 183ea1c:	d8c02015 	stw	r3,128(sp)
 183ea20:	d9001f15 	stw	r4,124(sp)
 183ea24:	014001c4 	movi	r5,7
 183ea28:	2901e616 	blt	r5,r4,183f1c4 <___svfprintf_internal_r+0x1c68>
 183ea2c:	42000204 	addi	r8,r8,8
 183ea30:	8001f616 	blt	r16,zero,183f20c <___svfprintf_internal_r+0x1cb0>
 183ea34:	1421c83a 	sub	r16,r2,r16
 183ea38:	043d1c0e 	bge	zero,r16,183deac <__ram_exceptions_end+0xff82da68>
 183ea3c:	04400404 	movi	r17,16
 183ea40:	d8801f17 	ldw	r2,124(sp)
 183ea44:	8c3edd0e 	bge	r17,r16,183e5bc <__ram_exceptions_end+0xff82e178>
 183ea48:	01406134 	movhi	r5,388
 183ea4c:	294fbc04 	addi	r5,r5,16112
 183ea50:	d9402b15 	stw	r5,172(sp)
 183ea54:	058001c4 	movi	r22,7
 183ea58:	dd002c17 	ldw	r20,176(sp)
 183ea5c:	00000306 	br	183ea6c <___svfprintf_internal_r+0x1510>
 183ea60:	42000204 	addi	r8,r8,8
 183ea64:	843ffc04 	addi	r16,r16,-16
 183ea68:	8c3ed70e 	bge	r17,r16,183e5c8 <__ram_exceptions_end+0xff82e184>
 183ea6c:	18c00404 	addi	r3,r3,16
 183ea70:	10800044 	addi	r2,r2,1
 183ea74:	45400015 	stw	r21,0(r8)
 183ea78:	44400115 	stw	r17,4(r8)
 183ea7c:	d8c02015 	stw	r3,128(sp)
 183ea80:	d8801f15 	stw	r2,124(sp)
 183ea84:	b0bff60e 	bge	r22,r2,183ea60 <__ram_exceptions_end+0xff82e61c>
 183ea88:	d9801e04 	addi	r6,sp,120
 183ea8c:	a00b883a 	mov	r5,r20
 183ea90:	9809883a 	mov	r4,r19
 183ea94:	183f9cc0 	call	183f9cc <__ssprint_r>
 183ea98:	103b951e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183ea9c:	d8c02017 	ldw	r3,128(sp)
 183eaa0:	d8801f17 	ldw	r2,124(sp)
 183eaa4:	da000404 	addi	r8,sp,16
 183eaa8:	003fee06 	br	183ea64 <__ram_exceptions_end+0xff82e620>
 183eaac:	9088703a 	and	r4,r18,r2
 183eab0:	203e8d1e 	bne	r4,zero,183e4e8 <__ram_exceptions_end+0xff82e0a4>
 183eab4:	dc401f17 	ldw	r17,124(sp)
 183eab8:	40800115 	stw	r2,4(r8)
 183eabc:	44000015 	stw	r16,0(r8)
 183eac0:	8c400044 	addi	r17,r17,1
 183eac4:	d8c02015 	stw	r3,128(sp)
 183eac8:	dc401f15 	stw	r17,124(sp)
 183eacc:	008001c4 	movi	r2,7
 183ead0:	147f7f16 	blt	r2,r17,183e8d0 <__ram_exceptions_end+0xff82e48c>
 183ead4:	45800204 	addi	r22,r8,8
 183ead8:	003eac06 	br	183e58c <__ram_exceptions_end+0xff82e148>
 183eadc:	d9402c17 	ldw	r5,176(sp)
 183eae0:	d9801e04 	addi	r6,sp,120
 183eae4:	9809883a 	mov	r4,r19
 183eae8:	183f9cc0 	call	183f9cc <__ssprint_r>
 183eaec:	103b801e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183eaf0:	d8c02017 	ldw	r3,128(sp)
 183eaf4:	dc401f17 	ldw	r17,124(sp)
 183eaf8:	da000404 	addi	r8,sp,16
 183eafc:	003e8406 	br	183e510 <__ram_exceptions_end+0xff82e0cc>
 183eb00:	d9402c17 	ldw	r5,176(sp)
 183eb04:	d9801e04 	addi	r6,sp,120
 183eb08:	9809883a 	mov	r4,r19
 183eb0c:	183f9cc0 	call	183f9cc <__ssprint_r>
 183eb10:	103b771e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183eb14:	d8c02017 	ldw	r3,128(sp)
 183eb18:	dc401f17 	ldw	r17,124(sp)
 183eb1c:	dd800404 	addi	r22,sp,16
 183eb20:	003e8606 	br	183e53c <__ram_exceptions_end+0xff82e0f8>
 183eb24:	0029883a 	mov	r20,zero
 183eb28:	a5000c04 	addi	r20,r20,48
 183eb2c:	dc001dc4 	addi	r16,sp,119
 183eb30:	dd001dc5 	stb	r20,119(sp)
 183eb34:	003f3806 	br	183e818 <__ram_exceptions_end+0xff82e3d4>
 183eb38:	d9402c17 	ldw	r5,176(sp)
 183eb3c:	d9801e04 	addi	r6,sp,120
 183eb40:	9809883a 	mov	r4,r19
 183eb44:	183f9cc0 	call	183f9cc <__ssprint_r>
 183eb48:	103b691e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183eb4c:	d8c02017 	ldw	r3,128(sp)
 183eb50:	da000404 	addi	r8,sp,16
 183eb54:	003c9506 	br	183ddac <__ram_exceptions_end+0xff82d968>
 183eb58:	d9003617 	ldw	r4,216(sp)
 183eb5c:	d9403717 	ldw	r5,220(sp)
 183eb60:	da003e15 	stw	r8,248(sp)
 183eb64:	18072f80 	call	18072f8 <__fpclassifyd>
 183eb68:	da003e17 	ldw	r8,248(sp)
 183eb6c:	1000bd1e 	bne	r2,zero,183ee64 <___svfprintf_internal_r+0x1908>
 183eb70:	008011c4 	movi	r2,71
 183eb74:	14411e0e 	bge	r2,r17,183eff0 <___svfprintf_internal_r+0x1a94>
 183eb78:	04006134 	movhi	r16,388
 183eb7c:	8404e004 	addi	r16,r16,4992
 183eb80:	00c000c4 	movi	r3,3
 183eb84:	00bfdfc4 	movi	r2,-129
 183eb88:	d8c02a15 	stw	r3,168(sp)
 183eb8c:	90a4703a 	and	r18,r18,r2
 183eb90:	df002783 	ldbu	fp,158(sp)
 183eb94:	d8c02e15 	stw	r3,184(sp)
 183eb98:	d8002915 	stw	zero,164(sp)
 183eb9c:	d8003215 	stw	zero,200(sp)
 183eba0:	003c1c06 	br	183dc14 <__ram_exceptions_end+0xff82d7d0>
 183eba4:	9080100c 	andi	r2,r18,64
 183eba8:	d8002785 	stb	zero,158(sp)
 183ebac:	10009426 	beq	r2,zero,183ee00 <___svfprintf_internal_r+0x18a4>
 183ebb0:	d8c02d17 	ldw	r3,180(sp)
 183ebb4:	d9002917 	ldw	r4,164(sp)
 183ebb8:	002d883a 	mov	r22,zero
 183ebbc:	18800104 	addi	r2,r3,4
 183ebc0:	1d00000b 	ldhu	r20,0(r3)
 183ebc4:	203ec10e 	bge	r4,zero,183e6cc <__ram_exceptions_end+0xff82e288>
 183ebc8:	a586b03a 	or	r3,r20,r22
 183ebcc:	d8802d15 	stw	r2,180(sp)
 183ebd0:	183ec21e 	bne	r3,zero,183e6dc <__ram_exceptions_end+0xff82e298>
 183ebd4:	0039883a 	mov	fp,zero
 183ebd8:	0005883a 	mov	r2,zero
 183ebdc:	003db806 	br	183e2c0 <__ram_exceptions_end+0xff82de7c>
 183ebe0:	d8802d17 	ldw	r2,180(sp)
 183ebe4:	d8c02d17 	ldw	r3,180(sp)
 183ebe8:	d9002d17 	ldw	r4,180(sp)
 183ebec:	10800017 	ldw	r2,0(r2)
 183ebf0:	18c00117 	ldw	r3,4(r3)
 183ebf4:	21000204 	addi	r4,r4,8
 183ebf8:	d8803615 	stw	r2,216(sp)
 183ebfc:	d8c03715 	stw	r3,220(sp)
 183ec00:	d9002d15 	stw	r4,180(sp)
 183ec04:	003b8206 	br	183da10 <__ram_exceptions_end+0xff82d5cc>
 183ec08:	9080100c 	andi	r2,r18,64
 183ec0c:	10010726 	beq	r2,zero,183f02c <___svfprintf_internal_r+0x1ad0>
 183ec10:	d8c02d17 	ldw	r3,180(sp)
 183ec14:	1d00000f 	ldh	r20,0(r3)
 183ec18:	18c00104 	addi	r3,r3,4
 183ec1c:	d8c02d15 	stw	r3,180(sp)
 183ec20:	a02dd7fa 	srai	r22,r20,31
 183ec24:	b005883a 	mov	r2,r22
 183ec28:	003ba206 	br	183dab4 <__ram_exceptions_end+0xff82d670>
 183ec2c:	9080100c 	andi	r2,r18,64
 183ec30:	10010526 	beq	r2,zero,183f048 <___svfprintf_internal_r+0x1aec>
 183ec34:	d9002d17 	ldw	r4,180(sp)
 183ec38:	002d883a 	mov	r22,zero
 183ec3c:	2500000b 	ldhu	r20,0(r4)
 183ec40:	21000104 	addi	r4,r4,4
 183ec44:	d9002d15 	stw	r4,180(sp)
 183ec48:	003cfe06 	br	183e044 <__ram_exceptions_end+0xff82dc00>
 183ec4c:	bc400007 	ldb	r17,0(r23)
 183ec50:	003a9606 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183ec54:	9080040c 	andi	r2,r18,16
 183ec58:	10010126 	beq	r2,zero,183f060 <___svfprintf_internal_r+0x1b04>
 183ec5c:	d9402d17 	ldw	r5,180(sp)
 183ec60:	d8c02f17 	ldw	r3,188(sp)
 183ec64:	28800017 	ldw	r2,0(r5)
 183ec68:	29400104 	addi	r5,r5,4
 183ec6c:	d9402d15 	stw	r5,180(sp)
 183ec70:	10c00015 	stw	r3,0(r2)
 183ec74:	003a6406 	br	183d608 <__ram_exceptions_end+0xff82d1c4>
 183ec78:	d9002917 	ldw	r4,164(sp)
 183ec7c:	d8002785 	stb	zero,158(sp)
 183ec80:	203d8d16 	blt	r4,zero,183e2b8 <__ram_exceptions_end+0xff82de74>
 183ec84:	00bfdfc4 	movi	r2,-129
 183ec88:	90a4703a 	and	r18,r18,r2
 183ec8c:	003b0506 	br	183d8a4 <__ram_exceptions_end+0xff82d460>
 183ec90:	01406134 	movhi	r5,388
 183ec94:	294fbc04 	addi	r5,r5,16112
 183ec98:	d9402b15 	stw	r5,172(sp)
 183ec9c:	d9402b17 	ldw	r5,172(sp)
 183eca0:	1c47883a 	add	r3,r3,r17
 183eca4:	10800044 	addi	r2,r2,1
 183eca8:	41400015 	stw	r5,0(r8)
 183ecac:	44400115 	stw	r17,4(r8)
 183ecb0:	d8c02015 	stw	r3,128(sp)
 183ecb4:	d8801f15 	stw	r2,124(sp)
 183ecb8:	010001c4 	movi	r4,7
 183ecbc:	20bf3016 	blt	r4,r2,183e980 <__ram_exceptions_end+0xff82e53c>
 183ecc0:	42000204 	addi	r8,r8,8
 183ecc4:	003f3506 	br	183e99c <__ram_exceptions_end+0xff82e558>
 183ecc8:	01006134 	movhi	r4,388
 183eccc:	210fbc04 	addi	r4,r4,16112
 183ecd0:	d9002b15 	stw	r4,172(sp)
 183ecd4:	003c5e06 	br	183de50 <__ram_exceptions_end+0xff82da0c>
 183ecd8:	d9402c17 	ldw	r5,176(sp)
 183ecdc:	d9801e04 	addi	r6,sp,120
 183ece0:	9809883a 	mov	r4,r19
 183ece4:	183f9cc0 	call	183f9cc <__ssprint_r>
 183ece8:	103b011e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183ecec:	d8c02017 	ldw	r3,128(sp)
 183ecf0:	da000404 	addi	r8,sp,16
 183ecf4:	003d9306 	br	183e344 <__ram_exceptions_end+0xff82df00>
 183ecf8:	d8801f17 	ldw	r2,124(sp)
 183ecfc:	01406134 	movhi	r5,388
 183ed00:	01000044 	movi	r4,1
 183ed04:	18c00044 	addi	r3,r3,1
 183ed08:	10800044 	addi	r2,r2,1
 183ed0c:	2944ed04 	addi	r5,r5,5044
 183ed10:	41000115 	stw	r4,4(r8)
 183ed14:	41400015 	stw	r5,0(r8)
 183ed18:	d8c02015 	stw	r3,128(sp)
 183ed1c:	d8801f15 	stw	r2,124(sp)
 183ed20:	010001c4 	movi	r4,7
 183ed24:	2080b516 	blt	r4,r2,183effc <___svfprintf_internal_r+0x1aa0>
 183ed28:	42000204 	addi	r8,r8,8
 183ed2c:	8800041e 	bne	r17,zero,183ed40 <___svfprintf_internal_r+0x17e4>
 183ed30:	d8803317 	ldw	r2,204(sp)
 183ed34:	1000021e 	bne	r2,zero,183ed40 <___svfprintf_internal_r+0x17e4>
 183ed38:	9080004c 	andi	r2,r18,1
 183ed3c:	103c5b26 	beq	r2,zero,183deac <__ram_exceptions_end+0xff82da68>
 183ed40:	d9003817 	ldw	r4,224(sp)
 183ed44:	d8801f17 	ldw	r2,124(sp)
 183ed48:	d9403417 	ldw	r5,208(sp)
 183ed4c:	20c7883a 	add	r3,r4,r3
 183ed50:	10800044 	addi	r2,r2,1
 183ed54:	41000115 	stw	r4,4(r8)
 183ed58:	41400015 	stw	r5,0(r8)
 183ed5c:	d8c02015 	stw	r3,128(sp)
 183ed60:	d8801f15 	stw	r2,124(sp)
 183ed64:	010001c4 	movi	r4,7
 183ed68:	20818016 	blt	r4,r2,183f36c <___svfprintf_internal_r+0x1e10>
 183ed6c:	42000204 	addi	r8,r8,8
 183ed70:	0463c83a 	sub	r17,zero,r17
 183ed74:	0440cb0e 	bge	zero,r17,183f0a4 <___svfprintf_internal_r+0x1b48>
 183ed78:	05800404 	movi	r22,16
 183ed7c:	b440e80e 	bge	r22,r17,183f120 <___svfprintf_internal_r+0x1bc4>
 183ed80:	01406134 	movhi	r5,388
 183ed84:	294fbc04 	addi	r5,r5,16112
 183ed88:	d9402b15 	stw	r5,172(sp)
 183ed8c:	070001c4 	movi	fp,7
 183ed90:	dd002c17 	ldw	r20,176(sp)
 183ed94:	00000306 	br	183eda4 <___svfprintf_internal_r+0x1848>
 183ed98:	42000204 	addi	r8,r8,8
 183ed9c:	8c7ffc04 	addi	r17,r17,-16
 183eda0:	b440e20e 	bge	r22,r17,183f12c <___svfprintf_internal_r+0x1bd0>
 183eda4:	18c00404 	addi	r3,r3,16
 183eda8:	10800044 	addi	r2,r2,1
 183edac:	45400015 	stw	r21,0(r8)
 183edb0:	45800115 	stw	r22,4(r8)
 183edb4:	d8c02015 	stw	r3,128(sp)
 183edb8:	d8801f15 	stw	r2,124(sp)
 183edbc:	e0bff60e 	bge	fp,r2,183ed98 <__ram_exceptions_end+0xff82e954>
 183edc0:	d9801e04 	addi	r6,sp,120
 183edc4:	a00b883a 	mov	r5,r20
 183edc8:	9809883a 	mov	r4,r19
 183edcc:	183f9cc0 	call	183f9cc <__ssprint_r>
 183edd0:	103ac71e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183edd4:	d8c02017 	ldw	r3,128(sp)
 183edd8:	d8801f17 	ldw	r2,124(sp)
 183eddc:	da000404 	addi	r8,sp,16
 183ede0:	003fee06 	br	183ed9c <__ram_exceptions_end+0xff82e958>
 183ede4:	d8c02d17 	ldw	r3,180(sp)
 183ede8:	d9002917 	ldw	r4,164(sp)
 183edec:	002d883a 	mov	r22,zero
 183edf0:	18800104 	addi	r2,r3,4
 183edf4:	1d000017 	ldw	r20,0(r3)
 183edf8:	203e7d0e 	bge	r4,zero,183e7f0 <__ram_exceptions_end+0xff82e3ac>
 183edfc:	003eda06 	br	183e968 <__ram_exceptions_end+0xff82e524>
 183ee00:	d9402d17 	ldw	r5,180(sp)
 183ee04:	d8c02917 	ldw	r3,164(sp)
 183ee08:	002d883a 	mov	r22,zero
 183ee0c:	28800104 	addi	r2,r5,4
 183ee10:	2d000017 	ldw	r20,0(r5)
 183ee14:	183e2d0e 	bge	r3,zero,183e6cc <__ram_exceptions_end+0xff82e288>
 183ee18:	003f6b06 	br	183ebc8 <__ram_exceptions_end+0xff82e784>
 183ee1c:	d8c02d15 	stw	r3,180(sp)
 183ee20:	0039883a 	mov	fp,zero
 183ee24:	003ed206 	br	183e970 <__ram_exceptions_end+0xff82e52c>
 183ee28:	bc400043 	ldbu	r17,1(r23)
 183ee2c:	94800814 	ori	r18,r18,32
 183ee30:	bdc00044 	addi	r23,r23,1
 183ee34:	8c403fcc 	andi	r17,r17,255
 183ee38:	8c40201c 	xori	r17,r17,128
 183ee3c:	8c7fe004 	addi	r17,r17,-128
 183ee40:	003a1a06 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183ee44:	d9402c17 	ldw	r5,176(sp)
 183ee48:	d9801e04 	addi	r6,sp,120
 183ee4c:	9809883a 	mov	r4,r19
 183ee50:	183f9cc0 	call	183f9cc <__ssprint_r>
 183ee54:	103aa61e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183ee58:	d8c02017 	ldw	r3,128(sp)
 183ee5c:	da000404 	addi	r8,sp,16
 183ee60:	003d4a06 	br	183e38c <__ram_exceptions_end+0xff82df48>
 183ee64:	d9002917 	ldw	r4,164(sp)
 183ee68:	05bff7c4 	movi	r22,-33
 183ee6c:	00bfffc4 	movi	r2,-1
 183ee70:	8dac703a 	and	r22,r17,r22
 183ee74:	20806a26 	beq	r4,r2,183f020 <___svfprintf_internal_r+0x1ac4>
 183ee78:	008011c4 	movi	r2,71
 183ee7c:	b0813726 	beq	r22,r2,183f35c <___svfprintf_internal_r+0x1e00>
 183ee80:	d9003717 	ldw	r4,220(sp)
 183ee84:	90c04014 	ori	r3,r18,256
 183ee88:	d8c02b15 	stw	r3,172(sp)
 183ee8c:	20015d16 	blt	r4,zero,183f404 <___svfprintf_internal_r+0x1ea8>
 183ee90:	dd003717 	ldw	r20,220(sp)
 183ee94:	d8002a05 	stb	zero,168(sp)
 183ee98:	00801984 	movi	r2,102
 183ee9c:	88814026 	beq	r17,r2,183f3a0 <___svfprintf_internal_r+0x1e44>
 183eea0:	00801184 	movi	r2,70
 183eea4:	88817126 	beq	r17,r2,183f46c <___svfprintf_internal_r+0x1f10>
 183eea8:	00801144 	movi	r2,69
 183eeac:	b0816226 	beq	r22,r2,183f438 <___svfprintf_internal_r+0x1edc>
 183eeb0:	d8c02917 	ldw	r3,164(sp)
 183eeb4:	d8802104 	addi	r2,sp,132
 183eeb8:	d8800315 	stw	r2,12(sp)
 183eebc:	d9403617 	ldw	r5,216(sp)
 183eec0:	d8802504 	addi	r2,sp,148
 183eec4:	d8800215 	stw	r2,8(sp)
 183eec8:	d8802604 	addi	r2,sp,152
 183eecc:	d8c00015 	stw	r3,0(sp)
 183eed0:	d8800115 	stw	r2,4(sp)
 183eed4:	01c00084 	movi	r7,2
 183eed8:	a00d883a 	mov	r6,r20
 183eedc:	9809883a 	mov	r4,r19
 183eee0:	d8c03d15 	stw	r3,244(sp)
 183eee4:	da003e15 	stw	r8,248(sp)
 183eee8:	18032780 	call	1803278 <_dtoa_r>
 183eeec:	1021883a 	mov	r16,r2
 183eef0:	008019c4 	movi	r2,103
 183eef4:	d8c03d17 	ldw	r3,244(sp)
 183eef8:	da003e17 	ldw	r8,248(sp)
 183eefc:	8880e726 	beq	r17,r2,183f29c <___svfprintf_internal_r+0x1d40>
 183ef00:	008011c4 	movi	r2,71
 183ef04:	8880d426 	beq	r17,r2,183f258 <___svfprintf_internal_r+0x1cfc>
 183ef08:	80f9883a 	add	fp,r16,r3
 183ef0c:	d9003617 	ldw	r4,216(sp)
 183ef10:	000d883a 	mov	r6,zero
 183ef14:	000f883a 	mov	r7,zero
 183ef18:	a00b883a 	mov	r5,r20
 183ef1c:	da003e15 	stw	r8,248(sp)
 183ef20:	180bf600 	call	180bf60 <__eqdf2>
 183ef24:	da003e17 	ldw	r8,248(sp)
 183ef28:	1000e426 	beq	r2,zero,183f2bc <___svfprintf_internal_r+0x1d60>
 183ef2c:	d8802117 	ldw	r2,132(sp)
 183ef30:	1700062e 	bgeu	r2,fp,183ef4c <___svfprintf_internal_r+0x19f0>
 183ef34:	01000c04 	movi	r4,48
 183ef38:	10c00044 	addi	r3,r2,1
 183ef3c:	d8c02115 	stw	r3,132(sp)
 183ef40:	11000005 	stb	r4,0(r2)
 183ef44:	d8802117 	ldw	r2,132(sp)
 183ef48:	173ffb36 	bltu	r2,fp,183ef38 <__ram_exceptions_end+0xff82eaf4>
 183ef4c:	1405c83a 	sub	r2,r2,r16
 183ef50:	d8803315 	stw	r2,204(sp)
 183ef54:	008011c4 	movi	r2,71
 183ef58:	b080c526 	beq	r22,r2,183f270 <___svfprintf_internal_r+0x1d14>
 183ef5c:	00801944 	movi	r2,101
 183ef60:	1441d90e 	bge	r2,r17,183f6c8 <___svfprintf_internal_r+0x216c>
 183ef64:	d8c02617 	ldw	r3,152(sp)
 183ef68:	00801984 	movi	r2,102
 183ef6c:	d8c03215 	stw	r3,200(sp)
 183ef70:	88813426 	beq	r17,r2,183f444 <___svfprintf_internal_r+0x1ee8>
 183ef74:	d8c03217 	ldw	r3,200(sp)
 183ef78:	d9003317 	ldw	r4,204(sp)
 183ef7c:	19012516 	blt	r3,r4,183f414 <___svfprintf_internal_r+0x1eb8>
 183ef80:	9480004c 	andi	r18,r18,1
 183ef84:	9001841e 	bne	r18,zero,183f598 <___svfprintf_internal_r+0x203c>
 183ef88:	1805883a 	mov	r2,r3
 183ef8c:	1801cc16 	blt	r3,zero,183f6c0 <___svfprintf_internal_r+0x2164>
 183ef90:	d8c03217 	ldw	r3,200(sp)
 183ef94:	044019c4 	movi	r17,103
 183ef98:	d8c02e15 	stw	r3,184(sp)
 183ef9c:	df002a07 	ldb	fp,168(sp)
 183efa0:	e000a61e 	bne	fp,zero,183f23c <___svfprintf_internal_r+0x1ce0>
 183efa4:	df002783 	ldbu	fp,158(sp)
 183efa8:	d8802a15 	stw	r2,168(sp)
 183efac:	dc802b17 	ldw	r18,172(sp)
 183efb0:	d8002915 	stw	zero,164(sp)
 183efb4:	003b1706 	br	183dc14 <__ram_exceptions_end+0xff82d7d0>
 183efb8:	04006134 	movhi	r16,388
 183efbc:	8404dd04 	addi	r16,r16,4980
 183efc0:	003aa606 	br	183da5c <__ram_exceptions_end+0xff82d618>
 183efc4:	d9003917 	ldw	r4,228(sp)
 183efc8:	04001004 	movi	r16,64
 183efcc:	800b883a 	mov	r5,r16
 183efd0:	180579c0 	call	180579c <_malloc_r>
 183efd4:	d9002c17 	ldw	r4,176(sp)
 183efd8:	20800015 	stw	r2,0(r4)
 183efdc:	20800415 	stw	r2,16(r4)
 183efe0:	1001cb26 	beq	r2,zero,183f710 <___svfprintf_internal_r+0x21b4>
 183efe4:	d8802c17 	ldw	r2,176(sp)
 183efe8:	14000515 	stw	r16,20(r2)
 183efec:	00397606 	br	183d5c8 <__ram_exceptions_end+0xff82d184>
 183eff0:	04006134 	movhi	r16,388
 183eff4:	8404df04 	addi	r16,r16,4988
 183eff8:	003ee106 	br	183eb80 <__ram_exceptions_end+0xff82e73c>
 183effc:	d9402c17 	ldw	r5,176(sp)
 183f000:	d9801e04 	addi	r6,sp,120
 183f004:	9809883a 	mov	r4,r19
 183f008:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f00c:	103a381e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f010:	dc402617 	ldw	r17,152(sp)
 183f014:	d8c02017 	ldw	r3,128(sp)
 183f018:	da000404 	addi	r8,sp,16
 183f01c:	003f4306 	br	183ed2c <__ram_exceptions_end+0xff82e8e8>
 183f020:	01400184 	movi	r5,6
 183f024:	d9402915 	stw	r5,164(sp)
 183f028:	003f9506 	br	183ee80 <__ram_exceptions_end+0xff82ea3c>
 183f02c:	d9002d17 	ldw	r4,180(sp)
 183f030:	25000017 	ldw	r20,0(r4)
 183f034:	21000104 	addi	r4,r4,4
 183f038:	d9002d15 	stw	r4,180(sp)
 183f03c:	a02dd7fa 	srai	r22,r20,31
 183f040:	b005883a 	mov	r2,r22
 183f044:	003a9b06 	br	183dab4 <__ram_exceptions_end+0xff82d670>
 183f048:	d9402d17 	ldw	r5,180(sp)
 183f04c:	002d883a 	mov	r22,zero
 183f050:	2d000017 	ldw	r20,0(r5)
 183f054:	29400104 	addi	r5,r5,4
 183f058:	d9402d15 	stw	r5,180(sp)
 183f05c:	003bf906 	br	183e044 <__ram_exceptions_end+0xff82dc00>
 183f060:	9480100c 	andi	r18,r18,64
 183f064:	90006e26 	beq	r18,zero,183f220 <___svfprintf_internal_r+0x1cc4>
 183f068:	d9002d17 	ldw	r4,180(sp)
 183f06c:	d9402f17 	ldw	r5,188(sp)
 183f070:	20800017 	ldw	r2,0(r4)
 183f074:	21000104 	addi	r4,r4,4
 183f078:	d9002d15 	stw	r4,180(sp)
 183f07c:	1140000d 	sth	r5,0(r2)
 183f080:	00396106 	br	183d608 <__ram_exceptions_end+0xff82d1c4>
 183f084:	d9402c17 	ldw	r5,176(sp)
 183f088:	d9801e04 	addi	r6,sp,120
 183f08c:	9809883a 	mov	r4,r19
 183f090:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f094:	103a161e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f098:	d8c02017 	ldw	r3,128(sp)
 183f09c:	d8801f17 	ldw	r2,124(sp)
 183f0a0:	da000404 	addi	r8,sp,16
 183f0a4:	d9403317 	ldw	r5,204(sp)
 183f0a8:	10800044 	addi	r2,r2,1
 183f0ac:	44000015 	stw	r16,0(r8)
 183f0b0:	28c7883a 	add	r3,r5,r3
 183f0b4:	003b7706 	br	183de94 <__ram_exceptions_end+0xff82da50>
 183f0b8:	8009883a 	mov	r4,r16
 183f0bc:	da003e15 	stw	r8,248(sp)
 183f0c0:	18075d80 	call	18075d8 <strlen>
 183f0c4:	d8802e15 	stw	r2,184(sp)
 183f0c8:	da003e17 	ldw	r8,248(sp)
 183f0cc:	103c280e 	bge	r2,zero,183e170 <__ram_exceptions_end+0xff82dd2c>
 183f0d0:	0005883a 	mov	r2,zero
 183f0d4:	003c2606 	br	183e170 <__ram_exceptions_end+0xff82dd2c>
 183f0d8:	00bfffc4 	movi	r2,-1
 183f0dc:	003a0906 	br	183d904 <__ram_exceptions_end+0xff82d4c0>
 183f0e0:	01006134 	movhi	r4,388
 183f0e4:	210fc004 	addi	r4,r4,16128
 183f0e8:	d9003515 	stw	r4,212(sp)
 183f0ec:	003b0606 	br	183dd08 <__ram_exceptions_end+0xff82d8c4>
 183f0f0:	013fffc4 	movi	r4,-1
 183f0f4:	003a2706 	br	183d994 <__ram_exceptions_end+0xff82d550>
 183f0f8:	d9402c17 	ldw	r5,176(sp)
 183f0fc:	d9801e04 	addi	r6,sp,120
 183f100:	9809883a 	mov	r4,r19
 183f104:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f108:	1039f91e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f10c:	d8c02017 	ldw	r3,128(sp)
 183f110:	da000404 	addi	r8,sp,16
 183f114:	003d8406 	br	183e728 <__ram_exceptions_end+0xff82e2e4>
 183f118:	0023883a 	mov	r17,zero
 183f11c:	003d8306 	br	183e72c <__ram_exceptions_end+0xff82e2e8>
 183f120:	01006134 	movhi	r4,388
 183f124:	210fbc04 	addi	r4,r4,16112
 183f128:	d9002b15 	stw	r4,172(sp)
 183f12c:	d9002b17 	ldw	r4,172(sp)
 183f130:	1c47883a 	add	r3,r3,r17
 183f134:	10800044 	addi	r2,r2,1
 183f138:	41000015 	stw	r4,0(r8)
 183f13c:	44400115 	stw	r17,4(r8)
 183f140:	d8c02015 	stw	r3,128(sp)
 183f144:	d8801f15 	stw	r2,124(sp)
 183f148:	010001c4 	movi	r4,7
 183f14c:	20bfcd16 	blt	r4,r2,183f084 <__ram_exceptions_end+0xff82ec40>
 183f150:	42000204 	addi	r8,r8,8
 183f154:	003fd306 	br	183f0a4 <__ram_exceptions_end+0xff82ec60>
 183f158:	d9402c17 	ldw	r5,176(sp)
 183f15c:	d9801e04 	addi	r6,sp,120
 183f160:	9809883a 	mov	r4,r19
 183f164:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f168:	1039e11e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f16c:	d8802617 	ldw	r2,152(sp)
 183f170:	d8c02017 	ldw	r3,128(sp)
 183f174:	da000404 	addi	r8,sp,16
 183f178:	003e1c06 	br	183e9ec <__ram_exceptions_end+0xff82e5a8>
 183f17c:	d8802917 	ldw	r2,164(sp)
 183f180:	00c00184 	movi	r3,6
 183f184:	1880012e 	bgeu	r3,r2,183f18c <___svfprintf_internal_r+0x1c30>
 183f188:	1805883a 	mov	r2,r3
 183f18c:	d8802e15 	stw	r2,184(sp)
 183f190:	1000f316 	blt	r2,zero,183f560 <___svfprintf_internal_r+0x2004>
 183f194:	04006134 	movhi	r16,388
 183f198:	d8802a15 	stw	r2,168(sp)
 183f19c:	dd002d15 	stw	r20,180(sp)
 183f1a0:	d8002915 	stw	zero,164(sp)
 183f1a4:	d8003215 	stw	zero,200(sp)
 183f1a8:	8404eb04 	addi	r16,r16,5036
 183f1ac:	0039883a 	mov	fp,zero
 183f1b0:	003a9f06 	br	183dc30 <__ram_exceptions_end+0xff82d7ec>
 183f1b4:	01006134 	movhi	r4,388
 183f1b8:	210fc004 	addi	r4,r4,16128
 183f1bc:	d9003515 	stw	r4,212(sp)
 183f1c0:	003b5f06 	br	183df40 <__ram_exceptions_end+0xff82dafc>
 183f1c4:	d9402c17 	ldw	r5,176(sp)
 183f1c8:	d9801e04 	addi	r6,sp,120
 183f1cc:	9809883a 	mov	r4,r19
 183f1d0:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f1d4:	1039c61e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f1d8:	d8802617 	ldw	r2,152(sp)
 183f1dc:	d9403317 	ldw	r5,204(sp)
 183f1e0:	d8c02017 	ldw	r3,128(sp)
 183f1e4:	da000404 	addi	r8,sp,16
 183f1e8:	2885c83a 	sub	r2,r5,r2
 183f1ec:	003e1006 	br	183ea30 <__ram_exceptions_end+0xff82e5ec>
 183f1f0:	00800044 	movi	r2,1
 183f1f4:	10803fcc 	andi	r2,r2,255
 183f1f8:	00c00044 	movi	r3,1
 183f1fc:	10fa3526 	beq	r2,r3,183dad4 <__ram_exceptions_end+0xff82d690>
 183f200:	00c00084 	movi	r3,2
 183f204:	10fb9e26 	beq	r2,r3,183e080 <__ram_exceptions_end+0xff82dc3c>
 183f208:	003a6406 	br	183db9c <__ram_exceptions_end+0xff82d758>
 183f20c:	0021883a 	mov	r16,zero
 183f210:	003e0806 	br	183ea34 <__ram_exceptions_end+0xff82e5f0>
 183f214:	07000b44 	movi	fp,45
 183f218:	df002785 	stb	fp,158(sp)
 183f21c:	003a0b06 	br	183da4c <__ram_exceptions_end+0xff82d608>
 183f220:	d8c02d17 	ldw	r3,180(sp)
 183f224:	d9002f17 	ldw	r4,188(sp)
 183f228:	18800017 	ldw	r2,0(r3)
 183f22c:	18c00104 	addi	r3,r3,4
 183f230:	d8c02d15 	stw	r3,180(sp)
 183f234:	11000015 	stw	r4,0(r2)
 183f238:	0038f306 	br	183d608 <__ram_exceptions_end+0xff82d1c4>
 183f23c:	00c00b44 	movi	r3,45
 183f240:	d8c02785 	stb	r3,158(sp)
 183f244:	d8802a15 	stw	r2,168(sp)
 183f248:	dc802b17 	ldw	r18,172(sp)
 183f24c:	d8002915 	stw	zero,164(sp)
 183f250:	07000b44 	movi	fp,45
 183f254:	003a7306 	br	183dc24 <__ram_exceptions_end+0xff82d7e0>
 183f258:	9080004c 	andi	r2,r18,1
 183f25c:	1000941e 	bne	r2,zero,183f4b0 <___svfprintf_internal_r+0x1f54>
 183f260:	d8802117 	ldw	r2,132(sp)
 183f264:	1405c83a 	sub	r2,r2,r16
 183f268:	d8803315 	stw	r2,204(sp)
 183f26c:	b441161e 	bne	r22,r17,183f6c8 <___svfprintf_internal_r+0x216c>
 183f270:	dd802617 	ldw	r22,152(sp)
 183f274:	00bfff44 	movi	r2,-3
 183f278:	b0801a16 	blt	r22,r2,183f2e4 <___svfprintf_internal_r+0x1d88>
 183f27c:	d9402917 	ldw	r5,164(sp)
 183f280:	2d801816 	blt	r5,r22,183f2e4 <___svfprintf_internal_r+0x1d88>
 183f284:	dd803215 	stw	r22,200(sp)
 183f288:	003f3a06 	br	183ef74 <__ram_exceptions_end+0xff82eb30>
 183f28c:	1025883a 	mov	r18,r2
 183f290:	0039883a 	mov	fp,zero
 183f294:	00800084 	movi	r2,2
 183f298:	003fd606 	br	183f1f4 <__ram_exceptions_end+0xff82edb0>
 183f29c:	9080004c 	andi	r2,r18,1
 183f2a0:	103f191e 	bne	r2,zero,183ef08 <__ram_exceptions_end+0xff82eac4>
 183f2a4:	d8802117 	ldw	r2,132(sp)
 183f2a8:	003f2806 	br	183ef4c <__ram_exceptions_end+0xff82eb08>
 183f2ac:	01006134 	movhi	r4,388
 183f2b0:	210fbc04 	addi	r4,r4,16112
 183f2b4:	d9002b15 	stw	r4,172(sp)
 183f2b8:	003c7c06 	br	183e4ac <__ram_exceptions_end+0xff82e068>
 183f2bc:	e005883a 	mov	r2,fp
 183f2c0:	003f2206 	br	183ef4c <__ram_exceptions_end+0xff82eb08>
 183f2c4:	d9402917 	ldw	r5,164(sp)
 183f2c8:	df002783 	ldbu	fp,158(sp)
 183f2cc:	dd002d15 	stw	r20,180(sp)
 183f2d0:	d9402a15 	stw	r5,168(sp)
 183f2d4:	d9402e15 	stw	r5,184(sp)
 183f2d8:	d8002915 	stw	zero,164(sp)
 183f2dc:	d8003215 	stw	zero,200(sp)
 183f2e0:	003a4c06 	br	183dc14 <__ram_exceptions_end+0xff82d7d0>
 183f2e4:	8c7fff84 	addi	r17,r17,-2
 183f2e8:	b5bfffc4 	addi	r22,r22,-1
 183f2ec:	dd802615 	stw	r22,152(sp)
 183f2f0:	dc4022c5 	stb	r17,139(sp)
 183f2f4:	b000c316 	blt	r22,zero,183f604 <___svfprintf_internal_r+0x20a8>
 183f2f8:	00800ac4 	movi	r2,43
 183f2fc:	d8802305 	stb	r2,140(sp)
 183f300:	00800244 	movi	r2,9
 183f304:	15806e16 	blt	r2,r22,183f4c0 <___svfprintf_internal_r+0x1f64>
 183f308:	00800c04 	movi	r2,48
 183f30c:	b5800c04 	addi	r22,r22,48
 183f310:	d8802345 	stb	r2,141(sp)
 183f314:	dd802385 	stb	r22,142(sp)
 183f318:	d88023c4 	addi	r2,sp,143
 183f31c:	df0022c4 	addi	fp,sp,139
 183f320:	d8c03317 	ldw	r3,204(sp)
 183f324:	1739c83a 	sub	fp,r2,fp
 183f328:	d9003317 	ldw	r4,204(sp)
 183f32c:	e0c7883a 	add	r3,fp,r3
 183f330:	df003b15 	stw	fp,236(sp)
 183f334:	d8c02e15 	stw	r3,184(sp)
 183f338:	00800044 	movi	r2,1
 183f33c:	1100b70e 	bge	r2,r4,183f61c <___svfprintf_internal_r+0x20c0>
 183f340:	d8c02e17 	ldw	r3,184(sp)
 183f344:	18c00044 	addi	r3,r3,1
 183f348:	d8c02e15 	stw	r3,184(sp)
 183f34c:	1805883a 	mov	r2,r3
 183f350:	1800b016 	blt	r3,zero,183f614 <___svfprintf_internal_r+0x20b8>
 183f354:	d8003215 	stw	zero,200(sp)
 183f358:	003f1006 	br	183ef9c <__ram_exceptions_end+0xff82eb58>
 183f35c:	d8802917 	ldw	r2,164(sp)
 183f360:	103ec71e 	bne	r2,zero,183ee80 <__ram_exceptions_end+0xff82ea3c>
 183f364:	dc002915 	stw	r16,164(sp)
 183f368:	003ec506 	br	183ee80 <__ram_exceptions_end+0xff82ea3c>
 183f36c:	d9402c17 	ldw	r5,176(sp)
 183f370:	d9801e04 	addi	r6,sp,120
 183f374:	9809883a 	mov	r4,r19
 183f378:	183f9cc0 	call	183f9cc <__ssprint_r>
 183f37c:	10395c1e 	bne	r2,zero,183d8f0 <__ram_exceptions_end+0xff82d4ac>
 183f380:	dc402617 	ldw	r17,152(sp)
 183f384:	d8c02017 	ldw	r3,128(sp)
 183f388:	d8801f17 	ldw	r2,124(sp)
 183f38c:	da000404 	addi	r8,sp,16
 183f390:	003e7706 	br	183ed70 <__ram_exceptions_end+0xff82e92c>
 183f394:	582f883a 	mov	r23,r11
 183f398:	d8002915 	stw	zero,164(sp)
 183f39c:	0038c406 	br	183d6b0 <__ram_exceptions_end+0xff82d26c>
 183f3a0:	d8c02917 	ldw	r3,164(sp)
 183f3a4:	d8802104 	addi	r2,sp,132
 183f3a8:	d8800315 	stw	r2,12(sp)
 183f3ac:	d9403617 	ldw	r5,216(sp)
 183f3b0:	d8802504 	addi	r2,sp,148
 183f3b4:	d8800215 	stw	r2,8(sp)
 183f3b8:	d8802604 	addi	r2,sp,152
 183f3bc:	d8c00015 	stw	r3,0(sp)
 183f3c0:	9809883a 	mov	r4,r19
 183f3c4:	d8800115 	stw	r2,4(sp)
 183f3c8:	01c000c4 	movi	r7,3
 183f3cc:	a00d883a 	mov	r6,r20
 183f3d0:	da003e15 	stw	r8,248(sp)
 183f3d4:	18032780 	call	1803278 <_dtoa_r>
 183f3d8:	d9002917 	ldw	r4,164(sp)
 183f3dc:	da003e17 	ldw	r8,248(sp)
 183f3e0:	1021883a 	mov	r16,r2
 183f3e4:	1139883a 	add	fp,r2,r4
 183f3e8:	2007883a 	mov	r3,r4
 183f3ec:	81000007 	ldb	r4,0(r16)
 183f3f0:	00800c04 	movi	r2,48
 183f3f4:	20806f26 	beq	r4,r2,183f5b4 <___svfprintf_internal_r+0x2058>
 183f3f8:	d8c02617 	ldw	r3,152(sp)
 183f3fc:	e0f9883a 	add	fp,fp,r3
 183f400:	003ec206 	br	183ef0c <__ram_exceptions_end+0xff82eac8>
 183f404:	00c00b44 	movi	r3,45
 183f408:	2520003c 	xorhi	r20,r4,32768
 183f40c:	d8c02a05 	stb	r3,168(sp)
 183f410:	003ea106 	br	183ee98 <__ram_exceptions_end+0xff82ea54>
 183f414:	d8c03217 	ldw	r3,200(sp)
 183f418:	00c0890e 	bge	zero,r3,183f640 <___svfprintf_internal_r+0x20e4>
 183f41c:	00800044 	movi	r2,1
 183f420:	d9003317 	ldw	r4,204(sp)
 183f424:	1105883a 	add	r2,r2,r4
 183f428:	d8802e15 	stw	r2,184(sp)
 183f42c:	10005f16 	blt	r2,zero,183f5ac <___svfprintf_internal_r+0x2050>
 183f430:	044019c4 	movi	r17,103
 183f434:	003ed906 	br	183ef9c <__ram_exceptions_end+0xff82eb58>
 183f438:	d9002917 	ldw	r4,164(sp)
 183f43c:	20c00044 	addi	r3,r4,1
 183f440:	003e9c06 	br	183eeb4 <__ram_exceptions_end+0xff82ea70>
 183f444:	d9002917 	ldw	r4,164(sp)
 183f448:	00c0680e 	bge	zero,r3,183f5ec <___svfprintf_internal_r+0x2090>
 183f44c:	2000461e 	bne	r4,zero,183f568 <___svfprintf_internal_r+0x200c>
 183f450:	9480004c 	andi	r18,r18,1
 183f454:	9000441e 	bne	r18,zero,183f568 <___svfprintf_internal_r+0x200c>
 183f458:	1805883a 	mov	r2,r3
 183f45c:	1800a016 	blt	r3,zero,183f6e0 <___svfprintf_internal_r+0x2184>
 183f460:	d8c03217 	ldw	r3,200(sp)
 183f464:	d8c02e15 	stw	r3,184(sp)
 183f468:	003ecc06 	br	183ef9c <__ram_exceptions_end+0xff82eb58>
 183f46c:	d9402917 	ldw	r5,164(sp)
 183f470:	d8802104 	addi	r2,sp,132
 183f474:	d8800315 	stw	r2,12(sp)
 183f478:	d9400015 	stw	r5,0(sp)
 183f47c:	d8802504 	addi	r2,sp,148
 183f480:	d9403617 	ldw	r5,216(sp)
 183f484:	d8800215 	stw	r2,8(sp)
 183f488:	d8802604 	addi	r2,sp,152
 183f48c:	d8800115 	stw	r2,4(sp)
 183f490:	01c000c4 	movi	r7,3
 183f494:	a00d883a 	mov	r6,r20
 183f498:	9809883a 	mov	r4,r19
 183f49c:	da003e15 	stw	r8,248(sp)
 183f4a0:	18032780 	call	1803278 <_dtoa_r>
 183f4a4:	d8c02917 	ldw	r3,164(sp)
 183f4a8:	da003e17 	ldw	r8,248(sp)
 183f4ac:	1021883a 	mov	r16,r2
 183f4b0:	00801184 	movi	r2,70
 183f4b4:	80f9883a 	add	fp,r16,r3
 183f4b8:	88bfcc26 	beq	r17,r2,183f3ec <__ram_exceptions_end+0xff82efa8>
 183f4bc:	003e9306 	br	183ef0c <__ram_exceptions_end+0xff82eac8>
 183f4c0:	df0022c4 	addi	fp,sp,139
 183f4c4:	dc002915 	stw	r16,164(sp)
 183f4c8:	9829883a 	mov	r20,r19
 183f4cc:	e021883a 	mov	r16,fp
 183f4d0:	4027883a 	mov	r19,r8
 183f4d4:	b009883a 	mov	r4,r22
 183f4d8:	01400284 	movi	r5,10
 183f4dc:	180ac9c0 	call	180ac9c <__modsi3>
 183f4e0:	10800c04 	addi	r2,r2,48
 183f4e4:	843fffc4 	addi	r16,r16,-1
 183f4e8:	b009883a 	mov	r4,r22
 183f4ec:	01400284 	movi	r5,10
 183f4f0:	80800005 	stb	r2,0(r16)
 183f4f4:	180ac180 	call	180ac18 <__divsi3>
 183f4f8:	102d883a 	mov	r22,r2
 183f4fc:	00800244 	movi	r2,9
 183f500:	15bff416 	blt	r2,r22,183f4d4 <__ram_exceptions_end+0xff82f090>
 183f504:	9811883a 	mov	r8,r19
 183f508:	b0800c04 	addi	r2,r22,48
 183f50c:	a027883a 	mov	r19,r20
 183f510:	8029883a 	mov	r20,r16
 183f514:	a17fffc4 	addi	r5,r20,-1
 183f518:	a0bfffc5 	stb	r2,-1(r20)
 183f51c:	dc002917 	ldw	r16,164(sp)
 183f520:	2f00752e 	bgeu	r5,fp,183f6f8 <___svfprintf_internal_r+0x219c>
 183f524:	d9c02384 	addi	r7,sp,142
 183f528:	3d0fc83a 	sub	r7,r7,r20
 183f52c:	d9002344 	addi	r4,sp,141
 183f530:	e1cf883a 	add	r7,fp,r7
 183f534:	00000106 	br	183f53c <___svfprintf_internal_r+0x1fe0>
 183f538:	28800003 	ldbu	r2,0(r5)
 183f53c:	20800005 	stb	r2,0(r4)
 183f540:	21000044 	addi	r4,r4,1
 183f544:	29400044 	addi	r5,r5,1
 183f548:	21fffb1e 	bne	r4,r7,183f538 <__ram_exceptions_end+0xff82f0f4>
 183f54c:	d8802304 	addi	r2,sp,140
 183f550:	1505c83a 	sub	r2,r2,r20
 183f554:	d8c02344 	addi	r3,sp,141
 183f558:	1885883a 	add	r2,r3,r2
 183f55c:	003f7006 	br	183f320 <__ram_exceptions_end+0xff82eedc>
 183f560:	0005883a 	mov	r2,zero
 183f564:	003f0b06 	br	183f194 <__ram_exceptions_end+0xff82ed50>
 183f568:	d9002917 	ldw	r4,164(sp)
 183f56c:	d8c03217 	ldw	r3,200(sp)
 183f570:	20800044 	addi	r2,r4,1
 183f574:	1885883a 	add	r2,r3,r2
 183f578:	d8802e15 	stw	r2,184(sp)
 183f57c:	103e870e 	bge	r2,zero,183ef9c <__ram_exceptions_end+0xff82eb58>
 183f580:	0005883a 	mov	r2,zero
 183f584:	003e8506 	br	183ef9c <__ram_exceptions_end+0xff82eb58>
 183f588:	01006134 	movhi	r4,388
 183f58c:	210fbc04 	addi	r4,r4,16112
 183f590:	d9002b15 	stw	r4,172(sp)
 183f594:	003cc506 	br	183e8ac <__ram_exceptions_end+0xff82e468>
 183f598:	d8c03217 	ldw	r3,200(sp)
 183f59c:	18c00044 	addi	r3,r3,1
 183f5a0:	d8c02e15 	stw	r3,184(sp)
 183f5a4:	1805883a 	mov	r2,r3
 183f5a8:	183fa10e 	bge	r3,zero,183f430 <__ram_exceptions_end+0xff82efec>
 183f5ac:	0005883a 	mov	r2,zero
 183f5b0:	003f9f06 	br	183f430 <__ram_exceptions_end+0xff82efec>
 183f5b4:	d9003617 	ldw	r4,216(sp)
 183f5b8:	000d883a 	mov	r6,zero
 183f5bc:	000f883a 	mov	r7,zero
 183f5c0:	a00b883a 	mov	r5,r20
 183f5c4:	d8c03d15 	stw	r3,244(sp)
 183f5c8:	da003e15 	stw	r8,248(sp)
 183f5cc:	180bf600 	call	180bf60 <__eqdf2>
 183f5d0:	d8c03d17 	ldw	r3,244(sp)
 183f5d4:	da003e17 	ldw	r8,248(sp)
 183f5d8:	103f8726 	beq	r2,zero,183f3f8 <__ram_exceptions_end+0xff82efb4>
 183f5dc:	00800044 	movi	r2,1
 183f5e0:	10c7c83a 	sub	r3,r2,r3
 183f5e4:	d8c02615 	stw	r3,152(sp)
 183f5e8:	003f8406 	br	183f3fc <__ram_exceptions_end+0xff82efb8>
 183f5ec:	20000e1e 	bne	r4,zero,183f628 <___svfprintf_internal_r+0x20cc>
 183f5f0:	9480004c 	andi	r18,r18,1
 183f5f4:	90000c1e 	bne	r18,zero,183f628 <___svfprintf_internal_r+0x20cc>
 183f5f8:	00800044 	movi	r2,1
 183f5fc:	d8802e15 	stw	r2,184(sp)
 183f600:	003e6606 	br	183ef9c <__ram_exceptions_end+0xff82eb58>
 183f604:	00800b44 	movi	r2,45
 183f608:	05adc83a 	sub	r22,zero,r22
 183f60c:	d8802305 	stb	r2,140(sp)
 183f610:	003f3b06 	br	183f300 <__ram_exceptions_end+0xff82eebc>
 183f614:	0005883a 	mov	r2,zero
 183f618:	003f4e06 	br	183f354 <__ram_exceptions_end+0xff82ef10>
 183f61c:	90a4703a 	and	r18,r18,r2
 183f620:	903f4a26 	beq	r18,zero,183f34c <__ram_exceptions_end+0xff82ef08>
 183f624:	003f4606 	br	183f340 <__ram_exceptions_end+0xff82eefc>
 183f628:	d8c02917 	ldw	r3,164(sp)
 183f62c:	18c00084 	addi	r3,r3,2
 183f630:	d8c02e15 	stw	r3,184(sp)
 183f634:	1805883a 	mov	r2,r3
 183f638:	183e580e 	bge	r3,zero,183ef9c <__ram_exceptions_end+0xff82eb58>
 183f63c:	003fd006 	br	183f580 <__ram_exceptions_end+0xff82f13c>
 183f640:	00800084 	movi	r2,2
 183f644:	10c5c83a 	sub	r2,r2,r3
 183f648:	003f7506 	br	183f420 <__ram_exceptions_end+0xff82efdc>
 183f64c:	d8802d17 	ldw	r2,180(sp)
 183f650:	d9002d17 	ldw	r4,180(sp)
 183f654:	bc400043 	ldbu	r17,1(r23)
 183f658:	10800017 	ldw	r2,0(r2)
 183f65c:	582f883a 	mov	r23,r11
 183f660:	d8802915 	stw	r2,164(sp)
 183f664:	20800104 	addi	r2,r4,4
 183f668:	d9002917 	ldw	r4,164(sp)
 183f66c:	d8802d15 	stw	r2,180(sp)
 183f670:	203df00e 	bge	r4,zero,183ee34 <__ram_exceptions_end+0xff82e9f0>
 183f674:	8c403fcc 	andi	r17,r17,255
 183f678:	00bfffc4 	movi	r2,-1
 183f67c:	8c40201c 	xori	r17,r17,128
 183f680:	d8802915 	stw	r2,164(sp)
 183f684:	8c7fe004 	addi	r17,r17,-128
 183f688:	00380806 	br	183d6ac <__ram_exceptions_end+0xff82d268>
 183f68c:	9080004c 	andi	r2,r18,1
 183f690:	0039883a 	mov	fp,zero
 183f694:	10000726 	beq	r2,zero,183f6b4 <___svfprintf_internal_r+0x2158>
 183f698:	d8c02817 	ldw	r3,160(sp)
 183f69c:	dc001dc4 	addi	r16,sp,119
 183f6a0:	00800c04 	movi	r2,48
 183f6a4:	1c07c83a 	sub	r3,r3,r16
 183f6a8:	d8801dc5 	stb	r2,119(sp)
 183f6ac:	d8c02e15 	stw	r3,184(sp)
 183f6b0:	00395206 	br	183dbfc <__ram_exceptions_end+0xff82d7b8>
 183f6b4:	d8002e15 	stw	zero,184(sp)
 183f6b8:	dc001e04 	addi	r16,sp,120
 183f6bc:	00394f06 	br	183dbfc <__ram_exceptions_end+0xff82d7b8>
 183f6c0:	0005883a 	mov	r2,zero
 183f6c4:	003e3206 	br	183ef90 <__ram_exceptions_end+0xff82eb4c>
 183f6c8:	dd802617 	ldw	r22,152(sp)
 183f6cc:	003f0606 	br	183f2e8 <__ram_exceptions_end+0xff82eea4>
 183f6d0:	d9c02785 	stb	r7,158(sp)
 183f6d4:	003a5106 	br	183e01c <__ram_exceptions_end+0xff82dbd8>
 183f6d8:	d9c02785 	stb	r7,158(sp)
 183f6dc:	003a3706 	br	183dfbc <__ram_exceptions_end+0xff82db78>
 183f6e0:	0005883a 	mov	r2,zero
 183f6e4:	003f5e06 	br	183f460 <__ram_exceptions_end+0xff82f01c>
 183f6e8:	d9c02785 	stb	r7,158(sp)
 183f6ec:	00391706 	br	183db4c <__ram_exceptions_end+0xff82d708>
 183f6f0:	d9c02785 	stb	r7,158(sp)
 183f6f4:	0038e606 	br	183da90 <__ram_exceptions_end+0xff82d64c>
 183f6f8:	d8802344 	addi	r2,sp,141
 183f6fc:	003f0806 	br	183f320 <__ram_exceptions_end+0xff82eedc>
 183f700:	d9c02785 	stb	r7,158(sp)
 183f704:	0038b706 	br	183d9e4 <__ram_exceptions_end+0xff82d5a0>
 183f708:	d9c02785 	stb	r7,158(sp)
 183f70c:	003adc06 	br	183e280 <__ram_exceptions_end+0xff82de3c>
 183f710:	d9403917 	ldw	r5,228(sp)
 183f714:	00800304 	movi	r2,12
 183f718:	28800015 	stw	r2,0(r5)
 183f71c:	00bfffc4 	movi	r2,-1
 183f720:	00387806 	br	183d904 <__ram_exceptions_end+0xff82d4c0>
 183f724:	d9c02785 	stb	r7,158(sp)
 183f728:	003abf06 	br	183e228 <__ram_exceptions_end+0xff82dde4>
 183f72c:	d9c02785 	stb	r7,158(sp)
 183f730:	003a9b06 	br	183e1a0 <__ram_exceptions_end+0xff82dd5c>

0183f734 <__register_exitproc>:
 183f734:	defffa04 	addi	sp,sp,-24
 183f738:	dc000315 	stw	r16,12(sp)
 183f73c:	04006134 	movhi	r16,388
 183f740:	84175404 	addi	r16,r16,23888
 183f744:	80c00017 	ldw	r3,0(r16)
 183f748:	dc400415 	stw	r17,16(sp)
 183f74c:	dfc00515 	stw	ra,20(sp)
 183f750:	18805217 	ldw	r2,328(r3)
 183f754:	2023883a 	mov	r17,r4
 183f758:	10003726 	beq	r2,zero,183f838 <__register_exitproc+0x104>
 183f75c:	10c00117 	ldw	r3,4(r2)
 183f760:	010007c4 	movi	r4,31
 183f764:	20c00e16 	blt	r4,r3,183f7a0 <__register_exitproc+0x6c>
 183f768:	1a000044 	addi	r8,r3,1
 183f76c:	8800221e 	bne	r17,zero,183f7f8 <__register_exitproc+0xc4>
 183f770:	18c00084 	addi	r3,r3,2
 183f774:	18c7883a 	add	r3,r3,r3
 183f778:	18c7883a 	add	r3,r3,r3
 183f77c:	12000115 	stw	r8,4(r2)
 183f780:	10c7883a 	add	r3,r2,r3
 183f784:	19400015 	stw	r5,0(r3)
 183f788:	0005883a 	mov	r2,zero
 183f78c:	dfc00517 	ldw	ra,20(sp)
 183f790:	dc400417 	ldw	r17,16(sp)
 183f794:	dc000317 	ldw	r16,12(sp)
 183f798:	dec00604 	addi	sp,sp,24
 183f79c:	f800283a 	ret
 183f7a0:	00806134 	movhi	r2,388
 183f7a4:	10b40c04 	addi	r2,r2,-12240
 183f7a8:	10002626 	beq	r2,zero,183f844 <__register_exitproc+0x110>
 183f7ac:	01006404 	movi	r4,400
 183f7b0:	d9400015 	stw	r5,0(sp)
 183f7b4:	d9800115 	stw	r6,4(sp)
 183f7b8:	d9c00215 	stw	r7,8(sp)
 183f7bc:	183d0300 	call	183d030 <malloc>
 183f7c0:	d9400017 	ldw	r5,0(sp)
 183f7c4:	d9800117 	ldw	r6,4(sp)
 183f7c8:	d9c00217 	ldw	r7,8(sp)
 183f7cc:	10001d26 	beq	r2,zero,183f844 <__register_exitproc+0x110>
 183f7d0:	81000017 	ldw	r4,0(r16)
 183f7d4:	10000115 	stw	zero,4(r2)
 183f7d8:	02000044 	movi	r8,1
 183f7dc:	22405217 	ldw	r9,328(r4)
 183f7e0:	0007883a 	mov	r3,zero
 183f7e4:	12400015 	stw	r9,0(r2)
 183f7e8:	20805215 	stw	r2,328(r4)
 183f7ec:	10006215 	stw	zero,392(r2)
 183f7f0:	10006315 	stw	zero,396(r2)
 183f7f4:	883fde26 	beq	r17,zero,183f770 <__ram_exceptions_end+0xff82f32c>
 183f7f8:	18c9883a 	add	r4,r3,r3
 183f7fc:	2109883a 	add	r4,r4,r4
 183f800:	1109883a 	add	r4,r2,r4
 183f804:	21802215 	stw	r6,136(r4)
 183f808:	01800044 	movi	r6,1
 183f80c:	12406217 	ldw	r9,392(r2)
 183f810:	30cc983a 	sll	r6,r6,r3
 183f814:	4992b03a 	or	r9,r9,r6
 183f818:	12406215 	stw	r9,392(r2)
 183f81c:	21c04215 	stw	r7,264(r4)
 183f820:	01000084 	movi	r4,2
 183f824:	893fd21e 	bne	r17,r4,183f770 <__ram_exceptions_end+0xff82f32c>
 183f828:	11006317 	ldw	r4,396(r2)
 183f82c:	218cb03a 	or	r6,r4,r6
 183f830:	11806315 	stw	r6,396(r2)
 183f834:	003fce06 	br	183f770 <__ram_exceptions_end+0xff82f32c>
 183f838:	18805304 	addi	r2,r3,332
 183f83c:	18805215 	stw	r2,328(r3)
 183f840:	003fc606 	br	183f75c <__ram_exceptions_end+0xff82f318>
 183f844:	00bfffc4 	movi	r2,-1
 183f848:	003fd006 	br	183f78c <__ram_exceptions_end+0xff82f348>

0183f84c <__call_exitprocs>:
 183f84c:	defff504 	addi	sp,sp,-44
 183f850:	df000915 	stw	fp,36(sp)
 183f854:	dd400615 	stw	r21,24(sp)
 183f858:	dc800315 	stw	r18,12(sp)
 183f85c:	dfc00a15 	stw	ra,40(sp)
 183f860:	ddc00815 	stw	r23,32(sp)
 183f864:	dd800715 	stw	r22,28(sp)
 183f868:	dd000515 	stw	r20,20(sp)
 183f86c:	dcc00415 	stw	r19,16(sp)
 183f870:	dc400215 	stw	r17,8(sp)
 183f874:	dc000115 	stw	r16,4(sp)
 183f878:	d9000015 	stw	r4,0(sp)
 183f87c:	2839883a 	mov	fp,r5
 183f880:	04800044 	movi	r18,1
 183f884:	057fffc4 	movi	r21,-1
 183f888:	00806134 	movhi	r2,388
 183f88c:	10975404 	addi	r2,r2,23888
 183f890:	12000017 	ldw	r8,0(r2)
 183f894:	45005217 	ldw	r20,328(r8)
 183f898:	44c05204 	addi	r19,r8,328
 183f89c:	a0001c26 	beq	r20,zero,183f910 <__call_exitprocs+0xc4>
 183f8a0:	a0800117 	ldw	r2,4(r20)
 183f8a4:	15ffffc4 	addi	r23,r2,-1
 183f8a8:	b8000d16 	blt	r23,zero,183f8e0 <__call_exitprocs+0x94>
 183f8ac:	14000044 	addi	r16,r2,1
 183f8b0:	8421883a 	add	r16,r16,r16
 183f8b4:	8421883a 	add	r16,r16,r16
 183f8b8:	84402004 	addi	r17,r16,128
 183f8bc:	a463883a 	add	r17,r20,r17
 183f8c0:	a421883a 	add	r16,r20,r16
 183f8c4:	e0001e26 	beq	fp,zero,183f940 <__call_exitprocs+0xf4>
 183f8c8:	80804017 	ldw	r2,256(r16)
 183f8cc:	e0801c26 	beq	fp,r2,183f940 <__call_exitprocs+0xf4>
 183f8d0:	bdffffc4 	addi	r23,r23,-1
 183f8d4:	843fff04 	addi	r16,r16,-4
 183f8d8:	8c7fff04 	addi	r17,r17,-4
 183f8dc:	bd7ff91e 	bne	r23,r21,183f8c4 <__ram_exceptions_end+0xff82f480>
 183f8e0:	00806134 	movhi	r2,388
 183f8e4:	10b41104 	addi	r2,r2,-12220
 183f8e8:	10000926 	beq	r2,zero,183f910 <__call_exitprocs+0xc4>
 183f8ec:	a0800117 	ldw	r2,4(r20)
 183f8f0:	1000301e 	bne	r2,zero,183f9b4 <__call_exitprocs+0x168>
 183f8f4:	a0800017 	ldw	r2,0(r20)
 183f8f8:	10003226 	beq	r2,zero,183f9c4 <__call_exitprocs+0x178>
 183f8fc:	a009883a 	mov	r4,r20
 183f900:	98800015 	stw	r2,0(r19)
 183f904:	183d0440 	call	183d044 <free>
 183f908:	9d000017 	ldw	r20,0(r19)
 183f90c:	a03fe41e 	bne	r20,zero,183f8a0 <__ram_exceptions_end+0xff82f45c>
 183f910:	dfc00a17 	ldw	ra,40(sp)
 183f914:	df000917 	ldw	fp,36(sp)
 183f918:	ddc00817 	ldw	r23,32(sp)
 183f91c:	dd800717 	ldw	r22,28(sp)
 183f920:	dd400617 	ldw	r21,24(sp)
 183f924:	dd000517 	ldw	r20,20(sp)
 183f928:	dcc00417 	ldw	r19,16(sp)
 183f92c:	dc800317 	ldw	r18,12(sp)
 183f930:	dc400217 	ldw	r17,8(sp)
 183f934:	dc000117 	ldw	r16,4(sp)
 183f938:	dec00b04 	addi	sp,sp,44
 183f93c:	f800283a 	ret
 183f940:	a0800117 	ldw	r2,4(r20)
 183f944:	80c00017 	ldw	r3,0(r16)
 183f948:	10bfffc4 	addi	r2,r2,-1
 183f94c:	15c01426 	beq	r2,r23,183f9a0 <__call_exitprocs+0x154>
 183f950:	80000015 	stw	zero,0(r16)
 183f954:	183fde26 	beq	r3,zero,183f8d0 <__ram_exceptions_end+0xff82f48c>
 183f958:	95c8983a 	sll	r4,r18,r23
 183f95c:	a0806217 	ldw	r2,392(r20)
 183f960:	a5800117 	ldw	r22,4(r20)
 183f964:	2084703a 	and	r2,r4,r2
 183f968:	10000b26 	beq	r2,zero,183f998 <__call_exitprocs+0x14c>
 183f96c:	a0806317 	ldw	r2,396(r20)
 183f970:	2088703a 	and	r4,r4,r2
 183f974:	20000c1e 	bne	r4,zero,183f9a8 <__call_exitprocs+0x15c>
 183f978:	89400017 	ldw	r5,0(r17)
 183f97c:	d9000017 	ldw	r4,0(sp)
 183f980:	183ee83a 	callr	r3
 183f984:	a0800117 	ldw	r2,4(r20)
 183f988:	15bfbf1e 	bne	r2,r22,183f888 <__ram_exceptions_end+0xff82f444>
 183f98c:	98800017 	ldw	r2,0(r19)
 183f990:	153fcf26 	beq	r2,r20,183f8d0 <__ram_exceptions_end+0xff82f48c>
 183f994:	003fbc06 	br	183f888 <__ram_exceptions_end+0xff82f444>
 183f998:	183ee83a 	callr	r3
 183f99c:	003ff906 	br	183f984 <__ram_exceptions_end+0xff82f540>
 183f9a0:	a5c00115 	stw	r23,4(r20)
 183f9a4:	003feb06 	br	183f954 <__ram_exceptions_end+0xff82f510>
 183f9a8:	89000017 	ldw	r4,0(r17)
 183f9ac:	183ee83a 	callr	r3
 183f9b0:	003ff406 	br	183f984 <__ram_exceptions_end+0xff82f540>
 183f9b4:	a0800017 	ldw	r2,0(r20)
 183f9b8:	a027883a 	mov	r19,r20
 183f9bc:	1029883a 	mov	r20,r2
 183f9c0:	003fb606 	br	183f89c <__ram_exceptions_end+0xff82f458>
 183f9c4:	0005883a 	mov	r2,zero
 183f9c8:	003ffb06 	br	183f9b8 <__ram_exceptions_end+0xff82f574>

0183f9cc <__ssprint_r>:
 183f9cc:	30800217 	ldw	r2,8(r6)
 183f9d0:	defff604 	addi	sp,sp,-40
 183f9d4:	dc800215 	stw	r18,8(sp)
 183f9d8:	dfc00915 	stw	ra,36(sp)
 183f9dc:	df000815 	stw	fp,32(sp)
 183f9e0:	ddc00715 	stw	r23,28(sp)
 183f9e4:	dd800615 	stw	r22,24(sp)
 183f9e8:	dd400515 	stw	r21,20(sp)
 183f9ec:	dd000415 	stw	r20,16(sp)
 183f9f0:	dcc00315 	stw	r19,12(sp)
 183f9f4:	dc400115 	stw	r17,4(sp)
 183f9f8:	dc000015 	stw	r16,0(sp)
 183f9fc:	3025883a 	mov	r18,r6
 183fa00:	10005826 	beq	r2,zero,183fb64 <__ssprint_r+0x198>
 183fa04:	2027883a 	mov	r19,r4
 183fa08:	35c00017 	ldw	r23,0(r6)
 183fa0c:	29000017 	ldw	r4,0(r5)
 183fa10:	28800217 	ldw	r2,8(r5)
 183fa14:	2823883a 	mov	r17,r5
 183fa18:	0039883a 	mov	fp,zero
 183fa1c:	0021883a 	mov	r16,zero
 183fa20:	80003926 	beq	r16,zero,183fb08 <__ssprint_r+0x13c>
 183fa24:	102b883a 	mov	r21,r2
 183fa28:	102d883a 	mov	r22,r2
 183fa2c:	80803a36 	bltu	r16,r2,183fb18 <__ssprint_r+0x14c>
 183fa30:	88c0030b 	ldhu	r3,12(r17)
 183fa34:	1881200c 	andi	r2,r3,1152
 183fa38:	10002626 	beq	r2,zero,183fad4 <__ssprint_r+0x108>
 183fa3c:	88800517 	ldw	r2,20(r17)
 183fa40:	89400417 	ldw	r5,16(r17)
 183fa44:	81800044 	addi	r6,r16,1
 183fa48:	108f883a 	add	r7,r2,r2
 183fa4c:	3885883a 	add	r2,r7,r2
 183fa50:	100ed7fa 	srli	r7,r2,31
 183fa54:	216dc83a 	sub	r22,r4,r5
 183fa58:	3589883a 	add	r4,r6,r22
 183fa5c:	3885883a 	add	r2,r7,r2
 183fa60:	102bd07a 	srai	r21,r2,1
 183fa64:	a80d883a 	mov	r6,r21
 183fa68:	a900022e 	bgeu	r21,r4,183fa74 <__ssprint_r+0xa8>
 183fa6c:	202b883a 	mov	r21,r4
 183fa70:	200d883a 	mov	r6,r4
 183fa74:	18c1000c 	andi	r3,r3,1024
 183fa78:	18002a26 	beq	r3,zero,183fb24 <__ssprint_r+0x158>
 183fa7c:	300b883a 	mov	r5,r6
 183fa80:	9809883a 	mov	r4,r19
 183fa84:	180579c0 	call	180579c <_malloc_r>
 183fa88:	1029883a 	mov	r20,r2
 183fa8c:	10002c26 	beq	r2,zero,183fb40 <__ssprint_r+0x174>
 183fa90:	89400417 	ldw	r5,16(r17)
 183fa94:	b00d883a 	mov	r6,r22
 183fa98:	1009883a 	mov	r4,r2
 183fa9c:	180608c0 	call	180608c <memcpy>
 183faa0:	8880030b 	ldhu	r2,12(r17)
 183faa4:	00fedfc4 	movi	r3,-1153
 183faa8:	10c4703a 	and	r2,r2,r3
 183faac:	10802014 	ori	r2,r2,128
 183fab0:	8880030d 	sth	r2,12(r17)
 183fab4:	a589883a 	add	r4,r20,r22
 183fab8:	adadc83a 	sub	r22,r21,r22
 183fabc:	8d400515 	stw	r21,20(r17)
 183fac0:	8d800215 	stw	r22,8(r17)
 183fac4:	8d000415 	stw	r20,16(r17)
 183fac8:	89000015 	stw	r4,0(r17)
 183facc:	802b883a 	mov	r21,r16
 183fad0:	802d883a 	mov	r22,r16
 183fad4:	b00d883a 	mov	r6,r22
 183fad8:	e00b883a 	mov	r5,fp
 183fadc:	18097080 	call	1809708 <memmove>
 183fae0:	88800217 	ldw	r2,8(r17)
 183fae4:	89000017 	ldw	r4,0(r17)
 183fae8:	90c00217 	ldw	r3,8(r18)
 183faec:	1545c83a 	sub	r2,r2,r21
 183faf0:	2589883a 	add	r4,r4,r22
 183faf4:	88800215 	stw	r2,8(r17)
 183faf8:	89000015 	stw	r4,0(r17)
 183fafc:	1c21c83a 	sub	r16,r3,r16
 183fb00:	94000215 	stw	r16,8(r18)
 183fb04:	80001726 	beq	r16,zero,183fb64 <__ssprint_r+0x198>
 183fb08:	bf000017 	ldw	fp,0(r23)
 183fb0c:	bc000117 	ldw	r16,4(r23)
 183fb10:	bdc00204 	addi	r23,r23,8
 183fb14:	003fc206 	br	183fa20 <__ram_exceptions_end+0xff82f5dc>
 183fb18:	802b883a 	mov	r21,r16
 183fb1c:	802d883a 	mov	r22,r16
 183fb20:	003fec06 	br	183fad4 <__ram_exceptions_end+0xff82f690>
 183fb24:	9809883a 	mov	r4,r19
 183fb28:	18098c40 	call	18098c4 <_realloc_r>
 183fb2c:	1029883a 	mov	r20,r2
 183fb30:	103fe01e 	bne	r2,zero,183fab4 <__ram_exceptions_end+0xff82f670>
 183fb34:	89400417 	ldw	r5,16(r17)
 183fb38:	9809883a 	mov	r4,r19
 183fb3c:	180506c0 	call	180506c <_free_r>
 183fb40:	88c0030b 	ldhu	r3,12(r17)
 183fb44:	00800304 	movi	r2,12
 183fb48:	98800015 	stw	r2,0(r19)
 183fb4c:	18c01014 	ori	r3,r3,64
 183fb50:	88c0030d 	sth	r3,12(r17)
 183fb54:	00bfffc4 	movi	r2,-1
 183fb58:	90000215 	stw	zero,8(r18)
 183fb5c:	90000115 	stw	zero,4(r18)
 183fb60:	00000206 	br	183fb6c <__ssprint_r+0x1a0>
 183fb64:	90000115 	stw	zero,4(r18)
 183fb68:	0005883a 	mov	r2,zero
 183fb6c:	dfc00917 	ldw	ra,36(sp)
 183fb70:	df000817 	ldw	fp,32(sp)
 183fb74:	ddc00717 	ldw	r23,28(sp)
 183fb78:	dd800617 	ldw	r22,24(sp)
 183fb7c:	dd400517 	ldw	r21,20(sp)
 183fb80:	dd000417 	ldw	r20,16(sp)
 183fb84:	dcc00317 	ldw	r19,12(sp)
 183fb88:	dc800217 	ldw	r18,8(sp)
 183fb8c:	dc400117 	ldw	r17,4(sp)
 183fb90:	dc000017 	ldw	r16,0(sp)
 183fb94:	dec00a04 	addi	sp,sp,40
 183fb98:	f800283a 	ret

0183fb9c <___svfiprintf_internal_r>:
 183fb9c:	2880030b 	ldhu	r2,12(r5)
 183fba0:	deffc804 	addi	sp,sp,-224
 183fba4:	dcc03115 	stw	r19,196(sp)
 183fba8:	dfc03715 	stw	ra,220(sp)
 183fbac:	df003615 	stw	fp,216(sp)
 183fbb0:	ddc03515 	stw	r23,212(sp)
 183fbb4:	dd803415 	stw	r22,208(sp)
 183fbb8:	dd403315 	stw	r21,204(sp)
 183fbbc:	dd003215 	stw	r20,200(sp)
 183fbc0:	dc803015 	stw	r18,192(sp)
 183fbc4:	dc402f15 	stw	r17,188(sp)
 183fbc8:	dc002e15 	stw	r16,184(sp)
 183fbcc:	d9402715 	stw	r5,156(sp)
 183fbd0:	d9002a15 	stw	r4,168(sp)
 183fbd4:	1080200c 	andi	r2,r2,128
 183fbd8:	d9c02315 	stw	r7,140(sp)
 183fbdc:	3027883a 	mov	r19,r6
 183fbe0:	10000226 	beq	r2,zero,183fbec <___svfiprintf_internal_r+0x50>
 183fbe4:	28800417 	ldw	r2,16(r5)
 183fbe8:	10041d26 	beq	r2,zero,1840c60 <___svfiprintf_internal_r+0x10c4>
 183fbec:	dac01a04 	addi	r11,sp,104
 183fbf0:	dac01e15 	stw	r11,120(sp)
 183fbf4:	d8801e17 	ldw	r2,120(sp)
 183fbf8:	dac019c4 	addi	r11,sp,103
 183fbfc:	dd402a17 	ldw	r21,168(sp)
 183fc00:	ddc02717 	ldw	r23,156(sp)
 183fc04:	05806134 	movhi	r22,388
 183fc08:	05006134 	movhi	r20,388
 183fc0c:	dac01f15 	stw	r11,124(sp)
 183fc10:	12d7c83a 	sub	r11,r2,r11
 183fc14:	b58fc804 	addi	r22,r22,16160
 183fc18:	a50fc404 	addi	r20,r20,16144
 183fc1c:	dec01a15 	stw	sp,104(sp)
 183fc20:	d8001c15 	stw	zero,112(sp)
 183fc24:	d8001b15 	stw	zero,108(sp)
 183fc28:	d811883a 	mov	r8,sp
 183fc2c:	d8002915 	stw	zero,164(sp)
 183fc30:	d8002515 	stw	zero,148(sp)
 183fc34:	dac02b15 	stw	r11,172(sp)
 183fc38:	98800007 	ldb	r2,0(r19)
 183fc3c:	1002dd26 	beq	r2,zero,18407b4 <___svfiprintf_internal_r+0xc18>
 183fc40:	00c00944 	movi	r3,37
 183fc44:	9823883a 	mov	r17,r19
 183fc48:	10c0021e 	bne	r2,r3,183fc54 <___svfiprintf_internal_r+0xb8>
 183fc4c:	00001406 	br	183fca0 <___svfiprintf_internal_r+0x104>
 183fc50:	10c00326 	beq	r2,r3,183fc60 <___svfiprintf_internal_r+0xc4>
 183fc54:	8c400044 	addi	r17,r17,1
 183fc58:	88800007 	ldb	r2,0(r17)
 183fc5c:	103ffc1e 	bne	r2,zero,183fc50 <__ram_exceptions_end+0xff82f80c>
 183fc60:	8ce1c83a 	sub	r16,r17,r19
 183fc64:	80000e26 	beq	r16,zero,183fca0 <___svfiprintf_internal_r+0x104>
 183fc68:	d8c01c17 	ldw	r3,112(sp)
 183fc6c:	d8801b17 	ldw	r2,108(sp)
 183fc70:	44c00015 	stw	r19,0(r8)
 183fc74:	1c07883a 	add	r3,r3,r16
 183fc78:	10800044 	addi	r2,r2,1
 183fc7c:	d8c01c15 	stw	r3,112(sp)
 183fc80:	44000115 	stw	r16,4(r8)
 183fc84:	d8801b15 	stw	r2,108(sp)
 183fc88:	00c001c4 	movi	r3,7
 183fc8c:	18831e16 	blt	r3,r2,1840908 <___svfiprintf_internal_r+0xd6c>
 183fc90:	42000204 	addi	r8,r8,8
 183fc94:	dac02517 	ldw	r11,148(sp)
 183fc98:	5c17883a 	add	r11,r11,r16
 183fc9c:	dac02515 	stw	r11,148(sp)
 183fca0:	88800007 	ldb	r2,0(r17)
 183fca4:	1002c526 	beq	r2,zero,18407bc <___svfiprintf_internal_r+0xc20>
 183fca8:	88c00047 	ldb	r3,1(r17)
 183fcac:	8cc00044 	addi	r19,r17,1
 183fcb0:	d8001d85 	stb	zero,118(sp)
 183fcb4:	0009883a 	mov	r4,zero
 183fcb8:	000f883a 	mov	r7,zero
 183fcbc:	043fffc4 	movi	r16,-1
 183fcc0:	d8002415 	stw	zero,144(sp)
 183fcc4:	0025883a 	mov	r18,zero
 183fcc8:	01401604 	movi	r5,88
 183fccc:	01800244 	movi	r6,9
 183fcd0:	02800a84 	movi	r10,42
 183fcd4:	02401b04 	movi	r9,108
 183fcd8:	9cc00044 	addi	r19,r19,1
 183fcdc:	18bff804 	addi	r2,r3,-32
 183fce0:	2881dd36 	bltu	r5,r2,1840458 <___svfiprintf_internal_r+0x8bc>
 183fce4:	100490ba 	slli	r2,r2,2
 183fce8:	02c06134 	movhi	r11,388
 183fcec:	5aff3f04 	addi	r11,r11,-772
 183fcf0:	12c5883a 	add	r2,r2,r11
 183fcf4:	10800017 	ldw	r2,0(r2)
 183fcf8:	1000683a 	jmp	r2
 183fcfc:	0183fef8 	rdprs	r6,zero,4091
 183fd00:	01840458 	cmpnei	r6,zero,4113
 183fd04:	01840458 	cmpnei	r6,zero,4113
 183fd08:	0183feec 	andhi	r6,zero,4091
 183fd0c:	01840458 	cmpnei	r6,zero,4113
 183fd10:	01840458 	cmpnei	r6,zero,4113
 183fd14:	01840458 	cmpnei	r6,zero,4113
 183fd18:	01840458 	cmpnei	r6,zero,4113
 183fd1c:	01840458 	cmpnei	r6,zero,4113
 183fd20:	01840458 	cmpnei	r6,zero,4113
 183fd24:	0183fe60 	cmpeqi	r6,zero,4089
 183fd28:	0184003c 	xorhi	r6,zero,4096
 183fd2c:	01840458 	cmpnei	r6,zero,4113
 183fd30:	0183fe8c 	andi	r6,zero,4090
 183fd34:	0184048c 	andi	r6,zero,4114
 183fd38:	01840458 	cmpnei	r6,zero,4113
 183fd3c:	01840480 	call	184048 <__alt_mem_tse_descriptor_memory_0+0x184048>
 183fd40:	01840420 	cmpeqi	r6,zero,4112
 183fd44:	01840420 	cmpeqi	r6,zero,4112
 183fd48:	01840420 	cmpeqi	r6,zero,4112
 183fd4c:	01840420 	cmpeqi	r6,zero,4112
 183fd50:	01840420 	cmpeqi	r6,zero,4112
 183fd54:	01840420 	cmpeqi	r6,zero,4112
 183fd58:	01840420 	cmpeqi	r6,zero,4112
 183fd5c:	01840420 	cmpeqi	r6,zero,4112
 183fd60:	01840420 	cmpeqi	r6,zero,4112
 183fd64:	01840458 	cmpnei	r6,zero,4113
 183fd68:	01840458 	cmpnei	r6,zero,4113
 183fd6c:	01840458 	cmpnei	r6,zero,4113
 183fd70:	01840458 	cmpnei	r6,zero,4113
 183fd74:	01840458 	cmpnei	r6,zero,4113
 183fd78:	01840458 	cmpnei	r6,zero,4113
 183fd7c:	01840458 	cmpnei	r6,zero,4113
 183fd80:	01840458 	cmpnei	r6,zero,4113
 183fd84:	01840458 	cmpnei	r6,zero,4113
 183fd88:	01840458 	cmpnei	r6,zero,4113
 183fd8c:	018403bc 	xorhi	r6,zero,4110
 183fd90:	01840458 	cmpnei	r6,zero,4113
 183fd94:	01840458 	cmpnei	r6,zero,4113
 183fd98:	01840458 	cmpnei	r6,zero,4113
 183fd9c:	01840458 	cmpnei	r6,zero,4113
 183fda0:	01840458 	cmpnei	r6,zero,4113
 183fda4:	01840458 	cmpnei	r6,zero,4113
 183fda8:	01840458 	cmpnei	r6,zero,4113
 183fdac:	01840458 	cmpnei	r6,zero,4113
 183fdb0:	01840458 	cmpnei	r6,zero,4113
 183fdb4:	01840458 	cmpnei	r6,zero,4113
 183fdb8:	01840534 	movhi	r6,4116
 183fdbc:	01840458 	cmpnei	r6,zero,4113
 183fdc0:	01840458 	cmpnei	r6,zero,4113
 183fdc4:	01840458 	cmpnei	r6,zero,4113
 183fdc8:	01840458 	cmpnei	r6,zero,4113
 183fdcc:	01840458 	cmpnei	r6,zero,4113
 183fdd0:	018404cc 	andi	r6,zero,4115
 183fdd4:	01840458 	cmpnei	r6,zero,4113
 183fdd8:	01840458 	cmpnei	r6,zero,4113
 183fddc:	01840200 	call	184020 <__alt_mem_tse_descriptor_memory_0+0x184020>
 183fde0:	01840458 	cmpnei	r6,zero,4113
 183fde4:	01840458 	cmpnei	r6,zero,4113
 183fde8:	01840458 	cmpnei	r6,zero,4113
 183fdec:	01840458 	cmpnei	r6,zero,4113
 183fdf0:	01840458 	cmpnei	r6,zero,4113
 183fdf4:	01840458 	cmpnei	r6,zero,4113
 183fdf8:	01840458 	cmpnei	r6,zero,4113
 183fdfc:	01840458 	cmpnei	r6,zero,4113
 183fe00:	01840458 	cmpnei	r6,zero,4113
 183fe04:	01840458 	cmpnei	r6,zero,4113
 183fe08:	018400f0 	cmpltui	r6,zero,4099
 183fe0c:	0184029c 	xori	r6,zero,4106
 183fe10:	01840458 	cmpnei	r6,zero,4113
 183fe14:	01840458 	cmpnei	r6,zero,4113
 183fe18:	01840458 	cmpnei	r6,zero,4113
 183fe1c:	01840290 	cmplti	r6,zero,4106
 183fe20:	0184029c 	xori	r6,zero,4106
 183fe24:	01840458 	cmpnei	r6,zero,4113
 183fe28:	01840458 	cmpnei	r6,zero,4113
 183fe2c:	01840280 	call	184028 <__alt_mem_tse_descriptor_memory_0+0x184028>
 183fe30:	01840458 	cmpnei	r6,zero,4113
 183fe34:	01840244 	movi	r6,4105
 183fe38:	0184004c 	andi	r6,zero,4097
 183fe3c:	0183fe98 	cmpnei	r6,zero,4090
 183fe40:	018403b0 	cmpltui	r6,zero,4110
 183fe44:	01840458 	cmpnei	r6,zero,4113
 183fe48:	01840364 	muli	r6,zero,4109
 183fe4c:	01840458 	cmpnei	r6,zero,4113
 183fe50:	0183ffbc 	xorhi	r6,zero,4094
 183fe54:	01840458 	cmpnei	r6,zero,4113
 183fe58:	01840458 	cmpnei	r6,zero,4113
 183fe5c:	0183ff18 	cmpnei	r6,zero,4092
 183fe60:	dac02317 	ldw	r11,140(sp)
 183fe64:	5ac00017 	ldw	r11,0(r11)
 183fe68:	dac02415 	stw	r11,144(sp)
 183fe6c:	dac02317 	ldw	r11,140(sp)
 183fe70:	58800104 	addi	r2,r11,4
 183fe74:	dac02417 	ldw	r11,144(sp)
 183fe78:	5802e90e 	bge	r11,zero,1840a20 <___svfiprintf_internal_r+0xe84>
 183fe7c:	dac02417 	ldw	r11,144(sp)
 183fe80:	d8802315 	stw	r2,140(sp)
 183fe84:	02d7c83a 	sub	r11,zero,r11
 183fe88:	dac02415 	stw	r11,144(sp)
 183fe8c:	94800114 	ori	r18,r18,4
 183fe90:	98c00007 	ldb	r3,0(r19)
 183fe94:	003f9006 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 183fe98:	00800c04 	movi	r2,48
 183fe9c:	dac02317 	ldw	r11,140(sp)
 183fea0:	d8801d05 	stb	r2,116(sp)
 183fea4:	00801e04 	movi	r2,120
 183fea8:	d8801d45 	stb	r2,117(sp)
 183feac:	d8001d85 	stb	zero,118(sp)
 183feb0:	58c00104 	addi	r3,r11,4
 183feb4:	5f000017 	ldw	fp,0(r11)
 183feb8:	0013883a 	mov	r9,zero
 183febc:	90800094 	ori	r2,r18,2
 183fec0:	80032b16 	blt	r16,zero,1840b70 <___svfiprintf_internal_r+0xfd4>
 183fec4:	00bfdfc4 	movi	r2,-129
 183fec8:	90a4703a 	and	r18,r18,r2
 183fecc:	d8c02315 	stw	r3,140(sp)
 183fed0:	94800094 	ori	r18,r18,2
 183fed4:	e002dc26 	beq	fp,zero,1840a48 <___svfiprintf_internal_r+0xeac>
 183fed8:	01006134 	movhi	r4,388
 183fedc:	2104e604 	addi	r4,r4,5016
 183fee0:	0015883a 	mov	r10,zero
 183fee4:	d9002915 	stw	r4,164(sp)
 183fee8:	00002306 	br	183ff78 <___svfiprintf_internal_r+0x3dc>
 183feec:	94800054 	ori	r18,r18,1
 183fef0:	98c00007 	ldb	r3,0(r19)
 183fef4:	003f7806 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 183fef8:	38803fcc 	andi	r2,r7,255
 183fefc:	1080201c 	xori	r2,r2,128
 183ff00:	10bfe004 	addi	r2,r2,-128
 183ff04:	1002f31e 	bne	r2,zero,1840ad4 <___svfiprintf_internal_r+0xf38>
 183ff08:	01000044 	movi	r4,1
 183ff0c:	01c00804 	movi	r7,32
 183ff10:	98c00007 	ldb	r3,0(r19)
 183ff14:	003f7006 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 183ff18:	21003fcc 	andi	r4,r4,255
 183ff1c:	2003aa1e 	bne	r4,zero,1840dc8 <___svfiprintf_internal_r+0x122c>
 183ff20:	00806134 	movhi	r2,388
 183ff24:	1084e604 	addi	r2,r2,5016
 183ff28:	d8802915 	stw	r2,164(sp)
 183ff2c:	9080080c 	andi	r2,r18,32
 183ff30:	1000ba26 	beq	r2,zero,184021c <___svfiprintf_internal_r+0x680>
 183ff34:	dac02317 	ldw	r11,140(sp)
 183ff38:	5f000017 	ldw	fp,0(r11)
 183ff3c:	5a400117 	ldw	r9,4(r11)
 183ff40:	5ac00204 	addi	r11,r11,8
 183ff44:	dac02315 	stw	r11,140(sp)
 183ff48:	9080004c 	andi	r2,r18,1
 183ff4c:	10029026 	beq	r2,zero,1840990 <___svfiprintf_internal_r+0xdf4>
 183ff50:	e244b03a 	or	r2,fp,r9
 183ff54:	1002d41e 	bne	r2,zero,1840aa8 <___svfiprintf_internal_r+0xf0c>
 183ff58:	d8001d85 	stb	zero,118(sp)
 183ff5c:	80030b16 	blt	r16,zero,1840b8c <___svfiprintf_internal_r+0xff0>
 183ff60:	00bfdfc4 	movi	r2,-129
 183ff64:	90a4703a 	and	r18,r18,r2
 183ff68:	0015883a 	mov	r10,zero
 183ff6c:	80002426 	beq	r16,zero,1840000 <___svfiprintf_internal_r+0x464>
 183ff70:	0039883a 	mov	fp,zero
 183ff74:	0013883a 	mov	r9,zero
 183ff78:	d9002917 	ldw	r4,164(sp)
 183ff7c:	dc401a04 	addi	r17,sp,104
 183ff80:	e08003cc 	andi	r2,fp,15
 183ff84:	4806973a 	slli	r3,r9,28
 183ff88:	2085883a 	add	r2,r4,r2
 183ff8c:	e038d13a 	srli	fp,fp,4
 183ff90:	10800003 	ldbu	r2,0(r2)
 183ff94:	4812d13a 	srli	r9,r9,4
 183ff98:	8c7fffc4 	addi	r17,r17,-1
 183ff9c:	1f38b03a 	or	fp,r3,fp
 183ffa0:	88800005 	stb	r2,0(r17)
 183ffa4:	e244b03a 	or	r2,fp,r9
 183ffa8:	103ff51e 	bne	r2,zero,183ff80 <__ram_exceptions_end+0xff82fb3c>
 183ffac:	dac01e17 	ldw	r11,120(sp)
 183ffb0:	5c57c83a 	sub	r11,r11,r17
 183ffb4:	dac02115 	stw	r11,132(sp)
 183ffb8:	00001406 	br	184000c <___svfiprintf_internal_r+0x470>
 183ffbc:	21003fcc 	andi	r4,r4,255
 183ffc0:	2003741e 	bne	r4,zero,1840d94 <___svfiprintf_internal_r+0x11f8>
 183ffc4:	9080080c 	andi	r2,r18,32
 183ffc8:	10014526 	beq	r2,zero,18404e0 <___svfiprintf_internal_r+0x944>
 183ffcc:	dac02317 	ldw	r11,140(sp)
 183ffd0:	d8001d85 	stb	zero,118(sp)
 183ffd4:	58c00204 	addi	r3,r11,8
 183ffd8:	5f000017 	ldw	fp,0(r11)
 183ffdc:	5a400117 	ldw	r9,4(r11)
 183ffe0:	8002d916 	blt	r16,zero,1840b48 <___svfiprintf_internal_r+0xfac>
 183ffe4:	013fdfc4 	movi	r4,-129
 183ffe8:	e244b03a 	or	r2,fp,r9
 183ffec:	d8c02315 	stw	r3,140(sp)
 183fff0:	9124703a 	and	r18,r18,r4
 183fff4:	0015883a 	mov	r10,zero
 183fff8:	1000b91e 	bne	r2,zero,18402e0 <___svfiprintf_internal_r+0x744>
 183fffc:	8002e61e 	bne	r16,zero,1840b98 <___svfiprintf_internal_r+0xffc>
 1840000:	0021883a 	mov	r16,zero
 1840004:	d8002115 	stw	zero,132(sp)
 1840008:	dc401a04 	addi	r17,sp,104
 184000c:	d8c02117 	ldw	r3,132(sp)
 1840010:	dc002015 	stw	r16,128(sp)
 1840014:	80c0010e 	bge	r16,r3,184001c <___svfiprintf_internal_r+0x480>
 1840018:	d8c02015 	stw	r3,128(sp)
 184001c:	52803fcc 	andi	r10,r10,255
 1840020:	5280201c 	xori	r10,r10,128
 1840024:	52bfe004 	addi	r10,r10,-128
 1840028:	50003c26 	beq	r10,zero,184011c <___svfiprintf_internal_r+0x580>
 184002c:	dac02017 	ldw	r11,128(sp)
 1840030:	5ac00044 	addi	r11,r11,1
 1840034:	dac02015 	stw	r11,128(sp)
 1840038:	00003806 	br	184011c <___svfiprintf_internal_r+0x580>
 184003c:	01000044 	movi	r4,1
 1840040:	01c00ac4 	movi	r7,43
 1840044:	98c00007 	ldb	r3,0(r19)
 1840048:	003f2306 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 184004c:	21003fcc 	andi	r4,r4,255
 1840050:	2003481e 	bne	r4,zero,1840d74 <___svfiprintf_internal_r+0x11d8>
 1840054:	9080080c 	andi	r2,r18,32
 1840058:	10013b26 	beq	r2,zero,1840548 <___svfiprintf_internal_r+0x9ac>
 184005c:	dac02317 	ldw	r11,140(sp)
 1840060:	d8001d85 	stb	zero,118(sp)
 1840064:	58800204 	addi	r2,r11,8
 1840068:	5f000017 	ldw	fp,0(r11)
 184006c:	5a400117 	ldw	r9,4(r11)
 1840070:	8002a816 	blt	r16,zero,1840b14 <___svfiprintf_internal_r+0xf78>
 1840074:	013fdfc4 	movi	r4,-129
 1840078:	e246b03a 	or	r3,fp,r9
 184007c:	d8802315 	stw	r2,140(sp)
 1840080:	9124703a 	and	r18,r18,r4
 1840084:	18013c26 	beq	r3,zero,1840578 <___svfiprintf_internal_r+0x9dc>
 1840088:	0015883a 	mov	r10,zero
 184008c:	dc401a04 	addi	r17,sp,104
 1840090:	e006d0fa 	srli	r3,fp,3
 1840094:	4808977a 	slli	r4,r9,29
 1840098:	4812d0fa 	srli	r9,r9,3
 184009c:	e70001cc 	andi	fp,fp,7
 18400a0:	e0800c04 	addi	r2,fp,48
 18400a4:	8c7fffc4 	addi	r17,r17,-1
 18400a8:	20f8b03a 	or	fp,r4,r3
 18400ac:	88800005 	stb	r2,0(r17)
 18400b0:	e246b03a 	or	r3,fp,r9
 18400b4:	183ff61e 	bne	r3,zero,1840090 <__ram_exceptions_end+0xff82fc4c>
 18400b8:	90c0004c 	andi	r3,r18,1
 18400bc:	1800a526 	beq	r3,zero,1840354 <___svfiprintf_internal_r+0x7b8>
 18400c0:	10803fcc 	andi	r2,r2,255
 18400c4:	1080201c 	xori	r2,r2,128
 18400c8:	10bfe004 	addi	r2,r2,-128
 18400cc:	00c00c04 	movi	r3,48
 18400d0:	10ffb626 	beq	r2,r3,183ffac <__ram_exceptions_end+0xff82fb68>
 18400d4:	88ffffc5 	stb	r3,-1(r17)
 18400d8:	d8c01e17 	ldw	r3,120(sp)
 18400dc:	88bfffc4 	addi	r2,r17,-1
 18400e0:	1023883a 	mov	r17,r2
 18400e4:	1887c83a 	sub	r3,r3,r2
 18400e8:	d8c02115 	stw	r3,132(sp)
 18400ec:	003fc706 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 18400f0:	dac02317 	ldw	r11,140(sp)
 18400f4:	00c00044 	movi	r3,1
 18400f8:	d8c02015 	stw	r3,128(sp)
 18400fc:	58800017 	ldw	r2,0(r11)
 1840100:	5ac00104 	addi	r11,r11,4
 1840104:	d8001d85 	stb	zero,118(sp)
 1840108:	d8801005 	stb	r2,64(sp)
 184010c:	dac02315 	stw	r11,140(sp)
 1840110:	d8c02115 	stw	r3,132(sp)
 1840114:	dc401004 	addi	r17,sp,64
 1840118:	0021883a 	mov	r16,zero
 184011c:	90c0008c 	andi	r3,r18,2
 1840120:	d8c02215 	stw	r3,136(sp)
 1840124:	18000326 	beq	r3,zero,1840134 <___svfiprintf_internal_r+0x598>
 1840128:	dac02017 	ldw	r11,128(sp)
 184012c:	5ac00084 	addi	r11,r11,2
 1840130:	dac02015 	stw	r11,128(sp)
 1840134:	90c0210c 	andi	r3,r18,132
 1840138:	d8c02615 	stw	r3,152(sp)
 184013c:	1801131e 	bne	r3,zero,184058c <___svfiprintf_internal_r+0x9f0>
 1840140:	dac02417 	ldw	r11,144(sp)
 1840144:	d8c02017 	ldw	r3,128(sp)
 1840148:	58f9c83a 	sub	fp,r11,r3
 184014c:	07010f0e 	bge	zero,fp,184058c <___svfiprintf_internal_r+0x9f0>
 1840150:	02400404 	movi	r9,16
 1840154:	d8c01c17 	ldw	r3,112(sp)
 1840158:	d8801b17 	ldw	r2,108(sp)
 184015c:	4f02d60e 	bge	r9,fp,1840cb8 <___svfiprintf_internal_r+0x111c>
 1840160:	01406134 	movhi	r5,388
 1840164:	294fc804 	addi	r5,r5,16160
 1840168:	d9402815 	stw	r5,160(sp)
 184016c:	028001c4 	movi	r10,7
 1840170:	00000306 	br	1840180 <___svfiprintf_internal_r+0x5e4>
 1840174:	e73ffc04 	addi	fp,fp,-16
 1840178:	42000204 	addi	r8,r8,8
 184017c:	4f00150e 	bge	r9,fp,18401d4 <___svfiprintf_internal_r+0x638>
 1840180:	18c00404 	addi	r3,r3,16
 1840184:	10800044 	addi	r2,r2,1
 1840188:	45800015 	stw	r22,0(r8)
 184018c:	42400115 	stw	r9,4(r8)
 1840190:	d8c01c15 	stw	r3,112(sp)
 1840194:	d8801b15 	stw	r2,108(sp)
 1840198:	50bff60e 	bge	r10,r2,1840174 <__ram_exceptions_end+0xff82fd30>
 184019c:	d9801a04 	addi	r6,sp,104
 18401a0:	b80b883a 	mov	r5,r23
 18401a4:	a809883a 	mov	r4,r21
 18401a8:	da402c15 	stw	r9,176(sp)
 18401ac:	da802d15 	stw	r10,180(sp)
 18401b0:	183f9cc0 	call	183f9cc <__ssprint_r>
 18401b4:	da402c17 	ldw	r9,176(sp)
 18401b8:	da802d17 	ldw	r10,180(sp)
 18401bc:	1001851e 	bne	r2,zero,18407d4 <___svfiprintf_internal_r+0xc38>
 18401c0:	e73ffc04 	addi	fp,fp,-16
 18401c4:	d8c01c17 	ldw	r3,112(sp)
 18401c8:	d8801b17 	ldw	r2,108(sp)
 18401cc:	d811883a 	mov	r8,sp
 18401d0:	4f3feb16 	blt	r9,fp,1840180 <__ram_exceptions_end+0xff82fd3c>
 18401d4:	dac02817 	ldw	r11,160(sp)
 18401d8:	e0c7883a 	add	r3,fp,r3
 18401dc:	10800044 	addi	r2,r2,1
 18401e0:	42c00015 	stw	r11,0(r8)
 18401e4:	47000115 	stw	fp,4(r8)
 18401e8:	d8c01c15 	stw	r3,112(sp)
 18401ec:	d8801b15 	stw	r2,108(sp)
 18401f0:	010001c4 	movi	r4,7
 18401f4:	2081ee16 	blt	r4,r2,18409b0 <___svfiprintf_internal_r+0xe14>
 18401f8:	42000204 	addi	r8,r8,8
 18401fc:	0000e506 	br	1840594 <___svfiprintf_internal_r+0x9f8>
 1840200:	21003fcc 	andi	r4,r4,255
 1840204:	2002dd1e 	bne	r4,zero,1840d7c <___svfiprintf_internal_r+0x11e0>
 1840208:	00806134 	movhi	r2,388
 184020c:	1084e104 	addi	r2,r2,4996
 1840210:	d8802915 	stw	r2,164(sp)
 1840214:	9080080c 	andi	r2,r18,32
 1840218:	103f461e 	bne	r2,zero,183ff34 <__ram_exceptions_end+0xff82faf0>
 184021c:	9080040c 	andi	r2,r18,16
 1840220:	10022e1e 	bne	r2,zero,1840adc <___svfiprintf_internal_r+0xf40>
 1840224:	9080100c 	andi	r2,r18,64
 1840228:	dac02317 	ldw	r11,140(sp)
 184022c:	10027326 	beq	r2,zero,1840bfc <___svfiprintf_internal_r+0x1060>
 1840230:	5f00000b 	ldhu	fp,0(r11)
 1840234:	5ac00104 	addi	r11,r11,4
 1840238:	0013883a 	mov	r9,zero
 184023c:	dac02315 	stw	r11,140(sp)
 1840240:	003f4106 	br	183ff48 <__ram_exceptions_end+0xff82fb04>
 1840244:	21003fcc 	andi	r4,r4,255
 1840248:	2002e11e 	bne	r4,zero,1840dd0 <___svfiprintf_internal_r+0x1234>
 184024c:	9080080c 	andi	r2,r18,32
 1840250:	1002011e 	bne	r2,zero,1840a58 <___svfiprintf_internal_r+0xebc>
 1840254:	9080040c 	andi	r2,r18,16
 1840258:	10023e1e 	bne	r2,zero,1840b54 <___svfiprintf_internal_r+0xfb8>
 184025c:	9480100c 	andi	r18,r18,64
 1840260:	90023c26 	beq	r18,zero,1840b54 <___svfiprintf_internal_r+0xfb8>
 1840264:	dac02317 	ldw	r11,140(sp)
 1840268:	58800017 	ldw	r2,0(r11)
 184026c:	5ac00104 	addi	r11,r11,4
 1840270:	dac02315 	stw	r11,140(sp)
 1840274:	dac02517 	ldw	r11,148(sp)
 1840278:	12c0000d 	sth	r11,0(r2)
 184027c:	003e6e06 	br	183fc38 <__ram_exceptions_end+0xff82f7f4>
 1840280:	98c00007 	ldb	r3,0(r19)
 1840284:	1a422926 	beq	r3,r9,1840b2c <___svfiprintf_internal_r+0xf90>
 1840288:	94800414 	ori	r18,r18,16
 184028c:	003e9206 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 1840290:	94801014 	ori	r18,r18,64
 1840294:	98c00007 	ldb	r3,0(r19)
 1840298:	003e8f06 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 184029c:	21003fcc 	andi	r4,r4,255
 18402a0:	2002c71e 	bne	r4,zero,1840dc0 <___svfiprintf_internal_r+0x1224>
 18402a4:	9080080c 	andi	r2,r18,32
 18402a8:	10004926 	beq	r2,zero,18403d0 <___svfiprintf_internal_r+0x834>
 18402ac:	dac02317 	ldw	r11,140(sp)
 18402b0:	58800117 	ldw	r2,4(r11)
 18402b4:	5f000017 	ldw	fp,0(r11)
 18402b8:	5ac00204 	addi	r11,r11,8
 18402bc:	dac02315 	stw	r11,140(sp)
 18402c0:	1013883a 	mov	r9,r2
 18402c4:	10004b16 	blt	r2,zero,18403f4 <___svfiprintf_internal_r+0x858>
 18402c8:	da801d83 	ldbu	r10,118(sp)
 18402cc:	8001cb16 	blt	r16,zero,18409fc <___svfiprintf_internal_r+0xe60>
 18402d0:	00ffdfc4 	movi	r3,-129
 18402d4:	e244b03a 	or	r2,fp,r9
 18402d8:	90e4703a 	and	r18,r18,r3
 18402dc:	103f4726 	beq	r2,zero,183fffc <__ram_exceptions_end+0xff82fbb8>
 18402e0:	48008c26 	beq	r9,zero,1840514 <___svfiprintf_internal_r+0x978>
 18402e4:	dc802015 	stw	r18,128(sp)
 18402e8:	dc002115 	stw	r16,132(sp)
 18402ec:	dc401a04 	addi	r17,sp,104
 18402f0:	e021883a 	mov	r16,fp
 18402f4:	da002215 	stw	r8,136(sp)
 18402f8:	5039883a 	mov	fp,r10
 18402fc:	4825883a 	mov	r18,r9
 1840300:	8009883a 	mov	r4,r16
 1840304:	900b883a 	mov	r5,r18
 1840308:	01800284 	movi	r6,10
 184030c:	000f883a 	mov	r7,zero
 1840310:	180a6e00 	call	180a6e0 <__umoddi3>
 1840314:	10800c04 	addi	r2,r2,48
 1840318:	8c7fffc4 	addi	r17,r17,-1
 184031c:	8009883a 	mov	r4,r16
 1840320:	900b883a 	mov	r5,r18
 1840324:	88800005 	stb	r2,0(r17)
 1840328:	01800284 	movi	r6,10
 184032c:	000f883a 	mov	r7,zero
 1840330:	180a1680 	call	180a168 <__udivdi3>
 1840334:	1021883a 	mov	r16,r2
 1840338:	10c4b03a 	or	r2,r2,r3
 184033c:	1825883a 	mov	r18,r3
 1840340:	103fef1e 	bne	r2,zero,1840300 <__ram_exceptions_end+0xff82febc>
 1840344:	dc802017 	ldw	r18,128(sp)
 1840348:	dc002117 	ldw	r16,132(sp)
 184034c:	da002217 	ldw	r8,136(sp)
 1840350:	e015883a 	mov	r10,fp
 1840354:	d8c01e17 	ldw	r3,120(sp)
 1840358:	1c47c83a 	sub	r3,r3,r17
 184035c:	d8c02115 	stw	r3,132(sp)
 1840360:	003f2a06 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840364:	dac02317 	ldw	r11,140(sp)
 1840368:	d8001d85 	stb	zero,118(sp)
 184036c:	5c400017 	ldw	r17,0(r11)
 1840370:	5f000104 	addi	fp,r11,4
 1840374:	88022f26 	beq	r17,zero,1840c34 <___svfiprintf_internal_r+0x1098>
 1840378:	80022516 	blt	r16,zero,1840c10 <___svfiprintf_internal_r+0x1074>
 184037c:	800d883a 	mov	r6,r16
 1840380:	000b883a 	mov	r5,zero
 1840384:	8809883a 	mov	r4,r17
 1840388:	da002c15 	stw	r8,176(sp)
 184038c:	1805fa80 	call	1805fa8 <memchr>
 1840390:	da002c17 	ldw	r8,176(sp)
 1840394:	10026426 	beq	r2,zero,1840d28 <___svfiprintf_internal_r+0x118c>
 1840398:	1445c83a 	sub	r2,r2,r17
 184039c:	d8802115 	stw	r2,132(sp)
 18403a0:	da801d83 	ldbu	r10,118(sp)
 18403a4:	df002315 	stw	fp,140(sp)
 18403a8:	0021883a 	mov	r16,zero
 18403ac:	003f1706 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 18403b0:	94800814 	ori	r18,r18,32
 18403b4:	98c00007 	ldb	r3,0(r19)
 18403b8:	003e4706 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 18403bc:	21003fcc 	andi	r4,r4,255
 18403c0:	2002701e 	bne	r4,zero,1840d84 <___svfiprintf_internal_r+0x11e8>
 18403c4:	94800414 	ori	r18,r18,16
 18403c8:	9080080c 	andi	r2,r18,32
 18403cc:	103fb71e 	bne	r2,zero,18402ac <__ram_exceptions_end+0xff82fe68>
 18403d0:	9080040c 	andi	r2,r18,16
 18403d4:	1001ab26 	beq	r2,zero,1840a84 <___svfiprintf_internal_r+0xee8>
 18403d8:	dac02317 	ldw	r11,140(sp)
 18403dc:	5f000017 	ldw	fp,0(r11)
 18403e0:	5ac00104 	addi	r11,r11,4
 18403e4:	dac02315 	stw	r11,140(sp)
 18403e8:	e013d7fa 	srai	r9,fp,31
 18403ec:	4805883a 	mov	r2,r9
 18403f0:	103fb50e 	bge	r2,zero,18402c8 <__ram_exceptions_end+0xff82fe84>
 18403f4:	0739c83a 	sub	fp,zero,fp
 18403f8:	02800b44 	movi	r10,45
 18403fc:	e004c03a 	cmpne	r2,fp,zero
 1840400:	0253c83a 	sub	r9,zero,r9
 1840404:	da801d85 	stb	r10,118(sp)
 1840408:	4893c83a 	sub	r9,r9,r2
 184040c:	80023016 	blt	r16,zero,1840cd0 <___svfiprintf_internal_r+0x1134>
 1840410:	00bfdfc4 	movi	r2,-129
 1840414:	90a4703a 	and	r18,r18,r2
 1840418:	483fb21e 	bne	r9,zero,18402e4 <__ram_exceptions_end+0xff82fea0>
 184041c:	00003d06 	br	1840514 <___svfiprintf_internal_r+0x978>
 1840420:	9817883a 	mov	r11,r19
 1840424:	d8002415 	stw	zero,144(sp)
 1840428:	18bff404 	addi	r2,r3,-48
 184042c:	0019883a 	mov	r12,zero
 1840430:	58c00007 	ldb	r3,0(r11)
 1840434:	630002a4 	muli	r12,r12,10
 1840438:	9cc00044 	addi	r19,r19,1
 184043c:	9817883a 	mov	r11,r19
 1840440:	1319883a 	add	r12,r2,r12
 1840444:	18bff404 	addi	r2,r3,-48
 1840448:	30bff92e 	bgeu	r6,r2,1840430 <__ram_exceptions_end+0xff82ffec>
 184044c:	db002415 	stw	r12,144(sp)
 1840450:	18bff804 	addi	r2,r3,-32
 1840454:	28be232e 	bgeu	r5,r2,183fce4 <__ram_exceptions_end+0xff82f8a0>
 1840458:	21003fcc 	andi	r4,r4,255
 184045c:	20024b1e 	bne	r4,zero,1840d8c <___svfiprintf_internal_r+0x11f0>
 1840460:	1800d626 	beq	r3,zero,18407bc <___svfiprintf_internal_r+0xc20>
 1840464:	02c00044 	movi	r11,1
 1840468:	dac02015 	stw	r11,128(sp)
 184046c:	d8c01005 	stb	r3,64(sp)
 1840470:	d8001d85 	stb	zero,118(sp)
 1840474:	dac02115 	stw	r11,132(sp)
 1840478:	dc401004 	addi	r17,sp,64
 184047c:	003f2606 	br	1840118 <__ram_exceptions_end+0xff82fcd4>
 1840480:	94802014 	ori	r18,r18,128
 1840484:	98c00007 	ldb	r3,0(r19)
 1840488:	003e1306 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 184048c:	98c00007 	ldb	r3,0(r19)
 1840490:	9ac00044 	addi	r11,r19,1
 1840494:	1a822b26 	beq	r3,r10,1840d44 <___svfiprintf_internal_r+0x11a8>
 1840498:	18bff404 	addi	r2,r3,-48
 184049c:	0021883a 	mov	r16,zero
 18404a0:	30821e36 	bltu	r6,r2,1840d1c <___svfiprintf_internal_r+0x1180>
 18404a4:	58c00007 	ldb	r3,0(r11)
 18404a8:	840002a4 	muli	r16,r16,10
 18404ac:	5cc00044 	addi	r19,r11,1
 18404b0:	9817883a 	mov	r11,r19
 18404b4:	80a1883a 	add	r16,r16,r2
 18404b8:	18bff404 	addi	r2,r3,-48
 18404bc:	30bff92e 	bgeu	r6,r2,18404a4 <__ram_exceptions_end+0xff830060>
 18404c0:	803e060e 	bge	r16,zero,183fcdc <__ram_exceptions_end+0xff82f898>
 18404c4:	043fffc4 	movi	r16,-1
 18404c8:	003e0406 	br	183fcdc <__ram_exceptions_end+0xff82f898>
 18404cc:	21003fcc 	andi	r4,r4,255
 18404d0:	2002371e 	bne	r4,zero,1840db0 <___svfiprintf_internal_r+0x1214>
 18404d4:	94800414 	ori	r18,r18,16
 18404d8:	9080080c 	andi	r2,r18,32
 18404dc:	103ebb1e 	bne	r2,zero,183ffcc <__ram_exceptions_end+0xff82fb88>
 18404e0:	9080040c 	andi	r2,r18,16
 18404e4:	10013b26 	beq	r2,zero,18409d4 <___svfiprintf_internal_r+0xe38>
 18404e8:	dac02317 	ldw	r11,140(sp)
 18404ec:	d8001d85 	stb	zero,118(sp)
 18404f0:	0013883a 	mov	r9,zero
 18404f4:	58800104 	addi	r2,r11,4
 18404f8:	5f000017 	ldw	fp,0(r11)
 18404fc:	80013d16 	blt	r16,zero,18409f4 <___svfiprintf_internal_r+0xe58>
 1840500:	00ffdfc4 	movi	r3,-129
 1840504:	d8802315 	stw	r2,140(sp)
 1840508:	90e4703a 	and	r18,r18,r3
 184050c:	0015883a 	mov	r10,zero
 1840510:	e03eba26 	beq	fp,zero,183fffc <__ram_exceptions_end+0xff82fbb8>
 1840514:	00800244 	movi	r2,9
 1840518:	173f7236 	bltu	r2,fp,18402e4 <__ram_exceptions_end+0xff82fea0>
 184051c:	dac02b17 	ldw	r11,172(sp)
 1840520:	e7000c04 	addi	fp,fp,48
 1840524:	df0019c5 	stb	fp,103(sp)
 1840528:	dac02115 	stw	r11,132(sp)
 184052c:	dc4019c4 	addi	r17,sp,103
 1840530:	003eb606 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840534:	21003fcc 	andi	r4,r4,255
 1840538:	20021f1e 	bne	r4,zero,1840db8 <___svfiprintf_internal_r+0x121c>
 184053c:	94800414 	ori	r18,r18,16
 1840540:	9080080c 	andi	r2,r18,32
 1840544:	103ec51e 	bne	r2,zero,184005c <__ram_exceptions_end+0xff82fc18>
 1840548:	9080040c 	andi	r2,r18,16
 184054c:	10016926 	beq	r2,zero,1840af4 <___svfiprintf_internal_r+0xf58>
 1840550:	dac02317 	ldw	r11,140(sp)
 1840554:	d8001d85 	stb	zero,118(sp)
 1840558:	0013883a 	mov	r9,zero
 184055c:	58800104 	addi	r2,r11,4
 1840560:	5f000017 	ldw	fp,0(r11)
 1840564:	80016b16 	blt	r16,zero,1840b14 <___svfiprintf_internal_r+0xf78>
 1840568:	00ffdfc4 	movi	r3,-129
 184056c:	d8802315 	stw	r2,140(sp)
 1840570:	90e4703a 	and	r18,r18,r3
 1840574:	e03ec41e 	bne	fp,zero,1840088 <__ram_exceptions_end+0xff82fc44>
 1840578:	0015883a 	mov	r10,zero
 184057c:	8001c226 	beq	r16,zero,1840c88 <___svfiprintf_internal_r+0x10ec>
 1840580:	0039883a 	mov	fp,zero
 1840584:	0013883a 	mov	r9,zero
 1840588:	003ec006 	br	184008c <__ram_exceptions_end+0xff82fc48>
 184058c:	d8c01c17 	ldw	r3,112(sp)
 1840590:	d8801b17 	ldw	r2,108(sp)
 1840594:	d9001d87 	ldb	r4,118(sp)
 1840598:	20000b26 	beq	r4,zero,18405c8 <___svfiprintf_internal_r+0xa2c>
 184059c:	d9001d84 	addi	r4,sp,118
 18405a0:	18c00044 	addi	r3,r3,1
 18405a4:	10800044 	addi	r2,r2,1
 18405a8:	41000015 	stw	r4,0(r8)
 18405ac:	01000044 	movi	r4,1
 18405b0:	41000115 	stw	r4,4(r8)
 18405b4:	d8c01c15 	stw	r3,112(sp)
 18405b8:	d8801b15 	stw	r2,108(sp)
 18405bc:	010001c4 	movi	r4,7
 18405c0:	2080e116 	blt	r4,r2,1840948 <___svfiprintf_internal_r+0xdac>
 18405c4:	42000204 	addi	r8,r8,8
 18405c8:	dac02217 	ldw	r11,136(sp)
 18405cc:	58000b26 	beq	r11,zero,18405fc <___svfiprintf_internal_r+0xa60>
 18405d0:	d9001d04 	addi	r4,sp,116
 18405d4:	18c00084 	addi	r3,r3,2
 18405d8:	10800044 	addi	r2,r2,1
 18405dc:	41000015 	stw	r4,0(r8)
 18405e0:	01000084 	movi	r4,2
 18405e4:	41000115 	stw	r4,4(r8)
 18405e8:	d8c01c15 	stw	r3,112(sp)
 18405ec:	d8801b15 	stw	r2,108(sp)
 18405f0:	010001c4 	movi	r4,7
 18405f4:	2080dd16 	blt	r4,r2,184096c <___svfiprintf_internal_r+0xdd0>
 18405f8:	42000204 	addi	r8,r8,8
 18405fc:	dac02617 	ldw	r11,152(sp)
 1840600:	01002004 	movi	r4,128
 1840604:	59008426 	beq	r11,r4,1840818 <___svfiprintf_internal_r+0xc7c>
 1840608:	dac02117 	ldw	r11,132(sp)
 184060c:	82e1c83a 	sub	r16,r16,r11
 1840610:	0400270e 	bge	zero,r16,18406b0 <___svfiprintf_internal_r+0xb14>
 1840614:	01c00404 	movi	r7,16
 1840618:	3c016a0e 	bge	r7,r16,1840bc4 <___svfiprintf_internal_r+0x1028>
 184061c:	01406134 	movhi	r5,388
 1840620:	294fc404 	addi	r5,r5,16144
 1840624:	d9402215 	stw	r5,136(sp)
 1840628:	070001c4 	movi	fp,7
 184062c:	00000306 	br	184063c <___svfiprintf_internal_r+0xaa0>
 1840630:	843ffc04 	addi	r16,r16,-16
 1840634:	42000204 	addi	r8,r8,8
 1840638:	3c00130e 	bge	r7,r16,1840688 <___svfiprintf_internal_r+0xaec>
 184063c:	18c00404 	addi	r3,r3,16
 1840640:	10800044 	addi	r2,r2,1
 1840644:	45000015 	stw	r20,0(r8)
 1840648:	41c00115 	stw	r7,4(r8)
 184064c:	d8c01c15 	stw	r3,112(sp)
 1840650:	d8801b15 	stw	r2,108(sp)
 1840654:	e0bff60e 	bge	fp,r2,1840630 <__ram_exceptions_end+0xff8301ec>
 1840658:	d9801a04 	addi	r6,sp,104
 184065c:	b80b883a 	mov	r5,r23
 1840660:	a809883a 	mov	r4,r21
 1840664:	d9c02c15 	stw	r7,176(sp)
 1840668:	183f9cc0 	call	183f9cc <__ssprint_r>
 184066c:	d9c02c17 	ldw	r7,176(sp)
 1840670:	1000581e 	bne	r2,zero,18407d4 <___svfiprintf_internal_r+0xc38>
 1840674:	843ffc04 	addi	r16,r16,-16
 1840678:	d8c01c17 	ldw	r3,112(sp)
 184067c:	d8801b17 	ldw	r2,108(sp)
 1840680:	d811883a 	mov	r8,sp
 1840684:	3c3fed16 	blt	r7,r16,184063c <__ram_exceptions_end+0xff8301f8>
 1840688:	dac02217 	ldw	r11,136(sp)
 184068c:	1c07883a 	add	r3,r3,r16
 1840690:	10800044 	addi	r2,r2,1
 1840694:	42c00015 	stw	r11,0(r8)
 1840698:	44000115 	stw	r16,4(r8)
 184069c:	d8c01c15 	stw	r3,112(sp)
 18406a0:	d8801b15 	stw	r2,108(sp)
 18406a4:	010001c4 	movi	r4,7
 18406a8:	20809e16 	blt	r4,r2,1840924 <___svfiprintf_internal_r+0xd88>
 18406ac:	42000204 	addi	r8,r8,8
 18406b0:	dac02117 	ldw	r11,132(sp)
 18406b4:	10800044 	addi	r2,r2,1
 18406b8:	44400015 	stw	r17,0(r8)
 18406bc:	58c7883a 	add	r3,r11,r3
 18406c0:	42c00115 	stw	r11,4(r8)
 18406c4:	d8c01c15 	stw	r3,112(sp)
 18406c8:	d8801b15 	stw	r2,108(sp)
 18406cc:	010001c4 	movi	r4,7
 18406d0:	20807f16 	blt	r4,r2,18408d0 <___svfiprintf_internal_r+0xd34>
 18406d4:	42000204 	addi	r8,r8,8
 18406d8:	9480010c 	andi	r18,r18,4
 18406dc:	90002926 	beq	r18,zero,1840784 <___svfiprintf_internal_r+0xbe8>
 18406e0:	dac02417 	ldw	r11,144(sp)
 18406e4:	d8802017 	ldw	r2,128(sp)
 18406e8:	58a1c83a 	sub	r16,r11,r2
 18406ec:	0400250e 	bge	zero,r16,1840784 <___svfiprintf_internal_r+0xbe8>
 18406f0:	04400404 	movi	r17,16
 18406f4:	d8801b17 	ldw	r2,108(sp)
 18406f8:	8c017c0e 	bge	r17,r16,1840cec <___svfiprintf_internal_r+0x1150>
 18406fc:	01406134 	movhi	r5,388
 1840700:	294fc804 	addi	r5,r5,16160
 1840704:	d9402815 	stw	r5,160(sp)
 1840708:	048001c4 	movi	r18,7
 184070c:	00000306 	br	184071c <___svfiprintf_internal_r+0xb80>
 1840710:	843ffc04 	addi	r16,r16,-16
 1840714:	42000204 	addi	r8,r8,8
 1840718:	8c00110e 	bge	r17,r16,1840760 <___svfiprintf_internal_r+0xbc4>
 184071c:	18c00404 	addi	r3,r3,16
 1840720:	10800044 	addi	r2,r2,1
 1840724:	45800015 	stw	r22,0(r8)
 1840728:	44400115 	stw	r17,4(r8)
 184072c:	d8c01c15 	stw	r3,112(sp)
 1840730:	d8801b15 	stw	r2,108(sp)
 1840734:	90bff60e 	bge	r18,r2,1840710 <__ram_exceptions_end+0xff8302cc>
 1840738:	d9801a04 	addi	r6,sp,104
 184073c:	b80b883a 	mov	r5,r23
 1840740:	a809883a 	mov	r4,r21
 1840744:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840748:	1000221e 	bne	r2,zero,18407d4 <___svfiprintf_internal_r+0xc38>
 184074c:	843ffc04 	addi	r16,r16,-16
 1840750:	d8c01c17 	ldw	r3,112(sp)
 1840754:	d8801b17 	ldw	r2,108(sp)
 1840758:	d811883a 	mov	r8,sp
 184075c:	8c3fef16 	blt	r17,r16,184071c <__ram_exceptions_end+0xff8302d8>
 1840760:	dac02817 	ldw	r11,160(sp)
 1840764:	1c07883a 	add	r3,r3,r16
 1840768:	10800044 	addi	r2,r2,1
 184076c:	42c00015 	stw	r11,0(r8)
 1840770:	44000115 	stw	r16,4(r8)
 1840774:	d8c01c15 	stw	r3,112(sp)
 1840778:	d8801b15 	stw	r2,108(sp)
 184077c:	010001c4 	movi	r4,7
 1840780:	2080aa16 	blt	r4,r2,1840a2c <___svfiprintf_internal_r+0xe90>
 1840784:	d8802417 	ldw	r2,144(sp)
 1840788:	dac02017 	ldw	r11,128(sp)
 184078c:	12c0010e 	bge	r2,r11,1840794 <___svfiprintf_internal_r+0xbf8>
 1840790:	5805883a 	mov	r2,r11
 1840794:	dac02517 	ldw	r11,148(sp)
 1840798:	5897883a 	add	r11,r11,r2
 184079c:	dac02515 	stw	r11,148(sp)
 18407a0:	1800531e 	bne	r3,zero,18408f0 <___svfiprintf_internal_r+0xd54>
 18407a4:	98800007 	ldb	r2,0(r19)
 18407a8:	d8001b15 	stw	zero,108(sp)
 18407ac:	d811883a 	mov	r8,sp
 18407b0:	103d231e 	bne	r2,zero,183fc40 <__ram_exceptions_end+0xff82f7fc>
 18407b4:	9823883a 	mov	r17,r19
 18407b8:	003d3906 	br	183fca0 <__ram_exceptions_end+0xff82f85c>
 18407bc:	d8801c17 	ldw	r2,112(sp)
 18407c0:	10000426 	beq	r2,zero,18407d4 <___svfiprintf_internal_r+0xc38>
 18407c4:	d9402717 	ldw	r5,156(sp)
 18407c8:	d9002a17 	ldw	r4,168(sp)
 18407cc:	d9801a04 	addi	r6,sp,104
 18407d0:	183f9cc0 	call	183f9cc <__ssprint_r>
 18407d4:	dac02717 	ldw	r11,156(sp)
 18407d8:	d8802517 	ldw	r2,148(sp)
 18407dc:	58c0030b 	ldhu	r3,12(r11)
 18407e0:	18c0100c 	andi	r3,r3,64
 18407e4:	1801381e 	bne	r3,zero,1840cc8 <___svfiprintf_internal_r+0x112c>
 18407e8:	dfc03717 	ldw	ra,220(sp)
 18407ec:	df003617 	ldw	fp,216(sp)
 18407f0:	ddc03517 	ldw	r23,212(sp)
 18407f4:	dd803417 	ldw	r22,208(sp)
 18407f8:	dd403317 	ldw	r21,204(sp)
 18407fc:	dd003217 	ldw	r20,200(sp)
 1840800:	dcc03117 	ldw	r19,196(sp)
 1840804:	dc803017 	ldw	r18,192(sp)
 1840808:	dc402f17 	ldw	r17,188(sp)
 184080c:	dc002e17 	ldw	r16,184(sp)
 1840810:	dec03804 	addi	sp,sp,224
 1840814:	f800283a 	ret
 1840818:	dac02417 	ldw	r11,144(sp)
 184081c:	d9002017 	ldw	r4,128(sp)
 1840820:	5939c83a 	sub	fp,r11,r4
 1840824:	073f780e 	bge	zero,fp,1840608 <__ram_exceptions_end+0xff8301c4>
 1840828:	02400404 	movi	r9,16
 184082c:	4f01370e 	bge	r9,fp,1840d0c <___svfiprintf_internal_r+0x1170>
 1840830:	02c06134 	movhi	r11,388
 1840834:	5acfc404 	addi	r11,r11,16144
 1840838:	dac02215 	stw	r11,136(sp)
 184083c:	028001c4 	movi	r10,7
 1840840:	00000306 	br	1840850 <___svfiprintf_internal_r+0xcb4>
 1840844:	e73ffc04 	addi	fp,fp,-16
 1840848:	42000204 	addi	r8,r8,8
 184084c:	4f00150e 	bge	r9,fp,18408a4 <___svfiprintf_internal_r+0xd08>
 1840850:	18c00404 	addi	r3,r3,16
 1840854:	10800044 	addi	r2,r2,1
 1840858:	45000015 	stw	r20,0(r8)
 184085c:	42400115 	stw	r9,4(r8)
 1840860:	d8c01c15 	stw	r3,112(sp)
 1840864:	d8801b15 	stw	r2,108(sp)
 1840868:	50bff60e 	bge	r10,r2,1840844 <__ram_exceptions_end+0xff830400>
 184086c:	d9801a04 	addi	r6,sp,104
 1840870:	b80b883a 	mov	r5,r23
 1840874:	a809883a 	mov	r4,r21
 1840878:	da402c15 	stw	r9,176(sp)
 184087c:	da802d15 	stw	r10,180(sp)
 1840880:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840884:	da402c17 	ldw	r9,176(sp)
 1840888:	da802d17 	ldw	r10,180(sp)
 184088c:	103fd11e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 1840890:	e73ffc04 	addi	fp,fp,-16
 1840894:	d8c01c17 	ldw	r3,112(sp)
 1840898:	d8801b17 	ldw	r2,108(sp)
 184089c:	d811883a 	mov	r8,sp
 18408a0:	4f3feb16 	blt	r9,fp,1840850 <__ram_exceptions_end+0xff83040c>
 18408a4:	dac02217 	ldw	r11,136(sp)
 18408a8:	1f07883a 	add	r3,r3,fp
 18408ac:	10800044 	addi	r2,r2,1
 18408b0:	42c00015 	stw	r11,0(r8)
 18408b4:	47000115 	stw	fp,4(r8)
 18408b8:	d8c01c15 	stw	r3,112(sp)
 18408bc:	d8801b15 	stw	r2,108(sp)
 18408c0:	010001c4 	movi	r4,7
 18408c4:	2080b616 	blt	r4,r2,1840ba0 <___svfiprintf_internal_r+0x1004>
 18408c8:	42000204 	addi	r8,r8,8
 18408cc:	003f4e06 	br	1840608 <__ram_exceptions_end+0xff8301c4>
 18408d0:	d9801a04 	addi	r6,sp,104
 18408d4:	b80b883a 	mov	r5,r23
 18408d8:	a809883a 	mov	r4,r21
 18408dc:	183f9cc0 	call	183f9cc <__ssprint_r>
 18408e0:	103fbc1e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 18408e4:	d8c01c17 	ldw	r3,112(sp)
 18408e8:	d811883a 	mov	r8,sp
 18408ec:	003f7a06 	br	18406d8 <__ram_exceptions_end+0xff830294>
 18408f0:	d9801a04 	addi	r6,sp,104
 18408f4:	b80b883a 	mov	r5,r23
 18408f8:	a809883a 	mov	r4,r21
 18408fc:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840900:	103fa826 	beq	r2,zero,18407a4 <__ram_exceptions_end+0xff830360>
 1840904:	003fb306 	br	18407d4 <__ram_exceptions_end+0xff830390>
 1840908:	d9801a04 	addi	r6,sp,104
 184090c:	b80b883a 	mov	r5,r23
 1840910:	a809883a 	mov	r4,r21
 1840914:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840918:	103fae1e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 184091c:	d811883a 	mov	r8,sp
 1840920:	003cdc06 	br	183fc94 <__ram_exceptions_end+0xff82f850>
 1840924:	d9801a04 	addi	r6,sp,104
 1840928:	b80b883a 	mov	r5,r23
 184092c:	a809883a 	mov	r4,r21
 1840930:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840934:	103fa71e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 1840938:	d8c01c17 	ldw	r3,112(sp)
 184093c:	d8801b17 	ldw	r2,108(sp)
 1840940:	d811883a 	mov	r8,sp
 1840944:	003f5a06 	br	18406b0 <__ram_exceptions_end+0xff83026c>
 1840948:	d9801a04 	addi	r6,sp,104
 184094c:	b80b883a 	mov	r5,r23
 1840950:	a809883a 	mov	r4,r21
 1840954:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840958:	103f9e1e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 184095c:	d8c01c17 	ldw	r3,112(sp)
 1840960:	d8801b17 	ldw	r2,108(sp)
 1840964:	d811883a 	mov	r8,sp
 1840968:	003f1706 	br	18405c8 <__ram_exceptions_end+0xff830184>
 184096c:	d9801a04 	addi	r6,sp,104
 1840970:	b80b883a 	mov	r5,r23
 1840974:	a809883a 	mov	r4,r21
 1840978:	183f9cc0 	call	183f9cc <__ssprint_r>
 184097c:	103f951e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 1840980:	d8c01c17 	ldw	r3,112(sp)
 1840984:	d8801b17 	ldw	r2,108(sp)
 1840988:	d811883a 	mov	r8,sp
 184098c:	003f1b06 	br	18405fc <__ram_exceptions_end+0xff8301b8>
 1840990:	d8001d85 	stb	zero,118(sp)
 1840994:	80007b16 	blt	r16,zero,1840b84 <___svfiprintf_internal_r+0xfe8>
 1840998:	00ffdfc4 	movi	r3,-129
 184099c:	e244b03a 	or	r2,fp,r9
 18409a0:	90e4703a 	and	r18,r18,r3
 18409a4:	103d7026 	beq	r2,zero,183ff68 <__ram_exceptions_end+0xff82fb24>
 18409a8:	0015883a 	mov	r10,zero
 18409ac:	003d7206 	br	183ff78 <__ram_exceptions_end+0xff82fb34>
 18409b0:	d9801a04 	addi	r6,sp,104
 18409b4:	b80b883a 	mov	r5,r23
 18409b8:	a809883a 	mov	r4,r21
 18409bc:	183f9cc0 	call	183f9cc <__ssprint_r>
 18409c0:	103f841e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 18409c4:	d8c01c17 	ldw	r3,112(sp)
 18409c8:	d8801b17 	ldw	r2,108(sp)
 18409cc:	d811883a 	mov	r8,sp
 18409d0:	003ef006 	br	1840594 <__ram_exceptions_end+0xff830150>
 18409d4:	9080100c 	andi	r2,r18,64
 18409d8:	d8001d85 	stb	zero,118(sp)
 18409dc:	dac02317 	ldw	r11,140(sp)
 18409e0:	10008126 	beq	r2,zero,1840be8 <___svfiprintf_internal_r+0x104c>
 18409e4:	58800104 	addi	r2,r11,4
 18409e8:	5f00000b 	ldhu	fp,0(r11)
 18409ec:	0013883a 	mov	r9,zero
 18409f0:	803ec30e 	bge	r16,zero,1840500 <__ram_exceptions_end+0xff8300bc>
 18409f4:	d8802315 	stw	r2,140(sp)
 18409f8:	0015883a 	mov	r10,zero
 18409fc:	e244b03a 	or	r2,fp,r9
 1840a00:	103e371e 	bne	r2,zero,18402e0 <__ram_exceptions_end+0xff82fe9c>
 1840a04:	00800044 	movi	r2,1
 1840a08:	10803fcc 	andi	r2,r2,255
 1840a0c:	00c00044 	movi	r3,1
 1840a10:	10c06126 	beq	r2,r3,1840b98 <___svfiprintf_internal_r+0xffc>
 1840a14:	00c00084 	movi	r3,2
 1840a18:	10fd5526 	beq	r2,r3,183ff70 <__ram_exceptions_end+0xff82fb2c>
 1840a1c:	003ed806 	br	1840580 <__ram_exceptions_end+0xff83013c>
 1840a20:	d8802315 	stw	r2,140(sp)
 1840a24:	98c00007 	ldb	r3,0(r19)
 1840a28:	003cab06 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 1840a2c:	d9801a04 	addi	r6,sp,104
 1840a30:	b80b883a 	mov	r5,r23
 1840a34:	a809883a 	mov	r4,r21
 1840a38:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840a3c:	103f651e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 1840a40:	d8c01c17 	ldw	r3,112(sp)
 1840a44:	003f4f06 	br	1840784 <__ram_exceptions_end+0xff830340>
 1840a48:	00806134 	movhi	r2,388
 1840a4c:	1084e604 	addi	r2,r2,5016
 1840a50:	d8802915 	stw	r2,164(sp)
 1840a54:	003d4406 	br	183ff68 <__ram_exceptions_end+0xff82fb24>
 1840a58:	dac02317 	ldw	r11,140(sp)
 1840a5c:	58800017 	ldw	r2,0(r11)
 1840a60:	dac02517 	ldw	r11,148(sp)
 1840a64:	5807d7fa 	srai	r3,r11,31
 1840a68:	dac02317 	ldw	r11,140(sp)
 1840a6c:	10c00115 	stw	r3,4(r2)
 1840a70:	5ac00104 	addi	r11,r11,4
 1840a74:	dac02315 	stw	r11,140(sp)
 1840a78:	dac02517 	ldw	r11,148(sp)
 1840a7c:	12c00015 	stw	r11,0(r2)
 1840a80:	003c6d06 	br	183fc38 <__ram_exceptions_end+0xff82f7f4>
 1840a84:	9080100c 	andi	r2,r18,64
 1840a88:	dac02317 	ldw	r11,140(sp)
 1840a8c:	103e5326 	beq	r2,zero,18403dc <__ram_exceptions_end+0xff82ff98>
 1840a90:	5f00000f 	ldh	fp,0(r11)
 1840a94:	5ac00104 	addi	r11,r11,4
 1840a98:	dac02315 	stw	r11,140(sp)
 1840a9c:	e013d7fa 	srai	r9,fp,31
 1840aa0:	4805883a 	mov	r2,r9
 1840aa4:	003e0706 	br	18402c4 <__ram_exceptions_end+0xff82fe80>
 1840aa8:	00800c04 	movi	r2,48
 1840aac:	d8801d05 	stb	r2,116(sp)
 1840ab0:	d8c01d45 	stb	r3,117(sp)
 1840ab4:	d8001d85 	stb	zero,118(sp)
 1840ab8:	90800094 	ori	r2,r18,2
 1840abc:	80008f16 	blt	r16,zero,1840cfc <___svfiprintf_internal_r+0x1160>
 1840ac0:	00bfdfc4 	movi	r2,-129
 1840ac4:	90a4703a 	and	r18,r18,r2
 1840ac8:	94800094 	ori	r18,r18,2
 1840acc:	0015883a 	mov	r10,zero
 1840ad0:	003d2906 	br	183ff78 <__ram_exceptions_end+0xff82fb34>
 1840ad4:	98c00007 	ldb	r3,0(r19)
 1840ad8:	003c7f06 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 1840adc:	dac02317 	ldw	r11,140(sp)
 1840ae0:	0013883a 	mov	r9,zero
 1840ae4:	5f000017 	ldw	fp,0(r11)
 1840ae8:	5ac00104 	addi	r11,r11,4
 1840aec:	dac02315 	stw	r11,140(sp)
 1840af0:	003d1506 	br	183ff48 <__ram_exceptions_end+0xff82fb04>
 1840af4:	9080100c 	andi	r2,r18,64
 1840af8:	d8001d85 	stb	zero,118(sp)
 1840afc:	dac02317 	ldw	r11,140(sp)
 1840b00:	10003426 	beq	r2,zero,1840bd4 <___svfiprintf_internal_r+0x1038>
 1840b04:	58800104 	addi	r2,r11,4
 1840b08:	5f00000b 	ldhu	fp,0(r11)
 1840b0c:	0013883a 	mov	r9,zero
 1840b10:	803e950e 	bge	r16,zero,1840568 <__ram_exceptions_end+0xff830124>
 1840b14:	e246b03a 	or	r3,fp,r9
 1840b18:	d8802315 	stw	r2,140(sp)
 1840b1c:	183d5a1e 	bne	r3,zero,1840088 <__ram_exceptions_end+0xff82fc44>
 1840b20:	0015883a 	mov	r10,zero
 1840b24:	0005883a 	mov	r2,zero
 1840b28:	003fb706 	br	1840a08 <__ram_exceptions_end+0xff8305c4>
 1840b2c:	98c00043 	ldbu	r3,1(r19)
 1840b30:	94800814 	ori	r18,r18,32
 1840b34:	9cc00044 	addi	r19,r19,1
 1840b38:	18c03fcc 	andi	r3,r3,255
 1840b3c:	18c0201c 	xori	r3,r3,128
 1840b40:	18ffe004 	addi	r3,r3,-128
 1840b44:	003c6406 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 1840b48:	d8c02315 	stw	r3,140(sp)
 1840b4c:	0015883a 	mov	r10,zero
 1840b50:	003faa06 	br	18409fc <__ram_exceptions_end+0xff8305b8>
 1840b54:	dac02317 	ldw	r11,140(sp)
 1840b58:	58800017 	ldw	r2,0(r11)
 1840b5c:	5ac00104 	addi	r11,r11,4
 1840b60:	dac02315 	stw	r11,140(sp)
 1840b64:	dac02517 	ldw	r11,148(sp)
 1840b68:	12c00015 	stw	r11,0(r2)
 1840b6c:	003c3206 	br	183fc38 <__ram_exceptions_end+0xff82f7f4>
 1840b70:	01006134 	movhi	r4,388
 1840b74:	2104e604 	addi	r4,r4,5016
 1840b78:	d9002915 	stw	r4,164(sp)
 1840b7c:	d8c02315 	stw	r3,140(sp)
 1840b80:	1025883a 	mov	r18,r2
 1840b84:	e244b03a 	or	r2,fp,r9
 1840b88:	103f871e 	bne	r2,zero,18409a8 <__ram_exceptions_end+0xff830564>
 1840b8c:	0015883a 	mov	r10,zero
 1840b90:	00800084 	movi	r2,2
 1840b94:	003f9c06 	br	1840a08 <__ram_exceptions_end+0xff8305c4>
 1840b98:	0039883a 	mov	fp,zero
 1840b9c:	003e5f06 	br	184051c <__ram_exceptions_end+0xff8300d8>
 1840ba0:	d9801a04 	addi	r6,sp,104
 1840ba4:	b80b883a 	mov	r5,r23
 1840ba8:	a809883a 	mov	r4,r21
 1840bac:	183f9cc0 	call	183f9cc <__ssprint_r>
 1840bb0:	103f081e 	bne	r2,zero,18407d4 <__ram_exceptions_end+0xff830390>
 1840bb4:	d8c01c17 	ldw	r3,112(sp)
 1840bb8:	d8801b17 	ldw	r2,108(sp)
 1840bbc:	d811883a 	mov	r8,sp
 1840bc0:	003e9106 	br	1840608 <__ram_exceptions_end+0xff8301c4>
 1840bc4:	01006134 	movhi	r4,388
 1840bc8:	210fc404 	addi	r4,r4,16144
 1840bcc:	d9002215 	stw	r4,136(sp)
 1840bd0:	003ead06 	br	1840688 <__ram_exceptions_end+0xff830244>
 1840bd4:	58800104 	addi	r2,r11,4
 1840bd8:	5f000017 	ldw	fp,0(r11)
 1840bdc:	0013883a 	mov	r9,zero
 1840be0:	803e610e 	bge	r16,zero,1840568 <__ram_exceptions_end+0xff830124>
 1840be4:	003fcb06 	br	1840b14 <__ram_exceptions_end+0xff8306d0>
 1840be8:	58800104 	addi	r2,r11,4
 1840bec:	5f000017 	ldw	fp,0(r11)
 1840bf0:	0013883a 	mov	r9,zero
 1840bf4:	803e420e 	bge	r16,zero,1840500 <__ram_exceptions_end+0xff8300bc>
 1840bf8:	003f7e06 	br	18409f4 <__ram_exceptions_end+0xff8305b0>
 1840bfc:	5f000017 	ldw	fp,0(r11)
 1840c00:	5ac00104 	addi	r11,r11,4
 1840c04:	0013883a 	mov	r9,zero
 1840c08:	dac02315 	stw	r11,140(sp)
 1840c0c:	003cce06 	br	183ff48 <__ram_exceptions_end+0xff82fb04>
 1840c10:	8809883a 	mov	r4,r17
 1840c14:	da002c15 	stw	r8,176(sp)
 1840c18:	18075d80 	call	18075d8 <strlen>
 1840c1c:	d8802115 	stw	r2,132(sp)
 1840c20:	da801d83 	ldbu	r10,118(sp)
 1840c24:	df002315 	stw	fp,140(sp)
 1840c28:	0021883a 	mov	r16,zero
 1840c2c:	da002c17 	ldw	r8,176(sp)
 1840c30:	003cf606 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840c34:	00800184 	movi	r2,6
 1840c38:	1400012e 	bgeu	r2,r16,1840c40 <___svfiprintf_internal_r+0x10a4>
 1840c3c:	1021883a 	mov	r16,r2
 1840c40:	dc002115 	stw	r16,132(sp)
 1840c44:	8005883a 	mov	r2,r16
 1840c48:	80003c16 	blt	r16,zero,1840d3c <___svfiprintf_internal_r+0x11a0>
 1840c4c:	04406134 	movhi	r17,388
 1840c50:	d8802015 	stw	r2,128(sp)
 1840c54:	df002315 	stw	fp,140(sp)
 1840c58:	8c44eb04 	addi	r17,r17,5036
 1840c5c:	003d2e06 	br	1840118 <__ram_exceptions_end+0xff82fcd4>
 1840c60:	04001004 	movi	r16,64
 1840c64:	800b883a 	mov	r5,r16
 1840c68:	180579c0 	call	180579c <_malloc_r>
 1840c6c:	dac02717 	ldw	r11,156(sp)
 1840c70:	58800015 	stw	r2,0(r11)
 1840c74:	58800415 	stw	r2,16(r11)
 1840c78:	10004826 	beq	r2,zero,1840d9c <___svfiprintf_internal_r+0x1200>
 1840c7c:	dac02717 	ldw	r11,156(sp)
 1840c80:	5c000515 	stw	r16,20(r11)
 1840c84:	003bd906 	br	183fbec <__ram_exceptions_end+0xff82f7a8>
 1840c88:	9080004c 	andi	r2,r18,1
 1840c8c:	0015883a 	mov	r10,zero
 1840c90:	10000626 	beq	r2,zero,1840cac <___svfiprintf_internal_r+0x1110>
 1840c94:	dac02b17 	ldw	r11,172(sp)
 1840c98:	00800c04 	movi	r2,48
 1840c9c:	d88019c5 	stb	r2,103(sp)
 1840ca0:	dac02115 	stw	r11,132(sp)
 1840ca4:	dc4019c4 	addi	r17,sp,103
 1840ca8:	003cd806 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840cac:	d8002115 	stw	zero,132(sp)
 1840cb0:	dc401a04 	addi	r17,sp,104
 1840cb4:	003cd506 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840cb8:	01006134 	movhi	r4,388
 1840cbc:	210fc804 	addi	r4,r4,16160
 1840cc0:	d9002815 	stw	r4,160(sp)
 1840cc4:	003d4306 	br	18401d4 <__ram_exceptions_end+0xff82fd90>
 1840cc8:	00bfffc4 	movi	r2,-1
 1840ccc:	003ec606 	br	18407e8 <__ram_exceptions_end+0xff8303a4>
 1840cd0:	00800044 	movi	r2,1
 1840cd4:	10803fcc 	andi	r2,r2,255
 1840cd8:	00c00044 	movi	r3,1
 1840cdc:	10fd8026 	beq	r2,r3,18402e0 <__ram_exceptions_end+0xff82fe9c>
 1840ce0:	00c00084 	movi	r3,2
 1840ce4:	10fca426 	beq	r2,r3,183ff78 <__ram_exceptions_end+0xff82fb34>
 1840ce8:	003ce806 	br	184008c <__ram_exceptions_end+0xff82fc48>
 1840cec:	01006134 	movhi	r4,388
 1840cf0:	210fc804 	addi	r4,r4,16160
 1840cf4:	d9002815 	stw	r4,160(sp)
 1840cf8:	003e9906 	br	1840760 <__ram_exceptions_end+0xff83031c>
 1840cfc:	1025883a 	mov	r18,r2
 1840d00:	0015883a 	mov	r10,zero
 1840d04:	00800084 	movi	r2,2
 1840d08:	003ff206 	br	1840cd4 <__ram_exceptions_end+0xff830890>
 1840d0c:	01406134 	movhi	r5,388
 1840d10:	294fc404 	addi	r5,r5,16144
 1840d14:	d9402215 	stw	r5,136(sp)
 1840d18:	003ee206 	br	18408a4 <__ram_exceptions_end+0xff830460>
 1840d1c:	5827883a 	mov	r19,r11
 1840d20:	0021883a 	mov	r16,zero
 1840d24:	003bed06 	br	183fcdc <__ram_exceptions_end+0xff82f898>
 1840d28:	dc002115 	stw	r16,132(sp)
 1840d2c:	da801d83 	ldbu	r10,118(sp)
 1840d30:	df002315 	stw	fp,140(sp)
 1840d34:	0021883a 	mov	r16,zero
 1840d38:	003cb406 	br	184000c <__ram_exceptions_end+0xff82fbc8>
 1840d3c:	0005883a 	mov	r2,zero
 1840d40:	003fc206 	br	1840c4c <__ram_exceptions_end+0xff830808>
 1840d44:	d8802317 	ldw	r2,140(sp)
 1840d48:	98c00043 	ldbu	r3,1(r19)
 1840d4c:	5827883a 	mov	r19,r11
 1840d50:	14000017 	ldw	r16,0(r2)
 1840d54:	10800104 	addi	r2,r2,4
 1840d58:	d8802315 	stw	r2,140(sp)
 1840d5c:	803f760e 	bge	r16,zero,1840b38 <__ram_exceptions_end+0xff8306f4>
 1840d60:	18c03fcc 	andi	r3,r3,255
 1840d64:	18c0201c 	xori	r3,r3,128
 1840d68:	043fffc4 	movi	r16,-1
 1840d6c:	18ffe004 	addi	r3,r3,-128
 1840d70:	003bd906 	br	183fcd8 <__ram_exceptions_end+0xff82f894>
 1840d74:	d9c01d85 	stb	r7,118(sp)
 1840d78:	003cb606 	br	1840054 <__ram_exceptions_end+0xff82fc10>
 1840d7c:	d9c01d85 	stb	r7,118(sp)
 1840d80:	003d2106 	br	1840208 <__ram_exceptions_end+0xff82fdc4>
 1840d84:	d9c01d85 	stb	r7,118(sp)
 1840d88:	003d8e06 	br	18403c4 <__ram_exceptions_end+0xff82ff80>
 1840d8c:	d9c01d85 	stb	r7,118(sp)
 1840d90:	003db306 	br	1840460 <__ram_exceptions_end+0xff83001c>
 1840d94:	d9c01d85 	stb	r7,118(sp)
 1840d98:	003c8a06 	br	183ffc4 <__ram_exceptions_end+0xff82fb80>
 1840d9c:	dac02a17 	ldw	r11,168(sp)
 1840da0:	00800304 	movi	r2,12
 1840da4:	58800015 	stw	r2,0(r11)
 1840da8:	00bfffc4 	movi	r2,-1
 1840dac:	003e8e06 	br	18407e8 <__ram_exceptions_end+0xff8303a4>
 1840db0:	d9c01d85 	stb	r7,118(sp)
 1840db4:	003dc706 	br	18404d4 <__ram_exceptions_end+0xff830090>
 1840db8:	d9c01d85 	stb	r7,118(sp)
 1840dbc:	003ddf06 	br	184053c <__ram_exceptions_end+0xff8300f8>
 1840dc0:	d9c01d85 	stb	r7,118(sp)
 1840dc4:	003d3706 	br	18402a4 <__ram_exceptions_end+0xff82fe60>
 1840dc8:	d9c01d85 	stb	r7,118(sp)
 1840dcc:	003c5406 	br	183ff20 <__ram_exceptions_end+0xff82fadc>
 1840dd0:	d9c01d85 	stb	r7,118(sp)
 1840dd4:	003d1d06 	br	184024c <__ram_exceptions_end+0xff82fe08>

01840dd8 <__muldi3>:
 1840dd8:	223fffcc 	andi	r8,r4,65535
 1840ddc:	2006d43a 	srli	r3,r4,16
 1840de0:	32bfffcc 	andi	r10,r6,65535
 1840de4:	3012d43a 	srli	r9,r6,16
 1840de8:	4297383a 	mul	r11,r8,r10
 1840dec:	1a95383a 	mul	r10,r3,r10
 1840df0:	4251383a 	mul	r8,r8,r9
 1840df4:	5804d43a 	srli	r2,r11,16
 1840df8:	4291883a 	add	r8,r8,r10
 1840dfc:	1205883a 	add	r2,r2,r8
 1840e00:	1a51383a 	mul	r8,r3,r9
 1840e04:	1280022e 	bgeu	r2,r10,1840e10 <__muldi3+0x38>
 1840e08:	00c00074 	movhi	r3,1
 1840e0c:	40d1883a 	add	r8,r8,r3
 1840e10:	1006d43a 	srli	r3,r2,16
 1840e14:	21cf383a 	mul	r7,r4,r7
 1840e18:	314b383a 	mul	r5,r6,r5
 1840e1c:	1004943a 	slli	r2,r2,16
 1840e20:	1a11883a 	add	r8,r3,r8
 1840e24:	5affffcc 	andi	r11,r11,65535
 1840e28:	3947883a 	add	r3,r7,r5
 1840e2c:	12c5883a 	add	r2,r2,r11
 1840e30:	1a07883a 	add	r3,r3,r8
 1840e34:	f800283a 	ret

01840e38 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 1840e38:	defffd04 	addi	sp,sp,-12
 1840e3c:	df000215 	stw	fp,8(sp)
 1840e40:	df000204 	addi	fp,sp,8
 1840e44:	e13fff15 	stw	r4,-4(fp)
 1840e48:	e0bfff17 	ldw	r2,-4(fp)
 1840e4c:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 1840e50:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 1840e54:	10000226 	beq	r2,zero,1840e60 <_exit+0x28>
    ALT_SIM_FAIL();
 1840e58:	002af070 	cmpltui	zero,zero,43969
 1840e5c:	00000106 	br	1840e64 <_exit+0x2c>
  } else {
    ALT_SIM_PASS();
 1840e60:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 1840e64:	003fff06 	br	1840e64 <__ram_exceptions_end+0xff830a20>
