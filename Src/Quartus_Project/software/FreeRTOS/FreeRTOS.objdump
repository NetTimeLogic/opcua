
FreeRTOS.elf:     file format elf32-littlenios2
FreeRTOS.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x02000414

Program Header:
    LOAD off    0x00001000 vaddr 0x02000000 paddr 0x02000000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x00043ab0 memsz 0x00043ab0 flags r-x
    LOAD off    0x00044ad0 vaddr 0x02043ad0 paddr 0x02045968 align 2**12
         filesz 0x00001e98 memsz 0x00001e98 flags rw-
    LOAD off    0x00047800 vaddr 0x02047800 paddr 0x02047800 align 2**12
         filesz 0x00000000 memsz 0x00122ea4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  02000000  02000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   000003f4  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004060c  02000414  02000414  00001414  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000030b0  02040a20  02040a20  00041a20  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001e98  02043ad0  02045968  00044ad0  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00122f2a  02047800  02047800  00047800  2**2
                  ALLOC, SMALL_DATA
  6 .sdram_controller_0 00000000  0216a6a4  0216a6a4  00046968  2**0
                  CONTENTS
  7 .tse_descriptor_memory_0 00000000  04000000  04000000  00046968  2**0
                  CONTENTS
  8 .mem_0        00000000  05020000  05020000  00046968  2**0
                  CONTENTS
  9 .comment      00000023  00000000  00000000  00046968  2**0
                  CONTENTS, READONLY
 10 .debug_aranges 00001600  00000000  00000000  00046990  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_info   0004a3d5  00000000  00000000  00047f90  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000f500  00000000  00000000  00092365  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00017e7a  00000000  00000000  000a1865  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00008174  00000000  00000000  000b96e0  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    0000a8a5  00000000  00000000  000c1854  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_loc    0001cc6c  00000000  00000000  000cc0f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_alt_sim_info 00000050  00000000  00000000  000e8d68  2**2
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00001bb0  00000000  00000000  000e8db8  2**3
                  CONTENTS, READONLY, DEBUGGING
 19 .thread_model 00000008  00000000  00000000  000f3f76  2**0
                  CONTENTS, READONLY
 20 .cpu          00000005  00000000  00000000  000f3f7e  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  000f3f83  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  000f3f84  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000006  00000000  00000000  000f3f85  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000006  00000000  00000000  000f3f8b  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000006  00000000  00000000  000f3f91  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000004  00000000  00000000  000f3f97  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000001c  00000000  00000000  000f3f9b  2**0
                  CONTENTS, READONLY
 28 .jdi          0000495a  00000000  00000000  000f3fb7  2**0
                  CONTENTS, READONLY
 29 .sopcinfo     0009cd38  00000000  00000000  000f8911  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
02000000 l    d  .entry	00000000 .entry
02000020 l    d  .exceptions	00000000 .exceptions
02000414 l    d  .text	00000000 .text
02040a20 l    d  .rodata	00000000 .rodata
02043ad0 l    d  .rwdata	00000000 .rwdata
02047800 l    d  .bss	00000000 .bss
0216a6a4 l    d  .sdram_controller_0	00000000 .sdram_controller_0
04000000 l    d  .tse_descriptor_memory_0	00000000 .tse_descriptor_memory_0
05020000 l    d  .mem_0	00000000 .mem_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../FreeRTOS_bsp//obj/HAL/src/crt0.o
0200044c l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 port_asm.o
02000020 l       .exceptions	00000000 save_context
0200009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
020000ac l       .exceptions	00000000 hw_irq_test
0200031c l       .exceptions	00000000 soft_exceptions
020000c0 l       .exceptions	00000000 hw_irq_handler
020000d4 l       .exceptions	00000000 restore_context
02000338 l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 main.c
02047800 l     O .bss	00000004 nw_ready
02047804 l     O .bss	00000004 main_thread_handle
020004a8 l     F .text	000000b0 StatusCallback
02000558 l     F .text	00000044 LinkCallback
020005e4 l     F .text	000001cc WaitOnPHY
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 vfprintf.c
02040f56 l     O .rodata	00000010 zeroes.4404
02002e00 l     F .text	000000bc __sbprintf
02040f66 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
02003010 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
02004b40 l     F .text	00000008 __fp_unlock
02004b54 l     F .text	0000019c __sinit.part.1
02004cf0 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
02043ad0 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 locale.c
02043f14 l     O .rwdata	00000020 lc_ctype_charset
02043ef4 l     O .rwdata	00000020 lc_message_charset
02043f34 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mprec.c
02040f98 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
02007608 l     F .text	000000fc __sprint_r.part.0
020410cc l     O .rodata	00000010 blanks.4348
020410bc l     O .rodata	00000010 zeroes.4349
02008b94 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 queue.c
0200d744 l     F .text	00000090 prvInitialiseNewQueue
0200d7d4 l     F .text	00000060 prvInitialiseMutex
0200e73c l     F .text	0000018c prvCopyDataToQueue
0200eb20 l     F .text	00000068 prvIsQueueFull
0200e964 l     F .text	00000114 prvUnlockQueue
0200e8c8 l     F .text	0000009c prvCopyDataFromQueue
0200ea78 l     F .text	00000060 prvIsQueueEmpty
0200e6ec l     F .text	00000050 prvGetDisinheritPriorityAfterTimeout
00000000 l    df *ABS*	00000000 tasks.c
0204799c l     O .bss	00000064 pxReadyTasksLists
02047a00 l     O .bss	00000014 xDelayedTaskList1
02047a14 l     O .bss	00000014 xDelayedTaskList2
02047840 l     O .bss	00000004 pxDelayedTaskList
02047844 l     O .bss	00000004 pxOverflowDelayedTaskList
02047a28 l     O .bss	00000014 xPendingReadyList
02047a3c l     O .bss	00000014 xTasksWaitingTermination
02047848 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
02047a50 l     O .bss	00000014 xSuspendedTaskList
0204784c l     O .bss	00000004 uxCurrentNumberOfTasks
02047850 l     O .bss	00000004 xTickCount
02047854 l     O .bss	00000004 uxTopReadyPriority
02047858 l     O .bss	00000004 xSchedulerRunning
0204785c l     O .bss	00000004 xPendedTicks
02047860 l     O .bss	00000004 xYieldPending
02047864 l     O .bss	00000004 xNumOfOverflows
02047868 l     O .bss	00000004 uxTaskNumber
0204786c l     O .bss	00000004 xNextTaskUnblockTime
02047870 l     O .bss	00000004 xIdleTaskHandle
02047874 l     O .bss	00000004 uxSchedulerSuspended
0200ed80 l     F .text	000001e4 prvInitialiseNewTask
0200ef64 l     F .text	00000118 prvAddNewTaskToReadyList
02010620 l     F .text	000000b8 prvInitialiseTaskLists
02010aa8 l     F .text	00000044 prvDeleteTCB
02010aec l     F .text	00000054 prvResetNextTaskUnblockTime
02011804 l     F .text	000000e8 prvAddCurrentTaskToDelayedList
0200f764 l     F .text	0000006c prvTaskIsTaskSuspended
02010604 l     F .text	0000001c prvIdleTask
020108c0 l     F .text	00000128 prvListTasksWithinSingleList
020106d8 l     F .text	00000090 prvCheckTasksWaitingTermination
020109e8 l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 timers.c
02047a64 l     O .bss	00000014 xActiveTimerList1
02047a78 l     O .bss	00000014 xActiveTimerList2
02047878 l     O .bss	00000004 pxCurrentTimerList
0204787c l     O .bss	00000004 pxOverflowTimerList
02047880 l     O .bss	00000004 xTimerQueue
02047884 l     O .bss	00000004 xTimerTaskHandle
020123b4 l     F .text	0000008c prvCheckForValidListAndQueue
02011ddc l     F .text	0000003c prvTimerTask
020119cc l     F .text	000000a4 prvInitialiseNewTimer
02011d04 l     F .text	000000d8 prvProcessExpiredTimer
02011fac l     F .text	000000dc prvInsertTimerInActiveList
02011ee0 l     F .text	00000068 prvGetNextExpireTime
02011e18 l     F .text	000000c8 prvProcessTimerOrBlockTask
02012088 l     F .text	00000218 prvProcessReceivedCommands
02011f48 l     F .text	00000064 prvSampleTimeNow
02047888 l     O .bss	00000004 xLastTime.2917
020122a0 l     F .text	00000114 prvSwitchTimerLists
00000000 l    df *ABS*	00000000 alt_dev.c
020125c0 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_fstat.c
020126ac l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_io_redirect.c
02012798 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_isatty.c
020128d8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_load.c
020129b8 l     F .text	00000068 alt_load_section
00000000 l    df *ABS*	00000000 alt_lseek.c
02012aa4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_open.c
02012bb4 l     F .text	0000003c alt_get_errno
02012bf0 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0204591c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_lwip_close.c
00000000 l    df *ABS*	00000000 alt_lwip_read.c
00000000 l    df *ABS*	00000000 alt_lwip_write.c
00000000 l    df *ABS*	00000000 altera_tse_ethernetif.c
0201329c l     F .text	00000074 low_level_init
02013310 l     F .text	00000154 low_level_input
00000000 l    df *ABS*	00000000 lwip_main.c
02047890 l     O .bss	00000004 status_callback
02047894 l     O .bss	00000004 link_callback
020138b0 l     F .text	0000025c lwip_handle_interfaces
02013ea4 l     F .text	00000040 lwip_status_callback
02013d1c l     F .text	000000d0 lwip_handle_ethernet_input
02013c68 l     F .text	000000b4 lwip_check_link_status
00000000 l    df *ABS*	00000000 lwip_tse_mac.c
00000000 l    df *ABS*	00000000 sys_arch.c
00000000 l    df *ABS*	00000000 dhcp.c
020155dc l     F .text	00000058 dhcp_clear_assignment
02015634 l     F .text	00000054 dhcp_handle_nak
02017248 l     F .text	0000005c dhcp_set_state
0201675c l     F .text	000001a0 dhcp_discover
02015688 l     F .text	000000a0 dhcp_check
02015728 l     F .text	000000ec dhcp_handle_offer
02015814 l     F .text	00000260 dhcp_select
02018220 l     F .text	00000584 dhcp_create_msg
020172a4 l     F .text	0000009c dhcp_option
020173a0 l     F .text	00000098 dhcp_option_short
02017438 l     F .text	0000010c dhcp_option_long
02017340 l     F .text	00000060 dhcp_option_byte
02017544 l     F .text	000000dc dhcp_option_hostname
02018828 l     F .text	000000fc dhcp_option_trailer
020187a4 l     F .text	00000084 dhcp_delete_msg
02015de8 l     F .text	0000007c dhcp_t2_timeout
02015d6c l     F .text	0000007c dhcp_t1_timeout
02015bd4 l     F .text	00000198 dhcp_timeout
020168fc l     F .text	0000028c dhcp_bind
02016cec l     F .text	0000015c dhcp_rebind
02016e48 l     F .text	000001a4 dhcp_reboot
02015e64 l     F .text	00000218 dhcp_handle_ack
02017ec8 l     F .text	00000358 dhcp_recv
020165f8 l     F .text	00000164 dhcp_decline
02017620 l     F .text	000008a8 dhcp_parse_reply
02045920 l     O .rwdata	00000004 xid.3993
00000000 l    df *ABS*	00000000 ip_addr.c
02047a8c l     O .bss	00000010 str.3409
00000000 l    df *ABS*	00000000 mem.c
020478a8 l     O .bss	00000004 ram
020478ac l     O .bss	00000004 ram_end
020478b0 l     O .bss	00000004 lfree
020478b4 l     O .bss	00000004 mem_mutex
020190c0 l     F .text	00000128 plug_holes
00000000 l    df *ABS*	00000000 netif.c
020478b8 l     O .bss	00000001 netif_num
00000000 l    df *ABS*	00000000 pbuf.c
0201a25c l     F .text	00000088 pbuf_free_ooseq
0201a2e4 l     F .text	00000030 pbuf_free_ooseq_callback
0201a314 l     F .text	00000098 pbuf_pool_is_empty
00000000 l    df *ABS*	00000000 stats.c
00000000 l    df *ABS*	00000000 tcp.c
0204592c l     O .rwdata	00000002 tcp_port
020478c8 l     O .bss	00000001 tcp_timer
020478c9 l     O .bss	00000001 tcp_timer_ctr
0201b9bc l     F .text	0000034c tcp_close_shutdown
0201c5ec l     F .text	000000d8 tcp_new_port
0201c1bc l     F .text	00000030 tcp_accept_null
0201d5a8 l     F .text	000000d8 tcp_kill_prio
0201d680 l     F .text	00000094 tcp_kill_timewait
02045938 l     O .rwdata	00000004 iss.4104
00000000 l    df *ABS*	00000000 tcp_out.c
0201de00 l     F .text	000003e8 tcp_output_alloc_header
0201e330 l     F .text	000003a0 tcp_create_segment
0201e6d0 l     F .text	00000120 tcp_pbuf_prealloc
0201e7f0 l     F .text	000000b8 tcp_seg_add_chksum
0201e8a8 l     F .text	00000124 tcp_write_checks
0202022c l     F .text	00000600 tcp_output_segment
00000000 l    df *ABS*	00000000 timers.c
020478e4 l     O .bss	00000004 next_timeout
020478e8 l     O .bss	00000004 tcpip_tcp_timer_active
020214f8 l     F .text	0000005c tcpip_tcp_timer
020215b0 l     F .text	00000044 ip_reass_timer
020215f4 l     F .text	00000044 arp_timer
02021638 l     F .text	00000044 dhcp_timer_coarse
0202167c l     F .text	00000044 dhcp_timer_fine
00000000 l    df *ABS*	00000000 udp.c
0204593c l     O .rwdata	00000002 udp_port
02021adc l     F .text	0000009c udp_new_port
00000000 l    df *ABS*	00000000 etharp.c
02047a9c l     O .bss	000001f4 arp_table
02022b74 l     F .text	00000068 free_etharp_q
02022bdc l     F .text	0000009c etharp_free_entry
02022df4 l     F .text	00000318 etharp_find_entry
0202310c l     F .text	000000a4 etharp_send_ip
020231b0 l     F .text	000001c8 etharp_update_arp_entry
020234dc l     F .text	000000e8 etharp_ip_input
020235c4 l     F .text	0000038c etharp_arp_input
02023950 l     F .text	0000010c etharp_output_to_arp_index
020240fc l     F .text	0000024c etharp_raw
00000000 l    df *ABS*	00000000 alt_sys_init.c
02024604 l     F .text	00000034 alt_dev_reg
0204451c l     O .rwdata	00001068 jtag_uart_0
02045584 l     O .rwdata	00000030 sgdma_tse_rx_0
020455b4 l     O .rwdata	00000030 sgdma_tse_tx_0
020455e4 l     O .rwdata	000000cc uart_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
020249c8 l     F .text	0000020c altera_avalon_jtag_uart_irq
02024bd4 l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
02025284 l     F .text	0000003c alt_get_errno
02025eb4 l     F .text	000000bc alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
02026018 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
020478f2 l     O .bss	00000001 tse_system_count.4134
020478f3 l     O .bss	00000001 is_init.4216
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
0202b354 l     F .text	0000009c altera_avalon_uart_irq
0202b3f0 l     F .text	000000e4 altera_avalon_uart_rxirq
0202b4d4 l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
0202b670 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
0202b8c4 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
00000000 l    df *ABS*	00000000 heap_3.c
02047c90 l     O .bss	00100000 ucHeap
020478f8 l     O .bss	00000004 xNextFreeByte
020478fc l     O .bss	00000004 pucAlignedHeap.2611
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
0202bf5c l     F .text	0000002c prvReadGp
02047900 l     O .bss	00000004 lastContext
0202c14c l     F .text	0000009c prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 tse_ethernet_phys.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0202c4d0 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0202c624 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_gettod.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
0202ce44 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0202d180 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 sockets.c
02147c90 l     O .bss	000003f0 sockets
02047920 l     O .bss	00000004 select_cb_list
02047924 l     O .bss	00000004 select_cb_ctr
02043508 l     O .rodata	00000040 err_to_errno_table
0202d2f8 l     F .text	00000078 get_socket
0202d370 l     F .text	00000080 tryget_socket
0202d3f0 l     F .text	000001a0 alloc_socket
0202d590 l     F .text	00000098 free_socket
0202f034 l     F .text	000003ac event_callback
0202e7d4 l     F .text	00000380 lwip_selscan
0202f554 l     F .text	00000114 lwip_getaddrname
0202f9b4 l     F .text	000003fc lwip_getsockopt_internal
02030044 l     F .text	00000338 lwip_setsockopt_internal
00000000 l    df *ABS*	00000000 tcpip.c
02047928 l     O .bss	00000004 tcpip_init_done
0204792c l     O .bss	00000004 tcpip_init_done_arg
02047930 l     O .bss	00000004 mbox
02030564 l     F .text	000001c0 tcpip_thread
02030b9c l     F .text	0000003c pbuf_free_int
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 icmp.c
02031328 l     F .text	000001e0 icmp_send_response
00000000 l    df *ABS*	00000000 inet_chksum.c
02031508 l     F .text	00000234 lwip_standard_chksum
00000000 l    df *ABS*	00000000 ip.c
02047934 l     O .bss	00000002 ip_id
00000000 l    df *ABS*	00000000 ip_frag.c
02047948 l     O .bss	00000004 reassdatagrams
0204794c l     O .bss	00000002 ip_reass_pbufcount
02032bb8 l     F .text	00000190 ip_reass_free_complete_datagram
02032fb4 l     F .text	00000068 ip_reass_dequeue_datagram
02032d48 l     F .text	00000190 ip_reass_remove_oldest_datagram
02032ed8 l     F .text	000000dc ip_reass_enqueue_new_datagram
0203301c l     F .text	00000700 ip_reass_chain_frag_into_datagram_and_validate
02033d28 l     F .text	0000002c ip_frag_alloc_pbuf_custom_ref
02033d54 l     F .text	00000038 ip_frag_free_pbuf_custom_ref
02033d8c l     F .text	00000058 ipfrag_free_pbuf_custom
00000000 l    df *ABS*	00000000 memp.c
02148080 l     O .bss	0000003c memp_tab
020435fc l     O .rodata	0000001e memp_sizes
0204361a l     O .rodata	0000001e memp_num
021480bc l     O .bss	0001a16f memp_memory
00000000 l    df *ABS*	00000000 raw.c
02047950 l     O .bss	00000004 raw_pcbs
00000000 l    df *ABS*	00000000 tcp_in.c
0216222c l     O .bss	00000014 inseg
02047954 l     O .bss	00000004 tcphdr
02047958 l     O .bss	00000004 iphdr
0204795c l     O .bss	00000004 seqno
02047960 l     O .bss	00000004 ackno
02047964 l     O .bss	00000001 flags
02047966 l     O .bss	00000002 tcplen
02047968 l     O .bss	00000001 recv_flags
0204796c l     O .bss	00000004 recv_data
02035d38 l     F .text	0000013c tcp_timewait_input
02035a50 l     F .text	000002e8 tcp_listen_input
02035e74 l     F .text	00000ab4 tcp_process
02038bbc l     F .text	00000228 tcp_parseopt
02036bc8 l     F .text	00001ff4 tcp_receive
02036928 l     F .text	000002a0 tcp_oos_insert_segment
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00000000 l    df *ABS*	00000000 api_lib.c
02039754 l     F .text	00000294 netconn_recv_data
02039f70 l     F .text	000000cc netconn_close_shutdown
00000000 l    df *ABS*	00000000 api_msg.c
0203a0dc l     F .text	00000170 recv_raw
0203a24c l     F .text	0000012c recv_udp
0203a378 l     F .text	00000140 recv_tcp
0203a4b8 l     F .text	000000fc poll_tcp
0203be88 l     F .text	0000030c do_writemore
0203af50 l     F .text	00000290 do_close_internal
0203a5b4 l     F .text	000000fc sent_tcp
0203a6b0 l     F .text	000001b4 err_tcp
0203a864 l     F .text	00000088 setup_tcp
0203a8ec l     F .text	00000168 accept_function
0203aa54 l     F .text	000001a4 pcb_new
0203add4 l     F .text	0000017c netconn_drain
0203b524 l     F .text	00000154 do_connected
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 vfprintf.c
02043a90 l     O .rodata	00000010 zeroes.4389
02043aa0 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 vfprintf.c
02043ac0 l     O .rodata	00000010 blanks.4332
02043ab0 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 alt_exit.c
0202d2d8 g     F .text	00000020 lwip_socket_init
0203b3b4 g     F .text	00000170 do_bind
02047938 g     O .bss	00000004 current_iphdr_src
02031b74 g     F .text	00000044 inet_chksum
02034814 g     F .text	00000048 raw_bind
02007118 g     F .text	00000074 _mprec_log10
0203371c g     F .text	0000060c ip_reass
02027384 g     F .text	000000d8 alt_tse_get_mac_info
0201a858 g     F .text	00000160 pbuf_realloc
02007204 g     F .text	0000008c __any_on
020095ec g     F .text	00000054 _isatty_r
02040fa4 g     O .rodata	00000028 __mprec_tinytens
0200d40c g     F .text	000000d8 alt_main
0203d084 g     F .text	00000090 strcpy
0201dd08 g     F .text	00000030 tcp_next_iss
0203cdf4 g     F .text	000000c0 _puts_r
0216a5a4 g     O .bss	00000100 alt_irq
0201c454 g     F .text	000000f0 tcp_update_rcv_ann_wnd
02009640 g     F .text	00000060 _lseek_r
020000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
02010144 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
0202bca0 g     F .text	0000002c xPortGetFreeHeapSize
020478bc g     O .bss	00000004 netif_list
020160c8 g     F .text	00000050 dhcp_cleanup
0202af80 g     F .text	000000f0 marvell_cfg_rgmii
02045968 g       *ABS*	00000000 __flash_rwdata_start
0202bfd8 g     F .text	0000003c enh_alt_irq_enable_all
02013dec g     F .text	000000b8 print_ipad
0200bef8 g     F .text	00000088 .hidden __eqdf2
0202082c g     F .text	000003cc tcp_rst
0201b7c4 g     F .text	000000c8 pbuf_memfind
02028574 g     F .text	00000210 alt_tse_phy_print_profile
0216a6a4 g       *ABS*	00000000 __alt_heap_start
0202ad20 g     F .text	00000098 marvell_phy_cfg
0200f3e0 g     F .text	00000068 uxTaskPriorityGet
02011954 g     F .text	00000078 xTimerCreate
02024348 g     F .text	00000074 etharp_request
0202214c g     F .text	00000074 udp_send_chksum
0203ad84 g     F .text	00000050 netconn_free
02000bb0 g     F .text	0000003c printf
02016118 g     F .text	000001ec dhcp_start
020253e4 g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
02009f18 g     F .text	0000009c _wcrtomb_r
0201d9dc g     F .text	00000034 tcp_err
02045924 g     O .rwdata	00000004 ip_addr_any
0203173c g     F .text	00000200 inet_chksum_pseudo
020164b0 g     F .text	000000a8 dhcp_network_changed
02007430 g     F .text	0000005c __sseek
02022a7c g     F .text	000000a0 udp_remove
02004e90 g     F .text	00000010 __sinit
02010768 g     F .text	00000158 vTaskGetInfo
02009dc0 g     F .text	00000140 __swbuf_r
0200ebd8 g     F .text	000000c8 vQueueWaitForMessageRestricted
02032348 g     F .text	0000064c ip_output_if
0200549c g     F .text	0000007c _setlocale_r
02004cf8 g     F .text	00000068 __sfmoreglue
02034600 g     F .text	000000e8 memp_free
0200d544 g     F .text	00000044 __malloc_unlock
02013bc0 g     F .text	00000034 lwip_set_status_callback
0201ab68 g     F .text	00000144 pbuf_free
0201d974 g     F .text	00000034 tcp_recv
0203b1e0 g     F .text	000001d4 do_delconn
020275c8 g     F .text	00000a7c getPHYSpeed
0201ad5c g     F .text	000000d4 pbuf_cat
02000940 g     F .text	000000b8 get_ip_addr
02025afc g     F .text	000003b8 alt_avalon_sgdma_construct_descriptor_burst
0202dd98 g     F .text	000004d8 lwip_recvfrom
020096a0 g     F .text	0000015c memmove
02032994 g     F .text	000000b4 ip_output
02023378 g     F .text	000000a4 etharp_cleanup_netif
020221c0 g     F .text	00000058 udp_sendto
02010f30 g     F .text	00000048 vTaskEnterCritical
02013824 g     F .text	0000008c lwip_wait_for_an
02004e78 g     F .text	00000018 _cleanup
0203cfa0 g     F .text	000000e4 snprintf
0200dbf8 g     F .text	000000f4 xQueueGenericSendFromISR
0200fc58 g     F .text	00000040 pcTaskGetName
02006294 g     F .text	000000a8 _Balloc
02018ab4 g     F .text	00000044 ipaddr_addr
0202107c g     F .text	00000194 tcp_keepalive
02022c78 g     F .text	0000017c etharp_tmr
02029f84 g     F .text	000001c4 alt_tse_phy_set_adv_1000
0203c624 g     F .text	00000074 netbuf_delete
02045954 g     O .rwdata	00000001 max_mac_system
0201d714 g     F .text	00000200 tcp_alloc
02026638 g     F .text	000009fc alt_tse_system_add_sys
0200bf80 g     F .text	000000dc .hidden __gtdf2
0202d2b4 g     F .text	00000024 altera_nios2_gen2_irq_init
0203c698 g     F .text	000000c8 netbuf_alloc
02030a3c g     F .text	00000070 tcpip_callbackmsg_new
020222d0 g     F .text	00000060 udp_sendto_if
02000000 g     F .entry	0000001c __reset
0200d890 g     F .text	00000090 xQueueGiveMutexRecursive
0203a070 g     F .text	0000006c netconn_shutdown
0201d940 g     F .text	00000034 tcp_arg
0204783c g     O .bss	00000004 pxCurrentTCB
020216c0 g     F .text	00000078 sys_timeouts_init
020478ca g     O .bss	00000001 tcp_active_pcbs_changed
02013c28  w    F .text	00000040 lwip_is_interface_up
020151b0 g     F .text	00000058 sys_mutex_free
020478cc g     O .bss	00000004 tcp_active_pcbs
0202564c g     F .text	00000078 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
0201a220 g     F .text	0000003c netif_set_link_callback
02000020 g       *ABS*	00000000 __flash_exceptions_start
020478ec g     O .bss	00000004 udp_pcbs
020090d4 g     F .text	0000005c _fstat_r
020456b0 g     O .rwdata	00000240 tse_mac_device
02047828 g     O .bss	00000004 errno
020243bc g     F .text	00000248 ethernet_input
0201bd64 g     F .text	000000f0 tcp_shutdown
020073ac g     F .text	00000008 __seofread
02039c04 g     F .text	00000080 netconn_recved
0203f754 g     F .text	0000123c ___svfiprintf_internal_r
0202a86c g     F .text	000004b4 alt_tse_phy_set_common_speed
0201acf8 g     F .text	00000064 pbuf_ref
0200d3cc  w    F .text	00000020 pre_constructors
0216a564 g     O .bss	00000020 pmac_groups
02019ef0 g     F .text	00000048 netif_set_netmask
02015398 g     F .text	00000060 sys_mbox_trypost
02047830 g     O .bss	00000004 alt_argv
0204d8f0 g       *ABS*	00000000 _gp
0201d52c g     F .text	0000007c tcp_recv_null
0202d150 g     F .text	00000030 usleep
0204793c g     O .bss	00000004 current_netif
0203a03c g     F .text	00000034 netconn_close
0201f2fc g     F .text	000002e8 tcp_enqueue_flags
0203c5b0 g     F .text	00000074 netbuf_new
0200f494 g     F .text	000001b4 vTaskPrioritySet
02047838 g     O .bss	00000004 alt_heapsem
02010424 g     F .text	0000003c vTaskInternalSetTimeOutState
0201bd08 g     F .text	0000005c tcp_close
0201c544 g     F .text	000000a8 tcp_recved
0202d120 g     F .text	00000030 alt_uncached_malloc
0201da8c g     F .text	00000170 tcp_pcb_purge
0202613c g     F .text	00000060 tse_mac_initTransInfo2
02013710 g     F .text	00000114 lwip_initialize
0204439c g     O .rwdata	00000180 alt_fd_list
020393d4 g     F .text	000000bc netconn_disconnect
02018ef0 g     F .text	0000003c ipaddr_ntoa
02000a30 g     F .text	00000048 get_iface_name
0204592e g     O .rwdata	00000007 tcp_persist_backoff
0202c0f4 g     F .text	00000038 xPortStartScheduler
0201177c g     F .text	00000088 ulTaskNotifyValueClear
0200fa1c g     F .text	00000034 vTaskEndScheduler
0202c704 g     F .text	00000090 alt_find_dev
02006024 g     F .text	00000148 memcpy
020192a0 g     F .text	0000010c mem_free
020263b0 g     F .text	00000054 tse_mac_setMIImode
020100f4 g     F .text	00000050 vTaskPlaceOnEventList
0201b4e8 g     F .text	0000010c pbuf_fill_chksum
02010300 g     F .text	000000c8 vTaskRemoveFromUnorderedEventList
020478d0 g     O .bss	00000004 tcp_ticks
020478d4 g     O .bss	00000004 tcp_listen_pcbs
02028044 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
02022330 g     F .text	00000454 udp_sendto_if_chksum
02020bf8 g     F .text	000000b4 tcp_rexmit_rto
02004b48 g     F .text	0000000c _cleanup_r
0200d1e4 g     F .text	000000dc .hidden __floatsidf
0202619c g     F .text	000000e4 tse_mac_sTxWrite
0201285c g     F .text	0000007c alt_io_redirect
0201d914 g     F .text	0000002c tcp_new
0200c05c g     F .text	000000f4 .hidden __ltdf2
0200e4c4 g     F .text	0000007c xQueuePeekFromISR
020229e8 g     F .text	00000050 udp_disconnect
0201b16c g     F .text	0000019c pbuf_copy_partial
02014d88 g     F .text	00000020 sys_init
02014f38 g     F .text	00000048 sys_sem_signal
02040a20 g       *ABS*	00000000 __DTOR_END__
0200d3ec  w    F .text	00000020 post_constructors
0202c50c g     F .text	000000d0 alt_close
02021738 g     F .text	0000017c sys_timeout
0203ceb4 g     F .text	00000014 puts
0202bc58 g     F .text	00000024 vPortFree
02011cd4 g     F .text	00000030 pcTimerGetName
02016fec g     F .text	000001a4 dhcp_release
02007290 g     F .text	00000074 __fpclassifyd
020416d4 g     O .rodata	0000002c tcp_state_str
02007074 g     F .text	000000a4 __ratio
02034a70 g     F .text	00000044 raw_send
02031bb8 g     F .text	0000010c inet_chksum_pbuf
02008b78 g     F .text	0000001c __vfiprintf_internal
0201b308 g     F .text	00000154 pbuf_take
0200dfa0 g     F .text	00000260 xQueueSemaphoreTake
02025744 g     F .text	0000008c alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0200e668 g     F .text	00000028 uxQueueGetQueueNumber
02024dcc g     F .text	00000258 altera_avalon_jtag_uart_read
0203cbe8 g     F .text	00000014 malloc
02000b80 g     F .text	00000030 _printf_r
02047940 g     O .bss	00000004 current_iphdr_dest
0200aca8 g     F .text	00000064 .hidden __udivsi3
02162284 g     O .bss	00000024 tse
02012914 g     F .text	000000a4 isatty
02027034 g     F .text	00000168 alt_tse_sys_enable_mdio_sharing
02030c9c g     F .text	000005fc icmp_input
02040ff4 g     O .rodata	000000c8 __mprec_tens
02027304 g     F .text	00000080 alt_tse_get_mac_info_index
02010a4c g     F .text	0000005c uxTaskGetStackHighWaterMark
02019a7c g     F .text	000000f0 netif_add
02005518 g     F .text	0000000c __locale_charset
02030ae4 g     F .text	00000044 tcpip_trycallback
02047904 g     O .bss	00000008 alt_timezone
0201505c g     F .text	000000c0 sys_mutex_new
0201d3dc g     F .text	00000054 tcp_segs_free
0202bd60 g     F .text	0000008c vListInsertEnd
02038f3c g     F .text	00000090 alt_icache_flush
0202e30c g     F .text	00000144 lwip_send
02047824 g     O .bss	00000004 __malloc_top_pad
0204788c g     O .bss	00000004 alt_fd_list_lock
02047808 g     O .bss	00000004 PingIp
020458f8 g     O .rwdata	00000004 __mb_cur_max
02005548 g     F .text	0000000c _localeconv_r
02030aac g     F .text	00000038 tcpip_callbackmsg_delete
02032a48 g     F .text	000000d0 ip_output_hinted
02019d80 g     F .text	00000128 netif_set_ipaddr
02009130 g     F .text	000004bc __sfvwrite_r
020066a0 g     F .text	0000003c __i2b
0202587c g     F .text	0000005c alt_avalon_sgdma_stop
020280e4 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
02007304 g     F .text	00000054 _sbrk_r
02028784 g     F .text	000006a4 alt_tse_mac_group_init
0201e9cc g     F .text	00000930 tcp_write
020140d4 g     F .text	0000084c tse_mac_init
0200f8ac g     F .text	000000e0 xTaskResumeFromISR
0202341c g     F .text	000000c0 etharp_find_addr
020153f8 g     F .text	00000100 sys_arch_mbox_fetch
0202f3e0 g     F .text	00000174 lwip_shutdown
02013b78 g     F .text	00000048 get_netif
020097fc g     F .text	00000060 _read_r
0202bd34 g     F .text	0000002c vListInitialiseItem
0202c5dc g     F .text	00000028 alt_dcache_flush
02045918 g     O .rwdata	00000004 alt_max_fd
0202c1e8 g     F .text	0000004c vPortSysTickHandler
02008dc8 g     F .text	000000f0 _fclose_r
0200ddc8 g     F .text	000001d8 xQueueReceive
0201bfec g     F .text	000001d0 tcp_bind
02004b10 g     F .text	00000030 fflush
02047820 g     O .bss	00000004 __malloc_max_sbrked_mem
020312e0 g     F .text	00000048 icmp_time_exceeded
0201bfb4 g     F .text	00000038 tcp_abort
0200f448 g     F .text	0000004c uxTaskPriorityGetFromISR
0203955c g     F .text	000001f8 netconn_accept
0202c234 g     F .text	00000170 alt_irq_register
02033de4 g     F .text	0000048c ip_frag
0200ad64 g     F .text	000008ac .hidden __adddf3
0202dc88 g     F .text	00000110 lwip_listen
02011c2c g     F .text	00000070 uxTimerGetReloadMode
02006e1c g     F .text	0000010c __b2d
0200a678 g     F .text	00000538 .hidden __umoddi3
02012ae0 g     F .text	000000d4 lseek
020348e8 g     F .text	00000188 raw_sendto
020282d8 g     F .text	0000029c alt_tse_phy_add_profile_default
020299f0 g     F .text	00000594 alt_tse_phy_get_cap
02000000 g       *ABS*	00000000 __alt_mem_sdram_controller_0
02011b6c g     F .text	00000030 xTimerGetPeriod
020458f0 g     O .rwdata	00000004 _global_impure_ptr
0203c480 g     F .text	00000130 do_close
0202ce80 g     F .text	000000fc alt_read
0200985c g     F .text	00000564 _realloc_r
0216a6a4 g       *ABS*	00000000 __bss_end
0202cd54 g     F .text	000000f0 alt_iic_isr_register
020252c0 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
0202d018 g     F .text	00000108 alt_tick
0202d92c g     F .text	00000154 lwip_bind
0200a100 g     F .text	00000578 .hidden __udivdi3
02017190 g     F .text	000000b8 dhcp_stop
02009030 g     F .text	00000024 _fputwc_r
02029890 g     F .text	00000160 alt_tse_phy_check_link
02040fcc g     O .rodata	00000028 __mprec_bigtens
02006484 g     F .text	00000104 __s2b
0202f668 g     F .text	00000044 lwip_getpeername
0200d2c0 g     F .text	000000a8 .hidden __floatunsidf
0202ae9c g     F .text	000000e4 marvell_cfg_sgmii
0201af10 g     F .text	0000025c pbuf_copy
020296d4 g     F .text	000001bc alt_tse_phy_restart_an
02020cac g     F .text	000002a8 tcp_rexmit
02006b5c g     F .text	00000060 __mcmp
0202bb8c g     F .text	000000cc pvPortMalloc
0202b1f8 g     F .text	0000015c altera_avalon_uart_init
0203c9a4 g     F .text	000000f4 netbuf_data
02004eb0 g     F .text	00000018 __fp_lock_all
020390e8 g     F .text	0000013c netconn_getaddr
0202cd08 g     F .text	0000004c alt_ic_irq_enabled
0216a584 g     O .bss	00000020 pphy_profiles
0200e62c g     F .text	0000003c vQueueDelete
0202c12c g     F .text	00000020 vPortEndScheduler
02019f64 g     F .text	000000b0 netif_set_up
0202bccc g     F .text	00000068 vListInitialise
0202cf7c g     F .text	0000009c alt_alarm_stop
02013bf4 g     F .text	00000034 lwip_set_link_callback
02047914 g     O .bss	00000004 alt_irq_active
0202e648 g     F .text	00000148 lwip_socket
02041710 g     O .rodata	00000010 tcp_pcb_lists
02030b28 g     F .text	00000074 tcpip_init
02000348 g     F .exceptions	000000cc alt_irq_handler
02044374 g     O .rwdata	00000028 alt_dev_null
0200fbe4 g     F .text	00000028 xTaskGetTickCount
0200da14 g     F .text	000001e4 xQueueGenericSend
02000a78 g     F .text	00000024 is_interface_active
020189f0 g     F .text	000000c4 ip4_addr_netmask_valid
020478d8 g     O .bss	00000004 tcp_tmp_pcb
020392fc g     F .text	000000d8 netconn_connect
020295bc g     F .text	00000118 alt_tse_phy_init
020258d8 g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
00000000 g       .debug_aranges	00000000 alt_exception_muldiv
02039c84 g     F .text	00000080 netconn_sendto
0202c604 g     F .text	00000020 alt_dcache_flush_all
02006588 g     F .text	00000068 __hi0bits
0200fc98 g     F .text	00000188 uxTaskGetSystemState
02014a58 g     F .text	00000160 tse_mac_raw_send
0200d164 g     F .text	00000080 .hidden __fixdfsi
020149c4 g     F .text	00000094 tse_sgdma_rx_isr
02010cf4 g     F .text	000000fc xTaskPriorityDisinherit
020191e8 g     F .text	000000b8 mem_init
0202d1bc g     F .text	000000f8 alt_write
0202db0c g     F .text	0000017c lwip_connect
0201e1e8 g     F .text	00000148 tcp_send_fin
02045968 g       *ABS*	00000000 __ram_rwdata_end
0201f780 g     F .text	00000aac tcp_output
02047898 g     O .bss	00000004 tx_counter
02045910 g     O .rwdata	00000008 alt_dev_list
020193ac g     F .text	00000308 mem_trim
02013238 g     F .text	00000064 write
02025a1c g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0203cc8c g     F .text	000000a0 _putc_r
0201020c g     F .text	000000f4 xTaskRemoveFromEventList
02000450 g     F .text	00000028 vApplicationMallocFailedHook
02043ad0 g       *ABS*	00000000 __ram_rodata_end
0203c760 g     F .text	0000008c netbuf_free
020126e8 g     F .text	000000b0 fstat
02039490 g     F .text	000000cc netconn_listen_with_backlog
02047970 g     O .bss	00000004 tcp_input_pcb
020346e8 g     F .text	0000012c raw_input
0200c05c g     F .text	000000f4 .hidden __ledf2
0202b070 g     F .text	00000078 DP83848C_link_status_read
0201f5e4 g     F .text	0000019c tcp_send_empty_ack
0200e200 g     F .text	000001e0 xQueuePeek
02020f54 g     F .text	00000128 tcp_rexmit_fast
02014dfc g     F .text	000000e4 sys_sem_new
020068d4 g     F .text	00000140 __pow5mult
0200771c g     F .text	0000145c ___vfiprintf_internal_r
02047818 g     O .bss	00000004 __nlocale_changed
02030940 g     F .text	0000008c tcpip_untimeout
0200ad0c g     F .text	00000058 .hidden __umodsi3
02018af8 g     F .text	000003f8 ipaddr_aton
02018924 g     F .text	000000cc ip4_addr_isbroadcast
02019f38 g     F .text	0000002c netif_set_default
02022a38 g     F .text	00000044 udp_recv
020256c4 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_stream_desc
020257d0 g     F .text	00000054 alt_avalon_sgdma_register_callback
0216a6a4 g       *ABS*	00000000 end
0200f07c g     F .text	000000f8 vTaskDelete
020219a8 g     F .text	00000114 sys_timeouts_mbox_fetch
0201a014 g     F .text	00000094 netif_set_down
0204789c g     O .bss	00000004 rx_counter
0201a3ac g     F .text	0000036c pbuf_alloc
0201a0e4 g     F .text	000000c4 netif_set_link_up
020152d8 g     F .text	00000070 sys_mbox_free
0202b900 g     F .text	000001e8 altera_avalon_uart_write
02026454 g     F .text	000001e4 alt_tse_phy_add_profile
02024880 g     F .text	00000148 altera_avalon_jtag_uart_init
02011018 g     F .text	00000038 pvTaskIncrementMutexHeldCount
02040a20 g       *ABS*	00000000 __CTOR_LIST__
04000000 g       *ABS*	00000000 __alt_stack_pointer
02039088 g     F .text	00000060 netconn_delete
02025a9c g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
02026090 g     F .text	0000007c alt_avalon_timer_sc_init
0202b148 g     F .text	00000060 altera_avalon_uart_write_fd
0200d368 g     F .text	00000064 .hidden __clzsi2
0203cec8 g     F .text	000000d8 _snprintf_r
0202b1a8 g     F .text	00000050 altera_avalon_uart_close_fd
0203ca98 g     F .text	0000009c netbuf_next
02025024 g     F .text	00000260 altera_avalon_jtag_uart_write
020254f4 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_mem_desc
0203cb34 g     F .text	00000068 netbuf_first
02004ea0 g     F .text	00000004 __sfp_lock_acquire
02005f40 g     F .text	000000e4 memchr
02045928 g     O .rwdata	00000004 ip_addr_broadcast
02000bec g     F .text	000021f8 ___vfprintf_internal_r
0202e450 g     F .text	000001f8 lwip_sendto
02032b18 g     F .text	000000a0 ip_reass_tmr
02010460 g     F .text	000000f0 xTaskCheckForTimeOut
020255ec g     F .text	00000060 alt_avalon_sgdma_construct_stream_to_mem_desc
02005004 g     F .text	00000310 _free_r
02012e08 g     F .text	0000022c alt_printf
02010bb4 g     F .text	00000140 xTaskPriorityInherit
02012564 g     F .text	00000028 uxTimerGetTimerNumber
02005524 g     F .text	00000010 __locale_mb_cur_max
020228e0 g     F .text	00000108 udp_connect
0203f404 g     F .text	00000180 __call_exitprocs
0203ac58 g     F .text	0000012c netconn_alloc
02047944 g     O .bss	00000004 current_header
0202eb54 g     F .text	000004e0 lwip_select
0202e270 g     F .text	0000004c lwip_read
020478a4 g     O .bss	00000004 rx_faulty_packets
02047814 g     O .bss	00000004 __mlocale_changed
02014bb8 g     F .text	000001d0 tse_mac_rcv
02011050 g     F .text	000000d0 ulTaskNotifyTake
02019b6c g     F .text	0000005c netif_set_addr
02016558 g     F .text	000000a0 dhcp_arp_reply
020458fc g     O .rwdata	00000004 __malloc_sbrk_base
02000414 g     F .text	0000003c _start
02047918 g     O .bss	00000004 _alt_tick_rate
0200fa50 g     F .text	0000002c vTaskSuspendAll
0200f2c0 g     F .text	00000120 eTaskGetState
0201b88c g     F .text	000000a4 pbuf_strstr
0202593c g     F .text	00000054 alt_avalon_sgdma_open
0200fc0c g     F .text	0000002c xTaskGetTickCountFromISR
02000824 g     F .text	0000011c get_mac_addr
02034434 g     F .text	000001cc memp_malloc
02006a14 g     F .text	00000148 __lshift
02021210 g     F .text	000002e8 tcp_zero_window_probe
0204791c g     O .bss	00000004 _alt_nticks
0202820c g     F .text	000000cc alt_tse_phy_rd_mdio_reg
020131cc g     F .text	0000006c read
0203c194 g     F .text	00000114 do_write
02024670 g     F .text	000000ac alt_sys_init
0203f584 g     F .text	000001d0 __ssprint_r
02015b1c g     F .text	000000b8 dhcp_fine_tmr
021622a8 g     O .bss	0000000a dhcp_rx_options_given
0202bec4 g     F .text	00000098 uxListRemove
0203f2ec g     F .text	00000118 __register_exitproc
020478f0 g     O .bss	00000001 phy_profile_count
02027290 g     F .text	00000074 alt_tse_get_mac_group_index
02018f2c g     F .text	00000194 ipaddr_ntoa_r
020066dc g     F .text	000001f8 __multiply
02024c74 g     F .text	00000068 altera_avalon_jtag_uart_close
02043ad0 g       *ABS*	00000000 __ram_rwdata_start
02040a20 g       *ABS*	00000000 __ram_rodata_start
02047974 g     O .bss	00000028 __malloc_current_mallinfo
020116f4 g     F .text	00000088 xTaskNotifyStateClear
020478dc g     O .bss	00000004 tcp_bound_pcbs
0200f7d0 g     F .text	000000dc vTaskResume
02006f28 g     F .text	0000014c __d2b
02014ee0 g     F .text	00000058 sys_sem_free
0201d430 g     F .text	0000005c tcp_seg_free
0201001c g     F .text	000000d8 vTaskSwitchContext
0201b6a4 g     F .text	00000120 pbuf_memcmp
02011b9c g     F .text	00000090 vTimerSetReloadMode
02030c14 g     F .text	0000003c mem_free_callback
0202808c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
0202471c g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0202c89c g     F .text	000000e0 alt_get_fd
020101a8 g     F .text	00000064 vTaskPlaceOnEventListRestricted
0203c2a8 g     F .text	000001d8 do_getaddr
02038de4 g     F .text	00000158 alt_busy_sleep
0203c8e4 g     F .text	000000c0 netbuf_chain
0201b950 g     F .text	00000020 tcp_init
0201c6c4 g     F .text	00000398 tcp_connect
0203193c g     F .text	00000238 inet_chksum_pseudo_partial
02008cb0 g     F .text	00000054 _close_r
020196b4 g     F .text	00000330 mem_malloc
02011120 g     F .text	00000114 xTaskNotifyWait
0202a544 g     F .text	00000328 alt_tse_phy_get_common_speed
0203cc10 g     F .text	0000007c memcmp
020247dc g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0216a6a4 g       *ABS*	00000000 __alt_stack_base
0202482c g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
020478f1 g     O .bss	00000001 mac_group_count
0201a1a8 g     F .text	00000078 netif_set_link_down
02016b88 g     F .text	00000164 dhcp_renew
02011a70 g     F .text	000000dc xTimerGenericCommand
020105c0 g     F .text	00000044 vTaskSetTaskNumber
0203b8c4 g     F .text	00000084 do_disconnect
02002ebc g     F .text	00000154 __swsetup_r
02000478 g     F .text	00000030 vApplicationStackOverflowHook
02014920 g     F .text	000000a4 tse_sgdma_read_init
0200f648 g     F .text	0000011c vTaskSuspend
0200b610 g     F .text	000008e8 .hidden __divdf3
02004d60 g     F .text	00000118 __sfp
0200fe20 g     F .text	0000004c xTaskCatchUpTicks
0200718c g     F .text	00000078 __copybits
0200fc38 g     F .text	00000020 uxTaskGetNumberOfTasks
0201dd38 g     F .text	0000008c tcp_eff_send_mss
02043f6c g     O .rwdata	00000408 __malloc_av_
02004eac g     F .text	00000004 __sinit_lock_release
0200c150 g     F .text	00000718 .hidden __muldf3
02162240 g     O .bss	00000044 eth_tse
02007358 g     F .text	00000054 __sread
02028e28 g     F .text	00000424 alt_tse_mac_get_phy
0202c794 g     F .text	00000108 alt_find_file
0202fdb0 g     F .text	00000294 lwip_setsockopt
0202c660 g     F .text	000000a4 alt_dev_llist_insert
0200d4e4 g     F .text	00000060 __malloc_lock
020130d4 g     F .text	000000b0 sbrk
0203d114 g     F .text	000021d8 ___svfprintf_internal_r
0200d920 g     F .text	0000009c xQueueTakeMutexRecursive
02025824 g     F .text	00000058 alt_avalon_sgdma_start
02016304 g     F .text	000001ac dhcp_inform
020308a4 g     F .text	0000009c tcpip_timeout
02004ab4 g     F .text	0000005c _fflush_r
0202753c g     F .text	0000008c alt_tse_mac_set_duplex
02008d04 g     F .text	000000c4 _calloc_r
0203485c g     F .text	00000048 raw_connect
020399e8 g     F .text	00000074 netconn_recv_tcp_pbuf
02011234 g     F .text	000001bc xTaskGenericNotify
0202c97c g     F .text	000001f4 gettimeofday
02015208 g     F .text	000000d0 sys_mbox_new
02013ee4 g     F .text	000001f0 lwip_initialize_phys
02047800 g       *ABS*	00000000 __bss_start
02010578 g     F .text	00000048 uxTaskGetTaskNumber
0200616c g     F .text	00000128 memset
02000a9c g     F .text	00000040 main
02047834 g     O .bss	00000004 alt_envp
0204781c g     O .bss	00000004 __malloc_max_total_mem
0202477c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
02009f00 g     F .text	00000018 __swbuf
0202bdec g     F .text	000000d8 vListInsert
02031298 g     F .text	00000048 icmp_dest_unreach
0204594c g     O .rwdata	00000008 alt_sgdma_list
0201d9a8 g     F .text	00000034 tcp_sent
0200748c g     F .text	00000008 __sclose
0201b5f4 g     F .text	000000b0 pbuf_get_at
04000000 g       *ABS*	00000000 __alt_heap_limit
05020000 g       *ABS*	00000000 __alt_mem_mem_0
02008eb8 g     F .text	00000014 fclose
020118ec g     F .text	00000068 xTimerCreateTimerTask
02003210 g     F .text	00001688 _dtoa_r
02034b54 g     F .text	00000080 raw_new
02005734 g     F .text	0000080c _malloc_r
02026328 g     F .text	00000088 tse_mac_SwReset
0200a074 g     F .text	00000030 __ascii_wctomb
0202f6ac g     F .text	00000044 lwip_getsockname
0200e6c4 g     F .text	00000028 ucQueueGetQueueType
02013464 g     F .text	000000fc ethernetif_input
02045958 g     O .rwdata	00000004 alt_errno
0200f174 g     F .text	000000f0 vTaskDelayUntil
02030bd8 g     F .text	0000003c pbuf_free_callback
0202bb48 g     F .text	00000044 __env_unlock
0201a0a8 g     F .text	0000003c netif_set_status_callback
02005314 g     F .text	000000c4 _fwalk
02039d04 g     F .text	000000c8 netconn_send
0200e3e0 g     F .text	000000e4 xQueueReceiveFromISR
02038fcc g     F .text	000000bc netconn_new_with_proto_and_callback
02010b40 g     F .text	00000028 xTaskGetCurrentTaskHandle
02039dcc g     F .text	000001a4 netconn_write_partly
0203cd2c g     F .text	000000c8 putc
0200abb0 g     F .text	00000084 .hidden __divsi3
020271dc g     F .text	00000048 alt_tse_mac_set_common_speed
02034ab4 g     F .text	000000a0 raw_remove
0200d6ac g     F .text	00000098 xQueueGenericCreate
02004ee0 g     F .text	00000124 _malloc_trim_r
02040a20 g       *ABS*	00000000 __CTOR_END__
02013b2c g     F .text	0000004c get_mac_base
020478c4 g     O .bss	00000001 pbuf_free_ooseq_pending
02022784 g     F .text	0000015c udp_bind
0201b970 g     F .text	0000004c tcp_tmr
02023d48 g     F .text	000003b4 etharp_query
02007494 g     F .text	000000dc strcmp
02030c50 g     F .text	0000004c lwip_init
0200d9bc g     F .text	00000058 xQueueCreateCountingSemaphore
02040a20 g       *ABS*	00000000 __flash_rodata_start
02015560 g     F .text	0000007c sys_thread_new
02040a20 g       *ABS*	00000000 __DTOR_LIST__
02023a5c g     F .text	000002ec etharp_output
02022218 g     F .text	000000b8 udp_sendto_chksum
020113f0 g     F .text	000001e4 xTaskGenericNotifyFromISR
0200bef8 g     F .text	00000088 .hidden __nedf2
0200e690 g     F .text	00000034 vQueueSetQueueNumber
02024638 g     F .text	00000038 alt_irq_init
0202719c g     F .text	00000040 alt_tse_mac_get_common_speed
02013070 g     F .text	00000064 alt_release_fd
0200fa7c g     F .text	00000168 xTaskResumeAll
020309cc g     F .text	00000070 tcpip_apimsg
0201a718 g     F .text	00000140 pbuf_alloced_custom
0200e590 g     F .text	00000064 uxQueueSpacesAvailable
02019ea8 g     F .text	00000048 netif_set_gw
020410dc g     O .rodata	00000100 .hidden __clz_tab
0200f98c g     F .text	00000090 vTaskStartScheduler
0201acac g     F .text	0000004c pbuf_clen
02047810 g     O .bss	00000004 _PathLocale
0203cb9c g     F .text	00000014 atexit
02013b0c g     F .text	00000020 get_mac_count
02008c50 g     F .text	00000060 _write_r
0201d48c g     F .text	00000038 tcp_setprio
020220f8 g     F .text	00000054 udp_send
0202f6f0 g     F .text	000002c4 lwip_getsockopt
02005554 g     F .text	00000018 setlocale
0200eb88 g     F .text	00000050 xQueueIsQueueFullFromISR
0201b45c g     F .text	0000008c pbuf_coalesce
020348a4 g     F .text	00000044 raw_recv
020124b0 g     F .text	00000058 pvTimerGetTimerID
02015168 g     F .text	00000048 sys_mutex_unlock
02000adc g     F .text	000000a4 main_thread
02019bc8 g     F .text	000000d8 netif_remove
0201511c g     F .text	0000004c sys_mutex_lock
02014f80 g     F .text	000000dc sys_arch_sem_wait
020458f4 g     O .rwdata	00000004 _impure_ptr
0204782c g     O .bss	00000004 alt_argc
0201ca5c g     F .text	00000738 tcp_slowtmr
02011c9c g     F .text	00000038 xTimerGetExpiryTime
02004898 g     F .text	0000021c __sflush_r
0201264c g     F .text	00000060 _do_dtors
02005540 g     F .text	00000008 __locale_cjk_lang
02006db8 g     F .text	00000064 __ulp
0201da10 g     F .text	00000034 tcp_accept
02004ec8 g     F .text	00000018 __fp_unlock_all
0203b948 g     F .text	00000200 do_listen
02010550 g     F .text	00000028 vTaskMissedYield
02013560 g     F .text	000001b0 ethernetif_init
02045908 g     O .rwdata	00000008 alt_fs_list
0200e540 g     F .text	00000050 uxQueueMessagesWaiting
0204790c g     O .bss	00000008 alt_resettime
0200fe6c g     F .text	000001b0 xTaskIncrementTick
02000020 g       *ABS*	00000000 __ram_exceptions_start
0200556c g     F .text	0000000c localeconv
02030724 g     F .text	000000b0 tcpip_input
020478e0 g     O .bss	00000004 tcp_tw_pcbs
0202a39c g     F .text	000001a8 alt_tse_phy_set_adv_10
0200059c g     F .text	00000048 InitNetwork
0202cba4 g     F .text	00000050 alt_ic_isr_register
02014da8 g     F .text	00000054 sys_now
02021b78 g     F .text	00000580 udp_input
0200d588 g     F .text	00000124 xQueueGenericReset
02012508 g     F .text	0000005c vTimerSetTimerID
02045968 g       *ABS*	00000000 _edata
0202b0e8 g     F .text	00000060 altera_avalon_uart_read_fd
0216a6a4 g       *ABS*	00000000 _end
0202924c g     F .text	00000248 alt_tse_mac_associate_phy
02019a5c g     F .text	00000020 netif_init
02008ecc g     F .text	00000164 __fputwc
02000414 g       *ABS*	00000000 __ram_exceptions_end
02024cdc g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
02031d1c g     F .text	000000f0 ip_route
0201c1ec g     F .text	00000268 tcp_listen_with_backlog
0216a2f0 g     O .bss	00000274 lwip_stats
0200eca0 g     F .text	000000e0 xTaskCreate
0203bd8c g     F .text	000000fc do_recv
0202bc7c g     F .text	00000024 vPortInitialiseBlocks
0201a9b8 g     F .text	000001b0 pbuf_header
02012440 g     F .text	00000070 xTimerIsTimerActive
020478c0 g     O .bss	00000004 netif_default
0202cc7c g     F .text	0000008c alt_ic_irq_disable
0201dbfc g     F .text	0000010c tcp_pcb_remove
0204780c g     O .bss	00000004 lwipStaticIp
020478a0 g     O .bss	00000004 rx_missed_packets
02025990 g     F .text	0000008c alt_avalon_sgdma_construct_descriptor
020073b4 g     F .text	0000007c __swrite
02031cc4 g     F .text	00000058 lwip_chksum_copy
02045900 g     O .rwdata	00000004 __malloc_trim_threshold
0201ae30 g     F .text	00000044 pbuf_chain
02005534 g     F .text	0000000c __locale_msgcharset
0201be54 g     F .text	00000160 tcp_abandon
0203cbb0 g     F .text	00000038 exit
0201ddc4 g     F .text	0000003c tcp_debug_state_str
02021554 g     F .text	0000005c tcp_timer_needed
020053d8 g     F .text	000000c4 _fwalk_reent
02034270 g     F .text	000001c4 memp_init
0201607c g     F .text	0000004c dhcp_set_struct
020199e4 g     F .text	00000078 mem_calloc
02006bbc g     F .text	000001fc __mdiff
0201d194 g     F .text	000000f8 tcp_fasttmr
0200ac34 g     F .text	00000074 .hidden __modsi3
0201d28c g     F .text	00000150 tcp_process_refused_data
02026404 g     F .text	00000050 tse_mac_setGMIImode
0200f264 g     F .text	0000005c vTaskDelay
0202adb8 g     F .text	000000e4 marvell_cfg_gmii
04000000 g       *ABS*	00000000 __alt_data_end
02004ea4 g     F .text	00000004 __sfp_lock_release
02039224 g     F .text	000000d8 netconn_bind
0202e790 g     F .text	00000044 lwip_write
02029494 g     F .text	00000128 alt_tse_phy_cfg_pcs
021622b4 g     O .bss	00000028 dhcp_rx_options_val
04000000 g       *ABS*	00000000 __alt_mem_tse_descriptor_memory_0
02010b68 g     F .text	0000004c xTaskGetSchedulerState
0202e2bc g     F .text	00000050 lwip_recv
02010df0 g     F .text	00000140 vTaskPriorityDisinheritAfterTimeout
0202b61c g     F .text	00000054 altera_avalon_uart_close
0203037c g     F .text	000000e4 lwip_ioctl
020409f0 g     F .text	00000030 _exit
02015a74 g     F .text	000000a8 dhcp_coarse_tmr
0202c3a4 g     F .text	0000012c alt_alarm_start
0201d4c4 g     F .text	00000068 tcp_seg_copy
02040990 g     F .text	00000060 .hidden __muldi3
02005578 g     F .text	000001bc __smakebuf_r
02010f78 g     F .text	0000005c vTaskExitCritical
0201da44 g     F .text	00000048 tcp_poll
02007570 g     F .text	00000098 strlen
0202c014 g     F .text	000000e0 pxPortInitialiseStack
02030460 g     F .text	00000104 lwip_fcntl
02012cb4 g     F .text	00000154 open
02021abc g     F .text	00000020 udp_init
021622dc g     O .bss	00008014 ram_heap
0200bf80 g     F .text	000000dc .hidden __gedf2
02022b1c g     F .text	00000058 udp_new
02013034 g     F .text	0000003c alt_putchar
02045904 g     O .rwdata	00000004 __wctomb
0202da80 g     F .text	0000008c lwip_close
0202bf88 g     F .text	00000050 enh_alt_irq_disable_all
02007704 g     F .text	00000018 __sprint_r
02026280 g     F .text	000000a8 tse_mac_aRxRead
0202cb70 g     F .text	00000034 alt_icache_flush_all
0203c7ec g     F .text	000000f8 netbuf_ref
0204593e g     O .rwdata	00000006 ethbroadcast
020103c8 g     F .text	0000005c vTaskSetTimeOutState
02011b4c g     F .text	00000020 xTimerGetTimerDaemonTaskHandle
02041700 g     O .rodata	0000000d tcp_backoff
0201258c g     F .text	00000034 vTimerSetTimerNumber
0204595c g     O .rwdata	00000004 alt_priority_mask
020154f8 g     F .text	00000068 sys_arch_mbox_tryfetch
0202cbf4 g     F .text	00000088 alt_ic_irq_enable
02002de4 g     F .text	0000001c __vfprintf_internal
0202d628 g     F .text	00000304 lwip_accept
0202b6ac g     F .text	00000218 altera_avalon_uart_read
0200e5f4 g     F .text	00000038 uxQueueMessagesWaitingFromISR
0200a0a4 g     F .text	0000005c _wctomb_r
0202bae8 g     F .text	00000060 __env_lock
02039a5c g     F .text	000001a8 netconn_recv
0200ead8 g     F .text	00000048 xQueueIsQueueEmptyFromISR
0203abf8 g     F .text	00000060 do_newconn
0202745c g     F .text	000000e0 alt_tse_mac_set_speed
02015348 g     F .text	00000050 sys_mbox_post
02025568 g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0200c868 g     F .text	000008fc .hidden __subdf3
020065f0 g     F .text	000000b0 __lo0bits
0203b678 g     F .text	0000024c do_connect
02045960 g     O .rwdata	00000008 alt_alarm_list
020125ec g     F .text	00000060 _do_ctors
0202a148 g     F .text	00000254 alt_tse_phy_set_adv_100
02010fd4 g     F .text	00000044 uxTaskResetEventItemValue
020218b4 g     F .text	000000f4 sys_untimeout
02009fb4 g     F .text	000000c0 wcrtomb
02034bd4 g     F .text	00000e7c tcp_input
0200d834 g     F .text	0000005c xQueueCreateMutex
02013184 g     F .text	00000048 close
020478f4 g     O .bss	00000004 alt_envsem
02031e0c g     F .text	0000053c ip_input
020115d4 g     F .text	00000120 vTaskNotifyGiveFromISR
020009f8 g     F .text	00000038 get_hostname
0203bb48 g     F .text	00000244 do_send
02012a20 g     F .text	00000084 alt_load
02045944 g     O .rwdata	00000006 ethzero
0201b930 g     F .text	00000020 stats_init
02027224 g     F .text	0000006c alt_tse_get_system_index
02025f70 g     F .text	000000a8 alt_avalon_sgdma_init
0200dcec g     F .text	000000dc xQueueGiveFromISR
02009054 g     F .text	00000080 fputwc
0203cbfc g     F .text	00000014 free
02019ca0 g     F .text	000000e0 netif_find
02004ea8 g     F .text	00000004 __sinit_lock_acquire
020007b0 g     F .text	00000074 xEthernetRun
02006364 g     F .text	00000120 __multadd
020307d4 g     F .text	000000d0 tcpip_callback_with_block
0200633c g     F .text	00000028 _Bfree
0202610c g     F .text	00000030 no_printf
0201ae74 g     F .text	0000009c pbuf_dechain



Disassembly of section .entry:

02000000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
 2000000:	00900014 	movui	r2,16384
#endif

0:
    initi r2
 2000004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
 2000008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 200000c:	00bffd16 	blt	zero,r2,2000004 <__alt_mem_mem_0+0xfcfe0004>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
 2000010:	00408034 	movhi	at,512
    ori r1, r1, %lo(_start)
 2000014:	08410514 	ori	at,at,1044
    jmp r1
 2000018:	0800683a 	jmp	at
 200001c:	00000000 	call	0 <alt_exception_muldiv>

Disassembly of section .exceptions:

02000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 2000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 2000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 2000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 200002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 2000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 2000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 2000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 200003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 2000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 2000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 2000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 200004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 2000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 2000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 2000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 200005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 2000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 2000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 2000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 200006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 2000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 2000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 2000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 200007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 2000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 2000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 2000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 200008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 2000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 2000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 2000098:	df001c15 	stw	fp,112(sp)

0200009c <save_sp_to_pxCurrentTCB>:
 200009c:	06008134 	movhi	et,516

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 20000a0:	c61e0f04 	addi	et,et,30780
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 20000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 20000a8:	c6c00015 	stw	sp,0(et)

020000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 20000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 20000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 20000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 20000b8:	10009826 	beq	r2,zero,200031c <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 20000bc:	20009726 	beq	r4,zero,200031c <soft_exceptions>

020000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 20000c0:	20003480 	call	2000348 <alt_irq_handler>

020000c4 <restore_sp_from_pxCurrentTCB>:
 20000c4:	06008134 	movhi	et,516

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 20000c8:	c61e0f04 	addi	et,et,30780
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 20000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 20000d0:	c6c00017 	ldw	sp,0(et)

020000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 20000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 20000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 20000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 20000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 20000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 20000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 20000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 20000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 20000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 20000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 20000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 2000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 2000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 2000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 200010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 2000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 2000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 2000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 200011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 2000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 2000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 2000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 200012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 2000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 2000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 2000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 200013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 2000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 2000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 2000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 200014c:	ef80083a 	eret
        /*
         * Split the instruction into its fields.  We need 4*A, 4*B, and 4*C as
         * offsets to the stack pointer for access to the stored register values.
         */
                             /* r2 = AAAAA,BBBBB,IIIIIIIIIIIIIIII,PPPPPP    */
        roli  r3, r2, 7      /* r3 = BBB,IIIIIIIIIIIIIIII,PPPPPP,AAAAA,BB   */
 2000150:	100611fa 	roli	r3,r2,7
        roli  r4, r3, 3      /* r4 = IIIIIIIIIIIIIIII,PPPPPP,AAAAA,BBBBB    */
 2000154:	180810fa 	roli	r4,r3,3
        roli  r6, r4, 2      /* r6 = IIIIIIIIIIIIII,PPPPPP,AAAAA,BBBBB,II   */
 2000158:	200c10ba 	roli	r6,r4,2
        srai  r4, r4, 16     /* r4 = (sign-extended) IMM16                  */
 200015c:	2009d43a 	srai	r4,r4,16
        xori  r6, r6, 0x42   /* r6 = CCC,XXXXXX,NNNNN,PPPPPP,AAAAA,bBBBB,cC */
 2000160:	3180109c 	xori	r6,r6,66
        roli  r7, r6, 5      /* r7 = XXXX,NNNNN,PPPPPP,AAAAA,bBBBB,cCCCC,XX */
 2000164:	300e117a 	roli	r7,r6,5
        andi  r5, r2, 0x3f   /* r5 = 00000000000000000000000000,PPPPPP      */
 2000168:	11400fcc 	andi	r5,r2,63
        xori  r3, r3, 0x40
 200016c:	18c0101c 	xori	r3,r3,64
        andi  r3, r3, 0x7c   /* r3 = 0000000000000000000000000,aAAAA,00     */
 2000170:	18c01f0c 	andi	r3,r3,124
        andi  r6, r6, 0x7c   /* r6 = 0000000000000000000000000,bBBBB,00     */
 2000174:	31801f0c 	andi	r6,r6,124
        andi  r7, r7, 0x7c   /* r7 = 0000000000000000000000000,cCCCC,00     */
 2000178:	39c01f0c 	andi	r7,r7,124
         * Save everything on the stack to make it easy for the emulation routines
         * to retrieve the source register operands.  The exception entry code has
         * already saved some of this so we don't need to do it all again.
         */

        addi  sp, sp, -60
 200017c:	defff104 	addi	sp,sp,-60
        stw   zero, 64(sp)   /* Save zero on stack to avoid special case for r0. */
 2000180:	d8001015 	stw	zero,64(sp)
                             /* Register at and r2-r15 have already been saved.  */

        stw   r16,  0(sp)
 2000184:	dc000015 	stw	r16,0(sp)
        stw   r17,  4(sp)
 2000188:	dc400115 	stw	r17,4(sp)
        stw   r18,  8(sp)
 200018c:	dc800215 	stw	r18,8(sp)
        stw   r19, 12(sp)
 2000190:	dcc00315 	stw	r19,12(sp)
        stw   r20, 16(sp)
 2000194:	dd000415 	stw	r20,16(sp)
        stw   r21, 20(sp)
 2000198:	dd400515 	stw	r21,20(sp)
        stw   r22, 24(sp)
 200019c:	dd800615 	stw	r22,24(sp)
        stw   r23, 28(sp)
 20001a0:	ddc00715 	stw	r23,28(sp)
                            /* et @ 32 - Has already been changed.*/
                            /* bt @ 36 - Usually isn't an operand.   */
        stw   gp,  40(sp)
 20001a4:	de800a15 	stw	gp,40(sp)
        stw   sp,  44(sp)
 20001a8:	dec00b15 	stw	sp,44(sp)
        stw   fp,  48(sp)
 20001ac:	df000c15 	stw	fp,48(sp)

        /*
         *  Prepare for either multiplication or division loop.
         *  They both loop 32 times.
         */
        movi   r14, 32
 20001b0:	03800804 	movi	r14,32
         * Get the operands.
         *
         * It is necessary to check for muli because it uses an I-type instruction
         * format, while the other instructions are have an R-type format.
         */
        add    r3, r3, sp     /* r3 = address of A-operand. */
 20001b4:	1ec7883a 	add	r3,r3,sp
        ldw    r3, 0(r3)      /* r3 = A-operand. */
 20001b8:	18c00017 	ldw	r3,0(r3)
        movi   r15, 0x24      /* muli opcode (I-type instruction format) */
 20001bc:	03c00904 	movi	r15,36
        beq    r5, r15, .Lmul_immed /* muli doesn't use the B register as a source */
 20001c0:	2bc02726 	beq	r5,r15,2000260 <restore_context+0x18c>

        add    r6, r6, sp     /* r6 = address of B-operand.               */
 20001c4:	36cd883a 	add	r6,r6,sp
        ldw    r6, 0(r6)      /* r6 = B-operand.                          */
 20001c8:	31800017 	ldw	r6,0(r6)
                              /* r4 = SSSSSSSSSSSSSSSS,-----IMM16------   */
                              /* IMM16 not needed, align OPX portion      */
                              /* r4 = SSSSSSSSSSSSSSSS,CCCCC,-OPX--,00000 */
        srli   r4, r4, 5      /* r4 = 00000,SSSSSSSSSSSSSSSS,CCCCC,-OPX-- */
 20001cc:	2008d17a 	srli	r4,r4,5
        andi   r4, r4, 0x3f   /* r4 = 00000000000000000000000000,-OPX--   */
 20001d0:	21000fcc 	andi	r4,r4,63
         *
         *  This code assumes that OP is not muli (because muli was tested above).
         *  All other multiplies and divides are legal.  Anything else is illegal.
         */

        movi  r8, 0x3a                        /* OP for R-type mul* and div* */
 20001d4:	02000e84 	movi	r8,58
        bne   r5, r8, .Lnot_muldiv
 20001d8:	2a004f1e 	bne	r5,r8,2000318 <restore_context+0x244>

        /* r15 already is 0x24 */            /* OPX of divu */
        beq   r4, r15, .Ldivide
 20001dc:	23c00a26 	beq	r4,r15,2000208 <restore_context+0x134>

        movi  r15,0x27                        /* OPX of mul */
 20001e0:	03c009c4 	movi	r15,39
        beq   r4, r15, .Lmultiply
 20001e4:	23c02126 	beq	r4,r15,200026c <restore_context+0x198>

        movi  r15,0x07                        /* OPX of mulxuu */
 20001e8:	03c001c4 	movi	r15,7
        beq   r4, r15, .Lmultiply
 20001ec:	23c01f26 	beq	r4,r15,200026c <restore_context+0x198>

        movi  r15,0x17                        /* OPX of mulxsu */
 20001f0:	03c005c4 	movi	r15,23
        beq   r4, r15, .Lmultiply
 20001f4:	23c01d26 	beq	r4,r15,200026c <restore_context+0x198>

        movi  r15,0x1f                        /* OPX of mulxss */
 20001f8:	03c007c4 	movi	r15,31
        beq   r4, r15, .Lmultiply
 20001fc:	23c01b26 	beq	r4,r15,200026c <restore_context+0x198>

        movi  r15,0x25                        /* OPX of div */
 2000200:	03c00944 	movi	r15,37
        bne   r4, r15, .Lnot_muldiv
 2000204:	23c0441e 	bne	r4,r15,2000318 <restore_context+0x244>
.Ldivide:
        /*
         *  Prepare for division by assuming the result
         *  is unsigned, and storing its "sign" as 0.
         */
        movi   r17, 0
 2000208:	04400004 	movi	r17,0


        /* Which division opcode? */
        xori   r15, r4, 0x25         /* OPX of div */
 200020c:	23c0095c 	xori	r15,r4,37
        bne    r15, zero, .Lunsigned_division
 2000210:	7800051e 	bne	r15,zero,2000228 <restore_context+0x154>

        /*
         *  OPX is div.  Determine and store the sign of the quotient.
         *  Then take the absolute value of both operands.
         */
        xor   r17, r3, r6      /* MSB contains sign of quotient */
 2000214:	19a2f03a 	xor	r17,r3,r6
        bge   r3, zero, 0f
 2000218:	1800010e 	bge	r3,zero,2000220 <restore_context+0x14c>
        sub   r3, zero, r3     /* -r3 */
 200021c:	00c7c83a 	sub	r3,zero,r3
0:
        bge   r6, zero, 0f
 2000220:	3000010e 	bge	r6,zero,2000228 <restore_context+0x154>
        sub   r6, zero, r6     /* -r6 */
 2000224:	018dc83a 	sub	r6,zero,r6
0:


.Lunsigned_division:
        /* Initialize the unsigned-division loop. */
        movi  r13, 0          /* remainder = 0 */
 2000228:	03400004 	movi	r13,0
        /*
        *       Division:
        *
        *       (remainder:dividend:quotient) <<= 1;
        */
        slli  r13, r13, 1
 200022c:	681a907a 	slli	r13,r13,1
        cmplt r15, r3, zero        /* r15 = MSB of r3 */
 2000230:	181e803a 	cmplt	r15,r3,zero
        or    r13, r13, r15
 2000234:	6bdab03a 	or	r13,r13,r15
        slli  r3, r3, 1
 2000238:	1806907a 	slli	r3,r3,1
        *       {
        *           set LSB of quotient
        *           remainder -= divisor;
        *       }
        */
        bltu  r13, r6, .Ldiv_skip
 200023c:	69800236 	bltu	r13,r6,2000248 <restore_context+0x174>
        ori   r3, r3, 1
 2000240:	18c00054 	ori	r3,r3,1
        sub   r13, r13, r6
 2000244:	699bc83a 	sub	r13,r13,r6
.Ldiv_skip:

        /*
        *   }
        */
        subi  r14, r14, 1
 2000248:	73bfffc4 	addi	r14,r14,-1
        bne   r14, zero, .Ldivide_loop
 200024c:	703ff71e 	bne	r14,zero,200022c <__alt_mem_mem_0+0xfcfe022c>

        mov   r9, r3
 2000250:	1813883a 	mov	r9,r3
    
        /*
        *  Conditionally negate signed quotient.  If quotient is unsigned,
        *  the sign already is initialized to 0.
        */
        bge   r17, zero, .Lstore_result
 2000254:	8800230e 	bge	r17,zero,20002e4 <restore_context+0x210>
        sub   r9, zero, r9     /* -r9 */
 2000258:	0253c83a 	sub	r9,zero,r9

        br    .Lstore_result
 200025c:	00002106 	br	20002e4 <restore_context+0x210>
        *
        */

.Lmul_immed:
        /* Opcode is muli.  Change it into mul for remainder of algorithm. */
        mov   r7, r6         /* Field B is dest register, not field C. */
 2000260:	300f883a 	mov	r7,r6
        mov   r6, r4         /* Field IMM16 is src2, not field B. */
 2000264:	200d883a 	mov	r6,r4
        movi  r4, 0x27       /* OPX of mul is 0x27 */
 2000268:	010009c4 	movi	r4,39

.Lmultiply:
        /* Initialize the multiplication loop. */
        movi  r9, 0          /* mul_product    = 0 */
 200026c:	02400004 	movi	r9,0
        movi  r10, 0         /* mulxuu_product = 0 */
 2000270:	02800004 	movi	r10,0
        mov   r11, r6        /* save original multiplier for mulxsu and mulxss */
 2000274:	3017883a 	mov	r11,r6
        mov   r12, r6        /* mulxuu_multiplier (will be shifted) */
 2000278:	3019883a 	mov	r12,r6
        movi  r16, 1         /* used to create "rori B,A,1" from "ror B,A,r16" */
 200027c:	04000044 	movi	r16,1

        /*
        *       mul_product <<= 1;
        *       lsb = multiplier & 1;
        */
        slli   r9, r9, 1
 2000280:	4812907a 	slli	r9,r9,1
        andi   r15, r12, 1
 2000284:	63c0004c 	andi	r15,r12,1
        *       if (lsb == 1)
        *       {
        *           mulxuu_product += multiplicand;
        *       }
        */
        beq   r15, zero, .Lmulx_skip
 2000288:	78000326 	beq	r15,zero,2000298 <restore_context+0x1c4>
        add   r10, r10, r3
 200028c:	50d5883a 	add	r10,r10,r3
        cmpltu r15, r10, r3  /* Save the carry from the MSB of mulxuu_product. */
 2000290:	50df803a 	cmpltu	r15,r10,r3
        ror   r15, r15, r16  /* r15 = 0x80000000 on carry, or else 0x00000000 */
 2000294:	7c1e583a 	ror	r15,r15,r16
        *       if (MSB of mul_multiplier == 1)
        *       {
        *           mul_product += multiplicand;
        *       }
        */
        bge   r6, zero, .Lmul_skip
 2000298:	3000010e 	bge	r6,zero,20002a0 <restore_context+0x1cc>
        add   r9, r9, r3
 200029c:	48d3883a 	add	r9,r9,r3
        /*
        *       mulxuu_product >>= 1;           logical shift
        *       mul_multiplier <<= 1;           done with MSB
        *       mulx_multiplier >>= 1;          done with LSB
        */
        srli   r10, r10, 1
 20002a0:	5014d07a 	srli	r10,r10,1
        or     r10, r10, r15           /* OR in the saved carry bit. */
 20002a4:	53d4b03a 	or	r10,r10,r15
        slli   r6, r6, 1
 20002a8:	300c907a 	slli	r6,r6,1
        srli   r12, r12, 1
 20002ac:	6018d07a 	srli	r12,r12,1


        /*
        *   }
        */
        subi   r14, r14, 1
 20002b0:	73bfffc4 	addi	r14,r14,-1
        bne    r14, zero, .Lmultiply_loop
 20002b4:	703ff21e 	bne	r14,zero,2000280 <__alt_mem_mem_0+0xfcfe0280>
        *  Select/compute the result based on OPX.
        */


        /* OPX == mul?  Then store. */
        xori  r15, r4, 0x27
 20002b8:	23c009dc 	xori	r15,r4,39
        beq   r15, zero, .Lstore_result
 20002bc:	78000926 	beq	r15,zero,20002e4 <restore_context+0x210>

        /* It's one of the mulx.. opcodes.  Move over the result. */
        mov   r9, r10
 20002c0:	5013883a 	mov	r9,r10

        /* OPX == mulxuu?  Then store. */
        xori  r15, r4, 0x07
 20002c4:	23c001dc 	xori	r15,r4,7
        beq   r15, zero, .Lstore_result
 20002c8:	78000626 	beq	r15,zero,20002e4 <restore_context+0x210>

        /* Compute mulxsu
         *
         * mulxsu = mulxuu - ((rA < 0) ? rB : 0);
         */
        bge   r3, zero, .Lmulxsu_skip
 20002cc:	1800010e 	bge	r3,zero,20002d4 <restore_context+0x200>
        sub   r9, r9, r11
 20002d0:	4ad3c83a 	sub	r9,r9,r11
.Lmulxsu_skip:

        /* OPX == mulxsu?  Then store. */
        xori  r15, r4, 0x17
 20002d4:	23c005dc 	xori	r15,r4,23
        beq   r15, zero, .Lstore_result
 20002d8:	78000226 	beq	r15,zero,20002e4 <restore_context+0x210>

        /* Compute mulxss
         *
         * mulxss = mulxsu - ((rB < 0) ? rA : 0);
         */
        bge   r11, zero, .Lmulxss_skip
 20002dc:	5800010e 	bge	r11,zero,20002e4 <restore_context+0x210>
        sub   r9, r9, r3
 20002e0:	48d3c83a 	sub	r9,r9,r3
.Lmulxss_skip:
        /* At this point, assume that OPX is mulxss, so store */


.Lstore_result:
        add   r7, r7, sp
 20002e4:	3ecf883a 	add	r7,r7,sp
        stw   r9, 0(r7)
 20002e8:	3a400015 	stw	r9,0(r7)

        ldw   r16,  0(sp)
 20002ec:	dc000017 	ldw	r16,0(sp)
        ldw   r17,  4(sp)
 20002f0:	dc400117 	ldw	r17,4(sp)
        ldw   r18,  8(sp)
 20002f4:	dc800217 	ldw	r18,8(sp)
        ldw   r19, 12(sp)
 20002f8:	dcc00317 	ldw	r19,12(sp)
        ldw   r20, 16(sp)
 20002fc:	dd000417 	ldw	r20,16(sp)
        ldw   r21, 20(sp)
 2000300:	dd400517 	ldw	r21,20(sp)
        ldw   r22, 24(sp)
 2000304:	dd800617 	ldw	r22,24(sp)
        ldw   r23, 28(sp)
 2000308:	ddc00717 	ldw	r23,28(sp)

                            /* bt @ 32 - Breakpoint register usually isn't an operand. */
                            /* et @ 36 - Don't corrupt et. */
                            /* gp @ 40 - Don't corrupt gp. */
                            /* sp @ 44 - Don't corrupt sp. */
        ldw   fp,  48(sp)
 200030c:	df000c17 	ldw	fp,48(sp)
                            /* ea @ 52 - Don't corrupt ea. */
                            /* ba @ 56 - Breakpoint register usually isn't an operand. */

        addi  sp, sp, 60
 2000310:	dec00f04 	addi	sp,sp,60

        br    .Lexception_exit
 2000314:	00000c06 	br	2000348 <alt_irq_handler>


.Lnot_muldiv:

        addi  sp, sp, 60
 2000318:	dec00f04 	addi	sp,sp,60

0200031c <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 200031c:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 2000320:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 2000324:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 2000328:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 200032c:	c0000226 	beq	et,zero,2000338 <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 2000330:	003da03a 	break	0
  	br		restore_context			# its something else
 2000334:	003f6706 	br	20000d4 <__alt_mem_mem_0+0xfcfe00d4>

02000338 <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 2000338:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 200033c:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 2000340:	201001c0 	call	201001c <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 2000344:	003f5f06 	br	20000c4 <__alt_mem_mem_0+0xfcfe00c4>

02000348 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 2000348:	defff904 	addi	sp,sp,-28
 200034c:	dfc00615 	stw	ra,24(sp)
 2000350:	df000515 	stw	fp,20(sp)
 2000354:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2000358:	0005313a 	rdctl	r2,ipending
 200035c:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2000360:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 2000364:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 2000368:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 200036c:	00800044 	movi	r2,1
 2000370:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 2000374:	e0fffb17 	ldw	r3,-20(fp)
 2000378:	e0bffc17 	ldw	r2,-16(fp)
 200037c:	1884703a 	and	r2,r3,r2
 2000380:	10001426 	beq	r2,zero,20003d4 <alt_irq_handler+0x8c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 2000384:	008085f4 	movhi	r2,535
 2000388:	10a96904 	addi	r2,r2,-23132
 200038c:	e0fffd17 	ldw	r3,-12(fp)
 2000390:	180690fa 	slli	r3,r3,3
 2000394:	10c5883a 	add	r2,r2,r3
 2000398:	10c00017 	ldw	r3,0(r2)
 200039c:	008085f4 	movhi	r2,535
 20003a0:	10a96904 	addi	r2,r2,-23132
 20003a4:	e13ffd17 	ldw	r4,-12(fp)
 20003a8:	200890fa 	slli	r4,r4,3
 20003ac:	1105883a 	add	r2,r2,r4
 20003b0:	10800104 	addi	r2,r2,4
 20003b4:	10800017 	ldw	r2,0(r2)
 20003b8:	1009883a 	mov	r4,r2
 20003bc:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 20003c0:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 20003c4:	0005313a 	rdctl	r2,ipending
 20003c8:	e0bfff15 	stw	r2,-4(fp)

  return active;
 20003cc:	e0bfff17 	ldw	r2,-4(fp)
 20003d0:	00000706 	br	20003f0 <alt_irq_handler+0xa8>
      }
      mask <<= 1;
 20003d4:	e0bffc17 	ldw	r2,-16(fp)
 20003d8:	1085883a 	add	r2,r2,r2
 20003dc:	e0bffc15 	stw	r2,-16(fp)
      i++;
 20003e0:	e0bffd17 	ldw	r2,-12(fp)
 20003e4:	10800044 	addi	r2,r2,1
 20003e8:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 20003ec:	003fe106 	br	2000374 <__alt_mem_mem_0+0xfcfe0374>

    active = alt_irq_pending ();
 20003f0:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 20003f4:	e0bffb17 	ldw	r2,-20(fp)
 20003f8:	103fdb1e 	bne	r2,zero,2000368 <__alt_mem_mem_0+0xfcfe0368>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 20003fc:	0001883a 	nop
 2000400:	e037883a 	mov	sp,fp
 2000404:	dfc00117 	ldw	ra,4(sp)
 2000408:	df000017 	ldw	fp,0(sp)
 200040c:	dec00204 	addi	sp,sp,8
 2000410:	f800283a 	ret

Disassembly of section .text:

02000414 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 2000414:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 2000418:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 200041c:	06808134 	movhi	gp,516
    ori gp, gp, %lo(_gp)
 2000420:	d6b63c14 	ori	gp,gp,55536
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 2000424:	00808134 	movhi	r2,516
    ori r2, r2, %lo(__bss_start)
 2000428:	109e0014 	ori	r2,r2,30720

    movhi r3, %hi(__bss_end)
 200042c:	00c085b4 	movhi	r3,534
    ori r3, r3, %lo(__bss_end)
 2000430:	18e9a914 	ori	r3,r3,42660

    beq r2, r3, 1f
 2000434:	10c00326 	beq	r2,r3,2000444 <_start+0x30>

0:
    stw zero, (r2)
 2000438:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 200043c:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 2000440:	10fffd36 	bltu	r2,r3,2000438 <__alt_mem_mem_0+0xfcfe0438>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
 2000444:	2012a200 	call	2012a20 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 2000448:	200d40c0 	call	200d40c <alt_main>

0200044c <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 200044c:	003fff06 	br	200044c <__alt_mem_mem_0+0xfcfe044c>

02000450 <vApplicationMallocFailedHook>:

static int nw_ready;
static sys_thread_t main_thread_handle;

// hook functions
void vApplicationMallocFailedHook(){
 2000450:	defffe04 	addi	sp,sp,-8
 2000454:	dfc00115 	stw	ra,4(sp)
 2000458:	df000015 	stw	fp,0(sp)
 200045c:	d839883a 	mov	fp,sp
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 2000460:	0100fa04 	movi	r4,1000
 2000464:	200f2640 	call	200f264 <vTaskDelay>
        alt_printf("vApplicationMallocFailedHook \r\n");
 2000468:	01008134 	movhi	r4,516
 200046c:	21028804 	addi	r4,r4,2592
 2000470:	2012e080 	call	2012e08 <alt_printf>
    }
 2000474:	003ffa06 	br	2000460 <__alt_mem_mem_0+0xfcfe0460>

02000478 <vApplicationStackOverflowHook>:
}

void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName ){
 2000478:	defffc04 	addi	sp,sp,-16
 200047c:	dfc00315 	stw	ra,12(sp)
 2000480:	df000215 	stw	fp,8(sp)
 2000484:	df000204 	addi	fp,sp,8
 2000488:	e13ffe15 	stw	r4,-8(fp)
 200048c:	e17fff15 	stw	r5,-4(fp)
    for(;;){
        vTaskDelay(pdMS_TO_TICKS(1000));
 2000490:	0100fa04 	movi	r4,1000
 2000494:	200f2640 	call	200f264 <vTaskDelay>
        alt_printf("vApplicationStackOverflowHook \r\n");
 2000498:	01008134 	movhi	r4,516
 200049c:	21029004 	addi	r4,r4,2624
 20004a0:	2012e080 	call	2012e08 <alt_printf>
    }
 20004a4:	003ffa06 	br	2000490 <__alt_mem_mem_0+0xfcfe0490>

020004a8 <StatusCallback>:
}

// callback function for when the DHCP subsystem acquires an IP address.
static void StatusCallback(struct netif* netif)
{
 20004a8:	deffbd04 	addi	sp,sp,-268
 20004ac:	dfc04215 	stw	ra,264(sp)
 20004b0:	df004115 	stw	fp,260(sp)
 20004b4:	df004104 	addi	fp,sp,260
 20004b8:	e13fff15 	stw	r4,-4(fp)
	// get IP and stuff
	printf("[ethernet] Acquired IP address via DHCP client for interface: %s\n", netif->name);
 20004bc:	e0bfff17 	ldw	r2,-4(fp)
 20004c0:	10800e84 	addi	r2,r2,58
 20004c4:	100b883a 	mov	r5,r2
 20004c8:	01008134 	movhi	r4,516
 20004cc:	21029904 	addi	r4,r4,2660
 20004d0:	2000bb00 	call	2000bb0 <printf>

	char buf[255];

	print_ipad(netif->ip_addr.addr, buf);
 20004d4:	e0bfff17 	ldw	r2,-4(fp)
 20004d8:	10800117 	ldw	r2,4(r2)
 20004dc:	e17fbf04 	addi	r5,fp,-260
 20004e0:	1009883a 	mov	r4,r2
 20004e4:	2013dec0 	call	2013dec <print_ipad>
	printf("[ethernet] IP address : %s\n", buf);
 20004e8:	e17fbf04 	addi	r5,fp,-260
 20004ec:	01008134 	movhi	r4,516
 20004f0:	2102aa04 	addi	r4,r4,2728
 20004f4:	2000bb00 	call	2000bb0 <printf>

	print_ipad(netif->netmask.addr, buf);
 20004f8:	e0bfff17 	ldw	r2,-4(fp)
 20004fc:	10800217 	ldw	r2,8(r2)
 2000500:	e17fbf04 	addi	r5,fp,-260
 2000504:	1009883a 	mov	r4,r2
 2000508:	2013dec0 	call	2013dec <print_ipad>
	printf("[ethernet] Subnet     : %s\n", buf);
 200050c:	e17fbf04 	addi	r5,fp,-260
 2000510:	01008134 	movhi	r4,516
 2000514:	2102b104 	addi	r4,r4,2756
 2000518:	2000bb00 	call	2000bb0 <printf>

    print_ipad(netif->gw.addr, buf);
 200051c:	e0bfff17 	ldw	r2,-4(fp)
 2000520:	10800317 	ldw	r2,12(r2)
 2000524:	e17fbf04 	addi	r5,fp,-260
 2000528:	1009883a 	mov	r4,r2
 200052c:	2013dec0 	call	2013dec <print_ipad>
	printf("[ethernet] Gateway    : %s\n", buf);
 2000530:	e17fbf04 	addi	r5,fp,-260
 2000534:	01008134 	movhi	r4,516
 2000538:	2102b804 	addi	r4,r4,2784
 200053c:	2000bb00 	call	2000bb0 <printf>
}
 2000540:	0001883a 	nop
 2000544:	e037883a 	mov	sp,fp
 2000548:	dfc00117 	ldw	ra,4(sp)
 200054c:	df000017 	ldw	fp,0(sp)
 2000550:	dec00204 	addi	sp,sp,8
 2000554:	f800283a 	ret

02000558 <LinkCallback>:

static void LinkCallback(struct netif* netif)
{
 2000558:	defffd04 	addi	sp,sp,-12
 200055c:	dfc00215 	stw	ra,8(sp)
 2000560:	df000115 	stw	fp,4(sp)
 2000564:	df000104 	addi	fp,sp,4
 2000568:	e13fff15 	stw	r4,-4(fp)
	// link change callback
	// TODO release semaphore
	// TODO switch context

	alt_printf("[ethernet] Link Callback for interface: %s\n", netif->name);
 200056c:	e0bfff17 	ldw	r2,-4(fp)
 2000570:	10800e84 	addi	r2,r2,58
 2000574:	100b883a 	mov	r5,r2
 2000578:	01008134 	movhi	r4,516
 200057c:	2102bf04 	addi	r4,r4,2812
 2000580:	2012e080 	call	2012e08 <alt_printf>
}
 2000584:	0001883a 	nop
 2000588:	e037883a 	mov	sp,fp
 200058c:	dfc00117 	ldw	ra,4(sp)
 2000590:	df000017 	ldw	fp,0(sp)
 2000594:	dec00204 	addi	sp,sp,8
 2000598:	f800283a 	ret

0200059c <InitNetwork>:

int InitNetwork(void)
{
 200059c:	defffe04 	addi	sp,sp,-8
 20005a0:	dfc00115 	stw	ra,4(sp)
 20005a4:	df000015 	stw	fp,0(sp)
 20005a8:	d839883a 	mov	fp,sp
	// register new DHCP "IP attained" callback function.
	// if DHCP is acquired, ws_ipset will be called instead of dhc_main_ipset().
	lwip_set_status_callback(StatusCallback);
 20005ac:	01008034 	movhi	r4,512
 20005b0:	21012a04 	addi	r4,r4,1192
 20005b4:	2013bc00 	call	2013bc0 <lwip_set_status_callback>
	lwip_set_link_callback(LinkCallback);
 20005b8:	01008034 	movhi	r4,512
 20005bc:	21015604 	addi	r4,r4,1368
 20005c0:	2013bf40 	call	2013bf4 <lwip_set_link_callback>

	// Initialize LwIP TCP/IP stack.
	// This function is blocking till the the interface is up.
	lwip_initialize(1);
 20005c4:	01000044 	movi	r4,1
 20005c8:	20137100 	call	2013710 <lwip_initialize>

	return EXIT_SUCCESS;
 20005cc:	0005883a 	mov	r2,zero
}
 20005d0:	e037883a 	mov	sp,fp
 20005d4:	dfc00117 	ldw	ra,4(sp)
 20005d8:	df000017 	ldw	fp,0(sp)
 20005dc:	dec00204 	addi	sp,sp,8
 20005e0:	f800283a 	ret

020005e4 <WaitOnPHY>:

static int WaitOnPHY(void)
{
 20005e4:	defff904 	addi	sp,sp,-28
 20005e8:	dfc00615 	stw	ra,24(sp)
 20005ec:	df000515 	stw	fp,20(sp)
 20005f0:	df000504 	addi	fp,sp,20
	int phyadd;
	int phyid;
	int phyid2 = 0;
 20005f4:	e03ffd15 	stw	zero,-12(fp)

	np_tse_mac* pmac;
	bool bInitialized = false;
 20005f8:	e03fff05 	stb	zero,-4(fp)

	while (!bInitialized) {
 20005fc:	00003606 	br	20006d8 <WaitOnPHY+0xf4>
		alt_printf("[ethernet] PHY INFO: Interface: %d Waiting for PHY\n", 0);
 2000600:	000b883a 	mov	r5,zero
 2000604:	01008134 	movhi	r4,516
 2000608:	2102ca04 	addi	r4,r4,2856
 200060c:	2012e080 	call	2012e08 <alt_printf>

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;
 2000610:	00810034 	movhi	r2,1024
 2000614:	10880004 	addi	r2,r2,8192
 2000618:	e0bffe15 	stw	r2,-8(fp)


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 200061c:	e03ffb15 	stw	zero,-20(fp)
 2000620:	00001a06 	br	200068c <WaitOnPHY+0xa8>
			IOWR(&pmac->MDIO_ADDR0, 0, phyadd);
 2000624:	e0bffe17 	ldw	r2,-8(fp)
 2000628:	10800f04 	addi	r2,r2,60
 200062c:	e0fffb17 	ldw	r3,-20(fp)
 2000630:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->MDIO_IFACE.PHY_ID1, 0);
 2000634:	e0bffe17 	ldw	r2,-8(fp)
 2000638:	1080a204 	addi	r2,r2,648
 200063c:	10800037 	ldwio	r2,0(r2)
 2000640:	e0bffc15 	stw	r2,-16(fp)
			phyid2 = IORD(&pmac->MDIO_IFACE.PHY_ID2, 0);
 2000644:	e0bffe17 	ldw	r2,-8(fp)
 2000648:	1080a304 	addi	r2,r2,652
 200064c:	10800037 	ldwio	r2,0(r2)
 2000650:	e0bffd15 	stw	r2,-12(fp)

			if (phyid != phyid2) {
 2000654:	e0fffc17 	ldw	r3,-16(fp)
 2000658:	e0bffd17 	ldw	r2,-12(fp)
 200065c:	18800826 	beq	r3,r2,2000680 <WaitOnPHY+0x9c>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
 2000660:	e1fffd17 	ldw	r7,-12(fp)
 2000664:	e1bffc17 	ldw	r6,-16(fp)
 2000668:	e17ffb17 	ldw	r5,-20(fp)
 200066c:	01008134 	movhi	r4,516
 2000670:	2102d704 	addi	r4,r4,2908
 2000674:	2012e080 	call	2012e08 <alt_printf>
				phyadd = 0xff;
 2000678:	00803fc4 	movi	r2,255
 200067c:	e0bffb15 	stw	r2,-20(fp)

		// initialize the structure necessary for "pmac" to function.
		pmac = (np_tse_mac*)TSE_MAC_0_BASE;


		for (phyadd = 0x00; phyadd < 0xff; phyadd++) {
 2000680:	e0bffb17 	ldw	r2,-20(fp)
 2000684:	10800044 	addi	r2,r2,1
 2000688:	e0bffb15 	stw	r2,-20(fp)
 200068c:	e0bffb17 	ldw	r2,-20(fp)
 2000690:	10803fd0 	cmplti	r2,r2,255
 2000694:	103fe31e 	bne	r2,zero,2000624 <__alt_mem_mem_0+0xfcfe0624>
				alt_printf("[ethernet] PHY INFO: [PHY ID] 0x%x %x %x\n", phyadd, phyid, phyid2);
				phyadd = 0xff;
			}
		}

		if ((phyadd == 0xff) && (phyid == phyid2)) {
 2000698:	e0bffb17 	ldw	r2,-20(fp)
 200069c:	10803fd8 	cmpnei	r2,r2,255
 20006a0:	10000b1e 	bne	r2,zero,20006d0 <WaitOnPHY+0xec>
 20006a4:	e0fffc17 	ldw	r3,-16(fp)
 20006a8:	e0bffd17 	ldw	r2,-12(fp)
 20006ac:	1880081e 	bne	r3,r2,20006d0 <WaitOnPHY+0xec>
			alt_printf("[ethernet] PHY INFO: No PHY found... restart detect\n");
 20006b0:	01008134 	movhi	r4,516
 20006b4:	2102e204 	addi	r4,r4,2952
 20006b8:	2012e080 	call	2012e08 <alt_printf>
			bInitialized = true;
 20006bc:	00800044 	movi	r2,1
 20006c0:	e0bfff05 	stb	r2,-4(fp)
			mssleep(1000);
 20006c4:	0100fa04 	movi	r4,1000
 20006c8:	200f2640 	call	200f264 <vTaskDelay>
 20006cc:	00000206 	br	20006d8 <WaitOnPHY+0xf4>
		}
		else
			bInitialized = true;
 20006d0:	00800044 	movi	r2,1
 20006d4:	e0bfff05 	stb	r2,-4(fp)
	int phyid2 = 0;

	np_tse_mac* pmac;
	bool bInitialized = false;

	while (!bInitialized) {
 20006d8:	e0bfff03 	ldbu	r2,-4(fp)
 20006dc:	1080005c 	xori	r2,r2,1
 20006e0:	10803fcc 	andi	r2,r2,255
 20006e4:	103fc61e 	bne	r2,zero,2000600 <__alt_mem_mem_0+0xfcfe0600>
		else
			bInitialized = true;
	}

	// issue a PHY reset.
	IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 20006e8:	e0bffe17 	ldw	r2,-8(fp)
 20006ec:	1080a004 	addi	r2,r2,640
 20006f0:	00e40014 	movui	r3,36864
 20006f4:	10c00035 	stwio	r3,0(r2)
	if (((IORD(&pmac->MDIO_IFACE.CONTROL, 0) & PCS_CTL_rx_slpbk) != 0) || ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)) {
 20006f8:	e0bffe17 	ldw	r2,-8(fp)
 20006fc:	1080a004 	addi	r2,r2,640
 2000700:	10800037 	ldwio	r2,0(r2)
 2000704:	1090000c 	andi	r2,r2,16384
 2000708:	1000051e 	bne	r2,zero,2000720 <WaitOnPHY+0x13c>
 200070c:	e0bffe17 	ldw	r2,-8(fp)
 2000710:	1080a104 	addi	r2,r2,644
 2000714:	10800037 	ldwio	r2,0(r2)
 2000718:	1080080c 	andi	r2,r2,32
 200071c:	1000071e 	bne	r2,zero,200073c <WaitOnPHY+0x158>
		IOWR(&pmac->MDIO_IFACE.CONTROL, 0, PCS_CTL_an_enable | PCS_CTL_sw_reset);
 2000720:	e0bffe17 	ldw	r2,-8(fp)
 2000724:	1080a004 	addi	r2,r2,640
 2000728:	00e40014 	movui	r3,36864
 200072c:	10c00035 	stwio	r3,0(r2)
		alt_printf("[ethernet] PHY INFO: Issuing PHY Reset\n");
 2000730:	01008134 	movhi	r4,516
 2000734:	2102f004 	addi	r4,r4,3008
 2000738:	2012e080 	call	2012e08 <alt_printf>
	}

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
 200073c:	e0bffe17 	ldw	r2,-8(fp)
 2000740:	1080a104 	addi	r2,r2,644
 2000744:	10800037 	ldwio	r2,0(r2)
 2000748:	1080080c 	andi	r2,r2,32
 200074c:	1000101e 	bne	r2,zero,2000790 <WaitOnPHY+0x1ac>
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");
 2000750:	01008134 	movhi	r4,516
 2000754:	2102fa04 	addi	r4,r4,3048
 2000758:	2012e080 	call	2012e08 <alt_printf>

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 200075c:	00000206 	br	2000768 <WaitOnPHY+0x184>
			mssleep(10);
 2000760:	01000284 	movi	r4,10
 2000764:	200f2640 	call	200f264 <vTaskDelay>

	// holding pattern until autonegotiation completes.
	if ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0) {
		alt_printf("[ethernet] PHY INFO: Waiting on PHY link...\n");

		while ((IORD(&pmac->MDIO_IFACE.STATUS, 0) & PCS_ST_an_done) == 0)
 2000768:	e0bffe17 	ldw	r2,-8(fp)
 200076c:	1080a104 	addi	r2,r2,644
 2000770:	10800037 	ldwio	r2,0(r2)
 2000774:	1080080c 	andi	r2,r2,32
 2000778:	103ff926 	beq	r2,zero,2000760 <__alt_mem_mem_0+0xfcfe0760>
			mssleep(10);

		alt_printf("[ethernet] PHY INFO: PHY link detected, allowing network to start.\n");
 200077c:	01008134 	movhi	r4,516
 2000780:	21030604 	addi	r4,r4,3096
 2000784:	2012e080 	call	2012e08 <alt_printf>
		
		mssleep(1000);
 2000788:	0100fa04 	movi	r4,1000
 200078c:	200f2640 	call	200f264 <vTaskDelay>
	}

	mssleep(10);
 2000790:	01000284 	movi	r4,10
 2000794:	200f2640 	call	200f264 <vTaskDelay>

	return 0;
 2000798:	0005883a 	mov	r2,zero
}
 200079c:	e037883a 	mov	sp,fp
 20007a0:	dfc00117 	ldw	ra,4(sp)
 20007a4:	df000017 	ldw	fp,0(sp)
 20007a8:	dec00204 	addi	sp,sp,8
 20007ac:	f800283a 	ret

020007b0 <xEthernetRun>:


void xEthernetRun()
{
 20007b0:	defffd04 	addi	sp,sp,-12
 20007b4:	dfc00215 	stw	ra,8(sp)
 20007b8:	df000115 	stw	fp,4(sp)
 20007bc:	df000104 	addi	fp,sp,4
    alt_printf("--------- Init Network ---------\r\n");
 20007c0:	01008134 	movhi	r4,516
 20007c4:	21031704 	addi	r4,r4,3164
 20007c8:	2012e080 	call	2012e08 <alt_printf>

	// initialize PHY
	WaitOnPHY();
 20007cc:	20005e40 	call	20005e4 <WaitOnPHY>

	if (InitNetwork() != EXIT_SUCCESS) {
 20007d0:	200059c0 	call	200059c <InitNetwork>
 20007d4:	10000326 	beq	r2,zero,20007e4 <xEthernetRun+0x34>
		// the network initialization has failed.
		alt_printf("[ethernet] Network initialize failed!\n");
 20007d8:	01008134 	movhi	r4,516
 20007dc:	21032004 	addi	r4,r4,3200
 20007e0:	2012e080 	call	2012e08 <alt_printf>
	}

    nw_ready = 1;
 20007e4:	00800044 	movi	r2,1
 20007e8:	d0a7c415 	stw	r2,-24816(gp)
	alt_printf("--------- Init Done ---------\r\n");
 20007ec:	01008134 	movhi	r4,516
 20007f0:	21032a04 	addi	r4,r4,3240
 20007f4:	2012e080 	call	2012e08 <alt_printf>
    /*sys_thread_new("ping", PingThread, NULL,
    		THREAD_STACKSIZE,
            DEFAULT_THREAD_PRIO);*/

	struct netif* ethif;
	ethif = get_netif(0);
 20007f8:	0009883a 	mov	r4,zero
 20007fc:	2013b780 	call	2013b78 <get_netif>
 2000800:	e0bfff15 	stw	r2,-4(fp)

	IP4_ADDR(&PingIp, 192, 168, 1, 100);
 2000804:	009900b4 	movhi	r2,25602
 2000808:	10aa3004 	addi	r2,r2,-22336
 200080c:	d0a7c615 	stw	r2,-24808(gp)
	while(1) {

        //lwip_ping_target(PingIp.addr, 1, 0, 100);
		// sleep for 1 second
		//lwip_ping_target(PingIp.addr, 10, 0, 100);
        ethernetif_input(ethif);
 2000810:	e13fff17 	ldw	r4,-4(fp)
 2000814:	20134640 	call	2013464 <ethernetif_input>
        vTaskDelay(10);
 2000818:	01000284 	movi	r4,10
 200081c:	200f2640 	call	200f264 <vTaskDelay>
	}
 2000820:	003ffb06 	br	2000810 <__alt_mem_mem_0+0xfcfe0810>

02000824 <get_mac_addr>:
    //vTaskDelete(NULL);
}

// callback wrapper for lwip to get the interface configurations
int get_mac_addr(int iface, struct netif* ethif, unsigned char mac_addr[6])
{
 2000824:	defff704 	addi	sp,sp,-36
 2000828:	dfc00815 	stw	ra,32(sp)
 200082c:	df000715 	stw	fp,28(sp)
 2000830:	df000704 	addi	fp,sp,28
 2000834:	e13ffd15 	stw	r4,-12(fp)
 2000838:	e17ffe15 	stw	r5,-8(fp)
 200083c:	e1bfff15 	stw	r6,-4(fp)
	mac_addr[0] = 0x12;
 2000840:	e0bfff17 	ldw	r2,-4(fp)
 2000844:	00c00484 	movi	r3,18
 2000848:	10c00005 	stb	r3,0(r2)
	mac_addr[1] = 0x23;
 200084c:	e0bfff17 	ldw	r2,-4(fp)
 2000850:	10800044 	addi	r2,r2,1
 2000854:	00c008c4 	movi	r3,35
 2000858:	10c00005 	stb	r3,0(r2)
	mac_addr[2] = 0x45;
 200085c:	e0bfff17 	ldw	r2,-4(fp)
 2000860:	10800084 	addi	r2,r2,2
 2000864:	00c01144 	movi	r3,69
 2000868:	10c00005 	stb	r3,0(r2)
	mac_addr[3] = 0xFF;
 200086c:	e0bfff17 	ldw	r2,-4(fp)
 2000870:	108000c4 	addi	r2,r2,3
 2000874:	00ffffc4 	movi	r3,-1
 2000878:	10c00005 	stb	r3,0(r2)
	mac_addr[4] = 0xFF;
 200087c:	e0bfff17 	ldw	r2,-4(fp)
 2000880:	10800104 	addi	r2,r2,4
 2000884:	00ffffc4 	movi	r3,-1
 2000888:	10c00005 	stb	r3,0(r2)
	mac_addr[5] = 0xF0 + iface;
 200088c:	e0bfff17 	ldw	r2,-4(fp)
 2000890:	10800144 	addi	r2,r2,5
 2000894:	e0fffd17 	ldw	r3,-12(fp)
 2000898:	18fffc04 	addi	r3,r3,-16
 200089c:	10c00005 	stb	r3,0(r2)

	// only show info if net is not NULL
	if (ethif)
 20008a0:	e0bffe17 	ldw	r2,-8(fp)
 20008a4:	10002026 	beq	r2,zero,2000928 <get_mac_addr+0x104>
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008a8:	e0bfff17 	ldw	r2,-4(fp)
 20008ac:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20008b0:	12003fcc 	andi	r8,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008b4:	e0bfff17 	ldw	r2,-4(fp)
 20008b8:	10800044 	addi	r2,r2,1
 20008bc:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20008c0:	11803fcc 	andi	r6,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008c4:	e0bfff17 	ldw	r2,-4(fp)
 20008c8:	10800084 	addi	r2,r2,2
 20008cc:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20008d0:	11c03fcc 	andi	r7,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008d4:	e0bfff17 	ldw	r2,-4(fp)
 20008d8:	108000c4 	addi	r2,r2,3
 20008dc:	10800003 	ldbu	r2,0(r2)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20008e0:	10803fcc 	andi	r2,r2,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008e4:	e0ffff17 	ldw	r3,-4(fp)
 20008e8:	18c00104 	addi	r3,r3,4
 20008ec:	18c00003 	ldbu	r3,0(r3)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 20008f0:	18c03fcc 	andi	r3,r3,255
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);
 20008f4:	e13fff17 	ldw	r4,-4(fp)
 20008f8:	21000144 	addi	r4,r4,5
 20008fc:	21000003 	ldbu	r4,0(r4)
	mac_addr[4] = 0xFF;
	mac_addr[5] = 0xF0 + iface;

	// only show info if net is not NULL
	if (ethif)
		printf("[ethernet] Using Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x for interface: %d\n",
 2000900:	21003fcc 	andi	r4,r4,255
 2000904:	e17ffd17 	ldw	r5,-12(fp)
 2000908:	d9400315 	stw	r5,12(sp)
 200090c:	d9000215 	stw	r4,8(sp)
 2000910:	d8c00115 	stw	r3,4(sp)
 2000914:	d8800015 	stw	r2,0(sp)
 2000918:	400b883a 	mov	r5,r8
 200091c:	01008134 	movhi	r4,516
 2000920:	21033204 	addi	r4,r4,3272
 2000924:	2000bb00 	call	2000bb0 <printf>
				mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5], iface);

	return EXIT_SUCCESS;
 2000928:	0005883a 	mov	r2,zero
}
 200092c:	e037883a 	mov	sp,fp
 2000930:	dfc00117 	ldw	ra,4(sp)
 2000934:	df000017 	ldw	fp,0(sp)
 2000938:	dec00204 	addi	sp,sp,8
 200093c:	f800283a 	ret

02000940 <get_ip_addr>:

// callback wrapper for lwip to get the IP configurations
int get_ip_addr(int iface, ip_addr_t* ipaddr, ip_addr_t* netmask, ip_addr_t* gw, int* use_dhcp)
{
 2000940:	deffba04 	addi	sp,sp,-280
 2000944:	dfc04515 	stw	ra,276(sp)
 2000948:	df004415 	stw	fp,272(sp)
 200094c:	df004404 	addi	fp,sp,272
 2000950:	e13ffc15 	stw	r4,-16(fp)
 2000954:	e17ffd15 	stw	r5,-12(fp)
 2000958:	e1bffe15 	stw	r6,-8(fp)
 200095c:	e1ffff15 	stw	r7,-4(fp)
	// set configuration
	IP4_ADDR(ipaddr, 192, 168, 1, 218);
 2000960:	e0fffd17 	ldw	r3,-12(fp)
 2000964:	00b680b4 	movhi	r2,55810
 2000968:	10aa3004 	addi	r2,r2,-22336
 200096c:	18800015 	stw	r2,0(r3)
	IP4_ADDR(netmask, 255, 255, 255, 0);
 2000970:	e0fffe17 	ldw	r3,-8(fp)
 2000974:	00804034 	movhi	r2,256
 2000978:	10bfffc4 	addi	r2,r2,-1
 200097c:	18800015 	stw	r2,0(r3)
	IP4_ADDR(gw, 192, 168, 1, 1);
 2000980:	e0ffff17 	ldw	r3,-4(fp)
 2000984:	008040b4 	movhi	r2,258
 2000988:	10aa3004 	addi	r2,r2,-22336
 200098c:	18800015 	stw	r2,0(r3)
	*use_dhcp = 0;
 2000990:	e0800217 	ldw	r2,8(fp)
 2000994:	10000015 	stw	zero,0(r2)

	if (*use_dhcp == 0){
 2000998:	e0800217 	ldw	r2,8(fp)
 200099c:	10800017 	ldw	r2,0(r2)
 20009a0:	10000b1e 	bne	r2,zero,20009d0 <get_ip_addr+0x90>
		char buf[255];
		print_ipad(ipaddr->addr, buf);
 20009a4:	e0bffd17 	ldw	r2,-12(fp)
 20009a8:	10800017 	ldw	r2,0(r2)
 20009ac:	e17fbc04 	addi	r5,fp,-272
 20009b0:	1009883a 	mov	r4,r2
 20009b4:	2013dec0 	call	2013dec <print_ipad>
		printf("[ethernet] Static IP Address for interface %d %s\n", iface, buf);
 20009b8:	e1bfbc04 	addi	r6,fp,-272
 20009bc:	e17ffc17 	ldw	r5,-16(fp)
 20009c0:	01008134 	movhi	r4,516
 20009c4:	21034804 	addi	r4,r4,3360
 20009c8:	2000bb00 	call	2000bb0 <printf>
 20009cc:	00000406 	br	20009e0 <get_ip_addr+0xa0>
	}
	else
		printf("[ethernet] Starting get IP via DHCP for interface %d\n", iface);
 20009d0:	e17ffc17 	ldw	r5,-16(fp)
 20009d4:	01008134 	movhi	r4,516
 20009d8:	21035504 	addi	r4,r4,3412
 20009dc:	2000bb00 	call	2000bb0 <printf>

	return EXIT_SUCCESS;
 20009e0:	0005883a 	mov	r2,zero
}
 20009e4:	e037883a 	mov	sp,fp
 20009e8:	dfc00117 	ldw	ra,4(sp)
 20009ec:	df000017 	ldw	fp,0(sp)
 20009f0:	dec00204 	addi	sp,sp,8
 20009f4:	f800283a 	ret

020009f8 <get_hostname>:

int get_hostname(int iface, const char **hostname)
{
 20009f8:	defffd04 	addi	sp,sp,-12
 20009fc:	df000215 	stw	fp,8(sp)
 2000a00:	df000204 	addi	fp,sp,8
 2000a04:	e13ffe15 	stw	r4,-8(fp)
 2000a08:	e17fff15 	stw	r5,-4(fp)
	*hostname = "LwIP";
 2000a0c:	e0ffff17 	ldw	r3,-4(fp)
 2000a10:	00808134 	movhi	r2,516
 2000a14:	10836304 	addi	r2,r2,3468
 2000a18:	18800015 	stw	r2,0(r3)

	return ERR_OK;
 2000a1c:	0005883a 	mov	r2,zero
}
 2000a20:	e037883a 	mov	sp,fp
 2000a24:	df000017 	ldw	fp,0(sp)
 2000a28:	dec00104 	addi	sp,sp,4
 2000a2c:	f800283a 	ret

02000a30 <get_iface_name>:

int get_iface_name(int iface, char name[ETH_IFACE_NAME_LENGTH])
{
 2000a30:	defffd04 	addi	sp,sp,-12
 2000a34:	df000215 	stw	fp,8(sp)
 2000a38:	df000204 	addi	fp,sp,8
 2000a3c:	e13ffe15 	stw	r4,-8(fp)
 2000a40:	e17fff15 	stw	r5,-4(fp)
	name[0] = 'e';
 2000a44:	e0bfff17 	ldw	r2,-4(fp)
 2000a48:	00c01944 	movi	r3,101
 2000a4c:	10c00005 	stb	r3,0(r2)
	name[1] = (iface + 0x30);
 2000a50:	e0bfff17 	ldw	r2,-4(fp)
 2000a54:	10800044 	addi	r2,r2,1
 2000a58:	e0fffe17 	ldw	r3,-8(fp)
 2000a5c:	18c00c04 	addi	r3,r3,48
 2000a60:	10c00005 	stb	r3,0(r2)

	return ERR_OK;
 2000a64:	0005883a 	mov	r2,zero
}
 2000a68:	e037883a 	mov	sp,fp
 2000a6c:	df000017 	ldw	fp,0(sp)
 2000a70:	dec00104 	addi	sp,sp,4
 2000a74:	f800283a 	ret

02000a78 <is_interface_active>:

int is_interface_active(int iface)
{
 2000a78:	defffe04 	addi	sp,sp,-8
 2000a7c:	df000115 	stw	fp,4(sp)
 2000a80:	df000104 	addi	fp,sp,4
 2000a84:	e13fff15 	stw	r4,-4(fp)
	return 1;
 2000a88:	00800044 	movi	r2,1
}
 2000a8c:	e037883a 	mov	sp,fp
 2000a90:	df000017 	ldw	fp,0(sp)
 2000a94:	dec00104 	addi	sp,sp,4
 2000a98:	f800283a 	ret

02000a9c <main>:


int main(){
 2000a9c:	defffd04 	addi	sp,sp,-12
 2000aa0:	dfc00215 	stw	ra,8(sp)
 2000aa4:	df000115 	stw	fp,4(sp)
 2000aa8:	df000104 	addi	fp,sp,4
    main_thread_handle = sys_thread_new("main_thrd", (void(*)(void*))main_thread, 0,
 2000aac:	008000c4 	movi	r2,3
 2000ab0:	d8800015 	stw	r2,0(sp)
 2000ab4:	01c40004 	movi	r7,4096
 2000ab8:	000d883a 	mov	r6,zero
 2000abc:	01408034 	movhi	r5,512
 2000ac0:	2942b704 	addi	r5,r5,2780
 2000ac4:	01008134 	movhi	r4,516
 2000ac8:	21036504 	addi	r4,r4,3476
 2000acc:	20155600 	call	2015560 <sys_thread_new>
 2000ad0:	d0a7c515 	stw	r2,-24812(gp)
                    THREAD_STACKSIZE,
					DEFAULT_THREAD_PRIO);
    vTaskStartScheduler();
 2000ad4:	200f98c0 	call	200f98c <vTaskStartScheduler>
    while(1);
 2000ad8:	003fff06 	br	2000ad8 <__alt_mem_mem_0+0xfcfe0ad8>

02000adc <main_thread>:
    return 0;
}


int main_thread(){
 2000adc:	defffd04 	addi	sp,sp,-12
 2000ae0:	dfc00215 	stw	ra,8(sp)
 2000ae4:	df000115 	stw	fp,4(sp)
 2000ae8:	df000104 	addi	fp,sp,4
	alt_printf("------------------------------------------------------\r\n");
 2000aec:	01008134 	movhi	r4,516
 2000af0:	21036804 	addi	r4,r4,3488
 2000af4:	2012e080 	call	2012e08 <alt_printf>
	alt_printf("--------- Starting OPC UA Server application ---------\r\n");
 2000af8:	01008134 	movhi	r4,516
 2000afc:	21037704 	addi	r4,r4,3548
 2000b00:	2012e080 	call	2012e08 <alt_printf>
	alt_printf("------------------------------------------------------\r\n");
 2000b04:	01008134 	movhi	r4,516
 2000b08:	21036804 	addi	r4,r4,3488
 2000b0c:	2012e080 	call	2012e08 <alt_printf>
	alt_printf("--------- open62541 example created for a    ---------\r\n");
 2000b10:	01008134 	movhi	r4,516
 2000b14:	21038604 	addi	r4,r4,3608
 2000b18:	2012e080 	call	2012e08 <alt_printf>
    alt_printf("--------- MicroBlaze design on a Artix7 FPGA ---------\r\n");
 2000b1c:	01008134 	movhi	r4,516
 2000b20:	21039504 	addi	r4,r4,3668
 2000b24:	2012e080 	call	2012e08 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 2000b28:	01008134 	movhi	r4,516
 2000b2c:	21036804 	addi	r4,r4,3488
 2000b30:	2012e080 	call	2012e08 <alt_printf>
    alt_printf("--------- NetTImeLogic GmbH, Switzerland     ---------\r\n");
 2000b34:	01008134 	movhi	r4,516
 2000b38:	2103a404 	addi	r4,r4,3728
 2000b3c:	2012e080 	call	2012e08 <alt_printf>
    alt_printf("--------- contact@nettimelogic.com           ---------\r\n");
 2000b40:	01008134 	movhi	r4,516
 2000b44:	2103b304 	addi	r4,r4,3788
 2000b48:	2012e080 	call	2012e08 <alt_printf>
    alt_printf("------------------------------------------------------\r\n");
 2000b4c:	01008134 	movhi	r4,516
 2000b50:	21036804 	addi	r4,r4,3488
 2000b54:	2012e080 	call	2012e08 <alt_printf>

	//xTaskCreate(xEthernetRun, "eth0", KB(4), NULL, tskIDLE_PRIORITY + 2, NULL);

	sys_thread_new("NetworkInit", xEthernetRun, NULL,
 2000b58:	008000c4 	movi	r2,3
 2000b5c:	d8800015 	stw	r2,0(sp)
 2000b60:	01c40004 	movi	r7,4096
 2000b64:	000d883a 	mov	r6,zero
 2000b68:	01408034 	movhi	r5,512
 2000b6c:	2941ec04 	addi	r5,r5,1968
 2000b70:	01008134 	movhi	r4,516
 2000b74:	2103c204 	addi	r4,r4,3848
 2000b78:	20155600 	call	2015560 <sys_thread_new>
            DEFAULT_THREAD_PRIO);



    //vTaskStartScheduler();
    while(1);
 2000b7c:	003fff06 	br	2000b7c <__alt_mem_mem_0+0xfcfe0b7c>

02000b80 <_printf_r>:
 2000b80:	defffd04 	addi	sp,sp,-12
 2000b84:	2805883a 	mov	r2,r5
 2000b88:	dfc00015 	stw	ra,0(sp)
 2000b8c:	d9800115 	stw	r6,4(sp)
 2000b90:	d9c00215 	stw	r7,8(sp)
 2000b94:	21400217 	ldw	r5,8(r4)
 2000b98:	d9c00104 	addi	r7,sp,4
 2000b9c:	100d883a 	mov	r6,r2
 2000ba0:	2000bec0 	call	2000bec <___vfprintf_internal_r>
 2000ba4:	dfc00017 	ldw	ra,0(sp)
 2000ba8:	dec00304 	addi	sp,sp,12
 2000bac:	f800283a 	ret

02000bb0 <printf>:
 2000bb0:	defffc04 	addi	sp,sp,-16
 2000bb4:	dfc00015 	stw	ra,0(sp)
 2000bb8:	d9400115 	stw	r5,4(sp)
 2000bbc:	d9800215 	stw	r6,8(sp)
 2000bc0:	d9c00315 	stw	r7,12(sp)
 2000bc4:	00808134 	movhi	r2,516
 2000bc8:	10963d04 	addi	r2,r2,22772
 2000bcc:	10800017 	ldw	r2,0(r2)
 2000bd0:	200b883a 	mov	r5,r4
 2000bd4:	d9800104 	addi	r6,sp,4
 2000bd8:	11000217 	ldw	r4,8(r2)
 2000bdc:	2002de40 	call	2002de4 <__vfprintf_internal>
 2000be0:	dfc00017 	ldw	ra,0(sp)
 2000be4:	dec00404 	addi	sp,sp,16
 2000be8:	f800283a 	ret

02000bec <___vfprintf_internal_r>:
 2000bec:	deffb804 	addi	sp,sp,-288
 2000bf0:	dfc04715 	stw	ra,284(sp)
 2000bf4:	ddc04515 	stw	r23,276(sp)
 2000bf8:	dd404315 	stw	r21,268(sp)
 2000bfc:	d9002c15 	stw	r4,176(sp)
 2000c00:	282f883a 	mov	r23,r5
 2000c04:	302b883a 	mov	r21,r6
 2000c08:	d9c02d15 	stw	r7,180(sp)
 2000c0c:	df004615 	stw	fp,280(sp)
 2000c10:	dd804415 	stw	r22,272(sp)
 2000c14:	dd004215 	stw	r20,264(sp)
 2000c18:	dcc04115 	stw	r19,260(sp)
 2000c1c:	dc804015 	stw	r18,256(sp)
 2000c20:	dc403f15 	stw	r17,252(sp)
 2000c24:	dc003e15 	stw	r16,248(sp)
 2000c28:	20055480 	call	2005548 <_localeconv_r>
 2000c2c:	10800017 	ldw	r2,0(r2)
 2000c30:	1009883a 	mov	r4,r2
 2000c34:	d8803415 	stw	r2,208(sp)
 2000c38:	20075700 	call	2007570 <strlen>
 2000c3c:	d8803715 	stw	r2,220(sp)
 2000c40:	d8802c17 	ldw	r2,176(sp)
 2000c44:	10000226 	beq	r2,zero,2000c50 <___vfprintf_internal_r+0x64>
 2000c48:	10800e17 	ldw	r2,56(r2)
 2000c4c:	1000f926 	beq	r2,zero,2001034 <___vfprintf_internal_r+0x448>
 2000c50:	b880030b 	ldhu	r2,12(r23)
 2000c54:	10c8000c 	andi	r3,r2,8192
 2000c58:	1800061e 	bne	r3,zero,2000c74 <___vfprintf_internal_r+0x88>
 2000c5c:	b9001917 	ldw	r4,100(r23)
 2000c60:	00f7ffc4 	movi	r3,-8193
 2000c64:	10880014 	ori	r2,r2,8192
 2000c68:	20c6703a 	and	r3,r4,r3
 2000c6c:	b880030d 	sth	r2,12(r23)
 2000c70:	b8c01915 	stw	r3,100(r23)
 2000c74:	10c0020c 	andi	r3,r2,8
 2000c78:	1800c126 	beq	r3,zero,2000f80 <___vfprintf_internal_r+0x394>
 2000c7c:	b8c00417 	ldw	r3,16(r23)
 2000c80:	1800bf26 	beq	r3,zero,2000f80 <___vfprintf_internal_r+0x394>
 2000c84:	1080068c 	andi	r2,r2,26
 2000c88:	00c00284 	movi	r3,10
 2000c8c:	10c0c426 	beq	r2,r3,2000fa0 <___vfprintf_internal_r+0x3b4>
 2000c90:	d8c00404 	addi	r3,sp,16
 2000c94:	05008134 	movhi	r20,516
 2000c98:	d9001e04 	addi	r4,sp,120
 2000c9c:	a503d584 	addi	r20,r20,3926
 2000ca0:	d8c01e15 	stw	r3,120(sp)
 2000ca4:	d8002015 	stw	zero,128(sp)
 2000ca8:	d8001f15 	stw	zero,124(sp)
 2000cac:	d8003315 	stw	zero,204(sp)
 2000cb0:	d8003615 	stw	zero,216(sp)
 2000cb4:	d8003815 	stw	zero,224(sp)
 2000cb8:	1811883a 	mov	r8,r3
 2000cbc:	d8003915 	stw	zero,228(sp)
 2000cc0:	d8003a15 	stw	zero,232(sp)
 2000cc4:	d8002f15 	stw	zero,188(sp)
 2000cc8:	d9002815 	stw	r4,160(sp)
 2000ccc:	a8800007 	ldb	r2,0(r21)
 2000cd0:	10027b26 	beq	r2,zero,20016c0 <___vfprintf_internal_r+0xad4>
 2000cd4:	00c00944 	movi	r3,37
 2000cd8:	a821883a 	mov	r16,r21
 2000cdc:	10c0021e 	bne	r2,r3,2000ce8 <___vfprintf_internal_r+0xfc>
 2000ce0:	00001406 	br	2000d34 <___vfprintf_internal_r+0x148>
 2000ce4:	10c00326 	beq	r2,r3,2000cf4 <___vfprintf_internal_r+0x108>
 2000ce8:	84000044 	addi	r16,r16,1
 2000cec:	80800007 	ldb	r2,0(r16)
 2000cf0:	103ffc1e 	bne	r2,zero,2000ce4 <__alt_mem_mem_0+0xfcfe0ce4>
 2000cf4:	8563c83a 	sub	r17,r16,r21
 2000cf8:	88000e26 	beq	r17,zero,2000d34 <___vfprintf_internal_r+0x148>
 2000cfc:	d8c02017 	ldw	r3,128(sp)
 2000d00:	d8801f17 	ldw	r2,124(sp)
 2000d04:	45400015 	stw	r21,0(r8)
 2000d08:	1c47883a 	add	r3,r3,r17
 2000d0c:	10800044 	addi	r2,r2,1
 2000d10:	d8c02015 	stw	r3,128(sp)
 2000d14:	44400115 	stw	r17,4(r8)
 2000d18:	d8801f15 	stw	r2,124(sp)
 2000d1c:	00c001c4 	movi	r3,7
 2000d20:	1880a716 	blt	r3,r2,2000fc0 <___vfprintf_internal_r+0x3d4>
 2000d24:	42000204 	addi	r8,r8,8
 2000d28:	d9402f17 	ldw	r5,188(sp)
 2000d2c:	2c4b883a 	add	r5,r5,r17
 2000d30:	d9402f15 	stw	r5,188(sp)
 2000d34:	80800007 	ldb	r2,0(r16)
 2000d38:	1000a826 	beq	r2,zero,2000fdc <___vfprintf_internal_r+0x3f0>
 2000d3c:	84400047 	ldb	r17,1(r16)
 2000d40:	00bfffc4 	movi	r2,-1
 2000d44:	85400044 	addi	r21,r16,1
 2000d48:	d8002785 	stb	zero,158(sp)
 2000d4c:	0007883a 	mov	r3,zero
 2000d50:	000f883a 	mov	r7,zero
 2000d54:	d8802915 	stw	r2,164(sp)
 2000d58:	d8003115 	stw	zero,196(sp)
 2000d5c:	0025883a 	mov	r18,zero
 2000d60:	01401604 	movi	r5,88
 2000d64:	01800244 	movi	r6,9
 2000d68:	02800a84 	movi	r10,42
 2000d6c:	02401b04 	movi	r9,108
 2000d70:	ad400044 	addi	r21,r21,1
 2000d74:	88bff804 	addi	r2,r17,-32
 2000d78:	28830436 	bltu	r5,r2,200198c <___vfprintf_internal_r+0xda0>
 2000d7c:	100490ba 	slli	r2,r2,2
 2000d80:	01008034 	movhi	r4,512
 2000d84:	21036504 	addi	r4,r4,3476
 2000d88:	1105883a 	add	r2,r2,r4
 2000d8c:	10800017 	ldw	r2,0(r2)
 2000d90:	1000683a 	jmp	r2
 2000d94:	020018ac 	andhi	r8,zero,98
 2000d98:	0200198c 	andi	r8,zero,102
 2000d9c:	0200198c 	andi	r8,zero,102
 2000da0:	020018cc 	andi	r8,zero,99
 2000da4:	0200198c 	andi	r8,zero,102
 2000da8:	0200198c 	andi	r8,zero,102
 2000dac:	0200198c 	andi	r8,zero,102
 2000db0:	0200198c 	andi	r8,zero,102
 2000db4:	0200198c 	andi	r8,zero,102
 2000db8:	0200198c 	andi	r8,zero,102
 2000dbc:	02001040 	call	200104 <alt_exception_muldiv+0x200104>
 2000dc0:	020017e8 	cmpgeui	r8,zero,95
 2000dc4:	0200198c 	andi	r8,zero,102
 2000dc8:	02000f08 	cmpgei	r8,zero,60
 2000dcc:	02001068 	cmpgeui	r8,zero,65
 2000dd0:	0200198c 	andi	r8,zero,102
 2000dd4:	020010a8 	cmpgeui	r8,zero,66
 2000dd8:	020010b4 	movhi	r8,66
 2000ddc:	020010b4 	movhi	r8,66
 2000de0:	020010b4 	movhi	r8,66
 2000de4:	020010b4 	movhi	r8,66
 2000de8:	020010b4 	movhi	r8,66
 2000dec:	020010b4 	movhi	r8,66
 2000df0:	020010b4 	movhi	r8,66
 2000df4:	020010b4 	movhi	r8,66
 2000df8:	020010b4 	movhi	r8,66
 2000dfc:	0200198c 	andi	r8,zero,102
 2000e00:	0200198c 	andi	r8,zero,102
 2000e04:	0200198c 	andi	r8,zero,102
 2000e08:	0200198c 	andi	r8,zero,102
 2000e0c:	0200198c 	andi	r8,zero,102
 2000e10:	0200198c 	andi	r8,zero,102
 2000e14:	0200198c 	andi	r8,zero,102
 2000e18:	0200198c 	andi	r8,zero,102
 2000e1c:	0200198c 	andi	r8,zero,102
 2000e20:	0200198c 	andi	r8,zero,102
 2000e24:	020010e8 	cmpgeui	r8,zero,67
 2000e28:	020011a4 	muli	r8,zero,70
 2000e2c:	0200198c 	andi	r8,zero,102
 2000e30:	020011a4 	muli	r8,zero,70
 2000e34:	0200198c 	andi	r8,zero,102
 2000e38:	0200198c 	andi	r8,zero,102
 2000e3c:	0200198c 	andi	r8,zero,102
 2000e40:	0200198c 	andi	r8,zero,102
 2000e44:	02001244 	movi	r8,73
 2000e48:	0200198c 	andi	r8,zero,102
 2000e4c:	0200198c 	andi	r8,zero,102
 2000e50:	02001250 	cmplti	r8,zero,73
 2000e54:	0200198c 	andi	r8,zero,102
 2000e58:	0200198c 	andi	r8,zero,102
 2000e5c:	0200198c 	andi	r8,zero,102
 2000e60:	0200198c 	andi	r8,zero,102
 2000e64:	0200198c 	andi	r8,zero,102
 2000e68:	020016c8 	cmpgei	r8,zero,91
 2000e6c:	0200198c 	andi	r8,zero,102
 2000e70:	0200198c 	andi	r8,zero,102
 2000e74:	02001728 	cmpgeui	r8,zero,92
 2000e78:	0200198c 	andi	r8,zero,102
 2000e7c:	0200198c 	andi	r8,zero,102
 2000e80:	0200198c 	andi	r8,zero,102
 2000e84:	0200198c 	andi	r8,zero,102
 2000e88:	0200198c 	andi	r8,zero,102
 2000e8c:	0200198c 	andi	r8,zero,102
 2000e90:	0200198c 	andi	r8,zero,102
 2000e94:	0200198c 	andi	r8,zero,102
 2000e98:	0200198c 	andi	r8,zero,102
 2000e9c:	0200198c 	andi	r8,zero,102
 2000ea0:	02001938 	rdprs	r8,zero,100
 2000ea4:	020018d8 	cmpnei	r8,zero,99
 2000ea8:	020011a4 	muli	r8,zero,70
 2000eac:	020011a4 	muli	r8,zero,70
 2000eb0:	020011a4 	muli	r8,zero,70
 2000eb4:	020018e8 	cmpgeui	r8,zero,99
 2000eb8:	020018d8 	cmpnei	r8,zero,99
 2000ebc:	0200198c 	andi	r8,zero,102
 2000ec0:	0200198c 	andi	r8,zero,102
 2000ec4:	020018f4 	movhi	r8,99
 2000ec8:	0200198c 	andi	r8,zero,102
 2000ecc:	02001904 	movi	r8,100
 2000ed0:	020017d8 	cmpnei	r8,zero,95
 2000ed4:	02000f14 	movui	r8,60
 2000ed8:	020017f8 	rdprs	r8,zero,95
 2000edc:	0200198c 	andi	r8,zero,102
 2000ee0:	02001804 	movi	r8,96
 2000ee4:	0200198c 	andi	r8,zero,102
 2000ee8:	02001860 	cmpeqi	r8,zero,97
 2000eec:	0200198c 	andi	r8,zero,102
 2000ef0:	0200198c 	andi	r8,zero,102
 2000ef4:	02001870 	cmpltui	r8,zero,97
 2000ef8:	d9003117 	ldw	r4,196(sp)
 2000efc:	d8802d15 	stw	r2,180(sp)
 2000f00:	0109c83a 	sub	r4,zero,r4
 2000f04:	d9003115 	stw	r4,196(sp)
 2000f08:	94800114 	ori	r18,r18,4
 2000f0c:	ac400007 	ldb	r17,0(r21)
 2000f10:	003f9706 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2000f14:	00800c04 	movi	r2,48
 2000f18:	d9002d17 	ldw	r4,180(sp)
 2000f1c:	d9402917 	ldw	r5,164(sp)
 2000f20:	d8802705 	stb	r2,156(sp)
 2000f24:	00801e04 	movi	r2,120
 2000f28:	d8802745 	stb	r2,157(sp)
 2000f2c:	d8002785 	stb	zero,158(sp)
 2000f30:	20c00104 	addi	r3,r4,4
 2000f34:	24c00017 	ldw	r19,0(r4)
 2000f38:	002d883a 	mov	r22,zero
 2000f3c:	90800094 	ori	r2,r18,2
 2000f40:	28029a16 	blt	r5,zero,20019ac <___vfprintf_internal_r+0xdc0>
 2000f44:	00bfdfc4 	movi	r2,-129
 2000f48:	90a4703a 	and	r18,r18,r2
 2000f4c:	d8c02d15 	stw	r3,180(sp)
 2000f50:	94800094 	ori	r18,r18,2
 2000f54:	9802871e 	bne	r19,zero,2001974 <___vfprintf_internal_r+0xd88>
 2000f58:	00808134 	movhi	r2,516
 2000f5c:	1083ce04 	addi	r2,r2,3896
 2000f60:	d8803915 	stw	r2,228(sp)
 2000f64:	04401e04 	movi	r17,120
 2000f68:	d8802917 	ldw	r2,164(sp)
 2000f6c:	0039883a 	mov	fp,zero
 2000f70:	1001e926 	beq	r2,zero,2001718 <___vfprintf_internal_r+0xb2c>
 2000f74:	0027883a 	mov	r19,zero
 2000f78:	002d883a 	mov	r22,zero
 2000f7c:	00020506 	br	2001794 <___vfprintf_internal_r+0xba8>
 2000f80:	d9002c17 	ldw	r4,176(sp)
 2000f84:	b80b883a 	mov	r5,r23
 2000f88:	2002ebc0 	call	2002ebc <__swsetup_r>
 2000f8c:	1005ac1e 	bne	r2,zero,2002640 <___vfprintf_internal_r+0x1a54>
 2000f90:	b880030b 	ldhu	r2,12(r23)
 2000f94:	00c00284 	movi	r3,10
 2000f98:	1080068c 	andi	r2,r2,26
 2000f9c:	10ff3c1e 	bne	r2,r3,2000c90 <__alt_mem_mem_0+0xfcfe0c90>
 2000fa0:	b880038f 	ldh	r2,14(r23)
 2000fa4:	103f3a16 	blt	r2,zero,2000c90 <__alt_mem_mem_0+0xfcfe0c90>
 2000fa8:	d9c02d17 	ldw	r7,180(sp)
 2000fac:	d9002c17 	ldw	r4,176(sp)
 2000fb0:	a80d883a 	mov	r6,r21
 2000fb4:	b80b883a 	mov	r5,r23
 2000fb8:	2002e000 	call	2002e00 <__sbprintf>
 2000fbc:	00001106 	br	2001004 <___vfprintf_internal_r+0x418>
 2000fc0:	d9002c17 	ldw	r4,176(sp)
 2000fc4:	d9801e04 	addi	r6,sp,120
 2000fc8:	b80b883a 	mov	r5,r23
 2000fcc:	20077040 	call	2007704 <__sprint_r>
 2000fd0:	1000081e 	bne	r2,zero,2000ff4 <___vfprintf_internal_r+0x408>
 2000fd4:	da000404 	addi	r8,sp,16
 2000fd8:	003f5306 	br	2000d28 <__alt_mem_mem_0+0xfcfe0d28>
 2000fdc:	d8802017 	ldw	r2,128(sp)
 2000fe0:	10000426 	beq	r2,zero,2000ff4 <___vfprintf_internal_r+0x408>
 2000fe4:	d9002c17 	ldw	r4,176(sp)
 2000fe8:	d9801e04 	addi	r6,sp,120
 2000fec:	b80b883a 	mov	r5,r23
 2000ff0:	20077040 	call	2007704 <__sprint_r>
 2000ff4:	b880030b 	ldhu	r2,12(r23)
 2000ff8:	1080100c 	andi	r2,r2,64
 2000ffc:	1005901e 	bne	r2,zero,2002640 <___vfprintf_internal_r+0x1a54>
 2001000:	d8802f17 	ldw	r2,188(sp)
 2001004:	dfc04717 	ldw	ra,284(sp)
 2001008:	df004617 	ldw	fp,280(sp)
 200100c:	ddc04517 	ldw	r23,276(sp)
 2001010:	dd804417 	ldw	r22,272(sp)
 2001014:	dd404317 	ldw	r21,268(sp)
 2001018:	dd004217 	ldw	r20,264(sp)
 200101c:	dcc04117 	ldw	r19,260(sp)
 2001020:	dc804017 	ldw	r18,256(sp)
 2001024:	dc403f17 	ldw	r17,252(sp)
 2001028:	dc003e17 	ldw	r16,248(sp)
 200102c:	dec04804 	addi	sp,sp,288
 2001030:	f800283a 	ret
 2001034:	d9002c17 	ldw	r4,176(sp)
 2001038:	2004e900 	call	2004e90 <__sinit>
 200103c:	003f0406 	br	2000c50 <__alt_mem_mem_0+0xfcfe0c50>
 2001040:	d8802d17 	ldw	r2,180(sp)
 2001044:	d9002d17 	ldw	r4,180(sp)
 2001048:	10800017 	ldw	r2,0(r2)
 200104c:	d8803115 	stw	r2,196(sp)
 2001050:	20800104 	addi	r2,r4,4
 2001054:	d9003117 	ldw	r4,196(sp)
 2001058:	203fa716 	blt	r4,zero,2000ef8 <__alt_mem_mem_0+0xfcfe0ef8>
 200105c:	d8802d15 	stw	r2,180(sp)
 2001060:	ac400007 	ldb	r17,0(r21)
 2001064:	003f4206 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2001068:	ac400007 	ldb	r17,0(r21)
 200106c:	aac00044 	addi	r11,r21,1
 2001070:	8a872826 	beq	r17,r10,2002d14 <___vfprintf_internal_r+0x2128>
 2001074:	88bff404 	addi	r2,r17,-48
 2001078:	0009883a 	mov	r4,zero
 200107c:	30867d36 	bltu	r6,r2,2002a74 <___vfprintf_internal_r+0x1e88>
 2001080:	5c400007 	ldb	r17,0(r11)
 2001084:	210002a4 	muli	r4,r4,10
 2001088:	5d400044 	addi	r21,r11,1
 200108c:	a817883a 	mov	r11,r21
 2001090:	2089883a 	add	r4,r4,r2
 2001094:	88bff404 	addi	r2,r17,-48
 2001098:	30bff92e 	bgeu	r6,r2,2001080 <__alt_mem_mem_0+0xfcfe1080>
 200109c:	2005c916 	blt	r4,zero,20027c4 <___vfprintf_internal_r+0x1bd8>
 20010a0:	d9002915 	stw	r4,164(sp)
 20010a4:	003f3306 	br	2000d74 <__alt_mem_mem_0+0xfcfe0d74>
 20010a8:	94802014 	ori	r18,r18,128
 20010ac:	ac400007 	ldb	r17,0(r21)
 20010b0:	003f2f06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 20010b4:	a809883a 	mov	r4,r21
 20010b8:	d8003115 	stw	zero,196(sp)
 20010bc:	88bff404 	addi	r2,r17,-48
 20010c0:	0017883a 	mov	r11,zero
 20010c4:	24400007 	ldb	r17,0(r4)
 20010c8:	5ac002a4 	muli	r11,r11,10
 20010cc:	ad400044 	addi	r21,r21,1
 20010d0:	a809883a 	mov	r4,r21
 20010d4:	12d7883a 	add	r11,r2,r11
 20010d8:	88bff404 	addi	r2,r17,-48
 20010dc:	30bff92e 	bgeu	r6,r2,20010c4 <__alt_mem_mem_0+0xfcfe10c4>
 20010e0:	dac03115 	stw	r11,196(sp)
 20010e4:	003f2306 	br	2000d74 <__alt_mem_mem_0+0xfcfe0d74>
 20010e8:	18c03fcc 	andi	r3,r3,255
 20010ec:	18072b1e 	bne	r3,zero,2002d9c <___vfprintf_internal_r+0x21b0>
 20010f0:	94800414 	ori	r18,r18,16
 20010f4:	9080080c 	andi	r2,r18,32
 20010f8:	10037b26 	beq	r2,zero,2001ee8 <___vfprintf_internal_r+0x12fc>
 20010fc:	d9402d17 	ldw	r5,180(sp)
 2001100:	28800117 	ldw	r2,4(r5)
 2001104:	2cc00017 	ldw	r19,0(r5)
 2001108:	29400204 	addi	r5,r5,8
 200110c:	d9402d15 	stw	r5,180(sp)
 2001110:	102d883a 	mov	r22,r2
 2001114:	10044b16 	blt	r2,zero,2002244 <___vfprintf_internal_r+0x1658>
 2001118:	d9402917 	ldw	r5,164(sp)
 200111c:	df002783 	ldbu	fp,158(sp)
 2001120:	2803bc16 	blt	r5,zero,2002014 <___vfprintf_internal_r+0x1428>
 2001124:	00ffdfc4 	movi	r3,-129
 2001128:	9d84b03a 	or	r2,r19,r22
 200112c:	90e4703a 	and	r18,r18,r3
 2001130:	10017726 	beq	r2,zero,2001710 <___vfprintf_internal_r+0xb24>
 2001134:	b0038326 	beq	r22,zero,2001f44 <___vfprintf_internal_r+0x1358>
 2001138:	dc402a15 	stw	r17,168(sp)
 200113c:	dc001e04 	addi	r16,sp,120
 2001140:	b023883a 	mov	r17,r22
 2001144:	402d883a 	mov	r22,r8
 2001148:	9809883a 	mov	r4,r19
 200114c:	880b883a 	mov	r5,r17
 2001150:	01800284 	movi	r6,10
 2001154:	000f883a 	mov	r7,zero
 2001158:	200a6780 	call	200a678 <__umoddi3>
 200115c:	10800c04 	addi	r2,r2,48
 2001160:	843fffc4 	addi	r16,r16,-1
 2001164:	9809883a 	mov	r4,r19
 2001168:	880b883a 	mov	r5,r17
 200116c:	80800005 	stb	r2,0(r16)
 2001170:	01800284 	movi	r6,10
 2001174:	000f883a 	mov	r7,zero
 2001178:	200a1000 	call	200a100 <__udivdi3>
 200117c:	1027883a 	mov	r19,r2
 2001180:	10c4b03a 	or	r2,r2,r3
 2001184:	1823883a 	mov	r17,r3
 2001188:	103fef1e 	bne	r2,zero,2001148 <__alt_mem_mem_0+0xfcfe1148>
 200118c:	d8c02817 	ldw	r3,160(sp)
 2001190:	dc402a17 	ldw	r17,168(sp)
 2001194:	b011883a 	mov	r8,r22
 2001198:	1c07c83a 	sub	r3,r3,r16
 200119c:	d8c02e15 	stw	r3,184(sp)
 20011a0:	00005906 	br	2001308 <___vfprintf_internal_r+0x71c>
 20011a4:	18c03fcc 	andi	r3,r3,255
 20011a8:	1806fa1e 	bne	r3,zero,2002d94 <___vfprintf_internal_r+0x21a8>
 20011ac:	9080020c 	andi	r2,r18,8
 20011b0:	10048a26 	beq	r2,zero,20023dc <___vfprintf_internal_r+0x17f0>
 20011b4:	d8c02d17 	ldw	r3,180(sp)
 20011b8:	d9002d17 	ldw	r4,180(sp)
 20011bc:	d9402d17 	ldw	r5,180(sp)
 20011c0:	18c00017 	ldw	r3,0(r3)
 20011c4:	21000117 	ldw	r4,4(r4)
 20011c8:	29400204 	addi	r5,r5,8
 20011cc:	d8c03615 	stw	r3,216(sp)
 20011d0:	d9003815 	stw	r4,224(sp)
 20011d4:	d9402d15 	stw	r5,180(sp)
 20011d8:	d9003617 	ldw	r4,216(sp)
 20011dc:	d9403817 	ldw	r5,224(sp)
 20011e0:	da003d15 	stw	r8,244(sp)
 20011e4:	04000044 	movi	r16,1
 20011e8:	20072900 	call	2007290 <__fpclassifyd>
 20011ec:	da003d17 	ldw	r8,244(sp)
 20011f0:	14041f1e 	bne	r2,r16,2002270 <___vfprintf_internal_r+0x1684>
 20011f4:	d9003617 	ldw	r4,216(sp)
 20011f8:	d9403817 	ldw	r5,224(sp)
 20011fc:	000d883a 	mov	r6,zero
 2001200:	000f883a 	mov	r7,zero
 2001204:	200c05c0 	call	200c05c <__ledf2>
 2001208:	da003d17 	ldw	r8,244(sp)
 200120c:	1005be16 	blt	r2,zero,2002908 <___vfprintf_internal_r+0x1d1c>
 2001210:	df002783 	ldbu	fp,158(sp)
 2001214:	008011c4 	movi	r2,71
 2001218:	1445330e 	bge	r2,r17,20026e8 <___vfprintf_internal_r+0x1afc>
 200121c:	04008134 	movhi	r16,516
 2001220:	8403c604 	addi	r16,r16,3864
 2001224:	00c000c4 	movi	r3,3
 2001228:	00bfdfc4 	movi	r2,-129
 200122c:	d8c02a15 	stw	r3,168(sp)
 2001230:	90a4703a 	and	r18,r18,r2
 2001234:	d8c02e15 	stw	r3,184(sp)
 2001238:	d8002915 	stw	zero,164(sp)
 200123c:	d8003215 	stw	zero,200(sp)
 2001240:	00003706 	br	2001320 <___vfprintf_internal_r+0x734>
 2001244:	94800214 	ori	r18,r18,8
 2001248:	ac400007 	ldb	r17,0(r21)
 200124c:	003ec806 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2001250:	18c03fcc 	andi	r3,r3,255
 2001254:	1806db1e 	bne	r3,zero,2002dc4 <___vfprintf_internal_r+0x21d8>
 2001258:	94800414 	ori	r18,r18,16
 200125c:	9080080c 	andi	r2,r18,32
 2001260:	1002d826 	beq	r2,zero,2001dc4 <___vfprintf_internal_r+0x11d8>
 2001264:	d9402d17 	ldw	r5,180(sp)
 2001268:	d8c02917 	ldw	r3,164(sp)
 200126c:	d8002785 	stb	zero,158(sp)
 2001270:	28800204 	addi	r2,r5,8
 2001274:	2cc00017 	ldw	r19,0(r5)
 2001278:	2d800117 	ldw	r22,4(r5)
 200127c:	18048f16 	blt	r3,zero,20024bc <___vfprintf_internal_r+0x18d0>
 2001280:	013fdfc4 	movi	r4,-129
 2001284:	9d86b03a 	or	r3,r19,r22
 2001288:	d8802d15 	stw	r2,180(sp)
 200128c:	9124703a 	and	r18,r18,r4
 2001290:	1802d91e 	bne	r3,zero,2001df8 <___vfprintf_internal_r+0x120c>
 2001294:	d8c02917 	ldw	r3,164(sp)
 2001298:	0039883a 	mov	fp,zero
 200129c:	1805c326 	beq	r3,zero,20029ac <___vfprintf_internal_r+0x1dc0>
 20012a0:	0027883a 	mov	r19,zero
 20012a4:	002d883a 	mov	r22,zero
 20012a8:	dc001e04 	addi	r16,sp,120
 20012ac:	9806d0fa 	srli	r3,r19,3
 20012b0:	b008977a 	slli	r4,r22,29
 20012b4:	b02cd0fa 	srli	r22,r22,3
 20012b8:	9cc001cc 	andi	r19,r19,7
 20012bc:	98800c04 	addi	r2,r19,48
 20012c0:	843fffc4 	addi	r16,r16,-1
 20012c4:	20e6b03a 	or	r19,r4,r3
 20012c8:	80800005 	stb	r2,0(r16)
 20012cc:	9d86b03a 	or	r3,r19,r22
 20012d0:	183ff61e 	bne	r3,zero,20012ac <__alt_mem_mem_0+0xfcfe12ac>
 20012d4:	90c0004c 	andi	r3,r18,1
 20012d8:	18013b26 	beq	r3,zero,20017c8 <___vfprintf_internal_r+0xbdc>
 20012dc:	10803fcc 	andi	r2,r2,255
 20012e0:	1080201c 	xori	r2,r2,128
 20012e4:	10bfe004 	addi	r2,r2,-128
 20012e8:	00c00c04 	movi	r3,48
 20012ec:	10c13626 	beq	r2,r3,20017c8 <___vfprintf_internal_r+0xbdc>
 20012f0:	80ffffc5 	stb	r3,-1(r16)
 20012f4:	d8c02817 	ldw	r3,160(sp)
 20012f8:	80bfffc4 	addi	r2,r16,-1
 20012fc:	1021883a 	mov	r16,r2
 2001300:	1887c83a 	sub	r3,r3,r2
 2001304:	d8c02e15 	stw	r3,184(sp)
 2001308:	d8802e17 	ldw	r2,184(sp)
 200130c:	d9002917 	ldw	r4,164(sp)
 2001310:	1100010e 	bge	r2,r4,2001318 <___vfprintf_internal_r+0x72c>
 2001314:	2005883a 	mov	r2,r4
 2001318:	d8802a15 	stw	r2,168(sp)
 200131c:	d8003215 	stw	zero,200(sp)
 2001320:	e7003fcc 	andi	fp,fp,255
 2001324:	e700201c 	xori	fp,fp,128
 2001328:	e73fe004 	addi	fp,fp,-128
 200132c:	e0000326 	beq	fp,zero,200133c <___vfprintf_internal_r+0x750>
 2001330:	d8c02a17 	ldw	r3,168(sp)
 2001334:	18c00044 	addi	r3,r3,1
 2001338:	d8c02a15 	stw	r3,168(sp)
 200133c:	90c0008c 	andi	r3,r18,2
 2001340:	d8c02b15 	stw	r3,172(sp)
 2001344:	18000326 	beq	r3,zero,2001354 <___vfprintf_internal_r+0x768>
 2001348:	d8c02a17 	ldw	r3,168(sp)
 200134c:	18c00084 	addi	r3,r3,2
 2001350:	d8c02a15 	stw	r3,168(sp)
 2001354:	90c0210c 	andi	r3,r18,132
 2001358:	d8c03015 	stw	r3,192(sp)
 200135c:	1801a31e 	bne	r3,zero,20019ec <___vfprintf_internal_r+0xe00>
 2001360:	d9003117 	ldw	r4,196(sp)
 2001364:	d8c02a17 	ldw	r3,168(sp)
 2001368:	20e7c83a 	sub	r19,r4,r3
 200136c:	04c19f0e 	bge	zero,r19,20019ec <___vfprintf_internal_r+0xe00>
 2001370:	02400404 	movi	r9,16
 2001374:	d8c02017 	ldw	r3,128(sp)
 2001378:	d8801f17 	ldw	r2,124(sp)
 200137c:	4cc50d0e 	bge	r9,r19,20027b4 <___vfprintf_internal_r+0x1bc8>
 2001380:	01408134 	movhi	r5,516
 2001384:	2943d984 	addi	r5,r5,3942
 2001388:	dc403b15 	stw	r17,236(sp)
 200138c:	d9403515 	stw	r5,212(sp)
 2001390:	9823883a 	mov	r17,r19
 2001394:	482d883a 	mov	r22,r9
 2001398:	9027883a 	mov	r19,r18
 200139c:	070001c4 	movi	fp,7
 20013a0:	8025883a 	mov	r18,r16
 20013a4:	dc002c17 	ldw	r16,176(sp)
 20013a8:	00000306 	br	20013b8 <___vfprintf_internal_r+0x7cc>
 20013ac:	8c7ffc04 	addi	r17,r17,-16
 20013b0:	42000204 	addi	r8,r8,8
 20013b4:	b440130e 	bge	r22,r17,2001404 <___vfprintf_internal_r+0x818>
 20013b8:	01008134 	movhi	r4,516
 20013bc:	18c00404 	addi	r3,r3,16
 20013c0:	10800044 	addi	r2,r2,1
 20013c4:	2103d984 	addi	r4,r4,3942
 20013c8:	41000015 	stw	r4,0(r8)
 20013cc:	45800115 	stw	r22,4(r8)
 20013d0:	d8c02015 	stw	r3,128(sp)
 20013d4:	d8801f15 	stw	r2,124(sp)
 20013d8:	e0bff40e 	bge	fp,r2,20013ac <__alt_mem_mem_0+0xfcfe13ac>
 20013dc:	d9801e04 	addi	r6,sp,120
 20013e0:	b80b883a 	mov	r5,r23
 20013e4:	8009883a 	mov	r4,r16
 20013e8:	20077040 	call	2007704 <__sprint_r>
 20013ec:	103f011e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 20013f0:	8c7ffc04 	addi	r17,r17,-16
 20013f4:	d8c02017 	ldw	r3,128(sp)
 20013f8:	d8801f17 	ldw	r2,124(sp)
 20013fc:	da000404 	addi	r8,sp,16
 2001400:	b47fed16 	blt	r22,r17,20013b8 <__alt_mem_mem_0+0xfcfe13b8>
 2001404:	9021883a 	mov	r16,r18
 2001408:	9825883a 	mov	r18,r19
 200140c:	8827883a 	mov	r19,r17
 2001410:	dc403b17 	ldw	r17,236(sp)
 2001414:	d9403517 	ldw	r5,212(sp)
 2001418:	98c7883a 	add	r3,r19,r3
 200141c:	10800044 	addi	r2,r2,1
 2001420:	41400015 	stw	r5,0(r8)
 2001424:	44c00115 	stw	r19,4(r8)
 2001428:	d8c02015 	stw	r3,128(sp)
 200142c:	d8801f15 	stw	r2,124(sp)
 2001430:	010001c4 	movi	r4,7
 2001434:	2082a316 	blt	r4,r2,2001ec4 <___vfprintf_internal_r+0x12d8>
 2001438:	df002787 	ldb	fp,158(sp)
 200143c:	42000204 	addi	r8,r8,8
 2001440:	e0000c26 	beq	fp,zero,2001474 <___vfprintf_internal_r+0x888>
 2001444:	d8801f17 	ldw	r2,124(sp)
 2001448:	d9002784 	addi	r4,sp,158
 200144c:	18c00044 	addi	r3,r3,1
 2001450:	10800044 	addi	r2,r2,1
 2001454:	41000015 	stw	r4,0(r8)
 2001458:	01000044 	movi	r4,1
 200145c:	41000115 	stw	r4,4(r8)
 2001460:	d8c02015 	stw	r3,128(sp)
 2001464:	d8801f15 	stw	r2,124(sp)
 2001468:	010001c4 	movi	r4,7
 200146c:	20823c16 	blt	r4,r2,2001d60 <___vfprintf_internal_r+0x1174>
 2001470:	42000204 	addi	r8,r8,8
 2001474:	d8802b17 	ldw	r2,172(sp)
 2001478:	10000c26 	beq	r2,zero,20014ac <___vfprintf_internal_r+0x8c0>
 200147c:	d8801f17 	ldw	r2,124(sp)
 2001480:	d9002704 	addi	r4,sp,156
 2001484:	18c00084 	addi	r3,r3,2
 2001488:	10800044 	addi	r2,r2,1
 200148c:	41000015 	stw	r4,0(r8)
 2001490:	01000084 	movi	r4,2
 2001494:	41000115 	stw	r4,4(r8)
 2001498:	d8c02015 	stw	r3,128(sp)
 200149c:	d8801f15 	stw	r2,124(sp)
 20014a0:	010001c4 	movi	r4,7
 20014a4:	20823616 	blt	r4,r2,2001d80 <___vfprintf_internal_r+0x1194>
 20014a8:	42000204 	addi	r8,r8,8
 20014ac:	d9003017 	ldw	r4,192(sp)
 20014b0:	00802004 	movi	r2,128
 20014b4:	20819926 	beq	r4,r2,2001b1c <___vfprintf_internal_r+0xf30>
 20014b8:	d9402917 	ldw	r5,164(sp)
 20014bc:	d8802e17 	ldw	r2,184(sp)
 20014c0:	28adc83a 	sub	r22,r5,r2
 20014c4:	0580310e 	bge	zero,r22,200158c <___vfprintf_internal_r+0x9a0>
 20014c8:	07000404 	movi	fp,16
 20014cc:	d8801f17 	ldw	r2,124(sp)
 20014d0:	e584140e 	bge	fp,r22,2002524 <___vfprintf_internal_r+0x1938>
 20014d4:	01408134 	movhi	r5,516
 20014d8:	2943d584 	addi	r5,r5,3926
 20014dc:	dc402915 	stw	r17,164(sp)
 20014e0:	d9402b15 	stw	r5,172(sp)
 20014e4:	b023883a 	mov	r17,r22
 20014e8:	04c001c4 	movi	r19,7
 20014ec:	a82d883a 	mov	r22,r21
 20014f0:	902b883a 	mov	r21,r18
 20014f4:	8025883a 	mov	r18,r16
 20014f8:	dc002c17 	ldw	r16,176(sp)
 20014fc:	00000306 	br	200150c <___vfprintf_internal_r+0x920>
 2001500:	8c7ffc04 	addi	r17,r17,-16
 2001504:	42000204 	addi	r8,r8,8
 2001508:	e440110e 	bge	fp,r17,2001550 <___vfprintf_internal_r+0x964>
 200150c:	18c00404 	addi	r3,r3,16
 2001510:	10800044 	addi	r2,r2,1
 2001514:	45000015 	stw	r20,0(r8)
 2001518:	47000115 	stw	fp,4(r8)
 200151c:	d8c02015 	stw	r3,128(sp)
 2001520:	d8801f15 	stw	r2,124(sp)
 2001524:	98bff60e 	bge	r19,r2,2001500 <__alt_mem_mem_0+0xfcfe1500>
 2001528:	d9801e04 	addi	r6,sp,120
 200152c:	b80b883a 	mov	r5,r23
 2001530:	8009883a 	mov	r4,r16
 2001534:	20077040 	call	2007704 <__sprint_r>
 2001538:	103eae1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 200153c:	8c7ffc04 	addi	r17,r17,-16
 2001540:	d8c02017 	ldw	r3,128(sp)
 2001544:	d8801f17 	ldw	r2,124(sp)
 2001548:	da000404 	addi	r8,sp,16
 200154c:	e47fef16 	blt	fp,r17,200150c <__alt_mem_mem_0+0xfcfe150c>
 2001550:	9021883a 	mov	r16,r18
 2001554:	a825883a 	mov	r18,r21
 2001558:	b02b883a 	mov	r21,r22
 200155c:	882d883a 	mov	r22,r17
 2001560:	dc402917 	ldw	r17,164(sp)
 2001564:	d9002b17 	ldw	r4,172(sp)
 2001568:	1d87883a 	add	r3,r3,r22
 200156c:	10800044 	addi	r2,r2,1
 2001570:	41000015 	stw	r4,0(r8)
 2001574:	45800115 	stw	r22,4(r8)
 2001578:	d8c02015 	stw	r3,128(sp)
 200157c:	d8801f15 	stw	r2,124(sp)
 2001580:	010001c4 	movi	r4,7
 2001584:	2081ee16 	blt	r4,r2,2001d40 <___vfprintf_internal_r+0x1154>
 2001588:	42000204 	addi	r8,r8,8
 200158c:	9080400c 	andi	r2,r18,256
 2001590:	1001181e 	bne	r2,zero,20019f4 <___vfprintf_internal_r+0xe08>
 2001594:	d9402e17 	ldw	r5,184(sp)
 2001598:	d8801f17 	ldw	r2,124(sp)
 200159c:	44000015 	stw	r16,0(r8)
 20015a0:	1947883a 	add	r3,r3,r5
 20015a4:	10800044 	addi	r2,r2,1
 20015a8:	41400115 	stw	r5,4(r8)
 20015ac:	d8c02015 	stw	r3,128(sp)
 20015b0:	d8801f15 	stw	r2,124(sp)
 20015b4:	010001c4 	movi	r4,7
 20015b8:	2081d316 	blt	r4,r2,2001d08 <___vfprintf_internal_r+0x111c>
 20015bc:	42000204 	addi	r8,r8,8
 20015c0:	9480010c 	andi	r18,r18,4
 20015c4:	90003226 	beq	r18,zero,2001690 <___vfprintf_internal_r+0xaa4>
 20015c8:	d9403117 	ldw	r5,196(sp)
 20015cc:	d8802a17 	ldw	r2,168(sp)
 20015d0:	28a1c83a 	sub	r16,r5,r2
 20015d4:	04002e0e 	bge	zero,r16,2001690 <___vfprintf_internal_r+0xaa4>
 20015d8:	04400404 	movi	r17,16
 20015dc:	d8801f17 	ldw	r2,124(sp)
 20015e0:	8c04a20e 	bge	r17,r16,200286c <___vfprintf_internal_r+0x1c80>
 20015e4:	01408134 	movhi	r5,516
 20015e8:	2943d984 	addi	r5,r5,3942
 20015ec:	d9403515 	stw	r5,212(sp)
 20015f0:	048001c4 	movi	r18,7
 20015f4:	dcc02c17 	ldw	r19,176(sp)
 20015f8:	00000306 	br	2001608 <___vfprintf_internal_r+0xa1c>
 20015fc:	843ffc04 	addi	r16,r16,-16
 2001600:	42000204 	addi	r8,r8,8
 2001604:	8c00130e 	bge	r17,r16,2001654 <___vfprintf_internal_r+0xa68>
 2001608:	01008134 	movhi	r4,516
 200160c:	18c00404 	addi	r3,r3,16
 2001610:	10800044 	addi	r2,r2,1
 2001614:	2103d984 	addi	r4,r4,3942
 2001618:	41000015 	stw	r4,0(r8)
 200161c:	44400115 	stw	r17,4(r8)
 2001620:	d8c02015 	stw	r3,128(sp)
 2001624:	d8801f15 	stw	r2,124(sp)
 2001628:	90bff40e 	bge	r18,r2,20015fc <__alt_mem_mem_0+0xfcfe15fc>
 200162c:	d9801e04 	addi	r6,sp,120
 2001630:	b80b883a 	mov	r5,r23
 2001634:	9809883a 	mov	r4,r19
 2001638:	20077040 	call	2007704 <__sprint_r>
 200163c:	103e6d1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001640:	843ffc04 	addi	r16,r16,-16
 2001644:	d8c02017 	ldw	r3,128(sp)
 2001648:	d8801f17 	ldw	r2,124(sp)
 200164c:	da000404 	addi	r8,sp,16
 2001650:	8c3fed16 	blt	r17,r16,2001608 <__alt_mem_mem_0+0xfcfe1608>
 2001654:	d9403517 	ldw	r5,212(sp)
 2001658:	1c07883a 	add	r3,r3,r16
 200165c:	10800044 	addi	r2,r2,1
 2001660:	41400015 	stw	r5,0(r8)
 2001664:	44000115 	stw	r16,4(r8)
 2001668:	d8c02015 	stw	r3,128(sp)
 200166c:	d8801f15 	stw	r2,124(sp)
 2001670:	010001c4 	movi	r4,7
 2001674:	2080060e 	bge	r4,r2,2001690 <___vfprintf_internal_r+0xaa4>
 2001678:	d9002c17 	ldw	r4,176(sp)
 200167c:	d9801e04 	addi	r6,sp,120
 2001680:	b80b883a 	mov	r5,r23
 2001684:	20077040 	call	2007704 <__sprint_r>
 2001688:	103e5a1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 200168c:	d8c02017 	ldw	r3,128(sp)
 2001690:	d8803117 	ldw	r2,196(sp)
 2001694:	d9002a17 	ldw	r4,168(sp)
 2001698:	1100010e 	bge	r2,r4,20016a0 <___vfprintf_internal_r+0xab4>
 200169c:	2005883a 	mov	r2,r4
 20016a0:	d9402f17 	ldw	r5,188(sp)
 20016a4:	288b883a 	add	r5,r5,r2
 20016a8:	d9402f15 	stw	r5,188(sp)
 20016ac:	18019e1e 	bne	r3,zero,2001d28 <___vfprintf_internal_r+0x113c>
 20016b0:	a8800007 	ldb	r2,0(r21)
 20016b4:	d8001f15 	stw	zero,124(sp)
 20016b8:	da000404 	addi	r8,sp,16
 20016bc:	103d851e 	bne	r2,zero,2000cd4 <__alt_mem_mem_0+0xfcfe0cd4>
 20016c0:	a821883a 	mov	r16,r21
 20016c4:	003d9b06 	br	2000d34 <__alt_mem_mem_0+0xfcfe0d34>
 20016c8:	18c03fcc 	andi	r3,r3,255
 20016cc:	1805c11e 	bne	r3,zero,2002dd4 <___vfprintf_internal_r+0x21e8>
 20016d0:	94800414 	ori	r18,r18,16
 20016d4:	9080080c 	andi	r2,r18,32
 20016d8:	10020c26 	beq	r2,zero,2001f0c <___vfprintf_internal_r+0x1320>
 20016dc:	d8802d17 	ldw	r2,180(sp)
 20016e0:	d9002917 	ldw	r4,164(sp)
 20016e4:	d8002785 	stb	zero,158(sp)
 20016e8:	10c00204 	addi	r3,r2,8
 20016ec:	14c00017 	ldw	r19,0(r2)
 20016f0:	15800117 	ldw	r22,4(r2)
 20016f4:	20040f16 	blt	r4,zero,2002734 <___vfprintf_internal_r+0x1b48>
 20016f8:	013fdfc4 	movi	r4,-129
 20016fc:	9d84b03a 	or	r2,r19,r22
 2001700:	d8c02d15 	stw	r3,180(sp)
 2001704:	9124703a 	and	r18,r18,r4
 2001708:	0039883a 	mov	fp,zero
 200170c:	103e891e 	bne	r2,zero,2001134 <__alt_mem_mem_0+0xfcfe1134>
 2001710:	d9002917 	ldw	r4,164(sp)
 2001714:	2002c11e 	bne	r4,zero,200221c <___vfprintf_internal_r+0x1630>
 2001718:	d8002915 	stw	zero,164(sp)
 200171c:	d8002e15 	stw	zero,184(sp)
 2001720:	dc001e04 	addi	r16,sp,120
 2001724:	003ef806 	br	2001308 <__alt_mem_mem_0+0xfcfe1308>
 2001728:	18c03fcc 	andi	r3,r3,255
 200172c:	18059d1e 	bne	r3,zero,2002da4 <___vfprintf_internal_r+0x21b8>
 2001730:	01408134 	movhi	r5,516
 2001734:	2943c904 	addi	r5,r5,3876
 2001738:	d9403915 	stw	r5,228(sp)
 200173c:	9080080c 	andi	r2,r18,32
 2001740:	10005226 	beq	r2,zero,200188c <___vfprintf_internal_r+0xca0>
 2001744:	d8802d17 	ldw	r2,180(sp)
 2001748:	14c00017 	ldw	r19,0(r2)
 200174c:	15800117 	ldw	r22,4(r2)
 2001750:	10800204 	addi	r2,r2,8
 2001754:	d8802d15 	stw	r2,180(sp)
 2001758:	9080004c 	andi	r2,r18,1
 200175c:	10019026 	beq	r2,zero,2001da0 <___vfprintf_internal_r+0x11b4>
 2001760:	9d84b03a 	or	r2,r19,r22
 2001764:	10036926 	beq	r2,zero,200250c <___vfprintf_internal_r+0x1920>
 2001768:	d8c02917 	ldw	r3,164(sp)
 200176c:	00800c04 	movi	r2,48
 2001770:	d8802705 	stb	r2,156(sp)
 2001774:	dc402745 	stb	r17,157(sp)
 2001778:	d8002785 	stb	zero,158(sp)
 200177c:	90800094 	ori	r2,r18,2
 2001780:	18045d16 	blt	r3,zero,20028f8 <___vfprintf_internal_r+0x1d0c>
 2001784:	00bfdfc4 	movi	r2,-129
 2001788:	90a4703a 	and	r18,r18,r2
 200178c:	94800094 	ori	r18,r18,2
 2001790:	0039883a 	mov	fp,zero
 2001794:	d9003917 	ldw	r4,228(sp)
 2001798:	dc001e04 	addi	r16,sp,120
 200179c:	988003cc 	andi	r2,r19,15
 20017a0:	b006973a 	slli	r3,r22,28
 20017a4:	2085883a 	add	r2,r4,r2
 20017a8:	9826d13a 	srli	r19,r19,4
 20017ac:	10800003 	ldbu	r2,0(r2)
 20017b0:	b02cd13a 	srli	r22,r22,4
 20017b4:	843fffc4 	addi	r16,r16,-1
 20017b8:	1ce6b03a 	or	r19,r3,r19
 20017bc:	80800005 	stb	r2,0(r16)
 20017c0:	9d84b03a 	or	r2,r19,r22
 20017c4:	103ff51e 	bne	r2,zero,200179c <__alt_mem_mem_0+0xfcfe179c>
 20017c8:	d8c02817 	ldw	r3,160(sp)
 20017cc:	1c07c83a 	sub	r3,r3,r16
 20017d0:	d8c02e15 	stw	r3,184(sp)
 20017d4:	003ecc06 	br	2001308 <__alt_mem_mem_0+0xfcfe1308>
 20017d8:	18c03fcc 	andi	r3,r3,255
 20017dc:	183e9f26 	beq	r3,zero,200125c <__alt_mem_mem_0+0xfcfe125c>
 20017e0:	d9c02785 	stb	r7,158(sp)
 20017e4:	003e9d06 	br	200125c <__alt_mem_mem_0+0xfcfe125c>
 20017e8:	00c00044 	movi	r3,1
 20017ec:	01c00ac4 	movi	r7,43
 20017f0:	ac400007 	ldb	r17,0(r21)
 20017f4:	003d5e06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 20017f8:	94800814 	ori	r18,r18,32
 20017fc:	ac400007 	ldb	r17,0(r21)
 2001800:	003d5b06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2001804:	d8c02d17 	ldw	r3,180(sp)
 2001808:	d8002785 	stb	zero,158(sp)
 200180c:	1c000017 	ldw	r16,0(r3)
 2001810:	1cc00104 	addi	r19,r3,4
 2001814:	80041926 	beq	r16,zero,200287c <___vfprintf_internal_r+0x1c90>
 2001818:	d9002917 	ldw	r4,164(sp)
 200181c:	2003d016 	blt	r4,zero,2002760 <___vfprintf_internal_r+0x1b74>
 2001820:	200d883a 	mov	r6,r4
 2001824:	000b883a 	mov	r5,zero
 2001828:	8009883a 	mov	r4,r16
 200182c:	da003d15 	stw	r8,244(sp)
 2001830:	2005f400 	call	2005f40 <memchr>
 2001834:	da003d17 	ldw	r8,244(sp)
 2001838:	10045426 	beq	r2,zero,200298c <___vfprintf_internal_r+0x1da0>
 200183c:	1405c83a 	sub	r2,r2,r16
 2001840:	d8802e15 	stw	r2,184(sp)
 2001844:	1003cc16 	blt	r2,zero,2002778 <___vfprintf_internal_r+0x1b8c>
 2001848:	df002783 	ldbu	fp,158(sp)
 200184c:	d8802a15 	stw	r2,168(sp)
 2001850:	dcc02d15 	stw	r19,180(sp)
 2001854:	d8002915 	stw	zero,164(sp)
 2001858:	d8003215 	stw	zero,200(sp)
 200185c:	003eb006 	br	2001320 <__alt_mem_mem_0+0xfcfe1320>
 2001860:	18c03fcc 	andi	r3,r3,255
 2001864:	183f9b26 	beq	r3,zero,20016d4 <__alt_mem_mem_0+0xfcfe16d4>
 2001868:	d9c02785 	stb	r7,158(sp)
 200186c:	003f9906 	br	20016d4 <__alt_mem_mem_0+0xfcfe16d4>
 2001870:	18c03fcc 	andi	r3,r3,255
 2001874:	1805551e 	bne	r3,zero,2002dcc <___vfprintf_internal_r+0x21e0>
 2001878:	01408134 	movhi	r5,516
 200187c:	2943ce04 	addi	r5,r5,3896
 2001880:	d9403915 	stw	r5,228(sp)
 2001884:	9080080c 	andi	r2,r18,32
 2001888:	103fae1e 	bne	r2,zero,2001744 <__alt_mem_mem_0+0xfcfe1744>
 200188c:	9080040c 	andi	r2,r18,16
 2001890:	1002de26 	beq	r2,zero,200240c <___vfprintf_internal_r+0x1820>
 2001894:	d8c02d17 	ldw	r3,180(sp)
 2001898:	002d883a 	mov	r22,zero
 200189c:	1cc00017 	ldw	r19,0(r3)
 20018a0:	18c00104 	addi	r3,r3,4
 20018a4:	d8c02d15 	stw	r3,180(sp)
 20018a8:	003fab06 	br	2001758 <__alt_mem_mem_0+0xfcfe1758>
 20018ac:	38803fcc 	andi	r2,r7,255
 20018b0:	1080201c 	xori	r2,r2,128
 20018b4:	10bfe004 	addi	r2,r2,-128
 20018b8:	1002d21e 	bne	r2,zero,2002404 <___vfprintf_internal_r+0x1818>
 20018bc:	00c00044 	movi	r3,1
 20018c0:	01c00804 	movi	r7,32
 20018c4:	ac400007 	ldb	r17,0(r21)
 20018c8:	003d2906 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 20018cc:	94800054 	ori	r18,r18,1
 20018d0:	ac400007 	ldb	r17,0(r21)
 20018d4:	003d2606 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 20018d8:	18c03fcc 	andi	r3,r3,255
 20018dc:	183e0526 	beq	r3,zero,20010f4 <__alt_mem_mem_0+0xfcfe10f4>
 20018e0:	d9c02785 	stb	r7,158(sp)
 20018e4:	003e0306 	br	20010f4 <__alt_mem_mem_0+0xfcfe10f4>
 20018e8:	94801014 	ori	r18,r18,64
 20018ec:	ac400007 	ldb	r17,0(r21)
 20018f0:	003d1f06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 20018f4:	ac400007 	ldb	r17,0(r21)
 20018f8:	8a438726 	beq	r17,r9,2002718 <___vfprintf_internal_r+0x1b2c>
 20018fc:	94800414 	ori	r18,r18,16
 2001900:	003d1b06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2001904:	18c03fcc 	andi	r3,r3,255
 2001908:	1805341e 	bne	r3,zero,2002ddc <___vfprintf_internal_r+0x21f0>
 200190c:	9080080c 	andi	r2,r18,32
 2001910:	1002cd26 	beq	r2,zero,2002448 <___vfprintf_internal_r+0x185c>
 2001914:	d9402d17 	ldw	r5,180(sp)
 2001918:	d9002f17 	ldw	r4,188(sp)
 200191c:	28800017 	ldw	r2,0(r5)
 2001920:	2007d7fa 	srai	r3,r4,31
 2001924:	29400104 	addi	r5,r5,4
 2001928:	d9402d15 	stw	r5,180(sp)
 200192c:	11000015 	stw	r4,0(r2)
 2001930:	10c00115 	stw	r3,4(r2)
 2001934:	003ce506 	br	2000ccc <__alt_mem_mem_0+0xfcfe0ccc>
 2001938:	d8c02d17 	ldw	r3,180(sp)
 200193c:	d9002d17 	ldw	r4,180(sp)
 2001940:	d8002785 	stb	zero,158(sp)
 2001944:	18800017 	ldw	r2,0(r3)
 2001948:	21000104 	addi	r4,r4,4
 200194c:	00c00044 	movi	r3,1
 2001950:	d8c02a15 	stw	r3,168(sp)
 2001954:	d8801405 	stb	r2,80(sp)
 2001958:	d9002d15 	stw	r4,180(sp)
 200195c:	d8c02e15 	stw	r3,184(sp)
 2001960:	d8002915 	stw	zero,164(sp)
 2001964:	d8003215 	stw	zero,200(sp)
 2001968:	dc001404 	addi	r16,sp,80
 200196c:	0039883a 	mov	fp,zero
 2001970:	003e7206 	br	200133c <__alt_mem_mem_0+0xfcfe133c>
 2001974:	01008134 	movhi	r4,516
 2001978:	2103ce04 	addi	r4,r4,3896
 200197c:	0039883a 	mov	fp,zero
 2001980:	d9003915 	stw	r4,228(sp)
 2001984:	04401e04 	movi	r17,120
 2001988:	003f8206 	br	2001794 <__alt_mem_mem_0+0xfcfe1794>
 200198c:	18c03fcc 	andi	r3,r3,255
 2001990:	1805061e 	bne	r3,zero,2002dac <___vfprintf_internal_r+0x21c0>
 2001994:	883d9126 	beq	r17,zero,2000fdc <__alt_mem_mem_0+0xfcfe0fdc>
 2001998:	00c00044 	movi	r3,1
 200199c:	d8c02a15 	stw	r3,168(sp)
 20019a0:	dc401405 	stb	r17,80(sp)
 20019a4:	d8002785 	stb	zero,158(sp)
 20019a8:	003fec06 	br	200195c <__alt_mem_mem_0+0xfcfe195c>
 20019ac:	01408134 	movhi	r5,516
 20019b0:	2943ce04 	addi	r5,r5,3896
 20019b4:	d9403915 	stw	r5,228(sp)
 20019b8:	d8c02d15 	stw	r3,180(sp)
 20019bc:	1025883a 	mov	r18,r2
 20019c0:	04401e04 	movi	r17,120
 20019c4:	9d84b03a 	or	r2,r19,r22
 20019c8:	1000fc1e 	bne	r2,zero,2001dbc <___vfprintf_internal_r+0x11d0>
 20019cc:	0039883a 	mov	fp,zero
 20019d0:	00800084 	movi	r2,2
 20019d4:	10803fcc 	andi	r2,r2,255
 20019d8:	00c00044 	movi	r3,1
 20019dc:	10c20f26 	beq	r2,r3,200221c <___vfprintf_internal_r+0x1630>
 20019e0:	00c00084 	movi	r3,2
 20019e4:	10fd6326 	beq	r2,r3,2000f74 <__alt_mem_mem_0+0xfcfe0f74>
 20019e8:	003e2d06 	br	20012a0 <__alt_mem_mem_0+0xfcfe12a0>
 20019ec:	d8c02017 	ldw	r3,128(sp)
 20019f0:	003e9306 	br	2001440 <__alt_mem_mem_0+0xfcfe1440>
 20019f4:	00801944 	movi	r2,101
 20019f8:	14407e0e 	bge	r2,r17,2001bf4 <___vfprintf_internal_r+0x1008>
 20019fc:	d9003617 	ldw	r4,216(sp)
 2001a00:	d9403817 	ldw	r5,224(sp)
 2001a04:	000d883a 	mov	r6,zero
 2001a08:	000f883a 	mov	r7,zero
 2001a0c:	d8c03c15 	stw	r3,240(sp)
 2001a10:	da003d15 	stw	r8,244(sp)
 2001a14:	200bef80 	call	200bef8 <__eqdf2>
 2001a18:	d8c03c17 	ldw	r3,240(sp)
 2001a1c:	da003d17 	ldw	r8,244(sp)
 2001a20:	1000f71e 	bne	r2,zero,2001e00 <___vfprintf_internal_r+0x1214>
 2001a24:	d8801f17 	ldw	r2,124(sp)
 2001a28:	01008134 	movhi	r4,516
 2001a2c:	2103d504 	addi	r4,r4,3924
 2001a30:	18c00044 	addi	r3,r3,1
 2001a34:	10800044 	addi	r2,r2,1
 2001a38:	41000015 	stw	r4,0(r8)
 2001a3c:	01000044 	movi	r4,1
 2001a40:	41000115 	stw	r4,4(r8)
 2001a44:	d8c02015 	stw	r3,128(sp)
 2001a48:	d8801f15 	stw	r2,124(sp)
 2001a4c:	010001c4 	movi	r4,7
 2001a50:	2082b816 	blt	r4,r2,2002534 <___vfprintf_internal_r+0x1948>
 2001a54:	42000204 	addi	r8,r8,8
 2001a58:	d8802617 	ldw	r2,152(sp)
 2001a5c:	d9403317 	ldw	r5,204(sp)
 2001a60:	11400216 	blt	r2,r5,2001a6c <___vfprintf_internal_r+0xe80>
 2001a64:	9080004c 	andi	r2,r18,1
 2001a68:	103ed526 	beq	r2,zero,20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 2001a6c:	d8803717 	ldw	r2,220(sp)
 2001a70:	d9003417 	ldw	r4,208(sp)
 2001a74:	d9403717 	ldw	r5,220(sp)
 2001a78:	1887883a 	add	r3,r3,r2
 2001a7c:	d8801f17 	ldw	r2,124(sp)
 2001a80:	41000015 	stw	r4,0(r8)
 2001a84:	41400115 	stw	r5,4(r8)
 2001a88:	10800044 	addi	r2,r2,1
 2001a8c:	d8c02015 	stw	r3,128(sp)
 2001a90:	d8801f15 	stw	r2,124(sp)
 2001a94:	010001c4 	movi	r4,7
 2001a98:	20832916 	blt	r4,r2,2002740 <___vfprintf_internal_r+0x1b54>
 2001a9c:	42000204 	addi	r8,r8,8
 2001aa0:	d8803317 	ldw	r2,204(sp)
 2001aa4:	143fffc4 	addi	r16,r2,-1
 2001aa8:	043ec50e 	bge	zero,r16,20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 2001aac:	04400404 	movi	r17,16
 2001ab0:	d8801f17 	ldw	r2,124(sp)
 2001ab4:	8c00880e 	bge	r17,r16,2001cd8 <___vfprintf_internal_r+0x10ec>
 2001ab8:	01408134 	movhi	r5,516
 2001abc:	2943d584 	addi	r5,r5,3926
 2001ac0:	d9402b15 	stw	r5,172(sp)
 2001ac4:	058001c4 	movi	r22,7
 2001ac8:	dcc02c17 	ldw	r19,176(sp)
 2001acc:	00000306 	br	2001adc <___vfprintf_internal_r+0xef0>
 2001ad0:	42000204 	addi	r8,r8,8
 2001ad4:	843ffc04 	addi	r16,r16,-16
 2001ad8:	8c00820e 	bge	r17,r16,2001ce4 <___vfprintf_internal_r+0x10f8>
 2001adc:	18c00404 	addi	r3,r3,16
 2001ae0:	10800044 	addi	r2,r2,1
 2001ae4:	45000015 	stw	r20,0(r8)
 2001ae8:	44400115 	stw	r17,4(r8)
 2001aec:	d8c02015 	stw	r3,128(sp)
 2001af0:	d8801f15 	stw	r2,124(sp)
 2001af4:	b0bff60e 	bge	r22,r2,2001ad0 <__alt_mem_mem_0+0xfcfe1ad0>
 2001af8:	d9801e04 	addi	r6,sp,120
 2001afc:	b80b883a 	mov	r5,r23
 2001b00:	9809883a 	mov	r4,r19
 2001b04:	20077040 	call	2007704 <__sprint_r>
 2001b08:	103d3a1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001b0c:	d8c02017 	ldw	r3,128(sp)
 2001b10:	d8801f17 	ldw	r2,124(sp)
 2001b14:	da000404 	addi	r8,sp,16
 2001b18:	003fee06 	br	2001ad4 <__alt_mem_mem_0+0xfcfe1ad4>
 2001b1c:	d9403117 	ldw	r5,196(sp)
 2001b20:	d8802a17 	ldw	r2,168(sp)
 2001b24:	28adc83a 	sub	r22,r5,r2
 2001b28:	05be630e 	bge	zero,r22,20014b8 <__alt_mem_mem_0+0xfcfe14b8>
 2001b2c:	07000404 	movi	fp,16
 2001b30:	d8801f17 	ldw	r2,124(sp)
 2001b34:	e5838f0e 	bge	fp,r22,2002974 <___vfprintf_internal_r+0x1d88>
 2001b38:	01408134 	movhi	r5,516
 2001b3c:	2943d584 	addi	r5,r5,3926
 2001b40:	dc403015 	stw	r17,192(sp)
 2001b44:	d9402b15 	stw	r5,172(sp)
 2001b48:	b023883a 	mov	r17,r22
 2001b4c:	04c001c4 	movi	r19,7
 2001b50:	a82d883a 	mov	r22,r21
 2001b54:	902b883a 	mov	r21,r18
 2001b58:	8025883a 	mov	r18,r16
 2001b5c:	dc002c17 	ldw	r16,176(sp)
 2001b60:	00000306 	br	2001b70 <___vfprintf_internal_r+0xf84>
 2001b64:	8c7ffc04 	addi	r17,r17,-16
 2001b68:	42000204 	addi	r8,r8,8
 2001b6c:	e440110e 	bge	fp,r17,2001bb4 <___vfprintf_internal_r+0xfc8>
 2001b70:	18c00404 	addi	r3,r3,16
 2001b74:	10800044 	addi	r2,r2,1
 2001b78:	45000015 	stw	r20,0(r8)
 2001b7c:	47000115 	stw	fp,4(r8)
 2001b80:	d8c02015 	stw	r3,128(sp)
 2001b84:	d8801f15 	stw	r2,124(sp)
 2001b88:	98bff60e 	bge	r19,r2,2001b64 <__alt_mem_mem_0+0xfcfe1b64>
 2001b8c:	d9801e04 	addi	r6,sp,120
 2001b90:	b80b883a 	mov	r5,r23
 2001b94:	8009883a 	mov	r4,r16
 2001b98:	20077040 	call	2007704 <__sprint_r>
 2001b9c:	103d151e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001ba0:	8c7ffc04 	addi	r17,r17,-16
 2001ba4:	d8c02017 	ldw	r3,128(sp)
 2001ba8:	d8801f17 	ldw	r2,124(sp)
 2001bac:	da000404 	addi	r8,sp,16
 2001bb0:	e47fef16 	blt	fp,r17,2001b70 <__alt_mem_mem_0+0xfcfe1b70>
 2001bb4:	9021883a 	mov	r16,r18
 2001bb8:	a825883a 	mov	r18,r21
 2001bbc:	b02b883a 	mov	r21,r22
 2001bc0:	882d883a 	mov	r22,r17
 2001bc4:	dc403017 	ldw	r17,192(sp)
 2001bc8:	d9002b17 	ldw	r4,172(sp)
 2001bcc:	1d87883a 	add	r3,r3,r22
 2001bd0:	10800044 	addi	r2,r2,1
 2001bd4:	41000015 	stw	r4,0(r8)
 2001bd8:	45800115 	stw	r22,4(r8)
 2001bdc:	d8c02015 	stw	r3,128(sp)
 2001be0:	d8801f15 	stw	r2,124(sp)
 2001be4:	010001c4 	movi	r4,7
 2001be8:	20818e16 	blt	r4,r2,2002224 <___vfprintf_internal_r+0x1638>
 2001bec:	42000204 	addi	r8,r8,8
 2001bf0:	003e3106 	br	20014b8 <__alt_mem_mem_0+0xfcfe14b8>
 2001bf4:	d9403317 	ldw	r5,204(sp)
 2001bf8:	00800044 	movi	r2,1
 2001bfc:	18c00044 	addi	r3,r3,1
 2001c00:	1141530e 	bge	r2,r5,2002150 <___vfprintf_internal_r+0x1564>
 2001c04:	dc401f17 	ldw	r17,124(sp)
 2001c08:	00800044 	movi	r2,1
 2001c0c:	40800115 	stw	r2,4(r8)
 2001c10:	8c400044 	addi	r17,r17,1
 2001c14:	44000015 	stw	r16,0(r8)
 2001c18:	d8c02015 	stw	r3,128(sp)
 2001c1c:	dc401f15 	stw	r17,124(sp)
 2001c20:	008001c4 	movi	r2,7
 2001c24:	14416b16 	blt	r2,r17,20021d4 <___vfprintf_internal_r+0x15e8>
 2001c28:	42000204 	addi	r8,r8,8
 2001c2c:	d8803717 	ldw	r2,220(sp)
 2001c30:	d9003417 	ldw	r4,208(sp)
 2001c34:	8c400044 	addi	r17,r17,1
 2001c38:	10c7883a 	add	r3,r2,r3
 2001c3c:	40800115 	stw	r2,4(r8)
 2001c40:	41000015 	stw	r4,0(r8)
 2001c44:	d8c02015 	stw	r3,128(sp)
 2001c48:	dc401f15 	stw	r17,124(sp)
 2001c4c:	008001c4 	movi	r2,7
 2001c50:	14416916 	blt	r2,r17,20021f8 <___vfprintf_internal_r+0x160c>
 2001c54:	45800204 	addi	r22,r8,8
 2001c58:	d9003617 	ldw	r4,216(sp)
 2001c5c:	d9403817 	ldw	r5,224(sp)
 2001c60:	000d883a 	mov	r6,zero
 2001c64:	000f883a 	mov	r7,zero
 2001c68:	d8c03c15 	stw	r3,240(sp)
 2001c6c:	200bef80 	call	200bef8 <__eqdf2>
 2001c70:	d8c03c17 	ldw	r3,240(sp)
 2001c74:	1000bc26 	beq	r2,zero,2001f68 <___vfprintf_internal_r+0x137c>
 2001c78:	d9403317 	ldw	r5,204(sp)
 2001c7c:	84000044 	addi	r16,r16,1
 2001c80:	8c400044 	addi	r17,r17,1
 2001c84:	28bfffc4 	addi	r2,r5,-1
 2001c88:	1887883a 	add	r3,r3,r2
 2001c8c:	b0800115 	stw	r2,4(r22)
 2001c90:	b4000015 	stw	r16,0(r22)
 2001c94:	d8c02015 	stw	r3,128(sp)
 2001c98:	dc401f15 	stw	r17,124(sp)
 2001c9c:	008001c4 	movi	r2,7
 2001ca0:	14414316 	blt	r2,r17,20021b0 <___vfprintf_internal_r+0x15c4>
 2001ca4:	b5800204 	addi	r22,r22,8
 2001ca8:	d9003a17 	ldw	r4,232(sp)
 2001cac:	df0022c4 	addi	fp,sp,139
 2001cb0:	8c400044 	addi	r17,r17,1
 2001cb4:	20c7883a 	add	r3,r4,r3
 2001cb8:	b7000015 	stw	fp,0(r22)
 2001cbc:	b1000115 	stw	r4,4(r22)
 2001cc0:	d8c02015 	stw	r3,128(sp)
 2001cc4:	dc401f15 	stw	r17,124(sp)
 2001cc8:	008001c4 	movi	r2,7
 2001ccc:	14400e16 	blt	r2,r17,2001d08 <___vfprintf_internal_r+0x111c>
 2001cd0:	b2000204 	addi	r8,r22,8
 2001cd4:	003e3a06 	br	20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 2001cd8:	01008134 	movhi	r4,516
 2001cdc:	2103d584 	addi	r4,r4,3926
 2001ce0:	d9002b15 	stw	r4,172(sp)
 2001ce4:	d9002b17 	ldw	r4,172(sp)
 2001ce8:	1c07883a 	add	r3,r3,r16
 2001cec:	44000115 	stw	r16,4(r8)
 2001cf0:	41000015 	stw	r4,0(r8)
 2001cf4:	10800044 	addi	r2,r2,1
 2001cf8:	d8c02015 	stw	r3,128(sp)
 2001cfc:	d8801f15 	stw	r2,124(sp)
 2001d00:	010001c4 	movi	r4,7
 2001d04:	20be2d0e 	bge	r4,r2,20015bc <__alt_mem_mem_0+0xfcfe15bc>
 2001d08:	d9002c17 	ldw	r4,176(sp)
 2001d0c:	d9801e04 	addi	r6,sp,120
 2001d10:	b80b883a 	mov	r5,r23
 2001d14:	20077040 	call	2007704 <__sprint_r>
 2001d18:	103cb61e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001d1c:	d8c02017 	ldw	r3,128(sp)
 2001d20:	da000404 	addi	r8,sp,16
 2001d24:	003e2606 	br	20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 2001d28:	d9002c17 	ldw	r4,176(sp)
 2001d2c:	d9801e04 	addi	r6,sp,120
 2001d30:	b80b883a 	mov	r5,r23
 2001d34:	20077040 	call	2007704 <__sprint_r>
 2001d38:	103e5d26 	beq	r2,zero,20016b0 <__alt_mem_mem_0+0xfcfe16b0>
 2001d3c:	003cad06 	br	2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001d40:	d9002c17 	ldw	r4,176(sp)
 2001d44:	d9801e04 	addi	r6,sp,120
 2001d48:	b80b883a 	mov	r5,r23
 2001d4c:	20077040 	call	2007704 <__sprint_r>
 2001d50:	103ca81e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001d54:	d8c02017 	ldw	r3,128(sp)
 2001d58:	da000404 	addi	r8,sp,16
 2001d5c:	003e0b06 	br	200158c <__alt_mem_mem_0+0xfcfe158c>
 2001d60:	d9002c17 	ldw	r4,176(sp)
 2001d64:	d9801e04 	addi	r6,sp,120
 2001d68:	b80b883a 	mov	r5,r23
 2001d6c:	20077040 	call	2007704 <__sprint_r>
 2001d70:	103ca01e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001d74:	d8c02017 	ldw	r3,128(sp)
 2001d78:	da000404 	addi	r8,sp,16
 2001d7c:	003dbd06 	br	2001474 <__alt_mem_mem_0+0xfcfe1474>
 2001d80:	d9002c17 	ldw	r4,176(sp)
 2001d84:	d9801e04 	addi	r6,sp,120
 2001d88:	b80b883a 	mov	r5,r23
 2001d8c:	20077040 	call	2007704 <__sprint_r>
 2001d90:	103c981e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001d94:	d8c02017 	ldw	r3,128(sp)
 2001d98:	da000404 	addi	r8,sp,16
 2001d9c:	003dc306 	br	20014ac <__alt_mem_mem_0+0xfcfe14ac>
 2001da0:	d8802917 	ldw	r2,164(sp)
 2001da4:	d8002785 	stb	zero,158(sp)
 2001da8:	103f0616 	blt	r2,zero,20019c4 <__alt_mem_mem_0+0xfcfe19c4>
 2001dac:	00ffdfc4 	movi	r3,-129
 2001db0:	9d84b03a 	or	r2,r19,r22
 2001db4:	90e4703a 	and	r18,r18,r3
 2001db8:	103c6b26 	beq	r2,zero,2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 2001dbc:	0039883a 	mov	fp,zero
 2001dc0:	003e7406 	br	2001794 <__alt_mem_mem_0+0xfcfe1794>
 2001dc4:	9080040c 	andi	r2,r18,16
 2001dc8:	1001b326 	beq	r2,zero,2002498 <___vfprintf_internal_r+0x18ac>
 2001dcc:	d9002d17 	ldw	r4,180(sp)
 2001dd0:	d9402917 	ldw	r5,164(sp)
 2001dd4:	d8002785 	stb	zero,158(sp)
 2001dd8:	20800104 	addi	r2,r4,4
 2001ddc:	24c00017 	ldw	r19,0(r4)
 2001de0:	002d883a 	mov	r22,zero
 2001de4:	2801b516 	blt	r5,zero,20024bc <___vfprintf_internal_r+0x18d0>
 2001de8:	00ffdfc4 	movi	r3,-129
 2001dec:	d8802d15 	stw	r2,180(sp)
 2001df0:	90e4703a 	and	r18,r18,r3
 2001df4:	983d2726 	beq	r19,zero,2001294 <__alt_mem_mem_0+0xfcfe1294>
 2001df8:	0039883a 	mov	fp,zero
 2001dfc:	003d2a06 	br	20012a8 <__alt_mem_mem_0+0xfcfe12a8>
 2001e00:	dc402617 	ldw	r17,152(sp)
 2001e04:	0441d30e 	bge	zero,r17,2002554 <___vfprintf_internal_r+0x1968>
 2001e08:	dc403217 	ldw	r17,200(sp)
 2001e0c:	d8803317 	ldw	r2,204(sp)
 2001e10:	1440010e 	bge	r2,r17,2001e18 <___vfprintf_internal_r+0x122c>
 2001e14:	1023883a 	mov	r17,r2
 2001e18:	04400a0e 	bge	zero,r17,2001e44 <___vfprintf_internal_r+0x1258>
 2001e1c:	d8801f17 	ldw	r2,124(sp)
 2001e20:	1c47883a 	add	r3,r3,r17
 2001e24:	44000015 	stw	r16,0(r8)
 2001e28:	10800044 	addi	r2,r2,1
 2001e2c:	44400115 	stw	r17,4(r8)
 2001e30:	d8c02015 	stw	r3,128(sp)
 2001e34:	d8801f15 	stw	r2,124(sp)
 2001e38:	010001c4 	movi	r4,7
 2001e3c:	20826516 	blt	r4,r2,20027d4 <___vfprintf_internal_r+0x1be8>
 2001e40:	42000204 	addi	r8,r8,8
 2001e44:	88026116 	blt	r17,zero,20027cc <___vfprintf_internal_r+0x1be0>
 2001e48:	d9003217 	ldw	r4,200(sp)
 2001e4c:	2463c83a 	sub	r17,r4,r17
 2001e50:	04407b0e 	bge	zero,r17,2002040 <___vfprintf_internal_r+0x1454>
 2001e54:	05800404 	movi	r22,16
 2001e58:	d8801f17 	ldw	r2,124(sp)
 2001e5c:	b4419d0e 	bge	r22,r17,20024d4 <___vfprintf_internal_r+0x18e8>
 2001e60:	01008134 	movhi	r4,516
 2001e64:	2103d584 	addi	r4,r4,3926
 2001e68:	d9002b15 	stw	r4,172(sp)
 2001e6c:	070001c4 	movi	fp,7
 2001e70:	dcc02c17 	ldw	r19,176(sp)
 2001e74:	00000306 	br	2001e84 <___vfprintf_internal_r+0x1298>
 2001e78:	42000204 	addi	r8,r8,8
 2001e7c:	8c7ffc04 	addi	r17,r17,-16
 2001e80:	b441970e 	bge	r22,r17,20024e0 <___vfprintf_internal_r+0x18f4>
 2001e84:	18c00404 	addi	r3,r3,16
 2001e88:	10800044 	addi	r2,r2,1
 2001e8c:	45000015 	stw	r20,0(r8)
 2001e90:	45800115 	stw	r22,4(r8)
 2001e94:	d8c02015 	stw	r3,128(sp)
 2001e98:	d8801f15 	stw	r2,124(sp)
 2001e9c:	e0bff60e 	bge	fp,r2,2001e78 <__alt_mem_mem_0+0xfcfe1e78>
 2001ea0:	d9801e04 	addi	r6,sp,120
 2001ea4:	b80b883a 	mov	r5,r23
 2001ea8:	9809883a 	mov	r4,r19
 2001eac:	20077040 	call	2007704 <__sprint_r>
 2001eb0:	103c501e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001eb4:	d8c02017 	ldw	r3,128(sp)
 2001eb8:	d8801f17 	ldw	r2,124(sp)
 2001ebc:	da000404 	addi	r8,sp,16
 2001ec0:	003fee06 	br	2001e7c <__alt_mem_mem_0+0xfcfe1e7c>
 2001ec4:	d9002c17 	ldw	r4,176(sp)
 2001ec8:	d9801e04 	addi	r6,sp,120
 2001ecc:	b80b883a 	mov	r5,r23
 2001ed0:	20077040 	call	2007704 <__sprint_r>
 2001ed4:	103c471e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001ed8:	d8c02017 	ldw	r3,128(sp)
 2001edc:	df002787 	ldb	fp,158(sp)
 2001ee0:	da000404 	addi	r8,sp,16
 2001ee4:	003d5606 	br	2001440 <__alt_mem_mem_0+0xfcfe1440>
 2001ee8:	9080040c 	andi	r2,r18,16
 2001eec:	10016126 	beq	r2,zero,2002474 <___vfprintf_internal_r+0x1888>
 2001ef0:	d8802d17 	ldw	r2,180(sp)
 2001ef4:	14c00017 	ldw	r19,0(r2)
 2001ef8:	10800104 	addi	r2,r2,4
 2001efc:	d8802d15 	stw	r2,180(sp)
 2001f00:	982dd7fa 	srai	r22,r19,31
 2001f04:	b005883a 	mov	r2,r22
 2001f08:	003c8206 	br	2001114 <__alt_mem_mem_0+0xfcfe1114>
 2001f0c:	9080040c 	andi	r2,r18,16
 2001f10:	10003526 	beq	r2,zero,2001fe8 <___vfprintf_internal_r+0x13fc>
 2001f14:	d9402d17 	ldw	r5,180(sp)
 2001f18:	d8c02917 	ldw	r3,164(sp)
 2001f1c:	d8002785 	stb	zero,158(sp)
 2001f20:	28800104 	addi	r2,r5,4
 2001f24:	2cc00017 	ldw	r19,0(r5)
 2001f28:	002d883a 	mov	r22,zero
 2001f2c:	18003716 	blt	r3,zero,200200c <___vfprintf_internal_r+0x1420>
 2001f30:	00ffdfc4 	movi	r3,-129
 2001f34:	d8802d15 	stw	r2,180(sp)
 2001f38:	90e4703a 	and	r18,r18,r3
 2001f3c:	0039883a 	mov	fp,zero
 2001f40:	983df326 	beq	r19,zero,2001710 <__alt_mem_mem_0+0xfcfe1710>
 2001f44:	00800244 	movi	r2,9
 2001f48:	14fc7b36 	bltu	r2,r19,2001138 <__alt_mem_mem_0+0xfcfe1138>
 2001f4c:	d8c02817 	ldw	r3,160(sp)
 2001f50:	dc001dc4 	addi	r16,sp,119
 2001f54:	9cc00c04 	addi	r19,r19,48
 2001f58:	1c07c83a 	sub	r3,r3,r16
 2001f5c:	dcc01dc5 	stb	r19,119(sp)
 2001f60:	d8c02e15 	stw	r3,184(sp)
 2001f64:	003ce806 	br	2001308 <__alt_mem_mem_0+0xfcfe1308>
 2001f68:	d8803317 	ldw	r2,204(sp)
 2001f6c:	143fffc4 	addi	r16,r2,-1
 2001f70:	043f4d0e 	bge	zero,r16,2001ca8 <__alt_mem_mem_0+0xfcfe1ca8>
 2001f74:	07000404 	movi	fp,16
 2001f78:	e400810e 	bge	fp,r16,2002180 <___vfprintf_internal_r+0x1594>
 2001f7c:	01408134 	movhi	r5,516
 2001f80:	2943d584 	addi	r5,r5,3926
 2001f84:	d9402b15 	stw	r5,172(sp)
 2001f88:	01c001c4 	movi	r7,7
 2001f8c:	dcc02c17 	ldw	r19,176(sp)
 2001f90:	00000306 	br	2001fa0 <___vfprintf_internal_r+0x13b4>
 2001f94:	b5800204 	addi	r22,r22,8
 2001f98:	843ffc04 	addi	r16,r16,-16
 2001f9c:	e4007b0e 	bge	fp,r16,200218c <___vfprintf_internal_r+0x15a0>
 2001fa0:	18c00404 	addi	r3,r3,16
 2001fa4:	8c400044 	addi	r17,r17,1
 2001fa8:	b5000015 	stw	r20,0(r22)
 2001fac:	b7000115 	stw	fp,4(r22)
 2001fb0:	d8c02015 	stw	r3,128(sp)
 2001fb4:	dc401f15 	stw	r17,124(sp)
 2001fb8:	3c7ff60e 	bge	r7,r17,2001f94 <__alt_mem_mem_0+0xfcfe1f94>
 2001fbc:	d9801e04 	addi	r6,sp,120
 2001fc0:	b80b883a 	mov	r5,r23
 2001fc4:	9809883a 	mov	r4,r19
 2001fc8:	d9c03c15 	stw	r7,240(sp)
 2001fcc:	20077040 	call	2007704 <__sprint_r>
 2001fd0:	d9c03c17 	ldw	r7,240(sp)
 2001fd4:	103c071e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2001fd8:	d8c02017 	ldw	r3,128(sp)
 2001fdc:	dc401f17 	ldw	r17,124(sp)
 2001fe0:	dd800404 	addi	r22,sp,16
 2001fe4:	003fec06 	br	2001f98 <__alt_mem_mem_0+0xfcfe1f98>
 2001fe8:	9080100c 	andi	r2,r18,64
 2001fec:	d8002785 	stb	zero,158(sp)
 2001ff0:	10010e26 	beq	r2,zero,200242c <___vfprintf_internal_r+0x1840>
 2001ff4:	d9002d17 	ldw	r4,180(sp)
 2001ff8:	d9402917 	ldw	r5,164(sp)
 2001ffc:	002d883a 	mov	r22,zero
 2002000:	20800104 	addi	r2,r4,4
 2002004:	24c0000b 	ldhu	r19,0(r4)
 2002008:	283fc90e 	bge	r5,zero,2001f30 <__alt_mem_mem_0+0xfcfe1f30>
 200200c:	d8802d15 	stw	r2,180(sp)
 2002010:	0039883a 	mov	fp,zero
 2002014:	9d84b03a 	or	r2,r19,r22
 2002018:	103c461e 	bne	r2,zero,2001134 <__alt_mem_mem_0+0xfcfe1134>
 200201c:	00800044 	movi	r2,1
 2002020:	003e6c06 	br	20019d4 <__alt_mem_mem_0+0xfcfe19d4>
 2002024:	d9002c17 	ldw	r4,176(sp)
 2002028:	d9801e04 	addi	r6,sp,120
 200202c:	b80b883a 	mov	r5,r23
 2002030:	20077040 	call	2007704 <__sprint_r>
 2002034:	103bef1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002038:	d8c02017 	ldw	r3,128(sp)
 200203c:	da000404 	addi	r8,sp,16
 2002040:	d9003217 	ldw	r4,200(sp)
 2002044:	d8802617 	ldw	r2,152(sp)
 2002048:	d9403317 	ldw	r5,204(sp)
 200204c:	8123883a 	add	r17,r16,r4
 2002050:	11400216 	blt	r2,r5,200205c <___vfprintf_internal_r+0x1470>
 2002054:	9100004c 	andi	r4,r18,1
 2002058:	20000d26 	beq	r4,zero,2002090 <___vfprintf_internal_r+0x14a4>
 200205c:	d9003717 	ldw	r4,220(sp)
 2002060:	d9403417 	ldw	r5,208(sp)
 2002064:	1907883a 	add	r3,r3,r4
 2002068:	d9001f17 	ldw	r4,124(sp)
 200206c:	41400015 	stw	r5,0(r8)
 2002070:	d9403717 	ldw	r5,220(sp)
 2002074:	21000044 	addi	r4,r4,1
 2002078:	d8c02015 	stw	r3,128(sp)
 200207c:	41400115 	stw	r5,4(r8)
 2002080:	d9001f15 	stw	r4,124(sp)
 2002084:	014001c4 	movi	r5,7
 2002088:	2901e816 	blt	r5,r4,200282c <___vfprintf_internal_r+0x1c40>
 200208c:	42000204 	addi	r8,r8,8
 2002090:	d9003317 	ldw	r4,204(sp)
 2002094:	8121883a 	add	r16,r16,r4
 2002098:	2085c83a 	sub	r2,r4,r2
 200209c:	8461c83a 	sub	r16,r16,r17
 20020a0:	1400010e 	bge	r2,r16,20020a8 <___vfprintf_internal_r+0x14bc>
 20020a4:	1021883a 	mov	r16,r2
 20020a8:	04000a0e 	bge	zero,r16,20020d4 <___vfprintf_internal_r+0x14e8>
 20020ac:	d9001f17 	ldw	r4,124(sp)
 20020b0:	1c07883a 	add	r3,r3,r16
 20020b4:	44400015 	stw	r17,0(r8)
 20020b8:	21000044 	addi	r4,r4,1
 20020bc:	44000115 	stw	r16,4(r8)
 20020c0:	d8c02015 	stw	r3,128(sp)
 20020c4:	d9001f15 	stw	r4,124(sp)
 20020c8:	014001c4 	movi	r5,7
 20020cc:	2901fb16 	blt	r5,r4,20028bc <___vfprintf_internal_r+0x1cd0>
 20020d0:	42000204 	addi	r8,r8,8
 20020d4:	8001f716 	blt	r16,zero,20028b4 <___vfprintf_internal_r+0x1cc8>
 20020d8:	1421c83a 	sub	r16,r2,r16
 20020dc:	043d380e 	bge	zero,r16,20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 20020e0:	04400404 	movi	r17,16
 20020e4:	d8801f17 	ldw	r2,124(sp)
 20020e8:	8c3efb0e 	bge	r17,r16,2001cd8 <__alt_mem_mem_0+0xfcfe1cd8>
 20020ec:	01408134 	movhi	r5,516
 20020f0:	2943d584 	addi	r5,r5,3926
 20020f4:	d9402b15 	stw	r5,172(sp)
 20020f8:	058001c4 	movi	r22,7
 20020fc:	dcc02c17 	ldw	r19,176(sp)
 2002100:	00000306 	br	2002110 <___vfprintf_internal_r+0x1524>
 2002104:	42000204 	addi	r8,r8,8
 2002108:	843ffc04 	addi	r16,r16,-16
 200210c:	8c3ef50e 	bge	r17,r16,2001ce4 <__alt_mem_mem_0+0xfcfe1ce4>
 2002110:	18c00404 	addi	r3,r3,16
 2002114:	10800044 	addi	r2,r2,1
 2002118:	45000015 	stw	r20,0(r8)
 200211c:	44400115 	stw	r17,4(r8)
 2002120:	d8c02015 	stw	r3,128(sp)
 2002124:	d8801f15 	stw	r2,124(sp)
 2002128:	b0bff60e 	bge	r22,r2,2002104 <__alt_mem_mem_0+0xfcfe2104>
 200212c:	d9801e04 	addi	r6,sp,120
 2002130:	b80b883a 	mov	r5,r23
 2002134:	9809883a 	mov	r4,r19
 2002138:	20077040 	call	2007704 <__sprint_r>
 200213c:	103bad1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002140:	d8c02017 	ldw	r3,128(sp)
 2002144:	d8801f17 	ldw	r2,124(sp)
 2002148:	da000404 	addi	r8,sp,16
 200214c:	003fee06 	br	2002108 <__alt_mem_mem_0+0xfcfe2108>
 2002150:	9088703a 	and	r4,r18,r2
 2002154:	203eab1e 	bne	r4,zero,2001c04 <__alt_mem_mem_0+0xfcfe1c04>
 2002158:	dc401f17 	ldw	r17,124(sp)
 200215c:	40800115 	stw	r2,4(r8)
 2002160:	44000015 	stw	r16,0(r8)
 2002164:	8c400044 	addi	r17,r17,1
 2002168:	d8c02015 	stw	r3,128(sp)
 200216c:	dc401f15 	stw	r17,124(sp)
 2002170:	008001c4 	movi	r2,7
 2002174:	14400e16 	blt	r2,r17,20021b0 <___vfprintf_internal_r+0x15c4>
 2002178:	45800204 	addi	r22,r8,8
 200217c:	003eca06 	br	2001ca8 <__alt_mem_mem_0+0xfcfe1ca8>
 2002180:	01008134 	movhi	r4,516
 2002184:	2103d584 	addi	r4,r4,3926
 2002188:	d9002b15 	stw	r4,172(sp)
 200218c:	d8802b17 	ldw	r2,172(sp)
 2002190:	1c07883a 	add	r3,r3,r16
 2002194:	8c400044 	addi	r17,r17,1
 2002198:	b0800015 	stw	r2,0(r22)
 200219c:	b4000115 	stw	r16,4(r22)
 20021a0:	d8c02015 	stw	r3,128(sp)
 20021a4:	dc401f15 	stw	r17,124(sp)
 20021a8:	008001c4 	movi	r2,7
 20021ac:	147ebd0e 	bge	r2,r17,2001ca4 <__alt_mem_mem_0+0xfcfe1ca4>
 20021b0:	d9002c17 	ldw	r4,176(sp)
 20021b4:	d9801e04 	addi	r6,sp,120
 20021b8:	b80b883a 	mov	r5,r23
 20021bc:	20077040 	call	2007704 <__sprint_r>
 20021c0:	103b8c1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 20021c4:	d8c02017 	ldw	r3,128(sp)
 20021c8:	dc401f17 	ldw	r17,124(sp)
 20021cc:	dd800404 	addi	r22,sp,16
 20021d0:	003eb506 	br	2001ca8 <__alt_mem_mem_0+0xfcfe1ca8>
 20021d4:	d9002c17 	ldw	r4,176(sp)
 20021d8:	d9801e04 	addi	r6,sp,120
 20021dc:	b80b883a 	mov	r5,r23
 20021e0:	20077040 	call	2007704 <__sprint_r>
 20021e4:	103b831e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 20021e8:	d8c02017 	ldw	r3,128(sp)
 20021ec:	dc401f17 	ldw	r17,124(sp)
 20021f0:	da000404 	addi	r8,sp,16
 20021f4:	003e8d06 	br	2001c2c <__alt_mem_mem_0+0xfcfe1c2c>
 20021f8:	d9002c17 	ldw	r4,176(sp)
 20021fc:	d9801e04 	addi	r6,sp,120
 2002200:	b80b883a 	mov	r5,r23
 2002204:	20077040 	call	2007704 <__sprint_r>
 2002208:	103b7a1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 200220c:	d8c02017 	ldw	r3,128(sp)
 2002210:	dc401f17 	ldw	r17,124(sp)
 2002214:	dd800404 	addi	r22,sp,16
 2002218:	003e8f06 	br	2001c58 <__alt_mem_mem_0+0xfcfe1c58>
 200221c:	0027883a 	mov	r19,zero
 2002220:	003f4a06 	br	2001f4c <__alt_mem_mem_0+0xfcfe1f4c>
 2002224:	d9002c17 	ldw	r4,176(sp)
 2002228:	d9801e04 	addi	r6,sp,120
 200222c:	b80b883a 	mov	r5,r23
 2002230:	20077040 	call	2007704 <__sprint_r>
 2002234:	103b6f1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002238:	d8c02017 	ldw	r3,128(sp)
 200223c:	da000404 	addi	r8,sp,16
 2002240:	003c9d06 	br	20014b8 <__alt_mem_mem_0+0xfcfe14b8>
 2002244:	04e7c83a 	sub	r19,zero,r19
 2002248:	9804c03a 	cmpne	r2,r19,zero
 200224c:	05adc83a 	sub	r22,zero,r22
 2002250:	b0adc83a 	sub	r22,r22,r2
 2002254:	d8802917 	ldw	r2,164(sp)
 2002258:	07000b44 	movi	fp,45
 200225c:	df002785 	stb	fp,158(sp)
 2002260:	10017b16 	blt	r2,zero,2002850 <___vfprintf_internal_r+0x1c64>
 2002264:	00bfdfc4 	movi	r2,-129
 2002268:	90a4703a 	and	r18,r18,r2
 200226c:	003bb106 	br	2001134 <__alt_mem_mem_0+0xfcfe1134>
 2002270:	d9003617 	ldw	r4,216(sp)
 2002274:	d9403817 	ldw	r5,224(sp)
 2002278:	da003d15 	stw	r8,244(sp)
 200227c:	20072900 	call	2007290 <__fpclassifyd>
 2002280:	da003d17 	ldw	r8,244(sp)
 2002284:	1000f026 	beq	r2,zero,2002648 <___vfprintf_internal_r+0x1a5c>
 2002288:	d9002917 	ldw	r4,164(sp)
 200228c:	05bff7c4 	movi	r22,-33
 2002290:	00bfffc4 	movi	r2,-1
 2002294:	8dac703a 	and	r22,r17,r22
 2002298:	20820026 	beq	r4,r2,2002a9c <___vfprintf_internal_r+0x1eb0>
 200229c:	008011c4 	movi	r2,71
 20022a0:	b081f726 	beq	r22,r2,2002a80 <___vfprintf_internal_r+0x1e94>
 20022a4:	d9003817 	ldw	r4,224(sp)
 20022a8:	90c04014 	ori	r3,r18,256
 20022ac:	d8c02b15 	stw	r3,172(sp)
 20022b0:	20021516 	blt	r4,zero,2002b08 <___vfprintf_internal_r+0x1f1c>
 20022b4:	dcc03817 	ldw	r19,224(sp)
 20022b8:	d8002a05 	stb	zero,168(sp)
 20022bc:	00801984 	movi	r2,102
 20022c0:	8881f926 	beq	r17,r2,2002aa8 <___vfprintf_internal_r+0x1ebc>
 20022c4:	00801184 	movi	r2,70
 20022c8:	88821c26 	beq	r17,r2,2002b3c <___vfprintf_internal_r+0x1f50>
 20022cc:	00801144 	movi	r2,69
 20022d0:	b081ef26 	beq	r22,r2,2002a90 <___vfprintf_internal_r+0x1ea4>
 20022d4:	d8c02917 	ldw	r3,164(sp)
 20022d8:	d8802104 	addi	r2,sp,132
 20022dc:	d8800315 	stw	r2,12(sp)
 20022e0:	d9403617 	ldw	r5,216(sp)
 20022e4:	d8802504 	addi	r2,sp,148
 20022e8:	d9002c17 	ldw	r4,176(sp)
 20022ec:	d8800215 	stw	r2,8(sp)
 20022f0:	d8802604 	addi	r2,sp,152
 20022f4:	d8c00015 	stw	r3,0(sp)
 20022f8:	d8800115 	stw	r2,4(sp)
 20022fc:	01c00084 	movi	r7,2
 2002300:	980d883a 	mov	r6,r19
 2002304:	d8c03c15 	stw	r3,240(sp)
 2002308:	da003d15 	stw	r8,244(sp)
 200230c:	20032100 	call	2003210 <_dtoa_r>
 2002310:	1021883a 	mov	r16,r2
 2002314:	008019c4 	movi	r2,103
 2002318:	d8c03c17 	ldw	r3,240(sp)
 200231c:	da003d17 	ldw	r8,244(sp)
 2002320:	88817126 	beq	r17,r2,20028e8 <___vfprintf_internal_r+0x1cfc>
 2002324:	008011c4 	movi	r2,71
 2002328:	88829226 	beq	r17,r2,2002d74 <___vfprintf_internal_r+0x2188>
 200232c:	80f9883a 	add	fp,r16,r3
 2002330:	d9003617 	ldw	r4,216(sp)
 2002334:	000d883a 	mov	r6,zero
 2002338:	000f883a 	mov	r7,zero
 200233c:	980b883a 	mov	r5,r19
 2002340:	da003d15 	stw	r8,244(sp)
 2002344:	200bef80 	call	200bef8 <__eqdf2>
 2002348:	da003d17 	ldw	r8,244(sp)
 200234c:	10018d26 	beq	r2,zero,2002984 <___vfprintf_internal_r+0x1d98>
 2002350:	d8802117 	ldw	r2,132(sp)
 2002354:	1700062e 	bgeu	r2,fp,2002370 <___vfprintf_internal_r+0x1784>
 2002358:	01000c04 	movi	r4,48
 200235c:	10c00044 	addi	r3,r2,1
 2002360:	d8c02115 	stw	r3,132(sp)
 2002364:	11000005 	stb	r4,0(r2)
 2002368:	d8802117 	ldw	r2,132(sp)
 200236c:	173ffb36 	bltu	r2,fp,200235c <__alt_mem_mem_0+0xfcfe235c>
 2002370:	1405c83a 	sub	r2,r2,r16
 2002374:	d8803315 	stw	r2,204(sp)
 2002378:	008011c4 	movi	r2,71
 200237c:	b0817626 	beq	r22,r2,2002958 <___vfprintf_internal_r+0x1d6c>
 2002380:	00801944 	movi	r2,101
 2002384:	1442810e 	bge	r2,r17,2002d8c <___vfprintf_internal_r+0x21a0>
 2002388:	d8c02617 	ldw	r3,152(sp)
 200238c:	00801984 	movi	r2,102
 2002390:	d8c03215 	stw	r3,200(sp)
 2002394:	8881fe26 	beq	r17,r2,2002b90 <___vfprintf_internal_r+0x1fa4>
 2002398:	d8c03217 	ldw	r3,200(sp)
 200239c:	d9003317 	ldw	r4,204(sp)
 20023a0:	1901dd16 	blt	r3,r4,2002b18 <___vfprintf_internal_r+0x1f2c>
 20023a4:	9480004c 	andi	r18,r18,1
 20023a8:	90022b1e 	bne	r18,zero,2002c58 <___vfprintf_internal_r+0x206c>
 20023ac:	1805883a 	mov	r2,r3
 20023b0:	18028016 	blt	r3,zero,2002db4 <___vfprintf_internal_r+0x21c8>
 20023b4:	d8c03217 	ldw	r3,200(sp)
 20023b8:	044019c4 	movi	r17,103
 20023bc:	d8c02e15 	stw	r3,184(sp)
 20023c0:	df002a07 	ldb	fp,168(sp)
 20023c4:	e001531e 	bne	fp,zero,2002914 <___vfprintf_internal_r+0x1d28>
 20023c8:	df002783 	ldbu	fp,158(sp)
 20023cc:	d8802a15 	stw	r2,168(sp)
 20023d0:	dc802b17 	ldw	r18,172(sp)
 20023d4:	d8002915 	stw	zero,164(sp)
 20023d8:	003bd106 	br	2001320 <__alt_mem_mem_0+0xfcfe1320>
 20023dc:	d8802d17 	ldw	r2,180(sp)
 20023e0:	d8c02d17 	ldw	r3,180(sp)
 20023e4:	d9002d17 	ldw	r4,180(sp)
 20023e8:	10800017 	ldw	r2,0(r2)
 20023ec:	18c00117 	ldw	r3,4(r3)
 20023f0:	21000204 	addi	r4,r4,8
 20023f4:	d8803615 	stw	r2,216(sp)
 20023f8:	d8c03815 	stw	r3,224(sp)
 20023fc:	d9002d15 	stw	r4,180(sp)
 2002400:	003b7506 	br	20011d8 <__alt_mem_mem_0+0xfcfe11d8>
 2002404:	ac400007 	ldb	r17,0(r21)
 2002408:	003a5906 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 200240c:	9080100c 	andi	r2,r18,64
 2002410:	1000a826 	beq	r2,zero,20026b4 <___vfprintf_internal_r+0x1ac8>
 2002414:	d9002d17 	ldw	r4,180(sp)
 2002418:	002d883a 	mov	r22,zero
 200241c:	24c0000b 	ldhu	r19,0(r4)
 2002420:	21000104 	addi	r4,r4,4
 2002424:	d9002d15 	stw	r4,180(sp)
 2002428:	003ccb06 	br	2001758 <__alt_mem_mem_0+0xfcfe1758>
 200242c:	d8c02d17 	ldw	r3,180(sp)
 2002430:	d9002917 	ldw	r4,164(sp)
 2002434:	002d883a 	mov	r22,zero
 2002438:	18800104 	addi	r2,r3,4
 200243c:	1cc00017 	ldw	r19,0(r3)
 2002440:	203ebb0e 	bge	r4,zero,2001f30 <__alt_mem_mem_0+0xfcfe1f30>
 2002444:	003ef106 	br	200200c <__alt_mem_mem_0+0xfcfe200c>
 2002448:	9080040c 	andi	r2,r18,16
 200244c:	1000921e 	bne	r2,zero,2002698 <___vfprintf_internal_r+0x1aac>
 2002450:	9480100c 	andi	r18,r18,64
 2002454:	90013926 	beq	r18,zero,200293c <___vfprintf_internal_r+0x1d50>
 2002458:	d9002d17 	ldw	r4,180(sp)
 200245c:	d9402f17 	ldw	r5,188(sp)
 2002460:	20800017 	ldw	r2,0(r4)
 2002464:	21000104 	addi	r4,r4,4
 2002468:	d9002d15 	stw	r4,180(sp)
 200246c:	1140000d 	sth	r5,0(r2)
 2002470:	003a1606 	br	2000ccc <__alt_mem_mem_0+0xfcfe0ccc>
 2002474:	9080100c 	andi	r2,r18,64
 2002478:	10008026 	beq	r2,zero,200267c <___vfprintf_internal_r+0x1a90>
 200247c:	d8c02d17 	ldw	r3,180(sp)
 2002480:	1cc0000f 	ldh	r19,0(r3)
 2002484:	18c00104 	addi	r3,r3,4
 2002488:	d8c02d15 	stw	r3,180(sp)
 200248c:	982dd7fa 	srai	r22,r19,31
 2002490:	b005883a 	mov	r2,r22
 2002494:	003b1f06 	br	2001114 <__alt_mem_mem_0+0xfcfe1114>
 2002498:	9080100c 	andi	r2,r18,64
 200249c:	d8002785 	stb	zero,158(sp)
 20024a0:	10008a1e 	bne	r2,zero,20026cc <___vfprintf_internal_r+0x1ae0>
 20024a4:	d9402d17 	ldw	r5,180(sp)
 20024a8:	d8c02917 	ldw	r3,164(sp)
 20024ac:	002d883a 	mov	r22,zero
 20024b0:	28800104 	addi	r2,r5,4
 20024b4:	2cc00017 	ldw	r19,0(r5)
 20024b8:	183e4b0e 	bge	r3,zero,2001de8 <__alt_mem_mem_0+0xfcfe1de8>
 20024bc:	9d86b03a 	or	r3,r19,r22
 20024c0:	d8802d15 	stw	r2,180(sp)
 20024c4:	183e4c1e 	bne	r3,zero,2001df8 <__alt_mem_mem_0+0xfcfe1df8>
 20024c8:	0039883a 	mov	fp,zero
 20024cc:	0005883a 	mov	r2,zero
 20024d0:	003d4006 	br	20019d4 <__alt_mem_mem_0+0xfcfe19d4>
 20024d4:	01408134 	movhi	r5,516
 20024d8:	2943d584 	addi	r5,r5,3926
 20024dc:	d9402b15 	stw	r5,172(sp)
 20024e0:	d9402b17 	ldw	r5,172(sp)
 20024e4:	1c47883a 	add	r3,r3,r17
 20024e8:	10800044 	addi	r2,r2,1
 20024ec:	41400015 	stw	r5,0(r8)
 20024f0:	44400115 	stw	r17,4(r8)
 20024f4:	d8c02015 	stw	r3,128(sp)
 20024f8:	d8801f15 	stw	r2,124(sp)
 20024fc:	010001c4 	movi	r4,7
 2002500:	20bec816 	blt	r4,r2,2002024 <__alt_mem_mem_0+0xfcfe2024>
 2002504:	42000204 	addi	r8,r8,8
 2002508:	003ecd06 	br	2002040 <__alt_mem_mem_0+0xfcfe2040>
 200250c:	d9002917 	ldw	r4,164(sp)
 2002510:	d8002785 	stb	zero,158(sp)
 2002514:	203d2d16 	blt	r4,zero,20019cc <__alt_mem_mem_0+0xfcfe19cc>
 2002518:	00bfdfc4 	movi	r2,-129
 200251c:	90a4703a 	and	r18,r18,r2
 2002520:	003a9106 	br	2000f68 <__alt_mem_mem_0+0xfcfe0f68>
 2002524:	01008134 	movhi	r4,516
 2002528:	2103d584 	addi	r4,r4,3926
 200252c:	d9002b15 	stw	r4,172(sp)
 2002530:	003c0c06 	br	2001564 <__alt_mem_mem_0+0xfcfe1564>
 2002534:	d9002c17 	ldw	r4,176(sp)
 2002538:	d9801e04 	addi	r6,sp,120
 200253c:	b80b883a 	mov	r5,r23
 2002540:	20077040 	call	2007704 <__sprint_r>
 2002544:	103aab1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002548:	d8c02017 	ldw	r3,128(sp)
 200254c:	da000404 	addi	r8,sp,16
 2002550:	003d4106 	br	2001a58 <__alt_mem_mem_0+0xfcfe1a58>
 2002554:	d8801f17 	ldw	r2,124(sp)
 2002558:	01408134 	movhi	r5,516
 200255c:	01000044 	movi	r4,1
 2002560:	18c00044 	addi	r3,r3,1
 2002564:	10800044 	addi	r2,r2,1
 2002568:	2943d504 	addi	r5,r5,3924
 200256c:	41000115 	stw	r4,4(r8)
 2002570:	41400015 	stw	r5,0(r8)
 2002574:	d8c02015 	stw	r3,128(sp)
 2002578:	d8801f15 	stw	r2,124(sp)
 200257c:	010001c4 	movi	r4,7
 2002580:	20805c16 	blt	r4,r2,20026f4 <___vfprintf_internal_r+0x1b08>
 2002584:	42000204 	addi	r8,r8,8
 2002588:	8800041e 	bne	r17,zero,200259c <___vfprintf_internal_r+0x19b0>
 200258c:	d8803317 	ldw	r2,204(sp)
 2002590:	1000021e 	bne	r2,zero,200259c <___vfprintf_internal_r+0x19b0>
 2002594:	9080004c 	andi	r2,r18,1
 2002598:	103c0926 	beq	r2,zero,20015c0 <__alt_mem_mem_0+0xfcfe15c0>
 200259c:	d9003717 	ldw	r4,220(sp)
 20025a0:	d8801f17 	ldw	r2,124(sp)
 20025a4:	d9403417 	ldw	r5,208(sp)
 20025a8:	20c7883a 	add	r3,r4,r3
 20025ac:	10800044 	addi	r2,r2,1
 20025b0:	41000115 	stw	r4,4(r8)
 20025b4:	41400015 	stw	r5,0(r8)
 20025b8:	d8c02015 	stw	r3,128(sp)
 20025bc:	d8801f15 	stw	r2,124(sp)
 20025c0:	010001c4 	movi	r4,7
 20025c4:	20812116 	blt	r4,r2,2002a4c <___vfprintf_internal_r+0x1e60>
 20025c8:	42000204 	addi	r8,r8,8
 20025cc:	0463c83a 	sub	r17,zero,r17
 20025d0:	0440730e 	bge	zero,r17,20027a0 <___vfprintf_internal_r+0x1bb4>
 20025d4:	05800404 	movi	r22,16
 20025d8:	b440860e 	bge	r22,r17,20027f4 <___vfprintf_internal_r+0x1c08>
 20025dc:	01408134 	movhi	r5,516
 20025e0:	2943d584 	addi	r5,r5,3926
 20025e4:	d9402b15 	stw	r5,172(sp)
 20025e8:	070001c4 	movi	fp,7
 20025ec:	dcc02c17 	ldw	r19,176(sp)
 20025f0:	00000306 	br	2002600 <___vfprintf_internal_r+0x1a14>
 20025f4:	42000204 	addi	r8,r8,8
 20025f8:	8c7ffc04 	addi	r17,r17,-16
 20025fc:	b440800e 	bge	r22,r17,2002800 <___vfprintf_internal_r+0x1c14>
 2002600:	18c00404 	addi	r3,r3,16
 2002604:	10800044 	addi	r2,r2,1
 2002608:	45000015 	stw	r20,0(r8)
 200260c:	45800115 	stw	r22,4(r8)
 2002610:	d8c02015 	stw	r3,128(sp)
 2002614:	d8801f15 	stw	r2,124(sp)
 2002618:	e0bff60e 	bge	fp,r2,20025f4 <__alt_mem_mem_0+0xfcfe25f4>
 200261c:	d9801e04 	addi	r6,sp,120
 2002620:	b80b883a 	mov	r5,r23
 2002624:	9809883a 	mov	r4,r19
 2002628:	20077040 	call	2007704 <__sprint_r>
 200262c:	103a711e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002630:	d8c02017 	ldw	r3,128(sp)
 2002634:	d8801f17 	ldw	r2,124(sp)
 2002638:	da000404 	addi	r8,sp,16
 200263c:	003fee06 	br	20025f8 <__alt_mem_mem_0+0xfcfe25f8>
 2002640:	00bfffc4 	movi	r2,-1
 2002644:	003a6f06 	br	2001004 <__alt_mem_mem_0+0xfcfe1004>
 2002648:	008011c4 	movi	r2,71
 200264c:	1440b816 	blt	r2,r17,2002930 <___vfprintf_internal_r+0x1d44>
 2002650:	04008134 	movhi	r16,516
 2002654:	8403c704 	addi	r16,r16,3868
 2002658:	00c000c4 	movi	r3,3
 200265c:	00bfdfc4 	movi	r2,-129
 2002660:	d8c02a15 	stw	r3,168(sp)
 2002664:	90a4703a 	and	r18,r18,r2
 2002668:	df002783 	ldbu	fp,158(sp)
 200266c:	d8c02e15 	stw	r3,184(sp)
 2002670:	d8002915 	stw	zero,164(sp)
 2002674:	d8003215 	stw	zero,200(sp)
 2002678:	003b2906 	br	2001320 <__alt_mem_mem_0+0xfcfe1320>
 200267c:	d9002d17 	ldw	r4,180(sp)
 2002680:	24c00017 	ldw	r19,0(r4)
 2002684:	21000104 	addi	r4,r4,4
 2002688:	d9002d15 	stw	r4,180(sp)
 200268c:	982dd7fa 	srai	r22,r19,31
 2002690:	b005883a 	mov	r2,r22
 2002694:	003a9f06 	br	2001114 <__alt_mem_mem_0+0xfcfe1114>
 2002698:	d9402d17 	ldw	r5,180(sp)
 200269c:	d8c02f17 	ldw	r3,188(sp)
 20026a0:	28800017 	ldw	r2,0(r5)
 20026a4:	29400104 	addi	r5,r5,4
 20026a8:	d9402d15 	stw	r5,180(sp)
 20026ac:	10c00015 	stw	r3,0(r2)
 20026b0:	00398606 	br	2000ccc <__alt_mem_mem_0+0xfcfe0ccc>
 20026b4:	d9402d17 	ldw	r5,180(sp)
 20026b8:	002d883a 	mov	r22,zero
 20026bc:	2cc00017 	ldw	r19,0(r5)
 20026c0:	29400104 	addi	r5,r5,4
 20026c4:	d9402d15 	stw	r5,180(sp)
 20026c8:	003c2306 	br	2001758 <__alt_mem_mem_0+0xfcfe1758>
 20026cc:	d8c02d17 	ldw	r3,180(sp)
 20026d0:	d9002917 	ldw	r4,164(sp)
 20026d4:	002d883a 	mov	r22,zero
 20026d8:	18800104 	addi	r2,r3,4
 20026dc:	1cc0000b 	ldhu	r19,0(r3)
 20026e0:	203dc10e 	bge	r4,zero,2001de8 <__alt_mem_mem_0+0xfcfe1de8>
 20026e4:	003f7506 	br	20024bc <__alt_mem_mem_0+0xfcfe24bc>
 20026e8:	04008134 	movhi	r16,516
 20026ec:	8403c504 	addi	r16,r16,3860
 20026f0:	003acc06 	br	2001224 <__alt_mem_mem_0+0xfcfe1224>
 20026f4:	d9002c17 	ldw	r4,176(sp)
 20026f8:	d9801e04 	addi	r6,sp,120
 20026fc:	b80b883a 	mov	r5,r23
 2002700:	20077040 	call	2007704 <__sprint_r>
 2002704:	103a3b1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002708:	dc402617 	ldw	r17,152(sp)
 200270c:	d8c02017 	ldw	r3,128(sp)
 2002710:	da000404 	addi	r8,sp,16
 2002714:	003f9c06 	br	2002588 <__alt_mem_mem_0+0xfcfe2588>
 2002718:	ac400043 	ldbu	r17,1(r21)
 200271c:	94800814 	ori	r18,r18,32
 2002720:	ad400044 	addi	r21,r21,1
 2002724:	8c403fcc 	andi	r17,r17,255
 2002728:	8c40201c 	xori	r17,r17,128
 200272c:	8c7fe004 	addi	r17,r17,-128
 2002730:	00398f06 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2002734:	d8c02d15 	stw	r3,180(sp)
 2002738:	0039883a 	mov	fp,zero
 200273c:	003e3506 	br	2002014 <__alt_mem_mem_0+0xfcfe2014>
 2002740:	d9002c17 	ldw	r4,176(sp)
 2002744:	d9801e04 	addi	r6,sp,120
 2002748:	b80b883a 	mov	r5,r23
 200274c:	20077040 	call	2007704 <__sprint_r>
 2002750:	103a281e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002754:	d8c02017 	ldw	r3,128(sp)
 2002758:	da000404 	addi	r8,sp,16
 200275c:	003cd006 	br	2001aa0 <__alt_mem_mem_0+0xfcfe1aa0>
 2002760:	8009883a 	mov	r4,r16
 2002764:	da003d15 	stw	r8,244(sp)
 2002768:	20075700 	call	2007570 <strlen>
 200276c:	d8802e15 	stw	r2,184(sp)
 2002770:	da003d17 	ldw	r8,244(sp)
 2002774:	103c340e 	bge	r2,zero,2001848 <__alt_mem_mem_0+0xfcfe1848>
 2002778:	0005883a 	mov	r2,zero
 200277c:	003c3206 	br	2001848 <__alt_mem_mem_0+0xfcfe1848>
 2002780:	d9002c17 	ldw	r4,176(sp)
 2002784:	d9801e04 	addi	r6,sp,120
 2002788:	b80b883a 	mov	r5,r23
 200278c:	20077040 	call	2007704 <__sprint_r>
 2002790:	103a181e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002794:	d8c02017 	ldw	r3,128(sp)
 2002798:	d8801f17 	ldw	r2,124(sp)
 200279c:	da000404 	addi	r8,sp,16
 20027a0:	d9403317 	ldw	r5,204(sp)
 20027a4:	10800044 	addi	r2,r2,1
 20027a8:	44000015 	stw	r16,0(r8)
 20027ac:	28c7883a 	add	r3,r5,r3
 20027b0:	003b7d06 	br	20015a8 <__alt_mem_mem_0+0xfcfe15a8>
 20027b4:	01008134 	movhi	r4,516
 20027b8:	2103d984 	addi	r4,r4,3942
 20027bc:	d9003515 	stw	r4,212(sp)
 20027c0:	003b1406 	br	2001414 <__alt_mem_mem_0+0xfcfe1414>
 20027c4:	013fffc4 	movi	r4,-1
 20027c8:	003a3506 	br	20010a0 <__alt_mem_mem_0+0xfcfe10a0>
 20027cc:	0023883a 	mov	r17,zero
 20027d0:	003d9d06 	br	2001e48 <__alt_mem_mem_0+0xfcfe1e48>
 20027d4:	d9002c17 	ldw	r4,176(sp)
 20027d8:	d9801e04 	addi	r6,sp,120
 20027dc:	b80b883a 	mov	r5,r23
 20027e0:	20077040 	call	2007704 <__sprint_r>
 20027e4:	103a031e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 20027e8:	d8c02017 	ldw	r3,128(sp)
 20027ec:	da000404 	addi	r8,sp,16
 20027f0:	003d9406 	br	2001e44 <__alt_mem_mem_0+0xfcfe1e44>
 20027f4:	01008134 	movhi	r4,516
 20027f8:	2103d584 	addi	r4,r4,3926
 20027fc:	d9002b15 	stw	r4,172(sp)
 2002800:	d9002b17 	ldw	r4,172(sp)
 2002804:	1c47883a 	add	r3,r3,r17
 2002808:	10800044 	addi	r2,r2,1
 200280c:	41000015 	stw	r4,0(r8)
 2002810:	44400115 	stw	r17,4(r8)
 2002814:	d8c02015 	stw	r3,128(sp)
 2002818:	d8801f15 	stw	r2,124(sp)
 200281c:	010001c4 	movi	r4,7
 2002820:	20bfd716 	blt	r4,r2,2002780 <__alt_mem_mem_0+0xfcfe2780>
 2002824:	42000204 	addi	r8,r8,8
 2002828:	003fdd06 	br	20027a0 <__alt_mem_mem_0+0xfcfe27a0>
 200282c:	d9002c17 	ldw	r4,176(sp)
 2002830:	d9801e04 	addi	r6,sp,120
 2002834:	b80b883a 	mov	r5,r23
 2002838:	20077040 	call	2007704 <__sprint_r>
 200283c:	1039ed1e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002840:	d8802617 	ldw	r2,152(sp)
 2002844:	d8c02017 	ldw	r3,128(sp)
 2002848:	da000404 	addi	r8,sp,16
 200284c:	003e1006 	br	2002090 <__alt_mem_mem_0+0xfcfe2090>
 2002850:	00800044 	movi	r2,1
 2002854:	10803fcc 	andi	r2,r2,255
 2002858:	00c00044 	movi	r3,1
 200285c:	10fa3526 	beq	r2,r3,2001134 <__alt_mem_mem_0+0xfcfe1134>
 2002860:	00c00084 	movi	r3,2
 2002864:	10fbcb26 	beq	r2,r3,2001794 <__alt_mem_mem_0+0xfcfe1794>
 2002868:	003a8f06 	br	20012a8 <__alt_mem_mem_0+0xfcfe12a8>
 200286c:	01008134 	movhi	r4,516
 2002870:	2103d984 	addi	r4,r4,3942
 2002874:	d9003515 	stw	r4,212(sp)
 2002878:	003b7606 	br	2001654 <__alt_mem_mem_0+0xfcfe1654>
 200287c:	d8802917 	ldw	r2,164(sp)
 2002880:	00c00184 	movi	r3,6
 2002884:	1880012e 	bgeu	r3,r2,200288c <___vfprintf_internal_r+0x1ca0>
 2002888:	1805883a 	mov	r2,r3
 200288c:	d8802e15 	stw	r2,184(sp)
 2002890:	1000ef16 	blt	r2,zero,2002c50 <___vfprintf_internal_r+0x2064>
 2002894:	04008134 	movhi	r16,516
 2002898:	d8802a15 	stw	r2,168(sp)
 200289c:	dcc02d15 	stw	r19,180(sp)
 20028a0:	d8002915 	stw	zero,164(sp)
 20028a4:	d8003215 	stw	zero,200(sp)
 20028a8:	8403d304 	addi	r16,r16,3916
 20028ac:	0039883a 	mov	fp,zero
 20028b0:	003aa206 	br	200133c <__alt_mem_mem_0+0xfcfe133c>
 20028b4:	0021883a 	mov	r16,zero
 20028b8:	003e0706 	br	20020d8 <__alt_mem_mem_0+0xfcfe20d8>
 20028bc:	d9002c17 	ldw	r4,176(sp)
 20028c0:	d9801e04 	addi	r6,sp,120
 20028c4:	b80b883a 	mov	r5,r23
 20028c8:	20077040 	call	2007704 <__sprint_r>
 20028cc:	1039c91e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 20028d0:	d8802617 	ldw	r2,152(sp)
 20028d4:	d9403317 	ldw	r5,204(sp)
 20028d8:	d8c02017 	ldw	r3,128(sp)
 20028dc:	da000404 	addi	r8,sp,16
 20028e0:	2885c83a 	sub	r2,r5,r2
 20028e4:	003dfb06 	br	20020d4 <__alt_mem_mem_0+0xfcfe20d4>
 20028e8:	9080004c 	andi	r2,r18,1
 20028ec:	103e8f1e 	bne	r2,zero,200232c <__alt_mem_mem_0+0xfcfe232c>
 20028f0:	d8802117 	ldw	r2,132(sp)
 20028f4:	003e9e06 	br	2002370 <__alt_mem_mem_0+0xfcfe2370>
 20028f8:	1025883a 	mov	r18,r2
 20028fc:	0039883a 	mov	fp,zero
 2002900:	00800084 	movi	r2,2
 2002904:	003fd306 	br	2002854 <__alt_mem_mem_0+0xfcfe2854>
 2002908:	07000b44 	movi	fp,45
 200290c:	df002785 	stb	fp,158(sp)
 2002910:	003a4006 	br	2001214 <__alt_mem_mem_0+0xfcfe1214>
 2002914:	00c00b44 	movi	r3,45
 2002918:	d8c02785 	stb	r3,158(sp)
 200291c:	d8802a15 	stw	r2,168(sp)
 2002920:	dc802b17 	ldw	r18,172(sp)
 2002924:	d8002915 	stw	zero,164(sp)
 2002928:	07000b44 	movi	fp,45
 200292c:	003a8006 	br	2001330 <__alt_mem_mem_0+0xfcfe1330>
 2002930:	04008134 	movhi	r16,516
 2002934:	8403c804 	addi	r16,r16,3872
 2002938:	003f4706 	br	2002658 <__alt_mem_mem_0+0xfcfe2658>
 200293c:	d8c02d17 	ldw	r3,180(sp)
 2002940:	d9002f17 	ldw	r4,188(sp)
 2002944:	18800017 	ldw	r2,0(r3)
 2002948:	18c00104 	addi	r3,r3,4
 200294c:	d8c02d15 	stw	r3,180(sp)
 2002950:	11000015 	stw	r4,0(r2)
 2002954:	0038dd06 	br	2000ccc <__alt_mem_mem_0+0xfcfe0ccc>
 2002958:	dd802617 	ldw	r22,152(sp)
 200295c:	00bfff44 	movi	r2,-3
 2002960:	b0801c16 	blt	r22,r2,20029d4 <___vfprintf_internal_r+0x1de8>
 2002964:	d9402917 	ldw	r5,164(sp)
 2002968:	2d801a16 	blt	r5,r22,20029d4 <___vfprintf_internal_r+0x1de8>
 200296c:	dd803215 	stw	r22,200(sp)
 2002970:	003e8906 	br	2002398 <__alt_mem_mem_0+0xfcfe2398>
 2002974:	01008134 	movhi	r4,516
 2002978:	2103d584 	addi	r4,r4,3926
 200297c:	d9002b15 	stw	r4,172(sp)
 2002980:	003c9106 	br	2001bc8 <__alt_mem_mem_0+0xfcfe1bc8>
 2002984:	e005883a 	mov	r2,fp
 2002988:	003e7906 	br	2002370 <__alt_mem_mem_0+0xfcfe2370>
 200298c:	d9402917 	ldw	r5,164(sp)
 2002990:	df002783 	ldbu	fp,158(sp)
 2002994:	dcc02d15 	stw	r19,180(sp)
 2002998:	d9402a15 	stw	r5,168(sp)
 200299c:	d9402e15 	stw	r5,184(sp)
 20029a0:	d8002915 	stw	zero,164(sp)
 20029a4:	d8003215 	stw	zero,200(sp)
 20029a8:	003a5d06 	br	2001320 <__alt_mem_mem_0+0xfcfe1320>
 20029ac:	9080004c 	andi	r2,r18,1
 20029b0:	0039883a 	mov	fp,zero
 20029b4:	10000426 	beq	r2,zero,20029c8 <___vfprintf_internal_r+0x1ddc>
 20029b8:	00800c04 	movi	r2,48
 20029bc:	dc001dc4 	addi	r16,sp,119
 20029c0:	d8801dc5 	stb	r2,119(sp)
 20029c4:	003b8006 	br	20017c8 <__alt_mem_mem_0+0xfcfe17c8>
 20029c8:	d8002e15 	stw	zero,184(sp)
 20029cc:	dc001e04 	addi	r16,sp,120
 20029d0:	003a4d06 	br	2001308 <__alt_mem_mem_0+0xfcfe1308>
 20029d4:	8c7fff84 	addi	r17,r17,-2
 20029d8:	b5bfffc4 	addi	r22,r22,-1
 20029dc:	dd802615 	stw	r22,152(sp)
 20029e0:	dc4022c5 	stb	r17,139(sp)
 20029e4:	b000bf16 	blt	r22,zero,2002ce4 <___vfprintf_internal_r+0x20f8>
 20029e8:	00800ac4 	movi	r2,43
 20029ec:	d8802305 	stb	r2,140(sp)
 20029f0:	00800244 	movi	r2,9
 20029f4:	15807016 	blt	r2,r22,2002bb8 <___vfprintf_internal_r+0x1fcc>
 20029f8:	00800c04 	movi	r2,48
 20029fc:	b5800c04 	addi	r22,r22,48
 2002a00:	d8802345 	stb	r2,141(sp)
 2002a04:	dd802385 	stb	r22,142(sp)
 2002a08:	d88023c4 	addi	r2,sp,143
 2002a0c:	df0022c4 	addi	fp,sp,139
 2002a10:	d8c03317 	ldw	r3,204(sp)
 2002a14:	1739c83a 	sub	fp,r2,fp
 2002a18:	d9003317 	ldw	r4,204(sp)
 2002a1c:	e0c7883a 	add	r3,fp,r3
 2002a20:	df003a15 	stw	fp,232(sp)
 2002a24:	d8c02e15 	stw	r3,184(sp)
 2002a28:	00800044 	movi	r2,1
 2002a2c:	1100b30e 	bge	r2,r4,2002cfc <___vfprintf_internal_r+0x2110>
 2002a30:	d8c02e17 	ldw	r3,184(sp)
 2002a34:	18c00044 	addi	r3,r3,1
 2002a38:	d8c02e15 	stw	r3,184(sp)
 2002a3c:	1805883a 	mov	r2,r3
 2002a40:	1800ac16 	blt	r3,zero,2002cf4 <___vfprintf_internal_r+0x2108>
 2002a44:	d8003215 	stw	zero,200(sp)
 2002a48:	003e5d06 	br	20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002a4c:	d9002c17 	ldw	r4,176(sp)
 2002a50:	d9801e04 	addi	r6,sp,120
 2002a54:	b80b883a 	mov	r5,r23
 2002a58:	20077040 	call	2007704 <__sprint_r>
 2002a5c:	1039651e 	bne	r2,zero,2000ff4 <__alt_mem_mem_0+0xfcfe0ff4>
 2002a60:	dc402617 	ldw	r17,152(sp)
 2002a64:	d8c02017 	ldw	r3,128(sp)
 2002a68:	d8801f17 	ldw	r2,124(sp)
 2002a6c:	da000404 	addi	r8,sp,16
 2002a70:	003ed606 	br	20025cc <__alt_mem_mem_0+0xfcfe25cc>
 2002a74:	582b883a 	mov	r21,r11
 2002a78:	d8002915 	stw	zero,164(sp)
 2002a7c:	0038bd06 	br	2000d74 <__alt_mem_mem_0+0xfcfe0d74>
 2002a80:	d8802917 	ldw	r2,164(sp)
 2002a84:	103e071e 	bne	r2,zero,20022a4 <__alt_mem_mem_0+0xfcfe22a4>
 2002a88:	dc002915 	stw	r16,164(sp)
 2002a8c:	003e0506 	br	20022a4 <__alt_mem_mem_0+0xfcfe22a4>
 2002a90:	d9002917 	ldw	r4,164(sp)
 2002a94:	20c00044 	addi	r3,r4,1
 2002a98:	003e0f06 	br	20022d8 <__alt_mem_mem_0+0xfcfe22d8>
 2002a9c:	01400184 	movi	r5,6
 2002aa0:	d9402915 	stw	r5,164(sp)
 2002aa4:	003dff06 	br	20022a4 <__alt_mem_mem_0+0xfcfe22a4>
 2002aa8:	d8802104 	addi	r2,sp,132
 2002aac:	d8800315 	stw	r2,12(sp)
 2002ab0:	d8802504 	addi	r2,sp,148
 2002ab4:	d8800215 	stw	r2,8(sp)
 2002ab8:	d8802604 	addi	r2,sp,152
 2002abc:	d8800115 	stw	r2,4(sp)
 2002ac0:	d8802917 	ldw	r2,164(sp)
 2002ac4:	d9403617 	ldw	r5,216(sp)
 2002ac8:	d9002c17 	ldw	r4,176(sp)
 2002acc:	d8800015 	stw	r2,0(sp)
 2002ad0:	01c000c4 	movi	r7,3
 2002ad4:	980d883a 	mov	r6,r19
 2002ad8:	da003d15 	stw	r8,244(sp)
 2002adc:	20032100 	call	2003210 <_dtoa_r>
 2002ae0:	d8c02917 	ldw	r3,164(sp)
 2002ae4:	da003d17 	ldw	r8,244(sp)
 2002ae8:	1021883a 	mov	r16,r2
 2002aec:	10f9883a 	add	fp,r2,r3
 2002af0:	81000007 	ldb	r4,0(r16)
 2002af4:	00800c04 	movi	r2,48
 2002af8:	20805e26 	beq	r4,r2,2002c74 <___vfprintf_internal_r+0x2088>
 2002afc:	d8c02617 	ldw	r3,152(sp)
 2002b00:	e0f9883a 	add	fp,fp,r3
 2002b04:	003e0a06 	br	2002330 <__alt_mem_mem_0+0xfcfe2330>
 2002b08:	00c00b44 	movi	r3,45
 2002b0c:	24e0003c 	xorhi	r19,r4,32768
 2002b10:	d8c02a05 	stb	r3,168(sp)
 2002b14:	003de906 	br	20022bc <__alt_mem_mem_0+0xfcfe22bc>
 2002b18:	d8c03217 	ldw	r3,200(sp)
 2002b1c:	00c07a0e 	bge	zero,r3,2002d08 <___vfprintf_internal_r+0x211c>
 2002b20:	00800044 	movi	r2,1
 2002b24:	d9003317 	ldw	r4,204(sp)
 2002b28:	1105883a 	add	r2,r2,r4
 2002b2c:	d8802e15 	stw	r2,184(sp)
 2002b30:	10004e16 	blt	r2,zero,2002c6c <___vfprintf_internal_r+0x2080>
 2002b34:	044019c4 	movi	r17,103
 2002b38:	003e2106 	br	20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002b3c:	d9002917 	ldw	r4,164(sp)
 2002b40:	d8802104 	addi	r2,sp,132
 2002b44:	d8800315 	stw	r2,12(sp)
 2002b48:	d9000015 	stw	r4,0(sp)
 2002b4c:	d8802504 	addi	r2,sp,148
 2002b50:	d9403617 	ldw	r5,216(sp)
 2002b54:	d9002c17 	ldw	r4,176(sp)
 2002b58:	d8800215 	stw	r2,8(sp)
 2002b5c:	d8802604 	addi	r2,sp,152
 2002b60:	d8800115 	stw	r2,4(sp)
 2002b64:	01c000c4 	movi	r7,3
 2002b68:	980d883a 	mov	r6,r19
 2002b6c:	da003d15 	stw	r8,244(sp)
 2002b70:	20032100 	call	2003210 <_dtoa_r>
 2002b74:	d8c02917 	ldw	r3,164(sp)
 2002b78:	da003d17 	ldw	r8,244(sp)
 2002b7c:	1021883a 	mov	r16,r2
 2002b80:	00801184 	movi	r2,70
 2002b84:	80f9883a 	add	fp,r16,r3
 2002b88:	88bfd926 	beq	r17,r2,2002af0 <__alt_mem_mem_0+0xfcfe2af0>
 2002b8c:	003de806 	br	2002330 <__alt_mem_mem_0+0xfcfe2330>
 2002b90:	d9002917 	ldw	r4,164(sp)
 2002b94:	00c04d0e 	bge	zero,r3,2002ccc <___vfprintf_internal_r+0x20e0>
 2002b98:	2000441e 	bne	r4,zero,2002cac <___vfprintf_internal_r+0x20c0>
 2002b9c:	9480004c 	andi	r18,r18,1
 2002ba0:	9000421e 	bne	r18,zero,2002cac <___vfprintf_internal_r+0x20c0>
 2002ba4:	1805883a 	mov	r2,r3
 2002ba8:	18007016 	blt	r3,zero,2002d6c <___vfprintf_internal_r+0x2180>
 2002bac:	d8c03217 	ldw	r3,200(sp)
 2002bb0:	d8c02e15 	stw	r3,184(sp)
 2002bb4:	003e0206 	br	20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002bb8:	df0022c4 	addi	fp,sp,139
 2002bbc:	dc002915 	stw	r16,164(sp)
 2002bc0:	4027883a 	mov	r19,r8
 2002bc4:	e021883a 	mov	r16,fp
 2002bc8:	b009883a 	mov	r4,r22
 2002bcc:	01400284 	movi	r5,10
 2002bd0:	200ac340 	call	200ac34 <__modsi3>
 2002bd4:	10800c04 	addi	r2,r2,48
 2002bd8:	843fffc4 	addi	r16,r16,-1
 2002bdc:	b009883a 	mov	r4,r22
 2002be0:	01400284 	movi	r5,10
 2002be4:	80800005 	stb	r2,0(r16)
 2002be8:	200abb00 	call	200abb0 <__divsi3>
 2002bec:	102d883a 	mov	r22,r2
 2002bf0:	00800244 	movi	r2,9
 2002bf4:	15bff416 	blt	r2,r22,2002bc8 <__alt_mem_mem_0+0xfcfe2bc8>
 2002bf8:	9811883a 	mov	r8,r19
 2002bfc:	b0800c04 	addi	r2,r22,48
 2002c00:	8027883a 	mov	r19,r16
 2002c04:	997fffc4 	addi	r5,r19,-1
 2002c08:	98bfffc5 	stb	r2,-1(r19)
 2002c0c:	dc002917 	ldw	r16,164(sp)
 2002c10:	2f006a2e 	bgeu	r5,fp,2002dbc <___vfprintf_internal_r+0x21d0>
 2002c14:	d9c02384 	addi	r7,sp,142
 2002c18:	3ccfc83a 	sub	r7,r7,r19
 2002c1c:	d9002344 	addi	r4,sp,141
 2002c20:	e1cf883a 	add	r7,fp,r7
 2002c24:	00000106 	br	2002c2c <___vfprintf_internal_r+0x2040>
 2002c28:	28800003 	ldbu	r2,0(r5)
 2002c2c:	20800005 	stb	r2,0(r4)
 2002c30:	21000044 	addi	r4,r4,1
 2002c34:	29400044 	addi	r5,r5,1
 2002c38:	393ffb1e 	bne	r7,r4,2002c28 <__alt_mem_mem_0+0xfcfe2c28>
 2002c3c:	d8802304 	addi	r2,sp,140
 2002c40:	14c5c83a 	sub	r2,r2,r19
 2002c44:	d8c02344 	addi	r3,sp,141
 2002c48:	1885883a 	add	r2,r3,r2
 2002c4c:	003f7006 	br	2002a10 <__alt_mem_mem_0+0xfcfe2a10>
 2002c50:	0005883a 	mov	r2,zero
 2002c54:	003f0f06 	br	2002894 <__alt_mem_mem_0+0xfcfe2894>
 2002c58:	d8c03217 	ldw	r3,200(sp)
 2002c5c:	18c00044 	addi	r3,r3,1
 2002c60:	d8c02e15 	stw	r3,184(sp)
 2002c64:	1805883a 	mov	r2,r3
 2002c68:	183fb20e 	bge	r3,zero,2002b34 <__alt_mem_mem_0+0xfcfe2b34>
 2002c6c:	0005883a 	mov	r2,zero
 2002c70:	003fb006 	br	2002b34 <__alt_mem_mem_0+0xfcfe2b34>
 2002c74:	d9003617 	ldw	r4,216(sp)
 2002c78:	000d883a 	mov	r6,zero
 2002c7c:	000f883a 	mov	r7,zero
 2002c80:	980b883a 	mov	r5,r19
 2002c84:	d8c03c15 	stw	r3,240(sp)
 2002c88:	da003d15 	stw	r8,244(sp)
 2002c8c:	200bef80 	call	200bef8 <__eqdf2>
 2002c90:	d8c03c17 	ldw	r3,240(sp)
 2002c94:	da003d17 	ldw	r8,244(sp)
 2002c98:	103f9826 	beq	r2,zero,2002afc <__alt_mem_mem_0+0xfcfe2afc>
 2002c9c:	00800044 	movi	r2,1
 2002ca0:	10c7c83a 	sub	r3,r2,r3
 2002ca4:	d8c02615 	stw	r3,152(sp)
 2002ca8:	003f9506 	br	2002b00 <__alt_mem_mem_0+0xfcfe2b00>
 2002cac:	d9002917 	ldw	r4,164(sp)
 2002cb0:	d8c03217 	ldw	r3,200(sp)
 2002cb4:	20800044 	addi	r2,r4,1
 2002cb8:	1885883a 	add	r2,r3,r2
 2002cbc:	d8802e15 	stw	r2,184(sp)
 2002cc0:	103dbf0e 	bge	r2,zero,20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002cc4:	0005883a 	mov	r2,zero
 2002cc8:	003dbd06 	br	20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002ccc:	2000211e 	bne	r4,zero,2002d54 <___vfprintf_internal_r+0x2168>
 2002cd0:	9480004c 	andi	r18,r18,1
 2002cd4:	90001f1e 	bne	r18,zero,2002d54 <___vfprintf_internal_r+0x2168>
 2002cd8:	00800044 	movi	r2,1
 2002cdc:	d8802e15 	stw	r2,184(sp)
 2002ce0:	003db706 	br	20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002ce4:	00800b44 	movi	r2,45
 2002ce8:	05adc83a 	sub	r22,zero,r22
 2002cec:	d8802305 	stb	r2,140(sp)
 2002cf0:	003f3f06 	br	20029f0 <__alt_mem_mem_0+0xfcfe29f0>
 2002cf4:	0005883a 	mov	r2,zero
 2002cf8:	003f5206 	br	2002a44 <__alt_mem_mem_0+0xfcfe2a44>
 2002cfc:	90a4703a 	and	r18,r18,r2
 2002d00:	903f4e26 	beq	r18,zero,2002a3c <__alt_mem_mem_0+0xfcfe2a3c>
 2002d04:	003f4a06 	br	2002a30 <__alt_mem_mem_0+0xfcfe2a30>
 2002d08:	00800084 	movi	r2,2
 2002d0c:	10c5c83a 	sub	r2,r2,r3
 2002d10:	003f8406 	br	2002b24 <__alt_mem_mem_0+0xfcfe2b24>
 2002d14:	d8802d17 	ldw	r2,180(sp)
 2002d18:	d9002d17 	ldw	r4,180(sp)
 2002d1c:	ac400043 	ldbu	r17,1(r21)
 2002d20:	10800017 	ldw	r2,0(r2)
 2002d24:	582b883a 	mov	r21,r11
 2002d28:	d8802915 	stw	r2,164(sp)
 2002d2c:	20800104 	addi	r2,r4,4
 2002d30:	d9002917 	ldw	r4,164(sp)
 2002d34:	d8802d15 	stw	r2,180(sp)
 2002d38:	203e7a0e 	bge	r4,zero,2002724 <__alt_mem_mem_0+0xfcfe2724>
 2002d3c:	8c403fcc 	andi	r17,r17,255
 2002d40:	00bfffc4 	movi	r2,-1
 2002d44:	8c40201c 	xori	r17,r17,128
 2002d48:	d8802915 	stw	r2,164(sp)
 2002d4c:	8c7fe004 	addi	r17,r17,-128
 2002d50:	00380706 	br	2000d70 <__alt_mem_mem_0+0xfcfe0d70>
 2002d54:	d8c02917 	ldw	r3,164(sp)
 2002d58:	18c00084 	addi	r3,r3,2
 2002d5c:	d8c02e15 	stw	r3,184(sp)
 2002d60:	1805883a 	mov	r2,r3
 2002d64:	183d960e 	bge	r3,zero,20023c0 <__alt_mem_mem_0+0xfcfe23c0>
 2002d68:	003fd606 	br	2002cc4 <__alt_mem_mem_0+0xfcfe2cc4>
 2002d6c:	0005883a 	mov	r2,zero
 2002d70:	003f8e06 	br	2002bac <__alt_mem_mem_0+0xfcfe2bac>
 2002d74:	9080004c 	andi	r2,r18,1
 2002d78:	103f811e 	bne	r2,zero,2002b80 <__alt_mem_mem_0+0xfcfe2b80>
 2002d7c:	d8802117 	ldw	r2,132(sp)
 2002d80:	1405c83a 	sub	r2,r2,r16
 2002d84:	d8803315 	stw	r2,204(sp)
 2002d88:	b47ef326 	beq	r22,r17,2002958 <__alt_mem_mem_0+0xfcfe2958>
 2002d8c:	dd802617 	ldw	r22,152(sp)
 2002d90:	003f1106 	br	20029d8 <__alt_mem_mem_0+0xfcfe29d8>
 2002d94:	d9c02785 	stb	r7,158(sp)
 2002d98:	00390406 	br	20011ac <__alt_mem_mem_0+0xfcfe11ac>
 2002d9c:	d9c02785 	stb	r7,158(sp)
 2002da0:	0038d306 	br	20010f0 <__alt_mem_mem_0+0xfcfe10f0>
 2002da4:	d9c02785 	stb	r7,158(sp)
 2002da8:	003a6106 	br	2001730 <__alt_mem_mem_0+0xfcfe1730>
 2002dac:	d9c02785 	stb	r7,158(sp)
 2002db0:	003af806 	br	2001994 <__alt_mem_mem_0+0xfcfe1994>
 2002db4:	0005883a 	mov	r2,zero
 2002db8:	003d7e06 	br	20023b4 <__alt_mem_mem_0+0xfcfe23b4>
 2002dbc:	d8802344 	addi	r2,sp,141
 2002dc0:	003f1306 	br	2002a10 <__alt_mem_mem_0+0xfcfe2a10>
 2002dc4:	d9c02785 	stb	r7,158(sp)
 2002dc8:	00392306 	br	2001258 <__alt_mem_mem_0+0xfcfe1258>
 2002dcc:	d9c02785 	stb	r7,158(sp)
 2002dd0:	003aa906 	br	2001878 <__alt_mem_mem_0+0xfcfe1878>
 2002dd4:	d9c02785 	stb	r7,158(sp)
 2002dd8:	003a3d06 	br	20016d0 <__alt_mem_mem_0+0xfcfe16d0>
 2002ddc:	d9c02785 	stb	r7,158(sp)
 2002de0:	003aca06 	br	200190c <__alt_mem_mem_0+0xfcfe190c>

02002de4 <__vfprintf_internal>:
 2002de4:	00808134 	movhi	r2,516
 2002de8:	10963d04 	addi	r2,r2,22772
 2002dec:	300f883a 	mov	r7,r6
 2002df0:	280d883a 	mov	r6,r5
 2002df4:	200b883a 	mov	r5,r4
 2002df8:	11000017 	ldw	r4,0(r2)
 2002dfc:	2000bec1 	jmpi	2000bec <___vfprintf_internal_r>

02002e00 <__sbprintf>:
 2002e00:	2880030b 	ldhu	r2,12(r5)
 2002e04:	2ac01917 	ldw	r11,100(r5)
 2002e08:	2a80038b 	ldhu	r10,14(r5)
 2002e0c:	2a400717 	ldw	r9,28(r5)
 2002e10:	2a000917 	ldw	r8,36(r5)
 2002e14:	defee204 	addi	sp,sp,-1144
 2002e18:	00c10004 	movi	r3,1024
 2002e1c:	dc011a15 	stw	r16,1128(sp)
 2002e20:	10bfff4c 	andi	r2,r2,65533
 2002e24:	2821883a 	mov	r16,r5
 2002e28:	d8cb883a 	add	r5,sp,r3
 2002e2c:	dc811c15 	stw	r18,1136(sp)
 2002e30:	dc411b15 	stw	r17,1132(sp)
 2002e34:	dfc11d15 	stw	ra,1140(sp)
 2002e38:	2025883a 	mov	r18,r4
 2002e3c:	d881030d 	sth	r2,1036(sp)
 2002e40:	dac11915 	stw	r11,1124(sp)
 2002e44:	da81038d 	sth	r10,1038(sp)
 2002e48:	da410715 	stw	r9,1052(sp)
 2002e4c:	da010915 	stw	r8,1060(sp)
 2002e50:	dec10015 	stw	sp,1024(sp)
 2002e54:	dec10415 	stw	sp,1040(sp)
 2002e58:	d8c10215 	stw	r3,1032(sp)
 2002e5c:	d8c10515 	stw	r3,1044(sp)
 2002e60:	d8010615 	stw	zero,1048(sp)
 2002e64:	2000bec0 	call	2000bec <___vfprintf_internal_r>
 2002e68:	1023883a 	mov	r17,r2
 2002e6c:	10000416 	blt	r2,zero,2002e80 <__sbprintf+0x80>
 2002e70:	d9410004 	addi	r5,sp,1024
 2002e74:	9009883a 	mov	r4,r18
 2002e78:	2004ab40 	call	2004ab4 <_fflush_r>
 2002e7c:	10000d1e 	bne	r2,zero,2002eb4 <__sbprintf+0xb4>
 2002e80:	d881030b 	ldhu	r2,1036(sp)
 2002e84:	1080100c 	andi	r2,r2,64
 2002e88:	10000326 	beq	r2,zero,2002e98 <__sbprintf+0x98>
 2002e8c:	8080030b 	ldhu	r2,12(r16)
 2002e90:	10801014 	ori	r2,r2,64
 2002e94:	8080030d 	sth	r2,12(r16)
 2002e98:	8805883a 	mov	r2,r17
 2002e9c:	dfc11d17 	ldw	ra,1140(sp)
 2002ea0:	dc811c17 	ldw	r18,1136(sp)
 2002ea4:	dc411b17 	ldw	r17,1132(sp)
 2002ea8:	dc011a17 	ldw	r16,1128(sp)
 2002eac:	dec11e04 	addi	sp,sp,1144
 2002eb0:	f800283a 	ret
 2002eb4:	047fffc4 	movi	r17,-1
 2002eb8:	003ff106 	br	2002e80 <__alt_mem_mem_0+0xfcfe2e80>

02002ebc <__swsetup_r>:
 2002ebc:	00808134 	movhi	r2,516
 2002ec0:	defffd04 	addi	sp,sp,-12
 2002ec4:	10963d04 	addi	r2,r2,22772
 2002ec8:	dc400115 	stw	r17,4(sp)
 2002ecc:	2023883a 	mov	r17,r4
 2002ed0:	11000017 	ldw	r4,0(r2)
 2002ed4:	dc000015 	stw	r16,0(sp)
 2002ed8:	dfc00215 	stw	ra,8(sp)
 2002edc:	2821883a 	mov	r16,r5
 2002ee0:	20000226 	beq	r4,zero,2002eec <__swsetup_r+0x30>
 2002ee4:	20800e17 	ldw	r2,56(r4)
 2002ee8:	10003126 	beq	r2,zero,2002fb0 <__swsetup_r+0xf4>
 2002eec:	8080030b 	ldhu	r2,12(r16)
 2002ef0:	10c0020c 	andi	r3,r2,8
 2002ef4:	1009883a 	mov	r4,r2
 2002ef8:	18000f26 	beq	r3,zero,2002f38 <__swsetup_r+0x7c>
 2002efc:	80c00417 	ldw	r3,16(r16)
 2002f00:	18001526 	beq	r3,zero,2002f58 <__swsetup_r+0x9c>
 2002f04:	1100004c 	andi	r4,r2,1
 2002f08:	20001c1e 	bne	r4,zero,2002f7c <__swsetup_r+0xc0>
 2002f0c:	1080008c 	andi	r2,r2,2
 2002f10:	1000291e 	bne	r2,zero,2002fb8 <__swsetup_r+0xfc>
 2002f14:	80800517 	ldw	r2,20(r16)
 2002f18:	80800215 	stw	r2,8(r16)
 2002f1c:	18001c26 	beq	r3,zero,2002f90 <__swsetup_r+0xd4>
 2002f20:	0005883a 	mov	r2,zero
 2002f24:	dfc00217 	ldw	ra,8(sp)
 2002f28:	dc400117 	ldw	r17,4(sp)
 2002f2c:	dc000017 	ldw	r16,0(sp)
 2002f30:	dec00304 	addi	sp,sp,12
 2002f34:	f800283a 	ret
 2002f38:	2080040c 	andi	r2,r4,16
 2002f3c:	10002e26 	beq	r2,zero,2002ff8 <__swsetup_r+0x13c>
 2002f40:	2080010c 	andi	r2,r4,4
 2002f44:	10001e1e 	bne	r2,zero,2002fc0 <__swsetup_r+0x104>
 2002f48:	80c00417 	ldw	r3,16(r16)
 2002f4c:	20800214 	ori	r2,r4,8
 2002f50:	8080030d 	sth	r2,12(r16)
 2002f54:	183feb1e 	bne	r3,zero,2002f04 <__alt_mem_mem_0+0xfcfe2f04>
 2002f58:	1100a00c 	andi	r4,r2,640
 2002f5c:	01408004 	movi	r5,512
 2002f60:	217fe826 	beq	r4,r5,2002f04 <__alt_mem_mem_0+0xfcfe2f04>
 2002f64:	800b883a 	mov	r5,r16
 2002f68:	8809883a 	mov	r4,r17
 2002f6c:	20055780 	call	2005578 <__smakebuf_r>
 2002f70:	8080030b 	ldhu	r2,12(r16)
 2002f74:	80c00417 	ldw	r3,16(r16)
 2002f78:	003fe206 	br	2002f04 <__alt_mem_mem_0+0xfcfe2f04>
 2002f7c:	80800517 	ldw	r2,20(r16)
 2002f80:	80000215 	stw	zero,8(r16)
 2002f84:	0085c83a 	sub	r2,zero,r2
 2002f88:	80800615 	stw	r2,24(r16)
 2002f8c:	183fe41e 	bne	r3,zero,2002f20 <__alt_mem_mem_0+0xfcfe2f20>
 2002f90:	80c0030b 	ldhu	r3,12(r16)
 2002f94:	0005883a 	mov	r2,zero
 2002f98:	1900200c 	andi	r4,r3,128
 2002f9c:	203fe126 	beq	r4,zero,2002f24 <__alt_mem_mem_0+0xfcfe2f24>
 2002fa0:	18c01014 	ori	r3,r3,64
 2002fa4:	80c0030d 	sth	r3,12(r16)
 2002fa8:	00bfffc4 	movi	r2,-1
 2002fac:	003fdd06 	br	2002f24 <__alt_mem_mem_0+0xfcfe2f24>
 2002fb0:	2004e900 	call	2004e90 <__sinit>
 2002fb4:	003fcd06 	br	2002eec <__alt_mem_mem_0+0xfcfe2eec>
 2002fb8:	0005883a 	mov	r2,zero
 2002fbc:	003fd606 	br	2002f18 <__alt_mem_mem_0+0xfcfe2f18>
 2002fc0:	81400c17 	ldw	r5,48(r16)
 2002fc4:	28000626 	beq	r5,zero,2002fe0 <__swsetup_r+0x124>
 2002fc8:	80801004 	addi	r2,r16,64
 2002fcc:	28800326 	beq	r5,r2,2002fdc <__swsetup_r+0x120>
 2002fd0:	8809883a 	mov	r4,r17
 2002fd4:	20050040 	call	2005004 <_free_r>
 2002fd8:	8100030b 	ldhu	r4,12(r16)
 2002fdc:	80000c15 	stw	zero,48(r16)
 2002fe0:	80c00417 	ldw	r3,16(r16)
 2002fe4:	00bff6c4 	movi	r2,-37
 2002fe8:	1108703a 	and	r4,r2,r4
 2002fec:	80000115 	stw	zero,4(r16)
 2002ff0:	80c00015 	stw	r3,0(r16)
 2002ff4:	003fd506 	br	2002f4c <__alt_mem_mem_0+0xfcfe2f4c>
 2002ff8:	00800244 	movi	r2,9
 2002ffc:	88800015 	stw	r2,0(r17)
 2003000:	20801014 	ori	r2,r4,64
 2003004:	8080030d 	sth	r2,12(r16)
 2003008:	00bfffc4 	movi	r2,-1
 200300c:	003fc506 	br	2002f24 <__alt_mem_mem_0+0xfcfe2f24>

02003010 <quorem>:
 2003010:	defff704 	addi	sp,sp,-36
 2003014:	dc800215 	stw	r18,8(sp)
 2003018:	20800417 	ldw	r2,16(r4)
 200301c:	2c800417 	ldw	r18,16(r5)
 2003020:	dfc00815 	stw	ra,32(sp)
 2003024:	ddc00715 	stw	r23,28(sp)
 2003028:	dd800615 	stw	r22,24(sp)
 200302c:	dd400515 	stw	r21,20(sp)
 2003030:	dd000415 	stw	r20,16(sp)
 2003034:	dcc00315 	stw	r19,12(sp)
 2003038:	dc400115 	stw	r17,4(sp)
 200303c:	dc000015 	stw	r16,0(sp)
 2003040:	14807116 	blt	r2,r18,2003208 <quorem+0x1f8>
 2003044:	94bfffc4 	addi	r18,r18,-1
 2003048:	94ad883a 	add	r22,r18,r18
 200304c:	b5ad883a 	add	r22,r22,r22
 2003050:	2c400504 	addi	r17,r5,20
 2003054:	8da9883a 	add	r20,r17,r22
 2003058:	25400504 	addi	r21,r4,20
 200305c:	282f883a 	mov	r23,r5
 2003060:	adad883a 	add	r22,r21,r22
 2003064:	a1400017 	ldw	r5,0(r20)
 2003068:	2021883a 	mov	r16,r4
 200306c:	b1000017 	ldw	r4,0(r22)
 2003070:	29400044 	addi	r5,r5,1
 2003074:	200aca80 	call	200aca8 <__udivsi3>
 2003078:	1027883a 	mov	r19,r2
 200307c:	10002c26 	beq	r2,zero,2003130 <quorem+0x120>
 2003080:	a813883a 	mov	r9,r21
 2003084:	880b883a 	mov	r5,r17
 2003088:	0009883a 	mov	r4,zero
 200308c:	000d883a 	mov	r6,zero
 2003090:	2a000017 	ldw	r8,0(r5)
 2003094:	49c00017 	ldw	r7,0(r9)
 2003098:	29400104 	addi	r5,r5,4
 200309c:	40bfffcc 	andi	r2,r8,65535
 20030a0:	14c5383a 	mul	r2,r2,r19
 20030a4:	4010d43a 	srli	r8,r8,16
 20030a8:	38ffffcc 	andi	r3,r7,65535
 20030ac:	1105883a 	add	r2,r2,r4
 20030b0:	1008d43a 	srli	r4,r2,16
 20030b4:	44d1383a 	mul	r8,r8,r19
 20030b8:	198d883a 	add	r6,r3,r6
 20030bc:	10ffffcc 	andi	r3,r2,65535
 20030c0:	30c7c83a 	sub	r3,r6,r3
 20030c4:	380ed43a 	srli	r7,r7,16
 20030c8:	4105883a 	add	r2,r8,r4
 20030cc:	180dd43a 	srai	r6,r3,16
 20030d0:	113fffcc 	andi	r4,r2,65535
 20030d4:	390fc83a 	sub	r7,r7,r4
 20030d8:	398d883a 	add	r6,r7,r6
 20030dc:	300e943a 	slli	r7,r6,16
 20030e0:	18ffffcc 	andi	r3,r3,65535
 20030e4:	1008d43a 	srli	r4,r2,16
 20030e8:	38ceb03a 	or	r7,r7,r3
 20030ec:	49c00015 	stw	r7,0(r9)
 20030f0:	300dd43a 	srai	r6,r6,16
 20030f4:	4a400104 	addi	r9,r9,4
 20030f8:	a17fe52e 	bgeu	r20,r5,2003090 <__alt_mem_mem_0+0xfcfe3090>
 20030fc:	b0800017 	ldw	r2,0(r22)
 2003100:	10000b1e 	bne	r2,zero,2003130 <quorem+0x120>
 2003104:	b0bfff04 	addi	r2,r22,-4
 2003108:	a880082e 	bgeu	r21,r2,200312c <quorem+0x11c>
 200310c:	b0ffff17 	ldw	r3,-4(r22)
 2003110:	18000326 	beq	r3,zero,2003120 <quorem+0x110>
 2003114:	00000506 	br	200312c <quorem+0x11c>
 2003118:	10c00017 	ldw	r3,0(r2)
 200311c:	1800031e 	bne	r3,zero,200312c <quorem+0x11c>
 2003120:	10bfff04 	addi	r2,r2,-4
 2003124:	94bfffc4 	addi	r18,r18,-1
 2003128:	a8bffb36 	bltu	r21,r2,2003118 <__alt_mem_mem_0+0xfcfe3118>
 200312c:	84800415 	stw	r18,16(r16)
 2003130:	b80b883a 	mov	r5,r23
 2003134:	8009883a 	mov	r4,r16
 2003138:	2006b5c0 	call	2006b5c <__mcmp>
 200313c:	10002616 	blt	r2,zero,20031d8 <quorem+0x1c8>
 2003140:	9cc00044 	addi	r19,r19,1
 2003144:	a805883a 	mov	r2,r21
 2003148:	000b883a 	mov	r5,zero
 200314c:	11000017 	ldw	r4,0(r2)
 2003150:	89800017 	ldw	r6,0(r17)
 2003154:	10800104 	addi	r2,r2,4
 2003158:	20ffffcc 	andi	r3,r4,65535
 200315c:	194b883a 	add	r5,r3,r5
 2003160:	30ffffcc 	andi	r3,r6,65535
 2003164:	28c7c83a 	sub	r3,r5,r3
 2003168:	300cd43a 	srli	r6,r6,16
 200316c:	2008d43a 	srli	r4,r4,16
 2003170:	180bd43a 	srai	r5,r3,16
 2003174:	18ffffcc 	andi	r3,r3,65535
 2003178:	2189c83a 	sub	r4,r4,r6
 200317c:	2149883a 	add	r4,r4,r5
 2003180:	200c943a 	slli	r6,r4,16
 2003184:	8c400104 	addi	r17,r17,4
 2003188:	200bd43a 	srai	r5,r4,16
 200318c:	30c6b03a 	or	r3,r6,r3
 2003190:	10ffff15 	stw	r3,-4(r2)
 2003194:	a47fed2e 	bgeu	r20,r17,200314c <__alt_mem_mem_0+0xfcfe314c>
 2003198:	9485883a 	add	r2,r18,r18
 200319c:	1085883a 	add	r2,r2,r2
 20031a0:	a887883a 	add	r3,r21,r2
 20031a4:	18800017 	ldw	r2,0(r3)
 20031a8:	10000b1e 	bne	r2,zero,20031d8 <quorem+0x1c8>
 20031ac:	18bfff04 	addi	r2,r3,-4
 20031b0:	a880082e 	bgeu	r21,r2,20031d4 <quorem+0x1c4>
 20031b4:	18ffff17 	ldw	r3,-4(r3)
 20031b8:	18000326 	beq	r3,zero,20031c8 <quorem+0x1b8>
 20031bc:	00000506 	br	20031d4 <quorem+0x1c4>
 20031c0:	10c00017 	ldw	r3,0(r2)
 20031c4:	1800031e 	bne	r3,zero,20031d4 <quorem+0x1c4>
 20031c8:	10bfff04 	addi	r2,r2,-4
 20031cc:	94bfffc4 	addi	r18,r18,-1
 20031d0:	a8bffb36 	bltu	r21,r2,20031c0 <__alt_mem_mem_0+0xfcfe31c0>
 20031d4:	84800415 	stw	r18,16(r16)
 20031d8:	9805883a 	mov	r2,r19
 20031dc:	dfc00817 	ldw	ra,32(sp)
 20031e0:	ddc00717 	ldw	r23,28(sp)
 20031e4:	dd800617 	ldw	r22,24(sp)
 20031e8:	dd400517 	ldw	r21,20(sp)
 20031ec:	dd000417 	ldw	r20,16(sp)
 20031f0:	dcc00317 	ldw	r19,12(sp)
 20031f4:	dc800217 	ldw	r18,8(sp)
 20031f8:	dc400117 	ldw	r17,4(sp)
 20031fc:	dc000017 	ldw	r16,0(sp)
 2003200:	dec00904 	addi	sp,sp,36
 2003204:	f800283a 	ret
 2003208:	0005883a 	mov	r2,zero
 200320c:	003ff306 	br	20031dc <__alt_mem_mem_0+0xfcfe31dc>

02003210 <_dtoa_r>:
 2003210:	20801017 	ldw	r2,64(r4)
 2003214:	deffde04 	addi	sp,sp,-136
 2003218:	df002015 	stw	fp,128(sp)
 200321c:	dcc01b15 	stw	r19,108(sp)
 2003220:	dc801a15 	stw	r18,104(sp)
 2003224:	dc401915 	stw	r17,100(sp)
 2003228:	dc001815 	stw	r16,96(sp)
 200322c:	dfc02115 	stw	ra,132(sp)
 2003230:	ddc01f15 	stw	r23,124(sp)
 2003234:	dd801e15 	stw	r22,120(sp)
 2003238:	dd401d15 	stw	r21,116(sp)
 200323c:	dd001c15 	stw	r20,112(sp)
 2003240:	d9c00315 	stw	r7,12(sp)
 2003244:	2039883a 	mov	fp,r4
 2003248:	3023883a 	mov	r17,r6
 200324c:	2825883a 	mov	r18,r5
 2003250:	dc002417 	ldw	r16,144(sp)
 2003254:	3027883a 	mov	r19,r6
 2003258:	10000826 	beq	r2,zero,200327c <_dtoa_r+0x6c>
 200325c:	21801117 	ldw	r6,68(r4)
 2003260:	00c00044 	movi	r3,1
 2003264:	100b883a 	mov	r5,r2
 2003268:	1986983a 	sll	r3,r3,r6
 200326c:	11800115 	stw	r6,4(r2)
 2003270:	10c00215 	stw	r3,8(r2)
 2003274:	200633c0 	call	200633c <_Bfree>
 2003278:	e0001015 	stw	zero,64(fp)
 200327c:	88002e16 	blt	r17,zero,2003338 <_dtoa_r+0x128>
 2003280:	80000015 	stw	zero,0(r16)
 2003284:	889ffc2c 	andhi	r2,r17,32752
 2003288:	00dffc34 	movhi	r3,32752
 200328c:	10c01c26 	beq	r2,r3,2003300 <_dtoa_r+0xf0>
 2003290:	000d883a 	mov	r6,zero
 2003294:	000f883a 	mov	r7,zero
 2003298:	9009883a 	mov	r4,r18
 200329c:	980b883a 	mov	r5,r19
 20032a0:	200bef80 	call	200bef8 <__eqdf2>
 20032a4:	10002b1e 	bne	r2,zero,2003354 <_dtoa_r+0x144>
 20032a8:	d9c02317 	ldw	r7,140(sp)
 20032ac:	00800044 	movi	r2,1
 20032b0:	38800015 	stw	r2,0(r7)
 20032b4:	d8802517 	ldw	r2,148(sp)
 20032b8:	10019e26 	beq	r2,zero,2003934 <_dtoa_r+0x724>
 20032bc:	d8c02517 	ldw	r3,148(sp)
 20032c0:	00808134 	movhi	r2,516
 20032c4:	1083d544 	addi	r2,r2,3925
 20032c8:	18800015 	stw	r2,0(r3)
 20032cc:	10bfffc4 	addi	r2,r2,-1
 20032d0:	dfc02117 	ldw	ra,132(sp)
 20032d4:	df002017 	ldw	fp,128(sp)
 20032d8:	ddc01f17 	ldw	r23,124(sp)
 20032dc:	dd801e17 	ldw	r22,120(sp)
 20032e0:	dd401d17 	ldw	r21,116(sp)
 20032e4:	dd001c17 	ldw	r20,112(sp)
 20032e8:	dcc01b17 	ldw	r19,108(sp)
 20032ec:	dc801a17 	ldw	r18,104(sp)
 20032f0:	dc401917 	ldw	r17,100(sp)
 20032f4:	dc001817 	ldw	r16,96(sp)
 20032f8:	dec02204 	addi	sp,sp,136
 20032fc:	f800283a 	ret
 2003300:	d8c02317 	ldw	r3,140(sp)
 2003304:	0089c3c4 	movi	r2,9999
 2003308:	18800015 	stw	r2,0(r3)
 200330c:	90017726 	beq	r18,zero,20038ec <_dtoa_r+0x6dc>
 2003310:	00808134 	movhi	r2,516
 2003314:	1083e104 	addi	r2,r2,3972
 2003318:	d9002517 	ldw	r4,148(sp)
 200331c:	203fec26 	beq	r4,zero,20032d0 <__alt_mem_mem_0+0xfcfe32d0>
 2003320:	10c000c7 	ldb	r3,3(r2)
 2003324:	1801781e 	bne	r3,zero,2003908 <_dtoa_r+0x6f8>
 2003328:	10c000c4 	addi	r3,r2,3
 200332c:	d9802517 	ldw	r6,148(sp)
 2003330:	30c00015 	stw	r3,0(r6)
 2003334:	003fe606 	br	20032d0 <__alt_mem_mem_0+0xfcfe32d0>
 2003338:	04e00034 	movhi	r19,32768
 200333c:	9cffffc4 	addi	r19,r19,-1
 2003340:	00800044 	movi	r2,1
 2003344:	8ce6703a 	and	r19,r17,r19
 2003348:	80800015 	stw	r2,0(r16)
 200334c:	9823883a 	mov	r17,r19
 2003350:	003fcc06 	br	2003284 <__alt_mem_mem_0+0xfcfe3284>
 2003354:	d8800204 	addi	r2,sp,8
 2003358:	d8800015 	stw	r2,0(sp)
 200335c:	d9c00104 	addi	r7,sp,4
 2003360:	900b883a 	mov	r5,r18
 2003364:	980d883a 	mov	r6,r19
 2003368:	e009883a 	mov	r4,fp
 200336c:	8820d53a 	srli	r16,r17,20
 2003370:	2006f280 	call	2006f28 <__d2b>
 2003374:	d8800915 	stw	r2,36(sp)
 2003378:	8001651e 	bne	r16,zero,2003910 <_dtoa_r+0x700>
 200337c:	dd800217 	ldw	r22,8(sp)
 2003380:	dc000117 	ldw	r16,4(sp)
 2003384:	00800804 	movi	r2,32
 2003388:	b421883a 	add	r16,r22,r16
 200338c:	80c10c84 	addi	r3,r16,1074
 2003390:	10c2d10e 	bge	r2,r3,2003ed8 <_dtoa_r+0xcc8>
 2003394:	00801004 	movi	r2,64
 2003398:	81010484 	addi	r4,r16,1042
 200339c:	10c7c83a 	sub	r3,r2,r3
 20033a0:	9108d83a 	srl	r4,r18,r4
 20033a4:	88e2983a 	sll	r17,r17,r3
 20033a8:	2448b03a 	or	r4,r4,r17
 20033ac:	200d2c00 	call	200d2c0 <__floatunsidf>
 20033b0:	017f8434 	movhi	r5,65040
 20033b4:	01800044 	movi	r6,1
 20033b8:	1009883a 	mov	r4,r2
 20033bc:	194b883a 	add	r5,r3,r5
 20033c0:	843fffc4 	addi	r16,r16,-1
 20033c4:	d9801115 	stw	r6,68(sp)
 20033c8:	000d883a 	mov	r6,zero
 20033cc:	01cffe34 	movhi	r7,16376
 20033d0:	200c8680 	call	200c868 <__subdf3>
 20033d4:	0198dbf4 	movhi	r6,25455
 20033d8:	01cff4f4 	movhi	r7,16339
 20033dc:	3190d844 	addi	r6,r6,17249
 20033e0:	39e1e9c4 	addi	r7,r7,-30809
 20033e4:	1009883a 	mov	r4,r2
 20033e8:	180b883a 	mov	r5,r3
 20033ec:	200c1500 	call	200c150 <__muldf3>
 20033f0:	01a2d874 	movhi	r6,35681
 20033f4:	01cff1f4 	movhi	r7,16327
 20033f8:	31b22cc4 	addi	r6,r6,-14157
 20033fc:	39e28a04 	addi	r7,r7,-30168
 2003400:	180b883a 	mov	r5,r3
 2003404:	1009883a 	mov	r4,r2
 2003408:	200ad640 	call	200ad64 <__adddf3>
 200340c:	8009883a 	mov	r4,r16
 2003410:	1029883a 	mov	r20,r2
 2003414:	1823883a 	mov	r17,r3
 2003418:	200d1e40 	call	200d1e4 <__floatsidf>
 200341c:	019427f4 	movhi	r6,20639
 2003420:	01cff4f4 	movhi	r7,16339
 2003424:	319e7ec4 	addi	r6,r6,31227
 2003428:	39d104c4 	addi	r7,r7,17427
 200342c:	1009883a 	mov	r4,r2
 2003430:	180b883a 	mov	r5,r3
 2003434:	200c1500 	call	200c150 <__muldf3>
 2003438:	100d883a 	mov	r6,r2
 200343c:	180f883a 	mov	r7,r3
 2003440:	a009883a 	mov	r4,r20
 2003444:	880b883a 	mov	r5,r17
 2003448:	200ad640 	call	200ad64 <__adddf3>
 200344c:	1009883a 	mov	r4,r2
 2003450:	180b883a 	mov	r5,r3
 2003454:	1029883a 	mov	r20,r2
 2003458:	1823883a 	mov	r17,r3
 200345c:	200d1640 	call	200d164 <__fixdfsi>
 2003460:	000d883a 	mov	r6,zero
 2003464:	000f883a 	mov	r7,zero
 2003468:	a009883a 	mov	r4,r20
 200346c:	880b883a 	mov	r5,r17
 2003470:	d8800515 	stw	r2,20(sp)
 2003474:	200c05c0 	call	200c05c <__ledf2>
 2003478:	10028716 	blt	r2,zero,2003e98 <_dtoa_r+0xc88>
 200347c:	d8c00517 	ldw	r3,20(sp)
 2003480:	00800584 	movi	r2,22
 2003484:	10c27536 	bltu	r2,r3,2003e5c <_dtoa_r+0xc4c>
 2003488:	180490fa 	slli	r2,r3,3
 200348c:	00c08134 	movhi	r3,516
 2003490:	18c3fd04 	addi	r3,r3,4084
 2003494:	1885883a 	add	r2,r3,r2
 2003498:	11000017 	ldw	r4,0(r2)
 200349c:	11400117 	ldw	r5,4(r2)
 20034a0:	900d883a 	mov	r6,r18
 20034a4:	980f883a 	mov	r7,r19
 20034a8:	200bf800 	call	200bf80 <__gedf2>
 20034ac:	00828d0e 	bge	zero,r2,2003ee4 <_dtoa_r+0xcd4>
 20034b0:	d9000517 	ldw	r4,20(sp)
 20034b4:	d8000e15 	stw	zero,56(sp)
 20034b8:	213fffc4 	addi	r4,r4,-1
 20034bc:	d9000515 	stw	r4,20(sp)
 20034c0:	b42dc83a 	sub	r22,r22,r16
 20034c4:	b5bfffc4 	addi	r22,r22,-1
 20034c8:	b0026f16 	blt	r22,zero,2003e88 <_dtoa_r+0xc78>
 20034cc:	d8000815 	stw	zero,32(sp)
 20034d0:	d9c00517 	ldw	r7,20(sp)
 20034d4:	38026416 	blt	r7,zero,2003e68 <_dtoa_r+0xc58>
 20034d8:	b1ed883a 	add	r22,r22,r7
 20034dc:	d9c00d15 	stw	r7,52(sp)
 20034e0:	d8000a15 	stw	zero,40(sp)
 20034e4:	d9800317 	ldw	r6,12(sp)
 20034e8:	00800244 	movi	r2,9
 20034ec:	11811436 	bltu	r2,r6,2003940 <_dtoa_r+0x730>
 20034f0:	00800144 	movi	r2,5
 20034f4:	1184e10e 	bge	r2,r6,200487c <_dtoa_r+0x166c>
 20034f8:	31bfff04 	addi	r6,r6,-4
 20034fc:	d9800315 	stw	r6,12(sp)
 2003500:	0023883a 	mov	r17,zero
 2003504:	d9800317 	ldw	r6,12(sp)
 2003508:	008000c4 	movi	r2,3
 200350c:	30836726 	beq	r6,r2,20042ac <_dtoa_r+0x109c>
 2003510:	1183410e 	bge	r2,r6,2004218 <_dtoa_r+0x1008>
 2003514:	d9c00317 	ldw	r7,12(sp)
 2003518:	00800104 	movi	r2,4
 200351c:	38827c26 	beq	r7,r2,2003f10 <_dtoa_r+0xd00>
 2003520:	00800144 	movi	r2,5
 2003524:	3884c41e 	bne	r7,r2,2004838 <_dtoa_r+0x1628>
 2003528:	00800044 	movi	r2,1
 200352c:	d8800b15 	stw	r2,44(sp)
 2003530:	d8c00517 	ldw	r3,20(sp)
 2003534:	d9002217 	ldw	r4,136(sp)
 2003538:	1907883a 	add	r3,r3,r4
 200353c:	19800044 	addi	r6,r3,1
 2003540:	d8c00c15 	stw	r3,48(sp)
 2003544:	d9800615 	stw	r6,24(sp)
 2003548:	0183a40e 	bge	zero,r6,20043dc <_dtoa_r+0x11cc>
 200354c:	d9800617 	ldw	r6,24(sp)
 2003550:	3021883a 	mov	r16,r6
 2003554:	e0001115 	stw	zero,68(fp)
 2003558:	008005c4 	movi	r2,23
 200355c:	1184c92e 	bgeu	r2,r6,2004884 <_dtoa_r+0x1674>
 2003560:	00c00044 	movi	r3,1
 2003564:	00800104 	movi	r2,4
 2003568:	1085883a 	add	r2,r2,r2
 200356c:	11000504 	addi	r4,r2,20
 2003570:	180b883a 	mov	r5,r3
 2003574:	18c00044 	addi	r3,r3,1
 2003578:	313ffb2e 	bgeu	r6,r4,2003568 <__alt_mem_mem_0+0xfcfe3568>
 200357c:	e1401115 	stw	r5,68(fp)
 2003580:	e009883a 	mov	r4,fp
 2003584:	20062940 	call	2006294 <_Balloc>
 2003588:	d8800715 	stw	r2,28(sp)
 200358c:	e0801015 	stw	r2,64(fp)
 2003590:	00800384 	movi	r2,14
 2003594:	1400f736 	bltu	r2,r16,2003974 <_dtoa_r+0x764>
 2003598:	8800f626 	beq	r17,zero,2003974 <_dtoa_r+0x764>
 200359c:	d9c00517 	ldw	r7,20(sp)
 20035a0:	01c39a0e 	bge	zero,r7,200440c <_dtoa_r+0x11fc>
 20035a4:	388003cc 	andi	r2,r7,15
 20035a8:	100490fa 	slli	r2,r2,3
 20035ac:	382bd13a 	srai	r21,r7,4
 20035b0:	00c08134 	movhi	r3,516
 20035b4:	18c3fd04 	addi	r3,r3,4084
 20035b8:	1885883a 	add	r2,r3,r2
 20035bc:	a8c0040c 	andi	r3,r21,16
 20035c0:	12400017 	ldw	r9,0(r2)
 20035c4:	12000117 	ldw	r8,4(r2)
 20035c8:	18037926 	beq	r3,zero,20043b0 <_dtoa_r+0x11a0>
 20035cc:	00808134 	movhi	r2,516
 20035d0:	1083f304 	addi	r2,r2,4044
 20035d4:	11800817 	ldw	r6,32(r2)
 20035d8:	11c00917 	ldw	r7,36(r2)
 20035dc:	9009883a 	mov	r4,r18
 20035e0:	980b883a 	mov	r5,r19
 20035e4:	da001715 	stw	r8,92(sp)
 20035e8:	da401615 	stw	r9,88(sp)
 20035ec:	200b6100 	call	200b610 <__divdf3>
 20035f0:	da001717 	ldw	r8,92(sp)
 20035f4:	da401617 	ldw	r9,88(sp)
 20035f8:	ad4003cc 	andi	r21,r21,15
 20035fc:	040000c4 	movi	r16,3
 2003600:	1023883a 	mov	r17,r2
 2003604:	1829883a 	mov	r20,r3
 2003608:	a8001126 	beq	r21,zero,2003650 <_dtoa_r+0x440>
 200360c:	05c08134 	movhi	r23,516
 2003610:	bdc3f304 	addi	r23,r23,4044
 2003614:	4805883a 	mov	r2,r9
 2003618:	4007883a 	mov	r3,r8
 200361c:	a980004c 	andi	r6,r21,1
 2003620:	1009883a 	mov	r4,r2
 2003624:	a82bd07a 	srai	r21,r21,1
 2003628:	180b883a 	mov	r5,r3
 200362c:	30000426 	beq	r6,zero,2003640 <_dtoa_r+0x430>
 2003630:	b9800017 	ldw	r6,0(r23)
 2003634:	b9c00117 	ldw	r7,4(r23)
 2003638:	84000044 	addi	r16,r16,1
 200363c:	200c1500 	call	200c150 <__muldf3>
 2003640:	bdc00204 	addi	r23,r23,8
 2003644:	a83ff51e 	bne	r21,zero,200361c <__alt_mem_mem_0+0xfcfe361c>
 2003648:	1013883a 	mov	r9,r2
 200364c:	1811883a 	mov	r8,r3
 2003650:	480d883a 	mov	r6,r9
 2003654:	400f883a 	mov	r7,r8
 2003658:	8809883a 	mov	r4,r17
 200365c:	a00b883a 	mov	r5,r20
 2003660:	200b6100 	call	200b610 <__divdf3>
 2003664:	d8800f15 	stw	r2,60(sp)
 2003668:	d8c01015 	stw	r3,64(sp)
 200366c:	d8c00e17 	ldw	r3,56(sp)
 2003670:	18000626 	beq	r3,zero,200368c <_dtoa_r+0x47c>
 2003674:	d9000f17 	ldw	r4,60(sp)
 2003678:	d9401017 	ldw	r5,64(sp)
 200367c:	000d883a 	mov	r6,zero
 2003680:	01cffc34 	movhi	r7,16368
 2003684:	200c05c0 	call	200c05c <__ledf2>
 2003688:	10040b16 	blt	r2,zero,20046b8 <_dtoa_r+0x14a8>
 200368c:	8009883a 	mov	r4,r16
 2003690:	200d1e40 	call	200d1e4 <__floatsidf>
 2003694:	d9800f17 	ldw	r6,60(sp)
 2003698:	d9c01017 	ldw	r7,64(sp)
 200369c:	1009883a 	mov	r4,r2
 20036a0:	180b883a 	mov	r5,r3
 20036a4:	200c1500 	call	200c150 <__muldf3>
 20036a8:	000d883a 	mov	r6,zero
 20036ac:	01d00734 	movhi	r7,16412
 20036b0:	1009883a 	mov	r4,r2
 20036b4:	180b883a 	mov	r5,r3
 20036b8:	200ad640 	call	200ad64 <__adddf3>
 20036bc:	1021883a 	mov	r16,r2
 20036c0:	d8800617 	ldw	r2,24(sp)
 20036c4:	047f3034 	movhi	r17,64704
 20036c8:	1c63883a 	add	r17,r3,r17
 20036cc:	10031826 	beq	r2,zero,2004330 <_dtoa_r+0x1120>
 20036d0:	d8c00517 	ldw	r3,20(sp)
 20036d4:	db000617 	ldw	r12,24(sp)
 20036d8:	d8c01315 	stw	r3,76(sp)
 20036dc:	d9000b17 	ldw	r4,44(sp)
 20036e0:	20038f26 	beq	r4,zero,2004520 <_dtoa_r+0x1310>
 20036e4:	60bfffc4 	addi	r2,r12,-1
 20036e8:	100490fa 	slli	r2,r2,3
 20036ec:	00c08134 	movhi	r3,516
 20036f0:	18c3fd04 	addi	r3,r3,4084
 20036f4:	1885883a 	add	r2,r3,r2
 20036f8:	11800017 	ldw	r6,0(r2)
 20036fc:	11c00117 	ldw	r7,4(r2)
 2003700:	d8800717 	ldw	r2,28(sp)
 2003704:	0009883a 	mov	r4,zero
 2003708:	014ff834 	movhi	r5,16352
 200370c:	db001615 	stw	r12,88(sp)
 2003710:	15c00044 	addi	r23,r2,1
 2003714:	200b6100 	call	200b610 <__divdf3>
 2003718:	800d883a 	mov	r6,r16
 200371c:	880f883a 	mov	r7,r17
 2003720:	1009883a 	mov	r4,r2
 2003724:	180b883a 	mov	r5,r3
 2003728:	200c8680 	call	200c868 <__subdf3>
 200372c:	d9401017 	ldw	r5,64(sp)
 2003730:	d9000f17 	ldw	r4,60(sp)
 2003734:	102b883a 	mov	r21,r2
 2003738:	d8c01215 	stw	r3,72(sp)
 200373c:	200d1640 	call	200d164 <__fixdfsi>
 2003740:	1009883a 	mov	r4,r2
 2003744:	1029883a 	mov	r20,r2
 2003748:	200d1e40 	call	200d1e4 <__floatsidf>
 200374c:	d9000f17 	ldw	r4,60(sp)
 2003750:	d9401017 	ldw	r5,64(sp)
 2003754:	100d883a 	mov	r6,r2
 2003758:	180f883a 	mov	r7,r3
 200375c:	200c8680 	call	200c868 <__subdf3>
 2003760:	1823883a 	mov	r17,r3
 2003764:	d8c00717 	ldw	r3,28(sp)
 2003768:	d9401217 	ldw	r5,72(sp)
 200376c:	a2000c04 	addi	r8,r20,48
 2003770:	1021883a 	mov	r16,r2
 2003774:	1a000005 	stb	r8,0(r3)
 2003778:	800d883a 	mov	r6,r16
 200377c:	880f883a 	mov	r7,r17
 2003780:	a809883a 	mov	r4,r21
 2003784:	4029883a 	mov	r20,r8
 2003788:	200bf800 	call	200bf80 <__gedf2>
 200378c:	00841d16 	blt	zero,r2,2004804 <_dtoa_r+0x15f4>
 2003790:	800d883a 	mov	r6,r16
 2003794:	880f883a 	mov	r7,r17
 2003798:	0009883a 	mov	r4,zero
 200379c:	014ffc34 	movhi	r5,16368
 20037a0:	200c8680 	call	200c868 <__subdf3>
 20037a4:	d9401217 	ldw	r5,72(sp)
 20037a8:	100d883a 	mov	r6,r2
 20037ac:	180f883a 	mov	r7,r3
 20037b0:	a809883a 	mov	r4,r21
 20037b4:	200bf800 	call	200bf80 <__gedf2>
 20037b8:	db001617 	ldw	r12,88(sp)
 20037bc:	00840e16 	blt	zero,r2,20047f8 <_dtoa_r+0x15e8>
 20037c0:	00800044 	movi	r2,1
 20037c4:	13006b0e 	bge	r2,r12,2003974 <_dtoa_r+0x764>
 20037c8:	d9000717 	ldw	r4,28(sp)
 20037cc:	dd800f15 	stw	r22,60(sp)
 20037d0:	dcc01015 	stw	r19,64(sp)
 20037d4:	2319883a 	add	r12,r4,r12
 20037d8:	dcc01217 	ldw	r19,72(sp)
 20037dc:	602d883a 	mov	r22,r12
 20037e0:	dc801215 	stw	r18,72(sp)
 20037e4:	b825883a 	mov	r18,r23
 20037e8:	00000906 	br	2003810 <_dtoa_r+0x600>
 20037ec:	200c8680 	call	200c868 <__subdf3>
 20037f0:	a80d883a 	mov	r6,r21
 20037f4:	980f883a 	mov	r7,r19
 20037f8:	1009883a 	mov	r4,r2
 20037fc:	180b883a 	mov	r5,r3
 2003800:	200c05c0 	call	200c05c <__ledf2>
 2003804:	1003e816 	blt	r2,zero,20047a8 <_dtoa_r+0x1598>
 2003808:	b825883a 	mov	r18,r23
 200380c:	bd83e926 	beq	r23,r22,20047b4 <_dtoa_r+0x15a4>
 2003810:	a809883a 	mov	r4,r21
 2003814:	980b883a 	mov	r5,r19
 2003818:	000d883a 	mov	r6,zero
 200381c:	01d00934 	movhi	r7,16420
 2003820:	200c1500 	call	200c150 <__muldf3>
 2003824:	000d883a 	mov	r6,zero
 2003828:	01d00934 	movhi	r7,16420
 200382c:	8009883a 	mov	r4,r16
 2003830:	880b883a 	mov	r5,r17
 2003834:	102b883a 	mov	r21,r2
 2003838:	1827883a 	mov	r19,r3
 200383c:	200c1500 	call	200c150 <__muldf3>
 2003840:	180b883a 	mov	r5,r3
 2003844:	1009883a 	mov	r4,r2
 2003848:	1821883a 	mov	r16,r3
 200384c:	1023883a 	mov	r17,r2
 2003850:	200d1640 	call	200d164 <__fixdfsi>
 2003854:	1009883a 	mov	r4,r2
 2003858:	1029883a 	mov	r20,r2
 200385c:	200d1e40 	call	200d1e4 <__floatsidf>
 2003860:	8809883a 	mov	r4,r17
 2003864:	800b883a 	mov	r5,r16
 2003868:	100d883a 	mov	r6,r2
 200386c:	180f883a 	mov	r7,r3
 2003870:	200c8680 	call	200c868 <__subdf3>
 2003874:	a5000c04 	addi	r20,r20,48
 2003878:	a80d883a 	mov	r6,r21
 200387c:	980f883a 	mov	r7,r19
 2003880:	1009883a 	mov	r4,r2
 2003884:	180b883a 	mov	r5,r3
 2003888:	95000005 	stb	r20,0(r18)
 200388c:	1021883a 	mov	r16,r2
 2003890:	1823883a 	mov	r17,r3
 2003894:	200c05c0 	call	200c05c <__ledf2>
 2003898:	bdc00044 	addi	r23,r23,1
 200389c:	800d883a 	mov	r6,r16
 20038a0:	880f883a 	mov	r7,r17
 20038a4:	0009883a 	mov	r4,zero
 20038a8:	014ffc34 	movhi	r5,16368
 20038ac:	103fcf0e 	bge	r2,zero,20037ec <__alt_mem_mem_0+0xfcfe37ec>
 20038b0:	d8c01317 	ldw	r3,76(sp)
 20038b4:	d8c00515 	stw	r3,20(sp)
 20038b8:	d9400917 	ldw	r5,36(sp)
 20038bc:	e009883a 	mov	r4,fp
 20038c0:	200633c0 	call	200633c <_Bfree>
 20038c4:	d9000517 	ldw	r4,20(sp)
 20038c8:	d9802317 	ldw	r6,140(sp)
 20038cc:	d9c02517 	ldw	r7,148(sp)
 20038d0:	b8000005 	stb	zero,0(r23)
 20038d4:	20800044 	addi	r2,r4,1
 20038d8:	30800015 	stw	r2,0(r6)
 20038dc:	3802aa26 	beq	r7,zero,2004388 <_dtoa_r+0x1178>
 20038e0:	3dc00015 	stw	r23,0(r7)
 20038e4:	d8800717 	ldw	r2,28(sp)
 20038e8:	003e7906 	br	20032d0 <__alt_mem_mem_0+0xfcfe32d0>
 20038ec:	00800434 	movhi	r2,16
 20038f0:	10bfffc4 	addi	r2,r2,-1
 20038f4:	88a2703a 	and	r17,r17,r2
 20038f8:	883e851e 	bne	r17,zero,2003310 <__alt_mem_mem_0+0xfcfe3310>
 20038fc:	00808134 	movhi	r2,516
 2003900:	1083de04 	addi	r2,r2,3960
 2003904:	003e8406 	br	2003318 <__alt_mem_mem_0+0xfcfe3318>
 2003908:	10c00204 	addi	r3,r2,8
 200390c:	003e8706 	br	200332c <__alt_mem_mem_0+0xfcfe332c>
 2003910:	01400434 	movhi	r5,16
 2003914:	297fffc4 	addi	r5,r5,-1
 2003918:	994a703a 	and	r5,r19,r5
 200391c:	9009883a 	mov	r4,r18
 2003920:	843f0044 	addi	r16,r16,-1023
 2003924:	294ffc34 	orhi	r5,r5,16368
 2003928:	dd800217 	ldw	r22,8(sp)
 200392c:	d8001115 	stw	zero,68(sp)
 2003930:	003ea506 	br	20033c8 <__alt_mem_mem_0+0xfcfe33c8>
 2003934:	00808134 	movhi	r2,516
 2003938:	1083d504 	addi	r2,r2,3924
 200393c:	003e6406 	br	20032d0 <__alt_mem_mem_0+0xfcfe32d0>
 2003940:	e0001115 	stw	zero,68(fp)
 2003944:	000b883a 	mov	r5,zero
 2003948:	e009883a 	mov	r4,fp
 200394c:	20062940 	call	2006294 <_Balloc>
 2003950:	01bfffc4 	movi	r6,-1
 2003954:	01c00044 	movi	r7,1
 2003958:	d8800715 	stw	r2,28(sp)
 200395c:	d9800c15 	stw	r6,48(sp)
 2003960:	e0801015 	stw	r2,64(fp)
 2003964:	d8000315 	stw	zero,12(sp)
 2003968:	d9c00b15 	stw	r7,44(sp)
 200396c:	d9800615 	stw	r6,24(sp)
 2003970:	d8002215 	stw	zero,136(sp)
 2003974:	d8800117 	ldw	r2,4(sp)
 2003978:	10008916 	blt	r2,zero,2003ba0 <_dtoa_r+0x990>
 200397c:	d9000517 	ldw	r4,20(sp)
 2003980:	00c00384 	movi	r3,14
 2003984:	19008616 	blt	r3,r4,2003ba0 <_dtoa_r+0x990>
 2003988:	200490fa 	slli	r2,r4,3
 200398c:	00c08134 	movhi	r3,516
 2003990:	d9802217 	ldw	r6,136(sp)
 2003994:	18c3fd04 	addi	r3,r3,4084
 2003998:	1885883a 	add	r2,r3,r2
 200399c:	14000017 	ldw	r16,0(r2)
 20039a0:	14400117 	ldw	r17,4(r2)
 20039a4:	30016316 	blt	r6,zero,2003f34 <_dtoa_r+0xd24>
 20039a8:	800d883a 	mov	r6,r16
 20039ac:	880f883a 	mov	r7,r17
 20039b0:	9009883a 	mov	r4,r18
 20039b4:	980b883a 	mov	r5,r19
 20039b8:	200b6100 	call	200b610 <__divdf3>
 20039bc:	180b883a 	mov	r5,r3
 20039c0:	1009883a 	mov	r4,r2
 20039c4:	200d1640 	call	200d164 <__fixdfsi>
 20039c8:	1009883a 	mov	r4,r2
 20039cc:	102b883a 	mov	r21,r2
 20039d0:	200d1e40 	call	200d1e4 <__floatsidf>
 20039d4:	800d883a 	mov	r6,r16
 20039d8:	880f883a 	mov	r7,r17
 20039dc:	1009883a 	mov	r4,r2
 20039e0:	180b883a 	mov	r5,r3
 20039e4:	200c1500 	call	200c150 <__muldf3>
 20039e8:	100d883a 	mov	r6,r2
 20039ec:	180f883a 	mov	r7,r3
 20039f0:	9009883a 	mov	r4,r18
 20039f4:	980b883a 	mov	r5,r19
 20039f8:	200c8680 	call	200c868 <__subdf3>
 20039fc:	d9c00717 	ldw	r7,28(sp)
 2003a00:	1009883a 	mov	r4,r2
 2003a04:	a8800c04 	addi	r2,r21,48
 2003a08:	38800005 	stb	r2,0(r7)
 2003a0c:	3dc00044 	addi	r23,r7,1
 2003a10:	d9c00617 	ldw	r7,24(sp)
 2003a14:	01800044 	movi	r6,1
 2003a18:	180b883a 	mov	r5,r3
 2003a1c:	2005883a 	mov	r2,r4
 2003a20:	39803826 	beq	r7,r6,2003b04 <_dtoa_r+0x8f4>
 2003a24:	000d883a 	mov	r6,zero
 2003a28:	01d00934 	movhi	r7,16420
 2003a2c:	200c1500 	call	200c150 <__muldf3>
 2003a30:	000d883a 	mov	r6,zero
 2003a34:	000f883a 	mov	r7,zero
 2003a38:	1009883a 	mov	r4,r2
 2003a3c:	180b883a 	mov	r5,r3
 2003a40:	1025883a 	mov	r18,r2
 2003a44:	1827883a 	mov	r19,r3
 2003a48:	200bef80 	call	200bef8 <__eqdf2>
 2003a4c:	103f9a26 	beq	r2,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003a50:	d9c00617 	ldw	r7,24(sp)
 2003a54:	d8c00717 	ldw	r3,28(sp)
 2003a58:	b829883a 	mov	r20,r23
 2003a5c:	38bfffc4 	addi	r2,r7,-1
 2003a60:	18ad883a 	add	r22,r3,r2
 2003a64:	00000a06 	br	2003a90 <_dtoa_r+0x880>
 2003a68:	200c1500 	call	200c150 <__muldf3>
 2003a6c:	000d883a 	mov	r6,zero
 2003a70:	000f883a 	mov	r7,zero
 2003a74:	1009883a 	mov	r4,r2
 2003a78:	180b883a 	mov	r5,r3
 2003a7c:	1025883a 	mov	r18,r2
 2003a80:	1827883a 	mov	r19,r3
 2003a84:	b829883a 	mov	r20,r23
 2003a88:	200bef80 	call	200bef8 <__eqdf2>
 2003a8c:	103f8a26 	beq	r2,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003a90:	800d883a 	mov	r6,r16
 2003a94:	880f883a 	mov	r7,r17
 2003a98:	9009883a 	mov	r4,r18
 2003a9c:	980b883a 	mov	r5,r19
 2003aa0:	200b6100 	call	200b610 <__divdf3>
 2003aa4:	180b883a 	mov	r5,r3
 2003aa8:	1009883a 	mov	r4,r2
 2003aac:	200d1640 	call	200d164 <__fixdfsi>
 2003ab0:	1009883a 	mov	r4,r2
 2003ab4:	102b883a 	mov	r21,r2
 2003ab8:	200d1e40 	call	200d1e4 <__floatsidf>
 2003abc:	800d883a 	mov	r6,r16
 2003ac0:	880f883a 	mov	r7,r17
 2003ac4:	1009883a 	mov	r4,r2
 2003ac8:	180b883a 	mov	r5,r3
 2003acc:	200c1500 	call	200c150 <__muldf3>
 2003ad0:	100d883a 	mov	r6,r2
 2003ad4:	180f883a 	mov	r7,r3
 2003ad8:	9009883a 	mov	r4,r18
 2003adc:	980b883a 	mov	r5,r19
 2003ae0:	200c8680 	call	200c868 <__subdf3>
 2003ae4:	aa000c04 	addi	r8,r21,48
 2003ae8:	a2000005 	stb	r8,0(r20)
 2003aec:	000d883a 	mov	r6,zero
 2003af0:	01d00934 	movhi	r7,16420
 2003af4:	1009883a 	mov	r4,r2
 2003af8:	180b883a 	mov	r5,r3
 2003afc:	a5c00044 	addi	r23,r20,1
 2003b00:	b53fd91e 	bne	r22,r20,2003a68 <__alt_mem_mem_0+0xfcfe3a68>
 2003b04:	100d883a 	mov	r6,r2
 2003b08:	180f883a 	mov	r7,r3
 2003b0c:	1009883a 	mov	r4,r2
 2003b10:	180b883a 	mov	r5,r3
 2003b14:	200ad640 	call	200ad64 <__adddf3>
 2003b18:	100d883a 	mov	r6,r2
 2003b1c:	180f883a 	mov	r7,r3
 2003b20:	8009883a 	mov	r4,r16
 2003b24:	880b883a 	mov	r5,r17
 2003b28:	1027883a 	mov	r19,r2
 2003b2c:	1825883a 	mov	r18,r3
 2003b30:	200c05c0 	call	200c05c <__ledf2>
 2003b34:	10000816 	blt	r2,zero,2003b58 <_dtoa_r+0x948>
 2003b38:	980d883a 	mov	r6,r19
 2003b3c:	900f883a 	mov	r7,r18
 2003b40:	8009883a 	mov	r4,r16
 2003b44:	880b883a 	mov	r5,r17
 2003b48:	200bef80 	call	200bef8 <__eqdf2>
 2003b4c:	103f5a1e 	bne	r2,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003b50:	ad40004c 	andi	r21,r21,1
 2003b54:	a83f5826 	beq	r21,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003b58:	bd3fffc3 	ldbu	r20,-1(r23)
 2003b5c:	b8bfffc4 	addi	r2,r23,-1
 2003b60:	1007883a 	mov	r3,r2
 2003b64:	01400e44 	movi	r5,57
 2003b68:	d9800717 	ldw	r6,28(sp)
 2003b6c:	00000506 	br	2003b84 <_dtoa_r+0x974>
 2003b70:	18ffffc4 	addi	r3,r3,-1
 2003b74:	11824726 	beq	r2,r6,2004494 <_dtoa_r+0x1284>
 2003b78:	1d000003 	ldbu	r20,0(r3)
 2003b7c:	102f883a 	mov	r23,r2
 2003b80:	10bfffc4 	addi	r2,r2,-1
 2003b84:	a1003fcc 	andi	r4,r20,255
 2003b88:	2100201c 	xori	r4,r4,128
 2003b8c:	213fe004 	addi	r4,r4,-128
 2003b90:	217ff726 	beq	r4,r5,2003b70 <__alt_mem_mem_0+0xfcfe3b70>
 2003b94:	a2000044 	addi	r8,r20,1
 2003b98:	12000005 	stb	r8,0(r2)
 2003b9c:	003f4606 	br	20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003ba0:	d9000b17 	ldw	r4,44(sp)
 2003ba4:	2000c826 	beq	r4,zero,2003ec8 <_dtoa_r+0xcb8>
 2003ba8:	d9800317 	ldw	r6,12(sp)
 2003bac:	00c00044 	movi	r3,1
 2003bb0:	1980f90e 	bge	r3,r6,2003f98 <_dtoa_r+0xd88>
 2003bb4:	d8800617 	ldw	r2,24(sp)
 2003bb8:	d8c00a17 	ldw	r3,40(sp)
 2003bbc:	157fffc4 	addi	r21,r2,-1
 2003bc0:	1d41f316 	blt	r3,r21,2004390 <_dtoa_r+0x1180>
 2003bc4:	1d6bc83a 	sub	r21,r3,r21
 2003bc8:	d9c00617 	ldw	r7,24(sp)
 2003bcc:	3802aa16 	blt	r7,zero,2004678 <_dtoa_r+0x1468>
 2003bd0:	dd000817 	ldw	r20,32(sp)
 2003bd4:	d8800617 	ldw	r2,24(sp)
 2003bd8:	d8c00817 	ldw	r3,32(sp)
 2003bdc:	01400044 	movi	r5,1
 2003be0:	e009883a 	mov	r4,fp
 2003be4:	1887883a 	add	r3,r3,r2
 2003be8:	d8c00815 	stw	r3,32(sp)
 2003bec:	b0ad883a 	add	r22,r22,r2
 2003bf0:	20066a00 	call	20066a0 <__i2b>
 2003bf4:	1023883a 	mov	r17,r2
 2003bf8:	a0000826 	beq	r20,zero,2003c1c <_dtoa_r+0xa0c>
 2003bfc:	0580070e 	bge	zero,r22,2003c1c <_dtoa_r+0xa0c>
 2003c00:	a005883a 	mov	r2,r20
 2003c04:	b500b916 	blt	r22,r20,2003eec <_dtoa_r+0xcdc>
 2003c08:	d9000817 	ldw	r4,32(sp)
 2003c0c:	a0a9c83a 	sub	r20,r20,r2
 2003c10:	b0adc83a 	sub	r22,r22,r2
 2003c14:	2089c83a 	sub	r4,r4,r2
 2003c18:	d9000815 	stw	r4,32(sp)
 2003c1c:	d9800a17 	ldw	r6,40(sp)
 2003c20:	0181810e 	bge	zero,r6,2004228 <_dtoa_r+0x1018>
 2003c24:	d9c00b17 	ldw	r7,44(sp)
 2003c28:	3800b326 	beq	r7,zero,2003ef8 <_dtoa_r+0xce8>
 2003c2c:	a800b226 	beq	r21,zero,2003ef8 <_dtoa_r+0xce8>
 2003c30:	880b883a 	mov	r5,r17
 2003c34:	a80d883a 	mov	r6,r21
 2003c38:	e009883a 	mov	r4,fp
 2003c3c:	20068d40 	call	20068d4 <__pow5mult>
 2003c40:	d9800917 	ldw	r6,36(sp)
 2003c44:	100b883a 	mov	r5,r2
 2003c48:	e009883a 	mov	r4,fp
 2003c4c:	1023883a 	mov	r17,r2
 2003c50:	20066dc0 	call	20066dc <__multiply>
 2003c54:	1021883a 	mov	r16,r2
 2003c58:	d8800a17 	ldw	r2,40(sp)
 2003c5c:	d9400917 	ldw	r5,36(sp)
 2003c60:	e009883a 	mov	r4,fp
 2003c64:	1545c83a 	sub	r2,r2,r21
 2003c68:	d8800a15 	stw	r2,40(sp)
 2003c6c:	200633c0 	call	200633c <_Bfree>
 2003c70:	d8c00a17 	ldw	r3,40(sp)
 2003c74:	18009f1e 	bne	r3,zero,2003ef4 <_dtoa_r+0xce4>
 2003c78:	05c00044 	movi	r23,1
 2003c7c:	e009883a 	mov	r4,fp
 2003c80:	b80b883a 	mov	r5,r23
 2003c84:	20066a00 	call	20066a0 <__i2b>
 2003c88:	d9000d17 	ldw	r4,52(sp)
 2003c8c:	102b883a 	mov	r21,r2
 2003c90:	2000ce26 	beq	r4,zero,2003fcc <_dtoa_r+0xdbc>
 2003c94:	200d883a 	mov	r6,r4
 2003c98:	100b883a 	mov	r5,r2
 2003c9c:	e009883a 	mov	r4,fp
 2003ca0:	20068d40 	call	20068d4 <__pow5mult>
 2003ca4:	d9800317 	ldw	r6,12(sp)
 2003ca8:	102b883a 	mov	r21,r2
 2003cac:	b981810e 	bge	r23,r6,20042b4 <_dtoa_r+0x10a4>
 2003cb0:	0027883a 	mov	r19,zero
 2003cb4:	a8800417 	ldw	r2,16(r21)
 2003cb8:	05c00804 	movi	r23,32
 2003cbc:	10800104 	addi	r2,r2,4
 2003cc0:	1085883a 	add	r2,r2,r2
 2003cc4:	1085883a 	add	r2,r2,r2
 2003cc8:	a885883a 	add	r2,r21,r2
 2003ccc:	11000017 	ldw	r4,0(r2)
 2003cd0:	20065880 	call	2006588 <__hi0bits>
 2003cd4:	b885c83a 	sub	r2,r23,r2
 2003cd8:	1585883a 	add	r2,r2,r22
 2003cdc:	108007cc 	andi	r2,r2,31
 2003ce0:	1000b326 	beq	r2,zero,2003fb0 <_dtoa_r+0xda0>
 2003ce4:	00c00804 	movi	r3,32
 2003ce8:	1887c83a 	sub	r3,r3,r2
 2003cec:	01000104 	movi	r4,4
 2003cf0:	20c2cd0e 	bge	r4,r3,2004828 <_dtoa_r+0x1618>
 2003cf4:	00c00704 	movi	r3,28
 2003cf8:	1885c83a 	sub	r2,r3,r2
 2003cfc:	d8c00817 	ldw	r3,32(sp)
 2003d00:	a0a9883a 	add	r20,r20,r2
 2003d04:	b0ad883a 	add	r22,r22,r2
 2003d08:	1887883a 	add	r3,r3,r2
 2003d0c:	d8c00815 	stw	r3,32(sp)
 2003d10:	d9800817 	ldw	r6,32(sp)
 2003d14:	0180040e 	bge	zero,r6,2003d28 <_dtoa_r+0xb18>
 2003d18:	800b883a 	mov	r5,r16
 2003d1c:	e009883a 	mov	r4,fp
 2003d20:	2006a140 	call	2006a14 <__lshift>
 2003d24:	1021883a 	mov	r16,r2
 2003d28:	0580050e 	bge	zero,r22,2003d40 <_dtoa_r+0xb30>
 2003d2c:	a80b883a 	mov	r5,r21
 2003d30:	b00d883a 	mov	r6,r22
 2003d34:	e009883a 	mov	r4,fp
 2003d38:	2006a140 	call	2006a14 <__lshift>
 2003d3c:	102b883a 	mov	r21,r2
 2003d40:	d9c00e17 	ldw	r7,56(sp)
 2003d44:	3801211e 	bne	r7,zero,20041cc <_dtoa_r+0xfbc>
 2003d48:	d9800617 	ldw	r6,24(sp)
 2003d4c:	0181380e 	bge	zero,r6,2004230 <_dtoa_r+0x1020>
 2003d50:	d8c00b17 	ldw	r3,44(sp)
 2003d54:	1800ab1e 	bne	r3,zero,2004004 <_dtoa_r+0xdf4>
 2003d58:	dc800717 	ldw	r18,28(sp)
 2003d5c:	dcc00617 	ldw	r19,24(sp)
 2003d60:	9029883a 	mov	r20,r18
 2003d64:	00000206 	br	2003d70 <_dtoa_r+0xb60>
 2003d68:	20063640 	call	2006364 <__multadd>
 2003d6c:	1021883a 	mov	r16,r2
 2003d70:	a80b883a 	mov	r5,r21
 2003d74:	8009883a 	mov	r4,r16
 2003d78:	20030100 	call	2003010 <quorem>
 2003d7c:	10800c04 	addi	r2,r2,48
 2003d80:	90800005 	stb	r2,0(r18)
 2003d84:	94800044 	addi	r18,r18,1
 2003d88:	9507c83a 	sub	r3,r18,r20
 2003d8c:	000f883a 	mov	r7,zero
 2003d90:	01800284 	movi	r6,10
 2003d94:	800b883a 	mov	r5,r16
 2003d98:	e009883a 	mov	r4,fp
 2003d9c:	1cfff216 	blt	r3,r19,2003d68 <__alt_mem_mem_0+0xfcfe3d68>
 2003da0:	1011883a 	mov	r8,r2
 2003da4:	d8800617 	ldw	r2,24(sp)
 2003da8:	0082370e 	bge	zero,r2,2004688 <_dtoa_r+0x1478>
 2003dac:	d9000717 	ldw	r4,28(sp)
 2003db0:	0025883a 	mov	r18,zero
 2003db4:	20af883a 	add	r23,r4,r2
 2003db8:	01800044 	movi	r6,1
 2003dbc:	800b883a 	mov	r5,r16
 2003dc0:	e009883a 	mov	r4,fp
 2003dc4:	da001715 	stw	r8,92(sp)
 2003dc8:	2006a140 	call	2006a14 <__lshift>
 2003dcc:	a80b883a 	mov	r5,r21
 2003dd0:	1009883a 	mov	r4,r2
 2003dd4:	d8800915 	stw	r2,36(sp)
 2003dd8:	2006b5c0 	call	2006b5c <__mcmp>
 2003ddc:	da001717 	ldw	r8,92(sp)
 2003de0:	0081800e 	bge	zero,r2,20043e4 <_dtoa_r+0x11d4>
 2003de4:	b93fffc3 	ldbu	r4,-1(r23)
 2003de8:	b8bfffc4 	addi	r2,r23,-1
 2003dec:	1007883a 	mov	r3,r2
 2003df0:	01800e44 	movi	r6,57
 2003df4:	d9c00717 	ldw	r7,28(sp)
 2003df8:	00000506 	br	2003e10 <_dtoa_r+0xc00>
 2003dfc:	18ffffc4 	addi	r3,r3,-1
 2003e00:	11c12326 	beq	r2,r7,2004290 <_dtoa_r+0x1080>
 2003e04:	19000003 	ldbu	r4,0(r3)
 2003e08:	102f883a 	mov	r23,r2
 2003e0c:	10bfffc4 	addi	r2,r2,-1
 2003e10:	21403fcc 	andi	r5,r4,255
 2003e14:	2940201c 	xori	r5,r5,128
 2003e18:	297fe004 	addi	r5,r5,-128
 2003e1c:	29bff726 	beq	r5,r6,2003dfc <__alt_mem_mem_0+0xfcfe3dfc>
 2003e20:	21000044 	addi	r4,r4,1
 2003e24:	11000005 	stb	r4,0(r2)
 2003e28:	a80b883a 	mov	r5,r21
 2003e2c:	e009883a 	mov	r4,fp
 2003e30:	200633c0 	call	200633c <_Bfree>
 2003e34:	883ea026 	beq	r17,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003e38:	90000426 	beq	r18,zero,2003e4c <_dtoa_r+0xc3c>
 2003e3c:	94400326 	beq	r18,r17,2003e4c <_dtoa_r+0xc3c>
 2003e40:	900b883a 	mov	r5,r18
 2003e44:	e009883a 	mov	r4,fp
 2003e48:	200633c0 	call	200633c <_Bfree>
 2003e4c:	880b883a 	mov	r5,r17
 2003e50:	e009883a 	mov	r4,fp
 2003e54:	200633c0 	call	200633c <_Bfree>
 2003e58:	003e9706 	br	20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003e5c:	01800044 	movi	r6,1
 2003e60:	d9800e15 	stw	r6,56(sp)
 2003e64:	003d9606 	br	20034c0 <__alt_mem_mem_0+0xfcfe34c0>
 2003e68:	d8800817 	ldw	r2,32(sp)
 2003e6c:	d8c00517 	ldw	r3,20(sp)
 2003e70:	d8000d15 	stw	zero,52(sp)
 2003e74:	10c5c83a 	sub	r2,r2,r3
 2003e78:	00c9c83a 	sub	r4,zero,r3
 2003e7c:	d8800815 	stw	r2,32(sp)
 2003e80:	d9000a15 	stw	r4,40(sp)
 2003e84:	003d9706 	br	20034e4 <__alt_mem_mem_0+0xfcfe34e4>
 2003e88:	05adc83a 	sub	r22,zero,r22
 2003e8c:	dd800815 	stw	r22,32(sp)
 2003e90:	002d883a 	mov	r22,zero
 2003e94:	003d8e06 	br	20034d0 <__alt_mem_mem_0+0xfcfe34d0>
 2003e98:	d9000517 	ldw	r4,20(sp)
 2003e9c:	200d1e40 	call	200d1e4 <__floatsidf>
 2003ea0:	100d883a 	mov	r6,r2
 2003ea4:	180f883a 	mov	r7,r3
 2003ea8:	a009883a 	mov	r4,r20
 2003eac:	880b883a 	mov	r5,r17
 2003eb0:	200bef80 	call	200bef8 <__eqdf2>
 2003eb4:	103d7126 	beq	r2,zero,200347c <__alt_mem_mem_0+0xfcfe347c>
 2003eb8:	d9c00517 	ldw	r7,20(sp)
 2003ebc:	39ffffc4 	addi	r7,r7,-1
 2003ec0:	d9c00515 	stw	r7,20(sp)
 2003ec4:	003d6d06 	br	200347c <__alt_mem_mem_0+0xfcfe347c>
 2003ec8:	dd400a17 	ldw	r21,40(sp)
 2003ecc:	dd000817 	ldw	r20,32(sp)
 2003ed0:	0023883a 	mov	r17,zero
 2003ed4:	003f4806 	br	2003bf8 <__alt_mem_mem_0+0xfcfe3bf8>
 2003ed8:	10e3c83a 	sub	r17,r2,r3
 2003edc:	9448983a 	sll	r4,r18,r17
 2003ee0:	003d3206 	br	20033ac <__alt_mem_mem_0+0xfcfe33ac>
 2003ee4:	d8000e15 	stw	zero,56(sp)
 2003ee8:	003d7506 	br	20034c0 <__alt_mem_mem_0+0xfcfe34c0>
 2003eec:	b005883a 	mov	r2,r22
 2003ef0:	003f4506 	br	2003c08 <__alt_mem_mem_0+0xfcfe3c08>
 2003ef4:	dc000915 	stw	r16,36(sp)
 2003ef8:	d9800a17 	ldw	r6,40(sp)
 2003efc:	d9400917 	ldw	r5,36(sp)
 2003f00:	e009883a 	mov	r4,fp
 2003f04:	20068d40 	call	20068d4 <__pow5mult>
 2003f08:	1021883a 	mov	r16,r2
 2003f0c:	003f5a06 	br	2003c78 <__alt_mem_mem_0+0xfcfe3c78>
 2003f10:	01c00044 	movi	r7,1
 2003f14:	d9c00b15 	stw	r7,44(sp)
 2003f18:	d8802217 	ldw	r2,136(sp)
 2003f1c:	0081280e 	bge	zero,r2,20043c0 <_dtoa_r+0x11b0>
 2003f20:	100d883a 	mov	r6,r2
 2003f24:	1021883a 	mov	r16,r2
 2003f28:	d8800c15 	stw	r2,48(sp)
 2003f2c:	d8800615 	stw	r2,24(sp)
 2003f30:	003d8806 	br	2003554 <__alt_mem_mem_0+0xfcfe3554>
 2003f34:	d8800617 	ldw	r2,24(sp)
 2003f38:	00be9b16 	blt	zero,r2,20039a8 <__alt_mem_mem_0+0xfcfe39a8>
 2003f3c:	10010f1e 	bne	r2,zero,200437c <_dtoa_r+0x116c>
 2003f40:	880b883a 	mov	r5,r17
 2003f44:	000d883a 	mov	r6,zero
 2003f48:	01d00534 	movhi	r7,16404
 2003f4c:	8009883a 	mov	r4,r16
 2003f50:	200c1500 	call	200c150 <__muldf3>
 2003f54:	900d883a 	mov	r6,r18
 2003f58:	980f883a 	mov	r7,r19
 2003f5c:	1009883a 	mov	r4,r2
 2003f60:	180b883a 	mov	r5,r3
 2003f64:	200bf800 	call	200bf80 <__gedf2>
 2003f68:	002b883a 	mov	r21,zero
 2003f6c:	0023883a 	mov	r17,zero
 2003f70:	1000bf16 	blt	r2,zero,2004270 <_dtoa_r+0x1060>
 2003f74:	d9802217 	ldw	r6,136(sp)
 2003f78:	ddc00717 	ldw	r23,28(sp)
 2003f7c:	018c303a 	nor	r6,zero,r6
 2003f80:	d9800515 	stw	r6,20(sp)
 2003f84:	a80b883a 	mov	r5,r21
 2003f88:	e009883a 	mov	r4,fp
 2003f8c:	200633c0 	call	200633c <_Bfree>
 2003f90:	883e4926 	beq	r17,zero,20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2003f94:	003fad06 	br	2003e4c <__alt_mem_mem_0+0xfcfe3e4c>
 2003f98:	d9c01117 	ldw	r7,68(sp)
 2003f9c:	3801bc26 	beq	r7,zero,2004690 <_dtoa_r+0x1480>
 2003fa0:	10810cc4 	addi	r2,r2,1075
 2003fa4:	dd400a17 	ldw	r21,40(sp)
 2003fa8:	dd000817 	ldw	r20,32(sp)
 2003fac:	003f0a06 	br	2003bd8 <__alt_mem_mem_0+0xfcfe3bd8>
 2003fb0:	00800704 	movi	r2,28
 2003fb4:	d9000817 	ldw	r4,32(sp)
 2003fb8:	a0a9883a 	add	r20,r20,r2
 2003fbc:	b0ad883a 	add	r22,r22,r2
 2003fc0:	2089883a 	add	r4,r4,r2
 2003fc4:	d9000815 	stw	r4,32(sp)
 2003fc8:	003f5106 	br	2003d10 <__alt_mem_mem_0+0xfcfe3d10>
 2003fcc:	d8c00317 	ldw	r3,12(sp)
 2003fd0:	b8c1fc0e 	bge	r23,r3,20047c4 <_dtoa_r+0x15b4>
 2003fd4:	0027883a 	mov	r19,zero
 2003fd8:	b805883a 	mov	r2,r23
 2003fdc:	003f3e06 	br	2003cd8 <__alt_mem_mem_0+0xfcfe3cd8>
 2003fe0:	880b883a 	mov	r5,r17
 2003fe4:	e009883a 	mov	r4,fp
 2003fe8:	000f883a 	mov	r7,zero
 2003fec:	01800284 	movi	r6,10
 2003ff0:	20063640 	call	2006364 <__multadd>
 2003ff4:	d9000c17 	ldw	r4,48(sp)
 2003ff8:	1023883a 	mov	r17,r2
 2003ffc:	0102040e 	bge	zero,r4,2004810 <_dtoa_r+0x1600>
 2004000:	d9000615 	stw	r4,24(sp)
 2004004:	0500050e 	bge	zero,r20,200401c <_dtoa_r+0xe0c>
 2004008:	880b883a 	mov	r5,r17
 200400c:	a00d883a 	mov	r6,r20
 2004010:	e009883a 	mov	r4,fp
 2004014:	2006a140 	call	2006a14 <__lshift>
 2004018:	1023883a 	mov	r17,r2
 200401c:	9801241e 	bne	r19,zero,20044b0 <_dtoa_r+0x12a0>
 2004020:	8829883a 	mov	r20,r17
 2004024:	d9000617 	ldw	r4,24(sp)
 2004028:	dcc00717 	ldw	r19,28(sp)
 200402c:	9480004c 	andi	r18,r18,1
 2004030:	20bfffc4 	addi	r2,r4,-1
 2004034:	9885883a 	add	r2,r19,r2
 2004038:	d8800415 	stw	r2,16(sp)
 200403c:	dc800615 	stw	r18,24(sp)
 2004040:	a80b883a 	mov	r5,r21
 2004044:	8009883a 	mov	r4,r16
 2004048:	20030100 	call	2003010 <quorem>
 200404c:	880b883a 	mov	r5,r17
 2004050:	8009883a 	mov	r4,r16
 2004054:	102f883a 	mov	r23,r2
 2004058:	2006b5c0 	call	2006b5c <__mcmp>
 200405c:	a80b883a 	mov	r5,r21
 2004060:	a00d883a 	mov	r6,r20
 2004064:	e009883a 	mov	r4,fp
 2004068:	102d883a 	mov	r22,r2
 200406c:	2006bbc0 	call	2006bbc <__mdiff>
 2004070:	1007883a 	mov	r3,r2
 2004074:	10800317 	ldw	r2,12(r2)
 2004078:	bc800c04 	addi	r18,r23,48
 200407c:	180b883a 	mov	r5,r3
 2004080:	10004e1e 	bne	r2,zero,20041bc <_dtoa_r+0xfac>
 2004084:	8009883a 	mov	r4,r16
 2004088:	d8c01615 	stw	r3,88(sp)
 200408c:	2006b5c0 	call	2006b5c <__mcmp>
 2004090:	d8c01617 	ldw	r3,88(sp)
 2004094:	e009883a 	mov	r4,fp
 2004098:	d8801615 	stw	r2,88(sp)
 200409c:	180b883a 	mov	r5,r3
 20040a0:	200633c0 	call	200633c <_Bfree>
 20040a4:	d8801617 	ldw	r2,88(sp)
 20040a8:	1000041e 	bne	r2,zero,20040bc <_dtoa_r+0xeac>
 20040ac:	d9800317 	ldw	r6,12(sp)
 20040b0:	3000021e 	bne	r6,zero,20040bc <_dtoa_r+0xeac>
 20040b4:	d8c00617 	ldw	r3,24(sp)
 20040b8:	18003726 	beq	r3,zero,2004198 <_dtoa_r+0xf88>
 20040bc:	b0002016 	blt	r22,zero,2004140 <_dtoa_r+0xf30>
 20040c0:	b000041e 	bne	r22,zero,20040d4 <_dtoa_r+0xec4>
 20040c4:	d9000317 	ldw	r4,12(sp)
 20040c8:	2000021e 	bne	r4,zero,20040d4 <_dtoa_r+0xec4>
 20040cc:	d8c00617 	ldw	r3,24(sp)
 20040d0:	18001b26 	beq	r3,zero,2004140 <_dtoa_r+0xf30>
 20040d4:	00810716 	blt	zero,r2,20044f4 <_dtoa_r+0x12e4>
 20040d8:	d8c00417 	ldw	r3,16(sp)
 20040dc:	9d800044 	addi	r22,r19,1
 20040e0:	9c800005 	stb	r18,0(r19)
 20040e4:	b02f883a 	mov	r23,r22
 20040e8:	98c10626 	beq	r19,r3,2004504 <_dtoa_r+0x12f4>
 20040ec:	800b883a 	mov	r5,r16
 20040f0:	000f883a 	mov	r7,zero
 20040f4:	01800284 	movi	r6,10
 20040f8:	e009883a 	mov	r4,fp
 20040fc:	20063640 	call	2006364 <__multadd>
 2004100:	1021883a 	mov	r16,r2
 2004104:	000f883a 	mov	r7,zero
 2004108:	01800284 	movi	r6,10
 200410c:	880b883a 	mov	r5,r17
 2004110:	e009883a 	mov	r4,fp
 2004114:	8d002526 	beq	r17,r20,20041ac <_dtoa_r+0xf9c>
 2004118:	20063640 	call	2006364 <__multadd>
 200411c:	a00b883a 	mov	r5,r20
 2004120:	000f883a 	mov	r7,zero
 2004124:	01800284 	movi	r6,10
 2004128:	e009883a 	mov	r4,fp
 200412c:	1023883a 	mov	r17,r2
 2004130:	20063640 	call	2006364 <__multadd>
 2004134:	1029883a 	mov	r20,r2
 2004138:	b027883a 	mov	r19,r22
 200413c:	003fc006 	br	2004040 <__alt_mem_mem_0+0xfcfe4040>
 2004140:	9011883a 	mov	r8,r18
 2004144:	00800e0e 	bge	zero,r2,2004180 <_dtoa_r+0xf70>
 2004148:	800b883a 	mov	r5,r16
 200414c:	01800044 	movi	r6,1
 2004150:	e009883a 	mov	r4,fp
 2004154:	da001715 	stw	r8,92(sp)
 2004158:	2006a140 	call	2006a14 <__lshift>
 200415c:	a80b883a 	mov	r5,r21
 2004160:	1009883a 	mov	r4,r2
 2004164:	1021883a 	mov	r16,r2
 2004168:	2006b5c0 	call	2006b5c <__mcmp>
 200416c:	da001717 	ldw	r8,92(sp)
 2004170:	0081960e 	bge	zero,r2,20047cc <_dtoa_r+0x15bc>
 2004174:	00800e44 	movi	r2,57
 2004178:	40817026 	beq	r8,r2,200473c <_dtoa_r+0x152c>
 200417c:	ba000c44 	addi	r8,r23,49
 2004180:	8825883a 	mov	r18,r17
 2004184:	9dc00044 	addi	r23,r19,1
 2004188:	9a000005 	stb	r8,0(r19)
 200418c:	a023883a 	mov	r17,r20
 2004190:	dc000915 	stw	r16,36(sp)
 2004194:	003f2406 	br	2003e28 <__alt_mem_mem_0+0xfcfe3e28>
 2004198:	00800e44 	movi	r2,57
 200419c:	9011883a 	mov	r8,r18
 20041a0:	90816626 	beq	r18,r2,200473c <_dtoa_r+0x152c>
 20041a4:	05bff516 	blt	zero,r22,200417c <__alt_mem_mem_0+0xfcfe417c>
 20041a8:	003ff506 	br	2004180 <__alt_mem_mem_0+0xfcfe4180>
 20041ac:	20063640 	call	2006364 <__multadd>
 20041b0:	1023883a 	mov	r17,r2
 20041b4:	1029883a 	mov	r20,r2
 20041b8:	003fdf06 	br	2004138 <__alt_mem_mem_0+0xfcfe4138>
 20041bc:	e009883a 	mov	r4,fp
 20041c0:	200633c0 	call	200633c <_Bfree>
 20041c4:	00800044 	movi	r2,1
 20041c8:	003fbc06 	br	20040bc <__alt_mem_mem_0+0xfcfe40bc>
 20041cc:	a80b883a 	mov	r5,r21
 20041d0:	8009883a 	mov	r4,r16
 20041d4:	2006b5c0 	call	2006b5c <__mcmp>
 20041d8:	103edb0e 	bge	r2,zero,2003d48 <__alt_mem_mem_0+0xfcfe3d48>
 20041dc:	800b883a 	mov	r5,r16
 20041e0:	000f883a 	mov	r7,zero
 20041e4:	01800284 	movi	r6,10
 20041e8:	e009883a 	mov	r4,fp
 20041ec:	20063640 	call	2006364 <__multadd>
 20041f0:	1021883a 	mov	r16,r2
 20041f4:	d8800517 	ldw	r2,20(sp)
 20041f8:	d8c00b17 	ldw	r3,44(sp)
 20041fc:	10bfffc4 	addi	r2,r2,-1
 2004200:	d8800515 	stw	r2,20(sp)
 2004204:	183f761e 	bne	r3,zero,2003fe0 <__alt_mem_mem_0+0xfcfe3fe0>
 2004208:	d9000c17 	ldw	r4,48(sp)
 200420c:	0101730e 	bge	zero,r4,20047dc <_dtoa_r+0x15cc>
 2004210:	d9000615 	stw	r4,24(sp)
 2004214:	003ed006 	br	2003d58 <__alt_mem_mem_0+0xfcfe3d58>
 2004218:	00800084 	movi	r2,2
 200421c:	3081861e 	bne	r6,r2,2004838 <_dtoa_r+0x1628>
 2004220:	d8000b15 	stw	zero,44(sp)
 2004224:	003f3c06 	br	2003f18 <__alt_mem_mem_0+0xfcfe3f18>
 2004228:	dc000917 	ldw	r16,36(sp)
 200422c:	003e9206 	br	2003c78 <__alt_mem_mem_0+0xfcfe3c78>
 2004230:	d9c00317 	ldw	r7,12(sp)
 2004234:	00800084 	movi	r2,2
 2004238:	11fec50e 	bge	r2,r7,2003d50 <__alt_mem_mem_0+0xfcfe3d50>
 200423c:	d9000617 	ldw	r4,24(sp)
 2004240:	20013c1e 	bne	r4,zero,2004734 <_dtoa_r+0x1524>
 2004244:	a80b883a 	mov	r5,r21
 2004248:	000f883a 	mov	r7,zero
 200424c:	01800144 	movi	r6,5
 2004250:	e009883a 	mov	r4,fp
 2004254:	20063640 	call	2006364 <__multadd>
 2004258:	100b883a 	mov	r5,r2
 200425c:	8009883a 	mov	r4,r16
 2004260:	102b883a 	mov	r21,r2
 2004264:	2006b5c0 	call	2006b5c <__mcmp>
 2004268:	dc000915 	stw	r16,36(sp)
 200426c:	00bf410e 	bge	zero,r2,2003f74 <__alt_mem_mem_0+0xfcfe3f74>
 2004270:	d9c00717 	ldw	r7,28(sp)
 2004274:	00800c44 	movi	r2,49
 2004278:	38800005 	stb	r2,0(r7)
 200427c:	d8800517 	ldw	r2,20(sp)
 2004280:	3dc00044 	addi	r23,r7,1
 2004284:	10800044 	addi	r2,r2,1
 2004288:	d8800515 	stw	r2,20(sp)
 200428c:	003f3d06 	br	2003f84 <__alt_mem_mem_0+0xfcfe3f84>
 2004290:	d9800517 	ldw	r6,20(sp)
 2004294:	d9c00717 	ldw	r7,28(sp)
 2004298:	00800c44 	movi	r2,49
 200429c:	31800044 	addi	r6,r6,1
 20042a0:	d9800515 	stw	r6,20(sp)
 20042a4:	38800005 	stb	r2,0(r7)
 20042a8:	003edf06 	br	2003e28 <__alt_mem_mem_0+0xfcfe3e28>
 20042ac:	d8000b15 	stw	zero,44(sp)
 20042b0:	003c9f06 	br	2003530 <__alt_mem_mem_0+0xfcfe3530>
 20042b4:	903e7e1e 	bne	r18,zero,2003cb0 <__alt_mem_mem_0+0xfcfe3cb0>
 20042b8:	00800434 	movhi	r2,16
 20042bc:	10bfffc4 	addi	r2,r2,-1
 20042c0:	9884703a 	and	r2,r19,r2
 20042c4:	1000ea1e 	bne	r2,zero,2004670 <_dtoa_r+0x1460>
 20042c8:	9cdffc2c 	andhi	r19,r19,32752
 20042cc:	9800e826 	beq	r19,zero,2004670 <_dtoa_r+0x1460>
 20042d0:	d9c00817 	ldw	r7,32(sp)
 20042d4:	b5800044 	addi	r22,r22,1
 20042d8:	04c00044 	movi	r19,1
 20042dc:	39c00044 	addi	r7,r7,1
 20042e0:	d9c00815 	stw	r7,32(sp)
 20042e4:	d8800d17 	ldw	r2,52(sp)
 20042e8:	103e721e 	bne	r2,zero,2003cb4 <__alt_mem_mem_0+0xfcfe3cb4>
 20042ec:	00800044 	movi	r2,1
 20042f0:	003e7906 	br	2003cd8 <__alt_mem_mem_0+0xfcfe3cd8>
 20042f4:	8009883a 	mov	r4,r16
 20042f8:	200d1e40 	call	200d1e4 <__floatsidf>
 20042fc:	d9800f17 	ldw	r6,60(sp)
 2004300:	d9c01017 	ldw	r7,64(sp)
 2004304:	1009883a 	mov	r4,r2
 2004308:	180b883a 	mov	r5,r3
 200430c:	200c1500 	call	200c150 <__muldf3>
 2004310:	000d883a 	mov	r6,zero
 2004314:	01d00734 	movhi	r7,16412
 2004318:	1009883a 	mov	r4,r2
 200431c:	180b883a 	mov	r5,r3
 2004320:	200ad640 	call	200ad64 <__adddf3>
 2004324:	047f3034 	movhi	r17,64704
 2004328:	1021883a 	mov	r16,r2
 200432c:	1c63883a 	add	r17,r3,r17
 2004330:	d9000f17 	ldw	r4,60(sp)
 2004334:	d9401017 	ldw	r5,64(sp)
 2004338:	000d883a 	mov	r6,zero
 200433c:	01d00534 	movhi	r7,16404
 2004340:	200c8680 	call	200c868 <__subdf3>
 2004344:	800d883a 	mov	r6,r16
 2004348:	880f883a 	mov	r7,r17
 200434c:	1009883a 	mov	r4,r2
 2004350:	180b883a 	mov	r5,r3
 2004354:	102b883a 	mov	r21,r2
 2004358:	1829883a 	mov	r20,r3
 200435c:	200bf800 	call	200bf80 <__gedf2>
 2004360:	00806c16 	blt	zero,r2,2004514 <_dtoa_r+0x1304>
 2004364:	89e0003c 	xorhi	r7,r17,32768
 2004368:	800d883a 	mov	r6,r16
 200436c:	a809883a 	mov	r4,r21
 2004370:	a00b883a 	mov	r5,r20
 2004374:	200c05c0 	call	200c05c <__ledf2>
 2004378:	103d7e0e 	bge	r2,zero,2003974 <__alt_mem_mem_0+0xfcfe3974>
 200437c:	002b883a 	mov	r21,zero
 2004380:	0023883a 	mov	r17,zero
 2004384:	003efb06 	br	2003f74 <__alt_mem_mem_0+0xfcfe3f74>
 2004388:	d8800717 	ldw	r2,28(sp)
 200438c:	003bd006 	br	20032d0 <__alt_mem_mem_0+0xfcfe32d0>
 2004390:	d9000a17 	ldw	r4,40(sp)
 2004394:	d9800d17 	ldw	r6,52(sp)
 2004398:	dd400a15 	stw	r21,40(sp)
 200439c:	a905c83a 	sub	r2,r21,r4
 20043a0:	308d883a 	add	r6,r6,r2
 20043a4:	d9800d15 	stw	r6,52(sp)
 20043a8:	002b883a 	mov	r21,zero
 20043ac:	003e0606 	br	2003bc8 <__alt_mem_mem_0+0xfcfe3bc8>
 20043b0:	9023883a 	mov	r17,r18
 20043b4:	9829883a 	mov	r20,r19
 20043b8:	04000084 	movi	r16,2
 20043bc:	003c9206 	br	2003608 <__alt_mem_mem_0+0xfcfe3608>
 20043c0:	04000044 	movi	r16,1
 20043c4:	dc000c15 	stw	r16,48(sp)
 20043c8:	dc000615 	stw	r16,24(sp)
 20043cc:	dc002215 	stw	r16,136(sp)
 20043d0:	e0001115 	stw	zero,68(fp)
 20043d4:	000b883a 	mov	r5,zero
 20043d8:	003c6906 	br	2003580 <__alt_mem_mem_0+0xfcfe3580>
 20043dc:	3021883a 	mov	r16,r6
 20043e0:	003ffb06 	br	20043d0 <__alt_mem_mem_0+0xfcfe43d0>
 20043e4:	1000021e 	bne	r2,zero,20043f0 <_dtoa_r+0x11e0>
 20043e8:	4200004c 	andi	r8,r8,1
 20043ec:	403e7d1e 	bne	r8,zero,2003de4 <__alt_mem_mem_0+0xfcfe3de4>
 20043f0:	01000c04 	movi	r4,48
 20043f4:	00000106 	br	20043fc <_dtoa_r+0x11ec>
 20043f8:	102f883a 	mov	r23,r2
 20043fc:	b8bfffc4 	addi	r2,r23,-1
 2004400:	10c00007 	ldb	r3,0(r2)
 2004404:	193ffc26 	beq	r3,r4,20043f8 <__alt_mem_mem_0+0xfcfe43f8>
 2004408:	003e8706 	br	2003e28 <__alt_mem_mem_0+0xfcfe3e28>
 200440c:	d8800517 	ldw	r2,20(sp)
 2004410:	00a3c83a 	sub	r17,zero,r2
 2004414:	8800a426 	beq	r17,zero,20046a8 <_dtoa_r+0x1498>
 2004418:	888003cc 	andi	r2,r17,15
 200441c:	100490fa 	slli	r2,r2,3
 2004420:	00c08134 	movhi	r3,516
 2004424:	18c3fd04 	addi	r3,r3,4084
 2004428:	1885883a 	add	r2,r3,r2
 200442c:	11800017 	ldw	r6,0(r2)
 2004430:	11c00117 	ldw	r7,4(r2)
 2004434:	9009883a 	mov	r4,r18
 2004438:	980b883a 	mov	r5,r19
 200443c:	8823d13a 	srai	r17,r17,4
 2004440:	200c1500 	call	200c150 <__muldf3>
 2004444:	d8800f15 	stw	r2,60(sp)
 2004448:	d8c01015 	stw	r3,64(sp)
 200444c:	8800e826 	beq	r17,zero,20047f0 <_dtoa_r+0x15e0>
 2004450:	05008134 	movhi	r20,516
 2004454:	a503f304 	addi	r20,r20,4044
 2004458:	04000084 	movi	r16,2
 200445c:	8980004c 	andi	r6,r17,1
 2004460:	1009883a 	mov	r4,r2
 2004464:	8823d07a 	srai	r17,r17,1
 2004468:	180b883a 	mov	r5,r3
 200446c:	30000426 	beq	r6,zero,2004480 <_dtoa_r+0x1270>
 2004470:	a1800017 	ldw	r6,0(r20)
 2004474:	a1c00117 	ldw	r7,4(r20)
 2004478:	84000044 	addi	r16,r16,1
 200447c:	200c1500 	call	200c150 <__muldf3>
 2004480:	a5000204 	addi	r20,r20,8
 2004484:	883ff51e 	bne	r17,zero,200445c <__alt_mem_mem_0+0xfcfe445c>
 2004488:	d8800f15 	stw	r2,60(sp)
 200448c:	d8c01015 	stw	r3,64(sp)
 2004490:	003c7606 	br	200366c <__alt_mem_mem_0+0xfcfe366c>
 2004494:	00c00c04 	movi	r3,48
 2004498:	10c00005 	stb	r3,0(r2)
 200449c:	d8c00517 	ldw	r3,20(sp)
 20044a0:	bd3fffc3 	ldbu	r20,-1(r23)
 20044a4:	18c00044 	addi	r3,r3,1
 20044a8:	d8c00515 	stw	r3,20(sp)
 20044ac:	003db906 	br	2003b94 <__alt_mem_mem_0+0xfcfe3b94>
 20044b0:	89400117 	ldw	r5,4(r17)
 20044b4:	e009883a 	mov	r4,fp
 20044b8:	20062940 	call	2006294 <_Balloc>
 20044bc:	89800417 	ldw	r6,16(r17)
 20044c0:	89400304 	addi	r5,r17,12
 20044c4:	11000304 	addi	r4,r2,12
 20044c8:	31800084 	addi	r6,r6,2
 20044cc:	318d883a 	add	r6,r6,r6
 20044d0:	318d883a 	add	r6,r6,r6
 20044d4:	1027883a 	mov	r19,r2
 20044d8:	20060240 	call	2006024 <memcpy>
 20044dc:	01800044 	movi	r6,1
 20044e0:	980b883a 	mov	r5,r19
 20044e4:	e009883a 	mov	r4,fp
 20044e8:	2006a140 	call	2006a14 <__lshift>
 20044ec:	1029883a 	mov	r20,r2
 20044f0:	003ecc06 	br	2004024 <__alt_mem_mem_0+0xfcfe4024>
 20044f4:	00800e44 	movi	r2,57
 20044f8:	90809026 	beq	r18,r2,200473c <_dtoa_r+0x152c>
 20044fc:	92000044 	addi	r8,r18,1
 2004500:	003f1f06 	br	2004180 <__alt_mem_mem_0+0xfcfe4180>
 2004504:	9011883a 	mov	r8,r18
 2004508:	8825883a 	mov	r18,r17
 200450c:	a023883a 	mov	r17,r20
 2004510:	003e2906 	br	2003db8 <__alt_mem_mem_0+0xfcfe3db8>
 2004514:	002b883a 	mov	r21,zero
 2004518:	0023883a 	mov	r17,zero
 200451c:	003f5406 	br	2004270 <__alt_mem_mem_0+0xfcfe4270>
 2004520:	61bfffc4 	addi	r6,r12,-1
 2004524:	300490fa 	slli	r2,r6,3
 2004528:	00c08134 	movhi	r3,516
 200452c:	18c3fd04 	addi	r3,r3,4084
 2004530:	1885883a 	add	r2,r3,r2
 2004534:	11000017 	ldw	r4,0(r2)
 2004538:	11400117 	ldw	r5,4(r2)
 200453c:	d8800717 	ldw	r2,28(sp)
 2004540:	880f883a 	mov	r7,r17
 2004544:	d9801215 	stw	r6,72(sp)
 2004548:	800d883a 	mov	r6,r16
 200454c:	db001615 	stw	r12,88(sp)
 2004550:	15c00044 	addi	r23,r2,1
 2004554:	200c1500 	call	200c150 <__muldf3>
 2004558:	d9401017 	ldw	r5,64(sp)
 200455c:	d9000f17 	ldw	r4,60(sp)
 2004560:	d8c01515 	stw	r3,84(sp)
 2004564:	d8801415 	stw	r2,80(sp)
 2004568:	200d1640 	call	200d164 <__fixdfsi>
 200456c:	1009883a 	mov	r4,r2
 2004570:	1021883a 	mov	r16,r2
 2004574:	200d1e40 	call	200d1e4 <__floatsidf>
 2004578:	d9000f17 	ldw	r4,60(sp)
 200457c:	d9401017 	ldw	r5,64(sp)
 2004580:	100d883a 	mov	r6,r2
 2004584:	180f883a 	mov	r7,r3
 2004588:	200c8680 	call	200c868 <__subdf3>
 200458c:	1829883a 	mov	r20,r3
 2004590:	d8c00717 	ldw	r3,28(sp)
 2004594:	84000c04 	addi	r16,r16,48
 2004598:	1023883a 	mov	r17,r2
 200459c:	1c000005 	stb	r16,0(r3)
 20045a0:	db001617 	ldw	r12,88(sp)
 20045a4:	00800044 	movi	r2,1
 20045a8:	60802226 	beq	r12,r2,2004634 <_dtoa_r+0x1424>
 20045ac:	d9c00717 	ldw	r7,28(sp)
 20045b0:	8805883a 	mov	r2,r17
 20045b4:	b82b883a 	mov	r21,r23
 20045b8:	3b19883a 	add	r12,r7,r12
 20045bc:	6023883a 	mov	r17,r12
 20045c0:	a007883a 	mov	r3,r20
 20045c4:	dc800f15 	stw	r18,60(sp)
 20045c8:	000d883a 	mov	r6,zero
 20045cc:	01d00934 	movhi	r7,16420
 20045d0:	1009883a 	mov	r4,r2
 20045d4:	180b883a 	mov	r5,r3
 20045d8:	200c1500 	call	200c150 <__muldf3>
 20045dc:	180b883a 	mov	r5,r3
 20045e0:	1009883a 	mov	r4,r2
 20045e4:	1829883a 	mov	r20,r3
 20045e8:	1025883a 	mov	r18,r2
 20045ec:	200d1640 	call	200d164 <__fixdfsi>
 20045f0:	1009883a 	mov	r4,r2
 20045f4:	1021883a 	mov	r16,r2
 20045f8:	200d1e40 	call	200d1e4 <__floatsidf>
 20045fc:	100d883a 	mov	r6,r2
 2004600:	180f883a 	mov	r7,r3
 2004604:	9009883a 	mov	r4,r18
 2004608:	a00b883a 	mov	r5,r20
 200460c:	84000c04 	addi	r16,r16,48
 2004610:	200c8680 	call	200c868 <__subdf3>
 2004614:	ad400044 	addi	r21,r21,1
 2004618:	ac3fffc5 	stb	r16,-1(r21)
 200461c:	ac7fea1e 	bne	r21,r17,20045c8 <__alt_mem_mem_0+0xfcfe45c8>
 2004620:	1023883a 	mov	r17,r2
 2004624:	d8801217 	ldw	r2,72(sp)
 2004628:	dc800f17 	ldw	r18,60(sp)
 200462c:	1829883a 	mov	r20,r3
 2004630:	b8af883a 	add	r23,r23,r2
 2004634:	d9001417 	ldw	r4,80(sp)
 2004638:	d9401517 	ldw	r5,84(sp)
 200463c:	000d883a 	mov	r6,zero
 2004640:	01cff834 	movhi	r7,16352
 2004644:	200ad640 	call	200ad64 <__adddf3>
 2004648:	880d883a 	mov	r6,r17
 200464c:	a00f883a 	mov	r7,r20
 2004650:	1009883a 	mov	r4,r2
 2004654:	180b883a 	mov	r5,r3
 2004658:	200c05c0 	call	200c05c <__ledf2>
 200465c:	10003e0e 	bge	r2,zero,2004758 <_dtoa_r+0x1548>
 2004660:	d9001317 	ldw	r4,76(sp)
 2004664:	bd3fffc3 	ldbu	r20,-1(r23)
 2004668:	d9000515 	stw	r4,20(sp)
 200466c:	003d3b06 	br	2003b5c <__alt_mem_mem_0+0xfcfe3b5c>
 2004670:	0027883a 	mov	r19,zero
 2004674:	003f1b06 	br	20042e4 <__alt_mem_mem_0+0xfcfe42e4>
 2004678:	d8800817 	ldw	r2,32(sp)
 200467c:	11e9c83a 	sub	r20,r2,r7
 2004680:	0005883a 	mov	r2,zero
 2004684:	003d5406 	br	2003bd8 <__alt_mem_mem_0+0xfcfe3bd8>
 2004688:	00800044 	movi	r2,1
 200468c:	003dc706 	br	2003dac <__alt_mem_mem_0+0xfcfe3dac>
 2004690:	d8c00217 	ldw	r3,8(sp)
 2004694:	00800d84 	movi	r2,54
 2004698:	dd400a17 	ldw	r21,40(sp)
 200469c:	10c5c83a 	sub	r2,r2,r3
 20046a0:	dd000817 	ldw	r20,32(sp)
 20046a4:	003d4c06 	br	2003bd8 <__alt_mem_mem_0+0xfcfe3bd8>
 20046a8:	dc800f15 	stw	r18,60(sp)
 20046ac:	dcc01015 	stw	r19,64(sp)
 20046b0:	04000084 	movi	r16,2
 20046b4:	003bed06 	br	200366c <__alt_mem_mem_0+0xfcfe366c>
 20046b8:	d9000617 	ldw	r4,24(sp)
 20046bc:	203f0d26 	beq	r4,zero,20042f4 <__alt_mem_mem_0+0xfcfe42f4>
 20046c0:	d9800c17 	ldw	r6,48(sp)
 20046c4:	01bcab0e 	bge	zero,r6,2003974 <__alt_mem_mem_0+0xfcfe3974>
 20046c8:	d9401017 	ldw	r5,64(sp)
 20046cc:	d9000f17 	ldw	r4,60(sp)
 20046d0:	000d883a 	mov	r6,zero
 20046d4:	01d00934 	movhi	r7,16420
 20046d8:	200c1500 	call	200c150 <__muldf3>
 20046dc:	81000044 	addi	r4,r16,1
 20046e0:	d8800f15 	stw	r2,60(sp)
 20046e4:	d8c01015 	stw	r3,64(sp)
 20046e8:	200d1e40 	call	200d1e4 <__floatsidf>
 20046ec:	d9800f17 	ldw	r6,60(sp)
 20046f0:	d9c01017 	ldw	r7,64(sp)
 20046f4:	1009883a 	mov	r4,r2
 20046f8:	180b883a 	mov	r5,r3
 20046fc:	200c1500 	call	200c150 <__muldf3>
 2004700:	01d00734 	movhi	r7,16412
 2004704:	000d883a 	mov	r6,zero
 2004708:	1009883a 	mov	r4,r2
 200470c:	180b883a 	mov	r5,r3
 2004710:	200ad640 	call	200ad64 <__adddf3>
 2004714:	d9c00517 	ldw	r7,20(sp)
 2004718:	047f3034 	movhi	r17,64704
 200471c:	1021883a 	mov	r16,r2
 2004720:	39ffffc4 	addi	r7,r7,-1
 2004724:	d9c01315 	stw	r7,76(sp)
 2004728:	1c63883a 	add	r17,r3,r17
 200472c:	db000c17 	ldw	r12,48(sp)
 2004730:	003bea06 	br	20036dc <__alt_mem_mem_0+0xfcfe36dc>
 2004734:	dc000915 	stw	r16,36(sp)
 2004738:	003e0e06 	br	2003f74 <__alt_mem_mem_0+0xfcfe3f74>
 200473c:	01000e44 	movi	r4,57
 2004740:	8825883a 	mov	r18,r17
 2004744:	9dc00044 	addi	r23,r19,1
 2004748:	99000005 	stb	r4,0(r19)
 200474c:	a023883a 	mov	r17,r20
 2004750:	dc000915 	stw	r16,36(sp)
 2004754:	003da406 	br	2003de8 <__alt_mem_mem_0+0xfcfe3de8>
 2004758:	d9801417 	ldw	r6,80(sp)
 200475c:	d9c01517 	ldw	r7,84(sp)
 2004760:	0009883a 	mov	r4,zero
 2004764:	014ff834 	movhi	r5,16352
 2004768:	200c8680 	call	200c868 <__subdf3>
 200476c:	880d883a 	mov	r6,r17
 2004770:	a00f883a 	mov	r7,r20
 2004774:	1009883a 	mov	r4,r2
 2004778:	180b883a 	mov	r5,r3
 200477c:	200bf800 	call	200bf80 <__gedf2>
 2004780:	00bc7c0e 	bge	zero,r2,2003974 <__alt_mem_mem_0+0xfcfe3974>
 2004784:	01000c04 	movi	r4,48
 2004788:	00000106 	br	2004790 <_dtoa_r+0x1580>
 200478c:	102f883a 	mov	r23,r2
 2004790:	b8bfffc4 	addi	r2,r23,-1
 2004794:	10c00007 	ldb	r3,0(r2)
 2004798:	193ffc26 	beq	r3,r4,200478c <__alt_mem_mem_0+0xfcfe478c>
 200479c:	d9801317 	ldw	r6,76(sp)
 20047a0:	d9800515 	stw	r6,20(sp)
 20047a4:	003c4406 	br	20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 20047a8:	d9801317 	ldw	r6,76(sp)
 20047ac:	d9800515 	stw	r6,20(sp)
 20047b0:	003cea06 	br	2003b5c <__alt_mem_mem_0+0xfcfe3b5c>
 20047b4:	dd800f17 	ldw	r22,60(sp)
 20047b8:	dcc01017 	ldw	r19,64(sp)
 20047bc:	dc801217 	ldw	r18,72(sp)
 20047c0:	003c6c06 	br	2003974 <__alt_mem_mem_0+0xfcfe3974>
 20047c4:	903e031e 	bne	r18,zero,2003fd4 <__alt_mem_mem_0+0xfcfe3fd4>
 20047c8:	003ebb06 	br	20042b8 <__alt_mem_mem_0+0xfcfe42b8>
 20047cc:	103e6c1e 	bne	r2,zero,2004180 <__alt_mem_mem_0+0xfcfe4180>
 20047d0:	4080004c 	andi	r2,r8,1
 20047d4:	103e6a26 	beq	r2,zero,2004180 <__alt_mem_mem_0+0xfcfe4180>
 20047d8:	003e6606 	br	2004174 <__alt_mem_mem_0+0xfcfe4174>
 20047dc:	d8c00317 	ldw	r3,12(sp)
 20047e0:	00800084 	movi	r2,2
 20047e4:	10c02916 	blt	r2,r3,200488c <_dtoa_r+0x167c>
 20047e8:	d9000c17 	ldw	r4,48(sp)
 20047ec:	003e8806 	br	2004210 <__alt_mem_mem_0+0xfcfe4210>
 20047f0:	04000084 	movi	r16,2
 20047f4:	003b9d06 	br	200366c <__alt_mem_mem_0+0xfcfe366c>
 20047f8:	d9001317 	ldw	r4,76(sp)
 20047fc:	d9000515 	stw	r4,20(sp)
 2004800:	003cd606 	br	2003b5c <__alt_mem_mem_0+0xfcfe3b5c>
 2004804:	d8801317 	ldw	r2,76(sp)
 2004808:	d8800515 	stw	r2,20(sp)
 200480c:	003c2a06 	br	20038b8 <__alt_mem_mem_0+0xfcfe38b8>
 2004810:	d9800317 	ldw	r6,12(sp)
 2004814:	00800084 	movi	r2,2
 2004818:	11801516 	blt	r2,r6,2004870 <_dtoa_r+0x1660>
 200481c:	d9c00c17 	ldw	r7,48(sp)
 2004820:	d9c00615 	stw	r7,24(sp)
 2004824:	003df706 	br	2004004 <__alt_mem_mem_0+0xfcfe4004>
 2004828:	193d3926 	beq	r3,r4,2003d10 <__alt_mem_mem_0+0xfcfe3d10>
 200482c:	00c00f04 	movi	r3,60
 2004830:	1885c83a 	sub	r2,r3,r2
 2004834:	003ddf06 	br	2003fb4 <__alt_mem_mem_0+0xfcfe3fb4>
 2004838:	e009883a 	mov	r4,fp
 200483c:	e0001115 	stw	zero,68(fp)
 2004840:	000b883a 	mov	r5,zero
 2004844:	20062940 	call	2006294 <_Balloc>
 2004848:	d8800715 	stw	r2,28(sp)
 200484c:	d8c00717 	ldw	r3,28(sp)
 2004850:	00bfffc4 	movi	r2,-1
 2004854:	01000044 	movi	r4,1
 2004858:	d8800c15 	stw	r2,48(sp)
 200485c:	e0c01015 	stw	r3,64(fp)
 2004860:	d9000b15 	stw	r4,44(sp)
 2004864:	d8800615 	stw	r2,24(sp)
 2004868:	d8002215 	stw	zero,136(sp)
 200486c:	003c4106 	br	2003974 <__alt_mem_mem_0+0xfcfe3974>
 2004870:	d8c00c17 	ldw	r3,48(sp)
 2004874:	d8c00615 	stw	r3,24(sp)
 2004878:	003e7006 	br	200423c <__alt_mem_mem_0+0xfcfe423c>
 200487c:	04400044 	movi	r17,1
 2004880:	003b2006 	br	2003504 <__alt_mem_mem_0+0xfcfe3504>
 2004884:	000b883a 	mov	r5,zero
 2004888:	003b3d06 	br	2003580 <__alt_mem_mem_0+0xfcfe3580>
 200488c:	d8800c17 	ldw	r2,48(sp)
 2004890:	d8800615 	stw	r2,24(sp)
 2004894:	003e6906 	br	200423c <__alt_mem_mem_0+0xfcfe423c>

02004898 <__sflush_r>:
 2004898:	2880030b 	ldhu	r2,12(r5)
 200489c:	defffb04 	addi	sp,sp,-20
 20048a0:	dcc00315 	stw	r19,12(sp)
 20048a4:	dc400115 	stw	r17,4(sp)
 20048a8:	dfc00415 	stw	ra,16(sp)
 20048ac:	dc800215 	stw	r18,8(sp)
 20048b0:	dc000015 	stw	r16,0(sp)
 20048b4:	10c0020c 	andi	r3,r2,8
 20048b8:	2823883a 	mov	r17,r5
 20048bc:	2027883a 	mov	r19,r4
 20048c0:	1800311e 	bne	r3,zero,2004988 <__sflush_r+0xf0>
 20048c4:	28c00117 	ldw	r3,4(r5)
 20048c8:	10820014 	ori	r2,r2,2048
 20048cc:	2880030d 	sth	r2,12(r5)
 20048d0:	00c04b0e 	bge	zero,r3,2004a00 <__sflush_r+0x168>
 20048d4:	8a000a17 	ldw	r8,40(r17)
 20048d8:	40002326 	beq	r8,zero,2004968 <__sflush_r+0xd0>
 20048dc:	9c000017 	ldw	r16,0(r19)
 20048e0:	10c4000c 	andi	r3,r2,4096
 20048e4:	98000015 	stw	zero,0(r19)
 20048e8:	18004826 	beq	r3,zero,2004a0c <__sflush_r+0x174>
 20048ec:	89801417 	ldw	r6,80(r17)
 20048f0:	10c0010c 	andi	r3,r2,4
 20048f4:	18000626 	beq	r3,zero,2004910 <__sflush_r+0x78>
 20048f8:	88c00117 	ldw	r3,4(r17)
 20048fc:	88800c17 	ldw	r2,48(r17)
 2004900:	30cdc83a 	sub	r6,r6,r3
 2004904:	10000226 	beq	r2,zero,2004910 <__sflush_r+0x78>
 2004908:	88800f17 	ldw	r2,60(r17)
 200490c:	308dc83a 	sub	r6,r6,r2
 2004910:	89400717 	ldw	r5,28(r17)
 2004914:	000f883a 	mov	r7,zero
 2004918:	9809883a 	mov	r4,r19
 200491c:	403ee83a 	callr	r8
 2004920:	00ffffc4 	movi	r3,-1
 2004924:	10c04426 	beq	r2,r3,2004a38 <__sflush_r+0x1a0>
 2004928:	88c0030b 	ldhu	r3,12(r17)
 200492c:	89000417 	ldw	r4,16(r17)
 2004930:	88000115 	stw	zero,4(r17)
 2004934:	197dffcc 	andi	r5,r3,63487
 2004938:	8940030d 	sth	r5,12(r17)
 200493c:	89000015 	stw	r4,0(r17)
 2004940:	18c4000c 	andi	r3,r3,4096
 2004944:	18002c1e 	bne	r3,zero,20049f8 <__sflush_r+0x160>
 2004948:	89400c17 	ldw	r5,48(r17)
 200494c:	9c000015 	stw	r16,0(r19)
 2004950:	28000526 	beq	r5,zero,2004968 <__sflush_r+0xd0>
 2004954:	88801004 	addi	r2,r17,64
 2004958:	28800226 	beq	r5,r2,2004964 <__sflush_r+0xcc>
 200495c:	9809883a 	mov	r4,r19
 2004960:	20050040 	call	2005004 <_free_r>
 2004964:	88000c15 	stw	zero,48(r17)
 2004968:	0005883a 	mov	r2,zero
 200496c:	dfc00417 	ldw	ra,16(sp)
 2004970:	dcc00317 	ldw	r19,12(sp)
 2004974:	dc800217 	ldw	r18,8(sp)
 2004978:	dc400117 	ldw	r17,4(sp)
 200497c:	dc000017 	ldw	r16,0(sp)
 2004980:	dec00504 	addi	sp,sp,20
 2004984:	f800283a 	ret
 2004988:	2c800417 	ldw	r18,16(r5)
 200498c:	903ff626 	beq	r18,zero,2004968 <__alt_mem_mem_0+0xfcfe4968>
 2004990:	2c000017 	ldw	r16,0(r5)
 2004994:	108000cc 	andi	r2,r2,3
 2004998:	2c800015 	stw	r18,0(r5)
 200499c:	84a1c83a 	sub	r16,r16,r18
 20049a0:	1000131e 	bne	r2,zero,20049f0 <__sflush_r+0x158>
 20049a4:	28800517 	ldw	r2,20(r5)
 20049a8:	88800215 	stw	r2,8(r17)
 20049ac:	04000316 	blt	zero,r16,20049bc <__sflush_r+0x124>
 20049b0:	003fed06 	br	2004968 <__alt_mem_mem_0+0xfcfe4968>
 20049b4:	90a5883a 	add	r18,r18,r2
 20049b8:	043feb0e 	bge	zero,r16,2004968 <__alt_mem_mem_0+0xfcfe4968>
 20049bc:	88800917 	ldw	r2,36(r17)
 20049c0:	89400717 	ldw	r5,28(r17)
 20049c4:	800f883a 	mov	r7,r16
 20049c8:	900d883a 	mov	r6,r18
 20049cc:	9809883a 	mov	r4,r19
 20049d0:	103ee83a 	callr	r2
 20049d4:	80a1c83a 	sub	r16,r16,r2
 20049d8:	00bff616 	blt	zero,r2,20049b4 <__alt_mem_mem_0+0xfcfe49b4>
 20049dc:	88c0030b 	ldhu	r3,12(r17)
 20049e0:	00bfffc4 	movi	r2,-1
 20049e4:	18c01014 	ori	r3,r3,64
 20049e8:	88c0030d 	sth	r3,12(r17)
 20049ec:	003fdf06 	br	200496c <__alt_mem_mem_0+0xfcfe496c>
 20049f0:	0005883a 	mov	r2,zero
 20049f4:	003fec06 	br	20049a8 <__alt_mem_mem_0+0xfcfe49a8>
 20049f8:	88801415 	stw	r2,80(r17)
 20049fc:	003fd206 	br	2004948 <__alt_mem_mem_0+0xfcfe4948>
 2004a00:	28c00f17 	ldw	r3,60(r5)
 2004a04:	00ffb316 	blt	zero,r3,20048d4 <__alt_mem_mem_0+0xfcfe48d4>
 2004a08:	003fd706 	br	2004968 <__alt_mem_mem_0+0xfcfe4968>
 2004a0c:	89400717 	ldw	r5,28(r17)
 2004a10:	000d883a 	mov	r6,zero
 2004a14:	01c00044 	movi	r7,1
 2004a18:	9809883a 	mov	r4,r19
 2004a1c:	403ee83a 	callr	r8
 2004a20:	100d883a 	mov	r6,r2
 2004a24:	00bfffc4 	movi	r2,-1
 2004a28:	30801426 	beq	r6,r2,2004a7c <__sflush_r+0x1e4>
 2004a2c:	8880030b 	ldhu	r2,12(r17)
 2004a30:	8a000a17 	ldw	r8,40(r17)
 2004a34:	003fae06 	br	20048f0 <__alt_mem_mem_0+0xfcfe48f0>
 2004a38:	98c00017 	ldw	r3,0(r19)
 2004a3c:	183fba26 	beq	r3,zero,2004928 <__alt_mem_mem_0+0xfcfe4928>
 2004a40:	01000744 	movi	r4,29
 2004a44:	19000626 	beq	r3,r4,2004a60 <__sflush_r+0x1c8>
 2004a48:	01000584 	movi	r4,22
 2004a4c:	19000426 	beq	r3,r4,2004a60 <__sflush_r+0x1c8>
 2004a50:	88c0030b 	ldhu	r3,12(r17)
 2004a54:	18c01014 	ori	r3,r3,64
 2004a58:	88c0030d 	sth	r3,12(r17)
 2004a5c:	003fc306 	br	200496c <__alt_mem_mem_0+0xfcfe496c>
 2004a60:	8880030b 	ldhu	r2,12(r17)
 2004a64:	88c00417 	ldw	r3,16(r17)
 2004a68:	88000115 	stw	zero,4(r17)
 2004a6c:	10bdffcc 	andi	r2,r2,63487
 2004a70:	8880030d 	sth	r2,12(r17)
 2004a74:	88c00015 	stw	r3,0(r17)
 2004a78:	003fb306 	br	2004948 <__alt_mem_mem_0+0xfcfe4948>
 2004a7c:	98800017 	ldw	r2,0(r19)
 2004a80:	103fea26 	beq	r2,zero,2004a2c <__alt_mem_mem_0+0xfcfe4a2c>
 2004a84:	00c00744 	movi	r3,29
 2004a88:	10c00226 	beq	r2,r3,2004a94 <__sflush_r+0x1fc>
 2004a8c:	00c00584 	movi	r3,22
 2004a90:	10c0031e 	bne	r2,r3,2004aa0 <__sflush_r+0x208>
 2004a94:	9c000015 	stw	r16,0(r19)
 2004a98:	0005883a 	mov	r2,zero
 2004a9c:	003fb306 	br	200496c <__alt_mem_mem_0+0xfcfe496c>
 2004aa0:	88c0030b 	ldhu	r3,12(r17)
 2004aa4:	3005883a 	mov	r2,r6
 2004aa8:	18c01014 	ori	r3,r3,64
 2004aac:	88c0030d 	sth	r3,12(r17)
 2004ab0:	003fae06 	br	200496c <__alt_mem_mem_0+0xfcfe496c>

02004ab4 <_fflush_r>:
 2004ab4:	defffd04 	addi	sp,sp,-12
 2004ab8:	dc000115 	stw	r16,4(sp)
 2004abc:	dfc00215 	stw	ra,8(sp)
 2004ac0:	2021883a 	mov	r16,r4
 2004ac4:	20000226 	beq	r4,zero,2004ad0 <_fflush_r+0x1c>
 2004ac8:	20800e17 	ldw	r2,56(r4)
 2004acc:	10000c26 	beq	r2,zero,2004b00 <_fflush_r+0x4c>
 2004ad0:	2880030f 	ldh	r2,12(r5)
 2004ad4:	1000051e 	bne	r2,zero,2004aec <_fflush_r+0x38>
 2004ad8:	0005883a 	mov	r2,zero
 2004adc:	dfc00217 	ldw	ra,8(sp)
 2004ae0:	dc000117 	ldw	r16,4(sp)
 2004ae4:	dec00304 	addi	sp,sp,12
 2004ae8:	f800283a 	ret
 2004aec:	8009883a 	mov	r4,r16
 2004af0:	dfc00217 	ldw	ra,8(sp)
 2004af4:	dc000117 	ldw	r16,4(sp)
 2004af8:	dec00304 	addi	sp,sp,12
 2004afc:	20048981 	jmpi	2004898 <__sflush_r>
 2004b00:	d9400015 	stw	r5,0(sp)
 2004b04:	2004e900 	call	2004e90 <__sinit>
 2004b08:	d9400017 	ldw	r5,0(sp)
 2004b0c:	003ff006 	br	2004ad0 <__alt_mem_mem_0+0xfcfe4ad0>

02004b10 <fflush>:
 2004b10:	20000526 	beq	r4,zero,2004b28 <fflush+0x18>
 2004b14:	00808134 	movhi	r2,516
 2004b18:	10963d04 	addi	r2,r2,22772
 2004b1c:	200b883a 	mov	r5,r4
 2004b20:	11000017 	ldw	r4,0(r2)
 2004b24:	2004ab41 	jmpi	2004ab4 <_fflush_r>
 2004b28:	00808134 	movhi	r2,516
 2004b2c:	10963c04 	addi	r2,r2,22768
 2004b30:	11000017 	ldw	r4,0(r2)
 2004b34:	01408034 	movhi	r5,512
 2004b38:	2952ad04 	addi	r5,r5,19124
 2004b3c:	20053d81 	jmpi	20053d8 <_fwalk_reent>

02004b40 <__fp_unlock>:
 2004b40:	0005883a 	mov	r2,zero
 2004b44:	f800283a 	ret

02004b48 <_cleanup_r>:
 2004b48:	01408074 	movhi	r5,513
 2004b4c:	29637204 	addi	r5,r5,-29240
 2004b50:	20053d81 	jmpi	20053d8 <_fwalk_reent>

02004b54 <__sinit.part.1>:
 2004b54:	defff704 	addi	sp,sp,-36
 2004b58:	00c08034 	movhi	r3,512
 2004b5c:	dfc00815 	stw	ra,32(sp)
 2004b60:	ddc00715 	stw	r23,28(sp)
 2004b64:	dd800615 	stw	r22,24(sp)
 2004b68:	dd400515 	stw	r21,20(sp)
 2004b6c:	dd000415 	stw	r20,16(sp)
 2004b70:	dcc00315 	stw	r19,12(sp)
 2004b74:	dc800215 	stw	r18,8(sp)
 2004b78:	dc400115 	stw	r17,4(sp)
 2004b7c:	dc000015 	stw	r16,0(sp)
 2004b80:	18d2d204 	addi	r3,r3,19272
 2004b84:	24000117 	ldw	r16,4(r4)
 2004b88:	20c00f15 	stw	r3,60(r4)
 2004b8c:	2080bb04 	addi	r2,r4,748
 2004b90:	00c000c4 	movi	r3,3
 2004b94:	20c0b915 	stw	r3,740(r4)
 2004b98:	2080ba15 	stw	r2,744(r4)
 2004b9c:	2000b815 	stw	zero,736(r4)
 2004ba0:	05c00204 	movi	r23,8
 2004ba4:	00800104 	movi	r2,4
 2004ba8:	2025883a 	mov	r18,r4
 2004bac:	b80d883a 	mov	r6,r23
 2004bb0:	81001704 	addi	r4,r16,92
 2004bb4:	000b883a 	mov	r5,zero
 2004bb8:	80000015 	stw	zero,0(r16)
 2004bbc:	80000115 	stw	zero,4(r16)
 2004bc0:	80000215 	stw	zero,8(r16)
 2004bc4:	8080030d 	sth	r2,12(r16)
 2004bc8:	80001915 	stw	zero,100(r16)
 2004bcc:	8000038d 	sth	zero,14(r16)
 2004bd0:	80000415 	stw	zero,16(r16)
 2004bd4:	80000515 	stw	zero,20(r16)
 2004bd8:	80000615 	stw	zero,24(r16)
 2004bdc:	200616c0 	call	200616c <memset>
 2004be0:	05808034 	movhi	r22,512
 2004be4:	94400217 	ldw	r17,8(r18)
 2004be8:	05408034 	movhi	r21,512
 2004bec:	05008034 	movhi	r20,512
 2004bf0:	04c08034 	movhi	r19,512
 2004bf4:	b59cd604 	addi	r22,r22,29528
 2004bf8:	ad5ced04 	addi	r21,r21,29620
 2004bfc:	a51d0c04 	addi	r20,r20,29744
 2004c00:	9cdd2304 	addi	r19,r19,29836
 2004c04:	85800815 	stw	r22,32(r16)
 2004c08:	85400915 	stw	r21,36(r16)
 2004c0c:	85000a15 	stw	r20,40(r16)
 2004c10:	84c00b15 	stw	r19,44(r16)
 2004c14:	84000715 	stw	r16,28(r16)
 2004c18:	00800284 	movi	r2,10
 2004c1c:	8880030d 	sth	r2,12(r17)
 2004c20:	00800044 	movi	r2,1
 2004c24:	b80d883a 	mov	r6,r23
 2004c28:	89001704 	addi	r4,r17,92
 2004c2c:	000b883a 	mov	r5,zero
 2004c30:	88000015 	stw	zero,0(r17)
 2004c34:	88000115 	stw	zero,4(r17)
 2004c38:	88000215 	stw	zero,8(r17)
 2004c3c:	88001915 	stw	zero,100(r17)
 2004c40:	8880038d 	sth	r2,14(r17)
 2004c44:	88000415 	stw	zero,16(r17)
 2004c48:	88000515 	stw	zero,20(r17)
 2004c4c:	88000615 	stw	zero,24(r17)
 2004c50:	200616c0 	call	200616c <memset>
 2004c54:	94000317 	ldw	r16,12(r18)
 2004c58:	00800484 	movi	r2,18
 2004c5c:	8c400715 	stw	r17,28(r17)
 2004c60:	8d800815 	stw	r22,32(r17)
 2004c64:	8d400915 	stw	r21,36(r17)
 2004c68:	8d000a15 	stw	r20,40(r17)
 2004c6c:	8cc00b15 	stw	r19,44(r17)
 2004c70:	8080030d 	sth	r2,12(r16)
 2004c74:	00800084 	movi	r2,2
 2004c78:	80000015 	stw	zero,0(r16)
 2004c7c:	80000115 	stw	zero,4(r16)
 2004c80:	80000215 	stw	zero,8(r16)
 2004c84:	80001915 	stw	zero,100(r16)
 2004c88:	8080038d 	sth	r2,14(r16)
 2004c8c:	80000415 	stw	zero,16(r16)
 2004c90:	80000515 	stw	zero,20(r16)
 2004c94:	80000615 	stw	zero,24(r16)
 2004c98:	b80d883a 	mov	r6,r23
 2004c9c:	000b883a 	mov	r5,zero
 2004ca0:	81001704 	addi	r4,r16,92
 2004ca4:	200616c0 	call	200616c <memset>
 2004ca8:	00800044 	movi	r2,1
 2004cac:	84000715 	stw	r16,28(r16)
 2004cb0:	85800815 	stw	r22,32(r16)
 2004cb4:	85400915 	stw	r21,36(r16)
 2004cb8:	85000a15 	stw	r20,40(r16)
 2004cbc:	84c00b15 	stw	r19,44(r16)
 2004cc0:	90800e15 	stw	r2,56(r18)
 2004cc4:	dfc00817 	ldw	ra,32(sp)
 2004cc8:	ddc00717 	ldw	r23,28(sp)
 2004ccc:	dd800617 	ldw	r22,24(sp)
 2004cd0:	dd400517 	ldw	r21,20(sp)
 2004cd4:	dd000417 	ldw	r20,16(sp)
 2004cd8:	dcc00317 	ldw	r19,12(sp)
 2004cdc:	dc800217 	ldw	r18,8(sp)
 2004ce0:	dc400117 	ldw	r17,4(sp)
 2004ce4:	dc000017 	ldw	r16,0(sp)
 2004ce8:	dec00904 	addi	sp,sp,36
 2004cec:	f800283a 	ret

02004cf0 <__fp_lock>:
 2004cf0:	0005883a 	mov	r2,zero
 2004cf4:	f800283a 	ret

02004cf8 <__sfmoreglue>:
 2004cf8:	defffc04 	addi	sp,sp,-16
 2004cfc:	dc400115 	stw	r17,4(sp)
 2004d00:	2c7fffc4 	addi	r17,r5,-1
 2004d04:	8c401a24 	muli	r17,r17,104
 2004d08:	dc800215 	stw	r18,8(sp)
 2004d0c:	2825883a 	mov	r18,r5
 2004d10:	89401d04 	addi	r5,r17,116
 2004d14:	dc000015 	stw	r16,0(sp)
 2004d18:	dfc00315 	stw	ra,12(sp)
 2004d1c:	20057340 	call	2005734 <_malloc_r>
 2004d20:	1021883a 	mov	r16,r2
 2004d24:	10000726 	beq	r2,zero,2004d44 <__sfmoreglue+0x4c>
 2004d28:	11000304 	addi	r4,r2,12
 2004d2c:	10000015 	stw	zero,0(r2)
 2004d30:	14800115 	stw	r18,4(r2)
 2004d34:	11000215 	stw	r4,8(r2)
 2004d38:	89801a04 	addi	r6,r17,104
 2004d3c:	000b883a 	mov	r5,zero
 2004d40:	200616c0 	call	200616c <memset>
 2004d44:	8005883a 	mov	r2,r16
 2004d48:	dfc00317 	ldw	ra,12(sp)
 2004d4c:	dc800217 	ldw	r18,8(sp)
 2004d50:	dc400117 	ldw	r17,4(sp)
 2004d54:	dc000017 	ldw	r16,0(sp)
 2004d58:	dec00404 	addi	sp,sp,16
 2004d5c:	f800283a 	ret

02004d60 <__sfp>:
 2004d60:	defffb04 	addi	sp,sp,-20
 2004d64:	dc000015 	stw	r16,0(sp)
 2004d68:	04008134 	movhi	r16,516
 2004d6c:	84163c04 	addi	r16,r16,22768
 2004d70:	dcc00315 	stw	r19,12(sp)
 2004d74:	2027883a 	mov	r19,r4
 2004d78:	81000017 	ldw	r4,0(r16)
 2004d7c:	dfc00415 	stw	ra,16(sp)
 2004d80:	dc800215 	stw	r18,8(sp)
 2004d84:	20800e17 	ldw	r2,56(r4)
 2004d88:	dc400115 	stw	r17,4(sp)
 2004d8c:	1000021e 	bne	r2,zero,2004d98 <__sfp+0x38>
 2004d90:	2004b540 	call	2004b54 <__sinit.part.1>
 2004d94:	81000017 	ldw	r4,0(r16)
 2004d98:	2480b804 	addi	r18,r4,736
 2004d9c:	047fffc4 	movi	r17,-1
 2004da0:	91000117 	ldw	r4,4(r18)
 2004da4:	94000217 	ldw	r16,8(r18)
 2004da8:	213fffc4 	addi	r4,r4,-1
 2004dac:	20000a16 	blt	r4,zero,2004dd8 <__sfp+0x78>
 2004db0:	8080030f 	ldh	r2,12(r16)
 2004db4:	10000c26 	beq	r2,zero,2004de8 <__sfp+0x88>
 2004db8:	80c01d04 	addi	r3,r16,116
 2004dbc:	00000206 	br	2004dc8 <__sfp+0x68>
 2004dc0:	18bfe60f 	ldh	r2,-104(r3)
 2004dc4:	10000826 	beq	r2,zero,2004de8 <__sfp+0x88>
 2004dc8:	213fffc4 	addi	r4,r4,-1
 2004dcc:	1c3ffd04 	addi	r16,r3,-12
 2004dd0:	18c01a04 	addi	r3,r3,104
 2004dd4:	247ffa1e 	bne	r4,r17,2004dc0 <__alt_mem_mem_0+0xfcfe4dc0>
 2004dd8:	90800017 	ldw	r2,0(r18)
 2004ddc:	10001d26 	beq	r2,zero,2004e54 <__sfp+0xf4>
 2004de0:	1025883a 	mov	r18,r2
 2004de4:	003fee06 	br	2004da0 <__alt_mem_mem_0+0xfcfe4da0>
 2004de8:	00bfffc4 	movi	r2,-1
 2004dec:	8080038d 	sth	r2,14(r16)
 2004df0:	00800044 	movi	r2,1
 2004df4:	8080030d 	sth	r2,12(r16)
 2004df8:	80001915 	stw	zero,100(r16)
 2004dfc:	80000015 	stw	zero,0(r16)
 2004e00:	80000215 	stw	zero,8(r16)
 2004e04:	80000115 	stw	zero,4(r16)
 2004e08:	80000415 	stw	zero,16(r16)
 2004e0c:	80000515 	stw	zero,20(r16)
 2004e10:	80000615 	stw	zero,24(r16)
 2004e14:	01800204 	movi	r6,8
 2004e18:	000b883a 	mov	r5,zero
 2004e1c:	81001704 	addi	r4,r16,92
 2004e20:	200616c0 	call	200616c <memset>
 2004e24:	8005883a 	mov	r2,r16
 2004e28:	80000c15 	stw	zero,48(r16)
 2004e2c:	80000d15 	stw	zero,52(r16)
 2004e30:	80001115 	stw	zero,68(r16)
 2004e34:	80001215 	stw	zero,72(r16)
 2004e38:	dfc00417 	ldw	ra,16(sp)
 2004e3c:	dcc00317 	ldw	r19,12(sp)
 2004e40:	dc800217 	ldw	r18,8(sp)
 2004e44:	dc400117 	ldw	r17,4(sp)
 2004e48:	dc000017 	ldw	r16,0(sp)
 2004e4c:	dec00504 	addi	sp,sp,20
 2004e50:	f800283a 	ret
 2004e54:	01400104 	movi	r5,4
 2004e58:	9809883a 	mov	r4,r19
 2004e5c:	2004cf80 	call	2004cf8 <__sfmoreglue>
 2004e60:	90800015 	stw	r2,0(r18)
 2004e64:	103fde1e 	bne	r2,zero,2004de0 <__alt_mem_mem_0+0xfcfe4de0>
 2004e68:	00800304 	movi	r2,12
 2004e6c:	98800015 	stw	r2,0(r19)
 2004e70:	0005883a 	mov	r2,zero
 2004e74:	003ff006 	br	2004e38 <__alt_mem_mem_0+0xfcfe4e38>

02004e78 <_cleanup>:
 2004e78:	00808134 	movhi	r2,516
 2004e7c:	10963c04 	addi	r2,r2,22768
 2004e80:	11000017 	ldw	r4,0(r2)
 2004e84:	01408074 	movhi	r5,513
 2004e88:	29637204 	addi	r5,r5,-29240
 2004e8c:	20053d81 	jmpi	20053d8 <_fwalk_reent>

02004e90 <__sinit>:
 2004e90:	20800e17 	ldw	r2,56(r4)
 2004e94:	10000126 	beq	r2,zero,2004e9c <__sinit+0xc>
 2004e98:	f800283a 	ret
 2004e9c:	2004b541 	jmpi	2004b54 <__sinit.part.1>

02004ea0 <__sfp_lock_acquire>:
 2004ea0:	f800283a 	ret

02004ea4 <__sfp_lock_release>:
 2004ea4:	f800283a 	ret

02004ea8 <__sinit_lock_acquire>:
 2004ea8:	f800283a 	ret

02004eac <__sinit_lock_release>:
 2004eac:	f800283a 	ret

02004eb0 <__fp_lock_all>:
 2004eb0:	00808134 	movhi	r2,516
 2004eb4:	10963d04 	addi	r2,r2,22772
 2004eb8:	11000017 	ldw	r4,0(r2)
 2004ebc:	01408034 	movhi	r5,512
 2004ec0:	29533c04 	addi	r5,r5,19696
 2004ec4:	20053141 	jmpi	2005314 <_fwalk>

02004ec8 <__fp_unlock_all>:
 2004ec8:	00808134 	movhi	r2,516
 2004ecc:	10963d04 	addi	r2,r2,22772
 2004ed0:	11000017 	ldw	r4,0(r2)
 2004ed4:	01408034 	movhi	r5,512
 2004ed8:	2952d004 	addi	r5,r5,19264
 2004edc:	20053141 	jmpi	2005314 <_fwalk>

02004ee0 <_malloc_trim_r>:
 2004ee0:	defffb04 	addi	sp,sp,-20
 2004ee4:	dcc00315 	stw	r19,12(sp)
 2004ee8:	04c08134 	movhi	r19,516
 2004eec:	dc800215 	stw	r18,8(sp)
 2004ef0:	dc400115 	stw	r17,4(sp)
 2004ef4:	dc000015 	stw	r16,0(sp)
 2004ef8:	dfc00415 	stw	ra,16(sp)
 2004efc:	2821883a 	mov	r16,r5
 2004f00:	9ccfdb04 	addi	r19,r19,16236
 2004f04:	2025883a 	mov	r18,r4
 2004f08:	200d4e40 	call	200d4e4 <__malloc_lock>
 2004f0c:	98800217 	ldw	r2,8(r19)
 2004f10:	14400117 	ldw	r17,4(r2)
 2004f14:	00bfff04 	movi	r2,-4
 2004f18:	88a2703a 	and	r17,r17,r2
 2004f1c:	8c21c83a 	sub	r16,r17,r16
 2004f20:	8403fbc4 	addi	r16,r16,4079
 2004f24:	8020d33a 	srli	r16,r16,12
 2004f28:	0083ffc4 	movi	r2,4095
 2004f2c:	843fffc4 	addi	r16,r16,-1
 2004f30:	8020933a 	slli	r16,r16,12
 2004f34:	1400060e 	bge	r2,r16,2004f50 <_malloc_trim_r+0x70>
 2004f38:	000b883a 	mov	r5,zero
 2004f3c:	9009883a 	mov	r4,r18
 2004f40:	20073040 	call	2007304 <_sbrk_r>
 2004f44:	98c00217 	ldw	r3,8(r19)
 2004f48:	1c47883a 	add	r3,r3,r17
 2004f4c:	10c00a26 	beq	r2,r3,2004f78 <_malloc_trim_r+0x98>
 2004f50:	9009883a 	mov	r4,r18
 2004f54:	200d5440 	call	200d544 <__malloc_unlock>
 2004f58:	0005883a 	mov	r2,zero
 2004f5c:	dfc00417 	ldw	ra,16(sp)
 2004f60:	dcc00317 	ldw	r19,12(sp)
 2004f64:	dc800217 	ldw	r18,8(sp)
 2004f68:	dc400117 	ldw	r17,4(sp)
 2004f6c:	dc000017 	ldw	r16,0(sp)
 2004f70:	dec00504 	addi	sp,sp,20
 2004f74:	f800283a 	ret
 2004f78:	040bc83a 	sub	r5,zero,r16
 2004f7c:	9009883a 	mov	r4,r18
 2004f80:	20073040 	call	2007304 <_sbrk_r>
 2004f84:	00ffffc4 	movi	r3,-1
 2004f88:	10c00d26 	beq	r2,r3,2004fc0 <_malloc_trim_r+0xe0>
 2004f8c:	00c08134 	movhi	r3,516
 2004f90:	18de5d04 	addi	r3,r3,31092
 2004f94:	18800017 	ldw	r2,0(r3)
 2004f98:	99000217 	ldw	r4,8(r19)
 2004f9c:	8c23c83a 	sub	r17,r17,r16
 2004fa0:	8c400054 	ori	r17,r17,1
 2004fa4:	1421c83a 	sub	r16,r2,r16
 2004fa8:	24400115 	stw	r17,4(r4)
 2004fac:	9009883a 	mov	r4,r18
 2004fb0:	1c000015 	stw	r16,0(r3)
 2004fb4:	200d5440 	call	200d544 <__malloc_unlock>
 2004fb8:	00800044 	movi	r2,1
 2004fbc:	003fe706 	br	2004f5c <__alt_mem_mem_0+0xfcfe4f5c>
 2004fc0:	000b883a 	mov	r5,zero
 2004fc4:	9009883a 	mov	r4,r18
 2004fc8:	20073040 	call	2007304 <_sbrk_r>
 2004fcc:	99000217 	ldw	r4,8(r19)
 2004fd0:	014003c4 	movi	r5,15
 2004fd4:	1107c83a 	sub	r3,r2,r4
 2004fd8:	28ffdd0e 	bge	r5,r3,2004f50 <__alt_mem_mem_0+0xfcfe4f50>
 2004fdc:	01408134 	movhi	r5,516
 2004fe0:	29563f04 	addi	r5,r5,22780
 2004fe4:	29400017 	ldw	r5,0(r5)
 2004fe8:	18c00054 	ori	r3,r3,1
 2004fec:	20c00115 	stw	r3,4(r4)
 2004ff0:	00c08134 	movhi	r3,516
 2004ff4:	1145c83a 	sub	r2,r2,r5
 2004ff8:	18de5d04 	addi	r3,r3,31092
 2004ffc:	18800015 	stw	r2,0(r3)
 2005000:	003fd306 	br	2004f50 <__alt_mem_mem_0+0xfcfe4f50>

02005004 <_free_r>:
 2005004:	28004126 	beq	r5,zero,200510c <_free_r+0x108>
 2005008:	defffd04 	addi	sp,sp,-12
 200500c:	dc400115 	stw	r17,4(sp)
 2005010:	dc000015 	stw	r16,0(sp)
 2005014:	2023883a 	mov	r17,r4
 2005018:	2821883a 	mov	r16,r5
 200501c:	dfc00215 	stw	ra,8(sp)
 2005020:	200d4e40 	call	200d4e4 <__malloc_lock>
 2005024:	81ffff17 	ldw	r7,-4(r16)
 2005028:	00bfff84 	movi	r2,-2
 200502c:	01008134 	movhi	r4,516
 2005030:	81bffe04 	addi	r6,r16,-8
 2005034:	3884703a 	and	r2,r7,r2
 2005038:	210fdb04 	addi	r4,r4,16236
 200503c:	308b883a 	add	r5,r6,r2
 2005040:	2a400117 	ldw	r9,4(r5)
 2005044:	22000217 	ldw	r8,8(r4)
 2005048:	00ffff04 	movi	r3,-4
 200504c:	48c6703a 	and	r3,r9,r3
 2005050:	2a005726 	beq	r5,r8,20051b0 <_free_r+0x1ac>
 2005054:	28c00115 	stw	r3,4(r5)
 2005058:	39c0004c 	andi	r7,r7,1
 200505c:	3800091e 	bne	r7,zero,2005084 <_free_r+0x80>
 2005060:	823ffe17 	ldw	r8,-8(r16)
 2005064:	22400204 	addi	r9,r4,8
 2005068:	320dc83a 	sub	r6,r6,r8
 200506c:	31c00217 	ldw	r7,8(r6)
 2005070:	1205883a 	add	r2,r2,r8
 2005074:	3a406526 	beq	r7,r9,200520c <_free_r+0x208>
 2005078:	32000317 	ldw	r8,12(r6)
 200507c:	3a000315 	stw	r8,12(r7)
 2005080:	41c00215 	stw	r7,8(r8)
 2005084:	28cf883a 	add	r7,r5,r3
 2005088:	39c00117 	ldw	r7,4(r7)
 200508c:	39c0004c 	andi	r7,r7,1
 2005090:	38003a26 	beq	r7,zero,200517c <_free_r+0x178>
 2005094:	10c00054 	ori	r3,r2,1
 2005098:	30c00115 	stw	r3,4(r6)
 200509c:	3087883a 	add	r3,r6,r2
 20050a0:	18800015 	stw	r2,0(r3)
 20050a4:	00c07fc4 	movi	r3,511
 20050a8:	18801936 	bltu	r3,r2,2005110 <_free_r+0x10c>
 20050ac:	1004d0fa 	srli	r2,r2,3
 20050b0:	01c00044 	movi	r7,1
 20050b4:	21400117 	ldw	r5,4(r4)
 20050b8:	10c00044 	addi	r3,r2,1
 20050bc:	18c7883a 	add	r3,r3,r3
 20050c0:	1005d0ba 	srai	r2,r2,2
 20050c4:	18c7883a 	add	r3,r3,r3
 20050c8:	18c7883a 	add	r3,r3,r3
 20050cc:	1907883a 	add	r3,r3,r4
 20050d0:	3884983a 	sll	r2,r7,r2
 20050d4:	19c00017 	ldw	r7,0(r3)
 20050d8:	1a3ffe04 	addi	r8,r3,-8
 20050dc:	1144b03a 	or	r2,r2,r5
 20050e0:	32000315 	stw	r8,12(r6)
 20050e4:	31c00215 	stw	r7,8(r6)
 20050e8:	20800115 	stw	r2,4(r4)
 20050ec:	19800015 	stw	r6,0(r3)
 20050f0:	39800315 	stw	r6,12(r7)
 20050f4:	8809883a 	mov	r4,r17
 20050f8:	dfc00217 	ldw	ra,8(sp)
 20050fc:	dc400117 	ldw	r17,4(sp)
 2005100:	dc000017 	ldw	r16,0(sp)
 2005104:	dec00304 	addi	sp,sp,12
 2005108:	200d5441 	jmpi	200d544 <__malloc_unlock>
 200510c:	f800283a 	ret
 2005110:	100ad27a 	srli	r5,r2,9
 2005114:	00c00104 	movi	r3,4
 2005118:	19404a36 	bltu	r3,r5,2005244 <_free_r+0x240>
 200511c:	100ad1ba 	srli	r5,r2,6
 2005120:	28c00e44 	addi	r3,r5,57
 2005124:	18c7883a 	add	r3,r3,r3
 2005128:	29400e04 	addi	r5,r5,56
 200512c:	18c7883a 	add	r3,r3,r3
 2005130:	18c7883a 	add	r3,r3,r3
 2005134:	1909883a 	add	r4,r3,r4
 2005138:	20c00017 	ldw	r3,0(r4)
 200513c:	01c08134 	movhi	r7,516
 2005140:	213ffe04 	addi	r4,r4,-8
 2005144:	39cfdb04 	addi	r7,r7,16236
 2005148:	20c04426 	beq	r4,r3,200525c <_free_r+0x258>
 200514c:	01ffff04 	movi	r7,-4
 2005150:	19400117 	ldw	r5,4(r3)
 2005154:	29ca703a 	and	r5,r5,r7
 2005158:	1140022e 	bgeu	r2,r5,2005164 <_free_r+0x160>
 200515c:	18c00217 	ldw	r3,8(r3)
 2005160:	20fffb1e 	bne	r4,r3,2005150 <__alt_mem_mem_0+0xfcfe5150>
 2005164:	19000317 	ldw	r4,12(r3)
 2005168:	31000315 	stw	r4,12(r6)
 200516c:	30c00215 	stw	r3,8(r6)
 2005170:	21800215 	stw	r6,8(r4)
 2005174:	19800315 	stw	r6,12(r3)
 2005178:	003fde06 	br	20050f4 <__alt_mem_mem_0+0xfcfe50f4>
 200517c:	29c00217 	ldw	r7,8(r5)
 2005180:	10c5883a 	add	r2,r2,r3
 2005184:	00c08134 	movhi	r3,516
 2005188:	18cfdd04 	addi	r3,r3,16244
 200518c:	38c03b26 	beq	r7,r3,200527c <_free_r+0x278>
 2005190:	2a000317 	ldw	r8,12(r5)
 2005194:	11400054 	ori	r5,r2,1
 2005198:	3087883a 	add	r3,r6,r2
 200519c:	3a000315 	stw	r8,12(r7)
 20051a0:	41c00215 	stw	r7,8(r8)
 20051a4:	31400115 	stw	r5,4(r6)
 20051a8:	18800015 	stw	r2,0(r3)
 20051ac:	003fbd06 	br	20050a4 <__alt_mem_mem_0+0xfcfe50a4>
 20051b0:	39c0004c 	andi	r7,r7,1
 20051b4:	10c5883a 	add	r2,r2,r3
 20051b8:	3800071e 	bne	r7,zero,20051d8 <_free_r+0x1d4>
 20051bc:	81fffe17 	ldw	r7,-8(r16)
 20051c0:	31cdc83a 	sub	r6,r6,r7
 20051c4:	30c00317 	ldw	r3,12(r6)
 20051c8:	31400217 	ldw	r5,8(r6)
 20051cc:	11c5883a 	add	r2,r2,r7
 20051d0:	28c00315 	stw	r3,12(r5)
 20051d4:	19400215 	stw	r5,8(r3)
 20051d8:	10c00054 	ori	r3,r2,1
 20051dc:	30c00115 	stw	r3,4(r6)
 20051e0:	00c08134 	movhi	r3,516
 20051e4:	18d64004 	addi	r3,r3,22784
 20051e8:	18c00017 	ldw	r3,0(r3)
 20051ec:	21800215 	stw	r6,8(r4)
 20051f0:	10ffc036 	bltu	r2,r3,20050f4 <__alt_mem_mem_0+0xfcfe50f4>
 20051f4:	00808134 	movhi	r2,516
 20051f8:	109e0904 	addi	r2,r2,30756
 20051fc:	11400017 	ldw	r5,0(r2)
 2005200:	8809883a 	mov	r4,r17
 2005204:	2004ee00 	call	2004ee0 <_malloc_trim_r>
 2005208:	003fba06 	br	20050f4 <__alt_mem_mem_0+0xfcfe50f4>
 200520c:	28c9883a 	add	r4,r5,r3
 2005210:	21000117 	ldw	r4,4(r4)
 2005214:	2100004c 	andi	r4,r4,1
 2005218:	2000391e 	bne	r4,zero,2005300 <_free_r+0x2fc>
 200521c:	29c00217 	ldw	r7,8(r5)
 2005220:	29000317 	ldw	r4,12(r5)
 2005224:	1885883a 	add	r2,r3,r2
 2005228:	10c00054 	ori	r3,r2,1
 200522c:	39000315 	stw	r4,12(r7)
 2005230:	21c00215 	stw	r7,8(r4)
 2005234:	30c00115 	stw	r3,4(r6)
 2005238:	308d883a 	add	r6,r6,r2
 200523c:	30800015 	stw	r2,0(r6)
 2005240:	003fac06 	br	20050f4 <__alt_mem_mem_0+0xfcfe50f4>
 2005244:	00c00504 	movi	r3,20
 2005248:	19401536 	bltu	r3,r5,20052a0 <_free_r+0x29c>
 200524c:	28c01704 	addi	r3,r5,92
 2005250:	18c7883a 	add	r3,r3,r3
 2005254:	294016c4 	addi	r5,r5,91
 2005258:	003fb406 	br	200512c <__alt_mem_mem_0+0xfcfe512c>
 200525c:	280bd0ba 	srai	r5,r5,2
 2005260:	00c00044 	movi	r3,1
 2005264:	38800117 	ldw	r2,4(r7)
 2005268:	194a983a 	sll	r5,r3,r5
 200526c:	2007883a 	mov	r3,r4
 2005270:	2884b03a 	or	r2,r5,r2
 2005274:	38800115 	stw	r2,4(r7)
 2005278:	003fbb06 	br	2005168 <__alt_mem_mem_0+0xfcfe5168>
 200527c:	21800515 	stw	r6,20(r4)
 2005280:	21800415 	stw	r6,16(r4)
 2005284:	10c00054 	ori	r3,r2,1
 2005288:	31c00315 	stw	r7,12(r6)
 200528c:	31c00215 	stw	r7,8(r6)
 2005290:	30c00115 	stw	r3,4(r6)
 2005294:	308d883a 	add	r6,r6,r2
 2005298:	30800015 	stw	r2,0(r6)
 200529c:	003f9506 	br	20050f4 <__alt_mem_mem_0+0xfcfe50f4>
 20052a0:	00c01504 	movi	r3,84
 20052a4:	19400536 	bltu	r3,r5,20052bc <_free_r+0x2b8>
 20052a8:	100ad33a 	srli	r5,r2,12
 20052ac:	28c01bc4 	addi	r3,r5,111
 20052b0:	18c7883a 	add	r3,r3,r3
 20052b4:	29401b84 	addi	r5,r5,110
 20052b8:	003f9c06 	br	200512c <__alt_mem_mem_0+0xfcfe512c>
 20052bc:	00c05504 	movi	r3,340
 20052c0:	19400536 	bltu	r3,r5,20052d8 <_free_r+0x2d4>
 20052c4:	100ad3fa 	srli	r5,r2,15
 20052c8:	28c01e04 	addi	r3,r5,120
 20052cc:	18c7883a 	add	r3,r3,r3
 20052d0:	29401dc4 	addi	r5,r5,119
 20052d4:	003f9506 	br	200512c <__alt_mem_mem_0+0xfcfe512c>
 20052d8:	00c15504 	movi	r3,1364
 20052dc:	19400536 	bltu	r3,r5,20052f4 <_free_r+0x2f0>
 20052e0:	100ad4ba 	srli	r5,r2,18
 20052e4:	28c01f44 	addi	r3,r5,125
 20052e8:	18c7883a 	add	r3,r3,r3
 20052ec:	29401f04 	addi	r5,r5,124
 20052f0:	003f8e06 	br	200512c <__alt_mem_mem_0+0xfcfe512c>
 20052f4:	00c03f84 	movi	r3,254
 20052f8:	01401f84 	movi	r5,126
 20052fc:	003f8b06 	br	200512c <__alt_mem_mem_0+0xfcfe512c>
 2005300:	10c00054 	ori	r3,r2,1
 2005304:	30c00115 	stw	r3,4(r6)
 2005308:	308d883a 	add	r6,r6,r2
 200530c:	30800015 	stw	r2,0(r6)
 2005310:	003f7806 	br	20050f4 <__alt_mem_mem_0+0xfcfe50f4>

02005314 <_fwalk>:
 2005314:	defff704 	addi	sp,sp,-36
 2005318:	dd000415 	stw	r20,16(sp)
 200531c:	dfc00815 	stw	ra,32(sp)
 2005320:	ddc00715 	stw	r23,28(sp)
 2005324:	dd800615 	stw	r22,24(sp)
 2005328:	dd400515 	stw	r21,20(sp)
 200532c:	dcc00315 	stw	r19,12(sp)
 2005330:	dc800215 	stw	r18,8(sp)
 2005334:	dc400115 	stw	r17,4(sp)
 2005338:	dc000015 	stw	r16,0(sp)
 200533c:	2500b804 	addi	r20,r4,736
 2005340:	a0002326 	beq	r20,zero,20053d0 <_fwalk+0xbc>
 2005344:	282b883a 	mov	r21,r5
 2005348:	002f883a 	mov	r23,zero
 200534c:	05800044 	movi	r22,1
 2005350:	04ffffc4 	movi	r19,-1
 2005354:	a4400117 	ldw	r17,4(r20)
 2005358:	a4800217 	ldw	r18,8(r20)
 200535c:	8c7fffc4 	addi	r17,r17,-1
 2005360:	88000d16 	blt	r17,zero,2005398 <_fwalk+0x84>
 2005364:	94000304 	addi	r16,r18,12
 2005368:	94800384 	addi	r18,r18,14
 200536c:	8080000b 	ldhu	r2,0(r16)
 2005370:	8c7fffc4 	addi	r17,r17,-1
 2005374:	813ffd04 	addi	r4,r16,-12
 2005378:	b080042e 	bgeu	r22,r2,200538c <_fwalk+0x78>
 200537c:	9080000f 	ldh	r2,0(r18)
 2005380:	14c00226 	beq	r2,r19,200538c <_fwalk+0x78>
 2005384:	a83ee83a 	callr	r21
 2005388:	b8aeb03a 	or	r23,r23,r2
 200538c:	84001a04 	addi	r16,r16,104
 2005390:	94801a04 	addi	r18,r18,104
 2005394:	8cfff51e 	bne	r17,r19,200536c <__alt_mem_mem_0+0xfcfe536c>
 2005398:	a5000017 	ldw	r20,0(r20)
 200539c:	a03fed1e 	bne	r20,zero,2005354 <__alt_mem_mem_0+0xfcfe5354>
 20053a0:	b805883a 	mov	r2,r23
 20053a4:	dfc00817 	ldw	ra,32(sp)
 20053a8:	ddc00717 	ldw	r23,28(sp)
 20053ac:	dd800617 	ldw	r22,24(sp)
 20053b0:	dd400517 	ldw	r21,20(sp)
 20053b4:	dd000417 	ldw	r20,16(sp)
 20053b8:	dcc00317 	ldw	r19,12(sp)
 20053bc:	dc800217 	ldw	r18,8(sp)
 20053c0:	dc400117 	ldw	r17,4(sp)
 20053c4:	dc000017 	ldw	r16,0(sp)
 20053c8:	dec00904 	addi	sp,sp,36
 20053cc:	f800283a 	ret
 20053d0:	002f883a 	mov	r23,zero
 20053d4:	003ff206 	br	20053a0 <__alt_mem_mem_0+0xfcfe53a0>

020053d8 <_fwalk_reent>:
 20053d8:	defff704 	addi	sp,sp,-36
 20053dc:	dd000415 	stw	r20,16(sp)
 20053e0:	dfc00815 	stw	ra,32(sp)
 20053e4:	ddc00715 	stw	r23,28(sp)
 20053e8:	dd800615 	stw	r22,24(sp)
 20053ec:	dd400515 	stw	r21,20(sp)
 20053f0:	dcc00315 	stw	r19,12(sp)
 20053f4:	dc800215 	stw	r18,8(sp)
 20053f8:	dc400115 	stw	r17,4(sp)
 20053fc:	dc000015 	stw	r16,0(sp)
 2005400:	2500b804 	addi	r20,r4,736
 2005404:	a0002326 	beq	r20,zero,2005494 <_fwalk_reent+0xbc>
 2005408:	282b883a 	mov	r21,r5
 200540c:	2027883a 	mov	r19,r4
 2005410:	002f883a 	mov	r23,zero
 2005414:	05800044 	movi	r22,1
 2005418:	04bfffc4 	movi	r18,-1
 200541c:	a4400117 	ldw	r17,4(r20)
 2005420:	a4000217 	ldw	r16,8(r20)
 2005424:	8c7fffc4 	addi	r17,r17,-1
 2005428:	88000c16 	blt	r17,zero,200545c <_fwalk_reent+0x84>
 200542c:	84000304 	addi	r16,r16,12
 2005430:	8080000b 	ldhu	r2,0(r16)
 2005434:	8c7fffc4 	addi	r17,r17,-1
 2005438:	817ffd04 	addi	r5,r16,-12
 200543c:	b080052e 	bgeu	r22,r2,2005454 <_fwalk_reent+0x7c>
 2005440:	8080008f 	ldh	r2,2(r16)
 2005444:	9809883a 	mov	r4,r19
 2005448:	14800226 	beq	r2,r18,2005454 <_fwalk_reent+0x7c>
 200544c:	a83ee83a 	callr	r21
 2005450:	b8aeb03a 	or	r23,r23,r2
 2005454:	84001a04 	addi	r16,r16,104
 2005458:	8cbff51e 	bne	r17,r18,2005430 <__alt_mem_mem_0+0xfcfe5430>
 200545c:	a5000017 	ldw	r20,0(r20)
 2005460:	a03fee1e 	bne	r20,zero,200541c <__alt_mem_mem_0+0xfcfe541c>
 2005464:	b805883a 	mov	r2,r23
 2005468:	dfc00817 	ldw	ra,32(sp)
 200546c:	ddc00717 	ldw	r23,28(sp)
 2005470:	dd800617 	ldw	r22,24(sp)
 2005474:	dd400517 	ldw	r21,20(sp)
 2005478:	dd000417 	ldw	r20,16(sp)
 200547c:	dcc00317 	ldw	r19,12(sp)
 2005480:	dc800217 	ldw	r18,8(sp)
 2005484:	dc400117 	ldw	r17,4(sp)
 2005488:	dc000017 	ldw	r16,0(sp)
 200548c:	dec00904 	addi	sp,sp,36
 2005490:	f800283a 	ret
 2005494:	002f883a 	mov	r23,zero
 2005498:	003ff206 	br	2005464 <__alt_mem_mem_0+0xfcfe5464>

0200549c <_setlocale_r>:
 200549c:	30001b26 	beq	r6,zero,200550c <_setlocale_r+0x70>
 20054a0:	01408134 	movhi	r5,516
 20054a4:	defffe04 	addi	sp,sp,-8
 20054a8:	2943e304 	addi	r5,r5,3980
 20054ac:	3009883a 	mov	r4,r6
 20054b0:	dc000015 	stw	r16,0(sp)
 20054b4:	dfc00115 	stw	ra,4(sp)
 20054b8:	3021883a 	mov	r16,r6
 20054bc:	20074940 	call	2007494 <strcmp>
 20054c0:	1000061e 	bne	r2,zero,20054dc <_setlocale_r+0x40>
 20054c4:	00808134 	movhi	r2,516
 20054c8:	1083e204 	addi	r2,r2,3976
 20054cc:	dfc00117 	ldw	ra,4(sp)
 20054d0:	dc000017 	ldw	r16,0(sp)
 20054d4:	dec00204 	addi	sp,sp,8
 20054d8:	f800283a 	ret
 20054dc:	01408134 	movhi	r5,516
 20054e0:	2943e204 	addi	r5,r5,3976
 20054e4:	8009883a 	mov	r4,r16
 20054e8:	20074940 	call	2007494 <strcmp>
 20054ec:	103ff526 	beq	r2,zero,20054c4 <__alt_mem_mem_0+0xfcfe54c4>
 20054f0:	01408134 	movhi	r5,516
 20054f4:	2943cd04 	addi	r5,r5,3892
 20054f8:	8009883a 	mov	r4,r16
 20054fc:	20074940 	call	2007494 <strcmp>
 2005500:	103ff026 	beq	r2,zero,20054c4 <__alt_mem_mem_0+0xfcfe54c4>
 2005504:	0005883a 	mov	r2,zero
 2005508:	003ff006 	br	20054cc <__alt_mem_mem_0+0xfcfe54cc>
 200550c:	00808134 	movhi	r2,516
 2005510:	1083e204 	addi	r2,r2,3976
 2005514:	f800283a 	ret

02005518 <__locale_charset>:
 2005518:	00808134 	movhi	r2,516
 200551c:	108fc504 	addi	r2,r2,16148
 2005520:	f800283a 	ret

02005524 <__locale_mb_cur_max>:
 2005524:	00808134 	movhi	r2,516
 2005528:	10963e04 	addi	r2,r2,22776
 200552c:	10800017 	ldw	r2,0(r2)
 2005530:	f800283a 	ret

02005534 <__locale_msgcharset>:
 2005534:	00808134 	movhi	r2,516
 2005538:	108fbd04 	addi	r2,r2,16116
 200553c:	f800283a 	ret

02005540 <__locale_cjk_lang>:
 2005540:	0005883a 	mov	r2,zero
 2005544:	f800283a 	ret

02005548 <_localeconv_r>:
 2005548:	00808134 	movhi	r2,516
 200554c:	108fcd04 	addi	r2,r2,16180
 2005550:	f800283a 	ret

02005554 <setlocale>:
 2005554:	00808134 	movhi	r2,516
 2005558:	10963d04 	addi	r2,r2,22772
 200555c:	280d883a 	mov	r6,r5
 2005560:	200b883a 	mov	r5,r4
 2005564:	11000017 	ldw	r4,0(r2)
 2005568:	200549c1 	jmpi	200549c <_setlocale_r>

0200556c <localeconv>:
 200556c:	00808134 	movhi	r2,516
 2005570:	108fcd04 	addi	r2,r2,16180
 2005574:	f800283a 	ret

02005578 <__smakebuf_r>:
 2005578:	2880030b 	ldhu	r2,12(r5)
 200557c:	10c0008c 	andi	r3,r2,2
 2005580:	1800411e 	bne	r3,zero,2005688 <__smakebuf_r+0x110>
 2005584:	deffec04 	addi	sp,sp,-80
 2005588:	dc000f15 	stw	r16,60(sp)
 200558c:	2821883a 	mov	r16,r5
 2005590:	2940038f 	ldh	r5,14(r5)
 2005594:	dc401015 	stw	r17,64(sp)
 2005598:	dfc01315 	stw	ra,76(sp)
 200559c:	dcc01215 	stw	r19,72(sp)
 20055a0:	dc801115 	stw	r18,68(sp)
 20055a4:	2023883a 	mov	r17,r4
 20055a8:	28001c16 	blt	r5,zero,200561c <__smakebuf_r+0xa4>
 20055ac:	d80d883a 	mov	r6,sp
 20055b0:	20090d40 	call	20090d4 <_fstat_r>
 20055b4:	10001816 	blt	r2,zero,2005618 <__smakebuf_r+0xa0>
 20055b8:	d8800117 	ldw	r2,4(sp)
 20055bc:	00e00014 	movui	r3,32768
 20055c0:	10bc000c 	andi	r2,r2,61440
 20055c4:	14c80020 	cmpeqi	r19,r2,8192
 20055c8:	10c03726 	beq	r2,r3,20056a8 <__smakebuf_r+0x130>
 20055cc:	80c0030b 	ldhu	r3,12(r16)
 20055d0:	18c20014 	ori	r3,r3,2048
 20055d4:	80c0030d 	sth	r3,12(r16)
 20055d8:	00c80004 	movi	r3,8192
 20055dc:	10c0521e 	bne	r2,r3,2005728 <__smakebuf_r+0x1b0>
 20055e0:	8140038f 	ldh	r5,14(r16)
 20055e4:	8809883a 	mov	r4,r17
 20055e8:	20095ec0 	call	20095ec <_isatty_r>
 20055ec:	10004c26 	beq	r2,zero,2005720 <__smakebuf_r+0x1a8>
 20055f0:	8080030b 	ldhu	r2,12(r16)
 20055f4:	80c010c4 	addi	r3,r16,67
 20055f8:	80c00015 	stw	r3,0(r16)
 20055fc:	10800054 	ori	r2,r2,1
 2005600:	8080030d 	sth	r2,12(r16)
 2005604:	00800044 	movi	r2,1
 2005608:	80c00415 	stw	r3,16(r16)
 200560c:	80800515 	stw	r2,20(r16)
 2005610:	04810004 	movi	r18,1024
 2005614:	00000706 	br	2005634 <__smakebuf_r+0xbc>
 2005618:	8080030b 	ldhu	r2,12(r16)
 200561c:	10c0200c 	andi	r3,r2,128
 2005620:	18001f1e 	bne	r3,zero,20056a0 <__smakebuf_r+0x128>
 2005624:	04810004 	movi	r18,1024
 2005628:	10820014 	ori	r2,r2,2048
 200562c:	8080030d 	sth	r2,12(r16)
 2005630:	0027883a 	mov	r19,zero
 2005634:	900b883a 	mov	r5,r18
 2005638:	8809883a 	mov	r4,r17
 200563c:	20057340 	call	2005734 <_malloc_r>
 2005640:	10002c26 	beq	r2,zero,20056f4 <__smakebuf_r+0x17c>
 2005644:	80c0030b 	ldhu	r3,12(r16)
 2005648:	01008034 	movhi	r4,512
 200564c:	2112d204 	addi	r4,r4,19272
 2005650:	89000f15 	stw	r4,60(r17)
 2005654:	18c02014 	ori	r3,r3,128
 2005658:	80c0030d 	sth	r3,12(r16)
 200565c:	80800015 	stw	r2,0(r16)
 2005660:	80800415 	stw	r2,16(r16)
 2005664:	84800515 	stw	r18,20(r16)
 2005668:	98001a1e 	bne	r19,zero,20056d4 <__smakebuf_r+0x15c>
 200566c:	dfc01317 	ldw	ra,76(sp)
 2005670:	dcc01217 	ldw	r19,72(sp)
 2005674:	dc801117 	ldw	r18,68(sp)
 2005678:	dc401017 	ldw	r17,64(sp)
 200567c:	dc000f17 	ldw	r16,60(sp)
 2005680:	dec01404 	addi	sp,sp,80
 2005684:	f800283a 	ret
 2005688:	288010c4 	addi	r2,r5,67
 200568c:	28800015 	stw	r2,0(r5)
 2005690:	28800415 	stw	r2,16(r5)
 2005694:	00800044 	movi	r2,1
 2005698:	28800515 	stw	r2,20(r5)
 200569c:	f800283a 	ret
 20056a0:	04801004 	movi	r18,64
 20056a4:	003fe006 	br	2005628 <__alt_mem_mem_0+0xfcfe5628>
 20056a8:	81000a17 	ldw	r4,40(r16)
 20056ac:	00c08034 	movhi	r3,512
 20056b0:	18dd0c04 	addi	r3,r3,29744
 20056b4:	20ffc51e 	bne	r4,r3,20055cc <__alt_mem_mem_0+0xfcfe55cc>
 20056b8:	8080030b 	ldhu	r2,12(r16)
 20056bc:	04810004 	movi	r18,1024
 20056c0:	84801315 	stw	r18,76(r16)
 20056c4:	1484b03a 	or	r2,r2,r18
 20056c8:	8080030d 	sth	r2,12(r16)
 20056cc:	0027883a 	mov	r19,zero
 20056d0:	003fd806 	br	2005634 <__alt_mem_mem_0+0xfcfe5634>
 20056d4:	8140038f 	ldh	r5,14(r16)
 20056d8:	8809883a 	mov	r4,r17
 20056dc:	20095ec0 	call	20095ec <_isatty_r>
 20056e0:	103fe226 	beq	r2,zero,200566c <__alt_mem_mem_0+0xfcfe566c>
 20056e4:	8080030b 	ldhu	r2,12(r16)
 20056e8:	10800054 	ori	r2,r2,1
 20056ec:	8080030d 	sth	r2,12(r16)
 20056f0:	003fde06 	br	200566c <__alt_mem_mem_0+0xfcfe566c>
 20056f4:	8080030b 	ldhu	r2,12(r16)
 20056f8:	10c0800c 	andi	r3,r2,512
 20056fc:	183fdb1e 	bne	r3,zero,200566c <__alt_mem_mem_0+0xfcfe566c>
 2005700:	10800094 	ori	r2,r2,2
 2005704:	80c010c4 	addi	r3,r16,67
 2005708:	8080030d 	sth	r2,12(r16)
 200570c:	00800044 	movi	r2,1
 2005710:	80c00015 	stw	r3,0(r16)
 2005714:	80c00415 	stw	r3,16(r16)
 2005718:	80800515 	stw	r2,20(r16)
 200571c:	003fd306 	br	200566c <__alt_mem_mem_0+0xfcfe566c>
 2005720:	04810004 	movi	r18,1024
 2005724:	003fc306 	br	2005634 <__alt_mem_mem_0+0xfcfe5634>
 2005728:	0027883a 	mov	r19,zero
 200572c:	04810004 	movi	r18,1024
 2005730:	003fc006 	br	2005634 <__alt_mem_mem_0+0xfcfe5634>

02005734 <_malloc_r>:
 2005734:	defff504 	addi	sp,sp,-44
 2005738:	dc800315 	stw	r18,12(sp)
 200573c:	dfc00a15 	stw	ra,40(sp)
 2005740:	df000915 	stw	fp,36(sp)
 2005744:	ddc00815 	stw	r23,32(sp)
 2005748:	dd800715 	stw	r22,28(sp)
 200574c:	dd400615 	stw	r21,24(sp)
 2005750:	dd000515 	stw	r20,20(sp)
 2005754:	dcc00415 	stw	r19,16(sp)
 2005758:	dc400215 	stw	r17,8(sp)
 200575c:	dc000115 	stw	r16,4(sp)
 2005760:	288002c4 	addi	r2,r5,11
 2005764:	00c00584 	movi	r3,22
 2005768:	2025883a 	mov	r18,r4
 200576c:	18807f2e 	bgeu	r3,r2,200596c <_malloc_r+0x238>
 2005770:	047ffe04 	movi	r17,-8
 2005774:	1462703a 	and	r17,r2,r17
 2005778:	8800a316 	blt	r17,zero,2005a08 <_malloc_r+0x2d4>
 200577c:	8940a236 	bltu	r17,r5,2005a08 <_malloc_r+0x2d4>
 2005780:	200d4e40 	call	200d4e4 <__malloc_lock>
 2005784:	00807dc4 	movi	r2,503
 2005788:	1441e92e 	bgeu	r2,r17,2005f30 <_malloc_r+0x7fc>
 200578c:	8804d27a 	srli	r2,r17,9
 2005790:	1000a126 	beq	r2,zero,2005a18 <_malloc_r+0x2e4>
 2005794:	00c00104 	movi	r3,4
 2005798:	18811e36 	bltu	r3,r2,2005c14 <_malloc_r+0x4e0>
 200579c:	8804d1ba 	srli	r2,r17,6
 20057a0:	12000e44 	addi	r8,r2,57
 20057a4:	11c00e04 	addi	r7,r2,56
 20057a8:	4209883a 	add	r4,r8,r8
 20057ac:	04c08134 	movhi	r19,516
 20057b0:	2109883a 	add	r4,r4,r4
 20057b4:	9ccfdb04 	addi	r19,r19,16236
 20057b8:	2109883a 	add	r4,r4,r4
 20057bc:	9909883a 	add	r4,r19,r4
 20057c0:	24000117 	ldw	r16,4(r4)
 20057c4:	213ffe04 	addi	r4,r4,-8
 20057c8:	24009726 	beq	r4,r16,2005a28 <_malloc_r+0x2f4>
 20057cc:	80800117 	ldw	r2,4(r16)
 20057d0:	01bfff04 	movi	r6,-4
 20057d4:	014003c4 	movi	r5,15
 20057d8:	1184703a 	and	r2,r2,r6
 20057dc:	1447c83a 	sub	r3,r2,r17
 20057e0:	28c00716 	blt	r5,r3,2005800 <_malloc_r+0xcc>
 20057e4:	1800920e 	bge	r3,zero,2005a30 <_malloc_r+0x2fc>
 20057e8:	84000317 	ldw	r16,12(r16)
 20057ec:	24008e26 	beq	r4,r16,2005a28 <_malloc_r+0x2f4>
 20057f0:	80800117 	ldw	r2,4(r16)
 20057f4:	1184703a 	and	r2,r2,r6
 20057f8:	1447c83a 	sub	r3,r2,r17
 20057fc:	28fff90e 	bge	r5,r3,20057e4 <__alt_mem_mem_0+0xfcfe57e4>
 2005800:	3809883a 	mov	r4,r7
 2005804:	01808134 	movhi	r6,516
 2005808:	9c000417 	ldw	r16,16(r19)
 200580c:	318fdb04 	addi	r6,r6,16236
 2005810:	32000204 	addi	r8,r6,8
 2005814:	82013426 	beq	r16,r8,2005ce8 <_malloc_r+0x5b4>
 2005818:	80c00117 	ldw	r3,4(r16)
 200581c:	00bfff04 	movi	r2,-4
 2005820:	188e703a 	and	r7,r3,r2
 2005824:	3c45c83a 	sub	r2,r7,r17
 2005828:	00c003c4 	movi	r3,15
 200582c:	18811f16 	blt	r3,r2,2005cac <_malloc_r+0x578>
 2005830:	32000515 	stw	r8,20(r6)
 2005834:	32000415 	stw	r8,16(r6)
 2005838:	10007f0e 	bge	r2,zero,2005a38 <_malloc_r+0x304>
 200583c:	00807fc4 	movi	r2,511
 2005840:	11c0fd36 	bltu	r2,r7,2005c38 <_malloc_r+0x504>
 2005844:	3806d0fa 	srli	r3,r7,3
 2005848:	01c00044 	movi	r7,1
 200584c:	30800117 	ldw	r2,4(r6)
 2005850:	19400044 	addi	r5,r3,1
 2005854:	294b883a 	add	r5,r5,r5
 2005858:	1807d0ba 	srai	r3,r3,2
 200585c:	294b883a 	add	r5,r5,r5
 2005860:	294b883a 	add	r5,r5,r5
 2005864:	298b883a 	add	r5,r5,r6
 2005868:	38c6983a 	sll	r3,r7,r3
 200586c:	29c00017 	ldw	r7,0(r5)
 2005870:	2a7ffe04 	addi	r9,r5,-8
 2005874:	1886b03a 	or	r3,r3,r2
 2005878:	82400315 	stw	r9,12(r16)
 200587c:	81c00215 	stw	r7,8(r16)
 2005880:	30c00115 	stw	r3,4(r6)
 2005884:	2c000015 	stw	r16,0(r5)
 2005888:	3c000315 	stw	r16,12(r7)
 200588c:	2005d0ba 	srai	r2,r4,2
 2005890:	01400044 	movi	r5,1
 2005894:	288a983a 	sll	r5,r5,r2
 2005898:	19406f36 	bltu	r3,r5,2005a58 <_malloc_r+0x324>
 200589c:	28c4703a 	and	r2,r5,r3
 20058a0:	10000a1e 	bne	r2,zero,20058cc <_malloc_r+0x198>
 20058a4:	00bfff04 	movi	r2,-4
 20058a8:	294b883a 	add	r5,r5,r5
 20058ac:	2088703a 	and	r4,r4,r2
 20058b0:	28c4703a 	and	r2,r5,r3
 20058b4:	21000104 	addi	r4,r4,4
 20058b8:	1000041e 	bne	r2,zero,20058cc <_malloc_r+0x198>
 20058bc:	294b883a 	add	r5,r5,r5
 20058c0:	28c4703a 	and	r2,r5,r3
 20058c4:	21000104 	addi	r4,r4,4
 20058c8:	103ffc26 	beq	r2,zero,20058bc <__alt_mem_mem_0+0xfcfe58bc>
 20058cc:	02bfff04 	movi	r10,-4
 20058d0:	024003c4 	movi	r9,15
 20058d4:	21800044 	addi	r6,r4,1
 20058d8:	318d883a 	add	r6,r6,r6
 20058dc:	318d883a 	add	r6,r6,r6
 20058e0:	318d883a 	add	r6,r6,r6
 20058e4:	998d883a 	add	r6,r19,r6
 20058e8:	333ffe04 	addi	r12,r6,-8
 20058ec:	2017883a 	mov	r11,r4
 20058f0:	31800104 	addi	r6,r6,4
 20058f4:	34000017 	ldw	r16,0(r6)
 20058f8:	31fffd04 	addi	r7,r6,-12
 20058fc:	81c0041e 	bne	r16,r7,2005910 <_malloc_r+0x1dc>
 2005900:	0000fb06 	br	2005cf0 <_malloc_r+0x5bc>
 2005904:	1801030e 	bge	r3,zero,2005d14 <_malloc_r+0x5e0>
 2005908:	84000317 	ldw	r16,12(r16)
 200590c:	81c0f826 	beq	r16,r7,2005cf0 <_malloc_r+0x5bc>
 2005910:	80800117 	ldw	r2,4(r16)
 2005914:	1284703a 	and	r2,r2,r10
 2005918:	1447c83a 	sub	r3,r2,r17
 200591c:	48fff90e 	bge	r9,r3,2005904 <__alt_mem_mem_0+0xfcfe5904>
 2005920:	80800317 	ldw	r2,12(r16)
 2005924:	81000217 	ldw	r4,8(r16)
 2005928:	89400054 	ori	r5,r17,1
 200592c:	81400115 	stw	r5,4(r16)
 2005930:	20800315 	stw	r2,12(r4)
 2005934:	11000215 	stw	r4,8(r2)
 2005938:	8463883a 	add	r17,r16,r17
 200593c:	9c400515 	stw	r17,20(r19)
 2005940:	9c400415 	stw	r17,16(r19)
 2005944:	18800054 	ori	r2,r3,1
 2005948:	88800115 	stw	r2,4(r17)
 200594c:	8a000315 	stw	r8,12(r17)
 2005950:	8a000215 	stw	r8,8(r17)
 2005954:	88e3883a 	add	r17,r17,r3
 2005958:	88c00015 	stw	r3,0(r17)
 200595c:	9009883a 	mov	r4,r18
 2005960:	200d5440 	call	200d544 <__malloc_unlock>
 2005964:	80800204 	addi	r2,r16,8
 2005968:	00001b06 	br	20059d8 <_malloc_r+0x2a4>
 200596c:	04400404 	movi	r17,16
 2005970:	89402536 	bltu	r17,r5,2005a08 <_malloc_r+0x2d4>
 2005974:	200d4e40 	call	200d4e4 <__malloc_lock>
 2005978:	00800184 	movi	r2,6
 200597c:	01000084 	movi	r4,2
 2005980:	04c08134 	movhi	r19,516
 2005984:	1085883a 	add	r2,r2,r2
 2005988:	9ccfdb04 	addi	r19,r19,16236
 200598c:	1085883a 	add	r2,r2,r2
 2005990:	9885883a 	add	r2,r19,r2
 2005994:	14000117 	ldw	r16,4(r2)
 2005998:	10fffe04 	addi	r3,r2,-8
 200599c:	80c0d926 	beq	r16,r3,2005d04 <_malloc_r+0x5d0>
 20059a0:	80c00117 	ldw	r3,4(r16)
 20059a4:	81000317 	ldw	r4,12(r16)
 20059a8:	00bfff04 	movi	r2,-4
 20059ac:	1884703a 	and	r2,r3,r2
 20059b0:	81400217 	ldw	r5,8(r16)
 20059b4:	8085883a 	add	r2,r16,r2
 20059b8:	10c00117 	ldw	r3,4(r2)
 20059bc:	29000315 	stw	r4,12(r5)
 20059c0:	21400215 	stw	r5,8(r4)
 20059c4:	18c00054 	ori	r3,r3,1
 20059c8:	10c00115 	stw	r3,4(r2)
 20059cc:	9009883a 	mov	r4,r18
 20059d0:	200d5440 	call	200d544 <__malloc_unlock>
 20059d4:	80800204 	addi	r2,r16,8
 20059d8:	dfc00a17 	ldw	ra,40(sp)
 20059dc:	df000917 	ldw	fp,36(sp)
 20059e0:	ddc00817 	ldw	r23,32(sp)
 20059e4:	dd800717 	ldw	r22,28(sp)
 20059e8:	dd400617 	ldw	r21,24(sp)
 20059ec:	dd000517 	ldw	r20,20(sp)
 20059f0:	dcc00417 	ldw	r19,16(sp)
 20059f4:	dc800317 	ldw	r18,12(sp)
 20059f8:	dc400217 	ldw	r17,8(sp)
 20059fc:	dc000117 	ldw	r16,4(sp)
 2005a00:	dec00b04 	addi	sp,sp,44
 2005a04:	f800283a 	ret
 2005a08:	00800304 	movi	r2,12
 2005a0c:	90800015 	stw	r2,0(r18)
 2005a10:	0005883a 	mov	r2,zero
 2005a14:	003ff006 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005a18:	01002004 	movi	r4,128
 2005a1c:	02001004 	movi	r8,64
 2005a20:	01c00fc4 	movi	r7,63
 2005a24:	003f6106 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005a28:	4009883a 	mov	r4,r8
 2005a2c:	003f7506 	br	2005804 <__alt_mem_mem_0+0xfcfe5804>
 2005a30:	81000317 	ldw	r4,12(r16)
 2005a34:	003fde06 	br	20059b0 <__alt_mem_mem_0+0xfcfe59b0>
 2005a38:	81c5883a 	add	r2,r16,r7
 2005a3c:	11400117 	ldw	r5,4(r2)
 2005a40:	9009883a 	mov	r4,r18
 2005a44:	29400054 	ori	r5,r5,1
 2005a48:	11400115 	stw	r5,4(r2)
 2005a4c:	200d5440 	call	200d544 <__malloc_unlock>
 2005a50:	80800204 	addi	r2,r16,8
 2005a54:	003fe006 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005a58:	9c000217 	ldw	r16,8(r19)
 2005a5c:	00bfff04 	movi	r2,-4
 2005a60:	85800117 	ldw	r22,4(r16)
 2005a64:	b0ac703a 	and	r22,r22,r2
 2005a68:	b4400336 	bltu	r22,r17,2005a78 <_malloc_r+0x344>
 2005a6c:	b445c83a 	sub	r2,r22,r17
 2005a70:	00c003c4 	movi	r3,15
 2005a74:	18805d16 	blt	r3,r2,2005bec <_malloc_r+0x4b8>
 2005a78:	05c08134 	movhi	r23,516
 2005a7c:	00808134 	movhi	r2,516
 2005a80:	109e0904 	addi	r2,r2,30756
 2005a84:	bdd63f04 	addi	r23,r23,22780
 2005a88:	15400017 	ldw	r21,0(r2)
 2005a8c:	b8c00017 	ldw	r3,0(r23)
 2005a90:	00bfffc4 	movi	r2,-1
 2005a94:	858d883a 	add	r6,r16,r22
 2005a98:	8d6b883a 	add	r21,r17,r21
 2005a9c:	1880ea26 	beq	r3,r2,2005e48 <_malloc_r+0x714>
 2005aa0:	ad4403c4 	addi	r21,r21,4111
 2005aa4:	00bc0004 	movi	r2,-4096
 2005aa8:	a8aa703a 	and	r21,r21,r2
 2005aac:	a80b883a 	mov	r5,r21
 2005ab0:	9009883a 	mov	r4,r18
 2005ab4:	d9800015 	stw	r6,0(sp)
 2005ab8:	20073040 	call	2007304 <_sbrk_r>
 2005abc:	1029883a 	mov	r20,r2
 2005ac0:	00bfffc4 	movi	r2,-1
 2005ac4:	d9800017 	ldw	r6,0(sp)
 2005ac8:	a080e826 	beq	r20,r2,2005e6c <_malloc_r+0x738>
 2005acc:	a180a636 	bltu	r20,r6,2005d68 <_malloc_r+0x634>
 2005ad0:	07008134 	movhi	fp,516
 2005ad4:	e71e5d04 	addi	fp,fp,31092
 2005ad8:	e0800017 	ldw	r2,0(fp)
 2005adc:	a887883a 	add	r3,r21,r2
 2005ae0:	e0c00015 	stw	r3,0(fp)
 2005ae4:	3500e626 	beq	r6,r20,2005e80 <_malloc_r+0x74c>
 2005ae8:	b9000017 	ldw	r4,0(r23)
 2005aec:	00bfffc4 	movi	r2,-1
 2005af0:	2080ee26 	beq	r4,r2,2005eac <_malloc_r+0x778>
 2005af4:	a185c83a 	sub	r2,r20,r6
 2005af8:	10c5883a 	add	r2,r2,r3
 2005afc:	e0800015 	stw	r2,0(fp)
 2005b00:	a0c001cc 	andi	r3,r20,7
 2005b04:	1800bc26 	beq	r3,zero,2005df8 <_malloc_r+0x6c4>
 2005b08:	a0e9c83a 	sub	r20,r20,r3
 2005b0c:	00840204 	movi	r2,4104
 2005b10:	a5000204 	addi	r20,r20,8
 2005b14:	10c7c83a 	sub	r3,r2,r3
 2005b18:	a545883a 	add	r2,r20,r21
 2005b1c:	1083ffcc 	andi	r2,r2,4095
 2005b20:	18abc83a 	sub	r21,r3,r2
 2005b24:	a80b883a 	mov	r5,r21
 2005b28:	9009883a 	mov	r4,r18
 2005b2c:	20073040 	call	2007304 <_sbrk_r>
 2005b30:	00ffffc4 	movi	r3,-1
 2005b34:	10c0e126 	beq	r2,r3,2005ebc <_malloc_r+0x788>
 2005b38:	1505c83a 	sub	r2,r2,r20
 2005b3c:	1545883a 	add	r2,r2,r21
 2005b40:	10800054 	ori	r2,r2,1
 2005b44:	e0c00017 	ldw	r3,0(fp)
 2005b48:	9d000215 	stw	r20,8(r19)
 2005b4c:	a0800115 	stw	r2,4(r20)
 2005b50:	a8c7883a 	add	r3,r21,r3
 2005b54:	e0c00015 	stw	r3,0(fp)
 2005b58:	84c00e26 	beq	r16,r19,2005b94 <_malloc_r+0x460>
 2005b5c:	018003c4 	movi	r6,15
 2005b60:	3580a72e 	bgeu	r6,r22,2005e00 <_malloc_r+0x6cc>
 2005b64:	81400117 	ldw	r5,4(r16)
 2005b68:	013ffe04 	movi	r4,-8
 2005b6c:	b0bffd04 	addi	r2,r22,-12
 2005b70:	1104703a 	and	r2,r2,r4
 2005b74:	2900004c 	andi	r4,r5,1
 2005b78:	2088b03a 	or	r4,r4,r2
 2005b7c:	81000115 	stw	r4,4(r16)
 2005b80:	01400144 	movi	r5,5
 2005b84:	8089883a 	add	r4,r16,r2
 2005b88:	21400115 	stw	r5,4(r4)
 2005b8c:	21400215 	stw	r5,8(r4)
 2005b90:	3080cd36 	bltu	r6,r2,2005ec8 <_malloc_r+0x794>
 2005b94:	00808134 	movhi	r2,516
 2005b98:	109e0804 	addi	r2,r2,30752
 2005b9c:	11000017 	ldw	r4,0(r2)
 2005ba0:	20c0012e 	bgeu	r4,r3,2005ba8 <_malloc_r+0x474>
 2005ba4:	10c00015 	stw	r3,0(r2)
 2005ba8:	00808134 	movhi	r2,516
 2005bac:	109e0704 	addi	r2,r2,30748
 2005bb0:	11000017 	ldw	r4,0(r2)
 2005bb4:	9c000217 	ldw	r16,8(r19)
 2005bb8:	20c0012e 	bgeu	r4,r3,2005bc0 <_malloc_r+0x48c>
 2005bbc:	10c00015 	stw	r3,0(r2)
 2005bc0:	80c00117 	ldw	r3,4(r16)
 2005bc4:	00bfff04 	movi	r2,-4
 2005bc8:	1886703a 	and	r3,r3,r2
 2005bcc:	1c45c83a 	sub	r2,r3,r17
 2005bd0:	1c400236 	bltu	r3,r17,2005bdc <_malloc_r+0x4a8>
 2005bd4:	00c003c4 	movi	r3,15
 2005bd8:	18800416 	blt	r3,r2,2005bec <_malloc_r+0x4b8>
 2005bdc:	9009883a 	mov	r4,r18
 2005be0:	200d5440 	call	200d544 <__malloc_unlock>
 2005be4:	0005883a 	mov	r2,zero
 2005be8:	003f7b06 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005bec:	88c00054 	ori	r3,r17,1
 2005bf0:	80c00115 	stw	r3,4(r16)
 2005bf4:	8463883a 	add	r17,r16,r17
 2005bf8:	10800054 	ori	r2,r2,1
 2005bfc:	9c400215 	stw	r17,8(r19)
 2005c00:	88800115 	stw	r2,4(r17)
 2005c04:	9009883a 	mov	r4,r18
 2005c08:	200d5440 	call	200d544 <__malloc_unlock>
 2005c0c:	80800204 	addi	r2,r16,8
 2005c10:	003f7106 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005c14:	00c00504 	movi	r3,20
 2005c18:	18804a2e 	bgeu	r3,r2,2005d44 <_malloc_r+0x610>
 2005c1c:	00c01504 	movi	r3,84
 2005c20:	18806e36 	bltu	r3,r2,2005ddc <_malloc_r+0x6a8>
 2005c24:	8804d33a 	srli	r2,r17,12
 2005c28:	12001bc4 	addi	r8,r2,111
 2005c2c:	11c01b84 	addi	r7,r2,110
 2005c30:	4209883a 	add	r4,r8,r8
 2005c34:	003edd06 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005c38:	3804d27a 	srli	r2,r7,9
 2005c3c:	00c00104 	movi	r3,4
 2005c40:	1880442e 	bgeu	r3,r2,2005d54 <_malloc_r+0x620>
 2005c44:	00c00504 	movi	r3,20
 2005c48:	18808136 	bltu	r3,r2,2005e50 <_malloc_r+0x71c>
 2005c4c:	11401704 	addi	r5,r2,92
 2005c50:	10c016c4 	addi	r3,r2,91
 2005c54:	294b883a 	add	r5,r5,r5
 2005c58:	294b883a 	add	r5,r5,r5
 2005c5c:	294b883a 	add	r5,r5,r5
 2005c60:	994b883a 	add	r5,r19,r5
 2005c64:	28800017 	ldw	r2,0(r5)
 2005c68:	01808134 	movhi	r6,516
 2005c6c:	297ffe04 	addi	r5,r5,-8
 2005c70:	318fdb04 	addi	r6,r6,16236
 2005c74:	28806526 	beq	r5,r2,2005e0c <_malloc_r+0x6d8>
 2005c78:	01bfff04 	movi	r6,-4
 2005c7c:	10c00117 	ldw	r3,4(r2)
 2005c80:	1986703a 	and	r3,r3,r6
 2005c84:	38c0022e 	bgeu	r7,r3,2005c90 <_malloc_r+0x55c>
 2005c88:	10800217 	ldw	r2,8(r2)
 2005c8c:	28bffb1e 	bne	r5,r2,2005c7c <__alt_mem_mem_0+0xfcfe5c7c>
 2005c90:	11400317 	ldw	r5,12(r2)
 2005c94:	98c00117 	ldw	r3,4(r19)
 2005c98:	81400315 	stw	r5,12(r16)
 2005c9c:	80800215 	stw	r2,8(r16)
 2005ca0:	2c000215 	stw	r16,8(r5)
 2005ca4:	14000315 	stw	r16,12(r2)
 2005ca8:	003ef806 	br	200588c <__alt_mem_mem_0+0xfcfe588c>
 2005cac:	88c00054 	ori	r3,r17,1
 2005cb0:	80c00115 	stw	r3,4(r16)
 2005cb4:	8463883a 	add	r17,r16,r17
 2005cb8:	34400515 	stw	r17,20(r6)
 2005cbc:	34400415 	stw	r17,16(r6)
 2005cc0:	10c00054 	ori	r3,r2,1
 2005cc4:	8a000315 	stw	r8,12(r17)
 2005cc8:	8a000215 	stw	r8,8(r17)
 2005ccc:	88c00115 	stw	r3,4(r17)
 2005cd0:	88a3883a 	add	r17,r17,r2
 2005cd4:	88800015 	stw	r2,0(r17)
 2005cd8:	9009883a 	mov	r4,r18
 2005cdc:	200d5440 	call	200d544 <__malloc_unlock>
 2005ce0:	80800204 	addi	r2,r16,8
 2005ce4:	003f3c06 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005ce8:	30c00117 	ldw	r3,4(r6)
 2005cec:	003ee706 	br	200588c <__alt_mem_mem_0+0xfcfe588c>
 2005cf0:	5ac00044 	addi	r11,r11,1
 2005cf4:	588000cc 	andi	r2,r11,3
 2005cf8:	31800204 	addi	r6,r6,8
 2005cfc:	103efd1e 	bne	r2,zero,20058f4 <__alt_mem_mem_0+0xfcfe58f4>
 2005d00:	00002406 	br	2005d94 <_malloc_r+0x660>
 2005d04:	14000317 	ldw	r16,12(r2)
 2005d08:	143f251e 	bne	r2,r16,20059a0 <__alt_mem_mem_0+0xfcfe59a0>
 2005d0c:	21000084 	addi	r4,r4,2
 2005d10:	003ebc06 	br	2005804 <__alt_mem_mem_0+0xfcfe5804>
 2005d14:	8085883a 	add	r2,r16,r2
 2005d18:	10c00117 	ldw	r3,4(r2)
 2005d1c:	81000317 	ldw	r4,12(r16)
 2005d20:	81400217 	ldw	r5,8(r16)
 2005d24:	18c00054 	ori	r3,r3,1
 2005d28:	10c00115 	stw	r3,4(r2)
 2005d2c:	29000315 	stw	r4,12(r5)
 2005d30:	21400215 	stw	r5,8(r4)
 2005d34:	9009883a 	mov	r4,r18
 2005d38:	200d5440 	call	200d544 <__malloc_unlock>
 2005d3c:	80800204 	addi	r2,r16,8
 2005d40:	003f2506 	br	20059d8 <__alt_mem_mem_0+0xfcfe59d8>
 2005d44:	12001704 	addi	r8,r2,92
 2005d48:	11c016c4 	addi	r7,r2,91
 2005d4c:	4209883a 	add	r4,r8,r8
 2005d50:	003e9606 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005d54:	3804d1ba 	srli	r2,r7,6
 2005d58:	11400e44 	addi	r5,r2,57
 2005d5c:	10c00e04 	addi	r3,r2,56
 2005d60:	294b883a 	add	r5,r5,r5
 2005d64:	003fbc06 	br	2005c58 <__alt_mem_mem_0+0xfcfe5c58>
 2005d68:	84ff5926 	beq	r16,r19,2005ad0 <__alt_mem_mem_0+0xfcfe5ad0>
 2005d6c:	00808134 	movhi	r2,516
 2005d70:	108fdb04 	addi	r2,r2,16236
 2005d74:	14000217 	ldw	r16,8(r2)
 2005d78:	00bfff04 	movi	r2,-4
 2005d7c:	80c00117 	ldw	r3,4(r16)
 2005d80:	1886703a 	and	r3,r3,r2
 2005d84:	003f9106 	br	2005bcc <__alt_mem_mem_0+0xfcfe5bcc>
 2005d88:	60800217 	ldw	r2,8(r12)
 2005d8c:	213fffc4 	addi	r4,r4,-1
 2005d90:	1300651e 	bne	r2,r12,2005f28 <_malloc_r+0x7f4>
 2005d94:	208000cc 	andi	r2,r4,3
 2005d98:	633ffe04 	addi	r12,r12,-8
 2005d9c:	103ffa1e 	bne	r2,zero,2005d88 <__alt_mem_mem_0+0xfcfe5d88>
 2005da0:	98800117 	ldw	r2,4(r19)
 2005da4:	0146303a 	nor	r3,zero,r5
 2005da8:	1884703a 	and	r2,r3,r2
 2005dac:	98800115 	stw	r2,4(r19)
 2005db0:	294b883a 	add	r5,r5,r5
 2005db4:	117f2836 	bltu	r2,r5,2005a58 <__alt_mem_mem_0+0xfcfe5a58>
 2005db8:	283f2726 	beq	r5,zero,2005a58 <__alt_mem_mem_0+0xfcfe5a58>
 2005dbc:	2886703a 	and	r3,r5,r2
 2005dc0:	5809883a 	mov	r4,r11
 2005dc4:	183ec31e 	bne	r3,zero,20058d4 <__alt_mem_mem_0+0xfcfe58d4>
 2005dc8:	294b883a 	add	r5,r5,r5
 2005dcc:	2886703a 	and	r3,r5,r2
 2005dd0:	21000104 	addi	r4,r4,4
 2005dd4:	183ffc26 	beq	r3,zero,2005dc8 <__alt_mem_mem_0+0xfcfe5dc8>
 2005dd8:	003ebe06 	br	20058d4 <__alt_mem_mem_0+0xfcfe58d4>
 2005ddc:	00c05504 	movi	r3,340
 2005de0:	18801236 	bltu	r3,r2,2005e2c <_malloc_r+0x6f8>
 2005de4:	8804d3fa 	srli	r2,r17,15
 2005de8:	12001e04 	addi	r8,r2,120
 2005dec:	11c01dc4 	addi	r7,r2,119
 2005df0:	4209883a 	add	r4,r8,r8
 2005df4:	003e6d06 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005df8:	00c40004 	movi	r3,4096
 2005dfc:	003f4606 	br	2005b18 <__alt_mem_mem_0+0xfcfe5b18>
 2005e00:	00800044 	movi	r2,1
 2005e04:	a0800115 	stw	r2,4(r20)
 2005e08:	003f7406 	br	2005bdc <__alt_mem_mem_0+0xfcfe5bdc>
 2005e0c:	1805d0ba 	srai	r2,r3,2
 2005e10:	01c00044 	movi	r7,1
 2005e14:	30c00117 	ldw	r3,4(r6)
 2005e18:	388e983a 	sll	r7,r7,r2
 2005e1c:	2805883a 	mov	r2,r5
 2005e20:	38c6b03a 	or	r3,r7,r3
 2005e24:	30c00115 	stw	r3,4(r6)
 2005e28:	003f9b06 	br	2005c98 <__alt_mem_mem_0+0xfcfe5c98>
 2005e2c:	00c15504 	movi	r3,1364
 2005e30:	18801a36 	bltu	r3,r2,2005e9c <_malloc_r+0x768>
 2005e34:	8804d4ba 	srli	r2,r17,18
 2005e38:	12001f44 	addi	r8,r2,125
 2005e3c:	11c01f04 	addi	r7,r2,124
 2005e40:	4209883a 	add	r4,r8,r8
 2005e44:	003e5906 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005e48:	ad400404 	addi	r21,r21,16
 2005e4c:	003f1706 	br	2005aac <__alt_mem_mem_0+0xfcfe5aac>
 2005e50:	00c01504 	movi	r3,84
 2005e54:	18802336 	bltu	r3,r2,2005ee4 <_malloc_r+0x7b0>
 2005e58:	3804d33a 	srli	r2,r7,12
 2005e5c:	11401bc4 	addi	r5,r2,111
 2005e60:	10c01b84 	addi	r3,r2,110
 2005e64:	294b883a 	add	r5,r5,r5
 2005e68:	003f7b06 	br	2005c58 <__alt_mem_mem_0+0xfcfe5c58>
 2005e6c:	9c000217 	ldw	r16,8(r19)
 2005e70:	00bfff04 	movi	r2,-4
 2005e74:	80c00117 	ldw	r3,4(r16)
 2005e78:	1886703a 	and	r3,r3,r2
 2005e7c:	003f5306 	br	2005bcc <__alt_mem_mem_0+0xfcfe5bcc>
 2005e80:	3083ffcc 	andi	r2,r6,4095
 2005e84:	103f181e 	bne	r2,zero,2005ae8 <__alt_mem_mem_0+0xfcfe5ae8>
 2005e88:	99000217 	ldw	r4,8(r19)
 2005e8c:	b545883a 	add	r2,r22,r21
 2005e90:	10800054 	ori	r2,r2,1
 2005e94:	20800115 	stw	r2,4(r4)
 2005e98:	003f3e06 	br	2005b94 <__alt_mem_mem_0+0xfcfe5b94>
 2005e9c:	01003f84 	movi	r4,254
 2005ea0:	02001fc4 	movi	r8,127
 2005ea4:	01c01f84 	movi	r7,126
 2005ea8:	003e4006 	br	20057ac <__alt_mem_mem_0+0xfcfe57ac>
 2005eac:	00808134 	movhi	r2,516
 2005eb0:	10963f04 	addi	r2,r2,22780
 2005eb4:	15000015 	stw	r20,0(r2)
 2005eb8:	003f1106 	br	2005b00 <__alt_mem_mem_0+0xfcfe5b00>
 2005ebc:	00800044 	movi	r2,1
 2005ec0:	002b883a 	mov	r21,zero
 2005ec4:	003f1f06 	br	2005b44 <__alt_mem_mem_0+0xfcfe5b44>
 2005ec8:	81400204 	addi	r5,r16,8
 2005ecc:	9009883a 	mov	r4,r18
 2005ed0:	20050040 	call	2005004 <_free_r>
 2005ed4:	00808134 	movhi	r2,516
 2005ed8:	109e5d04 	addi	r2,r2,31092
 2005edc:	10c00017 	ldw	r3,0(r2)
 2005ee0:	003f2c06 	br	2005b94 <__alt_mem_mem_0+0xfcfe5b94>
 2005ee4:	00c05504 	movi	r3,340
 2005ee8:	18800536 	bltu	r3,r2,2005f00 <_malloc_r+0x7cc>
 2005eec:	3804d3fa 	srli	r2,r7,15
 2005ef0:	11401e04 	addi	r5,r2,120
 2005ef4:	10c01dc4 	addi	r3,r2,119
 2005ef8:	294b883a 	add	r5,r5,r5
 2005efc:	003f5606 	br	2005c58 <__alt_mem_mem_0+0xfcfe5c58>
 2005f00:	00c15504 	movi	r3,1364
 2005f04:	18800536 	bltu	r3,r2,2005f1c <_malloc_r+0x7e8>
 2005f08:	3804d4ba 	srli	r2,r7,18
 2005f0c:	11401f44 	addi	r5,r2,125
 2005f10:	10c01f04 	addi	r3,r2,124
 2005f14:	294b883a 	add	r5,r5,r5
 2005f18:	003f4f06 	br	2005c58 <__alt_mem_mem_0+0xfcfe5c58>
 2005f1c:	01403f84 	movi	r5,254
 2005f20:	00c01f84 	movi	r3,126
 2005f24:	003f4c06 	br	2005c58 <__alt_mem_mem_0+0xfcfe5c58>
 2005f28:	98800117 	ldw	r2,4(r19)
 2005f2c:	003fa006 	br	2005db0 <__alt_mem_mem_0+0xfcfe5db0>
 2005f30:	8808d0fa 	srli	r4,r17,3
 2005f34:	20800044 	addi	r2,r4,1
 2005f38:	1085883a 	add	r2,r2,r2
 2005f3c:	003e9006 	br	2005980 <__alt_mem_mem_0+0xfcfe5980>

02005f40 <memchr>:
 2005f40:	208000cc 	andi	r2,r4,3
 2005f44:	280f883a 	mov	r7,r5
 2005f48:	10003426 	beq	r2,zero,200601c <memchr+0xdc>
 2005f4c:	30bfffc4 	addi	r2,r6,-1
 2005f50:	30001a26 	beq	r6,zero,2005fbc <memchr+0x7c>
 2005f54:	20c00003 	ldbu	r3,0(r4)
 2005f58:	29803fcc 	andi	r6,r5,255
 2005f5c:	30c0051e 	bne	r6,r3,2005f74 <memchr+0x34>
 2005f60:	00001806 	br	2005fc4 <memchr+0x84>
 2005f64:	10001526 	beq	r2,zero,2005fbc <memchr+0x7c>
 2005f68:	20c00003 	ldbu	r3,0(r4)
 2005f6c:	10bfffc4 	addi	r2,r2,-1
 2005f70:	30c01426 	beq	r6,r3,2005fc4 <memchr+0x84>
 2005f74:	21000044 	addi	r4,r4,1
 2005f78:	20c000cc 	andi	r3,r4,3
 2005f7c:	183ff91e 	bne	r3,zero,2005f64 <__alt_mem_mem_0+0xfcfe5f64>
 2005f80:	020000c4 	movi	r8,3
 2005f84:	40801136 	bltu	r8,r2,2005fcc <memchr+0x8c>
 2005f88:	10000c26 	beq	r2,zero,2005fbc <memchr+0x7c>
 2005f8c:	20c00003 	ldbu	r3,0(r4)
 2005f90:	29403fcc 	andi	r5,r5,255
 2005f94:	28c00b26 	beq	r5,r3,2005fc4 <memchr+0x84>
 2005f98:	20c00044 	addi	r3,r4,1
 2005f9c:	39803fcc 	andi	r6,r7,255
 2005fa0:	2089883a 	add	r4,r4,r2
 2005fa4:	00000306 	br	2005fb4 <memchr+0x74>
 2005fa8:	18c00044 	addi	r3,r3,1
 2005fac:	197fffc3 	ldbu	r5,-1(r3)
 2005fb0:	31400526 	beq	r6,r5,2005fc8 <memchr+0x88>
 2005fb4:	1805883a 	mov	r2,r3
 2005fb8:	20fffb1e 	bne	r4,r3,2005fa8 <__alt_mem_mem_0+0xfcfe5fa8>
 2005fbc:	0005883a 	mov	r2,zero
 2005fc0:	f800283a 	ret
 2005fc4:	2005883a 	mov	r2,r4
 2005fc8:	f800283a 	ret
 2005fcc:	28c03fcc 	andi	r3,r5,255
 2005fd0:	1812923a 	slli	r9,r3,8
 2005fd4:	02ffbff4 	movhi	r11,65279
 2005fd8:	02a02074 	movhi	r10,32897
 2005fdc:	48d2b03a 	or	r9,r9,r3
 2005fe0:	4806943a 	slli	r3,r9,16
 2005fe4:	5affbfc4 	addi	r11,r11,-257
 2005fe8:	52a02004 	addi	r10,r10,-32640
 2005fec:	48d2b03a 	or	r9,r9,r3
 2005ff0:	20c00017 	ldw	r3,0(r4)
 2005ff4:	48c6f03a 	xor	r3,r9,r3
 2005ff8:	1acd883a 	add	r6,r3,r11
 2005ffc:	00c6303a 	nor	r3,zero,r3
 2006000:	30c6703a 	and	r3,r6,r3
 2006004:	1a86703a 	and	r3,r3,r10
 2006008:	183fe01e 	bne	r3,zero,2005f8c <__alt_mem_mem_0+0xfcfe5f8c>
 200600c:	10bfff04 	addi	r2,r2,-4
 2006010:	21000104 	addi	r4,r4,4
 2006014:	40bff636 	bltu	r8,r2,2005ff0 <__alt_mem_mem_0+0xfcfe5ff0>
 2006018:	003fdb06 	br	2005f88 <__alt_mem_mem_0+0xfcfe5f88>
 200601c:	3005883a 	mov	r2,r6
 2006020:	003fd706 	br	2005f80 <__alt_mem_mem_0+0xfcfe5f80>

02006024 <memcpy>:
 2006024:	defffd04 	addi	sp,sp,-12
 2006028:	dfc00215 	stw	ra,8(sp)
 200602c:	dc400115 	stw	r17,4(sp)
 2006030:	dc000015 	stw	r16,0(sp)
 2006034:	00c003c4 	movi	r3,15
 2006038:	2005883a 	mov	r2,r4
 200603c:	1980452e 	bgeu	r3,r6,2006154 <memcpy+0x130>
 2006040:	2906b03a 	or	r3,r5,r4
 2006044:	18c000cc 	andi	r3,r3,3
 2006048:	1800441e 	bne	r3,zero,200615c <memcpy+0x138>
 200604c:	347ffc04 	addi	r17,r6,-16
 2006050:	8822d13a 	srli	r17,r17,4
 2006054:	28c00104 	addi	r3,r5,4
 2006058:	23400104 	addi	r13,r4,4
 200605c:	8820913a 	slli	r16,r17,4
 2006060:	2b000204 	addi	r12,r5,8
 2006064:	22c00204 	addi	r11,r4,8
 2006068:	84000504 	addi	r16,r16,20
 200606c:	2a800304 	addi	r10,r5,12
 2006070:	22400304 	addi	r9,r4,12
 2006074:	2c21883a 	add	r16,r5,r16
 2006078:	2811883a 	mov	r8,r5
 200607c:	200f883a 	mov	r7,r4
 2006080:	41000017 	ldw	r4,0(r8)
 2006084:	1fc00017 	ldw	ra,0(r3)
 2006088:	63c00017 	ldw	r15,0(r12)
 200608c:	39000015 	stw	r4,0(r7)
 2006090:	53800017 	ldw	r14,0(r10)
 2006094:	6fc00015 	stw	ra,0(r13)
 2006098:	5bc00015 	stw	r15,0(r11)
 200609c:	4b800015 	stw	r14,0(r9)
 20060a0:	18c00404 	addi	r3,r3,16
 20060a4:	39c00404 	addi	r7,r7,16
 20060a8:	42000404 	addi	r8,r8,16
 20060ac:	6b400404 	addi	r13,r13,16
 20060b0:	63000404 	addi	r12,r12,16
 20060b4:	5ac00404 	addi	r11,r11,16
 20060b8:	52800404 	addi	r10,r10,16
 20060bc:	4a400404 	addi	r9,r9,16
 20060c0:	1c3fef1e 	bne	r3,r16,2006080 <__alt_mem_mem_0+0xfcfe6080>
 20060c4:	89c00044 	addi	r7,r17,1
 20060c8:	380e913a 	slli	r7,r7,4
 20060cc:	310003cc 	andi	r4,r6,15
 20060d0:	02c000c4 	movi	r11,3
 20060d4:	11c7883a 	add	r3,r2,r7
 20060d8:	29cb883a 	add	r5,r5,r7
 20060dc:	5900212e 	bgeu	r11,r4,2006164 <memcpy+0x140>
 20060e0:	1813883a 	mov	r9,r3
 20060e4:	2811883a 	mov	r8,r5
 20060e8:	200f883a 	mov	r7,r4
 20060ec:	42800017 	ldw	r10,0(r8)
 20060f0:	4a400104 	addi	r9,r9,4
 20060f4:	39ffff04 	addi	r7,r7,-4
 20060f8:	4abfff15 	stw	r10,-4(r9)
 20060fc:	42000104 	addi	r8,r8,4
 2006100:	59fffa36 	bltu	r11,r7,20060ec <__alt_mem_mem_0+0xfcfe60ec>
 2006104:	213fff04 	addi	r4,r4,-4
 2006108:	2008d0ba 	srli	r4,r4,2
 200610c:	318000cc 	andi	r6,r6,3
 2006110:	21000044 	addi	r4,r4,1
 2006114:	2109883a 	add	r4,r4,r4
 2006118:	2109883a 	add	r4,r4,r4
 200611c:	1907883a 	add	r3,r3,r4
 2006120:	290b883a 	add	r5,r5,r4
 2006124:	30000626 	beq	r6,zero,2006140 <memcpy+0x11c>
 2006128:	198d883a 	add	r6,r3,r6
 200612c:	29c00003 	ldbu	r7,0(r5)
 2006130:	18c00044 	addi	r3,r3,1
 2006134:	29400044 	addi	r5,r5,1
 2006138:	19ffffc5 	stb	r7,-1(r3)
 200613c:	19bffb1e 	bne	r3,r6,200612c <__alt_mem_mem_0+0xfcfe612c>
 2006140:	dfc00217 	ldw	ra,8(sp)
 2006144:	dc400117 	ldw	r17,4(sp)
 2006148:	dc000017 	ldw	r16,0(sp)
 200614c:	dec00304 	addi	sp,sp,12
 2006150:	f800283a 	ret
 2006154:	2007883a 	mov	r3,r4
 2006158:	003ff206 	br	2006124 <__alt_mem_mem_0+0xfcfe6124>
 200615c:	2007883a 	mov	r3,r4
 2006160:	003ff106 	br	2006128 <__alt_mem_mem_0+0xfcfe6128>
 2006164:	200d883a 	mov	r6,r4
 2006168:	003fee06 	br	2006124 <__alt_mem_mem_0+0xfcfe6124>

0200616c <memset>:
 200616c:	20c000cc 	andi	r3,r4,3
 2006170:	2005883a 	mov	r2,r4
 2006174:	18004426 	beq	r3,zero,2006288 <memset+0x11c>
 2006178:	31ffffc4 	addi	r7,r6,-1
 200617c:	30004026 	beq	r6,zero,2006280 <memset+0x114>
 2006180:	2813883a 	mov	r9,r5
 2006184:	200d883a 	mov	r6,r4
 2006188:	2007883a 	mov	r3,r4
 200618c:	00000406 	br	20061a0 <memset+0x34>
 2006190:	3a3fffc4 	addi	r8,r7,-1
 2006194:	31800044 	addi	r6,r6,1
 2006198:	38003926 	beq	r7,zero,2006280 <memset+0x114>
 200619c:	400f883a 	mov	r7,r8
 20061a0:	18c00044 	addi	r3,r3,1
 20061a4:	32400005 	stb	r9,0(r6)
 20061a8:	1a0000cc 	andi	r8,r3,3
 20061ac:	403ff81e 	bne	r8,zero,2006190 <__alt_mem_mem_0+0xfcfe6190>
 20061b0:	010000c4 	movi	r4,3
 20061b4:	21c02d2e 	bgeu	r4,r7,200626c <memset+0x100>
 20061b8:	29003fcc 	andi	r4,r5,255
 20061bc:	200c923a 	slli	r6,r4,8
 20061c0:	3108b03a 	or	r4,r6,r4
 20061c4:	200c943a 	slli	r6,r4,16
 20061c8:	218cb03a 	or	r6,r4,r6
 20061cc:	010003c4 	movi	r4,15
 20061d0:	21c0182e 	bgeu	r4,r7,2006234 <memset+0xc8>
 20061d4:	3b3ffc04 	addi	r12,r7,-16
 20061d8:	6018d13a 	srli	r12,r12,4
 20061dc:	1a000104 	addi	r8,r3,4
 20061e0:	1ac00204 	addi	r11,r3,8
 20061e4:	6008913a 	slli	r4,r12,4
 20061e8:	1a800304 	addi	r10,r3,12
 20061ec:	1813883a 	mov	r9,r3
 20061f0:	21000504 	addi	r4,r4,20
 20061f4:	1909883a 	add	r4,r3,r4
 20061f8:	49800015 	stw	r6,0(r9)
 20061fc:	41800015 	stw	r6,0(r8)
 2006200:	59800015 	stw	r6,0(r11)
 2006204:	51800015 	stw	r6,0(r10)
 2006208:	42000404 	addi	r8,r8,16
 200620c:	4a400404 	addi	r9,r9,16
 2006210:	5ac00404 	addi	r11,r11,16
 2006214:	52800404 	addi	r10,r10,16
 2006218:	413ff71e 	bne	r8,r4,20061f8 <__alt_mem_mem_0+0xfcfe61f8>
 200621c:	63000044 	addi	r12,r12,1
 2006220:	6018913a 	slli	r12,r12,4
 2006224:	39c003cc 	andi	r7,r7,15
 2006228:	010000c4 	movi	r4,3
 200622c:	1b07883a 	add	r3,r3,r12
 2006230:	21c00e2e 	bgeu	r4,r7,200626c <memset+0x100>
 2006234:	1813883a 	mov	r9,r3
 2006238:	3811883a 	mov	r8,r7
 200623c:	010000c4 	movi	r4,3
 2006240:	49800015 	stw	r6,0(r9)
 2006244:	423fff04 	addi	r8,r8,-4
 2006248:	4a400104 	addi	r9,r9,4
 200624c:	223ffc36 	bltu	r4,r8,2006240 <__alt_mem_mem_0+0xfcfe6240>
 2006250:	393fff04 	addi	r4,r7,-4
 2006254:	2008d0ba 	srli	r4,r4,2
 2006258:	39c000cc 	andi	r7,r7,3
 200625c:	21000044 	addi	r4,r4,1
 2006260:	2109883a 	add	r4,r4,r4
 2006264:	2109883a 	add	r4,r4,r4
 2006268:	1907883a 	add	r3,r3,r4
 200626c:	38000526 	beq	r7,zero,2006284 <memset+0x118>
 2006270:	19cf883a 	add	r7,r3,r7
 2006274:	19400005 	stb	r5,0(r3)
 2006278:	18c00044 	addi	r3,r3,1
 200627c:	38fffd1e 	bne	r7,r3,2006274 <__alt_mem_mem_0+0xfcfe6274>
 2006280:	f800283a 	ret
 2006284:	f800283a 	ret
 2006288:	2007883a 	mov	r3,r4
 200628c:	300f883a 	mov	r7,r6
 2006290:	003fc706 	br	20061b0 <__alt_mem_mem_0+0xfcfe61b0>

02006294 <_Balloc>:
 2006294:	20801317 	ldw	r2,76(r4)
 2006298:	defffc04 	addi	sp,sp,-16
 200629c:	dc400115 	stw	r17,4(sp)
 20062a0:	dc000015 	stw	r16,0(sp)
 20062a4:	dfc00315 	stw	ra,12(sp)
 20062a8:	dc800215 	stw	r18,8(sp)
 20062ac:	2023883a 	mov	r17,r4
 20062b0:	2821883a 	mov	r16,r5
 20062b4:	10000f26 	beq	r2,zero,20062f4 <_Balloc+0x60>
 20062b8:	8407883a 	add	r3,r16,r16
 20062bc:	18c7883a 	add	r3,r3,r3
 20062c0:	10c7883a 	add	r3,r2,r3
 20062c4:	18800017 	ldw	r2,0(r3)
 20062c8:	10001126 	beq	r2,zero,2006310 <_Balloc+0x7c>
 20062cc:	11000017 	ldw	r4,0(r2)
 20062d0:	19000015 	stw	r4,0(r3)
 20062d4:	10000415 	stw	zero,16(r2)
 20062d8:	10000315 	stw	zero,12(r2)
 20062dc:	dfc00317 	ldw	ra,12(sp)
 20062e0:	dc800217 	ldw	r18,8(sp)
 20062e4:	dc400117 	ldw	r17,4(sp)
 20062e8:	dc000017 	ldw	r16,0(sp)
 20062ec:	dec00404 	addi	sp,sp,16
 20062f0:	f800283a 	ret
 20062f4:	01800844 	movi	r6,33
 20062f8:	01400104 	movi	r5,4
 20062fc:	2008d040 	call	2008d04 <_calloc_r>
 2006300:	88801315 	stw	r2,76(r17)
 2006304:	103fec1e 	bne	r2,zero,20062b8 <__alt_mem_mem_0+0xfcfe62b8>
 2006308:	0005883a 	mov	r2,zero
 200630c:	003ff306 	br	20062dc <__alt_mem_mem_0+0xfcfe62dc>
 2006310:	01400044 	movi	r5,1
 2006314:	2c24983a 	sll	r18,r5,r16
 2006318:	8809883a 	mov	r4,r17
 200631c:	91800144 	addi	r6,r18,5
 2006320:	318d883a 	add	r6,r6,r6
 2006324:	318d883a 	add	r6,r6,r6
 2006328:	2008d040 	call	2008d04 <_calloc_r>
 200632c:	103ff626 	beq	r2,zero,2006308 <__alt_mem_mem_0+0xfcfe6308>
 2006330:	14000115 	stw	r16,4(r2)
 2006334:	14800215 	stw	r18,8(r2)
 2006338:	003fe606 	br	20062d4 <__alt_mem_mem_0+0xfcfe62d4>

0200633c <_Bfree>:
 200633c:	28000826 	beq	r5,zero,2006360 <_Bfree+0x24>
 2006340:	28c00117 	ldw	r3,4(r5)
 2006344:	20801317 	ldw	r2,76(r4)
 2006348:	18c7883a 	add	r3,r3,r3
 200634c:	18c7883a 	add	r3,r3,r3
 2006350:	10c5883a 	add	r2,r2,r3
 2006354:	10c00017 	ldw	r3,0(r2)
 2006358:	28c00015 	stw	r3,0(r5)
 200635c:	11400015 	stw	r5,0(r2)
 2006360:	f800283a 	ret

02006364 <__multadd>:
 2006364:	defffa04 	addi	sp,sp,-24
 2006368:	dc800315 	stw	r18,12(sp)
 200636c:	dc400215 	stw	r17,8(sp)
 2006370:	dc000115 	stw	r16,4(sp)
 2006374:	2823883a 	mov	r17,r5
 2006378:	2c000417 	ldw	r16,16(r5)
 200637c:	dfc00515 	stw	ra,20(sp)
 2006380:	dcc00415 	stw	r19,16(sp)
 2006384:	2025883a 	mov	r18,r4
 2006388:	29400504 	addi	r5,r5,20
 200638c:	0011883a 	mov	r8,zero
 2006390:	28c00017 	ldw	r3,0(r5)
 2006394:	29400104 	addi	r5,r5,4
 2006398:	42000044 	addi	r8,r8,1
 200639c:	18bfffcc 	andi	r2,r3,65535
 20063a0:	1185383a 	mul	r2,r2,r6
 20063a4:	1806d43a 	srli	r3,r3,16
 20063a8:	11cf883a 	add	r7,r2,r7
 20063ac:	3808d43a 	srli	r4,r7,16
 20063b0:	1987383a 	mul	r3,r3,r6
 20063b4:	38bfffcc 	andi	r2,r7,65535
 20063b8:	1907883a 	add	r3,r3,r4
 20063bc:	1808943a 	slli	r4,r3,16
 20063c0:	180ed43a 	srli	r7,r3,16
 20063c4:	2085883a 	add	r2,r4,r2
 20063c8:	28bfff15 	stw	r2,-4(r5)
 20063cc:	443ff016 	blt	r8,r16,2006390 <__alt_mem_mem_0+0xfcfe6390>
 20063d0:	38000926 	beq	r7,zero,20063f8 <__multadd+0x94>
 20063d4:	88800217 	ldw	r2,8(r17)
 20063d8:	80800f0e 	bge	r16,r2,2006418 <__multadd+0xb4>
 20063dc:	80800144 	addi	r2,r16,5
 20063e0:	1085883a 	add	r2,r2,r2
 20063e4:	1085883a 	add	r2,r2,r2
 20063e8:	8885883a 	add	r2,r17,r2
 20063ec:	11c00015 	stw	r7,0(r2)
 20063f0:	84000044 	addi	r16,r16,1
 20063f4:	8c000415 	stw	r16,16(r17)
 20063f8:	8805883a 	mov	r2,r17
 20063fc:	dfc00517 	ldw	ra,20(sp)
 2006400:	dcc00417 	ldw	r19,16(sp)
 2006404:	dc800317 	ldw	r18,12(sp)
 2006408:	dc400217 	ldw	r17,8(sp)
 200640c:	dc000117 	ldw	r16,4(sp)
 2006410:	dec00604 	addi	sp,sp,24
 2006414:	f800283a 	ret
 2006418:	89400117 	ldw	r5,4(r17)
 200641c:	9009883a 	mov	r4,r18
 2006420:	d9c00015 	stw	r7,0(sp)
 2006424:	29400044 	addi	r5,r5,1
 2006428:	20062940 	call	2006294 <_Balloc>
 200642c:	89800417 	ldw	r6,16(r17)
 2006430:	89400304 	addi	r5,r17,12
 2006434:	11000304 	addi	r4,r2,12
 2006438:	31800084 	addi	r6,r6,2
 200643c:	318d883a 	add	r6,r6,r6
 2006440:	318d883a 	add	r6,r6,r6
 2006444:	1027883a 	mov	r19,r2
 2006448:	20060240 	call	2006024 <memcpy>
 200644c:	d9c00017 	ldw	r7,0(sp)
 2006450:	88000a26 	beq	r17,zero,200647c <__multadd+0x118>
 2006454:	88c00117 	ldw	r3,4(r17)
 2006458:	90801317 	ldw	r2,76(r18)
 200645c:	18c7883a 	add	r3,r3,r3
 2006460:	18c7883a 	add	r3,r3,r3
 2006464:	10c5883a 	add	r2,r2,r3
 2006468:	10c00017 	ldw	r3,0(r2)
 200646c:	88c00015 	stw	r3,0(r17)
 2006470:	14400015 	stw	r17,0(r2)
 2006474:	9823883a 	mov	r17,r19
 2006478:	003fd806 	br	20063dc <__alt_mem_mem_0+0xfcfe63dc>
 200647c:	9823883a 	mov	r17,r19
 2006480:	003fd606 	br	20063dc <__alt_mem_mem_0+0xfcfe63dc>

02006484 <__s2b>:
 2006484:	defff904 	addi	sp,sp,-28
 2006488:	dc400115 	stw	r17,4(sp)
 200648c:	dc000015 	stw	r16,0(sp)
 2006490:	2023883a 	mov	r17,r4
 2006494:	2821883a 	mov	r16,r5
 2006498:	39000204 	addi	r4,r7,8
 200649c:	01400244 	movi	r5,9
 20064a0:	dcc00315 	stw	r19,12(sp)
 20064a4:	dc800215 	stw	r18,8(sp)
 20064a8:	dfc00615 	stw	ra,24(sp)
 20064ac:	dd400515 	stw	r21,20(sp)
 20064b0:	dd000415 	stw	r20,16(sp)
 20064b4:	3825883a 	mov	r18,r7
 20064b8:	3027883a 	mov	r19,r6
 20064bc:	200abb00 	call	200abb0 <__divsi3>
 20064c0:	00c00044 	movi	r3,1
 20064c4:	000b883a 	mov	r5,zero
 20064c8:	1880030e 	bge	r3,r2,20064d8 <__s2b+0x54>
 20064cc:	18c7883a 	add	r3,r3,r3
 20064d0:	29400044 	addi	r5,r5,1
 20064d4:	18bffd16 	blt	r3,r2,20064cc <__alt_mem_mem_0+0xfcfe64cc>
 20064d8:	8809883a 	mov	r4,r17
 20064dc:	20062940 	call	2006294 <_Balloc>
 20064e0:	d8c00717 	ldw	r3,28(sp)
 20064e4:	10c00515 	stw	r3,20(r2)
 20064e8:	00c00044 	movi	r3,1
 20064ec:	10c00415 	stw	r3,16(r2)
 20064f0:	00c00244 	movi	r3,9
 20064f4:	1cc0210e 	bge	r3,r19,200657c <__s2b+0xf8>
 20064f8:	80eb883a 	add	r21,r16,r3
 20064fc:	a829883a 	mov	r20,r21
 2006500:	84e1883a 	add	r16,r16,r19
 2006504:	a1c00007 	ldb	r7,0(r20)
 2006508:	01800284 	movi	r6,10
 200650c:	a5000044 	addi	r20,r20,1
 2006510:	100b883a 	mov	r5,r2
 2006514:	39fff404 	addi	r7,r7,-48
 2006518:	8809883a 	mov	r4,r17
 200651c:	20063640 	call	2006364 <__multadd>
 2006520:	a43ff81e 	bne	r20,r16,2006504 <__alt_mem_mem_0+0xfcfe6504>
 2006524:	ace1883a 	add	r16,r21,r19
 2006528:	843ffe04 	addi	r16,r16,-8
 200652c:	9c800a0e 	bge	r19,r18,2006558 <__s2b+0xd4>
 2006530:	94e5c83a 	sub	r18,r18,r19
 2006534:	84a5883a 	add	r18,r16,r18
 2006538:	81c00007 	ldb	r7,0(r16)
 200653c:	01800284 	movi	r6,10
 2006540:	84000044 	addi	r16,r16,1
 2006544:	100b883a 	mov	r5,r2
 2006548:	39fff404 	addi	r7,r7,-48
 200654c:	8809883a 	mov	r4,r17
 2006550:	20063640 	call	2006364 <__multadd>
 2006554:	84bff81e 	bne	r16,r18,2006538 <__alt_mem_mem_0+0xfcfe6538>
 2006558:	dfc00617 	ldw	ra,24(sp)
 200655c:	dd400517 	ldw	r21,20(sp)
 2006560:	dd000417 	ldw	r20,16(sp)
 2006564:	dcc00317 	ldw	r19,12(sp)
 2006568:	dc800217 	ldw	r18,8(sp)
 200656c:	dc400117 	ldw	r17,4(sp)
 2006570:	dc000017 	ldw	r16,0(sp)
 2006574:	dec00704 	addi	sp,sp,28
 2006578:	f800283a 	ret
 200657c:	84000284 	addi	r16,r16,10
 2006580:	1827883a 	mov	r19,r3
 2006584:	003fe906 	br	200652c <__alt_mem_mem_0+0xfcfe652c>

02006588 <__hi0bits>:
 2006588:	20bfffec 	andhi	r2,r4,65535
 200658c:	1000141e 	bne	r2,zero,20065e0 <__hi0bits+0x58>
 2006590:	2008943a 	slli	r4,r4,16
 2006594:	00800404 	movi	r2,16
 2006598:	20ffc02c 	andhi	r3,r4,65280
 200659c:	1800021e 	bne	r3,zero,20065a8 <__hi0bits+0x20>
 20065a0:	2008923a 	slli	r4,r4,8
 20065a4:	10800204 	addi	r2,r2,8
 20065a8:	20fc002c 	andhi	r3,r4,61440
 20065ac:	1800021e 	bne	r3,zero,20065b8 <__hi0bits+0x30>
 20065b0:	2008913a 	slli	r4,r4,4
 20065b4:	10800104 	addi	r2,r2,4
 20065b8:	20f0002c 	andhi	r3,r4,49152
 20065bc:	1800031e 	bne	r3,zero,20065cc <__hi0bits+0x44>
 20065c0:	2109883a 	add	r4,r4,r4
 20065c4:	10800084 	addi	r2,r2,2
 20065c8:	2109883a 	add	r4,r4,r4
 20065cc:	20000316 	blt	r4,zero,20065dc <__hi0bits+0x54>
 20065d0:	2110002c 	andhi	r4,r4,16384
 20065d4:	2000041e 	bne	r4,zero,20065e8 <__hi0bits+0x60>
 20065d8:	00800804 	movi	r2,32
 20065dc:	f800283a 	ret
 20065e0:	0005883a 	mov	r2,zero
 20065e4:	003fec06 	br	2006598 <__alt_mem_mem_0+0xfcfe6598>
 20065e8:	10800044 	addi	r2,r2,1
 20065ec:	f800283a 	ret

020065f0 <__lo0bits>:
 20065f0:	20c00017 	ldw	r3,0(r4)
 20065f4:	188001cc 	andi	r2,r3,7
 20065f8:	10000826 	beq	r2,zero,200661c <__lo0bits+0x2c>
 20065fc:	1880004c 	andi	r2,r3,1
 2006600:	1000211e 	bne	r2,zero,2006688 <__lo0bits+0x98>
 2006604:	1880008c 	andi	r2,r3,2
 2006608:	1000211e 	bne	r2,zero,2006690 <__lo0bits+0xa0>
 200660c:	1806d0ba 	srli	r3,r3,2
 2006610:	00800084 	movi	r2,2
 2006614:	20c00015 	stw	r3,0(r4)
 2006618:	f800283a 	ret
 200661c:	18bfffcc 	andi	r2,r3,65535
 2006620:	10001326 	beq	r2,zero,2006670 <__lo0bits+0x80>
 2006624:	0005883a 	mov	r2,zero
 2006628:	19403fcc 	andi	r5,r3,255
 200662c:	2800021e 	bne	r5,zero,2006638 <__lo0bits+0x48>
 2006630:	1806d23a 	srli	r3,r3,8
 2006634:	10800204 	addi	r2,r2,8
 2006638:	194003cc 	andi	r5,r3,15
 200663c:	2800021e 	bne	r5,zero,2006648 <__lo0bits+0x58>
 2006640:	1806d13a 	srli	r3,r3,4
 2006644:	10800104 	addi	r2,r2,4
 2006648:	194000cc 	andi	r5,r3,3
 200664c:	2800021e 	bne	r5,zero,2006658 <__lo0bits+0x68>
 2006650:	1806d0ba 	srli	r3,r3,2
 2006654:	10800084 	addi	r2,r2,2
 2006658:	1940004c 	andi	r5,r3,1
 200665c:	2800081e 	bne	r5,zero,2006680 <__lo0bits+0x90>
 2006660:	1806d07a 	srli	r3,r3,1
 2006664:	1800051e 	bne	r3,zero,200667c <__lo0bits+0x8c>
 2006668:	00800804 	movi	r2,32
 200666c:	f800283a 	ret
 2006670:	1806d43a 	srli	r3,r3,16
 2006674:	00800404 	movi	r2,16
 2006678:	003feb06 	br	2006628 <__alt_mem_mem_0+0xfcfe6628>
 200667c:	10800044 	addi	r2,r2,1
 2006680:	20c00015 	stw	r3,0(r4)
 2006684:	f800283a 	ret
 2006688:	0005883a 	mov	r2,zero
 200668c:	f800283a 	ret
 2006690:	1806d07a 	srli	r3,r3,1
 2006694:	00800044 	movi	r2,1
 2006698:	20c00015 	stw	r3,0(r4)
 200669c:	f800283a 	ret

020066a0 <__i2b>:
 20066a0:	defffd04 	addi	sp,sp,-12
 20066a4:	dc000015 	stw	r16,0(sp)
 20066a8:	04000044 	movi	r16,1
 20066ac:	dc400115 	stw	r17,4(sp)
 20066b0:	2823883a 	mov	r17,r5
 20066b4:	800b883a 	mov	r5,r16
 20066b8:	dfc00215 	stw	ra,8(sp)
 20066bc:	20062940 	call	2006294 <_Balloc>
 20066c0:	14400515 	stw	r17,20(r2)
 20066c4:	14000415 	stw	r16,16(r2)
 20066c8:	dfc00217 	ldw	ra,8(sp)
 20066cc:	dc400117 	ldw	r17,4(sp)
 20066d0:	dc000017 	ldw	r16,0(sp)
 20066d4:	dec00304 	addi	sp,sp,12
 20066d8:	f800283a 	ret

020066dc <__multiply>:
 20066dc:	defffa04 	addi	sp,sp,-24
 20066e0:	dcc00315 	stw	r19,12(sp)
 20066e4:	dc800215 	stw	r18,8(sp)
 20066e8:	34c00417 	ldw	r19,16(r6)
 20066ec:	2c800417 	ldw	r18,16(r5)
 20066f0:	dd000415 	stw	r20,16(sp)
 20066f4:	dc400115 	stw	r17,4(sp)
 20066f8:	dfc00515 	stw	ra,20(sp)
 20066fc:	dc000015 	stw	r16,0(sp)
 2006700:	2829883a 	mov	r20,r5
 2006704:	3023883a 	mov	r17,r6
 2006708:	94c0050e 	bge	r18,r19,2006720 <__multiply+0x44>
 200670c:	9007883a 	mov	r3,r18
 2006710:	3029883a 	mov	r20,r6
 2006714:	9825883a 	mov	r18,r19
 2006718:	2823883a 	mov	r17,r5
 200671c:	1827883a 	mov	r19,r3
 2006720:	a0800217 	ldw	r2,8(r20)
 2006724:	94e1883a 	add	r16,r18,r19
 2006728:	a1400117 	ldw	r5,4(r20)
 200672c:	1400010e 	bge	r2,r16,2006734 <__multiply+0x58>
 2006730:	29400044 	addi	r5,r5,1
 2006734:	20062940 	call	2006294 <_Balloc>
 2006738:	8415883a 	add	r10,r16,r16
 200673c:	12c00504 	addi	r11,r2,20
 2006740:	5295883a 	add	r10,r10,r10
 2006744:	5a95883a 	add	r10,r11,r10
 2006748:	5807883a 	mov	r3,r11
 200674c:	5a80032e 	bgeu	r11,r10,200675c <__multiply+0x80>
 2006750:	18000015 	stw	zero,0(r3)
 2006754:	18c00104 	addi	r3,r3,4
 2006758:	1abffd36 	bltu	r3,r10,2006750 <__alt_mem_mem_0+0xfcfe6750>
 200675c:	9ce7883a 	add	r19,r19,r19
 2006760:	94a5883a 	add	r18,r18,r18
 2006764:	89800504 	addi	r6,r17,20
 2006768:	9ce7883a 	add	r19,r19,r19
 200676c:	a3400504 	addi	r13,r20,20
 2006770:	94a5883a 	add	r18,r18,r18
 2006774:	34d9883a 	add	r12,r6,r19
 2006778:	6c93883a 	add	r9,r13,r18
 200677c:	3300422e 	bgeu	r6,r12,2006888 <__multiply+0x1ac>
 2006780:	37c00017 	ldw	ra,0(r6)
 2006784:	fbffffcc 	andi	r15,ra,65535
 2006788:	78001b26 	beq	r15,zero,20067f8 <__multiply+0x11c>
 200678c:	5811883a 	mov	r8,r11
 2006790:	681d883a 	mov	r14,r13
 2006794:	000f883a 	mov	r7,zero
 2006798:	71000017 	ldw	r4,0(r14)
 200679c:	40c00017 	ldw	r3,0(r8)
 20067a0:	73800104 	addi	r14,r14,4
 20067a4:	217fffcc 	andi	r5,r4,65535
 20067a8:	2bcb383a 	mul	r5,r5,r15
 20067ac:	2008d43a 	srli	r4,r4,16
 20067b0:	1c7fffcc 	andi	r17,r3,65535
 20067b4:	2c4b883a 	add	r5,r5,r17
 20067b8:	29cb883a 	add	r5,r5,r7
 20067bc:	23c9383a 	mul	r4,r4,r15
 20067c0:	1806d43a 	srli	r3,r3,16
 20067c4:	280ed43a 	srli	r7,r5,16
 20067c8:	297fffcc 	andi	r5,r5,65535
 20067cc:	20c7883a 	add	r3,r4,r3
 20067d0:	19c7883a 	add	r3,r3,r7
 20067d4:	1808943a 	slli	r4,r3,16
 20067d8:	4023883a 	mov	r17,r8
 20067dc:	180ed43a 	srli	r7,r3,16
 20067e0:	214ab03a 	or	r5,r4,r5
 20067e4:	41400015 	stw	r5,0(r8)
 20067e8:	42000104 	addi	r8,r8,4
 20067ec:	727fea36 	bltu	r14,r9,2006798 <__alt_mem_mem_0+0xfcfe6798>
 20067f0:	89c00115 	stw	r7,4(r17)
 20067f4:	37c00017 	ldw	ra,0(r6)
 20067f8:	f83ed43a 	srli	ra,ra,16
 20067fc:	f8001f26 	beq	ra,zero,200687c <__multiply+0x1a0>
 2006800:	58c00017 	ldw	r3,0(r11)
 2006804:	681d883a 	mov	r14,r13
 2006808:	581f883a 	mov	r15,r11
 200680c:	1811883a 	mov	r8,r3
 2006810:	5825883a 	mov	r18,r11
 2006814:	000f883a 	mov	r7,zero
 2006818:	00000106 	br	2006820 <__multiply+0x144>
 200681c:	8825883a 	mov	r18,r17
 2006820:	7140000b 	ldhu	r5,0(r14)
 2006824:	4010d43a 	srli	r8,r8,16
 2006828:	193fffcc 	andi	r4,r3,65535
 200682c:	2fcb383a 	mul	r5,r5,ra
 2006830:	7bc00104 	addi	r15,r15,4
 2006834:	73800104 	addi	r14,r14,4
 2006838:	2a0b883a 	add	r5,r5,r8
 200683c:	29cb883a 	add	r5,r5,r7
 2006840:	2806943a 	slli	r3,r5,16
 2006844:	94400104 	addi	r17,r18,4
 2006848:	280ad43a 	srli	r5,r5,16
 200684c:	1908b03a 	or	r4,r3,r4
 2006850:	793fff15 	stw	r4,-4(r15)
 2006854:	70ffff17 	ldw	r3,-4(r14)
 2006858:	8a000017 	ldw	r8,0(r17)
 200685c:	1806d43a 	srli	r3,r3,16
 2006860:	413fffcc 	andi	r4,r8,65535
 2006864:	1fc7383a 	mul	r3,r3,ra
 2006868:	1907883a 	add	r3,r3,r4
 200686c:	1947883a 	add	r3,r3,r5
 2006870:	180ed43a 	srli	r7,r3,16
 2006874:	727fe936 	bltu	r14,r9,200681c <__alt_mem_mem_0+0xfcfe681c>
 2006878:	90c00115 	stw	r3,4(r18)
 200687c:	31800104 	addi	r6,r6,4
 2006880:	5ac00104 	addi	r11,r11,4
 2006884:	333fbe36 	bltu	r6,r12,2006780 <__alt_mem_mem_0+0xfcfe6780>
 2006888:	0400090e 	bge	zero,r16,20068b0 <__multiply+0x1d4>
 200688c:	50ffff17 	ldw	r3,-4(r10)
 2006890:	52bfff04 	addi	r10,r10,-4
 2006894:	18000326 	beq	r3,zero,20068a4 <__multiply+0x1c8>
 2006898:	00000506 	br	20068b0 <__multiply+0x1d4>
 200689c:	50c00017 	ldw	r3,0(r10)
 20068a0:	1800031e 	bne	r3,zero,20068b0 <__multiply+0x1d4>
 20068a4:	843fffc4 	addi	r16,r16,-1
 20068a8:	52bfff04 	addi	r10,r10,-4
 20068ac:	803ffb1e 	bne	r16,zero,200689c <__alt_mem_mem_0+0xfcfe689c>
 20068b0:	14000415 	stw	r16,16(r2)
 20068b4:	dfc00517 	ldw	ra,20(sp)
 20068b8:	dd000417 	ldw	r20,16(sp)
 20068bc:	dcc00317 	ldw	r19,12(sp)
 20068c0:	dc800217 	ldw	r18,8(sp)
 20068c4:	dc400117 	ldw	r17,4(sp)
 20068c8:	dc000017 	ldw	r16,0(sp)
 20068cc:	dec00604 	addi	sp,sp,24
 20068d0:	f800283a 	ret

020068d4 <__pow5mult>:
 20068d4:	defffa04 	addi	sp,sp,-24
 20068d8:	dcc00315 	stw	r19,12(sp)
 20068dc:	dc000015 	stw	r16,0(sp)
 20068e0:	dfc00515 	stw	ra,20(sp)
 20068e4:	dd000415 	stw	r20,16(sp)
 20068e8:	dc800215 	stw	r18,8(sp)
 20068ec:	dc400115 	stw	r17,4(sp)
 20068f0:	308000cc 	andi	r2,r6,3
 20068f4:	3021883a 	mov	r16,r6
 20068f8:	2027883a 	mov	r19,r4
 20068fc:	10002f1e 	bne	r2,zero,20069bc <__pow5mult+0xe8>
 2006900:	2825883a 	mov	r18,r5
 2006904:	8021d0ba 	srai	r16,r16,2
 2006908:	80001a26 	beq	r16,zero,2006974 <__pow5mult+0xa0>
 200690c:	9c401217 	ldw	r17,72(r19)
 2006910:	8800061e 	bne	r17,zero,200692c <__pow5mult+0x58>
 2006914:	00003406 	br	20069e8 <__pow5mult+0x114>
 2006918:	8021d07a 	srai	r16,r16,1
 200691c:	80001526 	beq	r16,zero,2006974 <__pow5mult+0xa0>
 2006920:	88800017 	ldw	r2,0(r17)
 2006924:	10001c26 	beq	r2,zero,2006998 <__pow5mult+0xc4>
 2006928:	1023883a 	mov	r17,r2
 200692c:	8080004c 	andi	r2,r16,1
 2006930:	103ff926 	beq	r2,zero,2006918 <__alt_mem_mem_0+0xfcfe6918>
 2006934:	880d883a 	mov	r6,r17
 2006938:	900b883a 	mov	r5,r18
 200693c:	9809883a 	mov	r4,r19
 2006940:	20066dc0 	call	20066dc <__multiply>
 2006944:	90001b26 	beq	r18,zero,20069b4 <__pow5mult+0xe0>
 2006948:	91000117 	ldw	r4,4(r18)
 200694c:	98c01317 	ldw	r3,76(r19)
 2006950:	8021d07a 	srai	r16,r16,1
 2006954:	2109883a 	add	r4,r4,r4
 2006958:	2109883a 	add	r4,r4,r4
 200695c:	1907883a 	add	r3,r3,r4
 2006960:	19000017 	ldw	r4,0(r3)
 2006964:	91000015 	stw	r4,0(r18)
 2006968:	1c800015 	stw	r18,0(r3)
 200696c:	1025883a 	mov	r18,r2
 2006970:	803feb1e 	bne	r16,zero,2006920 <__alt_mem_mem_0+0xfcfe6920>
 2006974:	9005883a 	mov	r2,r18
 2006978:	dfc00517 	ldw	ra,20(sp)
 200697c:	dd000417 	ldw	r20,16(sp)
 2006980:	dcc00317 	ldw	r19,12(sp)
 2006984:	dc800217 	ldw	r18,8(sp)
 2006988:	dc400117 	ldw	r17,4(sp)
 200698c:	dc000017 	ldw	r16,0(sp)
 2006990:	dec00604 	addi	sp,sp,24
 2006994:	f800283a 	ret
 2006998:	880d883a 	mov	r6,r17
 200699c:	880b883a 	mov	r5,r17
 20069a0:	9809883a 	mov	r4,r19
 20069a4:	20066dc0 	call	20066dc <__multiply>
 20069a8:	88800015 	stw	r2,0(r17)
 20069ac:	10000015 	stw	zero,0(r2)
 20069b0:	003fdd06 	br	2006928 <__alt_mem_mem_0+0xfcfe6928>
 20069b4:	1025883a 	mov	r18,r2
 20069b8:	003fd706 	br	2006918 <__alt_mem_mem_0+0xfcfe6918>
 20069bc:	10bfffc4 	addi	r2,r2,-1
 20069c0:	1085883a 	add	r2,r2,r2
 20069c4:	00c08134 	movhi	r3,516
 20069c8:	18c3e604 	addi	r3,r3,3992
 20069cc:	1085883a 	add	r2,r2,r2
 20069d0:	1885883a 	add	r2,r3,r2
 20069d4:	11800017 	ldw	r6,0(r2)
 20069d8:	000f883a 	mov	r7,zero
 20069dc:	20063640 	call	2006364 <__multadd>
 20069e0:	1025883a 	mov	r18,r2
 20069e4:	003fc706 	br	2006904 <__alt_mem_mem_0+0xfcfe6904>
 20069e8:	05000044 	movi	r20,1
 20069ec:	a00b883a 	mov	r5,r20
 20069f0:	9809883a 	mov	r4,r19
 20069f4:	20062940 	call	2006294 <_Balloc>
 20069f8:	1023883a 	mov	r17,r2
 20069fc:	00809c44 	movi	r2,625
 2006a00:	88800515 	stw	r2,20(r17)
 2006a04:	8d000415 	stw	r20,16(r17)
 2006a08:	9c401215 	stw	r17,72(r19)
 2006a0c:	88000015 	stw	zero,0(r17)
 2006a10:	003fc606 	br	200692c <__alt_mem_mem_0+0xfcfe692c>

02006a14 <__lshift>:
 2006a14:	defff904 	addi	sp,sp,-28
 2006a18:	dd400515 	stw	r21,20(sp)
 2006a1c:	dcc00315 	stw	r19,12(sp)
 2006a20:	302bd17a 	srai	r21,r6,5
 2006a24:	2cc00417 	ldw	r19,16(r5)
 2006a28:	28800217 	ldw	r2,8(r5)
 2006a2c:	dd000415 	stw	r20,16(sp)
 2006a30:	ace7883a 	add	r19,r21,r19
 2006a34:	dc800215 	stw	r18,8(sp)
 2006a38:	dc400115 	stw	r17,4(sp)
 2006a3c:	dc000015 	stw	r16,0(sp)
 2006a40:	dfc00615 	stw	ra,24(sp)
 2006a44:	9c000044 	addi	r16,r19,1
 2006a48:	2823883a 	mov	r17,r5
 2006a4c:	3029883a 	mov	r20,r6
 2006a50:	2025883a 	mov	r18,r4
 2006a54:	29400117 	ldw	r5,4(r5)
 2006a58:	1400030e 	bge	r2,r16,2006a68 <__lshift+0x54>
 2006a5c:	1085883a 	add	r2,r2,r2
 2006a60:	29400044 	addi	r5,r5,1
 2006a64:	143ffd16 	blt	r2,r16,2006a5c <__alt_mem_mem_0+0xfcfe6a5c>
 2006a68:	9009883a 	mov	r4,r18
 2006a6c:	20062940 	call	2006294 <_Balloc>
 2006a70:	10c00504 	addi	r3,r2,20
 2006a74:	0540070e 	bge	zero,r21,2006a94 <__lshift+0x80>
 2006a78:	ad6b883a 	add	r21,r21,r21
 2006a7c:	ad6b883a 	add	r21,r21,r21
 2006a80:	1809883a 	mov	r4,r3
 2006a84:	1d47883a 	add	r3,r3,r21
 2006a88:	20000015 	stw	zero,0(r4)
 2006a8c:	21000104 	addi	r4,r4,4
 2006a90:	193ffd1e 	bne	r3,r4,2006a88 <__alt_mem_mem_0+0xfcfe6a88>
 2006a94:	8a000417 	ldw	r8,16(r17)
 2006a98:	89000504 	addi	r4,r17,20
 2006a9c:	a18007cc 	andi	r6,r20,31
 2006aa0:	4211883a 	add	r8,r8,r8
 2006aa4:	4211883a 	add	r8,r8,r8
 2006aa8:	2211883a 	add	r8,r4,r8
 2006aac:	30002326 	beq	r6,zero,2006b3c <__lshift+0x128>
 2006ab0:	02400804 	movi	r9,32
 2006ab4:	4993c83a 	sub	r9,r9,r6
 2006ab8:	000b883a 	mov	r5,zero
 2006abc:	21c00017 	ldw	r7,0(r4)
 2006ac0:	1815883a 	mov	r10,r3
 2006ac4:	18c00104 	addi	r3,r3,4
 2006ac8:	398e983a 	sll	r7,r7,r6
 2006acc:	21000104 	addi	r4,r4,4
 2006ad0:	394ab03a 	or	r5,r7,r5
 2006ad4:	197fff15 	stw	r5,-4(r3)
 2006ad8:	217fff17 	ldw	r5,-4(r4)
 2006adc:	2a4ad83a 	srl	r5,r5,r9
 2006ae0:	223ff636 	bltu	r4,r8,2006abc <__alt_mem_mem_0+0xfcfe6abc>
 2006ae4:	51400115 	stw	r5,4(r10)
 2006ae8:	28001a1e 	bne	r5,zero,2006b54 <__lshift+0x140>
 2006aec:	843fffc4 	addi	r16,r16,-1
 2006af0:	14000415 	stw	r16,16(r2)
 2006af4:	88000826 	beq	r17,zero,2006b18 <__lshift+0x104>
 2006af8:	89000117 	ldw	r4,4(r17)
 2006afc:	90c01317 	ldw	r3,76(r18)
 2006b00:	2109883a 	add	r4,r4,r4
 2006b04:	2109883a 	add	r4,r4,r4
 2006b08:	1907883a 	add	r3,r3,r4
 2006b0c:	19000017 	ldw	r4,0(r3)
 2006b10:	89000015 	stw	r4,0(r17)
 2006b14:	1c400015 	stw	r17,0(r3)
 2006b18:	dfc00617 	ldw	ra,24(sp)
 2006b1c:	dd400517 	ldw	r21,20(sp)
 2006b20:	dd000417 	ldw	r20,16(sp)
 2006b24:	dcc00317 	ldw	r19,12(sp)
 2006b28:	dc800217 	ldw	r18,8(sp)
 2006b2c:	dc400117 	ldw	r17,4(sp)
 2006b30:	dc000017 	ldw	r16,0(sp)
 2006b34:	dec00704 	addi	sp,sp,28
 2006b38:	f800283a 	ret
 2006b3c:	21400017 	ldw	r5,0(r4)
 2006b40:	18c00104 	addi	r3,r3,4
 2006b44:	21000104 	addi	r4,r4,4
 2006b48:	197fff15 	stw	r5,-4(r3)
 2006b4c:	223ffb36 	bltu	r4,r8,2006b3c <__alt_mem_mem_0+0xfcfe6b3c>
 2006b50:	003fe606 	br	2006aec <__alt_mem_mem_0+0xfcfe6aec>
 2006b54:	9c000084 	addi	r16,r19,2
 2006b58:	003fe406 	br	2006aec <__alt_mem_mem_0+0xfcfe6aec>

02006b5c <__mcmp>:
 2006b5c:	20800417 	ldw	r2,16(r4)
 2006b60:	28c00417 	ldw	r3,16(r5)
 2006b64:	10c5c83a 	sub	r2,r2,r3
 2006b68:	1000111e 	bne	r2,zero,2006bb0 <__mcmp+0x54>
 2006b6c:	18c7883a 	add	r3,r3,r3
 2006b70:	18c7883a 	add	r3,r3,r3
 2006b74:	21000504 	addi	r4,r4,20
 2006b78:	29400504 	addi	r5,r5,20
 2006b7c:	20c5883a 	add	r2,r4,r3
 2006b80:	28cb883a 	add	r5,r5,r3
 2006b84:	00000106 	br	2006b8c <__mcmp+0x30>
 2006b88:	20800a2e 	bgeu	r4,r2,2006bb4 <__mcmp+0x58>
 2006b8c:	10bfff04 	addi	r2,r2,-4
 2006b90:	297fff04 	addi	r5,r5,-4
 2006b94:	11800017 	ldw	r6,0(r2)
 2006b98:	28c00017 	ldw	r3,0(r5)
 2006b9c:	30fffa26 	beq	r6,r3,2006b88 <__alt_mem_mem_0+0xfcfe6b88>
 2006ba0:	30c00236 	bltu	r6,r3,2006bac <__mcmp+0x50>
 2006ba4:	00800044 	movi	r2,1
 2006ba8:	f800283a 	ret
 2006bac:	00bfffc4 	movi	r2,-1
 2006bb0:	f800283a 	ret
 2006bb4:	0005883a 	mov	r2,zero
 2006bb8:	f800283a 	ret

02006bbc <__mdiff>:
 2006bbc:	28c00417 	ldw	r3,16(r5)
 2006bc0:	30800417 	ldw	r2,16(r6)
 2006bc4:	defffa04 	addi	sp,sp,-24
 2006bc8:	dcc00315 	stw	r19,12(sp)
 2006bcc:	dc800215 	stw	r18,8(sp)
 2006bd0:	dfc00515 	stw	ra,20(sp)
 2006bd4:	dd000415 	stw	r20,16(sp)
 2006bd8:	dc400115 	stw	r17,4(sp)
 2006bdc:	dc000015 	stw	r16,0(sp)
 2006be0:	1887c83a 	sub	r3,r3,r2
 2006be4:	2825883a 	mov	r18,r5
 2006be8:	3027883a 	mov	r19,r6
 2006bec:	1800141e 	bne	r3,zero,2006c40 <__mdiff+0x84>
 2006bf0:	1085883a 	add	r2,r2,r2
 2006bf4:	1085883a 	add	r2,r2,r2
 2006bf8:	2a000504 	addi	r8,r5,20
 2006bfc:	34000504 	addi	r16,r6,20
 2006c00:	4087883a 	add	r3,r8,r2
 2006c04:	8085883a 	add	r2,r16,r2
 2006c08:	00000106 	br	2006c10 <__mdiff+0x54>
 2006c0c:	40c0592e 	bgeu	r8,r3,2006d74 <__mdiff+0x1b8>
 2006c10:	18ffff04 	addi	r3,r3,-4
 2006c14:	10bfff04 	addi	r2,r2,-4
 2006c18:	19c00017 	ldw	r7,0(r3)
 2006c1c:	11400017 	ldw	r5,0(r2)
 2006c20:	397ffa26 	beq	r7,r5,2006c0c <__alt_mem_mem_0+0xfcfe6c0c>
 2006c24:	3940592e 	bgeu	r7,r5,2006d8c <__mdiff+0x1d0>
 2006c28:	9005883a 	mov	r2,r18
 2006c2c:	4023883a 	mov	r17,r8
 2006c30:	9825883a 	mov	r18,r19
 2006c34:	05000044 	movi	r20,1
 2006c38:	1027883a 	mov	r19,r2
 2006c3c:	00000406 	br	2006c50 <__mdiff+0x94>
 2006c40:	18005616 	blt	r3,zero,2006d9c <__mdiff+0x1e0>
 2006c44:	34400504 	addi	r17,r6,20
 2006c48:	2c000504 	addi	r16,r5,20
 2006c4c:	0029883a 	mov	r20,zero
 2006c50:	91400117 	ldw	r5,4(r18)
 2006c54:	20062940 	call	2006294 <_Balloc>
 2006c58:	92400417 	ldw	r9,16(r18)
 2006c5c:	9b000417 	ldw	r12,16(r19)
 2006c60:	12c00504 	addi	r11,r2,20
 2006c64:	4a51883a 	add	r8,r9,r9
 2006c68:	6319883a 	add	r12,r12,r12
 2006c6c:	4211883a 	add	r8,r8,r8
 2006c70:	6319883a 	add	r12,r12,r12
 2006c74:	15000315 	stw	r20,12(r2)
 2006c78:	8211883a 	add	r8,r16,r8
 2006c7c:	8b19883a 	add	r12,r17,r12
 2006c80:	0007883a 	mov	r3,zero
 2006c84:	81400017 	ldw	r5,0(r16)
 2006c88:	89c00017 	ldw	r7,0(r17)
 2006c8c:	59800104 	addi	r6,r11,4
 2006c90:	293fffcc 	andi	r4,r5,65535
 2006c94:	20c7883a 	add	r3,r4,r3
 2006c98:	393fffcc 	andi	r4,r7,65535
 2006c9c:	1909c83a 	sub	r4,r3,r4
 2006ca0:	280ad43a 	srli	r5,r5,16
 2006ca4:	380ed43a 	srli	r7,r7,16
 2006ca8:	2007d43a 	srai	r3,r4,16
 2006cac:	213fffcc 	andi	r4,r4,65535
 2006cb0:	29cbc83a 	sub	r5,r5,r7
 2006cb4:	28c7883a 	add	r3,r5,r3
 2006cb8:	180a943a 	slli	r5,r3,16
 2006cbc:	8c400104 	addi	r17,r17,4
 2006cc0:	84000104 	addi	r16,r16,4
 2006cc4:	2908b03a 	or	r4,r5,r4
 2006cc8:	59000015 	stw	r4,0(r11)
 2006ccc:	1807d43a 	srai	r3,r3,16
 2006cd0:	3015883a 	mov	r10,r6
 2006cd4:	3017883a 	mov	r11,r6
 2006cd8:	8b3fea36 	bltu	r17,r12,2006c84 <__alt_mem_mem_0+0xfcfe6c84>
 2006cdc:	8200162e 	bgeu	r16,r8,2006d38 <__mdiff+0x17c>
 2006ce0:	8017883a 	mov	r11,r16
 2006ce4:	59400017 	ldw	r5,0(r11)
 2006ce8:	31800104 	addi	r6,r6,4
 2006cec:	5ac00104 	addi	r11,r11,4
 2006cf0:	293fffcc 	andi	r4,r5,65535
 2006cf4:	20c7883a 	add	r3,r4,r3
 2006cf8:	280ed43a 	srli	r7,r5,16
 2006cfc:	180bd43a 	srai	r5,r3,16
 2006d00:	193fffcc 	andi	r4,r3,65535
 2006d04:	3947883a 	add	r3,r7,r5
 2006d08:	180a943a 	slli	r5,r3,16
 2006d0c:	1807d43a 	srai	r3,r3,16
 2006d10:	2908b03a 	or	r4,r5,r4
 2006d14:	313fff15 	stw	r4,-4(r6)
 2006d18:	5a3ff236 	bltu	r11,r8,2006ce4 <__alt_mem_mem_0+0xfcfe6ce4>
 2006d1c:	0406303a 	nor	r3,zero,r16
 2006d20:	1a07883a 	add	r3,r3,r8
 2006d24:	1806d0ba 	srli	r3,r3,2
 2006d28:	18c00044 	addi	r3,r3,1
 2006d2c:	18c7883a 	add	r3,r3,r3
 2006d30:	18c7883a 	add	r3,r3,r3
 2006d34:	50d5883a 	add	r10,r10,r3
 2006d38:	50ffff04 	addi	r3,r10,-4
 2006d3c:	2000041e 	bne	r4,zero,2006d50 <__mdiff+0x194>
 2006d40:	18ffff04 	addi	r3,r3,-4
 2006d44:	19000017 	ldw	r4,0(r3)
 2006d48:	4a7fffc4 	addi	r9,r9,-1
 2006d4c:	203ffc26 	beq	r4,zero,2006d40 <__alt_mem_mem_0+0xfcfe6d40>
 2006d50:	12400415 	stw	r9,16(r2)
 2006d54:	dfc00517 	ldw	ra,20(sp)
 2006d58:	dd000417 	ldw	r20,16(sp)
 2006d5c:	dcc00317 	ldw	r19,12(sp)
 2006d60:	dc800217 	ldw	r18,8(sp)
 2006d64:	dc400117 	ldw	r17,4(sp)
 2006d68:	dc000017 	ldw	r16,0(sp)
 2006d6c:	dec00604 	addi	sp,sp,24
 2006d70:	f800283a 	ret
 2006d74:	000b883a 	mov	r5,zero
 2006d78:	20062940 	call	2006294 <_Balloc>
 2006d7c:	00c00044 	movi	r3,1
 2006d80:	10c00415 	stw	r3,16(r2)
 2006d84:	10000515 	stw	zero,20(r2)
 2006d88:	003ff206 	br	2006d54 <__alt_mem_mem_0+0xfcfe6d54>
 2006d8c:	8023883a 	mov	r17,r16
 2006d90:	0029883a 	mov	r20,zero
 2006d94:	4021883a 	mov	r16,r8
 2006d98:	003fad06 	br	2006c50 <__alt_mem_mem_0+0xfcfe6c50>
 2006d9c:	9005883a 	mov	r2,r18
 2006da0:	94400504 	addi	r17,r18,20
 2006da4:	9c000504 	addi	r16,r19,20
 2006da8:	9825883a 	mov	r18,r19
 2006dac:	05000044 	movi	r20,1
 2006db0:	1027883a 	mov	r19,r2
 2006db4:	003fa606 	br	2006c50 <__alt_mem_mem_0+0xfcfe6c50>

02006db8 <__ulp>:
 2006db8:	295ffc2c 	andhi	r5,r5,32752
 2006dbc:	00bf3034 	movhi	r2,64704
 2006dc0:	2887883a 	add	r3,r5,r2
 2006dc4:	00c0020e 	bge	zero,r3,2006dd0 <__ulp+0x18>
 2006dc8:	0005883a 	mov	r2,zero
 2006dcc:	f800283a 	ret
 2006dd0:	00c7c83a 	sub	r3,zero,r3
 2006dd4:	1807d53a 	srai	r3,r3,20
 2006dd8:	008004c4 	movi	r2,19
 2006ddc:	10c00b0e 	bge	r2,r3,2006e0c <__ulp+0x54>
 2006de0:	18bffb04 	addi	r2,r3,-20
 2006de4:	01000784 	movi	r4,30
 2006de8:	0007883a 	mov	r3,zero
 2006dec:	20800516 	blt	r4,r2,2006e04 <__ulp+0x4c>
 2006df0:	010007c4 	movi	r4,31
 2006df4:	2089c83a 	sub	r4,r4,r2
 2006df8:	00800044 	movi	r2,1
 2006dfc:	1104983a 	sll	r2,r2,r4
 2006e00:	f800283a 	ret
 2006e04:	00800044 	movi	r2,1
 2006e08:	f800283a 	ret
 2006e0c:	01400234 	movhi	r5,8
 2006e10:	28c7d83a 	sra	r3,r5,r3
 2006e14:	0005883a 	mov	r2,zero
 2006e18:	f800283a 	ret

02006e1c <__b2d>:
 2006e1c:	defffa04 	addi	sp,sp,-24
 2006e20:	dc000015 	stw	r16,0(sp)
 2006e24:	24000417 	ldw	r16,16(r4)
 2006e28:	dc400115 	stw	r17,4(sp)
 2006e2c:	24400504 	addi	r17,r4,20
 2006e30:	8421883a 	add	r16,r16,r16
 2006e34:	8421883a 	add	r16,r16,r16
 2006e38:	8c21883a 	add	r16,r17,r16
 2006e3c:	dc800215 	stw	r18,8(sp)
 2006e40:	84bfff17 	ldw	r18,-4(r16)
 2006e44:	dd000415 	stw	r20,16(sp)
 2006e48:	dcc00315 	stw	r19,12(sp)
 2006e4c:	9009883a 	mov	r4,r18
 2006e50:	2829883a 	mov	r20,r5
 2006e54:	dfc00515 	stw	ra,20(sp)
 2006e58:	20065880 	call	2006588 <__hi0bits>
 2006e5c:	00c00804 	movi	r3,32
 2006e60:	1889c83a 	sub	r4,r3,r2
 2006e64:	a1000015 	stw	r4,0(r20)
 2006e68:	01000284 	movi	r4,10
 2006e6c:	84ffff04 	addi	r19,r16,-4
 2006e70:	20801216 	blt	r4,r2,2006ebc <__b2d+0xa0>
 2006e74:	018002c4 	movi	r6,11
 2006e78:	308dc83a 	sub	r6,r6,r2
 2006e7c:	9186d83a 	srl	r3,r18,r6
 2006e80:	18cffc34 	orhi	r3,r3,16368
 2006e84:	8cc0212e 	bgeu	r17,r19,2006f0c <__b2d+0xf0>
 2006e88:	813ffe17 	ldw	r4,-8(r16)
 2006e8c:	218cd83a 	srl	r6,r4,r6
 2006e90:	10800544 	addi	r2,r2,21
 2006e94:	9084983a 	sll	r2,r18,r2
 2006e98:	1184b03a 	or	r2,r2,r6
 2006e9c:	dfc00517 	ldw	ra,20(sp)
 2006ea0:	dd000417 	ldw	r20,16(sp)
 2006ea4:	dcc00317 	ldw	r19,12(sp)
 2006ea8:	dc800217 	ldw	r18,8(sp)
 2006eac:	dc400117 	ldw	r17,4(sp)
 2006eb0:	dc000017 	ldw	r16,0(sp)
 2006eb4:	dec00604 	addi	sp,sp,24
 2006eb8:	f800283a 	ret
 2006ebc:	8cc00f2e 	bgeu	r17,r19,2006efc <__b2d+0xe0>
 2006ec0:	117ffd44 	addi	r5,r2,-11
 2006ec4:	80bffe17 	ldw	r2,-8(r16)
 2006ec8:	28000e26 	beq	r5,zero,2006f04 <__b2d+0xe8>
 2006ecc:	1949c83a 	sub	r4,r3,r5
 2006ed0:	9164983a 	sll	r18,r18,r5
 2006ed4:	1106d83a 	srl	r3,r2,r4
 2006ed8:	81bffe04 	addi	r6,r16,-8
 2006edc:	948ffc34 	orhi	r18,r18,16368
 2006ee0:	90c6b03a 	or	r3,r18,r3
 2006ee4:	89800e2e 	bgeu	r17,r6,2006f20 <__b2d+0x104>
 2006ee8:	81bffd17 	ldw	r6,-12(r16)
 2006eec:	1144983a 	sll	r2,r2,r5
 2006ef0:	310ad83a 	srl	r5,r6,r4
 2006ef4:	2884b03a 	or	r2,r5,r2
 2006ef8:	003fe806 	br	2006e9c <__alt_mem_mem_0+0xfcfe6e9c>
 2006efc:	10bffd44 	addi	r2,r2,-11
 2006f00:	1000041e 	bne	r2,zero,2006f14 <__b2d+0xf8>
 2006f04:	90cffc34 	orhi	r3,r18,16368
 2006f08:	003fe406 	br	2006e9c <__alt_mem_mem_0+0xfcfe6e9c>
 2006f0c:	000d883a 	mov	r6,zero
 2006f10:	003fdf06 	br	2006e90 <__alt_mem_mem_0+0xfcfe6e90>
 2006f14:	90a4983a 	sll	r18,r18,r2
 2006f18:	0005883a 	mov	r2,zero
 2006f1c:	003ff906 	br	2006f04 <__alt_mem_mem_0+0xfcfe6f04>
 2006f20:	1144983a 	sll	r2,r2,r5
 2006f24:	003fdd06 	br	2006e9c <__alt_mem_mem_0+0xfcfe6e9c>

02006f28 <__d2b>:
 2006f28:	defff804 	addi	sp,sp,-32
 2006f2c:	dc000215 	stw	r16,8(sp)
 2006f30:	3021883a 	mov	r16,r6
 2006f34:	dc400315 	stw	r17,12(sp)
 2006f38:	8022907a 	slli	r17,r16,1
 2006f3c:	dd000615 	stw	r20,24(sp)
 2006f40:	2829883a 	mov	r20,r5
 2006f44:	01400044 	movi	r5,1
 2006f48:	dcc00515 	stw	r19,20(sp)
 2006f4c:	dc800415 	stw	r18,16(sp)
 2006f50:	dfc00715 	stw	ra,28(sp)
 2006f54:	3825883a 	mov	r18,r7
 2006f58:	8822d57a 	srli	r17,r17,21
 2006f5c:	20062940 	call	2006294 <_Balloc>
 2006f60:	1027883a 	mov	r19,r2
 2006f64:	00800434 	movhi	r2,16
 2006f68:	10bfffc4 	addi	r2,r2,-1
 2006f6c:	808c703a 	and	r6,r16,r2
 2006f70:	88000126 	beq	r17,zero,2006f78 <__d2b+0x50>
 2006f74:	31800434 	orhi	r6,r6,16
 2006f78:	d9800015 	stw	r6,0(sp)
 2006f7c:	a0002426 	beq	r20,zero,2007010 <__d2b+0xe8>
 2006f80:	d9000104 	addi	r4,sp,4
 2006f84:	dd000115 	stw	r20,4(sp)
 2006f88:	20065f00 	call	20065f0 <__lo0bits>
 2006f8c:	d8c00017 	ldw	r3,0(sp)
 2006f90:	10002f1e 	bne	r2,zero,2007050 <__d2b+0x128>
 2006f94:	d9000117 	ldw	r4,4(sp)
 2006f98:	99000515 	stw	r4,20(r19)
 2006f9c:	1821003a 	cmpeq	r16,r3,zero
 2006fa0:	01000084 	movi	r4,2
 2006fa4:	2421c83a 	sub	r16,r4,r16
 2006fa8:	98c00615 	stw	r3,24(r19)
 2006fac:	9c000415 	stw	r16,16(r19)
 2006fb0:	88001f1e 	bne	r17,zero,2007030 <__d2b+0x108>
 2006fb4:	10bef384 	addi	r2,r2,-1074
 2006fb8:	90800015 	stw	r2,0(r18)
 2006fbc:	00900034 	movhi	r2,16384
 2006fc0:	10bfffc4 	addi	r2,r2,-1
 2006fc4:	8085883a 	add	r2,r16,r2
 2006fc8:	1085883a 	add	r2,r2,r2
 2006fcc:	1085883a 	add	r2,r2,r2
 2006fd0:	9885883a 	add	r2,r19,r2
 2006fd4:	11000517 	ldw	r4,20(r2)
 2006fd8:	8020917a 	slli	r16,r16,5
 2006fdc:	20065880 	call	2006588 <__hi0bits>
 2006fe0:	d8c00817 	ldw	r3,32(sp)
 2006fe4:	8085c83a 	sub	r2,r16,r2
 2006fe8:	18800015 	stw	r2,0(r3)
 2006fec:	9805883a 	mov	r2,r19
 2006ff0:	dfc00717 	ldw	ra,28(sp)
 2006ff4:	dd000617 	ldw	r20,24(sp)
 2006ff8:	dcc00517 	ldw	r19,20(sp)
 2006ffc:	dc800417 	ldw	r18,16(sp)
 2007000:	dc400317 	ldw	r17,12(sp)
 2007004:	dc000217 	ldw	r16,8(sp)
 2007008:	dec00804 	addi	sp,sp,32
 200700c:	f800283a 	ret
 2007010:	d809883a 	mov	r4,sp
 2007014:	20065f00 	call	20065f0 <__lo0bits>
 2007018:	d8c00017 	ldw	r3,0(sp)
 200701c:	04000044 	movi	r16,1
 2007020:	9c000415 	stw	r16,16(r19)
 2007024:	98c00515 	stw	r3,20(r19)
 2007028:	10800804 	addi	r2,r2,32
 200702c:	883fe126 	beq	r17,zero,2006fb4 <__alt_mem_mem_0+0xfcfe6fb4>
 2007030:	00c00d44 	movi	r3,53
 2007034:	8c7ef344 	addi	r17,r17,-1075
 2007038:	88a3883a 	add	r17,r17,r2
 200703c:	1885c83a 	sub	r2,r3,r2
 2007040:	d8c00817 	ldw	r3,32(sp)
 2007044:	94400015 	stw	r17,0(r18)
 2007048:	18800015 	stw	r2,0(r3)
 200704c:	003fe706 	br	2006fec <__alt_mem_mem_0+0xfcfe6fec>
 2007050:	01000804 	movi	r4,32
 2007054:	2089c83a 	sub	r4,r4,r2
 2007058:	1908983a 	sll	r4,r3,r4
 200705c:	d9400117 	ldw	r5,4(sp)
 2007060:	1886d83a 	srl	r3,r3,r2
 2007064:	2148b03a 	or	r4,r4,r5
 2007068:	99000515 	stw	r4,20(r19)
 200706c:	d8c00015 	stw	r3,0(sp)
 2007070:	003fca06 	br	2006f9c <__alt_mem_mem_0+0xfcfe6f9c>

02007074 <__ratio>:
 2007074:	defff904 	addi	sp,sp,-28
 2007078:	dc400315 	stw	r17,12(sp)
 200707c:	2823883a 	mov	r17,r5
 2007080:	d9400104 	addi	r5,sp,4
 2007084:	dfc00615 	stw	ra,24(sp)
 2007088:	dcc00515 	stw	r19,20(sp)
 200708c:	dc800415 	stw	r18,16(sp)
 2007090:	2027883a 	mov	r19,r4
 2007094:	dc000215 	stw	r16,8(sp)
 2007098:	2006e1c0 	call	2006e1c <__b2d>
 200709c:	d80b883a 	mov	r5,sp
 20070a0:	8809883a 	mov	r4,r17
 20070a4:	1025883a 	mov	r18,r2
 20070a8:	1821883a 	mov	r16,r3
 20070ac:	2006e1c0 	call	2006e1c <__b2d>
 20070b0:	8a000417 	ldw	r8,16(r17)
 20070b4:	99000417 	ldw	r4,16(r19)
 20070b8:	d9400117 	ldw	r5,4(sp)
 20070bc:	2209c83a 	sub	r4,r4,r8
 20070c0:	2010917a 	slli	r8,r4,5
 20070c4:	d9000017 	ldw	r4,0(sp)
 20070c8:	2909c83a 	sub	r4,r5,r4
 20070cc:	4109883a 	add	r4,r8,r4
 20070d0:	01000e0e 	bge	zero,r4,200710c <__ratio+0x98>
 20070d4:	2008953a 	slli	r4,r4,20
 20070d8:	2421883a 	add	r16,r4,r16
 20070dc:	100d883a 	mov	r6,r2
 20070e0:	180f883a 	mov	r7,r3
 20070e4:	9009883a 	mov	r4,r18
 20070e8:	800b883a 	mov	r5,r16
 20070ec:	200b6100 	call	200b610 <__divdf3>
 20070f0:	dfc00617 	ldw	ra,24(sp)
 20070f4:	dcc00517 	ldw	r19,20(sp)
 20070f8:	dc800417 	ldw	r18,16(sp)
 20070fc:	dc400317 	ldw	r17,12(sp)
 2007100:	dc000217 	ldw	r16,8(sp)
 2007104:	dec00704 	addi	sp,sp,28
 2007108:	f800283a 	ret
 200710c:	2008953a 	slli	r4,r4,20
 2007110:	1907c83a 	sub	r3,r3,r4
 2007114:	003ff106 	br	20070dc <__alt_mem_mem_0+0xfcfe70dc>

02007118 <_mprec_log10>:
 2007118:	defffe04 	addi	sp,sp,-8
 200711c:	dc000015 	stw	r16,0(sp)
 2007120:	dfc00115 	stw	ra,4(sp)
 2007124:	008005c4 	movi	r2,23
 2007128:	2021883a 	mov	r16,r4
 200712c:	11000d0e 	bge	r2,r4,2007164 <_mprec_log10+0x4c>
 2007130:	0005883a 	mov	r2,zero
 2007134:	00cffc34 	movhi	r3,16368
 2007138:	843fffc4 	addi	r16,r16,-1
 200713c:	000d883a 	mov	r6,zero
 2007140:	01d00934 	movhi	r7,16420
 2007144:	1009883a 	mov	r4,r2
 2007148:	180b883a 	mov	r5,r3
 200714c:	200c1500 	call	200c150 <__muldf3>
 2007150:	803ff91e 	bne	r16,zero,2007138 <__alt_mem_mem_0+0xfcfe7138>
 2007154:	dfc00117 	ldw	ra,4(sp)
 2007158:	dc000017 	ldw	r16,0(sp)
 200715c:	dec00204 	addi	sp,sp,8
 2007160:	f800283a 	ret
 2007164:	202090fa 	slli	r16,r4,3
 2007168:	00808134 	movhi	r2,516
 200716c:	1083fd04 	addi	r2,r2,4084
 2007170:	1421883a 	add	r16,r2,r16
 2007174:	80800017 	ldw	r2,0(r16)
 2007178:	80c00117 	ldw	r3,4(r16)
 200717c:	dfc00117 	ldw	ra,4(sp)
 2007180:	dc000017 	ldw	r16,0(sp)
 2007184:	dec00204 	addi	sp,sp,8
 2007188:	f800283a 	ret

0200718c <__copybits>:
 200718c:	297fffc4 	addi	r5,r5,-1
 2007190:	280fd17a 	srai	r7,r5,5
 2007194:	30c00417 	ldw	r3,16(r6)
 2007198:	30800504 	addi	r2,r6,20
 200719c:	39c00044 	addi	r7,r7,1
 20071a0:	18c7883a 	add	r3,r3,r3
 20071a4:	39cf883a 	add	r7,r7,r7
 20071a8:	18c7883a 	add	r3,r3,r3
 20071ac:	39cf883a 	add	r7,r7,r7
 20071b0:	10c7883a 	add	r3,r2,r3
 20071b4:	21cf883a 	add	r7,r4,r7
 20071b8:	10c00d2e 	bgeu	r2,r3,20071f0 <__copybits+0x64>
 20071bc:	200b883a 	mov	r5,r4
 20071c0:	12000017 	ldw	r8,0(r2)
 20071c4:	29400104 	addi	r5,r5,4
 20071c8:	10800104 	addi	r2,r2,4
 20071cc:	2a3fff15 	stw	r8,-4(r5)
 20071d0:	10fffb36 	bltu	r2,r3,20071c0 <__alt_mem_mem_0+0xfcfe71c0>
 20071d4:	1985c83a 	sub	r2,r3,r6
 20071d8:	10bffac4 	addi	r2,r2,-21
 20071dc:	1004d0ba 	srli	r2,r2,2
 20071e0:	10800044 	addi	r2,r2,1
 20071e4:	1085883a 	add	r2,r2,r2
 20071e8:	1085883a 	add	r2,r2,r2
 20071ec:	2089883a 	add	r4,r4,r2
 20071f0:	21c0032e 	bgeu	r4,r7,2007200 <__copybits+0x74>
 20071f4:	20000015 	stw	zero,0(r4)
 20071f8:	21000104 	addi	r4,r4,4
 20071fc:	21fffd36 	bltu	r4,r7,20071f4 <__alt_mem_mem_0+0xfcfe71f4>
 2007200:	f800283a 	ret

02007204 <__any_on>:
 2007204:	20c00417 	ldw	r3,16(r4)
 2007208:	2805d17a 	srai	r2,r5,5
 200720c:	21000504 	addi	r4,r4,20
 2007210:	18800d0e 	bge	r3,r2,2007248 <__any_on+0x44>
 2007214:	18c7883a 	add	r3,r3,r3
 2007218:	18c7883a 	add	r3,r3,r3
 200721c:	20c7883a 	add	r3,r4,r3
 2007220:	20c0192e 	bgeu	r4,r3,2007288 <__any_on+0x84>
 2007224:	18bfff17 	ldw	r2,-4(r3)
 2007228:	18ffff04 	addi	r3,r3,-4
 200722c:	1000041e 	bne	r2,zero,2007240 <__any_on+0x3c>
 2007230:	20c0142e 	bgeu	r4,r3,2007284 <__any_on+0x80>
 2007234:	18ffff04 	addi	r3,r3,-4
 2007238:	19400017 	ldw	r5,0(r3)
 200723c:	283ffc26 	beq	r5,zero,2007230 <__alt_mem_mem_0+0xfcfe7230>
 2007240:	00800044 	movi	r2,1
 2007244:	f800283a 	ret
 2007248:	10c00a0e 	bge	r2,r3,2007274 <__any_on+0x70>
 200724c:	1085883a 	add	r2,r2,r2
 2007250:	1085883a 	add	r2,r2,r2
 2007254:	294007cc 	andi	r5,r5,31
 2007258:	2087883a 	add	r3,r4,r2
 200725c:	283ff026 	beq	r5,zero,2007220 <__alt_mem_mem_0+0xfcfe7220>
 2007260:	19800017 	ldw	r6,0(r3)
 2007264:	3144d83a 	srl	r2,r6,r5
 2007268:	114a983a 	sll	r5,r2,r5
 200726c:	317ff41e 	bne	r6,r5,2007240 <__alt_mem_mem_0+0xfcfe7240>
 2007270:	003feb06 	br	2007220 <__alt_mem_mem_0+0xfcfe7220>
 2007274:	1085883a 	add	r2,r2,r2
 2007278:	1085883a 	add	r2,r2,r2
 200727c:	2087883a 	add	r3,r4,r2
 2007280:	003fe706 	br	2007220 <__alt_mem_mem_0+0xfcfe7220>
 2007284:	f800283a 	ret
 2007288:	0005883a 	mov	r2,zero
 200728c:	f800283a 	ret

02007290 <__fpclassifyd>:
 2007290:	00a00034 	movhi	r2,32768
 2007294:	10bfffc4 	addi	r2,r2,-1
 2007298:	2884703a 	and	r2,r5,r2
 200729c:	10000726 	beq	r2,zero,20072bc <__fpclassifyd+0x2c>
 20072a0:	00fffc34 	movhi	r3,65520
 20072a4:	019ff834 	movhi	r6,32736
 20072a8:	28c7883a 	add	r3,r5,r3
 20072ac:	31bfffc4 	addi	r6,r6,-1
 20072b0:	30c00536 	bltu	r6,r3,20072c8 <__fpclassifyd+0x38>
 20072b4:	00800104 	movi	r2,4
 20072b8:	f800283a 	ret
 20072bc:	2000021e 	bne	r4,zero,20072c8 <__fpclassifyd+0x38>
 20072c0:	00800084 	movi	r2,2
 20072c4:	f800283a 	ret
 20072c8:	00dffc34 	movhi	r3,32752
 20072cc:	019ff834 	movhi	r6,32736
 20072d0:	28cb883a 	add	r5,r5,r3
 20072d4:	31bfffc4 	addi	r6,r6,-1
 20072d8:	317ff62e 	bgeu	r6,r5,20072b4 <__alt_mem_mem_0+0xfcfe72b4>
 20072dc:	01400434 	movhi	r5,16
 20072e0:	297fffc4 	addi	r5,r5,-1
 20072e4:	28800236 	bltu	r5,r2,20072f0 <__fpclassifyd+0x60>
 20072e8:	008000c4 	movi	r2,3
 20072ec:	f800283a 	ret
 20072f0:	10c00226 	beq	r2,r3,20072fc <__fpclassifyd+0x6c>
 20072f4:	0005883a 	mov	r2,zero
 20072f8:	f800283a 	ret
 20072fc:	2005003a 	cmpeq	r2,r4,zero
 2007300:	f800283a 	ret

02007304 <_sbrk_r>:
 2007304:	defffd04 	addi	sp,sp,-12
 2007308:	dc000015 	stw	r16,0(sp)
 200730c:	04008134 	movhi	r16,516
 2007310:	dc400115 	stw	r17,4(sp)
 2007314:	841e0a04 	addi	r16,r16,30760
 2007318:	2023883a 	mov	r17,r4
 200731c:	2809883a 	mov	r4,r5
 2007320:	dfc00215 	stw	ra,8(sp)
 2007324:	80000015 	stw	zero,0(r16)
 2007328:	20130d40 	call	20130d4 <sbrk>
 200732c:	00ffffc4 	movi	r3,-1
 2007330:	10c00526 	beq	r2,r3,2007348 <_sbrk_r+0x44>
 2007334:	dfc00217 	ldw	ra,8(sp)
 2007338:	dc400117 	ldw	r17,4(sp)
 200733c:	dc000017 	ldw	r16,0(sp)
 2007340:	dec00304 	addi	sp,sp,12
 2007344:	f800283a 	ret
 2007348:	80c00017 	ldw	r3,0(r16)
 200734c:	183ff926 	beq	r3,zero,2007334 <__alt_mem_mem_0+0xfcfe7334>
 2007350:	88c00015 	stw	r3,0(r17)
 2007354:	003ff706 	br	2007334 <__alt_mem_mem_0+0xfcfe7334>

02007358 <__sread>:
 2007358:	defffe04 	addi	sp,sp,-8
 200735c:	dc000015 	stw	r16,0(sp)
 2007360:	2821883a 	mov	r16,r5
 2007364:	2940038f 	ldh	r5,14(r5)
 2007368:	dfc00115 	stw	ra,4(sp)
 200736c:	20097fc0 	call	20097fc <_read_r>
 2007370:	10000716 	blt	r2,zero,2007390 <__sread+0x38>
 2007374:	80c01417 	ldw	r3,80(r16)
 2007378:	1887883a 	add	r3,r3,r2
 200737c:	80c01415 	stw	r3,80(r16)
 2007380:	dfc00117 	ldw	ra,4(sp)
 2007384:	dc000017 	ldw	r16,0(sp)
 2007388:	dec00204 	addi	sp,sp,8
 200738c:	f800283a 	ret
 2007390:	80c0030b 	ldhu	r3,12(r16)
 2007394:	18fbffcc 	andi	r3,r3,61439
 2007398:	80c0030d 	sth	r3,12(r16)
 200739c:	dfc00117 	ldw	ra,4(sp)
 20073a0:	dc000017 	ldw	r16,0(sp)
 20073a4:	dec00204 	addi	sp,sp,8
 20073a8:	f800283a 	ret

020073ac <__seofread>:
 20073ac:	0005883a 	mov	r2,zero
 20073b0:	f800283a 	ret

020073b4 <__swrite>:
 20073b4:	2880030b 	ldhu	r2,12(r5)
 20073b8:	defffb04 	addi	sp,sp,-20
 20073bc:	dcc00315 	stw	r19,12(sp)
 20073c0:	dc800215 	stw	r18,8(sp)
 20073c4:	dc400115 	stw	r17,4(sp)
 20073c8:	dc000015 	stw	r16,0(sp)
 20073cc:	dfc00415 	stw	ra,16(sp)
 20073d0:	10c0400c 	andi	r3,r2,256
 20073d4:	2821883a 	mov	r16,r5
 20073d8:	2023883a 	mov	r17,r4
 20073dc:	3025883a 	mov	r18,r6
 20073e0:	3827883a 	mov	r19,r7
 20073e4:	18000526 	beq	r3,zero,20073fc <__swrite+0x48>
 20073e8:	2940038f 	ldh	r5,14(r5)
 20073ec:	01c00084 	movi	r7,2
 20073f0:	000d883a 	mov	r6,zero
 20073f4:	20096400 	call	2009640 <_lseek_r>
 20073f8:	8080030b 	ldhu	r2,12(r16)
 20073fc:	8140038f 	ldh	r5,14(r16)
 2007400:	10bbffcc 	andi	r2,r2,61439
 2007404:	980f883a 	mov	r7,r19
 2007408:	900d883a 	mov	r6,r18
 200740c:	8809883a 	mov	r4,r17
 2007410:	8080030d 	sth	r2,12(r16)
 2007414:	dfc00417 	ldw	ra,16(sp)
 2007418:	dcc00317 	ldw	r19,12(sp)
 200741c:	dc800217 	ldw	r18,8(sp)
 2007420:	dc400117 	ldw	r17,4(sp)
 2007424:	dc000017 	ldw	r16,0(sp)
 2007428:	dec00504 	addi	sp,sp,20
 200742c:	2008c501 	jmpi	2008c50 <_write_r>

02007430 <__sseek>:
 2007430:	defffe04 	addi	sp,sp,-8
 2007434:	dc000015 	stw	r16,0(sp)
 2007438:	2821883a 	mov	r16,r5
 200743c:	2940038f 	ldh	r5,14(r5)
 2007440:	dfc00115 	stw	ra,4(sp)
 2007444:	20096400 	call	2009640 <_lseek_r>
 2007448:	00ffffc4 	movi	r3,-1
 200744c:	10c00826 	beq	r2,r3,2007470 <__sseek+0x40>
 2007450:	80c0030b 	ldhu	r3,12(r16)
 2007454:	80801415 	stw	r2,80(r16)
 2007458:	18c40014 	ori	r3,r3,4096
 200745c:	80c0030d 	sth	r3,12(r16)
 2007460:	dfc00117 	ldw	ra,4(sp)
 2007464:	dc000017 	ldw	r16,0(sp)
 2007468:	dec00204 	addi	sp,sp,8
 200746c:	f800283a 	ret
 2007470:	80c0030b 	ldhu	r3,12(r16)
 2007474:	18fbffcc 	andi	r3,r3,61439
 2007478:	80c0030d 	sth	r3,12(r16)
 200747c:	dfc00117 	ldw	ra,4(sp)
 2007480:	dc000017 	ldw	r16,0(sp)
 2007484:	dec00204 	addi	sp,sp,8
 2007488:	f800283a 	ret

0200748c <__sclose>:
 200748c:	2940038f 	ldh	r5,14(r5)
 2007490:	2008cb01 	jmpi	2008cb0 <_close_r>

02007494 <strcmp>:
 2007494:	2144b03a 	or	r2,r4,r5
 2007498:	108000cc 	andi	r2,r2,3
 200749c:	1000171e 	bne	r2,zero,20074fc <strcmp+0x68>
 20074a0:	20800017 	ldw	r2,0(r4)
 20074a4:	28c00017 	ldw	r3,0(r5)
 20074a8:	10c0141e 	bne	r2,r3,20074fc <strcmp+0x68>
 20074ac:	027fbff4 	movhi	r9,65279
 20074b0:	4a7fbfc4 	addi	r9,r9,-257
 20074b4:	0086303a 	nor	r3,zero,r2
 20074b8:	02202074 	movhi	r8,32897
 20074bc:	1245883a 	add	r2,r2,r9
 20074c0:	42202004 	addi	r8,r8,-32640
 20074c4:	10c4703a 	and	r2,r2,r3
 20074c8:	1204703a 	and	r2,r2,r8
 20074cc:	10000226 	beq	r2,zero,20074d8 <strcmp+0x44>
 20074d0:	00002306 	br	2007560 <strcmp+0xcc>
 20074d4:	1000221e 	bne	r2,zero,2007560 <strcmp+0xcc>
 20074d8:	21000104 	addi	r4,r4,4
 20074dc:	20c00017 	ldw	r3,0(r4)
 20074e0:	29400104 	addi	r5,r5,4
 20074e4:	29800017 	ldw	r6,0(r5)
 20074e8:	1a4f883a 	add	r7,r3,r9
 20074ec:	00c4303a 	nor	r2,zero,r3
 20074f0:	3884703a 	and	r2,r7,r2
 20074f4:	1204703a 	and	r2,r2,r8
 20074f8:	19bff626 	beq	r3,r6,20074d4 <__alt_mem_mem_0+0xfcfe74d4>
 20074fc:	20800003 	ldbu	r2,0(r4)
 2007500:	10c03fcc 	andi	r3,r2,255
 2007504:	18c0201c 	xori	r3,r3,128
 2007508:	18ffe004 	addi	r3,r3,-128
 200750c:	18000c26 	beq	r3,zero,2007540 <strcmp+0xac>
 2007510:	29800007 	ldb	r6,0(r5)
 2007514:	19800326 	beq	r3,r6,2007524 <strcmp+0x90>
 2007518:	00001306 	br	2007568 <strcmp+0xd4>
 200751c:	29800007 	ldb	r6,0(r5)
 2007520:	11800b1e 	bne	r2,r6,2007550 <strcmp+0xbc>
 2007524:	21000044 	addi	r4,r4,1
 2007528:	20c00003 	ldbu	r3,0(r4)
 200752c:	29400044 	addi	r5,r5,1
 2007530:	18803fcc 	andi	r2,r3,255
 2007534:	1080201c 	xori	r2,r2,128
 2007538:	10bfe004 	addi	r2,r2,-128
 200753c:	103ff71e 	bne	r2,zero,200751c <__alt_mem_mem_0+0xfcfe751c>
 2007540:	0007883a 	mov	r3,zero
 2007544:	28800003 	ldbu	r2,0(r5)
 2007548:	1885c83a 	sub	r2,r3,r2
 200754c:	f800283a 	ret
 2007550:	28800003 	ldbu	r2,0(r5)
 2007554:	18c03fcc 	andi	r3,r3,255
 2007558:	1885c83a 	sub	r2,r3,r2
 200755c:	f800283a 	ret
 2007560:	0005883a 	mov	r2,zero
 2007564:	f800283a 	ret
 2007568:	10c03fcc 	andi	r3,r2,255
 200756c:	003ff506 	br	2007544 <__alt_mem_mem_0+0xfcfe7544>

02007570 <strlen>:
 2007570:	208000cc 	andi	r2,r4,3
 2007574:	10002026 	beq	r2,zero,20075f8 <strlen+0x88>
 2007578:	20800007 	ldb	r2,0(r4)
 200757c:	10002026 	beq	r2,zero,2007600 <strlen+0x90>
 2007580:	2005883a 	mov	r2,r4
 2007584:	00000206 	br	2007590 <strlen+0x20>
 2007588:	10c00007 	ldb	r3,0(r2)
 200758c:	18001826 	beq	r3,zero,20075f0 <strlen+0x80>
 2007590:	10800044 	addi	r2,r2,1
 2007594:	10c000cc 	andi	r3,r2,3
 2007598:	183ffb1e 	bne	r3,zero,2007588 <__alt_mem_mem_0+0xfcfe7588>
 200759c:	10c00017 	ldw	r3,0(r2)
 20075a0:	01ffbff4 	movhi	r7,65279
 20075a4:	39ffbfc4 	addi	r7,r7,-257
 20075a8:	00ca303a 	nor	r5,zero,r3
 20075ac:	01a02074 	movhi	r6,32897
 20075b0:	19c7883a 	add	r3,r3,r7
 20075b4:	31a02004 	addi	r6,r6,-32640
 20075b8:	1946703a 	and	r3,r3,r5
 20075bc:	1986703a 	and	r3,r3,r6
 20075c0:	1800091e 	bne	r3,zero,20075e8 <strlen+0x78>
 20075c4:	10800104 	addi	r2,r2,4
 20075c8:	10c00017 	ldw	r3,0(r2)
 20075cc:	19cb883a 	add	r5,r3,r7
 20075d0:	00c6303a 	nor	r3,zero,r3
 20075d4:	28c6703a 	and	r3,r5,r3
 20075d8:	1986703a 	and	r3,r3,r6
 20075dc:	183ff926 	beq	r3,zero,20075c4 <__alt_mem_mem_0+0xfcfe75c4>
 20075e0:	00000106 	br	20075e8 <strlen+0x78>
 20075e4:	10800044 	addi	r2,r2,1
 20075e8:	10c00007 	ldb	r3,0(r2)
 20075ec:	183ffd1e 	bne	r3,zero,20075e4 <__alt_mem_mem_0+0xfcfe75e4>
 20075f0:	1105c83a 	sub	r2,r2,r4
 20075f4:	f800283a 	ret
 20075f8:	2005883a 	mov	r2,r4
 20075fc:	003fe706 	br	200759c <__alt_mem_mem_0+0xfcfe759c>
 2007600:	0005883a 	mov	r2,zero
 2007604:	f800283a 	ret

02007608 <__sprint_r.part.0>:
 2007608:	28801917 	ldw	r2,100(r5)
 200760c:	defff604 	addi	sp,sp,-40
 2007610:	dd400515 	stw	r21,20(sp)
 2007614:	dfc00915 	stw	ra,36(sp)
 2007618:	df000815 	stw	fp,32(sp)
 200761c:	ddc00715 	stw	r23,28(sp)
 2007620:	dd800615 	stw	r22,24(sp)
 2007624:	dd000415 	stw	r20,16(sp)
 2007628:	dcc00315 	stw	r19,12(sp)
 200762c:	dc800215 	stw	r18,8(sp)
 2007630:	dc400115 	stw	r17,4(sp)
 2007634:	dc000015 	stw	r16,0(sp)
 2007638:	1088000c 	andi	r2,r2,8192
 200763c:	302b883a 	mov	r21,r6
 2007640:	10002e26 	beq	r2,zero,20076fc <__sprint_r.part.0+0xf4>
 2007644:	30800217 	ldw	r2,8(r6)
 2007648:	35800017 	ldw	r22,0(r6)
 200764c:	10002926 	beq	r2,zero,20076f4 <__sprint_r.part.0+0xec>
 2007650:	2827883a 	mov	r19,r5
 2007654:	2029883a 	mov	r20,r4
 2007658:	b5c00104 	addi	r23,r22,4
 200765c:	04bfffc4 	movi	r18,-1
 2007660:	bc400017 	ldw	r17,0(r23)
 2007664:	b4000017 	ldw	r16,0(r22)
 2007668:	0039883a 	mov	fp,zero
 200766c:	8822d0ba 	srli	r17,r17,2
 2007670:	8800031e 	bne	r17,zero,2007680 <__sprint_r.part.0+0x78>
 2007674:	00001806 	br	20076d8 <__sprint_r.part.0+0xd0>
 2007678:	84000104 	addi	r16,r16,4
 200767c:	8f001526 	beq	r17,fp,20076d4 <__sprint_r.part.0+0xcc>
 2007680:	81400017 	ldw	r5,0(r16)
 2007684:	980d883a 	mov	r6,r19
 2007688:	a009883a 	mov	r4,r20
 200768c:	20090300 	call	2009030 <_fputwc_r>
 2007690:	e7000044 	addi	fp,fp,1
 2007694:	14bff81e 	bne	r2,r18,2007678 <__alt_mem_mem_0+0xfcfe7678>
 2007698:	9005883a 	mov	r2,r18
 200769c:	a8000215 	stw	zero,8(r21)
 20076a0:	a8000115 	stw	zero,4(r21)
 20076a4:	dfc00917 	ldw	ra,36(sp)
 20076a8:	df000817 	ldw	fp,32(sp)
 20076ac:	ddc00717 	ldw	r23,28(sp)
 20076b0:	dd800617 	ldw	r22,24(sp)
 20076b4:	dd400517 	ldw	r21,20(sp)
 20076b8:	dd000417 	ldw	r20,16(sp)
 20076bc:	dcc00317 	ldw	r19,12(sp)
 20076c0:	dc800217 	ldw	r18,8(sp)
 20076c4:	dc400117 	ldw	r17,4(sp)
 20076c8:	dc000017 	ldw	r16,0(sp)
 20076cc:	dec00a04 	addi	sp,sp,40
 20076d0:	f800283a 	ret
 20076d4:	a8800217 	ldw	r2,8(r21)
 20076d8:	8c63883a 	add	r17,r17,r17
 20076dc:	8c63883a 	add	r17,r17,r17
 20076e0:	1445c83a 	sub	r2,r2,r17
 20076e4:	a8800215 	stw	r2,8(r21)
 20076e8:	b5800204 	addi	r22,r22,8
 20076ec:	bdc00204 	addi	r23,r23,8
 20076f0:	103fdb1e 	bne	r2,zero,2007660 <__alt_mem_mem_0+0xfcfe7660>
 20076f4:	0005883a 	mov	r2,zero
 20076f8:	003fe806 	br	200769c <__alt_mem_mem_0+0xfcfe769c>
 20076fc:	20091300 	call	2009130 <__sfvwrite_r>
 2007700:	003fe606 	br	200769c <__alt_mem_mem_0+0xfcfe769c>

02007704 <__sprint_r>:
 2007704:	30c00217 	ldw	r3,8(r6)
 2007708:	18000126 	beq	r3,zero,2007710 <__sprint_r+0xc>
 200770c:	20076081 	jmpi	2007608 <__sprint_r.part.0>
 2007710:	30000115 	stw	zero,4(r6)
 2007714:	0005883a 	mov	r2,zero
 2007718:	f800283a 	ret

0200771c <___vfiprintf_internal_r>:
 200771c:	deffc904 	addi	sp,sp,-220
 2007720:	df003515 	stw	fp,212(sp)
 2007724:	dd003115 	stw	r20,196(sp)
 2007728:	dfc03615 	stw	ra,216(sp)
 200772c:	ddc03415 	stw	r23,208(sp)
 2007730:	dd803315 	stw	r22,204(sp)
 2007734:	dd403215 	stw	r21,200(sp)
 2007738:	dcc03015 	stw	r19,192(sp)
 200773c:	dc802f15 	stw	r18,188(sp)
 2007740:	dc402e15 	stw	r17,184(sp)
 2007744:	dc002d15 	stw	r16,180(sp)
 2007748:	d9002015 	stw	r4,128(sp)
 200774c:	d9c02215 	stw	r7,136(sp)
 2007750:	2829883a 	mov	r20,r5
 2007754:	3039883a 	mov	fp,r6
 2007758:	20000226 	beq	r4,zero,2007764 <___vfiprintf_internal_r+0x48>
 200775c:	20800e17 	ldw	r2,56(r4)
 2007760:	1000cf26 	beq	r2,zero,2007aa0 <___vfiprintf_internal_r+0x384>
 2007764:	a080030b 	ldhu	r2,12(r20)
 2007768:	10c8000c 	andi	r3,r2,8192
 200776c:	1800061e 	bne	r3,zero,2007788 <___vfiprintf_internal_r+0x6c>
 2007770:	a1001917 	ldw	r4,100(r20)
 2007774:	00f7ffc4 	movi	r3,-8193
 2007778:	10880014 	ori	r2,r2,8192
 200777c:	20c6703a 	and	r3,r4,r3
 2007780:	a080030d 	sth	r2,12(r20)
 2007784:	a0c01915 	stw	r3,100(r20)
 2007788:	10c0020c 	andi	r3,r2,8
 200778c:	1800a926 	beq	r3,zero,2007a34 <___vfiprintf_internal_r+0x318>
 2007790:	a0c00417 	ldw	r3,16(r20)
 2007794:	1800a726 	beq	r3,zero,2007a34 <___vfiprintf_internal_r+0x318>
 2007798:	1080068c 	andi	r2,r2,26
 200779c:	00c00284 	movi	r3,10
 20077a0:	10c0ac26 	beq	r2,r3,2007a54 <___vfiprintf_internal_r+0x338>
 20077a4:	da801a04 	addi	r10,sp,104
 20077a8:	da801e15 	stw	r10,120(sp)
 20077ac:	d8801e17 	ldw	r2,120(sp)
 20077b0:	da8019c4 	addi	r10,sp,103
 20077b4:	05808134 	movhi	r22,516
 20077b8:	05c08134 	movhi	r23,516
 20077bc:	da801f15 	stw	r10,124(sp)
 20077c0:	1295c83a 	sub	r10,r2,r10
 20077c4:	b5843304 	addi	r22,r22,4300
 20077c8:	bdc42f04 	addi	r23,r23,4284
 20077cc:	dec01a15 	stw	sp,104(sp)
 20077d0:	d8001c15 	stw	zero,112(sp)
 20077d4:	d8001b15 	stw	zero,108(sp)
 20077d8:	d8002615 	stw	zero,152(sp)
 20077dc:	d8002315 	stw	zero,140(sp)
 20077e0:	da802715 	stw	r10,156(sp)
 20077e4:	d811883a 	mov	r8,sp
 20077e8:	dd002115 	stw	r20,132(sp)
 20077ec:	e021883a 	mov	r16,fp
 20077f0:	80800007 	ldb	r2,0(r16)
 20077f4:	1003ea26 	beq	r2,zero,20087a0 <___vfiprintf_internal_r+0x1084>
 20077f8:	00c00944 	movi	r3,37
 20077fc:	8025883a 	mov	r18,r16
 2007800:	10c0021e 	bne	r2,r3,200780c <___vfiprintf_internal_r+0xf0>
 2007804:	00001606 	br	2007860 <___vfiprintf_internal_r+0x144>
 2007808:	10c00326 	beq	r2,r3,2007818 <___vfiprintf_internal_r+0xfc>
 200780c:	94800044 	addi	r18,r18,1
 2007810:	90800007 	ldb	r2,0(r18)
 2007814:	103ffc1e 	bne	r2,zero,2007808 <__alt_mem_mem_0+0xfcfe7808>
 2007818:	9423c83a 	sub	r17,r18,r16
 200781c:	88001026 	beq	r17,zero,2007860 <___vfiprintf_internal_r+0x144>
 2007820:	d8c01c17 	ldw	r3,112(sp)
 2007824:	d8801b17 	ldw	r2,108(sp)
 2007828:	44000015 	stw	r16,0(r8)
 200782c:	88c7883a 	add	r3,r17,r3
 2007830:	10800044 	addi	r2,r2,1
 2007834:	44400115 	stw	r17,4(r8)
 2007838:	d8c01c15 	stw	r3,112(sp)
 200783c:	d8801b15 	stw	r2,108(sp)
 2007840:	010001c4 	movi	r4,7
 2007844:	2080760e 	bge	r4,r2,2007a20 <___vfiprintf_internal_r+0x304>
 2007848:	1803821e 	bne	r3,zero,2008654 <___vfiprintf_internal_r+0xf38>
 200784c:	da802317 	ldw	r10,140(sp)
 2007850:	d8001b15 	stw	zero,108(sp)
 2007854:	d811883a 	mov	r8,sp
 2007858:	5455883a 	add	r10,r10,r17
 200785c:	da802315 	stw	r10,140(sp)
 2007860:	90800007 	ldb	r2,0(r18)
 2007864:	10044626 	beq	r2,zero,2008980 <___vfiprintf_internal_r+0x1264>
 2007868:	90c00047 	ldb	r3,1(r18)
 200786c:	94000044 	addi	r16,r18,1
 2007870:	d8001d85 	stb	zero,118(sp)
 2007874:	0009883a 	mov	r4,zero
 2007878:	000f883a 	mov	r7,zero
 200787c:	027fffc4 	movi	r9,-1
 2007880:	0023883a 	mov	r17,zero
 2007884:	0029883a 	mov	r20,zero
 2007888:	01401604 	movi	r5,88
 200788c:	01800244 	movi	r6,9
 2007890:	03400a84 	movi	r13,42
 2007894:	03001b04 	movi	r12,108
 2007898:	84000044 	addi	r16,r16,1
 200789c:	18bff804 	addi	r2,r3,-32
 20078a0:	28827336 	bltu	r5,r2,2008270 <___vfiprintf_internal_r+0xb54>
 20078a4:	100490ba 	slli	r2,r2,2
 20078a8:	02808034 	movhi	r10,512
 20078ac:	529e2f04 	addi	r10,r10,30908
 20078b0:	1285883a 	add	r2,r2,r10
 20078b4:	10800017 	ldw	r2,0(r2)
 20078b8:	1000683a 	jmp	r2
 20078bc:	02007fa4 	muli	r8,zero,510
 20078c0:	02008270 	cmpltui	r8,zero,521
 20078c4:	02008270 	cmpltui	r8,zero,521
 20078c8:	02007fc4 	movi	r8,511
 20078cc:	02008270 	cmpltui	r8,zero,521
 20078d0:	02008270 	cmpltui	r8,zero,521
 20078d4:	02008270 	cmpltui	r8,zero,521
 20078d8:	02008270 	cmpltui	r8,zero,521
 20078dc:	02008270 	cmpltui	r8,zero,521
 20078e0:	02008270 	cmpltui	r8,zero,521
 20078e4:	020081ac 	andhi	r8,zero,518
 20078e8:	020081c8 	cmpgei	r8,zero,519
 20078ec:	02008270 	cmpltui	r8,zero,521
 20078f0:	02007ab0 	cmpltui	r8,zero,490
 20078f4:	020081d8 	cmpnei	r8,zero,519
 20078f8:	02008270 	cmpltui	r8,zero,521
 20078fc:	02007fd0 	cmplti	r8,zero,511
 2007900:	02007fdc 	xori	r8,zero,511
 2007904:	02007fdc 	xori	r8,zero,511
 2007908:	02007fdc 	xori	r8,zero,511
 200790c:	02007fdc 	xori	r8,zero,511
 2007910:	02007fdc 	xori	r8,zero,511
 2007914:	02007fdc 	xori	r8,zero,511
 2007918:	02007fdc 	xori	r8,zero,511
 200791c:	02007fdc 	xori	r8,zero,511
 2007920:	02007fdc 	xori	r8,zero,511
 2007924:	02008270 	cmpltui	r8,zero,521
 2007928:	02008270 	cmpltui	r8,zero,521
 200792c:	02008270 	cmpltui	r8,zero,521
 2007930:	02008270 	cmpltui	r8,zero,521
 2007934:	02008270 	cmpltui	r8,zero,521
 2007938:	02008270 	cmpltui	r8,zero,521
 200793c:	02008270 	cmpltui	r8,zero,521
 2007940:	02008270 	cmpltui	r8,zero,521
 2007944:	02008270 	cmpltui	r8,zero,521
 2007948:	02008270 	cmpltui	r8,zero,521
 200794c:	02008008 	cmpgei	r8,zero,512
 2007950:	02008270 	cmpltui	r8,zero,521
 2007954:	02008270 	cmpltui	r8,zero,521
 2007958:	02008270 	cmpltui	r8,zero,521
 200795c:	02008270 	cmpltui	r8,zero,521
 2007960:	02008270 	cmpltui	r8,zero,521
 2007964:	02008270 	cmpltui	r8,zero,521
 2007968:	02008270 	cmpltui	r8,zero,521
 200796c:	02008270 	cmpltui	r8,zero,521
 2007970:	02008270 	cmpltui	r8,zero,521
 2007974:	02008270 	cmpltui	r8,zero,521
 2007978:	02008040 	call	200804 <alt_exception_muldiv+0x200804>
 200797c:	02008270 	cmpltui	r8,zero,521
 2007980:	02008270 	cmpltui	r8,zero,521
 2007984:	02008270 	cmpltui	r8,zero,521
 2007988:	02008270 	cmpltui	r8,zero,521
 200798c:	02008270 	cmpltui	r8,zero,521
 2007990:	02008098 	cmpnei	r8,zero,514
 2007994:	02008270 	cmpltui	r8,zero,521
 2007998:	02008270 	cmpltui	r8,zero,521
 200799c:	02008108 	cmpgei	r8,zero,516
 20079a0:	02008270 	cmpltui	r8,zero,521
 20079a4:	02008270 	cmpltui	r8,zero,521
 20079a8:	02008270 	cmpltui	r8,zero,521
 20079ac:	02008270 	cmpltui	r8,zero,521
 20079b0:	02008270 	cmpltui	r8,zero,521
 20079b4:	02008270 	cmpltui	r8,zero,521
 20079b8:	02008270 	cmpltui	r8,zero,521
 20079bc:	02008270 	cmpltui	r8,zero,521
 20079c0:	02008270 	cmpltui	r8,zero,521
 20079c4:	02008270 	cmpltui	r8,zero,521
 20079c8:	02007eb4 	movhi	r8,506
 20079cc:	02007ee0 	cmpeqi	r8,zero,507
 20079d0:	02008270 	cmpltui	r8,zero,521
 20079d4:	02008270 	cmpltui	r8,zero,521
 20079d8:	02008270 	cmpltui	r8,zero,521
 20079dc:	02008218 	cmpnei	r8,zero,520
 20079e0:	02007ee0 	cmpeqi	r8,zero,507
 20079e4:	02008270 	cmpltui	r8,zero,521
 20079e8:	02008270 	cmpltui	r8,zero,521
 20079ec:	02007d74 	movhi	r8,501
 20079f0:	02008270 	cmpltui	r8,zero,521
 20079f4:	02007d84 	movi	r8,502
 20079f8:	02007dc0 	call	2007dc <alt_exception_muldiv+0x2007dc>
 20079fc:	02007abc 	xorhi	r8,zero,490
 2007a00:	02007d68 	cmpgeui	r8,zero,501
 2007a04:	02008270 	cmpltui	r8,zero,521
 2007a08:	02008144 	movi	r8,517
 2007a0c:	02008270 	cmpltui	r8,zero,521
 2007a10:	0200819c 	xori	r8,zero,518
 2007a14:	02008270 	cmpltui	r8,zero,521
 2007a18:	02008270 	cmpltui	r8,zero,521
 2007a1c:	02007e60 	cmpeqi	r8,zero,505
 2007a20:	42000204 	addi	r8,r8,8
 2007a24:	da802317 	ldw	r10,140(sp)
 2007a28:	5455883a 	add	r10,r10,r17
 2007a2c:	da802315 	stw	r10,140(sp)
 2007a30:	003f8b06 	br	2007860 <__alt_mem_mem_0+0xfcfe7860>
 2007a34:	d9002017 	ldw	r4,128(sp)
 2007a38:	a00b883a 	mov	r5,r20
 2007a3c:	2002ebc0 	call	2002ebc <__swsetup_r>
 2007a40:	1003b11e 	bne	r2,zero,2008908 <___vfiprintf_internal_r+0x11ec>
 2007a44:	a080030b 	ldhu	r2,12(r20)
 2007a48:	00c00284 	movi	r3,10
 2007a4c:	1080068c 	andi	r2,r2,26
 2007a50:	10ff541e 	bne	r2,r3,20077a4 <__alt_mem_mem_0+0xfcfe77a4>
 2007a54:	a080038f 	ldh	r2,14(r20)
 2007a58:	103f5216 	blt	r2,zero,20077a4 <__alt_mem_mem_0+0xfcfe77a4>
 2007a5c:	d9c02217 	ldw	r7,136(sp)
 2007a60:	d9002017 	ldw	r4,128(sp)
 2007a64:	e00d883a 	mov	r6,fp
 2007a68:	a00b883a 	mov	r5,r20
 2007a6c:	2008b940 	call	2008b94 <__sbprintf>
 2007a70:	dfc03617 	ldw	ra,216(sp)
 2007a74:	df003517 	ldw	fp,212(sp)
 2007a78:	ddc03417 	ldw	r23,208(sp)
 2007a7c:	dd803317 	ldw	r22,204(sp)
 2007a80:	dd403217 	ldw	r21,200(sp)
 2007a84:	dd003117 	ldw	r20,196(sp)
 2007a88:	dcc03017 	ldw	r19,192(sp)
 2007a8c:	dc802f17 	ldw	r18,188(sp)
 2007a90:	dc402e17 	ldw	r17,184(sp)
 2007a94:	dc002d17 	ldw	r16,180(sp)
 2007a98:	dec03704 	addi	sp,sp,220
 2007a9c:	f800283a 	ret
 2007aa0:	2004e900 	call	2004e90 <__sinit>
 2007aa4:	003f2f06 	br	2007764 <__alt_mem_mem_0+0xfcfe7764>
 2007aa8:	0463c83a 	sub	r17,zero,r17
 2007aac:	d8802215 	stw	r2,136(sp)
 2007ab0:	a5000114 	ori	r20,r20,4
 2007ab4:	80c00007 	ldb	r3,0(r16)
 2007ab8:	003f7706 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007abc:	00800c04 	movi	r2,48
 2007ac0:	da802217 	ldw	r10,136(sp)
 2007ac4:	d8801d05 	stb	r2,116(sp)
 2007ac8:	00801e04 	movi	r2,120
 2007acc:	d8801d45 	stb	r2,117(sp)
 2007ad0:	d8001d85 	stb	zero,118(sp)
 2007ad4:	50c00104 	addi	r3,r10,4
 2007ad8:	54800017 	ldw	r18,0(r10)
 2007adc:	0027883a 	mov	r19,zero
 2007ae0:	a0800094 	ori	r2,r20,2
 2007ae4:	48030b16 	blt	r9,zero,2008714 <___vfiprintf_internal_r+0xff8>
 2007ae8:	00bfdfc4 	movi	r2,-129
 2007aec:	a096703a 	and	r11,r20,r2
 2007af0:	d8c02215 	stw	r3,136(sp)
 2007af4:	5d000094 	ori	r20,r11,2
 2007af8:	90032b1e 	bne	r18,zero,20087a8 <___vfiprintf_internal_r+0x108c>
 2007afc:	00808134 	movhi	r2,516
 2007b00:	1083ce04 	addi	r2,r2,3896
 2007b04:	d8802615 	stw	r2,152(sp)
 2007b08:	0039883a 	mov	fp,zero
 2007b0c:	48017b1e 	bne	r9,zero,20080fc <___vfiprintf_internal_r+0x9e0>
 2007b10:	0013883a 	mov	r9,zero
 2007b14:	0027883a 	mov	r19,zero
 2007b18:	dd401a04 	addi	r21,sp,104
 2007b1c:	4825883a 	mov	r18,r9
 2007b20:	4cc0010e 	bge	r9,r19,2007b28 <___vfiprintf_internal_r+0x40c>
 2007b24:	9825883a 	mov	r18,r19
 2007b28:	e7003fcc 	andi	fp,fp,255
 2007b2c:	e700201c 	xori	fp,fp,128
 2007b30:	e73fe004 	addi	fp,fp,-128
 2007b34:	e0000126 	beq	fp,zero,2007b3c <___vfiprintf_internal_r+0x420>
 2007b38:	94800044 	addi	r18,r18,1
 2007b3c:	a380008c 	andi	r14,r20,2
 2007b40:	70000126 	beq	r14,zero,2007b48 <___vfiprintf_internal_r+0x42c>
 2007b44:	94800084 	addi	r18,r18,2
 2007b48:	a700210c 	andi	fp,r20,132
 2007b4c:	e001df1e 	bne	fp,zero,20082cc <___vfiprintf_internal_r+0xbb0>
 2007b50:	8c87c83a 	sub	r3,r17,r18
 2007b54:	00c1dd0e 	bge	zero,r3,20082cc <___vfiprintf_internal_r+0xbb0>
 2007b58:	01c00404 	movi	r7,16
 2007b5c:	d8801c17 	ldw	r2,112(sp)
 2007b60:	38c3ad0e 	bge	r7,r3,2008a18 <___vfiprintf_internal_r+0x12fc>
 2007b64:	02808134 	movhi	r10,516
 2007b68:	52843304 	addi	r10,r10,4300
 2007b6c:	dc002915 	stw	r16,164(sp)
 2007b70:	d9801b17 	ldw	r6,108(sp)
 2007b74:	da802415 	stw	r10,144(sp)
 2007b78:	03c001c4 	movi	r15,7
 2007b7c:	da402515 	stw	r9,148(sp)
 2007b80:	db802815 	stw	r14,160(sp)
 2007b84:	1821883a 	mov	r16,r3
 2007b88:	00000506 	br	2007ba0 <___vfiprintf_internal_r+0x484>
 2007b8c:	31400084 	addi	r5,r6,2
 2007b90:	42000204 	addi	r8,r8,8
 2007b94:	200d883a 	mov	r6,r4
 2007b98:	843ffc04 	addi	r16,r16,-16
 2007b9c:	3c000d0e 	bge	r7,r16,2007bd4 <___vfiprintf_internal_r+0x4b8>
 2007ba0:	10800404 	addi	r2,r2,16
 2007ba4:	31000044 	addi	r4,r6,1
 2007ba8:	45800015 	stw	r22,0(r8)
 2007bac:	41c00115 	stw	r7,4(r8)
 2007bb0:	d8801c15 	stw	r2,112(sp)
 2007bb4:	d9001b15 	stw	r4,108(sp)
 2007bb8:	793ff40e 	bge	r15,r4,2007b8c <__alt_mem_mem_0+0xfcfe7b8c>
 2007bbc:	1001b51e 	bne	r2,zero,2008294 <___vfiprintf_internal_r+0xb78>
 2007bc0:	843ffc04 	addi	r16,r16,-16
 2007bc4:	000d883a 	mov	r6,zero
 2007bc8:	01400044 	movi	r5,1
 2007bcc:	d811883a 	mov	r8,sp
 2007bd0:	3c3ff316 	blt	r7,r16,2007ba0 <__alt_mem_mem_0+0xfcfe7ba0>
 2007bd4:	8007883a 	mov	r3,r16
 2007bd8:	da402517 	ldw	r9,148(sp)
 2007bdc:	db802817 	ldw	r14,160(sp)
 2007be0:	dc002917 	ldw	r16,164(sp)
 2007be4:	da802417 	ldw	r10,144(sp)
 2007be8:	1885883a 	add	r2,r3,r2
 2007bec:	40c00115 	stw	r3,4(r8)
 2007bf0:	42800015 	stw	r10,0(r8)
 2007bf4:	d8801c15 	stw	r2,112(sp)
 2007bf8:	d9401b15 	stw	r5,108(sp)
 2007bfc:	00c001c4 	movi	r3,7
 2007c00:	19426016 	blt	r3,r5,2008584 <___vfiprintf_internal_r+0xe68>
 2007c04:	d8c01d87 	ldb	r3,118(sp)
 2007c08:	42000204 	addi	r8,r8,8
 2007c0c:	29000044 	addi	r4,r5,1
 2007c10:	1801b31e 	bne	r3,zero,20082e0 <___vfiprintf_internal_r+0xbc4>
 2007c14:	7001c026 	beq	r14,zero,2008318 <___vfiprintf_internal_r+0xbfc>
 2007c18:	d8c01d04 	addi	r3,sp,116
 2007c1c:	10800084 	addi	r2,r2,2
 2007c20:	40c00015 	stw	r3,0(r8)
 2007c24:	00c00084 	movi	r3,2
 2007c28:	40c00115 	stw	r3,4(r8)
 2007c2c:	d8801c15 	stw	r2,112(sp)
 2007c30:	d9001b15 	stw	r4,108(sp)
 2007c34:	00c001c4 	movi	r3,7
 2007c38:	1902650e 	bge	r3,r4,20085d0 <___vfiprintf_internal_r+0xeb4>
 2007c3c:	10029a1e 	bne	r2,zero,20086a8 <___vfiprintf_internal_r+0xf8c>
 2007c40:	00c02004 	movi	r3,128
 2007c44:	01000044 	movi	r4,1
 2007c48:	000b883a 	mov	r5,zero
 2007c4c:	d811883a 	mov	r8,sp
 2007c50:	e0c1b31e 	bne	fp,r3,2008320 <___vfiprintf_internal_r+0xc04>
 2007c54:	8cb9c83a 	sub	fp,r17,r18
 2007c58:	0701b10e 	bge	zero,fp,2008320 <___vfiprintf_internal_r+0xc04>
 2007c5c:	01c00404 	movi	r7,16
 2007c60:	3f03890e 	bge	r7,fp,2008a88 <___vfiprintf_internal_r+0x136c>
 2007c64:	00c08134 	movhi	r3,516
 2007c68:	18c42f04 	addi	r3,r3,4284
 2007c6c:	d8c02415 	stw	r3,144(sp)
 2007c70:	8007883a 	mov	r3,r16
 2007c74:	034001c4 	movi	r13,7
 2007c78:	e021883a 	mov	r16,fp
 2007c7c:	da402515 	stw	r9,148(sp)
 2007c80:	1839883a 	mov	fp,r3
 2007c84:	00000506 	br	2007c9c <___vfiprintf_internal_r+0x580>
 2007c88:	29800084 	addi	r6,r5,2
 2007c8c:	42000204 	addi	r8,r8,8
 2007c90:	180b883a 	mov	r5,r3
 2007c94:	843ffc04 	addi	r16,r16,-16
 2007c98:	3c000d0e 	bge	r7,r16,2007cd0 <___vfiprintf_internal_r+0x5b4>
 2007c9c:	10800404 	addi	r2,r2,16
 2007ca0:	28c00044 	addi	r3,r5,1
 2007ca4:	45c00015 	stw	r23,0(r8)
 2007ca8:	41c00115 	stw	r7,4(r8)
 2007cac:	d8801c15 	stw	r2,112(sp)
 2007cb0:	d8c01b15 	stw	r3,108(sp)
 2007cb4:	68fff40e 	bge	r13,r3,2007c88 <__alt_mem_mem_0+0xfcfe7c88>
 2007cb8:	1002241e 	bne	r2,zero,200854c <___vfiprintf_internal_r+0xe30>
 2007cbc:	843ffc04 	addi	r16,r16,-16
 2007cc0:	01800044 	movi	r6,1
 2007cc4:	000b883a 	mov	r5,zero
 2007cc8:	d811883a 	mov	r8,sp
 2007ccc:	3c3ff316 	blt	r7,r16,2007c9c <__alt_mem_mem_0+0xfcfe7c9c>
 2007cd0:	da402517 	ldw	r9,148(sp)
 2007cd4:	e007883a 	mov	r3,fp
 2007cd8:	8039883a 	mov	fp,r16
 2007cdc:	1821883a 	mov	r16,r3
 2007ce0:	d8c02417 	ldw	r3,144(sp)
 2007ce4:	1705883a 	add	r2,r2,fp
 2007ce8:	47000115 	stw	fp,4(r8)
 2007cec:	40c00015 	stw	r3,0(r8)
 2007cf0:	d8801c15 	stw	r2,112(sp)
 2007cf4:	d9801b15 	stw	r6,108(sp)
 2007cf8:	00c001c4 	movi	r3,7
 2007cfc:	19827616 	blt	r3,r6,20086d8 <___vfiprintf_internal_r+0xfbc>
 2007d00:	4cf9c83a 	sub	fp,r9,r19
 2007d04:	42000204 	addi	r8,r8,8
 2007d08:	31000044 	addi	r4,r6,1
 2007d0c:	300b883a 	mov	r5,r6
 2007d10:	07018516 	blt	zero,fp,2008328 <___vfiprintf_internal_r+0xc0c>
 2007d14:	9885883a 	add	r2,r19,r2
 2007d18:	45400015 	stw	r21,0(r8)
 2007d1c:	44c00115 	stw	r19,4(r8)
 2007d20:	d8801c15 	stw	r2,112(sp)
 2007d24:	d9001b15 	stw	r4,108(sp)
 2007d28:	00c001c4 	movi	r3,7
 2007d2c:	1901dd0e 	bge	r3,r4,20084a4 <___vfiprintf_internal_r+0xd88>
 2007d30:	1002401e 	bne	r2,zero,2008634 <___vfiprintf_internal_r+0xf18>
 2007d34:	d8001b15 	stw	zero,108(sp)
 2007d38:	a2c0010c 	andi	r11,r20,4
 2007d3c:	58000226 	beq	r11,zero,2007d48 <___vfiprintf_internal_r+0x62c>
 2007d40:	8ca7c83a 	sub	r19,r17,r18
 2007d44:	04c2f216 	blt	zero,r19,2008910 <___vfiprintf_internal_r+0x11f4>
 2007d48:	8c80010e 	bge	r17,r18,2007d50 <___vfiprintf_internal_r+0x634>
 2007d4c:	9023883a 	mov	r17,r18
 2007d50:	da802317 	ldw	r10,140(sp)
 2007d54:	5455883a 	add	r10,r10,r17
 2007d58:	da802315 	stw	r10,140(sp)
 2007d5c:	d8001b15 	stw	zero,108(sp)
 2007d60:	d811883a 	mov	r8,sp
 2007d64:	003ea206 	br	20077f0 <__alt_mem_mem_0+0xfcfe77f0>
 2007d68:	a5000814 	ori	r20,r20,32
 2007d6c:	80c00007 	ldb	r3,0(r16)
 2007d70:	003ec906 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007d74:	80c00007 	ldb	r3,0(r16)
 2007d78:	1b030926 	beq	r3,r12,20089a0 <___vfiprintf_internal_r+0x1284>
 2007d7c:	a5000414 	ori	r20,r20,16
 2007d80:	003ec506 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007d84:	21003fcc 	andi	r4,r4,255
 2007d88:	20035e1e 	bne	r4,zero,2008b04 <___vfiprintf_internal_r+0x13e8>
 2007d8c:	a080080c 	andi	r2,r20,32
 2007d90:	1002a526 	beq	r2,zero,2008828 <___vfiprintf_internal_r+0x110c>
 2007d94:	da802217 	ldw	r10,136(sp)
 2007d98:	50800017 	ldw	r2,0(r10)
 2007d9c:	da802317 	ldw	r10,140(sp)
 2007da0:	5007d7fa 	srai	r3,r10,31
 2007da4:	da802217 	ldw	r10,136(sp)
 2007da8:	10c00115 	stw	r3,4(r2)
 2007dac:	52800104 	addi	r10,r10,4
 2007db0:	da802215 	stw	r10,136(sp)
 2007db4:	da802317 	ldw	r10,140(sp)
 2007db8:	12800015 	stw	r10,0(r2)
 2007dbc:	003e8c06 	br	20077f0 <__alt_mem_mem_0+0xfcfe77f0>
 2007dc0:	21003fcc 	andi	r4,r4,255
 2007dc4:	2003511e 	bne	r4,zero,2008b0c <___vfiprintf_internal_r+0x13f0>
 2007dc8:	a080080c 	andi	r2,r20,32
 2007dcc:	1000a126 	beq	r2,zero,2008054 <___vfiprintf_internal_r+0x938>
 2007dd0:	da802217 	ldw	r10,136(sp)
 2007dd4:	d8001d85 	stb	zero,118(sp)
 2007dd8:	50800204 	addi	r2,r10,8
 2007ddc:	54800017 	ldw	r18,0(r10)
 2007de0:	54c00117 	ldw	r19,4(r10)
 2007de4:	4802b416 	blt	r9,zero,20088b8 <___vfiprintf_internal_r+0x119c>
 2007de8:	013fdfc4 	movi	r4,-129
 2007dec:	94c6b03a 	or	r3,r18,r19
 2007df0:	d8802215 	stw	r2,136(sp)
 2007df4:	a128703a 	and	r20,r20,r4
 2007df8:	1800a226 	beq	r3,zero,2008084 <___vfiprintf_internal_r+0x968>
 2007dfc:	0039883a 	mov	fp,zero
 2007e00:	dd401a04 	addi	r21,sp,104
 2007e04:	9006d0fa 	srli	r3,r18,3
 2007e08:	9808977a 	slli	r4,r19,29
 2007e0c:	9826d0fa 	srli	r19,r19,3
 2007e10:	948001cc 	andi	r18,r18,7
 2007e14:	90800c04 	addi	r2,r18,48
 2007e18:	ad7fffc4 	addi	r21,r21,-1
 2007e1c:	20e4b03a 	or	r18,r4,r3
 2007e20:	a8800005 	stb	r2,0(r21)
 2007e24:	94c6b03a 	or	r3,r18,r19
 2007e28:	183ff61e 	bne	r3,zero,2007e04 <__alt_mem_mem_0+0xfcfe7e04>
 2007e2c:	a0c0004c 	andi	r3,r20,1
 2007e30:	18005926 	beq	r3,zero,2007f98 <___vfiprintf_internal_r+0x87c>
 2007e34:	10803fcc 	andi	r2,r2,255
 2007e38:	1080201c 	xori	r2,r2,128
 2007e3c:	10bfe004 	addi	r2,r2,-128
 2007e40:	00c00c04 	movi	r3,48
 2007e44:	10c05426 	beq	r2,r3,2007f98 <___vfiprintf_internal_r+0x87c>
 2007e48:	da801e17 	ldw	r10,120(sp)
 2007e4c:	a8bfffc4 	addi	r2,r21,-1
 2007e50:	a8ffffc5 	stb	r3,-1(r21)
 2007e54:	50a7c83a 	sub	r19,r10,r2
 2007e58:	102b883a 	mov	r21,r2
 2007e5c:	003f2f06 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2007e60:	21003fcc 	andi	r4,r4,255
 2007e64:	2003421e 	bne	r4,zero,2008b70 <___vfiprintf_internal_r+0x1454>
 2007e68:	00808134 	movhi	r2,516
 2007e6c:	1083ce04 	addi	r2,r2,3896
 2007e70:	d8802615 	stw	r2,152(sp)
 2007e74:	a080080c 	andi	r2,r20,32
 2007e78:	1000aa26 	beq	r2,zero,2008124 <___vfiprintf_internal_r+0xa08>
 2007e7c:	da802217 	ldw	r10,136(sp)
 2007e80:	54800017 	ldw	r18,0(r10)
 2007e84:	54c00117 	ldw	r19,4(r10)
 2007e88:	52800204 	addi	r10,r10,8
 2007e8c:	da802215 	stw	r10,136(sp)
 2007e90:	a080004c 	andi	r2,r20,1
 2007e94:	1001d226 	beq	r2,zero,20085e0 <___vfiprintf_internal_r+0xec4>
 2007e98:	94c4b03a 	or	r2,r18,r19
 2007e9c:	1002351e 	bne	r2,zero,2008774 <___vfiprintf_internal_r+0x1058>
 2007ea0:	d8001d85 	stb	zero,118(sp)
 2007ea4:	48022216 	blt	r9,zero,2008730 <___vfiprintf_internal_r+0x1014>
 2007ea8:	00bfdfc4 	movi	r2,-129
 2007eac:	a0a8703a 	and	r20,r20,r2
 2007eb0:	003f1506 	br	2007b08 <__alt_mem_mem_0+0xfcfe7b08>
 2007eb4:	da802217 	ldw	r10,136(sp)
 2007eb8:	04800044 	movi	r18,1
 2007ebc:	d8001d85 	stb	zero,118(sp)
 2007ec0:	50800017 	ldw	r2,0(r10)
 2007ec4:	52800104 	addi	r10,r10,4
 2007ec8:	da802215 	stw	r10,136(sp)
 2007ecc:	d8801005 	stb	r2,64(sp)
 2007ed0:	9027883a 	mov	r19,r18
 2007ed4:	dd401004 	addi	r21,sp,64
 2007ed8:	0013883a 	mov	r9,zero
 2007edc:	003f1706 	br	2007b3c <__alt_mem_mem_0+0xfcfe7b3c>
 2007ee0:	21003fcc 	andi	r4,r4,255
 2007ee4:	2003201e 	bne	r4,zero,2008b68 <___vfiprintf_internal_r+0x144c>
 2007ee8:	a080080c 	andi	r2,r20,32
 2007eec:	10004b26 	beq	r2,zero,200801c <___vfiprintf_internal_r+0x900>
 2007ef0:	da802217 	ldw	r10,136(sp)
 2007ef4:	50800117 	ldw	r2,4(r10)
 2007ef8:	54800017 	ldw	r18,0(r10)
 2007efc:	52800204 	addi	r10,r10,8
 2007f00:	da802215 	stw	r10,136(sp)
 2007f04:	1027883a 	mov	r19,r2
 2007f08:	10022c16 	blt	r2,zero,20087bc <___vfiprintf_internal_r+0x10a0>
 2007f0c:	df001d83 	ldbu	fp,118(sp)
 2007f10:	48007216 	blt	r9,zero,20080dc <___vfiprintf_internal_r+0x9c0>
 2007f14:	00ffdfc4 	movi	r3,-129
 2007f18:	94c4b03a 	or	r2,r18,r19
 2007f1c:	a0e8703a 	and	r20,r20,r3
 2007f20:	1000cc26 	beq	r2,zero,2008254 <___vfiprintf_internal_r+0xb38>
 2007f24:	98021026 	beq	r19,zero,2008768 <___vfiprintf_internal_r+0x104c>
 2007f28:	dc402415 	stw	r17,144(sp)
 2007f2c:	dc002515 	stw	r16,148(sp)
 2007f30:	9823883a 	mov	r17,r19
 2007f34:	9021883a 	mov	r16,r18
 2007f38:	dd401a04 	addi	r21,sp,104
 2007f3c:	4825883a 	mov	r18,r9
 2007f40:	4027883a 	mov	r19,r8
 2007f44:	8009883a 	mov	r4,r16
 2007f48:	880b883a 	mov	r5,r17
 2007f4c:	01800284 	movi	r6,10
 2007f50:	000f883a 	mov	r7,zero
 2007f54:	200a6780 	call	200a678 <__umoddi3>
 2007f58:	10800c04 	addi	r2,r2,48
 2007f5c:	ad7fffc4 	addi	r21,r21,-1
 2007f60:	8009883a 	mov	r4,r16
 2007f64:	880b883a 	mov	r5,r17
 2007f68:	a8800005 	stb	r2,0(r21)
 2007f6c:	01800284 	movi	r6,10
 2007f70:	000f883a 	mov	r7,zero
 2007f74:	200a1000 	call	200a100 <__udivdi3>
 2007f78:	1021883a 	mov	r16,r2
 2007f7c:	10c4b03a 	or	r2,r2,r3
 2007f80:	1823883a 	mov	r17,r3
 2007f84:	103fef1e 	bne	r2,zero,2007f44 <__alt_mem_mem_0+0xfcfe7f44>
 2007f88:	dc402417 	ldw	r17,144(sp)
 2007f8c:	dc002517 	ldw	r16,148(sp)
 2007f90:	9013883a 	mov	r9,r18
 2007f94:	9811883a 	mov	r8,r19
 2007f98:	da801e17 	ldw	r10,120(sp)
 2007f9c:	5567c83a 	sub	r19,r10,r21
 2007fa0:	003ede06 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2007fa4:	38803fcc 	andi	r2,r7,255
 2007fa8:	1080201c 	xori	r2,r2,128
 2007fac:	10bfe004 	addi	r2,r2,-128
 2007fb0:	1002371e 	bne	r2,zero,2008890 <___vfiprintf_internal_r+0x1174>
 2007fb4:	01000044 	movi	r4,1
 2007fb8:	01c00804 	movi	r7,32
 2007fbc:	80c00007 	ldb	r3,0(r16)
 2007fc0:	003e3506 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007fc4:	a5000054 	ori	r20,r20,1
 2007fc8:	80c00007 	ldb	r3,0(r16)
 2007fcc:	003e3206 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007fd0:	a5002014 	ori	r20,r20,128
 2007fd4:	80c00007 	ldb	r3,0(r16)
 2007fd8:	003e2f06 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2007fdc:	8015883a 	mov	r10,r16
 2007fe0:	0023883a 	mov	r17,zero
 2007fe4:	18bff404 	addi	r2,r3,-48
 2007fe8:	50c00007 	ldb	r3,0(r10)
 2007fec:	8c4002a4 	muli	r17,r17,10
 2007ff0:	84000044 	addi	r16,r16,1
 2007ff4:	8015883a 	mov	r10,r16
 2007ff8:	1463883a 	add	r17,r2,r17
 2007ffc:	18bff404 	addi	r2,r3,-48
 2008000:	30bff92e 	bgeu	r6,r2,2007fe8 <__alt_mem_mem_0+0xfcfe7fe8>
 2008004:	003e2506 	br	200789c <__alt_mem_mem_0+0xfcfe789c>
 2008008:	21003fcc 	andi	r4,r4,255
 200800c:	2002d41e 	bne	r4,zero,2008b60 <___vfiprintf_internal_r+0x1444>
 2008010:	a5000414 	ori	r20,r20,16
 2008014:	a080080c 	andi	r2,r20,32
 2008018:	103fb51e 	bne	r2,zero,2007ef0 <__alt_mem_mem_0+0xfcfe7ef0>
 200801c:	a080040c 	andi	r2,r20,16
 2008020:	1001f826 	beq	r2,zero,2008804 <___vfiprintf_internal_r+0x10e8>
 2008024:	da802217 	ldw	r10,136(sp)
 2008028:	54800017 	ldw	r18,0(r10)
 200802c:	52800104 	addi	r10,r10,4
 2008030:	da802215 	stw	r10,136(sp)
 2008034:	9027d7fa 	srai	r19,r18,31
 2008038:	9805883a 	mov	r2,r19
 200803c:	003fb206 	br	2007f08 <__alt_mem_mem_0+0xfcfe7f08>
 2008040:	21003fcc 	andi	r4,r4,255
 2008044:	2002c41e 	bne	r4,zero,2008b58 <___vfiprintf_internal_r+0x143c>
 2008048:	a5000414 	ori	r20,r20,16
 200804c:	a080080c 	andi	r2,r20,32
 2008050:	103f5f1e 	bne	r2,zero,2007dd0 <__alt_mem_mem_0+0xfcfe7dd0>
 2008054:	a080040c 	andi	r2,r20,16
 2008058:	10020f26 	beq	r2,zero,2008898 <___vfiprintf_internal_r+0x117c>
 200805c:	da802217 	ldw	r10,136(sp)
 2008060:	d8001d85 	stb	zero,118(sp)
 2008064:	0027883a 	mov	r19,zero
 2008068:	50800104 	addi	r2,r10,4
 200806c:	54800017 	ldw	r18,0(r10)
 2008070:	48021116 	blt	r9,zero,20088b8 <___vfiprintf_internal_r+0x119c>
 2008074:	00ffdfc4 	movi	r3,-129
 2008078:	d8802215 	stw	r2,136(sp)
 200807c:	a0e8703a 	and	r20,r20,r3
 2008080:	903f5e1e 	bne	r18,zero,2007dfc <__alt_mem_mem_0+0xfcfe7dfc>
 2008084:	0039883a 	mov	fp,zero
 2008088:	4802a626 	beq	r9,zero,2008b24 <___vfiprintf_internal_r+0x1408>
 200808c:	0025883a 	mov	r18,zero
 2008090:	0027883a 	mov	r19,zero
 2008094:	003f5a06 	br	2007e00 <__alt_mem_mem_0+0xfcfe7e00>
 2008098:	21003fcc 	andi	r4,r4,255
 200809c:	20029f1e 	bne	r4,zero,2008b1c <___vfiprintf_internal_r+0x1400>
 20080a0:	a5000414 	ori	r20,r20,16
 20080a4:	a080080c 	andi	r2,r20,32
 20080a8:	10005e1e 	bne	r2,zero,2008224 <___vfiprintf_internal_r+0xb08>
 20080ac:	a080040c 	andi	r2,r20,16
 20080b0:	1001a21e 	bne	r2,zero,200873c <___vfiprintf_internal_r+0x1020>
 20080b4:	a080100c 	andi	r2,r20,64
 20080b8:	d8001d85 	stb	zero,118(sp)
 20080bc:	da802217 	ldw	r10,136(sp)
 20080c0:	1002231e 	bne	r2,zero,2008950 <___vfiprintf_internal_r+0x1234>
 20080c4:	50800104 	addi	r2,r10,4
 20080c8:	54800017 	ldw	r18,0(r10)
 20080cc:	0027883a 	mov	r19,zero
 20080d0:	4801a00e 	bge	r9,zero,2008754 <___vfiprintf_internal_r+0x1038>
 20080d4:	d8802215 	stw	r2,136(sp)
 20080d8:	0039883a 	mov	fp,zero
 20080dc:	94c4b03a 	or	r2,r18,r19
 20080e0:	103f901e 	bne	r2,zero,2007f24 <__alt_mem_mem_0+0xfcfe7f24>
 20080e4:	00800044 	movi	r2,1
 20080e8:	10803fcc 	andi	r2,r2,255
 20080ec:	00c00044 	movi	r3,1
 20080f0:	10c05926 	beq	r2,r3,2008258 <___vfiprintf_internal_r+0xb3c>
 20080f4:	00c00084 	movi	r3,2
 20080f8:	10ffe41e 	bne	r2,r3,200808c <__alt_mem_mem_0+0xfcfe808c>
 20080fc:	0025883a 	mov	r18,zero
 2008100:	0027883a 	mov	r19,zero
 2008104:	00013d06 	br	20085fc <___vfiprintf_internal_r+0xee0>
 2008108:	21003fcc 	andi	r4,r4,255
 200810c:	2002811e 	bne	r4,zero,2008b14 <___vfiprintf_internal_r+0x13f8>
 2008110:	00808134 	movhi	r2,516
 2008114:	1083c904 	addi	r2,r2,3876
 2008118:	d8802615 	stw	r2,152(sp)
 200811c:	a080080c 	andi	r2,r20,32
 2008120:	103f561e 	bne	r2,zero,2007e7c <__alt_mem_mem_0+0xfcfe7e7c>
 2008124:	a080040c 	andi	r2,r20,16
 2008128:	1001d126 	beq	r2,zero,2008870 <___vfiprintf_internal_r+0x1154>
 200812c:	da802217 	ldw	r10,136(sp)
 2008130:	0027883a 	mov	r19,zero
 2008134:	54800017 	ldw	r18,0(r10)
 2008138:	52800104 	addi	r10,r10,4
 200813c:	da802215 	stw	r10,136(sp)
 2008140:	003f5306 	br	2007e90 <__alt_mem_mem_0+0xfcfe7e90>
 2008144:	da802217 	ldw	r10,136(sp)
 2008148:	d8001d85 	stb	zero,118(sp)
 200814c:	55400017 	ldw	r21,0(r10)
 2008150:	50c00104 	addi	r3,r10,4
 2008154:	a8024226 	beq	r21,zero,2008a60 <___vfiprintf_internal_r+0x1344>
 2008158:	48021816 	blt	r9,zero,20089bc <___vfiprintf_internal_r+0x12a0>
 200815c:	480d883a 	mov	r6,r9
 2008160:	000b883a 	mov	r5,zero
 2008164:	a809883a 	mov	r4,r21
 2008168:	d8c02a15 	stw	r3,168(sp)
 200816c:	da002b15 	stw	r8,172(sp)
 2008170:	da402c15 	stw	r9,176(sp)
 2008174:	2005f400 	call	2005f40 <memchr>
 2008178:	d8c02a17 	ldw	r3,168(sp)
 200817c:	da002b17 	ldw	r8,172(sp)
 2008180:	da402c17 	ldw	r9,176(sp)
 2008184:	10024826 	beq	r2,zero,2008aa8 <___vfiprintf_internal_r+0x138c>
 2008188:	1567c83a 	sub	r19,r2,r21
 200818c:	df001d83 	ldbu	fp,118(sp)
 2008190:	d8c02215 	stw	r3,136(sp)
 2008194:	0013883a 	mov	r9,zero
 2008198:	003e6006 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 200819c:	21003fcc 	andi	r4,r4,255
 20081a0:	203fc026 	beq	r4,zero,20080a4 <__alt_mem_mem_0+0xfcfe80a4>
 20081a4:	d9c01d85 	stb	r7,118(sp)
 20081a8:	003fbe06 	br	20080a4 <__alt_mem_mem_0+0xfcfe80a4>
 20081ac:	da802217 	ldw	r10,136(sp)
 20081b0:	54400017 	ldw	r17,0(r10)
 20081b4:	50800104 	addi	r2,r10,4
 20081b8:	883e3b16 	blt	r17,zero,2007aa8 <__alt_mem_mem_0+0xfcfe7aa8>
 20081bc:	d8802215 	stw	r2,136(sp)
 20081c0:	80c00007 	ldb	r3,0(r16)
 20081c4:	003db406 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 20081c8:	01000044 	movi	r4,1
 20081cc:	01c00ac4 	movi	r7,43
 20081d0:	80c00007 	ldb	r3,0(r16)
 20081d4:	003db006 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 20081d8:	80c00007 	ldb	r3,0(r16)
 20081dc:	82800044 	addi	r10,r16,1
 20081e0:	1b423c26 	beq	r3,r13,2008ad4 <___vfiprintf_internal_r+0x13b8>
 20081e4:	18bff404 	addi	r2,r3,-48
 20081e8:	0013883a 	mov	r9,zero
 20081ec:	30822b36 	bltu	r6,r2,2008a9c <___vfiprintf_internal_r+0x1380>
 20081f0:	50c00007 	ldb	r3,0(r10)
 20081f4:	4a4002a4 	muli	r9,r9,10
 20081f8:	54000044 	addi	r16,r10,1
 20081fc:	8015883a 	mov	r10,r16
 2008200:	4893883a 	add	r9,r9,r2
 2008204:	18bff404 	addi	r2,r3,-48
 2008208:	30bff92e 	bgeu	r6,r2,20081f0 <__alt_mem_mem_0+0xfcfe81f0>
 200820c:	483da30e 	bge	r9,zero,200789c <__alt_mem_mem_0+0xfcfe789c>
 2008210:	027fffc4 	movi	r9,-1
 2008214:	003da106 	br	200789c <__alt_mem_mem_0+0xfcfe789c>
 2008218:	a5001014 	ori	r20,r20,64
 200821c:	80c00007 	ldb	r3,0(r16)
 2008220:	003d9d06 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2008224:	da802217 	ldw	r10,136(sp)
 2008228:	d8001d85 	stb	zero,118(sp)
 200822c:	50c00204 	addi	r3,r10,8
 2008230:	54800017 	ldw	r18,0(r10)
 2008234:	54c00117 	ldw	r19,4(r10)
 2008238:	4801ca16 	blt	r9,zero,2008964 <___vfiprintf_internal_r+0x1248>
 200823c:	013fdfc4 	movi	r4,-129
 2008240:	94c4b03a 	or	r2,r18,r19
 2008244:	d8c02215 	stw	r3,136(sp)
 2008248:	a128703a 	and	r20,r20,r4
 200824c:	0039883a 	mov	fp,zero
 2008250:	103f341e 	bne	r2,zero,2007f24 <__alt_mem_mem_0+0xfcfe7f24>
 2008254:	483e2e26 	beq	r9,zero,2007b10 <__alt_mem_mem_0+0xfcfe7b10>
 2008258:	0025883a 	mov	r18,zero
 200825c:	94800c04 	addi	r18,r18,48
 2008260:	dc8019c5 	stb	r18,103(sp)
 2008264:	dcc02717 	ldw	r19,156(sp)
 2008268:	dd4019c4 	addi	r21,sp,103
 200826c:	003e2b06 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2008270:	21003fcc 	andi	r4,r4,255
 2008274:	2002361e 	bne	r4,zero,2008b50 <___vfiprintf_internal_r+0x1434>
 2008278:	1801c126 	beq	r3,zero,2008980 <___vfiprintf_internal_r+0x1264>
 200827c:	04800044 	movi	r18,1
 2008280:	d8c01005 	stb	r3,64(sp)
 2008284:	d8001d85 	stb	zero,118(sp)
 2008288:	9027883a 	mov	r19,r18
 200828c:	dd401004 	addi	r21,sp,64
 2008290:	003f1106 	br	2007ed8 <__alt_mem_mem_0+0xfcfe7ed8>
 2008294:	d9402117 	ldw	r5,132(sp)
 2008298:	d9002017 	ldw	r4,128(sp)
 200829c:	d9801a04 	addi	r6,sp,104
 20082a0:	d9c02b15 	stw	r7,172(sp)
 20082a4:	dbc02a15 	stw	r15,168(sp)
 20082a8:	20076080 	call	2007608 <__sprint_r.part.0>
 20082ac:	d9c02b17 	ldw	r7,172(sp)
 20082b0:	dbc02a17 	ldw	r15,168(sp)
 20082b4:	10006d1e 	bne	r2,zero,200846c <___vfiprintf_internal_r+0xd50>
 20082b8:	d9801b17 	ldw	r6,108(sp)
 20082bc:	d8801c17 	ldw	r2,112(sp)
 20082c0:	d811883a 	mov	r8,sp
 20082c4:	31400044 	addi	r5,r6,1
 20082c8:	003e3306 	br	2007b98 <__alt_mem_mem_0+0xfcfe7b98>
 20082cc:	d9401b17 	ldw	r5,108(sp)
 20082d0:	d8801c17 	ldw	r2,112(sp)
 20082d4:	29000044 	addi	r4,r5,1
 20082d8:	d8c01d87 	ldb	r3,118(sp)
 20082dc:	183e4d26 	beq	r3,zero,2007c14 <__alt_mem_mem_0+0xfcfe7c14>
 20082e0:	00c00044 	movi	r3,1
 20082e4:	d9401d84 	addi	r5,sp,118
 20082e8:	10c5883a 	add	r2,r2,r3
 20082ec:	41400015 	stw	r5,0(r8)
 20082f0:	40c00115 	stw	r3,4(r8)
 20082f4:	d8801c15 	stw	r2,112(sp)
 20082f8:	d9001b15 	stw	r4,108(sp)
 20082fc:	014001c4 	movi	r5,7
 2008300:	2900a90e 	bge	r5,r4,20085a8 <___vfiprintf_internal_r+0xe8c>
 2008304:	1000da1e 	bne	r2,zero,2008670 <___vfiprintf_internal_r+0xf54>
 2008308:	7000ab1e 	bne	r14,zero,20085b8 <___vfiprintf_internal_r+0xe9c>
 200830c:	000b883a 	mov	r5,zero
 2008310:	1809883a 	mov	r4,r3
 2008314:	d811883a 	mov	r8,sp
 2008318:	00c02004 	movi	r3,128
 200831c:	e0fe4d26 	beq	fp,r3,2007c54 <__alt_mem_mem_0+0xfcfe7c54>
 2008320:	4cf9c83a 	sub	fp,r9,r19
 2008324:	073e7b0e 	bge	zero,fp,2007d14 <__alt_mem_mem_0+0xfcfe7d14>
 2008328:	01c00404 	movi	r7,16
 200832c:	3f01900e 	bge	r7,fp,2008970 <___vfiprintf_internal_r+0x1254>
 2008330:	00c08134 	movhi	r3,516
 2008334:	18c42f04 	addi	r3,r3,4284
 2008338:	d8c02415 	stw	r3,144(sp)
 200833c:	034001c4 	movi	r13,7
 2008340:	00000506 	br	2008358 <___vfiprintf_internal_r+0xc3c>
 2008344:	29000084 	addi	r4,r5,2
 2008348:	42000204 	addi	r8,r8,8
 200834c:	180b883a 	mov	r5,r3
 2008350:	e73ffc04 	addi	fp,fp,-16
 2008354:	3f000d0e 	bge	r7,fp,200838c <___vfiprintf_internal_r+0xc70>
 2008358:	10800404 	addi	r2,r2,16
 200835c:	28c00044 	addi	r3,r5,1
 2008360:	45c00015 	stw	r23,0(r8)
 2008364:	41c00115 	stw	r7,4(r8)
 2008368:	d8801c15 	stw	r2,112(sp)
 200836c:	d8c01b15 	stw	r3,108(sp)
 2008370:	68fff40e 	bge	r13,r3,2008344 <__alt_mem_mem_0+0xfcfe8344>
 2008374:	1000101e 	bne	r2,zero,20083b8 <___vfiprintf_internal_r+0xc9c>
 2008378:	e73ffc04 	addi	fp,fp,-16
 200837c:	01000044 	movi	r4,1
 2008380:	000b883a 	mov	r5,zero
 2008384:	d811883a 	mov	r8,sp
 2008388:	3f3ff316 	blt	r7,fp,2008358 <__alt_mem_mem_0+0xfcfe8358>
 200838c:	da802417 	ldw	r10,144(sp)
 2008390:	1705883a 	add	r2,r2,fp
 2008394:	47000115 	stw	fp,4(r8)
 2008398:	42800015 	stw	r10,0(r8)
 200839c:	d8801c15 	stw	r2,112(sp)
 20083a0:	d9001b15 	stw	r4,108(sp)
 20083a4:	00c001c4 	movi	r3,7
 20083a8:	19003616 	blt	r3,r4,2008484 <___vfiprintf_internal_r+0xd68>
 20083ac:	42000204 	addi	r8,r8,8
 20083b0:	21000044 	addi	r4,r4,1
 20083b4:	003e5706 	br	2007d14 <__alt_mem_mem_0+0xfcfe7d14>
 20083b8:	d9402117 	ldw	r5,132(sp)
 20083bc:	d9002017 	ldw	r4,128(sp)
 20083c0:	d9801a04 	addi	r6,sp,104
 20083c4:	d9c02b15 	stw	r7,172(sp)
 20083c8:	db402a15 	stw	r13,168(sp)
 20083cc:	20076080 	call	2007608 <__sprint_r.part.0>
 20083d0:	d9c02b17 	ldw	r7,172(sp)
 20083d4:	db402a17 	ldw	r13,168(sp)
 20083d8:	1000241e 	bne	r2,zero,200846c <___vfiprintf_internal_r+0xd50>
 20083dc:	d9401b17 	ldw	r5,108(sp)
 20083e0:	d8801c17 	ldw	r2,112(sp)
 20083e4:	d811883a 	mov	r8,sp
 20083e8:	29000044 	addi	r4,r5,1
 20083ec:	003fd806 	br	2008350 <__alt_mem_mem_0+0xfcfe8350>
 20083f0:	d9401b17 	ldw	r5,108(sp)
 20083f4:	00c08134 	movhi	r3,516
 20083f8:	18c43304 	addi	r3,r3,4300
 20083fc:	d8c02415 	stw	r3,144(sp)
 2008400:	29400044 	addi	r5,r5,1
 2008404:	d8c02417 	ldw	r3,144(sp)
 2008408:	14c5883a 	add	r2,r2,r19
 200840c:	44c00115 	stw	r19,4(r8)
 2008410:	40c00015 	stw	r3,0(r8)
 2008414:	d8801c15 	stw	r2,112(sp)
 2008418:	d9401b15 	stw	r5,108(sp)
 200841c:	00c001c4 	movi	r3,7
 2008420:	1940070e 	bge	r3,r5,2008440 <___vfiprintf_internal_r+0xd24>
 2008424:	103e4826 	beq	r2,zero,2007d48 <__alt_mem_mem_0+0xfcfe7d48>
 2008428:	d9402117 	ldw	r5,132(sp)
 200842c:	d9002017 	ldw	r4,128(sp)
 2008430:	d9801a04 	addi	r6,sp,104
 2008434:	20076080 	call	2007608 <__sprint_r.part.0>
 2008438:	10000c1e 	bne	r2,zero,200846c <___vfiprintf_internal_r+0xd50>
 200843c:	d8801c17 	ldw	r2,112(sp)
 2008440:	8c80010e 	bge	r17,r18,2008448 <___vfiprintf_internal_r+0xd2c>
 2008444:	9023883a 	mov	r17,r18
 2008448:	da802317 	ldw	r10,140(sp)
 200844c:	5455883a 	add	r10,r10,r17
 2008450:	da802315 	stw	r10,140(sp)
 2008454:	103e4126 	beq	r2,zero,2007d5c <__alt_mem_mem_0+0xfcfe7d5c>
 2008458:	d9402117 	ldw	r5,132(sp)
 200845c:	d9002017 	ldw	r4,128(sp)
 2008460:	d9801a04 	addi	r6,sp,104
 2008464:	20076080 	call	2007608 <__sprint_r.part.0>
 2008468:	103e3c26 	beq	r2,zero,2007d5c <__alt_mem_mem_0+0xfcfe7d5c>
 200846c:	dd002117 	ldw	r20,132(sp)
 2008470:	a080030b 	ldhu	r2,12(r20)
 2008474:	1080100c 	andi	r2,r2,64
 2008478:	1001231e 	bne	r2,zero,2008908 <___vfiprintf_internal_r+0x11ec>
 200847c:	d8802317 	ldw	r2,140(sp)
 2008480:	003d7b06 	br	2007a70 <__alt_mem_mem_0+0xfcfe7a70>
 2008484:	1000991e 	bne	r2,zero,20086ec <___vfiprintf_internal_r+0xfd0>
 2008488:	00c00044 	movi	r3,1
 200848c:	9805883a 	mov	r2,r19
 2008490:	dd400015 	stw	r21,0(sp)
 2008494:	dcc00115 	stw	r19,4(sp)
 2008498:	dcc01c15 	stw	r19,112(sp)
 200849c:	d8c01b15 	stw	r3,108(sp)
 20084a0:	d811883a 	mov	r8,sp
 20084a4:	42000204 	addi	r8,r8,8
 20084a8:	a2c0010c 	andi	r11,r20,4
 20084ac:	583fe426 	beq	r11,zero,2008440 <__alt_mem_mem_0+0xfcfe8440>
 20084b0:	8ca7c83a 	sub	r19,r17,r18
 20084b4:	04ffe20e 	bge	zero,r19,2008440 <__alt_mem_mem_0+0xfcfe8440>
 20084b8:	01c00404 	movi	r7,16
 20084bc:	3cffcc0e 	bge	r7,r19,20083f0 <__alt_mem_mem_0+0xfcfe83f0>
 20084c0:	02808134 	movhi	r10,516
 20084c4:	52843304 	addi	r10,r10,4300
 20084c8:	d9001b17 	ldw	r4,108(sp)
 20084cc:	da802415 	stw	r10,144(sp)
 20084d0:	382b883a 	mov	r21,r7
 20084d4:	050001c4 	movi	r20,7
 20084d8:	df002017 	ldw	fp,128(sp)
 20084dc:	00000506 	br	20084f4 <___vfiprintf_internal_r+0xdd8>
 20084e0:	21400084 	addi	r5,r4,2
 20084e4:	42000204 	addi	r8,r8,8
 20084e8:	1809883a 	mov	r4,r3
 20084ec:	9cfffc04 	addi	r19,r19,-16
 20084f0:	acffc40e 	bge	r21,r19,2008404 <__alt_mem_mem_0+0xfcfe8404>
 20084f4:	10800404 	addi	r2,r2,16
 20084f8:	20c00044 	addi	r3,r4,1
 20084fc:	45800015 	stw	r22,0(r8)
 2008500:	45400115 	stw	r21,4(r8)
 2008504:	d8801c15 	stw	r2,112(sp)
 2008508:	d8c01b15 	stw	r3,108(sp)
 200850c:	a0fff40e 	bge	r20,r3,20084e0 <__alt_mem_mem_0+0xfcfe84e0>
 2008510:	1000041e 	bne	r2,zero,2008524 <___vfiprintf_internal_r+0xe08>
 2008514:	01400044 	movi	r5,1
 2008518:	0009883a 	mov	r4,zero
 200851c:	d811883a 	mov	r8,sp
 2008520:	003ff206 	br	20084ec <__alt_mem_mem_0+0xfcfe84ec>
 2008524:	d9402117 	ldw	r5,132(sp)
 2008528:	d9801a04 	addi	r6,sp,104
 200852c:	e009883a 	mov	r4,fp
 2008530:	20076080 	call	2007608 <__sprint_r.part.0>
 2008534:	103fcd1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008538:	d9001b17 	ldw	r4,108(sp)
 200853c:	d8801c17 	ldw	r2,112(sp)
 2008540:	d811883a 	mov	r8,sp
 2008544:	21400044 	addi	r5,r4,1
 2008548:	003fe806 	br	20084ec <__alt_mem_mem_0+0xfcfe84ec>
 200854c:	d9402117 	ldw	r5,132(sp)
 2008550:	d9002017 	ldw	r4,128(sp)
 2008554:	d9801a04 	addi	r6,sp,104
 2008558:	d9c02b15 	stw	r7,172(sp)
 200855c:	db402a15 	stw	r13,168(sp)
 2008560:	20076080 	call	2007608 <__sprint_r.part.0>
 2008564:	d9c02b17 	ldw	r7,172(sp)
 2008568:	db402a17 	ldw	r13,168(sp)
 200856c:	103fbf1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008570:	d9401b17 	ldw	r5,108(sp)
 2008574:	d8801c17 	ldw	r2,112(sp)
 2008578:	d811883a 	mov	r8,sp
 200857c:	29800044 	addi	r6,r5,1
 2008580:	003dc406 	br	2007c94 <__alt_mem_mem_0+0xfcfe7c94>
 2008584:	1000d21e 	bne	r2,zero,20088d0 <___vfiprintf_internal_r+0x11b4>
 2008588:	d8c01d87 	ldb	r3,118(sp)
 200858c:	18009526 	beq	r3,zero,20087e4 <___vfiprintf_internal_r+0x10c8>
 2008590:	00800044 	movi	r2,1
 2008594:	d8c01d84 	addi	r3,sp,118
 2008598:	1009883a 	mov	r4,r2
 200859c:	d8c00015 	stw	r3,0(sp)
 20085a0:	d8800115 	stw	r2,4(sp)
 20085a4:	d811883a 	mov	r8,sp
 20085a8:	200b883a 	mov	r5,r4
 20085ac:	42000204 	addi	r8,r8,8
 20085b0:	21000044 	addi	r4,r4,1
 20085b4:	003d9706 	br	2007c14 <__alt_mem_mem_0+0xfcfe7c14>
 20085b8:	d9001d04 	addi	r4,sp,116
 20085bc:	00800084 	movi	r2,2
 20085c0:	d9000015 	stw	r4,0(sp)
 20085c4:	d8800115 	stw	r2,4(sp)
 20085c8:	1809883a 	mov	r4,r3
 20085cc:	d811883a 	mov	r8,sp
 20085d0:	200b883a 	mov	r5,r4
 20085d4:	42000204 	addi	r8,r8,8
 20085d8:	21000044 	addi	r4,r4,1
 20085dc:	003f4e06 	br	2008318 <__alt_mem_mem_0+0xfcfe8318>
 20085e0:	d8001d85 	stb	zero,118(sp)
 20085e4:	48005016 	blt	r9,zero,2008728 <___vfiprintf_internal_r+0x100c>
 20085e8:	00ffdfc4 	movi	r3,-129
 20085ec:	94c4b03a 	or	r2,r18,r19
 20085f0:	a0e8703a 	and	r20,r20,r3
 20085f4:	103d4426 	beq	r2,zero,2007b08 <__alt_mem_mem_0+0xfcfe7b08>
 20085f8:	0039883a 	mov	fp,zero
 20085fc:	d9002617 	ldw	r4,152(sp)
 2008600:	dd401a04 	addi	r21,sp,104
 2008604:	908003cc 	andi	r2,r18,15
 2008608:	9806973a 	slli	r3,r19,28
 200860c:	2085883a 	add	r2,r4,r2
 2008610:	9024d13a 	srli	r18,r18,4
 2008614:	10800003 	ldbu	r2,0(r2)
 2008618:	9826d13a 	srli	r19,r19,4
 200861c:	ad7fffc4 	addi	r21,r21,-1
 2008620:	1ca4b03a 	or	r18,r3,r18
 2008624:	a8800005 	stb	r2,0(r21)
 2008628:	94c4b03a 	or	r2,r18,r19
 200862c:	103ff51e 	bne	r2,zero,2008604 <__alt_mem_mem_0+0xfcfe8604>
 2008630:	003e5906 	br	2007f98 <__alt_mem_mem_0+0xfcfe7f98>
 2008634:	d9402117 	ldw	r5,132(sp)
 2008638:	d9002017 	ldw	r4,128(sp)
 200863c:	d9801a04 	addi	r6,sp,104
 2008640:	20076080 	call	2007608 <__sprint_r.part.0>
 2008644:	103f891e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008648:	d8801c17 	ldw	r2,112(sp)
 200864c:	d811883a 	mov	r8,sp
 2008650:	003f9506 	br	20084a8 <__alt_mem_mem_0+0xfcfe84a8>
 2008654:	d9402117 	ldw	r5,132(sp)
 2008658:	d9002017 	ldw	r4,128(sp)
 200865c:	d9801a04 	addi	r6,sp,104
 2008660:	20076080 	call	2007608 <__sprint_r.part.0>
 2008664:	103f811e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008668:	d811883a 	mov	r8,sp
 200866c:	003ced06 	br	2007a24 <__alt_mem_mem_0+0xfcfe7a24>
 2008670:	d9402117 	ldw	r5,132(sp)
 2008674:	d9002017 	ldw	r4,128(sp)
 2008678:	d9801a04 	addi	r6,sp,104
 200867c:	da402c15 	stw	r9,176(sp)
 2008680:	db802a15 	stw	r14,168(sp)
 2008684:	20076080 	call	2007608 <__sprint_r.part.0>
 2008688:	da402c17 	ldw	r9,176(sp)
 200868c:	db802a17 	ldw	r14,168(sp)
 2008690:	103f761e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008694:	d9401b17 	ldw	r5,108(sp)
 2008698:	d8801c17 	ldw	r2,112(sp)
 200869c:	d811883a 	mov	r8,sp
 20086a0:	29000044 	addi	r4,r5,1
 20086a4:	003d5b06 	br	2007c14 <__alt_mem_mem_0+0xfcfe7c14>
 20086a8:	d9402117 	ldw	r5,132(sp)
 20086ac:	d9002017 	ldw	r4,128(sp)
 20086b0:	d9801a04 	addi	r6,sp,104
 20086b4:	da402c15 	stw	r9,176(sp)
 20086b8:	20076080 	call	2007608 <__sprint_r.part.0>
 20086bc:	da402c17 	ldw	r9,176(sp)
 20086c0:	103f6a1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 20086c4:	d9401b17 	ldw	r5,108(sp)
 20086c8:	d8801c17 	ldw	r2,112(sp)
 20086cc:	d811883a 	mov	r8,sp
 20086d0:	29000044 	addi	r4,r5,1
 20086d4:	003f1006 	br	2008318 <__alt_mem_mem_0+0xfcfe8318>
 20086d8:	1000c31e 	bne	r2,zero,20089e8 <___vfiprintf_internal_r+0x12cc>
 20086dc:	01000044 	movi	r4,1
 20086e0:	000b883a 	mov	r5,zero
 20086e4:	d811883a 	mov	r8,sp
 20086e8:	003f0d06 	br	2008320 <__alt_mem_mem_0+0xfcfe8320>
 20086ec:	d9402117 	ldw	r5,132(sp)
 20086f0:	d9002017 	ldw	r4,128(sp)
 20086f4:	d9801a04 	addi	r6,sp,104
 20086f8:	20076080 	call	2007608 <__sprint_r.part.0>
 20086fc:	103f5b1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008700:	d9001b17 	ldw	r4,108(sp)
 2008704:	d8801c17 	ldw	r2,112(sp)
 2008708:	d811883a 	mov	r8,sp
 200870c:	21000044 	addi	r4,r4,1
 2008710:	003d8006 	br	2007d14 <__alt_mem_mem_0+0xfcfe7d14>
 2008714:	01008134 	movhi	r4,516
 2008718:	2103ce04 	addi	r4,r4,3896
 200871c:	d9002615 	stw	r4,152(sp)
 2008720:	d8c02215 	stw	r3,136(sp)
 2008724:	1029883a 	mov	r20,r2
 2008728:	94c4b03a 	or	r2,r18,r19
 200872c:	103fb21e 	bne	r2,zero,20085f8 <__alt_mem_mem_0+0xfcfe85f8>
 2008730:	0039883a 	mov	fp,zero
 2008734:	00800084 	movi	r2,2
 2008738:	003e6b06 	br	20080e8 <__alt_mem_mem_0+0xfcfe80e8>
 200873c:	da802217 	ldw	r10,136(sp)
 2008740:	d8001d85 	stb	zero,118(sp)
 2008744:	0027883a 	mov	r19,zero
 2008748:	50800104 	addi	r2,r10,4
 200874c:	54800017 	ldw	r18,0(r10)
 2008750:	483e6016 	blt	r9,zero,20080d4 <__alt_mem_mem_0+0xfcfe80d4>
 2008754:	00ffdfc4 	movi	r3,-129
 2008758:	d8802215 	stw	r2,136(sp)
 200875c:	a0e8703a 	and	r20,r20,r3
 2008760:	0039883a 	mov	fp,zero
 2008764:	903ebb26 	beq	r18,zero,2008254 <__alt_mem_mem_0+0xfcfe8254>
 2008768:	00800244 	movi	r2,9
 200876c:	14bdee36 	bltu	r2,r18,2007f28 <__alt_mem_mem_0+0xfcfe7f28>
 2008770:	003eba06 	br	200825c <__alt_mem_mem_0+0xfcfe825c>
 2008774:	00800c04 	movi	r2,48
 2008778:	d8c01d45 	stb	r3,117(sp)
 200877c:	d8801d05 	stb	r2,116(sp)
 2008780:	d8001d85 	stb	zero,118(sp)
 2008784:	a0c00094 	ori	r3,r20,2
 2008788:	4800a916 	blt	r9,zero,2008a30 <___vfiprintf_internal_r+0x1314>
 200878c:	00bfdfc4 	movi	r2,-129
 2008790:	a096703a 	and	r11,r20,r2
 2008794:	5d000094 	ori	r20,r11,2
 2008798:	0039883a 	mov	fp,zero
 200879c:	003f9706 	br	20085fc <__alt_mem_mem_0+0xfcfe85fc>
 20087a0:	8025883a 	mov	r18,r16
 20087a4:	003c2e06 	br	2007860 <__alt_mem_mem_0+0xfcfe7860>
 20087a8:	00808134 	movhi	r2,516
 20087ac:	1083ce04 	addi	r2,r2,3896
 20087b0:	0039883a 	mov	fp,zero
 20087b4:	d8802615 	stw	r2,152(sp)
 20087b8:	003f9006 	br	20085fc <__alt_mem_mem_0+0xfcfe85fc>
 20087bc:	04a5c83a 	sub	r18,zero,r18
 20087c0:	07000b44 	movi	fp,45
 20087c4:	9004c03a 	cmpne	r2,r18,zero
 20087c8:	04e7c83a 	sub	r19,zero,r19
 20087cc:	df001d85 	stb	fp,118(sp)
 20087d0:	98a7c83a 	sub	r19,r19,r2
 20087d4:	48009f16 	blt	r9,zero,2008a54 <___vfiprintf_internal_r+0x1338>
 20087d8:	00bfdfc4 	movi	r2,-129
 20087dc:	a0a8703a 	and	r20,r20,r2
 20087e0:	003dd006 	br	2007f24 <__alt_mem_mem_0+0xfcfe7f24>
 20087e4:	70004c26 	beq	r14,zero,2008918 <___vfiprintf_internal_r+0x11fc>
 20087e8:	00800084 	movi	r2,2
 20087ec:	d8c01d04 	addi	r3,sp,116
 20087f0:	d8c00015 	stw	r3,0(sp)
 20087f4:	d8800115 	stw	r2,4(sp)
 20087f8:	01000044 	movi	r4,1
 20087fc:	d811883a 	mov	r8,sp
 2008800:	003f7306 	br	20085d0 <__alt_mem_mem_0+0xfcfe85d0>
 2008804:	a080100c 	andi	r2,r20,64
 2008808:	da802217 	ldw	r10,136(sp)
 200880c:	103e0626 	beq	r2,zero,2008028 <__alt_mem_mem_0+0xfcfe8028>
 2008810:	5480000f 	ldh	r18,0(r10)
 2008814:	52800104 	addi	r10,r10,4
 2008818:	da802215 	stw	r10,136(sp)
 200881c:	9027d7fa 	srai	r19,r18,31
 2008820:	9805883a 	mov	r2,r19
 2008824:	003db806 	br	2007f08 <__alt_mem_mem_0+0xfcfe7f08>
 2008828:	a080040c 	andi	r2,r20,16
 200882c:	1000091e 	bne	r2,zero,2008854 <___vfiprintf_internal_r+0x1138>
 2008830:	a2c0100c 	andi	r11,r20,64
 2008834:	58000726 	beq	r11,zero,2008854 <___vfiprintf_internal_r+0x1138>
 2008838:	da802217 	ldw	r10,136(sp)
 200883c:	50800017 	ldw	r2,0(r10)
 2008840:	52800104 	addi	r10,r10,4
 2008844:	da802215 	stw	r10,136(sp)
 2008848:	da802317 	ldw	r10,140(sp)
 200884c:	1280000d 	sth	r10,0(r2)
 2008850:	003be706 	br	20077f0 <__alt_mem_mem_0+0xfcfe77f0>
 2008854:	da802217 	ldw	r10,136(sp)
 2008858:	50800017 	ldw	r2,0(r10)
 200885c:	52800104 	addi	r10,r10,4
 2008860:	da802215 	stw	r10,136(sp)
 2008864:	da802317 	ldw	r10,140(sp)
 2008868:	12800015 	stw	r10,0(r2)
 200886c:	003be006 	br	20077f0 <__alt_mem_mem_0+0xfcfe77f0>
 2008870:	a080100c 	andi	r2,r20,64
 2008874:	da802217 	ldw	r10,136(sp)
 2008878:	10003026 	beq	r2,zero,200893c <___vfiprintf_internal_r+0x1220>
 200887c:	5480000b 	ldhu	r18,0(r10)
 2008880:	52800104 	addi	r10,r10,4
 2008884:	0027883a 	mov	r19,zero
 2008888:	da802215 	stw	r10,136(sp)
 200888c:	003d8006 	br	2007e90 <__alt_mem_mem_0+0xfcfe7e90>
 2008890:	80c00007 	ldb	r3,0(r16)
 2008894:	003c0006 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2008898:	a080100c 	andi	r2,r20,64
 200889c:	d8001d85 	stb	zero,118(sp)
 20088a0:	da802217 	ldw	r10,136(sp)
 20088a4:	1000201e 	bne	r2,zero,2008928 <___vfiprintf_internal_r+0x120c>
 20088a8:	50800104 	addi	r2,r10,4
 20088ac:	54800017 	ldw	r18,0(r10)
 20088b0:	0027883a 	mov	r19,zero
 20088b4:	483def0e 	bge	r9,zero,2008074 <__alt_mem_mem_0+0xfcfe8074>
 20088b8:	94c6b03a 	or	r3,r18,r19
 20088bc:	d8802215 	stw	r2,136(sp)
 20088c0:	183d4e1e 	bne	r3,zero,2007dfc <__alt_mem_mem_0+0xfcfe7dfc>
 20088c4:	0039883a 	mov	fp,zero
 20088c8:	0005883a 	mov	r2,zero
 20088cc:	003e0606 	br	20080e8 <__alt_mem_mem_0+0xfcfe80e8>
 20088d0:	d9402117 	ldw	r5,132(sp)
 20088d4:	d9002017 	ldw	r4,128(sp)
 20088d8:	d9801a04 	addi	r6,sp,104
 20088dc:	da402c15 	stw	r9,176(sp)
 20088e0:	db802a15 	stw	r14,168(sp)
 20088e4:	20076080 	call	2007608 <__sprint_r.part.0>
 20088e8:	da402c17 	ldw	r9,176(sp)
 20088ec:	db802a17 	ldw	r14,168(sp)
 20088f0:	103ede1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 20088f4:	d9401b17 	ldw	r5,108(sp)
 20088f8:	d8801c17 	ldw	r2,112(sp)
 20088fc:	d811883a 	mov	r8,sp
 2008900:	29000044 	addi	r4,r5,1
 2008904:	003e7406 	br	20082d8 <__alt_mem_mem_0+0xfcfe82d8>
 2008908:	00bfffc4 	movi	r2,-1
 200890c:	003c5806 	br	2007a70 <__alt_mem_mem_0+0xfcfe7a70>
 2008910:	d811883a 	mov	r8,sp
 2008914:	003ee806 	br	20084b8 <__alt_mem_mem_0+0xfcfe84b8>
 2008918:	000b883a 	mov	r5,zero
 200891c:	01000044 	movi	r4,1
 2008920:	d811883a 	mov	r8,sp
 2008924:	003e7c06 	br	2008318 <__alt_mem_mem_0+0xfcfe8318>
 2008928:	50800104 	addi	r2,r10,4
 200892c:	5480000b 	ldhu	r18,0(r10)
 2008930:	0027883a 	mov	r19,zero
 2008934:	483dcf0e 	bge	r9,zero,2008074 <__alt_mem_mem_0+0xfcfe8074>
 2008938:	003fdf06 	br	20088b8 <__alt_mem_mem_0+0xfcfe88b8>
 200893c:	54800017 	ldw	r18,0(r10)
 2008940:	52800104 	addi	r10,r10,4
 2008944:	0027883a 	mov	r19,zero
 2008948:	da802215 	stw	r10,136(sp)
 200894c:	003d5006 	br	2007e90 <__alt_mem_mem_0+0xfcfe7e90>
 2008950:	50800104 	addi	r2,r10,4
 2008954:	5480000b 	ldhu	r18,0(r10)
 2008958:	0027883a 	mov	r19,zero
 200895c:	483f7d0e 	bge	r9,zero,2008754 <__alt_mem_mem_0+0xfcfe8754>
 2008960:	003ddc06 	br	20080d4 <__alt_mem_mem_0+0xfcfe80d4>
 2008964:	d8c02215 	stw	r3,136(sp)
 2008968:	0039883a 	mov	fp,zero
 200896c:	003ddb06 	br	20080dc <__alt_mem_mem_0+0xfcfe80dc>
 2008970:	02808134 	movhi	r10,516
 2008974:	52842f04 	addi	r10,r10,4284
 2008978:	da802415 	stw	r10,144(sp)
 200897c:	003e8306 	br	200838c <__alt_mem_mem_0+0xfcfe838c>
 2008980:	d8801c17 	ldw	r2,112(sp)
 2008984:	dd002117 	ldw	r20,132(sp)
 2008988:	103eb926 	beq	r2,zero,2008470 <__alt_mem_mem_0+0xfcfe8470>
 200898c:	d9002017 	ldw	r4,128(sp)
 2008990:	d9801a04 	addi	r6,sp,104
 2008994:	a00b883a 	mov	r5,r20
 2008998:	20076080 	call	2007608 <__sprint_r.part.0>
 200899c:	003eb406 	br	2008470 <__alt_mem_mem_0+0xfcfe8470>
 20089a0:	80c00043 	ldbu	r3,1(r16)
 20089a4:	a5000814 	ori	r20,r20,32
 20089a8:	84000044 	addi	r16,r16,1
 20089ac:	18c03fcc 	andi	r3,r3,255
 20089b0:	18c0201c 	xori	r3,r3,128
 20089b4:	18ffe004 	addi	r3,r3,-128
 20089b8:	003bb706 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 20089bc:	a809883a 	mov	r4,r21
 20089c0:	d8c02a15 	stw	r3,168(sp)
 20089c4:	da002b15 	stw	r8,172(sp)
 20089c8:	20075700 	call	2007570 <strlen>
 20089cc:	d8c02a17 	ldw	r3,168(sp)
 20089d0:	1027883a 	mov	r19,r2
 20089d4:	df001d83 	ldbu	fp,118(sp)
 20089d8:	d8c02215 	stw	r3,136(sp)
 20089dc:	0013883a 	mov	r9,zero
 20089e0:	da002b17 	ldw	r8,172(sp)
 20089e4:	003c4d06 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 20089e8:	d9402117 	ldw	r5,132(sp)
 20089ec:	d9002017 	ldw	r4,128(sp)
 20089f0:	d9801a04 	addi	r6,sp,104
 20089f4:	da402c15 	stw	r9,176(sp)
 20089f8:	20076080 	call	2007608 <__sprint_r.part.0>
 20089fc:	da402c17 	ldw	r9,176(sp)
 2008a00:	103e9a1e 	bne	r2,zero,200846c <__alt_mem_mem_0+0xfcfe846c>
 2008a04:	d9401b17 	ldw	r5,108(sp)
 2008a08:	d8801c17 	ldw	r2,112(sp)
 2008a0c:	d811883a 	mov	r8,sp
 2008a10:	29000044 	addi	r4,r5,1
 2008a14:	003e4206 	br	2008320 <__alt_mem_mem_0+0xfcfe8320>
 2008a18:	d9401b17 	ldw	r5,108(sp)
 2008a1c:	01008134 	movhi	r4,516
 2008a20:	21043304 	addi	r4,r4,4300
 2008a24:	d9002415 	stw	r4,144(sp)
 2008a28:	29400044 	addi	r5,r5,1
 2008a2c:	003c6d06 	br	2007be4 <__alt_mem_mem_0+0xfcfe7be4>
 2008a30:	0039883a 	mov	fp,zero
 2008a34:	00800084 	movi	r2,2
 2008a38:	10803fcc 	andi	r2,r2,255
 2008a3c:	01000044 	movi	r4,1
 2008a40:	11001e26 	beq	r2,r4,2008abc <___vfiprintf_internal_r+0x13a0>
 2008a44:	01000084 	movi	r4,2
 2008a48:	11001e1e 	bne	r2,r4,2008ac4 <___vfiprintf_internal_r+0x13a8>
 2008a4c:	1829883a 	mov	r20,r3
 2008a50:	003eea06 	br	20085fc <__alt_mem_mem_0+0xfcfe85fc>
 2008a54:	a007883a 	mov	r3,r20
 2008a58:	00800044 	movi	r2,1
 2008a5c:	003ff606 	br	2008a38 <__alt_mem_mem_0+0xfcfe8a38>
 2008a60:	00800184 	movi	r2,6
 2008a64:	1240012e 	bgeu	r2,r9,2008a6c <___vfiprintf_internal_r+0x1350>
 2008a68:	1013883a 	mov	r9,r2
 2008a6c:	4827883a 	mov	r19,r9
 2008a70:	4825883a 	mov	r18,r9
 2008a74:	48001516 	blt	r9,zero,2008acc <___vfiprintf_internal_r+0x13b0>
 2008a78:	05408134 	movhi	r21,516
 2008a7c:	d8c02215 	stw	r3,136(sp)
 2008a80:	ad43d304 	addi	r21,r21,3916
 2008a84:	003d1406 	br	2007ed8 <__alt_mem_mem_0+0xfcfe7ed8>
 2008a88:	02808134 	movhi	r10,516
 2008a8c:	52842f04 	addi	r10,r10,4284
 2008a90:	da802415 	stw	r10,144(sp)
 2008a94:	200d883a 	mov	r6,r4
 2008a98:	003c9106 	br	2007ce0 <__alt_mem_mem_0+0xfcfe7ce0>
 2008a9c:	5021883a 	mov	r16,r10
 2008aa0:	0013883a 	mov	r9,zero
 2008aa4:	003b7d06 	br	200789c <__alt_mem_mem_0+0xfcfe789c>
 2008aa8:	4827883a 	mov	r19,r9
 2008aac:	df001d83 	ldbu	fp,118(sp)
 2008ab0:	d8c02215 	stw	r3,136(sp)
 2008ab4:	0013883a 	mov	r9,zero
 2008ab8:	003c1806 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2008abc:	1829883a 	mov	r20,r3
 2008ac0:	003d1806 	br	2007f24 <__alt_mem_mem_0+0xfcfe7f24>
 2008ac4:	1829883a 	mov	r20,r3
 2008ac8:	003ccd06 	br	2007e00 <__alt_mem_mem_0+0xfcfe7e00>
 2008acc:	0025883a 	mov	r18,zero
 2008ad0:	003fe906 	br	2008a78 <__alt_mem_mem_0+0xfcfe8a78>
 2008ad4:	d8802217 	ldw	r2,136(sp)
 2008ad8:	80c00043 	ldbu	r3,1(r16)
 2008adc:	5021883a 	mov	r16,r10
 2008ae0:	12400017 	ldw	r9,0(r2)
 2008ae4:	10800104 	addi	r2,r2,4
 2008ae8:	d8802215 	stw	r2,136(sp)
 2008aec:	483faf0e 	bge	r9,zero,20089ac <__alt_mem_mem_0+0xfcfe89ac>
 2008af0:	18c03fcc 	andi	r3,r3,255
 2008af4:	18c0201c 	xori	r3,r3,128
 2008af8:	027fffc4 	movi	r9,-1
 2008afc:	18ffe004 	addi	r3,r3,-128
 2008b00:	003b6506 	br	2007898 <__alt_mem_mem_0+0xfcfe7898>
 2008b04:	d9c01d85 	stb	r7,118(sp)
 2008b08:	003ca006 	br	2007d8c <__alt_mem_mem_0+0xfcfe7d8c>
 2008b0c:	d9c01d85 	stb	r7,118(sp)
 2008b10:	003cad06 	br	2007dc8 <__alt_mem_mem_0+0xfcfe7dc8>
 2008b14:	d9c01d85 	stb	r7,118(sp)
 2008b18:	003d7d06 	br	2008110 <__alt_mem_mem_0+0xfcfe8110>
 2008b1c:	d9c01d85 	stb	r7,118(sp)
 2008b20:	003d5f06 	br	20080a0 <__alt_mem_mem_0+0xfcfe80a0>
 2008b24:	a080004c 	andi	r2,r20,1
 2008b28:	0039883a 	mov	fp,zero
 2008b2c:	10000526 	beq	r2,zero,2008b44 <___vfiprintf_internal_r+0x1428>
 2008b30:	00800c04 	movi	r2,48
 2008b34:	d88019c5 	stb	r2,103(sp)
 2008b38:	dcc02717 	ldw	r19,156(sp)
 2008b3c:	dd4019c4 	addi	r21,sp,103
 2008b40:	003bf606 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2008b44:	0027883a 	mov	r19,zero
 2008b48:	dd401a04 	addi	r21,sp,104
 2008b4c:	003bf306 	br	2007b1c <__alt_mem_mem_0+0xfcfe7b1c>
 2008b50:	d9c01d85 	stb	r7,118(sp)
 2008b54:	003dc806 	br	2008278 <__alt_mem_mem_0+0xfcfe8278>
 2008b58:	d9c01d85 	stb	r7,118(sp)
 2008b5c:	003d3a06 	br	2008048 <__alt_mem_mem_0+0xfcfe8048>
 2008b60:	d9c01d85 	stb	r7,118(sp)
 2008b64:	003d2a06 	br	2008010 <__alt_mem_mem_0+0xfcfe8010>
 2008b68:	d9c01d85 	stb	r7,118(sp)
 2008b6c:	003cde06 	br	2007ee8 <__alt_mem_mem_0+0xfcfe7ee8>
 2008b70:	d9c01d85 	stb	r7,118(sp)
 2008b74:	003cbc06 	br	2007e68 <__alt_mem_mem_0+0xfcfe7e68>

02008b78 <__vfiprintf_internal>:
 2008b78:	00808134 	movhi	r2,516
 2008b7c:	10963d04 	addi	r2,r2,22772
 2008b80:	300f883a 	mov	r7,r6
 2008b84:	280d883a 	mov	r6,r5
 2008b88:	200b883a 	mov	r5,r4
 2008b8c:	11000017 	ldw	r4,0(r2)
 2008b90:	200771c1 	jmpi	200771c <___vfiprintf_internal_r>

02008b94 <__sbprintf>:
 2008b94:	2880030b 	ldhu	r2,12(r5)
 2008b98:	2ac01917 	ldw	r11,100(r5)
 2008b9c:	2a80038b 	ldhu	r10,14(r5)
 2008ba0:	2a400717 	ldw	r9,28(r5)
 2008ba4:	2a000917 	ldw	r8,36(r5)
 2008ba8:	defee204 	addi	sp,sp,-1144
 2008bac:	00c10004 	movi	r3,1024
 2008bb0:	dc011a15 	stw	r16,1128(sp)
 2008bb4:	10bfff4c 	andi	r2,r2,65533
 2008bb8:	2821883a 	mov	r16,r5
 2008bbc:	d8cb883a 	add	r5,sp,r3
 2008bc0:	dc811c15 	stw	r18,1136(sp)
 2008bc4:	dc411b15 	stw	r17,1132(sp)
 2008bc8:	dfc11d15 	stw	ra,1140(sp)
 2008bcc:	2025883a 	mov	r18,r4
 2008bd0:	d881030d 	sth	r2,1036(sp)
 2008bd4:	dac11915 	stw	r11,1124(sp)
 2008bd8:	da81038d 	sth	r10,1038(sp)
 2008bdc:	da410715 	stw	r9,1052(sp)
 2008be0:	da010915 	stw	r8,1060(sp)
 2008be4:	dec10015 	stw	sp,1024(sp)
 2008be8:	dec10415 	stw	sp,1040(sp)
 2008bec:	d8c10215 	stw	r3,1032(sp)
 2008bf0:	d8c10515 	stw	r3,1044(sp)
 2008bf4:	d8010615 	stw	zero,1048(sp)
 2008bf8:	200771c0 	call	200771c <___vfiprintf_internal_r>
 2008bfc:	1023883a 	mov	r17,r2
 2008c00:	10000416 	blt	r2,zero,2008c14 <__sbprintf+0x80>
 2008c04:	d9410004 	addi	r5,sp,1024
 2008c08:	9009883a 	mov	r4,r18
 2008c0c:	2004ab40 	call	2004ab4 <_fflush_r>
 2008c10:	10000d1e 	bne	r2,zero,2008c48 <__sbprintf+0xb4>
 2008c14:	d881030b 	ldhu	r2,1036(sp)
 2008c18:	1080100c 	andi	r2,r2,64
 2008c1c:	10000326 	beq	r2,zero,2008c2c <__sbprintf+0x98>
 2008c20:	8080030b 	ldhu	r2,12(r16)
 2008c24:	10801014 	ori	r2,r2,64
 2008c28:	8080030d 	sth	r2,12(r16)
 2008c2c:	8805883a 	mov	r2,r17
 2008c30:	dfc11d17 	ldw	ra,1140(sp)
 2008c34:	dc811c17 	ldw	r18,1136(sp)
 2008c38:	dc411b17 	ldw	r17,1132(sp)
 2008c3c:	dc011a17 	ldw	r16,1128(sp)
 2008c40:	dec11e04 	addi	sp,sp,1144
 2008c44:	f800283a 	ret
 2008c48:	047fffc4 	movi	r17,-1
 2008c4c:	003ff106 	br	2008c14 <__alt_mem_mem_0+0xfcfe8c14>

02008c50 <_write_r>:
 2008c50:	defffd04 	addi	sp,sp,-12
 2008c54:	2805883a 	mov	r2,r5
 2008c58:	dc000015 	stw	r16,0(sp)
 2008c5c:	04008134 	movhi	r16,516
 2008c60:	dc400115 	stw	r17,4(sp)
 2008c64:	300b883a 	mov	r5,r6
 2008c68:	841e0a04 	addi	r16,r16,30760
 2008c6c:	2023883a 	mov	r17,r4
 2008c70:	380d883a 	mov	r6,r7
 2008c74:	1009883a 	mov	r4,r2
 2008c78:	dfc00215 	stw	ra,8(sp)
 2008c7c:	80000015 	stw	zero,0(r16)
 2008c80:	20132380 	call	2013238 <write>
 2008c84:	00ffffc4 	movi	r3,-1
 2008c88:	10c00526 	beq	r2,r3,2008ca0 <_write_r+0x50>
 2008c8c:	dfc00217 	ldw	ra,8(sp)
 2008c90:	dc400117 	ldw	r17,4(sp)
 2008c94:	dc000017 	ldw	r16,0(sp)
 2008c98:	dec00304 	addi	sp,sp,12
 2008c9c:	f800283a 	ret
 2008ca0:	80c00017 	ldw	r3,0(r16)
 2008ca4:	183ff926 	beq	r3,zero,2008c8c <__alt_mem_mem_0+0xfcfe8c8c>
 2008ca8:	88c00015 	stw	r3,0(r17)
 2008cac:	003ff706 	br	2008c8c <__alt_mem_mem_0+0xfcfe8c8c>

02008cb0 <_close_r>:
 2008cb0:	defffd04 	addi	sp,sp,-12
 2008cb4:	dc000015 	stw	r16,0(sp)
 2008cb8:	04008134 	movhi	r16,516
 2008cbc:	dc400115 	stw	r17,4(sp)
 2008cc0:	841e0a04 	addi	r16,r16,30760
 2008cc4:	2023883a 	mov	r17,r4
 2008cc8:	2809883a 	mov	r4,r5
 2008ccc:	dfc00215 	stw	ra,8(sp)
 2008cd0:	80000015 	stw	zero,0(r16)
 2008cd4:	20131840 	call	2013184 <close>
 2008cd8:	00ffffc4 	movi	r3,-1
 2008cdc:	10c00526 	beq	r2,r3,2008cf4 <_close_r+0x44>
 2008ce0:	dfc00217 	ldw	ra,8(sp)
 2008ce4:	dc400117 	ldw	r17,4(sp)
 2008ce8:	dc000017 	ldw	r16,0(sp)
 2008cec:	dec00304 	addi	sp,sp,12
 2008cf0:	f800283a 	ret
 2008cf4:	80c00017 	ldw	r3,0(r16)
 2008cf8:	183ff926 	beq	r3,zero,2008ce0 <__alt_mem_mem_0+0xfcfe8ce0>
 2008cfc:	88c00015 	stw	r3,0(r17)
 2008d00:	003ff706 	br	2008ce0 <__alt_mem_mem_0+0xfcfe8ce0>

02008d04 <_calloc_r>:
 2008d04:	298b383a 	mul	r5,r5,r6
 2008d08:	defffe04 	addi	sp,sp,-8
 2008d0c:	dfc00115 	stw	ra,4(sp)
 2008d10:	dc000015 	stw	r16,0(sp)
 2008d14:	20057340 	call	2005734 <_malloc_r>
 2008d18:	10002926 	beq	r2,zero,2008dc0 <_calloc_r+0xbc>
 2008d1c:	11bfff17 	ldw	r6,-4(r2)
 2008d20:	1021883a 	mov	r16,r2
 2008d24:	00bfff04 	movi	r2,-4
 2008d28:	308c703a 	and	r6,r6,r2
 2008d2c:	00c00904 	movi	r3,36
 2008d30:	308d883a 	add	r6,r6,r2
 2008d34:	19801636 	bltu	r3,r6,2008d90 <_calloc_r+0x8c>
 2008d38:	008004c4 	movi	r2,19
 2008d3c:	11800b2e 	bgeu	r2,r6,2008d6c <_calloc_r+0x68>
 2008d40:	80000015 	stw	zero,0(r16)
 2008d44:	80000115 	stw	zero,4(r16)
 2008d48:	008006c4 	movi	r2,27
 2008d4c:	11801a2e 	bgeu	r2,r6,2008db8 <_calloc_r+0xb4>
 2008d50:	80000215 	stw	zero,8(r16)
 2008d54:	80000315 	stw	zero,12(r16)
 2008d58:	30c0151e 	bne	r6,r3,2008db0 <_calloc_r+0xac>
 2008d5c:	80000415 	stw	zero,16(r16)
 2008d60:	80800604 	addi	r2,r16,24
 2008d64:	80000515 	stw	zero,20(r16)
 2008d68:	00000106 	br	2008d70 <_calloc_r+0x6c>
 2008d6c:	8005883a 	mov	r2,r16
 2008d70:	10000015 	stw	zero,0(r2)
 2008d74:	10000115 	stw	zero,4(r2)
 2008d78:	10000215 	stw	zero,8(r2)
 2008d7c:	8005883a 	mov	r2,r16
 2008d80:	dfc00117 	ldw	ra,4(sp)
 2008d84:	dc000017 	ldw	r16,0(sp)
 2008d88:	dec00204 	addi	sp,sp,8
 2008d8c:	f800283a 	ret
 2008d90:	000b883a 	mov	r5,zero
 2008d94:	8009883a 	mov	r4,r16
 2008d98:	200616c0 	call	200616c <memset>
 2008d9c:	8005883a 	mov	r2,r16
 2008da0:	dfc00117 	ldw	ra,4(sp)
 2008da4:	dc000017 	ldw	r16,0(sp)
 2008da8:	dec00204 	addi	sp,sp,8
 2008dac:	f800283a 	ret
 2008db0:	80800404 	addi	r2,r16,16
 2008db4:	003fee06 	br	2008d70 <__alt_mem_mem_0+0xfcfe8d70>
 2008db8:	80800204 	addi	r2,r16,8
 2008dbc:	003fec06 	br	2008d70 <__alt_mem_mem_0+0xfcfe8d70>
 2008dc0:	0005883a 	mov	r2,zero
 2008dc4:	003fee06 	br	2008d80 <__alt_mem_mem_0+0xfcfe8d80>

02008dc8 <_fclose_r>:
 2008dc8:	28003926 	beq	r5,zero,2008eb0 <_fclose_r+0xe8>
 2008dcc:	defffc04 	addi	sp,sp,-16
 2008dd0:	dc400115 	stw	r17,4(sp)
 2008dd4:	dc000015 	stw	r16,0(sp)
 2008dd8:	dfc00315 	stw	ra,12(sp)
 2008ddc:	dc800215 	stw	r18,8(sp)
 2008de0:	2023883a 	mov	r17,r4
 2008de4:	2821883a 	mov	r16,r5
 2008de8:	20000226 	beq	r4,zero,2008df4 <_fclose_r+0x2c>
 2008dec:	20800e17 	ldw	r2,56(r4)
 2008df0:	10002726 	beq	r2,zero,2008e90 <_fclose_r+0xc8>
 2008df4:	8080030f 	ldh	r2,12(r16)
 2008df8:	1000071e 	bne	r2,zero,2008e18 <_fclose_r+0x50>
 2008dfc:	0005883a 	mov	r2,zero
 2008e00:	dfc00317 	ldw	ra,12(sp)
 2008e04:	dc800217 	ldw	r18,8(sp)
 2008e08:	dc400117 	ldw	r17,4(sp)
 2008e0c:	dc000017 	ldw	r16,0(sp)
 2008e10:	dec00404 	addi	sp,sp,16
 2008e14:	f800283a 	ret
 2008e18:	800b883a 	mov	r5,r16
 2008e1c:	8809883a 	mov	r4,r17
 2008e20:	20048980 	call	2004898 <__sflush_r>
 2008e24:	1025883a 	mov	r18,r2
 2008e28:	80800b17 	ldw	r2,44(r16)
 2008e2c:	10000426 	beq	r2,zero,2008e40 <_fclose_r+0x78>
 2008e30:	81400717 	ldw	r5,28(r16)
 2008e34:	8809883a 	mov	r4,r17
 2008e38:	103ee83a 	callr	r2
 2008e3c:	10001616 	blt	r2,zero,2008e98 <_fclose_r+0xd0>
 2008e40:	8080030b 	ldhu	r2,12(r16)
 2008e44:	1080200c 	andi	r2,r2,128
 2008e48:	1000151e 	bne	r2,zero,2008ea0 <_fclose_r+0xd8>
 2008e4c:	81400c17 	ldw	r5,48(r16)
 2008e50:	28000526 	beq	r5,zero,2008e68 <_fclose_r+0xa0>
 2008e54:	80801004 	addi	r2,r16,64
 2008e58:	28800226 	beq	r5,r2,2008e64 <_fclose_r+0x9c>
 2008e5c:	8809883a 	mov	r4,r17
 2008e60:	20050040 	call	2005004 <_free_r>
 2008e64:	80000c15 	stw	zero,48(r16)
 2008e68:	81401117 	ldw	r5,68(r16)
 2008e6c:	28000326 	beq	r5,zero,2008e7c <_fclose_r+0xb4>
 2008e70:	8809883a 	mov	r4,r17
 2008e74:	20050040 	call	2005004 <_free_r>
 2008e78:	80001115 	stw	zero,68(r16)
 2008e7c:	2004ea00 	call	2004ea0 <__sfp_lock_acquire>
 2008e80:	8000030d 	sth	zero,12(r16)
 2008e84:	2004ea40 	call	2004ea4 <__sfp_lock_release>
 2008e88:	9005883a 	mov	r2,r18
 2008e8c:	003fdc06 	br	2008e00 <__alt_mem_mem_0+0xfcfe8e00>
 2008e90:	2004e900 	call	2004e90 <__sinit>
 2008e94:	003fd706 	br	2008df4 <__alt_mem_mem_0+0xfcfe8df4>
 2008e98:	04bfffc4 	movi	r18,-1
 2008e9c:	003fe806 	br	2008e40 <__alt_mem_mem_0+0xfcfe8e40>
 2008ea0:	81400417 	ldw	r5,16(r16)
 2008ea4:	8809883a 	mov	r4,r17
 2008ea8:	20050040 	call	2005004 <_free_r>
 2008eac:	003fe706 	br	2008e4c <__alt_mem_mem_0+0xfcfe8e4c>
 2008eb0:	0005883a 	mov	r2,zero
 2008eb4:	f800283a 	ret

02008eb8 <fclose>:
 2008eb8:	00808134 	movhi	r2,516
 2008ebc:	10963d04 	addi	r2,r2,22772
 2008ec0:	200b883a 	mov	r5,r4
 2008ec4:	11000017 	ldw	r4,0(r2)
 2008ec8:	2008dc81 	jmpi	2008dc8 <_fclose_r>

02008ecc <__fputwc>:
 2008ecc:	defff804 	addi	sp,sp,-32
 2008ed0:	dcc00415 	stw	r19,16(sp)
 2008ed4:	dc800315 	stw	r18,12(sp)
 2008ed8:	dc000115 	stw	r16,4(sp)
 2008edc:	dfc00715 	stw	ra,28(sp)
 2008ee0:	dd400615 	stw	r21,24(sp)
 2008ee4:	dd000515 	stw	r20,20(sp)
 2008ee8:	dc400215 	stw	r17,8(sp)
 2008eec:	2027883a 	mov	r19,r4
 2008ef0:	2825883a 	mov	r18,r5
 2008ef4:	3021883a 	mov	r16,r6
 2008ef8:	20055240 	call	2005524 <__locale_mb_cur_max>
 2008efc:	00c00044 	movi	r3,1
 2008f00:	10c03e26 	beq	r2,r3,2008ffc <__fputwc+0x130>
 2008f04:	81c01704 	addi	r7,r16,92
 2008f08:	900d883a 	mov	r6,r18
 2008f0c:	d80b883a 	mov	r5,sp
 2008f10:	9809883a 	mov	r4,r19
 2008f14:	2009f180 	call	2009f18 <_wcrtomb_r>
 2008f18:	1029883a 	mov	r20,r2
 2008f1c:	00bfffc4 	movi	r2,-1
 2008f20:	a0802026 	beq	r20,r2,2008fa4 <__fputwc+0xd8>
 2008f24:	d9400003 	ldbu	r5,0(sp)
 2008f28:	a0001c26 	beq	r20,zero,2008f9c <__fputwc+0xd0>
 2008f2c:	0023883a 	mov	r17,zero
 2008f30:	05400284 	movi	r21,10
 2008f34:	00000906 	br	2008f5c <__fputwc+0x90>
 2008f38:	80800017 	ldw	r2,0(r16)
 2008f3c:	11400005 	stb	r5,0(r2)
 2008f40:	80c00017 	ldw	r3,0(r16)
 2008f44:	18c00044 	addi	r3,r3,1
 2008f48:	80c00015 	stw	r3,0(r16)
 2008f4c:	8c400044 	addi	r17,r17,1
 2008f50:	dc45883a 	add	r2,sp,r17
 2008f54:	8d00112e 	bgeu	r17,r20,2008f9c <__fputwc+0xd0>
 2008f58:	11400003 	ldbu	r5,0(r2)
 2008f5c:	80c00217 	ldw	r3,8(r16)
 2008f60:	18ffffc4 	addi	r3,r3,-1
 2008f64:	80c00215 	stw	r3,8(r16)
 2008f68:	183ff30e 	bge	r3,zero,2008f38 <__alt_mem_mem_0+0xfcfe8f38>
 2008f6c:	80800617 	ldw	r2,24(r16)
 2008f70:	18801916 	blt	r3,r2,2008fd8 <__fputwc+0x10c>
 2008f74:	80800017 	ldw	r2,0(r16)
 2008f78:	11400005 	stb	r5,0(r2)
 2008f7c:	80800017 	ldw	r2,0(r16)
 2008f80:	10c00003 	ldbu	r3,0(r2)
 2008f84:	10800044 	addi	r2,r2,1
 2008f88:	1d402326 	beq	r3,r21,2009018 <__fputwc+0x14c>
 2008f8c:	80800015 	stw	r2,0(r16)
 2008f90:	8c400044 	addi	r17,r17,1
 2008f94:	dc45883a 	add	r2,sp,r17
 2008f98:	8d3fef36 	bltu	r17,r20,2008f58 <__alt_mem_mem_0+0xfcfe8f58>
 2008f9c:	9005883a 	mov	r2,r18
 2008fa0:	00000406 	br	2008fb4 <__fputwc+0xe8>
 2008fa4:	80c0030b 	ldhu	r3,12(r16)
 2008fa8:	a005883a 	mov	r2,r20
 2008fac:	18c01014 	ori	r3,r3,64
 2008fb0:	80c0030d 	sth	r3,12(r16)
 2008fb4:	dfc00717 	ldw	ra,28(sp)
 2008fb8:	dd400617 	ldw	r21,24(sp)
 2008fbc:	dd000517 	ldw	r20,20(sp)
 2008fc0:	dcc00417 	ldw	r19,16(sp)
 2008fc4:	dc800317 	ldw	r18,12(sp)
 2008fc8:	dc400217 	ldw	r17,8(sp)
 2008fcc:	dc000117 	ldw	r16,4(sp)
 2008fd0:	dec00804 	addi	sp,sp,32
 2008fd4:	f800283a 	ret
 2008fd8:	800d883a 	mov	r6,r16
 2008fdc:	29403fcc 	andi	r5,r5,255
 2008fe0:	9809883a 	mov	r4,r19
 2008fe4:	2009dc00 	call	2009dc0 <__swbuf_r>
 2008fe8:	10bfffe0 	cmpeqi	r2,r2,-1
 2008fec:	10803fcc 	andi	r2,r2,255
 2008ff0:	103fd626 	beq	r2,zero,2008f4c <__alt_mem_mem_0+0xfcfe8f4c>
 2008ff4:	00bfffc4 	movi	r2,-1
 2008ff8:	003fee06 	br	2008fb4 <__alt_mem_mem_0+0xfcfe8fb4>
 2008ffc:	90ffffc4 	addi	r3,r18,-1
 2009000:	01003f84 	movi	r4,254
 2009004:	20ffbf36 	bltu	r4,r3,2008f04 <__alt_mem_mem_0+0xfcfe8f04>
 2009008:	900b883a 	mov	r5,r18
 200900c:	dc800005 	stb	r18,0(sp)
 2009010:	1029883a 	mov	r20,r2
 2009014:	003fc506 	br	2008f2c <__alt_mem_mem_0+0xfcfe8f2c>
 2009018:	800d883a 	mov	r6,r16
 200901c:	a80b883a 	mov	r5,r21
 2009020:	9809883a 	mov	r4,r19
 2009024:	2009dc00 	call	2009dc0 <__swbuf_r>
 2009028:	10bfffe0 	cmpeqi	r2,r2,-1
 200902c:	003fef06 	br	2008fec <__alt_mem_mem_0+0xfcfe8fec>

02009030 <_fputwc_r>:
 2009030:	3080030b 	ldhu	r2,12(r6)
 2009034:	10c8000c 	andi	r3,r2,8192
 2009038:	1800051e 	bne	r3,zero,2009050 <_fputwc_r+0x20>
 200903c:	30c01917 	ldw	r3,100(r6)
 2009040:	10880014 	ori	r2,r2,8192
 2009044:	3080030d 	sth	r2,12(r6)
 2009048:	18880014 	ori	r2,r3,8192
 200904c:	30801915 	stw	r2,100(r6)
 2009050:	2008ecc1 	jmpi	2008ecc <__fputwc>

02009054 <fputwc>:
 2009054:	00808134 	movhi	r2,516
 2009058:	defffc04 	addi	sp,sp,-16
 200905c:	10963d04 	addi	r2,r2,22772
 2009060:	dc000115 	stw	r16,4(sp)
 2009064:	14000017 	ldw	r16,0(r2)
 2009068:	dc400215 	stw	r17,8(sp)
 200906c:	dfc00315 	stw	ra,12(sp)
 2009070:	2023883a 	mov	r17,r4
 2009074:	80000226 	beq	r16,zero,2009080 <fputwc+0x2c>
 2009078:	80800e17 	ldw	r2,56(r16)
 200907c:	10001026 	beq	r2,zero,20090c0 <fputwc+0x6c>
 2009080:	2880030b 	ldhu	r2,12(r5)
 2009084:	10c8000c 	andi	r3,r2,8192
 2009088:	1800051e 	bne	r3,zero,20090a0 <fputwc+0x4c>
 200908c:	28c01917 	ldw	r3,100(r5)
 2009090:	10880014 	ori	r2,r2,8192
 2009094:	2880030d 	sth	r2,12(r5)
 2009098:	18880014 	ori	r2,r3,8192
 200909c:	28801915 	stw	r2,100(r5)
 20090a0:	280d883a 	mov	r6,r5
 20090a4:	8009883a 	mov	r4,r16
 20090a8:	880b883a 	mov	r5,r17
 20090ac:	dfc00317 	ldw	ra,12(sp)
 20090b0:	dc400217 	ldw	r17,8(sp)
 20090b4:	dc000117 	ldw	r16,4(sp)
 20090b8:	dec00404 	addi	sp,sp,16
 20090bc:	2008ecc1 	jmpi	2008ecc <__fputwc>
 20090c0:	8009883a 	mov	r4,r16
 20090c4:	d9400015 	stw	r5,0(sp)
 20090c8:	2004e900 	call	2004e90 <__sinit>
 20090cc:	d9400017 	ldw	r5,0(sp)
 20090d0:	003feb06 	br	2009080 <__alt_mem_mem_0+0xfcfe9080>

020090d4 <_fstat_r>:
 20090d4:	defffd04 	addi	sp,sp,-12
 20090d8:	2805883a 	mov	r2,r5
 20090dc:	dc000015 	stw	r16,0(sp)
 20090e0:	04008134 	movhi	r16,516
 20090e4:	dc400115 	stw	r17,4(sp)
 20090e8:	841e0a04 	addi	r16,r16,30760
 20090ec:	2023883a 	mov	r17,r4
 20090f0:	300b883a 	mov	r5,r6
 20090f4:	1009883a 	mov	r4,r2
 20090f8:	dfc00215 	stw	ra,8(sp)
 20090fc:	80000015 	stw	zero,0(r16)
 2009100:	20126e80 	call	20126e8 <fstat>
 2009104:	00ffffc4 	movi	r3,-1
 2009108:	10c00526 	beq	r2,r3,2009120 <_fstat_r+0x4c>
 200910c:	dfc00217 	ldw	ra,8(sp)
 2009110:	dc400117 	ldw	r17,4(sp)
 2009114:	dc000017 	ldw	r16,0(sp)
 2009118:	dec00304 	addi	sp,sp,12
 200911c:	f800283a 	ret
 2009120:	80c00017 	ldw	r3,0(r16)
 2009124:	183ff926 	beq	r3,zero,200910c <__alt_mem_mem_0+0xfcfe910c>
 2009128:	88c00015 	stw	r3,0(r17)
 200912c:	003ff706 	br	200910c <__alt_mem_mem_0+0xfcfe910c>

02009130 <__sfvwrite_r>:
 2009130:	30800217 	ldw	r2,8(r6)
 2009134:	10006726 	beq	r2,zero,20092d4 <__sfvwrite_r+0x1a4>
 2009138:	28c0030b 	ldhu	r3,12(r5)
 200913c:	defff404 	addi	sp,sp,-48
 2009140:	dd400715 	stw	r21,28(sp)
 2009144:	dd000615 	stw	r20,24(sp)
 2009148:	dc000215 	stw	r16,8(sp)
 200914c:	dfc00b15 	stw	ra,44(sp)
 2009150:	df000a15 	stw	fp,40(sp)
 2009154:	ddc00915 	stw	r23,36(sp)
 2009158:	dd800815 	stw	r22,32(sp)
 200915c:	dcc00515 	stw	r19,20(sp)
 2009160:	dc800415 	stw	r18,16(sp)
 2009164:	dc400315 	stw	r17,12(sp)
 2009168:	1880020c 	andi	r2,r3,8
 200916c:	2821883a 	mov	r16,r5
 2009170:	202b883a 	mov	r21,r4
 2009174:	3029883a 	mov	r20,r6
 2009178:	10002726 	beq	r2,zero,2009218 <__sfvwrite_r+0xe8>
 200917c:	28800417 	ldw	r2,16(r5)
 2009180:	10002526 	beq	r2,zero,2009218 <__sfvwrite_r+0xe8>
 2009184:	1880008c 	andi	r2,r3,2
 2009188:	a4400017 	ldw	r17,0(r20)
 200918c:	10002a26 	beq	r2,zero,2009238 <__sfvwrite_r+0x108>
 2009190:	05a00034 	movhi	r22,32768
 2009194:	0027883a 	mov	r19,zero
 2009198:	0025883a 	mov	r18,zero
 200919c:	b5bf0004 	addi	r22,r22,-1024
 20091a0:	980d883a 	mov	r6,r19
 20091a4:	a809883a 	mov	r4,r21
 20091a8:	90004626 	beq	r18,zero,20092c4 <__sfvwrite_r+0x194>
 20091ac:	900f883a 	mov	r7,r18
 20091b0:	b480022e 	bgeu	r22,r18,20091bc <__sfvwrite_r+0x8c>
 20091b4:	01e00034 	movhi	r7,32768
 20091b8:	39ff0004 	addi	r7,r7,-1024
 20091bc:	80800917 	ldw	r2,36(r16)
 20091c0:	81400717 	ldw	r5,28(r16)
 20091c4:	103ee83a 	callr	r2
 20091c8:	0080570e 	bge	zero,r2,2009328 <__sfvwrite_r+0x1f8>
 20091cc:	a0c00217 	ldw	r3,8(r20)
 20091d0:	98a7883a 	add	r19,r19,r2
 20091d4:	90a5c83a 	sub	r18,r18,r2
 20091d8:	1885c83a 	sub	r2,r3,r2
 20091dc:	a0800215 	stw	r2,8(r20)
 20091e0:	103fef1e 	bne	r2,zero,20091a0 <__alt_mem_mem_0+0xfcfe91a0>
 20091e4:	0005883a 	mov	r2,zero
 20091e8:	dfc00b17 	ldw	ra,44(sp)
 20091ec:	df000a17 	ldw	fp,40(sp)
 20091f0:	ddc00917 	ldw	r23,36(sp)
 20091f4:	dd800817 	ldw	r22,32(sp)
 20091f8:	dd400717 	ldw	r21,28(sp)
 20091fc:	dd000617 	ldw	r20,24(sp)
 2009200:	dcc00517 	ldw	r19,20(sp)
 2009204:	dc800417 	ldw	r18,16(sp)
 2009208:	dc400317 	ldw	r17,12(sp)
 200920c:	dc000217 	ldw	r16,8(sp)
 2009210:	dec00c04 	addi	sp,sp,48
 2009214:	f800283a 	ret
 2009218:	800b883a 	mov	r5,r16
 200921c:	a809883a 	mov	r4,r21
 2009220:	2002ebc0 	call	2002ebc <__swsetup_r>
 2009224:	1000eb1e 	bne	r2,zero,20095d4 <__sfvwrite_r+0x4a4>
 2009228:	80c0030b 	ldhu	r3,12(r16)
 200922c:	a4400017 	ldw	r17,0(r20)
 2009230:	1880008c 	andi	r2,r3,2
 2009234:	103fd61e 	bne	r2,zero,2009190 <__alt_mem_mem_0+0xfcfe9190>
 2009238:	1880004c 	andi	r2,r3,1
 200923c:	10003f1e 	bne	r2,zero,200933c <__sfvwrite_r+0x20c>
 2009240:	0039883a 	mov	fp,zero
 2009244:	0025883a 	mov	r18,zero
 2009248:	90001a26 	beq	r18,zero,20092b4 <__sfvwrite_r+0x184>
 200924c:	1880800c 	andi	r2,r3,512
 2009250:	84c00217 	ldw	r19,8(r16)
 2009254:	10002126 	beq	r2,zero,20092dc <__sfvwrite_r+0x1ac>
 2009258:	982f883a 	mov	r23,r19
 200925c:	94c09336 	bltu	r18,r19,20094ac <__sfvwrite_r+0x37c>
 2009260:	1881200c 	andi	r2,r3,1152
 2009264:	10009e1e 	bne	r2,zero,20094e0 <__sfvwrite_r+0x3b0>
 2009268:	81000017 	ldw	r4,0(r16)
 200926c:	b80d883a 	mov	r6,r23
 2009270:	e00b883a 	mov	r5,fp
 2009274:	20096a00 	call	20096a0 <memmove>
 2009278:	80c00217 	ldw	r3,8(r16)
 200927c:	81000017 	ldw	r4,0(r16)
 2009280:	9005883a 	mov	r2,r18
 2009284:	1ce7c83a 	sub	r19,r3,r19
 2009288:	25cf883a 	add	r7,r4,r23
 200928c:	84c00215 	stw	r19,8(r16)
 2009290:	81c00015 	stw	r7,0(r16)
 2009294:	a0c00217 	ldw	r3,8(r20)
 2009298:	e0b9883a 	add	fp,fp,r2
 200929c:	90a5c83a 	sub	r18,r18,r2
 20092a0:	18a7c83a 	sub	r19,r3,r2
 20092a4:	a4c00215 	stw	r19,8(r20)
 20092a8:	983fce26 	beq	r19,zero,20091e4 <__alt_mem_mem_0+0xfcfe91e4>
 20092ac:	80c0030b 	ldhu	r3,12(r16)
 20092b0:	903fe61e 	bne	r18,zero,200924c <__alt_mem_mem_0+0xfcfe924c>
 20092b4:	8f000017 	ldw	fp,0(r17)
 20092b8:	8c800117 	ldw	r18,4(r17)
 20092bc:	8c400204 	addi	r17,r17,8
 20092c0:	003fe106 	br	2009248 <__alt_mem_mem_0+0xfcfe9248>
 20092c4:	8cc00017 	ldw	r19,0(r17)
 20092c8:	8c800117 	ldw	r18,4(r17)
 20092cc:	8c400204 	addi	r17,r17,8
 20092d0:	003fb306 	br	20091a0 <__alt_mem_mem_0+0xfcfe91a0>
 20092d4:	0005883a 	mov	r2,zero
 20092d8:	f800283a 	ret
 20092dc:	81000017 	ldw	r4,0(r16)
 20092e0:	80800417 	ldw	r2,16(r16)
 20092e4:	11005736 	bltu	r2,r4,2009444 <__sfvwrite_r+0x314>
 20092e8:	85c00517 	ldw	r23,20(r16)
 20092ec:	95c05536 	bltu	r18,r23,2009444 <__sfvwrite_r+0x314>
 20092f0:	00a00034 	movhi	r2,32768
 20092f4:	10bfffc4 	addi	r2,r2,-1
 20092f8:	9009883a 	mov	r4,r18
 20092fc:	1480012e 	bgeu	r2,r18,2009304 <__sfvwrite_r+0x1d4>
 2009300:	1009883a 	mov	r4,r2
 2009304:	b80b883a 	mov	r5,r23
 2009308:	200abb00 	call	200abb0 <__divsi3>
 200930c:	15cf383a 	mul	r7,r2,r23
 2009310:	81400717 	ldw	r5,28(r16)
 2009314:	80800917 	ldw	r2,36(r16)
 2009318:	e00d883a 	mov	r6,fp
 200931c:	a809883a 	mov	r4,r21
 2009320:	103ee83a 	callr	r2
 2009324:	00bfdb16 	blt	zero,r2,2009294 <__alt_mem_mem_0+0xfcfe9294>
 2009328:	8080030b 	ldhu	r2,12(r16)
 200932c:	10801014 	ori	r2,r2,64
 2009330:	8080030d 	sth	r2,12(r16)
 2009334:	00bfffc4 	movi	r2,-1
 2009338:	003fab06 	br	20091e8 <__alt_mem_mem_0+0xfcfe91e8>
 200933c:	0027883a 	mov	r19,zero
 2009340:	0011883a 	mov	r8,zero
 2009344:	0039883a 	mov	fp,zero
 2009348:	0025883a 	mov	r18,zero
 200934c:	90001f26 	beq	r18,zero,20093cc <__sfvwrite_r+0x29c>
 2009350:	40005a26 	beq	r8,zero,20094bc <__sfvwrite_r+0x38c>
 2009354:	982d883a 	mov	r22,r19
 2009358:	94c0012e 	bgeu	r18,r19,2009360 <__sfvwrite_r+0x230>
 200935c:	902d883a 	mov	r22,r18
 2009360:	81000017 	ldw	r4,0(r16)
 2009364:	80800417 	ldw	r2,16(r16)
 2009368:	b02f883a 	mov	r23,r22
 200936c:	81c00517 	ldw	r7,20(r16)
 2009370:	1100032e 	bgeu	r2,r4,2009380 <__sfvwrite_r+0x250>
 2009374:	80c00217 	ldw	r3,8(r16)
 2009378:	38c7883a 	add	r3,r7,r3
 200937c:	1d801816 	blt	r3,r22,20093e0 <__sfvwrite_r+0x2b0>
 2009380:	b1c03e16 	blt	r22,r7,200947c <__sfvwrite_r+0x34c>
 2009384:	80800917 	ldw	r2,36(r16)
 2009388:	81400717 	ldw	r5,28(r16)
 200938c:	e00d883a 	mov	r6,fp
 2009390:	da000115 	stw	r8,4(sp)
 2009394:	a809883a 	mov	r4,r21
 2009398:	103ee83a 	callr	r2
 200939c:	102f883a 	mov	r23,r2
 20093a0:	da000117 	ldw	r8,4(sp)
 20093a4:	00bfe00e 	bge	zero,r2,2009328 <__alt_mem_mem_0+0xfcfe9328>
 20093a8:	9de7c83a 	sub	r19,r19,r23
 20093ac:	98001f26 	beq	r19,zero,200942c <__sfvwrite_r+0x2fc>
 20093b0:	a0800217 	ldw	r2,8(r20)
 20093b4:	e5f9883a 	add	fp,fp,r23
 20093b8:	95e5c83a 	sub	r18,r18,r23
 20093bc:	15efc83a 	sub	r23,r2,r23
 20093c0:	a5c00215 	stw	r23,8(r20)
 20093c4:	b83f8726 	beq	r23,zero,20091e4 <__alt_mem_mem_0+0xfcfe91e4>
 20093c8:	903fe11e 	bne	r18,zero,2009350 <__alt_mem_mem_0+0xfcfe9350>
 20093cc:	8f000017 	ldw	fp,0(r17)
 20093d0:	8c800117 	ldw	r18,4(r17)
 20093d4:	0011883a 	mov	r8,zero
 20093d8:	8c400204 	addi	r17,r17,8
 20093dc:	003fdb06 	br	200934c <__alt_mem_mem_0+0xfcfe934c>
 20093e0:	180d883a 	mov	r6,r3
 20093e4:	e00b883a 	mov	r5,fp
 20093e8:	da000115 	stw	r8,4(sp)
 20093ec:	d8c00015 	stw	r3,0(sp)
 20093f0:	20096a00 	call	20096a0 <memmove>
 20093f4:	d8c00017 	ldw	r3,0(sp)
 20093f8:	80800017 	ldw	r2,0(r16)
 20093fc:	800b883a 	mov	r5,r16
 2009400:	a809883a 	mov	r4,r21
 2009404:	10c5883a 	add	r2,r2,r3
 2009408:	80800015 	stw	r2,0(r16)
 200940c:	d8c00015 	stw	r3,0(sp)
 2009410:	2004ab40 	call	2004ab4 <_fflush_r>
 2009414:	d8c00017 	ldw	r3,0(sp)
 2009418:	da000117 	ldw	r8,4(sp)
 200941c:	103fc21e 	bne	r2,zero,2009328 <__alt_mem_mem_0+0xfcfe9328>
 2009420:	182f883a 	mov	r23,r3
 2009424:	9de7c83a 	sub	r19,r19,r23
 2009428:	983fe11e 	bne	r19,zero,20093b0 <__alt_mem_mem_0+0xfcfe93b0>
 200942c:	800b883a 	mov	r5,r16
 2009430:	a809883a 	mov	r4,r21
 2009434:	2004ab40 	call	2004ab4 <_fflush_r>
 2009438:	103fbb1e 	bne	r2,zero,2009328 <__alt_mem_mem_0+0xfcfe9328>
 200943c:	0011883a 	mov	r8,zero
 2009440:	003fdb06 	br	20093b0 <__alt_mem_mem_0+0xfcfe93b0>
 2009444:	94c0012e 	bgeu	r18,r19,200944c <__sfvwrite_r+0x31c>
 2009448:	9027883a 	mov	r19,r18
 200944c:	980d883a 	mov	r6,r19
 2009450:	e00b883a 	mov	r5,fp
 2009454:	20096a00 	call	20096a0 <memmove>
 2009458:	80800217 	ldw	r2,8(r16)
 200945c:	80c00017 	ldw	r3,0(r16)
 2009460:	14c5c83a 	sub	r2,r2,r19
 2009464:	1cc7883a 	add	r3,r3,r19
 2009468:	80800215 	stw	r2,8(r16)
 200946c:	80c00015 	stw	r3,0(r16)
 2009470:	10004326 	beq	r2,zero,2009580 <__sfvwrite_r+0x450>
 2009474:	9805883a 	mov	r2,r19
 2009478:	003f8606 	br	2009294 <__alt_mem_mem_0+0xfcfe9294>
 200947c:	b00d883a 	mov	r6,r22
 2009480:	e00b883a 	mov	r5,fp
 2009484:	da000115 	stw	r8,4(sp)
 2009488:	20096a00 	call	20096a0 <memmove>
 200948c:	80800217 	ldw	r2,8(r16)
 2009490:	80c00017 	ldw	r3,0(r16)
 2009494:	da000117 	ldw	r8,4(sp)
 2009498:	1585c83a 	sub	r2,r2,r22
 200949c:	1dad883a 	add	r22,r3,r22
 20094a0:	80800215 	stw	r2,8(r16)
 20094a4:	85800015 	stw	r22,0(r16)
 20094a8:	003fbf06 	br	20093a8 <__alt_mem_mem_0+0xfcfe93a8>
 20094ac:	81000017 	ldw	r4,0(r16)
 20094b0:	9027883a 	mov	r19,r18
 20094b4:	902f883a 	mov	r23,r18
 20094b8:	003f6c06 	br	200926c <__alt_mem_mem_0+0xfcfe926c>
 20094bc:	900d883a 	mov	r6,r18
 20094c0:	01400284 	movi	r5,10
 20094c4:	e009883a 	mov	r4,fp
 20094c8:	2005f400 	call	2005f40 <memchr>
 20094cc:	10003e26 	beq	r2,zero,20095c8 <__sfvwrite_r+0x498>
 20094d0:	10800044 	addi	r2,r2,1
 20094d4:	1727c83a 	sub	r19,r2,fp
 20094d8:	02000044 	movi	r8,1
 20094dc:	003f9d06 	br	2009354 <__alt_mem_mem_0+0xfcfe9354>
 20094e0:	80800517 	ldw	r2,20(r16)
 20094e4:	81400417 	ldw	r5,16(r16)
 20094e8:	81c00017 	ldw	r7,0(r16)
 20094ec:	10a7883a 	add	r19,r2,r2
 20094f0:	9885883a 	add	r2,r19,r2
 20094f4:	1026d7fa 	srli	r19,r2,31
 20094f8:	396dc83a 	sub	r22,r7,r5
 20094fc:	b1000044 	addi	r4,r22,1
 2009500:	9885883a 	add	r2,r19,r2
 2009504:	1027d07a 	srai	r19,r2,1
 2009508:	2485883a 	add	r2,r4,r18
 200950c:	980d883a 	mov	r6,r19
 2009510:	9880022e 	bgeu	r19,r2,200951c <__sfvwrite_r+0x3ec>
 2009514:	1027883a 	mov	r19,r2
 2009518:	100d883a 	mov	r6,r2
 200951c:	18c1000c 	andi	r3,r3,1024
 2009520:	18001c26 	beq	r3,zero,2009594 <__sfvwrite_r+0x464>
 2009524:	300b883a 	mov	r5,r6
 2009528:	a809883a 	mov	r4,r21
 200952c:	20057340 	call	2005734 <_malloc_r>
 2009530:	102f883a 	mov	r23,r2
 2009534:	10002926 	beq	r2,zero,20095dc <__sfvwrite_r+0x4ac>
 2009538:	81400417 	ldw	r5,16(r16)
 200953c:	b00d883a 	mov	r6,r22
 2009540:	1009883a 	mov	r4,r2
 2009544:	20060240 	call	2006024 <memcpy>
 2009548:	8080030b 	ldhu	r2,12(r16)
 200954c:	00fedfc4 	movi	r3,-1153
 2009550:	10c4703a 	and	r2,r2,r3
 2009554:	10802014 	ori	r2,r2,128
 2009558:	8080030d 	sth	r2,12(r16)
 200955c:	bd89883a 	add	r4,r23,r22
 2009560:	9d8fc83a 	sub	r7,r19,r22
 2009564:	85c00415 	stw	r23,16(r16)
 2009568:	84c00515 	stw	r19,20(r16)
 200956c:	81000015 	stw	r4,0(r16)
 2009570:	9027883a 	mov	r19,r18
 2009574:	81c00215 	stw	r7,8(r16)
 2009578:	902f883a 	mov	r23,r18
 200957c:	003f3b06 	br	200926c <__alt_mem_mem_0+0xfcfe926c>
 2009580:	800b883a 	mov	r5,r16
 2009584:	a809883a 	mov	r4,r21
 2009588:	2004ab40 	call	2004ab4 <_fflush_r>
 200958c:	103fb926 	beq	r2,zero,2009474 <__alt_mem_mem_0+0xfcfe9474>
 2009590:	003f6506 	br	2009328 <__alt_mem_mem_0+0xfcfe9328>
 2009594:	a809883a 	mov	r4,r21
 2009598:	200985c0 	call	200985c <_realloc_r>
 200959c:	102f883a 	mov	r23,r2
 20095a0:	103fee1e 	bne	r2,zero,200955c <__alt_mem_mem_0+0xfcfe955c>
 20095a4:	81400417 	ldw	r5,16(r16)
 20095a8:	a809883a 	mov	r4,r21
 20095ac:	20050040 	call	2005004 <_free_r>
 20095b0:	8080030b 	ldhu	r2,12(r16)
 20095b4:	00ffdfc4 	movi	r3,-129
 20095b8:	1884703a 	and	r2,r3,r2
 20095bc:	00c00304 	movi	r3,12
 20095c0:	a8c00015 	stw	r3,0(r21)
 20095c4:	003f5906 	br	200932c <__alt_mem_mem_0+0xfcfe932c>
 20095c8:	94c00044 	addi	r19,r18,1
 20095cc:	02000044 	movi	r8,1
 20095d0:	003f6006 	br	2009354 <__alt_mem_mem_0+0xfcfe9354>
 20095d4:	00bfffc4 	movi	r2,-1
 20095d8:	003f0306 	br	20091e8 <__alt_mem_mem_0+0xfcfe91e8>
 20095dc:	00800304 	movi	r2,12
 20095e0:	a8800015 	stw	r2,0(r21)
 20095e4:	8080030b 	ldhu	r2,12(r16)
 20095e8:	003f5006 	br	200932c <__alt_mem_mem_0+0xfcfe932c>

020095ec <_isatty_r>:
 20095ec:	defffd04 	addi	sp,sp,-12
 20095f0:	dc000015 	stw	r16,0(sp)
 20095f4:	04008134 	movhi	r16,516
 20095f8:	dc400115 	stw	r17,4(sp)
 20095fc:	841e0a04 	addi	r16,r16,30760
 2009600:	2023883a 	mov	r17,r4
 2009604:	2809883a 	mov	r4,r5
 2009608:	dfc00215 	stw	ra,8(sp)
 200960c:	80000015 	stw	zero,0(r16)
 2009610:	20129140 	call	2012914 <isatty>
 2009614:	00ffffc4 	movi	r3,-1
 2009618:	10c00526 	beq	r2,r3,2009630 <_isatty_r+0x44>
 200961c:	dfc00217 	ldw	ra,8(sp)
 2009620:	dc400117 	ldw	r17,4(sp)
 2009624:	dc000017 	ldw	r16,0(sp)
 2009628:	dec00304 	addi	sp,sp,12
 200962c:	f800283a 	ret
 2009630:	80c00017 	ldw	r3,0(r16)
 2009634:	183ff926 	beq	r3,zero,200961c <__alt_mem_mem_0+0xfcfe961c>
 2009638:	88c00015 	stw	r3,0(r17)
 200963c:	003ff706 	br	200961c <__alt_mem_mem_0+0xfcfe961c>

02009640 <_lseek_r>:
 2009640:	defffd04 	addi	sp,sp,-12
 2009644:	2805883a 	mov	r2,r5
 2009648:	dc000015 	stw	r16,0(sp)
 200964c:	04008134 	movhi	r16,516
 2009650:	dc400115 	stw	r17,4(sp)
 2009654:	300b883a 	mov	r5,r6
 2009658:	841e0a04 	addi	r16,r16,30760
 200965c:	2023883a 	mov	r17,r4
 2009660:	380d883a 	mov	r6,r7
 2009664:	1009883a 	mov	r4,r2
 2009668:	dfc00215 	stw	ra,8(sp)
 200966c:	80000015 	stw	zero,0(r16)
 2009670:	2012ae00 	call	2012ae0 <lseek>
 2009674:	00ffffc4 	movi	r3,-1
 2009678:	10c00526 	beq	r2,r3,2009690 <_lseek_r+0x50>
 200967c:	dfc00217 	ldw	ra,8(sp)
 2009680:	dc400117 	ldw	r17,4(sp)
 2009684:	dc000017 	ldw	r16,0(sp)
 2009688:	dec00304 	addi	sp,sp,12
 200968c:	f800283a 	ret
 2009690:	80c00017 	ldw	r3,0(r16)
 2009694:	183ff926 	beq	r3,zero,200967c <__alt_mem_mem_0+0xfcfe967c>
 2009698:	88c00015 	stw	r3,0(r17)
 200969c:	003ff706 	br	200967c <__alt_mem_mem_0+0xfcfe967c>

020096a0 <memmove>:
 20096a0:	2005883a 	mov	r2,r4
 20096a4:	29000b2e 	bgeu	r5,r4,20096d4 <memmove+0x34>
 20096a8:	298f883a 	add	r7,r5,r6
 20096ac:	21c0092e 	bgeu	r4,r7,20096d4 <memmove+0x34>
 20096b0:	2187883a 	add	r3,r4,r6
 20096b4:	198bc83a 	sub	r5,r3,r6
 20096b8:	30004826 	beq	r6,zero,20097dc <memmove+0x13c>
 20096bc:	39ffffc4 	addi	r7,r7,-1
 20096c0:	39000003 	ldbu	r4,0(r7)
 20096c4:	18ffffc4 	addi	r3,r3,-1
 20096c8:	19000005 	stb	r4,0(r3)
 20096cc:	28fffb1e 	bne	r5,r3,20096bc <__alt_mem_mem_0+0xfcfe96bc>
 20096d0:	f800283a 	ret
 20096d4:	00c003c4 	movi	r3,15
 20096d8:	1980412e 	bgeu	r3,r6,20097e0 <memmove+0x140>
 20096dc:	2886b03a 	or	r3,r5,r2
 20096e0:	18c000cc 	andi	r3,r3,3
 20096e4:	1800401e 	bne	r3,zero,20097e8 <memmove+0x148>
 20096e8:	33fffc04 	addi	r15,r6,-16
 20096ec:	781ed13a 	srli	r15,r15,4
 20096f0:	28c00104 	addi	r3,r5,4
 20096f4:	13400104 	addi	r13,r2,4
 20096f8:	781c913a 	slli	r14,r15,4
 20096fc:	2b000204 	addi	r12,r5,8
 2009700:	12c00204 	addi	r11,r2,8
 2009704:	73800504 	addi	r14,r14,20
 2009708:	2a800304 	addi	r10,r5,12
 200970c:	12400304 	addi	r9,r2,12
 2009710:	2b9d883a 	add	r14,r5,r14
 2009714:	2811883a 	mov	r8,r5
 2009718:	100f883a 	mov	r7,r2
 200971c:	41000017 	ldw	r4,0(r8)
 2009720:	39c00404 	addi	r7,r7,16
 2009724:	18c00404 	addi	r3,r3,16
 2009728:	393ffc15 	stw	r4,-16(r7)
 200972c:	193ffc17 	ldw	r4,-16(r3)
 2009730:	6b400404 	addi	r13,r13,16
 2009734:	5ac00404 	addi	r11,r11,16
 2009738:	693ffc15 	stw	r4,-16(r13)
 200973c:	61000017 	ldw	r4,0(r12)
 2009740:	4a400404 	addi	r9,r9,16
 2009744:	42000404 	addi	r8,r8,16
 2009748:	593ffc15 	stw	r4,-16(r11)
 200974c:	51000017 	ldw	r4,0(r10)
 2009750:	63000404 	addi	r12,r12,16
 2009754:	52800404 	addi	r10,r10,16
 2009758:	493ffc15 	stw	r4,-16(r9)
 200975c:	1bbfef1e 	bne	r3,r14,200971c <__alt_mem_mem_0+0xfcfe971c>
 2009760:	79000044 	addi	r4,r15,1
 2009764:	2008913a 	slli	r4,r4,4
 2009768:	328003cc 	andi	r10,r6,15
 200976c:	02c000c4 	movi	r11,3
 2009770:	1107883a 	add	r3,r2,r4
 2009774:	290b883a 	add	r5,r5,r4
 2009778:	5a801e2e 	bgeu	r11,r10,20097f4 <memmove+0x154>
 200977c:	1813883a 	mov	r9,r3
 2009780:	2811883a 	mov	r8,r5
 2009784:	500f883a 	mov	r7,r10
 2009788:	41000017 	ldw	r4,0(r8)
 200978c:	4a400104 	addi	r9,r9,4
 2009790:	39ffff04 	addi	r7,r7,-4
 2009794:	493fff15 	stw	r4,-4(r9)
 2009798:	42000104 	addi	r8,r8,4
 200979c:	59fffa36 	bltu	r11,r7,2009788 <__alt_mem_mem_0+0xfcfe9788>
 20097a0:	513fff04 	addi	r4,r10,-4
 20097a4:	2008d0ba 	srli	r4,r4,2
 20097a8:	318000cc 	andi	r6,r6,3
 20097ac:	21000044 	addi	r4,r4,1
 20097b0:	2109883a 	add	r4,r4,r4
 20097b4:	2109883a 	add	r4,r4,r4
 20097b8:	1907883a 	add	r3,r3,r4
 20097bc:	290b883a 	add	r5,r5,r4
 20097c0:	30000b26 	beq	r6,zero,20097f0 <memmove+0x150>
 20097c4:	198d883a 	add	r6,r3,r6
 20097c8:	29c00003 	ldbu	r7,0(r5)
 20097cc:	18c00044 	addi	r3,r3,1
 20097d0:	29400044 	addi	r5,r5,1
 20097d4:	19ffffc5 	stb	r7,-1(r3)
 20097d8:	19bffb1e 	bne	r3,r6,20097c8 <__alt_mem_mem_0+0xfcfe97c8>
 20097dc:	f800283a 	ret
 20097e0:	1007883a 	mov	r3,r2
 20097e4:	003ff606 	br	20097c0 <__alt_mem_mem_0+0xfcfe97c0>
 20097e8:	1007883a 	mov	r3,r2
 20097ec:	003ff506 	br	20097c4 <__alt_mem_mem_0+0xfcfe97c4>
 20097f0:	f800283a 	ret
 20097f4:	500d883a 	mov	r6,r10
 20097f8:	003ff106 	br	20097c0 <__alt_mem_mem_0+0xfcfe97c0>

020097fc <_read_r>:
 20097fc:	defffd04 	addi	sp,sp,-12
 2009800:	2805883a 	mov	r2,r5
 2009804:	dc000015 	stw	r16,0(sp)
 2009808:	04008134 	movhi	r16,516
 200980c:	dc400115 	stw	r17,4(sp)
 2009810:	300b883a 	mov	r5,r6
 2009814:	841e0a04 	addi	r16,r16,30760
 2009818:	2023883a 	mov	r17,r4
 200981c:	380d883a 	mov	r6,r7
 2009820:	1009883a 	mov	r4,r2
 2009824:	dfc00215 	stw	ra,8(sp)
 2009828:	80000015 	stw	zero,0(r16)
 200982c:	20131cc0 	call	20131cc <read>
 2009830:	00ffffc4 	movi	r3,-1
 2009834:	10c00526 	beq	r2,r3,200984c <_read_r+0x50>
 2009838:	dfc00217 	ldw	ra,8(sp)
 200983c:	dc400117 	ldw	r17,4(sp)
 2009840:	dc000017 	ldw	r16,0(sp)
 2009844:	dec00304 	addi	sp,sp,12
 2009848:	f800283a 	ret
 200984c:	80c00017 	ldw	r3,0(r16)
 2009850:	183ff926 	beq	r3,zero,2009838 <__alt_mem_mem_0+0xfcfe9838>
 2009854:	88c00015 	stw	r3,0(r17)
 2009858:	003ff706 	br	2009838 <__alt_mem_mem_0+0xfcfe9838>

0200985c <_realloc_r>:
 200985c:	defff604 	addi	sp,sp,-40
 2009860:	dc800215 	stw	r18,8(sp)
 2009864:	dfc00915 	stw	ra,36(sp)
 2009868:	df000815 	stw	fp,32(sp)
 200986c:	ddc00715 	stw	r23,28(sp)
 2009870:	dd800615 	stw	r22,24(sp)
 2009874:	dd400515 	stw	r21,20(sp)
 2009878:	dd000415 	stw	r20,16(sp)
 200987c:	dcc00315 	stw	r19,12(sp)
 2009880:	dc400115 	stw	r17,4(sp)
 2009884:	dc000015 	stw	r16,0(sp)
 2009888:	3025883a 	mov	r18,r6
 200988c:	2800b726 	beq	r5,zero,2009b6c <_realloc_r+0x310>
 2009890:	282b883a 	mov	r21,r5
 2009894:	2029883a 	mov	r20,r4
 2009898:	200d4e40 	call	200d4e4 <__malloc_lock>
 200989c:	a8bfff17 	ldw	r2,-4(r21)
 20098a0:	043fff04 	movi	r16,-4
 20098a4:	90c002c4 	addi	r3,r18,11
 20098a8:	01000584 	movi	r4,22
 20098ac:	acfffe04 	addi	r19,r21,-8
 20098b0:	1420703a 	and	r16,r2,r16
 20098b4:	20c0332e 	bgeu	r4,r3,2009984 <_realloc_r+0x128>
 20098b8:	047ffe04 	movi	r17,-8
 20098bc:	1c62703a 	and	r17,r3,r17
 20098c0:	8807883a 	mov	r3,r17
 20098c4:	88005816 	blt	r17,zero,2009a28 <_realloc_r+0x1cc>
 20098c8:	8c805736 	bltu	r17,r18,2009a28 <_realloc_r+0x1cc>
 20098cc:	80c0300e 	bge	r16,r3,2009990 <_realloc_r+0x134>
 20098d0:	07008134 	movhi	fp,516
 20098d4:	e70fdb04 	addi	fp,fp,16236
 20098d8:	e1c00217 	ldw	r7,8(fp)
 20098dc:	9c09883a 	add	r4,r19,r16
 20098e0:	22000117 	ldw	r8,4(r4)
 20098e4:	21c06326 	beq	r4,r7,2009a74 <_realloc_r+0x218>
 20098e8:	017fff84 	movi	r5,-2
 20098ec:	414a703a 	and	r5,r8,r5
 20098f0:	214b883a 	add	r5,r4,r5
 20098f4:	29800117 	ldw	r6,4(r5)
 20098f8:	3180004c 	andi	r6,r6,1
 20098fc:	30003f26 	beq	r6,zero,20099fc <_realloc_r+0x1a0>
 2009900:	1080004c 	andi	r2,r2,1
 2009904:	10008326 	beq	r2,zero,2009b14 <_realloc_r+0x2b8>
 2009908:	900b883a 	mov	r5,r18
 200990c:	a009883a 	mov	r4,r20
 2009910:	20057340 	call	2005734 <_malloc_r>
 2009914:	1025883a 	mov	r18,r2
 2009918:	10011e26 	beq	r2,zero,2009d94 <_realloc_r+0x538>
 200991c:	a93fff17 	ldw	r4,-4(r21)
 2009920:	10fffe04 	addi	r3,r2,-8
 2009924:	00bfff84 	movi	r2,-2
 2009928:	2084703a 	and	r2,r4,r2
 200992c:	9885883a 	add	r2,r19,r2
 2009930:	1880ee26 	beq	r3,r2,2009cec <_realloc_r+0x490>
 2009934:	81bfff04 	addi	r6,r16,-4
 2009938:	00800904 	movi	r2,36
 200993c:	1180b836 	bltu	r2,r6,2009c20 <_realloc_r+0x3c4>
 2009940:	00c004c4 	movi	r3,19
 2009944:	19809636 	bltu	r3,r6,2009ba0 <_realloc_r+0x344>
 2009948:	9005883a 	mov	r2,r18
 200994c:	a807883a 	mov	r3,r21
 2009950:	19000017 	ldw	r4,0(r3)
 2009954:	11000015 	stw	r4,0(r2)
 2009958:	19000117 	ldw	r4,4(r3)
 200995c:	11000115 	stw	r4,4(r2)
 2009960:	18c00217 	ldw	r3,8(r3)
 2009964:	10c00215 	stw	r3,8(r2)
 2009968:	a80b883a 	mov	r5,r21
 200996c:	a009883a 	mov	r4,r20
 2009970:	20050040 	call	2005004 <_free_r>
 2009974:	a009883a 	mov	r4,r20
 2009978:	200d5440 	call	200d544 <__malloc_unlock>
 200997c:	9005883a 	mov	r2,r18
 2009980:	00001206 	br	20099cc <_realloc_r+0x170>
 2009984:	00c00404 	movi	r3,16
 2009988:	1823883a 	mov	r17,r3
 200998c:	003fce06 	br	20098c8 <__alt_mem_mem_0+0xfcfe98c8>
 2009990:	a825883a 	mov	r18,r21
 2009994:	8445c83a 	sub	r2,r16,r17
 2009998:	00c003c4 	movi	r3,15
 200999c:	18802636 	bltu	r3,r2,2009a38 <_realloc_r+0x1dc>
 20099a0:	99800117 	ldw	r6,4(r19)
 20099a4:	9c07883a 	add	r3,r19,r16
 20099a8:	3180004c 	andi	r6,r6,1
 20099ac:	3420b03a 	or	r16,r6,r16
 20099b0:	9c000115 	stw	r16,4(r19)
 20099b4:	18800117 	ldw	r2,4(r3)
 20099b8:	10800054 	ori	r2,r2,1
 20099bc:	18800115 	stw	r2,4(r3)
 20099c0:	a009883a 	mov	r4,r20
 20099c4:	200d5440 	call	200d544 <__malloc_unlock>
 20099c8:	9005883a 	mov	r2,r18
 20099cc:	dfc00917 	ldw	ra,36(sp)
 20099d0:	df000817 	ldw	fp,32(sp)
 20099d4:	ddc00717 	ldw	r23,28(sp)
 20099d8:	dd800617 	ldw	r22,24(sp)
 20099dc:	dd400517 	ldw	r21,20(sp)
 20099e0:	dd000417 	ldw	r20,16(sp)
 20099e4:	dcc00317 	ldw	r19,12(sp)
 20099e8:	dc800217 	ldw	r18,8(sp)
 20099ec:	dc400117 	ldw	r17,4(sp)
 20099f0:	dc000017 	ldw	r16,0(sp)
 20099f4:	dec00a04 	addi	sp,sp,40
 20099f8:	f800283a 	ret
 20099fc:	017fff04 	movi	r5,-4
 2009a00:	414a703a 	and	r5,r8,r5
 2009a04:	814d883a 	add	r6,r16,r5
 2009a08:	30c01f16 	blt	r6,r3,2009a88 <_realloc_r+0x22c>
 2009a0c:	20800317 	ldw	r2,12(r4)
 2009a10:	20c00217 	ldw	r3,8(r4)
 2009a14:	a825883a 	mov	r18,r21
 2009a18:	3021883a 	mov	r16,r6
 2009a1c:	18800315 	stw	r2,12(r3)
 2009a20:	10c00215 	stw	r3,8(r2)
 2009a24:	003fdb06 	br	2009994 <__alt_mem_mem_0+0xfcfe9994>
 2009a28:	00800304 	movi	r2,12
 2009a2c:	a0800015 	stw	r2,0(r20)
 2009a30:	0005883a 	mov	r2,zero
 2009a34:	003fe506 	br	20099cc <__alt_mem_mem_0+0xfcfe99cc>
 2009a38:	98c00117 	ldw	r3,4(r19)
 2009a3c:	9c4b883a 	add	r5,r19,r17
 2009a40:	11000054 	ori	r4,r2,1
 2009a44:	18c0004c 	andi	r3,r3,1
 2009a48:	1c62b03a 	or	r17,r3,r17
 2009a4c:	9c400115 	stw	r17,4(r19)
 2009a50:	29000115 	stw	r4,4(r5)
 2009a54:	2885883a 	add	r2,r5,r2
 2009a58:	10c00117 	ldw	r3,4(r2)
 2009a5c:	29400204 	addi	r5,r5,8
 2009a60:	a009883a 	mov	r4,r20
 2009a64:	18c00054 	ori	r3,r3,1
 2009a68:	10c00115 	stw	r3,4(r2)
 2009a6c:	20050040 	call	2005004 <_free_r>
 2009a70:	003fd306 	br	20099c0 <__alt_mem_mem_0+0xfcfe99c0>
 2009a74:	017fff04 	movi	r5,-4
 2009a78:	414a703a 	and	r5,r8,r5
 2009a7c:	89800404 	addi	r6,r17,16
 2009a80:	8151883a 	add	r8,r16,r5
 2009a84:	4180590e 	bge	r8,r6,2009bec <_realloc_r+0x390>
 2009a88:	1080004c 	andi	r2,r2,1
 2009a8c:	103f9e1e 	bne	r2,zero,2009908 <__alt_mem_mem_0+0xfcfe9908>
 2009a90:	adbffe17 	ldw	r22,-8(r21)
 2009a94:	00bfff04 	movi	r2,-4
 2009a98:	9dadc83a 	sub	r22,r19,r22
 2009a9c:	b1800117 	ldw	r6,4(r22)
 2009aa0:	3084703a 	and	r2,r6,r2
 2009aa4:	20002026 	beq	r4,zero,2009b28 <_realloc_r+0x2cc>
 2009aa8:	80af883a 	add	r23,r16,r2
 2009aac:	b96f883a 	add	r23,r23,r5
 2009ab0:	21c05f26 	beq	r4,r7,2009c30 <_realloc_r+0x3d4>
 2009ab4:	b8c01c16 	blt	r23,r3,2009b28 <_realloc_r+0x2cc>
 2009ab8:	20800317 	ldw	r2,12(r4)
 2009abc:	20c00217 	ldw	r3,8(r4)
 2009ac0:	81bfff04 	addi	r6,r16,-4
 2009ac4:	01000904 	movi	r4,36
 2009ac8:	18800315 	stw	r2,12(r3)
 2009acc:	10c00215 	stw	r3,8(r2)
 2009ad0:	b0c00217 	ldw	r3,8(r22)
 2009ad4:	b0800317 	ldw	r2,12(r22)
 2009ad8:	b4800204 	addi	r18,r22,8
 2009adc:	18800315 	stw	r2,12(r3)
 2009ae0:	10c00215 	stw	r3,8(r2)
 2009ae4:	21801b36 	bltu	r4,r6,2009b54 <_realloc_r+0x2f8>
 2009ae8:	008004c4 	movi	r2,19
 2009aec:	1180352e 	bgeu	r2,r6,2009bc4 <_realloc_r+0x368>
 2009af0:	a8800017 	ldw	r2,0(r21)
 2009af4:	b0800215 	stw	r2,8(r22)
 2009af8:	a8800117 	ldw	r2,4(r21)
 2009afc:	b0800315 	stw	r2,12(r22)
 2009b00:	008006c4 	movi	r2,27
 2009b04:	11807f36 	bltu	r2,r6,2009d04 <_realloc_r+0x4a8>
 2009b08:	b0800404 	addi	r2,r22,16
 2009b0c:	ad400204 	addi	r21,r21,8
 2009b10:	00002d06 	br	2009bc8 <_realloc_r+0x36c>
 2009b14:	adbffe17 	ldw	r22,-8(r21)
 2009b18:	00bfff04 	movi	r2,-4
 2009b1c:	9dadc83a 	sub	r22,r19,r22
 2009b20:	b1000117 	ldw	r4,4(r22)
 2009b24:	2084703a 	and	r2,r4,r2
 2009b28:	b03f7726 	beq	r22,zero,2009908 <__alt_mem_mem_0+0xfcfe9908>
 2009b2c:	80af883a 	add	r23,r16,r2
 2009b30:	b8ff7516 	blt	r23,r3,2009908 <__alt_mem_mem_0+0xfcfe9908>
 2009b34:	b0800317 	ldw	r2,12(r22)
 2009b38:	b0c00217 	ldw	r3,8(r22)
 2009b3c:	81bfff04 	addi	r6,r16,-4
 2009b40:	01000904 	movi	r4,36
 2009b44:	18800315 	stw	r2,12(r3)
 2009b48:	10c00215 	stw	r3,8(r2)
 2009b4c:	b4800204 	addi	r18,r22,8
 2009b50:	21bfe52e 	bgeu	r4,r6,2009ae8 <__alt_mem_mem_0+0xfcfe9ae8>
 2009b54:	a80b883a 	mov	r5,r21
 2009b58:	9009883a 	mov	r4,r18
 2009b5c:	20096a00 	call	20096a0 <memmove>
 2009b60:	b821883a 	mov	r16,r23
 2009b64:	b027883a 	mov	r19,r22
 2009b68:	003f8a06 	br	2009994 <__alt_mem_mem_0+0xfcfe9994>
 2009b6c:	300b883a 	mov	r5,r6
 2009b70:	dfc00917 	ldw	ra,36(sp)
 2009b74:	df000817 	ldw	fp,32(sp)
 2009b78:	ddc00717 	ldw	r23,28(sp)
 2009b7c:	dd800617 	ldw	r22,24(sp)
 2009b80:	dd400517 	ldw	r21,20(sp)
 2009b84:	dd000417 	ldw	r20,16(sp)
 2009b88:	dcc00317 	ldw	r19,12(sp)
 2009b8c:	dc800217 	ldw	r18,8(sp)
 2009b90:	dc400117 	ldw	r17,4(sp)
 2009b94:	dc000017 	ldw	r16,0(sp)
 2009b98:	dec00a04 	addi	sp,sp,40
 2009b9c:	20057341 	jmpi	2005734 <_malloc_r>
 2009ba0:	a8c00017 	ldw	r3,0(r21)
 2009ba4:	90c00015 	stw	r3,0(r18)
 2009ba8:	a8c00117 	ldw	r3,4(r21)
 2009bac:	90c00115 	stw	r3,4(r18)
 2009bb0:	00c006c4 	movi	r3,27
 2009bb4:	19804536 	bltu	r3,r6,2009ccc <_realloc_r+0x470>
 2009bb8:	90800204 	addi	r2,r18,8
 2009bbc:	a8c00204 	addi	r3,r21,8
 2009bc0:	003f6306 	br	2009950 <__alt_mem_mem_0+0xfcfe9950>
 2009bc4:	9005883a 	mov	r2,r18
 2009bc8:	a8c00017 	ldw	r3,0(r21)
 2009bcc:	b821883a 	mov	r16,r23
 2009bd0:	b027883a 	mov	r19,r22
 2009bd4:	10c00015 	stw	r3,0(r2)
 2009bd8:	a8c00117 	ldw	r3,4(r21)
 2009bdc:	10c00115 	stw	r3,4(r2)
 2009be0:	a8c00217 	ldw	r3,8(r21)
 2009be4:	10c00215 	stw	r3,8(r2)
 2009be8:	003f6a06 	br	2009994 <__alt_mem_mem_0+0xfcfe9994>
 2009bec:	9c67883a 	add	r19,r19,r17
 2009bf0:	4445c83a 	sub	r2,r8,r17
 2009bf4:	e4c00215 	stw	r19,8(fp)
 2009bf8:	10800054 	ori	r2,r2,1
 2009bfc:	98800115 	stw	r2,4(r19)
 2009c00:	a8bfff17 	ldw	r2,-4(r21)
 2009c04:	a009883a 	mov	r4,r20
 2009c08:	1080004c 	andi	r2,r2,1
 2009c0c:	1462b03a 	or	r17,r2,r17
 2009c10:	ac7fff15 	stw	r17,-4(r21)
 2009c14:	200d5440 	call	200d544 <__malloc_unlock>
 2009c18:	a805883a 	mov	r2,r21
 2009c1c:	003f6b06 	br	20099cc <__alt_mem_mem_0+0xfcfe99cc>
 2009c20:	a80b883a 	mov	r5,r21
 2009c24:	9009883a 	mov	r4,r18
 2009c28:	20096a00 	call	20096a0 <memmove>
 2009c2c:	003f4e06 	br	2009968 <__alt_mem_mem_0+0xfcfe9968>
 2009c30:	89000404 	addi	r4,r17,16
 2009c34:	b93fbc16 	blt	r23,r4,2009b28 <__alt_mem_mem_0+0xfcfe9b28>
 2009c38:	b0800317 	ldw	r2,12(r22)
 2009c3c:	b0c00217 	ldw	r3,8(r22)
 2009c40:	81bfff04 	addi	r6,r16,-4
 2009c44:	01000904 	movi	r4,36
 2009c48:	18800315 	stw	r2,12(r3)
 2009c4c:	10c00215 	stw	r3,8(r2)
 2009c50:	b4800204 	addi	r18,r22,8
 2009c54:	21804336 	bltu	r4,r6,2009d64 <_realloc_r+0x508>
 2009c58:	008004c4 	movi	r2,19
 2009c5c:	11803f2e 	bgeu	r2,r6,2009d5c <_realloc_r+0x500>
 2009c60:	a8800017 	ldw	r2,0(r21)
 2009c64:	b0800215 	stw	r2,8(r22)
 2009c68:	a8800117 	ldw	r2,4(r21)
 2009c6c:	b0800315 	stw	r2,12(r22)
 2009c70:	008006c4 	movi	r2,27
 2009c74:	11803f36 	bltu	r2,r6,2009d74 <_realloc_r+0x518>
 2009c78:	b0800404 	addi	r2,r22,16
 2009c7c:	ad400204 	addi	r21,r21,8
 2009c80:	a8c00017 	ldw	r3,0(r21)
 2009c84:	10c00015 	stw	r3,0(r2)
 2009c88:	a8c00117 	ldw	r3,4(r21)
 2009c8c:	10c00115 	stw	r3,4(r2)
 2009c90:	a8c00217 	ldw	r3,8(r21)
 2009c94:	10c00215 	stw	r3,8(r2)
 2009c98:	b447883a 	add	r3,r22,r17
 2009c9c:	bc45c83a 	sub	r2,r23,r17
 2009ca0:	e0c00215 	stw	r3,8(fp)
 2009ca4:	10800054 	ori	r2,r2,1
 2009ca8:	18800115 	stw	r2,4(r3)
 2009cac:	b0800117 	ldw	r2,4(r22)
 2009cb0:	a009883a 	mov	r4,r20
 2009cb4:	1080004c 	andi	r2,r2,1
 2009cb8:	1462b03a 	or	r17,r2,r17
 2009cbc:	b4400115 	stw	r17,4(r22)
 2009cc0:	200d5440 	call	200d544 <__malloc_unlock>
 2009cc4:	9005883a 	mov	r2,r18
 2009cc8:	003f4006 	br	20099cc <__alt_mem_mem_0+0xfcfe99cc>
 2009ccc:	a8c00217 	ldw	r3,8(r21)
 2009cd0:	90c00215 	stw	r3,8(r18)
 2009cd4:	a8c00317 	ldw	r3,12(r21)
 2009cd8:	90c00315 	stw	r3,12(r18)
 2009cdc:	30801126 	beq	r6,r2,2009d24 <_realloc_r+0x4c8>
 2009ce0:	90800404 	addi	r2,r18,16
 2009ce4:	a8c00404 	addi	r3,r21,16
 2009ce8:	003f1906 	br	2009950 <__alt_mem_mem_0+0xfcfe9950>
 2009cec:	90ffff17 	ldw	r3,-4(r18)
 2009cf0:	00bfff04 	movi	r2,-4
 2009cf4:	a825883a 	mov	r18,r21
 2009cf8:	1884703a 	and	r2,r3,r2
 2009cfc:	80a1883a 	add	r16,r16,r2
 2009d00:	003f2406 	br	2009994 <__alt_mem_mem_0+0xfcfe9994>
 2009d04:	a8800217 	ldw	r2,8(r21)
 2009d08:	b0800415 	stw	r2,16(r22)
 2009d0c:	a8800317 	ldw	r2,12(r21)
 2009d10:	b0800515 	stw	r2,20(r22)
 2009d14:	31000a26 	beq	r6,r4,2009d40 <_realloc_r+0x4e4>
 2009d18:	b0800604 	addi	r2,r22,24
 2009d1c:	ad400404 	addi	r21,r21,16
 2009d20:	003fa906 	br	2009bc8 <__alt_mem_mem_0+0xfcfe9bc8>
 2009d24:	a9000417 	ldw	r4,16(r21)
 2009d28:	90800604 	addi	r2,r18,24
 2009d2c:	a8c00604 	addi	r3,r21,24
 2009d30:	91000415 	stw	r4,16(r18)
 2009d34:	a9000517 	ldw	r4,20(r21)
 2009d38:	91000515 	stw	r4,20(r18)
 2009d3c:	003f0406 	br	2009950 <__alt_mem_mem_0+0xfcfe9950>
 2009d40:	a8c00417 	ldw	r3,16(r21)
 2009d44:	ad400604 	addi	r21,r21,24
 2009d48:	b0800804 	addi	r2,r22,32
 2009d4c:	b0c00615 	stw	r3,24(r22)
 2009d50:	a8ffff17 	ldw	r3,-4(r21)
 2009d54:	b0c00715 	stw	r3,28(r22)
 2009d58:	003f9b06 	br	2009bc8 <__alt_mem_mem_0+0xfcfe9bc8>
 2009d5c:	9005883a 	mov	r2,r18
 2009d60:	003fc706 	br	2009c80 <__alt_mem_mem_0+0xfcfe9c80>
 2009d64:	a80b883a 	mov	r5,r21
 2009d68:	9009883a 	mov	r4,r18
 2009d6c:	20096a00 	call	20096a0 <memmove>
 2009d70:	003fc906 	br	2009c98 <__alt_mem_mem_0+0xfcfe9c98>
 2009d74:	a8800217 	ldw	r2,8(r21)
 2009d78:	b0800415 	stw	r2,16(r22)
 2009d7c:	a8800317 	ldw	r2,12(r21)
 2009d80:	b0800515 	stw	r2,20(r22)
 2009d84:	31000726 	beq	r6,r4,2009da4 <_realloc_r+0x548>
 2009d88:	b0800604 	addi	r2,r22,24
 2009d8c:	ad400404 	addi	r21,r21,16
 2009d90:	003fbb06 	br	2009c80 <__alt_mem_mem_0+0xfcfe9c80>
 2009d94:	a009883a 	mov	r4,r20
 2009d98:	200d5440 	call	200d544 <__malloc_unlock>
 2009d9c:	0005883a 	mov	r2,zero
 2009da0:	003f0a06 	br	20099cc <__alt_mem_mem_0+0xfcfe99cc>
 2009da4:	a8c00417 	ldw	r3,16(r21)
 2009da8:	ad400604 	addi	r21,r21,24
 2009dac:	b0800804 	addi	r2,r22,32
 2009db0:	b0c00615 	stw	r3,24(r22)
 2009db4:	a8ffff17 	ldw	r3,-4(r21)
 2009db8:	b0c00715 	stw	r3,28(r22)
 2009dbc:	003fb006 	br	2009c80 <__alt_mem_mem_0+0xfcfe9c80>

02009dc0 <__swbuf_r>:
 2009dc0:	defffb04 	addi	sp,sp,-20
 2009dc4:	dcc00315 	stw	r19,12(sp)
 2009dc8:	dc800215 	stw	r18,8(sp)
 2009dcc:	dc000015 	stw	r16,0(sp)
 2009dd0:	dfc00415 	stw	ra,16(sp)
 2009dd4:	dc400115 	stw	r17,4(sp)
 2009dd8:	2025883a 	mov	r18,r4
 2009ddc:	2827883a 	mov	r19,r5
 2009de0:	3021883a 	mov	r16,r6
 2009de4:	20000226 	beq	r4,zero,2009df0 <__swbuf_r+0x30>
 2009de8:	20800e17 	ldw	r2,56(r4)
 2009dec:	10004226 	beq	r2,zero,2009ef8 <__swbuf_r+0x138>
 2009df0:	80800617 	ldw	r2,24(r16)
 2009df4:	8100030b 	ldhu	r4,12(r16)
 2009df8:	80800215 	stw	r2,8(r16)
 2009dfc:	2080020c 	andi	r2,r4,8
 2009e00:	10003626 	beq	r2,zero,2009edc <__swbuf_r+0x11c>
 2009e04:	80c00417 	ldw	r3,16(r16)
 2009e08:	18003426 	beq	r3,zero,2009edc <__swbuf_r+0x11c>
 2009e0c:	2088000c 	andi	r2,r4,8192
 2009e10:	9c403fcc 	andi	r17,r19,255
 2009e14:	10001a26 	beq	r2,zero,2009e80 <__swbuf_r+0xc0>
 2009e18:	80800017 	ldw	r2,0(r16)
 2009e1c:	81000517 	ldw	r4,20(r16)
 2009e20:	10c7c83a 	sub	r3,r2,r3
 2009e24:	1900200e 	bge	r3,r4,2009ea8 <__swbuf_r+0xe8>
 2009e28:	18c00044 	addi	r3,r3,1
 2009e2c:	81000217 	ldw	r4,8(r16)
 2009e30:	11400044 	addi	r5,r2,1
 2009e34:	81400015 	stw	r5,0(r16)
 2009e38:	213fffc4 	addi	r4,r4,-1
 2009e3c:	81000215 	stw	r4,8(r16)
 2009e40:	14c00005 	stb	r19,0(r2)
 2009e44:	80800517 	ldw	r2,20(r16)
 2009e48:	10c01e26 	beq	r2,r3,2009ec4 <__swbuf_r+0x104>
 2009e4c:	8080030b 	ldhu	r2,12(r16)
 2009e50:	1080004c 	andi	r2,r2,1
 2009e54:	10000226 	beq	r2,zero,2009e60 <__swbuf_r+0xa0>
 2009e58:	00800284 	movi	r2,10
 2009e5c:	88801926 	beq	r17,r2,2009ec4 <__swbuf_r+0x104>
 2009e60:	8805883a 	mov	r2,r17
 2009e64:	dfc00417 	ldw	ra,16(sp)
 2009e68:	dcc00317 	ldw	r19,12(sp)
 2009e6c:	dc800217 	ldw	r18,8(sp)
 2009e70:	dc400117 	ldw	r17,4(sp)
 2009e74:	dc000017 	ldw	r16,0(sp)
 2009e78:	dec00504 	addi	sp,sp,20
 2009e7c:	f800283a 	ret
 2009e80:	81401917 	ldw	r5,100(r16)
 2009e84:	00b7ffc4 	movi	r2,-8193
 2009e88:	21080014 	ori	r4,r4,8192
 2009e8c:	2884703a 	and	r2,r5,r2
 2009e90:	80801915 	stw	r2,100(r16)
 2009e94:	80800017 	ldw	r2,0(r16)
 2009e98:	8100030d 	sth	r4,12(r16)
 2009e9c:	81000517 	ldw	r4,20(r16)
 2009ea0:	10c7c83a 	sub	r3,r2,r3
 2009ea4:	193fe016 	blt	r3,r4,2009e28 <__alt_mem_mem_0+0xfcfe9e28>
 2009ea8:	800b883a 	mov	r5,r16
 2009eac:	9009883a 	mov	r4,r18
 2009eb0:	2004ab40 	call	2004ab4 <_fflush_r>
 2009eb4:	1000071e 	bne	r2,zero,2009ed4 <__swbuf_r+0x114>
 2009eb8:	80800017 	ldw	r2,0(r16)
 2009ebc:	00c00044 	movi	r3,1
 2009ec0:	003fda06 	br	2009e2c <__alt_mem_mem_0+0xfcfe9e2c>
 2009ec4:	800b883a 	mov	r5,r16
 2009ec8:	9009883a 	mov	r4,r18
 2009ecc:	2004ab40 	call	2004ab4 <_fflush_r>
 2009ed0:	103fe326 	beq	r2,zero,2009e60 <__alt_mem_mem_0+0xfcfe9e60>
 2009ed4:	00bfffc4 	movi	r2,-1
 2009ed8:	003fe206 	br	2009e64 <__alt_mem_mem_0+0xfcfe9e64>
 2009edc:	800b883a 	mov	r5,r16
 2009ee0:	9009883a 	mov	r4,r18
 2009ee4:	2002ebc0 	call	2002ebc <__swsetup_r>
 2009ee8:	103ffa1e 	bne	r2,zero,2009ed4 <__alt_mem_mem_0+0xfcfe9ed4>
 2009eec:	8100030b 	ldhu	r4,12(r16)
 2009ef0:	80c00417 	ldw	r3,16(r16)
 2009ef4:	003fc506 	br	2009e0c <__alt_mem_mem_0+0xfcfe9e0c>
 2009ef8:	2004e900 	call	2004e90 <__sinit>
 2009efc:	003fbc06 	br	2009df0 <__alt_mem_mem_0+0xfcfe9df0>

02009f00 <__swbuf>:
 2009f00:	00808134 	movhi	r2,516
 2009f04:	10963d04 	addi	r2,r2,22772
 2009f08:	280d883a 	mov	r6,r5
 2009f0c:	200b883a 	mov	r5,r4
 2009f10:	11000017 	ldw	r4,0(r2)
 2009f14:	2009dc01 	jmpi	2009dc0 <__swbuf_r>

02009f18 <_wcrtomb_r>:
 2009f18:	defff604 	addi	sp,sp,-40
 2009f1c:	00808134 	movhi	r2,516
 2009f20:	dc800815 	stw	r18,32(sp)
 2009f24:	dc400715 	stw	r17,28(sp)
 2009f28:	dc000615 	stw	r16,24(sp)
 2009f2c:	10964104 	addi	r2,r2,22788
 2009f30:	dfc00915 	stw	ra,36(sp)
 2009f34:	2021883a 	mov	r16,r4
 2009f38:	3823883a 	mov	r17,r7
 2009f3c:	14800017 	ldw	r18,0(r2)
 2009f40:	28001426 	beq	r5,zero,2009f94 <_wcrtomb_r+0x7c>
 2009f44:	d9400415 	stw	r5,16(sp)
 2009f48:	d9800515 	stw	r6,20(sp)
 2009f4c:	20055180 	call	2005518 <__locale_charset>
 2009f50:	d9800517 	ldw	r6,20(sp)
 2009f54:	d9400417 	ldw	r5,16(sp)
 2009f58:	100f883a 	mov	r7,r2
 2009f5c:	dc400015 	stw	r17,0(sp)
 2009f60:	8009883a 	mov	r4,r16
 2009f64:	903ee83a 	callr	r18
 2009f68:	00ffffc4 	movi	r3,-1
 2009f6c:	10c0031e 	bne	r2,r3,2009f7c <_wcrtomb_r+0x64>
 2009f70:	88000015 	stw	zero,0(r17)
 2009f74:	00c02284 	movi	r3,138
 2009f78:	80c00015 	stw	r3,0(r16)
 2009f7c:	dfc00917 	ldw	ra,36(sp)
 2009f80:	dc800817 	ldw	r18,32(sp)
 2009f84:	dc400717 	ldw	r17,28(sp)
 2009f88:	dc000617 	ldw	r16,24(sp)
 2009f8c:	dec00a04 	addi	sp,sp,40
 2009f90:	f800283a 	ret
 2009f94:	20055180 	call	2005518 <__locale_charset>
 2009f98:	100f883a 	mov	r7,r2
 2009f9c:	dc400015 	stw	r17,0(sp)
 2009fa0:	000d883a 	mov	r6,zero
 2009fa4:	d9400104 	addi	r5,sp,4
 2009fa8:	8009883a 	mov	r4,r16
 2009fac:	903ee83a 	callr	r18
 2009fb0:	003fed06 	br	2009f68 <__alt_mem_mem_0+0xfcfe9f68>

02009fb4 <wcrtomb>:
 2009fb4:	defff604 	addi	sp,sp,-40
 2009fb8:	00808134 	movhi	r2,516
 2009fbc:	dc800615 	stw	r18,24(sp)
 2009fc0:	dc400515 	stw	r17,20(sp)
 2009fc4:	10963d04 	addi	r2,r2,22772
 2009fc8:	dfc00915 	stw	ra,36(sp)
 2009fcc:	dd000815 	stw	r20,32(sp)
 2009fd0:	dcc00715 	stw	r19,28(sp)
 2009fd4:	dc000415 	stw	r16,16(sp)
 2009fd8:	3025883a 	mov	r18,r6
 2009fdc:	14400017 	ldw	r17,0(r2)
 2009fe0:	20001926 	beq	r4,zero,200a048 <wcrtomb+0x94>
 2009fe4:	00808134 	movhi	r2,516
 2009fe8:	10964104 	addi	r2,r2,22788
 2009fec:	15000017 	ldw	r20,0(r2)
 2009ff0:	2021883a 	mov	r16,r4
 2009ff4:	2827883a 	mov	r19,r5
 2009ff8:	20055180 	call	2005518 <__locale_charset>
 2009ffc:	100f883a 	mov	r7,r2
 200a000:	dc800015 	stw	r18,0(sp)
 200a004:	980d883a 	mov	r6,r19
 200a008:	800b883a 	mov	r5,r16
 200a00c:	8809883a 	mov	r4,r17
 200a010:	a03ee83a 	callr	r20
 200a014:	00ffffc4 	movi	r3,-1
 200a018:	10c0031e 	bne	r2,r3,200a028 <wcrtomb+0x74>
 200a01c:	90000015 	stw	zero,0(r18)
 200a020:	00c02284 	movi	r3,138
 200a024:	88c00015 	stw	r3,0(r17)
 200a028:	dfc00917 	ldw	ra,36(sp)
 200a02c:	dd000817 	ldw	r20,32(sp)
 200a030:	dcc00717 	ldw	r19,28(sp)
 200a034:	dc800617 	ldw	r18,24(sp)
 200a038:	dc400517 	ldw	r17,20(sp)
 200a03c:	dc000417 	ldw	r16,16(sp)
 200a040:	dec00a04 	addi	sp,sp,40
 200a044:	f800283a 	ret
 200a048:	00808134 	movhi	r2,516
 200a04c:	10964104 	addi	r2,r2,22788
 200a050:	14000017 	ldw	r16,0(r2)
 200a054:	20055180 	call	2005518 <__locale_charset>
 200a058:	100f883a 	mov	r7,r2
 200a05c:	dc800015 	stw	r18,0(sp)
 200a060:	000d883a 	mov	r6,zero
 200a064:	d9400104 	addi	r5,sp,4
 200a068:	8809883a 	mov	r4,r17
 200a06c:	803ee83a 	callr	r16
 200a070:	003fe806 	br	200a014 <__alt_mem_mem_0+0xfcfea014>

0200a074 <__ascii_wctomb>:
 200a074:	28000526 	beq	r5,zero,200a08c <__ascii_wctomb+0x18>
 200a078:	00803fc4 	movi	r2,255
 200a07c:	11800536 	bltu	r2,r6,200a094 <__ascii_wctomb+0x20>
 200a080:	29800005 	stb	r6,0(r5)
 200a084:	00800044 	movi	r2,1
 200a088:	f800283a 	ret
 200a08c:	0005883a 	mov	r2,zero
 200a090:	f800283a 	ret
 200a094:	00802284 	movi	r2,138
 200a098:	20800015 	stw	r2,0(r4)
 200a09c:	00bfffc4 	movi	r2,-1
 200a0a0:	f800283a 	ret

0200a0a4 <_wctomb_r>:
 200a0a4:	00808134 	movhi	r2,516
 200a0a8:	defff904 	addi	sp,sp,-28
 200a0ac:	10964104 	addi	r2,r2,22788
 200a0b0:	dfc00615 	stw	ra,24(sp)
 200a0b4:	dc400515 	stw	r17,20(sp)
 200a0b8:	dc000415 	stw	r16,16(sp)
 200a0bc:	3823883a 	mov	r17,r7
 200a0c0:	14000017 	ldw	r16,0(r2)
 200a0c4:	d9000115 	stw	r4,4(sp)
 200a0c8:	d9400215 	stw	r5,8(sp)
 200a0cc:	d9800315 	stw	r6,12(sp)
 200a0d0:	20055180 	call	2005518 <__locale_charset>
 200a0d4:	d9800317 	ldw	r6,12(sp)
 200a0d8:	d9400217 	ldw	r5,8(sp)
 200a0dc:	d9000117 	ldw	r4,4(sp)
 200a0e0:	100f883a 	mov	r7,r2
 200a0e4:	dc400015 	stw	r17,0(sp)
 200a0e8:	803ee83a 	callr	r16
 200a0ec:	dfc00617 	ldw	ra,24(sp)
 200a0f0:	dc400517 	ldw	r17,20(sp)
 200a0f4:	dc000417 	ldw	r16,16(sp)
 200a0f8:	dec00704 	addi	sp,sp,28
 200a0fc:	f800283a 	ret

0200a100 <__udivdi3>:
 200a100:	defff504 	addi	sp,sp,-44
 200a104:	dcc00415 	stw	r19,16(sp)
 200a108:	dc000115 	stw	r16,4(sp)
 200a10c:	dfc00a15 	stw	ra,40(sp)
 200a110:	df000915 	stw	fp,36(sp)
 200a114:	ddc00815 	stw	r23,32(sp)
 200a118:	dd800715 	stw	r22,28(sp)
 200a11c:	dd400615 	stw	r21,24(sp)
 200a120:	dd000515 	stw	r20,20(sp)
 200a124:	dc800315 	stw	r18,12(sp)
 200a128:	dc400215 	stw	r17,8(sp)
 200a12c:	2027883a 	mov	r19,r4
 200a130:	2821883a 	mov	r16,r5
 200a134:	3800411e 	bne	r7,zero,200a23c <__udivdi3+0x13c>
 200a138:	3023883a 	mov	r17,r6
 200a13c:	2025883a 	mov	r18,r4
 200a140:	2980522e 	bgeu	r5,r6,200a28c <__udivdi3+0x18c>
 200a144:	00bfffd4 	movui	r2,65535
 200a148:	282d883a 	mov	r22,r5
 200a14c:	1180a836 	bltu	r2,r6,200a3f0 <__udivdi3+0x2f0>
 200a150:	00803fc4 	movi	r2,255
 200a154:	1185803a 	cmpltu	r2,r2,r6
 200a158:	100490fa 	slli	r2,r2,3
 200a15c:	3086d83a 	srl	r3,r6,r2
 200a160:	01008134 	movhi	r4,516
 200a164:	21043704 	addi	r4,r4,4316
 200a168:	20c7883a 	add	r3,r4,r3
 200a16c:	18c00003 	ldbu	r3,0(r3)
 200a170:	1885883a 	add	r2,r3,r2
 200a174:	00c00804 	movi	r3,32
 200a178:	1887c83a 	sub	r3,r3,r2
 200a17c:	18000526 	beq	r3,zero,200a194 <__udivdi3+0x94>
 200a180:	80e0983a 	sll	r16,r16,r3
 200a184:	9884d83a 	srl	r2,r19,r2
 200a188:	30e2983a 	sll	r17,r6,r3
 200a18c:	98e4983a 	sll	r18,r19,r3
 200a190:	142cb03a 	or	r22,r2,r16
 200a194:	882ad43a 	srli	r21,r17,16
 200a198:	b009883a 	mov	r4,r22
 200a19c:	8d3fffcc 	andi	r20,r17,65535
 200a1a0:	a80b883a 	mov	r5,r21
 200a1a4:	200ad0c0 	call	200ad0c <__umodsi3>
 200a1a8:	b009883a 	mov	r4,r22
 200a1ac:	a80b883a 	mov	r5,r21
 200a1b0:	1027883a 	mov	r19,r2
 200a1b4:	200aca80 	call	200aca8 <__udivsi3>
 200a1b8:	102d883a 	mov	r22,r2
 200a1bc:	9826943a 	slli	r19,r19,16
 200a1c0:	9004d43a 	srli	r2,r18,16
 200a1c4:	a5a1383a 	mul	r16,r20,r22
 200a1c8:	14c4b03a 	or	r2,r2,r19
 200a1cc:	1400052e 	bgeu	r2,r16,200a1e4 <__udivdi3+0xe4>
 200a1d0:	1445883a 	add	r2,r2,r17
 200a1d4:	b0ffffc4 	addi	r3,r22,-1
 200a1d8:	14400136 	bltu	r2,r17,200a1e0 <__udivdi3+0xe0>
 200a1dc:	14012336 	bltu	r2,r16,200a66c <__udivdi3+0x56c>
 200a1e0:	182d883a 	mov	r22,r3
 200a1e4:	1421c83a 	sub	r16,r2,r16
 200a1e8:	a80b883a 	mov	r5,r21
 200a1ec:	8009883a 	mov	r4,r16
 200a1f0:	200ad0c0 	call	200ad0c <__umodsi3>
 200a1f4:	1027883a 	mov	r19,r2
 200a1f8:	a80b883a 	mov	r5,r21
 200a1fc:	8009883a 	mov	r4,r16
 200a200:	200aca80 	call	200aca8 <__udivsi3>
 200a204:	9826943a 	slli	r19,r19,16
 200a208:	a0a9383a 	mul	r20,r20,r2
 200a20c:	94bfffcc 	andi	r18,r18,65535
 200a210:	94e4b03a 	or	r18,r18,r19
 200a214:	9500052e 	bgeu	r18,r20,200a22c <__udivdi3+0x12c>
 200a218:	8ca5883a 	add	r18,r17,r18
 200a21c:	10ffffc4 	addi	r3,r2,-1
 200a220:	9440f136 	bltu	r18,r17,200a5e8 <__udivdi3+0x4e8>
 200a224:	9500f02e 	bgeu	r18,r20,200a5e8 <__udivdi3+0x4e8>
 200a228:	10bfff84 	addi	r2,r2,-2
 200a22c:	b00c943a 	slli	r6,r22,16
 200a230:	0007883a 	mov	r3,zero
 200a234:	3084b03a 	or	r2,r6,r2
 200a238:	00005906 	br	200a3a0 <__udivdi3+0x2a0>
 200a23c:	29c05636 	bltu	r5,r7,200a398 <__udivdi3+0x298>
 200a240:	00bfffd4 	movui	r2,65535
 200a244:	11c0622e 	bgeu	r2,r7,200a3d0 <__udivdi3+0x2d0>
 200a248:	00804034 	movhi	r2,256
 200a24c:	10bfffc4 	addi	r2,r2,-1
 200a250:	11c0ee36 	bltu	r2,r7,200a60c <__udivdi3+0x50c>
 200a254:	00800404 	movi	r2,16
 200a258:	3886d83a 	srl	r3,r7,r2
 200a25c:	01008134 	movhi	r4,516
 200a260:	21043704 	addi	r4,r4,4316
 200a264:	20c7883a 	add	r3,r4,r3
 200a268:	18c00003 	ldbu	r3,0(r3)
 200a26c:	05400804 	movi	r21,32
 200a270:	1885883a 	add	r2,r3,r2
 200a274:	a8abc83a 	sub	r21,r21,r2
 200a278:	a800621e 	bne	r21,zero,200a404 <__udivdi3+0x304>
 200a27c:	3c00e936 	bltu	r7,r16,200a624 <__udivdi3+0x524>
 200a280:	9985403a 	cmpgeu	r2,r19,r6
 200a284:	0007883a 	mov	r3,zero
 200a288:	00004506 	br	200a3a0 <__udivdi3+0x2a0>
 200a28c:	3000041e 	bne	r6,zero,200a2a0 <__udivdi3+0x1a0>
 200a290:	000b883a 	mov	r5,zero
 200a294:	01000044 	movi	r4,1
 200a298:	200aca80 	call	200aca8 <__udivsi3>
 200a29c:	1023883a 	mov	r17,r2
 200a2a0:	00bfffd4 	movui	r2,65535
 200a2a4:	14404e2e 	bgeu	r2,r17,200a3e0 <__udivdi3+0x2e0>
 200a2a8:	00804034 	movhi	r2,256
 200a2ac:	10bfffc4 	addi	r2,r2,-1
 200a2b0:	1440d836 	bltu	r2,r17,200a614 <__udivdi3+0x514>
 200a2b4:	00800404 	movi	r2,16
 200a2b8:	8886d83a 	srl	r3,r17,r2
 200a2bc:	01008134 	movhi	r4,516
 200a2c0:	21043704 	addi	r4,r4,4316
 200a2c4:	20c7883a 	add	r3,r4,r3
 200a2c8:	18c00003 	ldbu	r3,0(r3)
 200a2cc:	1885883a 	add	r2,r3,r2
 200a2d0:	00c00804 	movi	r3,32
 200a2d4:	1887c83a 	sub	r3,r3,r2
 200a2d8:	18008f1e 	bne	r3,zero,200a518 <__udivdi3+0x418>
 200a2dc:	882ad43a 	srli	r21,r17,16
 200a2e0:	8461c83a 	sub	r16,r16,r17
 200a2e4:	8d3fffcc 	andi	r20,r17,65535
 200a2e8:	00c00044 	movi	r3,1
 200a2ec:	8009883a 	mov	r4,r16
 200a2f0:	a80b883a 	mov	r5,r21
 200a2f4:	d8c00015 	stw	r3,0(sp)
 200a2f8:	200ad0c0 	call	200ad0c <__umodsi3>
 200a2fc:	8009883a 	mov	r4,r16
 200a300:	a80b883a 	mov	r5,r21
 200a304:	1027883a 	mov	r19,r2
 200a308:	200aca80 	call	200aca8 <__udivsi3>
 200a30c:	9826943a 	slli	r19,r19,16
 200a310:	9008d43a 	srli	r4,r18,16
 200a314:	1521383a 	mul	r16,r2,r20
 200a318:	102d883a 	mov	r22,r2
 200a31c:	24c8b03a 	or	r4,r4,r19
 200a320:	d8c00017 	ldw	r3,0(sp)
 200a324:	2400052e 	bgeu	r4,r16,200a33c <__udivdi3+0x23c>
 200a328:	2449883a 	add	r4,r4,r17
 200a32c:	b0bfffc4 	addi	r2,r22,-1
 200a330:	24400136 	bltu	r4,r17,200a338 <__udivdi3+0x238>
 200a334:	2400ca36 	bltu	r4,r16,200a660 <__udivdi3+0x560>
 200a338:	102d883a 	mov	r22,r2
 200a33c:	2421c83a 	sub	r16,r4,r16
 200a340:	a80b883a 	mov	r5,r21
 200a344:	8009883a 	mov	r4,r16
 200a348:	d8c00015 	stw	r3,0(sp)
 200a34c:	200ad0c0 	call	200ad0c <__umodsi3>
 200a350:	1027883a 	mov	r19,r2
 200a354:	a80b883a 	mov	r5,r21
 200a358:	8009883a 	mov	r4,r16
 200a35c:	200aca80 	call	200aca8 <__udivsi3>
 200a360:	9826943a 	slli	r19,r19,16
 200a364:	1529383a 	mul	r20,r2,r20
 200a368:	94bfffcc 	andi	r18,r18,65535
 200a36c:	94e4b03a 	or	r18,r18,r19
 200a370:	d8c00017 	ldw	r3,0(sp)
 200a374:	9500052e 	bgeu	r18,r20,200a38c <__udivdi3+0x28c>
 200a378:	8ca5883a 	add	r18,r17,r18
 200a37c:	113fffc4 	addi	r4,r2,-1
 200a380:	94409736 	bltu	r18,r17,200a5e0 <__udivdi3+0x4e0>
 200a384:	9500962e 	bgeu	r18,r20,200a5e0 <__udivdi3+0x4e0>
 200a388:	10bfff84 	addi	r2,r2,-2
 200a38c:	b00c943a 	slli	r6,r22,16
 200a390:	3084b03a 	or	r2,r6,r2
 200a394:	00000206 	br	200a3a0 <__udivdi3+0x2a0>
 200a398:	0007883a 	mov	r3,zero
 200a39c:	0005883a 	mov	r2,zero
 200a3a0:	dfc00a17 	ldw	ra,40(sp)
 200a3a4:	df000917 	ldw	fp,36(sp)
 200a3a8:	ddc00817 	ldw	r23,32(sp)
 200a3ac:	dd800717 	ldw	r22,28(sp)
 200a3b0:	dd400617 	ldw	r21,24(sp)
 200a3b4:	dd000517 	ldw	r20,20(sp)
 200a3b8:	dcc00417 	ldw	r19,16(sp)
 200a3bc:	dc800317 	ldw	r18,12(sp)
 200a3c0:	dc400217 	ldw	r17,8(sp)
 200a3c4:	dc000117 	ldw	r16,4(sp)
 200a3c8:	dec00b04 	addi	sp,sp,44
 200a3cc:	f800283a 	ret
 200a3d0:	00803fc4 	movi	r2,255
 200a3d4:	11c5803a 	cmpltu	r2,r2,r7
 200a3d8:	100490fa 	slli	r2,r2,3
 200a3dc:	003f9e06 	br	200a258 <__alt_mem_mem_0+0xfcfea258>
 200a3e0:	00803fc4 	movi	r2,255
 200a3e4:	1445803a 	cmpltu	r2,r2,r17
 200a3e8:	100490fa 	slli	r2,r2,3
 200a3ec:	003fb206 	br	200a2b8 <__alt_mem_mem_0+0xfcfea2b8>
 200a3f0:	00804034 	movhi	r2,256
 200a3f4:	10bfffc4 	addi	r2,r2,-1
 200a3f8:	11808836 	bltu	r2,r6,200a61c <__udivdi3+0x51c>
 200a3fc:	00800404 	movi	r2,16
 200a400:	003f5606 	br	200a15c <__alt_mem_mem_0+0xfcfea15c>
 200a404:	30aed83a 	srl	r23,r6,r2
 200a408:	3d4e983a 	sll	r7,r7,r21
 200a40c:	80acd83a 	srl	r22,r16,r2
 200a410:	9884d83a 	srl	r2,r19,r2
 200a414:	3deeb03a 	or	r23,r7,r23
 200a418:	b824d43a 	srli	r18,r23,16
 200a41c:	8560983a 	sll	r16,r16,r21
 200a420:	b009883a 	mov	r4,r22
 200a424:	900b883a 	mov	r5,r18
 200a428:	3568983a 	sll	r20,r6,r21
 200a42c:	1420b03a 	or	r16,r2,r16
 200a430:	200ad0c0 	call	200ad0c <__umodsi3>
 200a434:	b009883a 	mov	r4,r22
 200a438:	900b883a 	mov	r5,r18
 200a43c:	1023883a 	mov	r17,r2
 200a440:	200aca80 	call	200aca8 <__udivsi3>
 200a444:	8808943a 	slli	r4,r17,16
 200a448:	bf3fffcc 	andi	fp,r23,65535
 200a44c:	8006d43a 	srli	r3,r16,16
 200a450:	e0a3383a 	mul	r17,fp,r2
 200a454:	100d883a 	mov	r6,r2
 200a458:	1906b03a 	or	r3,r3,r4
 200a45c:	1c40042e 	bgeu	r3,r17,200a470 <__udivdi3+0x370>
 200a460:	1dc7883a 	add	r3,r3,r23
 200a464:	10bfffc4 	addi	r2,r2,-1
 200a468:	1dc0752e 	bgeu	r3,r23,200a640 <__udivdi3+0x540>
 200a46c:	100d883a 	mov	r6,r2
 200a470:	1c63c83a 	sub	r17,r3,r17
 200a474:	900b883a 	mov	r5,r18
 200a478:	8809883a 	mov	r4,r17
 200a47c:	d9800015 	stw	r6,0(sp)
 200a480:	200ad0c0 	call	200ad0c <__umodsi3>
 200a484:	102d883a 	mov	r22,r2
 200a488:	8809883a 	mov	r4,r17
 200a48c:	900b883a 	mov	r5,r18
 200a490:	200aca80 	call	200aca8 <__udivsi3>
 200a494:	b02c943a 	slli	r22,r22,16
 200a498:	e089383a 	mul	r4,fp,r2
 200a49c:	843fffcc 	andi	r16,r16,65535
 200a4a0:	85a0b03a 	or	r16,r16,r22
 200a4a4:	d9800017 	ldw	r6,0(sp)
 200a4a8:	8100042e 	bgeu	r16,r4,200a4bc <__udivdi3+0x3bc>
 200a4ac:	85e1883a 	add	r16,r16,r23
 200a4b0:	10ffffc4 	addi	r3,r2,-1
 200a4b4:	85c05e2e 	bgeu	r16,r23,200a630 <__udivdi3+0x530>
 200a4b8:	1805883a 	mov	r2,r3
 200a4bc:	300c943a 	slli	r6,r6,16
 200a4c0:	a17fffcc 	andi	r5,r20,65535
 200a4c4:	a028d43a 	srli	r20,r20,16
 200a4c8:	3084b03a 	or	r2,r6,r2
 200a4cc:	10ffffcc 	andi	r3,r2,65535
 200a4d0:	100cd43a 	srli	r6,r2,16
 200a4d4:	194f383a 	mul	r7,r3,r5
 200a4d8:	1d07383a 	mul	r3,r3,r20
 200a4dc:	314b383a 	mul	r5,r6,r5
 200a4e0:	3810d43a 	srli	r8,r7,16
 200a4e4:	8121c83a 	sub	r16,r16,r4
 200a4e8:	1947883a 	add	r3,r3,r5
 200a4ec:	40c7883a 	add	r3,r8,r3
 200a4f0:	350d383a 	mul	r6,r6,r20
 200a4f4:	1940022e 	bgeu	r3,r5,200a500 <__udivdi3+0x400>
 200a4f8:	01000074 	movhi	r4,1
 200a4fc:	310d883a 	add	r6,r6,r4
 200a500:	1828d43a 	srli	r20,r3,16
 200a504:	a18d883a 	add	r6,r20,r6
 200a508:	81803e36 	bltu	r16,r6,200a604 <__udivdi3+0x504>
 200a50c:	81803826 	beq	r16,r6,200a5f0 <__udivdi3+0x4f0>
 200a510:	0007883a 	mov	r3,zero
 200a514:	003fa206 	br	200a3a0 <__alt_mem_mem_0+0xfcfea3a0>
 200a518:	88e2983a 	sll	r17,r17,r3
 200a51c:	80a8d83a 	srl	r20,r16,r2
 200a520:	80e0983a 	sll	r16,r16,r3
 200a524:	882ad43a 	srli	r21,r17,16
 200a528:	9884d83a 	srl	r2,r19,r2
 200a52c:	a009883a 	mov	r4,r20
 200a530:	a80b883a 	mov	r5,r21
 200a534:	142eb03a 	or	r23,r2,r16
 200a538:	98e4983a 	sll	r18,r19,r3
 200a53c:	200ad0c0 	call	200ad0c <__umodsi3>
 200a540:	a009883a 	mov	r4,r20
 200a544:	a80b883a 	mov	r5,r21
 200a548:	1021883a 	mov	r16,r2
 200a54c:	200aca80 	call	200aca8 <__udivsi3>
 200a550:	1039883a 	mov	fp,r2
 200a554:	8d3fffcc 	andi	r20,r17,65535
 200a558:	8020943a 	slli	r16,r16,16
 200a55c:	b804d43a 	srli	r2,r23,16
 200a560:	a72d383a 	mul	r22,r20,fp
 200a564:	1404b03a 	or	r2,r2,r16
 200a568:	1580062e 	bgeu	r2,r22,200a584 <__udivdi3+0x484>
 200a56c:	1445883a 	add	r2,r2,r17
 200a570:	e0ffffc4 	addi	r3,fp,-1
 200a574:	14403836 	bltu	r2,r17,200a658 <__udivdi3+0x558>
 200a578:	1580372e 	bgeu	r2,r22,200a658 <__udivdi3+0x558>
 200a57c:	e73fff84 	addi	fp,fp,-2
 200a580:	1445883a 	add	r2,r2,r17
 200a584:	15adc83a 	sub	r22,r2,r22
 200a588:	a80b883a 	mov	r5,r21
 200a58c:	b009883a 	mov	r4,r22
 200a590:	200ad0c0 	call	200ad0c <__umodsi3>
 200a594:	1027883a 	mov	r19,r2
 200a598:	b009883a 	mov	r4,r22
 200a59c:	a80b883a 	mov	r5,r21
 200a5a0:	200aca80 	call	200aca8 <__udivsi3>
 200a5a4:	9826943a 	slli	r19,r19,16
 200a5a8:	a0a1383a 	mul	r16,r20,r2
 200a5ac:	b93fffcc 	andi	r4,r23,65535
 200a5b0:	24c8b03a 	or	r4,r4,r19
 200a5b4:	2400062e 	bgeu	r4,r16,200a5d0 <__udivdi3+0x4d0>
 200a5b8:	2449883a 	add	r4,r4,r17
 200a5bc:	10ffffc4 	addi	r3,r2,-1
 200a5c0:	24402336 	bltu	r4,r17,200a650 <__udivdi3+0x550>
 200a5c4:	2400222e 	bgeu	r4,r16,200a650 <__udivdi3+0x550>
 200a5c8:	10bfff84 	addi	r2,r2,-2
 200a5cc:	2449883a 	add	r4,r4,r17
 200a5d0:	e038943a 	slli	fp,fp,16
 200a5d4:	2421c83a 	sub	r16,r4,r16
 200a5d8:	e086b03a 	or	r3,fp,r2
 200a5dc:	003f4306 	br	200a2ec <__alt_mem_mem_0+0xfcfea2ec>
 200a5e0:	2005883a 	mov	r2,r4
 200a5e4:	003f6906 	br	200a38c <__alt_mem_mem_0+0xfcfea38c>
 200a5e8:	1805883a 	mov	r2,r3
 200a5ec:	003f0f06 	br	200a22c <__alt_mem_mem_0+0xfcfea22c>
 200a5f0:	1806943a 	slli	r3,r3,16
 200a5f4:	9d66983a 	sll	r19,r19,r21
 200a5f8:	39ffffcc 	andi	r7,r7,65535
 200a5fc:	19c7883a 	add	r3,r3,r7
 200a600:	98ffc32e 	bgeu	r19,r3,200a510 <__alt_mem_mem_0+0xfcfea510>
 200a604:	10bfffc4 	addi	r2,r2,-1
 200a608:	003fc106 	br	200a510 <__alt_mem_mem_0+0xfcfea510>
 200a60c:	00800604 	movi	r2,24
 200a610:	003f1106 	br	200a258 <__alt_mem_mem_0+0xfcfea258>
 200a614:	00800604 	movi	r2,24
 200a618:	003f2706 	br	200a2b8 <__alt_mem_mem_0+0xfcfea2b8>
 200a61c:	00800604 	movi	r2,24
 200a620:	003ece06 	br	200a15c <__alt_mem_mem_0+0xfcfea15c>
 200a624:	0007883a 	mov	r3,zero
 200a628:	00800044 	movi	r2,1
 200a62c:	003f5c06 	br	200a3a0 <__alt_mem_mem_0+0xfcfea3a0>
 200a630:	813fa12e 	bgeu	r16,r4,200a4b8 <__alt_mem_mem_0+0xfcfea4b8>
 200a634:	10bfff84 	addi	r2,r2,-2
 200a638:	85e1883a 	add	r16,r16,r23
 200a63c:	003f9f06 	br	200a4bc <__alt_mem_mem_0+0xfcfea4bc>
 200a640:	1c7f8a2e 	bgeu	r3,r17,200a46c <__alt_mem_mem_0+0xfcfea46c>
 200a644:	31bfff84 	addi	r6,r6,-2
 200a648:	1dc7883a 	add	r3,r3,r23
 200a64c:	003f8806 	br	200a470 <__alt_mem_mem_0+0xfcfea470>
 200a650:	1805883a 	mov	r2,r3
 200a654:	003fde06 	br	200a5d0 <__alt_mem_mem_0+0xfcfea5d0>
 200a658:	1839883a 	mov	fp,r3
 200a65c:	003fc906 	br	200a584 <__alt_mem_mem_0+0xfcfea584>
 200a660:	b5bfff84 	addi	r22,r22,-2
 200a664:	2449883a 	add	r4,r4,r17
 200a668:	003f3406 	br	200a33c <__alt_mem_mem_0+0xfcfea33c>
 200a66c:	b5bfff84 	addi	r22,r22,-2
 200a670:	1445883a 	add	r2,r2,r17
 200a674:	003edb06 	br	200a1e4 <__alt_mem_mem_0+0xfcfea1e4>

0200a678 <__umoddi3>:
 200a678:	defff404 	addi	sp,sp,-48
 200a67c:	df000a15 	stw	fp,40(sp)
 200a680:	dc400315 	stw	r17,12(sp)
 200a684:	dc000215 	stw	r16,8(sp)
 200a688:	dfc00b15 	stw	ra,44(sp)
 200a68c:	ddc00915 	stw	r23,36(sp)
 200a690:	dd800815 	stw	r22,32(sp)
 200a694:	dd400715 	stw	r21,28(sp)
 200a698:	dd000615 	stw	r20,24(sp)
 200a69c:	dcc00515 	stw	r19,20(sp)
 200a6a0:	dc800415 	stw	r18,16(sp)
 200a6a4:	2021883a 	mov	r16,r4
 200a6a8:	2823883a 	mov	r17,r5
 200a6ac:	2839883a 	mov	fp,r5
 200a6b0:	38003c1e 	bne	r7,zero,200a7a4 <__umoddi3+0x12c>
 200a6b4:	3027883a 	mov	r19,r6
 200a6b8:	2029883a 	mov	r20,r4
 200a6bc:	2980512e 	bgeu	r5,r6,200a804 <__umoddi3+0x18c>
 200a6c0:	00bfffd4 	movui	r2,65535
 200a6c4:	11809a36 	bltu	r2,r6,200a930 <__umoddi3+0x2b8>
 200a6c8:	01003fc4 	movi	r4,255
 200a6cc:	2189803a 	cmpltu	r4,r4,r6
 200a6d0:	200890fa 	slli	r4,r4,3
 200a6d4:	3104d83a 	srl	r2,r6,r4
 200a6d8:	00c08134 	movhi	r3,516
 200a6dc:	18c43704 	addi	r3,r3,4316
 200a6e0:	1885883a 	add	r2,r3,r2
 200a6e4:	10c00003 	ldbu	r3,0(r2)
 200a6e8:	00800804 	movi	r2,32
 200a6ec:	1909883a 	add	r4,r3,r4
 200a6f0:	1125c83a 	sub	r18,r2,r4
 200a6f4:	90000526 	beq	r18,zero,200a70c <__umoddi3+0x94>
 200a6f8:	8ca2983a 	sll	r17,r17,r18
 200a6fc:	8108d83a 	srl	r4,r16,r4
 200a700:	34a6983a 	sll	r19,r6,r18
 200a704:	84a8983a 	sll	r20,r16,r18
 200a708:	2478b03a 	or	fp,r4,r17
 200a70c:	982ed43a 	srli	r23,r19,16
 200a710:	e009883a 	mov	r4,fp
 200a714:	9dbfffcc 	andi	r22,r19,65535
 200a718:	b80b883a 	mov	r5,r23
 200a71c:	200ad0c0 	call	200ad0c <__umodsi3>
 200a720:	e009883a 	mov	r4,fp
 200a724:	b80b883a 	mov	r5,r23
 200a728:	102b883a 	mov	r21,r2
 200a72c:	200aca80 	call	200aca8 <__udivsi3>
 200a730:	a806943a 	slli	r3,r21,16
 200a734:	a008d43a 	srli	r4,r20,16
 200a738:	b085383a 	mul	r2,r22,r2
 200a73c:	20c8b03a 	or	r4,r4,r3
 200a740:	2080032e 	bgeu	r4,r2,200a750 <__umoddi3+0xd8>
 200a744:	24c9883a 	add	r4,r4,r19
 200a748:	24c00136 	bltu	r4,r19,200a750 <__umoddi3+0xd8>
 200a74c:	20811036 	bltu	r4,r2,200ab90 <__umoddi3+0x518>
 200a750:	20abc83a 	sub	r21,r4,r2
 200a754:	b80b883a 	mov	r5,r23
 200a758:	a809883a 	mov	r4,r21
 200a75c:	200ad0c0 	call	200ad0c <__umodsi3>
 200a760:	1023883a 	mov	r17,r2
 200a764:	b80b883a 	mov	r5,r23
 200a768:	a809883a 	mov	r4,r21
 200a76c:	200aca80 	call	200aca8 <__udivsi3>
 200a770:	8822943a 	slli	r17,r17,16
 200a774:	b085383a 	mul	r2,r22,r2
 200a778:	a0ffffcc 	andi	r3,r20,65535
 200a77c:	1c46b03a 	or	r3,r3,r17
 200a780:	1880042e 	bgeu	r3,r2,200a794 <__umoddi3+0x11c>
 200a784:	1cc7883a 	add	r3,r3,r19
 200a788:	1cc00236 	bltu	r3,r19,200a794 <__umoddi3+0x11c>
 200a78c:	1880012e 	bgeu	r3,r2,200a794 <__umoddi3+0x11c>
 200a790:	1cc7883a 	add	r3,r3,r19
 200a794:	1885c83a 	sub	r2,r3,r2
 200a798:	1484d83a 	srl	r2,r2,r18
 200a79c:	0007883a 	mov	r3,zero
 200a7a0:	00004f06 	br	200a8e0 <__umoddi3+0x268>
 200a7a4:	29c04c36 	bltu	r5,r7,200a8d8 <__umoddi3+0x260>
 200a7a8:	00bfffd4 	movui	r2,65535
 200a7ac:	11c0582e 	bgeu	r2,r7,200a910 <__umoddi3+0x298>
 200a7b0:	00804034 	movhi	r2,256
 200a7b4:	10bfffc4 	addi	r2,r2,-1
 200a7b8:	11c0e736 	bltu	r2,r7,200ab58 <__umoddi3+0x4e0>
 200a7bc:	01000404 	movi	r4,16
 200a7c0:	3904d83a 	srl	r2,r7,r4
 200a7c4:	00c08134 	movhi	r3,516
 200a7c8:	18c43704 	addi	r3,r3,4316
 200a7cc:	1885883a 	add	r2,r3,r2
 200a7d0:	14c00003 	ldbu	r19,0(r2)
 200a7d4:	00c00804 	movi	r3,32
 200a7d8:	9927883a 	add	r19,r19,r4
 200a7dc:	1ce9c83a 	sub	r20,r3,r19
 200a7e0:	a000581e 	bne	r20,zero,200a944 <__umoddi3+0x2cc>
 200a7e4:	3c400136 	bltu	r7,r17,200a7ec <__umoddi3+0x174>
 200a7e8:	8180eb36 	bltu	r16,r6,200ab98 <__umoddi3+0x520>
 200a7ec:	8185c83a 	sub	r2,r16,r6
 200a7f0:	89e3c83a 	sub	r17,r17,r7
 200a7f4:	8089803a 	cmpltu	r4,r16,r2
 200a7f8:	8939c83a 	sub	fp,r17,r4
 200a7fc:	e007883a 	mov	r3,fp
 200a800:	00003706 	br	200a8e0 <__umoddi3+0x268>
 200a804:	3000041e 	bne	r6,zero,200a818 <__umoddi3+0x1a0>
 200a808:	000b883a 	mov	r5,zero
 200a80c:	01000044 	movi	r4,1
 200a810:	200aca80 	call	200aca8 <__udivsi3>
 200a814:	1027883a 	mov	r19,r2
 200a818:	00bfffd4 	movui	r2,65535
 200a81c:	14c0402e 	bgeu	r2,r19,200a920 <__umoddi3+0x2a8>
 200a820:	00804034 	movhi	r2,256
 200a824:	10bfffc4 	addi	r2,r2,-1
 200a828:	14c0cd36 	bltu	r2,r19,200ab60 <__umoddi3+0x4e8>
 200a82c:	00800404 	movi	r2,16
 200a830:	9886d83a 	srl	r3,r19,r2
 200a834:	01008134 	movhi	r4,516
 200a838:	21043704 	addi	r4,r4,4316
 200a83c:	20c7883a 	add	r3,r4,r3
 200a840:	18c00003 	ldbu	r3,0(r3)
 200a844:	1887883a 	add	r3,r3,r2
 200a848:	00800804 	movi	r2,32
 200a84c:	10e5c83a 	sub	r18,r2,r3
 200a850:	9000901e 	bne	r18,zero,200aa94 <__umoddi3+0x41c>
 200a854:	982cd43a 	srli	r22,r19,16
 200a858:	8ce3c83a 	sub	r17,r17,r19
 200a85c:	9d7fffcc 	andi	r21,r19,65535
 200a860:	b00b883a 	mov	r5,r22
 200a864:	8809883a 	mov	r4,r17
 200a868:	200ad0c0 	call	200ad0c <__umodsi3>
 200a86c:	8809883a 	mov	r4,r17
 200a870:	b00b883a 	mov	r5,r22
 200a874:	1021883a 	mov	r16,r2
 200a878:	200aca80 	call	200aca8 <__udivsi3>
 200a87c:	8006943a 	slli	r3,r16,16
 200a880:	a008d43a 	srli	r4,r20,16
 200a884:	1545383a 	mul	r2,r2,r21
 200a888:	20c8b03a 	or	r4,r4,r3
 200a88c:	2080042e 	bgeu	r4,r2,200a8a0 <__umoddi3+0x228>
 200a890:	24c9883a 	add	r4,r4,r19
 200a894:	24c00236 	bltu	r4,r19,200a8a0 <__umoddi3+0x228>
 200a898:	2080012e 	bgeu	r4,r2,200a8a0 <__umoddi3+0x228>
 200a89c:	24c9883a 	add	r4,r4,r19
 200a8a0:	20a1c83a 	sub	r16,r4,r2
 200a8a4:	b00b883a 	mov	r5,r22
 200a8a8:	8009883a 	mov	r4,r16
 200a8ac:	200ad0c0 	call	200ad0c <__umodsi3>
 200a8b0:	1023883a 	mov	r17,r2
 200a8b4:	b00b883a 	mov	r5,r22
 200a8b8:	8009883a 	mov	r4,r16
 200a8bc:	200aca80 	call	200aca8 <__udivsi3>
 200a8c0:	8822943a 	slli	r17,r17,16
 200a8c4:	1545383a 	mul	r2,r2,r21
 200a8c8:	a53fffcc 	andi	r20,r20,65535
 200a8cc:	a446b03a 	or	r3,r20,r17
 200a8d0:	18bfb02e 	bgeu	r3,r2,200a794 <__alt_mem_mem_0+0xfcfea794>
 200a8d4:	003fab06 	br	200a784 <__alt_mem_mem_0+0xfcfea784>
 200a8d8:	2005883a 	mov	r2,r4
 200a8dc:	2807883a 	mov	r3,r5
 200a8e0:	dfc00b17 	ldw	ra,44(sp)
 200a8e4:	df000a17 	ldw	fp,40(sp)
 200a8e8:	ddc00917 	ldw	r23,36(sp)
 200a8ec:	dd800817 	ldw	r22,32(sp)
 200a8f0:	dd400717 	ldw	r21,28(sp)
 200a8f4:	dd000617 	ldw	r20,24(sp)
 200a8f8:	dcc00517 	ldw	r19,20(sp)
 200a8fc:	dc800417 	ldw	r18,16(sp)
 200a900:	dc400317 	ldw	r17,12(sp)
 200a904:	dc000217 	ldw	r16,8(sp)
 200a908:	dec00c04 	addi	sp,sp,48
 200a90c:	f800283a 	ret
 200a910:	04c03fc4 	movi	r19,255
 200a914:	99c9803a 	cmpltu	r4,r19,r7
 200a918:	200890fa 	slli	r4,r4,3
 200a91c:	003fa806 	br	200a7c0 <__alt_mem_mem_0+0xfcfea7c0>
 200a920:	00803fc4 	movi	r2,255
 200a924:	14c5803a 	cmpltu	r2,r2,r19
 200a928:	100490fa 	slli	r2,r2,3
 200a92c:	003fc006 	br	200a830 <__alt_mem_mem_0+0xfcfea830>
 200a930:	00804034 	movhi	r2,256
 200a934:	10bfffc4 	addi	r2,r2,-1
 200a938:	11808b36 	bltu	r2,r6,200ab68 <__umoddi3+0x4f0>
 200a93c:	01000404 	movi	r4,16
 200a940:	003f6406 	br	200a6d4 <__alt_mem_mem_0+0xfcfea6d4>
 200a944:	34c4d83a 	srl	r2,r6,r19
 200a948:	3d0e983a 	sll	r7,r7,r20
 200a94c:	8cf8d83a 	srl	fp,r17,r19
 200a950:	8d10983a 	sll	r8,r17,r20
 200a954:	38aab03a 	or	r21,r7,r2
 200a958:	a82cd43a 	srli	r22,r21,16
 200a95c:	84e2d83a 	srl	r17,r16,r19
 200a960:	e009883a 	mov	r4,fp
 200a964:	b00b883a 	mov	r5,r22
 200a968:	8a22b03a 	or	r17,r17,r8
 200a96c:	3524983a 	sll	r18,r6,r20
 200a970:	200ad0c0 	call	200ad0c <__umodsi3>
 200a974:	e009883a 	mov	r4,fp
 200a978:	b00b883a 	mov	r5,r22
 200a97c:	102f883a 	mov	r23,r2
 200a980:	200aca80 	call	200aca8 <__udivsi3>
 200a984:	100d883a 	mov	r6,r2
 200a988:	b808943a 	slli	r4,r23,16
 200a98c:	aa3fffcc 	andi	r8,r21,65535
 200a990:	8804d43a 	srli	r2,r17,16
 200a994:	41af383a 	mul	r23,r8,r6
 200a998:	8520983a 	sll	r16,r16,r20
 200a99c:	1104b03a 	or	r2,r2,r4
 200a9a0:	15c0042e 	bgeu	r2,r23,200a9b4 <__umoddi3+0x33c>
 200a9a4:	1545883a 	add	r2,r2,r21
 200a9a8:	30ffffc4 	addi	r3,r6,-1
 200a9ac:	1540742e 	bgeu	r2,r21,200ab80 <__umoddi3+0x508>
 200a9b0:	180d883a 	mov	r6,r3
 200a9b4:	15efc83a 	sub	r23,r2,r23
 200a9b8:	b00b883a 	mov	r5,r22
 200a9bc:	b809883a 	mov	r4,r23
 200a9c0:	d9800115 	stw	r6,4(sp)
 200a9c4:	da000015 	stw	r8,0(sp)
 200a9c8:	200ad0c0 	call	200ad0c <__umodsi3>
 200a9cc:	b00b883a 	mov	r5,r22
 200a9d0:	b809883a 	mov	r4,r23
 200a9d4:	1039883a 	mov	fp,r2
 200a9d8:	200aca80 	call	200aca8 <__udivsi3>
 200a9dc:	da000017 	ldw	r8,0(sp)
 200a9e0:	e038943a 	slli	fp,fp,16
 200a9e4:	100b883a 	mov	r5,r2
 200a9e8:	4089383a 	mul	r4,r8,r2
 200a9ec:	8a3fffcc 	andi	r8,r17,65535
 200a9f0:	4710b03a 	or	r8,r8,fp
 200a9f4:	d9800117 	ldw	r6,4(sp)
 200a9f8:	4100042e 	bgeu	r8,r4,200aa0c <__umoddi3+0x394>
 200a9fc:	4551883a 	add	r8,r8,r21
 200aa00:	10bfffc4 	addi	r2,r2,-1
 200aa04:	45405a2e 	bgeu	r8,r21,200ab70 <__umoddi3+0x4f8>
 200aa08:	100b883a 	mov	r5,r2
 200aa0c:	300c943a 	slli	r6,r6,16
 200aa10:	91ffffcc 	andi	r7,r18,65535
 200aa14:	9004d43a 	srli	r2,r18,16
 200aa18:	314cb03a 	or	r6,r6,r5
 200aa1c:	317fffcc 	andi	r5,r6,65535
 200aa20:	300cd43a 	srli	r6,r6,16
 200aa24:	29d3383a 	mul	r9,r5,r7
 200aa28:	288b383a 	mul	r5,r5,r2
 200aa2c:	31cf383a 	mul	r7,r6,r7
 200aa30:	4806d43a 	srli	r3,r9,16
 200aa34:	4111c83a 	sub	r8,r8,r4
 200aa38:	29cb883a 	add	r5,r5,r7
 200aa3c:	194b883a 	add	r5,r3,r5
 200aa40:	3085383a 	mul	r2,r6,r2
 200aa44:	29c0022e 	bgeu	r5,r7,200aa50 <__umoddi3+0x3d8>
 200aa48:	00c00074 	movhi	r3,1
 200aa4c:	10c5883a 	add	r2,r2,r3
 200aa50:	2808d43a 	srli	r4,r5,16
 200aa54:	280a943a 	slli	r5,r5,16
 200aa58:	4a7fffcc 	andi	r9,r9,65535
 200aa5c:	2085883a 	add	r2,r4,r2
 200aa60:	2a4b883a 	add	r5,r5,r9
 200aa64:	40803636 	bltu	r8,r2,200ab40 <__umoddi3+0x4c8>
 200aa68:	40804d26 	beq	r8,r2,200aba0 <__umoddi3+0x528>
 200aa6c:	4089c83a 	sub	r4,r8,r2
 200aa70:	280f883a 	mov	r7,r5
 200aa74:	81cfc83a 	sub	r7,r16,r7
 200aa78:	81c7803a 	cmpltu	r3,r16,r7
 200aa7c:	20c7c83a 	sub	r3,r4,r3
 200aa80:	1cc4983a 	sll	r2,r3,r19
 200aa84:	3d0ed83a 	srl	r7,r7,r20
 200aa88:	1d06d83a 	srl	r3,r3,r20
 200aa8c:	11c4b03a 	or	r2,r2,r7
 200aa90:	003f9306 	br	200a8e0 <__alt_mem_mem_0+0xfcfea8e0>
 200aa94:	9ca6983a 	sll	r19,r19,r18
 200aa98:	88e8d83a 	srl	r20,r17,r3
 200aa9c:	80c4d83a 	srl	r2,r16,r3
 200aaa0:	982cd43a 	srli	r22,r19,16
 200aaa4:	8ca2983a 	sll	r17,r17,r18
 200aaa8:	a009883a 	mov	r4,r20
 200aaac:	b00b883a 	mov	r5,r22
 200aab0:	1478b03a 	or	fp,r2,r17
 200aab4:	200ad0c0 	call	200ad0c <__umodsi3>
 200aab8:	a009883a 	mov	r4,r20
 200aabc:	b00b883a 	mov	r5,r22
 200aac0:	1023883a 	mov	r17,r2
 200aac4:	200aca80 	call	200aca8 <__udivsi3>
 200aac8:	9d7fffcc 	andi	r21,r19,65535
 200aacc:	880a943a 	slli	r5,r17,16
 200aad0:	e008d43a 	srli	r4,fp,16
 200aad4:	a885383a 	mul	r2,r21,r2
 200aad8:	84a8983a 	sll	r20,r16,r18
 200aadc:	2148b03a 	or	r4,r4,r5
 200aae0:	2080042e 	bgeu	r4,r2,200aaf4 <__umoddi3+0x47c>
 200aae4:	24c9883a 	add	r4,r4,r19
 200aae8:	24c00236 	bltu	r4,r19,200aaf4 <__umoddi3+0x47c>
 200aaec:	2080012e 	bgeu	r4,r2,200aaf4 <__umoddi3+0x47c>
 200aaf0:	24c9883a 	add	r4,r4,r19
 200aaf4:	20a3c83a 	sub	r17,r4,r2
 200aaf8:	b00b883a 	mov	r5,r22
 200aafc:	8809883a 	mov	r4,r17
 200ab00:	200ad0c0 	call	200ad0c <__umodsi3>
 200ab04:	102f883a 	mov	r23,r2
 200ab08:	8809883a 	mov	r4,r17
 200ab0c:	b00b883a 	mov	r5,r22
 200ab10:	200aca80 	call	200aca8 <__udivsi3>
 200ab14:	b82e943a 	slli	r23,r23,16
 200ab18:	a885383a 	mul	r2,r21,r2
 200ab1c:	e13fffcc 	andi	r4,fp,65535
 200ab20:	25c8b03a 	or	r4,r4,r23
 200ab24:	2080042e 	bgeu	r4,r2,200ab38 <__umoddi3+0x4c0>
 200ab28:	24c9883a 	add	r4,r4,r19
 200ab2c:	24c00236 	bltu	r4,r19,200ab38 <__umoddi3+0x4c0>
 200ab30:	2080012e 	bgeu	r4,r2,200ab38 <__umoddi3+0x4c0>
 200ab34:	24c9883a 	add	r4,r4,r19
 200ab38:	20a3c83a 	sub	r17,r4,r2
 200ab3c:	003f4806 	br	200a860 <__alt_mem_mem_0+0xfcfea860>
 200ab40:	2c8fc83a 	sub	r7,r5,r18
 200ab44:	1545c83a 	sub	r2,r2,r21
 200ab48:	29cb803a 	cmpltu	r5,r5,r7
 200ab4c:	1145c83a 	sub	r2,r2,r5
 200ab50:	4089c83a 	sub	r4,r8,r2
 200ab54:	003fc706 	br	200aa74 <__alt_mem_mem_0+0xfcfeaa74>
 200ab58:	01000604 	movi	r4,24
 200ab5c:	003f1806 	br	200a7c0 <__alt_mem_mem_0+0xfcfea7c0>
 200ab60:	00800604 	movi	r2,24
 200ab64:	003f3206 	br	200a830 <__alt_mem_mem_0+0xfcfea830>
 200ab68:	01000604 	movi	r4,24
 200ab6c:	003ed906 	br	200a6d4 <__alt_mem_mem_0+0xfcfea6d4>
 200ab70:	413fa52e 	bgeu	r8,r4,200aa08 <__alt_mem_mem_0+0xfcfeaa08>
 200ab74:	297fff84 	addi	r5,r5,-2
 200ab78:	4551883a 	add	r8,r8,r21
 200ab7c:	003fa306 	br	200aa0c <__alt_mem_mem_0+0xfcfeaa0c>
 200ab80:	15ff8b2e 	bgeu	r2,r23,200a9b0 <__alt_mem_mem_0+0xfcfea9b0>
 200ab84:	31bfff84 	addi	r6,r6,-2
 200ab88:	1545883a 	add	r2,r2,r21
 200ab8c:	003f8906 	br	200a9b4 <__alt_mem_mem_0+0xfcfea9b4>
 200ab90:	24c9883a 	add	r4,r4,r19
 200ab94:	003eee06 	br	200a750 <__alt_mem_mem_0+0xfcfea750>
 200ab98:	8005883a 	mov	r2,r16
 200ab9c:	003f1706 	br	200a7fc <__alt_mem_mem_0+0xfcfea7fc>
 200aba0:	817fe736 	bltu	r16,r5,200ab40 <__alt_mem_mem_0+0xfcfeab40>
 200aba4:	280f883a 	mov	r7,r5
 200aba8:	0009883a 	mov	r4,zero
 200abac:	003fb106 	br	200aa74 <__alt_mem_mem_0+0xfcfeaa74>

0200abb0 <__divsi3>:
 200abb0:	20001b16 	blt	r4,zero,200ac20 <__divsi3+0x70>
 200abb4:	000f883a 	mov	r7,zero
 200abb8:	28001616 	blt	r5,zero,200ac14 <__divsi3+0x64>
 200abbc:	200d883a 	mov	r6,r4
 200abc0:	29001a2e 	bgeu	r5,r4,200ac2c <__divsi3+0x7c>
 200abc4:	00800804 	movi	r2,32
 200abc8:	00c00044 	movi	r3,1
 200abcc:	00000106 	br	200abd4 <__divsi3+0x24>
 200abd0:	10000d26 	beq	r2,zero,200ac08 <__divsi3+0x58>
 200abd4:	294b883a 	add	r5,r5,r5
 200abd8:	10bfffc4 	addi	r2,r2,-1
 200abdc:	18c7883a 	add	r3,r3,r3
 200abe0:	293ffb36 	bltu	r5,r4,200abd0 <__alt_mem_mem_0+0xfcfeabd0>
 200abe4:	0005883a 	mov	r2,zero
 200abe8:	18000726 	beq	r3,zero,200ac08 <__divsi3+0x58>
 200abec:	0005883a 	mov	r2,zero
 200abf0:	31400236 	bltu	r6,r5,200abfc <__divsi3+0x4c>
 200abf4:	314dc83a 	sub	r6,r6,r5
 200abf8:	10c4b03a 	or	r2,r2,r3
 200abfc:	1806d07a 	srli	r3,r3,1
 200ac00:	280ad07a 	srli	r5,r5,1
 200ac04:	183ffa1e 	bne	r3,zero,200abf0 <__alt_mem_mem_0+0xfcfeabf0>
 200ac08:	38000126 	beq	r7,zero,200ac10 <__divsi3+0x60>
 200ac0c:	0085c83a 	sub	r2,zero,r2
 200ac10:	f800283a 	ret
 200ac14:	014bc83a 	sub	r5,zero,r5
 200ac18:	39c0005c 	xori	r7,r7,1
 200ac1c:	003fe706 	br	200abbc <__alt_mem_mem_0+0xfcfeabbc>
 200ac20:	0109c83a 	sub	r4,zero,r4
 200ac24:	01c00044 	movi	r7,1
 200ac28:	003fe306 	br	200abb8 <__alt_mem_mem_0+0xfcfeabb8>
 200ac2c:	00c00044 	movi	r3,1
 200ac30:	003fee06 	br	200abec <__alt_mem_mem_0+0xfcfeabec>

0200ac34 <__modsi3>:
 200ac34:	20001716 	blt	r4,zero,200ac94 <__modsi3+0x60>
 200ac38:	000f883a 	mov	r7,zero
 200ac3c:	2005883a 	mov	r2,r4
 200ac40:	28001216 	blt	r5,zero,200ac8c <__modsi3+0x58>
 200ac44:	2900162e 	bgeu	r5,r4,200aca0 <__modsi3+0x6c>
 200ac48:	01800804 	movi	r6,32
 200ac4c:	00c00044 	movi	r3,1
 200ac50:	00000106 	br	200ac58 <__modsi3+0x24>
 200ac54:	30000a26 	beq	r6,zero,200ac80 <__modsi3+0x4c>
 200ac58:	294b883a 	add	r5,r5,r5
 200ac5c:	31bfffc4 	addi	r6,r6,-1
 200ac60:	18c7883a 	add	r3,r3,r3
 200ac64:	293ffb36 	bltu	r5,r4,200ac54 <__alt_mem_mem_0+0xfcfeac54>
 200ac68:	18000526 	beq	r3,zero,200ac80 <__modsi3+0x4c>
 200ac6c:	1806d07a 	srli	r3,r3,1
 200ac70:	11400136 	bltu	r2,r5,200ac78 <__modsi3+0x44>
 200ac74:	1145c83a 	sub	r2,r2,r5
 200ac78:	280ad07a 	srli	r5,r5,1
 200ac7c:	183ffb1e 	bne	r3,zero,200ac6c <__alt_mem_mem_0+0xfcfeac6c>
 200ac80:	38000126 	beq	r7,zero,200ac88 <__modsi3+0x54>
 200ac84:	0085c83a 	sub	r2,zero,r2
 200ac88:	f800283a 	ret
 200ac8c:	014bc83a 	sub	r5,zero,r5
 200ac90:	003fec06 	br	200ac44 <__alt_mem_mem_0+0xfcfeac44>
 200ac94:	0109c83a 	sub	r4,zero,r4
 200ac98:	01c00044 	movi	r7,1
 200ac9c:	003fe706 	br	200ac3c <__alt_mem_mem_0+0xfcfeac3c>
 200aca0:	00c00044 	movi	r3,1
 200aca4:	003ff106 	br	200ac6c <__alt_mem_mem_0+0xfcfeac6c>

0200aca8 <__udivsi3>:
 200aca8:	200d883a 	mov	r6,r4
 200acac:	2900152e 	bgeu	r5,r4,200ad04 <__udivsi3+0x5c>
 200acb0:	28001416 	blt	r5,zero,200ad04 <__udivsi3+0x5c>
 200acb4:	00800804 	movi	r2,32
 200acb8:	00c00044 	movi	r3,1
 200acbc:	00000206 	br	200acc8 <__udivsi3+0x20>
 200acc0:	10000e26 	beq	r2,zero,200acfc <__udivsi3+0x54>
 200acc4:	28000516 	blt	r5,zero,200acdc <__udivsi3+0x34>
 200acc8:	294b883a 	add	r5,r5,r5
 200accc:	10bfffc4 	addi	r2,r2,-1
 200acd0:	18c7883a 	add	r3,r3,r3
 200acd4:	293ffa36 	bltu	r5,r4,200acc0 <__alt_mem_mem_0+0xfcfeacc0>
 200acd8:	18000826 	beq	r3,zero,200acfc <__udivsi3+0x54>
 200acdc:	0005883a 	mov	r2,zero
 200ace0:	31400236 	bltu	r6,r5,200acec <__udivsi3+0x44>
 200ace4:	314dc83a 	sub	r6,r6,r5
 200ace8:	10c4b03a 	or	r2,r2,r3
 200acec:	1806d07a 	srli	r3,r3,1
 200acf0:	280ad07a 	srli	r5,r5,1
 200acf4:	183ffa1e 	bne	r3,zero,200ace0 <__alt_mem_mem_0+0xfcfeace0>
 200acf8:	f800283a 	ret
 200acfc:	0005883a 	mov	r2,zero
 200ad00:	f800283a 	ret
 200ad04:	00c00044 	movi	r3,1
 200ad08:	003ff406 	br	200acdc <__alt_mem_mem_0+0xfcfeacdc>

0200ad0c <__umodsi3>:
 200ad0c:	2005883a 	mov	r2,r4
 200ad10:	2900122e 	bgeu	r5,r4,200ad5c <__umodsi3+0x50>
 200ad14:	28001116 	blt	r5,zero,200ad5c <__umodsi3+0x50>
 200ad18:	01800804 	movi	r6,32
 200ad1c:	00c00044 	movi	r3,1
 200ad20:	00000206 	br	200ad2c <__umodsi3+0x20>
 200ad24:	30000c26 	beq	r6,zero,200ad58 <__umodsi3+0x4c>
 200ad28:	28000516 	blt	r5,zero,200ad40 <__umodsi3+0x34>
 200ad2c:	294b883a 	add	r5,r5,r5
 200ad30:	31bfffc4 	addi	r6,r6,-1
 200ad34:	18c7883a 	add	r3,r3,r3
 200ad38:	293ffa36 	bltu	r5,r4,200ad24 <__alt_mem_mem_0+0xfcfead24>
 200ad3c:	18000626 	beq	r3,zero,200ad58 <__umodsi3+0x4c>
 200ad40:	1806d07a 	srli	r3,r3,1
 200ad44:	11400136 	bltu	r2,r5,200ad4c <__umodsi3+0x40>
 200ad48:	1145c83a 	sub	r2,r2,r5
 200ad4c:	280ad07a 	srli	r5,r5,1
 200ad50:	183ffb1e 	bne	r3,zero,200ad40 <__alt_mem_mem_0+0xfcfead40>
 200ad54:	f800283a 	ret
 200ad58:	f800283a 	ret
 200ad5c:	00c00044 	movi	r3,1
 200ad60:	003ff706 	br	200ad40 <__alt_mem_mem_0+0xfcfead40>

0200ad64 <__adddf3>:
 200ad64:	02c00434 	movhi	r11,16
 200ad68:	5affffc4 	addi	r11,r11,-1
 200ad6c:	2806d7fa 	srli	r3,r5,31
 200ad70:	2ad4703a 	and	r10,r5,r11
 200ad74:	3ad2703a 	and	r9,r7,r11
 200ad78:	3804d53a 	srli	r2,r7,20
 200ad7c:	3018d77a 	srli	r12,r6,29
 200ad80:	280ad53a 	srli	r5,r5,20
 200ad84:	501490fa 	slli	r10,r10,3
 200ad88:	2010d77a 	srli	r8,r4,29
 200ad8c:	481290fa 	slli	r9,r9,3
 200ad90:	380ed7fa 	srli	r7,r7,31
 200ad94:	defffb04 	addi	sp,sp,-20
 200ad98:	dc800215 	stw	r18,8(sp)
 200ad9c:	dc400115 	stw	r17,4(sp)
 200ada0:	dc000015 	stw	r16,0(sp)
 200ada4:	dfc00415 	stw	ra,16(sp)
 200ada8:	dcc00315 	stw	r19,12(sp)
 200adac:	1c803fcc 	andi	r18,r3,255
 200adb0:	2c01ffcc 	andi	r16,r5,2047
 200adb4:	5210b03a 	or	r8,r10,r8
 200adb8:	202290fa 	slli	r17,r4,3
 200adbc:	1081ffcc 	andi	r2,r2,2047
 200adc0:	4b12b03a 	or	r9,r9,r12
 200adc4:	300c90fa 	slli	r6,r6,3
 200adc8:	91c07526 	beq	r18,r7,200afa0 <__adddf3+0x23c>
 200adcc:	8087c83a 	sub	r3,r16,r2
 200add0:	00c0ab0e 	bge	zero,r3,200b080 <__adddf3+0x31c>
 200add4:	10002a1e 	bne	r2,zero,200ae80 <__adddf3+0x11c>
 200add8:	4984b03a 	or	r2,r9,r6
 200addc:	1000961e 	bne	r2,zero,200b038 <__adddf3+0x2d4>
 200ade0:	888001cc 	andi	r2,r17,7
 200ade4:	10000726 	beq	r2,zero,200ae04 <__adddf3+0xa0>
 200ade8:	888003cc 	andi	r2,r17,15
 200adec:	00c00104 	movi	r3,4
 200adf0:	10c00426 	beq	r2,r3,200ae04 <__adddf3+0xa0>
 200adf4:	88c7883a 	add	r3,r17,r3
 200adf8:	1c63803a 	cmpltu	r17,r3,r17
 200adfc:	4451883a 	add	r8,r8,r17
 200ae00:	1823883a 	mov	r17,r3
 200ae04:	4080202c 	andhi	r2,r8,128
 200ae08:	10005926 	beq	r2,zero,200af70 <__adddf3+0x20c>
 200ae0c:	84000044 	addi	r16,r16,1
 200ae10:	0081ffc4 	movi	r2,2047
 200ae14:	8080ba26 	beq	r16,r2,200b100 <__adddf3+0x39c>
 200ae18:	00bfe034 	movhi	r2,65408
 200ae1c:	10bfffc4 	addi	r2,r2,-1
 200ae20:	4090703a 	and	r8,r8,r2
 200ae24:	4004977a 	slli	r2,r8,29
 200ae28:	4010927a 	slli	r8,r8,9
 200ae2c:	8822d0fa 	srli	r17,r17,3
 200ae30:	8401ffcc 	andi	r16,r16,2047
 200ae34:	4010d33a 	srli	r8,r8,12
 200ae38:	9007883a 	mov	r3,r18
 200ae3c:	1444b03a 	or	r2,r2,r17
 200ae40:	8401ffcc 	andi	r16,r16,2047
 200ae44:	8020953a 	slli	r16,r16,20
 200ae48:	18c03fcc 	andi	r3,r3,255
 200ae4c:	01000434 	movhi	r4,16
 200ae50:	213fffc4 	addi	r4,r4,-1
 200ae54:	180697fa 	slli	r3,r3,31
 200ae58:	4110703a 	and	r8,r8,r4
 200ae5c:	4410b03a 	or	r8,r8,r16
 200ae60:	40c6b03a 	or	r3,r8,r3
 200ae64:	dfc00417 	ldw	ra,16(sp)
 200ae68:	dcc00317 	ldw	r19,12(sp)
 200ae6c:	dc800217 	ldw	r18,8(sp)
 200ae70:	dc400117 	ldw	r17,4(sp)
 200ae74:	dc000017 	ldw	r16,0(sp)
 200ae78:	dec00504 	addi	sp,sp,20
 200ae7c:	f800283a 	ret
 200ae80:	0081ffc4 	movi	r2,2047
 200ae84:	80bfd626 	beq	r16,r2,200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200ae88:	4a402034 	orhi	r9,r9,128
 200ae8c:	00800e04 	movi	r2,56
 200ae90:	10c09f16 	blt	r2,r3,200b110 <__adddf3+0x3ac>
 200ae94:	008007c4 	movi	r2,31
 200ae98:	10c0c216 	blt	r2,r3,200b1a4 <__adddf3+0x440>
 200ae9c:	00800804 	movi	r2,32
 200aea0:	10c5c83a 	sub	r2,r2,r3
 200aea4:	488a983a 	sll	r5,r9,r2
 200aea8:	30c8d83a 	srl	r4,r6,r3
 200aeac:	3084983a 	sll	r2,r6,r2
 200aeb0:	48c6d83a 	srl	r3,r9,r3
 200aeb4:	290cb03a 	or	r6,r5,r4
 200aeb8:	1004c03a 	cmpne	r2,r2,zero
 200aebc:	308cb03a 	or	r6,r6,r2
 200aec0:	898dc83a 	sub	r6,r17,r6
 200aec4:	89a3803a 	cmpltu	r17,r17,r6
 200aec8:	40d1c83a 	sub	r8,r8,r3
 200aecc:	4451c83a 	sub	r8,r8,r17
 200aed0:	3023883a 	mov	r17,r6
 200aed4:	4080202c 	andhi	r2,r8,128
 200aed8:	10002326 	beq	r2,zero,200af68 <__adddf3+0x204>
 200aedc:	04c02034 	movhi	r19,128
 200aee0:	9cffffc4 	addi	r19,r19,-1
 200aee4:	44e6703a 	and	r19,r8,r19
 200aee8:	98007626 	beq	r19,zero,200b0c4 <__adddf3+0x360>
 200aeec:	9809883a 	mov	r4,r19
 200aef0:	200d3680 	call	200d368 <__clzsi2>
 200aef4:	10fffe04 	addi	r3,r2,-8
 200aef8:	010007c4 	movi	r4,31
 200aefc:	20c07716 	blt	r4,r3,200b0dc <__adddf3+0x378>
 200af00:	00800804 	movi	r2,32
 200af04:	10c5c83a 	sub	r2,r2,r3
 200af08:	8884d83a 	srl	r2,r17,r2
 200af0c:	98d0983a 	sll	r8,r19,r3
 200af10:	88e2983a 	sll	r17,r17,r3
 200af14:	1204b03a 	or	r2,r2,r8
 200af18:	1c007416 	blt	r3,r16,200b0ec <__adddf3+0x388>
 200af1c:	1c21c83a 	sub	r16,r3,r16
 200af20:	82000044 	addi	r8,r16,1
 200af24:	00c007c4 	movi	r3,31
 200af28:	1a009116 	blt	r3,r8,200b170 <__adddf3+0x40c>
 200af2c:	00c00804 	movi	r3,32
 200af30:	1a07c83a 	sub	r3,r3,r8
 200af34:	8a08d83a 	srl	r4,r17,r8
 200af38:	88e2983a 	sll	r17,r17,r3
 200af3c:	10c6983a 	sll	r3,r2,r3
 200af40:	1210d83a 	srl	r8,r2,r8
 200af44:	8804c03a 	cmpne	r2,r17,zero
 200af48:	1906b03a 	or	r3,r3,r4
 200af4c:	18a2b03a 	or	r17,r3,r2
 200af50:	0021883a 	mov	r16,zero
 200af54:	003fa206 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200af58:	1890b03a 	or	r8,r3,r2
 200af5c:	40017d26 	beq	r8,zero,200b554 <__adddf3+0x7f0>
 200af60:	1011883a 	mov	r8,r2
 200af64:	1823883a 	mov	r17,r3
 200af68:	888001cc 	andi	r2,r17,7
 200af6c:	103f9e1e 	bne	r2,zero,200ade8 <__alt_mem_mem_0+0xfcfeade8>
 200af70:	4004977a 	slli	r2,r8,29
 200af74:	8822d0fa 	srli	r17,r17,3
 200af78:	4010d0fa 	srli	r8,r8,3
 200af7c:	9007883a 	mov	r3,r18
 200af80:	1444b03a 	or	r2,r2,r17
 200af84:	0101ffc4 	movi	r4,2047
 200af88:	81002426 	beq	r16,r4,200b01c <__adddf3+0x2b8>
 200af8c:	8120703a 	and	r16,r16,r4
 200af90:	01000434 	movhi	r4,16
 200af94:	213fffc4 	addi	r4,r4,-1
 200af98:	4110703a 	and	r8,r8,r4
 200af9c:	003fa806 	br	200ae40 <__alt_mem_mem_0+0xfcfeae40>
 200afa0:	8089c83a 	sub	r4,r16,r2
 200afa4:	01005e0e 	bge	zero,r4,200b120 <__adddf3+0x3bc>
 200afa8:	10002b26 	beq	r2,zero,200b058 <__adddf3+0x2f4>
 200afac:	0081ffc4 	movi	r2,2047
 200afb0:	80bf8b26 	beq	r16,r2,200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200afb4:	4a402034 	orhi	r9,r9,128
 200afb8:	00800e04 	movi	r2,56
 200afbc:	1100a40e 	bge	r2,r4,200b250 <__adddf3+0x4ec>
 200afc0:	498cb03a 	or	r6,r9,r6
 200afc4:	300ac03a 	cmpne	r5,r6,zero
 200afc8:	0013883a 	mov	r9,zero
 200afcc:	2c4b883a 	add	r5,r5,r17
 200afd0:	2c63803a 	cmpltu	r17,r5,r17
 200afd4:	4a11883a 	add	r8,r9,r8
 200afd8:	8a11883a 	add	r8,r17,r8
 200afdc:	2823883a 	mov	r17,r5
 200afe0:	4080202c 	andhi	r2,r8,128
 200afe4:	103fe026 	beq	r2,zero,200af68 <__alt_mem_mem_0+0xfcfeaf68>
 200afe8:	84000044 	addi	r16,r16,1
 200afec:	0081ffc4 	movi	r2,2047
 200aff0:	8080d226 	beq	r16,r2,200b33c <__adddf3+0x5d8>
 200aff4:	00bfe034 	movhi	r2,65408
 200aff8:	10bfffc4 	addi	r2,r2,-1
 200affc:	4090703a 	and	r8,r8,r2
 200b000:	880ad07a 	srli	r5,r17,1
 200b004:	400897fa 	slli	r4,r8,31
 200b008:	88c0004c 	andi	r3,r17,1
 200b00c:	28e2b03a 	or	r17,r5,r3
 200b010:	4010d07a 	srli	r8,r8,1
 200b014:	2462b03a 	or	r17,r4,r17
 200b018:	003f7106 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b01c:	4088b03a 	or	r4,r8,r2
 200b020:	20014526 	beq	r4,zero,200b538 <__adddf3+0x7d4>
 200b024:	01000434 	movhi	r4,16
 200b028:	42000234 	orhi	r8,r8,8
 200b02c:	213fffc4 	addi	r4,r4,-1
 200b030:	4110703a 	and	r8,r8,r4
 200b034:	003f8206 	br	200ae40 <__alt_mem_mem_0+0xfcfeae40>
 200b038:	18ffffc4 	addi	r3,r3,-1
 200b03c:	1800491e 	bne	r3,zero,200b164 <__adddf3+0x400>
 200b040:	898bc83a 	sub	r5,r17,r6
 200b044:	8963803a 	cmpltu	r17,r17,r5
 200b048:	4251c83a 	sub	r8,r8,r9
 200b04c:	4451c83a 	sub	r8,r8,r17
 200b050:	2823883a 	mov	r17,r5
 200b054:	003f9f06 	br	200aed4 <__alt_mem_mem_0+0xfcfeaed4>
 200b058:	4984b03a 	or	r2,r9,r6
 200b05c:	103f6026 	beq	r2,zero,200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b060:	213fffc4 	addi	r4,r4,-1
 200b064:	2000931e 	bne	r4,zero,200b2b4 <__adddf3+0x550>
 200b068:	898d883a 	add	r6,r17,r6
 200b06c:	3463803a 	cmpltu	r17,r6,r17
 200b070:	4251883a 	add	r8,r8,r9
 200b074:	8a11883a 	add	r8,r17,r8
 200b078:	3023883a 	mov	r17,r6
 200b07c:	003fd806 	br	200afe0 <__alt_mem_mem_0+0xfcfeafe0>
 200b080:	1800541e 	bne	r3,zero,200b1d4 <__adddf3+0x470>
 200b084:	80800044 	addi	r2,r16,1
 200b088:	1081ffcc 	andi	r2,r2,2047
 200b08c:	00c00044 	movi	r3,1
 200b090:	1880a00e 	bge	r3,r2,200b314 <__adddf3+0x5b0>
 200b094:	8989c83a 	sub	r4,r17,r6
 200b098:	8905803a 	cmpltu	r2,r17,r4
 200b09c:	4267c83a 	sub	r19,r8,r9
 200b0a0:	98a7c83a 	sub	r19,r19,r2
 200b0a4:	9880202c 	andhi	r2,r19,128
 200b0a8:	10006326 	beq	r2,zero,200b238 <__adddf3+0x4d4>
 200b0ac:	3463c83a 	sub	r17,r6,r17
 200b0b0:	4a07c83a 	sub	r3,r9,r8
 200b0b4:	344d803a 	cmpltu	r6,r6,r17
 200b0b8:	19a7c83a 	sub	r19,r3,r6
 200b0bc:	3825883a 	mov	r18,r7
 200b0c0:	983f8a1e 	bne	r19,zero,200aeec <__alt_mem_mem_0+0xfcfeaeec>
 200b0c4:	8809883a 	mov	r4,r17
 200b0c8:	200d3680 	call	200d368 <__clzsi2>
 200b0cc:	10800804 	addi	r2,r2,32
 200b0d0:	10fffe04 	addi	r3,r2,-8
 200b0d4:	010007c4 	movi	r4,31
 200b0d8:	20ff890e 	bge	r4,r3,200af00 <__alt_mem_mem_0+0xfcfeaf00>
 200b0dc:	10bff604 	addi	r2,r2,-40
 200b0e0:	8884983a 	sll	r2,r17,r2
 200b0e4:	0023883a 	mov	r17,zero
 200b0e8:	1c3f8c0e 	bge	r3,r16,200af1c <__alt_mem_mem_0+0xfcfeaf1c>
 200b0ec:	023fe034 	movhi	r8,65408
 200b0f0:	423fffc4 	addi	r8,r8,-1
 200b0f4:	80e1c83a 	sub	r16,r16,r3
 200b0f8:	1210703a 	and	r8,r2,r8
 200b0fc:	003f3806 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b100:	9007883a 	mov	r3,r18
 200b104:	0011883a 	mov	r8,zero
 200b108:	0005883a 	mov	r2,zero
 200b10c:	003f4c06 	br	200ae40 <__alt_mem_mem_0+0xfcfeae40>
 200b110:	498cb03a 	or	r6,r9,r6
 200b114:	300cc03a 	cmpne	r6,r6,zero
 200b118:	0007883a 	mov	r3,zero
 200b11c:	003f6806 	br	200aec0 <__alt_mem_mem_0+0xfcfeaec0>
 200b120:	20009c1e 	bne	r4,zero,200b394 <__adddf3+0x630>
 200b124:	80800044 	addi	r2,r16,1
 200b128:	1141ffcc 	andi	r5,r2,2047
 200b12c:	01000044 	movi	r4,1
 200b130:	2140670e 	bge	r4,r5,200b2d0 <__adddf3+0x56c>
 200b134:	0101ffc4 	movi	r4,2047
 200b138:	11007f26 	beq	r2,r4,200b338 <__adddf3+0x5d4>
 200b13c:	898d883a 	add	r6,r17,r6
 200b140:	4247883a 	add	r3,r8,r9
 200b144:	3451803a 	cmpltu	r8,r6,r17
 200b148:	40d1883a 	add	r8,r8,r3
 200b14c:	402297fa 	slli	r17,r8,31
 200b150:	300cd07a 	srli	r6,r6,1
 200b154:	4010d07a 	srli	r8,r8,1
 200b158:	1021883a 	mov	r16,r2
 200b15c:	89a2b03a 	or	r17,r17,r6
 200b160:	003f1f06 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b164:	0081ffc4 	movi	r2,2047
 200b168:	80bf481e 	bne	r16,r2,200ae8c <__alt_mem_mem_0+0xfcfeae8c>
 200b16c:	003f1c06 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b170:	843ff844 	addi	r16,r16,-31
 200b174:	01000804 	movi	r4,32
 200b178:	1406d83a 	srl	r3,r2,r16
 200b17c:	41005026 	beq	r8,r4,200b2c0 <__adddf3+0x55c>
 200b180:	01001004 	movi	r4,64
 200b184:	2211c83a 	sub	r8,r4,r8
 200b188:	1204983a 	sll	r2,r2,r8
 200b18c:	88a2b03a 	or	r17,r17,r2
 200b190:	8822c03a 	cmpne	r17,r17,zero
 200b194:	1c62b03a 	or	r17,r3,r17
 200b198:	0011883a 	mov	r8,zero
 200b19c:	0021883a 	mov	r16,zero
 200b1a0:	003f7106 	br	200af68 <__alt_mem_mem_0+0xfcfeaf68>
 200b1a4:	193ff804 	addi	r4,r3,-32
 200b1a8:	00800804 	movi	r2,32
 200b1ac:	4908d83a 	srl	r4,r9,r4
 200b1b0:	18804526 	beq	r3,r2,200b2c8 <__adddf3+0x564>
 200b1b4:	00801004 	movi	r2,64
 200b1b8:	10c5c83a 	sub	r2,r2,r3
 200b1bc:	4886983a 	sll	r3,r9,r2
 200b1c0:	198cb03a 	or	r6,r3,r6
 200b1c4:	300cc03a 	cmpne	r6,r6,zero
 200b1c8:	218cb03a 	or	r6,r4,r6
 200b1cc:	0007883a 	mov	r3,zero
 200b1d0:	003f3b06 	br	200aec0 <__alt_mem_mem_0+0xfcfeaec0>
 200b1d4:	80002a26 	beq	r16,zero,200b280 <__adddf3+0x51c>
 200b1d8:	0101ffc4 	movi	r4,2047
 200b1dc:	11006826 	beq	r2,r4,200b380 <__adddf3+0x61c>
 200b1e0:	00c7c83a 	sub	r3,zero,r3
 200b1e4:	42002034 	orhi	r8,r8,128
 200b1e8:	01000e04 	movi	r4,56
 200b1ec:	20c07c16 	blt	r4,r3,200b3e0 <__adddf3+0x67c>
 200b1f0:	010007c4 	movi	r4,31
 200b1f4:	20c0da16 	blt	r4,r3,200b560 <__adddf3+0x7fc>
 200b1f8:	01000804 	movi	r4,32
 200b1fc:	20c9c83a 	sub	r4,r4,r3
 200b200:	4114983a 	sll	r10,r8,r4
 200b204:	88cad83a 	srl	r5,r17,r3
 200b208:	8908983a 	sll	r4,r17,r4
 200b20c:	40c6d83a 	srl	r3,r8,r3
 200b210:	5162b03a 	or	r17,r10,r5
 200b214:	2008c03a 	cmpne	r4,r4,zero
 200b218:	8922b03a 	or	r17,r17,r4
 200b21c:	3463c83a 	sub	r17,r6,r17
 200b220:	48c7c83a 	sub	r3,r9,r3
 200b224:	344d803a 	cmpltu	r6,r6,r17
 200b228:	1991c83a 	sub	r8,r3,r6
 200b22c:	1021883a 	mov	r16,r2
 200b230:	3825883a 	mov	r18,r7
 200b234:	003f2706 	br	200aed4 <__alt_mem_mem_0+0xfcfeaed4>
 200b238:	24d0b03a 	or	r8,r4,r19
 200b23c:	40001b1e 	bne	r8,zero,200b2ac <__adddf3+0x548>
 200b240:	0005883a 	mov	r2,zero
 200b244:	0007883a 	mov	r3,zero
 200b248:	0021883a 	mov	r16,zero
 200b24c:	003f4d06 	br	200af84 <__alt_mem_mem_0+0xfcfeaf84>
 200b250:	008007c4 	movi	r2,31
 200b254:	11003c16 	blt	r2,r4,200b348 <__adddf3+0x5e4>
 200b258:	00800804 	movi	r2,32
 200b25c:	1105c83a 	sub	r2,r2,r4
 200b260:	488e983a 	sll	r7,r9,r2
 200b264:	310ad83a 	srl	r5,r6,r4
 200b268:	3084983a 	sll	r2,r6,r2
 200b26c:	4912d83a 	srl	r9,r9,r4
 200b270:	394ab03a 	or	r5,r7,r5
 200b274:	1004c03a 	cmpne	r2,r2,zero
 200b278:	288ab03a 	or	r5,r5,r2
 200b27c:	003f5306 	br	200afcc <__alt_mem_mem_0+0xfcfeafcc>
 200b280:	4448b03a 	or	r4,r8,r17
 200b284:	20003e26 	beq	r4,zero,200b380 <__adddf3+0x61c>
 200b288:	00c6303a 	nor	r3,zero,r3
 200b28c:	18003a1e 	bne	r3,zero,200b378 <__adddf3+0x614>
 200b290:	3463c83a 	sub	r17,r6,r17
 200b294:	4a07c83a 	sub	r3,r9,r8
 200b298:	344d803a 	cmpltu	r6,r6,r17
 200b29c:	1991c83a 	sub	r8,r3,r6
 200b2a0:	1021883a 	mov	r16,r2
 200b2a4:	3825883a 	mov	r18,r7
 200b2a8:	003f0a06 	br	200aed4 <__alt_mem_mem_0+0xfcfeaed4>
 200b2ac:	2023883a 	mov	r17,r4
 200b2b0:	003f0d06 	br	200aee8 <__alt_mem_mem_0+0xfcfeaee8>
 200b2b4:	0081ffc4 	movi	r2,2047
 200b2b8:	80bf3f1e 	bne	r16,r2,200afb8 <__alt_mem_mem_0+0xfcfeafb8>
 200b2bc:	003ec806 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b2c0:	0005883a 	mov	r2,zero
 200b2c4:	003fb106 	br	200b18c <__alt_mem_mem_0+0xfcfeb18c>
 200b2c8:	0007883a 	mov	r3,zero
 200b2cc:	003fbc06 	br	200b1c0 <__alt_mem_mem_0+0xfcfeb1c0>
 200b2d0:	4444b03a 	or	r2,r8,r17
 200b2d4:	8000871e 	bne	r16,zero,200b4f4 <__adddf3+0x790>
 200b2d8:	1000ba26 	beq	r2,zero,200b5c4 <__adddf3+0x860>
 200b2dc:	4984b03a 	or	r2,r9,r6
 200b2e0:	103ebf26 	beq	r2,zero,200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b2e4:	8985883a 	add	r2,r17,r6
 200b2e8:	4247883a 	add	r3,r8,r9
 200b2ec:	1451803a 	cmpltu	r8,r2,r17
 200b2f0:	40d1883a 	add	r8,r8,r3
 200b2f4:	40c0202c 	andhi	r3,r8,128
 200b2f8:	1023883a 	mov	r17,r2
 200b2fc:	183f1a26 	beq	r3,zero,200af68 <__alt_mem_mem_0+0xfcfeaf68>
 200b300:	00bfe034 	movhi	r2,65408
 200b304:	10bfffc4 	addi	r2,r2,-1
 200b308:	2021883a 	mov	r16,r4
 200b30c:	4090703a 	and	r8,r8,r2
 200b310:	003eb306 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b314:	4444b03a 	or	r2,r8,r17
 200b318:	8000291e 	bne	r16,zero,200b3c0 <__adddf3+0x65c>
 200b31c:	10004b1e 	bne	r2,zero,200b44c <__adddf3+0x6e8>
 200b320:	4990b03a 	or	r8,r9,r6
 200b324:	40008b26 	beq	r8,zero,200b554 <__adddf3+0x7f0>
 200b328:	4811883a 	mov	r8,r9
 200b32c:	3023883a 	mov	r17,r6
 200b330:	3825883a 	mov	r18,r7
 200b334:	003eaa06 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b338:	1021883a 	mov	r16,r2
 200b33c:	0011883a 	mov	r8,zero
 200b340:	0005883a 	mov	r2,zero
 200b344:	003f0f06 	br	200af84 <__alt_mem_mem_0+0xfcfeaf84>
 200b348:	217ff804 	addi	r5,r4,-32
 200b34c:	00800804 	movi	r2,32
 200b350:	494ad83a 	srl	r5,r9,r5
 200b354:	20807d26 	beq	r4,r2,200b54c <__adddf3+0x7e8>
 200b358:	00801004 	movi	r2,64
 200b35c:	1109c83a 	sub	r4,r2,r4
 200b360:	4912983a 	sll	r9,r9,r4
 200b364:	498cb03a 	or	r6,r9,r6
 200b368:	300cc03a 	cmpne	r6,r6,zero
 200b36c:	298ab03a 	or	r5,r5,r6
 200b370:	0013883a 	mov	r9,zero
 200b374:	003f1506 	br	200afcc <__alt_mem_mem_0+0xfcfeafcc>
 200b378:	0101ffc4 	movi	r4,2047
 200b37c:	113f9a1e 	bne	r2,r4,200b1e8 <__alt_mem_mem_0+0xfcfeb1e8>
 200b380:	4811883a 	mov	r8,r9
 200b384:	3023883a 	mov	r17,r6
 200b388:	1021883a 	mov	r16,r2
 200b38c:	3825883a 	mov	r18,r7
 200b390:	003e9306 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b394:	8000161e 	bne	r16,zero,200b3f0 <__adddf3+0x68c>
 200b398:	444ab03a 	or	r5,r8,r17
 200b39c:	28005126 	beq	r5,zero,200b4e4 <__adddf3+0x780>
 200b3a0:	0108303a 	nor	r4,zero,r4
 200b3a4:	20004d1e 	bne	r4,zero,200b4dc <__adddf3+0x778>
 200b3a8:	89a3883a 	add	r17,r17,r6
 200b3ac:	4253883a 	add	r9,r8,r9
 200b3b0:	898d803a 	cmpltu	r6,r17,r6
 200b3b4:	3251883a 	add	r8,r6,r9
 200b3b8:	1021883a 	mov	r16,r2
 200b3bc:	003f0806 	br	200afe0 <__alt_mem_mem_0+0xfcfeafe0>
 200b3c0:	1000301e 	bne	r2,zero,200b484 <__adddf3+0x720>
 200b3c4:	4984b03a 	or	r2,r9,r6
 200b3c8:	10007126 	beq	r2,zero,200b590 <__adddf3+0x82c>
 200b3cc:	4811883a 	mov	r8,r9
 200b3d0:	3023883a 	mov	r17,r6
 200b3d4:	3825883a 	mov	r18,r7
 200b3d8:	0401ffc4 	movi	r16,2047
 200b3dc:	003e8006 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b3e0:	4462b03a 	or	r17,r8,r17
 200b3e4:	8822c03a 	cmpne	r17,r17,zero
 200b3e8:	0007883a 	mov	r3,zero
 200b3ec:	003f8b06 	br	200b21c <__alt_mem_mem_0+0xfcfeb21c>
 200b3f0:	0141ffc4 	movi	r5,2047
 200b3f4:	11403b26 	beq	r2,r5,200b4e4 <__adddf3+0x780>
 200b3f8:	0109c83a 	sub	r4,zero,r4
 200b3fc:	42002034 	orhi	r8,r8,128
 200b400:	01400e04 	movi	r5,56
 200b404:	29006716 	blt	r5,r4,200b5a4 <__adddf3+0x840>
 200b408:	014007c4 	movi	r5,31
 200b40c:	29007016 	blt	r5,r4,200b5d0 <__adddf3+0x86c>
 200b410:	01400804 	movi	r5,32
 200b414:	290bc83a 	sub	r5,r5,r4
 200b418:	4154983a 	sll	r10,r8,r5
 200b41c:	890ed83a 	srl	r7,r17,r4
 200b420:	894a983a 	sll	r5,r17,r5
 200b424:	4108d83a 	srl	r4,r8,r4
 200b428:	51e2b03a 	or	r17,r10,r7
 200b42c:	280ac03a 	cmpne	r5,r5,zero
 200b430:	8962b03a 	or	r17,r17,r5
 200b434:	89a3883a 	add	r17,r17,r6
 200b438:	2253883a 	add	r9,r4,r9
 200b43c:	898d803a 	cmpltu	r6,r17,r6
 200b440:	3251883a 	add	r8,r6,r9
 200b444:	1021883a 	mov	r16,r2
 200b448:	003ee506 	br	200afe0 <__alt_mem_mem_0+0xfcfeafe0>
 200b44c:	4984b03a 	or	r2,r9,r6
 200b450:	103e6326 	beq	r2,zero,200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b454:	8987c83a 	sub	r3,r17,r6
 200b458:	88c9803a 	cmpltu	r4,r17,r3
 200b45c:	4245c83a 	sub	r2,r8,r9
 200b460:	1105c83a 	sub	r2,r2,r4
 200b464:	1100202c 	andhi	r4,r2,128
 200b468:	203ebb26 	beq	r4,zero,200af58 <__alt_mem_mem_0+0xfcfeaf58>
 200b46c:	3463c83a 	sub	r17,r6,r17
 200b470:	4a07c83a 	sub	r3,r9,r8
 200b474:	344d803a 	cmpltu	r6,r6,r17
 200b478:	1991c83a 	sub	r8,r3,r6
 200b47c:	3825883a 	mov	r18,r7
 200b480:	003e5706 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b484:	4984b03a 	or	r2,r9,r6
 200b488:	10002e26 	beq	r2,zero,200b544 <__adddf3+0x7e0>
 200b48c:	4004d0fa 	srli	r2,r8,3
 200b490:	8822d0fa 	srli	r17,r17,3
 200b494:	4010977a 	slli	r8,r8,29
 200b498:	10c0022c 	andhi	r3,r2,8
 200b49c:	4462b03a 	or	r17,r8,r17
 200b4a0:	18000826 	beq	r3,zero,200b4c4 <__adddf3+0x760>
 200b4a4:	4808d0fa 	srli	r4,r9,3
 200b4a8:	20c0022c 	andhi	r3,r4,8
 200b4ac:	1800051e 	bne	r3,zero,200b4c4 <__adddf3+0x760>
 200b4b0:	300cd0fa 	srli	r6,r6,3
 200b4b4:	4806977a 	slli	r3,r9,29
 200b4b8:	2005883a 	mov	r2,r4
 200b4bc:	3825883a 	mov	r18,r7
 200b4c0:	19a2b03a 	or	r17,r3,r6
 200b4c4:	8810d77a 	srli	r8,r17,29
 200b4c8:	100490fa 	slli	r2,r2,3
 200b4cc:	882290fa 	slli	r17,r17,3
 200b4d0:	0401ffc4 	movi	r16,2047
 200b4d4:	4090b03a 	or	r8,r8,r2
 200b4d8:	003e4106 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b4dc:	0141ffc4 	movi	r5,2047
 200b4e0:	117fc71e 	bne	r2,r5,200b400 <__alt_mem_mem_0+0xfcfeb400>
 200b4e4:	4811883a 	mov	r8,r9
 200b4e8:	3023883a 	mov	r17,r6
 200b4ec:	1021883a 	mov	r16,r2
 200b4f0:	003e3b06 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b4f4:	10002f26 	beq	r2,zero,200b5b4 <__adddf3+0x850>
 200b4f8:	4984b03a 	or	r2,r9,r6
 200b4fc:	10001126 	beq	r2,zero,200b544 <__adddf3+0x7e0>
 200b500:	4004d0fa 	srli	r2,r8,3
 200b504:	8822d0fa 	srli	r17,r17,3
 200b508:	4010977a 	slli	r8,r8,29
 200b50c:	10c0022c 	andhi	r3,r2,8
 200b510:	4462b03a 	or	r17,r8,r17
 200b514:	183feb26 	beq	r3,zero,200b4c4 <__alt_mem_mem_0+0xfcfeb4c4>
 200b518:	4808d0fa 	srli	r4,r9,3
 200b51c:	20c0022c 	andhi	r3,r4,8
 200b520:	183fe81e 	bne	r3,zero,200b4c4 <__alt_mem_mem_0+0xfcfeb4c4>
 200b524:	300cd0fa 	srli	r6,r6,3
 200b528:	4806977a 	slli	r3,r9,29
 200b52c:	2005883a 	mov	r2,r4
 200b530:	19a2b03a 	or	r17,r3,r6
 200b534:	003fe306 	br	200b4c4 <__alt_mem_mem_0+0xfcfeb4c4>
 200b538:	0011883a 	mov	r8,zero
 200b53c:	0005883a 	mov	r2,zero
 200b540:	003e3f06 	br	200ae40 <__alt_mem_mem_0+0xfcfeae40>
 200b544:	0401ffc4 	movi	r16,2047
 200b548:	003e2506 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b54c:	0013883a 	mov	r9,zero
 200b550:	003f8406 	br	200b364 <__alt_mem_mem_0+0xfcfeb364>
 200b554:	0005883a 	mov	r2,zero
 200b558:	0007883a 	mov	r3,zero
 200b55c:	003e8906 	br	200af84 <__alt_mem_mem_0+0xfcfeaf84>
 200b560:	197ff804 	addi	r5,r3,-32
 200b564:	01000804 	movi	r4,32
 200b568:	414ad83a 	srl	r5,r8,r5
 200b56c:	19002426 	beq	r3,r4,200b600 <__adddf3+0x89c>
 200b570:	01001004 	movi	r4,64
 200b574:	20c7c83a 	sub	r3,r4,r3
 200b578:	40c6983a 	sll	r3,r8,r3
 200b57c:	1c46b03a 	or	r3,r3,r17
 200b580:	1806c03a 	cmpne	r3,r3,zero
 200b584:	28e2b03a 	or	r17,r5,r3
 200b588:	0007883a 	mov	r3,zero
 200b58c:	003f2306 	br	200b21c <__alt_mem_mem_0+0xfcfeb21c>
 200b590:	0007883a 	mov	r3,zero
 200b594:	5811883a 	mov	r8,r11
 200b598:	00bfffc4 	movi	r2,-1
 200b59c:	0401ffc4 	movi	r16,2047
 200b5a0:	003e7806 	br	200af84 <__alt_mem_mem_0+0xfcfeaf84>
 200b5a4:	4462b03a 	or	r17,r8,r17
 200b5a8:	8822c03a 	cmpne	r17,r17,zero
 200b5ac:	0009883a 	mov	r4,zero
 200b5b0:	003fa006 	br	200b434 <__alt_mem_mem_0+0xfcfeb434>
 200b5b4:	4811883a 	mov	r8,r9
 200b5b8:	3023883a 	mov	r17,r6
 200b5bc:	0401ffc4 	movi	r16,2047
 200b5c0:	003e0706 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b5c4:	4811883a 	mov	r8,r9
 200b5c8:	3023883a 	mov	r17,r6
 200b5cc:	003e0406 	br	200ade0 <__alt_mem_mem_0+0xfcfeade0>
 200b5d0:	21fff804 	addi	r7,r4,-32
 200b5d4:	01400804 	movi	r5,32
 200b5d8:	41ced83a 	srl	r7,r8,r7
 200b5dc:	21400a26 	beq	r4,r5,200b608 <__adddf3+0x8a4>
 200b5e0:	01401004 	movi	r5,64
 200b5e4:	2909c83a 	sub	r4,r5,r4
 200b5e8:	4108983a 	sll	r4,r8,r4
 200b5ec:	2448b03a 	or	r4,r4,r17
 200b5f0:	2008c03a 	cmpne	r4,r4,zero
 200b5f4:	3922b03a 	or	r17,r7,r4
 200b5f8:	0009883a 	mov	r4,zero
 200b5fc:	003f8d06 	br	200b434 <__alt_mem_mem_0+0xfcfeb434>
 200b600:	0007883a 	mov	r3,zero
 200b604:	003fdd06 	br	200b57c <__alt_mem_mem_0+0xfcfeb57c>
 200b608:	0009883a 	mov	r4,zero
 200b60c:	003ff706 	br	200b5ec <__alt_mem_mem_0+0xfcfeb5ec>

0200b610 <__divdf3>:
 200b610:	defff204 	addi	sp,sp,-56
 200b614:	dd400915 	stw	r21,36(sp)
 200b618:	282ad53a 	srli	r21,r5,20
 200b61c:	dd000815 	stw	r20,32(sp)
 200b620:	2828d7fa 	srli	r20,r5,31
 200b624:	dc000415 	stw	r16,16(sp)
 200b628:	04000434 	movhi	r16,16
 200b62c:	df000c15 	stw	fp,48(sp)
 200b630:	843fffc4 	addi	r16,r16,-1
 200b634:	dfc00d15 	stw	ra,52(sp)
 200b638:	ddc00b15 	stw	r23,44(sp)
 200b63c:	dd800a15 	stw	r22,40(sp)
 200b640:	dcc00715 	stw	r19,28(sp)
 200b644:	dc800615 	stw	r18,24(sp)
 200b648:	dc400515 	stw	r17,20(sp)
 200b64c:	ad41ffcc 	andi	r21,r21,2047
 200b650:	2c20703a 	and	r16,r5,r16
 200b654:	a7003fcc 	andi	fp,r20,255
 200b658:	a8006126 	beq	r21,zero,200b7e0 <__divdf3+0x1d0>
 200b65c:	0081ffc4 	movi	r2,2047
 200b660:	2025883a 	mov	r18,r4
 200b664:	a8803726 	beq	r21,r2,200b744 <__divdf3+0x134>
 200b668:	80800434 	orhi	r2,r16,16
 200b66c:	100490fa 	slli	r2,r2,3
 200b670:	2020d77a 	srli	r16,r4,29
 200b674:	202490fa 	slli	r18,r4,3
 200b678:	ad7f0044 	addi	r21,r21,-1023
 200b67c:	80a0b03a 	or	r16,r16,r2
 200b680:	0027883a 	mov	r19,zero
 200b684:	0013883a 	mov	r9,zero
 200b688:	3804d53a 	srli	r2,r7,20
 200b68c:	382cd7fa 	srli	r22,r7,31
 200b690:	04400434 	movhi	r17,16
 200b694:	8c7fffc4 	addi	r17,r17,-1
 200b698:	1081ffcc 	andi	r2,r2,2047
 200b69c:	3011883a 	mov	r8,r6
 200b6a0:	3c62703a 	and	r17,r7,r17
 200b6a4:	b5c03fcc 	andi	r23,r22,255
 200b6a8:	10006c26 	beq	r2,zero,200b85c <__divdf3+0x24c>
 200b6ac:	00c1ffc4 	movi	r3,2047
 200b6b0:	10c06426 	beq	r2,r3,200b844 <__divdf3+0x234>
 200b6b4:	88c00434 	orhi	r3,r17,16
 200b6b8:	180690fa 	slli	r3,r3,3
 200b6bc:	3022d77a 	srli	r17,r6,29
 200b6c0:	301090fa 	slli	r8,r6,3
 200b6c4:	10bf0044 	addi	r2,r2,-1023
 200b6c8:	88e2b03a 	or	r17,r17,r3
 200b6cc:	000f883a 	mov	r7,zero
 200b6d0:	a58cf03a 	xor	r6,r20,r22
 200b6d4:	3cc8b03a 	or	r4,r7,r19
 200b6d8:	a8abc83a 	sub	r21,r21,r2
 200b6dc:	008003c4 	movi	r2,15
 200b6e0:	3007883a 	mov	r3,r6
 200b6e4:	34c03fcc 	andi	r19,r6,255
 200b6e8:	11009036 	bltu	r2,r4,200b92c <__divdf3+0x31c>
 200b6ec:	200890ba 	slli	r4,r4,2
 200b6f0:	00808074 	movhi	r2,513
 200b6f4:	10adc104 	addi	r2,r2,-18684
 200b6f8:	2089883a 	add	r4,r4,r2
 200b6fc:	20800017 	ldw	r2,0(r4)
 200b700:	1000683a 	jmp	r2
 200b704:	0200b92c 	andhi	r8,zero,740
 200b708:	0200b77c 	xorhi	r8,zero,733
 200b70c:	0200b91c 	xori	r8,zero,740
 200b710:	0200b770 	cmpltui	r8,zero,733
 200b714:	0200b91c 	xori	r8,zero,740
 200b718:	0200b8f0 	cmpltui	r8,zero,739
 200b71c:	0200b91c 	xori	r8,zero,740
 200b720:	0200b770 	cmpltui	r8,zero,733
 200b724:	0200b77c 	xorhi	r8,zero,733
 200b728:	0200b77c 	xorhi	r8,zero,733
 200b72c:	0200b8f0 	cmpltui	r8,zero,739
 200b730:	0200b770 	cmpltui	r8,zero,733
 200b734:	0200b760 	cmpeqi	r8,zero,733
 200b738:	0200b760 	cmpeqi	r8,zero,733
 200b73c:	0200b760 	cmpeqi	r8,zero,733
 200b740:	0200bc10 	cmplti	r8,zero,752
 200b744:	2404b03a 	or	r2,r4,r16
 200b748:	1000661e 	bne	r2,zero,200b8e4 <__divdf3+0x2d4>
 200b74c:	04c00204 	movi	r19,8
 200b750:	0021883a 	mov	r16,zero
 200b754:	0025883a 	mov	r18,zero
 200b758:	02400084 	movi	r9,2
 200b75c:	003fca06 	br	200b688 <__alt_mem_mem_0+0xfcfeb688>
 200b760:	8023883a 	mov	r17,r16
 200b764:	9011883a 	mov	r8,r18
 200b768:	e02f883a 	mov	r23,fp
 200b76c:	480f883a 	mov	r7,r9
 200b770:	00800084 	movi	r2,2
 200b774:	3881311e 	bne	r7,r2,200bc3c <__divdf3+0x62c>
 200b778:	b827883a 	mov	r19,r23
 200b77c:	98c0004c 	andi	r3,r19,1
 200b780:	0081ffc4 	movi	r2,2047
 200b784:	000b883a 	mov	r5,zero
 200b788:	0025883a 	mov	r18,zero
 200b78c:	1004953a 	slli	r2,r2,20
 200b790:	18c03fcc 	andi	r3,r3,255
 200b794:	04400434 	movhi	r17,16
 200b798:	8c7fffc4 	addi	r17,r17,-1
 200b79c:	180697fa 	slli	r3,r3,31
 200b7a0:	2c4a703a 	and	r5,r5,r17
 200b7a4:	288ab03a 	or	r5,r5,r2
 200b7a8:	28c6b03a 	or	r3,r5,r3
 200b7ac:	9005883a 	mov	r2,r18
 200b7b0:	dfc00d17 	ldw	ra,52(sp)
 200b7b4:	df000c17 	ldw	fp,48(sp)
 200b7b8:	ddc00b17 	ldw	r23,44(sp)
 200b7bc:	dd800a17 	ldw	r22,40(sp)
 200b7c0:	dd400917 	ldw	r21,36(sp)
 200b7c4:	dd000817 	ldw	r20,32(sp)
 200b7c8:	dcc00717 	ldw	r19,28(sp)
 200b7cc:	dc800617 	ldw	r18,24(sp)
 200b7d0:	dc400517 	ldw	r17,20(sp)
 200b7d4:	dc000417 	ldw	r16,16(sp)
 200b7d8:	dec00e04 	addi	sp,sp,56
 200b7dc:	f800283a 	ret
 200b7e0:	2404b03a 	or	r2,r4,r16
 200b7e4:	2027883a 	mov	r19,r4
 200b7e8:	10003926 	beq	r2,zero,200b8d0 <__divdf3+0x2c0>
 200b7ec:	80012e26 	beq	r16,zero,200bca8 <__divdf3+0x698>
 200b7f0:	8009883a 	mov	r4,r16
 200b7f4:	d9800315 	stw	r6,12(sp)
 200b7f8:	d9c00215 	stw	r7,8(sp)
 200b7fc:	200d3680 	call	200d368 <__clzsi2>
 200b800:	d9800317 	ldw	r6,12(sp)
 200b804:	d9c00217 	ldw	r7,8(sp)
 200b808:	113ffd44 	addi	r4,r2,-11
 200b80c:	00c00704 	movi	r3,28
 200b810:	19012116 	blt	r3,r4,200bc98 <__divdf3+0x688>
 200b814:	00c00744 	movi	r3,29
 200b818:	147ffe04 	addi	r17,r2,-8
 200b81c:	1907c83a 	sub	r3,r3,r4
 200b820:	8460983a 	sll	r16,r16,r17
 200b824:	98c6d83a 	srl	r3,r19,r3
 200b828:	9c64983a 	sll	r18,r19,r17
 200b82c:	1c20b03a 	or	r16,r3,r16
 200b830:	1080fcc4 	addi	r2,r2,1011
 200b834:	00abc83a 	sub	r21,zero,r2
 200b838:	0027883a 	mov	r19,zero
 200b83c:	0013883a 	mov	r9,zero
 200b840:	003f9106 	br	200b688 <__alt_mem_mem_0+0xfcfeb688>
 200b844:	3446b03a 	or	r3,r6,r17
 200b848:	18001f1e 	bne	r3,zero,200b8c8 <__divdf3+0x2b8>
 200b84c:	0023883a 	mov	r17,zero
 200b850:	0011883a 	mov	r8,zero
 200b854:	01c00084 	movi	r7,2
 200b858:	003f9d06 	br	200b6d0 <__alt_mem_mem_0+0xfcfeb6d0>
 200b85c:	3446b03a 	or	r3,r6,r17
 200b860:	18001526 	beq	r3,zero,200b8b8 <__divdf3+0x2a8>
 200b864:	88011b26 	beq	r17,zero,200bcd4 <__divdf3+0x6c4>
 200b868:	8809883a 	mov	r4,r17
 200b86c:	d9800315 	stw	r6,12(sp)
 200b870:	da400115 	stw	r9,4(sp)
 200b874:	200d3680 	call	200d368 <__clzsi2>
 200b878:	d9800317 	ldw	r6,12(sp)
 200b87c:	da400117 	ldw	r9,4(sp)
 200b880:	113ffd44 	addi	r4,r2,-11
 200b884:	00c00704 	movi	r3,28
 200b888:	19010e16 	blt	r3,r4,200bcc4 <__divdf3+0x6b4>
 200b88c:	00c00744 	movi	r3,29
 200b890:	123ffe04 	addi	r8,r2,-8
 200b894:	1907c83a 	sub	r3,r3,r4
 200b898:	8a22983a 	sll	r17,r17,r8
 200b89c:	30c6d83a 	srl	r3,r6,r3
 200b8a0:	3210983a 	sll	r8,r6,r8
 200b8a4:	1c62b03a 	or	r17,r3,r17
 200b8a8:	1080fcc4 	addi	r2,r2,1011
 200b8ac:	0085c83a 	sub	r2,zero,r2
 200b8b0:	000f883a 	mov	r7,zero
 200b8b4:	003f8606 	br	200b6d0 <__alt_mem_mem_0+0xfcfeb6d0>
 200b8b8:	0023883a 	mov	r17,zero
 200b8bc:	0011883a 	mov	r8,zero
 200b8c0:	01c00044 	movi	r7,1
 200b8c4:	003f8206 	br	200b6d0 <__alt_mem_mem_0+0xfcfeb6d0>
 200b8c8:	01c000c4 	movi	r7,3
 200b8cc:	003f8006 	br	200b6d0 <__alt_mem_mem_0+0xfcfeb6d0>
 200b8d0:	04c00104 	movi	r19,4
 200b8d4:	0021883a 	mov	r16,zero
 200b8d8:	0025883a 	mov	r18,zero
 200b8dc:	02400044 	movi	r9,1
 200b8e0:	003f6906 	br	200b688 <__alt_mem_mem_0+0xfcfeb688>
 200b8e4:	04c00304 	movi	r19,12
 200b8e8:	024000c4 	movi	r9,3
 200b8ec:	003f6606 	br	200b688 <__alt_mem_mem_0+0xfcfeb688>
 200b8f0:	01400434 	movhi	r5,16
 200b8f4:	0007883a 	mov	r3,zero
 200b8f8:	297fffc4 	addi	r5,r5,-1
 200b8fc:	04bfffc4 	movi	r18,-1
 200b900:	0081ffc4 	movi	r2,2047
 200b904:	003fa106 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200b908:	00c00044 	movi	r3,1
 200b90c:	1887c83a 	sub	r3,r3,r2
 200b910:	01000e04 	movi	r4,56
 200b914:	20c1210e 	bge	r4,r3,200bd9c <__divdf3+0x78c>
 200b918:	98c0004c 	andi	r3,r19,1
 200b91c:	0005883a 	mov	r2,zero
 200b920:	000b883a 	mov	r5,zero
 200b924:	0025883a 	mov	r18,zero
 200b928:	003f9806 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200b92c:	8c00fd36 	bltu	r17,r16,200bd24 <__divdf3+0x714>
 200b930:	8440fb26 	beq	r16,r17,200bd20 <__divdf3+0x710>
 200b934:	8007883a 	mov	r3,r16
 200b938:	ad7fffc4 	addi	r21,r21,-1
 200b93c:	0021883a 	mov	r16,zero
 200b940:	4004d63a 	srli	r2,r8,24
 200b944:	8822923a 	slli	r17,r17,8
 200b948:	1809883a 	mov	r4,r3
 200b94c:	402c923a 	slli	r22,r8,8
 200b950:	88b8b03a 	or	fp,r17,r2
 200b954:	e028d43a 	srli	r20,fp,16
 200b958:	d8c00015 	stw	r3,0(sp)
 200b95c:	e5ffffcc 	andi	r23,fp,65535
 200b960:	a00b883a 	mov	r5,r20
 200b964:	200aca80 	call	200aca8 <__udivsi3>
 200b968:	d8c00017 	ldw	r3,0(sp)
 200b96c:	a00b883a 	mov	r5,r20
 200b970:	d8800315 	stw	r2,12(sp)
 200b974:	1809883a 	mov	r4,r3
 200b978:	200ad0c0 	call	200ad0c <__umodsi3>
 200b97c:	d9800317 	ldw	r6,12(sp)
 200b980:	1006943a 	slli	r3,r2,16
 200b984:	9004d43a 	srli	r2,r18,16
 200b988:	b9a3383a 	mul	r17,r23,r6
 200b98c:	10c4b03a 	or	r2,r2,r3
 200b990:	1440062e 	bgeu	r2,r17,200b9ac <__divdf3+0x39c>
 200b994:	1705883a 	add	r2,r2,fp
 200b998:	30ffffc4 	addi	r3,r6,-1
 200b99c:	1700ee36 	bltu	r2,fp,200bd58 <__divdf3+0x748>
 200b9a0:	1440ed2e 	bgeu	r2,r17,200bd58 <__divdf3+0x748>
 200b9a4:	31bfff84 	addi	r6,r6,-2
 200b9a8:	1705883a 	add	r2,r2,fp
 200b9ac:	1463c83a 	sub	r17,r2,r17
 200b9b0:	a00b883a 	mov	r5,r20
 200b9b4:	8809883a 	mov	r4,r17
 200b9b8:	d9800315 	stw	r6,12(sp)
 200b9bc:	200aca80 	call	200aca8 <__udivsi3>
 200b9c0:	a00b883a 	mov	r5,r20
 200b9c4:	8809883a 	mov	r4,r17
 200b9c8:	d8800215 	stw	r2,8(sp)
 200b9cc:	200ad0c0 	call	200ad0c <__umodsi3>
 200b9d0:	d9c00217 	ldw	r7,8(sp)
 200b9d4:	1004943a 	slli	r2,r2,16
 200b9d8:	94bfffcc 	andi	r18,r18,65535
 200b9dc:	b9d1383a 	mul	r8,r23,r7
 200b9e0:	90a4b03a 	or	r18,r18,r2
 200b9e4:	d9800317 	ldw	r6,12(sp)
 200b9e8:	9200062e 	bgeu	r18,r8,200ba04 <__divdf3+0x3f4>
 200b9ec:	9725883a 	add	r18,r18,fp
 200b9f0:	38bfffc4 	addi	r2,r7,-1
 200b9f4:	9700d636 	bltu	r18,fp,200bd50 <__divdf3+0x740>
 200b9f8:	9200d52e 	bgeu	r18,r8,200bd50 <__divdf3+0x740>
 200b9fc:	39ffff84 	addi	r7,r7,-2
 200ba00:	9725883a 	add	r18,r18,fp
 200ba04:	3004943a 	slli	r2,r6,16
 200ba08:	b012d43a 	srli	r9,r22,16
 200ba0c:	b1bfffcc 	andi	r6,r22,65535
 200ba10:	11e2b03a 	or	r17,r2,r7
 200ba14:	8806d43a 	srli	r3,r17,16
 200ba18:	893fffcc 	andi	r4,r17,65535
 200ba1c:	218b383a 	mul	r5,r4,r6
 200ba20:	30c5383a 	mul	r2,r6,r3
 200ba24:	2249383a 	mul	r4,r4,r9
 200ba28:	280ed43a 	srli	r7,r5,16
 200ba2c:	9225c83a 	sub	r18,r18,r8
 200ba30:	2089883a 	add	r4,r4,r2
 200ba34:	3909883a 	add	r4,r7,r4
 200ba38:	1a47383a 	mul	r3,r3,r9
 200ba3c:	2080022e 	bgeu	r4,r2,200ba48 <__divdf3+0x438>
 200ba40:	00800074 	movhi	r2,1
 200ba44:	1887883a 	add	r3,r3,r2
 200ba48:	2004d43a 	srli	r2,r4,16
 200ba4c:	2008943a 	slli	r4,r4,16
 200ba50:	297fffcc 	andi	r5,r5,65535
 200ba54:	10c7883a 	add	r3,r2,r3
 200ba58:	2149883a 	add	r4,r4,r5
 200ba5c:	90c0a536 	bltu	r18,r3,200bcf4 <__divdf3+0x6e4>
 200ba60:	90c0bf26 	beq	r18,r3,200bd60 <__divdf3+0x750>
 200ba64:	90c7c83a 	sub	r3,r18,r3
 200ba68:	810fc83a 	sub	r7,r16,r4
 200ba6c:	81e5803a 	cmpltu	r18,r16,r7
 200ba70:	1ca5c83a 	sub	r18,r3,r18
 200ba74:	e480c126 	beq	fp,r18,200bd7c <__divdf3+0x76c>
 200ba78:	a00b883a 	mov	r5,r20
 200ba7c:	9009883a 	mov	r4,r18
 200ba80:	d9800315 	stw	r6,12(sp)
 200ba84:	d9c00215 	stw	r7,8(sp)
 200ba88:	da400115 	stw	r9,4(sp)
 200ba8c:	200aca80 	call	200aca8 <__udivsi3>
 200ba90:	a00b883a 	mov	r5,r20
 200ba94:	9009883a 	mov	r4,r18
 200ba98:	d8800015 	stw	r2,0(sp)
 200ba9c:	200ad0c0 	call	200ad0c <__umodsi3>
 200baa0:	d9c00217 	ldw	r7,8(sp)
 200baa4:	da000017 	ldw	r8,0(sp)
 200baa8:	1006943a 	slli	r3,r2,16
 200baac:	3804d43a 	srli	r2,r7,16
 200bab0:	ba21383a 	mul	r16,r23,r8
 200bab4:	d9800317 	ldw	r6,12(sp)
 200bab8:	10c4b03a 	or	r2,r2,r3
 200babc:	da400117 	ldw	r9,4(sp)
 200bac0:	1400062e 	bgeu	r2,r16,200badc <__divdf3+0x4cc>
 200bac4:	1705883a 	add	r2,r2,fp
 200bac8:	40ffffc4 	addi	r3,r8,-1
 200bacc:	1700ad36 	bltu	r2,fp,200bd84 <__divdf3+0x774>
 200bad0:	1400ac2e 	bgeu	r2,r16,200bd84 <__divdf3+0x774>
 200bad4:	423fff84 	addi	r8,r8,-2
 200bad8:	1705883a 	add	r2,r2,fp
 200badc:	1421c83a 	sub	r16,r2,r16
 200bae0:	a00b883a 	mov	r5,r20
 200bae4:	8009883a 	mov	r4,r16
 200bae8:	d9800315 	stw	r6,12(sp)
 200baec:	d9c00215 	stw	r7,8(sp)
 200baf0:	da000015 	stw	r8,0(sp)
 200baf4:	da400115 	stw	r9,4(sp)
 200baf8:	200aca80 	call	200aca8 <__udivsi3>
 200bafc:	8009883a 	mov	r4,r16
 200bb00:	a00b883a 	mov	r5,r20
 200bb04:	1025883a 	mov	r18,r2
 200bb08:	200ad0c0 	call	200ad0c <__umodsi3>
 200bb0c:	d9c00217 	ldw	r7,8(sp)
 200bb10:	1004943a 	slli	r2,r2,16
 200bb14:	bcaf383a 	mul	r23,r23,r18
 200bb18:	393fffcc 	andi	r4,r7,65535
 200bb1c:	2088b03a 	or	r4,r4,r2
 200bb20:	d9800317 	ldw	r6,12(sp)
 200bb24:	da000017 	ldw	r8,0(sp)
 200bb28:	da400117 	ldw	r9,4(sp)
 200bb2c:	25c0062e 	bgeu	r4,r23,200bb48 <__divdf3+0x538>
 200bb30:	2709883a 	add	r4,r4,fp
 200bb34:	90bfffc4 	addi	r2,r18,-1
 200bb38:	27009436 	bltu	r4,fp,200bd8c <__divdf3+0x77c>
 200bb3c:	25c0932e 	bgeu	r4,r23,200bd8c <__divdf3+0x77c>
 200bb40:	94bfff84 	addi	r18,r18,-2
 200bb44:	2709883a 	add	r4,r4,fp
 200bb48:	4004943a 	slli	r2,r8,16
 200bb4c:	25efc83a 	sub	r23,r4,r23
 200bb50:	1490b03a 	or	r8,r2,r18
 200bb54:	4008d43a 	srli	r4,r8,16
 200bb58:	40ffffcc 	andi	r3,r8,65535
 200bb5c:	30c5383a 	mul	r2,r6,r3
 200bb60:	1a47383a 	mul	r3,r3,r9
 200bb64:	310d383a 	mul	r6,r6,r4
 200bb68:	100ad43a 	srli	r5,r2,16
 200bb6c:	4913383a 	mul	r9,r9,r4
 200bb70:	1987883a 	add	r3,r3,r6
 200bb74:	28c7883a 	add	r3,r5,r3
 200bb78:	1980022e 	bgeu	r3,r6,200bb84 <__divdf3+0x574>
 200bb7c:	01000074 	movhi	r4,1
 200bb80:	4913883a 	add	r9,r9,r4
 200bb84:	1808d43a 	srli	r4,r3,16
 200bb88:	1806943a 	slli	r3,r3,16
 200bb8c:	10bfffcc 	andi	r2,r2,65535
 200bb90:	2253883a 	add	r9,r4,r9
 200bb94:	1887883a 	add	r3,r3,r2
 200bb98:	ba403836 	bltu	r23,r9,200bc7c <__divdf3+0x66c>
 200bb9c:	ba403626 	beq	r23,r9,200bc78 <__divdf3+0x668>
 200bba0:	42000054 	ori	r8,r8,1
 200bba4:	a880ffc4 	addi	r2,r21,1023
 200bba8:	00bf570e 	bge	zero,r2,200b908 <__alt_mem_mem_0+0xfcfeb908>
 200bbac:	40c001cc 	andi	r3,r8,7
 200bbb0:	18000726 	beq	r3,zero,200bbd0 <__divdf3+0x5c0>
 200bbb4:	40c003cc 	andi	r3,r8,15
 200bbb8:	01000104 	movi	r4,4
 200bbbc:	19000426 	beq	r3,r4,200bbd0 <__divdf3+0x5c0>
 200bbc0:	4107883a 	add	r3,r8,r4
 200bbc4:	1a11803a 	cmpltu	r8,r3,r8
 200bbc8:	8a23883a 	add	r17,r17,r8
 200bbcc:	1811883a 	mov	r8,r3
 200bbd0:	88c0402c 	andhi	r3,r17,256
 200bbd4:	18000426 	beq	r3,zero,200bbe8 <__divdf3+0x5d8>
 200bbd8:	00ffc034 	movhi	r3,65280
 200bbdc:	18ffffc4 	addi	r3,r3,-1
 200bbe0:	a8810004 	addi	r2,r21,1024
 200bbe4:	88e2703a 	and	r17,r17,r3
 200bbe8:	00c1ff84 	movi	r3,2046
 200bbec:	18bee316 	blt	r3,r2,200b77c <__alt_mem_mem_0+0xfcfeb77c>
 200bbf0:	8824977a 	slli	r18,r17,29
 200bbf4:	4010d0fa 	srli	r8,r8,3
 200bbf8:	8822927a 	slli	r17,r17,9
 200bbfc:	1081ffcc 	andi	r2,r2,2047
 200bc00:	9224b03a 	or	r18,r18,r8
 200bc04:	880ad33a 	srli	r5,r17,12
 200bc08:	98c0004c 	andi	r3,r19,1
 200bc0c:	003edf06 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200bc10:	8080022c 	andhi	r2,r16,8
 200bc14:	10001226 	beq	r2,zero,200bc60 <__divdf3+0x650>
 200bc18:	8880022c 	andhi	r2,r17,8
 200bc1c:	1000101e 	bne	r2,zero,200bc60 <__divdf3+0x650>
 200bc20:	00800434 	movhi	r2,16
 200bc24:	89400234 	orhi	r5,r17,8
 200bc28:	10bfffc4 	addi	r2,r2,-1
 200bc2c:	b007883a 	mov	r3,r22
 200bc30:	288a703a 	and	r5,r5,r2
 200bc34:	4025883a 	mov	r18,r8
 200bc38:	003f3106 	br	200b900 <__alt_mem_mem_0+0xfcfeb900>
 200bc3c:	008000c4 	movi	r2,3
 200bc40:	3880a626 	beq	r7,r2,200bedc <__divdf3+0x8cc>
 200bc44:	00800044 	movi	r2,1
 200bc48:	3880521e 	bne	r7,r2,200bd94 <__divdf3+0x784>
 200bc4c:	b807883a 	mov	r3,r23
 200bc50:	0005883a 	mov	r2,zero
 200bc54:	000b883a 	mov	r5,zero
 200bc58:	0025883a 	mov	r18,zero
 200bc5c:	003ecb06 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200bc60:	00800434 	movhi	r2,16
 200bc64:	81400234 	orhi	r5,r16,8
 200bc68:	10bfffc4 	addi	r2,r2,-1
 200bc6c:	a007883a 	mov	r3,r20
 200bc70:	288a703a 	and	r5,r5,r2
 200bc74:	003f2206 	br	200b900 <__alt_mem_mem_0+0xfcfeb900>
 200bc78:	183fca26 	beq	r3,zero,200bba4 <__alt_mem_mem_0+0xfcfebba4>
 200bc7c:	e5ef883a 	add	r23,fp,r23
 200bc80:	40bfffc4 	addi	r2,r8,-1
 200bc84:	bf00392e 	bgeu	r23,fp,200bd6c <__divdf3+0x75c>
 200bc88:	1011883a 	mov	r8,r2
 200bc8c:	ba7fc41e 	bne	r23,r9,200bba0 <__alt_mem_mem_0+0xfcfebba0>
 200bc90:	b0ffc31e 	bne	r22,r3,200bba0 <__alt_mem_mem_0+0xfcfebba0>
 200bc94:	003fc306 	br	200bba4 <__alt_mem_mem_0+0xfcfebba4>
 200bc98:	143ff604 	addi	r16,r2,-40
 200bc9c:	9c20983a 	sll	r16,r19,r16
 200bca0:	0025883a 	mov	r18,zero
 200bca4:	003ee206 	br	200b830 <__alt_mem_mem_0+0xfcfeb830>
 200bca8:	d9800315 	stw	r6,12(sp)
 200bcac:	d9c00215 	stw	r7,8(sp)
 200bcb0:	200d3680 	call	200d368 <__clzsi2>
 200bcb4:	10800804 	addi	r2,r2,32
 200bcb8:	d9c00217 	ldw	r7,8(sp)
 200bcbc:	d9800317 	ldw	r6,12(sp)
 200bcc0:	003ed106 	br	200b808 <__alt_mem_mem_0+0xfcfeb808>
 200bcc4:	147ff604 	addi	r17,r2,-40
 200bcc8:	3462983a 	sll	r17,r6,r17
 200bccc:	0011883a 	mov	r8,zero
 200bcd0:	003ef506 	br	200b8a8 <__alt_mem_mem_0+0xfcfeb8a8>
 200bcd4:	3009883a 	mov	r4,r6
 200bcd8:	d9800315 	stw	r6,12(sp)
 200bcdc:	da400115 	stw	r9,4(sp)
 200bce0:	200d3680 	call	200d368 <__clzsi2>
 200bce4:	10800804 	addi	r2,r2,32
 200bce8:	da400117 	ldw	r9,4(sp)
 200bcec:	d9800317 	ldw	r6,12(sp)
 200bcf0:	003ee306 	br	200b880 <__alt_mem_mem_0+0xfcfeb880>
 200bcf4:	85a1883a 	add	r16,r16,r22
 200bcf8:	8585803a 	cmpltu	r2,r16,r22
 200bcfc:	1705883a 	add	r2,r2,fp
 200bd00:	14a5883a 	add	r18,r2,r18
 200bd04:	88bfffc4 	addi	r2,r17,-1
 200bd08:	e4800c2e 	bgeu	fp,r18,200bd3c <__divdf3+0x72c>
 200bd0c:	90c03e36 	bltu	r18,r3,200be08 <__divdf3+0x7f8>
 200bd10:	1c806926 	beq	r3,r18,200beb8 <__divdf3+0x8a8>
 200bd14:	90c7c83a 	sub	r3,r18,r3
 200bd18:	1023883a 	mov	r17,r2
 200bd1c:	003f5206 	br	200ba68 <__alt_mem_mem_0+0xfcfeba68>
 200bd20:	923f0436 	bltu	r18,r8,200b934 <__alt_mem_mem_0+0xfcfeb934>
 200bd24:	800897fa 	slli	r4,r16,31
 200bd28:	9004d07a 	srli	r2,r18,1
 200bd2c:	8006d07a 	srli	r3,r16,1
 200bd30:	902097fa 	slli	r16,r18,31
 200bd34:	20a4b03a 	or	r18,r4,r2
 200bd38:	003f0106 	br	200b940 <__alt_mem_mem_0+0xfcfeb940>
 200bd3c:	e4bff51e 	bne	fp,r18,200bd14 <__alt_mem_mem_0+0xfcfebd14>
 200bd40:	85bff22e 	bgeu	r16,r22,200bd0c <__alt_mem_mem_0+0xfcfebd0c>
 200bd44:	e0c7c83a 	sub	r3,fp,r3
 200bd48:	1023883a 	mov	r17,r2
 200bd4c:	003f4606 	br	200ba68 <__alt_mem_mem_0+0xfcfeba68>
 200bd50:	100f883a 	mov	r7,r2
 200bd54:	003f2b06 	br	200ba04 <__alt_mem_mem_0+0xfcfeba04>
 200bd58:	180d883a 	mov	r6,r3
 200bd5c:	003f1306 	br	200b9ac <__alt_mem_mem_0+0xfcfeb9ac>
 200bd60:	813fe436 	bltu	r16,r4,200bcf4 <__alt_mem_mem_0+0xfcfebcf4>
 200bd64:	0007883a 	mov	r3,zero
 200bd68:	003f3f06 	br	200ba68 <__alt_mem_mem_0+0xfcfeba68>
 200bd6c:	ba402c36 	bltu	r23,r9,200be20 <__divdf3+0x810>
 200bd70:	4dc05426 	beq	r9,r23,200bec4 <__divdf3+0x8b4>
 200bd74:	1011883a 	mov	r8,r2
 200bd78:	003f8906 	br	200bba0 <__alt_mem_mem_0+0xfcfebba0>
 200bd7c:	023fffc4 	movi	r8,-1
 200bd80:	003f8806 	br	200bba4 <__alt_mem_mem_0+0xfcfebba4>
 200bd84:	1811883a 	mov	r8,r3
 200bd88:	003f5406 	br	200badc <__alt_mem_mem_0+0xfcfebadc>
 200bd8c:	1025883a 	mov	r18,r2
 200bd90:	003f6d06 	br	200bb48 <__alt_mem_mem_0+0xfcfebb48>
 200bd94:	b827883a 	mov	r19,r23
 200bd98:	003f8206 	br	200bba4 <__alt_mem_mem_0+0xfcfebba4>
 200bd9c:	010007c4 	movi	r4,31
 200bda0:	20c02616 	blt	r4,r3,200be3c <__divdf3+0x82c>
 200bda4:	00800804 	movi	r2,32
 200bda8:	10c5c83a 	sub	r2,r2,r3
 200bdac:	888a983a 	sll	r5,r17,r2
 200bdb0:	40c8d83a 	srl	r4,r8,r3
 200bdb4:	4084983a 	sll	r2,r8,r2
 200bdb8:	88e2d83a 	srl	r17,r17,r3
 200bdbc:	2906b03a 	or	r3,r5,r4
 200bdc0:	1004c03a 	cmpne	r2,r2,zero
 200bdc4:	1886b03a 	or	r3,r3,r2
 200bdc8:	188001cc 	andi	r2,r3,7
 200bdcc:	10000726 	beq	r2,zero,200bdec <__divdf3+0x7dc>
 200bdd0:	188003cc 	andi	r2,r3,15
 200bdd4:	01000104 	movi	r4,4
 200bdd8:	11000426 	beq	r2,r4,200bdec <__divdf3+0x7dc>
 200bddc:	1805883a 	mov	r2,r3
 200bde0:	10c00104 	addi	r3,r2,4
 200bde4:	1885803a 	cmpltu	r2,r3,r2
 200bde8:	88a3883a 	add	r17,r17,r2
 200bdec:	8880202c 	andhi	r2,r17,128
 200bdf0:	10002726 	beq	r2,zero,200be90 <__divdf3+0x880>
 200bdf4:	98c0004c 	andi	r3,r19,1
 200bdf8:	00800044 	movi	r2,1
 200bdfc:	000b883a 	mov	r5,zero
 200be00:	0025883a 	mov	r18,zero
 200be04:	003e6106 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200be08:	85a1883a 	add	r16,r16,r22
 200be0c:	8585803a 	cmpltu	r2,r16,r22
 200be10:	1705883a 	add	r2,r2,fp
 200be14:	14a5883a 	add	r18,r2,r18
 200be18:	8c7fff84 	addi	r17,r17,-2
 200be1c:	003f1106 	br	200ba64 <__alt_mem_mem_0+0xfcfeba64>
 200be20:	b589883a 	add	r4,r22,r22
 200be24:	25ad803a 	cmpltu	r22,r4,r22
 200be28:	b739883a 	add	fp,r22,fp
 200be2c:	40bfff84 	addi	r2,r8,-2
 200be30:	bf2f883a 	add	r23,r23,fp
 200be34:	202d883a 	mov	r22,r4
 200be38:	003f9306 	br	200bc88 <__alt_mem_mem_0+0xfcfebc88>
 200be3c:	013ff844 	movi	r4,-31
 200be40:	2085c83a 	sub	r2,r4,r2
 200be44:	8888d83a 	srl	r4,r17,r2
 200be48:	00800804 	movi	r2,32
 200be4c:	18802126 	beq	r3,r2,200bed4 <__divdf3+0x8c4>
 200be50:	00801004 	movi	r2,64
 200be54:	10c5c83a 	sub	r2,r2,r3
 200be58:	8884983a 	sll	r2,r17,r2
 200be5c:	1204b03a 	or	r2,r2,r8
 200be60:	1004c03a 	cmpne	r2,r2,zero
 200be64:	2084b03a 	or	r2,r4,r2
 200be68:	144001cc 	andi	r17,r2,7
 200be6c:	88000d1e 	bne	r17,zero,200bea4 <__divdf3+0x894>
 200be70:	000b883a 	mov	r5,zero
 200be74:	1024d0fa 	srli	r18,r2,3
 200be78:	98c0004c 	andi	r3,r19,1
 200be7c:	0005883a 	mov	r2,zero
 200be80:	9464b03a 	or	r18,r18,r17
 200be84:	003e4106 	br	200b78c <__alt_mem_mem_0+0xfcfeb78c>
 200be88:	1007883a 	mov	r3,r2
 200be8c:	0023883a 	mov	r17,zero
 200be90:	880a927a 	slli	r5,r17,9
 200be94:	1805883a 	mov	r2,r3
 200be98:	8822977a 	slli	r17,r17,29
 200be9c:	280ad33a 	srli	r5,r5,12
 200bea0:	003ff406 	br	200be74 <__alt_mem_mem_0+0xfcfebe74>
 200bea4:	10c003cc 	andi	r3,r2,15
 200bea8:	01000104 	movi	r4,4
 200beac:	193ff626 	beq	r3,r4,200be88 <__alt_mem_mem_0+0xfcfebe88>
 200beb0:	0023883a 	mov	r17,zero
 200beb4:	003fca06 	br	200bde0 <__alt_mem_mem_0+0xfcfebde0>
 200beb8:	813fd336 	bltu	r16,r4,200be08 <__alt_mem_mem_0+0xfcfebe08>
 200bebc:	1023883a 	mov	r17,r2
 200bec0:	003fa806 	br	200bd64 <__alt_mem_mem_0+0xfcfebd64>
 200bec4:	b0ffd636 	bltu	r22,r3,200be20 <__alt_mem_mem_0+0xfcfebe20>
 200bec8:	1011883a 	mov	r8,r2
 200becc:	b0ff341e 	bne	r22,r3,200bba0 <__alt_mem_mem_0+0xfcfebba0>
 200bed0:	003f3406 	br	200bba4 <__alt_mem_mem_0+0xfcfebba4>
 200bed4:	0005883a 	mov	r2,zero
 200bed8:	003fe006 	br	200be5c <__alt_mem_mem_0+0xfcfebe5c>
 200bedc:	00800434 	movhi	r2,16
 200bee0:	89400234 	orhi	r5,r17,8
 200bee4:	10bfffc4 	addi	r2,r2,-1
 200bee8:	b807883a 	mov	r3,r23
 200beec:	288a703a 	and	r5,r5,r2
 200bef0:	4025883a 	mov	r18,r8
 200bef4:	003e8206 	br	200b900 <__alt_mem_mem_0+0xfcfeb900>

0200bef8 <__eqdf2>:
 200bef8:	2804d53a 	srli	r2,r5,20
 200befc:	3806d53a 	srli	r3,r7,20
 200bf00:	02000434 	movhi	r8,16
 200bf04:	423fffc4 	addi	r8,r8,-1
 200bf08:	1081ffcc 	andi	r2,r2,2047
 200bf0c:	0281ffc4 	movi	r10,2047
 200bf10:	2a12703a 	and	r9,r5,r8
 200bf14:	18c1ffcc 	andi	r3,r3,2047
 200bf18:	3a10703a 	and	r8,r7,r8
 200bf1c:	280ad7fa 	srli	r5,r5,31
 200bf20:	380ed7fa 	srli	r7,r7,31
 200bf24:	12801026 	beq	r2,r10,200bf68 <__eqdf2+0x70>
 200bf28:	0281ffc4 	movi	r10,2047
 200bf2c:	1a800a26 	beq	r3,r10,200bf58 <__eqdf2+0x60>
 200bf30:	10c00226 	beq	r2,r3,200bf3c <__eqdf2+0x44>
 200bf34:	00800044 	movi	r2,1
 200bf38:	f800283a 	ret
 200bf3c:	4a3ffd1e 	bne	r9,r8,200bf34 <__alt_mem_mem_0+0xfcfebf34>
 200bf40:	21bffc1e 	bne	r4,r6,200bf34 <__alt_mem_mem_0+0xfcfebf34>
 200bf44:	29c00c26 	beq	r5,r7,200bf78 <__eqdf2+0x80>
 200bf48:	103ffa1e 	bne	r2,zero,200bf34 <__alt_mem_mem_0+0xfcfebf34>
 200bf4c:	2244b03a 	or	r2,r4,r9
 200bf50:	1004c03a 	cmpne	r2,r2,zero
 200bf54:	f800283a 	ret
 200bf58:	3214b03a 	or	r10,r6,r8
 200bf5c:	503ff426 	beq	r10,zero,200bf30 <__alt_mem_mem_0+0xfcfebf30>
 200bf60:	00800044 	movi	r2,1
 200bf64:	f800283a 	ret
 200bf68:	2254b03a 	or	r10,r4,r9
 200bf6c:	503fee26 	beq	r10,zero,200bf28 <__alt_mem_mem_0+0xfcfebf28>
 200bf70:	00800044 	movi	r2,1
 200bf74:	f800283a 	ret
 200bf78:	0005883a 	mov	r2,zero
 200bf7c:	f800283a 	ret

0200bf80 <__gedf2>:
 200bf80:	2804d53a 	srli	r2,r5,20
 200bf84:	3806d53a 	srli	r3,r7,20
 200bf88:	02000434 	movhi	r8,16
 200bf8c:	423fffc4 	addi	r8,r8,-1
 200bf90:	1081ffcc 	andi	r2,r2,2047
 200bf94:	0241ffc4 	movi	r9,2047
 200bf98:	2a14703a 	and	r10,r5,r8
 200bf9c:	18c1ffcc 	andi	r3,r3,2047
 200bfa0:	3a10703a 	and	r8,r7,r8
 200bfa4:	280ad7fa 	srli	r5,r5,31
 200bfa8:	380ed7fa 	srli	r7,r7,31
 200bfac:	12401d26 	beq	r2,r9,200c024 <__gedf2+0xa4>
 200bfb0:	0241ffc4 	movi	r9,2047
 200bfb4:	1a401226 	beq	r3,r9,200c000 <__gedf2+0x80>
 200bfb8:	1000081e 	bne	r2,zero,200bfdc <__gedf2+0x5c>
 200bfbc:	2296b03a 	or	r11,r4,r10
 200bfc0:	5813003a 	cmpeq	r9,r11,zero
 200bfc4:	1800091e 	bne	r3,zero,200bfec <__gedf2+0x6c>
 200bfc8:	3218b03a 	or	r12,r6,r8
 200bfcc:	6000071e 	bne	r12,zero,200bfec <__gedf2+0x6c>
 200bfd0:	0005883a 	mov	r2,zero
 200bfd4:	5800101e 	bne	r11,zero,200c018 <__gedf2+0x98>
 200bfd8:	f800283a 	ret
 200bfdc:	18000c1e 	bne	r3,zero,200c010 <__gedf2+0x90>
 200bfe0:	3212b03a 	or	r9,r6,r8
 200bfe4:	48000c26 	beq	r9,zero,200c018 <__gedf2+0x98>
 200bfe8:	0013883a 	mov	r9,zero
 200bfec:	39c03fcc 	andi	r7,r7,255
 200bff0:	48000826 	beq	r9,zero,200c014 <__gedf2+0x94>
 200bff4:	38000926 	beq	r7,zero,200c01c <__gedf2+0x9c>
 200bff8:	00800044 	movi	r2,1
 200bffc:	f800283a 	ret
 200c000:	3212b03a 	or	r9,r6,r8
 200c004:	483fec26 	beq	r9,zero,200bfb8 <__alt_mem_mem_0+0xfcfebfb8>
 200c008:	00bfff84 	movi	r2,-2
 200c00c:	f800283a 	ret
 200c010:	39c03fcc 	andi	r7,r7,255
 200c014:	29c00626 	beq	r5,r7,200c030 <__gedf2+0xb0>
 200c018:	283ff726 	beq	r5,zero,200bff8 <__alt_mem_mem_0+0xfcfebff8>
 200c01c:	00bfffc4 	movi	r2,-1
 200c020:	f800283a 	ret
 200c024:	2292b03a 	or	r9,r4,r10
 200c028:	483fe126 	beq	r9,zero,200bfb0 <__alt_mem_mem_0+0xfcfebfb0>
 200c02c:	003ff606 	br	200c008 <__alt_mem_mem_0+0xfcfec008>
 200c030:	18bff916 	blt	r3,r2,200c018 <__alt_mem_mem_0+0xfcfec018>
 200c034:	10c00316 	blt	r2,r3,200c044 <__gedf2+0xc4>
 200c038:	42bff736 	bltu	r8,r10,200c018 <__alt_mem_mem_0+0xfcfec018>
 200c03c:	52000326 	beq	r10,r8,200c04c <__gedf2+0xcc>
 200c040:	5200042e 	bgeu	r10,r8,200c054 <__gedf2+0xd4>
 200c044:	283fec1e 	bne	r5,zero,200bff8 <__alt_mem_mem_0+0xfcfebff8>
 200c048:	003ff406 	br	200c01c <__alt_mem_mem_0+0xfcfec01c>
 200c04c:	313ff236 	bltu	r6,r4,200c018 <__alt_mem_mem_0+0xfcfec018>
 200c050:	21bffc36 	bltu	r4,r6,200c044 <__alt_mem_mem_0+0xfcfec044>
 200c054:	0005883a 	mov	r2,zero
 200c058:	f800283a 	ret

0200c05c <__ledf2>:
 200c05c:	2804d53a 	srli	r2,r5,20
 200c060:	3810d53a 	srli	r8,r7,20
 200c064:	00c00434 	movhi	r3,16
 200c068:	18ffffc4 	addi	r3,r3,-1
 200c06c:	1081ffcc 	andi	r2,r2,2047
 200c070:	0241ffc4 	movi	r9,2047
 200c074:	28d4703a 	and	r10,r5,r3
 200c078:	4201ffcc 	andi	r8,r8,2047
 200c07c:	38c6703a 	and	r3,r7,r3
 200c080:	280ad7fa 	srli	r5,r5,31
 200c084:	380ed7fa 	srli	r7,r7,31
 200c088:	12401f26 	beq	r2,r9,200c108 <__ledf2+0xac>
 200c08c:	0241ffc4 	movi	r9,2047
 200c090:	42401426 	beq	r8,r9,200c0e4 <__ledf2+0x88>
 200c094:	1000091e 	bne	r2,zero,200c0bc <__ledf2+0x60>
 200c098:	2296b03a 	or	r11,r4,r10
 200c09c:	5813003a 	cmpeq	r9,r11,zero
 200c0a0:	29403fcc 	andi	r5,r5,255
 200c0a4:	40000a1e 	bne	r8,zero,200c0d0 <__ledf2+0x74>
 200c0a8:	30d8b03a 	or	r12,r6,r3
 200c0ac:	6000081e 	bne	r12,zero,200c0d0 <__ledf2+0x74>
 200c0b0:	0005883a 	mov	r2,zero
 200c0b4:	5800111e 	bne	r11,zero,200c0fc <__ledf2+0xa0>
 200c0b8:	f800283a 	ret
 200c0bc:	29403fcc 	andi	r5,r5,255
 200c0c0:	40000c1e 	bne	r8,zero,200c0f4 <__ledf2+0x98>
 200c0c4:	30d2b03a 	or	r9,r6,r3
 200c0c8:	48000c26 	beq	r9,zero,200c0fc <__ledf2+0xa0>
 200c0cc:	0013883a 	mov	r9,zero
 200c0d0:	39c03fcc 	andi	r7,r7,255
 200c0d4:	48000826 	beq	r9,zero,200c0f8 <__ledf2+0x9c>
 200c0d8:	38001126 	beq	r7,zero,200c120 <__ledf2+0xc4>
 200c0dc:	00800044 	movi	r2,1
 200c0e0:	f800283a 	ret
 200c0e4:	30d2b03a 	or	r9,r6,r3
 200c0e8:	483fea26 	beq	r9,zero,200c094 <__alt_mem_mem_0+0xfcfec094>
 200c0ec:	00800084 	movi	r2,2
 200c0f0:	f800283a 	ret
 200c0f4:	39c03fcc 	andi	r7,r7,255
 200c0f8:	39400726 	beq	r7,r5,200c118 <__ledf2+0xbc>
 200c0fc:	2800081e 	bne	r5,zero,200c120 <__ledf2+0xc4>
 200c100:	00800044 	movi	r2,1
 200c104:	f800283a 	ret
 200c108:	2292b03a 	or	r9,r4,r10
 200c10c:	483fdf26 	beq	r9,zero,200c08c <__alt_mem_mem_0+0xfcfec08c>
 200c110:	00800084 	movi	r2,2
 200c114:	f800283a 	ret
 200c118:	4080030e 	bge	r8,r2,200c128 <__ledf2+0xcc>
 200c11c:	383fef26 	beq	r7,zero,200c0dc <__alt_mem_mem_0+0xfcfec0dc>
 200c120:	00bfffc4 	movi	r2,-1
 200c124:	f800283a 	ret
 200c128:	123feb16 	blt	r2,r8,200c0d8 <__alt_mem_mem_0+0xfcfec0d8>
 200c12c:	1abff336 	bltu	r3,r10,200c0fc <__alt_mem_mem_0+0xfcfec0fc>
 200c130:	50c00326 	beq	r10,r3,200c140 <__ledf2+0xe4>
 200c134:	50c0042e 	bgeu	r10,r3,200c148 <__ledf2+0xec>
 200c138:	283fe81e 	bne	r5,zero,200c0dc <__alt_mem_mem_0+0xfcfec0dc>
 200c13c:	003ff806 	br	200c120 <__alt_mem_mem_0+0xfcfec120>
 200c140:	313fee36 	bltu	r6,r4,200c0fc <__alt_mem_mem_0+0xfcfec0fc>
 200c144:	21bffc36 	bltu	r4,r6,200c138 <__alt_mem_mem_0+0xfcfec138>
 200c148:	0005883a 	mov	r2,zero
 200c14c:	f800283a 	ret

0200c150 <__muldf3>:
 200c150:	defff304 	addi	sp,sp,-52
 200c154:	2804d53a 	srli	r2,r5,20
 200c158:	dd800915 	stw	r22,36(sp)
 200c15c:	282cd7fa 	srli	r22,r5,31
 200c160:	dc000315 	stw	r16,12(sp)
 200c164:	04000434 	movhi	r16,16
 200c168:	dd400815 	stw	r21,32(sp)
 200c16c:	dc800515 	stw	r18,20(sp)
 200c170:	843fffc4 	addi	r16,r16,-1
 200c174:	dfc00c15 	stw	ra,48(sp)
 200c178:	df000b15 	stw	fp,44(sp)
 200c17c:	ddc00a15 	stw	r23,40(sp)
 200c180:	dd000715 	stw	r20,28(sp)
 200c184:	dcc00615 	stw	r19,24(sp)
 200c188:	dc400415 	stw	r17,16(sp)
 200c18c:	1481ffcc 	andi	r18,r2,2047
 200c190:	2c20703a 	and	r16,r5,r16
 200c194:	b02b883a 	mov	r21,r22
 200c198:	b2403fcc 	andi	r9,r22,255
 200c19c:	90006026 	beq	r18,zero,200c320 <__muldf3+0x1d0>
 200c1a0:	0081ffc4 	movi	r2,2047
 200c1a4:	2029883a 	mov	r20,r4
 200c1a8:	90803626 	beq	r18,r2,200c284 <__muldf3+0x134>
 200c1ac:	80800434 	orhi	r2,r16,16
 200c1b0:	100490fa 	slli	r2,r2,3
 200c1b4:	2020d77a 	srli	r16,r4,29
 200c1b8:	202890fa 	slli	r20,r4,3
 200c1bc:	94bf0044 	addi	r18,r18,-1023
 200c1c0:	80a0b03a 	or	r16,r16,r2
 200c1c4:	0027883a 	mov	r19,zero
 200c1c8:	0039883a 	mov	fp,zero
 200c1cc:	3804d53a 	srli	r2,r7,20
 200c1d0:	382ed7fa 	srli	r23,r7,31
 200c1d4:	04400434 	movhi	r17,16
 200c1d8:	8c7fffc4 	addi	r17,r17,-1
 200c1dc:	1081ffcc 	andi	r2,r2,2047
 200c1e0:	3011883a 	mov	r8,r6
 200c1e4:	3c62703a 	and	r17,r7,r17
 200c1e8:	ba803fcc 	andi	r10,r23,255
 200c1ec:	10006d26 	beq	r2,zero,200c3a4 <__muldf3+0x254>
 200c1f0:	00c1ffc4 	movi	r3,2047
 200c1f4:	10c06526 	beq	r2,r3,200c38c <__muldf3+0x23c>
 200c1f8:	88c00434 	orhi	r3,r17,16
 200c1fc:	180690fa 	slli	r3,r3,3
 200c200:	3022d77a 	srli	r17,r6,29
 200c204:	301090fa 	slli	r8,r6,3
 200c208:	10bf0044 	addi	r2,r2,-1023
 200c20c:	88e2b03a 	or	r17,r17,r3
 200c210:	000b883a 	mov	r5,zero
 200c214:	9085883a 	add	r2,r18,r2
 200c218:	2cc8b03a 	or	r4,r5,r19
 200c21c:	00c003c4 	movi	r3,15
 200c220:	bdacf03a 	xor	r22,r23,r22
 200c224:	12c00044 	addi	r11,r2,1
 200c228:	19009936 	bltu	r3,r4,200c490 <__muldf3+0x340>
 200c22c:	200890ba 	slli	r4,r4,2
 200c230:	00c08074 	movhi	r3,513
 200c234:	18f09104 	addi	r3,r3,-15804
 200c238:	20c9883a 	add	r4,r4,r3
 200c23c:	20c00017 	ldw	r3,0(r4)
 200c240:	1800683a 	jmp	r3
 200c244:	0200c490 	cmplti	r8,zero,786
 200c248:	0200c2a4 	muli	r8,zero,778
 200c24c:	0200c2a4 	muli	r8,zero,778
 200c250:	0200c2a0 	cmpeqi	r8,zero,778
 200c254:	0200c46c 	andhi	r8,zero,785
 200c258:	0200c46c 	andhi	r8,zero,785
 200c25c:	0200c454 	movui	r8,785
 200c260:	0200c2a0 	cmpeqi	r8,zero,778
 200c264:	0200c46c 	andhi	r8,zero,785
 200c268:	0200c454 	movui	r8,785
 200c26c:	0200c46c 	andhi	r8,zero,785
 200c270:	0200c2a0 	cmpeqi	r8,zero,778
 200c274:	0200c47c 	xorhi	r8,zero,785
 200c278:	0200c47c 	xorhi	r8,zero,785
 200c27c:	0200c47c 	xorhi	r8,zero,785
 200c280:	0200c698 	cmpnei	r8,zero,794
 200c284:	2404b03a 	or	r2,r4,r16
 200c288:	10006f1e 	bne	r2,zero,200c448 <__muldf3+0x2f8>
 200c28c:	04c00204 	movi	r19,8
 200c290:	0021883a 	mov	r16,zero
 200c294:	0029883a 	mov	r20,zero
 200c298:	07000084 	movi	fp,2
 200c29c:	003fcb06 	br	200c1cc <__alt_mem_mem_0+0xfcfec1cc>
 200c2a0:	502d883a 	mov	r22,r10
 200c2a4:	00800084 	movi	r2,2
 200c2a8:	28805726 	beq	r5,r2,200c408 <__muldf3+0x2b8>
 200c2ac:	008000c4 	movi	r2,3
 200c2b0:	28816626 	beq	r5,r2,200c84c <__muldf3+0x6fc>
 200c2b4:	00800044 	movi	r2,1
 200c2b8:	2881411e 	bne	r5,r2,200c7c0 <__muldf3+0x670>
 200c2bc:	b02b883a 	mov	r21,r22
 200c2c0:	0005883a 	mov	r2,zero
 200c2c4:	000b883a 	mov	r5,zero
 200c2c8:	0029883a 	mov	r20,zero
 200c2cc:	1004953a 	slli	r2,r2,20
 200c2d0:	a8c03fcc 	andi	r3,r21,255
 200c2d4:	04400434 	movhi	r17,16
 200c2d8:	8c7fffc4 	addi	r17,r17,-1
 200c2dc:	180697fa 	slli	r3,r3,31
 200c2e0:	2c4a703a 	and	r5,r5,r17
 200c2e4:	288ab03a 	or	r5,r5,r2
 200c2e8:	28c6b03a 	or	r3,r5,r3
 200c2ec:	a005883a 	mov	r2,r20
 200c2f0:	dfc00c17 	ldw	ra,48(sp)
 200c2f4:	df000b17 	ldw	fp,44(sp)
 200c2f8:	ddc00a17 	ldw	r23,40(sp)
 200c2fc:	dd800917 	ldw	r22,36(sp)
 200c300:	dd400817 	ldw	r21,32(sp)
 200c304:	dd000717 	ldw	r20,28(sp)
 200c308:	dcc00617 	ldw	r19,24(sp)
 200c30c:	dc800517 	ldw	r18,20(sp)
 200c310:	dc400417 	ldw	r17,16(sp)
 200c314:	dc000317 	ldw	r16,12(sp)
 200c318:	dec00d04 	addi	sp,sp,52
 200c31c:	f800283a 	ret
 200c320:	2404b03a 	or	r2,r4,r16
 200c324:	2027883a 	mov	r19,r4
 200c328:	10004226 	beq	r2,zero,200c434 <__muldf3+0x2e4>
 200c32c:	8000fc26 	beq	r16,zero,200c720 <__muldf3+0x5d0>
 200c330:	8009883a 	mov	r4,r16
 200c334:	d9800215 	stw	r6,8(sp)
 200c338:	d9c00015 	stw	r7,0(sp)
 200c33c:	da400115 	stw	r9,4(sp)
 200c340:	200d3680 	call	200d368 <__clzsi2>
 200c344:	d9800217 	ldw	r6,8(sp)
 200c348:	d9c00017 	ldw	r7,0(sp)
 200c34c:	da400117 	ldw	r9,4(sp)
 200c350:	113ffd44 	addi	r4,r2,-11
 200c354:	00c00704 	movi	r3,28
 200c358:	1900ed16 	blt	r3,r4,200c710 <__muldf3+0x5c0>
 200c35c:	00c00744 	movi	r3,29
 200c360:	147ffe04 	addi	r17,r2,-8
 200c364:	1907c83a 	sub	r3,r3,r4
 200c368:	8460983a 	sll	r16,r16,r17
 200c36c:	98c6d83a 	srl	r3,r19,r3
 200c370:	9c68983a 	sll	r20,r19,r17
 200c374:	1c20b03a 	or	r16,r3,r16
 200c378:	1080fcc4 	addi	r2,r2,1011
 200c37c:	00a5c83a 	sub	r18,zero,r2
 200c380:	0027883a 	mov	r19,zero
 200c384:	0039883a 	mov	fp,zero
 200c388:	003f9006 	br	200c1cc <__alt_mem_mem_0+0xfcfec1cc>
 200c38c:	3446b03a 	or	r3,r6,r17
 200c390:	1800261e 	bne	r3,zero,200c42c <__muldf3+0x2dc>
 200c394:	0023883a 	mov	r17,zero
 200c398:	0011883a 	mov	r8,zero
 200c39c:	01400084 	movi	r5,2
 200c3a0:	003f9c06 	br	200c214 <__alt_mem_mem_0+0xfcfec214>
 200c3a4:	3446b03a 	or	r3,r6,r17
 200c3a8:	18001c26 	beq	r3,zero,200c41c <__muldf3+0x2cc>
 200c3ac:	8800ce26 	beq	r17,zero,200c6e8 <__muldf3+0x598>
 200c3b0:	8809883a 	mov	r4,r17
 200c3b4:	d9800215 	stw	r6,8(sp)
 200c3b8:	da400115 	stw	r9,4(sp)
 200c3bc:	da800015 	stw	r10,0(sp)
 200c3c0:	200d3680 	call	200d368 <__clzsi2>
 200c3c4:	d9800217 	ldw	r6,8(sp)
 200c3c8:	da400117 	ldw	r9,4(sp)
 200c3cc:	da800017 	ldw	r10,0(sp)
 200c3d0:	113ffd44 	addi	r4,r2,-11
 200c3d4:	00c00704 	movi	r3,28
 200c3d8:	1900bf16 	blt	r3,r4,200c6d8 <__muldf3+0x588>
 200c3dc:	00c00744 	movi	r3,29
 200c3e0:	123ffe04 	addi	r8,r2,-8
 200c3e4:	1907c83a 	sub	r3,r3,r4
 200c3e8:	8a22983a 	sll	r17,r17,r8
 200c3ec:	30c6d83a 	srl	r3,r6,r3
 200c3f0:	3210983a 	sll	r8,r6,r8
 200c3f4:	1c62b03a 	or	r17,r3,r17
 200c3f8:	1080fcc4 	addi	r2,r2,1011
 200c3fc:	0085c83a 	sub	r2,zero,r2
 200c400:	000b883a 	mov	r5,zero
 200c404:	003f8306 	br	200c214 <__alt_mem_mem_0+0xfcfec214>
 200c408:	b02b883a 	mov	r21,r22
 200c40c:	0081ffc4 	movi	r2,2047
 200c410:	000b883a 	mov	r5,zero
 200c414:	0029883a 	mov	r20,zero
 200c418:	003fac06 	br	200c2cc <__alt_mem_mem_0+0xfcfec2cc>
 200c41c:	0023883a 	mov	r17,zero
 200c420:	0011883a 	mov	r8,zero
 200c424:	01400044 	movi	r5,1
 200c428:	003f7a06 	br	200c214 <__alt_mem_mem_0+0xfcfec214>
 200c42c:	014000c4 	movi	r5,3
 200c430:	003f7806 	br	200c214 <__alt_mem_mem_0+0xfcfec214>
 200c434:	04c00104 	movi	r19,4
 200c438:	0021883a 	mov	r16,zero
 200c43c:	0029883a 	mov	r20,zero
 200c440:	07000044 	movi	fp,1
 200c444:	003f6106 	br	200c1cc <__alt_mem_mem_0+0xfcfec1cc>
 200c448:	04c00304 	movi	r19,12
 200c44c:	070000c4 	movi	fp,3
 200c450:	003f5e06 	br	200c1cc <__alt_mem_mem_0+0xfcfec1cc>
 200c454:	01400434 	movhi	r5,16
 200c458:	002b883a 	mov	r21,zero
 200c45c:	297fffc4 	addi	r5,r5,-1
 200c460:	053fffc4 	movi	r20,-1
 200c464:	0081ffc4 	movi	r2,2047
 200c468:	003f9806 	br	200c2cc <__alt_mem_mem_0+0xfcfec2cc>
 200c46c:	8023883a 	mov	r17,r16
 200c470:	a011883a 	mov	r8,r20
 200c474:	e00b883a 	mov	r5,fp
 200c478:	003f8a06 	br	200c2a4 <__alt_mem_mem_0+0xfcfec2a4>
 200c47c:	8023883a 	mov	r17,r16
 200c480:	a011883a 	mov	r8,r20
 200c484:	482d883a 	mov	r22,r9
 200c488:	e00b883a 	mov	r5,fp
 200c48c:	003f8506 	br	200c2a4 <__alt_mem_mem_0+0xfcfec2a4>
 200c490:	a00ad43a 	srli	r5,r20,16
 200c494:	401ad43a 	srli	r13,r8,16
 200c498:	a53fffcc 	andi	r20,r20,65535
 200c49c:	423fffcc 	andi	r8,r8,65535
 200c4a0:	4519383a 	mul	r12,r8,r20
 200c4a4:	4147383a 	mul	r3,r8,r5
 200c4a8:	6d09383a 	mul	r4,r13,r20
 200c4ac:	600cd43a 	srli	r6,r12,16
 200c4b0:	2b5d383a 	mul	r14,r5,r13
 200c4b4:	20c9883a 	add	r4,r4,r3
 200c4b8:	310d883a 	add	r6,r6,r4
 200c4bc:	30c0022e 	bgeu	r6,r3,200c4c8 <__muldf3+0x378>
 200c4c0:	00c00074 	movhi	r3,1
 200c4c4:	70dd883a 	add	r14,r14,r3
 200c4c8:	8826d43a 	srli	r19,r17,16
 200c4cc:	8bffffcc 	andi	r15,r17,65535
 200c4d0:	7d23383a 	mul	r17,r15,r20
 200c4d4:	7949383a 	mul	r4,r15,r5
 200c4d8:	9d29383a 	mul	r20,r19,r20
 200c4dc:	8814d43a 	srli	r10,r17,16
 200c4e0:	3012943a 	slli	r9,r6,16
 200c4e4:	a129883a 	add	r20,r20,r4
 200c4e8:	633fffcc 	andi	r12,r12,65535
 200c4ec:	5515883a 	add	r10,r10,r20
 200c4f0:	3006d43a 	srli	r3,r6,16
 200c4f4:	4b13883a 	add	r9,r9,r12
 200c4f8:	2ccb383a 	mul	r5,r5,r19
 200c4fc:	5100022e 	bgeu	r10,r4,200c508 <__muldf3+0x3b8>
 200c500:	01000074 	movhi	r4,1
 200c504:	290b883a 	add	r5,r5,r4
 200c508:	802ad43a 	srli	r21,r16,16
 200c50c:	843fffcc 	andi	r16,r16,65535
 200c510:	440d383a 	mul	r6,r8,r16
 200c514:	4565383a 	mul	r18,r8,r21
 200c518:	8349383a 	mul	r4,r16,r13
 200c51c:	500e943a 	slli	r7,r10,16
 200c520:	3010d43a 	srli	r8,r6,16
 200c524:	5028d43a 	srli	r20,r10,16
 200c528:	2489883a 	add	r4,r4,r18
 200c52c:	8abfffcc 	andi	r10,r17,65535
 200c530:	3a95883a 	add	r10,r7,r10
 200c534:	4119883a 	add	r12,r8,r4
 200c538:	a169883a 	add	r20,r20,r5
 200c53c:	1a87883a 	add	r3,r3,r10
 200c540:	6d5b383a 	mul	r13,r13,r21
 200c544:	6480022e 	bgeu	r12,r18,200c550 <__muldf3+0x400>
 200c548:	01000074 	movhi	r4,1
 200c54c:	691b883a 	add	r13,r13,r4
 200c550:	7c25383a 	mul	r18,r15,r16
 200c554:	7d4b383a 	mul	r5,r15,r21
 200c558:	84cf383a 	mul	r7,r16,r19
 200c55c:	901ed43a 	srli	r15,r18,16
 200c560:	6008d43a 	srli	r4,r12,16
 200c564:	6010943a 	slli	r8,r12,16
 200c568:	394f883a 	add	r7,r7,r5
 200c56c:	333fffcc 	andi	r12,r6,65535
 200c570:	79df883a 	add	r15,r15,r7
 200c574:	235b883a 	add	r13,r4,r13
 200c578:	9d63383a 	mul	r17,r19,r21
 200c57c:	4309883a 	add	r4,r8,r12
 200c580:	7940022e 	bgeu	r15,r5,200c58c <__muldf3+0x43c>
 200c584:	01400074 	movhi	r5,1
 200c588:	8963883a 	add	r17,r17,r5
 200c58c:	780a943a 	slli	r5,r15,16
 200c590:	91bfffcc 	andi	r6,r18,65535
 200c594:	70c7883a 	add	r3,r14,r3
 200c598:	298d883a 	add	r6,r5,r6
 200c59c:	1a8f803a 	cmpltu	r7,r3,r10
 200c5a0:	350b883a 	add	r5,r6,r20
 200c5a4:	20c7883a 	add	r3,r4,r3
 200c5a8:	3955883a 	add	r10,r7,r5
 200c5ac:	1909803a 	cmpltu	r4,r3,r4
 200c5b0:	6a91883a 	add	r8,r13,r10
 200c5b4:	780cd43a 	srli	r6,r15,16
 200c5b8:	2219883a 	add	r12,r4,r8
 200c5bc:	2d0b803a 	cmpltu	r5,r5,r20
 200c5c0:	51cf803a 	cmpltu	r7,r10,r7
 200c5c4:	29ceb03a 	or	r7,r5,r7
 200c5c8:	4351803a 	cmpltu	r8,r8,r13
 200c5cc:	610b803a 	cmpltu	r5,r12,r4
 200c5d0:	4148b03a 	or	r4,r8,r5
 200c5d4:	398f883a 	add	r7,r7,r6
 200c5d8:	3909883a 	add	r4,r7,r4
 200c5dc:	1810927a 	slli	r8,r3,9
 200c5e0:	2449883a 	add	r4,r4,r17
 200c5e4:	2008927a 	slli	r4,r4,9
 200c5e8:	6022d5fa 	srli	r17,r12,23
 200c5ec:	1806d5fa 	srli	r3,r3,23
 200c5f0:	4252b03a 	or	r9,r8,r9
 200c5f4:	600a927a 	slli	r5,r12,9
 200c5f8:	4810c03a 	cmpne	r8,r9,zero
 200c5fc:	2462b03a 	or	r17,r4,r17
 200c600:	40c6b03a 	or	r3,r8,r3
 200c604:	8900402c 	andhi	r4,r17,256
 200c608:	1950b03a 	or	r8,r3,r5
 200c60c:	20000726 	beq	r4,zero,200c62c <__muldf3+0x4dc>
 200c610:	4006d07a 	srli	r3,r8,1
 200c614:	880497fa 	slli	r2,r17,31
 200c618:	4200004c 	andi	r8,r8,1
 200c61c:	8822d07a 	srli	r17,r17,1
 200c620:	1a10b03a 	or	r8,r3,r8
 200c624:	1210b03a 	or	r8,r2,r8
 200c628:	5805883a 	mov	r2,r11
 200c62c:	1140ffc4 	addi	r5,r2,1023
 200c630:	0140440e 	bge	zero,r5,200c744 <__muldf3+0x5f4>
 200c634:	40c001cc 	andi	r3,r8,7
 200c638:	18000726 	beq	r3,zero,200c658 <__muldf3+0x508>
 200c63c:	40c003cc 	andi	r3,r8,15
 200c640:	01000104 	movi	r4,4
 200c644:	19000426 	beq	r3,r4,200c658 <__muldf3+0x508>
 200c648:	4107883a 	add	r3,r8,r4
 200c64c:	1a11803a 	cmpltu	r8,r3,r8
 200c650:	8a23883a 	add	r17,r17,r8
 200c654:	1811883a 	mov	r8,r3
 200c658:	88c0402c 	andhi	r3,r17,256
 200c65c:	18000426 	beq	r3,zero,200c670 <__muldf3+0x520>
 200c660:	11410004 	addi	r5,r2,1024
 200c664:	00bfc034 	movhi	r2,65280
 200c668:	10bfffc4 	addi	r2,r2,-1
 200c66c:	88a2703a 	and	r17,r17,r2
 200c670:	0081ff84 	movi	r2,2046
 200c674:	117f6416 	blt	r2,r5,200c408 <__alt_mem_mem_0+0xfcfec408>
 200c678:	8828977a 	slli	r20,r17,29
 200c67c:	4010d0fa 	srli	r8,r8,3
 200c680:	8822927a 	slli	r17,r17,9
 200c684:	2881ffcc 	andi	r2,r5,2047
 200c688:	a228b03a 	or	r20,r20,r8
 200c68c:	880ad33a 	srli	r5,r17,12
 200c690:	b02b883a 	mov	r21,r22
 200c694:	003f0d06 	br	200c2cc <__alt_mem_mem_0+0xfcfec2cc>
 200c698:	8080022c 	andhi	r2,r16,8
 200c69c:	10000926 	beq	r2,zero,200c6c4 <__muldf3+0x574>
 200c6a0:	8880022c 	andhi	r2,r17,8
 200c6a4:	1000071e 	bne	r2,zero,200c6c4 <__muldf3+0x574>
 200c6a8:	00800434 	movhi	r2,16
 200c6ac:	89400234 	orhi	r5,r17,8
 200c6b0:	10bfffc4 	addi	r2,r2,-1
 200c6b4:	b82b883a 	mov	r21,r23
 200c6b8:	288a703a 	and	r5,r5,r2
 200c6bc:	4029883a 	mov	r20,r8
 200c6c0:	003f6806 	br	200c464 <__alt_mem_mem_0+0xfcfec464>
 200c6c4:	00800434 	movhi	r2,16
 200c6c8:	81400234 	orhi	r5,r16,8
 200c6cc:	10bfffc4 	addi	r2,r2,-1
 200c6d0:	288a703a 	and	r5,r5,r2
 200c6d4:	003f6306 	br	200c464 <__alt_mem_mem_0+0xfcfec464>
 200c6d8:	147ff604 	addi	r17,r2,-40
 200c6dc:	3462983a 	sll	r17,r6,r17
 200c6e0:	0011883a 	mov	r8,zero
 200c6e4:	003f4406 	br	200c3f8 <__alt_mem_mem_0+0xfcfec3f8>
 200c6e8:	3009883a 	mov	r4,r6
 200c6ec:	d9800215 	stw	r6,8(sp)
 200c6f0:	da400115 	stw	r9,4(sp)
 200c6f4:	da800015 	stw	r10,0(sp)
 200c6f8:	200d3680 	call	200d368 <__clzsi2>
 200c6fc:	10800804 	addi	r2,r2,32
 200c700:	da800017 	ldw	r10,0(sp)
 200c704:	da400117 	ldw	r9,4(sp)
 200c708:	d9800217 	ldw	r6,8(sp)
 200c70c:	003f3006 	br	200c3d0 <__alt_mem_mem_0+0xfcfec3d0>
 200c710:	143ff604 	addi	r16,r2,-40
 200c714:	9c20983a 	sll	r16,r19,r16
 200c718:	0029883a 	mov	r20,zero
 200c71c:	003f1606 	br	200c378 <__alt_mem_mem_0+0xfcfec378>
 200c720:	d9800215 	stw	r6,8(sp)
 200c724:	d9c00015 	stw	r7,0(sp)
 200c728:	da400115 	stw	r9,4(sp)
 200c72c:	200d3680 	call	200d368 <__clzsi2>
 200c730:	10800804 	addi	r2,r2,32
 200c734:	da400117 	ldw	r9,4(sp)
 200c738:	d9c00017 	ldw	r7,0(sp)
 200c73c:	d9800217 	ldw	r6,8(sp)
 200c740:	003f0306 	br	200c350 <__alt_mem_mem_0+0xfcfec350>
 200c744:	00c00044 	movi	r3,1
 200c748:	1947c83a 	sub	r3,r3,r5
 200c74c:	00800e04 	movi	r2,56
 200c750:	10feda16 	blt	r2,r3,200c2bc <__alt_mem_mem_0+0xfcfec2bc>
 200c754:	008007c4 	movi	r2,31
 200c758:	10c01b16 	blt	r2,r3,200c7c8 <__muldf3+0x678>
 200c75c:	00800804 	movi	r2,32
 200c760:	10c5c83a 	sub	r2,r2,r3
 200c764:	888a983a 	sll	r5,r17,r2
 200c768:	40c8d83a 	srl	r4,r8,r3
 200c76c:	4084983a 	sll	r2,r8,r2
 200c770:	88e2d83a 	srl	r17,r17,r3
 200c774:	2906b03a 	or	r3,r5,r4
 200c778:	1004c03a 	cmpne	r2,r2,zero
 200c77c:	1886b03a 	or	r3,r3,r2
 200c780:	188001cc 	andi	r2,r3,7
 200c784:	10000726 	beq	r2,zero,200c7a4 <__muldf3+0x654>
 200c788:	188003cc 	andi	r2,r3,15
 200c78c:	01000104 	movi	r4,4
 200c790:	11000426 	beq	r2,r4,200c7a4 <__muldf3+0x654>
 200c794:	1805883a 	mov	r2,r3
 200c798:	10c00104 	addi	r3,r2,4
 200c79c:	1885803a 	cmpltu	r2,r3,r2
 200c7a0:	88a3883a 	add	r17,r17,r2
 200c7a4:	8880202c 	andhi	r2,r17,128
 200c7a8:	10001c26 	beq	r2,zero,200c81c <__muldf3+0x6cc>
 200c7ac:	b02b883a 	mov	r21,r22
 200c7b0:	00800044 	movi	r2,1
 200c7b4:	000b883a 	mov	r5,zero
 200c7b8:	0029883a 	mov	r20,zero
 200c7bc:	003ec306 	br	200c2cc <__alt_mem_mem_0+0xfcfec2cc>
 200c7c0:	5805883a 	mov	r2,r11
 200c7c4:	003f9906 	br	200c62c <__alt_mem_mem_0+0xfcfec62c>
 200c7c8:	00bff844 	movi	r2,-31
 200c7cc:	1145c83a 	sub	r2,r2,r5
 200c7d0:	8888d83a 	srl	r4,r17,r2
 200c7d4:	00800804 	movi	r2,32
 200c7d8:	18801a26 	beq	r3,r2,200c844 <__muldf3+0x6f4>
 200c7dc:	00801004 	movi	r2,64
 200c7e0:	10c5c83a 	sub	r2,r2,r3
 200c7e4:	8884983a 	sll	r2,r17,r2
 200c7e8:	1204b03a 	or	r2,r2,r8
 200c7ec:	1004c03a 	cmpne	r2,r2,zero
 200c7f0:	2084b03a 	or	r2,r4,r2
 200c7f4:	144001cc 	andi	r17,r2,7
 200c7f8:	88000d1e 	bne	r17,zero,200c830 <__muldf3+0x6e0>
 200c7fc:	000b883a 	mov	r5,zero
 200c800:	1028d0fa 	srli	r20,r2,3
 200c804:	b02b883a 	mov	r21,r22
 200c808:	0005883a 	mov	r2,zero
 200c80c:	a468b03a 	or	r20,r20,r17
 200c810:	003eae06 	br	200c2cc <__alt_mem_mem_0+0xfcfec2cc>
 200c814:	1007883a 	mov	r3,r2
 200c818:	0023883a 	mov	r17,zero
 200c81c:	880a927a 	slli	r5,r17,9
 200c820:	1805883a 	mov	r2,r3
 200c824:	8822977a 	slli	r17,r17,29
 200c828:	280ad33a 	srli	r5,r5,12
 200c82c:	003ff406 	br	200c800 <__alt_mem_mem_0+0xfcfec800>
 200c830:	10c003cc 	andi	r3,r2,15
 200c834:	01000104 	movi	r4,4
 200c838:	193ff626 	beq	r3,r4,200c814 <__alt_mem_mem_0+0xfcfec814>
 200c83c:	0023883a 	mov	r17,zero
 200c840:	003fd506 	br	200c798 <__alt_mem_mem_0+0xfcfec798>
 200c844:	0005883a 	mov	r2,zero
 200c848:	003fe706 	br	200c7e8 <__alt_mem_mem_0+0xfcfec7e8>
 200c84c:	00800434 	movhi	r2,16
 200c850:	89400234 	orhi	r5,r17,8
 200c854:	10bfffc4 	addi	r2,r2,-1
 200c858:	b02b883a 	mov	r21,r22
 200c85c:	288a703a 	and	r5,r5,r2
 200c860:	4029883a 	mov	r20,r8
 200c864:	003eff06 	br	200c464 <__alt_mem_mem_0+0xfcfec464>

0200c868 <__subdf3>:
 200c868:	02000434 	movhi	r8,16
 200c86c:	423fffc4 	addi	r8,r8,-1
 200c870:	defffb04 	addi	sp,sp,-20
 200c874:	2a14703a 	and	r10,r5,r8
 200c878:	3812d53a 	srli	r9,r7,20
 200c87c:	3a10703a 	and	r8,r7,r8
 200c880:	2006d77a 	srli	r3,r4,29
 200c884:	3004d77a 	srli	r2,r6,29
 200c888:	dc000015 	stw	r16,0(sp)
 200c88c:	501490fa 	slli	r10,r10,3
 200c890:	2820d53a 	srli	r16,r5,20
 200c894:	401090fa 	slli	r8,r8,3
 200c898:	dc800215 	stw	r18,8(sp)
 200c89c:	dc400115 	stw	r17,4(sp)
 200c8a0:	dfc00415 	stw	ra,16(sp)
 200c8a4:	202290fa 	slli	r17,r4,3
 200c8a8:	dcc00315 	stw	r19,12(sp)
 200c8ac:	4a41ffcc 	andi	r9,r9,2047
 200c8b0:	0101ffc4 	movi	r4,2047
 200c8b4:	2824d7fa 	srli	r18,r5,31
 200c8b8:	8401ffcc 	andi	r16,r16,2047
 200c8bc:	50c6b03a 	or	r3,r10,r3
 200c8c0:	380ed7fa 	srli	r7,r7,31
 200c8c4:	408ab03a 	or	r5,r8,r2
 200c8c8:	300c90fa 	slli	r6,r6,3
 200c8cc:	49009626 	beq	r9,r4,200cb28 <__subdf3+0x2c0>
 200c8d0:	39c0005c 	xori	r7,r7,1
 200c8d4:	8245c83a 	sub	r2,r16,r9
 200c8d8:	3c807426 	beq	r7,r18,200caac <__subdf3+0x244>
 200c8dc:	0080af0e 	bge	zero,r2,200cb9c <__subdf3+0x334>
 200c8e0:	48002a1e 	bne	r9,zero,200c98c <__subdf3+0x124>
 200c8e4:	2988b03a 	or	r4,r5,r6
 200c8e8:	20009a1e 	bne	r4,zero,200cb54 <__subdf3+0x2ec>
 200c8ec:	888001cc 	andi	r2,r17,7
 200c8f0:	10000726 	beq	r2,zero,200c910 <__subdf3+0xa8>
 200c8f4:	888003cc 	andi	r2,r17,15
 200c8f8:	01000104 	movi	r4,4
 200c8fc:	11000426 	beq	r2,r4,200c910 <__subdf3+0xa8>
 200c900:	890b883a 	add	r5,r17,r4
 200c904:	2c63803a 	cmpltu	r17,r5,r17
 200c908:	1c47883a 	add	r3,r3,r17
 200c90c:	2823883a 	mov	r17,r5
 200c910:	1880202c 	andhi	r2,r3,128
 200c914:	10005926 	beq	r2,zero,200ca7c <__subdf3+0x214>
 200c918:	84000044 	addi	r16,r16,1
 200c91c:	0081ffc4 	movi	r2,2047
 200c920:	8080be26 	beq	r16,r2,200cc1c <__subdf3+0x3b4>
 200c924:	017fe034 	movhi	r5,65408
 200c928:	297fffc4 	addi	r5,r5,-1
 200c92c:	1946703a 	and	r3,r3,r5
 200c930:	1804977a 	slli	r2,r3,29
 200c934:	1806927a 	slli	r3,r3,9
 200c938:	8822d0fa 	srli	r17,r17,3
 200c93c:	8401ffcc 	andi	r16,r16,2047
 200c940:	180ad33a 	srli	r5,r3,12
 200c944:	9100004c 	andi	r4,r18,1
 200c948:	1444b03a 	or	r2,r2,r17
 200c94c:	80c1ffcc 	andi	r3,r16,2047
 200c950:	1820953a 	slli	r16,r3,20
 200c954:	20c03fcc 	andi	r3,r4,255
 200c958:	180897fa 	slli	r4,r3,31
 200c95c:	00c00434 	movhi	r3,16
 200c960:	18ffffc4 	addi	r3,r3,-1
 200c964:	28c6703a 	and	r3,r5,r3
 200c968:	1c06b03a 	or	r3,r3,r16
 200c96c:	1906b03a 	or	r3,r3,r4
 200c970:	dfc00417 	ldw	ra,16(sp)
 200c974:	dcc00317 	ldw	r19,12(sp)
 200c978:	dc800217 	ldw	r18,8(sp)
 200c97c:	dc400117 	ldw	r17,4(sp)
 200c980:	dc000017 	ldw	r16,0(sp)
 200c984:	dec00504 	addi	sp,sp,20
 200c988:	f800283a 	ret
 200c98c:	0101ffc4 	movi	r4,2047
 200c990:	813fd626 	beq	r16,r4,200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200c994:	29402034 	orhi	r5,r5,128
 200c998:	01000e04 	movi	r4,56
 200c99c:	2080a316 	blt	r4,r2,200cc2c <__subdf3+0x3c4>
 200c9a0:	010007c4 	movi	r4,31
 200c9a4:	2080c616 	blt	r4,r2,200ccc0 <__subdf3+0x458>
 200c9a8:	01000804 	movi	r4,32
 200c9ac:	2089c83a 	sub	r4,r4,r2
 200c9b0:	2910983a 	sll	r8,r5,r4
 200c9b4:	308ed83a 	srl	r7,r6,r2
 200c9b8:	3108983a 	sll	r4,r6,r4
 200c9bc:	2884d83a 	srl	r2,r5,r2
 200c9c0:	41ccb03a 	or	r6,r8,r7
 200c9c4:	2008c03a 	cmpne	r4,r4,zero
 200c9c8:	310cb03a 	or	r6,r6,r4
 200c9cc:	898dc83a 	sub	r6,r17,r6
 200c9d0:	89a3803a 	cmpltu	r17,r17,r6
 200c9d4:	1887c83a 	sub	r3,r3,r2
 200c9d8:	1c47c83a 	sub	r3,r3,r17
 200c9dc:	3023883a 	mov	r17,r6
 200c9e0:	1880202c 	andhi	r2,r3,128
 200c9e4:	10002326 	beq	r2,zero,200ca74 <__subdf3+0x20c>
 200c9e8:	04c02034 	movhi	r19,128
 200c9ec:	9cffffc4 	addi	r19,r19,-1
 200c9f0:	1ce6703a 	and	r19,r3,r19
 200c9f4:	98007a26 	beq	r19,zero,200cbe0 <__subdf3+0x378>
 200c9f8:	9809883a 	mov	r4,r19
 200c9fc:	200d3680 	call	200d368 <__clzsi2>
 200ca00:	113ffe04 	addi	r4,r2,-8
 200ca04:	00c007c4 	movi	r3,31
 200ca08:	19007b16 	blt	r3,r4,200cbf8 <__subdf3+0x390>
 200ca0c:	00800804 	movi	r2,32
 200ca10:	1105c83a 	sub	r2,r2,r4
 200ca14:	8884d83a 	srl	r2,r17,r2
 200ca18:	9906983a 	sll	r3,r19,r4
 200ca1c:	8922983a 	sll	r17,r17,r4
 200ca20:	10c4b03a 	or	r2,r2,r3
 200ca24:	24007816 	blt	r4,r16,200cc08 <__subdf3+0x3a0>
 200ca28:	2421c83a 	sub	r16,r4,r16
 200ca2c:	80c00044 	addi	r3,r16,1
 200ca30:	010007c4 	movi	r4,31
 200ca34:	20c09516 	blt	r4,r3,200cc8c <__subdf3+0x424>
 200ca38:	01400804 	movi	r5,32
 200ca3c:	28cbc83a 	sub	r5,r5,r3
 200ca40:	88c8d83a 	srl	r4,r17,r3
 200ca44:	8962983a 	sll	r17,r17,r5
 200ca48:	114a983a 	sll	r5,r2,r5
 200ca4c:	10c6d83a 	srl	r3,r2,r3
 200ca50:	8804c03a 	cmpne	r2,r17,zero
 200ca54:	290ab03a 	or	r5,r5,r4
 200ca58:	28a2b03a 	or	r17,r5,r2
 200ca5c:	0021883a 	mov	r16,zero
 200ca60:	003fa206 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200ca64:	2090b03a 	or	r8,r4,r2
 200ca68:	40018e26 	beq	r8,zero,200d0a4 <__subdf3+0x83c>
 200ca6c:	1007883a 	mov	r3,r2
 200ca70:	2023883a 	mov	r17,r4
 200ca74:	888001cc 	andi	r2,r17,7
 200ca78:	103f9e1e 	bne	r2,zero,200c8f4 <__alt_mem_mem_0+0xfcfec8f4>
 200ca7c:	1804977a 	slli	r2,r3,29
 200ca80:	8822d0fa 	srli	r17,r17,3
 200ca84:	1810d0fa 	srli	r8,r3,3
 200ca88:	9100004c 	andi	r4,r18,1
 200ca8c:	1444b03a 	or	r2,r2,r17
 200ca90:	00c1ffc4 	movi	r3,2047
 200ca94:	80c02826 	beq	r16,r3,200cb38 <__subdf3+0x2d0>
 200ca98:	01400434 	movhi	r5,16
 200ca9c:	297fffc4 	addi	r5,r5,-1
 200caa0:	80e0703a 	and	r16,r16,r3
 200caa4:	414a703a 	and	r5,r8,r5
 200caa8:	003fa806 	br	200c94c <__alt_mem_mem_0+0xfcfec94c>
 200caac:	0080630e 	bge	zero,r2,200cc3c <__subdf3+0x3d4>
 200cab0:	48003026 	beq	r9,zero,200cb74 <__subdf3+0x30c>
 200cab4:	0101ffc4 	movi	r4,2047
 200cab8:	813f8c26 	beq	r16,r4,200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cabc:	29402034 	orhi	r5,r5,128
 200cac0:	01000e04 	movi	r4,56
 200cac4:	2080a90e 	bge	r4,r2,200cd6c <__subdf3+0x504>
 200cac8:	298cb03a 	or	r6,r5,r6
 200cacc:	3012c03a 	cmpne	r9,r6,zero
 200cad0:	0005883a 	mov	r2,zero
 200cad4:	4c53883a 	add	r9,r9,r17
 200cad8:	4c63803a 	cmpltu	r17,r9,r17
 200cadc:	10c7883a 	add	r3,r2,r3
 200cae0:	88c7883a 	add	r3,r17,r3
 200cae4:	4823883a 	mov	r17,r9
 200cae8:	1880202c 	andhi	r2,r3,128
 200caec:	1000d026 	beq	r2,zero,200ce30 <__subdf3+0x5c8>
 200caf0:	84000044 	addi	r16,r16,1
 200caf4:	0081ffc4 	movi	r2,2047
 200caf8:	8080fe26 	beq	r16,r2,200cef4 <__subdf3+0x68c>
 200cafc:	00bfe034 	movhi	r2,65408
 200cb00:	10bfffc4 	addi	r2,r2,-1
 200cb04:	1886703a 	and	r3,r3,r2
 200cb08:	880ad07a 	srli	r5,r17,1
 200cb0c:	180497fa 	slli	r2,r3,31
 200cb10:	8900004c 	andi	r4,r17,1
 200cb14:	2922b03a 	or	r17,r5,r4
 200cb18:	1806d07a 	srli	r3,r3,1
 200cb1c:	1462b03a 	or	r17,r2,r17
 200cb20:	3825883a 	mov	r18,r7
 200cb24:	003f7106 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cb28:	2984b03a 	or	r2,r5,r6
 200cb2c:	103f6826 	beq	r2,zero,200c8d0 <__alt_mem_mem_0+0xfcfec8d0>
 200cb30:	39c03fcc 	andi	r7,r7,255
 200cb34:	003f6706 	br	200c8d4 <__alt_mem_mem_0+0xfcfec8d4>
 200cb38:	4086b03a 	or	r3,r8,r2
 200cb3c:	18015226 	beq	r3,zero,200d088 <__subdf3+0x820>
 200cb40:	00c00434 	movhi	r3,16
 200cb44:	41400234 	orhi	r5,r8,8
 200cb48:	18ffffc4 	addi	r3,r3,-1
 200cb4c:	28ca703a 	and	r5,r5,r3
 200cb50:	003f7e06 	br	200c94c <__alt_mem_mem_0+0xfcfec94c>
 200cb54:	10bfffc4 	addi	r2,r2,-1
 200cb58:	1000491e 	bne	r2,zero,200cc80 <__subdf3+0x418>
 200cb5c:	898fc83a 	sub	r7,r17,r6
 200cb60:	89e3803a 	cmpltu	r17,r17,r7
 200cb64:	1947c83a 	sub	r3,r3,r5
 200cb68:	1c47c83a 	sub	r3,r3,r17
 200cb6c:	3823883a 	mov	r17,r7
 200cb70:	003f9b06 	br	200c9e0 <__alt_mem_mem_0+0xfcfec9e0>
 200cb74:	2988b03a 	or	r4,r5,r6
 200cb78:	203f5c26 	beq	r4,zero,200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cb7c:	10bfffc4 	addi	r2,r2,-1
 200cb80:	1000931e 	bne	r2,zero,200cdd0 <__subdf3+0x568>
 200cb84:	898d883a 	add	r6,r17,r6
 200cb88:	3463803a 	cmpltu	r17,r6,r17
 200cb8c:	1947883a 	add	r3,r3,r5
 200cb90:	88c7883a 	add	r3,r17,r3
 200cb94:	3023883a 	mov	r17,r6
 200cb98:	003fd306 	br	200cae8 <__alt_mem_mem_0+0xfcfecae8>
 200cb9c:	1000541e 	bne	r2,zero,200ccf0 <__subdf3+0x488>
 200cba0:	80800044 	addi	r2,r16,1
 200cba4:	1081ffcc 	andi	r2,r2,2047
 200cba8:	01000044 	movi	r4,1
 200cbac:	2080a20e 	bge	r4,r2,200ce38 <__subdf3+0x5d0>
 200cbb0:	8989c83a 	sub	r4,r17,r6
 200cbb4:	8905803a 	cmpltu	r2,r17,r4
 200cbb8:	1967c83a 	sub	r19,r3,r5
 200cbbc:	98a7c83a 	sub	r19,r19,r2
 200cbc0:	9880202c 	andhi	r2,r19,128
 200cbc4:	10006326 	beq	r2,zero,200cd54 <__subdf3+0x4ec>
 200cbc8:	3463c83a 	sub	r17,r6,r17
 200cbcc:	28c7c83a 	sub	r3,r5,r3
 200cbd0:	344d803a 	cmpltu	r6,r6,r17
 200cbd4:	19a7c83a 	sub	r19,r3,r6
 200cbd8:	3825883a 	mov	r18,r7
 200cbdc:	983f861e 	bne	r19,zero,200c9f8 <__alt_mem_mem_0+0xfcfec9f8>
 200cbe0:	8809883a 	mov	r4,r17
 200cbe4:	200d3680 	call	200d368 <__clzsi2>
 200cbe8:	10800804 	addi	r2,r2,32
 200cbec:	113ffe04 	addi	r4,r2,-8
 200cbf0:	00c007c4 	movi	r3,31
 200cbf4:	193f850e 	bge	r3,r4,200ca0c <__alt_mem_mem_0+0xfcfeca0c>
 200cbf8:	10bff604 	addi	r2,r2,-40
 200cbfc:	8884983a 	sll	r2,r17,r2
 200cc00:	0023883a 	mov	r17,zero
 200cc04:	243f880e 	bge	r4,r16,200ca28 <__alt_mem_mem_0+0xfcfeca28>
 200cc08:	00ffe034 	movhi	r3,65408
 200cc0c:	18ffffc4 	addi	r3,r3,-1
 200cc10:	8121c83a 	sub	r16,r16,r4
 200cc14:	10c6703a 	and	r3,r2,r3
 200cc18:	003f3406 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cc1c:	9100004c 	andi	r4,r18,1
 200cc20:	000b883a 	mov	r5,zero
 200cc24:	0005883a 	mov	r2,zero
 200cc28:	003f4806 	br	200c94c <__alt_mem_mem_0+0xfcfec94c>
 200cc2c:	298cb03a 	or	r6,r5,r6
 200cc30:	300cc03a 	cmpne	r6,r6,zero
 200cc34:	0005883a 	mov	r2,zero
 200cc38:	003f6406 	br	200c9cc <__alt_mem_mem_0+0xfcfec9cc>
 200cc3c:	10009a1e 	bne	r2,zero,200cea8 <__subdf3+0x640>
 200cc40:	82400044 	addi	r9,r16,1
 200cc44:	4881ffcc 	andi	r2,r9,2047
 200cc48:	02800044 	movi	r10,1
 200cc4c:	5080670e 	bge	r10,r2,200cdec <__subdf3+0x584>
 200cc50:	0081ffc4 	movi	r2,2047
 200cc54:	4880af26 	beq	r9,r2,200cf14 <__subdf3+0x6ac>
 200cc58:	898d883a 	add	r6,r17,r6
 200cc5c:	1945883a 	add	r2,r3,r5
 200cc60:	3447803a 	cmpltu	r3,r6,r17
 200cc64:	1887883a 	add	r3,r3,r2
 200cc68:	182297fa 	slli	r17,r3,31
 200cc6c:	300cd07a 	srli	r6,r6,1
 200cc70:	1806d07a 	srli	r3,r3,1
 200cc74:	4821883a 	mov	r16,r9
 200cc78:	89a2b03a 	or	r17,r17,r6
 200cc7c:	003f1b06 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cc80:	0101ffc4 	movi	r4,2047
 200cc84:	813f441e 	bne	r16,r4,200c998 <__alt_mem_mem_0+0xfcfec998>
 200cc88:	003f1806 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cc8c:	843ff844 	addi	r16,r16,-31
 200cc90:	01400804 	movi	r5,32
 200cc94:	1408d83a 	srl	r4,r2,r16
 200cc98:	19405026 	beq	r3,r5,200cddc <__subdf3+0x574>
 200cc9c:	01401004 	movi	r5,64
 200cca0:	28c7c83a 	sub	r3,r5,r3
 200cca4:	10c4983a 	sll	r2,r2,r3
 200cca8:	88a2b03a 	or	r17,r17,r2
 200ccac:	8822c03a 	cmpne	r17,r17,zero
 200ccb0:	2462b03a 	or	r17,r4,r17
 200ccb4:	0007883a 	mov	r3,zero
 200ccb8:	0021883a 	mov	r16,zero
 200ccbc:	003f6d06 	br	200ca74 <__alt_mem_mem_0+0xfcfeca74>
 200ccc0:	11fff804 	addi	r7,r2,-32
 200ccc4:	01000804 	movi	r4,32
 200ccc8:	29ced83a 	srl	r7,r5,r7
 200cccc:	11004526 	beq	r2,r4,200cde4 <__subdf3+0x57c>
 200ccd0:	01001004 	movi	r4,64
 200ccd4:	2089c83a 	sub	r4,r4,r2
 200ccd8:	2904983a 	sll	r2,r5,r4
 200ccdc:	118cb03a 	or	r6,r2,r6
 200cce0:	300cc03a 	cmpne	r6,r6,zero
 200cce4:	398cb03a 	or	r6,r7,r6
 200cce8:	0005883a 	mov	r2,zero
 200ccec:	003f3706 	br	200c9cc <__alt_mem_mem_0+0xfcfec9cc>
 200ccf0:	80002a26 	beq	r16,zero,200cd9c <__subdf3+0x534>
 200ccf4:	0101ffc4 	movi	r4,2047
 200ccf8:	49006626 	beq	r9,r4,200ce94 <__subdf3+0x62c>
 200ccfc:	0085c83a 	sub	r2,zero,r2
 200cd00:	18c02034 	orhi	r3,r3,128
 200cd04:	01000e04 	movi	r4,56
 200cd08:	20807e16 	blt	r4,r2,200cf04 <__subdf3+0x69c>
 200cd0c:	010007c4 	movi	r4,31
 200cd10:	2080e716 	blt	r4,r2,200d0b0 <__subdf3+0x848>
 200cd14:	01000804 	movi	r4,32
 200cd18:	2089c83a 	sub	r4,r4,r2
 200cd1c:	1914983a 	sll	r10,r3,r4
 200cd20:	8890d83a 	srl	r8,r17,r2
 200cd24:	8908983a 	sll	r4,r17,r4
 200cd28:	1884d83a 	srl	r2,r3,r2
 200cd2c:	5222b03a 	or	r17,r10,r8
 200cd30:	2006c03a 	cmpne	r3,r4,zero
 200cd34:	88e2b03a 	or	r17,r17,r3
 200cd38:	3463c83a 	sub	r17,r6,r17
 200cd3c:	2885c83a 	sub	r2,r5,r2
 200cd40:	344d803a 	cmpltu	r6,r6,r17
 200cd44:	1187c83a 	sub	r3,r2,r6
 200cd48:	4821883a 	mov	r16,r9
 200cd4c:	3825883a 	mov	r18,r7
 200cd50:	003f2306 	br	200c9e0 <__alt_mem_mem_0+0xfcfec9e0>
 200cd54:	24d0b03a 	or	r8,r4,r19
 200cd58:	40001b1e 	bne	r8,zero,200cdc8 <__subdf3+0x560>
 200cd5c:	0005883a 	mov	r2,zero
 200cd60:	0009883a 	mov	r4,zero
 200cd64:	0021883a 	mov	r16,zero
 200cd68:	003f4906 	br	200ca90 <__alt_mem_mem_0+0xfcfeca90>
 200cd6c:	010007c4 	movi	r4,31
 200cd70:	20803a16 	blt	r4,r2,200ce5c <__subdf3+0x5f4>
 200cd74:	01000804 	movi	r4,32
 200cd78:	2089c83a 	sub	r4,r4,r2
 200cd7c:	2912983a 	sll	r9,r5,r4
 200cd80:	3090d83a 	srl	r8,r6,r2
 200cd84:	3108983a 	sll	r4,r6,r4
 200cd88:	2884d83a 	srl	r2,r5,r2
 200cd8c:	4a12b03a 	or	r9,r9,r8
 200cd90:	2008c03a 	cmpne	r4,r4,zero
 200cd94:	4912b03a 	or	r9,r9,r4
 200cd98:	003f4e06 	br	200cad4 <__alt_mem_mem_0+0xfcfecad4>
 200cd9c:	1c48b03a 	or	r4,r3,r17
 200cda0:	20003c26 	beq	r4,zero,200ce94 <__subdf3+0x62c>
 200cda4:	0084303a 	nor	r2,zero,r2
 200cda8:	1000381e 	bne	r2,zero,200ce8c <__subdf3+0x624>
 200cdac:	3463c83a 	sub	r17,r6,r17
 200cdb0:	28c5c83a 	sub	r2,r5,r3
 200cdb4:	344d803a 	cmpltu	r6,r6,r17
 200cdb8:	1187c83a 	sub	r3,r2,r6
 200cdbc:	4821883a 	mov	r16,r9
 200cdc0:	3825883a 	mov	r18,r7
 200cdc4:	003f0606 	br	200c9e0 <__alt_mem_mem_0+0xfcfec9e0>
 200cdc8:	2023883a 	mov	r17,r4
 200cdcc:	003f0906 	br	200c9f4 <__alt_mem_mem_0+0xfcfec9f4>
 200cdd0:	0101ffc4 	movi	r4,2047
 200cdd4:	813f3a1e 	bne	r16,r4,200cac0 <__alt_mem_mem_0+0xfcfecac0>
 200cdd8:	003ec406 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cddc:	0005883a 	mov	r2,zero
 200cde0:	003fb106 	br	200cca8 <__alt_mem_mem_0+0xfcfecca8>
 200cde4:	0005883a 	mov	r2,zero
 200cde8:	003fbc06 	br	200ccdc <__alt_mem_mem_0+0xfcfeccdc>
 200cdec:	1c44b03a 	or	r2,r3,r17
 200cdf0:	80008e1e 	bne	r16,zero,200d02c <__subdf3+0x7c4>
 200cdf4:	1000c826 	beq	r2,zero,200d118 <__subdf3+0x8b0>
 200cdf8:	2984b03a 	or	r2,r5,r6
 200cdfc:	103ebb26 	beq	r2,zero,200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200ce00:	8989883a 	add	r4,r17,r6
 200ce04:	1945883a 	add	r2,r3,r5
 200ce08:	2447803a 	cmpltu	r3,r4,r17
 200ce0c:	1887883a 	add	r3,r3,r2
 200ce10:	1880202c 	andhi	r2,r3,128
 200ce14:	2023883a 	mov	r17,r4
 200ce18:	103f1626 	beq	r2,zero,200ca74 <__alt_mem_mem_0+0xfcfeca74>
 200ce1c:	00bfe034 	movhi	r2,65408
 200ce20:	10bfffc4 	addi	r2,r2,-1
 200ce24:	5021883a 	mov	r16,r10
 200ce28:	1886703a 	and	r3,r3,r2
 200ce2c:	003eaf06 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200ce30:	3825883a 	mov	r18,r7
 200ce34:	003f0f06 	br	200ca74 <__alt_mem_mem_0+0xfcfeca74>
 200ce38:	1c44b03a 	or	r2,r3,r17
 200ce3c:	8000251e 	bne	r16,zero,200ced4 <__subdf3+0x66c>
 200ce40:	1000661e 	bne	r2,zero,200cfdc <__subdf3+0x774>
 200ce44:	2990b03a 	or	r8,r5,r6
 200ce48:	40009626 	beq	r8,zero,200d0a4 <__subdf3+0x83c>
 200ce4c:	2807883a 	mov	r3,r5
 200ce50:	3023883a 	mov	r17,r6
 200ce54:	3825883a 	mov	r18,r7
 200ce58:	003ea406 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200ce5c:	127ff804 	addi	r9,r2,-32
 200ce60:	01000804 	movi	r4,32
 200ce64:	2a52d83a 	srl	r9,r5,r9
 200ce68:	11008c26 	beq	r2,r4,200d09c <__subdf3+0x834>
 200ce6c:	01001004 	movi	r4,64
 200ce70:	2085c83a 	sub	r2,r4,r2
 200ce74:	2884983a 	sll	r2,r5,r2
 200ce78:	118cb03a 	or	r6,r2,r6
 200ce7c:	300cc03a 	cmpne	r6,r6,zero
 200ce80:	4992b03a 	or	r9,r9,r6
 200ce84:	0005883a 	mov	r2,zero
 200ce88:	003f1206 	br	200cad4 <__alt_mem_mem_0+0xfcfecad4>
 200ce8c:	0101ffc4 	movi	r4,2047
 200ce90:	493f9c1e 	bne	r9,r4,200cd04 <__alt_mem_mem_0+0xfcfecd04>
 200ce94:	2807883a 	mov	r3,r5
 200ce98:	3023883a 	mov	r17,r6
 200ce9c:	4821883a 	mov	r16,r9
 200cea0:	3825883a 	mov	r18,r7
 200cea4:	003e9106 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cea8:	80001f1e 	bne	r16,zero,200cf28 <__subdf3+0x6c0>
 200ceac:	1c48b03a 	or	r4,r3,r17
 200ceb0:	20005a26 	beq	r4,zero,200d01c <__subdf3+0x7b4>
 200ceb4:	0084303a 	nor	r2,zero,r2
 200ceb8:	1000561e 	bne	r2,zero,200d014 <__subdf3+0x7ac>
 200cebc:	89a3883a 	add	r17,r17,r6
 200cec0:	1945883a 	add	r2,r3,r5
 200cec4:	898d803a 	cmpltu	r6,r17,r6
 200cec8:	3087883a 	add	r3,r6,r2
 200cecc:	4821883a 	mov	r16,r9
 200ced0:	003f0506 	br	200cae8 <__alt_mem_mem_0+0xfcfecae8>
 200ced4:	10002b1e 	bne	r2,zero,200cf84 <__subdf3+0x71c>
 200ced8:	2984b03a 	or	r2,r5,r6
 200cedc:	10008026 	beq	r2,zero,200d0e0 <__subdf3+0x878>
 200cee0:	2807883a 	mov	r3,r5
 200cee4:	3023883a 	mov	r17,r6
 200cee8:	3825883a 	mov	r18,r7
 200ceec:	0401ffc4 	movi	r16,2047
 200cef0:	003e7e06 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cef4:	3809883a 	mov	r4,r7
 200cef8:	0011883a 	mov	r8,zero
 200cefc:	0005883a 	mov	r2,zero
 200cf00:	003ee306 	br	200ca90 <__alt_mem_mem_0+0xfcfeca90>
 200cf04:	1c62b03a 	or	r17,r3,r17
 200cf08:	8822c03a 	cmpne	r17,r17,zero
 200cf0c:	0005883a 	mov	r2,zero
 200cf10:	003f8906 	br	200cd38 <__alt_mem_mem_0+0xfcfecd38>
 200cf14:	3809883a 	mov	r4,r7
 200cf18:	4821883a 	mov	r16,r9
 200cf1c:	0011883a 	mov	r8,zero
 200cf20:	0005883a 	mov	r2,zero
 200cf24:	003eda06 	br	200ca90 <__alt_mem_mem_0+0xfcfeca90>
 200cf28:	0101ffc4 	movi	r4,2047
 200cf2c:	49003b26 	beq	r9,r4,200d01c <__subdf3+0x7b4>
 200cf30:	0085c83a 	sub	r2,zero,r2
 200cf34:	18c02034 	orhi	r3,r3,128
 200cf38:	01000e04 	movi	r4,56
 200cf3c:	20806e16 	blt	r4,r2,200d0f8 <__subdf3+0x890>
 200cf40:	010007c4 	movi	r4,31
 200cf44:	20807716 	blt	r4,r2,200d124 <__subdf3+0x8bc>
 200cf48:	01000804 	movi	r4,32
 200cf4c:	2089c83a 	sub	r4,r4,r2
 200cf50:	1914983a 	sll	r10,r3,r4
 200cf54:	8890d83a 	srl	r8,r17,r2
 200cf58:	8908983a 	sll	r4,r17,r4
 200cf5c:	1884d83a 	srl	r2,r3,r2
 200cf60:	5222b03a 	or	r17,r10,r8
 200cf64:	2006c03a 	cmpne	r3,r4,zero
 200cf68:	88e2b03a 	or	r17,r17,r3
 200cf6c:	89a3883a 	add	r17,r17,r6
 200cf70:	1145883a 	add	r2,r2,r5
 200cf74:	898d803a 	cmpltu	r6,r17,r6
 200cf78:	3087883a 	add	r3,r6,r2
 200cf7c:	4821883a 	mov	r16,r9
 200cf80:	003ed906 	br	200cae8 <__alt_mem_mem_0+0xfcfecae8>
 200cf84:	2984b03a 	or	r2,r5,r6
 200cf88:	10004226 	beq	r2,zero,200d094 <__subdf3+0x82c>
 200cf8c:	1808d0fa 	srli	r4,r3,3
 200cf90:	8822d0fa 	srli	r17,r17,3
 200cf94:	1806977a 	slli	r3,r3,29
 200cf98:	2080022c 	andhi	r2,r4,8
 200cf9c:	1c62b03a 	or	r17,r3,r17
 200cfa0:	10000826 	beq	r2,zero,200cfc4 <__subdf3+0x75c>
 200cfa4:	2812d0fa 	srli	r9,r5,3
 200cfa8:	4880022c 	andhi	r2,r9,8
 200cfac:	1000051e 	bne	r2,zero,200cfc4 <__subdf3+0x75c>
 200cfb0:	300cd0fa 	srli	r6,r6,3
 200cfb4:	2804977a 	slli	r2,r5,29
 200cfb8:	4809883a 	mov	r4,r9
 200cfbc:	3825883a 	mov	r18,r7
 200cfc0:	11a2b03a 	or	r17,r2,r6
 200cfc4:	8806d77a 	srli	r3,r17,29
 200cfc8:	200890fa 	slli	r4,r4,3
 200cfcc:	882290fa 	slli	r17,r17,3
 200cfd0:	0401ffc4 	movi	r16,2047
 200cfd4:	1906b03a 	or	r3,r3,r4
 200cfd8:	003e4406 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cfdc:	2984b03a 	or	r2,r5,r6
 200cfe0:	103e4226 	beq	r2,zero,200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200cfe4:	8989c83a 	sub	r4,r17,r6
 200cfe8:	8911803a 	cmpltu	r8,r17,r4
 200cfec:	1945c83a 	sub	r2,r3,r5
 200cff0:	1205c83a 	sub	r2,r2,r8
 200cff4:	1200202c 	andhi	r8,r2,128
 200cff8:	403e9a26 	beq	r8,zero,200ca64 <__alt_mem_mem_0+0xfcfeca64>
 200cffc:	3463c83a 	sub	r17,r6,r17
 200d000:	28c5c83a 	sub	r2,r5,r3
 200d004:	344d803a 	cmpltu	r6,r6,r17
 200d008:	1187c83a 	sub	r3,r2,r6
 200d00c:	3825883a 	mov	r18,r7
 200d010:	003e3606 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d014:	0101ffc4 	movi	r4,2047
 200d018:	493fc71e 	bne	r9,r4,200cf38 <__alt_mem_mem_0+0xfcfecf38>
 200d01c:	2807883a 	mov	r3,r5
 200d020:	3023883a 	mov	r17,r6
 200d024:	4821883a 	mov	r16,r9
 200d028:	003e3006 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d02c:	10003626 	beq	r2,zero,200d108 <__subdf3+0x8a0>
 200d030:	2984b03a 	or	r2,r5,r6
 200d034:	10001726 	beq	r2,zero,200d094 <__subdf3+0x82c>
 200d038:	1808d0fa 	srli	r4,r3,3
 200d03c:	8822d0fa 	srli	r17,r17,3
 200d040:	1806977a 	slli	r3,r3,29
 200d044:	2080022c 	andhi	r2,r4,8
 200d048:	1c62b03a 	or	r17,r3,r17
 200d04c:	10000726 	beq	r2,zero,200d06c <__subdf3+0x804>
 200d050:	2812d0fa 	srli	r9,r5,3
 200d054:	4880022c 	andhi	r2,r9,8
 200d058:	1000041e 	bne	r2,zero,200d06c <__subdf3+0x804>
 200d05c:	300cd0fa 	srli	r6,r6,3
 200d060:	2804977a 	slli	r2,r5,29
 200d064:	4809883a 	mov	r4,r9
 200d068:	11a2b03a 	or	r17,r2,r6
 200d06c:	8806d77a 	srli	r3,r17,29
 200d070:	200890fa 	slli	r4,r4,3
 200d074:	882290fa 	slli	r17,r17,3
 200d078:	3825883a 	mov	r18,r7
 200d07c:	1906b03a 	or	r3,r3,r4
 200d080:	0401ffc4 	movi	r16,2047
 200d084:	003e1906 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d088:	000b883a 	mov	r5,zero
 200d08c:	0005883a 	mov	r2,zero
 200d090:	003e2e06 	br	200c94c <__alt_mem_mem_0+0xfcfec94c>
 200d094:	0401ffc4 	movi	r16,2047
 200d098:	003e1406 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d09c:	0005883a 	mov	r2,zero
 200d0a0:	003f7506 	br	200ce78 <__alt_mem_mem_0+0xfcfece78>
 200d0a4:	0005883a 	mov	r2,zero
 200d0a8:	0009883a 	mov	r4,zero
 200d0ac:	003e7806 	br	200ca90 <__alt_mem_mem_0+0xfcfeca90>
 200d0b0:	123ff804 	addi	r8,r2,-32
 200d0b4:	01000804 	movi	r4,32
 200d0b8:	1a10d83a 	srl	r8,r3,r8
 200d0bc:	11002526 	beq	r2,r4,200d154 <__subdf3+0x8ec>
 200d0c0:	01001004 	movi	r4,64
 200d0c4:	2085c83a 	sub	r2,r4,r2
 200d0c8:	1884983a 	sll	r2,r3,r2
 200d0cc:	1444b03a 	or	r2,r2,r17
 200d0d0:	1004c03a 	cmpne	r2,r2,zero
 200d0d4:	40a2b03a 	or	r17,r8,r2
 200d0d8:	0005883a 	mov	r2,zero
 200d0dc:	003f1606 	br	200cd38 <__alt_mem_mem_0+0xfcfecd38>
 200d0e0:	02000434 	movhi	r8,16
 200d0e4:	0009883a 	mov	r4,zero
 200d0e8:	423fffc4 	addi	r8,r8,-1
 200d0ec:	00bfffc4 	movi	r2,-1
 200d0f0:	0401ffc4 	movi	r16,2047
 200d0f4:	003e6606 	br	200ca90 <__alt_mem_mem_0+0xfcfeca90>
 200d0f8:	1c62b03a 	or	r17,r3,r17
 200d0fc:	8822c03a 	cmpne	r17,r17,zero
 200d100:	0005883a 	mov	r2,zero
 200d104:	003f9906 	br	200cf6c <__alt_mem_mem_0+0xfcfecf6c>
 200d108:	2807883a 	mov	r3,r5
 200d10c:	3023883a 	mov	r17,r6
 200d110:	0401ffc4 	movi	r16,2047
 200d114:	003df506 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d118:	2807883a 	mov	r3,r5
 200d11c:	3023883a 	mov	r17,r6
 200d120:	003df206 	br	200c8ec <__alt_mem_mem_0+0xfcfec8ec>
 200d124:	123ff804 	addi	r8,r2,-32
 200d128:	01000804 	movi	r4,32
 200d12c:	1a10d83a 	srl	r8,r3,r8
 200d130:	11000a26 	beq	r2,r4,200d15c <__subdf3+0x8f4>
 200d134:	01001004 	movi	r4,64
 200d138:	2085c83a 	sub	r2,r4,r2
 200d13c:	1884983a 	sll	r2,r3,r2
 200d140:	1444b03a 	or	r2,r2,r17
 200d144:	1004c03a 	cmpne	r2,r2,zero
 200d148:	40a2b03a 	or	r17,r8,r2
 200d14c:	0005883a 	mov	r2,zero
 200d150:	003f8606 	br	200cf6c <__alt_mem_mem_0+0xfcfecf6c>
 200d154:	0005883a 	mov	r2,zero
 200d158:	003fdc06 	br	200d0cc <__alt_mem_mem_0+0xfcfed0cc>
 200d15c:	0005883a 	mov	r2,zero
 200d160:	003ff706 	br	200d140 <__alt_mem_mem_0+0xfcfed140>

0200d164 <__fixdfsi>:
 200d164:	280cd53a 	srli	r6,r5,20
 200d168:	00c00434 	movhi	r3,16
 200d16c:	18ffffc4 	addi	r3,r3,-1
 200d170:	3181ffcc 	andi	r6,r6,2047
 200d174:	01c0ff84 	movi	r7,1022
 200d178:	28c6703a 	and	r3,r5,r3
 200d17c:	280ad7fa 	srli	r5,r5,31
 200d180:	3980120e 	bge	r7,r6,200d1cc <__fixdfsi+0x68>
 200d184:	00810744 	movi	r2,1053
 200d188:	11800c16 	blt	r2,r6,200d1bc <__fixdfsi+0x58>
 200d18c:	00810cc4 	movi	r2,1075
 200d190:	1185c83a 	sub	r2,r2,r6
 200d194:	01c007c4 	movi	r7,31
 200d198:	18c00434 	orhi	r3,r3,16
 200d19c:	38800d16 	blt	r7,r2,200d1d4 <__fixdfsi+0x70>
 200d1a0:	31befb44 	addi	r6,r6,-1043
 200d1a4:	2084d83a 	srl	r2,r4,r2
 200d1a8:	1986983a 	sll	r3,r3,r6
 200d1ac:	1884b03a 	or	r2,r3,r2
 200d1b0:	28000726 	beq	r5,zero,200d1d0 <__fixdfsi+0x6c>
 200d1b4:	0085c83a 	sub	r2,zero,r2
 200d1b8:	f800283a 	ret
 200d1bc:	00a00034 	movhi	r2,32768
 200d1c0:	10bfffc4 	addi	r2,r2,-1
 200d1c4:	2885883a 	add	r2,r5,r2
 200d1c8:	f800283a 	ret
 200d1cc:	0005883a 	mov	r2,zero
 200d1d0:	f800283a 	ret
 200d1d4:	008104c4 	movi	r2,1043
 200d1d8:	1185c83a 	sub	r2,r2,r6
 200d1dc:	1884d83a 	srl	r2,r3,r2
 200d1e0:	003ff306 	br	200d1b0 <__alt_mem_mem_0+0xfcfed1b0>

0200d1e4 <__floatsidf>:
 200d1e4:	defffd04 	addi	sp,sp,-12
 200d1e8:	dfc00215 	stw	ra,8(sp)
 200d1ec:	dc400115 	stw	r17,4(sp)
 200d1f0:	dc000015 	stw	r16,0(sp)
 200d1f4:	20002b26 	beq	r4,zero,200d2a4 <__floatsidf+0xc0>
 200d1f8:	2023883a 	mov	r17,r4
 200d1fc:	2020d7fa 	srli	r16,r4,31
 200d200:	20002d16 	blt	r4,zero,200d2b8 <__floatsidf+0xd4>
 200d204:	8809883a 	mov	r4,r17
 200d208:	200d3680 	call	200d368 <__clzsi2>
 200d20c:	01410784 	movi	r5,1054
 200d210:	288bc83a 	sub	r5,r5,r2
 200d214:	01010cc4 	movi	r4,1075
 200d218:	2149c83a 	sub	r4,r4,r5
 200d21c:	00c007c4 	movi	r3,31
 200d220:	1900160e 	bge	r3,r4,200d27c <__floatsidf+0x98>
 200d224:	00c104c4 	movi	r3,1043
 200d228:	1947c83a 	sub	r3,r3,r5
 200d22c:	88c6983a 	sll	r3,r17,r3
 200d230:	00800434 	movhi	r2,16
 200d234:	10bfffc4 	addi	r2,r2,-1
 200d238:	1886703a 	and	r3,r3,r2
 200d23c:	2941ffcc 	andi	r5,r5,2047
 200d240:	800d883a 	mov	r6,r16
 200d244:	0005883a 	mov	r2,zero
 200d248:	280a953a 	slli	r5,r5,20
 200d24c:	31803fcc 	andi	r6,r6,255
 200d250:	01000434 	movhi	r4,16
 200d254:	300c97fa 	slli	r6,r6,31
 200d258:	213fffc4 	addi	r4,r4,-1
 200d25c:	1906703a 	and	r3,r3,r4
 200d260:	1946b03a 	or	r3,r3,r5
 200d264:	1986b03a 	or	r3,r3,r6
 200d268:	dfc00217 	ldw	ra,8(sp)
 200d26c:	dc400117 	ldw	r17,4(sp)
 200d270:	dc000017 	ldw	r16,0(sp)
 200d274:	dec00304 	addi	sp,sp,12
 200d278:	f800283a 	ret
 200d27c:	00c002c4 	movi	r3,11
 200d280:	1887c83a 	sub	r3,r3,r2
 200d284:	88c6d83a 	srl	r3,r17,r3
 200d288:	8904983a 	sll	r2,r17,r4
 200d28c:	01000434 	movhi	r4,16
 200d290:	213fffc4 	addi	r4,r4,-1
 200d294:	2941ffcc 	andi	r5,r5,2047
 200d298:	1906703a 	and	r3,r3,r4
 200d29c:	800d883a 	mov	r6,r16
 200d2a0:	003fe906 	br	200d248 <__alt_mem_mem_0+0xfcfed248>
 200d2a4:	000d883a 	mov	r6,zero
 200d2a8:	000b883a 	mov	r5,zero
 200d2ac:	0007883a 	mov	r3,zero
 200d2b0:	0005883a 	mov	r2,zero
 200d2b4:	003fe406 	br	200d248 <__alt_mem_mem_0+0xfcfed248>
 200d2b8:	0123c83a 	sub	r17,zero,r4
 200d2bc:	003fd106 	br	200d204 <__alt_mem_mem_0+0xfcfed204>

0200d2c0 <__floatunsidf>:
 200d2c0:	defffe04 	addi	sp,sp,-8
 200d2c4:	dc000015 	stw	r16,0(sp)
 200d2c8:	dfc00115 	stw	ra,4(sp)
 200d2cc:	2021883a 	mov	r16,r4
 200d2d0:	20002226 	beq	r4,zero,200d35c <__floatunsidf+0x9c>
 200d2d4:	200d3680 	call	200d368 <__clzsi2>
 200d2d8:	01010784 	movi	r4,1054
 200d2dc:	2089c83a 	sub	r4,r4,r2
 200d2e0:	01810cc4 	movi	r6,1075
 200d2e4:	310dc83a 	sub	r6,r6,r4
 200d2e8:	00c007c4 	movi	r3,31
 200d2ec:	1980120e 	bge	r3,r6,200d338 <__floatunsidf+0x78>
 200d2f0:	00c104c4 	movi	r3,1043
 200d2f4:	1907c83a 	sub	r3,r3,r4
 200d2f8:	80ca983a 	sll	r5,r16,r3
 200d2fc:	00800434 	movhi	r2,16
 200d300:	10bfffc4 	addi	r2,r2,-1
 200d304:	2101ffcc 	andi	r4,r4,2047
 200d308:	0021883a 	mov	r16,zero
 200d30c:	288a703a 	and	r5,r5,r2
 200d310:	2008953a 	slli	r4,r4,20
 200d314:	00c00434 	movhi	r3,16
 200d318:	18ffffc4 	addi	r3,r3,-1
 200d31c:	28c6703a 	and	r3,r5,r3
 200d320:	8005883a 	mov	r2,r16
 200d324:	1906b03a 	or	r3,r3,r4
 200d328:	dfc00117 	ldw	ra,4(sp)
 200d32c:	dc000017 	ldw	r16,0(sp)
 200d330:	dec00204 	addi	sp,sp,8
 200d334:	f800283a 	ret
 200d338:	00c002c4 	movi	r3,11
 200d33c:	188bc83a 	sub	r5,r3,r2
 200d340:	814ad83a 	srl	r5,r16,r5
 200d344:	00c00434 	movhi	r3,16
 200d348:	18ffffc4 	addi	r3,r3,-1
 200d34c:	81a0983a 	sll	r16,r16,r6
 200d350:	2101ffcc 	andi	r4,r4,2047
 200d354:	28ca703a 	and	r5,r5,r3
 200d358:	003fed06 	br	200d310 <__alt_mem_mem_0+0xfcfed310>
 200d35c:	0009883a 	mov	r4,zero
 200d360:	000b883a 	mov	r5,zero
 200d364:	003fea06 	br	200d310 <__alt_mem_mem_0+0xfcfed310>

0200d368 <__clzsi2>:
 200d368:	00bfffd4 	movui	r2,65535
 200d36c:	11000536 	bltu	r2,r4,200d384 <__clzsi2+0x1c>
 200d370:	00803fc4 	movi	r2,255
 200d374:	11000f36 	bltu	r2,r4,200d3b4 <__clzsi2+0x4c>
 200d378:	00800804 	movi	r2,32
 200d37c:	0007883a 	mov	r3,zero
 200d380:	00000506 	br	200d398 <__clzsi2+0x30>
 200d384:	00804034 	movhi	r2,256
 200d388:	10bfffc4 	addi	r2,r2,-1
 200d38c:	11000c2e 	bgeu	r2,r4,200d3c0 <__clzsi2+0x58>
 200d390:	00800204 	movi	r2,8
 200d394:	00c00604 	movi	r3,24
 200d398:	20c8d83a 	srl	r4,r4,r3
 200d39c:	00c08134 	movhi	r3,516
 200d3a0:	18c43704 	addi	r3,r3,4316
 200d3a4:	1909883a 	add	r4,r3,r4
 200d3a8:	20c00003 	ldbu	r3,0(r4)
 200d3ac:	10c5c83a 	sub	r2,r2,r3
 200d3b0:	f800283a 	ret
 200d3b4:	00800604 	movi	r2,24
 200d3b8:	00c00204 	movi	r3,8
 200d3bc:	003ff606 	br	200d398 <__alt_mem_mem_0+0xfcfed398>
 200d3c0:	00800404 	movi	r2,16
 200d3c4:	1007883a 	mov	r3,r2
 200d3c8:	003ff306 	br	200d398 <__alt_mem_mem_0+0xfcfed398>

0200d3cc <pre_constructors>:
/*
 * We want this pre_constructors and post_constructors functions to be called when it is defined by the user, if the user didn't define it
 * we don't want a link error, just call this empty function
 */
void __attribute__((weak)) pre_constructors()
{
 200d3cc:	deffff04 	addi	sp,sp,-4
 200d3d0:	df000015 	stw	fp,0(sp)
 200d3d4:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 200d3d8:	0001883a 	nop
 200d3dc:	e037883a 	mov	sp,fp
 200d3e0:	df000017 	ldw	fp,0(sp)
 200d3e4:	dec00104 	addi	sp,sp,4
 200d3e8:	f800283a 	ret

0200d3ec <post_constructors>:

void __attribute__((weak)) post_constructors()
{
 200d3ec:	deffff04 	addi	sp,sp,-4
 200d3f0:	df000015 	stw	fp,0(sp)
 200d3f4:	d839883a 	mov	fp,sp
	// nothing to do here... may be overloaded by the application
}
 200d3f8:	0001883a 	nop
 200d3fc:	e037883a 	mov	sp,fp
 200d400:	df000017 	ldw	fp,0(sp)
 200d404:	dec00104 	addi	sp,sp,4
 200d408:	f800283a 	ret

0200d40c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 200d40c:	defff904 	addi	sp,sp,-28
 200d410:	dfc00615 	stw	ra,24(sp)
 200d414:	df000515 	stw	fp,20(sp)
 200d418:	df000504 	addi	fp,sp,20
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 200d41c:	0009883a 	mov	r4,zero
 200d420:	20246380 	call	2024638 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 200d424:	01000104 	movi	r4,4
 200d428:	200d8340 	call	200d834 <xQueueCreateMutex>
 200d42c:	d0a7d215 	stw	r2,-24760(gp)
 200d430:	01000104 	movi	r4,4
 200d434:	200d8340 	call	200d834 <xQueueCreateMutex>
 200d438:	d0a80115 	stw	r2,-24572(gp)
 200d43c:	d0a7e704 	addi	r2,gp,-24676
 200d440:	e0bffc15 	stw	r2,-16(fp)
 200d444:	00800044 	movi	r2,1
 200d448:	e0bffd0d 	sth	r2,-12(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 200d44c:	e0bffd0b 	ldhu	r2,-12(fp)
 200d450:	10000226 	beq	r2,zero,200d45c <alt_main+0x50>
 200d454:	e0bffd0b 	ldhu	r2,-12(fp)
 200d458:	00000106 	br	200d460 <alt_main+0x54>
 200d45c:	00800044 	movi	r2,1
 200d460:	e0fffd0b 	ldhu	r3,-12(fp)
 200d464:	180b883a 	mov	r5,r3
 200d468:	1009883a 	mov	r4,r2
 200d46c:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 200d470:	1007883a 	mov	r3,r2
 200d474:	e0bffc17 	ldw	r2,-16(fp)
 200d478:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 200d47c:	20246700 	call	2024670 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 200d480:	01808134 	movhi	r6,516
 200d484:	31847704 	addi	r6,r6,4572
 200d488:	01408134 	movhi	r5,516
 200d48c:	29447704 	addi	r5,r5,4572
 200d490:	01008134 	movhi	r4,516
 200d494:	21047704 	addi	r4,r4,4572
 200d498:	201285c0 	call	201285c <alt_io_redirect>
#endif

  /*
   * Call the pre_constructors function
   */
  pre_constructors();
 200d49c:	200d3cc0 	call	200d3cc <pre_constructors>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 200d4a0:	20125ec0 	call	20125ec <_do_ctors>
#endif /* ALT_NO_C_PLUS_PLUS */

  /*
   * Call the post_constructors function
   */
  post_constructors();
 200d4a4:	200d3ec0 	call	200d3ec <post_constructors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 200d4a8:	01008074 	movhi	r4,513
 200d4ac:	21099304 	addi	r4,r4,9804
 200d4b0:	203cb9c0 	call	203cb9c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 200d4b4:	d0a7cf17 	ldw	r2,-24772(gp)
 200d4b8:	d0e7d017 	ldw	r3,-24768(gp)
 200d4bc:	d127d117 	ldw	r4,-24764(gp)
 200d4c0:	200d883a 	mov	r6,r4
 200d4c4:	180b883a 	mov	r5,r3
 200d4c8:	1009883a 	mov	r4,r2
 200d4cc:	2000a9c0 	call	2000a9c <main>
 200d4d0:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
 200d4d4:	01000044 	movi	r4,1
 200d4d8:	20131840 	call	2013184 <close>
  exit (result);
 200d4dc:	e13ffb17 	ldw	r4,-20(fp)
 200d4e0:	203cbb00 	call	203cbb0 <exit>

0200d4e4 <__malloc_lock>:
xSemaphoreHandle alt_heapsem;

/* __malloc_lock needs to provide recursive mutex locking */

void __malloc_lock ( struct _reent *_r )
{
 200d4e4:	defffd04 	addi	sp,sp,-12
 200d4e8:	dfc00215 	stw	ra,8(sp)
 200d4ec:	df000115 	stw	fp,4(sp)
 200d4f0:	df000104 	addi	fp,sp,4
 200d4f4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 200d4f8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200d4fc:	10000b26 	beq	r2,zero,200d52c <__malloc_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 200d500:	00000206 	br	200d50c <__malloc_lock+0x28>
		vTaskDelay(1);
 200d504:	01000044 	movi	r4,1
 200d508:	200f2640 	call	200f264 <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
 200d50c:	d0a7d217 	ldw	r2,-24760(gp)
 200d510:	01400284 	movi	r5,10
 200d514:	1009883a 	mov	r4,r2
 200d518:	200d9200 	call	200d920 <xQueueTakeMutexRecursive>
 200d51c:	10800058 	cmpnei	r2,r2,1
 200d520:	103ff81e 	bne	r2,zero,200d504 <__alt_mem_mem_0+0xfcfed504>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 200d524:	0001883a 	nop
 200d528:	00000106 	br	200d530 <__malloc_lock+0x4c>

void __malloc_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 200d52c:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_heapsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 200d530:	e037883a 	mov	sp,fp
 200d534:	dfc00117 	ldw	ra,4(sp)
 200d538:	df000017 	ldw	fp,0(sp)
 200d53c:	dec00204 	addi	sp,sp,8
 200d540:	f800283a 	ret

0200d544 <__malloc_unlock>:

/* __malloc_unlock needs to provide recursive mutex unlocking */

void __malloc_unlock ( struct _reent *_r )
{
 200d544:	defffd04 	addi	sp,sp,-12
 200d548:	dfc00215 	stw	ra,8(sp)
 200d54c:	df000115 	stw	fp,4(sp)
 200d550:	df000104 	addi	fp,sp,4
 200d554:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 200d558:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200d55c:	10000426 	beq	r2,zero,200d570 <__malloc_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_heapsem);
 200d560:	d0a7d217 	ldw	r2,-24760(gp)
 200d564:	1009883a 	mov	r4,r2
 200d568:	200d8900 	call	200d890 <xQueueGiveMutexRecursive>
 200d56c:	00000106 	br	200d574 <__malloc_unlock+0x30>

void __malloc_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 200d570:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_heapsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 200d574:	e037883a 	mov	sp,fp
 200d578:	dfc00117 	ldw	ra,4(sp)
 200d57c:	df000017 	ldw	fp,0(sp)
 200d580:	dec00204 	addi	sp,sp,8
 200d584:	f800283a 	ret

0200d588 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 200d588:	defffb04 	addi	sp,sp,-20
 200d58c:	dfc00415 	stw	ra,16(sp)
 200d590:	df000315 	stw	fp,12(sp)
 200d594:	df000304 	addi	fp,sp,12
 200d598:	e13ffe15 	stw	r4,-8(fp)
 200d59c:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = xQueue;
 200d5a0:	e0bffe17 	ldw	r2,-8(fp)
 200d5a4:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 200d5a8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200d5ac:	10000126 	beq	r2,zero,200d5b4 <xQueueGenericReset+0x2c>
 200d5b0:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d5b4:	e0bffd17 	ldw	r2,-12(fp)
 200d5b8:	10c00017 	ldw	r3,0(r2)
 200d5bc:	e0bffd17 	ldw	r2,-12(fp)
 200d5c0:	11000f17 	ldw	r4,60(r2)
 200d5c4:	e0bffd17 	ldw	r2,-12(fp)
 200d5c8:	10801017 	ldw	r2,64(r2)
 200d5cc:	2085383a 	mul	r2,r4,r2
 200d5d0:	1887883a 	add	r3,r3,r2
 200d5d4:	e0bffd17 	ldw	r2,-12(fp)
 200d5d8:	10c00215 	stw	r3,8(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 200d5dc:	e0bffd17 	ldw	r2,-12(fp)
 200d5e0:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 200d5e4:	e0bffd17 	ldw	r2,-12(fp)
 200d5e8:	10c00017 	ldw	r3,0(r2)
 200d5ec:	e0bffd17 	ldw	r2,-12(fp)
 200d5f0:	10c00115 	stw	r3,4(r2)
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d5f4:	e0bffd17 	ldw	r2,-12(fp)
 200d5f8:	10c00017 	ldw	r3,0(r2)
 200d5fc:	e0bffd17 	ldw	r2,-12(fp)
 200d600:	10800f17 	ldw	r2,60(r2)
 200d604:	113fffc4 	addi	r4,r2,-1
 200d608:	e0bffd17 	ldw	r2,-12(fp)
 200d60c:	10801017 	ldw	r2,64(r2)
 200d610:	2085383a 	mul	r2,r4,r2
 200d614:	1887883a 	add	r3,r3,r2
 200d618:	e0bffd17 	ldw	r2,-12(fp)
 200d61c:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 200d620:	e0bffd17 	ldw	r2,-12(fp)
 200d624:	00ffffc4 	movi	r3,-1
 200d628:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 200d62c:	e0bffd17 	ldw	r2,-12(fp)
 200d630:	00ffffc4 	movi	r3,-1
 200d634:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 200d638:	e0bfff17 	ldw	r2,-4(fp)
 200d63c:	10000a1e 	bne	r2,zero,200d668 <xQueueGenericReset+0xe0>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200d640:	e0bffd17 	ldw	r2,-12(fp)
 200d644:	10800417 	ldw	r2,16(r2)
 200d648:	10000f26 	beq	r2,zero,200d688 <xQueueGenericReset+0x100>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200d64c:	e0bffd17 	ldw	r2,-12(fp)
 200d650:	10800404 	addi	r2,r2,16
 200d654:	1009883a 	mov	r4,r2
 200d658:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200d65c:	10000a26 	beq	r2,zero,200d688 <xQueueGenericReset+0x100>
				{
					queueYIELD_IF_USING_PREEMPTION();
 200d660:	003b683a 	trap	0
 200d664:	00000806 	br	200d688 <xQueueGenericReset+0x100>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 200d668:	e0bffd17 	ldw	r2,-12(fp)
 200d66c:	10800404 	addi	r2,r2,16
 200d670:	1009883a 	mov	r4,r2
 200d674:	202bccc0 	call	202bccc <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 200d678:	e0bffd17 	ldw	r2,-12(fp)
 200d67c:	10800904 	addi	r2,r2,36
 200d680:	1009883a 	mov	r4,r2
 200d684:	202bccc0 	call	202bccc <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 200d688:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200d68c:	10000126 	beq	r2,zero,200d694 <xQueueGenericReset+0x10c>
 200d690:	2010f780 	call	2010f78 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 200d694:	00800044 	movi	r2,1
}
 200d698:	e037883a 	mov	sp,fp
 200d69c:	dfc00117 	ldw	ra,4(sp)
 200d6a0:	df000017 	ldw	fp,0(sp)
 200d6a4:	dec00204 	addi	sp,sp,8
 200d6a8:	f800283a 	ret

0200d6ac <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 200d6ac:	defff704 	addi	sp,sp,-36
 200d6b0:	dfc00815 	stw	ra,32(sp)
 200d6b4:	df000715 	stw	fp,28(sp)
 200d6b8:	df000704 	addi	fp,sp,28
 200d6bc:	e13ffd15 	stw	r4,-12(fp)
 200d6c0:	e17ffe15 	stw	r5,-8(fp)
 200d6c4:	3005883a 	mov	r2,r6
 200d6c8:	e0bfff05 	stb	r2,-4(fp)
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200d6cc:	e0fffd17 	ldw	r3,-12(fp)
 200d6d0:	e0bffe17 	ldw	r2,-8(fp)
 200d6d4:	1885383a 	mul	r2,r3,r2
 200d6d8:	e0bffa15 	stw	r2,-24(fp)
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 200d6dc:	e0bffa17 	ldw	r2,-24(fp)
 200d6e0:	10801404 	addi	r2,r2,80
 200d6e4:	1009883a 	mov	r4,r2
 200d6e8:	202bb8c0 	call	202bb8c <pvPortMalloc>
 200d6ec:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 200d6f0:	e0bffb17 	ldw	r2,-20(fp)
 200d6f4:	10000d26 	beq	r2,zero,200d72c <xQueueGenericCreate+0x80>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 200d6f8:	e0bffb17 	ldw	r2,-20(fp)
 200d6fc:	e0bffc15 	stw	r2,-16(fp)
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 200d700:	e0bffc17 	ldw	r2,-16(fp)
 200d704:	10801404 	addi	r2,r2,80
 200d708:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 200d70c:	e0ffff03 	ldbu	r3,-4(fp)
 200d710:	e0bffb17 	ldw	r2,-20(fp)
 200d714:	d8800015 	stw	r2,0(sp)
 200d718:	180f883a 	mov	r7,r3
 200d71c:	e1bffc17 	ldw	r6,-16(fp)
 200d720:	e17ffe17 	ldw	r5,-8(fp)
 200d724:	e13ffd17 	ldw	r4,-12(fp)
 200d728:	200d7440 	call	200d744 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 200d72c:	e0bffb17 	ldw	r2,-20(fp)
	}
 200d730:	e037883a 	mov	sp,fp
 200d734:	dfc00117 	ldw	ra,4(sp)
 200d738:	df000017 	ldw	fp,0(sp)
 200d73c:	dec00204 	addi	sp,sp,8
 200d740:	f800283a 	ret

0200d744 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 200d744:	defffa04 	addi	sp,sp,-24
 200d748:	dfc00515 	stw	ra,20(sp)
 200d74c:	df000415 	stw	fp,16(sp)
 200d750:	df000404 	addi	fp,sp,16
 200d754:	e13ffc15 	stw	r4,-16(fp)
 200d758:	e17ffd15 	stw	r5,-12(fp)
 200d75c:	e1bffe15 	stw	r6,-8(fp)
 200d760:	3805883a 	mov	r2,r7
 200d764:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 200d768:	e0bffd17 	ldw	r2,-12(fp)
 200d76c:	1000041e 	bne	r2,zero,200d780 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 200d770:	e0800217 	ldw	r2,8(fp)
 200d774:	e0c00217 	ldw	r3,8(fp)
 200d778:	10c00015 	stw	r3,0(r2)
 200d77c:	00000306 	br	200d78c <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 200d780:	e0800217 	ldw	r2,8(fp)
 200d784:	e0fffe17 	ldw	r3,-8(fp)
 200d788:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 200d78c:	e0800217 	ldw	r2,8(fp)
 200d790:	e0fffc17 	ldw	r3,-16(fp)
 200d794:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 200d798:	e0800217 	ldw	r2,8(fp)
 200d79c:	e0fffd17 	ldw	r3,-12(fp)
 200d7a0:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 200d7a4:	01400044 	movi	r5,1
 200d7a8:	e1000217 	ldw	r4,8(fp)
 200d7ac:	200d5880 	call	200d588 <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 200d7b0:	e0800217 	ldw	r2,8(fp)
 200d7b4:	e0ffff03 	ldbu	r3,-4(fp)
 200d7b8:	10c01305 	stb	r3,76(r2)
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 200d7bc:	0001883a 	nop
 200d7c0:	e037883a 	mov	sp,fp
 200d7c4:	dfc00117 	ldw	ra,4(sp)
 200d7c8:	df000017 	ldw	fp,0(sp)
 200d7cc:	dec00204 	addi	sp,sp,8
 200d7d0:	f800283a 	ret

0200d7d4 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 200d7d4:	defffd04 	addi	sp,sp,-12
 200d7d8:	dfc00215 	stw	ra,8(sp)
 200d7dc:	df000115 	stw	fp,4(sp)
 200d7e0:	df000104 	addi	fp,sp,4
 200d7e4:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 200d7e8:	e0bfff17 	ldw	r2,-4(fp)
 200d7ec:	10000b26 	beq	r2,zero,200d81c <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 200d7f0:	e0bfff17 	ldw	r2,-4(fp)
 200d7f4:	10000215 	stw	zero,8(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 200d7f8:	e0bfff17 	ldw	r2,-4(fp)
 200d7fc:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 200d800:	e0bfff17 	ldw	r2,-4(fp)
 200d804:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 200d808:	000f883a 	mov	r7,zero
 200d80c:	000d883a 	mov	r6,zero
 200d810:	000b883a 	mov	r5,zero
 200d814:	e13fff17 	ldw	r4,-4(fp)
 200d818:	200da140 	call	200da14 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 200d81c:	0001883a 	nop
 200d820:	e037883a 	mov	sp,fp
 200d824:	dfc00117 	ldw	ra,4(sp)
 200d828:	df000017 	ldw	fp,0(sp)
 200d82c:	dec00204 	addi	sp,sp,8
 200d830:	f800283a 	ret

0200d834 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 200d834:	defffa04 	addi	sp,sp,-24
 200d838:	dfc00515 	stw	ra,20(sp)
 200d83c:	df000415 	stw	fp,16(sp)
 200d840:	df000404 	addi	fp,sp,16
 200d844:	2005883a 	mov	r2,r4
 200d848:	e0bfff05 	stb	r2,-4(fp)
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 200d84c:	00800044 	movi	r2,1
 200d850:	e0bffc15 	stw	r2,-16(fp)
 200d854:	e03ffd15 	stw	zero,-12(fp)

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 200d858:	e0bfff03 	ldbu	r2,-4(fp)
 200d85c:	100d883a 	mov	r6,r2
 200d860:	e17ffd17 	ldw	r5,-12(fp)
 200d864:	e13ffc17 	ldw	r4,-16(fp)
 200d868:	200d6ac0 	call	200d6ac <xQueueGenericCreate>
 200d86c:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 200d870:	e13ffe17 	ldw	r4,-8(fp)
 200d874:	200d7d40 	call	200d7d4 <prvInitialiseMutex>

		return xNewQueue;
 200d878:	e0bffe17 	ldw	r2,-8(fp)
	}
 200d87c:	e037883a 	mov	sp,fp
 200d880:	dfc00117 	ldw	ra,4(sp)
 200d884:	df000017 	ldw	fp,0(sp)
 200d888:	dec00204 	addi	sp,sp,8
 200d88c:	f800283a 	ret

0200d890 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 200d890:	defffa04 	addi	sp,sp,-24
 200d894:	dfc00515 	stw	ra,20(sp)
 200d898:	df000415 	stw	fp,16(sp)
 200d89c:	dc000315 	stw	r16,12(sp)
 200d8a0:	df000404 	addi	fp,sp,16
 200d8a4:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 200d8a8:	e0bffe17 	ldw	r2,-8(fp)
 200d8ac:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 200d8b0:	e0bffd17 	ldw	r2,-12(fp)
 200d8b4:	14000217 	ldw	r16,8(r2)
 200d8b8:	2010b400 	call	2010b40 <xTaskGetCurrentTaskHandle>
 200d8bc:	8080101e 	bne	r16,r2,200d900 <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if xMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 200d8c0:	e0bffd17 	ldw	r2,-12(fp)
 200d8c4:	10800317 	ldw	r2,12(r2)
 200d8c8:	10ffffc4 	addi	r3,r2,-1
 200d8cc:	e0bffd17 	ldw	r2,-12(fp)
 200d8d0:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 200d8d4:	e0bffd17 	ldw	r2,-12(fp)
 200d8d8:	10800317 	ldw	r2,12(r2)
 200d8dc:	1000051e 	bne	r2,zero,200d8f4 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 200d8e0:	000f883a 	mov	r7,zero
 200d8e4:	000d883a 	mov	r6,zero
 200d8e8:	000b883a 	mov	r5,zero
 200d8ec:	e13ffd17 	ldw	r4,-12(fp)
 200d8f0:	200da140 	call	200da14 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 200d8f4:	00800044 	movi	r2,1
 200d8f8:	e0bffc15 	stw	r2,-16(fp)
 200d8fc:	00000106 	br	200d904 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 200d900:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 200d904:	e0bffc17 	ldw	r2,-16(fp)
	}
 200d908:	e6ffff04 	addi	sp,fp,-4
 200d90c:	dfc00217 	ldw	ra,8(sp)
 200d910:	df000117 	ldw	fp,4(sp)
 200d914:	dc000017 	ldw	r16,0(sp)
 200d918:	dec00304 	addi	sp,sp,12
 200d91c:	f800283a 	ret

0200d920 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 200d920:	defff904 	addi	sp,sp,-28
 200d924:	dfc00615 	stw	ra,24(sp)
 200d928:	df000515 	stw	fp,20(sp)
 200d92c:	dc000415 	stw	r16,16(sp)
 200d930:	df000504 	addi	fp,sp,20
 200d934:	e13ffd15 	stw	r4,-12(fp)
 200d938:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 200d93c:	e0bffd17 	ldw	r2,-12(fp)
 200d940:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 200d944:	e0bffc17 	ldw	r2,-16(fp)
 200d948:	14000217 	ldw	r16,8(r2)
 200d94c:	2010b400 	call	2010b40 <xTaskGetCurrentTaskHandle>
 200d950:	8080081e 	bne	r16,r2,200d974 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 200d954:	e0bffc17 	ldw	r2,-16(fp)
 200d958:	10800317 	ldw	r2,12(r2)
 200d95c:	10c00044 	addi	r3,r2,1
 200d960:	e0bffc17 	ldw	r2,-16(fp)
 200d964:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 200d968:	00800044 	movi	r2,1
 200d96c:	e0bffb15 	stw	r2,-20(fp)
 200d970:	00000b06 	br	200d9a0 <xQueueTakeMutexRecursive+0x80>
		}
		else
		{
			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 200d974:	e17ffe17 	ldw	r5,-8(fp)
 200d978:	e13ffc17 	ldw	r4,-16(fp)
 200d97c:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
 200d980:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 200d984:	e0bffb17 	ldw	r2,-20(fp)
 200d988:	10000526 	beq	r2,zero,200d9a0 <xQueueTakeMutexRecursive+0x80>
			{
				( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 200d98c:	e0bffc17 	ldw	r2,-16(fp)
 200d990:	10800317 	ldw	r2,12(r2)
 200d994:	10c00044 	addi	r3,r2,1
 200d998:	e0bffc17 	ldw	r2,-16(fp)
 200d99c:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 200d9a0:	e0bffb17 	ldw	r2,-20(fp)
	}
 200d9a4:	e6ffff04 	addi	sp,fp,-4
 200d9a8:	dfc00217 	ldw	ra,8(sp)
 200d9ac:	df000117 	ldw	fp,4(sp)
 200d9b0:	dc000017 	ldw	r16,0(sp)
 200d9b4:	dec00304 	addi	sp,sp,12
 200d9b8:	f800283a 	ret

0200d9bc <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 200d9bc:	defffb04 	addi	sp,sp,-20
 200d9c0:	dfc00415 	stw	ra,16(sp)
 200d9c4:	df000315 	stw	fp,12(sp)
 200d9c8:	df000304 	addi	fp,sp,12
 200d9cc:	e13ffe15 	stw	r4,-8(fp)
 200d9d0:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 200d9d4:	01800084 	movi	r6,2
 200d9d8:	000b883a 	mov	r5,zero
 200d9dc:	e13ffe17 	ldw	r4,-8(fp)
 200d9e0:	200d6ac0 	call	200d6ac <xQueueGenericCreate>
 200d9e4:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 200d9e8:	e0bffd17 	ldw	r2,-12(fp)
 200d9ec:	10000326 	beq	r2,zero,200d9fc <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 200d9f0:	e0bffd17 	ldw	r2,-12(fp)
 200d9f4:	e0ffff17 	ldw	r3,-4(fp)
 200d9f8:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 200d9fc:	e0bffd17 	ldw	r2,-12(fp)
	}
 200da00:	e037883a 	mov	sp,fp
 200da04:	dfc00117 	ldw	ra,4(sp)
 200da08:	df000017 	ldw	fp,0(sp)
 200da0c:	dec00204 	addi	sp,sp,8
 200da10:	f800283a 	ret

0200da14 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 200da14:	defff504 	addi	sp,sp,-44
 200da18:	dfc00a15 	stw	ra,40(sp)
 200da1c:	df000915 	stw	fp,36(sp)
 200da20:	df000904 	addi	fp,sp,36
 200da24:	e13ffc15 	stw	r4,-16(fp)
 200da28:	e17ffd15 	stw	r5,-12(fp)
 200da2c:	e1bffe15 	stw	r6,-8(fp)
 200da30:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 200da34:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200da38:	e0bffc17 	ldw	r2,-16(fp)
 200da3c:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200da40:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200da44:	10000126 	beq	r2,zero,200da4c <xQueueGenericSend+0x38>
 200da48:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 200da4c:	e0bff817 	ldw	r2,-32(fp)
 200da50:	10c00e17 	ldw	r3,56(r2)
 200da54:	e0bff817 	ldw	r2,-32(fp)
 200da58:	10800f17 	ldw	r2,60(r2)
 200da5c:	18800336 	bltu	r3,r2,200da6c <xQueueGenericSend+0x58>
 200da60:	e0bfff17 	ldw	r2,-4(fp)
 200da64:	10800098 	cmpnei	r2,r2,2
 200da68:	1000171e 	bne	r2,zero,200dac8 <xQueueGenericSend+0xb4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 200da6c:	e1bfff17 	ldw	r6,-4(fp)
 200da70:	e17ffd17 	ldw	r5,-12(fp)
 200da74:	e13ff817 	ldw	r4,-32(fp)
 200da78:	200e73c0 	call	200e73c <prvCopyDataToQueue>
 200da7c:	e0bff915 	stw	r2,-28(fp)

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200da80:	e0bff817 	ldw	r2,-32(fp)
 200da84:	10800917 	ldw	r2,36(r2)
 200da88:	10000726 	beq	r2,zero,200daa8 <xQueueGenericSend+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200da8c:	e0bff817 	ldw	r2,-32(fp)
 200da90:	10800904 	addi	r2,r2,36
 200da94:	1009883a 	mov	r4,r2
 200da98:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200da9c:	10000526 	beq	r2,zero,200dab4 <xQueueGenericSend+0xa0>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 200daa0:	003b683a 	trap	0
 200daa4:	00000306 	br	200dab4 <xQueueGenericSend+0xa0>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 200daa8:	e0bff917 	ldw	r2,-28(fp)
 200daac:	10000126 	beq	r2,zero,200dab4 <xQueueGenericSend+0xa0>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 200dab0:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 200dab4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200dab8:	10000126 	beq	r2,zero,200dac0 <xQueueGenericSend+0xac>
 200dabc:	2010f780 	call	2010f78 <vTaskExitCritical>
				return pdPASS;
 200dac0:	00800044 	movi	r2,1
 200dac4:	00004706 	br	200dbe4 <xQueueGenericSend+0x1d0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200dac8:	e0bffe17 	ldw	r2,-8(fp)
 200dacc:	1000051e 	bne	r2,zero,200dae4 <xQueueGenericSend+0xd0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200dad0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200dad4:	10000126 	beq	r2,zero,200dadc <xQueueGenericSend+0xc8>
 200dad8:	2010f780 	call	2010f78 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 200dadc:	0005883a 	mov	r2,zero
 200dae0:	00004006 	br	200dbe4 <xQueueGenericSend+0x1d0>
				}
				else if( xEntryTimeSet == pdFALSE )
 200dae4:	e0bff717 	ldw	r2,-36(fp)
 200dae8:	1000051e 	bne	r2,zero,200db00 <xQueueGenericSend+0xec>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200daec:	e0bffa04 	addi	r2,fp,-24
 200daf0:	1009883a 	mov	r4,r2
 200daf4:	20104240 	call	2010424 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200daf8:	00800044 	movi	r2,1
 200dafc:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200db00:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200db04:	10000126 	beq	r2,zero,200db0c <xQueueGenericSend+0xf8>
 200db08:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200db0c:	200fa500 	call	200fa50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200db10:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200db14:	10000126 	beq	r2,zero,200db1c <xQueueGenericSend+0x108>
 200db18:	2010f300 	call	2010f30 <vTaskEnterCritical>
 200db1c:	e0bff817 	ldw	r2,-32(fp)
 200db20:	10801103 	ldbu	r2,68(r2)
 200db24:	10803fcc 	andi	r2,r2,255
 200db28:	1080201c 	xori	r2,r2,128
 200db2c:	10bfe004 	addi	r2,r2,-128
 200db30:	10bfffd8 	cmpnei	r2,r2,-1
 200db34:	1000021e 	bne	r2,zero,200db40 <xQueueGenericSend+0x12c>
 200db38:	e0bff817 	ldw	r2,-32(fp)
 200db3c:	10001105 	stb	zero,68(r2)
 200db40:	e0bff817 	ldw	r2,-32(fp)
 200db44:	10801143 	ldbu	r2,69(r2)
 200db48:	10803fcc 	andi	r2,r2,255
 200db4c:	1080201c 	xori	r2,r2,128
 200db50:	10bfe004 	addi	r2,r2,-128
 200db54:	10bfffd8 	cmpnei	r2,r2,-1
 200db58:	1000021e 	bne	r2,zero,200db64 <xQueueGenericSend+0x150>
 200db5c:	e0bff817 	ldw	r2,-32(fp)
 200db60:	10001145 	stb	zero,69(r2)
 200db64:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200db68:	10000126 	beq	r2,zero,200db70 <xQueueGenericSend+0x15c>
 200db6c:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200db70:	e0fffe04 	addi	r3,fp,-8
 200db74:	e0bffa04 	addi	r2,fp,-24
 200db78:	180b883a 	mov	r5,r3
 200db7c:	1009883a 	mov	r4,r2
 200db80:	20104600 	call	2010460 <xTaskCheckForTimeOut>
 200db84:	1000131e 	bne	r2,zero,200dbd4 <xQueueGenericSend+0x1c0>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 200db88:	e13ff817 	ldw	r4,-32(fp)
 200db8c:	200eb200 	call	200eb20 <prvIsQueueFull>
 200db90:	10000c26 	beq	r2,zero,200dbc4 <xQueueGenericSend+0x1b0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 200db94:	e0bff817 	ldw	r2,-32(fp)
 200db98:	10800404 	addi	r2,r2,16
 200db9c:	e0fffe17 	ldw	r3,-8(fp)
 200dba0:	180b883a 	mov	r5,r3
 200dba4:	1009883a 	mov	r4,r2
 200dba8:	20100f40 	call	20100f4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 200dbac:	e13ff817 	ldw	r4,-32(fp)
 200dbb0:	200e9640 	call	200e964 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 200dbb4:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200dbb8:	103fa11e 	bne	r2,zero,200da40 <__alt_mem_mem_0+0xfcfeda40>
				{
					portYIELD_WITHIN_API();
 200dbbc:	003b683a 	trap	0
 200dbc0:	003f9f06 	br	200da40 <__alt_mem_mem_0+0xfcfeda40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 200dbc4:	e13ff817 	ldw	r4,-32(fp)
 200dbc8:	200e9640 	call	200e964 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200dbcc:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200dbd0:	003f9b06 	br	200da40 <__alt_mem_mem_0+0xfcfeda40>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 200dbd4:	e13ff817 	ldw	r4,-32(fp)
 200dbd8:	200e9640 	call	200e964 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200dbdc:	200fa7c0 	call	200fa7c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 200dbe0:	0005883a 	mov	r2,zero
		}
	} /*lint -restore */
}
 200dbe4:	e037883a 	mov	sp,fp
 200dbe8:	dfc00117 	ldw	ra,4(sp)
 200dbec:	df000017 	ldw	fp,0(sp)
 200dbf0:	dec00204 	addi	sp,sp,8
 200dbf4:	f800283a 	ret

0200dbf8 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 200dbf8:	defff504 	addi	sp,sp,-44
 200dbfc:	dfc00a15 	stw	ra,40(sp)
 200dc00:	df000915 	stw	fp,36(sp)
 200dc04:	df000904 	addi	fp,sp,36
 200dc08:	e13ffc15 	stw	r4,-16(fp)
 200dc0c:	e17ffd15 	stw	r5,-12(fp)
 200dc10:	e1bffe15 	stw	r6,-8(fp)
 200dc14:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200dc18:	e0bffc17 	ldw	r2,-16(fp)
 200dc1c:	e0bff815 	stw	r2,-32(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200dc20:	e03ff915 	stw	zero,-28(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 200dc24:	e0bff817 	ldw	r2,-32(fp)
 200dc28:	10c00e17 	ldw	r3,56(r2)
 200dc2c:	e0bff817 	ldw	r2,-32(fp)
 200dc30:	10800f17 	ldw	r2,60(r2)
 200dc34:	18800336 	bltu	r3,r2,200dc44 <xQueueGenericSendFromISR+0x4c>
 200dc38:	e0bfff17 	ldw	r2,-4(fp)
 200dc3c:	10800098 	cmpnei	r2,r2,2
 200dc40:	1000231e 	bne	r2,zero,200dcd0 <xQueueGenericSendFromISR+0xd8>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 200dc44:	e0bff817 	ldw	r2,-32(fp)
 200dc48:	10801143 	ldbu	r2,69(r2)
 200dc4c:	e0bffa05 	stb	r2,-24(fp)
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 200dc50:	e0bff817 	ldw	r2,-32(fp)
 200dc54:	10800e17 	ldw	r2,56(r2)
 200dc58:	e0bffb15 	stw	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 200dc5c:	e1bfff17 	ldw	r6,-4(fp)
 200dc60:	e17ffd17 	ldw	r5,-12(fp)
 200dc64:	e13ff817 	ldw	r4,-32(fp)
 200dc68:	200e73c0 	call	200e73c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 200dc6c:	e0bffa07 	ldb	r2,-24(fp)
 200dc70:	10bfffd8 	cmpnei	r2,r2,-1
 200dc74:	10000e1e 	bne	r2,zero,200dcb0 <xQueueGenericSendFromISR+0xb8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200dc78:	e0bff817 	ldw	r2,-32(fp)
 200dc7c:	10800917 	ldw	r2,36(r2)
 200dc80:	10001026 	beq	r2,zero,200dcc4 <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200dc84:	e0bff817 	ldw	r2,-32(fp)
 200dc88:	10800904 	addi	r2,r2,36
 200dc8c:	1009883a 	mov	r4,r2
 200dc90:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200dc94:	10000b26 	beq	r2,zero,200dcc4 <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 200dc98:	e0bffe17 	ldw	r2,-8(fp)
 200dc9c:	10000926 	beq	r2,zero,200dcc4 <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 200dca0:	e0bffe17 	ldw	r2,-8(fp)
 200dca4:	00c00044 	movi	r3,1
 200dca8:	10c00015 	stw	r3,0(r2)
 200dcac:	00000506 	br	200dcc4 <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 200dcb0:	e0bffa03 	ldbu	r2,-24(fp)
 200dcb4:	10800044 	addi	r2,r2,1
 200dcb8:	1007883a 	mov	r3,r2
 200dcbc:	e0bff817 	ldw	r2,-32(fp)
 200dcc0:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 200dcc4:	00800044 	movi	r2,1
 200dcc8:	e0bff715 	stw	r2,-36(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 200dccc:	00000106 	br	200dcd4 <xQueueGenericSendFromISR+0xdc>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 200dcd0:	e03ff715 	stw	zero,-36(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200dcd4:	e0bff717 	ldw	r2,-36(fp)
}
 200dcd8:	e037883a 	mov	sp,fp
 200dcdc:	dfc00117 	ldw	ra,4(sp)
 200dce0:	df000017 	ldw	fp,0(sp)
 200dce4:	dec00204 	addi	sp,sp,8
 200dce8:	f800283a 	ret

0200dcec <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 200dcec:	defff704 	addi	sp,sp,-36
 200dcf0:	dfc00815 	stw	ra,32(sp)
 200dcf4:	df000715 	stw	fp,28(sp)
 200dcf8:	df000704 	addi	fp,sp,28
 200dcfc:	e13ffe15 	stw	r4,-8(fp)
 200dd00:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200dd04:	e0bffe17 	ldw	r2,-8(fp)
 200dd08:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200dd0c:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200dd10:	e0bffa17 	ldw	r2,-24(fp)
 200dd14:	10800e17 	ldw	r2,56(r2)
 200dd18:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 200dd1c:	e0bffa17 	ldw	r2,-24(fp)
 200dd20:	10800f17 	ldw	r2,60(r2)
 200dd24:	e0fffc17 	ldw	r3,-16(fp)
 200dd28:	1880202e 	bgeu	r3,r2,200ddac <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 200dd2c:	e0bffa17 	ldw	r2,-24(fp)
 200dd30:	10801143 	ldbu	r2,69(r2)
 200dd34:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 200dd38:	e0bffc17 	ldw	r2,-16(fp)
 200dd3c:	10c00044 	addi	r3,r2,1
 200dd40:	e0bffa17 	ldw	r2,-24(fp)
 200dd44:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 200dd48:	e0bffd07 	ldb	r2,-12(fp)
 200dd4c:	10bfffd8 	cmpnei	r2,r2,-1
 200dd50:	10000e1e 	bne	r2,zero,200dd8c <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200dd54:	e0bffa17 	ldw	r2,-24(fp)
 200dd58:	10800917 	ldw	r2,36(r2)
 200dd5c:	10001026 	beq	r2,zero,200dda0 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200dd60:	e0bffa17 	ldw	r2,-24(fp)
 200dd64:	10800904 	addi	r2,r2,36
 200dd68:	1009883a 	mov	r4,r2
 200dd6c:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200dd70:	10000b26 	beq	r2,zero,200dda0 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 200dd74:	e0bfff17 	ldw	r2,-4(fp)
 200dd78:	10000926 	beq	r2,zero,200dda0 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 200dd7c:	e0bfff17 	ldw	r2,-4(fp)
 200dd80:	00c00044 	movi	r3,1
 200dd84:	10c00015 	stw	r3,0(r2)
 200dd88:	00000506 	br	200dda0 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 200dd8c:	e0bffd03 	ldbu	r2,-12(fp)
 200dd90:	10800044 	addi	r2,r2,1
 200dd94:	1007883a 	mov	r3,r2
 200dd98:	e0bffa17 	ldw	r2,-24(fp)
 200dd9c:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 200dda0:	00800044 	movi	r2,1
 200dda4:	e0bff915 	stw	r2,-28(fp)
 200dda8:	00000106 	br	200ddb0 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 200ddac:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200ddb0:	e0bff917 	ldw	r2,-28(fp)
}
 200ddb4:	e037883a 	mov	sp,fp
 200ddb8:	dfc00117 	ldw	ra,4(sp)
 200ddbc:	df000017 	ldw	fp,0(sp)
 200ddc0:	dec00204 	addi	sp,sp,8
 200ddc4:	f800283a 	ret

0200ddc8 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 200ddc8:	defff604 	addi	sp,sp,-40
 200ddcc:	dfc00915 	stw	ra,36(sp)
 200ddd0:	df000815 	stw	fp,32(sp)
 200ddd4:	df000804 	addi	fp,sp,32
 200ddd8:	e13ffd15 	stw	r4,-12(fp)
 200dddc:	e17ffe15 	stw	r5,-8(fp)
 200dde0:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200dde4:	e03ff815 	stw	zero,-32(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200dde8:	e0bffd17 	ldw	r2,-12(fp)
 200ddec:	e0bff915 	stw	r2,-28(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200ddf0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ddf4:	10000126 	beq	r2,zero,200ddfc <xQueueReceive+0x34>
 200ddf8:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200ddfc:	e0bff917 	ldw	r2,-28(fp)
 200de00:	10800e17 	ldw	r2,56(r2)
 200de04:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200de08:	e0bffa17 	ldw	r2,-24(fp)
 200de0c:	10001526 	beq	r2,zero,200de64 <xQueueReceive+0x9c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 200de10:	e17ffe17 	ldw	r5,-8(fp)
 200de14:	e13ff917 	ldw	r4,-28(fp)
 200de18:	200e8c80 	call	200e8c8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 200de1c:	e0bffa17 	ldw	r2,-24(fp)
 200de20:	10ffffc4 	addi	r3,r2,-1
 200de24:	e0bff917 	ldw	r2,-28(fp)
 200de28:	10c00e15 	stw	r3,56(r2)

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200de2c:	e0bff917 	ldw	r2,-28(fp)
 200de30:	10800417 	ldw	r2,16(r2)
 200de34:	10000626 	beq	r2,zero,200de50 <xQueueReceive+0x88>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200de38:	e0bff917 	ldw	r2,-28(fp)
 200de3c:	10800404 	addi	r2,r2,16
 200de40:	1009883a 	mov	r4,r2
 200de44:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200de48:	10000126 	beq	r2,zero,200de50 <xQueueReceive+0x88>
					{
						queueYIELD_IF_USING_PREEMPTION();
 200de4c:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200de50:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200de54:	10000126 	beq	r2,zero,200de5c <xQueueReceive+0x94>
 200de58:	2010f780 	call	2010f78 <vTaskExitCritical>
				return pdPASS;
 200de5c:	00800044 	movi	r2,1
 200de60:	00004a06 	br	200df8c <xQueueReceive+0x1c4>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200de64:	e0bfff17 	ldw	r2,-4(fp)
 200de68:	1000051e 	bne	r2,zero,200de80 <xQueueReceive+0xb8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200de6c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200de70:	10000126 	beq	r2,zero,200de78 <xQueueReceive+0xb0>
 200de74:	2010f780 	call	2010f78 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200de78:	0005883a 	mov	r2,zero
 200de7c:	00004306 	br	200df8c <xQueueReceive+0x1c4>
				}
				else if( xEntryTimeSet == pdFALSE )
 200de80:	e0bff817 	ldw	r2,-32(fp)
 200de84:	1000051e 	bne	r2,zero,200de9c <xQueueReceive+0xd4>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200de88:	e0bffb04 	addi	r2,fp,-20
 200de8c:	1009883a 	mov	r4,r2
 200de90:	20104240 	call	2010424 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200de94:	00800044 	movi	r2,1
 200de98:	e0bff815 	stw	r2,-32(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200de9c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200dea0:	10000126 	beq	r2,zero,200dea8 <xQueueReceive+0xe0>
 200dea4:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200dea8:	200fa500 	call	200fa50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200deac:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200deb0:	10000126 	beq	r2,zero,200deb8 <xQueueReceive+0xf0>
 200deb4:	2010f300 	call	2010f30 <vTaskEnterCritical>
 200deb8:	e0bff917 	ldw	r2,-28(fp)
 200debc:	10801103 	ldbu	r2,68(r2)
 200dec0:	10803fcc 	andi	r2,r2,255
 200dec4:	1080201c 	xori	r2,r2,128
 200dec8:	10bfe004 	addi	r2,r2,-128
 200decc:	10bfffd8 	cmpnei	r2,r2,-1
 200ded0:	1000021e 	bne	r2,zero,200dedc <xQueueReceive+0x114>
 200ded4:	e0bff917 	ldw	r2,-28(fp)
 200ded8:	10001105 	stb	zero,68(r2)
 200dedc:	e0bff917 	ldw	r2,-28(fp)
 200dee0:	10801143 	ldbu	r2,69(r2)
 200dee4:	10803fcc 	andi	r2,r2,255
 200dee8:	1080201c 	xori	r2,r2,128
 200deec:	10bfe004 	addi	r2,r2,-128
 200def0:	10bfffd8 	cmpnei	r2,r2,-1
 200def4:	1000021e 	bne	r2,zero,200df00 <xQueueReceive+0x138>
 200def8:	e0bff917 	ldw	r2,-28(fp)
 200defc:	10001145 	stb	zero,69(r2)
 200df00:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200df04:	10000126 	beq	r2,zero,200df0c <xQueueReceive+0x144>
 200df08:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200df0c:	e0ffff04 	addi	r3,fp,-4
 200df10:	e0bffb04 	addi	r2,fp,-20
 200df14:	180b883a 	mov	r5,r3
 200df18:	1009883a 	mov	r4,r2
 200df1c:	20104600 	call	2010460 <xTaskCheckForTimeOut>
 200df20:	1000131e 	bne	r2,zero,200df70 <xQueueReceive+0x1a8>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200df24:	e13ff917 	ldw	r4,-28(fp)
 200df28:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200df2c:	10000c26 	beq	r2,zero,200df60 <xQueueReceive+0x198>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200df30:	e0bff917 	ldw	r2,-28(fp)
 200df34:	10800904 	addi	r2,r2,36
 200df38:	e0ffff17 	ldw	r3,-4(fp)
 200df3c:	180b883a 	mov	r5,r3
 200df40:	1009883a 	mov	r4,r2
 200df44:	20100f40 	call	20100f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200df48:	e13ff917 	ldw	r4,-28(fp)
 200df4c:	200e9640 	call	200e964 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200df50:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200df54:	103fa61e 	bne	r2,zero,200ddf0 <__alt_mem_mem_0+0xfcfeddf0>
				{
					portYIELD_WITHIN_API();
 200df58:	003b683a 	trap	0
 200df5c:	003fa406 	br	200ddf0 <__alt_mem_mem_0+0xfcfeddf0>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 200df60:	e13ff917 	ldw	r4,-28(fp)
 200df64:	200e9640 	call	200e964 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200df68:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200df6c:	003fa006 	br	200ddf0 <__alt_mem_mem_0+0xfcfeddf0>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 200df70:	e13ff917 	ldw	r4,-28(fp)
 200df74:	200e9640 	call	200e964 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200df78:	200fa7c0 	call	200fa7c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200df7c:	e13ff917 	ldw	r4,-28(fp)
 200df80:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200df84:	103f9a26 	beq	r2,zero,200ddf0 <__alt_mem_mem_0+0xfcfeddf0>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200df88:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200df8c:	e037883a 	mov	sp,fp
 200df90:	dfc00117 	ldw	ra,4(sp)
 200df94:	df000017 	ldw	fp,0(sp)
 200df98:	dec00204 	addi	sp,sp,8
 200df9c:	f800283a 	ret

0200dfa0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 200dfa0:	defff504 	addi	sp,sp,-44
 200dfa4:	dfc00a15 	stw	ra,40(sp)
 200dfa8:	df000915 	stw	fp,36(sp)
 200dfac:	df000904 	addi	fp,sp,36
 200dfb0:	e13ffe15 	stw	r4,-8(fp)
 200dfb4:	e17fff15 	stw	r5,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200dfb8:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 200dfbc:	e0bffe17 	ldw	r2,-8(fp)
 200dfc0:	e0bff915 	stw	r2,-28(fp)

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 200dfc4:	e03ff815 	stw	zero,-32(fp)
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200dfc8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200dfcc:	10000126 	beq	r2,zero,200dfd4 <xQueueSemaphoreTake+0x34>
 200dfd0:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 200dfd4:	e0bff917 	ldw	r2,-28(fp)
 200dfd8:	10800e17 	ldw	r2,56(r2)
 200dfdc:	e0bffa15 	stw	r2,-24(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 200dfe0:	e0bffa17 	ldw	r2,-24(fp)
 200dfe4:	10001926 	beq	r2,zero,200e04c <xQueueSemaphoreTake+0xac>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 200dfe8:	e0bffa17 	ldw	r2,-24(fp)
 200dfec:	10ffffc4 	addi	r3,r2,-1
 200dff0:	e0bff917 	ldw	r2,-28(fp)
 200dff4:	10c00e15 	stw	r3,56(r2)

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200dff8:	e0bff917 	ldw	r2,-28(fp)
 200dffc:	10800017 	ldw	r2,0(r2)
 200e000:	1000041e 	bne	r2,zero,200e014 <xQueueSemaphoreTake+0x74>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 200e004:	20110180 	call	2011018 <pvTaskIncrementMutexHeldCount>
 200e008:	1007883a 	mov	r3,r2
 200e00c:	e0bff917 	ldw	r2,-28(fp)
 200e010:	10c00215 	stw	r3,8(r2)
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200e014:	e0bff917 	ldw	r2,-28(fp)
 200e018:	10800417 	ldw	r2,16(r2)
 200e01c:	10000626 	beq	r2,zero,200e038 <xQueueSemaphoreTake+0x98>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200e020:	e0bff917 	ldw	r2,-28(fp)
 200e024:	10800404 	addi	r2,r2,16
 200e028:	1009883a 	mov	r4,r2
 200e02c:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200e030:	10000126 	beq	r2,zero,200e038 <xQueueSemaphoreTake+0x98>
					{
						queueYIELD_IF_USING_PREEMPTION();
 200e034:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200e038:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e03c:	10000126 	beq	r2,zero,200e044 <xQueueSemaphoreTake+0xa4>
 200e040:	2010f780 	call	2010f78 <vTaskExitCritical>
				return pdPASS;
 200e044:	00800044 	movi	r2,1
 200e048:	00006806 	br	200e1ec <xQueueSemaphoreTake+0x24c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200e04c:	e0bfff17 	ldw	r2,-4(fp)
 200e050:	1000051e 	bne	r2,zero,200e068 <xQueueSemaphoreTake+0xc8>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 200e054:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e058:	10000126 	beq	r2,zero,200e060 <xQueueSemaphoreTake+0xc0>
 200e05c:	2010f780 	call	2010f78 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200e060:	0005883a 	mov	r2,zero
 200e064:	00006106 	br	200e1ec <xQueueSemaphoreTake+0x24c>
				}
				else if( xEntryTimeSet == pdFALSE )
 200e068:	e0bff717 	ldw	r2,-36(fp)
 200e06c:	1000051e 	bne	r2,zero,200e084 <xQueueSemaphoreTake+0xe4>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200e070:	e0bffc04 	addi	r2,fp,-16
 200e074:	1009883a 	mov	r4,r2
 200e078:	20104240 	call	2010424 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200e07c:	00800044 	movi	r2,1
 200e080:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200e084:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e088:	10000126 	beq	r2,zero,200e090 <xQueueSemaphoreTake+0xf0>
 200e08c:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 200e090:	200fa500 	call	200fa50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200e094:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e098:	10000126 	beq	r2,zero,200e0a0 <xQueueSemaphoreTake+0x100>
 200e09c:	2010f300 	call	2010f30 <vTaskEnterCritical>
 200e0a0:	e0bff917 	ldw	r2,-28(fp)
 200e0a4:	10801103 	ldbu	r2,68(r2)
 200e0a8:	10803fcc 	andi	r2,r2,255
 200e0ac:	1080201c 	xori	r2,r2,128
 200e0b0:	10bfe004 	addi	r2,r2,-128
 200e0b4:	10bfffd8 	cmpnei	r2,r2,-1
 200e0b8:	1000021e 	bne	r2,zero,200e0c4 <xQueueSemaphoreTake+0x124>
 200e0bc:	e0bff917 	ldw	r2,-28(fp)
 200e0c0:	10001105 	stb	zero,68(r2)
 200e0c4:	e0bff917 	ldw	r2,-28(fp)
 200e0c8:	10801143 	ldbu	r2,69(r2)
 200e0cc:	10803fcc 	andi	r2,r2,255
 200e0d0:	1080201c 	xori	r2,r2,128
 200e0d4:	10bfe004 	addi	r2,r2,-128
 200e0d8:	10bfffd8 	cmpnei	r2,r2,-1
 200e0dc:	1000021e 	bne	r2,zero,200e0e8 <xQueueSemaphoreTake+0x148>
 200e0e0:	e0bff917 	ldw	r2,-28(fp)
 200e0e4:	10001145 	stb	zero,69(r2)
 200e0e8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e0ec:	10000126 	beq	r2,zero,200e0f4 <xQueueSemaphoreTake+0x154>
 200e0f0:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200e0f4:	e0ffff04 	addi	r3,fp,-4
 200e0f8:	e0bffc04 	addi	r2,fp,-16
 200e0fc:	180b883a 	mov	r5,r3
 200e100:	1009883a 	mov	r4,r2
 200e104:	20104600 	call	2010460 <xTaskCheckForTimeOut>
 200e108:	1000211e 	bne	r2,zero,200e190 <xQueueSemaphoreTake+0x1f0>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e10c:	e13ff917 	ldw	r4,-28(fp)
 200e110:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200e114:	10001a26 	beq	r2,zero,200e180 <xQueueSemaphoreTake+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200e118:	e0bff917 	ldw	r2,-28(fp)
 200e11c:	10800017 	ldw	r2,0(r2)
 200e120:	10000b1e 	bne	r2,zero,200e150 <xQueueSemaphoreTake+0x1b0>
					{
						taskENTER_CRITICAL();
 200e124:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e128:	10000126 	beq	r2,zero,200e130 <xQueueSemaphoreTake+0x190>
 200e12c:	2010f300 	call	2010f30 <vTaskEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 200e130:	e0bff917 	ldw	r2,-28(fp)
 200e134:	10800217 	ldw	r2,8(r2)
 200e138:	1009883a 	mov	r4,r2
 200e13c:	2010bb40 	call	2010bb4 <xTaskPriorityInherit>
 200e140:	e0bff815 	stw	r2,-32(fp)
						}
						taskEXIT_CRITICAL();
 200e144:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e148:	10000126 	beq	r2,zero,200e150 <xQueueSemaphoreTake+0x1b0>
 200e14c:	2010f780 	call	2010f78 <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200e150:	e0bff917 	ldw	r2,-28(fp)
 200e154:	10800904 	addi	r2,r2,36
 200e158:	e0ffff17 	ldw	r3,-4(fp)
 200e15c:	180b883a 	mov	r5,r3
 200e160:	1009883a 	mov	r4,r2
 200e164:	20100f40 	call	20100f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200e168:	e13ff917 	ldw	r4,-28(fp)
 200e16c:	200e9640 	call	200e964 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200e170:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200e174:	103f941e 	bne	r2,zero,200dfc8 <__alt_mem_mem_0+0xfcfedfc8>
				{
					portYIELD_WITHIN_API();
 200e178:	003b683a 	trap	0
 200e17c:	003f9206 	br	200dfc8 <__alt_mem_mem_0+0xfcfedfc8>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 200e180:	e13ff917 	ldw	r4,-28(fp)
 200e184:	200e9640 	call	200e964 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200e188:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200e18c:	003f8e06 	br	200dfc8 <__alt_mem_mem_0+0xfcfedfc8>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 200e190:	e13ff917 	ldw	r4,-28(fp)
 200e194:	200e9640 	call	200e964 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200e198:	200fa7c0 	call	200fa7c <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e19c:	e13ff917 	ldw	r4,-28(fp)
 200e1a0:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200e1a4:	103f8826 	beq	r2,zero,200dfc8 <__alt_mem_mem_0+0xfcfedfc8>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 200e1a8:	e0bff817 	ldw	r2,-32(fp)
 200e1ac:	10000e26 	beq	r2,zero,200e1e8 <xQueueSemaphoreTake+0x248>
					{
						taskENTER_CRITICAL();
 200e1b0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e1b4:	10000126 	beq	r2,zero,200e1bc <xQueueSemaphoreTake+0x21c>
 200e1b8:	2010f300 	call	2010f30 <vTaskEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 200e1bc:	e13ff917 	ldw	r4,-28(fp)
 200e1c0:	200e6ec0 	call	200e6ec <prvGetDisinheritPriorityAfterTimeout>
 200e1c4:	e0bffb15 	stw	r2,-20(fp)
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 200e1c8:	e0bff917 	ldw	r2,-28(fp)
 200e1cc:	10800217 	ldw	r2,8(r2)
 200e1d0:	e17ffb17 	ldw	r5,-20(fp)
 200e1d4:	1009883a 	mov	r4,r2
 200e1d8:	2010df00 	call	2010df0 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 200e1dc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e1e0:	10000126 	beq	r2,zero,200e1e8 <xQueueSemaphoreTake+0x248>
 200e1e4:	2010f780 	call	2010f78 <vTaskExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200e1e8:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200e1ec:	e037883a 	mov	sp,fp
 200e1f0:	dfc00117 	ldw	ra,4(sp)
 200e1f4:	df000017 	ldw	fp,0(sp)
 200e1f8:	dec00204 	addi	sp,sp,8
 200e1fc:	f800283a 	ret

0200e200 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 200e200:	defff504 	addi	sp,sp,-44
 200e204:	dfc00a15 	stw	ra,40(sp)
 200e208:	df000915 	stw	fp,36(sp)
 200e20c:	df000904 	addi	fp,sp,36
 200e210:	e13ffd15 	stw	r4,-12(fp)
 200e214:	e17ffe15 	stw	r5,-8(fp)
 200e218:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 200e21c:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 200e220:	e0bffd17 	ldw	r2,-12(fp)
 200e224:	e0bff815 	stw	r2,-32(fp)
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 200e228:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e22c:	10000126 	beq	r2,zero,200e234 <xQueuePeek+0x34>
 200e230:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e234:	e0bff817 	ldw	r2,-32(fp)
 200e238:	10800e17 	ldw	r2,56(r2)
 200e23c:	e0bff915 	stw	r2,-28(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e240:	e0bff917 	ldw	r2,-28(fp)
 200e244:	10001726 	beq	r2,zero,200e2a4 <xQueuePeek+0xa4>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 200e248:	e0bff817 	ldw	r2,-32(fp)
 200e24c:	10800317 	ldw	r2,12(r2)
 200e250:	e0bffa15 	stw	r2,-24(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e254:	e17ffe17 	ldw	r5,-8(fp)
 200e258:	e13ff817 	ldw	r4,-32(fp)
 200e25c:	200e8c80 	call	200e8c8 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 200e260:	e0bff817 	ldw	r2,-32(fp)
 200e264:	e0fffa17 	ldw	r3,-24(fp)
 200e268:	10c00315 	stw	r3,12(r2)

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200e26c:	e0bff817 	ldw	r2,-32(fp)
 200e270:	10800917 	ldw	r2,36(r2)
 200e274:	10000626 	beq	r2,zero,200e290 <xQueuePeek+0x90>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200e278:	e0bff817 	ldw	r2,-32(fp)
 200e27c:	10800904 	addi	r2,r2,36
 200e280:	1009883a 	mov	r4,r2
 200e284:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200e288:	10000126 	beq	r2,zero,200e290 <xQueuePeek+0x90>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
 200e28c:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 200e290:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e294:	10000126 	beq	r2,zero,200e29c <xQueuePeek+0x9c>
 200e298:	2010f780 	call	2010f78 <vTaskExitCritical>
				return pdPASS;
 200e29c:	00800044 	movi	r2,1
 200e2a0:	00004a06 	br	200e3cc <xQueuePeek+0x1cc>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 200e2a4:	e0bfff17 	ldw	r2,-4(fp)
 200e2a8:	1000051e 	bne	r2,zero,200e2c0 <xQueuePeek+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 200e2ac:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e2b0:	10000126 	beq	r2,zero,200e2b8 <xQueuePeek+0xb8>
 200e2b4:	2010f780 	call	2010f78 <vTaskExitCritical>
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 200e2b8:	0005883a 	mov	r2,zero
 200e2bc:	00004306 	br	200e3cc <xQueuePeek+0x1cc>
				}
				else if( xEntryTimeSet == pdFALSE )
 200e2c0:	e0bff717 	ldw	r2,-36(fp)
 200e2c4:	1000051e 	bne	r2,zero,200e2dc <xQueuePeek+0xdc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 200e2c8:	e0bffb04 	addi	r2,fp,-20
 200e2cc:	1009883a 	mov	r4,r2
 200e2d0:	20104240 	call	2010424 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 200e2d4:	00800044 	movi	r2,1
 200e2d8:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 200e2dc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e2e0:	10000126 	beq	r2,zero,200e2e8 <xQueuePeek+0xe8>
 200e2e4:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 200e2e8:	200fa500 	call	200fa50 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 200e2ec:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e2f0:	10000126 	beq	r2,zero,200e2f8 <xQueuePeek+0xf8>
 200e2f4:	2010f300 	call	2010f30 <vTaskEnterCritical>
 200e2f8:	e0bff817 	ldw	r2,-32(fp)
 200e2fc:	10801103 	ldbu	r2,68(r2)
 200e300:	10803fcc 	andi	r2,r2,255
 200e304:	1080201c 	xori	r2,r2,128
 200e308:	10bfe004 	addi	r2,r2,-128
 200e30c:	10bfffd8 	cmpnei	r2,r2,-1
 200e310:	1000021e 	bne	r2,zero,200e31c <xQueuePeek+0x11c>
 200e314:	e0bff817 	ldw	r2,-32(fp)
 200e318:	10001105 	stb	zero,68(r2)
 200e31c:	e0bff817 	ldw	r2,-32(fp)
 200e320:	10801143 	ldbu	r2,69(r2)
 200e324:	10803fcc 	andi	r2,r2,255
 200e328:	1080201c 	xori	r2,r2,128
 200e32c:	10bfe004 	addi	r2,r2,-128
 200e330:	10bfffd8 	cmpnei	r2,r2,-1
 200e334:	1000021e 	bne	r2,zero,200e340 <xQueuePeek+0x140>
 200e338:	e0bff817 	ldw	r2,-32(fp)
 200e33c:	10001145 	stb	zero,69(r2)
 200e340:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e344:	10000126 	beq	r2,zero,200e34c <xQueuePeek+0x14c>
 200e348:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 200e34c:	e0ffff04 	addi	r3,fp,-4
 200e350:	e0bffb04 	addi	r2,fp,-20
 200e354:	180b883a 	mov	r5,r3
 200e358:	1009883a 	mov	r4,r2
 200e35c:	20104600 	call	2010460 <xTaskCheckForTimeOut>
 200e360:	1000131e 	bne	r2,zero,200e3b0 <xQueuePeek+0x1b0>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e364:	e13ff817 	ldw	r4,-32(fp)
 200e368:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200e36c:	10000c26 	beq	r2,zero,200e3a0 <xQueuePeek+0x1a0>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 200e370:	e0bff817 	ldw	r2,-32(fp)
 200e374:	10800904 	addi	r2,r2,36
 200e378:	e0ffff17 	ldw	r3,-4(fp)
 200e37c:	180b883a 	mov	r5,r3
 200e380:	1009883a 	mov	r4,r2
 200e384:	20100f40 	call	20100f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 200e388:	e13ff817 	ldw	r4,-32(fp)
 200e38c:	200e9640 	call	200e964 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 200e390:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200e394:	103fa41e 	bne	r2,zero,200e228 <__alt_mem_mem_0+0xfcfee228>
				{
					portYIELD_WITHIN_API();
 200e398:	003b683a 	trap	0
 200e39c:	003fa206 	br	200e228 <__alt_mem_mem_0+0xfcfee228>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
 200e3a0:	e13ff817 	ldw	r4,-32(fp)
 200e3a4:	200e9640 	call	200e964 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 200e3a8:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200e3ac:	003f9e06 	br	200e228 <__alt_mem_mem_0+0xfcfee228>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
 200e3b0:	e13ff817 	ldw	r4,-32(fp)
 200e3b4:	200e9640 	call	200e964 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 200e3b8:	200fa7c0 	call	200fa7c <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 200e3bc:	e13ff817 	ldw	r4,-32(fp)
 200e3c0:	200ea780 	call	200ea78 <prvIsQueueEmpty>
 200e3c4:	103f9826 	beq	r2,zero,200e228 <__alt_mem_mem_0+0xfcfee228>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 200e3c8:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 200e3cc:	e037883a 	mov	sp,fp
 200e3d0:	dfc00117 	ldw	ra,4(sp)
 200e3d4:	df000017 	ldw	fp,0(sp)
 200e3d8:	dec00204 	addi	sp,sp,8
 200e3dc:	f800283a 	ret

0200e3e0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 200e3e0:	defff604 	addi	sp,sp,-40
 200e3e4:	dfc00915 	stw	ra,36(sp)
 200e3e8:	df000815 	stw	fp,32(sp)
 200e3ec:	df000804 	addi	fp,sp,32
 200e3f0:	e13ffd15 	stw	r4,-12(fp)
 200e3f4:	e17ffe15 	stw	r5,-8(fp)
 200e3f8:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 200e3fc:	e0bffd17 	ldw	r2,-12(fp)
 200e400:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200e404:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e408:	e0bff917 	ldw	r2,-28(fp)
 200e40c:	10800e17 	ldw	r2,56(r2)
 200e410:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e414:	e0bffb17 	ldw	r2,-20(fp)
 200e418:	10002326 	beq	r2,zero,200e4a8 <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 200e41c:	e0bff917 	ldw	r2,-28(fp)
 200e420:	10801103 	ldbu	r2,68(r2)
 200e424:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e428:	e17ffe17 	ldw	r5,-8(fp)
 200e42c:	e13ff917 	ldw	r4,-28(fp)
 200e430:	200e8c80 	call	200e8c8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 200e434:	e0bffb17 	ldw	r2,-20(fp)
 200e438:	10ffffc4 	addi	r3,r2,-1
 200e43c:	e0bff917 	ldw	r2,-28(fp)
 200e440:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 200e444:	e0bffc07 	ldb	r2,-16(fp)
 200e448:	10bfffd8 	cmpnei	r2,r2,-1
 200e44c:	10000e1e 	bne	r2,zero,200e488 <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200e450:	e0bff917 	ldw	r2,-28(fp)
 200e454:	10800417 	ldw	r2,16(r2)
 200e458:	10001026 	beq	r2,zero,200e49c <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200e45c:	e0bff917 	ldw	r2,-28(fp)
 200e460:	10800404 	addi	r2,r2,16
 200e464:	1009883a 	mov	r4,r2
 200e468:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200e46c:	10000b26 	beq	r2,zero,200e49c <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 200e470:	e0bfff17 	ldw	r2,-4(fp)
 200e474:	10000926 	beq	r2,zero,200e49c <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 200e478:	e0bfff17 	ldw	r2,-4(fp)
 200e47c:	00c00044 	movi	r3,1
 200e480:	10c00015 	stw	r3,0(r2)
 200e484:	00000506 	br	200e49c <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 200e488:	e0bffc03 	ldbu	r2,-16(fp)
 200e48c:	10800044 	addi	r2,r2,1
 200e490:	1007883a 	mov	r3,r2
 200e494:	e0bff917 	ldw	r2,-28(fp)
 200e498:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 200e49c:	00800044 	movi	r2,1
 200e4a0:	e0bff815 	stw	r2,-32(fp)
 200e4a4:	00000106 	br	200e4ac <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 200e4a8:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200e4ac:	e0bff817 	ldw	r2,-32(fp)
}
 200e4b0:	e037883a 	mov	sp,fp
 200e4b4:	dfc00117 	ldw	ra,4(sp)
 200e4b8:	df000017 	ldw	fp,0(sp)
 200e4bc:	dec00204 	addi	sp,sp,8
 200e4c0:	f800283a 	ret

0200e4c4 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 200e4c4:	defff804 	addi	sp,sp,-32
 200e4c8:	dfc00715 	stw	ra,28(sp)
 200e4cc:	df000615 	stw	fp,24(sp)
 200e4d0:	df000604 	addi	fp,sp,24
 200e4d4:	e13ffe15 	stw	r4,-8(fp)
 200e4d8:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
 200e4dc:	e0bffe17 	ldw	r2,-8(fp)
 200e4e0:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200e4e4:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e4e8:	e0bffb17 	ldw	r2,-20(fp)
 200e4ec:	10800e17 	ldw	r2,56(r2)
 200e4f0:	10000c26 	beq	r2,zero,200e524 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 200e4f4:	e0bffb17 	ldw	r2,-20(fp)
 200e4f8:	10800317 	ldw	r2,12(r2)
 200e4fc:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 200e500:	e17fff17 	ldw	r5,-4(fp)
 200e504:	e13ffb17 	ldw	r4,-20(fp)
 200e508:	200e8c80 	call	200e8c8 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 200e50c:	e0bffb17 	ldw	r2,-20(fp)
 200e510:	e0fffd17 	ldw	r3,-12(fp)
 200e514:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 200e518:	00800044 	movi	r2,1
 200e51c:	e0bffa15 	stw	r2,-24(fp)
 200e520:	00000106 	br	200e528 <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 200e524:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200e528:	e0bffa17 	ldw	r2,-24(fp)
}
 200e52c:	e037883a 	mov	sp,fp
 200e530:	dfc00117 	ldw	ra,4(sp)
 200e534:	df000017 	ldw	fp,0(sp)
 200e538:	dec00204 	addi	sp,sp,8
 200e53c:	f800283a 	ret

0200e540 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 200e540:	defffc04 	addi	sp,sp,-16
 200e544:	dfc00315 	stw	ra,12(sp)
 200e548:	df000215 	stw	fp,8(sp)
 200e54c:	df000204 	addi	fp,sp,8
 200e550:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 200e554:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e558:	10000126 	beq	r2,zero,200e560 <uxQueueMessagesWaiting+0x20>
 200e55c:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 200e560:	e0bfff17 	ldw	r2,-4(fp)
 200e564:	10800e17 	ldw	r2,56(r2)
 200e568:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 200e56c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e570:	10000126 	beq	r2,zero,200e578 <uxQueueMessagesWaiting+0x38>
 200e574:	2010f780 	call	2010f78 <vTaskExitCritical>

	return uxReturn;
 200e578:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e57c:	e037883a 	mov	sp,fp
 200e580:	dfc00117 	ldw	ra,4(sp)
 200e584:	df000017 	ldw	fp,0(sp)
 200e588:	dec00204 	addi	sp,sp,8
 200e58c:	f800283a 	ret

0200e590 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 200e590:	defffb04 	addi	sp,sp,-20
 200e594:	dfc00415 	stw	ra,16(sp)
 200e598:	df000315 	stw	fp,12(sp)
 200e59c:	df000304 	addi	fp,sp,12
 200e5a0:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 200e5a4:	e0bfff17 	ldw	r2,-4(fp)
 200e5a8:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 200e5ac:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e5b0:	10000126 	beq	r2,zero,200e5b8 <uxQueueSpacesAvailable+0x28>
 200e5b4:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 200e5b8:	e0bffd17 	ldw	r2,-12(fp)
 200e5bc:	10c00f17 	ldw	r3,60(r2)
 200e5c0:	e0bffd17 	ldw	r2,-12(fp)
 200e5c4:	10800e17 	ldw	r2,56(r2)
 200e5c8:	1885c83a 	sub	r2,r3,r2
 200e5cc:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 200e5d0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e5d4:	10000126 	beq	r2,zero,200e5dc <uxQueueSpacesAvailable+0x4c>
 200e5d8:	2010f780 	call	2010f78 <vTaskExitCritical>

	return uxReturn;
 200e5dc:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e5e0:	e037883a 	mov	sp,fp
 200e5e4:	dfc00117 	ldw	ra,4(sp)
 200e5e8:	df000017 	ldw	fp,0(sp)
 200e5ec:	dec00204 	addi	sp,sp,8
 200e5f0:	f800283a 	ret

0200e5f4 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 200e5f4:	defffc04 	addi	sp,sp,-16
 200e5f8:	df000315 	stw	fp,12(sp)
 200e5fc:	df000304 	addi	fp,sp,12
 200e600:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
 200e604:	e0bfff17 	ldw	r2,-4(fp)
 200e608:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
 200e60c:	e0bffd17 	ldw	r2,-12(fp)
 200e610:	10800e17 	ldw	r2,56(r2)
 200e614:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 200e618:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 200e61c:	e037883a 	mov	sp,fp
 200e620:	df000017 	ldw	fp,0(sp)
 200e624:	dec00104 	addi	sp,sp,4
 200e628:	f800283a 	ret

0200e62c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 200e62c:	defffc04 	addi	sp,sp,-16
 200e630:	dfc00315 	stw	ra,12(sp)
 200e634:	df000215 	stw	fp,8(sp)
 200e638:	df000204 	addi	fp,sp,8
 200e63c:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = xQueue;
 200e640:	e0bfff17 	ldw	r2,-4(fp)
 200e644:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 200e648:	e13ffe17 	ldw	r4,-8(fp)
 200e64c:	202bc580 	call	202bc58 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 200e650:	0001883a 	nop
 200e654:	e037883a 	mov	sp,fp
 200e658:	dfc00117 	ldw	ra,4(sp)
 200e65c:	df000017 	ldw	fp,0(sp)
 200e660:	dec00204 	addi	sp,sp,8
 200e664:	f800283a 	ret

0200e668 <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
 200e668:	defffe04 	addi	sp,sp,-8
 200e66c:	df000115 	stw	fp,4(sp)
 200e670:	df000104 	addi	fp,sp,4
 200e674:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
 200e678:	e0bfff17 	ldw	r2,-4(fp)
 200e67c:	10801217 	ldw	r2,72(r2)
	}
 200e680:	e037883a 	mov	sp,fp
 200e684:	df000017 	ldw	fp,0(sp)
 200e688:	dec00104 	addi	sp,sp,4
 200e68c:	f800283a 	ret

0200e690 <vQueueSetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
 200e690:	defffd04 	addi	sp,sp,-12
 200e694:	df000215 	stw	fp,8(sp)
 200e698:	df000204 	addi	fp,sp,8
 200e69c:	e13ffe15 	stw	r4,-8(fp)
 200e6a0:	e17fff15 	stw	r5,-4(fp)
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
 200e6a4:	e0bffe17 	ldw	r2,-8(fp)
 200e6a8:	e0ffff17 	ldw	r3,-4(fp)
 200e6ac:	10c01215 	stw	r3,72(r2)
	}
 200e6b0:	0001883a 	nop
 200e6b4:	e037883a 	mov	sp,fp
 200e6b8:	df000017 	ldw	fp,0(sp)
 200e6bc:	dec00104 	addi	sp,sp,4
 200e6c0:	f800283a 	ret

0200e6c4 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
 200e6c4:	defffe04 	addi	sp,sp,-8
 200e6c8:	df000115 	stw	fp,4(sp)
 200e6cc:	df000104 	addi	fp,sp,4
 200e6d0:	e13fff15 	stw	r4,-4(fp)
		return ( ( Queue_t * ) xQueue )->ucQueueType;
 200e6d4:	e0bfff17 	ldw	r2,-4(fp)
 200e6d8:	10801303 	ldbu	r2,76(r2)
	}
 200e6dc:	e037883a 	mov	sp,fp
 200e6e0:	df000017 	ldw	fp,0(sp)
 200e6e4:	dec00104 	addi	sp,sp,4
 200e6e8:	f800283a 	ret

0200e6ec <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 200e6ec:	defffd04 	addi	sp,sp,-12
 200e6f0:	df000215 	stw	fp,8(sp)
 200e6f4:	df000204 	addi	fp,sp,8
 200e6f8:	e13fff15 	stw	r4,-4(fp)
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 200e6fc:	e0bfff17 	ldw	r2,-4(fp)
 200e700:	10800917 	ldw	r2,36(r2)
 200e704:	10000726 	beq	r2,zero,200e724 <prvGetDisinheritPriorityAfterTimeout+0x38>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 200e708:	e0bfff17 	ldw	r2,-4(fp)
 200e70c:	10800c17 	ldw	r2,48(r2)
 200e710:	10800017 	ldw	r2,0(r2)
 200e714:	00c00144 	movi	r3,5
 200e718:	1885c83a 	sub	r2,r3,r2
 200e71c:	e0bffe15 	stw	r2,-8(fp)
 200e720:	00000106 	br	200e728 <prvGetDisinheritPriorityAfterTimeout+0x3c>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 200e724:	e03ffe15 	stw	zero,-8(fp)
		}

		return uxHighestPriorityOfWaitingTasks;
 200e728:	e0bffe17 	ldw	r2,-8(fp)
	}
 200e72c:	e037883a 	mov	sp,fp
 200e730:	df000017 	ldw	fp,0(sp)
 200e734:	dec00104 	addi	sp,sp,4
 200e738:	f800283a 	ret

0200e73c <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 200e73c:	defff904 	addi	sp,sp,-28
 200e740:	dfc00615 	stw	ra,24(sp)
 200e744:	df000515 	stw	fp,20(sp)
 200e748:	df000504 	addi	fp,sp,20
 200e74c:	e13ffd15 	stw	r4,-12(fp)
 200e750:	e17ffe15 	stw	r5,-8(fp)
 200e754:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 200e758:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 200e75c:	e0bffd17 	ldw	r2,-12(fp)
 200e760:	10800e17 	ldw	r2,56(r2)
 200e764:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 200e768:	e0bffd17 	ldw	r2,-12(fp)
 200e76c:	10801017 	ldw	r2,64(r2)
 200e770:	10000b1e 	bne	r2,zero,200e7a0 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 200e774:	e0bffd17 	ldw	r2,-12(fp)
 200e778:	10800017 	ldw	r2,0(r2)
 200e77c:	1000481e 	bne	r2,zero,200e8a0 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 200e780:	e0bffd17 	ldw	r2,-12(fp)
 200e784:	10800217 	ldw	r2,8(r2)
 200e788:	1009883a 	mov	r4,r2
 200e78c:	2010cf40 	call	2010cf4 <xTaskPriorityDisinherit>
 200e790:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 200e794:	e0bffd17 	ldw	r2,-12(fp)
 200e798:	10000215 	stw	zero,8(r2)
 200e79c:	00004006 	br	200e8a0 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 200e7a0:	e0bfff17 	ldw	r2,-4(fp)
 200e7a4:	1000191e 	bne	r2,zero,200e80c <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 200e7a8:	e0bffd17 	ldw	r2,-12(fp)
 200e7ac:	10c00117 	ldw	r3,4(r2)
 200e7b0:	e0bffd17 	ldw	r2,-12(fp)
 200e7b4:	10801017 	ldw	r2,64(r2)
 200e7b8:	100d883a 	mov	r6,r2
 200e7bc:	e17ffe17 	ldw	r5,-8(fp)
 200e7c0:	1809883a 	mov	r4,r3
 200e7c4:	20060240 	call	2006024 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 200e7c8:	e0bffd17 	ldw	r2,-12(fp)
 200e7cc:	10c00117 	ldw	r3,4(r2)
 200e7d0:	e0bffd17 	ldw	r2,-12(fp)
 200e7d4:	10801017 	ldw	r2,64(r2)
 200e7d8:	1887883a 	add	r3,r3,r2
 200e7dc:	e0bffd17 	ldw	r2,-12(fp)
 200e7e0:	10c00115 	stw	r3,4(r2)
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 200e7e4:	e0bffd17 	ldw	r2,-12(fp)
 200e7e8:	10c00117 	ldw	r3,4(r2)
 200e7ec:	e0bffd17 	ldw	r2,-12(fp)
 200e7f0:	10800217 	ldw	r2,8(r2)
 200e7f4:	18802a36 	bltu	r3,r2,200e8a0 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 200e7f8:	e0bffd17 	ldw	r2,-12(fp)
 200e7fc:	10c00017 	ldw	r3,0(r2)
 200e800:	e0bffd17 	ldw	r2,-12(fp)
 200e804:	10c00115 	stw	r3,4(r2)
 200e808:	00002506 	br	200e8a0 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 200e80c:	e0bffd17 	ldw	r2,-12(fp)
 200e810:	10c00317 	ldw	r3,12(r2)
 200e814:	e0bffd17 	ldw	r2,-12(fp)
 200e818:	10801017 	ldw	r2,64(r2)
 200e81c:	100d883a 	mov	r6,r2
 200e820:	e17ffe17 	ldw	r5,-8(fp)
 200e824:	1809883a 	mov	r4,r3
 200e828:	20060240 	call	2006024 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 200e82c:	e0bffd17 	ldw	r2,-12(fp)
 200e830:	10c00317 	ldw	r3,12(r2)
 200e834:	e0bffd17 	ldw	r2,-12(fp)
 200e838:	10801017 	ldw	r2,64(r2)
 200e83c:	0085c83a 	sub	r2,zero,r2
 200e840:	1887883a 	add	r3,r3,r2
 200e844:	e0bffd17 	ldw	r2,-12(fp)
 200e848:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 200e84c:	e0bffd17 	ldw	r2,-12(fp)
 200e850:	10c00317 	ldw	r3,12(r2)
 200e854:	e0bffd17 	ldw	r2,-12(fp)
 200e858:	10800017 	ldw	r2,0(r2)
 200e85c:	1880082e 	bgeu	r3,r2,200e880 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 200e860:	e0bffd17 	ldw	r2,-12(fp)
 200e864:	10c00217 	ldw	r3,8(r2)
 200e868:	e0bffd17 	ldw	r2,-12(fp)
 200e86c:	10801017 	ldw	r2,64(r2)
 200e870:	0085c83a 	sub	r2,zero,r2
 200e874:	1887883a 	add	r3,r3,r2
 200e878:	e0bffd17 	ldw	r2,-12(fp)
 200e87c:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 200e880:	e0bfff17 	ldw	r2,-4(fp)
 200e884:	10800098 	cmpnei	r2,r2,2
 200e888:	1000051e 	bne	r2,zero,200e8a0 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 200e88c:	e0bffc17 	ldw	r2,-16(fp)
 200e890:	10000326 	beq	r2,zero,200e8a0 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 200e894:	e0bffc17 	ldw	r2,-16(fp)
 200e898:	10bfffc4 	addi	r2,r2,-1
 200e89c:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 200e8a0:	e0bffc17 	ldw	r2,-16(fp)
 200e8a4:	10c00044 	addi	r3,r2,1
 200e8a8:	e0bffd17 	ldw	r2,-12(fp)
 200e8ac:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 200e8b0:	e0bffb17 	ldw	r2,-20(fp)
}
 200e8b4:	e037883a 	mov	sp,fp
 200e8b8:	dfc00117 	ldw	ra,4(sp)
 200e8bc:	df000017 	ldw	fp,0(sp)
 200e8c0:	dec00204 	addi	sp,sp,8
 200e8c4:	f800283a 	ret

0200e8c8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 200e8c8:	defffc04 	addi	sp,sp,-16
 200e8cc:	dfc00315 	stw	ra,12(sp)
 200e8d0:	df000215 	stw	fp,8(sp)
 200e8d4:	df000204 	addi	fp,sp,8
 200e8d8:	e13ffe15 	stw	r4,-8(fp)
 200e8dc:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 200e8e0:	e0bffe17 	ldw	r2,-8(fp)
 200e8e4:	10801017 	ldw	r2,64(r2)
 200e8e8:	10001826 	beq	r2,zero,200e94c <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 200e8ec:	e0bffe17 	ldw	r2,-8(fp)
 200e8f0:	10c00317 	ldw	r3,12(r2)
 200e8f4:	e0bffe17 	ldw	r2,-8(fp)
 200e8f8:	10801017 	ldw	r2,64(r2)
 200e8fc:	1887883a 	add	r3,r3,r2
 200e900:	e0bffe17 	ldw	r2,-8(fp)
 200e904:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 200e908:	e0bffe17 	ldw	r2,-8(fp)
 200e90c:	10c00317 	ldw	r3,12(r2)
 200e910:	e0bffe17 	ldw	r2,-8(fp)
 200e914:	10800217 	ldw	r2,8(r2)
 200e918:	18800436 	bltu	r3,r2,200e92c <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 200e91c:	e0bffe17 	ldw	r2,-8(fp)
 200e920:	10c00017 	ldw	r3,0(r2)
 200e924:	e0bffe17 	ldw	r2,-8(fp)
 200e928:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 200e92c:	e0bffe17 	ldw	r2,-8(fp)
 200e930:	10c00317 	ldw	r3,12(r2)
 200e934:	e0bffe17 	ldw	r2,-8(fp)
 200e938:	10801017 	ldw	r2,64(r2)
 200e93c:	100d883a 	mov	r6,r2
 200e940:	180b883a 	mov	r5,r3
 200e944:	e13fff17 	ldw	r4,-4(fp)
 200e948:	20060240 	call	2006024 <memcpy>
	}
}
 200e94c:	0001883a 	nop
 200e950:	e037883a 	mov	sp,fp
 200e954:	dfc00117 	ldw	ra,4(sp)
 200e958:	df000017 	ldw	fp,0(sp)
 200e95c:	dec00204 	addi	sp,sp,8
 200e960:	f800283a 	ret

0200e964 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 200e964:	defffc04 	addi	sp,sp,-16
 200e968:	dfc00315 	stw	ra,12(sp)
 200e96c:	df000215 	stw	fp,8(sp)
 200e970:	df000204 	addi	fp,sp,8
 200e974:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 200e978:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e97c:	10000126 	beq	r2,zero,200e984 <prvUnlockQueue+0x20>
 200e980:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 200e984:	e0bfff17 	ldw	r2,-4(fp)
 200e988:	10801143 	ldbu	r2,69(r2)
 200e98c:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 200e990:	00000c06 	br	200e9c4 <prvUnlockQueue+0x60>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 200e994:	e0bfff17 	ldw	r2,-4(fp)
 200e998:	10800917 	ldw	r2,36(r2)
 200e99c:	10000c26 	beq	r2,zero,200e9d0 <prvUnlockQueue+0x6c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 200e9a0:	e0bfff17 	ldw	r2,-4(fp)
 200e9a4:	10800904 	addi	r2,r2,36
 200e9a8:	1009883a 	mov	r4,r2
 200e9ac:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200e9b0:	10000126 	beq	r2,zero,200e9b8 <prvUnlockQueue+0x54>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 200e9b4:	20105500 	call	2010550 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 200e9b8:	e0bffe03 	ldbu	r2,-8(fp)
 200e9bc:	10bfffc4 	addi	r2,r2,-1
 200e9c0:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 200e9c4:	e0bffe07 	ldb	r2,-8(fp)
 200e9c8:	00bff216 	blt	zero,r2,200e994 <__alt_mem_mem_0+0xfcfee994>
 200e9cc:	00000106 	br	200e9d4 <prvUnlockQueue+0x70>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 200e9d0:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 200e9d4:	e0bfff17 	ldw	r2,-4(fp)
 200e9d8:	00ffffc4 	movi	r3,-1
 200e9dc:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 200e9e0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e9e4:	10000126 	beq	r2,zero,200e9ec <prvUnlockQueue+0x88>
 200e9e8:	2010f780 	call	2010f78 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 200e9ec:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200e9f0:	10000126 	beq	r2,zero,200e9f8 <prvUnlockQueue+0x94>
 200e9f4:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 200e9f8:	e0bfff17 	ldw	r2,-4(fp)
 200e9fc:	10801103 	ldbu	r2,68(r2)
 200ea00:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 200ea04:	00000c06 	br	200ea38 <prvUnlockQueue+0xd4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 200ea08:	e0bfff17 	ldw	r2,-4(fp)
 200ea0c:	10800417 	ldw	r2,16(r2)
 200ea10:	10000c26 	beq	r2,zero,200ea44 <prvUnlockQueue+0xe0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 200ea14:	e0bfff17 	ldw	r2,-4(fp)
 200ea18:	10800404 	addi	r2,r2,16
 200ea1c:	1009883a 	mov	r4,r2
 200ea20:	201020c0 	call	201020c <xTaskRemoveFromEventList>
 200ea24:	10000126 	beq	r2,zero,200ea2c <prvUnlockQueue+0xc8>
				{
					vTaskMissedYield();
 200ea28:	20105500 	call	2010550 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 200ea2c:	e0bffe43 	ldbu	r2,-7(fp)
 200ea30:	10bfffc4 	addi	r2,r2,-1
 200ea34:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 200ea38:	e0bffe47 	ldb	r2,-7(fp)
 200ea3c:	00bff216 	blt	zero,r2,200ea08 <__alt_mem_mem_0+0xfcfeea08>
 200ea40:	00000106 	br	200ea48 <prvUnlockQueue+0xe4>

				--cRxLock;
			}
			else
			{
				break;
 200ea44:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 200ea48:	e0bfff17 	ldw	r2,-4(fp)
 200ea4c:	00ffffc4 	movi	r3,-1
 200ea50:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 200ea54:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ea58:	10000126 	beq	r2,zero,200ea60 <prvUnlockQueue+0xfc>
 200ea5c:	2010f780 	call	2010f78 <vTaskExitCritical>
}
 200ea60:	0001883a 	nop
 200ea64:	e037883a 	mov	sp,fp
 200ea68:	dfc00117 	ldw	ra,4(sp)
 200ea6c:	df000017 	ldw	fp,0(sp)
 200ea70:	dec00204 	addi	sp,sp,8
 200ea74:	f800283a 	ret

0200ea78 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 200ea78:	defffc04 	addi	sp,sp,-16
 200ea7c:	dfc00315 	stw	ra,12(sp)
 200ea80:	df000215 	stw	fp,8(sp)
 200ea84:	df000204 	addi	fp,sp,8
 200ea88:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 200ea8c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ea90:	10000126 	beq	r2,zero,200ea98 <prvIsQueueEmpty+0x20>
 200ea94:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 200ea98:	e0bfff17 	ldw	r2,-4(fp)
 200ea9c:	10800e17 	ldw	r2,56(r2)
 200eaa0:	1000031e 	bne	r2,zero,200eab0 <prvIsQueueEmpty+0x38>
		{
			xReturn = pdTRUE;
 200eaa4:	00800044 	movi	r2,1
 200eaa8:	e0bffe15 	stw	r2,-8(fp)
 200eaac:	00000106 	br	200eab4 <prvIsQueueEmpty+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 200eab0:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 200eab4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200eab8:	10000126 	beq	r2,zero,200eac0 <prvIsQueueEmpty+0x48>
 200eabc:	2010f780 	call	2010f78 <vTaskExitCritical>

	return xReturn;
 200eac0:	e0bffe17 	ldw	r2,-8(fp)
}
 200eac4:	e037883a 	mov	sp,fp
 200eac8:	dfc00117 	ldw	ra,4(sp)
 200eacc:	df000017 	ldw	fp,0(sp)
 200ead0:	dec00204 	addi	sp,sp,8
 200ead4:	f800283a 	ret

0200ead8 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 200ead8:	defffc04 	addi	sp,sp,-16
 200eadc:	df000315 	stw	fp,12(sp)
 200eae0:	df000304 	addi	fp,sp,12
 200eae4:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 200eae8:	e0bfff17 	ldw	r2,-4(fp)
 200eaec:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 200eaf0:	e0bffe17 	ldw	r2,-8(fp)
 200eaf4:	10800e17 	ldw	r2,56(r2)
 200eaf8:	1000031e 	bne	r2,zero,200eb08 <xQueueIsQueueEmptyFromISR+0x30>
	{
		xReturn = pdTRUE;
 200eafc:	00800044 	movi	r2,1
 200eb00:	e0bffd15 	stw	r2,-12(fp)
 200eb04:	00000106 	br	200eb0c <xQueueIsQueueEmptyFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 200eb08:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 200eb0c:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 200eb10:	e037883a 	mov	sp,fp
 200eb14:	df000017 	ldw	fp,0(sp)
 200eb18:	dec00104 	addi	sp,sp,4
 200eb1c:	f800283a 	ret

0200eb20 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 200eb20:	defffc04 	addi	sp,sp,-16
 200eb24:	dfc00315 	stw	ra,12(sp)
 200eb28:	df000215 	stw	fp,8(sp)
 200eb2c:	df000204 	addi	fp,sp,8
 200eb30:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 200eb34:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200eb38:	10000126 	beq	r2,zero,200eb40 <prvIsQueueFull+0x20>
 200eb3c:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 200eb40:	e0bfff17 	ldw	r2,-4(fp)
 200eb44:	10c00e17 	ldw	r3,56(r2)
 200eb48:	e0bfff17 	ldw	r2,-4(fp)
 200eb4c:	10800f17 	ldw	r2,60(r2)
 200eb50:	1880031e 	bne	r3,r2,200eb60 <prvIsQueueFull+0x40>
		{
			xReturn = pdTRUE;
 200eb54:	00800044 	movi	r2,1
 200eb58:	e0bffe15 	stw	r2,-8(fp)
 200eb5c:	00000106 	br	200eb64 <prvIsQueueFull+0x44>
		}
		else
		{
			xReturn = pdFALSE;
 200eb60:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 200eb64:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200eb68:	10000126 	beq	r2,zero,200eb70 <prvIsQueueFull+0x50>
 200eb6c:	2010f780 	call	2010f78 <vTaskExitCritical>

	return xReturn;
 200eb70:	e0bffe17 	ldw	r2,-8(fp)
}
 200eb74:	e037883a 	mov	sp,fp
 200eb78:	dfc00117 	ldw	ra,4(sp)
 200eb7c:	df000017 	ldw	fp,0(sp)
 200eb80:	dec00204 	addi	sp,sp,8
 200eb84:	f800283a 	ret

0200eb88 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 200eb88:	defffc04 	addi	sp,sp,-16
 200eb8c:	df000315 	stw	fp,12(sp)
 200eb90:	df000304 	addi	fp,sp,12
 200eb94:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
 200eb98:	e0bfff17 	ldw	r2,-4(fp)
 200eb9c:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 200eba0:	e0bffe17 	ldw	r2,-8(fp)
 200eba4:	10c00e17 	ldw	r3,56(r2)
 200eba8:	e0bffe17 	ldw	r2,-8(fp)
 200ebac:	10800f17 	ldw	r2,60(r2)
 200ebb0:	1880031e 	bne	r3,r2,200ebc0 <xQueueIsQueueFullFromISR+0x38>
	{
		xReturn = pdTRUE;
 200ebb4:	00800044 	movi	r2,1
 200ebb8:	e0bffd15 	stw	r2,-12(fp)
 200ebbc:	00000106 	br	200ebc4 <xQueueIsQueueFullFromISR+0x3c>
	}
	else
	{
		xReturn = pdFALSE;
 200ebc0:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 200ebc4:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 200ebc8:	e037883a 	mov	sp,fp
 200ebcc:	df000017 	ldw	fp,0(sp)
 200ebd0:	dec00104 	addi	sp,sp,4
 200ebd4:	f800283a 	ret

0200ebd8 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 200ebd8:	defffa04 	addi	sp,sp,-24
 200ebdc:	dfc00515 	stw	ra,20(sp)
 200ebe0:	df000415 	stw	fp,16(sp)
 200ebe4:	df000404 	addi	fp,sp,16
 200ebe8:	e13ffd15 	stw	r4,-12(fp)
 200ebec:	e17ffe15 	stw	r5,-8(fp)
 200ebf0:	e1bfff15 	stw	r6,-4(fp)
	Queue_t * const pxQueue = xQueue;
 200ebf4:	e0bffd17 	ldw	r2,-12(fp)
 200ebf8:	e0bffc15 	stw	r2,-16(fp)
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 200ebfc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ec00:	10000126 	beq	r2,zero,200ec08 <vQueueWaitForMessageRestricted+0x30>
 200ec04:	2010f300 	call	2010f30 <vTaskEnterCritical>
 200ec08:	e0bffc17 	ldw	r2,-16(fp)
 200ec0c:	10801103 	ldbu	r2,68(r2)
 200ec10:	10803fcc 	andi	r2,r2,255
 200ec14:	1080201c 	xori	r2,r2,128
 200ec18:	10bfe004 	addi	r2,r2,-128
 200ec1c:	10bfffd8 	cmpnei	r2,r2,-1
 200ec20:	1000021e 	bne	r2,zero,200ec2c <vQueueWaitForMessageRestricted+0x54>
 200ec24:	e0bffc17 	ldw	r2,-16(fp)
 200ec28:	10001105 	stb	zero,68(r2)
 200ec2c:	e0bffc17 	ldw	r2,-16(fp)
 200ec30:	10801143 	ldbu	r2,69(r2)
 200ec34:	10803fcc 	andi	r2,r2,255
 200ec38:	1080201c 	xori	r2,r2,128
 200ec3c:	10bfe004 	addi	r2,r2,-128
 200ec40:	10bfffd8 	cmpnei	r2,r2,-1
 200ec44:	1000021e 	bne	r2,zero,200ec50 <vQueueWaitForMessageRestricted+0x78>
 200ec48:	e0bffc17 	ldw	r2,-16(fp)
 200ec4c:	10001145 	stb	zero,69(r2)
 200ec50:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ec54:	10000126 	beq	r2,zero,200ec5c <vQueueWaitForMessageRestricted+0x84>
 200ec58:	2010f780 	call	2010f78 <vTaskExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 200ec5c:	e0bffc17 	ldw	r2,-16(fp)
 200ec60:	10800e17 	ldw	r2,56(r2)
 200ec64:	1000061e 	bne	r2,zero,200ec80 <vQueueWaitForMessageRestricted+0xa8>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 200ec68:	e0bffc17 	ldw	r2,-16(fp)
 200ec6c:	10800904 	addi	r2,r2,36
 200ec70:	e1bfff17 	ldw	r6,-4(fp)
 200ec74:	e17ffe17 	ldw	r5,-8(fp)
 200ec78:	1009883a 	mov	r4,r2
 200ec7c:	20101a80 	call	20101a8 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 200ec80:	e13ffc17 	ldw	r4,-16(fp)
 200ec84:	200e9640 	call	200e964 <prvUnlockQueue>
	}
 200ec88:	0001883a 	nop
 200ec8c:	e037883a 	mov	sp,fp
 200ec90:	dfc00117 	ldw	ra,4(sp)
 200ec94:	df000017 	ldw	fp,0(sp)
 200ec98:	dec00204 	addi	sp,sp,8
 200ec9c:	f800283a 	ret

0200eca0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 200eca0:	defff304 	addi	sp,sp,-52
 200eca4:	dfc00c15 	stw	ra,48(sp)
 200eca8:	df000b15 	stw	fp,44(sp)
 200ecac:	df000b04 	addi	fp,sp,44
 200ecb0:	e13ffc15 	stw	r4,-16(fp)
 200ecb4:	e17ffd15 	stw	r5,-12(fp)
 200ecb8:	e1bffe15 	stw	r6,-8(fp)
 200ecbc:	e1ffff15 	stw	r7,-4(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 200ecc0:	e0bffe17 	ldw	r2,-8(fp)
 200ecc4:	1085883a 	add	r2,r2,r2
 200ecc8:	1085883a 	add	r2,r2,r2
 200eccc:	1009883a 	mov	r4,r2
 200ecd0:	202bb8c0 	call	202bb8c <pvPortMalloc>
 200ecd4:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 200ecd8:	e0bffb17 	ldw	r2,-20(fp)
 200ecdc:	10000c26 	beq	r2,zero,200ed10 <xTaskCreate+0x70>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 200ece0:	01001e04 	movi	r4,120
 200ece4:	202bb8c0 	call	202bb8c <pvPortMalloc>
 200ece8:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 200ecec:	e0bff917 	ldw	r2,-28(fp)
 200ecf0:	10000426 	beq	r2,zero,200ed04 <xTaskCreate+0x64>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 200ecf4:	e0bff917 	ldw	r2,-28(fp)
 200ecf8:	e0fffb17 	ldw	r3,-20(fp)
 200ecfc:	10c00c15 	stw	r3,48(r2)
 200ed00:	00000406 	br	200ed14 <xTaskCreate+0x74>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 200ed04:	e13ffb17 	ldw	r4,-20(fp)
 200ed08:	202bc580 	call	202bc58 <vPortFree>
 200ed0c:	00000106 	br	200ed14 <xTaskCreate+0x74>
				}
			}
			else
			{
				pxNewTCB = NULL;
 200ed10:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 200ed14:	e0bff917 	ldw	r2,-28(fp)
 200ed18:	10001126 	beq	r2,zero,200ed60 <xTaskCreate+0xc0>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 200ed1c:	d8000315 	stw	zero,12(sp)
 200ed20:	e0bff917 	ldw	r2,-28(fp)
 200ed24:	d8800215 	stw	r2,8(sp)
 200ed28:	e0800317 	ldw	r2,12(fp)
 200ed2c:	d8800115 	stw	r2,4(sp)
 200ed30:	e0800217 	ldw	r2,8(fp)
 200ed34:	d8800015 	stw	r2,0(sp)
 200ed38:	e1ffff17 	ldw	r7,-4(fp)
 200ed3c:	e1bffe17 	ldw	r6,-8(fp)
 200ed40:	e17ffd17 	ldw	r5,-12(fp)
 200ed44:	e13ffc17 	ldw	r4,-16(fp)
 200ed48:	200ed800 	call	200ed80 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 200ed4c:	e13ff917 	ldw	r4,-28(fp)
 200ed50:	200ef640 	call	200ef64 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 200ed54:	00800044 	movi	r2,1
 200ed58:	e0bffa15 	stw	r2,-24(fp)
 200ed5c:	00000206 	br	200ed68 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 200ed60:	00bfffc4 	movi	r2,-1
 200ed64:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 200ed68:	e0bffa17 	ldw	r2,-24(fp)
	}
 200ed6c:	e037883a 	mov	sp,fp
 200ed70:	dfc00117 	ldw	ra,4(sp)
 200ed74:	df000017 	ldw	fp,0(sp)
 200ed78:	dec00204 	addi	sp,sp,8
 200ed7c:	f800283a 	ret

0200ed80 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 200ed80:	defff804 	addi	sp,sp,-32
 200ed84:	dfc00715 	stw	ra,28(sp)
 200ed88:	df000615 	stw	fp,24(sp)
 200ed8c:	df000604 	addi	fp,sp,24
 200ed90:	e13ffc15 	stw	r4,-16(fp)
 200ed94:	e17ffd15 	stw	r5,-12(fp)
 200ed98:	e1bffe15 	stw	r6,-8(fp)
 200ed9c:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 200eda0:	e0800417 	ldw	r2,16(fp)
 200eda4:	10c00c17 	ldw	r3,48(r2)
 200eda8:	e0bffe17 	ldw	r2,-8(fp)
 200edac:	1085883a 	add	r2,r2,r2
 200edb0:	1085883a 	add	r2,r2,r2
 200edb4:	100d883a 	mov	r6,r2
 200edb8:	01402944 	movi	r5,165
 200edbc:	1809883a 	mov	r4,r3
 200edc0:	200616c0 	call	200616c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 200edc4:	e0800417 	ldw	r2,16(fp)
 200edc8:	10c00c17 	ldw	r3,48(r2)
 200edcc:	e13ffe17 	ldw	r4,-8(fp)
 200edd0:	00900034 	movhi	r2,16384
 200edd4:	10bfffc4 	addi	r2,r2,-1
 200edd8:	2085883a 	add	r2,r4,r2
 200eddc:	1085883a 	add	r2,r2,r2
 200ede0:	1085883a 	add	r2,r2,r2
 200ede4:	1885883a 	add	r2,r3,r2
 200ede8:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 200edec:	e0fffb17 	ldw	r3,-20(fp)
 200edf0:	00bfff04 	movi	r2,-4
 200edf4:	1884703a 	and	r2,r3,r2
 200edf8:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 200edfc:	e0bffd17 	ldw	r2,-12(fp)
 200ee00:	10001e26 	beq	r2,zero,200ee7c <prvInitialiseNewTask+0xfc>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 200ee04:	e03ffa15 	stw	zero,-24(fp)
 200ee08:	00001406 	br	200ee5c <prvInitialiseNewTask+0xdc>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 200ee0c:	e0fffd17 	ldw	r3,-12(fp)
 200ee10:	e0bffa17 	ldw	r2,-24(fp)
 200ee14:	1885883a 	add	r2,r3,r2
 200ee18:	10c00003 	ldbu	r3,0(r2)
 200ee1c:	e1000417 	ldw	r4,16(fp)
 200ee20:	e0bffa17 	ldw	r2,-24(fp)
 200ee24:	2085883a 	add	r2,r4,r2
 200ee28:	10800d04 	addi	r2,r2,52
 200ee2c:	10c00005 	stb	r3,0(r2)

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 200ee30:	e0fffd17 	ldw	r3,-12(fp)
 200ee34:	e0bffa17 	ldw	r2,-24(fp)
 200ee38:	1885883a 	add	r2,r3,r2
 200ee3c:	10800003 	ldbu	r2,0(r2)
 200ee40:	10803fcc 	andi	r2,r2,255
 200ee44:	1080201c 	xori	r2,r2,128
 200ee48:	10bfe004 	addi	r2,r2,-128
 200ee4c:	10000726 	beq	r2,zero,200ee6c <prvInitialiseNewTask+0xec>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 200ee50:	e0bffa17 	ldw	r2,-24(fp)
 200ee54:	10800044 	addi	r2,r2,1
 200ee58:	e0bffa15 	stw	r2,-24(fp)
 200ee5c:	e0bffa17 	ldw	r2,-24(fp)
 200ee60:	10800a30 	cmpltui	r2,r2,40
 200ee64:	103fe91e 	bne	r2,zero,200ee0c <__alt_mem_mem_0+0xfcfeee0c>
 200ee68:	00000106 	br	200ee70 <prvInitialiseNewTask+0xf0>
			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
			{
				break;
 200ee6c:	0001883a 	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 200ee70:	e0800417 	ldw	r2,16(fp)
 200ee74:	100016c5 	stb	zero,91(r2)
 200ee78:	00000206 	br	200ee84 <prvInitialiseNewTask+0x104>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 200ee7c:	e0800417 	ldw	r2,16(fp)
 200ee80:	10000d05 	stb	zero,52(r2)
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 200ee84:	e0800217 	ldw	r2,8(fp)
 200ee88:	10800170 	cmpltui	r2,r2,5
 200ee8c:	1000021e 	bne	r2,zero,200ee98 <prvInitialiseNewTask+0x118>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 200ee90:	00800104 	movi	r2,4
 200ee94:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 200ee98:	e0800417 	ldw	r2,16(fp)
 200ee9c:	e0c00217 	ldw	r3,8(fp)
 200eea0:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 200eea4:	e0800417 	ldw	r2,16(fp)
 200eea8:	e0c00217 	ldw	r3,8(fp)
 200eeac:	10c01a15 	stw	r3,104(r2)
		pxNewTCB->uxMutexesHeld = 0;
 200eeb0:	e0800417 	ldw	r2,16(fp)
 200eeb4:	10001b15 	stw	zero,108(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 200eeb8:	e0800417 	ldw	r2,16(fp)
 200eebc:	10800104 	addi	r2,r2,4
 200eec0:	1009883a 	mov	r4,r2
 200eec4:	202bd340 	call	202bd34 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 200eec8:	e0800417 	ldw	r2,16(fp)
 200eecc:	10800604 	addi	r2,r2,24
 200eed0:	1009883a 	mov	r4,r2
 200eed4:	202bd340 	call	202bd34 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 200eed8:	e0800417 	ldw	r2,16(fp)
 200eedc:	e0c00417 	ldw	r3,16(fp)
 200eee0:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200eee4:	00c00144 	movi	r3,5
 200eee8:	e0800217 	ldw	r2,8(fp)
 200eeec:	1887c83a 	sub	r3,r3,r2
 200eef0:	e0800417 	ldw	r2,16(fp)
 200eef4:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 200eef8:	e0800417 	ldw	r2,16(fp)
 200eefc:	e0c00417 	ldw	r3,16(fp)
 200ef00:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 200ef04:	e0800417 	ldw	r2,16(fp)
 200ef08:	10001715 	stw	zero,92(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 200ef0c:	e0800417 	ldw	r2,16(fp)
 200ef10:	10001c15 	stw	zero,112(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 200ef14:	e0800417 	ldw	r2,16(fp)
 200ef18:	10001d05 	stb	zero,116(r2)
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 200ef1c:	e1bfff17 	ldw	r6,-4(fp)
 200ef20:	e17ffc17 	ldw	r5,-16(fp)
 200ef24:	e13ffb17 	ldw	r4,-20(fp)
 200ef28:	202c0140 	call	202c014 <pxPortInitialiseStack>
 200ef2c:	1007883a 	mov	r3,r2
 200ef30:	e0800417 	ldw	r2,16(fp)
 200ef34:	10c00015 	stw	r3,0(r2)
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 200ef38:	e0800317 	ldw	r2,12(fp)
 200ef3c:	10000326 	beq	r2,zero,200ef4c <prvInitialiseNewTask+0x1cc>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 200ef40:	e0800317 	ldw	r2,12(fp)
 200ef44:	e0c00417 	ldw	r3,16(fp)
 200ef48:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 200ef4c:	0001883a 	nop
 200ef50:	e037883a 	mov	sp,fp
 200ef54:	dfc00117 	ldw	ra,4(sp)
 200ef58:	df000017 	ldw	fp,0(sp)
 200ef5c:	dec00204 	addi	sp,sp,8
 200ef60:	f800283a 	ret

0200ef64 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 200ef64:	defffd04 	addi	sp,sp,-12
 200ef68:	dfc00215 	stw	ra,8(sp)
 200ef6c:	df000115 	stw	fp,4(sp)
 200ef70:	df000104 	addi	fp,sp,4
 200ef74:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 200ef78:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200ef7c:	10000126 	beq	r2,zero,200ef84 <prvAddNewTaskToReadyList+0x20>
 200ef80:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 200ef84:	d0a7d717 	ldw	r2,-24740(gp)
 200ef88:	10800044 	addi	r2,r2,1
 200ef8c:	d0a7d715 	stw	r2,-24740(gp)
		if( pxCurrentTCB == NULL )
 200ef90:	d0a7d317 	ldw	r2,-24756(gp)
 200ef94:	1000071e 	bne	r2,zero,200efb4 <prvAddNewTaskToReadyList+0x50>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 200ef98:	e0bfff17 	ldw	r2,-4(fp)
 200ef9c:	d0a7d315 	stw	r2,-24756(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 200efa0:	d0a7d717 	ldw	r2,-24740(gp)
 200efa4:	10800058 	cmpnei	r2,r2,1
 200efa8:	10000b1e 	bne	r2,zero,200efd8 <prvAddNewTaskToReadyList+0x74>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 200efac:	20106200 	call	2010620 <prvInitialiseTaskLists>
 200efb0:	00000906 	br	200efd8 <prvAddNewTaskToReadyList+0x74>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 200efb4:	d0a7da17 	ldw	r2,-24728(gp)
 200efb8:	1000071e 	bne	r2,zero,200efd8 <prvAddNewTaskToReadyList+0x74>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 200efbc:	d0a7d317 	ldw	r2,-24756(gp)
 200efc0:	10800b17 	ldw	r2,44(r2)
 200efc4:	e0ffff17 	ldw	r3,-4(fp)
 200efc8:	18c00b17 	ldw	r3,44(r3)
 200efcc:	18800236 	bltu	r3,r2,200efd8 <prvAddNewTaskToReadyList+0x74>
				{
					pxCurrentTCB = pxNewTCB;
 200efd0:	e0bfff17 	ldw	r2,-4(fp)
 200efd4:	d0a7d315 	stw	r2,-24756(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 200efd8:	d0a7de17 	ldw	r2,-24712(gp)
 200efdc:	10800044 	addi	r2,r2,1
 200efe0:	d0a7de15 	stw	r2,-24712(gp)

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 200efe4:	d0e7de17 	ldw	r3,-24712(gp)
 200efe8:	e0bfff17 	ldw	r2,-4(fp)
 200efec:	10c01815 	stw	r3,96(r2)
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 200eff0:	e0bfff17 	ldw	r2,-4(fp)
 200eff4:	10800b17 	ldw	r2,44(r2)
 200eff8:	d0e7d917 	ldw	r3,-24732(gp)
 200effc:	1880032e 	bgeu	r3,r2,200f00c <prvAddNewTaskToReadyList+0xa8>
 200f000:	e0bfff17 	ldw	r2,-4(fp)
 200f004:	10800b17 	ldw	r2,44(r2)
 200f008:	d0a7d915 	stw	r2,-24732(gp)
 200f00c:	e0bfff17 	ldw	r2,-4(fp)
 200f010:	10800b17 	ldw	r2,44(r2)
 200f014:	10c00524 	muli	r3,r2,20
 200f018:	00808134 	movhi	r2,516
 200f01c:	109e6704 	addi	r2,r2,31132
 200f020:	1887883a 	add	r3,r3,r2
 200f024:	e0bfff17 	ldw	r2,-4(fp)
 200f028:	10800104 	addi	r2,r2,4
 200f02c:	100b883a 	mov	r5,r2
 200f030:	1809883a 	mov	r4,r3
 200f034:	202bd600 	call	202bd60 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 200f038:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f03c:	10000126 	beq	r2,zero,200f044 <prvAddNewTaskToReadyList+0xe0>
 200f040:	2010f780 	call	2010f78 <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 200f044:	d0a7da17 	ldw	r2,-24728(gp)
 200f048:	10000626 	beq	r2,zero,200f064 <prvAddNewTaskToReadyList+0x100>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 200f04c:	d0a7d317 	ldw	r2,-24756(gp)
 200f050:	10c00b17 	ldw	r3,44(r2)
 200f054:	e0bfff17 	ldw	r2,-4(fp)
 200f058:	10800b17 	ldw	r2,44(r2)
 200f05c:	1880012e 	bgeu	r3,r2,200f064 <prvAddNewTaskToReadyList+0x100>
		{
			taskYIELD_IF_USING_PREEMPTION();
 200f060:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 200f064:	0001883a 	nop
 200f068:	e037883a 	mov	sp,fp
 200f06c:	dfc00117 	ldw	ra,4(sp)
 200f070:	df000017 	ldw	fp,0(sp)
 200f074:	dec00204 	addi	sp,sp,8
 200f078:	f800283a 	ret

0200f07c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 200f07c:	defffc04 	addi	sp,sp,-16
 200f080:	dfc00315 	stw	ra,12(sp)
 200f084:	df000215 	stw	fp,8(sp)
 200f088:	df000204 	addi	fp,sp,8
 200f08c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 200f090:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f094:	10000126 	beq	r2,zero,200f09c <vTaskDelete+0x20>
 200f098:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 200f09c:	e0bfff17 	ldw	r2,-4(fp)
 200f0a0:	1000021e 	bne	r2,zero,200f0ac <vTaskDelete+0x30>
 200f0a4:	d0a7d317 	ldw	r2,-24756(gp)
 200f0a8:	00000106 	br	200f0b0 <vTaskDelete+0x34>
 200f0ac:	e0bfff17 	ldw	r2,-4(fp)
 200f0b0:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200f0b4:	e0bffe17 	ldw	r2,-8(fp)
 200f0b8:	10800104 	addi	r2,r2,4
 200f0bc:	1009883a 	mov	r4,r2
 200f0c0:	202bec40 	call	202bec4 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200f0c4:	e0bffe17 	ldw	r2,-8(fp)
 200f0c8:	10800a17 	ldw	r2,40(r2)
 200f0cc:	10000426 	beq	r2,zero,200f0e0 <vTaskDelete+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200f0d0:	e0bffe17 	ldw	r2,-8(fp)
 200f0d4:	10800604 	addi	r2,r2,24
 200f0d8:	1009883a 	mov	r4,r2
 200f0dc:	202bec40 	call	202bec4 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 200f0e0:	d0a7de17 	ldw	r2,-24712(gp)
 200f0e4:	10800044 	addi	r2,r2,1
 200f0e8:	d0a7de15 	stw	r2,-24712(gp)

			if( pxTCB == pxCurrentTCB )
 200f0ec:	d0a7d317 	ldw	r2,-24756(gp)
 200f0f0:	e0fffe17 	ldw	r3,-8(fp)
 200f0f4:	18800a1e 	bne	r3,r2,200f120 <vTaskDelete+0xa4>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 200f0f8:	e0bffe17 	ldw	r2,-8(fp)
 200f0fc:	10800104 	addi	r2,r2,4
 200f100:	100b883a 	mov	r5,r2
 200f104:	01008134 	movhi	r4,516
 200f108:	211e8f04 	addi	r4,r4,31292
 200f10c:	202bd600 	call	202bd60 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 200f110:	d0a7d617 	ldw	r2,-24744(gp)
 200f114:	10800044 	addi	r2,r2,1
 200f118:	d0a7d615 	stw	r2,-24744(gp)
 200f11c:	00000606 	br	200f138 <vTaskDelete+0xbc>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 200f120:	d0a7d717 	ldw	r2,-24740(gp)
 200f124:	10bfffc4 	addi	r2,r2,-1
 200f128:	d0a7d715 	stw	r2,-24740(gp)
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
 200f12c:	e13ffe17 	ldw	r4,-8(fp)
 200f130:	2010aa80 	call	2010aa8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 200f134:	2010aec0 	call	2010aec <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
 200f138:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f13c:	10000126 	beq	r2,zero,200f144 <vTaskDelete+0xc8>
 200f140:	2010f780 	call	2010f78 <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 200f144:	d0a7da17 	ldw	r2,-24728(gp)
 200f148:	10000426 	beq	r2,zero,200f15c <vTaskDelete+0xe0>
		{
			if( pxTCB == pxCurrentTCB )
 200f14c:	d0a7d317 	ldw	r2,-24756(gp)
 200f150:	e0fffe17 	ldw	r3,-8(fp)
 200f154:	1880011e 	bne	r3,r2,200f15c <vTaskDelete+0xe0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 200f158:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 200f15c:	0001883a 	nop
 200f160:	e037883a 	mov	sp,fp
 200f164:	dfc00117 	ldw	ra,4(sp)
 200f168:	df000017 	ldw	fp,0(sp)
 200f16c:	dec00204 	addi	sp,sp,8
 200f170:	f800283a 	ret

0200f174 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 200f174:	defff804 	addi	sp,sp,-32
 200f178:	dfc00715 	stw	ra,28(sp)
 200f17c:	df000615 	stw	fp,24(sp)
 200f180:	df000604 	addi	fp,sp,24
 200f184:	e13ffe15 	stw	r4,-8(fp)
 200f188:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 200f18c:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 200f190:	200fa500 	call	200fa50 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 200f194:	d0a7d817 	ldw	r2,-24736(gp)
 200f198:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 200f19c:	e0bffe17 	ldw	r2,-8(fp)
 200f1a0:	10c00017 	ldw	r3,0(r2)
 200f1a4:	e0bfff17 	ldw	r2,-4(fp)
 200f1a8:	1885883a 	add	r2,r3,r2
 200f1ac:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 200f1b0:	e0bffe17 	ldw	r2,-8(fp)
 200f1b4:	10800017 	ldw	r2,0(r2)
 200f1b8:	e0fffb17 	ldw	r3,-20(fp)
 200f1bc:	18800a2e 	bgeu	r3,r2,200f1e8 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 200f1c0:	e0bffe17 	ldw	r2,-8(fp)
 200f1c4:	10800017 	ldw	r2,0(r2)
 200f1c8:	e0fffc17 	ldw	r3,-16(fp)
 200f1cc:	18800f2e 	bgeu	r3,r2,200f20c <vTaskDelayUntil+0x98>
 200f1d0:	e0bffc17 	ldw	r2,-16(fp)
 200f1d4:	e0fffb17 	ldw	r3,-20(fp)
 200f1d8:	18800c2e 	bgeu	r3,r2,200f20c <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 200f1dc:	00800044 	movi	r2,1
 200f1e0:	e0bffa15 	stw	r2,-24(fp)
 200f1e4:	00000906 	br	200f20c <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 200f1e8:	e0bffe17 	ldw	r2,-8(fp)
 200f1ec:	10800017 	ldw	r2,0(r2)
 200f1f0:	e0fffc17 	ldw	r3,-16(fp)
 200f1f4:	18800336 	bltu	r3,r2,200f204 <vTaskDelayUntil+0x90>
 200f1f8:	e0bffc17 	ldw	r2,-16(fp)
 200f1fc:	e0fffb17 	ldw	r3,-20(fp)
 200f200:	1880022e 	bgeu	r3,r2,200f20c <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 200f204:	00800044 	movi	r2,1
 200f208:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 200f20c:	e0bffe17 	ldw	r2,-8(fp)
 200f210:	e0fffc17 	ldw	r3,-16(fp)
 200f214:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 200f218:	e0bffa17 	ldw	r2,-24(fp)
 200f21c:	10000626 	beq	r2,zero,200f238 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 200f220:	e0fffc17 	ldw	r3,-16(fp)
 200f224:	e0bffb17 	ldw	r2,-20(fp)
 200f228:	1885c83a 	sub	r2,r3,r2
 200f22c:	000b883a 	mov	r5,zero
 200f230:	1009883a 	mov	r4,r2
 200f234:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 200f238:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200f23c:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 200f240:	e0bffd17 	ldw	r2,-12(fp)
 200f244:	1000011e 	bne	r2,zero,200f24c <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 200f248:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f24c:	0001883a 	nop
 200f250:	e037883a 	mov	sp,fp
 200f254:	dfc00117 	ldw	ra,4(sp)
 200f258:	df000017 	ldw	fp,0(sp)
 200f25c:	dec00204 	addi	sp,sp,8
 200f260:	f800283a 	ret

0200f264 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 200f264:	defffc04 	addi	sp,sp,-16
 200f268:	dfc00315 	stw	ra,12(sp)
 200f26c:	df000215 	stw	fp,8(sp)
 200f270:	df000204 	addi	fp,sp,8
 200f274:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 200f278:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 200f27c:	e0bfff17 	ldw	r2,-4(fp)
 200f280:	10000626 	beq	r2,zero,200f29c <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 200f284:	200fa500 	call	200fa50 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 200f288:	000b883a 	mov	r5,zero
 200f28c:	e13fff17 	ldw	r4,-4(fp)
 200f290:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 200f294:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200f298:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 200f29c:	e0bffe17 	ldw	r2,-8(fp)
 200f2a0:	1000011e 	bne	r2,zero,200f2a8 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 200f2a4:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f2a8:	0001883a 	nop
 200f2ac:	e037883a 	mov	sp,fp
 200f2b0:	dfc00117 	ldw	ra,4(sp)
 200f2b4:	df000017 	ldw	fp,0(sp)
 200f2b8:	dec00204 	addi	sp,sp,8
 200f2bc:	f800283a 	ret

0200f2c0 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
 200f2c0:	defff804 	addi	sp,sp,-32
 200f2c4:	dfc00715 	stw	ra,28(sp)
 200f2c8:	df000615 	stw	fp,24(sp)
 200f2cc:	df000604 	addi	fp,sp,24
 200f2d0:	e13fff15 	stw	r4,-4(fp)
	eTaskState eReturn;
	List_t const * pxStateList, *pxDelayedList, *pxOverflowedDelayedList;
	const TCB_t * const pxTCB = xTask;
 200f2d4:	e0bfff17 	ldw	r2,-4(fp)
 200f2d8:	e0bffb15 	stw	r2,-20(fp)

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
 200f2dc:	d0a7d317 	ldw	r2,-24756(gp)
 200f2e0:	e0fffb17 	ldw	r3,-20(fp)
 200f2e4:	1880021e 	bne	r3,r2,200f2f0 <eTaskGetState+0x30>
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
 200f2e8:	e03ffa15 	stw	zero,-24(fp)
 200f2ec:	00003606 	br	200f3c8 <eTaskGetState+0x108>
		}
		else
		{
			taskENTER_CRITICAL();
 200f2f0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f2f4:	10000126 	beq	r2,zero,200f2fc <eTaskGetState+0x3c>
 200f2f8:	2010f300 	call	2010f30 <vTaskEnterCritical>
			{
				pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 200f2fc:	e0bffb17 	ldw	r2,-20(fp)
 200f300:	10800517 	ldw	r2,20(r2)
 200f304:	e0bffc15 	stw	r2,-16(fp)
				pxDelayedList = pxDelayedTaskList;
 200f308:	d0a7d417 	ldw	r2,-24752(gp)
 200f30c:	e0bffd15 	stw	r2,-12(fp)
				pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 200f310:	d0a7d517 	ldw	r2,-24748(gp)
 200f314:	e0bffe15 	stw	r2,-8(fp)
			}
			taskEXIT_CRITICAL();
 200f318:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f31c:	10000126 	beq	r2,zero,200f324 <eTaskGetState+0x64>
 200f320:	2010f780 	call	2010f78 <vTaskExitCritical>

			if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 200f324:	e0fffc17 	ldw	r3,-16(fp)
 200f328:	e0bffd17 	ldw	r2,-12(fp)
 200f32c:	18800326 	beq	r3,r2,200f33c <eTaskGetState+0x7c>
 200f330:	e0fffc17 	ldw	r3,-16(fp)
 200f334:	e0bffe17 	ldw	r2,-8(fp)
 200f338:	1880031e 	bne	r3,r2,200f348 <eTaskGetState+0x88>
			{
				/* The task being queried is referenced from one of the Blocked
				lists. */
				eReturn = eBlocked;
 200f33c:	00800084 	movi	r2,2
 200f340:	e0bffa15 	stw	r2,-24(fp)
 200f344:	00002006 	br	200f3c8 <eTaskGetState+0x108>
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
 200f348:	e0fffc17 	ldw	r3,-16(fp)
 200f34c:	00808134 	movhi	r2,516
 200f350:	109e9404 	addi	r2,r2,31312
 200f354:	1880111e 	bne	r3,r2,200f39c <eTaskGetState+0xdc>
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it blocked
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 200f358:	e0bffb17 	ldw	r2,-20(fp)
 200f35c:	10800a17 	ldw	r2,40(r2)
 200f360:	10000b1e 	bne	r2,zero,200f390 <eTaskGetState+0xd0>
						{
							/* The task does not appear on the event list item of
							and of the RTOS objects, but could still be in the
							blocked state if it is waiting on its notification
							rather than waiting on an object. */
							if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 200f364:	e0bffb17 	ldw	r2,-20(fp)
 200f368:	10801d03 	ldbu	r2,116(r2)
 200f36c:	10803fcc 	andi	r2,r2,255
 200f370:	10800058 	cmpnei	r2,r2,1
 200f374:	1000031e 	bne	r2,zero,200f384 <eTaskGetState+0xc4>
							{
								eReturn = eBlocked;
 200f378:	00800084 	movi	r2,2
 200f37c:	e0bffa15 	stw	r2,-24(fp)
 200f380:	00001106 	br	200f3c8 <eTaskGetState+0x108>
							}
							else
							{
								eReturn = eSuspended;
 200f384:	008000c4 	movi	r2,3
 200f388:	e0bffa15 	stw	r2,-24(fp)
 200f38c:	00000e06 	br	200f3c8 <eTaskGetState+0x108>
						}
						#endif
					}
					else
					{
						eReturn = eBlocked;
 200f390:	00800084 	movi	r2,2
 200f394:	e0bffa15 	stw	r2,-24(fp)
 200f398:	00000b06 	br	200f3c8 <eTaskGetState+0x108>
					}
				}
			#endif

			#if ( INCLUDE_vTaskDelete == 1 )
				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 200f39c:	e0fffc17 	ldw	r3,-16(fp)
 200f3a0:	00808134 	movhi	r2,516
 200f3a4:	109e8f04 	addi	r2,r2,31292
 200f3a8:	18800226 	beq	r3,r2,200f3b4 <eTaskGetState+0xf4>
 200f3ac:	e0bffc17 	ldw	r2,-16(fp)
 200f3b0:	1000031e 	bne	r2,zero,200f3c0 <eTaskGetState+0x100>
				{
					/* The task being queried is referenced from the deleted
					tasks list, or it is not referenced from any lists at
					all. */
					eReturn = eDeleted;
 200f3b4:	00800104 	movi	r2,4
 200f3b8:	e0bffa15 	stw	r2,-24(fp)
 200f3bc:	00000206 	br	200f3c8 <eTaskGetState+0x108>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
 200f3c0:	00800044 	movi	r2,1
 200f3c4:	e0bffa15 	stw	r2,-24(fp)
			}
		}

		return eReturn;
 200f3c8:	e0bffa17 	ldw	r2,-24(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 200f3cc:	e037883a 	mov	sp,fp
 200f3d0:	dfc00117 	ldw	ra,4(sp)
 200f3d4:	df000017 	ldw	fp,0(sp)
 200f3d8:	dec00204 	addi	sp,sp,8
 200f3dc:	f800283a 	ret

0200f3e0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
 200f3e0:	defffb04 	addi	sp,sp,-20
 200f3e4:	dfc00415 	stw	ra,16(sp)
 200f3e8:	df000315 	stw	fp,12(sp)
 200f3ec:	df000304 	addi	fp,sp,12
 200f3f0:	e13fff15 	stw	r4,-4(fp)
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 200f3f4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f3f8:	10000126 	beq	r2,zero,200f400 <uxTaskPriorityGet+0x20>
 200f3fc:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f400:	e0bfff17 	ldw	r2,-4(fp)
 200f404:	1000021e 	bne	r2,zero,200f410 <uxTaskPriorityGet+0x30>
 200f408:	d0a7d317 	ldw	r2,-24756(gp)
 200f40c:	00000106 	br	200f414 <uxTaskPriorityGet+0x34>
 200f410:	e0bfff17 	ldw	r2,-4(fp)
 200f414:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 200f418:	e0bffd17 	ldw	r2,-12(fp)
 200f41c:	10800b17 	ldw	r2,44(r2)
 200f420:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 200f424:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f428:	10000126 	beq	r2,zero,200f430 <uxTaskPriorityGet+0x50>
 200f42c:	2010f780 	call	2010f78 <vTaskExitCritical>

		return uxReturn;
 200f430:	e0bffe17 	ldw	r2,-8(fp)
	}
 200f434:	e037883a 	mov	sp,fp
 200f438:	dfc00117 	ldw	ra,4(sp)
 200f43c:	df000017 	ldw	fp,0(sp)
 200f440:	dec00204 	addi	sp,sp,8
 200f444:	f800283a 	ret

0200f448 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
 200f448:	defffb04 	addi	sp,sp,-20
 200f44c:	df000415 	stw	fp,16(sp)
 200f450:	df000404 	addi	fp,sp,16
 200f454:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 200f458:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f45c:	e0bfff17 	ldw	r2,-4(fp)
 200f460:	1000021e 	bne	r2,zero,200f46c <uxTaskPriorityGetFromISR+0x24>
 200f464:	d0a7d317 	ldw	r2,-24756(gp)
 200f468:	00000106 	br	200f470 <uxTaskPriorityGetFromISR+0x28>
 200f46c:	e0bfff17 	ldw	r2,-4(fp)
 200f470:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 200f474:	e0bffd17 	ldw	r2,-12(fp)
 200f478:	10800b17 	ldw	r2,44(r2)
 200f47c:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 200f480:	e0bffe17 	ldw	r2,-8(fp)
	}
 200f484:	e037883a 	mov	sp,fp
 200f488:	df000017 	ldw	fp,0(sp)
 200f48c:	dec00104 	addi	sp,sp,4
 200f490:	f800283a 	ret

0200f494 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 200f494:	defff804 	addi	sp,sp,-32
 200f498:	dfc00715 	stw	ra,28(sp)
 200f49c:	df000615 	stw	fp,24(sp)
 200f4a0:	df000604 	addi	fp,sp,24
 200f4a4:	e13ffe15 	stw	r4,-8(fp)
 200f4a8:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 200f4ac:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 200f4b0:	e0bfff17 	ldw	r2,-4(fp)
 200f4b4:	10800170 	cmpltui	r2,r2,5
 200f4b8:	1000021e 	bne	r2,zero,200f4c4 <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 200f4bc:	00800104 	movi	r2,4
 200f4c0:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 200f4c4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f4c8:	10000126 	beq	r2,zero,200f4d0 <vTaskPrioritySet+0x3c>
 200f4cc:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 200f4d0:	e0bffe17 	ldw	r2,-8(fp)
 200f4d4:	1000021e 	bne	r2,zero,200f4e0 <vTaskPrioritySet+0x4c>
 200f4d8:	d0a7d317 	ldw	r2,-24756(gp)
 200f4dc:	00000106 	br	200f4e4 <vTaskPrioritySet+0x50>
 200f4e0:	e0bffe17 	ldw	r2,-8(fp)
 200f4e4:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 200f4e8:	e0bffb17 	ldw	r2,-20(fp)
 200f4ec:	10801a17 	ldw	r2,104(r2)
 200f4f0:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 200f4f4:	e0fffc17 	ldw	r3,-16(fp)
 200f4f8:	e0bfff17 	ldw	r2,-4(fp)
 200f4fc:	18804926 	beq	r3,r2,200f624 <vTaskPrioritySet+0x190>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 200f500:	e0bfff17 	ldw	r2,-4(fp)
 200f504:	e0fffc17 	ldw	r3,-16(fp)
 200f508:	18800a2e 	bgeu	r3,r2,200f534 <vTaskPrioritySet+0xa0>
				{
					if( pxTCB != pxCurrentTCB )
 200f50c:	d0a7d317 	ldw	r2,-24756(gp)
 200f510:	e0fffb17 	ldw	r3,-20(fp)
 200f514:	18800c26 	beq	r3,r2,200f548 <vTaskPrioritySet+0xb4>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 200f518:	d0a7d317 	ldw	r2,-24756(gp)
 200f51c:	10800b17 	ldw	r2,44(r2)
 200f520:	e0ffff17 	ldw	r3,-4(fp)
 200f524:	18800836 	bltu	r3,r2,200f548 <vTaskPrioritySet+0xb4>
						{
							xYieldRequired = pdTRUE;
 200f528:	00800044 	movi	r2,1
 200f52c:	e0bffa15 	stw	r2,-24(fp)
 200f530:	00000506 	br	200f548 <vTaskPrioritySet+0xb4>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 200f534:	d0a7d317 	ldw	r2,-24756(gp)
 200f538:	e0fffb17 	ldw	r3,-20(fp)
 200f53c:	1880021e 	bne	r3,r2,200f548 <vTaskPrioritySet+0xb4>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 200f540:	00800044 	movi	r2,1
 200f544:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 200f548:	e0bffb17 	ldw	r2,-20(fp)
 200f54c:	10800b17 	ldw	r2,44(r2)
 200f550:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 200f554:	e0bffb17 	ldw	r2,-20(fp)
 200f558:	10c01a17 	ldw	r3,104(r2)
 200f55c:	e0bffb17 	ldw	r2,-20(fp)
 200f560:	10800b17 	ldw	r2,44(r2)
 200f564:	1880031e 	bne	r3,r2,200f574 <vTaskPrioritySet+0xe0>
					{
						pxTCB->uxPriority = uxNewPriority;
 200f568:	e0bffb17 	ldw	r2,-20(fp)
 200f56c:	e0ffff17 	ldw	r3,-4(fp)
 200f570:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 200f574:	e0bffb17 	ldw	r2,-20(fp)
 200f578:	e0ffff17 	ldw	r3,-4(fp)
 200f57c:	10c01a15 	stw	r3,104(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 200f580:	e0bffb17 	ldw	r2,-20(fp)
 200f584:	10800617 	ldw	r2,24(r2)
 200f588:	10000516 	blt	r2,zero,200f5a0 <vTaskPrioritySet+0x10c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200f58c:	00c00144 	movi	r3,5
 200f590:	e0bfff17 	ldw	r2,-4(fp)
 200f594:	1887c83a 	sub	r3,r3,r2
 200f598:	e0bffb17 	ldw	r2,-20(fp)
 200f59c:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 200f5a0:	e0bffb17 	ldw	r2,-20(fp)
 200f5a4:	10c00517 	ldw	r3,20(r2)
 200f5a8:	e0bffd17 	ldw	r2,-12(fp)
 200f5ac:	11000524 	muli	r4,r2,20
 200f5b0:	00808134 	movhi	r2,516
 200f5b4:	109e6704 	addi	r2,r2,31132
 200f5b8:	2085883a 	add	r2,r4,r2
 200f5bc:	1880161e 	bne	r3,r2,200f618 <vTaskPrioritySet+0x184>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200f5c0:	e0bffb17 	ldw	r2,-20(fp)
 200f5c4:	10800104 	addi	r2,r2,4
 200f5c8:	1009883a 	mov	r4,r2
 200f5cc:	202bec40 	call	202bec4 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 200f5d0:	e0bffb17 	ldw	r2,-20(fp)
 200f5d4:	10800b17 	ldw	r2,44(r2)
 200f5d8:	d0e7d917 	ldw	r3,-24732(gp)
 200f5dc:	1880032e 	bgeu	r3,r2,200f5ec <vTaskPrioritySet+0x158>
 200f5e0:	e0bffb17 	ldw	r2,-20(fp)
 200f5e4:	10800b17 	ldw	r2,44(r2)
 200f5e8:	d0a7d915 	stw	r2,-24732(gp)
 200f5ec:	e0bffb17 	ldw	r2,-20(fp)
 200f5f0:	10800b17 	ldw	r2,44(r2)
 200f5f4:	10c00524 	muli	r3,r2,20
 200f5f8:	00808134 	movhi	r2,516
 200f5fc:	109e6704 	addi	r2,r2,31132
 200f600:	1887883a 	add	r3,r3,r2
 200f604:	e0bffb17 	ldw	r2,-20(fp)
 200f608:	10800104 	addi	r2,r2,4
 200f60c:	100b883a 	mov	r5,r2
 200f610:	1809883a 	mov	r4,r3
 200f614:	202bd600 	call	202bd60 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 200f618:	e0bffa17 	ldw	r2,-24(fp)
 200f61c:	10000126 	beq	r2,zero,200f624 <vTaskPrioritySet+0x190>
				{
					taskYIELD_IF_USING_PREEMPTION();
 200f620:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 200f624:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f628:	10000126 	beq	r2,zero,200f630 <vTaskPrioritySet+0x19c>
 200f62c:	2010f780 	call	2010f78 <vTaskExitCritical>
	}
 200f630:	0001883a 	nop
 200f634:	e037883a 	mov	sp,fp
 200f638:	dfc00117 	ldw	ra,4(sp)
 200f63c:	df000017 	ldw	fp,0(sp)
 200f640:	dec00204 	addi	sp,sp,8
 200f644:	f800283a 	ret

0200f648 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 200f648:	defffc04 	addi	sp,sp,-16
 200f64c:	dfc00315 	stw	ra,12(sp)
 200f650:	df000215 	stw	fp,8(sp)
 200f654:	df000204 	addi	fp,sp,8
 200f658:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 200f65c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f660:	10000126 	beq	r2,zero,200f668 <vTaskSuspend+0x20>
 200f664:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 200f668:	e0bfff17 	ldw	r2,-4(fp)
 200f66c:	1000021e 	bne	r2,zero,200f678 <vTaskSuspend+0x30>
 200f670:	d0a7d317 	ldw	r2,-24756(gp)
 200f674:	00000106 	br	200f67c <vTaskSuspend+0x34>
 200f678:	e0bfff17 	ldw	r2,-4(fp)
 200f67c:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 200f680:	e0bffe17 	ldw	r2,-8(fp)
 200f684:	10800104 	addi	r2,r2,4
 200f688:	1009883a 	mov	r4,r2
 200f68c:	202bec40 	call	202bec4 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200f690:	e0bffe17 	ldw	r2,-8(fp)
 200f694:	10800a17 	ldw	r2,40(r2)
 200f698:	10000426 	beq	r2,zero,200f6ac <vTaskSuspend+0x64>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200f69c:	e0bffe17 	ldw	r2,-8(fp)
 200f6a0:	10800604 	addi	r2,r2,24
 200f6a4:	1009883a 	mov	r4,r2
 200f6a8:	202bec40 	call	202bec4 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 200f6ac:	e0bffe17 	ldw	r2,-8(fp)
 200f6b0:	10800104 	addi	r2,r2,4
 200f6b4:	100b883a 	mov	r5,r2
 200f6b8:	01008134 	movhi	r4,516
 200f6bc:	211e9404 	addi	r4,r4,31312
 200f6c0:	202bd600 	call	202bd60 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 200f6c4:	e0bffe17 	ldw	r2,-8(fp)
 200f6c8:	10801d03 	ldbu	r2,116(r2)
 200f6cc:	10803fcc 	andi	r2,r2,255
 200f6d0:	10800058 	cmpnei	r2,r2,1
 200f6d4:	1000021e 	bne	r2,zero,200f6e0 <vTaskSuspend+0x98>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 200f6d8:	e0bffe17 	ldw	r2,-8(fp)
 200f6dc:	10001d05 	stb	zero,116(r2)
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
 200f6e0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f6e4:	10000126 	beq	r2,zero,200f6ec <vTaskSuspend+0xa4>
 200f6e8:	2010f780 	call	2010f78 <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 200f6ec:	d0a7da17 	ldw	r2,-24728(gp)
 200f6f0:	10000726 	beq	r2,zero,200f710 <vTaskSuspend+0xc8>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 200f6f4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f6f8:	10000126 	beq	r2,zero,200f700 <vTaskSuspend+0xb8>
 200f6fc:	2010f300 	call	2010f30 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 200f700:	2010aec0 	call	2010aec <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 200f704:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f708:	10000126 	beq	r2,zero,200f710 <vTaskSuspend+0xc8>
 200f70c:	2010f780 	call	2010f78 <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 200f710:	d0a7d317 	ldw	r2,-24756(gp)
 200f714:	e0fffe17 	ldw	r3,-8(fp)
 200f718:	18800c1e 	bne	r3,r2,200f74c <vTaskSuspend+0x104>
		{
			if( xSchedulerRunning != pdFALSE )
 200f71c:	d0a7da17 	ldw	r2,-24728(gp)
 200f720:	10000226 	beq	r2,zero,200f72c <vTaskSuspend+0xe4>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 200f724:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f728:	00000806 	br	200f74c <vTaskSuspend+0x104>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
 200f72c:	00808134 	movhi	r2,516
 200f730:	109e9404 	addi	r2,r2,31312
 200f734:	10c00017 	ldw	r3,0(r2)
 200f738:	d0a7d717 	ldw	r2,-24740(gp)
 200f73c:	1880021e 	bne	r3,r2,200f748 <vTaskSuspend+0x100>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 200f740:	d027d315 	stw	zero,-24756(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f744:	00000106 	br	200f74c <vTaskSuspend+0x104>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 200f748:	201001c0 	call	201001c <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f74c:	0001883a 	nop
 200f750:	e037883a 	mov	sp,fp
 200f754:	dfc00117 	ldw	ra,4(sp)
 200f758:	df000017 	ldw	fp,0(sp)
 200f75c:	dec00204 	addi	sp,sp,8
 200f760:	f800283a 	ret

0200f764 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 200f764:	defffc04 	addi	sp,sp,-16
 200f768:	df000315 	stw	fp,12(sp)
 200f76c:	df000304 	addi	fp,sp,12
 200f770:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 200f774:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = xTask;
 200f778:	e0bfff17 	ldw	r2,-4(fp)
 200f77c:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 200f780:	e0bffe17 	ldw	r2,-8(fp)
 200f784:	10c00517 	ldw	r3,20(r2)
 200f788:	00808134 	movhi	r2,516
 200f78c:	109e9404 	addi	r2,r2,31312
 200f790:	18800a1e 	bne	r3,r2,200f7bc <prvTaskIsTaskSuspended+0x58>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 200f794:	e0bffe17 	ldw	r2,-8(fp)
 200f798:	10c00a17 	ldw	r3,40(r2)
 200f79c:	00808134 	movhi	r2,516
 200f7a0:	109e8a04 	addi	r2,r2,31272
 200f7a4:	18800526 	beq	r3,r2,200f7bc <prvTaskIsTaskSuspended+0x58>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
 200f7a8:	e0bffe17 	ldw	r2,-8(fp)
 200f7ac:	10800a17 	ldw	r2,40(r2)
 200f7b0:	1000021e 	bne	r2,zero,200f7bc <prvTaskIsTaskSuspended+0x58>
				{
					xReturn = pdTRUE;
 200f7b4:	00800044 	movi	r2,1
 200f7b8:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 200f7bc:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 200f7c0:	e037883a 	mov	sp,fp
 200f7c4:	df000017 	ldw	fp,0(sp)
 200f7c8:	dec00104 	addi	sp,sp,4
 200f7cc:	f800283a 	ret

0200f7d0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 200f7d0:	defffc04 	addi	sp,sp,-16
 200f7d4:	dfc00315 	stw	ra,12(sp)
 200f7d8:	df000215 	stw	fp,8(sp)
 200f7dc:	df000204 	addi	fp,sp,8
 200f7e0:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = xTaskToResume;
 200f7e4:	e0bfff17 	ldw	r2,-4(fp)
 200f7e8:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 200f7ec:	d0a7d317 	ldw	r2,-24756(gp)
 200f7f0:	e0fffe17 	ldw	r3,-8(fp)
 200f7f4:	18802726 	beq	r3,r2,200f894 <vTaskResume+0xc4>
 200f7f8:	e0bffe17 	ldw	r2,-8(fp)
 200f7fc:	10002526 	beq	r2,zero,200f894 <vTaskResume+0xc4>
		{
			taskENTER_CRITICAL();
 200f800:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f804:	10000126 	beq	r2,zero,200f80c <vTaskResume+0x3c>
 200f808:	2010f300 	call	2010f30 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 200f80c:	e13ffe17 	ldw	r4,-8(fp)
 200f810:	200f7640 	call	200f764 <prvTaskIsTaskSuspended>
 200f814:	10001c26 	beq	r2,zero,200f888 <vTaskResume+0xb8>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 200f818:	e0bffe17 	ldw	r2,-8(fp)
 200f81c:	10800104 	addi	r2,r2,4
 200f820:	1009883a 	mov	r4,r2
 200f824:	202bec40 	call	202bec4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200f828:	e0bffe17 	ldw	r2,-8(fp)
 200f82c:	10800b17 	ldw	r2,44(r2)
 200f830:	d0e7d917 	ldw	r3,-24732(gp)
 200f834:	1880032e 	bgeu	r3,r2,200f844 <vTaskResume+0x74>
 200f838:	e0bffe17 	ldw	r2,-8(fp)
 200f83c:	10800b17 	ldw	r2,44(r2)
 200f840:	d0a7d915 	stw	r2,-24732(gp)
 200f844:	e0bffe17 	ldw	r2,-8(fp)
 200f848:	10800b17 	ldw	r2,44(r2)
 200f84c:	10c00524 	muli	r3,r2,20
 200f850:	00808134 	movhi	r2,516
 200f854:	109e6704 	addi	r2,r2,31132
 200f858:	1887883a 	add	r3,r3,r2
 200f85c:	e0bffe17 	ldw	r2,-8(fp)
 200f860:	10800104 	addi	r2,r2,4
 200f864:	100b883a 	mov	r5,r2
 200f868:	1809883a 	mov	r4,r3
 200f86c:	202bd600 	call	202bd60 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200f870:	e0bffe17 	ldw	r2,-8(fp)
 200f874:	10c00b17 	ldw	r3,44(r2)
 200f878:	d0a7d317 	ldw	r2,-24756(gp)
 200f87c:	10800b17 	ldw	r2,44(r2)
 200f880:	18800136 	bltu	r3,r2,200f888 <vTaskResume+0xb8>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 200f884:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 200f888:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200f88c:	10000126 	beq	r2,zero,200f894 <vTaskResume+0xc4>
 200f890:	2010f780 	call	2010f78 <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 200f894:	0001883a 	nop
 200f898:	e037883a 	mov	sp,fp
 200f89c:	dfc00117 	ldw	ra,4(sp)
 200f8a0:	df000017 	ldw	fp,0(sp)
 200f8a4:	dec00204 	addi	sp,sp,8
 200f8a8:	f800283a 	ret

0200f8ac <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 200f8ac:	defffa04 	addi	sp,sp,-24
 200f8b0:	dfc00515 	stw	ra,20(sp)
 200f8b4:	df000415 	stw	fp,16(sp)
 200f8b8:	df000404 	addi	fp,sp,16
 200f8bc:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 200f8c0:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = xTaskToResume;
 200f8c4:	e0bfff17 	ldw	r2,-4(fp)
 200f8c8:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 200f8cc:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 200f8d0:	e13ffd17 	ldw	r4,-12(fp)
 200f8d4:	200f7640 	call	200f764 <prvTaskIsTaskSuspended>
 200f8d8:	10002626 	beq	r2,zero,200f974 <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200f8dc:	d0a7e117 	ldw	r2,-24700(gp)
 200f8e0:	10001e1e 	bne	r2,zero,200f95c <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200f8e4:	e0bffd17 	ldw	r2,-12(fp)
 200f8e8:	10c00b17 	ldw	r3,44(r2)
 200f8ec:	d0a7d317 	ldw	r2,-24756(gp)
 200f8f0:	10800b17 	ldw	r2,44(r2)
 200f8f4:	18800236 	bltu	r3,r2,200f900 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 200f8f8:	00800044 	movi	r2,1
 200f8fc:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200f900:	e0bffd17 	ldw	r2,-12(fp)
 200f904:	10800104 	addi	r2,r2,4
 200f908:	1009883a 	mov	r4,r2
 200f90c:	202bec40 	call	202bec4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200f910:	e0bffd17 	ldw	r2,-12(fp)
 200f914:	10800b17 	ldw	r2,44(r2)
 200f918:	d0e7d917 	ldw	r3,-24732(gp)
 200f91c:	1880032e 	bgeu	r3,r2,200f92c <xTaskResumeFromISR+0x80>
 200f920:	e0bffd17 	ldw	r2,-12(fp)
 200f924:	10800b17 	ldw	r2,44(r2)
 200f928:	d0a7d915 	stw	r2,-24732(gp)
 200f92c:	e0bffd17 	ldw	r2,-12(fp)
 200f930:	10800b17 	ldw	r2,44(r2)
 200f934:	10c00524 	muli	r3,r2,20
 200f938:	00808134 	movhi	r2,516
 200f93c:	109e6704 	addi	r2,r2,31132
 200f940:	1887883a 	add	r3,r3,r2
 200f944:	e0bffd17 	ldw	r2,-12(fp)
 200f948:	10800104 	addi	r2,r2,4
 200f94c:	100b883a 	mov	r5,r2
 200f950:	1809883a 	mov	r4,r3
 200f954:	202bd600 	call	202bd60 <vListInsertEnd>
 200f958:	00000606 	br	200f974 <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 200f95c:	e0bffd17 	ldw	r2,-12(fp)
 200f960:	10800604 	addi	r2,r2,24
 200f964:	100b883a 	mov	r5,r2
 200f968:	01008134 	movhi	r4,516
 200f96c:	211e8a04 	addi	r4,r4,31272
 200f970:	202bd600 	call	202bd60 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 200f974:	e0bffc17 	ldw	r2,-16(fp)
	}
 200f978:	e037883a 	mov	sp,fp
 200f97c:	dfc00117 	ldw	ra,4(sp)
 200f980:	df000017 	ldw	fp,0(sp)
 200f984:	dec00204 	addi	sp,sp,8
 200f988:	f800283a 	ret

0200f98c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 200f98c:	defffb04 	addi	sp,sp,-20
 200f990:	dfc00415 	stw	ra,16(sp)
 200f994:	df000315 	stw	fp,12(sp)
 200f998:	df000304 	addi	fp,sp,12
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 200f99c:	d0a7e004 	addi	r2,gp,-24704
 200f9a0:	d8800115 	stw	r2,4(sp)
 200f9a4:	d8000015 	stw	zero,0(sp)
 200f9a8:	000f883a 	mov	r7,zero
 200f9ac:	01820004 	movi	r6,2048
 200f9b0:	01408134 	movhi	r5,516
 200f9b4:	29447a04 	addi	r5,r5,4584
 200f9b8:	01008074 	movhi	r4,513
 200f9bc:	21018104 	addi	r4,r4,1540
 200f9c0:	200eca00 	call	200eca0 <xTaskCreate>
 200f9c4:	e0bfff15 	stw	r2,-4(fp)
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 200f9c8:	e0bfff17 	ldw	r2,-4(fp)
 200f9cc:	10800058 	cmpnei	r2,r2,1
 200f9d0:	1000021e 	bne	r2,zero,200f9dc <vTaskStartScheduler+0x50>
		{
			xReturn = xTimerCreateTimerTask();
 200f9d4:	20118ec0 	call	20118ec <xTimerCreateTimerTask>
 200f9d8:	e0bfff15 	stw	r2,-4(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 200f9dc:	e0bfff17 	ldw	r2,-4(fp)
 200f9e0:	10800058 	cmpnei	r2,r2,1
 200f9e4:	1000071e 	bne	r2,zero,200fa04 <vTaskStartScheduler+0x78>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 200f9e8:	202bf880 	call	202bf88 <enh_alt_irq_disable_all>
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 200f9ec:	00bfffc4 	movi	r2,-1
 200f9f0:	d0a7df15 	stw	r2,-24708(gp)
		xSchedulerRunning = pdTRUE;
 200f9f4:	00800044 	movi	r2,1
 200f9f8:	d0a7da15 	stw	r2,-24728(gp)
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 200f9fc:	d027d815 	stw	zero,-24736(gp)

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 200fa00:	202c0f40 	call	202c0f4 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 200fa04:	0001883a 	nop
 200fa08:	e037883a 	mov	sp,fp
 200fa0c:	dfc00117 	ldw	ra,4(sp)
 200fa10:	df000017 	ldw	fp,0(sp)
 200fa14:	dec00204 	addi	sp,sp,8
 200fa18:	f800283a 	ret

0200fa1c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 200fa1c:	defffe04 	addi	sp,sp,-8
 200fa20:	dfc00115 	stw	ra,4(sp)
 200fa24:	df000015 	stw	fp,0(sp)
 200fa28:	d839883a 	mov	fp,sp
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 200fa2c:	202bf880 	call	202bf88 <enh_alt_irq_disable_all>
	xSchedulerRunning = pdFALSE;
 200fa30:	d027da15 	stw	zero,-24728(gp)
	vPortEndScheduler();
 200fa34:	202c12c0 	call	202c12c <vPortEndScheduler>
}
 200fa38:	0001883a 	nop
 200fa3c:	e037883a 	mov	sp,fp
 200fa40:	dfc00117 	ldw	ra,4(sp)
 200fa44:	df000017 	ldw	fp,0(sp)
 200fa48:	dec00204 	addi	sp,sp,8
 200fa4c:	f800283a 	ret

0200fa50 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 200fa50:	deffff04 	addi	sp,sp,-4
 200fa54:	df000015 	stw	fp,0(sp)
 200fa58:	d839883a 	mov	fp,sp
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 200fa5c:	d0a7e117 	ldw	r2,-24700(gp)
 200fa60:	10800044 	addi	r2,r2,1
 200fa64:	d0a7e115 	stw	r2,-24700(gp)

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 200fa68:	0001883a 	nop
 200fa6c:	e037883a 	mov	sp,fp
 200fa70:	df000017 	ldw	fp,0(sp)
 200fa74:	dec00104 	addi	sp,sp,4
 200fa78:	f800283a 	ret

0200fa7c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 200fa7c:	defffb04 	addi	sp,sp,-20
 200fa80:	dfc00415 	stw	ra,16(sp)
 200fa84:	df000315 	stw	fp,12(sp)
 200fa88:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 200fa8c:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 200fa90:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 200fa94:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200fa98:	10000126 	beq	r2,zero,200faa0 <xTaskResumeAll+0x24>
 200fa9c:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 200faa0:	d0a7e117 	ldw	r2,-24700(gp)
 200faa4:	10bfffc4 	addi	r2,r2,-1
 200faa8:	d0a7e115 	stw	r2,-24700(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200faac:	d0a7e117 	ldw	r2,-24700(gp)
 200fab0:	1000431e 	bne	r2,zero,200fbc0 <xTaskResumeAll+0x144>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 200fab4:	d0a7d717 	ldw	r2,-24740(gp)
 200fab8:	10004126 	beq	r2,zero,200fbc0 <xTaskResumeAll+0x144>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 200fabc:	00002606 	br	200fb58 <xTaskResumeAll+0xdc>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 200fac0:	00808134 	movhi	r2,516
 200fac4:	109e8a04 	addi	r2,r2,31272
 200fac8:	10800317 	ldw	r2,12(r2)
 200facc:	10800317 	ldw	r2,12(r2)
 200fad0:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200fad4:	e0bffd17 	ldw	r2,-12(fp)
 200fad8:	10800604 	addi	r2,r2,24
 200fadc:	1009883a 	mov	r4,r2
 200fae0:	202bec40 	call	202bec4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200fae4:	e0bffd17 	ldw	r2,-12(fp)
 200fae8:	10800104 	addi	r2,r2,4
 200faec:	1009883a 	mov	r4,r2
 200faf0:	202bec40 	call	202bec4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 200faf4:	e0bffd17 	ldw	r2,-12(fp)
 200faf8:	10800b17 	ldw	r2,44(r2)
 200fafc:	d0e7d917 	ldw	r3,-24732(gp)
 200fb00:	1880032e 	bgeu	r3,r2,200fb10 <xTaskResumeAll+0x94>
 200fb04:	e0bffd17 	ldw	r2,-12(fp)
 200fb08:	10800b17 	ldw	r2,44(r2)
 200fb0c:	d0a7d915 	stw	r2,-24732(gp)
 200fb10:	e0bffd17 	ldw	r2,-12(fp)
 200fb14:	10800b17 	ldw	r2,44(r2)
 200fb18:	10c00524 	muli	r3,r2,20
 200fb1c:	00808134 	movhi	r2,516
 200fb20:	109e6704 	addi	r2,r2,31132
 200fb24:	1887883a 	add	r3,r3,r2
 200fb28:	e0bffd17 	ldw	r2,-12(fp)
 200fb2c:	10800104 	addi	r2,r2,4
 200fb30:	100b883a 	mov	r5,r2
 200fb34:	1809883a 	mov	r4,r3
 200fb38:	202bd600 	call	202bd60 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200fb3c:	e0bffd17 	ldw	r2,-12(fp)
 200fb40:	10c00b17 	ldw	r3,44(r2)
 200fb44:	d0a7d317 	ldw	r2,-24756(gp)
 200fb48:	10800b17 	ldw	r2,44(r2)
 200fb4c:	18800236 	bltu	r3,r2,200fb58 <xTaskResumeAll+0xdc>
					{
						xYieldPending = pdTRUE;
 200fb50:	00800044 	movi	r2,1
 200fb54:	d0a7dc15 	stw	r2,-24720(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 200fb58:	00808134 	movhi	r2,516
 200fb5c:	109e8a04 	addi	r2,r2,31272
 200fb60:	10800017 	ldw	r2,0(r2)
 200fb64:	103fd61e 	bne	r2,zero,200fac0 <__alt_mem_mem_0+0xfcfefac0>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 200fb68:	e0bffd17 	ldw	r2,-12(fp)
 200fb6c:	10000126 	beq	r2,zero,200fb74 <xTaskResumeAll+0xf8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 200fb70:	2010aec0 	call	2010aec <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 200fb74:	d0a7db17 	ldw	r2,-24724(gp)
 200fb78:	e0bfff15 	stw	r2,-4(fp)

					if( xPendedCounts > ( TickType_t ) 0U )
 200fb7c:	e0bfff17 	ldw	r2,-4(fp)
 200fb80:	10000a26 	beq	r2,zero,200fbac <xTaskResumeAll+0x130>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 200fb84:	200fe6c0 	call	200fe6c <xTaskIncrementTick>
 200fb88:	10000226 	beq	r2,zero,200fb94 <xTaskResumeAll+0x118>
							{
								xYieldPending = pdTRUE;
 200fb8c:	00800044 	movi	r2,1
 200fb90:	d0a7dc15 	stw	r2,-24720(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 200fb94:	e0bfff17 	ldw	r2,-4(fp)
 200fb98:	10bfffc4 	addi	r2,r2,-1
 200fb9c:	e0bfff15 	stw	r2,-4(fp)
						} while( xPendedCounts > ( TickType_t ) 0U );
 200fba0:	e0bfff17 	ldw	r2,-4(fp)
 200fba4:	103ff71e 	bne	r2,zero,200fb84 <__alt_mem_mem_0+0xfcfefb84>

						xPendedTicks = 0;
 200fba8:	d027db15 	stw	zero,-24724(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 200fbac:	d0a7dc17 	ldw	r2,-24720(gp)
 200fbb0:	10000326 	beq	r2,zero,200fbc0 <xTaskResumeAll+0x144>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 200fbb4:	00800044 	movi	r2,1
 200fbb8:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 200fbbc:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 200fbc0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 200fbc4:	10000126 	beq	r2,zero,200fbcc <xTaskResumeAll+0x150>
 200fbc8:	2010f780 	call	2010f78 <vTaskExitCritical>

	return xAlreadyYielded;
 200fbcc:	e0bffe17 	ldw	r2,-8(fp)
}
 200fbd0:	e037883a 	mov	sp,fp
 200fbd4:	dfc00117 	ldw	ra,4(sp)
 200fbd8:	df000017 	ldw	fp,0(sp)
 200fbdc:	dec00204 	addi	sp,sp,8
 200fbe0:	f800283a 	ret

0200fbe4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 200fbe4:	defffe04 	addi	sp,sp,-8
 200fbe8:	df000115 	stw	fp,4(sp)
 200fbec:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 200fbf0:	d0a7d817 	ldw	r2,-24736(gp)
 200fbf4:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 200fbf8:	e0bfff17 	ldw	r2,-4(fp)
}
 200fbfc:	e037883a 	mov	sp,fp
 200fc00:	df000017 	ldw	fp,0(sp)
 200fc04:	dec00104 	addi	sp,sp,4
 200fc08:	f800283a 	ret

0200fc0c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 200fc0c:	defffd04 	addi	sp,sp,-12
 200fc10:	df000215 	stw	fp,8(sp)
 200fc14:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 200fc18:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 200fc1c:	d0a7d817 	ldw	r2,-24736(gp)
 200fc20:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 200fc24:	e0bfff17 	ldw	r2,-4(fp)
}
 200fc28:	e037883a 	mov	sp,fp
 200fc2c:	df000017 	ldw	fp,0(sp)
 200fc30:	dec00104 	addi	sp,sp,4
 200fc34:	f800283a 	ret

0200fc38 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 200fc38:	deffff04 	addi	sp,sp,-4
 200fc3c:	df000015 	stw	fp,0(sp)
 200fc40:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 200fc44:	d0a7d717 	ldw	r2,-24740(gp)
}
 200fc48:	e037883a 	mov	sp,fp
 200fc4c:	df000017 	ldw	fp,0(sp)
 200fc50:	dec00104 	addi	sp,sp,4
 200fc54:	f800283a 	ret

0200fc58 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 200fc58:	defffd04 	addi	sp,sp,-12
 200fc5c:	df000215 	stw	fp,8(sp)
 200fc60:	df000204 	addi	fp,sp,8
 200fc64:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 200fc68:	e0bfff17 	ldw	r2,-4(fp)
 200fc6c:	1000021e 	bne	r2,zero,200fc78 <pcTaskGetName+0x20>
 200fc70:	d0a7d317 	ldw	r2,-24756(gp)
 200fc74:	00000106 	br	200fc7c <pcTaskGetName+0x24>
 200fc78:	e0bfff17 	ldw	r2,-4(fp)
 200fc7c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 200fc80:	e0bffe17 	ldw	r2,-8(fp)
 200fc84:	10800d04 	addi	r2,r2,52
}
 200fc88:	e037883a 	mov	sp,fp
 200fc8c:	df000017 	ldw	fp,0(sp)
 200fc90:	dec00104 	addi	sp,sp,4
 200fc94:	f800283a 	ret

0200fc98 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
 200fc98:	defff904 	addi	sp,sp,-28
 200fc9c:	dfc00615 	stw	ra,24(sp)
 200fca0:	df000515 	stw	fp,20(sp)
 200fca4:	df000504 	addi	fp,sp,20
 200fca8:	e13ffd15 	stw	r4,-12(fp)
 200fcac:	e17ffe15 	stw	r5,-8(fp)
 200fcb0:	e1bfff15 	stw	r6,-4(fp)
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
 200fcb4:	e03ffb15 	stw	zero,-20(fp)
 200fcb8:	00800144 	movi	r2,5
 200fcbc:	e0bffc15 	stw	r2,-16(fp)

		vTaskSuspendAll();
 200fcc0:	200fa500 	call	200fa50 <vTaskSuspendAll>
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
 200fcc4:	d0a7d717 	ldw	r2,-24740(gp)
 200fcc8:	e0fffe17 	ldw	r3,-8(fp)
 200fccc:	18804d36 	bltu	r3,r2,200fe04 <uxTaskGetSystemState+0x16c>
			{
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
 200fcd0:	e0bffc17 	ldw	r2,-16(fp)
 200fcd4:	10bfffc4 	addi	r2,r2,-1
 200fcd8:	e0bffc15 	stw	r2,-16(fp)
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
 200fcdc:	e0bffb17 	ldw	r2,-20(fp)
 200fce0:	10800924 	muli	r2,r2,36
 200fce4:	e0fffd17 	ldw	r3,-12(fp)
 200fce8:	1889883a 	add	r4,r3,r2
 200fcec:	e0bffc17 	ldw	r2,-16(fp)
 200fcf0:	10c00524 	muli	r3,r2,20
 200fcf4:	00808134 	movhi	r2,516
 200fcf8:	109e6704 	addi	r2,r2,31132
 200fcfc:	1885883a 	add	r2,r3,r2
 200fd00:	01800044 	movi	r6,1
 200fd04:	100b883a 	mov	r5,r2
 200fd08:	20108c00 	call	20108c0 <prvListTasksWithinSingleList>
 200fd0c:	1007883a 	mov	r3,r2
 200fd10:	e0bffb17 	ldw	r2,-20(fp)
 200fd14:	10c5883a 	add	r2,r2,r3
 200fd18:	e0bffb15 	stw	r2,-20(fp)

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200fd1c:	e0bffc17 	ldw	r2,-16(fp)
 200fd20:	103feb1e 	bne	r2,zero,200fcd0 <__alt_mem_mem_0+0xfcfefcd0>

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
 200fd24:	e0bffb17 	ldw	r2,-20(fp)
 200fd28:	10800924 	muli	r2,r2,36
 200fd2c:	e0fffd17 	ldw	r3,-12(fp)
 200fd30:	1885883a 	add	r2,r3,r2
 200fd34:	d0e7d417 	ldw	r3,-24752(gp)
 200fd38:	01800084 	movi	r6,2
 200fd3c:	180b883a 	mov	r5,r3
 200fd40:	1009883a 	mov	r4,r2
 200fd44:	20108c00 	call	20108c0 <prvListTasksWithinSingleList>
 200fd48:	1007883a 	mov	r3,r2
 200fd4c:	e0bffb17 	ldw	r2,-20(fp)
 200fd50:	10c5883a 	add	r2,r2,r3
 200fd54:	e0bffb15 	stw	r2,-20(fp)
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
 200fd58:	e0bffb17 	ldw	r2,-20(fp)
 200fd5c:	10800924 	muli	r2,r2,36
 200fd60:	e0fffd17 	ldw	r3,-12(fp)
 200fd64:	1885883a 	add	r2,r3,r2
 200fd68:	d0e7d517 	ldw	r3,-24748(gp)
 200fd6c:	01800084 	movi	r6,2
 200fd70:	180b883a 	mov	r5,r3
 200fd74:	1009883a 	mov	r4,r2
 200fd78:	20108c00 	call	20108c0 <prvListTasksWithinSingleList>
 200fd7c:	1007883a 	mov	r3,r2
 200fd80:	e0bffb17 	ldw	r2,-20(fp)
 200fd84:	10c5883a 	add	r2,r2,r3
 200fd88:	e0bffb15 	stw	r2,-20(fp)

				#if( INCLUDE_vTaskDelete == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task that has been deleted but not yet cleaned up. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
 200fd8c:	e0bffb17 	ldw	r2,-20(fp)
 200fd90:	10800924 	muli	r2,r2,36
 200fd94:	e0fffd17 	ldw	r3,-12(fp)
 200fd98:	1885883a 	add	r2,r3,r2
 200fd9c:	01800104 	movi	r6,4
 200fda0:	01408134 	movhi	r5,516
 200fda4:	295e8f04 	addi	r5,r5,31292
 200fda8:	1009883a 	mov	r4,r2
 200fdac:	20108c00 	call	20108c0 <prvListTasksWithinSingleList>
 200fdb0:	1007883a 	mov	r3,r2
 200fdb4:	e0bffb17 	ldw	r2,-20(fp)
 200fdb8:	10c5883a 	add	r2,r2,r3
 200fdbc:	e0bffb15 	stw	r2,-20(fp)

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
 200fdc0:	e0bffb17 	ldw	r2,-20(fp)
 200fdc4:	10800924 	muli	r2,r2,36
 200fdc8:	e0fffd17 	ldw	r3,-12(fp)
 200fdcc:	1885883a 	add	r2,r3,r2
 200fdd0:	018000c4 	movi	r6,3
 200fdd4:	01408134 	movhi	r5,516
 200fdd8:	295e9404 	addi	r5,r5,31312
 200fddc:	1009883a 	mov	r4,r2
 200fde0:	20108c00 	call	20108c0 <prvListTasksWithinSingleList>
 200fde4:	1007883a 	mov	r3,r2
 200fde8:	e0bffb17 	ldw	r2,-20(fp)
 200fdec:	10c5883a 	add	r2,r2,r3
 200fdf0:	e0bffb15 	stw	r2,-20(fp)
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
 200fdf4:	e0bfff17 	ldw	r2,-4(fp)
 200fdf8:	10000226 	beq	r2,zero,200fe04 <uxTaskGetSystemState+0x16c>
					{
						*pulTotalRunTime = 0;
 200fdfc:	e0bfff17 	ldw	r2,-4(fp)
 200fe00:	10000015 	stw	zero,0(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
 200fe04:	200fa7c0 	call	200fa7c <xTaskResumeAll>

		return uxTask;
 200fe08:	e0bffb17 	ldw	r2,-20(fp)
	}
 200fe0c:	e037883a 	mov	sp,fp
 200fe10:	dfc00117 	ldw	ra,4(sp)
 200fe14:	df000017 	ldw	fp,0(sp)
 200fe18:	dec00204 	addi	sp,sp,8
 200fe1c:	f800283a 	ret

0200fe20 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
 200fe20:	defffc04 	addi	sp,sp,-16
 200fe24:	dfc00315 	stw	ra,12(sp)
 200fe28:	df000215 	stw	fp,8(sp)
 200fe2c:	df000204 	addi	fp,sp,8
 200fe30:	e13fff15 	stw	r4,-4(fp)
BaseType_t xYieldRequired = pdFALSE;
 200fe34:	e03ffe15 	stw	zero,-8(fp)
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
 200fe38:	200fa500 	call	200fa50 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
 200fe3c:	d0e7db17 	ldw	r3,-24724(gp)
 200fe40:	e0bfff17 	ldw	r2,-4(fp)
 200fe44:	1885883a 	add	r2,r3,r2
 200fe48:	d0a7db15 	stw	r2,-24724(gp)
	xYieldRequired = xTaskResumeAll();
 200fe4c:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 200fe50:	e0bffe15 	stw	r2,-8(fp)

	return xYieldRequired;
 200fe54:	e0bffe17 	ldw	r2,-8(fp)
}
 200fe58:	e037883a 	mov	sp,fp
 200fe5c:	dfc00117 	ldw	ra,4(sp)
 200fe60:	df000017 	ldw	fp,0(sp)
 200fe64:	dec00204 	addi	sp,sp,8
 200fe68:	f800283a 	ret

0200fe6c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 200fe6c:	defff904 	addi	sp,sp,-28
 200fe70:	dfc00615 	stw	ra,24(sp)
 200fe74:	df000515 	stw	fp,20(sp)
 200fe78:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 200fe7c:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 200fe80:	d0a7e117 	ldw	r2,-24700(gp)
 200fe84:	10005c1e 	bne	r2,zero,200fff8 <xTaskIncrementTick+0x18c>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 200fe88:	d0a7d817 	ldw	r2,-24736(gp)
 200fe8c:	10800044 	addi	r2,r2,1
 200fe90:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 200fe94:	e0bffc17 	ldw	r2,-16(fp)
 200fe98:	d0a7d815 	stw	r2,-24736(gp)

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 200fe9c:	e0bffc17 	ldw	r2,-16(fp)
 200fea0:	10000a1e 	bne	r2,zero,200fecc <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 200fea4:	d0a7d417 	ldw	r2,-24752(gp)
 200fea8:	e0bffd15 	stw	r2,-12(fp)
 200feac:	d0a7d517 	ldw	r2,-24748(gp)
 200feb0:	d0a7d415 	stw	r2,-24752(gp)
 200feb4:	e0bffd17 	ldw	r2,-12(fp)
 200feb8:	d0a7d515 	stw	r2,-24748(gp)
 200febc:	d0a7dd17 	ldw	r2,-24716(gp)
 200fec0:	10800044 	addi	r2,r2,1
 200fec4:	d0a7dd15 	stw	r2,-24716(gp)
 200fec8:	2010aec0 	call	2010aec <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 200fecc:	d0a7df17 	ldw	r2,-24708(gp)
 200fed0:	e0fffc17 	ldw	r3,-16(fp)
 200fed4:	18803836 	bltu	r3,r2,200ffb8 <xTaskIncrementTick+0x14c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 200fed8:	d0a7d417 	ldw	r2,-24752(gp)
 200fedc:	10800017 	ldw	r2,0(r2)
 200fee0:	1000031e 	bne	r2,zero,200fef0 <xTaskIncrementTick+0x84>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 200fee4:	00bfffc4 	movi	r2,-1
 200fee8:	d0a7df15 	stw	r2,-24708(gp)
					break;
 200feec:	00003206 	br	200ffb8 <xTaskIncrementTick+0x14c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 200fef0:	d0a7d417 	ldw	r2,-24752(gp)
 200fef4:	10800317 	ldw	r2,12(r2)
 200fef8:	10800317 	ldw	r2,12(r2)
 200fefc:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 200ff00:	e0bffe17 	ldw	r2,-8(fp)
 200ff04:	10800117 	ldw	r2,4(r2)
 200ff08:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 200ff0c:	e0fffc17 	ldw	r3,-16(fp)
 200ff10:	e0bfff17 	ldw	r2,-4(fp)
 200ff14:	1880032e 	bgeu	r3,r2,200ff24 <xTaskIncrementTick+0xb8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 200ff18:	e0bfff17 	ldw	r2,-4(fp)
 200ff1c:	d0a7df15 	stw	r2,-24708(gp)
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 200ff20:	00002506 	br	200ffb8 <xTaskIncrementTick+0x14c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 200ff24:	e0bffe17 	ldw	r2,-8(fp)
 200ff28:	10800104 	addi	r2,r2,4
 200ff2c:	1009883a 	mov	r4,r2
 200ff30:	202bec40 	call	202bec4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 200ff34:	e0bffe17 	ldw	r2,-8(fp)
 200ff38:	10800a17 	ldw	r2,40(r2)
 200ff3c:	10000426 	beq	r2,zero,200ff50 <xTaskIncrementTick+0xe4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 200ff40:	e0bffe17 	ldw	r2,-8(fp)
 200ff44:	10800604 	addi	r2,r2,24
 200ff48:	1009883a 	mov	r4,r2
 200ff4c:	202bec40 	call	202bec4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 200ff50:	e0bffe17 	ldw	r2,-8(fp)
 200ff54:	10800b17 	ldw	r2,44(r2)
 200ff58:	d0e7d917 	ldw	r3,-24732(gp)
 200ff5c:	1880032e 	bgeu	r3,r2,200ff6c <xTaskIncrementTick+0x100>
 200ff60:	e0bffe17 	ldw	r2,-8(fp)
 200ff64:	10800b17 	ldw	r2,44(r2)
 200ff68:	d0a7d915 	stw	r2,-24732(gp)
 200ff6c:	e0bffe17 	ldw	r2,-8(fp)
 200ff70:	10800b17 	ldw	r2,44(r2)
 200ff74:	10c00524 	muli	r3,r2,20
 200ff78:	00808134 	movhi	r2,516
 200ff7c:	109e6704 	addi	r2,r2,31132
 200ff80:	1887883a 	add	r3,r3,r2
 200ff84:	e0bffe17 	ldw	r2,-8(fp)
 200ff88:	10800104 	addi	r2,r2,4
 200ff8c:	100b883a 	mov	r5,r2
 200ff90:	1809883a 	mov	r4,r3
 200ff94:	202bd600 	call	202bd60 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 200ff98:	e0bffe17 	ldw	r2,-8(fp)
 200ff9c:	10c00b17 	ldw	r3,44(r2)
 200ffa0:	d0a7d317 	ldw	r2,-24756(gp)
 200ffa4:	10800b17 	ldw	r2,44(r2)
 200ffa8:	18bfcb36 	bltu	r3,r2,200fed8 <__alt_mem_mem_0+0xfcfefed8>
						{
							xSwitchRequired = pdTRUE;
 200ffac:	00800044 	movi	r2,1
 200ffb0:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 200ffb4:	003fc806 	br	200fed8 <__alt_mem_mem_0+0xfcfefed8>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 200ffb8:	d0a7d317 	ldw	r2,-24756(gp)
 200ffbc:	10c00b17 	ldw	r3,44(r2)
 200ffc0:	00808134 	movhi	r2,516
 200ffc4:	109e6704 	addi	r2,r2,31132
 200ffc8:	18c00524 	muli	r3,r3,20
 200ffcc:	10c5883a 	add	r2,r2,r3
 200ffd0:	10800017 	ldw	r2,0(r2)
 200ffd4:	108000b0 	cmpltui	r2,r2,2
 200ffd8:	1000021e 	bne	r2,zero,200ffe4 <xTaskIncrementTick+0x178>
			{
				xSwitchRequired = pdTRUE;
 200ffdc:	00800044 	movi	r2,1
 200ffe0:	e0bffb15 	stw	r2,-20(fp)
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 200ffe4:	d0a7dc17 	ldw	r2,-24720(gp)
 200ffe8:	10000626 	beq	r2,zero,2010004 <xTaskIncrementTick+0x198>
			{
				xSwitchRequired = pdTRUE;
 200ffec:	00800044 	movi	r2,1
 200fff0:	e0bffb15 	stw	r2,-20(fp)
 200fff4:	00000306 	br	2010004 <xTaskIncrementTick+0x198>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 200fff8:	d0a7db17 	ldw	r2,-24724(gp)
 200fffc:	10800044 	addi	r2,r2,1
 2010000:	d0a7db15 	stw	r2,-24724(gp)
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 2010004:	e0bffb17 	ldw	r2,-20(fp)
}
 2010008:	e037883a 	mov	sp,fp
 201000c:	dfc00117 	ldw	ra,4(sp)
 2010010:	df000017 	ldw	fp,0(sp)
 2010014:	dec00204 	addi	sp,sp,8
 2010018:	f800283a 	ret

0201001c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 201001c:	defffd04 	addi	sp,sp,-12
 2010020:	df000215 	stw	fp,8(sp)
 2010024:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 2010028:	d0a7e117 	ldw	r2,-24700(gp)
 201002c:	10000326 	beq	r2,zero,201003c <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 2010030:	00800044 	movi	r2,1
 2010034:	d0a7dc15 	stw	r2,-24720(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 2010038:	00002906 	br	20100e0 <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 201003c:	d027dc15 	stw	zero,-24720(gp)
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2010040:	d0a7d917 	ldw	r2,-24732(gp)
 2010044:	e0bffe15 	stw	r2,-8(fp)
 2010048:	00000306 	br	2010058 <vTaskSwitchContext+0x3c>
 201004c:	e0bffe17 	ldw	r2,-8(fp)
 2010050:	10bfffc4 	addi	r2,r2,-1
 2010054:	e0bffe15 	stw	r2,-8(fp)
 2010058:	00808134 	movhi	r2,516
 201005c:	109e6704 	addi	r2,r2,31132
 2010060:	e0fffe17 	ldw	r3,-8(fp)
 2010064:	18c00524 	muli	r3,r3,20
 2010068:	10c5883a 	add	r2,r2,r3
 201006c:	10800017 	ldw	r2,0(r2)
 2010070:	103ff626 	beq	r2,zero,201004c <__alt_mem_mem_0+0xfcff004c>
 2010074:	e0bffe17 	ldw	r2,-8(fp)
 2010078:	10c00524 	muli	r3,r2,20
 201007c:	00808134 	movhi	r2,516
 2010080:	109e6704 	addi	r2,r2,31132
 2010084:	1885883a 	add	r2,r3,r2
 2010088:	e0bfff15 	stw	r2,-4(fp)
 201008c:	e0bfff17 	ldw	r2,-4(fp)
 2010090:	10800117 	ldw	r2,4(r2)
 2010094:	10c00117 	ldw	r3,4(r2)
 2010098:	e0bfff17 	ldw	r2,-4(fp)
 201009c:	10c00115 	stw	r3,4(r2)
 20100a0:	e0bfff17 	ldw	r2,-4(fp)
 20100a4:	10c00117 	ldw	r3,4(r2)
 20100a8:	e0bfff17 	ldw	r2,-4(fp)
 20100ac:	10800204 	addi	r2,r2,8
 20100b0:	1880051e 	bne	r3,r2,20100c8 <vTaskSwitchContext+0xac>
 20100b4:	e0bfff17 	ldw	r2,-4(fp)
 20100b8:	10800117 	ldw	r2,4(r2)
 20100bc:	10c00117 	ldw	r3,4(r2)
 20100c0:	e0bfff17 	ldw	r2,-4(fp)
 20100c4:	10c00115 	stw	r3,4(r2)
 20100c8:	e0bfff17 	ldw	r2,-4(fp)
 20100cc:	10800117 	ldw	r2,4(r2)
 20100d0:	10800317 	ldw	r2,12(r2)
 20100d4:	d0a7d315 	stw	r2,-24756(gp)
 20100d8:	e0bffe17 	ldw	r2,-8(fp)
 20100dc:	d0a7d915 	stw	r2,-24732(gp)
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 20100e0:	0001883a 	nop
 20100e4:	e037883a 	mov	sp,fp
 20100e8:	df000017 	ldw	fp,0(sp)
 20100ec:	dec00104 	addi	sp,sp,4
 20100f0:	f800283a 	ret

020100f4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 20100f4:	defffc04 	addi	sp,sp,-16
 20100f8:	dfc00315 	stw	ra,12(sp)
 20100fc:	df000215 	stw	fp,8(sp)
 2010100:	df000204 	addi	fp,sp,8
 2010104:	e13ffe15 	stw	r4,-8(fp)
 2010108:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 201010c:	d0a7d317 	ldw	r2,-24756(gp)
 2010110:	10800604 	addi	r2,r2,24
 2010114:	100b883a 	mov	r5,r2
 2010118:	e13ffe17 	ldw	r4,-8(fp)
 201011c:	202bdec0 	call	202bdec <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2010120:	01400044 	movi	r5,1
 2010124:	e13fff17 	ldw	r4,-4(fp)
 2010128:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>
}
 201012c:	0001883a 	nop
 2010130:	e037883a 	mov	sp,fp
 2010134:	dfc00117 	ldw	ra,4(sp)
 2010138:	df000017 	ldw	fp,0(sp)
 201013c:	dec00204 	addi	sp,sp,8
 2010140:	f800283a 	ret

02010144 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 2010144:	defffb04 	addi	sp,sp,-20
 2010148:	dfc00415 	stw	ra,16(sp)
 201014c:	df000315 	stw	fp,12(sp)
 2010150:	df000304 	addi	fp,sp,12
 2010154:	e13ffd15 	stw	r4,-12(fp)
 2010158:	e17ffe15 	stw	r5,-8(fp)
 201015c:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2010160:	d0a7d317 	ldw	r2,-24756(gp)
 2010164:	e0fffe17 	ldw	r3,-8(fp)
 2010168:	18e00034 	orhi	r3,r3,32768
 201016c:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 2010170:	d0a7d317 	ldw	r2,-24756(gp)
 2010174:	10800604 	addi	r2,r2,24
 2010178:	100b883a 	mov	r5,r2
 201017c:	e13ffd17 	ldw	r4,-12(fp)
 2010180:	202bd600 	call	202bd60 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2010184:	01400044 	movi	r5,1
 2010188:	e13fff17 	ldw	r4,-4(fp)
 201018c:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>
}
 2010190:	0001883a 	nop
 2010194:	e037883a 	mov	sp,fp
 2010198:	dfc00117 	ldw	ra,4(sp)
 201019c:	df000017 	ldw	fp,0(sp)
 20101a0:	dec00204 	addi	sp,sp,8
 20101a4:	f800283a 	ret

020101a8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 20101a8:	defffb04 	addi	sp,sp,-20
 20101ac:	dfc00415 	stw	ra,16(sp)
 20101b0:	df000315 	stw	fp,12(sp)
 20101b4:	df000304 	addi	fp,sp,12
 20101b8:	e13ffd15 	stw	r4,-12(fp)
 20101bc:	e17ffe15 	stw	r5,-8(fp)
 20101c0:	e1bfff15 	stw	r6,-4(fp)

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 20101c4:	d0a7d317 	ldw	r2,-24756(gp)
 20101c8:	10800604 	addi	r2,r2,24
 20101cc:	100b883a 	mov	r5,r2
 20101d0:	e13ffd17 	ldw	r4,-12(fp)
 20101d4:	202bd600 	call	202bd60 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 20101d8:	e0bfff17 	ldw	r2,-4(fp)
 20101dc:	10000226 	beq	r2,zero,20101e8 <vTaskPlaceOnEventListRestricted+0x40>
		{
			xTicksToWait = portMAX_DELAY;
 20101e0:	00bfffc4 	movi	r2,-1
 20101e4:	e0bffe15 	stw	r2,-8(fp)
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 20101e8:	e17fff17 	ldw	r5,-4(fp)
 20101ec:	e13ffe17 	ldw	r4,-8(fp)
 20101f0:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>
	}
 20101f4:	0001883a 	nop
 20101f8:	e037883a 	mov	sp,fp
 20101fc:	dfc00117 	ldw	ra,4(sp)
 2010200:	df000017 	ldw	fp,0(sp)
 2010204:	dec00204 	addi	sp,sp,8
 2010208:	f800283a 	ret

0201020c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 201020c:	defffb04 	addi	sp,sp,-20
 2010210:	dfc00415 	stw	ra,16(sp)
 2010214:	df000315 	stw	fp,12(sp)
 2010218:	df000304 	addi	fp,sp,12
 201021c:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2010220:	e0bfff17 	ldw	r2,-4(fp)
 2010224:	10800317 	ldw	r2,12(r2)
 2010228:	10800317 	ldw	r2,12(r2)
 201022c:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2010230:	e0bffe17 	ldw	r2,-8(fp)
 2010234:	10800604 	addi	r2,r2,24
 2010238:	1009883a 	mov	r4,r2
 201023c:	202bec40 	call	202bec4 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2010240:	d0a7e117 	ldw	r2,-24700(gp)
 2010244:	1000171e 	bne	r2,zero,20102a4 <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 2010248:	e0bffe17 	ldw	r2,-8(fp)
 201024c:	10800104 	addi	r2,r2,4
 2010250:	1009883a 	mov	r4,r2
 2010254:	202bec40 	call	202bec4 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 2010258:	e0bffe17 	ldw	r2,-8(fp)
 201025c:	10800b17 	ldw	r2,44(r2)
 2010260:	d0e7d917 	ldw	r3,-24732(gp)
 2010264:	1880032e 	bgeu	r3,r2,2010274 <xTaskRemoveFromEventList+0x68>
 2010268:	e0bffe17 	ldw	r2,-8(fp)
 201026c:	10800b17 	ldw	r2,44(r2)
 2010270:	d0a7d915 	stw	r2,-24732(gp)
 2010274:	e0bffe17 	ldw	r2,-8(fp)
 2010278:	10800b17 	ldw	r2,44(r2)
 201027c:	10c00524 	muli	r3,r2,20
 2010280:	00808134 	movhi	r2,516
 2010284:	109e6704 	addi	r2,r2,31132
 2010288:	1887883a 	add	r3,r3,r2
 201028c:	e0bffe17 	ldw	r2,-8(fp)
 2010290:	10800104 	addi	r2,r2,4
 2010294:	100b883a 	mov	r5,r2
 2010298:	1809883a 	mov	r4,r3
 201029c:	202bd600 	call	202bd60 <vListInsertEnd>
 20102a0:	00000606 	br	20102bc <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 20102a4:	e0bffe17 	ldw	r2,-8(fp)
 20102a8:	10800604 	addi	r2,r2,24
 20102ac:	100b883a 	mov	r5,r2
 20102b0:	01008134 	movhi	r4,516
 20102b4:	211e8a04 	addi	r4,r4,31272
 20102b8:	202bd600 	call	202bd60 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 20102bc:	e0bffe17 	ldw	r2,-8(fp)
 20102c0:	10800b17 	ldw	r2,44(r2)
 20102c4:	d0e7d317 	ldw	r3,-24756(gp)
 20102c8:	18c00b17 	ldw	r3,44(r3)
 20102cc:	1880052e 	bgeu	r3,r2,20102e4 <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 20102d0:	00800044 	movi	r2,1
 20102d4:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 20102d8:	00800044 	movi	r2,1
 20102dc:	d0a7dc15 	stw	r2,-24720(gp)
 20102e0:	00000106 	br	20102e8 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 20102e4:	e03ffd15 	stw	zero,-12(fp)
	}

	return xReturn;
 20102e8:	e0bffd17 	ldw	r2,-12(fp)
}
 20102ec:	e037883a 	mov	sp,fp
 20102f0:	dfc00117 	ldw	ra,4(sp)
 20102f4:	df000017 	ldw	fp,0(sp)
 20102f8:	dec00204 	addi	sp,sp,8
 20102fc:	f800283a 	ret

02010300 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 2010300:	defffb04 	addi	sp,sp,-20
 2010304:	dfc00415 	stw	ra,16(sp)
 2010308:	df000315 	stw	fp,12(sp)
 201030c:	df000304 	addi	fp,sp,12
 2010310:	e13ffe15 	stw	r4,-8(fp)
 2010314:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 2010318:	e0bfff17 	ldw	r2,-4(fp)
 201031c:	10e00034 	orhi	r3,r2,32768
 2010320:	e0bffe17 	ldw	r2,-8(fp)
 2010324:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2010328:	e0bffe17 	ldw	r2,-8(fp)
 201032c:	10800317 	ldw	r2,12(r2)
 2010330:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 2010334:	e13ffe17 	ldw	r4,-8(fp)
 2010338:	202bec40 	call	202bec4 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 201033c:	e0bffd17 	ldw	r2,-12(fp)
 2010340:	10800104 	addi	r2,r2,4
 2010344:	1009883a 	mov	r4,r2
 2010348:	202bec40 	call	202bec4 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 201034c:	e0bffd17 	ldw	r2,-12(fp)
 2010350:	10800b17 	ldw	r2,44(r2)
 2010354:	d0e7d917 	ldw	r3,-24732(gp)
 2010358:	1880032e 	bgeu	r3,r2,2010368 <vTaskRemoveFromUnorderedEventList+0x68>
 201035c:	e0bffd17 	ldw	r2,-12(fp)
 2010360:	10800b17 	ldw	r2,44(r2)
 2010364:	d0a7d915 	stw	r2,-24732(gp)
 2010368:	e0bffd17 	ldw	r2,-12(fp)
 201036c:	10800b17 	ldw	r2,44(r2)
 2010370:	10c00524 	muli	r3,r2,20
 2010374:	00808134 	movhi	r2,516
 2010378:	109e6704 	addi	r2,r2,31132
 201037c:	1887883a 	add	r3,r3,r2
 2010380:	e0bffd17 	ldw	r2,-12(fp)
 2010384:	10800104 	addi	r2,r2,4
 2010388:	100b883a 	mov	r5,r2
 201038c:	1809883a 	mov	r4,r3
 2010390:	202bd600 	call	202bd60 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 2010394:	e0bffd17 	ldw	r2,-12(fp)
 2010398:	10800b17 	ldw	r2,44(r2)
 201039c:	d0e7d317 	ldw	r3,-24756(gp)
 20103a0:	18c00b17 	ldw	r3,44(r3)
 20103a4:	1880022e 	bgeu	r3,r2,20103b0 <vTaskRemoveFromUnorderedEventList+0xb0>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
 20103a8:	00800044 	movi	r2,1
 20103ac:	d0a7dc15 	stw	r2,-24720(gp)
	}
}
 20103b0:	0001883a 	nop
 20103b4:	e037883a 	mov	sp,fp
 20103b8:	dfc00117 	ldw	ra,4(sp)
 20103bc:	df000017 	ldw	fp,0(sp)
 20103c0:	dec00204 	addi	sp,sp,8
 20103c4:	f800283a 	ret

020103c8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 20103c8:	defffd04 	addi	sp,sp,-12
 20103cc:	dfc00215 	stw	ra,8(sp)
 20103d0:	df000115 	stw	fp,4(sp)
 20103d4:	df000104 	addi	fp,sp,4
 20103d8:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
 20103dc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20103e0:	10000126 	beq	r2,zero,20103e8 <vTaskSetTimeOutState+0x20>
 20103e4:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
 20103e8:	d0e7dd17 	ldw	r3,-24716(gp)
 20103ec:	e0bfff17 	ldw	r2,-4(fp)
 20103f0:	10c00015 	stw	r3,0(r2)
		pxTimeOut->xTimeOnEntering = xTickCount;
 20103f4:	d0e7d817 	ldw	r3,-24736(gp)
 20103f8:	e0bfff17 	ldw	r2,-4(fp)
 20103fc:	10c00115 	stw	r3,4(r2)
	}
	taskEXIT_CRITICAL();
 2010400:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2010404:	10000126 	beq	r2,zero,201040c <vTaskSetTimeOutState+0x44>
 2010408:	2010f780 	call	2010f78 <vTaskExitCritical>
}
 201040c:	0001883a 	nop
 2010410:	e037883a 	mov	sp,fp
 2010414:	dfc00117 	ldw	ra,4(sp)
 2010418:	df000017 	ldw	fp,0(sp)
 201041c:	dec00204 	addi	sp,sp,8
 2010420:	f800283a 	ret

02010424 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 2010424:	defffe04 	addi	sp,sp,-8
 2010428:	df000115 	stw	fp,4(sp)
 201042c:	df000104 	addi	fp,sp,4
 2010430:	e13fff15 	stw	r4,-4(fp)
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2010434:	d0e7dd17 	ldw	r3,-24716(gp)
 2010438:	e0bfff17 	ldw	r2,-4(fp)
 201043c:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 2010440:	d0e7d817 	ldw	r3,-24736(gp)
 2010444:	e0bfff17 	ldw	r2,-4(fp)
 2010448:	10c00115 	stw	r3,4(r2)
}
 201044c:	0001883a 	nop
 2010450:	e037883a 	mov	sp,fp
 2010454:	df000017 	ldw	fp,0(sp)
 2010458:	dec00104 	addi	sp,sp,4
 201045c:	f800283a 	ret

02010460 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 2010460:	defff904 	addi	sp,sp,-28
 2010464:	dfc00615 	stw	ra,24(sp)
 2010468:	df000515 	stw	fp,20(sp)
 201046c:	df000504 	addi	fp,sp,20
 2010470:	e13ffe15 	stw	r4,-8(fp)
 2010474:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 2010478:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201047c:	10000126 	beq	r2,zero,2010484 <xTaskCheckForTimeOut+0x24>
 2010480:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 2010484:	d0a7d817 	ldw	r2,-24736(gp)
 2010488:	e0bffc15 	stw	r2,-16(fp)
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 201048c:	e0bffe17 	ldw	r2,-8(fp)
 2010490:	10800117 	ldw	r2,4(r2)
 2010494:	e0fffc17 	ldw	r3,-16(fp)
 2010498:	1885c83a 	sub	r2,r3,r2
 201049c:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 20104a0:	e0bfff17 	ldw	r2,-4(fp)
 20104a4:	10800017 	ldw	r2,0(r2)
 20104a8:	10bfffd8 	cmpnei	r2,r2,-1
 20104ac:	1000021e 	bne	r2,zero,20104b8 <xTaskCheckForTimeOut+0x58>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 20104b0:	e03ffb15 	stw	zero,-20(fp)
 20104b4:	00001d06 	br	201052c <xTaskCheckForTimeOut+0xcc>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 20104b8:	e0bffe17 	ldw	r2,-8(fp)
 20104bc:	10c00017 	ldw	r3,0(r2)
 20104c0:	d0a7dd17 	ldw	r2,-24716(gp)
 20104c4:	18800726 	beq	r3,r2,20104e4 <xTaskCheckForTimeOut+0x84>
 20104c8:	e0bffe17 	ldw	r2,-8(fp)
 20104cc:	10800117 	ldw	r2,4(r2)
 20104d0:	e0fffc17 	ldw	r3,-16(fp)
 20104d4:	18800336 	bltu	r3,r2,20104e4 <xTaskCheckForTimeOut+0x84>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 20104d8:	00800044 	movi	r2,1
 20104dc:	e0bffb15 	stw	r2,-20(fp)
 20104e0:	00001206 	br	201052c <xTaskCheckForTimeOut+0xcc>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 20104e4:	e0bfff17 	ldw	r2,-4(fp)
 20104e8:	10800017 	ldw	r2,0(r2)
 20104ec:	e0fffd17 	ldw	r3,-12(fp)
 20104f0:	18800a2e 	bgeu	r3,r2,201051c <xTaskCheckForTimeOut+0xbc>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 20104f4:	e0bfff17 	ldw	r2,-4(fp)
 20104f8:	10c00017 	ldw	r3,0(r2)
 20104fc:	e0bffd17 	ldw	r2,-12(fp)
 2010500:	1887c83a 	sub	r3,r3,r2
 2010504:	e0bfff17 	ldw	r2,-4(fp)
 2010508:	10c00015 	stw	r3,0(r2)
			vTaskInternalSetTimeOutState( pxTimeOut );
 201050c:	e13ffe17 	ldw	r4,-8(fp)
 2010510:	20104240 	call	2010424 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 2010514:	e03ffb15 	stw	zero,-20(fp)
 2010518:	00000406 	br	201052c <xTaskCheckForTimeOut+0xcc>
		}
		else
		{
			*pxTicksToWait = 0;
 201051c:	e0bfff17 	ldw	r2,-4(fp)
 2010520:	10000015 	stw	zero,0(r2)
			xReturn = pdTRUE;
 2010524:	00800044 	movi	r2,1
 2010528:	e0bffb15 	stw	r2,-20(fp)
		}
	}
	taskEXIT_CRITICAL();
 201052c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2010530:	10000126 	beq	r2,zero,2010538 <xTaskCheckForTimeOut+0xd8>
 2010534:	2010f780 	call	2010f78 <vTaskExitCritical>

	return xReturn;
 2010538:	e0bffb17 	ldw	r2,-20(fp)
}
 201053c:	e037883a 	mov	sp,fp
 2010540:	dfc00117 	ldw	ra,4(sp)
 2010544:	df000017 	ldw	fp,0(sp)
 2010548:	dec00204 	addi	sp,sp,8
 201054c:	f800283a 	ret

02010550 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 2010550:	deffff04 	addi	sp,sp,-4
 2010554:	df000015 	stw	fp,0(sp)
 2010558:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 201055c:	00800044 	movi	r2,1
 2010560:	d0a7dc15 	stw	r2,-24720(gp)
}
 2010564:	0001883a 	nop
 2010568:	e037883a 	mov	sp,fp
 201056c:	df000017 	ldw	fp,0(sp)
 2010570:	dec00104 	addi	sp,sp,4
 2010574:	f800283a 	ret

02010578 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
 2010578:	defffc04 	addi	sp,sp,-16
 201057c:	df000315 	stw	fp,12(sp)
 2010580:	df000304 	addi	fp,sp,12
 2010584:	e13fff15 	stw	r4,-4(fp)
	UBaseType_t uxReturn;
	TCB_t const *pxTCB;

		if( xTask != NULL )
 2010588:	e0bfff17 	ldw	r2,-4(fp)
 201058c:	10000626 	beq	r2,zero,20105a8 <uxTaskGetTaskNumber+0x30>
		{
			pxTCB = xTask;
 2010590:	e0bfff17 	ldw	r2,-4(fp)
 2010594:	e0bffe15 	stw	r2,-8(fp)
			uxReturn = pxTCB->uxTaskNumber;
 2010598:	e0bffe17 	ldw	r2,-8(fp)
 201059c:	10801917 	ldw	r2,100(r2)
 20105a0:	e0bffd15 	stw	r2,-12(fp)
 20105a4:	00000106 	br	20105ac <uxTaskGetTaskNumber+0x34>
		}
		else
		{
			uxReturn = 0U;
 20105a8:	e03ffd15 	stw	zero,-12(fp)
		}

		return uxReturn;
 20105ac:	e0bffd17 	ldw	r2,-12(fp)
	}
 20105b0:	e037883a 	mov	sp,fp
 20105b4:	df000017 	ldw	fp,0(sp)
 20105b8:	dec00104 	addi	sp,sp,4
 20105bc:	f800283a 	ret

020105c0 <vTaskSetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
 20105c0:	defffc04 	addi	sp,sp,-16
 20105c4:	df000315 	stw	fp,12(sp)
 20105c8:	df000304 	addi	fp,sp,12
 20105cc:	e13ffe15 	stw	r4,-8(fp)
 20105d0:	e17fff15 	stw	r5,-4(fp)
	TCB_t * pxTCB;

		if( xTask != NULL )
 20105d4:	e0bffe17 	ldw	r2,-8(fp)
 20105d8:	10000526 	beq	r2,zero,20105f0 <vTaskSetTaskNumber+0x30>
		{
			pxTCB = xTask;
 20105dc:	e0bffe17 	ldw	r2,-8(fp)
 20105e0:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->uxTaskNumber = uxHandle;
 20105e4:	e0bffd17 	ldw	r2,-12(fp)
 20105e8:	e0ffff17 	ldw	r3,-4(fp)
 20105ec:	10c01915 	stw	r3,100(r2)
		}
	}
 20105f0:	0001883a 	nop
 20105f4:	e037883a 	mov	sp,fp
 20105f8:	df000017 	ldw	fp,0(sp)
 20105fc:	dec00104 	addi	sp,sp,4
 2010600:	f800283a 	ret

02010604 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 2010604:	defffd04 	addi	sp,sp,-12
 2010608:	dfc00215 	stw	ra,8(sp)
 201060c:	df000115 	stw	fp,4(sp)
 2010610:	df000104 	addi	fp,sp,4
 2010614:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 2010618:	20106d80 	call	20106d8 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 201061c:	003ffe06 	br	2010618 <__alt_mem_mem_0+0xfcff0618>

02010620 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 2010620:	defffd04 	addi	sp,sp,-12
 2010624:	dfc00215 	stw	ra,8(sp)
 2010628:	df000115 	stw	fp,4(sp)
 201062c:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 2010630:	e03fff15 	stw	zero,-4(fp)
 2010634:	00000a06 	br	2010660 <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 2010638:	e0bfff17 	ldw	r2,-4(fp)
 201063c:	10c00524 	muli	r3,r2,20
 2010640:	00808134 	movhi	r2,516
 2010644:	109e6704 	addi	r2,r2,31132
 2010648:	1885883a 	add	r2,r3,r2
 201064c:	1009883a 	mov	r4,r2
 2010650:	202bccc0 	call	202bccc <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 2010654:	e0bfff17 	ldw	r2,-4(fp)
 2010658:	10800044 	addi	r2,r2,1
 201065c:	e0bfff15 	stw	r2,-4(fp)
 2010660:	e0bfff17 	ldw	r2,-4(fp)
 2010664:	10800170 	cmpltui	r2,r2,5
 2010668:	103ff31e 	bne	r2,zero,2010638 <__alt_mem_mem_0+0xfcff0638>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 201066c:	01008134 	movhi	r4,516
 2010670:	211e8004 	addi	r4,r4,31232
 2010674:	202bccc0 	call	202bccc <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 2010678:	01008134 	movhi	r4,516
 201067c:	211e8504 	addi	r4,r4,31252
 2010680:	202bccc0 	call	202bccc <vListInitialise>
	vListInitialise( &xPendingReadyList );
 2010684:	01008134 	movhi	r4,516
 2010688:	211e8a04 	addi	r4,r4,31272
 201068c:	202bccc0 	call	202bccc <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 2010690:	01008134 	movhi	r4,516
 2010694:	211e8f04 	addi	r4,r4,31292
 2010698:	202bccc0 	call	202bccc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 201069c:	01008134 	movhi	r4,516
 20106a0:	211e9404 	addi	r4,r4,31312
 20106a4:	202bccc0 	call	202bccc <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 20106a8:	00808134 	movhi	r2,516
 20106ac:	109e8004 	addi	r2,r2,31232
 20106b0:	d0a7d415 	stw	r2,-24752(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 20106b4:	00808134 	movhi	r2,516
 20106b8:	109e8504 	addi	r2,r2,31252
 20106bc:	d0a7d515 	stw	r2,-24748(gp)
}
 20106c0:	0001883a 	nop
 20106c4:	e037883a 	mov	sp,fp
 20106c8:	dfc00117 	ldw	ra,4(sp)
 20106cc:	df000017 	ldw	fp,0(sp)
 20106d0:	dec00204 	addi	sp,sp,8
 20106d4:	f800283a 	ret

020106d8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 20106d8:	defffd04 	addi	sp,sp,-12
 20106dc:	dfc00215 	stw	ra,8(sp)
 20106e0:	df000115 	stw	fp,4(sp)
 20106e4:	df000104 	addi	fp,sp,4
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 20106e8:	00001706 	br	2010748 <prvCheckTasksWaitingTermination+0x70>
		{
			taskENTER_CRITICAL();
 20106ec:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20106f0:	10000126 	beq	r2,zero,20106f8 <prvCheckTasksWaitingTermination+0x20>
 20106f4:	2010f300 	call	2010f30 <vTaskEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20106f8:	00808134 	movhi	r2,516
 20106fc:	109e8f04 	addi	r2,r2,31292
 2010700:	10800317 	ldw	r2,12(r2)
 2010704:	10800317 	ldw	r2,12(r2)
 2010708:	e0bfff15 	stw	r2,-4(fp)
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 201070c:	e0bfff17 	ldw	r2,-4(fp)
 2010710:	10800104 	addi	r2,r2,4
 2010714:	1009883a 	mov	r4,r2
 2010718:	202bec40 	call	202bec4 <uxListRemove>
				--uxCurrentNumberOfTasks;
 201071c:	d0a7d717 	ldw	r2,-24740(gp)
 2010720:	10bfffc4 	addi	r2,r2,-1
 2010724:	d0a7d715 	stw	r2,-24740(gp)
				--uxDeletedTasksWaitingCleanUp;
 2010728:	d0a7d617 	ldw	r2,-24744(gp)
 201072c:	10bfffc4 	addi	r2,r2,-1
 2010730:	d0a7d615 	stw	r2,-24744(gp)
			}
			taskEXIT_CRITICAL();
 2010734:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2010738:	10000126 	beq	r2,zero,2010740 <prvCheckTasksWaitingTermination+0x68>
 201073c:	2010f780 	call	2010f78 <vTaskExitCritical>

			prvDeleteTCB( pxTCB );
 2010740:	e13fff17 	ldw	r4,-4(fp)
 2010744:	2010aa80 	call	2010aa8 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 2010748:	d0a7d617 	ldw	r2,-24744(gp)
 201074c:	103fe71e 	bne	r2,zero,20106ec <__alt_mem_mem_0+0xfcff06ec>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 2010750:	0001883a 	nop
 2010754:	e037883a 	mov	sp,fp
 2010758:	dfc00117 	ldw	ra,4(sp)
 201075c:	df000017 	ldw	fp,0(sp)
 2010760:	dec00204 	addi	sp,sp,8
 2010764:	f800283a 	ret

02010768 <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
 2010768:	defff904 	addi	sp,sp,-28
 201076c:	dfc00615 	stw	ra,24(sp)
 2010770:	df000515 	stw	fp,20(sp)
 2010774:	df000504 	addi	fp,sp,20
 2010778:	e13ffc15 	stw	r4,-16(fp)
 201077c:	e17ffd15 	stw	r5,-12(fp)
 2010780:	e1bffe15 	stw	r6,-8(fp)
 2010784:	e1ffff15 	stw	r7,-4(fp)
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
 2010788:	e0bffc17 	ldw	r2,-16(fp)
 201078c:	1000021e 	bne	r2,zero,2010798 <vTaskGetInfo+0x30>
 2010790:	d0a7d317 	ldw	r2,-24756(gp)
 2010794:	00000106 	br	201079c <vTaskGetInfo+0x34>
 2010798:	e0bffc17 	ldw	r2,-16(fp)
 201079c:	e0bffb15 	stw	r2,-20(fp)

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
 20107a0:	e0bffd17 	ldw	r2,-12(fp)
 20107a4:	e0fffb17 	ldw	r3,-20(fp)
 20107a8:	10c00015 	stw	r3,0(r2)
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
 20107ac:	e0bffb17 	ldw	r2,-20(fp)
 20107b0:	10c00d04 	addi	r3,r2,52
 20107b4:	e0bffd17 	ldw	r2,-12(fp)
 20107b8:	10c00115 	stw	r3,4(r2)
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
 20107bc:	e0bffb17 	ldw	r2,-20(fp)
 20107c0:	10c00b17 	ldw	r3,44(r2)
 20107c4:	e0bffd17 	ldw	r2,-12(fp)
 20107c8:	10c00415 	stw	r3,16(r2)
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
 20107cc:	e0bffb17 	ldw	r2,-20(fp)
 20107d0:	10c00c17 	ldw	r3,48(r2)
 20107d4:	e0bffd17 	ldw	r2,-12(fp)
 20107d8:	10c00715 	stw	r3,28(r2)
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
 20107dc:	e0bffb17 	ldw	r2,-20(fp)
 20107e0:	10c01817 	ldw	r3,96(r2)
 20107e4:	e0bffd17 	ldw	r2,-12(fp)
 20107e8:	10c00215 	stw	r3,8(r2)

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
 20107ec:	e0bffb17 	ldw	r2,-20(fp)
 20107f0:	10c01a17 	ldw	r3,104(r2)
 20107f4:	e0bffd17 	ldw	r2,-12(fp)
 20107f8:	10c00515 	stw	r3,20(r2)
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
 20107fc:	e0bffd17 	ldw	r2,-12(fp)
 2010800:	10000615 	stw	zero,24(r2)
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the
		value of eState passed into this function is eInvalid - otherwise the
		state is just set to whatever is passed in. */
		if( eState != eInvalid )
 2010804:	e0bfff17 	ldw	r2,-4(fp)
 2010808:	10800160 	cmpeqi	r2,r2,5
 201080c:	1000151e 	bne	r2,zero,2010864 <vTaskGetInfo+0xfc>
		{
			if( pxTCB == pxCurrentTCB )
 2010810:	d0a7d317 	ldw	r2,-24756(gp)
 2010814:	e0fffb17 	ldw	r3,-20(fp)
 2010818:	1880031e 	bne	r3,r2,2010828 <vTaskGetInfo+0xc0>
			{
				pxTaskStatus->eCurrentState = eRunning;
 201081c:	e0bffd17 	ldw	r2,-12(fp)
 2010820:	10000315 	stw	zero,12(r2)
 2010824:	00001406 	br	2010878 <vTaskGetInfo+0x110>
			}
			else
			{
				pxTaskStatus->eCurrentState = eState;
 2010828:	e0bffd17 	ldw	r2,-12(fp)
 201082c:	e0ffff17 	ldw	r3,-4(fp)
 2010830:	10c00315 	stw	r3,12(r2)
				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* If the task is in the suspended list then there is a
					chance it is actually just blocked indefinitely - so really
					it should be reported as being in the Blocked state. */
					if( eState == eSuspended )
 2010834:	e0bfff17 	ldw	r2,-4(fp)
 2010838:	108000d8 	cmpnei	r2,r2,3
 201083c:	10000e1e 	bne	r2,zero,2010878 <vTaskGetInfo+0x110>
					{
						vTaskSuspendAll();
 2010840:	200fa500 	call	200fa50 <vTaskSuspendAll>
						{
							if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 2010844:	e0bffb17 	ldw	r2,-20(fp)
 2010848:	10800a17 	ldw	r2,40(r2)
 201084c:	10000326 	beq	r2,zero,201085c <vTaskGetInfo+0xf4>
							{
								pxTaskStatus->eCurrentState = eBlocked;
 2010850:	e0bffd17 	ldw	r2,-12(fp)
 2010854:	00c00084 	movi	r3,2
 2010858:	10c00315 	stw	r3,12(r2)
							}
						}
						( void ) xTaskResumeAll();
 201085c:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 2010860:	00000506 	br	2010878 <vTaskGetInfo+0x110>
				#endif /* INCLUDE_vTaskSuspend */
			}
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
 2010864:	e13ffb17 	ldw	r4,-20(fp)
 2010868:	200f2c00 	call	200f2c0 <eTaskGetState>
 201086c:	1007883a 	mov	r3,r2
 2010870:	e0bffd17 	ldw	r2,-12(fp)
 2010874:	10c00315 	stw	r3,12(r2)
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
 2010878:	e0bffe17 	ldw	r2,-8(fp)
 201087c:	10000826 	beq	r2,zero,20108a0 <vTaskGetInfo+0x138>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
 2010880:	e0bffb17 	ldw	r2,-20(fp)
 2010884:	10800c17 	ldw	r2,48(r2)
 2010888:	1009883a 	mov	r4,r2
 201088c:	20109e80 	call	20109e8 <prvTaskCheckFreeStackSpace>
 2010890:	1007883a 	mov	r3,r2
 2010894:	e0bffd17 	ldw	r2,-12(fp)
 2010898:	10c00815 	stw	r3,32(r2)
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
		}
	}
 201089c:	00000206 	br	20108a8 <vTaskGetInfo+0x140>
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
 20108a0:	e0bffd17 	ldw	r2,-12(fp)
 20108a4:	10000815 	stw	zero,32(r2)
		}
	}
 20108a8:	0001883a 	nop
 20108ac:	e037883a 	mov	sp,fp
 20108b0:	dfc00117 	ldw	ra,4(sp)
 20108b4:	df000017 	ldw	fp,0(sp)
 20108b8:	dec00204 	addi	sp,sp,8
 20108bc:	f800283a 	ret

020108c0 <prvListTasksWithinSingleList>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
 20108c0:	defff604 	addi	sp,sp,-40
 20108c4:	dfc00915 	stw	ra,36(sp)
 20108c8:	df000815 	stw	fp,32(sp)
 20108cc:	df000804 	addi	fp,sp,32
 20108d0:	e13ffd15 	stw	r4,-12(fp)
 20108d4:	e17ffe15 	stw	r5,-8(fp)
 20108d8:	e1bfff15 	stw	r6,-4(fp)
	configLIST_VOLATILE TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
 20108dc:	e03ff815 	stw	zero,-32(fp)

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 20108e0:	e0bffe17 	ldw	r2,-8(fp)
 20108e4:	10800017 	ldw	r2,0(r2)
 20108e8:	10003926 	beq	r2,zero,20109d0 <prvListTasksWithinSingleList+0x110>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20108ec:	e0bffe17 	ldw	r2,-8(fp)
 20108f0:	e0bff915 	stw	r2,-28(fp)
 20108f4:	e0bff917 	ldw	r2,-28(fp)
 20108f8:	10800117 	ldw	r2,4(r2)
 20108fc:	10c00117 	ldw	r3,4(r2)
 2010900:	e0bff917 	ldw	r2,-28(fp)
 2010904:	10c00115 	stw	r3,4(r2)
 2010908:	e0bff917 	ldw	r2,-28(fp)
 201090c:	10c00117 	ldw	r3,4(r2)
 2010910:	e0bff917 	ldw	r2,-28(fp)
 2010914:	10800204 	addi	r2,r2,8
 2010918:	1880051e 	bne	r3,r2,2010930 <prvListTasksWithinSingleList+0x70>
 201091c:	e0bff917 	ldw	r2,-28(fp)
 2010920:	10800117 	ldw	r2,4(r2)
 2010924:	10c00117 	ldw	r3,4(r2)
 2010928:	e0bff917 	ldw	r2,-28(fp)
 201092c:	10c00115 	stw	r3,4(r2)
 2010930:	e0bff917 	ldw	r2,-28(fp)
 2010934:	10800117 	ldw	r2,4(r2)
 2010938:	10800317 	ldw	r2,12(r2)
 201093c:	e0bffa15 	stw	r2,-24(fp)
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2010940:	e0bffe17 	ldw	r2,-8(fp)
 2010944:	e0bffb15 	stw	r2,-20(fp)
 2010948:	e0bffb17 	ldw	r2,-20(fp)
 201094c:	10800117 	ldw	r2,4(r2)
 2010950:	10c00117 	ldw	r3,4(r2)
 2010954:	e0bffb17 	ldw	r2,-20(fp)
 2010958:	10c00115 	stw	r3,4(r2)
 201095c:	e0bffb17 	ldw	r2,-20(fp)
 2010960:	10c00117 	ldw	r3,4(r2)
 2010964:	e0bffb17 	ldw	r2,-20(fp)
 2010968:	10800204 	addi	r2,r2,8
 201096c:	1880051e 	bne	r3,r2,2010984 <prvListTasksWithinSingleList+0xc4>
 2010970:	e0bffb17 	ldw	r2,-20(fp)
 2010974:	10800117 	ldw	r2,4(r2)
 2010978:	10c00117 	ldw	r3,4(r2)
 201097c:	e0bffb17 	ldw	r2,-20(fp)
 2010980:	10c00115 	stw	r3,4(r2)
 2010984:	e0bffb17 	ldw	r2,-20(fp)
 2010988:	10800117 	ldw	r2,4(r2)
 201098c:	10800317 	ldw	r2,12(r2)
 2010990:	e0bffc15 	stw	r2,-16(fp)
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
 2010994:	e0bff817 	ldw	r2,-32(fp)
 2010998:	10800924 	muli	r2,r2,36
 201099c:	e0fffd17 	ldw	r3,-12(fp)
 20109a0:	1885883a 	add	r2,r3,r2
 20109a4:	e1ffff17 	ldw	r7,-4(fp)
 20109a8:	01800044 	movi	r6,1
 20109ac:	100b883a 	mov	r5,r2
 20109b0:	e13ffc17 	ldw	r4,-16(fp)
 20109b4:	20107680 	call	2010768 <vTaskGetInfo>
				uxTask++;
 20109b8:	e0bff817 	ldw	r2,-32(fp)
 20109bc:	10800044 	addi	r2,r2,1
 20109c0:	e0bff815 	stw	r2,-32(fp)
			} while( pxNextTCB != pxFirstTCB );
 20109c4:	e0fffc17 	ldw	r3,-16(fp)
 20109c8:	e0bffa17 	ldw	r2,-24(fp)
 20109cc:	18bfdc1e 	bne	r3,r2,2010940 <__alt_mem_mem_0+0xfcff0940>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
 20109d0:	e0bff817 	ldw	r2,-32(fp)
	}
 20109d4:	e037883a 	mov	sp,fp
 20109d8:	dfc00117 	ldw	ra,4(sp)
 20109dc:	df000017 	ldw	fp,0(sp)
 20109e0:	dec00204 	addi	sp,sp,8
 20109e4:	f800283a 	ret

020109e8 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 20109e8:	defffd04 	addi	sp,sp,-12
 20109ec:	df000215 	stw	fp,8(sp)
 20109f0:	df000204 	addi	fp,sp,8
 20109f4:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 20109f8:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 20109fc:	00000606 	br	2010a18 <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 2010a00:	e0bfff17 	ldw	r2,-4(fp)
 2010a04:	10800044 	addi	r2,r2,1
 2010a08:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 2010a0c:	e0bffe17 	ldw	r2,-8(fp)
 2010a10:	10800044 	addi	r2,r2,1
 2010a14:	e0bffe15 	stw	r2,-8(fp)

	static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 2010a18:	e0bfff17 	ldw	r2,-4(fp)
 2010a1c:	10800003 	ldbu	r2,0(r2)
 2010a20:	10803fcc 	andi	r2,r2,255
 2010a24:	10802960 	cmpeqi	r2,r2,165
 2010a28:	103ff51e 	bne	r2,zero,2010a00 <__alt_mem_mem_0+0xfcff0a00>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 2010a2c:	e0bffe17 	ldw	r2,-8(fp)
 2010a30:	1004d0ba 	srli	r2,r2,2
 2010a34:	e0bffe15 	stw	r2,-8(fp)

		return ( configSTACK_DEPTH_TYPE ) ulCount;
 2010a38:	e0bffe17 	ldw	r2,-8(fp)
	}
 2010a3c:	e037883a 	mov	sp,fp
 2010a40:	df000017 	ldw	fp,0(sp)
 2010a44:	dec00104 	addi	sp,sp,4
 2010a48:	f800283a 	ret

02010a4c <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 2010a4c:	defffa04 	addi	sp,sp,-24
 2010a50:	dfc00515 	stw	ra,20(sp)
 2010a54:	df000415 	stw	fp,16(sp)
 2010a58:	df000404 	addi	fp,sp,16
 2010a5c:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 2010a60:	e0bfff17 	ldw	r2,-4(fp)
 2010a64:	1000021e 	bne	r2,zero,2010a70 <uxTaskGetStackHighWaterMark+0x24>
 2010a68:	d0a7d317 	ldw	r2,-24756(gp)
 2010a6c:	00000106 	br	2010a74 <uxTaskGetStackHighWaterMark+0x28>
 2010a70:	e0bfff17 	ldw	r2,-4(fp)
 2010a74:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 2010a78:	e0bffc17 	ldw	r2,-16(fp)
 2010a7c:	10800c17 	ldw	r2,48(r2)
 2010a80:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 2010a84:	e13ffd17 	ldw	r4,-12(fp)
 2010a88:	20109e80 	call	20109e8 <prvTaskCheckFreeStackSpace>
 2010a8c:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 2010a90:	e0bffe17 	ldw	r2,-8(fp)
	}
 2010a94:	e037883a 	mov	sp,fp
 2010a98:	dfc00117 	ldw	ra,4(sp)
 2010a9c:	df000017 	ldw	fp,0(sp)
 2010aa0:	dec00204 	addi	sp,sp,8
 2010aa4:	f800283a 	ret

02010aa8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 2010aa8:	defffd04 	addi	sp,sp,-12
 2010aac:	dfc00215 	stw	ra,8(sp)
 2010ab0:	df000115 	stw	fp,4(sp)
 2010ab4:	df000104 	addi	fp,sp,4
 2010ab8:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 2010abc:	e0bfff17 	ldw	r2,-4(fp)
 2010ac0:	10800c17 	ldw	r2,48(r2)
 2010ac4:	1009883a 	mov	r4,r2
 2010ac8:	202bc580 	call	202bc58 <vPortFree>
			vPortFree( pxTCB );
 2010acc:	e13fff17 	ldw	r4,-4(fp)
 2010ad0:	202bc580 	call	202bc58 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 2010ad4:	0001883a 	nop
 2010ad8:	e037883a 	mov	sp,fp
 2010adc:	dfc00117 	ldw	ra,4(sp)
 2010ae0:	df000017 	ldw	fp,0(sp)
 2010ae4:	dec00204 	addi	sp,sp,8
 2010ae8:	f800283a 	ret

02010aec <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 2010aec:	defffe04 	addi	sp,sp,-8
 2010af0:	df000115 	stw	fp,4(sp)
 2010af4:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 2010af8:	d0a7d417 	ldw	r2,-24752(gp)
 2010afc:	10800017 	ldw	r2,0(r2)
 2010b00:	1000031e 	bne	r2,zero,2010b10 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 2010b04:	00bfffc4 	movi	r2,-1
 2010b08:	d0a7df15 	stw	r2,-24708(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 2010b0c:	00000706 	br	2010b2c <prvResetNextTaskUnblockTime+0x40>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2010b10:	d0a7d417 	ldw	r2,-24752(gp)
 2010b14:	10800317 	ldw	r2,12(r2)
 2010b18:	10800317 	ldw	r2,12(r2)
 2010b1c:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 2010b20:	e0bfff17 	ldw	r2,-4(fp)
 2010b24:	10800117 	ldw	r2,4(r2)
 2010b28:	d0a7df15 	stw	r2,-24708(gp)
	}
}
 2010b2c:	0001883a 	nop
 2010b30:	e037883a 	mov	sp,fp
 2010b34:	df000017 	ldw	fp,0(sp)
 2010b38:	dec00104 	addi	sp,sp,4
 2010b3c:	f800283a 	ret

02010b40 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 2010b40:	defffe04 	addi	sp,sp,-8
 2010b44:	df000115 	stw	fp,4(sp)
 2010b48:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 2010b4c:	d0a7d317 	ldw	r2,-24756(gp)
 2010b50:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 2010b54:	e0bfff17 	ldw	r2,-4(fp)
	}
 2010b58:	e037883a 	mov	sp,fp
 2010b5c:	df000017 	ldw	fp,0(sp)
 2010b60:	dec00104 	addi	sp,sp,4
 2010b64:	f800283a 	ret

02010b68 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 2010b68:	defffe04 	addi	sp,sp,-8
 2010b6c:	df000115 	stw	fp,4(sp)
 2010b70:	df000104 	addi	fp,sp,4
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 2010b74:	d0a7da17 	ldw	r2,-24728(gp)
 2010b78:	1000031e 	bne	r2,zero,2010b88 <xTaskGetSchedulerState+0x20>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 2010b7c:	00800044 	movi	r2,1
 2010b80:	e0bfff15 	stw	r2,-4(fp)
 2010b84:	00000606 	br	2010ba0 <xTaskGetSchedulerState+0x38>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2010b88:	d0a7e117 	ldw	r2,-24700(gp)
 2010b8c:	1000031e 	bne	r2,zero,2010b9c <xTaskGetSchedulerState+0x34>
			{
				xReturn = taskSCHEDULER_RUNNING;
 2010b90:	00800084 	movi	r2,2
 2010b94:	e0bfff15 	stw	r2,-4(fp)
 2010b98:	00000106 	br	2010ba0 <xTaskGetSchedulerState+0x38>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 2010b9c:	e03fff15 	stw	zero,-4(fp)
			}
		}

		return xReturn;
 2010ba0:	e0bfff17 	ldw	r2,-4(fp)
	}
 2010ba4:	e037883a 	mov	sp,fp
 2010ba8:	df000017 	ldw	fp,0(sp)
 2010bac:	dec00104 	addi	sp,sp,4
 2010bb0:	f800283a 	ret

02010bb4 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 2010bb4:	defffb04 	addi	sp,sp,-20
 2010bb8:	dfc00415 	stw	ra,16(sp)
 2010bbc:	df000315 	stw	fp,12(sp)
 2010bc0:	df000304 	addi	fp,sp,12
 2010bc4:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 2010bc8:	e0bfff17 	ldw	r2,-4(fp)
 2010bcc:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 2010bd0:	e03ffd15 	stw	zero,-12(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 2010bd4:	e0bfff17 	ldw	r2,-4(fp)
 2010bd8:	10004026 	beq	r2,zero,2010cdc <xTaskPriorityInherit+0x128>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 2010bdc:	e0bffe17 	ldw	r2,-8(fp)
 2010be0:	10c00b17 	ldw	r3,44(r2)
 2010be4:	d0a7d317 	ldw	r2,-24756(gp)
 2010be8:	10800b17 	ldw	r2,44(r2)
 2010bec:	1880342e 	bgeu	r3,r2,2010cc0 <xTaskPriorityInherit+0x10c>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2010bf0:	e0bffe17 	ldw	r2,-8(fp)
 2010bf4:	10800617 	ldw	r2,24(r2)
 2010bf8:	10000616 	blt	r2,zero,2010c14 <xTaskPriorityInherit+0x60>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010bfc:	d0a7d317 	ldw	r2,-24756(gp)
 2010c00:	10800b17 	ldw	r2,44(r2)
 2010c04:	00c00144 	movi	r3,5
 2010c08:	1887c83a 	sub	r3,r3,r2
 2010c0c:	e0bffe17 	ldw	r2,-8(fp)
 2010c10:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 2010c14:	e0bffe17 	ldw	r2,-8(fp)
 2010c18:	10c00517 	ldw	r3,20(r2)
 2010c1c:	e0bffe17 	ldw	r2,-8(fp)
 2010c20:	10800b17 	ldw	r2,44(r2)
 2010c24:	11000524 	muli	r4,r2,20
 2010c28:	00808134 	movhi	r2,516
 2010c2c:	109e6704 	addi	r2,r2,31132
 2010c30:	2085883a 	add	r2,r4,r2
 2010c34:	18801b1e 	bne	r3,r2,2010ca4 <xTaskPriorityInherit+0xf0>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010c38:	e0bffe17 	ldw	r2,-8(fp)
 2010c3c:	10800104 	addi	r2,r2,4
 2010c40:	1009883a 	mov	r4,r2
 2010c44:	202bec40 	call	202bec4 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 2010c48:	d0a7d317 	ldw	r2,-24756(gp)
 2010c4c:	10c00b17 	ldw	r3,44(r2)
 2010c50:	e0bffe17 	ldw	r2,-8(fp)
 2010c54:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxMutexHolderTCB );
 2010c58:	e0bffe17 	ldw	r2,-8(fp)
 2010c5c:	10800b17 	ldw	r2,44(r2)
 2010c60:	d0e7d917 	ldw	r3,-24732(gp)
 2010c64:	1880032e 	bgeu	r3,r2,2010c74 <xTaskPriorityInherit+0xc0>
 2010c68:	e0bffe17 	ldw	r2,-8(fp)
 2010c6c:	10800b17 	ldw	r2,44(r2)
 2010c70:	d0a7d915 	stw	r2,-24732(gp)
 2010c74:	e0bffe17 	ldw	r2,-8(fp)
 2010c78:	10800b17 	ldw	r2,44(r2)
 2010c7c:	10c00524 	muli	r3,r2,20
 2010c80:	00808134 	movhi	r2,516
 2010c84:	109e6704 	addi	r2,r2,31132
 2010c88:	1887883a 	add	r3,r3,r2
 2010c8c:	e0bffe17 	ldw	r2,-8(fp)
 2010c90:	10800104 	addi	r2,r2,4
 2010c94:	100b883a 	mov	r5,r2
 2010c98:	1809883a 	mov	r4,r3
 2010c9c:	202bd600 	call	202bd60 <vListInsertEnd>
 2010ca0:	00000406 	br	2010cb4 <xTaskPriorityInherit+0x100>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 2010ca4:	d0a7d317 	ldw	r2,-24756(gp)
 2010ca8:	10c00b17 	ldw	r3,44(r2)
 2010cac:	e0bffe17 	ldw	r2,-8(fp)
 2010cb0:	10c00b15 	stw	r3,44(r2)
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 2010cb4:	00800044 	movi	r2,1
 2010cb8:	e0bffd15 	stw	r2,-12(fp)
 2010cbc:	00000706 	br	2010cdc <xTaskPriorityInherit+0x128>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 2010cc0:	e0bffe17 	ldw	r2,-8(fp)
 2010cc4:	10c01a17 	ldw	r3,104(r2)
 2010cc8:	d0a7d317 	ldw	r2,-24756(gp)
 2010ccc:	10800b17 	ldw	r2,44(r2)
 2010cd0:	1880022e 	bgeu	r3,r2,2010cdc <xTaskPriorityInherit+0x128>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 2010cd4:	00800044 	movi	r2,1
 2010cd8:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2010cdc:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010ce0:	e037883a 	mov	sp,fp
 2010ce4:	dfc00117 	ldw	ra,4(sp)
 2010ce8:	df000017 	ldw	fp,0(sp)
 2010cec:	dec00204 	addi	sp,sp,8
 2010cf0:	f800283a 	ret

02010cf4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 2010cf4:	defffb04 	addi	sp,sp,-20
 2010cf8:	dfc00415 	stw	ra,16(sp)
 2010cfc:	df000315 	stw	fp,12(sp)
 2010d00:	df000304 	addi	fp,sp,12
 2010d04:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 2010d08:	e0bfff17 	ldw	r2,-4(fp)
 2010d0c:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 2010d10:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 2010d14:	e0bfff17 	ldw	r2,-4(fp)
 2010d18:	10002f26 	beq	r2,zero,2010dd8 <xTaskPriorityDisinherit+0xe4>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 2010d1c:	e0bffe17 	ldw	r2,-8(fp)
 2010d20:	10801b17 	ldw	r2,108(r2)
 2010d24:	10ffffc4 	addi	r3,r2,-1
 2010d28:	e0bffe17 	ldw	r2,-8(fp)
 2010d2c:	10c01b15 	stw	r3,108(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 2010d30:	e0bffe17 	ldw	r2,-8(fp)
 2010d34:	10c00b17 	ldw	r3,44(r2)
 2010d38:	e0bffe17 	ldw	r2,-8(fp)
 2010d3c:	10801a17 	ldw	r2,104(r2)
 2010d40:	18802526 	beq	r3,r2,2010dd8 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 2010d44:	e0bffe17 	ldw	r2,-8(fp)
 2010d48:	10801b17 	ldw	r2,108(r2)
 2010d4c:	1000221e 	bne	r2,zero,2010dd8 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010d50:	e0bffe17 	ldw	r2,-8(fp)
 2010d54:	10800104 	addi	r2,r2,4
 2010d58:	1009883a 	mov	r4,r2
 2010d5c:	202bec40 	call	202bec4 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 2010d60:	e0bffe17 	ldw	r2,-8(fp)
 2010d64:	10c01a17 	ldw	r3,104(r2)
 2010d68:	e0bffe17 	ldw	r2,-8(fp)
 2010d6c:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010d70:	e0bffe17 	ldw	r2,-8(fp)
 2010d74:	10800b17 	ldw	r2,44(r2)
 2010d78:	00c00144 	movi	r3,5
 2010d7c:	1887c83a 	sub	r3,r3,r2
 2010d80:	e0bffe17 	ldw	r2,-8(fp)
 2010d84:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 2010d88:	e0bffe17 	ldw	r2,-8(fp)
 2010d8c:	10800b17 	ldw	r2,44(r2)
 2010d90:	d0e7d917 	ldw	r3,-24732(gp)
 2010d94:	1880032e 	bgeu	r3,r2,2010da4 <xTaskPriorityDisinherit+0xb0>
 2010d98:	e0bffe17 	ldw	r2,-8(fp)
 2010d9c:	10800b17 	ldw	r2,44(r2)
 2010da0:	d0a7d915 	stw	r2,-24732(gp)
 2010da4:	e0bffe17 	ldw	r2,-8(fp)
 2010da8:	10800b17 	ldw	r2,44(r2)
 2010dac:	10c00524 	muli	r3,r2,20
 2010db0:	00808134 	movhi	r2,516
 2010db4:	109e6704 	addi	r2,r2,31132
 2010db8:	1887883a 	add	r3,r3,r2
 2010dbc:	e0bffe17 	ldw	r2,-8(fp)
 2010dc0:	10800104 	addi	r2,r2,4
 2010dc4:	100b883a 	mov	r5,r2
 2010dc8:	1809883a 	mov	r4,r3
 2010dcc:	202bd600 	call	202bd60 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 2010dd0:	00800044 	movi	r2,1
 2010dd4:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 2010dd8:	e0bffd17 	ldw	r2,-12(fp)
	}
 2010ddc:	e037883a 	mov	sp,fp
 2010de0:	dfc00117 	ldw	ra,4(sp)
 2010de4:	df000017 	ldw	fp,0(sp)
 2010de8:	dec00204 	addi	sp,sp,8
 2010dec:	f800283a 	ret

02010df0 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 2010df0:	defff804 	addi	sp,sp,-32
 2010df4:	dfc00715 	stw	ra,28(sp)
 2010df8:	df000615 	stw	fp,24(sp)
 2010dfc:	df000604 	addi	fp,sp,24
 2010e00:	e13ffe15 	stw	r4,-8(fp)
 2010e04:	e17fff15 	stw	r5,-4(fp)
	TCB_t * const pxTCB = pxMutexHolder;
 2010e08:	e0bffe17 	ldw	r2,-8(fp)
 2010e0c:	e0bffb15 	stw	r2,-20(fp)
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 2010e10:	00800044 	movi	r2,1
 2010e14:	e0bffc15 	stw	r2,-16(fp)

		if( pxMutexHolder != NULL )
 2010e18:	e0bffe17 	ldw	r2,-8(fp)
 2010e1c:	10003e26 	beq	r2,zero,2010f18 <vTaskPriorityDisinheritAfterTimeout+0x128>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 2010e20:	e0bffb17 	ldw	r2,-20(fp)
 2010e24:	10c01a17 	ldw	r3,104(r2)
 2010e28:	e0bfff17 	ldw	r2,-4(fp)
 2010e2c:	1880032e 	bgeu	r3,r2,2010e3c <vTaskPriorityDisinheritAfterTimeout+0x4c>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 2010e30:	e0bfff17 	ldw	r2,-4(fp)
 2010e34:	e0bffa15 	stw	r2,-24(fp)
 2010e38:	00000306 	br	2010e48 <vTaskPriorityDisinheritAfterTimeout+0x58>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 2010e3c:	e0bffb17 	ldw	r2,-20(fp)
 2010e40:	10801a17 	ldw	r2,104(r2)
 2010e44:	e0bffa15 	stw	r2,-24(fp)
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 2010e48:	e0bffb17 	ldw	r2,-20(fp)
 2010e4c:	10c00b17 	ldw	r3,44(r2)
 2010e50:	e0bffa17 	ldw	r2,-24(fp)
 2010e54:	18803026 	beq	r3,r2,2010f18 <vTaskPriorityDisinheritAfterTimeout+0x128>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 2010e58:	e0bffb17 	ldw	r2,-20(fp)
 2010e5c:	10c01b17 	ldw	r3,108(r2)
 2010e60:	e0bffc17 	ldw	r2,-16(fp)
 2010e64:	18802c1e 	bne	r3,r2,2010f18 <vTaskPriorityDisinheritAfterTimeout+0x128>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 2010e68:	e0bffb17 	ldw	r2,-20(fp)
 2010e6c:	10800b17 	ldw	r2,44(r2)
 2010e70:	e0bffd15 	stw	r2,-12(fp)
					pxTCB->uxPriority = uxPriorityToUse;
 2010e74:	e0bffb17 	ldw	r2,-20(fp)
 2010e78:	e0fffa17 	ldw	r3,-24(fp)
 2010e7c:	10c00b15 	stw	r3,44(r2)

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 2010e80:	e0bffb17 	ldw	r2,-20(fp)
 2010e84:	10800617 	ldw	r2,24(r2)
 2010e88:	10000516 	blt	r2,zero,2010ea0 <vTaskPriorityDisinheritAfterTimeout+0xb0>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010e8c:	00c00144 	movi	r3,5
 2010e90:	e0bffa17 	ldw	r2,-24(fp)
 2010e94:	1887c83a 	sub	r3,r3,r2
 2010e98:	e0bffb17 	ldw	r2,-20(fp)
 2010e9c:	10c00615 	stw	r3,24(r2)
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 2010ea0:	e0bffb17 	ldw	r2,-20(fp)
 2010ea4:	10c00517 	ldw	r3,20(r2)
 2010ea8:	e0bffd17 	ldw	r2,-12(fp)
 2010eac:	11000524 	muli	r4,r2,20
 2010eb0:	00808134 	movhi	r2,516
 2010eb4:	109e6704 	addi	r2,r2,31132
 2010eb8:	2085883a 	add	r2,r4,r2
 2010ebc:	1880161e 	bne	r3,r2,2010f18 <vTaskPriorityDisinheritAfterTimeout+0x128>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2010ec0:	e0bffb17 	ldw	r2,-20(fp)
 2010ec4:	10800104 	addi	r2,r2,4
 2010ec8:	1009883a 	mov	r4,r2
 2010ecc:	202bec40 	call	202bec4 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 2010ed0:	e0bffb17 	ldw	r2,-20(fp)
 2010ed4:	10800b17 	ldw	r2,44(r2)
 2010ed8:	d0e7d917 	ldw	r3,-24732(gp)
 2010edc:	1880032e 	bgeu	r3,r2,2010eec <vTaskPriorityDisinheritAfterTimeout+0xfc>
 2010ee0:	e0bffb17 	ldw	r2,-20(fp)
 2010ee4:	10800b17 	ldw	r2,44(r2)
 2010ee8:	d0a7d915 	stw	r2,-24732(gp)
 2010eec:	e0bffb17 	ldw	r2,-20(fp)
 2010ef0:	10800b17 	ldw	r2,44(r2)
 2010ef4:	10c00524 	muli	r3,r2,20
 2010ef8:	00808134 	movhi	r2,516
 2010efc:	109e6704 	addi	r2,r2,31132
 2010f00:	1887883a 	add	r3,r3,r2
 2010f04:	e0bffb17 	ldw	r2,-20(fp)
 2010f08:	10800104 	addi	r2,r2,4
 2010f0c:	100b883a 	mov	r5,r2
 2010f10:	1809883a 	mov	r4,r3
 2010f14:	202bd600 	call	202bd60 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010f18:	0001883a 	nop
 2010f1c:	e037883a 	mov	sp,fp
 2010f20:	dfc00117 	ldw	ra,4(sp)
 2010f24:	df000017 	ldw	fp,0(sp)
 2010f28:	dec00204 	addi	sp,sp,8
 2010f2c:	f800283a 	ret

02010f30 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 2010f30:	defffe04 	addi	sp,sp,-8
 2010f34:	dfc00115 	stw	ra,4(sp)
 2010f38:	df000015 	stw	fp,0(sp)
 2010f3c:	d839883a 	mov	fp,sp
		portDISABLE_INTERRUPTS();
 2010f40:	202bf880 	call	202bf88 <enh_alt_irq_disable_all>

		if( xSchedulerRunning != pdFALSE )
 2010f44:	d0a7da17 	ldw	r2,-24728(gp)
 2010f48:	10000526 	beq	r2,zero,2010f60 <vTaskEnterCritical+0x30>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 2010f4c:	d0a7d317 	ldw	r2,-24756(gp)
 2010f50:	10c01717 	ldw	r3,92(r2)
 2010f54:	18c00044 	addi	r3,r3,1
 2010f58:	10c01715 	stw	r3,92(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 2010f5c:	d0a7d317 	ldw	r2,-24756(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010f60:	0001883a 	nop
 2010f64:	e037883a 	mov	sp,fp
 2010f68:	dfc00117 	ldw	ra,4(sp)
 2010f6c:	df000017 	ldw	fp,0(sp)
 2010f70:	dec00204 	addi	sp,sp,8
 2010f74:	f800283a 	ret

02010f78 <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 2010f78:	defffe04 	addi	sp,sp,-8
 2010f7c:	dfc00115 	stw	ra,4(sp)
 2010f80:	df000015 	stw	fp,0(sp)
 2010f84:	d839883a 	mov	fp,sp
		if( xSchedulerRunning != pdFALSE )
 2010f88:	d0a7da17 	ldw	r2,-24728(gp)
 2010f8c:	10000b26 	beq	r2,zero,2010fbc <vTaskExitCritical+0x44>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 2010f90:	d0a7d317 	ldw	r2,-24756(gp)
 2010f94:	10801717 	ldw	r2,92(r2)
 2010f98:	10000826 	beq	r2,zero,2010fbc <vTaskExitCritical+0x44>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 2010f9c:	d0a7d317 	ldw	r2,-24756(gp)
 2010fa0:	10c01717 	ldw	r3,92(r2)
 2010fa4:	18ffffc4 	addi	r3,r3,-1
 2010fa8:	10c01715 	stw	r3,92(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 2010fac:	d0a7d317 	ldw	r2,-24756(gp)
 2010fb0:	10801717 	ldw	r2,92(r2)
 2010fb4:	1000011e 	bne	r2,zero,2010fbc <vTaskExitCritical+0x44>
				{
					portENABLE_INTERRUPTS();
 2010fb8:	202bfd80 	call	202bfd8 <enh_alt_irq_enable_all>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 2010fbc:	0001883a 	nop
 2010fc0:	e037883a 	mov	sp,fp
 2010fc4:	dfc00117 	ldw	ra,4(sp)
 2010fc8:	df000017 	ldw	fp,0(sp)
 2010fcc:	dec00204 	addi	sp,sp,8
 2010fd0:	f800283a 	ret

02010fd4 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 2010fd4:	defffe04 	addi	sp,sp,-8
 2010fd8:	df000115 	stw	fp,4(sp)
 2010fdc:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 2010fe0:	d0a7d317 	ldw	r2,-24756(gp)
 2010fe4:	10800617 	ldw	r2,24(r2)
 2010fe8:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2010fec:	d0a7d317 	ldw	r2,-24756(gp)
 2010ff0:	d0e7d317 	ldw	r3,-24756(gp)
 2010ff4:	18c00b17 	ldw	r3,44(r3)
 2010ff8:	01000144 	movi	r4,5
 2010ffc:	20c7c83a 	sub	r3,r4,r3
 2011000:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 2011004:	e0bfff17 	ldw	r2,-4(fp)
}
 2011008:	e037883a 	mov	sp,fp
 201100c:	df000017 	ldw	fp,0(sp)
 2011010:	dec00104 	addi	sp,sp,4
 2011014:	f800283a 	ret

02011018 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 2011018:	deffff04 	addi	sp,sp,-4
 201101c:	df000015 	stw	fp,0(sp)
 2011020:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 2011024:	d0a7d317 	ldw	r2,-24756(gp)
 2011028:	10000426 	beq	r2,zero,201103c <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 201102c:	d0a7d317 	ldw	r2,-24756(gp)
 2011030:	10c01b17 	ldw	r3,108(r2)
 2011034:	18c00044 	addi	r3,r3,1
 2011038:	10c01b15 	stw	r3,108(r2)
		}

		return pxCurrentTCB;
 201103c:	d0a7d317 	ldw	r2,-24756(gp)
	}
 2011040:	e037883a 	mov	sp,fp
 2011044:	df000017 	ldw	fp,0(sp)
 2011048:	dec00104 	addi	sp,sp,4
 201104c:	f800283a 	ret

02011050 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 2011050:	defffb04 	addi	sp,sp,-20
 2011054:	dfc00415 	stw	ra,16(sp)
 2011058:	df000315 	stw	fp,12(sp)
 201105c:	df000304 	addi	fp,sp,12
 2011060:	e13ffe15 	stw	r4,-8(fp)
 2011064:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 2011068:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201106c:	10000126 	beq	r2,zero,2011074 <ulTaskNotifyTake+0x24>
 2011070:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 2011074:	d0a7d317 	ldw	r2,-24756(gp)
 2011078:	10801c17 	ldw	r2,112(r2)
 201107c:	1000091e 	bne	r2,zero,20110a4 <ulTaskNotifyTake+0x54>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 2011080:	d0a7d317 	ldw	r2,-24756(gp)
 2011084:	00c00044 	movi	r3,1
 2011088:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 201108c:	e0bfff17 	ldw	r2,-4(fp)
 2011090:	10000426 	beq	r2,zero,20110a4 <ulTaskNotifyTake+0x54>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 2011094:	01400044 	movi	r5,1
 2011098:	e13fff17 	ldw	r4,-4(fp)
 201109c:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 20110a0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 20110a4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20110a8:	10000126 	beq	r2,zero,20110b0 <ulTaskNotifyTake+0x60>
 20110ac:	2010f780 	call	2010f78 <vTaskExitCritical>

		taskENTER_CRITICAL();
 20110b0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20110b4:	10000126 	beq	r2,zero,20110bc <ulTaskNotifyTake+0x6c>
 20110b8:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 20110bc:	d0a7d317 	ldw	r2,-24756(gp)
 20110c0:	10801c17 	ldw	r2,112(r2)
 20110c4:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 20110c8:	e0bffd17 	ldw	r2,-12(fp)
 20110cc:	10000926 	beq	r2,zero,20110f4 <ulTaskNotifyTake+0xa4>
			{
				if( xClearCountOnExit != pdFALSE )
 20110d0:	e0bffe17 	ldw	r2,-8(fp)
 20110d4:	10000326 	beq	r2,zero,20110e4 <ulTaskNotifyTake+0x94>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 20110d8:	d0a7d317 	ldw	r2,-24756(gp)
 20110dc:	10001c15 	stw	zero,112(r2)
 20110e0:	00000406 	br	20110f4 <ulTaskNotifyTake+0xa4>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
 20110e4:	d0a7d317 	ldw	r2,-24756(gp)
 20110e8:	e0fffd17 	ldw	r3,-12(fp)
 20110ec:	18ffffc4 	addi	r3,r3,-1
 20110f0:	10c01c15 	stw	r3,112(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 20110f4:	d0a7d317 	ldw	r2,-24756(gp)
 20110f8:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 20110fc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011100:	10000126 	beq	r2,zero,2011108 <ulTaskNotifyTake+0xb8>
 2011104:	2010f780 	call	2010f78 <vTaskExitCritical>

		return ulReturn;
 2011108:	e0bffd17 	ldw	r2,-12(fp)
	}
 201110c:	e037883a 	mov	sp,fp
 2011110:	dfc00117 	ldw	ra,4(sp)
 2011114:	df000017 	ldw	fp,0(sp)
 2011118:	dec00204 	addi	sp,sp,8
 201111c:	f800283a 	ret

02011120 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 2011120:	defff904 	addi	sp,sp,-28
 2011124:	dfc00615 	stw	ra,24(sp)
 2011128:	df000515 	stw	fp,20(sp)
 201112c:	df000504 	addi	fp,sp,20
 2011130:	e13ffc15 	stw	r4,-16(fp)
 2011134:	e17ffd15 	stw	r5,-12(fp)
 2011138:	e1bffe15 	stw	r6,-8(fp)
 201113c:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 2011140:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011144:	10000126 	beq	r2,zero,201114c <xTaskNotifyWait+0x2c>
 2011148:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 201114c:	d0a7d317 	ldw	r2,-24756(gp)
 2011150:	10801d03 	ldbu	r2,116(r2)
 2011154:	10803fcc 	andi	r2,r2,255
 2011158:	108000a0 	cmpeqi	r2,r2,2
 201115c:	10000f1e 	bne	r2,zero,201119c <xTaskNotifyWait+0x7c>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 2011160:	d0a7d317 	ldw	r2,-24756(gp)
 2011164:	11001c17 	ldw	r4,112(r2)
 2011168:	e0fffc17 	ldw	r3,-16(fp)
 201116c:	00c6303a 	nor	r3,zero,r3
 2011170:	20c6703a 	and	r3,r4,r3
 2011174:	10c01c15 	stw	r3,112(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 2011178:	d0a7d317 	ldw	r2,-24756(gp)
 201117c:	00c00044 	movi	r3,1
 2011180:	10c01d05 	stb	r3,116(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 2011184:	e0bfff17 	ldw	r2,-4(fp)
 2011188:	10000426 	beq	r2,zero,201119c <xTaskNotifyWait+0x7c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 201118c:	01400044 	movi	r5,1
 2011190:	e13fff17 	ldw	r4,-4(fp)
 2011194:	20118040 	call	2011804 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 2011198:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 201119c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20111a0:	10000126 	beq	r2,zero,20111a8 <xTaskNotifyWait+0x88>
 20111a4:	2010f780 	call	2010f78 <vTaskExitCritical>

		taskENTER_CRITICAL();
 20111a8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20111ac:	10000126 	beq	r2,zero,20111b4 <xTaskNotifyWait+0x94>
 20111b0:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 20111b4:	e0bffe17 	ldw	r2,-8(fp)
 20111b8:	10000426 	beq	r2,zero,20111cc <xTaskNotifyWait+0xac>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 20111bc:	d0a7d317 	ldw	r2,-24756(gp)
 20111c0:	10c01c17 	ldw	r3,112(r2)
 20111c4:	e0bffe17 	ldw	r2,-8(fp)
 20111c8:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 20111cc:	d0a7d317 	ldw	r2,-24756(gp)
 20111d0:	10801d03 	ldbu	r2,116(r2)
 20111d4:	10803fcc 	andi	r2,r2,255
 20111d8:	108000a0 	cmpeqi	r2,r2,2
 20111dc:	1000021e 	bne	r2,zero,20111e8 <xTaskNotifyWait+0xc8>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 20111e0:	e03ffb15 	stw	zero,-20(fp)
 20111e4:	00000806 	br	2011208 <xTaskNotifyWait+0xe8>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 20111e8:	d0a7d317 	ldw	r2,-24756(gp)
 20111ec:	11001c17 	ldw	r4,112(r2)
 20111f0:	e0fffd17 	ldw	r3,-12(fp)
 20111f4:	00c6303a 	nor	r3,zero,r3
 20111f8:	20c6703a 	and	r3,r4,r3
 20111fc:	10c01c15 	stw	r3,112(r2)
				xReturn = pdTRUE;
 2011200:	00800044 	movi	r2,1
 2011204:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2011208:	d0a7d317 	ldw	r2,-24756(gp)
 201120c:	10001d05 	stb	zero,116(r2)
		}
		taskEXIT_CRITICAL();
 2011210:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011214:	10000126 	beq	r2,zero,201121c <xTaskNotifyWait+0xfc>
 2011218:	2010f780 	call	2010f78 <vTaskExitCritical>

		return xReturn;
 201121c:	e0bffb17 	ldw	r2,-20(fp)
	}
 2011220:	e037883a 	mov	sp,fp
 2011224:	dfc00117 	ldw	ra,4(sp)
 2011228:	df000017 	ldw	fp,0(sp)
 201122c:	dec00204 	addi	sp,sp,8
 2011230:	f800283a 	ret

02011234 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 2011234:	defff704 	addi	sp,sp,-36
 2011238:	dfc00815 	stw	ra,32(sp)
 201123c:	df000715 	stw	fp,28(sp)
 2011240:	df000704 	addi	fp,sp,28
 2011244:	e13ffc15 	stw	r4,-16(fp)
 2011248:	e17ffd15 	stw	r5,-12(fp)
 201124c:	e1bffe15 	stw	r6,-8(fp)
 2011250:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 2011254:	00800044 	movi	r2,1
 2011258:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
 201125c:	e0bffc17 	ldw	r2,-16(fp)
 2011260:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 2011264:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011268:	10000126 	beq	r2,zero,2011270 <xTaskGenericNotify+0x3c>
 201126c:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 2011270:	e0bfff17 	ldw	r2,-4(fp)
 2011274:	10000426 	beq	r2,zero,2011288 <xTaskGenericNotify+0x54>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 2011278:	e0bffa17 	ldw	r2,-24(fp)
 201127c:	10c01c17 	ldw	r3,112(r2)
 2011280:	e0bfff17 	ldw	r2,-4(fp)
 2011284:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 2011288:	e0bffa17 	ldw	r2,-24(fp)
 201128c:	10801d03 	ldbu	r2,116(r2)
 2011290:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2011294:	e0bffa17 	ldw	r2,-24(fp)
 2011298:	00c00084 	movi	r3,2
 201129c:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 20112a0:	e0bffe17 	ldw	r2,-8(fp)
 20112a4:	10800168 	cmpgeui	r2,r2,5
 20112a8:	1000261e 	bne	r2,zero,2011344 <xTaskGenericNotify+0x110>
 20112ac:	e0bffe17 	ldw	r2,-8(fp)
 20112b0:	100690ba 	slli	r3,r2,2
 20112b4:	00808074 	movhi	r2,513
 20112b8:	1084b204 	addi	r2,r2,4808
 20112bc:	1885883a 	add	r2,r3,r2
 20112c0:	10800017 	ldw	r2,0(r2)
 20112c4:	1000683a 	jmp	r2
 20112c8:	0201134c 	andi	r8,zero,1101
 20112cc:	020112dc 	xori	r8,zero,1099
 20112d0:	020112f8 	rdprs	r8,zero,1099
 20112d4:	02011310 	cmplti	r8,zero,1100
 20112d8:	02011320 	cmpeqi	r8,zero,1100
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 20112dc:	e0bffa17 	ldw	r2,-24(fp)
 20112e0:	10c01c17 	ldw	r3,112(r2)
 20112e4:	e0bffd17 	ldw	r2,-12(fp)
 20112e8:	1886b03a 	or	r3,r3,r2
 20112ec:	e0bffa17 	ldw	r2,-24(fp)
 20112f0:	10c01c15 	stw	r3,112(r2)
					break;
 20112f4:	00001606 	br	2011350 <xTaskGenericNotify+0x11c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 20112f8:	e0bffa17 	ldw	r2,-24(fp)
 20112fc:	10801c17 	ldw	r2,112(r2)
 2011300:	10c00044 	addi	r3,r2,1
 2011304:	e0bffa17 	ldw	r2,-24(fp)
 2011308:	10c01c15 	stw	r3,112(r2)
					break;
 201130c:	00001006 	br	2011350 <xTaskGenericNotify+0x11c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 2011310:	e0bffa17 	ldw	r2,-24(fp)
 2011314:	e0fffd17 	ldw	r3,-12(fp)
 2011318:	10c01c15 	stw	r3,112(r2)
					break;
 201131c:	00000c06 	br	2011350 <xTaskGenericNotify+0x11c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 2011320:	e0bffb03 	ldbu	r2,-20(fp)
 2011324:	108000a0 	cmpeqi	r2,r2,2
 2011328:	1000041e 	bne	r2,zero,201133c <xTaskGenericNotify+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
 201132c:	e0bffa17 	ldw	r2,-24(fp)
 2011330:	e0fffd17 	ldw	r3,-12(fp)
 2011334:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 2011338:	00000506 	br	2011350 <xTaskGenericNotify+0x11c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 201133c:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 2011340:	00000306 	br	2011350 <xTaskGenericNotify+0x11c>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
 2011344:	0001883a 	nop
 2011348:	00000106 	br	2011350 <xTaskGenericNotify+0x11c>
					break;

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 201134c:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2011350:	e0bffb03 	ldbu	r2,-20(fp)
 2011354:	10800058 	cmpnei	r2,r2,1
 2011358:	10001c1e 	bne	r2,zero,20113cc <xTaskGenericNotify+0x198>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 201135c:	e0bffa17 	ldw	r2,-24(fp)
 2011360:	10800104 	addi	r2,r2,4
 2011364:	1009883a 	mov	r4,r2
 2011368:	202bec40 	call	202bec4 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 201136c:	e0bffa17 	ldw	r2,-24(fp)
 2011370:	10800b17 	ldw	r2,44(r2)
 2011374:	d0e7d917 	ldw	r3,-24732(gp)
 2011378:	1880032e 	bgeu	r3,r2,2011388 <xTaskGenericNotify+0x154>
 201137c:	e0bffa17 	ldw	r2,-24(fp)
 2011380:	10800b17 	ldw	r2,44(r2)
 2011384:	d0a7d915 	stw	r2,-24732(gp)
 2011388:	e0bffa17 	ldw	r2,-24(fp)
 201138c:	10800b17 	ldw	r2,44(r2)
 2011390:	10c00524 	muli	r3,r2,20
 2011394:	00808134 	movhi	r2,516
 2011398:	109e6704 	addi	r2,r2,31132
 201139c:	1887883a 	add	r3,r3,r2
 20113a0:	e0bffa17 	ldw	r2,-24(fp)
 20113a4:	10800104 	addi	r2,r2,4
 20113a8:	100b883a 	mov	r5,r2
 20113ac:	1809883a 	mov	r4,r3
 20113b0:	202bd600 	call	202bd60 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 20113b4:	e0bffa17 	ldw	r2,-24(fp)
 20113b8:	10800b17 	ldw	r2,44(r2)
 20113bc:	d0e7d317 	ldw	r3,-24756(gp)
 20113c0:	18c00b17 	ldw	r3,44(r3)
 20113c4:	1880012e 	bgeu	r3,r2,20113cc <xTaskGenericNotify+0x198>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 20113c8:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 20113cc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20113d0:	10000126 	beq	r2,zero,20113d8 <xTaskGenericNotify+0x1a4>
 20113d4:	2010f780 	call	2010f78 <vTaskExitCritical>

		return xReturn;
 20113d8:	e0bff917 	ldw	r2,-28(fp)
	}
 20113dc:	e037883a 	mov	sp,fp
 20113e0:	dfc00117 	ldw	ra,4(sp)
 20113e4:	df000017 	ldw	fp,0(sp)
 20113e8:	dec00204 	addi	sp,sp,8
 20113ec:	f800283a 	ret

020113f0 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 20113f0:	defff604 	addi	sp,sp,-40
 20113f4:	dfc00915 	stw	ra,36(sp)
 20113f8:	df000815 	stw	fp,32(sp)
 20113fc:	df000804 	addi	fp,sp,32
 2011400:	e13ffc15 	stw	r4,-16(fp)
 2011404:	e17ffd15 	stw	r5,-12(fp)
 2011408:	e1bffe15 	stw	r6,-8(fp)
 201140c:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 2011410:	00800044 	movi	r2,1
 2011414:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 2011418:	e0bffc17 	ldw	r2,-16(fp)
 201141c:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 2011420:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 2011424:	e0bfff17 	ldw	r2,-4(fp)
 2011428:	10000426 	beq	r2,zero,201143c <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 201142c:	e0bff917 	ldw	r2,-28(fp)
 2011430:	10c01c17 	ldw	r3,112(r2)
 2011434:	e0bfff17 	ldw	r2,-4(fp)
 2011438:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 201143c:	e0bff917 	ldw	r2,-28(fp)
 2011440:	10801d03 	ldbu	r2,116(r2)
 2011444:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2011448:	e0bff917 	ldw	r2,-28(fp)
 201144c:	00c00084 	movi	r3,2
 2011450:	10c01d05 	stb	r3,116(r2)

			switch( eAction )
 2011454:	e0bffe17 	ldw	r2,-8(fp)
 2011458:	10800168 	cmpgeui	r2,r2,5
 201145c:	1000261e 	bne	r2,zero,20114f8 <xTaskGenericNotifyFromISR+0x108>
 2011460:	e0bffe17 	ldw	r2,-8(fp)
 2011464:	100690ba 	slli	r3,r2,2
 2011468:	00808074 	movhi	r2,513
 201146c:	10851f04 	addi	r2,r2,5244
 2011470:	1885883a 	add	r2,r3,r2
 2011474:	10800017 	ldw	r2,0(r2)
 2011478:	1000683a 	jmp	r2
 201147c:	02011500 	call	201150 <alt_exception_muldiv+0x201150>
 2011480:	02011490 	cmplti	r8,zero,1106
 2011484:	020114ac 	andhi	r8,zero,1106
 2011488:	020114c4 	movi	r8,1107
 201148c:	020114d4 	movui	r8,1107
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 2011490:	e0bff917 	ldw	r2,-28(fp)
 2011494:	10c01c17 	ldw	r3,112(r2)
 2011498:	e0bffd17 	ldw	r2,-12(fp)
 201149c:	1886b03a 	or	r3,r3,r2
 20114a0:	e0bff917 	ldw	r2,-28(fp)
 20114a4:	10c01c15 	stw	r3,112(r2)
					break;
 20114a8:	00001606 	br	2011504 <xTaskGenericNotifyFromISR+0x114>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 20114ac:	e0bff917 	ldw	r2,-28(fp)
 20114b0:	10801c17 	ldw	r2,112(r2)
 20114b4:	10c00044 	addi	r3,r2,1
 20114b8:	e0bff917 	ldw	r2,-28(fp)
 20114bc:	10c01c15 	stw	r3,112(r2)
					break;
 20114c0:	00001006 	br	2011504 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 20114c4:	e0bff917 	ldw	r2,-28(fp)
 20114c8:	e0fffd17 	ldw	r3,-12(fp)
 20114cc:	10c01c15 	stw	r3,112(r2)
					break;
 20114d0:	00000c06 	br	2011504 <xTaskGenericNotifyFromISR+0x114>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 20114d4:	e0bffb03 	ldbu	r2,-20(fp)
 20114d8:	108000a0 	cmpeqi	r2,r2,2
 20114dc:	1000041e 	bne	r2,zero,20114f0 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 20114e0:	e0bff917 	ldw	r2,-28(fp)
 20114e4:	e0fffd17 	ldw	r3,-12(fp)
 20114e8:	10c01c15 	stw	r3,112(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 20114ec:	00000506 	br	2011504 <xTaskGenericNotifyFromISR+0x114>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 20114f0:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 20114f4:	00000306 	br	2011504 <xTaskGenericNotifyFromISR+0x114>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
 20114f8:	0001883a 	nop
 20114fc:	00000106 	br	2011504 <xTaskGenericNotifyFromISR+0x114>
					break;

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 2011500:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2011504:	e0bffb03 	ldbu	r2,-20(fp)
 2011508:	10800058 	cmpnei	r2,r2,1
 201150c:	10002b1e 	bne	r2,zero,20115bc <xTaskGenericNotifyFromISR+0x1cc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2011510:	d0a7e117 	ldw	r2,-24700(gp)
 2011514:	1000171e 	bne	r2,zero,2011574 <xTaskGenericNotifyFromISR+0x184>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2011518:	e0bff917 	ldw	r2,-28(fp)
 201151c:	10800104 	addi	r2,r2,4
 2011520:	1009883a 	mov	r4,r2
 2011524:	202bec40 	call	202bec4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2011528:	e0bff917 	ldw	r2,-28(fp)
 201152c:	10800b17 	ldw	r2,44(r2)
 2011530:	d0e7d917 	ldw	r3,-24732(gp)
 2011534:	1880032e 	bgeu	r3,r2,2011544 <xTaskGenericNotifyFromISR+0x154>
 2011538:	e0bff917 	ldw	r2,-28(fp)
 201153c:	10800b17 	ldw	r2,44(r2)
 2011540:	d0a7d915 	stw	r2,-24732(gp)
 2011544:	e0bff917 	ldw	r2,-28(fp)
 2011548:	10800b17 	ldw	r2,44(r2)
 201154c:	10c00524 	muli	r3,r2,20
 2011550:	00808134 	movhi	r2,516
 2011554:	109e6704 	addi	r2,r2,31132
 2011558:	1887883a 	add	r3,r3,r2
 201155c:	e0bff917 	ldw	r2,-28(fp)
 2011560:	10800104 	addi	r2,r2,4
 2011564:	100b883a 	mov	r5,r2
 2011568:	1809883a 	mov	r4,r3
 201156c:	202bd600 	call	202bd60 <vListInsertEnd>
 2011570:	00000606 	br	201158c <xTaskGenericNotifyFromISR+0x19c>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 2011574:	e0bff917 	ldw	r2,-28(fp)
 2011578:	10800604 	addi	r2,r2,24
 201157c:	100b883a 	mov	r5,r2
 2011580:	01008134 	movhi	r4,516
 2011584:	211e8a04 	addi	r4,r4,31272
 2011588:	202bd600 	call	202bd60 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 201158c:	e0bff917 	ldw	r2,-28(fp)
 2011590:	10800b17 	ldw	r2,44(r2)
 2011594:	d0e7d317 	ldw	r3,-24756(gp)
 2011598:	18c00b17 	ldw	r3,44(r3)
 201159c:	1880072e 	bgeu	r3,r2,20115bc <xTaskGenericNotifyFromISR+0x1cc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 20115a0:	e0800217 	ldw	r2,8(fp)
 20115a4:	10000326 	beq	r2,zero,20115b4 <xTaskGenericNotifyFromISR+0x1c4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 20115a8:	e0800217 	ldw	r2,8(fp)
 20115ac:	00c00044 	movi	r3,1
 20115b0:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 20115b4:	00800044 	movi	r2,1
 20115b8:	d0a7dc15 	stw	r2,-24720(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 20115bc:	e0bff817 	ldw	r2,-32(fp)
	}
 20115c0:	e037883a 	mov	sp,fp
 20115c4:	dfc00117 	ldw	ra,4(sp)
 20115c8:	df000017 	ldw	fp,0(sp)
 20115cc:	dec00204 	addi	sp,sp,8
 20115d0:	f800283a 	ret

020115d4 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 20115d4:	defff904 	addi	sp,sp,-28
 20115d8:	dfc00615 	stw	ra,24(sp)
 20115dc:	df000515 	stw	fp,20(sp)
 20115e0:	df000504 	addi	fp,sp,20
 20115e4:	e13ffe15 	stw	r4,-8(fp)
 20115e8:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
 20115ec:	e0bffe17 	ldw	r2,-8(fp)
 20115f0:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 20115f4:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 20115f8:	e0bffb17 	ldw	r2,-20(fp)
 20115fc:	10801d03 	ldbu	r2,116(r2)
 2011600:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 2011604:	e0bffb17 	ldw	r2,-20(fp)
 2011608:	00c00084 	movi	r3,2
 201160c:	10c01d05 	stb	r3,116(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 2011610:	e0bffb17 	ldw	r2,-20(fp)
 2011614:	10801c17 	ldw	r2,112(r2)
 2011618:	10c00044 	addi	r3,r2,1
 201161c:	e0bffb17 	ldw	r2,-20(fp)
 2011620:	10c01c15 	stw	r3,112(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 2011624:	e0bffd03 	ldbu	r2,-12(fp)
 2011628:	10800058 	cmpnei	r2,r2,1
 201162c:	10002b1e 	bne	r2,zero,20116dc <vTaskNotifyGiveFromISR+0x108>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 2011630:	d0a7e117 	ldw	r2,-24700(gp)
 2011634:	1000171e 	bne	r2,zero,2011694 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 2011638:	e0bffb17 	ldw	r2,-20(fp)
 201163c:	10800104 	addi	r2,r2,4
 2011640:	1009883a 	mov	r4,r2
 2011644:	202bec40 	call	202bec4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 2011648:	e0bffb17 	ldw	r2,-20(fp)
 201164c:	10800b17 	ldw	r2,44(r2)
 2011650:	d0e7d917 	ldw	r3,-24732(gp)
 2011654:	1880032e 	bgeu	r3,r2,2011664 <vTaskNotifyGiveFromISR+0x90>
 2011658:	e0bffb17 	ldw	r2,-20(fp)
 201165c:	10800b17 	ldw	r2,44(r2)
 2011660:	d0a7d915 	stw	r2,-24732(gp)
 2011664:	e0bffb17 	ldw	r2,-20(fp)
 2011668:	10800b17 	ldw	r2,44(r2)
 201166c:	10c00524 	muli	r3,r2,20
 2011670:	00808134 	movhi	r2,516
 2011674:	109e6704 	addi	r2,r2,31132
 2011678:	1887883a 	add	r3,r3,r2
 201167c:	e0bffb17 	ldw	r2,-20(fp)
 2011680:	10800104 	addi	r2,r2,4
 2011684:	100b883a 	mov	r5,r2
 2011688:	1809883a 	mov	r4,r3
 201168c:	202bd600 	call	202bd60 <vListInsertEnd>
 2011690:	00000606 	br	20116ac <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 2011694:	e0bffb17 	ldw	r2,-20(fp)
 2011698:	10800604 	addi	r2,r2,24
 201169c:	100b883a 	mov	r5,r2
 20116a0:	01008134 	movhi	r4,516
 20116a4:	211e8a04 	addi	r4,r4,31272
 20116a8:	202bd600 	call	202bd60 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 20116ac:	e0bffb17 	ldw	r2,-20(fp)
 20116b0:	10800b17 	ldw	r2,44(r2)
 20116b4:	d0e7d317 	ldw	r3,-24756(gp)
 20116b8:	18c00b17 	ldw	r3,44(r3)
 20116bc:	1880072e 	bgeu	r3,r2,20116dc <vTaskNotifyGiveFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 20116c0:	e0bfff17 	ldw	r2,-4(fp)
 20116c4:	10000326 	beq	r2,zero,20116d4 <vTaskNotifyGiveFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 20116c8:	e0bfff17 	ldw	r2,-4(fp)
 20116cc:	00c00044 	movi	r3,1
 20116d0:	10c00015 	stw	r3,0(r2)
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
 20116d4:	00800044 	movi	r2,1
 20116d8:	d0a7dc15 	stw	r2,-24720(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 20116dc:	0001883a 	nop
 20116e0:	e037883a 	mov	sp,fp
 20116e4:	dfc00117 	ldw	ra,4(sp)
 20116e8:	df000017 	ldw	fp,0(sp)
 20116ec:	dec00204 	addi	sp,sp,8
 20116f0:	f800283a 	ret

020116f4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 20116f4:	defffb04 	addi	sp,sp,-20
 20116f8:	dfc00415 	stw	ra,16(sp)
 20116fc:	df000315 	stw	fp,12(sp)
 2011700:	df000304 	addi	fp,sp,12
 2011704:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 2011708:	e0bfff17 	ldw	r2,-4(fp)
 201170c:	1000021e 	bne	r2,zero,2011718 <xTaskNotifyStateClear+0x24>
 2011710:	d0a7d317 	ldw	r2,-24756(gp)
 2011714:	00000106 	br	201171c <xTaskNotifyStateClear+0x28>
 2011718:	e0bfff17 	ldw	r2,-4(fp)
 201171c:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 2011720:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011724:	10000126 	beq	r2,zero,201172c <xTaskNotifyStateClear+0x38>
 2011728:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 201172c:	e0bffe17 	ldw	r2,-8(fp)
 2011730:	10801d03 	ldbu	r2,116(r2)
 2011734:	10803fcc 	andi	r2,r2,255
 2011738:	10800098 	cmpnei	r2,r2,2
 201173c:	1000051e 	bne	r2,zero,2011754 <xTaskNotifyStateClear+0x60>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 2011740:	e0bffe17 	ldw	r2,-8(fp)
 2011744:	10001d05 	stb	zero,116(r2)
				xReturn = pdPASS;
 2011748:	00800044 	movi	r2,1
 201174c:	e0bffd15 	stw	r2,-12(fp)
 2011750:	00000106 	br	2011758 <xTaskNotifyStateClear+0x64>
			}
			else
			{
				xReturn = pdFAIL;
 2011754:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 2011758:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201175c:	10000126 	beq	r2,zero,2011764 <xTaskNotifyStateClear+0x70>
 2011760:	2010f780 	call	2010f78 <vTaskExitCritical>

		return xReturn;
 2011764:	e0bffd17 	ldw	r2,-12(fp)
	}
 2011768:	e037883a 	mov	sp,fp
 201176c:	dfc00117 	ldw	ra,4(sp)
 2011770:	df000017 	ldw	fp,0(sp)
 2011774:	dec00204 	addi	sp,sp,8
 2011778:	f800283a 	ret

0201177c <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
 201177c:	defffa04 	addi	sp,sp,-24
 2011780:	dfc00515 	stw	ra,20(sp)
 2011784:	df000415 	stw	fp,16(sp)
 2011788:	df000404 	addi	fp,sp,16
 201178c:	e13ffe15 	stw	r4,-8(fp)
 2011790:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 2011794:	e0bffe17 	ldw	r2,-8(fp)
 2011798:	1000021e 	bne	r2,zero,20117a4 <ulTaskNotifyValueClear+0x28>
 201179c:	d0a7d317 	ldw	r2,-24756(gp)
 20117a0:	00000106 	br	20117a8 <ulTaskNotifyValueClear+0x2c>
 20117a4:	e0bffe17 	ldw	r2,-8(fp)
 20117a8:	e0bffc15 	stw	r2,-16(fp)

		taskENTER_CRITICAL();
 20117ac:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20117b0:	10000126 	beq	r2,zero,20117b8 <ulTaskNotifyValueClear+0x3c>
 20117b4:	2010f300 	call	2010f30 <vTaskEnterCritical>
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 20117b8:	d0a7d317 	ldw	r2,-24756(gp)
 20117bc:	10801c17 	ldw	r2,112(r2)
 20117c0:	e0bffd15 	stw	r2,-12(fp)
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
 20117c4:	e0bffc17 	ldw	r2,-16(fp)
 20117c8:	10c01c17 	ldw	r3,112(r2)
 20117cc:	e0bfff17 	ldw	r2,-4(fp)
 20117d0:	0084303a 	nor	r2,zero,r2
 20117d4:	1886703a 	and	r3,r3,r2
 20117d8:	e0bffc17 	ldw	r2,-16(fp)
 20117dc:	10c01c15 	stw	r3,112(r2)
		}
		taskEXIT_CRITICAL();
 20117e0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20117e4:	10000126 	beq	r2,zero,20117ec <ulTaskNotifyValueClear+0x70>
 20117e8:	2010f780 	call	2010f78 <vTaskExitCritical>

		return ulReturn;
 20117ec:	e0bffd17 	ldw	r2,-12(fp)
	}
 20117f0:	e037883a 	mov	sp,fp
 20117f4:	dfc00117 	ldw	ra,4(sp)
 20117f8:	df000017 	ldw	fp,0(sp)
 20117fc:	dec00204 	addi	sp,sp,8
 2011800:	f800283a 	ret

02011804 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 2011804:	defffa04 	addi	sp,sp,-24
 2011808:	dfc00515 	stw	ra,20(sp)
 201180c:	df000415 	stw	fp,16(sp)
 2011810:	df000404 	addi	fp,sp,16
 2011814:	e13ffe15 	stw	r4,-8(fp)
 2011818:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 201181c:	d0a7d817 	ldw	r2,-24736(gp)
 2011820:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 2011824:	d0a7d317 	ldw	r2,-24756(gp)
 2011828:	10800104 	addi	r2,r2,4
 201182c:	1009883a 	mov	r4,r2
 2011830:	202bec40 	call	202bec4 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 2011834:	e0bffe17 	ldw	r2,-8(fp)
 2011838:	10bfffd8 	cmpnei	r2,r2,-1
 201183c:	1000091e 	bne	r2,zero,2011864 <prvAddCurrentTaskToDelayedList+0x60>
 2011840:	e0bfff17 	ldw	r2,-4(fp)
 2011844:	10000726 	beq	r2,zero,2011864 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 2011848:	d0a7d317 	ldw	r2,-24756(gp)
 201184c:	10800104 	addi	r2,r2,4
 2011850:	100b883a 	mov	r5,r2
 2011854:	01008134 	movhi	r4,516
 2011858:	211e9404 	addi	r4,r4,31312
 201185c:	202bd600 	call	202bd60 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 2011860:	00001c06 	br	20118d4 <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 2011864:	e0fffc17 	ldw	r3,-16(fp)
 2011868:	e0bffe17 	ldw	r2,-8(fp)
 201186c:	1885883a 	add	r2,r3,r2
 2011870:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 2011874:	d0a7d317 	ldw	r2,-24756(gp)
 2011878:	e0fffd17 	ldw	r3,-12(fp)
 201187c:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 2011880:	e0fffd17 	ldw	r3,-12(fp)
 2011884:	e0bffc17 	ldw	r2,-16(fp)
 2011888:	1880072e 	bgeu	r3,r2,20118a8 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 201188c:	d0e7d517 	ldw	r3,-24748(gp)
 2011890:	d0a7d317 	ldw	r2,-24756(gp)
 2011894:	10800104 	addi	r2,r2,4
 2011898:	100b883a 	mov	r5,r2
 201189c:	1809883a 	mov	r4,r3
 20118a0:	202bdec0 	call	202bdec <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 20118a4:	00000b06 	br	20118d4 <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 20118a8:	d0e7d417 	ldw	r3,-24752(gp)
 20118ac:	d0a7d317 	ldw	r2,-24756(gp)
 20118b0:	10800104 	addi	r2,r2,4
 20118b4:	100b883a 	mov	r5,r2
 20118b8:	1809883a 	mov	r4,r3
 20118bc:	202bdec0 	call	202bdec <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 20118c0:	d0a7df17 	ldw	r2,-24708(gp)
 20118c4:	e0fffd17 	ldw	r3,-12(fp)
 20118c8:	1880022e 	bgeu	r3,r2,20118d4 <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 20118cc:	e0bffd17 	ldw	r2,-12(fp)
 20118d0:	d0a7df15 	stw	r2,-24708(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 20118d4:	0001883a 	nop
 20118d8:	e037883a 	mov	sp,fp
 20118dc:	dfc00117 	ldw	ra,4(sp)
 20118e0:	df000017 	ldw	fp,0(sp)
 20118e4:	dec00204 	addi	sp,sp,8
 20118e8:	f800283a 	ret

020118ec <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 20118ec:	defffb04 	addi	sp,sp,-20
 20118f0:	dfc00415 	stw	ra,16(sp)
 20118f4:	df000315 	stw	fp,12(sp)
 20118f8:	df000304 	addi	fp,sp,12
BaseType_t xReturn = pdFAIL;
 20118fc:	e03fff15 	stw	zero,-4(fp)

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 2011900:	20123b40 	call	20123b4 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 2011904:	d0a7e417 	ldw	r2,-24688(gp)
 2011908:	10000c26 	beq	r2,zero,201193c <xTimerCreateTimerTask+0x50>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
 201190c:	d0a7e504 	addi	r2,gp,-24684
 2011910:	d8800115 	stw	r2,4(sp)
 2011914:	00800144 	movi	r2,5
 2011918:	d8800015 	stw	r2,0(sp)
 201191c:	000f883a 	mov	r7,zero
 2011920:	01820004 	movi	r6,2048
 2011924:	01408134 	movhi	r5,516
 2011928:	29447c04 	addi	r5,r5,4592
 201192c:	01008074 	movhi	r4,513
 2011930:	21077704 	addi	r4,r4,7644
 2011934:	200eca00 	call	200eca0 <xTaskCreate>
 2011938:	e0bfff15 	stw	r2,-4(fp)
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
 201193c:	e0bfff17 	ldw	r2,-4(fp)
}
 2011940:	e037883a 	mov	sp,fp
 2011944:	dfc00117 	ldw	ra,4(sp)
 2011948:	df000017 	ldw	fp,0(sp)
 201194c:	dec00204 	addi	sp,sp,8
 2011950:	f800283a 	ret

02011954 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
 2011954:	defff704 	addi	sp,sp,-36
 2011958:	dfc00815 	stw	ra,32(sp)
 201195c:	df000715 	stw	fp,28(sp)
 2011960:	df000704 	addi	fp,sp,28
 2011964:	e13ffc15 	stw	r4,-16(fp)
 2011968:	e17ffd15 	stw	r5,-12(fp)
 201196c:	e1bffe15 	stw	r6,-8(fp)
 2011970:	e1ffff15 	stw	r7,-4(fp)
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 2011974:	01000b04 	movi	r4,44
 2011978:	202bb8c0 	call	202bb8c <pvPortMalloc>
 201197c:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewTimer != NULL )
 2011980:	e0bffb17 	ldw	r2,-20(fp)
 2011984:	10000b26 	beq	r2,zero,20119b4 <xTimerCreate+0x60>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The auto-reload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
 2011988:	e0bffb17 	ldw	r2,-20(fp)
 201198c:	10000a05 	stb	zero,40(r2)
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 2011990:	e0bffb17 	ldw	r2,-20(fp)
 2011994:	d8800115 	stw	r2,4(sp)
 2011998:	e0800217 	ldw	r2,8(fp)
 201199c:	d8800015 	stw	r2,0(sp)
 20119a0:	e1ffff17 	ldw	r7,-4(fp)
 20119a4:	e1bffe17 	ldw	r6,-8(fp)
 20119a8:	e17ffd17 	ldw	r5,-12(fp)
 20119ac:	e13ffc17 	ldw	r4,-16(fp)
 20119b0:	20119cc0 	call	20119cc <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 20119b4:	e0bffb17 	ldw	r2,-20(fp)
	}
 20119b8:	e037883a 	mov	sp,fp
 20119bc:	dfc00117 	ldw	ra,4(sp)
 20119c0:	df000017 	ldw	fp,0(sp)
 20119c4:	dec00204 	addi	sp,sp,8
 20119c8:	f800283a 	ret

020119cc <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
 20119cc:	defffa04 	addi	sp,sp,-24
 20119d0:	dfc00515 	stw	ra,20(sp)
 20119d4:	df000415 	stw	fp,16(sp)
 20119d8:	df000404 	addi	fp,sp,16
 20119dc:	e13ffc15 	stw	r4,-16(fp)
 20119e0:	e17ffd15 	stw	r5,-12(fp)
 20119e4:	e1bffe15 	stw	r6,-8(fp)
 20119e8:	e1ffff15 	stw	r7,-4(fp)
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
 20119ec:	e0800317 	ldw	r2,12(fp)
 20119f0:	10001926 	beq	r2,zero,2011a58 <prvInitialiseNewTimer+0x8c>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
 20119f4:	20123b40 	call	20123b4 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
 20119f8:	e0800317 	ldw	r2,12(fp)
 20119fc:	e0fffc17 	ldw	r3,-16(fp)
 2011a00:	10c00015 	stw	r3,0(r2)
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 2011a04:	e0800317 	ldw	r2,12(fp)
 2011a08:	e0fffd17 	ldw	r3,-12(fp)
 2011a0c:	10c00615 	stw	r3,24(r2)
		pxNewTimer->pvTimerID = pvTimerID;
 2011a10:	e0800317 	ldw	r2,12(fp)
 2011a14:	e0ffff17 	ldw	r3,-4(fp)
 2011a18:	10c00715 	stw	r3,28(r2)
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 2011a1c:	e0800317 	ldw	r2,12(fp)
 2011a20:	e0c00217 	ldw	r3,8(fp)
 2011a24:	10c00815 	stw	r3,32(r2)
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 2011a28:	e0800317 	ldw	r2,12(fp)
 2011a2c:	10800104 	addi	r2,r2,4
 2011a30:	1009883a 	mov	r4,r2
 2011a34:	202bd340 	call	202bd34 <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 2011a38:	e0bffe17 	ldw	r2,-8(fp)
 2011a3c:	10000626 	beq	r2,zero,2011a58 <prvInitialiseNewTimer+0x8c>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 2011a40:	e0800317 	ldw	r2,12(fp)
 2011a44:	10800a03 	ldbu	r2,40(r2)
 2011a48:	10800114 	ori	r2,r2,4
 2011a4c:	1007883a 	mov	r3,r2
 2011a50:	e0800317 	ldw	r2,12(fp)
 2011a54:	10c00a05 	stb	r3,40(r2)
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
 2011a58:	0001883a 	nop
 2011a5c:	e037883a 	mov	sp,fp
 2011a60:	dfc00117 	ldw	ra,4(sp)
 2011a64:	df000017 	ldw	fp,0(sp)
 2011a68:	dec00204 	addi	sp,sp,8
 2011a6c:	f800283a 	ret

02011a70 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 2011a70:	defff604 	addi	sp,sp,-40
 2011a74:	dfc00915 	stw	ra,36(sp)
 2011a78:	df000815 	stw	fp,32(sp)
 2011a7c:	df000804 	addi	fp,sp,32
 2011a80:	e13ffc15 	stw	r4,-16(fp)
 2011a84:	e17ffd15 	stw	r5,-12(fp)
 2011a88:	e1bffe15 	stw	r6,-8(fp)
 2011a8c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn = pdFAIL;
 2011a90:	e03ff815 	stw	zero,-32(fp)

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 2011a94:	d0a7e417 	ldw	r2,-24688(gp)
 2011a98:	10002626 	beq	r2,zero,2011b34 <xTimerGenericCommand+0xc4>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 2011a9c:	e0bffd17 	ldw	r2,-12(fp)
 2011aa0:	e0bff915 	stw	r2,-28(fp)
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 2011aa4:	e0bffe17 	ldw	r2,-8(fp)
 2011aa8:	e0bffa15 	stw	r2,-24(fp)
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 2011aac:	e0bffc17 	ldw	r2,-16(fp)
 2011ab0:	e0bffb15 	stw	r2,-20(fp)

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 2011ab4:	e0bffd17 	ldw	r2,-12(fp)
 2011ab8:	10800188 	cmpgei	r2,r2,6
 2011abc:	1000151e 	bne	r2,zero,2011b14 <xTimerGenericCommand+0xa4>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 2011ac0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011ac4:	10800098 	cmpnei	r2,r2,2
 2011ac8:	1000091e 	bne	r2,zero,2011af0 <xTimerGenericCommand+0x80>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 2011acc:	d0a7e417 	ldw	r2,-24688(gp)
 2011ad0:	e0fff904 	addi	r3,fp,-28
 2011ad4:	000f883a 	mov	r7,zero
 2011ad8:	e1800217 	ldw	r6,8(fp)
 2011adc:	180b883a 	mov	r5,r3
 2011ae0:	1009883a 	mov	r4,r2
 2011ae4:	200da140 	call	200da14 <xQueueGenericSend>
 2011ae8:	e0bff815 	stw	r2,-32(fp)
 2011aec:	00001106 	br	2011b34 <xTimerGenericCommand+0xc4>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 2011af0:	d0a7e417 	ldw	r2,-24688(gp)
 2011af4:	e0fff904 	addi	r3,fp,-28
 2011af8:	000f883a 	mov	r7,zero
 2011afc:	000d883a 	mov	r6,zero
 2011b00:	180b883a 	mov	r5,r3
 2011b04:	1009883a 	mov	r4,r2
 2011b08:	200da140 	call	200da14 <xQueueGenericSend>
 2011b0c:	e0bff815 	stw	r2,-32(fp)
 2011b10:	00000806 	br	2011b34 <xTimerGenericCommand+0xc4>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 2011b14:	d0a7e417 	ldw	r2,-24688(gp)
 2011b18:	e0fff904 	addi	r3,fp,-28
 2011b1c:	000f883a 	mov	r7,zero
 2011b20:	e1bfff17 	ldw	r6,-4(fp)
 2011b24:	180b883a 	mov	r5,r3
 2011b28:	1009883a 	mov	r4,r2
 2011b2c:	200dbf80 	call	200dbf8 <xQueueGenericSendFromISR>
 2011b30:	e0bff815 	stw	r2,-32(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 2011b34:	e0bff817 	ldw	r2,-32(fp)
}
 2011b38:	e037883a 	mov	sp,fp
 2011b3c:	dfc00117 	ldw	ra,4(sp)
 2011b40:	df000017 	ldw	fp,0(sp)
 2011b44:	dec00204 	addi	sp,sp,8
 2011b48:	f800283a 	ret

02011b4c <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
{
 2011b4c:	deffff04 	addi	sp,sp,-4
 2011b50:	df000015 	stw	fp,0(sp)
 2011b54:	d839883a 	mov	fp,sp
	/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
	started, then xTimerTaskHandle will be NULL. */
	configASSERT( ( xTimerTaskHandle != NULL ) );
	return xTimerTaskHandle;
 2011b58:	d0a7e517 	ldw	r2,-24684(gp)
}
 2011b5c:	e037883a 	mov	sp,fp
 2011b60:	df000017 	ldw	fp,0(sp)
 2011b64:	dec00104 	addi	sp,sp,4
 2011b68:	f800283a 	ret

02011b6c <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
{
 2011b6c:	defffd04 	addi	sp,sp,-12
 2011b70:	df000215 	stw	fp,8(sp)
 2011b74:	df000204 	addi	fp,sp,8
 2011b78:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 2011b7c:	e0bfff17 	ldw	r2,-4(fp)
 2011b80:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->xTimerPeriodInTicks;
 2011b84:	e0bffe17 	ldw	r2,-8(fp)
 2011b88:	10800617 	ldw	r2,24(r2)
}
 2011b8c:	e037883a 	mov	sp,fp
 2011b90:	df000017 	ldw	fp,0(sp)
 2011b94:	dec00104 	addi	sp,sp,4
 2011b98:	f800283a 	ret

02011b9c <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

void vTimerSetReloadMode( TimerHandle_t xTimer, const UBaseType_t uxAutoReload )
{
 2011b9c:	defffb04 	addi	sp,sp,-20
 2011ba0:	dfc00415 	stw	ra,16(sp)
 2011ba4:	df000315 	stw	fp,12(sp)
 2011ba8:	df000304 	addi	fp,sp,12
 2011bac:	e13ffe15 	stw	r4,-8(fp)
 2011bb0:	e17fff15 	stw	r5,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011bb4:	e0bffe17 	ldw	r2,-8(fp)
 2011bb8:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 2011bbc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011bc0:	10000126 	beq	r2,zero,2011bc8 <vTimerSetReloadMode+0x2c>
 2011bc4:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( uxAutoReload != pdFALSE )
 2011bc8:	e0bfff17 	ldw	r2,-4(fp)
 2011bcc:	10000726 	beq	r2,zero,2011bec <vTimerSetReloadMode+0x50>
		{
			pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 2011bd0:	e0bffd17 	ldw	r2,-12(fp)
 2011bd4:	10800a03 	ldbu	r2,40(r2)
 2011bd8:	10800114 	ori	r2,r2,4
 2011bdc:	1007883a 	mov	r3,r2
 2011be0:	e0bffd17 	ldw	r2,-12(fp)
 2011be4:	10c00a05 	stb	r3,40(r2)
 2011be8:	00000706 	br	2011c08 <vTimerSetReloadMode+0x6c>
		}
		else
		{
			pxTimer->ucStatus &= ~tmrSTATUS_IS_AUTORELOAD;
 2011bec:	e0bffd17 	ldw	r2,-12(fp)
 2011bf0:	10c00a03 	ldbu	r3,40(r2)
 2011bf4:	00bffec4 	movi	r2,-5
 2011bf8:	1884703a 	and	r2,r3,r2
 2011bfc:	1007883a 	mov	r3,r2
 2011c00:	e0bffd17 	ldw	r2,-12(fp)
 2011c04:	10c00a05 	stb	r3,40(r2)
		}
	}
	taskEXIT_CRITICAL();
 2011c08:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011c0c:	10000126 	beq	r2,zero,2011c14 <vTimerSetReloadMode+0x78>
 2011c10:	2010f780 	call	2010f78 <vTaskExitCritical>
}
 2011c14:	0001883a 	nop
 2011c18:	e037883a 	mov	sp,fp
 2011c1c:	dfc00117 	ldw	ra,4(sp)
 2011c20:	df000017 	ldw	fp,0(sp)
 2011c24:	dec00204 	addi	sp,sp,8
 2011c28:	f800283a 	ret

02011c2c <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
{
 2011c2c:	defffb04 	addi	sp,sp,-20
 2011c30:	dfc00415 	stw	ra,16(sp)
 2011c34:	df000315 	stw	fp,12(sp)
 2011c38:	df000304 	addi	fp,sp,12
 2011c3c:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011c40:	e0bfff17 	ldw	r2,-4(fp)
 2011c44:	e0bffe15 	stw	r2,-8(fp)
UBaseType_t uxReturn;

	configASSERT( xTimer );
	taskENTER_CRITICAL();
 2011c48:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011c4c:	10000126 	beq	r2,zero,2011c54 <uxTimerGetReloadMode+0x28>
 2011c50:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
 2011c54:	e0bffe17 	ldw	r2,-8(fp)
 2011c58:	10800a03 	ldbu	r2,40(r2)
 2011c5c:	10803fcc 	andi	r2,r2,255
 2011c60:	1080010c 	andi	r2,r2,4
 2011c64:	1000021e 	bne	r2,zero,2011c70 <uxTimerGetReloadMode+0x44>
		{
			/* Not an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdFALSE;
 2011c68:	e03ffd15 	stw	zero,-12(fp)
 2011c6c:	00000206 	br	2011c78 <uxTimerGetReloadMode+0x4c>
		}
		else
		{
			/* Is an auto-reload timer. */
			uxReturn = ( UBaseType_t ) pdTRUE;
 2011c70:	00800044 	movi	r2,1
 2011c74:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 2011c78:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2011c7c:	10000126 	beq	r2,zero,2011c84 <uxTimerGetReloadMode+0x58>
 2011c80:	2010f780 	call	2010f78 <vTaskExitCritical>

	return uxReturn;
 2011c84:	e0bffd17 	ldw	r2,-12(fp)
}
 2011c88:	e037883a 	mov	sp,fp
 2011c8c:	dfc00117 	ldw	ra,4(sp)
 2011c90:	df000017 	ldw	fp,0(sp)
 2011c94:	dec00204 	addi	sp,sp,8
 2011c98:	f800283a 	ret

02011c9c <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
{
 2011c9c:	defffc04 	addi	sp,sp,-16
 2011ca0:	df000315 	stw	fp,12(sp)
 2011ca4:	df000304 	addi	fp,sp,12
 2011ca8:	e13fff15 	stw	r4,-4(fp)
Timer_t * pxTimer =  xTimer;
 2011cac:	e0bfff17 	ldw	r2,-4(fp)
 2011cb0:	e0bffd15 	stw	r2,-12(fp)
TickType_t xReturn;

	configASSERT( xTimer );
	xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
 2011cb4:	e0bffd17 	ldw	r2,-12(fp)
 2011cb8:	10800117 	ldw	r2,4(r2)
 2011cbc:	e0bffe15 	stw	r2,-8(fp)
	return xReturn;
 2011cc0:	e0bffe17 	ldw	r2,-8(fp)
}
 2011cc4:	e037883a 	mov	sp,fp
 2011cc8:	df000017 	ldw	fp,0(sp)
 2011ccc:	dec00104 	addi	sp,sp,4
 2011cd0:	f800283a 	ret

02011cd4 <pcTimerGetName>:
/*-----------------------------------------------------------*/

const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 2011cd4:	defffd04 	addi	sp,sp,-12
 2011cd8:	df000215 	stw	fp,8(sp)
 2011cdc:	df000204 	addi	fp,sp,8
 2011ce0:	e13fff15 	stw	r4,-4(fp)
Timer_t *pxTimer = xTimer;
 2011ce4:	e0bfff17 	ldw	r2,-4(fp)
 2011ce8:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );
	return pxTimer->pcTimerName;
 2011cec:	e0bffe17 	ldw	r2,-8(fp)
 2011cf0:	10800017 	ldw	r2,0(r2)
}
 2011cf4:	e037883a 	mov	sp,fp
 2011cf8:	df000017 	ldw	fp,0(sp)
 2011cfc:	dec00104 	addi	sp,sp,4
 2011d00:	f800283a 	ret

02011d04 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 2011d04:	defff904 	addi	sp,sp,-28
 2011d08:	dfc00615 	stw	ra,24(sp)
 2011d0c:	df000515 	stw	fp,20(sp)
 2011d10:	df000504 	addi	fp,sp,20
 2011d14:	e13ffe15 	stw	r4,-8(fp)
 2011d18:	e17fff15 	stw	r5,-4(fp)
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 2011d1c:	d0a7e217 	ldw	r2,-24696(gp)
 2011d20:	10800317 	ldw	r2,12(r2)
 2011d24:	10800317 	ldw	r2,12(r2)
 2011d28:	e0bffc15 	stw	r2,-16(fp)

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 2011d2c:	e0bffc17 	ldw	r2,-16(fp)
 2011d30:	10800104 	addi	r2,r2,4
 2011d34:	1009883a 	mov	r4,r2
 2011d38:	202bec40 	call	202bec4 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 2011d3c:	e0bffc17 	ldw	r2,-16(fp)
 2011d40:	10800a03 	ldbu	r2,40(r2)
 2011d44:	10803fcc 	andi	r2,r2,255
 2011d48:	1080010c 	andi	r2,r2,4
 2011d4c:	10001226 	beq	r2,zero,2011d98 <prvProcessExpiredTimer+0x94>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 2011d50:	e0bffc17 	ldw	r2,-16(fp)
 2011d54:	10c00617 	ldw	r3,24(r2)
 2011d58:	e0bffe17 	ldw	r2,-8(fp)
 2011d5c:	1885883a 	add	r2,r3,r2
 2011d60:	e1fffe17 	ldw	r7,-8(fp)
 2011d64:	e1bfff17 	ldw	r6,-4(fp)
 2011d68:	100b883a 	mov	r5,r2
 2011d6c:	e13ffc17 	ldw	r4,-16(fp)
 2011d70:	2011fac0 	call	2011fac <prvInsertTimerInActiveList>
 2011d74:	10000f26 	beq	r2,zero,2011db4 <prvProcessExpiredTimer+0xb0>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 2011d78:	d8000015 	stw	zero,0(sp)
 2011d7c:	000f883a 	mov	r7,zero
 2011d80:	e1bffe17 	ldw	r6,-8(fp)
 2011d84:	000b883a 	mov	r5,zero
 2011d88:	e13ffc17 	ldw	r4,-16(fp)
 2011d8c:	2011a700 	call	2011a70 <xTimerGenericCommand>
 2011d90:	e0bffd15 	stw	r2,-12(fp)
 2011d94:	00000706 	br	2011db4 <prvProcessExpiredTimer+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 2011d98:	e0bffc17 	ldw	r2,-16(fp)
 2011d9c:	10c00a03 	ldbu	r3,40(r2)
 2011da0:	00bfff84 	movi	r2,-2
 2011da4:	1884703a 	and	r2,r3,r2
 2011da8:	1007883a 	mov	r3,r2
 2011dac:	e0bffc17 	ldw	r2,-16(fp)
 2011db0:	10c00a05 	stb	r3,40(r2)
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 2011db4:	e0bffc17 	ldw	r2,-16(fp)
 2011db8:	10800817 	ldw	r2,32(r2)
 2011dbc:	e13ffc17 	ldw	r4,-16(fp)
 2011dc0:	103ee83a 	callr	r2
}
 2011dc4:	0001883a 	nop
 2011dc8:	e037883a 	mov	sp,fp
 2011dcc:	dfc00117 	ldw	ra,4(sp)
 2011dd0:	df000017 	ldw	fp,0(sp)
 2011dd4:	dec00204 	addi	sp,sp,8
 2011dd8:	f800283a 	ret

02011ddc <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 2011ddc:	defffb04 	addi	sp,sp,-20
 2011de0:	dfc00415 	stw	ra,16(sp)
 2011de4:	df000315 	stw	fp,12(sp)
 2011de8:	df000304 	addi	fp,sp,12
 2011dec:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 2011df0:	e0bffe04 	addi	r2,fp,-8
 2011df4:	1009883a 	mov	r4,r2
 2011df8:	2011ee00 	call	2011ee0 <prvGetNextExpireTime>
 2011dfc:	e0bffd15 	stw	r2,-12(fp)

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 2011e00:	e0bffe17 	ldw	r2,-8(fp)
 2011e04:	100b883a 	mov	r5,r2
 2011e08:	e13ffd17 	ldw	r4,-12(fp)
 2011e0c:	2011e180 	call	2011e18 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 2011e10:	20120880 	call	2012088 <prvProcessReceivedCommands>
	}
 2011e14:	003ff606 	br	2011df0 <__alt_mem_mem_0+0xfcff1df0>

02011e18 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 2011e18:	defffa04 	addi	sp,sp,-24
 2011e1c:	dfc00515 	stw	ra,20(sp)
 2011e20:	df000415 	stw	fp,16(sp)
 2011e24:	df000404 	addi	fp,sp,16
 2011e28:	e13ffe15 	stw	r4,-8(fp)
 2011e2c:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 2011e30:	200fa500 	call	200fa50 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 2011e34:	e0bffd04 	addi	r2,fp,-12
 2011e38:	1009883a 	mov	r4,r2
 2011e3c:	2011f480 	call	2011f48 <prvSampleTimeNow>
 2011e40:	e0bffc15 	stw	r2,-16(fp)
		if( xTimerListsWereSwitched == pdFALSE )
 2011e44:	e0bffd17 	ldw	r2,-12(fp)
 2011e48:	10001e1e 	bne	r2,zero,2011ec4 <prvProcessTimerOrBlockTask+0xac>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 2011e4c:	e0bfff17 	ldw	r2,-4(fp)
 2011e50:	1000081e 	bne	r2,zero,2011e74 <prvProcessTimerOrBlockTask+0x5c>
 2011e54:	e0bffe17 	ldw	r2,-8(fp)
 2011e58:	e0fffc17 	ldw	r3,-16(fp)
 2011e5c:	18800536 	bltu	r3,r2,2011e74 <prvProcessTimerOrBlockTask+0x5c>
			{
				( void ) xTaskResumeAll();
 2011e60:	200fa7c0 	call	200fa7c <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 2011e64:	e17ffc17 	ldw	r5,-16(fp)
 2011e68:	e13ffe17 	ldw	r4,-8(fp)
 2011e6c:	2011d040 	call	2011d04 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 2011e70:	00001506 	br	2011ec8 <prvProcessTimerOrBlockTask+0xb0>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
 2011e74:	e0bfff17 	ldw	r2,-4(fp)
 2011e78:	10000726 	beq	r2,zero,2011e98 <prvProcessTimerOrBlockTask+0x80>
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 2011e7c:	d0a7e317 	ldw	r2,-24692(gp)
 2011e80:	10800017 	ldw	r2,0(r2)
 2011e84:	1000021e 	bne	r2,zero,2011e90 <prvProcessTimerOrBlockTask+0x78>
 2011e88:	00800044 	movi	r2,1
 2011e8c:	00000106 	br	2011e94 <prvProcessTimerOrBlockTask+0x7c>
 2011e90:	0005883a 	mov	r2,zero
 2011e94:	e0bfff15 	stw	r2,-4(fp)
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 2011e98:	d127e417 	ldw	r4,-24688(gp)
 2011e9c:	e0fffe17 	ldw	r3,-8(fp)
 2011ea0:	e0bffc17 	ldw	r2,-16(fp)
 2011ea4:	1885c83a 	sub	r2,r3,r2
 2011ea8:	e1bfff17 	ldw	r6,-4(fp)
 2011eac:	100b883a 	mov	r5,r2
 2011eb0:	200ebd80 	call	200ebd8 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 2011eb4:	200fa7c0 	call	200fa7c <xTaskResumeAll>
 2011eb8:	1000031e 	bne	r2,zero,2011ec8 <prvProcessTimerOrBlockTask+0xb0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
 2011ebc:	003b683a 	trap	0
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 2011ec0:	00000106 	br	2011ec8 <prvProcessTimerOrBlockTask+0xb0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 2011ec4:	200fa7c0 	call	200fa7c <xTaskResumeAll>
		}
	}
}
 2011ec8:	0001883a 	nop
 2011ecc:	e037883a 	mov	sp,fp
 2011ed0:	dfc00117 	ldw	ra,4(sp)
 2011ed4:	df000017 	ldw	fp,0(sp)
 2011ed8:	dec00204 	addi	sp,sp,8
 2011edc:	f800283a 	ret

02011ee0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 2011ee0:	defffd04 	addi	sp,sp,-12
 2011ee4:	df000215 	stw	fp,8(sp)
 2011ee8:	df000204 	addi	fp,sp,8
 2011eec:	e13fff15 	stw	r4,-4(fp)
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 2011ef0:	d0a7e217 	ldw	r2,-24696(gp)
 2011ef4:	10800017 	ldw	r2,0(r2)
 2011ef8:	1000021e 	bne	r2,zero,2011f04 <prvGetNextExpireTime+0x24>
 2011efc:	00800044 	movi	r2,1
 2011f00:	00000106 	br	2011f08 <prvGetNextExpireTime+0x28>
 2011f04:	0005883a 	mov	r2,zero
 2011f08:	e0ffff17 	ldw	r3,-4(fp)
 2011f0c:	18800015 	stw	r2,0(r3)
	if( *pxListWasEmpty == pdFALSE )
 2011f10:	e0bfff17 	ldw	r2,-4(fp)
 2011f14:	10800017 	ldw	r2,0(r2)
 2011f18:	1000051e 	bne	r2,zero,2011f30 <prvGetNextExpireTime+0x50>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 2011f1c:	d0a7e217 	ldw	r2,-24696(gp)
 2011f20:	10800317 	ldw	r2,12(r2)
 2011f24:	10800017 	ldw	r2,0(r2)
 2011f28:	e0bffe15 	stw	r2,-8(fp)
 2011f2c:	00000106 	br	2011f34 <prvGetNextExpireTime+0x54>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 2011f30:	e03ffe15 	stw	zero,-8(fp)
	}

	return xNextExpireTime;
 2011f34:	e0bffe17 	ldw	r2,-8(fp)
}
 2011f38:	e037883a 	mov	sp,fp
 2011f3c:	df000017 	ldw	fp,0(sp)
 2011f40:	dec00104 	addi	sp,sp,4
 2011f44:	f800283a 	ret

02011f48 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 2011f48:	defffc04 	addi	sp,sp,-16
 2011f4c:	dfc00315 	stw	ra,12(sp)
 2011f50:	df000215 	stw	fp,8(sp)
 2011f54:	df000204 	addi	fp,sp,8
 2011f58:	e13fff15 	stw	r4,-4(fp)
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 2011f5c:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2011f60:	e0bffe15 	stw	r2,-8(fp)

	if( xTimeNow < xLastTime )
 2011f64:	d0a7e617 	ldw	r2,-24680(gp)
 2011f68:	e0fffe17 	ldw	r3,-8(fp)
 2011f6c:	1880052e 	bgeu	r3,r2,2011f84 <prvSampleTimeNow+0x3c>
	{
		prvSwitchTimerLists();
 2011f70:	20122a00 	call	20122a0 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 2011f74:	e0bfff17 	ldw	r2,-4(fp)
 2011f78:	00c00044 	movi	r3,1
 2011f7c:	10c00015 	stw	r3,0(r2)
 2011f80:	00000206 	br	2011f8c <prvSampleTimeNow+0x44>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 2011f84:	e0bfff17 	ldw	r2,-4(fp)
 2011f88:	10000015 	stw	zero,0(r2)
	}

	xLastTime = xTimeNow;
 2011f8c:	e0bffe17 	ldw	r2,-8(fp)
 2011f90:	d0a7e615 	stw	r2,-24680(gp)

	return xTimeNow;
 2011f94:	e0bffe17 	ldw	r2,-8(fp)
}
 2011f98:	e037883a 	mov	sp,fp
 2011f9c:	dfc00117 	ldw	ra,4(sp)
 2011fa0:	df000017 	ldw	fp,0(sp)
 2011fa4:	dec00204 	addi	sp,sp,8
 2011fa8:	f800283a 	ret

02011fac <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 2011fac:	defff904 	addi	sp,sp,-28
 2011fb0:	dfc00615 	stw	ra,24(sp)
 2011fb4:	df000515 	stw	fp,20(sp)
 2011fb8:	df000504 	addi	fp,sp,20
 2011fbc:	e13ffc15 	stw	r4,-16(fp)
 2011fc0:	e17ffd15 	stw	r5,-12(fp)
 2011fc4:	e1bffe15 	stw	r6,-8(fp)
 2011fc8:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xProcessTimerNow = pdFALSE;
 2011fcc:	e03ffb15 	stw	zero,-20(fp)

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 2011fd0:	e0bffc17 	ldw	r2,-16(fp)
 2011fd4:	e0fffd17 	ldw	r3,-12(fp)
 2011fd8:	10c00115 	stw	r3,4(r2)
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 2011fdc:	e0bffc17 	ldw	r2,-16(fp)
 2011fe0:	e0fffc17 	ldw	r3,-16(fp)
 2011fe4:	10c00415 	stw	r3,16(r2)

	if( xNextExpiryTime <= xTimeNow )
 2011fe8:	e0bffd17 	ldw	r2,-12(fp)
 2011fec:	e0fffe17 	ldw	r3,-8(fp)
 2011ff0:	18801036 	bltu	r3,r2,2012034 <prvInsertTimerInActiveList+0x88>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 2011ff4:	e0fffe17 	ldw	r3,-8(fp)
 2011ff8:	e0bfff17 	ldw	r2,-4(fp)
 2011ffc:	1887c83a 	sub	r3,r3,r2
 2012000:	e0bffc17 	ldw	r2,-16(fp)
 2012004:	10800617 	ldw	r2,24(r2)
 2012008:	18800336 	bltu	r3,r2,2012018 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 201200c:	00800044 	movi	r2,1
 2012010:	e0bffb15 	stw	r2,-20(fp)
 2012014:	00001606 	br	2012070 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 2012018:	d0e7e317 	ldw	r3,-24692(gp)
 201201c:	e0bffc17 	ldw	r2,-16(fp)
 2012020:	10800104 	addi	r2,r2,4
 2012024:	100b883a 	mov	r5,r2
 2012028:	1809883a 	mov	r4,r3
 201202c:	202bdec0 	call	202bdec <vListInsert>
 2012030:	00000f06 	br	2012070 <prvInsertTimerInActiveList+0xc4>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 2012034:	e0fffe17 	ldw	r3,-8(fp)
 2012038:	e0bfff17 	ldw	r2,-4(fp)
 201203c:	1880062e 	bgeu	r3,r2,2012058 <prvInsertTimerInActiveList+0xac>
 2012040:	e0fffd17 	ldw	r3,-12(fp)
 2012044:	e0bfff17 	ldw	r2,-4(fp)
 2012048:	18800336 	bltu	r3,r2,2012058 <prvInsertTimerInActiveList+0xac>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 201204c:	00800044 	movi	r2,1
 2012050:	e0bffb15 	stw	r2,-20(fp)
 2012054:	00000606 	br	2012070 <prvInsertTimerInActiveList+0xc4>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 2012058:	d0e7e217 	ldw	r3,-24696(gp)
 201205c:	e0bffc17 	ldw	r2,-16(fp)
 2012060:	10800104 	addi	r2,r2,4
 2012064:	100b883a 	mov	r5,r2
 2012068:	1809883a 	mov	r4,r3
 201206c:	202bdec0 	call	202bdec <vListInsert>
		}
	}

	return xProcessTimerNow;
 2012070:	e0bffb17 	ldw	r2,-20(fp)
}
 2012074:	e037883a 	mov	sp,fp
 2012078:	dfc00117 	ldw	ra,4(sp)
 201207c:	df000017 	ldw	fp,0(sp)
 2012080:	dec00204 	addi	sp,sp,8
 2012084:	f800283a 	ret

02012088 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 2012088:	defff604 	addi	sp,sp,-40
 201208c:	dfc00915 	stw	ra,36(sp)
 2012090:	df000815 	stw	fp,32(sp)
 2012094:	df000804 	addi	fp,sp,32
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 2012098:	00007406 	br	201226c <prvProcessReceivedCommands+0x1e4>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 201209c:	e0bffc17 	ldw	r2,-16(fp)
 20120a0:	10007216 	blt	r2,zero,201226c <prvProcessReceivedCommands+0x1e4>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 20120a4:	e0bffe17 	ldw	r2,-8(fp)
 20120a8:	e0bff915 	stw	r2,-28(fp)

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 20120ac:	e0bff917 	ldw	r2,-28(fp)
 20120b0:	10800517 	ldw	r2,20(r2)
 20120b4:	10000426 	beq	r2,zero,20120c8 <prvProcessReceivedCommands+0x40>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 20120b8:	e0bff917 	ldw	r2,-28(fp)
 20120bc:	10800104 	addi	r2,r2,4
 20120c0:	1009883a 	mov	r4,r2
 20120c4:	202bec40 	call	202bec4 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 20120c8:	e0bfff04 	addi	r2,fp,-4
 20120cc:	1009883a 	mov	r4,r2
 20120d0:	2011f480 	call	2011f48 <prvSampleTimeNow>
 20120d4:	e0bffa15 	stw	r2,-24(fp)

			switch( xMessage.xMessageID )
 20120d8:	e0bffc17 	ldw	r2,-16(fp)
 20120dc:	10c002a8 	cmpgeui	r3,r2,10
 20120e0:	1800611e 	bne	r3,zero,2012268 <prvProcessReceivedCommands+0x1e0>
 20120e4:	100690ba 	slli	r3,r2,2
 20120e8:	00808074 	movhi	r2,513
 20120ec:	10883f04 	addi	r2,r2,8444
 20120f0:	1885883a 	add	r2,r3,r2
 20120f4:	10800017 	ldw	r2,0(r2)
 20120f8:	1000683a 	jmp	r2
 20120fc:	02012124 	muli	r8,zero,1156
 2012100:	02012124 	muli	r8,zero,1156
 2012104:	02012124 	muli	r8,zero,1156
 2012108:	020121bc 	xorhi	r8,zero,1158
 201210c:	020121dc 	xori	r8,zero,1159
 2012110:	02012228 	cmpgeui	r8,zero,1160
 2012114:	02012124 	muli	r8,zero,1156
 2012118:	02012124 	muli	r8,zero,1156
 201211c:	020121bc 	xorhi	r8,zero,1158
 2012120:	020121dc 	xori	r8,zero,1159
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 2012124:	e0bff917 	ldw	r2,-28(fp)
 2012128:	10800a03 	ldbu	r2,40(r2)
 201212c:	10800054 	ori	r2,r2,1
 2012130:	1007883a 	mov	r3,r2
 2012134:	e0bff917 	ldw	r2,-28(fp)
 2012138:	10c00a05 	stb	r3,40(r2)
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 201213c:	e0fffd17 	ldw	r3,-12(fp)
 2012140:	e0bff917 	ldw	r2,-28(fp)
 2012144:	10800617 	ldw	r2,24(r2)
 2012148:	1885883a 	add	r2,r3,r2
 201214c:	e0fffd17 	ldw	r3,-12(fp)
 2012150:	180f883a 	mov	r7,r3
 2012154:	e1bffa17 	ldw	r6,-24(fp)
 2012158:	100b883a 	mov	r5,r2
 201215c:	e13ff917 	ldw	r4,-28(fp)
 2012160:	2011fac0 	call	2011fac <prvInsertTimerInActiveList>
 2012164:	10004126 	beq	r2,zero,201226c <prvProcessReceivedCommands+0x1e4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 2012168:	e0bff917 	ldw	r2,-28(fp)
 201216c:	10800817 	ldw	r2,32(r2)
 2012170:	e13ff917 	ldw	r4,-28(fp)
 2012174:	103ee83a 	callr	r2
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 2012178:	e0bff917 	ldw	r2,-28(fp)
 201217c:	10800a03 	ldbu	r2,40(r2)
 2012180:	10803fcc 	andi	r2,r2,255
 2012184:	1080010c 	andi	r2,r2,4
 2012188:	10003826 	beq	r2,zero,201226c <prvProcessReceivedCommands+0x1e4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 201218c:	e0fffd17 	ldw	r3,-12(fp)
 2012190:	e0bff917 	ldw	r2,-28(fp)
 2012194:	10800617 	ldw	r2,24(r2)
 2012198:	1885883a 	add	r2,r3,r2
 201219c:	d8000015 	stw	zero,0(sp)
 20121a0:	000f883a 	mov	r7,zero
 20121a4:	100d883a 	mov	r6,r2
 20121a8:	000b883a 	mov	r5,zero
 20121ac:	e13ff917 	ldw	r4,-28(fp)
 20121b0:	2011a700 	call	2011a70 <xTimerGenericCommand>
 20121b4:	e0bffb15 	stw	r2,-20(fp)
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
 20121b8:	00002c06 	br	201226c <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 20121bc:	e0bff917 	ldw	r2,-28(fp)
 20121c0:	10c00a03 	ldbu	r3,40(r2)
 20121c4:	00bfff84 	movi	r2,-2
 20121c8:	1884703a 	and	r2,r3,r2
 20121cc:	1007883a 	mov	r3,r2
 20121d0:	e0bff917 	ldw	r2,-28(fp)
 20121d4:	10c00a05 	stb	r3,40(r2)
					break;
 20121d8:	00002406 	br	201226c <prvProcessReceivedCommands+0x1e4>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 20121dc:	e0bff917 	ldw	r2,-28(fp)
 20121e0:	10800a03 	ldbu	r2,40(r2)
 20121e4:	10800054 	ori	r2,r2,1
 20121e8:	1007883a 	mov	r3,r2
 20121ec:	e0bff917 	ldw	r2,-28(fp)
 20121f0:	10c00a05 	stb	r3,40(r2)
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 20121f4:	e0fffd17 	ldw	r3,-12(fp)
 20121f8:	e0bff917 	ldw	r2,-28(fp)
 20121fc:	10c00615 	stw	r3,24(r2)
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 2012200:	e0bff917 	ldw	r2,-28(fp)
 2012204:	10c00617 	ldw	r3,24(r2)
 2012208:	e0bffa17 	ldw	r2,-24(fp)
 201220c:	1885883a 	add	r2,r3,r2
 2012210:	e1fffa17 	ldw	r7,-24(fp)
 2012214:	e1bffa17 	ldw	r6,-24(fp)
 2012218:	100b883a 	mov	r5,r2
 201221c:	e13ff917 	ldw	r4,-28(fp)
 2012220:	2011fac0 	call	2011fac <prvInsertTimerInActiveList>
					break;
 2012224:	00001106 	br	201226c <prvProcessReceivedCommands+0x1e4>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 2012228:	e0bff917 	ldw	r2,-28(fp)
 201222c:	10800a03 	ldbu	r2,40(r2)
 2012230:	10803fcc 	andi	r2,r2,255
 2012234:	1080008c 	andi	r2,r2,2
 2012238:	1000031e 	bne	r2,zero,2012248 <prvProcessReceivedCommands+0x1c0>
						{
							vPortFree( pxTimer );
 201223c:	e13ff917 	ldw	r4,-28(fp)
 2012240:	202bc580 	call	202bc58 <vPortFree>
 2012244:	00000906 	br	201226c <prvProcessReceivedCommands+0x1e4>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 2012248:	e0bff917 	ldw	r2,-28(fp)
 201224c:	10c00a03 	ldbu	r3,40(r2)
 2012250:	00bfff84 	movi	r2,-2
 2012254:	1884703a 	and	r2,r3,r2
 2012258:	1007883a 	mov	r3,r2
 201225c:	e0bff917 	ldw	r2,-28(fp)
 2012260:	10c00a05 	stb	r3,40(r2)
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 2012264:	00000106 	br	201226c <prvProcessReceivedCommands+0x1e4>

				default	:
					/* Don't expect to get here. */
					break;
 2012268:	0001883a 	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 201226c:	d0a7e417 	ldw	r2,-24688(gp)
 2012270:	e0fffc04 	addi	r3,fp,-16
 2012274:	000d883a 	mov	r6,zero
 2012278:	180b883a 	mov	r5,r3
 201227c:	1009883a 	mov	r4,r2
 2012280:	200ddc80 	call	200ddc8 <xQueueReceive>
 2012284:	103f851e 	bne	r2,zero,201209c <__alt_mem_mem_0+0xfcff209c>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
 2012288:	0001883a 	nop
 201228c:	e037883a 	mov	sp,fp
 2012290:	dfc00117 	ldw	ra,4(sp)
 2012294:	df000017 	ldw	fp,0(sp)
 2012298:	dec00204 	addi	sp,sp,8
 201229c:	f800283a 	ret

020122a0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 20122a0:	defff804 	addi	sp,sp,-32
 20122a4:	dfc00715 	stw	ra,28(sp)
 20122a8:	df000615 	stw	fp,24(sp)
 20122ac:	df000604 	addi	fp,sp,24

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 20122b0:	00003106 	br	2012378 <prvSwitchTimerLists+0xd8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 20122b4:	d0a7e217 	ldw	r2,-24696(gp)
 20122b8:	10800317 	ldw	r2,12(r2)
 20122bc:	10800017 	ldw	r2,0(r2)
 20122c0:	e0bffb15 	stw	r2,-20(fp)

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 20122c4:	d0a7e217 	ldw	r2,-24696(gp)
 20122c8:	10800317 	ldw	r2,12(r2)
 20122cc:	10800317 	ldw	r2,12(r2)
 20122d0:	e0bffc15 	stw	r2,-16(fp)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 20122d4:	e0bffc17 	ldw	r2,-16(fp)
 20122d8:	10800104 	addi	r2,r2,4
 20122dc:	1009883a 	mov	r4,r2
 20122e0:	202bec40 	call	202bec4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 20122e4:	e0bffc17 	ldw	r2,-16(fp)
 20122e8:	10800817 	ldw	r2,32(r2)
 20122ec:	e13ffc17 	ldw	r4,-16(fp)
 20122f0:	103ee83a 	callr	r2

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 20122f4:	e0bffc17 	ldw	r2,-16(fp)
 20122f8:	10800a03 	ldbu	r2,40(r2)
 20122fc:	10803fcc 	andi	r2,r2,255
 2012300:	1080010c 	andi	r2,r2,4
 2012304:	10001c26 	beq	r2,zero,2012378 <prvSwitchTimerLists+0xd8>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 2012308:	e0bffc17 	ldw	r2,-16(fp)
 201230c:	10c00617 	ldw	r3,24(r2)
 2012310:	e0bffb17 	ldw	r2,-20(fp)
 2012314:	1885883a 	add	r2,r3,r2
 2012318:	e0bffd15 	stw	r2,-12(fp)
			if( xReloadTime > xNextExpireTime )
 201231c:	e0bffd17 	ldw	r2,-12(fp)
 2012320:	e0fffb17 	ldw	r3,-20(fp)
 2012324:	18800d2e 	bgeu	r3,r2,201235c <prvSwitchTimerLists+0xbc>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 2012328:	e0bffc17 	ldw	r2,-16(fp)
 201232c:	e0fffd17 	ldw	r3,-12(fp)
 2012330:	10c00115 	stw	r3,4(r2)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 2012334:	e0bffc17 	ldw	r2,-16(fp)
 2012338:	e0fffc17 	ldw	r3,-16(fp)
 201233c:	10c00415 	stw	r3,16(r2)
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 2012340:	d0e7e217 	ldw	r3,-24696(gp)
 2012344:	e0bffc17 	ldw	r2,-16(fp)
 2012348:	10800104 	addi	r2,r2,4
 201234c:	100b883a 	mov	r5,r2
 2012350:	1809883a 	mov	r4,r3
 2012354:	202bdec0 	call	202bdec <vListInsert>
 2012358:	00000706 	br	2012378 <prvSwitchTimerLists+0xd8>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 201235c:	d8000015 	stw	zero,0(sp)
 2012360:	000f883a 	mov	r7,zero
 2012364:	e1bffb17 	ldw	r6,-20(fp)
 2012368:	000b883a 	mov	r5,zero
 201236c:	e13ffc17 	ldw	r4,-16(fp)
 2012370:	2011a700 	call	2011a70 <xTimerGenericCommand>
 2012374:	e0bffe15 	stw	r2,-8(fp)

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 2012378:	d0a7e217 	ldw	r2,-24696(gp)
 201237c:	10800017 	ldw	r2,0(r2)
 2012380:	103fcc1e 	bne	r2,zero,20122b4 <__alt_mem_mem_0+0xfcff22b4>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 2012384:	d0a7e217 	ldw	r2,-24696(gp)
 2012388:	e0bfff15 	stw	r2,-4(fp)
	pxCurrentTimerList = pxOverflowTimerList;
 201238c:	d0a7e317 	ldw	r2,-24692(gp)
 2012390:	d0a7e215 	stw	r2,-24696(gp)
	pxOverflowTimerList = pxTemp;
 2012394:	e0bfff17 	ldw	r2,-4(fp)
 2012398:	d0a7e315 	stw	r2,-24692(gp)
}
 201239c:	0001883a 	nop
 20123a0:	e037883a 	mov	sp,fp
 20123a4:	dfc00117 	ldw	ra,4(sp)
 20123a8:	df000017 	ldw	fp,0(sp)
 20123ac:	dec00204 	addi	sp,sp,8
 20123b0:	f800283a 	ret

020123b4 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 20123b4:	defffe04 	addi	sp,sp,-8
 20123b8:	dfc00115 	stw	ra,4(sp)
 20123bc:	df000015 	stw	fp,0(sp)
 20123c0:	d839883a 	mov	fp,sp
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 20123c4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20123c8:	10000126 	beq	r2,zero,20123d0 <prvCheckForValidListAndQueue+0x1c>
 20123cc:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( xTimerQueue == NULL )
 20123d0:	d0a7e417 	ldw	r2,-24688(gp)
 20123d4:	1000111e 	bne	r2,zero,201241c <prvCheckForValidListAndQueue+0x68>
		{
			vListInitialise( &xActiveTimerList1 );
 20123d8:	01008134 	movhi	r4,516
 20123dc:	211e9904 	addi	r4,r4,31332
 20123e0:	202bccc0 	call	202bccc <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 20123e4:	01008134 	movhi	r4,516
 20123e8:	211e9e04 	addi	r4,r4,31352
 20123ec:	202bccc0 	call	202bccc <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 20123f0:	00808134 	movhi	r2,516
 20123f4:	109e9904 	addi	r2,r2,31332
 20123f8:	d0a7e215 	stw	r2,-24696(gp)
			pxOverflowTimerList = &xActiveTimerList2;
 20123fc:	00808134 	movhi	r2,516
 2012400:	109e9e04 	addi	r2,r2,31352
 2012404:	d0a7e315 	stw	r2,-24692(gp)

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 2012408:	000d883a 	mov	r6,zero
 201240c:	01400304 	movi	r5,12
 2012410:	01000284 	movi	r4,10
 2012414:	200d6ac0 	call	200d6ac <xQueueGenericCreate>
 2012418:	d0a7e415 	stw	r2,-24688(gp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 201241c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2012420:	10000126 	beq	r2,zero,2012428 <prvCheckForValidListAndQueue+0x74>
 2012424:	2010f780 	call	2010f78 <vTaskExitCritical>
}
 2012428:	0001883a 	nop
 201242c:	e037883a 	mov	sp,fp
 2012430:	dfc00117 	ldw	ra,4(sp)
 2012434:	df000017 	ldw	fp,0(sp)
 2012438:	dec00204 	addi	sp,sp,8
 201243c:	f800283a 	ret

02012440 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
{
 2012440:	defffb04 	addi	sp,sp,-20
 2012444:	dfc00415 	stw	ra,16(sp)
 2012448:	df000315 	stw	fp,12(sp)
 201244c:	df000304 	addi	fp,sp,12
 2012450:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;
Timer_t *pxTimer = xTimer;
 2012454:	e0bfff17 	ldw	r2,-4(fp)
 2012458:	e0bffe15 	stw	r2,-8(fp)

	configASSERT( xTimer );

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 201245c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2012460:	10000126 	beq	r2,zero,2012468 <xTimerIsTimerActive+0x28>
 2012464:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
 2012468:	e0bffe17 	ldw	r2,-8(fp)
 201246c:	10800a03 	ldbu	r2,40(r2)
 2012470:	10803fcc 	andi	r2,r2,255
 2012474:	1080004c 	andi	r2,r2,1
 2012478:	1000021e 	bne	r2,zero,2012484 <xTimerIsTimerActive+0x44>
		{
			xReturn = pdFALSE;
 201247c:	e03ffd15 	stw	zero,-12(fp)
 2012480:	00000206 	br	201248c <xTimerIsTimerActive+0x4c>
		}
		else
		{
			xReturn = pdTRUE;
 2012484:	00800044 	movi	r2,1
 2012488:	e0bffd15 	stw	r2,-12(fp)
		}
	}
	taskEXIT_CRITICAL();
 201248c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2012490:	10000126 	beq	r2,zero,2012498 <xTimerIsTimerActive+0x58>
 2012494:	2010f780 	call	2010f78 <vTaskExitCritical>

	return xReturn;
 2012498:	e0bffd17 	ldw	r2,-12(fp)
} /*lint !e818 Can't be pointer to const due to the typedef. */
 201249c:	e037883a 	mov	sp,fp
 20124a0:	dfc00117 	ldw	ra,4(sp)
 20124a4:	df000017 	ldw	fp,0(sp)
 20124a8:	dec00204 	addi	sp,sp,8
 20124ac:	f800283a 	ret

020124b0 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 20124b0:	defffb04 	addi	sp,sp,-20
 20124b4:	dfc00415 	stw	ra,16(sp)
 20124b8:	df000315 	stw	fp,12(sp)
 20124bc:	df000304 	addi	fp,sp,12
 20124c0:	e13fff15 	stw	r4,-4(fp)
Timer_t * const pxTimer = xTimer;
 20124c4:	e0bfff17 	ldw	r2,-4(fp)
 20124c8:	e0bffd15 	stw	r2,-12(fp)
void *pvReturn;

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 20124cc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20124d0:	10000126 	beq	r2,zero,20124d8 <pvTimerGetTimerID+0x28>
 20124d4:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 20124d8:	e0bffd17 	ldw	r2,-12(fp)
 20124dc:	10800717 	ldw	r2,28(r2)
 20124e0:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 20124e4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20124e8:	10000126 	beq	r2,zero,20124f0 <pvTimerGetTimerID+0x40>
 20124ec:	2010f780 	call	2010f78 <vTaskExitCritical>

	return pvReturn;
 20124f0:	e0bffe17 	ldw	r2,-8(fp)
}
 20124f4:	e037883a 	mov	sp,fp
 20124f8:	dfc00117 	ldw	ra,4(sp)
 20124fc:	df000017 	ldw	fp,0(sp)
 2012500:	dec00204 	addi	sp,sp,8
 2012504:	f800283a 	ret

02012508 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 2012508:	defffb04 	addi	sp,sp,-20
 201250c:	dfc00415 	stw	ra,16(sp)
 2012510:	df000315 	stw	fp,12(sp)
 2012514:	df000304 	addi	fp,sp,12
 2012518:	e13ffe15 	stw	r4,-8(fp)
 201251c:	e17fff15 	stw	r5,-4(fp)
Timer_t * const pxTimer = xTimer;
 2012520:	e0bffe17 	ldw	r2,-8(fp)
 2012524:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( xTimer );

	taskENTER_CRITICAL();
 2012528:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201252c:	10000126 	beq	r2,zero,2012534 <vTimerSetTimerID+0x2c>
 2012530:	2010f300 	call	2010f30 <vTaskEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 2012534:	e0bffd17 	ldw	r2,-12(fp)
 2012538:	e0ffff17 	ldw	r3,-4(fp)
 201253c:	10c00715 	stw	r3,28(r2)
	}
	taskEXIT_CRITICAL();
 2012540:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2012544:	10000126 	beq	r2,zero,201254c <vTimerSetTimerID+0x44>
 2012548:	2010f780 	call	2010f78 <vTaskExitCritical>
}
 201254c:	0001883a 	nop
 2012550:	e037883a 	mov	sp,fp
 2012554:	dfc00117 	ldw	ra,4(sp)
 2012558:	df000017 	ldw	fp,0(sp)
 201255c:	dec00204 	addi	sp,sp,8
 2012560:	f800283a 	ret

02012564 <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
	{
 2012564:	defffe04 	addi	sp,sp,-8
 2012568:	df000115 	stw	fp,4(sp)
 201256c:	df000104 	addi	fp,sp,4
 2012570:	e13fff15 	stw	r4,-4(fp)
		return ( ( Timer_t * ) xTimer )->uxTimerNumber;
 2012574:	e0bfff17 	ldw	r2,-4(fp)
 2012578:	10800917 	ldw	r2,36(r2)
	}
 201257c:	e037883a 	mov	sp,fp
 2012580:	df000017 	ldw	fp,0(sp)
 2012584:	dec00104 	addi	sp,sp,4
 2012588:	f800283a 	ret

0201258c <vTimerSetTimerNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	void vTimerSetTimerNumber( TimerHandle_t xTimer, UBaseType_t uxTimerNumber )
	{
 201258c:	defffd04 	addi	sp,sp,-12
 2012590:	df000215 	stw	fp,8(sp)
 2012594:	df000204 	addi	fp,sp,8
 2012598:	e13ffe15 	stw	r4,-8(fp)
 201259c:	e17fff15 	stw	r5,-4(fp)
		( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
 20125a0:	e0bffe17 	ldw	r2,-8(fp)
 20125a4:	e0ffff17 	ldw	r3,-4(fp)
 20125a8:	10c00915 	stw	r3,36(r2)
	}
 20125ac:	0001883a 	nop
 20125b0:	e037883a 	mov	sp,fp
 20125b4:	df000017 	ldw	fp,0(sp)
 20125b8:	dec00104 	addi	sp,sp,4
 20125bc:	f800283a 	ret

020125c0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 20125c0:	defffc04 	addi	sp,sp,-16
 20125c4:	df000315 	stw	fp,12(sp)
 20125c8:	df000304 	addi	fp,sp,12
 20125cc:	e13ffd15 	stw	r4,-12(fp)
 20125d0:	e17ffe15 	stw	r5,-8(fp)
 20125d4:	e1bfff15 	stw	r6,-4(fp)
  return len;
 20125d8:	e0bfff17 	ldw	r2,-4(fp)
}
 20125dc:	e037883a 	mov	sp,fp
 20125e0:	df000017 	ldw	fp,0(sp)
 20125e4:	dec00104 	addi	sp,sp,4
 20125e8:	f800283a 	ret

020125ec <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 20125ec:	defffd04 	addi	sp,sp,-12
 20125f0:	dfc00215 	stw	ra,8(sp)
 20125f4:	df000115 	stw	fp,4(sp)
 20125f8:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 20125fc:	00808134 	movhi	r2,516
 2012600:	10828704 	addi	r2,r2,2588
 2012604:	e0bfff15 	stw	r2,-4(fp)
 2012608:	00000606 	br	2012624 <_do_ctors+0x38>
        (*ctor) (); 
 201260c:	e0bfff17 	ldw	r2,-4(fp)
 2012610:	10800017 	ldw	r2,0(r2)
 2012614:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 2012618:	e0bfff17 	ldw	r2,-4(fp)
 201261c:	10bfff04 	addi	r2,r2,-4
 2012620:	e0bfff15 	stw	r2,-4(fp)
 2012624:	e0ffff17 	ldw	r3,-4(fp)
 2012628:	00808134 	movhi	r2,516
 201262c:	10828804 	addi	r2,r2,2592
 2012630:	18bff62e 	bgeu	r3,r2,201260c <__alt_mem_mem_0+0xfcff260c>
        (*ctor) (); 
}
 2012634:	0001883a 	nop
 2012638:	e037883a 	mov	sp,fp
 201263c:	dfc00117 	ldw	ra,4(sp)
 2012640:	df000017 	ldw	fp,0(sp)
 2012644:	dec00204 	addi	sp,sp,8
 2012648:	f800283a 	ret

0201264c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 201264c:	defffd04 	addi	sp,sp,-12
 2012650:	dfc00215 	stw	ra,8(sp)
 2012654:	df000115 	stw	fp,4(sp)
 2012658:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 201265c:	00808134 	movhi	r2,516
 2012660:	10828704 	addi	r2,r2,2588
 2012664:	e0bfff15 	stw	r2,-4(fp)
 2012668:	00000606 	br	2012684 <_do_dtors+0x38>
        (*dtor) (); 
 201266c:	e0bfff17 	ldw	r2,-4(fp)
 2012670:	10800017 	ldw	r2,0(r2)
 2012674:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2012678:	e0bfff17 	ldw	r2,-4(fp)
 201267c:	10bfff04 	addi	r2,r2,-4
 2012680:	e0bfff15 	stw	r2,-4(fp)
 2012684:	e0ffff17 	ldw	r3,-4(fp)
 2012688:	00808134 	movhi	r2,516
 201268c:	10828804 	addi	r2,r2,2592
 2012690:	18bff62e 	bgeu	r3,r2,201266c <__alt_mem_mem_0+0xfcff266c>
        (*dtor) (); 
}
 2012694:	0001883a 	nop
 2012698:	e037883a 	mov	sp,fp
 201269c:	dfc00117 	ldw	ra,4(sp)
 20126a0:	df000017 	ldw	fp,0(sp)
 20126a4:	dec00204 	addi	sp,sp,8
 20126a8:	f800283a 	ret

020126ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20126ac:	defffe04 	addi	sp,sp,-8
 20126b0:	dfc00115 	stw	ra,4(sp)
 20126b4:	df000015 	stw	fp,0(sp)
 20126b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20126bc:	d0a01a17 	ldw	r2,-32664(gp)
 20126c0:	10000326 	beq	r2,zero,20126d0 <alt_get_errno+0x24>
 20126c4:	d0a01a17 	ldw	r2,-32664(gp)
 20126c8:	103ee83a 	callr	r2
 20126cc:	00000106 	br	20126d4 <alt_get_errno+0x28>
 20126d0:	d0a7ce04 	addi	r2,gp,-24776
}
 20126d4:	e037883a 	mov	sp,fp
 20126d8:	dfc00117 	ldw	ra,4(sp)
 20126dc:	df000017 	ldw	fp,0(sp)
 20126e0:	dec00204 	addi	sp,sp,8
 20126e4:	f800283a 	ret

020126e8 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 20126e8:	defffb04 	addi	sp,sp,-20
 20126ec:	dfc00415 	stw	ra,16(sp)
 20126f0:	df000315 	stw	fp,12(sp)
 20126f4:	df000304 	addi	fp,sp,12
 20126f8:	e13ffe15 	stw	r4,-8(fp)
 20126fc:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2012700:	e0bffe17 	ldw	r2,-8(fp)
 2012704:	10000616 	blt	r2,zero,2012720 <fstat+0x38>
 2012708:	e0bffe17 	ldw	r2,-8(fp)
 201270c:	10c00324 	muli	r3,r2,12
 2012710:	00808134 	movhi	r2,516
 2012714:	1090e704 	addi	r2,r2,17308
 2012718:	1885883a 	add	r2,r3,r2
 201271c:	00000106 	br	2012724 <fstat+0x3c>
 2012720:	0005883a 	mov	r2,zero
 2012724:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 2012728:	e0bffd17 	ldw	r2,-12(fp)
 201272c:	10001026 	beq	r2,zero,2012770 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 2012730:	e0bffd17 	ldw	r2,-12(fp)
 2012734:	10800017 	ldw	r2,0(r2)
 2012738:	10800817 	ldw	r2,32(r2)
 201273c:	10000726 	beq	r2,zero,201275c <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 2012740:	e0bffd17 	ldw	r2,-12(fp)
 2012744:	10800017 	ldw	r2,0(r2)
 2012748:	10800817 	ldw	r2,32(r2)
 201274c:	e17fff17 	ldw	r5,-4(fp)
 2012750:	e13ffd17 	ldw	r4,-12(fp)
 2012754:	103ee83a 	callr	r2
 2012758:	00000a06 	br	2012784 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 201275c:	e0bfff17 	ldw	r2,-4(fp)
 2012760:	00c80004 	movi	r3,8192
 2012764:	10c00115 	stw	r3,4(r2)
      return 0;
 2012768:	0005883a 	mov	r2,zero
 201276c:	00000506 	br	2012784 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2012770:	20126ac0 	call	20126ac <alt_get_errno>
 2012774:	1007883a 	mov	r3,r2
 2012778:	00801444 	movi	r2,81
 201277c:	18800015 	stw	r2,0(r3)
    return -1;
 2012780:	00bfffc4 	movi	r2,-1
  }
}
 2012784:	e037883a 	mov	sp,fp
 2012788:	dfc00117 	ldw	ra,4(sp)
 201278c:	df000017 	ldw	fp,0(sp)
 2012790:	dec00204 	addi	sp,sp,8
 2012794:	f800283a 	ret

02012798 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 2012798:	defff904 	addi	sp,sp,-28
 201279c:	dfc00615 	stw	ra,24(sp)
 20127a0:	df000515 	stw	fp,20(sp)
 20127a4:	df000504 	addi	fp,sp,20
 20127a8:	e13ffc15 	stw	r4,-16(fp)
 20127ac:	e17ffd15 	stw	r5,-12(fp)
 20127b0:	e1bffe15 	stw	r6,-8(fp)
 20127b4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 20127b8:	e1bfff17 	ldw	r6,-4(fp)
 20127bc:	e17ffe17 	ldw	r5,-8(fp)
 20127c0:	e13ffd17 	ldw	r4,-12(fp)
 20127c4:	2012cb40 	call	2012cb4 <open>
 20127c8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 20127cc:	e0bffb17 	ldw	r2,-20(fp)
 20127d0:	10001c16 	blt	r2,zero,2012844 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 20127d4:	00808134 	movhi	r2,516
 20127d8:	1090e704 	addi	r2,r2,17308
 20127dc:	e0fffb17 	ldw	r3,-20(fp)
 20127e0:	18c00324 	muli	r3,r3,12
 20127e4:	10c5883a 	add	r2,r2,r3
 20127e8:	10c00017 	ldw	r3,0(r2)
 20127ec:	e0bffc17 	ldw	r2,-16(fp)
 20127f0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 20127f4:	00808134 	movhi	r2,516
 20127f8:	1090e704 	addi	r2,r2,17308
 20127fc:	e0fffb17 	ldw	r3,-20(fp)
 2012800:	18c00324 	muli	r3,r3,12
 2012804:	10c5883a 	add	r2,r2,r3
 2012808:	10800104 	addi	r2,r2,4
 201280c:	10c00017 	ldw	r3,0(r2)
 2012810:	e0bffc17 	ldw	r2,-16(fp)
 2012814:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 2012818:	00808134 	movhi	r2,516
 201281c:	1090e704 	addi	r2,r2,17308
 2012820:	e0fffb17 	ldw	r3,-20(fp)
 2012824:	18c00324 	muli	r3,r3,12
 2012828:	10c5883a 	add	r2,r2,r3
 201282c:	10800204 	addi	r2,r2,8
 2012830:	10c00017 	ldw	r3,0(r2)
 2012834:	e0bffc17 	ldw	r2,-16(fp)
 2012838:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 201283c:	e13ffb17 	ldw	r4,-20(fp)
 2012840:	20130700 	call	2013070 <alt_release_fd>
  }
} 
 2012844:	0001883a 	nop
 2012848:	e037883a 	mov	sp,fp
 201284c:	dfc00117 	ldw	ra,4(sp)
 2012850:	df000017 	ldw	fp,0(sp)
 2012854:	dec00204 	addi	sp,sp,8
 2012858:	f800283a 	ret

0201285c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 201285c:	defffb04 	addi	sp,sp,-20
 2012860:	dfc00415 	stw	ra,16(sp)
 2012864:	df000315 	stw	fp,12(sp)
 2012868:	df000304 	addi	fp,sp,12
 201286c:	e13ffd15 	stw	r4,-12(fp)
 2012870:	e17ffe15 	stw	r5,-8(fp)
 2012874:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 2012878:	01c07fc4 	movi	r7,511
 201287c:	01800044 	movi	r6,1
 2012880:	e17ffd17 	ldw	r5,-12(fp)
 2012884:	01008134 	movhi	r4,516
 2012888:	2110ea04 	addi	r4,r4,17320
 201288c:	20127980 	call	2012798 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 2012890:	01c07fc4 	movi	r7,511
 2012894:	000d883a 	mov	r6,zero
 2012898:	e17ffe17 	ldw	r5,-8(fp)
 201289c:	01008134 	movhi	r4,516
 20128a0:	2110e704 	addi	r4,r4,17308
 20128a4:	20127980 	call	2012798 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 20128a8:	01c07fc4 	movi	r7,511
 20128ac:	01800044 	movi	r6,1
 20128b0:	e17fff17 	ldw	r5,-4(fp)
 20128b4:	01008134 	movhi	r4,516
 20128b8:	2110ed04 	addi	r4,r4,17332
 20128bc:	20127980 	call	2012798 <alt_open_fd>
}  
 20128c0:	0001883a 	nop
 20128c4:	e037883a 	mov	sp,fp
 20128c8:	dfc00117 	ldw	ra,4(sp)
 20128cc:	df000017 	ldw	fp,0(sp)
 20128d0:	dec00204 	addi	sp,sp,8
 20128d4:	f800283a 	ret

020128d8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20128d8:	defffe04 	addi	sp,sp,-8
 20128dc:	dfc00115 	stw	ra,4(sp)
 20128e0:	df000015 	stw	fp,0(sp)
 20128e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20128e8:	d0a01a17 	ldw	r2,-32664(gp)
 20128ec:	10000326 	beq	r2,zero,20128fc <alt_get_errno+0x24>
 20128f0:	d0a01a17 	ldw	r2,-32664(gp)
 20128f4:	103ee83a 	callr	r2
 20128f8:	00000106 	br	2012900 <alt_get_errno+0x28>
 20128fc:	d0a7ce04 	addi	r2,gp,-24776
}
 2012900:	e037883a 	mov	sp,fp
 2012904:	dfc00117 	ldw	ra,4(sp)
 2012908:	df000017 	ldw	fp,0(sp)
 201290c:	dec00204 	addi	sp,sp,8
 2012910:	f800283a 	ret

02012914 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 2012914:	deffed04 	addi	sp,sp,-76
 2012918:	dfc01215 	stw	ra,72(sp)
 201291c:	df001115 	stw	fp,68(sp)
 2012920:	df001104 	addi	fp,sp,68
 2012924:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2012928:	e0bfff17 	ldw	r2,-4(fp)
 201292c:	10000616 	blt	r2,zero,2012948 <isatty+0x34>
 2012930:	e0bfff17 	ldw	r2,-4(fp)
 2012934:	10c00324 	muli	r3,r2,12
 2012938:	00808134 	movhi	r2,516
 201293c:	1090e704 	addi	r2,r2,17308
 2012940:	1885883a 	add	r2,r3,r2
 2012944:	00000106 	br	201294c <isatty+0x38>
 2012948:	0005883a 	mov	r2,zero
 201294c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 2012950:	e0bfef17 	ldw	r2,-68(fp)
 2012954:	10000e26 	beq	r2,zero,2012990 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 2012958:	e0bfef17 	ldw	r2,-68(fp)
 201295c:	10800017 	ldw	r2,0(r2)
 2012960:	10800817 	ldw	r2,32(r2)
 2012964:	1000021e 	bne	r2,zero,2012970 <isatty+0x5c>
    {
      return 1;
 2012968:	00800044 	movi	r2,1
 201296c:	00000d06 	br	20129a4 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 2012970:	e0bff004 	addi	r2,fp,-64
 2012974:	100b883a 	mov	r5,r2
 2012978:	e13fff17 	ldw	r4,-4(fp)
 201297c:	20126e80 	call	20126e8 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 2012980:	e0bff117 	ldw	r2,-60(fp)
 2012984:	10880020 	cmpeqi	r2,r2,8192
 2012988:	10803fcc 	andi	r2,r2,255
 201298c:	00000506 	br	20129a4 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2012990:	20128d80 	call	20128d8 <alt_get_errno>
 2012994:	1007883a 	mov	r3,r2
 2012998:	00801444 	movi	r2,81
 201299c:	18800015 	stw	r2,0(r3)
    return 0;
 20129a0:	0005883a 	mov	r2,zero
  }
}
 20129a4:	e037883a 	mov	sp,fp
 20129a8:	dfc00117 	ldw	ra,4(sp)
 20129ac:	df000017 	ldw	fp,0(sp)
 20129b0:	dec00204 	addi	sp,sp,8
 20129b4:	f800283a 	ret

020129b8 <alt_load_section>:
 */

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
 20129b8:	defffc04 	addi	sp,sp,-16
 20129bc:	df000315 	stw	fp,12(sp)
 20129c0:	df000304 	addi	fp,sp,12
 20129c4:	e13ffd15 	stw	r4,-12(fp)
 20129c8:	e17ffe15 	stw	r5,-8(fp)
 20129cc:	e1bfff15 	stw	r6,-4(fp)
  if (to != from)
 20129d0:	e0fffe17 	ldw	r3,-8(fp)
 20129d4:	e0bffd17 	ldw	r2,-12(fp)
 20129d8:	18800c26 	beq	r3,r2,2012a0c <alt_load_section+0x54>
  {
    while( to != end )
 20129dc:	00000806 	br	2012a00 <alt_load_section+0x48>
    {
      *to++ = *from++;
 20129e0:	e0bffe17 	ldw	r2,-8(fp)
 20129e4:	10c00104 	addi	r3,r2,4
 20129e8:	e0fffe15 	stw	r3,-8(fp)
 20129ec:	e0fffd17 	ldw	r3,-12(fp)
 20129f0:	19000104 	addi	r4,r3,4
 20129f4:	e13ffd15 	stw	r4,-12(fp)
 20129f8:	18c00017 	ldw	r3,0(r3)
 20129fc:	10c00015 	stw	r3,0(r2)
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
  {
    while( to != end )
 2012a00:	e0fffe17 	ldw	r3,-8(fp)
 2012a04:	e0bfff17 	ldw	r2,-4(fp)
 2012a08:	18bff51e 	bne	r3,r2,20129e0 <__alt_mem_mem_0+0xfcff29e0>
    {
      *to++ = *from++;
    }
  }
}
 2012a0c:	0001883a 	nop
 2012a10:	e037883a 	mov	sp,fp
 2012a14:	df000017 	ldw	fp,0(sp)
 2012a18:	dec00104 	addi	sp,sp,4
 2012a1c:	f800283a 	ret

02012a20 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
 2012a20:	defffe04 	addi	sp,sp,-8
 2012a24:	dfc00115 	stw	ra,4(sp)
 2012a28:	df000015 	stw	fp,0(sp)
 2012a2c:	d839883a 	mov	fp,sp
  /* 
   * Copy the .rwdata section. 
   */

  alt_load_section (&__flash_rwdata_start, 
 2012a30:	01808134 	movhi	r6,516
 2012a34:	31965a04 	addi	r6,r6,22888
 2012a38:	01408134 	movhi	r5,516
 2012a3c:	294eb404 	addi	r5,r5,15056
 2012a40:	01008134 	movhi	r4,516
 2012a44:	21165a04 	addi	r4,r4,22888
 2012a48:	20129b80 	call	20129b8 <alt_load_section>

  /*
   * Copy the exception handler.
   */

  alt_load_section (&__flash_exceptions_start, 
 2012a4c:	01808034 	movhi	r6,512
 2012a50:	31810504 	addi	r6,r6,1044
 2012a54:	01408034 	movhi	r5,512
 2012a58:	29400804 	addi	r5,r5,32
 2012a5c:	01008034 	movhi	r4,512
 2012a60:	21000804 	addi	r4,r4,32
 2012a64:	20129b80 	call	20129b8 <alt_load_section>

  /*
   * Copy the .rodata section.
   */

  alt_load_section (&__flash_rodata_start, 
 2012a68:	01808134 	movhi	r6,516
 2012a6c:	318eb404 	addi	r6,r6,15056
 2012a70:	01408134 	movhi	r5,516
 2012a74:	29428804 	addi	r5,r5,2592
 2012a78:	01008134 	movhi	r4,516
 2012a7c:	21028804 	addi	r4,r4,2592
 2012a80:	20129b80 	call	20129b8 <alt_load_section>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
 2012a84:	202c6040 	call	202c604 <alt_dcache_flush_all>
  alt_icache_flush_all();
 2012a88:	202cb700 	call	202cb70 <alt_icache_flush_all>
}
 2012a8c:	0001883a 	nop
 2012a90:	e037883a 	mov	sp,fp
 2012a94:	dfc00117 	ldw	ra,4(sp)
 2012a98:	df000017 	ldw	fp,0(sp)
 2012a9c:	dec00204 	addi	sp,sp,8
 2012aa0:	f800283a 	ret

02012aa4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2012aa4:	defffe04 	addi	sp,sp,-8
 2012aa8:	dfc00115 	stw	ra,4(sp)
 2012aac:	df000015 	stw	fp,0(sp)
 2012ab0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2012ab4:	d0a01a17 	ldw	r2,-32664(gp)
 2012ab8:	10000326 	beq	r2,zero,2012ac8 <alt_get_errno+0x24>
 2012abc:	d0a01a17 	ldw	r2,-32664(gp)
 2012ac0:	103ee83a 	callr	r2
 2012ac4:	00000106 	br	2012acc <alt_get_errno+0x28>
 2012ac8:	d0a7ce04 	addi	r2,gp,-24776
}
 2012acc:	e037883a 	mov	sp,fp
 2012ad0:	dfc00117 	ldw	ra,4(sp)
 2012ad4:	df000017 	ldw	fp,0(sp)
 2012ad8:	dec00204 	addi	sp,sp,8
 2012adc:	f800283a 	ret

02012ae0 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 2012ae0:	defff904 	addi	sp,sp,-28
 2012ae4:	dfc00615 	stw	ra,24(sp)
 2012ae8:	df000515 	stw	fp,20(sp)
 2012aec:	df000504 	addi	fp,sp,20
 2012af0:	e13ffd15 	stw	r4,-12(fp)
 2012af4:	e17ffe15 	stw	r5,-8(fp)
 2012af8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 2012afc:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2012b00:	e0bffd17 	ldw	r2,-12(fp)
 2012b04:	10000616 	blt	r2,zero,2012b20 <lseek+0x40>
 2012b08:	e0bffd17 	ldw	r2,-12(fp)
 2012b0c:	10c00324 	muli	r3,r2,12
 2012b10:	00808134 	movhi	r2,516
 2012b14:	1090e704 	addi	r2,r2,17308
 2012b18:	1885883a 	add	r2,r3,r2
 2012b1c:	00000106 	br	2012b24 <lseek+0x44>
 2012b20:	0005883a 	mov	r2,zero
 2012b24:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 2012b28:	e0bffc17 	ldw	r2,-16(fp)
 2012b2c:	10001026 	beq	r2,zero,2012b70 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 2012b30:	e0bffc17 	ldw	r2,-16(fp)
 2012b34:	10800017 	ldw	r2,0(r2)
 2012b38:	10800717 	ldw	r2,28(r2)
 2012b3c:	10000926 	beq	r2,zero,2012b64 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 2012b40:	e0bffc17 	ldw	r2,-16(fp)
 2012b44:	10800017 	ldw	r2,0(r2)
 2012b48:	10800717 	ldw	r2,28(r2)
 2012b4c:	e1bfff17 	ldw	r6,-4(fp)
 2012b50:	e17ffe17 	ldw	r5,-8(fp)
 2012b54:	e13ffc17 	ldw	r4,-16(fp)
 2012b58:	103ee83a 	callr	r2
 2012b5c:	e0bffb15 	stw	r2,-20(fp)
 2012b60:	00000506 	br	2012b78 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 2012b64:	00bfde84 	movi	r2,-134
 2012b68:	e0bffb15 	stw	r2,-20(fp)
 2012b6c:	00000206 	br	2012b78 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 2012b70:	00bfebc4 	movi	r2,-81
 2012b74:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 2012b78:	e0bffb17 	ldw	r2,-20(fp)
 2012b7c:	1000070e 	bge	r2,zero,2012b9c <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 2012b80:	2012aa40 	call	2012aa4 <alt_get_errno>
 2012b84:	1007883a 	mov	r3,r2
 2012b88:	e0bffb17 	ldw	r2,-20(fp)
 2012b8c:	0085c83a 	sub	r2,zero,r2
 2012b90:	18800015 	stw	r2,0(r3)
    rc = -1;
 2012b94:	00bfffc4 	movi	r2,-1
 2012b98:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 2012b9c:	e0bffb17 	ldw	r2,-20(fp)
}
 2012ba0:	e037883a 	mov	sp,fp
 2012ba4:	dfc00117 	ldw	ra,4(sp)
 2012ba8:	df000017 	ldw	fp,0(sp)
 2012bac:	dec00204 	addi	sp,sp,8
 2012bb0:	f800283a 	ret

02012bb4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2012bb4:	defffe04 	addi	sp,sp,-8
 2012bb8:	dfc00115 	stw	ra,4(sp)
 2012bbc:	df000015 	stw	fp,0(sp)
 2012bc0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2012bc4:	d0a01a17 	ldw	r2,-32664(gp)
 2012bc8:	10000326 	beq	r2,zero,2012bd8 <alt_get_errno+0x24>
 2012bcc:	d0a01a17 	ldw	r2,-32664(gp)
 2012bd0:	103ee83a 	callr	r2
 2012bd4:	00000106 	br	2012bdc <alt_get_errno+0x28>
 2012bd8:	d0a7ce04 	addi	r2,gp,-24776
}
 2012bdc:	e037883a 	mov	sp,fp
 2012be0:	dfc00117 	ldw	ra,4(sp)
 2012be4:	df000017 	ldw	fp,0(sp)
 2012be8:	dec00204 	addi	sp,sp,8
 2012bec:	f800283a 	ret

02012bf0 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 2012bf0:	defffd04 	addi	sp,sp,-12
 2012bf4:	df000215 	stw	fp,8(sp)
 2012bf8:	df000204 	addi	fp,sp,8
 2012bfc:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 2012c00:	e0bfff17 	ldw	r2,-4(fp)
 2012c04:	10800217 	ldw	r2,8(r2)
 2012c08:	10d00034 	orhi	r3,r2,16384
 2012c0c:	e0bfff17 	ldw	r2,-4(fp)
 2012c10:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 2012c14:	e03ffe15 	stw	zero,-8(fp)
 2012c18:	00001d06 	br	2012c90 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2012c1c:	00808134 	movhi	r2,516
 2012c20:	1090e704 	addi	r2,r2,17308
 2012c24:	e0fffe17 	ldw	r3,-8(fp)
 2012c28:	18c00324 	muli	r3,r3,12
 2012c2c:	10c5883a 	add	r2,r2,r3
 2012c30:	10c00017 	ldw	r3,0(r2)
 2012c34:	e0bfff17 	ldw	r2,-4(fp)
 2012c38:	10800017 	ldw	r2,0(r2)
 2012c3c:	1880111e 	bne	r3,r2,2012c84 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2012c40:	00808134 	movhi	r2,516
 2012c44:	1090e704 	addi	r2,r2,17308
 2012c48:	e0fffe17 	ldw	r3,-8(fp)
 2012c4c:	18c00324 	muli	r3,r3,12
 2012c50:	10c5883a 	add	r2,r2,r3
 2012c54:	10800204 	addi	r2,r2,8
 2012c58:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2012c5c:	1000090e 	bge	r2,zero,2012c84 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 2012c60:	e0bffe17 	ldw	r2,-8(fp)
 2012c64:	10c00324 	muli	r3,r2,12
 2012c68:	00808134 	movhi	r2,516
 2012c6c:	1090e704 	addi	r2,r2,17308
 2012c70:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2012c74:	e0bfff17 	ldw	r2,-4(fp)
 2012c78:	18800226 	beq	r3,r2,2012c84 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 2012c7c:	00bffcc4 	movi	r2,-13
 2012c80:	00000806 	br	2012ca4 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 2012c84:	e0bffe17 	ldw	r2,-8(fp)
 2012c88:	10800044 	addi	r2,r2,1
 2012c8c:	e0bffe15 	stw	r2,-8(fp)
 2012c90:	d0a00a17 	ldw	r2,-32728(gp)
 2012c94:	1007883a 	mov	r3,r2
 2012c98:	e0bffe17 	ldw	r2,-8(fp)
 2012c9c:	18bfdf2e 	bgeu	r3,r2,2012c1c <__alt_mem_mem_0+0xfcff2c1c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 2012ca0:	0005883a 	mov	r2,zero
}
 2012ca4:	e037883a 	mov	sp,fp
 2012ca8:	df000017 	ldw	fp,0(sp)
 2012cac:	dec00104 	addi	sp,sp,4
 2012cb0:	f800283a 	ret

02012cb4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 2012cb4:	defff604 	addi	sp,sp,-40
 2012cb8:	dfc00915 	stw	ra,36(sp)
 2012cbc:	df000815 	stw	fp,32(sp)
 2012cc0:	df000804 	addi	fp,sp,32
 2012cc4:	e13ffd15 	stw	r4,-12(fp)
 2012cc8:	e17ffe15 	stw	r5,-8(fp)
 2012ccc:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 2012cd0:	00bfffc4 	movi	r2,-1
 2012cd4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 2012cd8:	00bffb44 	movi	r2,-19
 2012cdc:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 2012ce0:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 2012ce4:	d1600804 	addi	r5,gp,-32736
 2012ce8:	e13ffd17 	ldw	r4,-12(fp)
 2012cec:	202c7040 	call	202c704 <alt_find_dev>
 2012cf0:	e0bff815 	stw	r2,-32(fp)
 2012cf4:	e0bff817 	ldw	r2,-32(fp)
 2012cf8:	1000051e 	bne	r2,zero,2012d10 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 2012cfc:	e13ffd17 	ldw	r4,-12(fp)
 2012d00:	202c7940 	call	202c794 <alt_find_file>
 2012d04:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 2012d08:	00800044 	movi	r2,1
 2012d0c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 2012d10:	e0bff817 	ldw	r2,-32(fp)
 2012d14:	10002926 	beq	r2,zero,2012dbc <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 2012d18:	e13ff817 	ldw	r4,-32(fp)
 2012d1c:	202c89c0 	call	202c89c <alt_get_fd>
 2012d20:	e0bff915 	stw	r2,-28(fp)
 2012d24:	e0bff917 	ldw	r2,-28(fp)
 2012d28:	1000030e 	bge	r2,zero,2012d38 <open+0x84>
    {
      status = index;
 2012d2c:	e0bff917 	ldw	r2,-28(fp)
 2012d30:	e0bffa15 	stw	r2,-24(fp)
 2012d34:	00002306 	br	2012dc4 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 2012d38:	e0bff917 	ldw	r2,-28(fp)
 2012d3c:	10c00324 	muli	r3,r2,12
 2012d40:	00808134 	movhi	r2,516
 2012d44:	1090e704 	addi	r2,r2,17308
 2012d48:	1885883a 	add	r2,r3,r2
 2012d4c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 2012d50:	e0fffe17 	ldw	r3,-8(fp)
 2012d54:	00900034 	movhi	r2,16384
 2012d58:	10bfffc4 	addi	r2,r2,-1
 2012d5c:	1886703a 	and	r3,r3,r2
 2012d60:	e0bffc17 	ldw	r2,-16(fp)
 2012d64:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 2012d68:	e0bffb17 	ldw	r2,-20(fp)
 2012d6c:	1000051e 	bne	r2,zero,2012d84 <open+0xd0>
 2012d70:	e13ffc17 	ldw	r4,-16(fp)
 2012d74:	2012bf00 	call	2012bf0 <alt_file_locked>
 2012d78:	e0bffa15 	stw	r2,-24(fp)
 2012d7c:	e0bffa17 	ldw	r2,-24(fp)
 2012d80:	10001016 	blt	r2,zero,2012dc4 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 2012d84:	e0bff817 	ldw	r2,-32(fp)
 2012d88:	10800317 	ldw	r2,12(r2)
 2012d8c:	10000826 	beq	r2,zero,2012db0 <open+0xfc>
 2012d90:	e0bff817 	ldw	r2,-32(fp)
 2012d94:	10800317 	ldw	r2,12(r2)
 2012d98:	e1ffff17 	ldw	r7,-4(fp)
 2012d9c:	e1bffe17 	ldw	r6,-8(fp)
 2012da0:	e17ffd17 	ldw	r5,-12(fp)
 2012da4:	e13ffc17 	ldw	r4,-16(fp)
 2012da8:	103ee83a 	callr	r2
 2012dac:	00000106 	br	2012db4 <open+0x100>
 2012db0:	0005883a 	mov	r2,zero
 2012db4:	e0bffa15 	stw	r2,-24(fp)
 2012db8:	00000206 	br	2012dc4 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 2012dbc:	00bffb44 	movi	r2,-19
 2012dc0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 2012dc4:	e0bffa17 	ldw	r2,-24(fp)
 2012dc8:	1000090e 	bge	r2,zero,2012df0 <open+0x13c>
  {
    alt_release_fd (index);  
 2012dcc:	e13ff917 	ldw	r4,-28(fp)
 2012dd0:	20130700 	call	2013070 <alt_release_fd>
    ALT_ERRNO = -status;
 2012dd4:	2012bb40 	call	2012bb4 <alt_get_errno>
 2012dd8:	1007883a 	mov	r3,r2
 2012ddc:	e0bffa17 	ldw	r2,-24(fp)
 2012de0:	0085c83a 	sub	r2,zero,r2
 2012de4:	18800015 	stw	r2,0(r3)
    return -1;
 2012de8:	00bfffc4 	movi	r2,-1
 2012dec:	00000106 	br	2012df4 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 2012df0:	e0bff917 	ldw	r2,-28(fp)
}
 2012df4:	e037883a 	mov	sp,fp
 2012df8:	dfc00117 	ldw	ra,4(sp)
 2012dfc:	df000017 	ldw	fp,0(sp)
 2012e00:	dec00204 	addi	sp,sp,8
 2012e04:	f800283a 	ret

02012e08 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
 2012e08:	defff204 	addi	sp,sp,-56
 2012e0c:	dfc00a15 	stw	ra,40(sp)
 2012e10:	df000915 	stw	fp,36(sp)
 2012e14:	df000904 	addi	fp,sp,36
 2012e18:	e13fff15 	stw	r4,-4(fp)
 2012e1c:	e1400215 	stw	r5,8(fp)
 2012e20:	e1800315 	stw	r6,12(fp)
 2012e24:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
 2012e28:	e0800204 	addi	r2,fp,8
 2012e2c:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
 2012e30:	e0bfff17 	ldw	r2,-4(fp)
 2012e34:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
 2012e38:	00006f06 	br	2012ff8 <alt_printf+0x1f0>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
 2012e3c:	e0bff807 	ldb	r2,-32(fp)
 2012e40:	10800960 	cmpeqi	r2,r2,37
 2012e44:	1000041e 	bne	r2,zero,2012e58 <alt_printf+0x50>
        {
            alt_putchar(c);
 2012e48:	e0bff807 	ldb	r2,-32(fp)
 2012e4c:	1009883a 	mov	r4,r2
 2012e50:	20130340 	call	2013034 <alt_putchar>
 2012e54:	00006806 	br	2012ff8 <alt_printf+0x1f0>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
 2012e58:	e0bff717 	ldw	r2,-36(fp)
 2012e5c:	10c00044 	addi	r3,r2,1
 2012e60:	e0fff715 	stw	r3,-36(fp)
 2012e64:	10800003 	ldbu	r2,0(r2)
 2012e68:	e0bff805 	stb	r2,-32(fp)
 2012e6c:	e0bff807 	ldb	r2,-32(fp)
 2012e70:	10006926 	beq	r2,zero,2013018 <alt_printf+0x210>
            {
                if (c == '%')
 2012e74:	e0bff807 	ldb	r2,-32(fp)
 2012e78:	10800958 	cmpnei	r2,r2,37
 2012e7c:	1000041e 	bne	r2,zero,2012e90 <alt_printf+0x88>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
 2012e80:	e0bff807 	ldb	r2,-32(fp)
 2012e84:	1009883a 	mov	r4,r2
 2012e88:	20130340 	call	2013034 <alt_putchar>
 2012e8c:	00005a06 	br	2012ff8 <alt_printf+0x1f0>
                } 
                else if (c == 'c')
 2012e90:	e0bff807 	ldb	r2,-32(fp)
 2012e94:	108018d8 	cmpnei	r2,r2,99
 2012e98:	1000081e 	bne	r2,zero,2012ebc <alt_printf+0xb4>
                {
                    int v = va_arg(args, int);
 2012e9c:	e0bffe17 	ldw	r2,-8(fp)
 2012ea0:	10c00104 	addi	r3,r2,4
 2012ea4:	e0fffe15 	stw	r3,-8(fp)
 2012ea8:	10800017 	ldw	r2,0(r2)
 2012eac:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
 2012eb0:	e13ffd17 	ldw	r4,-12(fp)
 2012eb4:	20130340 	call	2013034 <alt_putchar>
 2012eb8:	00004f06 	br	2012ff8 <alt_printf+0x1f0>
                }
                else if (c == 'x')
 2012ebc:	e0bff807 	ldb	r2,-32(fp)
 2012ec0:	10801e18 	cmpnei	r2,r2,120
 2012ec4:	1000341e 	bne	r2,zero,2012f98 <alt_printf+0x190>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
 2012ec8:	e0bffe17 	ldw	r2,-8(fp)
 2012ecc:	10c00104 	addi	r3,r2,4
 2012ed0:	e0fffe15 	stw	r3,-8(fp)
 2012ed4:	10800017 	ldw	r2,0(r2)
 2012ed8:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
 2012edc:	e0bffb17 	ldw	r2,-20(fp)
 2012ee0:	1000031e 	bne	r2,zero,2012ef0 <alt_printf+0xe8>
                    {
                        alt_putchar('0');
 2012ee4:	01000c04 	movi	r4,48
 2012ee8:	20130340 	call	2013034 <alt_putchar>
                        continue;
 2012eec:	00004206 	br	2012ff8 <alt_printf+0x1f0>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
 2012ef0:	00800704 	movi	r2,28
 2012ef4:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
 2012ef8:	00000306 	br	2012f08 <alt_printf+0x100>
                        digit_shift -= 4;
 2012efc:	e0bff917 	ldw	r2,-28(fp)
 2012f00:	10bfff04 	addi	r2,r2,-4
 2012f04:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
 2012f08:	00c003c4 	movi	r3,15
 2012f0c:	e0bff917 	ldw	r2,-28(fp)
 2012f10:	1884983a 	sll	r2,r3,r2
 2012f14:	1007883a 	mov	r3,r2
 2012f18:	e0bffb17 	ldw	r2,-20(fp)
 2012f1c:	1884703a 	and	r2,r3,r2
 2012f20:	103ff626 	beq	r2,zero,2012efc <__alt_mem_mem_0+0xfcff2efc>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 2012f24:	00001906 	br	2012f8c <alt_printf+0x184>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
 2012f28:	00c003c4 	movi	r3,15
 2012f2c:	e0bff917 	ldw	r2,-28(fp)
 2012f30:	1884983a 	sll	r2,r3,r2
 2012f34:	1007883a 	mov	r3,r2
 2012f38:	e0bffb17 	ldw	r2,-20(fp)
 2012f3c:	1886703a 	and	r3,r3,r2
 2012f40:	e0bff917 	ldw	r2,-28(fp)
 2012f44:	1884d83a 	srl	r2,r3,r2
 2012f48:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
 2012f4c:	e0bffc17 	ldw	r2,-16(fp)
 2012f50:	108002a8 	cmpgeui	r2,r2,10
 2012f54:	1000041e 	bne	r2,zero,2012f68 <alt_printf+0x160>
                            c = '0' + digit;
 2012f58:	e0bffc17 	ldw	r2,-16(fp)
 2012f5c:	10800c04 	addi	r2,r2,48
 2012f60:	e0bff805 	stb	r2,-32(fp)
 2012f64:	00000306 	br	2012f74 <alt_printf+0x16c>
                        else
                            c = 'a' + digit - 10;
 2012f68:	e0bffc17 	ldw	r2,-16(fp)
 2012f6c:	108015c4 	addi	r2,r2,87
 2012f70:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
 2012f74:	e0bff807 	ldb	r2,-32(fp)
 2012f78:	1009883a 	mov	r4,r2
 2012f7c:	20130340 	call	2013034 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
 2012f80:	e0bff917 	ldw	r2,-28(fp)
 2012f84:	10bfff04 	addi	r2,r2,-4
 2012f88:	e0bff915 	stw	r2,-28(fp)
 2012f8c:	e0bff917 	ldw	r2,-28(fp)
 2012f90:	103fe50e 	bge	r2,zero,2012f28 <__alt_mem_mem_0+0xfcff2f28>
 2012f94:	00001806 	br	2012ff8 <alt_printf+0x1f0>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
 2012f98:	e0bff807 	ldb	r2,-32(fp)
 2012f9c:	10801cd8 	cmpnei	r2,r2,115
 2012fa0:	1000151e 	bne	r2,zero,2012ff8 <alt_printf+0x1f0>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
 2012fa4:	e0bffe17 	ldw	r2,-8(fp)
 2012fa8:	10c00104 	addi	r3,r2,4
 2012fac:	e0fffe15 	stw	r3,-8(fp)
 2012fb0:	10800017 	ldw	r2,0(r2)
 2012fb4:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
 2012fb8:	00000906 	br	2012fe0 <alt_printf+0x1d8>
                      alt_putchar(*s++);
 2012fbc:	e0bffa17 	ldw	r2,-24(fp)
 2012fc0:	10c00044 	addi	r3,r2,1
 2012fc4:	e0fffa15 	stw	r3,-24(fp)
 2012fc8:	10800003 	ldbu	r2,0(r2)
 2012fcc:	10803fcc 	andi	r2,r2,255
 2012fd0:	1080201c 	xori	r2,r2,128
 2012fd4:	10bfe004 	addi	r2,r2,-128
 2012fd8:	1009883a 	mov	r4,r2
 2012fdc:	20130340 	call	2013034 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
 2012fe0:	e0bffa17 	ldw	r2,-24(fp)
 2012fe4:	10800003 	ldbu	r2,0(r2)
 2012fe8:	10803fcc 	andi	r2,r2,255
 2012fec:	1080201c 	xori	r2,r2,128
 2012ff0:	10bfe004 	addi	r2,r2,-128
 2012ff4:	103ff11e 	bne	r2,zero,2012fbc <__alt_mem_mem_0+0xfcff2fbc>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
 2012ff8:	e0bff717 	ldw	r2,-36(fp)
 2012ffc:	10c00044 	addi	r3,r2,1
 2013000:	e0fff715 	stw	r3,-36(fp)
 2013004:	10800003 	ldbu	r2,0(r2)
 2013008:	e0bff805 	stb	r2,-32(fp)
 201300c:	e0bff807 	ldb	r2,-32(fp)
 2013010:	103f8a1e 	bne	r2,zero,2012e3c <__alt_mem_mem_0+0xfcff2e3c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 2013014:	00000106 	br	201301c <alt_printf+0x214>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
 2013018:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
 201301c:	0001883a 	nop
 2013020:	e037883a 	mov	sp,fp
 2013024:	dfc00117 	ldw	ra,4(sp)
 2013028:	df000017 	ldw	fp,0(sp)
 201302c:	dec00504 	addi	sp,sp,20
 2013030:	f800283a 	ret

02013034 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
 2013034:	defffd04 	addi	sp,sp,-12
 2013038:	dfc00215 	stw	ra,8(sp)
 201303c:	df000115 	stw	fp,4(sp)
 2013040:	df000104 	addi	fp,sp,4
 2013044:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
 2013048:	d0a00117 	ldw	r2,-32764(gp)
 201304c:	10800217 	ldw	r2,8(r2)
 2013050:	100b883a 	mov	r5,r2
 2013054:	e13fff17 	ldw	r4,-4(fp)
 2013058:	203cd2c0 	call	203cd2c <putc>
#endif
#endif
}
 201305c:	e037883a 	mov	sp,fp
 2013060:	dfc00117 	ldw	ra,4(sp)
 2013064:	df000017 	ldw	fp,0(sp)
 2013068:	dec00204 	addi	sp,sp,8
 201306c:	f800283a 	ret

02013070 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 2013070:	defffe04 	addi	sp,sp,-8
 2013074:	df000115 	stw	fp,4(sp)
 2013078:	df000104 	addi	fp,sp,4
 201307c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 2013080:	e0bfff17 	ldw	r2,-4(fp)
 2013084:	108000d0 	cmplti	r2,r2,3
 2013088:	10000d1e 	bne	r2,zero,20130c0 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 201308c:	00808134 	movhi	r2,516
 2013090:	1090e704 	addi	r2,r2,17308
 2013094:	e0ffff17 	ldw	r3,-4(fp)
 2013098:	18c00324 	muli	r3,r3,12
 201309c:	10c5883a 	add	r2,r2,r3
 20130a0:	10800204 	addi	r2,r2,8
 20130a4:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 20130a8:	00808134 	movhi	r2,516
 20130ac:	1090e704 	addi	r2,r2,17308
 20130b0:	e0ffff17 	ldw	r3,-4(fp)
 20130b4:	18c00324 	muli	r3,r3,12
 20130b8:	10c5883a 	add	r2,r2,r3
 20130bc:	10000015 	stw	zero,0(r2)
  }
}
 20130c0:	0001883a 	nop
 20130c4:	e037883a 	mov	sp,fp
 20130c8:	df000017 	ldw	fp,0(sp)
 20130cc:	dec00104 	addi	sp,sp,4
 20130d0:	f800283a 	ret

020130d4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 20130d4:	defff904 	addi	sp,sp,-28
 20130d8:	df000615 	stw	fp,24(sp)
 20130dc:	df000604 	addi	fp,sp,24
 20130e0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20130e4:	0005303a 	rdctl	r2,status
 20130e8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20130ec:	e0fffe17 	ldw	r3,-8(fp)
 20130f0:	00bfff84 	movi	r2,-2
 20130f4:	1884703a 	and	r2,r3,r2
 20130f8:	1001703a 	wrctl	status,r2
  
  return context;
 20130fc:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 2013100:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 2013104:	d0a00b17 	ldw	r2,-32724(gp)
 2013108:	10c000c4 	addi	r3,r2,3
 201310c:	00bfff04 	movi	r2,-4
 2013110:	1884703a 	and	r2,r3,r2
 2013114:	d0a00b15 	stw	r2,-32724(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 2013118:	d0e00b17 	ldw	r3,-32724(gp)
 201311c:	e0bfff17 	ldw	r2,-4(fp)
 2013120:	1887883a 	add	r3,r3,r2
 2013124:	00810034 	movhi	r2,1024
 2013128:	10800004 	addi	r2,r2,0
 201312c:	10c0062e 	bgeu	r2,r3,2013148 <sbrk+0x74>
 2013130:	e0bffb17 	ldw	r2,-20(fp)
 2013134:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2013138:	e0bffa17 	ldw	r2,-24(fp)
 201313c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 2013140:	00bfffc4 	movi	r2,-1
 2013144:	00000b06 	br	2013174 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 2013148:	d0a00b17 	ldw	r2,-32724(gp)
 201314c:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 2013150:	d0e00b17 	ldw	r3,-32724(gp)
 2013154:	e0bfff17 	ldw	r2,-4(fp)
 2013158:	1885883a 	add	r2,r3,r2
 201315c:	d0a00b15 	stw	r2,-32724(gp)
 2013160:	e0bffb17 	ldw	r2,-20(fp)
 2013164:	e0bffc15 	stw	r2,-16(fp)
 2013168:	e0bffc17 	ldw	r2,-16(fp)
 201316c:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 2013170:	e0bffd17 	ldw	r2,-12(fp)
} 
 2013174:	e037883a 	mov	sp,fp
 2013178:	df000017 	ldw	fp,0(sp)
 201317c:	dec00104 	addi	sp,sp,4
 2013180:	f800283a 	ret

02013184 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 2013184:	defffd04 	addi	sp,sp,-12
 2013188:	dfc00215 	stw	ra,8(sp)
 201318c:	df000115 	stw	fp,4(sp)
 2013190:	df000104 	addi	fp,sp,4
 2013194:	e13fff15 	stw	r4,-4(fp)
	if (fd < ALT_MAX_FD)
 2013198:	e0bfff17 	ldw	r2,-4(fp)
 201319c:	10800808 	cmpgei	r2,r2,32
 20131a0:	1000031e 	bne	r2,zero,20131b0 <close+0x2c>
		return ALT_CLOSE (fd);
 20131a4:	e13fff17 	ldw	r4,-4(fp)
 20131a8:	202c50c0 	call	202c50c <alt_close>
 20131ac:	00000206 	br	20131b8 <close+0x34>
#if LWIP_SOCKET
	else
		return lwip_close((long) fd);
 20131b0:	e13fff17 	ldw	r4,-4(fp)
 20131b4:	202da800 	call	202da80 <lwip_close>
#else
	else
		return -1;
#endif
}
 20131b8:	e037883a 	mov	sp,fp
 20131bc:	dfc00117 	ldw	ra,4(sp)
 20131c0:	df000017 	ldw	fp,0(sp)
 20131c4:	dec00204 	addi	sp,sp,8
 20131c8:	f800283a 	ret

020131cc <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 20131cc:	defff904 	addi	sp,sp,-28
 20131d0:	dfc00615 	stw	ra,24(sp)
 20131d4:	df000515 	stw	fp,20(sp)
 20131d8:	df000504 	addi	fp,sp,20
 20131dc:	e13ffd15 	stw	r4,-12(fp)
 20131e0:	e17ffe15 	stw	r5,-8(fp)
 20131e4:	e1bfff15 	stw	r6,-4(fp)
	if (fd < ALT_MAX_FD)
 20131e8:	e0bffd17 	ldw	r2,-12(fp)
 20131ec:	10800808 	cmpgei	r2,r2,32
 20131f0:	1000051e 	bne	r2,zero,2013208 <read+0x3c>
		return ALT_READ (fd, ptr, len);
 20131f4:	e1bfff17 	ldw	r6,-4(fp)
 20131f8:	e17ffe17 	ldw	r5,-8(fp)
 20131fc:	e13ffd17 	ldw	r4,-12(fp)
 2013200:	202ce800 	call	202ce80 <alt_read>
 2013204:	00000706 	br	2013224 <read+0x58>
#if LWIP_SOCKET
	else
		return recvfrom(fd, ptr, len, 0, NULL, NULL);
 2013208:	d8000115 	stw	zero,4(sp)
 201320c:	d8000015 	stw	zero,0(sp)
 2013210:	000f883a 	mov	r7,zero
 2013214:	e1bfff17 	ldw	r6,-4(fp)
 2013218:	e17ffe17 	ldw	r5,-8(fp)
 201321c:	e13ffd17 	ldw	r4,-12(fp)
 2013220:	202dd980 	call	202dd98 <lwip_recvfrom>
#else
	else
		return -1;
#endif
}
 2013224:	e037883a 	mov	sp,fp
 2013228:	dfc00117 	ldw	ra,4(sp)
 201322c:	df000017 	ldw	fp,0(sp)
 2013230:	dec00204 	addi	sp,sp,8
 2013234:	f800283a 	ret

02013238 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 2013238:	defffb04 	addi	sp,sp,-20
 201323c:	dfc00415 	stw	ra,16(sp)
 2013240:	df000315 	stw	fp,12(sp)
 2013244:	df000304 	addi	fp,sp,12
 2013248:	e13ffd15 	stw	r4,-12(fp)
 201324c:	e17ffe15 	stw	r5,-8(fp)
 2013250:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 2013254:	e0bffd17 	ldw	r2,-12(fp)
 2013258:	10800808 	cmpgei	r2,r2,32
 201325c:	1000051e 	bne	r2,zero,2013274 <write+0x3c>
    return ALT_WRITE(fd, ptr, len);
 2013260:	e1bfff17 	ldw	r6,-4(fp)
 2013264:	e17ffe17 	ldw	r5,-8(fp)
 2013268:	e13ffd17 	ldw	r4,-12(fp)
 201326c:	202d1bc0 	call	202d1bc <alt_write>
 2013270:	00000506 	br	2013288 <write+0x50>
#if LWIP_SOCKET
  else
    return send (fd, (void*) ptr, len, 0);
 2013274:	000f883a 	mov	r7,zero
 2013278:	e1bfff17 	ldw	r6,-4(fp)
 201327c:	e17ffe17 	ldw	r5,-8(fp)
 2013280:	e13ffd17 	ldw	r4,-12(fp)
 2013284:	202e30c0 	call	202e30c <lwip_send>
#else
	else
		return -1;
#endif
}
 2013288:	e037883a 	mov	sp,fp
 201328c:	dfc00117 	ldw	ra,4(sp)
 2013290:	df000017 	ldw	fp,0(sp)
 2013294:	dec00204 	addi	sp,sp,8
 2013298:	f800283a 	ret

0201329c <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
 201329c:	defffc04 	addi	sp,sp,-16
 20132a0:	dfc00315 	stw	ra,12(sp)
 20132a4:	df000215 	stw	fp,8(sp)
 20132a8:	df000204 	addi	fp,sp,8
 20132ac:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 20132b0:	e0bfff17 	ldw	r2,-4(fp)
 20132b4:	10800917 	ldw	r2,36(r2)
 20132b8:	e0bffe15 	stw	r2,-8(fp)

	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
 20132bc:	e0bfff17 	ldw	r2,-4(fp)
 20132c0:	00c00184 	movi	r3,6
 20132c4:	10c00c85 	stb	r3,50(r2)

	/* maximum transfer unit */
	netif->mtu = IP_FRAG_MAX_MTU;
 20132c8:	e0bfff17 	ldw	r2,-4(fp)
 20132cc:	00c17704 	movi	r3,1500
 20132d0:	10c00c0d 	sth	r3,48(r2)

	/* device capabilities */
	/* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
	netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
 20132d4:	e0bfff17 	ldw	r2,-4(fp)
 20132d8:	00c00c84 	movi	r3,50
 20132dc:	10c00e45 	stb	r3,57(r2)

	tse_mac_init(netif->num, ethernetif);
 20132e0:	e0bfff17 	ldw	r2,-4(fp)
 20132e4:	10800f03 	ldbu	r2,60(r2)
 20132e8:	10803fcc 	andi	r2,r2,255
 20132ec:	e17ffe17 	ldw	r5,-8(fp)
 20132f0:	1009883a 	mov	r4,r2
 20132f4:	20140d40 	call	20140d4 <tse_mac_init>
}
 20132f8:	0001883a 	nop
 20132fc:	e037883a 	mov	sp,fp
 2013300:	dfc00117 	ldw	ra,4(sp)
 2013304:	df000017 	ldw	fp,0(sp)
 2013308:	dec00204 	addi	sp,sp,8
 201330c:	f800283a 	ret

02013310 <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
 2013310:	defffa04 	addi	sp,sp,-24
 2013314:	dfc00515 	stw	ra,20(sp)
 2013318:	df000415 	stw	fp,16(sp)
 201331c:	df000404 	addi	fp,sp,16
 2013320:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif = netif->state;
 2013324:	e0bfff17 	ldw	r2,-4(fp)
 2013328:	10800917 	ldw	r2,36(r2)
 201332c:	e0bffd15 	stw	r2,-12(fp)
	struct pbuf *p, *nextPkt;

	if(ethernetif->lwipRxCount <= 0)
 2013330:	e0bffd17 	ldw	r2,-12(fp)
 2013334:	10801517 	ldw	r2,84(r2)
 2013338:	00800216 	blt	zero,r2,2013344 <low_level_input+0x34>
		return NULL;
 201333c:	0005883a 	mov	r2,zero
 2013340:	00004306 	br	2013450 <low_level_input+0x140>

	//  Dump current packet if there is no memory for the next packet.
	//  The lwipRxPbuf must contain pointers to pbufs at all times.
	nextPkt = pbuf_alloc(PBUF_RAW,  PBUF_POOL_BUFSIZE, PBUF_POOL);
 2013344:	018000c4 	movi	r6,3
 2013348:	01417b04 	movi	r5,1516
 201334c:	010000c4 	movi	r4,3
 2013350:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2013354:	e0bffe15 	stw	r2,-8(fp)
	if(nextPkt == NULL)
 2013358:	e0bffe17 	ldw	r2,-8(fp)
 201335c:	1000101e 	bne	r2,zero,20133a0 <low_level_input+0x90>
	{
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("no pbuf available\n"));

		LINK_STATS_INC(link.memerr);
 2013360:	008085f4 	movhi	r2,535
 2013364:	10a8bc04 	addi	r2,r2,-23824
 2013368:	10800617 	ldw	r2,24(r2)
 201336c:	10c00044 	addi	r3,r2,1
 2013370:	008085f4 	movhi	r2,535
 2013374:	10a8bc04 	addi	r2,r2,-23824
 2013378:	10c00615 	stw	r3,24(r2)
		LINK_STATS_INC(link.drop);
 201337c:	008085f4 	movhi	r2,535
 2013380:	10a8bc04 	addi	r2,r2,-23824
 2013384:	10800317 	ldw	r2,12(r2)
 2013388:	10c00044 	addi	r3,r2,1
 201338c:	008085f4 	movhi	r2,535
 2013390:	10a8bc04 	addi	r2,r2,-23824
 2013394:	10c00315 	stw	r3,12(r2)
		return NULL;
 2013398:	0005883a 	mov	r2,zero
 201339c:	00002c06 	br	2013450 <low_level_input+0x140>
	}

	nextPkt = (void*)(((alt_u32)nextPkt));
	nextPkt->payload = (void*)(((alt_u32)nextPkt->payload));
 20133a0:	e0bffe17 	ldw	r2,-8(fp)
 20133a4:	10c00117 	ldw	r3,4(r2)
 20133a8:	e0bffe17 	ldw	r2,-8(fp)
 20133ac:	10c00115 	stw	r3,4(r2)

	enh_alt_irq_disable_all();
 20133b0:	202bf880 	call	202bf88 <enh_alt_irq_disable_all>

	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex];
 20133b4:	e0bffd17 	ldw	r2,-12(fp)
 20133b8:	10801417 	ldw	r2,80(r2)
 20133bc:	e0fffd17 	ldw	r3,-12(fp)
 20133c0:	108001c4 	addi	r2,r2,7
 20133c4:	1085883a 	add	r2,r2,r2
 20133c8:	1085883a 	add	r2,r2,r2
 20133cc:	1885883a 	add	r2,r3,r2
 20133d0:	10800017 	ldw	r2,0(r2)
 20133d4:	e0bffc15 	stw	r2,-16(fp)
	ethernetif->lwipRxPbuf[ethernetif->lwipRxIndex] = nextPkt;
 20133d8:	e0bffd17 	ldw	r2,-12(fp)
 20133dc:	10801417 	ldw	r2,80(r2)
 20133e0:	e0fffd17 	ldw	r3,-12(fp)
 20133e4:	108001c4 	addi	r2,r2,7
 20133e8:	1085883a 	add	r2,r2,r2
 20133ec:	1085883a 	add	r2,r2,r2
 20133f0:	1885883a 	add	r2,r3,r2
 20133f4:	e0fffe17 	ldw	r3,-8(fp)
 20133f8:	10c00015 	stw	r3,0(r2)
	if(++ethernetif->lwipRxIndex >= LWIP_RX_ETH_BUFFER)
 20133fc:	e0bffd17 	ldw	r2,-12(fp)
 2013400:	10801417 	ldw	r2,80(r2)
 2013404:	10800044 	addi	r2,r2,1
 2013408:	e0fffd17 	ldw	r3,-12(fp)
 201340c:	18801415 	stw	r2,80(r3)
 2013410:	10800310 	cmplti	r2,r2,12
 2013414:	1000021e 	bne	r2,zero,2013420 <low_level_input+0x110>
		ethernetif->lwipRxIndex = 0;
 2013418:	e0bffd17 	ldw	r2,-12(fp)
 201341c:	10001415 	stw	zero,80(r2)

	--ethernetif->lwipRxCount;
 2013420:	e0bffd17 	ldw	r2,-12(fp)
 2013424:	10801517 	ldw	r2,84(r2)
 2013428:	10ffffc4 	addi	r3,r2,-1
 201342c:	e0bffd17 	ldw	r2,-12(fp)
 2013430:	10c01515 	stw	r3,84(r2)

	enh_alt_irq_enable_all();
 2013434:	202bfd80 	call	202bfd8 <enh_alt_irq_enable_all>

	LWIP_ASSERT("low_level_input: pbuf in rx buffer is NULL", p != NULL );
	LWIP_ASSERT("low_level_input: pbuf->len in rx buffer is 0", p->len != 0 );

	if( p->len == 0 )
 2013438:	e0bffc17 	ldw	r2,-16(fp)
 201343c:	1080028b 	ldhu	r2,10(r2)
 2013440:	10bfffcc 	andi	r2,r2,65535
 2013444:	1000011e 	bne	r2,zero,201344c <low_level_input+0x13c>
		p = NULL;
 2013448:	e03ffc15 	stw	zero,-16(fp)

	return p;
 201344c:	e0bffc17 	ldw	r2,-16(fp)
}
 2013450:	e037883a 	mov	sp,fp
 2013454:	dfc00117 	ldw	ra,4(sp)
 2013458:	df000017 	ldw	fp,0(sp)
 201345c:	dec00204 	addi	sp,sp,8
 2013460:	f800283a 	ret

02013464 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
int
ethernetif_input(struct netif *netif)
{
 2013464:	defffa04 	addi	sp,sp,-24
 2013468:	dfc00515 	stw	ra,20(sp)
 201346c:	df000415 	stw	fp,16(sp)
 2013470:	df000404 	addi	fp,sp,16
 2013474:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;
	struct eth_hdr *ethhdr;
	struct pbuf *p;

	ethernetif = netif->state;
 2013478:	e0bfff17 	ldw	r2,-4(fp)
 201347c:	10800917 	ldw	r2,36(r2)
 2013480:	e0bffc15 	stw	r2,-16(fp)

	/* move received packet into a new pbuf */
	p = low_level_input(netif);
 2013484:	e13fff17 	ldw	r4,-4(fp)
 2013488:	20133100 	call	2013310 <low_level_input>
 201348c:	e0bffd15 	stw	r2,-12(fp)

	/* no packet could be read, silently ignore this */
	if (p == NULL) return -1;
 2013490:	e0bffd17 	ldw	r2,-12(fp)
 2013494:	1000021e 	bne	r2,zero,20134a0 <ethernetif_input+0x3c>
 2013498:	00bfffc4 	movi	r2,-1
 201349c:	00002b06 	br	201354c <ethernetif_input+0xe8>

	/* points to packet payload, which starts with an Ethernet header */
	ethhdr = p->payload;
 20134a0:	e0bffd17 	ldw	r2,-12(fp)
 20134a4:	10800117 	ldw	r2,4(r2)
 20134a8:	e0bffe15 	stw	r2,-8(fp)

	LINK_STATS_INC(link.recv);
 20134ac:	008085f4 	movhi	r2,535
 20134b0:	10a8bc04 	addi	r2,r2,-23824
 20134b4:	10800117 	ldw	r2,4(r2)
 20134b8:	10c00044 	addi	r3,r2,1
 20134bc:	008085f4 	movhi	r2,535
 20134c0:	10a8bc04 	addi	r2,r2,-23824
 20134c4:	10c00115 	stw	r3,4(r2)
		pbuf_free(p);
		p = NULL;
		break;
	}
#else
	switch (htons(ethhdr->type)) {
 20134c8:	e0bffe17 	ldw	r2,-8(fp)
 20134cc:	10c00383 	ldbu	r3,14(r2)
 20134d0:	108003c3 	ldbu	r2,15(r2)
 20134d4:	1004923a 	slli	r2,r2,8
 20134d8:	10c4b03a 	or	r2,r2,r3
 20134dc:	10bfffcc 	andi	r2,r2,65535
 20134e0:	1004d23a 	srli	r2,r2,8
 20134e4:	10ffffcc 	andi	r3,r2,65535
 20134e8:	e0bffe17 	ldw	r2,-8(fp)
 20134ec:	11000383 	ldbu	r4,14(r2)
 20134f0:	108003c3 	ldbu	r2,15(r2)
 20134f4:	1004923a 	slli	r2,r2,8
 20134f8:	1104b03a 	or	r2,r2,r4
 20134fc:	10bfffcc 	andi	r2,r2,65535
 2013500:	1004923a 	slli	r2,r2,8
 2013504:	10bfffcc 	andi	r2,r2,65535
 2013508:	1884b03a 	or	r2,r3,r2
 201350c:	10c20020 	cmpeqi	r3,r2,2048
 2013510:	1800021e 	bne	r3,zero,201351c <ethernetif_input+0xb8>
 2013514:	108201a0 	cmpeqi	r2,r2,2054
 2013518:	10000626 	beq	r2,zero,2013534 <ethernetif_input+0xd0>
#if PPPOE_SUPPORT
	/* PPPoE packet? */
	case ETHTYPE_PPPOEDISC:
	case ETHTYPE_PPPOE:
#endif /* PPPOE_SUPPORT */
		netif->input(p, netif);
 201351c:	e0bfff17 	ldw	r2,-4(fp)
 2013520:	10800417 	ldw	r2,16(r2)
 2013524:	e17fff17 	ldw	r5,-4(fp)
 2013528:	e13ffd17 	ldw	r4,-12(fp)
 201352c:	103ee83a 	callr	r2
		break;
 2013530:	00000406 	br	2013544 <ethernetif_input+0xe0>

	default:
		pbuf_free( p );
 2013534:	e13ffd17 	ldw	r4,-12(fp)
 2013538:	201ab680 	call	201ab68 <pbuf_free>
		p = NULL;
 201353c:	e03ffd15 	stw	zero,-12(fp)
		break;
 2013540:	0001883a 	nop
	}
#endif

	// return the waiting packet count
	return ethernetif->lwipRxCount;
 2013544:	e0bffc17 	ldw	r2,-16(fp)
 2013548:	10801517 	ldw	r2,84(r2)
}
 201354c:	e037883a 	mov	sp,fp
 2013550:	dfc00117 	ldw	ra,4(sp)
 2013554:	df000017 	ldw	fp,0(sp)
 2013558:	dec00204 	addi	sp,sp,8
 201355c:	f800283a 	ret

02013560 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 2013560:	defff904 	addi	sp,sp,-28
 2013564:	dfc00615 	stw	ra,24(sp)
 2013568:	df000515 	stw	fp,20(sp)
 201356c:	df000504 	addi	fp,sp,20
 2013570:	e13fff15 	stw	r4,-4(fp)
	err_t tse_mac_raw_send(struct netif *netif, struct pbuf *p);
	char *tmpptr;

	LWIP_ASSERT("netif != NULL", (netif != NULL));

	ethernetif = mem_malloc(sizeof(struct ethernetif));
 2013574:	01001804 	movi	r4,96
 2013578:	20196b40 	call	20196b4 <mem_malloc>
 201357c:	e0bffc15 	stw	r2,-16(fp)
	if (ethernetif == NULL) {
 2013580:	e0bffc17 	ldw	r2,-16(fp)
 2013584:	1000021e 	bne	r2,zero,2013590 <ethernetif_init+0x30>
		LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("ethernetif_init: out of memory\n"));
		return ERR_MEM;
 2013588:	00bfffc4 	movi	r2,-1
 201358c:	00005b06 	br	20136fc <ethernetif_init+0x19c>
	}

#if LWIP_NETIF_HOSTNAME
	/* Initialize interface hostname */
	if (get_hostname(netif->num, (const char**)&tmpptr) == ERR_OK)
 2013590:	e0bfff17 	ldw	r2,-4(fp)
 2013594:	10800f03 	ldbu	r2,60(r2)
 2013598:	10803fcc 	andi	r2,r2,255
 201359c:	e0fffe04 	addi	r3,fp,-8
 20135a0:	180b883a 	mov	r5,r3
 20135a4:	1009883a 	mov	r4,r2
 20135a8:	20009f80 	call	20009f8 <get_hostname>
 20135ac:	1000041e 	bne	r2,zero,20135c0 <ethernetif_init+0x60>
		netif->hostname = tmpptr;
 20135b0:	e0fffe17 	ldw	r3,-8(fp)
 20135b4:	e0bfff17 	ldw	r2,-4(fp)
 20135b8:	10c00b15 	stw	r3,44(r2)
 20135bc:	00000406 	br	20135d0 <ethernetif_init+0x70>
	else
		netif->hostname = "lwip";
 20135c0:	e0ffff17 	ldw	r3,-4(fp)
 20135c4:	00808134 	movhi	r2,516
 20135c8:	10848104 	addi	r2,r2,4612
 20135cc:	18800b15 	stw	r2,44(r3)
	 * of bits per second.
	 */
	NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, LINK_SPEED_OF_YOUR_NETIF_IN_BPS);

	// pointer abuse, don't worry ;)
	netif->state = ethernetif;
 20135d0:	e0bfff17 	ldw	r2,-4(fp)
 20135d4:	e0fffc17 	ldw	r3,-16(fp)
 20135d8:	10c00915 	stw	r3,36(r2)
	if (get_iface_name(netif->num, (char*)&tmpptr) == ERR_OK) {
 20135dc:	e0bfff17 	ldw	r2,-4(fp)
 20135e0:	10800f03 	ldbu	r2,60(r2)
 20135e4:	10803fcc 	andi	r2,r2,255
 20135e8:	e0fffe04 	addi	r3,fp,-8
 20135ec:	180b883a 	mov	r5,r3
 20135f0:	1009883a 	mov	r4,r2
 20135f4:	2000a300 	call	2000a30 <get_iface_name>
 20135f8:	1000081e 	bne	r2,zero,201361c <ethernetif_init+0xbc>
		netif->name[0] = ((char*)&tmpptr)[0];
 20135fc:	e0bffe04 	addi	r2,fp,-8
 2013600:	10c00003 	ldbu	r3,0(r2)
 2013604:	e0bfff17 	ldw	r2,-4(fp)
 2013608:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = ((char*)&tmpptr)[1];
 201360c:	e0fffe43 	ldbu	r3,-7(fp)
 2013610:	e0bfff17 	ldw	r2,-4(fp)
 2013614:	10c00ec5 	stb	r3,59(r2)
 2013618:	00000606 	br	2013634 <ethernetif_init+0xd4>
	} else {
		netif->name[0] = 'e';
 201361c:	e0bfff17 	ldw	r2,-4(fp)
 2013620:	00c01944 	movi	r3,101
 2013624:	10c00e85 	stb	r3,58(r2)
		netif->name[1] = 't';
 2013628:	e0bfff17 	ldw	r2,-4(fp)
 201362c:	00c01d04 	movi	r3,116
 2013630:	10c00ec5 	stb	r3,59(r2)

	/* We directly use etharp_output() here to save a function call.
	 * You can instead declare your own function an call etharp_output()
	 * from it if you have to do some checks before sending (e.g. if link
	 * is available...) */
	netif->output = etharp_output;
 2013634:	e0ffff17 	ldw	r3,-4(fp)
 2013638:	008080b4 	movhi	r2,514
 201363c:	108e9704 	addi	r2,r2,14940
 2013640:	18800515 	stw	r2,20(r3)
	netif->linkoutput = tse_mac_raw_send;
 2013644:	e0ffff17 	ldw	r3,-4(fp)
 2013648:	00808074 	movhi	r2,513
 201364c:	10929604 	addi	r2,r2,19032
 2013650:	18800615 	stw	r2,24(r3)

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
 2013654:	e0bfff17 	ldw	r2,-4(fp)
 2013658:	10c00cc4 	addi	r3,r2,51
 201365c:	e0bffc17 	ldw	r2,-16(fp)
 2013660:	10c00015 	stw	r3,0(r2)

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 2013664:	e03ffb15 	stw	zero,-20(fp)
 2013668:	00001806 	br	20136cc <ethernetif_init+0x16c>
	{
		p = pbuf_alloc(PBUF_RAW, PBUF_POOL_BUFSIZE, PBUF_POOL);
 201366c:	018000c4 	movi	r6,3
 2013670:	01417b04 	movi	r5,1516
 2013674:	010000c4 	movi	r4,3
 2013678:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201367c:	e0bffd15 	stw	r2,-12(fp)
		if (p == NULL)
 2013680:	e0bffd17 	ldw	r2,-12(fp)
 2013684:	1000021e 	bne	r2,zero,2013690 <ethernetif_init+0x130>
			return ERR_MEM;
 2013688:	00bfffc4 	movi	r2,-1
 201368c:	00001b06 	br	20136fc <ethernetif_init+0x19c>
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
 2013690:	e0bffd17 	ldw	r2,-12(fp)
 2013694:	10c00117 	ldw	r3,4(r2)
 2013698:	e0bffd17 	ldw	r2,-12(fp)
 201369c:	10c00115 	stw	r3,4(r2)
		ethernetif->lwipRxPbuf[idx] = p;
 20136a0:	e0fffc17 	ldw	r3,-16(fp)
 20136a4:	e0bffb17 	ldw	r2,-20(fp)
 20136a8:	108001c4 	addi	r2,r2,7
 20136ac:	1085883a 	add	r2,r2,r2
 20136b0:	1085883a 	add	r2,r2,r2
 20136b4:	1885883a 	add	r2,r3,r2
 20136b8:	e0fffd17 	ldw	r3,-12(fp)
 20136bc:	10c00015 	stw	r3,0(r2)
	netif->linkoutput = tse_mac_raw_send;

	ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);

	/* initialize the rx buffer for access by the TSE ISR */
	for(idx = 0; idx < LWIP_RX_ETH_BUFFER; ++idx)
 20136c0:	e0bffb17 	ldw	r2,-20(fp)
 20136c4:	10800044 	addi	r2,r2,1
 20136c8:	e0bffb15 	stw	r2,-20(fp)
 20136cc:	e0bffb17 	ldw	r2,-20(fp)
 20136d0:	10800310 	cmplti	r2,r2,12
 20136d4:	103fe51e 	bne	r2,zero,201366c <__alt_mem_mem_0+0xfcff366c>
			return ERR_MEM;
		p = (void*)(((alt_u32) p));
		p->payload = (void*)(((alt_u32) p->payload));
		ethernetif->lwipRxPbuf[idx] = p;
	}
	ethernetif->lwipRxCount = 0;
 20136d8:	e0bffc17 	ldw	r2,-16(fp)
 20136dc:	10001515 	stw	zero,84(r2)
	ethernetif->lwipRxIndex = 0;
 20136e0:	e0bffc17 	ldw	r2,-16(fp)
 20136e4:	10001415 	stw	zero,80(r2)
	ethernetif->lwipRxIndexIsr = 0;
 20136e8:	e0bffc17 	ldw	r2,-16(fp)
 20136ec:	10001315 	stw	zero,76(r2)

	/* initialize the low level hardware */
	low_level_init(netif);
 20136f0:	e13fff17 	ldw	r4,-4(fp)
 20136f4:	201329c0 	call	201329c <low_level_init>

	return ERR_OK;
 20136f8:	0005883a 	mov	r2,zero
}
 20136fc:	e037883a 	mov	sp,fp
 2013700:	dfc00117 	ldw	ra,4(sp)
 2013704:	df000017 	ldw	fp,0(sp)
 2013708:	dec00204 	addi	sp,sp,8
 201370c:	f800283a 	ret

02013710 <lwip_initialize>:
}
#endif

// Function which initializes the LwIP TCP/IP stack
void lwip_initialize(int waitForAll)
{
 2013710:	defffa04 	addi	sp,sp,-24
 2013714:	dfc00515 	stw	ra,20(sp)
 2013718:	df000415 	stw	fp,16(sp)
 201371c:	df000404 	addi	fp,sp,16
 2013720:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int upCount = 0;
 2013724:	e03ffd15 	stw	zero,-12(fp)
	int activeCount = 0;
 2013728:	e03ffe15 	stw	zero,-8(fp)
		return;
	}
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);
 201372c:	000b883a 	mov	r5,zero
 2013730:	01008074 	movhi	r4,513
 2013734:	210e2c04 	addi	r4,r4,14512
 2013738:	2030b280 	call	2030b28 <tcpip_init>

	for (idx = 0; idx < PHY_COUNT; ++idx)
 201373c:	e03ffc15 	stw	zero,-16(fp)
 2013740:	00000906 	br	2013768 <lwip_initialize+0x58>
		if (is_interface_active(idx))
 2013744:	e13ffc17 	ldw	r4,-16(fp)
 2013748:	2000a780 	call	2000a78 <is_interface_active>
 201374c:	10000326 	beq	r2,zero,201375c <lwip_initialize+0x4c>
			++activeCount;
 2013750:	e0bffe17 	ldw	r2,-8(fp)
 2013754:	10800044 	addi	r2,r2,1
 2013758:	e0bffe15 	stw	r2,-8(fp)
#endif

	// Initialize the TCP/IP stack and give our configuration function as callback
	tcpip_init(lwip_handle_interfaces, NULL);

	for (idx = 0; idx < PHY_COUNT; ++idx)
 201375c:	e0bffc17 	ldw	r2,-16(fp)
 2013760:	10800044 	addi	r2,r2,1
 2013764:	e0bffc15 	stw	r2,-16(fp)
 2013768:	e0bffc17 	ldw	r2,-16(fp)
 201376c:	00bff50e 	bge	zero,r2,2013744 <__alt_mem_mem_0+0xfcff3744>
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 2013770:	00001d06 	br	20137e8 <lwip_initialize+0xd8>
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 2013774:	e03ffc15 	stw	zero,-16(fp)
 2013778:	00001706 	br	20137d8 <lwip_initialize+0xc8>
		{
			if (is_interface_active(idx) && netif_is_up(&eth_tse[idx]))
 201377c:	e13ffc17 	ldw	r4,-16(fp)
 2013780:	2000a780 	call	2000a78 <is_interface_active>
 2013784:	10001126 	beq	r2,zero,20137cc <lwip_initialize+0xbc>
 2013788:	008085b4 	movhi	r2,534
 201378c:	10889004 	addi	r2,r2,8768
 2013790:	e0fffc17 	ldw	r3,-16(fp)
 2013794:	18c01124 	muli	r3,r3,68
 2013798:	10c5883a 	add	r2,r2,r3
 201379c:	10800e44 	addi	r2,r2,57
 20137a0:	10800003 	ldbu	r2,0(r2)
 20137a4:	10803fcc 	andi	r2,r2,255
 20137a8:	1080004c 	andi	r2,r2,1
 20137ac:	10000726 	beq	r2,zero,20137cc <lwip_initialize+0xbc>
			{
				printf("[lwip_eth%d] up\r\n", idx);
 20137b0:	e17ffc17 	ldw	r5,-16(fp)
 20137b4:	01008134 	movhi	r4,516
 20137b8:	21048304 	addi	r4,r4,4620
 20137bc:	2000bb00 	call	2000bb0 <printf>
				++upCount;
 20137c0:	e0bffd17 	ldw	r2,-12(fp)
 20137c4:	10800044 	addi	r2,r2,1
 20137c8:	e0bffd15 	stw	r2,-12(fp)
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
	{
		for (idx = 0; idx < PHY_COUNT; ++idx)
 20137cc:	e0bffc17 	ldw	r2,-16(fp)
 20137d0:	10800044 	addi	r2,r2,1
 20137d4:	e0bffc15 	stw	r2,-16(fp)
 20137d8:	e0bffc17 	ldw	r2,-16(fp)
 20137dc:	00bfe70e 	bge	zero,r2,201377c <__alt_mem_mem_0+0xfcff377c>
				printf("[lwip_eth%d] up\r\n", idx);
				++upCount;
			}
		}

		mssleep(10);
 20137e0:	0109c404 	movi	r4,10000
 20137e4:	202d1500 	call	202d150 <usleep>
	for (idx = 0; idx < PHY_COUNT; ++idx)
		if (is_interface_active(idx))
			++activeCount;

	// Wait for the network to get up
	while ((waitForAll && activeCount != upCount) || (!waitForAll && !upCount))
 20137e8:	e0bfff17 	ldw	r2,-4(fp)
 20137ec:	10000326 	beq	r2,zero,20137fc <lwip_initialize+0xec>
 20137f0:	e0fffe17 	ldw	r3,-8(fp)
 20137f4:	e0bffd17 	ldw	r2,-12(fp)
 20137f8:	18bfde1e 	bne	r3,r2,2013774 <__alt_mem_mem_0+0xfcff3774>
 20137fc:	e0bfff17 	ldw	r2,-4(fp)
 2013800:	1000021e 	bne	r2,zero,201380c <lwip_initialize+0xfc>
 2013804:	e0bffd17 	ldw	r2,-12(fp)
 2013808:	103fda26 	beq	r2,zero,2013774 <__alt_mem_mem_0+0xfcff3774>
			}
		}

		mssleep(10);
	}
}
 201380c:	0001883a 	nop
 2013810:	e037883a 	mov	sp,fp
 2013814:	dfc00117 	ldw	ra,4(sp)
 2013818:	df000017 	ldw	fp,0(sp)
 201381c:	dec00204 	addi	sp,sp,8
 2013820:	f800283a 	ret

02013824 <lwip_wait_for_an>:
#endif

#define MAX_RETRY_COUNT			3

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
 2013824:	defffb04 	addi	sp,sp,-20
 2013828:	dfc00415 	stw	ra,16(sp)
 201382c:	df000315 	stw	fp,12(sp)
 2013830:	df000304 	addi	fp,sp,12
 2013834:	e13ffe15 	stw	r4,-8(fp)
 2013838:	e17fff15 	stw	r5,-4(fp)
	int retryCount = MAX_RETRY_COUNT;
 201383c:	008000c4 	movi	r2,3
 2013840:	e0bffd15 	stw	r2,-12(fp)

	while (ethernetif->link_alive != 1 && --retryCount) {
 2013844:	00000b06 	br	2013874 <lwip_wait_for_an+0x50>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
 2013848:	00c000c4 	movi	r3,3
 201384c:	e0bffd17 	ldw	r2,-12(fp)
 2013850:	1887c83a 	sub	r3,r3,r2
 2013854:	008000b4 	movhi	r2,2
 2013858:	10a1a804 	addi	r2,r2,-31072
 201385c:	1885383a 	mul	r2,r3,r2
 2013860:	1009883a 	mov	r4,r2
 2013864:	202d1500 	call	202d150 <usleep>
		tse_mac_init(idx, ethernetif);
 2013868:	e17fff17 	ldw	r5,-4(fp)
 201386c:	e13ffe17 	ldw	r4,-8(fp)
 2013870:	20140d40 	call	20140d4 <tse_mac_init>

int lwip_wait_for_an(int idx, struct ethernetif *ethernetif)
{
	int retryCount = MAX_RETRY_COUNT;

	while (ethernetif->link_alive != 1 && --retryCount) {
 2013874:	e0bfff17 	ldw	r2,-4(fp)
 2013878:	10800217 	ldw	r2,8(r2)
 201387c:	10800060 	cmpeqi	r2,r2,1
 2013880:	1000051e 	bne	r2,zero,2013898 <lwip_wait_for_an+0x74>
 2013884:	e0bffd17 	ldw	r2,-12(fp)
 2013888:	10bfffc4 	addi	r2,r2,-1
 201388c:	e0bffd15 	stw	r2,-12(fp)
 2013890:	e0bffd17 	ldw	r2,-12(fp)
 2013894:	103fec1e 	bne	r2,zero,2013848 <__alt_mem_mem_0+0xfcff3848>
		mssleep(100 * (MAX_RETRY_COUNT - retryCount));
		tse_mac_init(idx, ethernetif);
	}

	return retryCount;
 2013898:	e0bffd17 	ldw	r2,-12(fp)
}
 201389c:	e037883a 	mov	sp,fp
 20138a0:	dfc00117 	ldw	ra,4(sp)
 20138a4:	df000017 	ldw	fp,0(sp)
 20138a8:	dec00204 	addi	sp,sp,8
 20138ac:	f800283a 	ret

020138b0 <lwip_handle_interfaces>:

void lwip_handle_interfaces(__unused void *params)
{
 20138b0:	deffe904 	addi	sp,sp,-92
 20138b4:	dfc01615 	stw	ra,88(sp)
 20138b8:	df001515 	stw	fp,84(sp)
 20138bc:	df001504 	addi	fp,sp,84
 20138c0:	e13fff15 	stw	r4,-4(fp)
	int idx;
	int active_macs = 0;
 20138c4:	e03fef15 	stw	zero,-68(fp)
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
 20138c8:	e03ffb15 	stw	zero,-20(fp)
 20138cc:	e03ffc15 	stw	zero,-16(fp)
 20138d0:	e03ffd15 	stw	zero,-12(fp)
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 20138d4:	e03fee15 	stw	zero,-72(fp)
 20138d8:	00008406 	br	2013aec <lwip_handle_interfaces+0x23c>
	{
		struct netif *eth = &eth_tse[idx];
 20138dc:	e0bfee17 	ldw	r2,-72(fp)
 20138e0:	10c01124 	muli	r3,r2,68
 20138e4:	008085b4 	movhi	r2,534
 20138e8:	10889004 	addi	r2,r2,8768
 20138ec:	1885883a 	add	r2,r3,r2
 20138f0:	e0bff015 	stw	r2,-64(fp)

		// Load platform specific MAC address into netif
		if (get_mac_addr(idx, eth, eth->hwaddr) != EXIT_SUCCESS)
 20138f4:	e0bff017 	ldw	r2,-64(fp)
 20138f8:	10800cc4 	addi	r2,r2,51
 20138fc:	100d883a 	mov	r6,r2
 2013900:	e17ff017 	ldw	r5,-64(fp)
 2013904:	e13fee17 	ldw	r4,-72(fp)
 2013908:	20008240 	call	2000824 <get_mac_addr>
 201390c:	10000326 	beq	r2,zero,201391c <lwip_handle_interfaces+0x6c>
			printf("[LwIP] Failed to get MAC address\n");
 2013910:	01008134 	movhi	r4,516
 2013914:	21048804 	addi	r4,r4,4640
 2013918:	203ceb40 	call	203ceb4 <puts>

		// Get the requested IP configuration for the given interface
		if (get_ip_addr(idx, &ip, &subnet, &gateway, &dhcp) != EXIT_SUCCESS)
 201391c:	e17ffd04 	addi	r5,fp,-12
 2013920:	e13ffc04 	addi	r4,fp,-16
 2013924:	e0fffb04 	addi	r3,fp,-20
 2013928:	e0bffe04 	addi	r2,fp,-8
 201392c:	d8800015 	stw	r2,0(sp)
 2013930:	280f883a 	mov	r7,r5
 2013934:	200d883a 	mov	r6,r4
 2013938:	180b883a 	mov	r5,r3
 201393c:	e13fee17 	ldw	r4,-72(fp)
 2013940:	20009400 	call	2000940 <get_ip_addr>
 2013944:	10000326 	beq	r2,zero,2013954 <lwip_handle_interfaces+0xa4>
			printf("[LwIP] Failed to get IP config\n");
 2013948:	01008134 	movhi	r4,516
 201394c:	21049104 	addi	r4,r4,4676
 2013950:	203ceb40 	call	203ceb4 <puts>

		//  Initialize lwIP, Altera TSE and the ethernetif
#if NO_SYS
		if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, ethernet_input) == NULL)
#else
			if (netif_add(eth, &ip, &subnet, &gateway, eth->state, ethernetif_init, tcpip_input) == NULL)
 2013954:	e0bff017 	ldw	r2,-64(fp)
 2013958:	10c00917 	ldw	r3,36(r2)
 201395c:	e1bffd04 	addi	r6,fp,-12
 2013960:	e17ffc04 	addi	r5,fp,-16
 2013964:	e13ffb04 	addi	r4,fp,-20
 2013968:	008080f4 	movhi	r2,515
 201396c:	1081c904 	addi	r2,r2,1828
 2013970:	d8800215 	stw	r2,8(sp)
 2013974:	00808074 	movhi	r2,513
 2013978:	108d5804 	addi	r2,r2,13664
 201397c:	d8800115 	stw	r2,4(sp)
 2013980:	d8c00015 	stw	r3,0(sp)
 2013984:	300f883a 	mov	r7,r6
 2013988:	280d883a 	mov	r6,r5
 201398c:	200b883a 	mov	r5,r4
 2013990:	e13ff017 	ldw	r4,-64(fp)
 2013994:	2019a7c0 	call	2019a7c <netif_add>
 2013998:	1000051e 	bne	r2,zero,20139b0 <lwip_handle_interfaces+0x100>
#endif
			{
				printf("[eth%d] Fatal error initializing...\n", idx);
 201399c:	e17fee17 	ldw	r5,-72(fp)
 20139a0:	01008134 	movhi	r4,516
 20139a4:	21049904 	addi	r4,r4,4708
 20139a8:	2000bb00 	call	2000bb0 <printf>
				for(;;) ;
 20139ac:	003fff06 	br	20139ac <__alt_mem_mem_0+0xfcff39ac>
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
 20139b0:	e13fee17 	ldw	r4,-72(fp)
 20139b4:	2000a780 	call	2000a78 <is_interface_active>
 20139b8:	10004826 	beq	r2,zero,2013adc <lwip_handle_interfaces+0x22c>
			continue;

		// update the active phy count
		++active_macs;
 20139bc:	e0bfef17 	ldw	r2,-68(fp)
 20139c0:	10800044 	addi	r2,r2,1
 20139c4:	e0bfef15 	stw	r2,-68(fp)

		if (active_macs == 1)
 20139c8:	e0bfef17 	ldw	r2,-68(fp)
 20139cc:	10800058 	cmpnei	r2,r2,1
 20139d0:	1000021e 	bne	r2,zero,20139dc <lwip_handle_interfaces+0x12c>
			netif_set_default(eth);
 20139d4:	e13ff017 	ldw	r4,-64(fp)
 20139d8:	2019f380 	call	2019f38 <netif_set_default>

		// Set status and link callback (link is not working?)
		netif_set_status_callback(eth, lwip_status_callback);
 20139dc:	01408074 	movhi	r5,513
 20139e0:	294fa904 	addi	r5,r5,16036
 20139e4:	e13ff017 	ldw	r4,-64(fp)
 20139e8:	201a0a80 	call	201a0a8 <netif_set_status_callback>

		if (link_callback)
 20139ec:	d0a7e917 	ldw	r2,-24668(gp)
 20139f0:	10000426 	beq	r2,zero,2013a04 <lwip_handle_interfaces+0x154>
			netif_set_link_callback(eth, link_callback);
 20139f4:	d0a7e917 	ldw	r2,-24668(gp)
 20139f8:	100b883a 	mov	r5,r2
 20139fc:	e13ff017 	ldw	r4,-64(fp)
 2013a00:	201a2200 	call	201a220 <netif_set_link_callback>

		// Initialize Altera TSE in a loop if waiting for a link
		printf("Waiting for link... ");
 2013a04:	01008134 	movhi	r4,516
 2013a08:	2104a304 	addi	r4,r4,4748
 2013a0c:	2000bb00 	call	2000bb0 <printf>
		if (lwip_wait_for_an(idx, eth->state) < 0) {
 2013a10:	e0bff017 	ldw	r2,-64(fp)
 2013a14:	10800917 	ldw	r2,36(r2)
 2013a18:	100b883a 	mov	r5,r2
 2013a1c:	e13fee17 	ldw	r4,-72(fp)
 2013a20:	20138240 	call	2013824 <lwip_wait_for_an>
 2013a24:	1000040e 	bge	r2,zero,2013a38 <lwip_handle_interfaces+0x188>
			printf("FAILED\n");
 2013a28:	01008134 	movhi	r4,516
 2013a2c:	2104a904 	addi	r4,r4,4772
 2013a30:	203ceb40 	call	203ceb4 <puts>
			continue;
 2013a34:	00002a06 	br	2013ae0 <lwip_handle_interfaces+0x230>
		}

		printf("OK\n");
 2013a38:	01008134 	movhi	r4,516
 2013a3c:	2104ab04 	addi	r4,r4,4780
 2013a40:	203ceb40 	call	203ceb4 <puts>

		// create input output task and start DHCP or static w/e
		snprintf(tmpbuf, OS_MAX_TASK_NAME_LEN, "LwIP %*sih", 2, eth->name);
 2013a44:	e0bff017 	ldw	r2,-64(fp)
 2013a48:	10800e84 	addi	r2,r2,58
 2013a4c:	e0fff104 	addi	r3,fp,-60
 2013a50:	d8800015 	stw	r2,0(sp)
 2013a54:	01c00084 	movi	r7,2
 2013a58:	01808134 	movhi	r6,516
 2013a5c:	3184ac04 	addi	r6,r6,4784
 2013a60:	01400a04 	movi	r5,40
 2013a64:	1809883a 	mov	r4,r3
 2013a68:	203cfa00 	call	203cfa0 <snprintf>
		tmpbuf[(OS_MAX_TASK_NAME_LEN - 1)] = 0;
 2013a6c:	e03ffac5 	stb	zero,-21(fp)

		// create input task, this must be started before we can do any DHCP request
		if (sys_thread_new(tmpbuf, lwip_handle_ethernet_input, eth, KB(32), TCPIP_THREAD_PRIO) == NULL)
 2013a70:	e0fff104 	addi	r3,fp,-60
 2013a74:	008000c4 	movi	r2,3
 2013a78:	d8800015 	stw	r2,0(sp)
 2013a7c:	01e00014 	movui	r7,32768
 2013a80:	e1bff017 	ldw	r6,-64(fp)
 2013a84:	01408074 	movhi	r5,513
 2013a88:	294f4704 	addi	r5,r5,15644
 2013a8c:	1809883a 	mov	r4,r3
 2013a90:	20155600 	call	2015560 <sys_thread_new>
 2013a94:	1000031e 	bne	r2,zero,2013aa4 <lwip_handle_interfaces+0x1f4>
			printf("LwIP Couldn't create input / output task for ethernet\n");
 2013a98:	01008134 	movhi	r4,516
 2013a9c:	2104af04 	addi	r4,r4,4796
 2013aa0:	203ceb40 	call	203ceb4 <puts>

		// wait previous DHCP to finish
		if (dhcp) {
 2013aa4:	e0bffe17 	ldw	r2,-8(fp)
 2013aa8:	10000926 	beq	r2,zero,2013ad0 <lwip_handle_interfaces+0x220>
			printf("[LwIP] Start DHCP request...\n");
 2013aac:	01008134 	movhi	r4,516
 2013ab0:	2104bd04 	addi	r4,r4,4852
 2013ab4:	203ceb40 	call	203ceb4 <puts>

			dhcp_start(eth);
 2013ab8:	e13ff017 	ldw	r4,-64(fp)
 2013abc:	20161180 	call	2016118 <dhcp_start>

			// wait till we got our address
			printf("[LwIP] Waiting for DHCP IP address...\n");
 2013ac0:	01008134 	movhi	r4,516
 2013ac4:	2104c504 	addi	r4,r4,4884
 2013ac8:	203ceb40 	call	203ceb4 <puts>
 2013acc:	00000406 	br	2013ae0 <lwip_handle_interfaces+0x230>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
 2013ad0:	e13ff017 	ldw	r4,-64(fp)
 2013ad4:	2019f640 	call	2019f64 <netif_set_up>
 2013ad8:	00000106 	br	2013ae0 <lwip_handle_interfaces+0x230>
				for(;;) ;
			}

		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 2013adc:	0001883a 	nop
	char tmpbuf[OS_MAX_TASK_NAME_LEN];

	ip_addr_t ip = {0}, subnet = {0}, gateway = {0};
	int dhcp;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013ae0:	e0bfee17 	ldw	r2,-72(fp)
 2013ae4:	10800044 	addi	r2,r2,1
 2013ae8:	e0bfee15 	stw	r2,-72(fp)
 2013aec:	e0bfee17 	ldw	r2,-72(fp)
 2013af0:	00bf7a0e 	bge	zero,r2,20138dc <__alt_mem_mem_0+0xfcff38dc>
		} else {
			// the static IP has already been set, just bring up the interface
			netif_set_up(eth);
		}
	}
}
 2013af4:	0001883a 	nop
 2013af8:	e037883a 	mov	sp,fp
 2013afc:	dfc00117 	ldw	ra,4(sp)
 2013b00:	df000017 	ldw	fp,0(sp)
 2013b04:	dec00204 	addi	sp,sp,8
 2013b08:	f800283a 	ret

02013b0c <get_mac_count>:
 * \brief Get the number of MAC's available in the NIOS build
 *
 * \returns the number of MAC's in the NIOS build
 */
int get_mac_count(void)
{
 2013b0c:	deffff04 	addi	sp,sp,-4
 2013b10:	df000015 	stw	fp,0(sp)
 2013b14:	d839883a 	mov	fp,sp
	return PHY_COUNT;
 2013b18:	00800044 	movi	r2,1
}
 2013b1c:	e037883a 	mov	sp,fp
 2013b20:	df000017 	ldw	fp,0(sp)
 2013b24:	dec00104 	addi	sp,sp,4
 2013b28:	f800283a 	ret

02013b2c <get_mac_base>:
 * \param [in] idx the index of the MAC
 *
 * \returns the base address of the MAC
 */
volatile np_tse_mac* get_mac_base(int idx)
{
 2013b2c:	defffe04 	addi	sp,sp,-8
 2013b30:	df000115 	stw	fp,4(sp)
 2013b34:	df000104 	addi	fp,sp,4
 2013b38:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 2013b3c:	e0bfff17 	ldw	r2,-4(fp)
 2013b40:	10800090 	cmplti	r2,r2,2
 2013b44:	1000021e 	bne	r2,zero,2013b50 <get_mac_base+0x24>
		return NULL;
 2013b48:	0005883a 	mov	r2,zero
 2013b4c:	00000606 	br	2013b68 <get_mac_base+0x3c>

	return (volatile np_tse_mac*)tse_mac_device[idx].tse_mac_base;
 2013b50:	00808134 	movhi	r2,516
 2013b54:	1095ac04 	addi	r2,r2,22192
 2013b58:	e0ffff17 	ldw	r3,-4(fp)
 2013b5c:	18c01224 	muli	r3,r3,72
 2013b60:	10c5883a 	add	r2,r2,r3
 2013b64:	10800017 	ldw	r2,0(r2)
}
 2013b68:	e037883a 	mov	sp,fp
 2013b6c:	df000017 	ldw	fp,0(sp)
 2013b70:	dec00104 	addi	sp,sp,4
 2013b74:	f800283a 	ret

02013b78 <get_netif>:
 * \brief Get the netif struct used by LwIP
 *
 * \return the reference to the netif used by LwIP
 */
struct netif* get_netif(int idx)
{
 2013b78:	defffe04 	addi	sp,sp,-8
 2013b7c:	df000115 	stw	fp,4(sp)
 2013b80:	df000104 	addi	fp,sp,4
 2013b84:	e13fff15 	stw	r4,-4(fp)
	if (idx > PHY_COUNT)
 2013b88:	e0bfff17 	ldw	r2,-4(fp)
 2013b8c:	10800090 	cmplti	r2,r2,2
 2013b90:	1000021e 	bne	r2,zero,2013b9c <get_netif+0x24>
		return NULL;
 2013b94:	0005883a 	mov	r2,zero
 2013b98:	00000506 	br	2013bb0 <get_netif+0x38>

	return eth_tse + idx;
 2013b9c:	e0bfff17 	ldw	r2,-4(fp)
 2013ba0:	10c01124 	muli	r3,r2,68
 2013ba4:	008085b4 	movhi	r2,534
 2013ba8:	10889004 	addi	r2,r2,8768
 2013bac:	1885883a 	add	r2,r3,r2
}
 2013bb0:	e037883a 	mov	sp,fp
 2013bb4:	df000017 	ldw	fp,0(sp)
 2013bb8:	dec00104 	addi	sp,sp,4
 2013bbc:	f800283a 	ret

02013bc0 <lwip_set_status_callback>:

netif_status_callback_fn lwip_set_status_callback(netif_status_callback_fn callback)
{
 2013bc0:	defffd04 	addi	sp,sp,-12
 2013bc4:	df000215 	stw	fp,8(sp)
 2013bc8:	df000204 	addi	fp,sp,8
 2013bcc:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = status_callback;
 2013bd0:	d0a7e817 	ldw	r2,-24672(gp)
 2013bd4:	e0bffe15 	stw	r2,-8(fp)

	status_callback = callback;
 2013bd8:	e0bfff17 	ldw	r2,-4(fp)
 2013bdc:	d0a7e815 	stw	r2,-24672(gp)

	return old;
 2013be0:	e0bffe17 	ldw	r2,-8(fp)
}
 2013be4:	e037883a 	mov	sp,fp
 2013be8:	df000017 	ldw	fp,0(sp)
 2013bec:	dec00104 	addi	sp,sp,4
 2013bf0:	f800283a 	ret

02013bf4 <lwip_set_link_callback>:

netif_status_callback_fn lwip_set_link_callback(netif_status_callback_fn callback)
{
 2013bf4:	defffd04 	addi	sp,sp,-12
 2013bf8:	df000215 	stw	fp,8(sp)
 2013bfc:	df000204 	addi	fp,sp,8
 2013c00:	e13fff15 	stw	r4,-4(fp)
	netif_status_callback_fn old = link_callback;
 2013c04:	d0a7e917 	ldw	r2,-24668(gp)
 2013c08:	e0bffe15 	stw	r2,-8(fp)

	link_callback = callback;
 2013c0c:	e0bfff17 	ldw	r2,-4(fp)
 2013c10:	d0a7e915 	stw	r2,-24668(gp)

	return old;
 2013c14:	e0bffe17 	ldw	r2,-8(fp)
}
 2013c18:	e037883a 	mov	sp,fp
 2013c1c:	df000017 	ldw	fp,0(sp)
 2013c20:	dec00104 	addi	sp,sp,4
 2013c24:	f800283a 	ret

02013c28 <lwip_is_interface_up>:

#define REG_STATS_LS					(1 << 2)	// Link Status

int __attribute__((weak)) lwip_is_interface_up(__unused np_tse_mac* pmac)
{
 2013c28:	defffd04 	addi	sp,sp,-12
 2013c2c:	df000215 	stw	fp,8(sp)
 2013c30:	df000204 	addi	fp,sp,8
 2013c34:	e13fff15 	stw	r4,-4(fp)
	alt_u16 reg = IORD(&pmac->mdio1.STATUS, 0);
 2013c38:	e0bfff17 	ldw	r2,-4(fp)
 2013c3c:	1080a104 	addi	r2,r2,644
 2013c40:	10800037 	ldwio	r2,0(r2)
 2013c44:	e0bffe0d 	sth	r2,-8(fp)

	return ((reg & (REG_STATS_LS)) == REG_STATS_LS) ? ETH_INTERFACE_UP : ETH_INTERFACE_DOWN;
 2013c48:	e0bffe0b 	ldhu	r2,-8(fp)
 2013c4c:	1080010c 	andi	r2,r2,4
 2013c50:	1004c03a 	cmpne	r2,r2,zero
 2013c54:	10803fcc 	andi	r2,r2,255
}
 2013c58:	e037883a 	mov	sp,fp
 2013c5c:	df000017 	ldw	fp,0(sp)
 2013c60:	dec00104 	addi	sp,sp,4
 2013c64:	f800283a 	ret

02013c68 <lwip_check_link_status>:

static void lwip_check_link_status(struct netif *netif, np_tse_mac* base)
{
 2013c68:	defffa04 	addi	sp,sp,-24
 2013c6c:	dfc00515 	stw	ra,20(sp)
 2013c70:	df000415 	stw	fp,16(sp)
 2013c74:	df000404 	addi	fp,sp,16
 2013c78:	e13ffe15 	stw	r4,-8(fp)
 2013c7c:	e17fff15 	stw	r5,-4(fp)
	struct ethernetif *ethif = (struct ethernetif*)netif->state;
 2013c80:	e0bffe17 	ldw	r2,-8(fp)
 2013c84:	10800917 	ldw	r2,36(r2)
 2013c88:	e0bffc15 	stw	r2,-16(fp)

	// check if the interface is up
	int cur_status = lwip_is_interface_up(base);
 2013c8c:	e13fff17 	ldw	r4,-4(fp)
 2013c90:	2013c280 	call	2013c28 <lwip_is_interface_up>
 2013c94:	e0bffd15 	stw	r2,-12(fp)

	// is there a state change in the ethernet connectivity
	if (cur_status != ethif->current_state)
 2013c98:	e0bffc17 	ldw	r2,-16(fp)
 2013c9c:	10c01617 	ldw	r3,88(r2)
 2013ca0:	e0bffd17 	ldw	r2,-12(fp)
 2013ca4:	18801726 	beq	r3,r2,2013d04 <lwip_check_link_status+0x9c>
	{
		// check if the Auto-Negotiate is successful
		if (cur_status == ETH_INTERFACE_UP)
 2013ca8:	e0bffd17 	ldw	r2,-12(fp)
 2013cac:	10800058 	cmpnei	r2,r2,1
 2013cb0:	10000d1e 	bne	r2,zero,2013ce8 <lwip_check_link_status+0x80>
		{
			// wait for auto-negotiate...
			if (lwip_wait_for_an(netif->num, ethif) > 0)
 2013cb4:	e0bffe17 	ldw	r2,-8(fp)
 2013cb8:	10800f03 	ldbu	r2,60(r2)
 2013cbc:	10803fcc 	andi	r2,r2,255
 2013cc0:	e17ffc17 	ldw	r5,-16(fp)
 2013cc4:	1009883a 	mov	r4,r2
 2013cc8:	20138240 	call	2013824 <lwip_wait_for_an>
 2013ccc:	00800d0e 	bge	zero,r2,2013d04 <lwip_check_link_status+0x9c>
			{
				netif_set_link_up(netif);
 2013cd0:	e13ffe17 	ldw	r4,-8(fp)
 2013cd4:	201a0e40 	call	201a0e4 <netif_set_link_up>
				ethif->current_state = cur_status;
 2013cd8:	e0bffc17 	ldw	r2,-16(fp)
 2013cdc:	e0fffd17 	ldw	r3,-12(fp)
 2013ce0:	10c01615 	stw	r3,88(r2)

			netif_set_link_down(netif);
			ethif->current_state = cur_status;
		}
	}
}
 2013ce4:	00000706 	br	2013d04 <lwip_check_link_status+0x9c>
			}
		}
		else
		{
			// bring down the link
			ethif->link_alive = 0;
 2013ce8:	e0bffc17 	ldw	r2,-16(fp)
 2013cec:	10000215 	stw	zero,8(r2)

			netif_set_link_down(netif);
 2013cf0:	e13ffe17 	ldw	r4,-8(fp)
 2013cf4:	201a1a80 	call	201a1a8 <netif_set_link_down>
			ethif->current_state = cur_status;
 2013cf8:	e0bffc17 	ldw	r2,-16(fp)
 2013cfc:	e0fffd17 	ldw	r3,-12(fp)
 2013d00:	10c01615 	stw	r3,88(r2)
		}
	}
}
 2013d04:	0001883a 	nop
 2013d08:	e037883a 	mov	sp,fp
 2013d0c:	dfc00117 	ldw	ra,4(sp)
 2013d10:	df000017 	ldw	fp,0(sp)
 2013d14:	dec00204 	addi	sp,sp,8
 2013d18:	f800283a 	ret

02013d1c <lwip_handle_ethernet_input>:

#define NR_TEST_PACKETS						50000

// Input / monitor task per ethernet device
static void lwip_handle_ethernet_input(void *pvParameters)
{
 2013d1c:	defe7104 	addi	sp,sp,-1596
 2013d20:	dfc18e15 	stw	ra,1592(sp)
 2013d24:	df018d15 	stw	fp,1588(sp)
 2013d28:	df018d04 	addi	fp,sp,1588
 2013d2c:	e13fff15 	stw	r4,-4(fp)
	sys_sem_t rcvsem = NULL;
 2013d30:	e03e7815 	stw	zero,-1568(fp)
	np_tse_mac* base = NULL;
 2013d34:	e03e7415 	stw	zero,-1584(fp)
	struct netif *cur_netif = (struct netif*)pvParameters;
 2013d38:	e0bfff17 	ldw	r2,-4(fp)
 2013d3c:	e0be7515 	stw	r2,-1580(fp)
	struct ethernetif *cur_ethif = (struct ethernetif*)cur_netif->state;
 2013d40:	e0be7517 	ldw	r2,-1580(fp)
 2013d44:	10800917 	ldw	r2,36(r2)
 2013d48:	e0be7615 	stw	r2,-1576(fp)
	int packets_waiting = 0;
 2013d4c:	e03e7315 	stw	zero,-1588(fp)

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560]; // TODO remove
	int replug_state = 0; // TODO remove
 2013d50:	e03e7715 	stw	zero,-1572(fp)

#if LWIP_RECEIVE_SEMAPHORE
	rcvsem = cur_ethif->tse_info->rx_semaphore;
 2013d54:	e0be7617 	ldw	r2,-1576(fp)
 2013d58:	10801717 	ldw	r2,92(r2)
 2013d5c:	10800817 	ldw	r2,32(r2)
 2013d60:	e0be7815 	stw	r2,-1568(fp)
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
 2013d64:	e0be7517 	ldw	r2,-1580(fp)
 2013d68:	10800f03 	ldbu	r2,60(r2)
 2013d6c:	10803fcc 	andi	r2,r2,255
 2013d70:	1009883a 	mov	r4,r2
 2013d74:	2013b2c0 	call	2013b2c <get_mac_base>
 2013d78:	e0be7415 	stw	r2,-1584(fp)
	if (!base)
 2013d7c:	e0be7417 	ldw	r2,-1584(fp)
 2013d80:	10001426 	beq	r2,zero,2013dd4 <lwip_handle_ethernet_input+0xb8>
	// else we'll poll the function once every 100ms
		while (1) {
		// if we have a semaphore wait for it to be released by the SGDMA IRQ, or sleep for 1 ms
			// if we timeout also call ethernetif_input although most likely it would be useless
			// it is use full however to check the link status
		if (rcvsem)
 2013d84:	e0be7817 	ldw	r2,-1568(fp)
 2013d88:	10000526 	beq	r2,zero,2013da0 <lwip_handle_ethernet_input+0x84>
			sys_arch_sem_wait(&rcvsem, 100);
 2013d8c:	e0be7804 	addi	r2,fp,-1568
 2013d90:	01401904 	movi	r5,100
 2013d94:	1009883a 	mov	r4,r2
 2013d98:	2014f800 	call	2014f80 <sys_arch_sem_wait>
 2013d9c:	00000406 	br	2013db0 <lwip_handle_ethernet_input+0x94>
		else if (packets_waiting <= 0)	// only sleep if there are no packets waiting
 2013da0:	e0be7317 	ldw	r2,-1588(fp)
 2013da4:	00800216 	blt	zero,r2,2013db0 <lwip_handle_ethernet_input+0x94>
			mssleep(1);					// sleep a bit to be nice to the CPU
 2013da8:	0100fa04 	movi	r4,1000
 2013dac:	202d1500 	call	202d150 <usleep>

			// Use semaphore or the timeout to call ethernet_input
			// this to avoid unnecessary load and faster responses ;)
		packets_waiting = ethernetif_input(cur_netif);
 2013db0:	e13e7517 	ldw	r4,-1580(fp)
 2013db4:	20134640 	call	2013464 <ethernetif_input>
 2013db8:	e0be7315 	stw	r2,-1588(fp)

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
 2013dbc:	e0be7317 	ldw	r2,-1588(fp)
 2013dc0:	00bff016 	blt	zero,r2,2013d84 <__alt_mem_mem_0+0xfcff3d84>
			lwip_check_link_status(cur_netif, base);
 2013dc4:	e17e7417 	ldw	r5,-1584(fp)
 2013dc8:	e13e7517 	ldw	r4,-1580(fp)
 2013dcc:	2013c680 	call	2013c68 <lwip_check_link_status>
	}
 2013dd0:	003fec06 	br	2013d84 <__alt_mem_mem_0+0xfcff3d84>
#endif

	// get the actual MAC peripheral
	base = get_mac_base(cur_netif->num);
	if (!base)
		return;
 2013dd4:	0001883a 	nop

		// check the link status if there are no packets waiting
		if (packets_waiting <= 0)
			lwip_check_link_status(cur_netif, base);
	}
}
 2013dd8:	e037883a 	mov	sp,fp
 2013ddc:	dfc00117 	ldw	ra,4(sp)
 2013de0:	df000017 	ldw	fp,0(sp)
 2013de4:	dec00204 	addi	sp,sp,8
 2013de8:	f800283a 	ret

02013dec <print_ipad>:

const char* print_ipad(alt_u32 ip, char* buf)
{
 2013dec:	defff704 	addi	sp,sp,-36
 2013df0:	dfc00815 	stw	ra,32(sp)
 2013df4:	df000715 	stw	fp,28(sp)
 2013df8:	df000704 	addi	fp,sp,28
 2013dfc:	e13ffe15 	stw	r4,-8(fp)
 2013e00:	e17fff15 	stw	r5,-4(fp)
	alt_u8 bip[4];
	alt_u32 idx = 0;
 2013e04:	e03ffc15 	stw	zero,-16(fp)

	for (; idx < sizeof(bip); idx++) {
 2013e08:	00000c06 	br	2013e3c <print_ipad+0x50>
		bip[idx] = ip & 0xFF;
 2013e0c:	e0bffe17 	ldw	r2,-8(fp)
 2013e10:	1009883a 	mov	r4,r2
 2013e14:	e0fffd04 	addi	r3,fp,-12
 2013e18:	e0bffc17 	ldw	r2,-16(fp)
 2013e1c:	1885883a 	add	r2,r3,r2
 2013e20:	11000005 	stb	r4,0(r2)
		ip >>= 8;
 2013e24:	e0bffe17 	ldw	r2,-8(fp)
 2013e28:	1004d23a 	srli	r2,r2,8
 2013e2c:	e0bffe15 	stw	r2,-8(fp)
const char* print_ipad(alt_u32 ip, char* buf)
{
	alt_u8 bip[4];
	alt_u32 idx = 0;

	for (; idx < sizeof(bip); idx++) {
 2013e30:	e0bffc17 	ldw	r2,-16(fp)
 2013e34:	10800044 	addi	r2,r2,1
 2013e38:	e0bffc15 	stw	r2,-16(fp)
 2013e3c:	e0bffc17 	ldw	r2,-16(fp)
 2013e40:	10800130 	cmpltui	r2,r2,4
 2013e44:	103ff11e 	bne	r2,zero,2013e0c <__alt_mem_mem_0+0xfcff3e0c>
		bip[idx] = ip & 0xFF;
		ip >>= 8;
	}

	snprintf(buf, 17, "%d.%d.%d.%d", bip[0], bip[1], bip[2], bip[3]);
 2013e48:	e0bffd03 	ldbu	r2,-12(fp)
 2013e4c:	11403fcc 	andi	r5,r2,255
 2013e50:	e0bffd43 	ldbu	r2,-11(fp)
 2013e54:	10803fcc 	andi	r2,r2,255
 2013e58:	e0fffd83 	ldbu	r3,-10(fp)
 2013e5c:	18c03fcc 	andi	r3,r3,255
 2013e60:	e13ffdc3 	ldbu	r4,-9(fp)
 2013e64:	21003fcc 	andi	r4,r4,255
 2013e68:	d9000215 	stw	r4,8(sp)
 2013e6c:	d8c00115 	stw	r3,4(sp)
 2013e70:	d8800015 	stw	r2,0(sp)
 2013e74:	280f883a 	mov	r7,r5
 2013e78:	01808134 	movhi	r6,516
 2013e7c:	3184cf04 	addi	r6,r6,4924
 2013e80:	01400444 	movi	r5,17
 2013e84:	e13fff17 	ldw	r4,-4(fp)
 2013e88:	203cfa00 	call	203cfa0 <snprintf>

	return buf;
 2013e8c:	e0bfff17 	ldw	r2,-4(fp)
}
 2013e90:	e037883a 	mov	sp,fp
 2013e94:	dfc00117 	ldw	ra,4(sp)
 2013e98:	df000017 	ldw	fp,0(sp)
 2013e9c:	dec00204 	addi	sp,sp,8
 2013ea0:	f800283a 	ret

02013ea4 <lwip_status_callback>:

static void lwip_status_callback(struct netif *netif)
{
 2013ea4:	defffd04 	addi	sp,sp,-12
 2013ea8:	dfc00215 	stw	ra,8(sp)
 2013eac:	df000115 	stw	fp,4(sp)
 2013eb0:	df000104 	addi	fp,sp,4
 2013eb4:	e13fff15 	stw	r4,-4(fp)
	if (status_callback)
 2013eb8:	d0a7e817 	ldw	r2,-24672(gp)
 2013ebc:	10000326 	beq	r2,zero,2013ecc <lwip_status_callback+0x28>
		status_callback(netif);
 2013ec0:	d0a7e817 	ldw	r2,-24672(gp)
 2013ec4:	e13fff17 	ldw	r4,-4(fp)
 2013ec8:	103ee83a 	callr	r2
}
 2013ecc:	0001883a 	nop
 2013ed0:	e037883a 	mov	sp,fp
 2013ed4:	dfc00117 	ldw	ra,4(sp)
 2013ed8:	df000017 	ldw	fp,0(sp)
 2013edc:	dec00204 	addi	sp,sp,8
 2013ee0:	f800283a 	ret

02013ee4 <lwip_initialize_phys>:

void lwip_initialize_phys(void)
{
 2013ee4:	defff604 	addi	sp,sp,-40
 2013ee8:	dfc00915 	stw	ra,36(sp)
 2013eec:	df000815 	stw	fp,32(sp)
 2013ef0:	df000804 	addi	fp,sp,32
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 2013ef4:	e03ff815 	stw	zero,-32(fp)
 2013ef8:	00006e06 	br	20140b4 <lwip_initialize_phys+0x1d0>
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
 2013efc:	e13ff817 	ldw	r4,-32(fp)
 2013f00:	2000a780 	call	2000a78 <is_interface_active>
 2013f04:	10006326 	beq	r2,zero,2014094 <lwip_initialize_phys+0x1b0>
			continue;

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
 2013f08:	e13ff817 	ldw	r4,-32(fp)
 2013f0c:	2013b2c0 	call	2013b2c <get_mac_base>
 2013f10:	e0bffd15 	stw	r2,-12(fp)
		if (!pmac)
 2013f14:	e0bffd17 	ldw	r2,-12(fp)
 2013f18:	10006026 	beq	r2,zero,201409c <lwip_initialize_phys+0x1b8>
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 2013f1c:	e03ff915 	stw	zero,-28(fp)
 2013f20:	00001206 	br	2013f6c <lwip_initialize_phys+0x88>
		{
			IOWR(&pmac->MDIO_ADDR1, 0, phyadd);
 2013f24:	e0bffd17 	ldw	r2,-12(fp)
 2013f28:	10801004 	addi	r2,r2,64
 2013f2c:	e0fff917 	ldw	r3,-28(fp)
 2013f30:	10c00035 	stwio	r3,0(r2)

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
 2013f34:	e0bffd17 	ldw	r2,-12(fp)
 2013f38:	1080a204 	addi	r2,r2,648
 2013f3c:	10800037 	ldwio	r2,0(r2)
 2013f40:	e0bffa15 	stw	r2,-24(fp)
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);
 2013f44:	e0bffd17 	ldw	r2,-12(fp)
 2013f48:	1080a304 	addi	r2,r2,652
 2013f4c:	10800037 	ldwio	r2,0(r2)
 2013f50:	e0bffb15 	stw	r2,-20(fp)

			if (phyid != phyid2)
 2013f54:	e0fffa17 	ldw	r3,-24(fp)
 2013f58:	e0bffb17 	ldw	r2,-20(fp)
 2013f5c:	1880071e 	bne	r3,r2,2013f7c <lwip_initialize_phys+0x98>
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;

		// search the PHY and it's ID
		for (phyadd = 0x00; phyadd < 0x20; ++phyadd)
 2013f60:	e0bff917 	ldw	r2,-28(fp)
 2013f64:	10800044 	addi	r2,r2,1
 2013f68:	e0bff915 	stw	r2,-28(fp)
 2013f6c:	e0bff917 	ldw	r2,-28(fp)
 2013f70:	10800810 	cmplti	r2,r2,32
 2013f74:	103feb1e 	bne	r2,zero,2013f24 <__alt_mem_mem_0+0xfcff3f24>
 2013f78:	00000106 	br	2013f80 <lwip_initialize_phys+0x9c>

			phyid = IORD(&pmac->mdio1.PHY_ID1, 0);
			phyid2 = IORD(&pmac->mdio1.PHY_ID2, 0);

			if (phyid != phyid2)
				break;
 2013f7c:	0001883a 	nop
		}

		// if we have the PHY we can initialize it if we can find the driver in the pphy_profiles array
		if (phyid != phyid2)
 2013f80:	e0fffa17 	ldw	r3,-24(fp)
 2013f84:	e0bffb17 	ldw	r2,-20(fp)
 2013f88:	18804726 	beq	r3,r2,20140a8 <lwip_initialize_phys+0x1c4>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 2013f8c:	e03ffc15 	stw	zero,-16(fp)
 2013f90:	00003b06 	br	2014080 <lwip_initialize_phys+0x19c>
                alt_u32 oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 2013f94:	e0bffa17 	ldw	r2,-24(fp)
 2013f98:	100691ba 	slli	r3,r2,6
 2013f9c:	e0bffb17 	ldw	r2,-20(fp)
 2013fa0:	1005d2ba 	srai	r2,r2,10
 2013fa4:	10800fcc 	andi	r2,r2,63
 2013fa8:	1884b03a 	or	r2,r3,r2
 2013fac:	e0bffe15 	stw	r2,-8(fp)
                alt_u8 model_number = (phyid2 >> 4) & 0x3f;
 2013fb0:	e0bffb17 	ldw	r2,-20(fp)
 2013fb4:	1005d13a 	srai	r2,r2,4
 2013fb8:	10800fcc 	andi	r2,r2,63
 2013fbc:	e0bfff05 	stb	r2,-4(fp)
                // unused so far... alt_u8 revision_number = phyid2 & 0x0f;

                // if PHY match with PHY in profile we can call the initialize function
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 2013fc0:	008085f4 	movhi	r2,535
 2013fc4:	10a96104 	addi	r2,r2,-23164
 2013fc8:	e0fffc17 	ldw	r3,-16(fp)
 2013fcc:	18c7883a 	add	r3,r3,r3
 2013fd0:	18c7883a 	add	r3,r3,r3
 2013fd4:	10c5883a 	add	r2,r2,r3
 2013fd8:	10800017 	ldw	r2,0(r2)
 2013fdc:	10c01417 	ldw	r3,80(r2)
 2013fe0:	e0bffe17 	ldw	r2,-8(fp)
 2013fe4:	1880231e 	bne	r3,r2,2014074 <lwip_initialize_phys+0x190>
 2013fe8:	008085f4 	movhi	r2,535
 2013fec:	10a96104 	addi	r2,r2,-23164
 2013ff0:	e0fffc17 	ldw	r3,-16(fp)
 2013ff4:	18c7883a 	add	r3,r3,r3
 2013ff8:	18c7883a 	add	r3,r3,r3
 2013ffc:	10c5883a 	add	r2,r2,r3
 2014000:	10800017 	ldw	r2,0(r2)
 2014004:	10801503 	ldbu	r2,84(r2)
 2014008:	10c03fcc 	andi	r3,r2,255
 201400c:	e0bfff03 	ldbu	r2,-4(fp)
 2014010:	1880181e 	bne	r3,r2,2014074 <lwip_initialize_phys+0x190>
                {
                    if (pphy_profiles[i]->phy_cfg)
 2014014:	008085f4 	movhi	r2,535
 2014018:	10a96104 	addi	r2,r2,-23164
 201401c:	e0fffc17 	ldw	r3,-16(fp)
 2014020:	18c7883a 	add	r3,r3,r3
 2014024:	18c7883a 	add	r3,r3,r3
 2014028:	10c5883a 	add	r2,r2,r3
 201402c:	10800017 	ldw	r2,0(r2)
 2014030:	10801717 	ldw	r2,92(r2)
 2014034:	10001b26 	beq	r2,zero,20140a4 <lwip_initialize_phys+0x1c0>
                    {
                    	// initialize the PHY
                    	pphy_profiles[i]->phy_cfg(pmac);
 2014038:	008085f4 	movhi	r2,535
 201403c:	10a96104 	addi	r2,r2,-23164
 2014040:	e0fffc17 	ldw	r3,-16(fp)
 2014044:	18c7883a 	add	r3,r3,r3
 2014048:	18c7883a 	add	r3,r3,r3
 201404c:	10c5883a 	add	r2,r2,r3
 2014050:	10800017 	ldw	r2,0(r2)
 2014054:	10801717 	ldw	r2,92(r2)
 2014058:	e13ffd17 	ldw	r4,-12(fp)
 201405c:	103ee83a 	callr	r2

                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
 2014060:	e0bffd17 	ldw	r2,-12(fp)
 2014064:	1080a004 	addi	r2,r2,640
 2014068:	00c48004 	movi	r3,4608
 201406c:	10c00035 	stwio	r3,0(r2)
                    }

                    // and done for this PHY
                    break;
 2014070:	00000c06 	br	20140a4 <lwip_initialize_phys+0x1c0>
            extern alt_tse_phy_profile *pphy_profiles[];
            extern alt_u8 phy_profile_count;

            int i;

            for(i = 0; i < phy_profile_count; i++) {
 2014074:	e0bffc17 	ldw	r2,-16(fp)
 2014078:	10800044 	addi	r2,r2,1
 201407c:	e0bffc15 	stw	r2,-16(fp)
 2014080:	d0a80003 	ldbu	r2,-24576(gp)
 2014084:	10803fcc 	andi	r2,r2,255
 2014088:	e0fffc17 	ldw	r3,-16(fp)
 201408c:	18bfc116 	blt	r3,r2,2013f94 <__alt_mem_mem_0+0xfcff3f94>
 2014090:	00000506 	br	20140a8 <lwip_initialize_phys+0x1c4>

	for (idx = 0; idx < PHY_COUNT; ++idx)
	{
		// check whether this interface should be used
		if (!is_interface_active(idx))
			continue;
 2014094:	0001883a 	nop
 2014098:	00000306 	br	20140a8 <lwip_initialize_phys+0x1c4>

		// the PHY is active... let's get the mac base
		pmac = get_mac_base(idx);
		if (!pmac)
			continue;
 201409c:	0001883a 	nop
 20140a0:	00000106 	br	20140a8 <lwip_initialize_phys+0x1c4>
                    	// and restart the Auto-Negotiation
                    	IOWR(&pmac->mdio1.CONTROL, 0, (1<<12 | 1<<9));
                    }

                    // and done for this PHY
                    break;
 20140a4:	0001883a 	nop
void lwip_initialize_phys(void)
{
	int idx, phyadd, phyid, phyid2;
	np_tse_mac *pmac;

	for (idx = 0; idx < PHY_COUNT; ++idx)
 20140a8:	e0bff817 	ldw	r2,-32(fp)
 20140ac:	10800044 	addi	r2,r2,1
 20140b0:	e0bff815 	stw	r2,-32(fp)
 20140b4:	e0bff817 	ldw	r2,-32(fp)
 20140b8:	00bf900e 	bge	zero,r2,2013efc <__alt_mem_mem_0+0xfcff3efc>
                    break;
                }
            }
		}
	}
}
 20140bc:	0001883a 	nop
 20140c0:	e037883a 	mov	sp,fp
 20140c4:	dfc00117 	ldw	ra,4(sp)
 20140c8:	df000017 	ldw	fp,0(sp)
 20140cc:	dec00204 	addi	sp,sp,8
 20140d0:	f800283a 	ret

020140d4 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface, struct ethernetif *ethernetif)
{
 20140d4:	defff004 	addi	sp,sp,-64
 20140d8:	dfc00f15 	stw	ra,60(sp)
 20140dc:	df000e15 	stw	fp,56(sp)
 20140e0:	df000e04 	addi	fp,sp,56
 20140e4:	e13ffe15 	stw	r4,-8(fp)
 20140e8:	e17fff15 	stw	r5,-4(fp)
	int speed, duplex, result;
	int x;

	alt_sgdma_dev *sgdma_tx_dev;
	alt_sgdma_dev *sgdma_rx_dev;
	alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 20140ec:	008085b4 	movhi	r2,534
 20140f0:	1088a104 	addi	r2,r2,8836
 20140f4:	e0fffe17 	ldw	r3,-8(fp)
 20140f8:	18c00924 	muli	r3,r3,36
 20140fc:	10c5883a 	add	r2,r2,r3
 2014100:	10800704 	addi	r2,r2,28
 2014104:	10800017 	ldw	r2,0(r2)
 2014108:	e0bff715 	stw	r2,-36(fp)
	np_tse_mac *mi_base;
	alt_tse_mac_info *pmac_info;

#if LWIP_RECEIVE_SEMAPHORE
	if (!tse[iface].rx_semaphore) {
 201410c:	008085b4 	movhi	r2,534
 2014110:	1088a104 	addi	r2,r2,8836
 2014114:	e0fffe17 	ldw	r3,-8(fp)
 2014118:	18c00924 	muli	r3,r3,36
 201411c:	10c5883a 	add	r2,r2,r3
 2014120:	10800804 	addi	r2,r2,32
 2014124:	10800017 	ldw	r2,0(r2)
 2014128:	10001e1e 	bne	r2,zero,20141a4 <tse_mac_init+0xd0>
		dprintf(("creating RX SGDMA semaphore\n"));
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
 201412c:	e0bffe17 	ldw	r2,-8(fp)
 2014130:	10800924 	muli	r2,r2,36
 2014134:	10c00804 	addi	r3,r2,32
 2014138:	008085b4 	movhi	r2,534
 201413c:	1088a104 	addi	r2,r2,8836
 2014140:	1885883a 	add	r2,r3,r2
 2014144:	01400304 	movi	r5,12
 2014148:	1009883a 	mov	r4,r2
 201414c:	2014dfc0 	call	2014dfc <sys_sem_new>
 2014150:	10803fcc 	andi	r2,r2,255
 2014154:	1080201c 	xori	r2,r2,128
 2014158:	10bfe004 	addi	r2,r2,-128
 201415c:	1000111e 	bne	r2,zero,20141a4 <tse_mac_init+0xd0>
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 2014160:	e03ff515 	stw	zero,-44(fp)
 2014164:	00000c06 	br	2014198 <tse_mac_init+0xc4>
				sys_arch_sem_wait(&tse[iface].rx_semaphore, 1);
 2014168:	e0bffe17 	ldw	r2,-8(fp)
 201416c:	10800924 	muli	r2,r2,36
 2014170:	10c00804 	addi	r3,r2,32
 2014174:	008085b4 	movhi	r2,534
 2014178:	1088a104 	addi	r2,r2,8836
 201417c:	1885883a 	add	r2,r3,r2
 2014180:	01400044 	movi	r5,1
 2014184:	1009883a 	mov	r4,r2
 2014188:	2014f800 	call	2014f80 <sys_arch_sem_wait>
		// create a counting semaphore so we can 'release' the semaphore for each rx input buffer filled
		if (sys_sem_new(&tse[iface].rx_semaphore, LWIP_RX_ETH_BUFFER) != ERR_OK) {
			dprintf(("[LwIP] Couldn't create the rx_semephore\n"));
		} else {
			// we got a semaphore, completely lock it
			for (x = 0; x < LWIP_RX_ETH_BUFFER; x++)
 201418c:	e0bff517 	ldw	r2,-44(fp)
 2014190:	10800044 	addi	r2,r2,1
 2014194:	e0bff515 	stw	r2,-44(fp)
 2014198:	e0bff517 	ldw	r2,-44(fp)
 201419c:	10800310 	cmplti	r2,r2,12
 20141a0:	103ff11e 	bne	r2,zero,2014168 <__alt_mem_mem_0+0xfcff4168>
	dprintf(("[tse_mac_init]\n"));
#ifdef PRINTIF
	dprintf(("tse_mac_init %d\n", iface));
#endif    
	// These lines were done in prep_tse_mac
	tse_hw = &tse_mac_device[iface];
 20141a4:	e0bffe17 	ldw	r2,-8(fp)
 20141a8:	10c01224 	muli	r3,r2,72
 20141ac:	00808134 	movhi	r2,516
 20141b0:	1095ac04 	addi	r2,r2,22192
 20141b4:	1885883a 	add	r2,r3,r2
 20141b8:	e0bff715 	stw	r2,-36(fp)
	tse[iface].tse = tse_hw;
 20141bc:	008085b4 	movhi	r2,534
 20141c0:	1088a104 	addi	r2,r2,8836
 20141c4:	e0fffe17 	ldw	r3,-8(fp)
 20141c8:	18c00924 	muli	r3,r3,36
 20141cc:	10c5883a 	add	r2,r2,r3
 20141d0:	10800704 	addi	r2,r2,28
 20141d4:	e0fff717 	ldw	r3,-36(fp)
 20141d8:	10c00015 	stw	r3,0(r2)

	// Store ethernetif for access, and the tse in ethernetif for access in tse_mac_raw_send/tse_mac_rcv
	tse[iface].ethernetif = ethernetif;
 20141dc:	008085b4 	movhi	r2,534
 20141e0:	1088a104 	addi	r2,r2,8836
 20141e4:	e0fffe17 	ldw	r3,-8(fp)
 20141e8:	18c00924 	muli	r3,r3,36
 20141ec:	10c5883a 	add	r2,r2,r3
 20141f0:	10800604 	addi	r2,r2,24
 20141f4:	e0ffff17 	ldw	r3,-4(fp)
 20141f8:	10c00015 	stw	r3,0(r2)
	ethernetif->iface = iface;
 20141fc:	e0bfff17 	ldw	r2,-4(fp)
 2014200:	e0fffe17 	ldw	r3,-8(fp)
 2014204:	10c00115 	stw	r3,4(r2)
	ethernetif->tse_info = &tse[iface];
 2014208:	e0bffe17 	ldw	r2,-8(fp)
 201420c:	10c00924 	muli	r3,r2,36
 2014210:	008085b4 	movhi	r2,534
 2014214:	1088a104 	addi	r2,r2,8836
 2014218:	1887883a 	add	r3,r3,r2
 201421c:	e0bfff17 	ldw	r2,-4(fp)
 2014220:	10c01715 	stw	r3,92(r2)

	if (tse_hw->ext_desc_mem == 1)
 2014224:	e0bff717 	ldw	r2,-36(fp)
 2014228:	10800783 	ldbu	r2,30(r2)
 201422c:	10803fcc 	andi	r2,r2,255
 2014230:	10800058 	cmpnei	r2,r2,1
 2014234:	10000b1e 	bne	r2,zero,2014264 <tse_mac_init+0x190>
	{
		tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 2014238:	e0bff717 	ldw	r2,-36(fp)
 201423c:	10800817 	ldw	r2,32(r2)
 2014240:	1009883a 	mov	r4,r2
 2014244:	008085b4 	movhi	r2,534
 2014248:	1088a104 	addi	r2,r2,8836
 201424c:	e0fffe17 	ldw	r3,-8(fp)
 2014250:	18c00924 	muli	r3,r3,36
 2014254:	10c5883a 	add	r2,r2,r3
 2014258:	10800504 	addi	r2,r2,20
 201425c:	11000015 	stw	r4,0(r2)
 2014260:	00001206 	br	20142ac <tse_mac_init+0x1d8>
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 2014264:	01002804 	movi	r4,160
 2014268:	202d1200 	call	202d120 <alt_uncached_malloc>
 201426c:	e0bff615 	stw	r2,-40(fp)

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 2014270:	00000306 	br	2014280 <tse_mac_init+0x1ac>
			temp_desc++;
 2014274:	e0bff617 	ldw	r2,-40(fp)
 2014278:	10800044 	addi	r2,r2,1
 201427c:	e0bff615 	stw	r2,-40(fp)
	}
	else
	{
		unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));

		while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 2014280:	e0bff617 	ldw	r2,-40(fp)
 2014284:	108007cc 	andi	r2,r2,31
 2014288:	103ffa1e 	bne	r2,zero,2014274 <__alt_mem_mem_0+0xfcff4274>
			temp_desc++;
		tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 201428c:	008085b4 	movhi	r2,534
 2014290:	1088a104 	addi	r2,r2,8836
 2014294:	e0fffe17 	ldw	r3,-8(fp)
 2014298:	18c00924 	muli	r3,r3,36
 201429c:	10c5883a 	add	r2,r2,r3
 20142a0:	10800504 	addi	r2,r2,20
 20142a4:	e0fff617 	ldw	r3,-40(fp)
 20142a8:	10c00015 	stw	r3,0(r2)
	}

	/* Get the Rx and Tx SGDMA addresses */
	sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 20142ac:	e0bff717 	ldw	r2,-36(fp)
 20142b0:	10800517 	ldw	r2,20(r2)
 20142b4:	1009883a 	mov	r4,r2
 20142b8:	202593c0 	call	202593c <alt_avalon_sgdma_open>
 20142bc:	e0bff815 	stw	r2,-32(fp)

	if (!sgdma_tx_dev)
 20142c0:	e0bff817 	ldw	r2,-32(fp)
 20142c4:	1000021e 	bne	r2,zero,20142d0 <tse_mac_init+0x1fc>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening TX SGDMA\n"));
		return ENP_RESOURCE;
 20142c8:	00bffa84 	movi	r2,-22
 20142cc:	00018f06 	br	201490c <tse_mac_init+0x838>
	}

	sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 20142d0:	e0bff717 	ldw	r2,-36(fp)
 20142d4:	10800617 	ldw	r2,24(r2)
 20142d8:	1009883a 	mov	r4,r2
 20142dc:	202593c0 	call	202593c <alt_avalon_sgdma_open>
 20142e0:	e0bff915 	stw	r2,-28(fp)
	if (!sgdma_rx_dev)
 20142e4:	e0bff917 	ldw	r2,-28(fp)
 20142e8:	1000021e 	bne	r2,zero,20142f4 <tse_mac_init+0x220>
	{
		dprintf(("[triple_speed_ethernet_init] Error opening RX SGDMA\n"));
		return ENP_RESOURCE;
 20142ec:	00bffa84 	movi	r2,-22
 20142f0:	00018606 	br	201490c <tse_mac_init+0x838>
	}

	/* Initialize mtip_mac_trans_info structure with values from <system.h>*/

	tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 20142f4:	e0bffe17 	ldw	r2,-8(fp)
 20142f8:	10c00924 	muli	r3,r2,36
 20142fc:	008085b4 	movhi	r2,534
 2014300:	1088a104 	addi	r2,r2,8836
 2014304:	1887883a 	add	r3,r3,r2
 2014308:	e0bff717 	ldw	r2,-36(fp)
 201430c:	10800017 	ldw	r2,0(r2)
 2014310:	e13ff817 	ldw	r4,-32(fp)
 2014314:	e17ff917 	ldw	r5,-28(fp)
 2014318:	d8000015 	stw	zero,0(sp)
 201431c:	280f883a 	mov	r7,r5
 2014320:	200d883a 	mov	r6,r4
 2014324:	100b883a 	mov	r5,r2
 2014328:	1809883a 	mov	r4,r3
 201432c:	202613c0 	call	202613c <tse_mac_initTransInfo2>
			(unsigned int)sgdma_tx_dev,
			(unsigned int)sgdma_rx_dev,
			0);
	mi_base = tse[iface].mi.base;
 2014330:	008085b4 	movhi	r2,534
 2014334:	1088a104 	addi	r2,r2,8836
 2014338:	e0fffe17 	ldw	r3,-8(fp)
 201433c:	18c00924 	muli	r3,r3,36
 2014340:	10c5883a 	add	r2,r2,r3
 2014344:	10800017 	ldw	r2,0(r2)
 2014348:	e0bffa15 	stw	r2,-24(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
 201434c:	008085b4 	movhi	r2,534
 2014350:	1088a104 	addi	r2,r2,8836
 2014354:	e0fffe17 	ldw	r3,-8(fp)
 2014358:	18c00924 	muli	r3,r3,36
 201435c:	10c5883a 	add	r2,r2,r3
 2014360:	10800204 	addi	r2,r2,8
 2014364:	10800017 	ldw	r2,0(r2)
 2014368:	10800317 	ldw	r2,12(r2)
 201436c:	10800404 	addi	r2,r2,16
 2014370:	00c00074 	movhi	r3,1
 2014374:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 2014378:	008085b4 	movhi	r2,534
 201437c:	1088a104 	addi	r2,r2,8836
 2014380:	e0fffe17 	ldw	r3,-8(fp)
 2014384:	18c00924 	muli	r3,r3,36
 2014388:	10c5883a 	add	r2,r2,r3
 201438c:	10800204 	addi	r2,r2,8
 2014390:	10800017 	ldw	r2,0(r2)
 2014394:	10800317 	ldw	r2,12(r2)
 2014398:	10800404 	addi	r2,r2,16
 201439c:	0007883a 	mov	r3,zero
 20143a0:	10c00035 	stwio	r3,0(r2)

	/* reset the PHY if necessary */
	result = getPHYSpeed(tse[iface].mi.base);
 20143a4:	008085b4 	movhi	r2,534
 20143a8:	1088a104 	addi	r2,r2,8836
 20143ac:	e0fffe17 	ldw	r3,-8(fp)
 20143b0:	18c00924 	muli	r3,r3,36
 20143b4:	10c5883a 	add	r2,r2,r3
 20143b8:	10800017 	ldw	r2,0(r2)
 20143bc:	1009883a 	mov	r4,r2
 20143c0:	20275c80 	call	20275c8 <getPHYSpeed>
 20143c4:	e0bffb15 	stw	r2,-20(fp)
	speed = (result >> 1) & 0x07;
 20143c8:	e0bffb17 	ldw	r2,-20(fp)
 20143cc:	1005d07a 	srai	r2,r2,1
 20143d0:	108001cc 	andi	r2,r2,7
 20143d4:	e0bffc15 	stw	r2,-16(fp)
	duplex = result & 0x01;
 20143d8:	e0bffb17 	ldw	r2,-20(fp)
 20143dc:	1080004c 	andi	r2,r2,1
 20143e0:	e0bff415 	stw	r2,-48(fp)

	/* reset the mac */
	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 20143e4:	008085b4 	movhi	r2,534
 20143e8:	1088a104 	addi	r2,r2,8836
 20143ec:	e0fffe17 	ldw	r3,-8(fp)
 20143f0:	18c00924 	muli	r3,r3,36
 20143f4:	10c5883a 	add	r2,r2,r3
 20143f8:	10800017 	ldw	r2,0(r2)
 20143fc:	10800204 	addi	r2,r2,8
 2014400:	00c800c4 	movi	r3,8195
 2014404:	10c00035 	stwio	r3,0(r2)
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
 2014408:	e03ff515 	stw	zero,-44(fp)
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 201440c:	00000506 	br	2014424 <tse_mac_init+0x350>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
 2014410:	e0bff517 	ldw	r2,-44(fp)
 2014414:	10c00044 	addi	r3,r2,1
 2014418:	e0fff515 	stw	r3,-44(fp)
 201441c:	1089c450 	cmplti	r2,r2,10001
 2014420:	10000b26 	beq	r2,zero,2014450 <tse_mac_init+0x37c>
			mmac_cc_SW_RESET_mask |
			mmac_cc_TX_ENA_mask |
			mmac_cc_RX_ENA_mask);

	x = 0;
	while (IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) &
 2014424:	008085b4 	movhi	r2,534
 2014428:	1088a104 	addi	r2,r2,8836
 201442c:	e0fffe17 	ldw	r3,-8(fp)
 2014430:	18c00924 	muli	r3,r3,36
 2014434:	10c5883a 	add	r2,r2,r3
 2014438:	10800017 	ldw	r2,0(r2)
 201443c:	10800204 	addi	r2,r2,8
 2014440:	10800037 	ldwio	r2,0(r2)
 2014444:	1088000c 	andi	r2,r2,8192
 2014448:	103ff11e 	bne	r2,zero,2014410 <__alt_mem_mem_0+0xfcff4410>
 201444c:	00000106 	br	2014454 <tse_mac_init+0x380>
			ALTERA_TSEMAC_CMD_SW_RESET_MSK)
	{
		if( x++ > 10000 )
			break;
 2014450:	0001883a 	nop
	}

	if (x >= 10000)
		dprintf(("TSEMAC SW reset bit never cleared!\n"));

	dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 2014454:	008085b4 	movhi	r2,534
 2014458:	1088a104 	addi	r2,r2,8836
 201445c:	e0fffe17 	ldw	r3,-8(fp)
 2014460:	18c00924 	muli	r3,r3,36
 2014464:	10c5883a 	add	r2,r2,r3
 2014468:	10800017 	ldw	r2,0(r2)
 201446c:	10800204 	addi	r2,r2,8
 2014470:	10800037 	ldwio	r2,0(r2)
 2014474:	e0bff315 	stw	r2,-52(fp)
		dprintf(("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat));
	else
		dprintf(("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat));

	/* Initialize MAC registers */
	IOWR_ALTERA_TSEMAC_FRM_LENGTH(mi_base, PBUF_POOL_BUFSIZE+ETH_PAD_SIZE);
 2014478:	e0bffa17 	ldw	r2,-24(fp)
 201447c:	10800504 	addi	r2,r2,20
 2014480:	00c17b84 	movi	r3,1518
 2014484:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(mi_base, 8);
 2014488:	e0bffa17 	ldw	r2,-24(fp)
 201448c:	10800b04 	addi	r2,r2,44
 2014490:	00c00204 	movi	r3,8
 2014494:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(mi_base, 8);
 2014498:	e0bffa17 	ldw	r2,-24(fp)
 201449c:	10800c04 	addi	r2,r2,48
 20144a0:	00c00204 	movi	r3,8
 20144a4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(mi_base, 8);
 20144a8:	e0bffa17 	ldw	r2,-24(fp)
 20144ac:	10800d04 	addi	r2,r2,52
 20144b0:	00c00204 	movi	r3,8
 20144b4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(mi_base,  3);
 20144b8:	e0bffa17 	ldw	r2,-24(fp)
 20144bc:	10800e04 	addi	r2,r2,56
 20144c0:	00c000c4 	movi	r3,3
 20144c4:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(mi_base, tse_hw->tse_tx_depth - 16);
 20144c8:	e0bffa17 	ldw	r2,-24(fp)
 20144cc:	10800904 	addi	r2,r2,36
 20144d0:	e0fff717 	ldw	r3,-36(fp)
 20144d4:	18c0010b 	ldhu	r3,4(r3)
 20144d8:	18ffffcc 	andi	r3,r3,65535
 20144dc:	18fffc04 	addi	r3,r3,-16
 20144e0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(mi_base,  0);
 20144e4:	e0bffa17 	ldw	r2,-24(fp)
 20144e8:	10800a04 	addi	r2,r2,40
 20144ec:	0007883a 	mov	r3,zero
 20144f0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(mi_base, tse_hw->tse_rx_depth - 16);
 20144f4:	e0bffa17 	ldw	r2,-24(fp)
 20144f8:	10800704 	addi	r2,r2,28
 20144fc:	e0fff717 	ldw	r3,-36(fp)
 2014500:	18c0018b 	ldhu	r3,6(r3)
 2014504:	18ffffcc 	andi	r3,r3,65535
 2014508:	18fffc04 	addi	r3,r3,-16
 201450c:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(mi_base,  0);
 2014510:	e0bffa17 	ldw	r2,-24(fp)
 2014514:	10800804 	addi	r2,r2,32
 2014518:	0007883a 	mov	r3,zero
 201451c:	10c00035 	stwio	r3,0(r2)

	/* Enable TX shift 16 for removing two bytes from the start of all transmitted frames */
	IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 2014520:	008085b4 	movhi	r2,534
 2014524:	1088a104 	addi	r2,r2,8836
 2014528:	e0fffe17 	ldw	r3,-8(fp)
 201452c:	18c00924 	muli	r3,r3,36
 2014530:	10c5883a 	add	r2,r2,r3
 2014534:	10800017 	ldw	r2,0(r2)
 2014538:	10803a04 	addi	r2,r2,232
 201453c:	00c00134 	movhi	r3,4
 2014540:	10c00035 	stwio	r3,0(r2)

	/*
	 * check if the MAC supports the 16-bit shift option allowing us
	 * to send BIASed frames without copying. Used by the send function later.
	 */
	if ((IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) == 0)
 2014544:	008085b4 	movhi	r2,534
 2014548:	1088a104 	addi	r2,r2,8836
 201454c:	e0fffe17 	ldw	r3,-8(fp)
 2014550:	18c00924 	muli	r3,r3,36
 2014554:	10c5883a 	add	r2,r2,r3
 2014558:	10800017 	ldw	r2,0(r2)
 201455c:	10803a04 	addi	r2,r2,232
 2014560:	10800037 	ldwio	r2,0(r2)
 2014564:	1080012c 	andhi	r2,r2,4
 2014568:	1000021e 	bne	r2,zero,2014574 <tse_mac_init+0x4a0>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 201456c:	00bffc44 	movi	r2,-15
 2014570:	0000e606 	br	201490c <tse_mac_init+0x838>
	}

	/* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
	IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 2014574:	008085b4 	movhi	r2,534
 2014578:	1088a104 	addi	r2,r2,8836
 201457c:	e0fffe17 	ldw	r3,-8(fp)
 2014580:	18c00924 	muli	r3,r3,36
 2014584:	10c5883a 	add	r2,r2,r3
 2014588:	10800017 	ldw	r2,0(r2)
 201458c:	10803b04 	addi	r2,r2,236
 2014590:	00c08034 	movhi	r3,512
 2014594:	10c00035 	stwio	r3,0(r2)

	/* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */
	if ((IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK) == 0)
 2014598:	008085b4 	movhi	r2,534
 201459c:	1088a104 	addi	r2,r2,8836
 20145a0:	e0fffe17 	ldw	r3,-8(fp)
 20145a4:	18c00924 	muli	r3,r3,36
 20145a8:	10c5883a 	add	r2,r2,r3
 20145ac:	10800017 	ldw	r2,0(r2)
 20145b0:	10803b04 	addi	r2,r2,236
 20145b4:	10800037 	ldwio	r2,0(r2)
 20145b8:	1080802c 	andhi	r2,r2,512
 20145bc:	1000021e 	bne	r2,zero,20145c8 <tse_mac_init+0x4f4>
	{
		dprintf(("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETH_PAD_SIZE));
		return ERR_IF;
 20145c0:	00bffc44 	movi	r2,-15
 20145c4:	0000d106 	br	201490c <tse_mac_init+0x838>
	}

	/* Set the MAC address */
	IOWR_ALTERA_TSEMAC_MAC_0(mi_base,
 20145c8:	e0bffa17 	ldw	r2,-24(fp)
 20145cc:	10800304 	addi	r2,r2,12
 20145d0:	e0ffff17 	ldw	r3,-4(fp)
 20145d4:	18c00017 	ldw	r3,0(r3)
 20145d8:	18c00003 	ldbu	r3,0(r3)
 20145dc:	19003fcc 	andi	r4,r3,255
 20145e0:	e0ffff17 	ldw	r3,-4(fp)
 20145e4:	18c00017 	ldw	r3,0(r3)
 20145e8:	18c00043 	ldbu	r3,1(r3)
 20145ec:	18c03fcc 	andi	r3,r3,255
 20145f0:	1806923a 	slli	r3,r3,8
 20145f4:	20c8b03a 	or	r4,r4,r3
 20145f8:	e0ffff17 	ldw	r3,-4(fp)
 20145fc:	18c00017 	ldw	r3,0(r3)
 2014600:	18c00083 	ldbu	r3,2(r3)
 2014604:	18c03fcc 	andi	r3,r3,255
 2014608:	1806943a 	slli	r3,r3,16
 201460c:	20c8b03a 	or	r4,r4,r3
 2014610:	e0ffff17 	ldw	r3,-4(fp)
 2014614:	18c00017 	ldw	r3,0(r3)
 2014618:	18c000c3 	ldbu	r3,3(r3)
 201461c:	18c03fcc 	andi	r3,r3,255
 2014620:	1806963a 	slli	r3,r3,24
 2014624:	20c6b03a 	or	r3,r4,r3
 2014628:	10c00035 	stwio	r3,0(r2)
			((int)((unsigned char) ethernetif->ethaddr->addr[0]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[1] <<  8) |
					(int)((unsigned char) ethernetif->ethaddr->addr[2] << 16) |
					(int)((unsigned char) ethernetif->ethaddr->addr[3] << 24)));

	IOWR_ALTERA_TSEMAC_MAC_1(mi_base,
 201462c:	e0bffa17 	ldw	r2,-24(fp)
 2014630:	10800404 	addi	r2,r2,16
 2014634:	e0ffff17 	ldw	r3,-4(fp)
 2014638:	18c00017 	ldw	r3,0(r3)
 201463c:	18c00103 	ldbu	r3,4(r3)
 2014640:	19003fcc 	andi	r4,r3,255
 2014644:	e0ffff17 	ldw	r3,-4(fp)
 2014648:	18c00017 	ldw	r3,0(r3)
 201464c:	18c00143 	ldbu	r3,5(r3)
 2014650:	18c03fcc 	andi	r3,r3,255
 2014654:	1806923a 	slli	r3,r3,8
 2014658:	20c6b03a 	or	r3,r4,r3
 201465c:	18ffffcc 	andi	r3,r3,65535
 2014660:	10c00035 	stwio	r3,0(r2)
			(((int)((unsigned char) ethernetif->ethaddr->addr[4]) |
					(int)((unsigned char) ethernetif->ethaddr->addr[5] <<  8)) & 0xFFFF));

	/* enable MAC */
	dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 2014664:	00810034 	movhi	r2,1024
 2014668:	108080c4 	addi	r2,r2,515
 201466c:	e0bff315 	stw	r2,-52(fp)
			ALTERA_TSEMAC_CMD_LOOPBACK_MSK     |     // promiscuous mode
#endif
			ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
			ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */

	if ((result & ALT_TSE_E_AN_NOT_COMPLETE) == 0)
 2014670:	e0bffb17 	ldw	r2,-20(fp)
 2014674:	1080022c 	andhi	r2,r2,8
 2014678:	1000461e 	bne	r2,zero,2014794 <tse_mac_init+0x6c0>
	{
		speed = (result >> 1) & 0x07;
 201467c:	e0bffb17 	ldw	r2,-20(fp)
 2014680:	1005d07a 	srai	r2,r2,1
 2014684:	108001cc 	andi	r2,r2,7
 2014688:	e0bffc15 	stw	r2,-16(fp)
		duplex = result & 0x01;
 201468c:	e0bffb17 	ldw	r2,-20(fp)
 2014690:	1080004c 	andi	r2,r2,1
 2014694:	e0bff415 	stw	r2,-48(fp)

		/* 1000 Mbps */
		if(speed == 0x01)
 2014698:	e0bffc17 	ldw	r2,-16(fp)
 201469c:	10800058 	cmpnei	r2,r2,1
 20146a0:	1000121e 	bne	r2,zero,20146ec <tse_mac_init+0x618>
		{
			dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20146a4:	e0bff317 	ldw	r2,-52(fp)
 20146a8:	10800214 	ori	r2,r2,8
 20146ac:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20146b0:	e0fff317 	ldw	r3,-52(fp)
 20146b4:	00bf8034 	movhi	r2,65024
 20146b8:	10bfffc4 	addi	r2,r2,-1
 20146bc:	1884703a 	and	r2,r3,r2
 20146c0:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 1000;
 20146c4:	008085b4 	movhi	r2,534
 20146c8:	1088a104 	addi	r2,r2,8836
 20146cc:	e0fffe17 	ldw	r3,-8(fp)
 20146d0:	18c00924 	muli	r3,r3,36
 20146d4:	10c5883a 	add	r2,r2,r3
 20146d8:	10800604 	addi	r2,r2,24
 20146dc:	10800017 	ldw	r2,0(r2)
 20146e0:	00c0fa04 	movi	r3,1000
 20146e4:	10c00315 	stw	r3,12(r2)
 20146e8:	00003306 	br	20147b8 <tse_mac_init+0x6e4>
		}
		/* 100 Mbps */
		else if(speed == 0x02)
 20146ec:	e0bffc17 	ldw	r2,-16(fp)
 20146f0:	10800098 	cmpnei	r2,r2,2
 20146f4:	1000131e 	bne	r2,zero,2014744 <tse_mac_init+0x670>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20146f8:	e0fff317 	ldw	r3,-52(fp)
 20146fc:	00bffdc4 	movi	r2,-9
 2014700:	1884703a 	and	r2,r3,r2
 2014704:	e0bff315 	stw	r2,-52(fp)
			dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2014708:	e0fff317 	ldw	r3,-52(fp)
 201470c:	00bf8034 	movhi	r2,65024
 2014710:	10bfffc4 	addi	r2,r2,-1
 2014714:	1884703a 	and	r2,r3,r2
 2014718:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 100;
 201471c:	008085b4 	movhi	r2,534
 2014720:	1088a104 	addi	r2,r2,8836
 2014724:	e0fffe17 	ldw	r3,-8(fp)
 2014728:	18c00924 	muli	r3,r3,36
 201472c:	10c5883a 	add	r2,r2,r3
 2014730:	10800604 	addi	r2,r2,24
 2014734:	10800017 	ldw	r2,0(r2)
 2014738:	00c01904 	movi	r3,100
 201473c:	10c00315 	stw	r3,12(r2)
 2014740:	00001d06 	br	20147b8 <tse_mac_init+0x6e4>
		}
		/* 10 Mbps */
		else if(speed == 0x04)
 2014744:	e0bffc17 	ldw	r2,-16(fp)
 2014748:	10800118 	cmpnei	r2,r2,4
 201474c:	10001a1e 	bne	r2,zero,20147b8 <tse_mac_init+0x6e4>
		{
			dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2014750:	e0fff317 	ldw	r3,-52(fp)
 2014754:	00bffdc4 	movi	r2,-9
 2014758:	1884703a 	and	r2,r3,r2
 201475c:	e0bff315 	stw	r2,-52(fp)
			dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2014760:	e0bff317 	ldw	r2,-52(fp)
 2014764:	10808034 	orhi	r2,r2,512
 2014768:	e0bff315 	stw	r2,-52(fp)
			tse[iface].ethernetif->link_speed = 10;
 201476c:	008085b4 	movhi	r2,534
 2014770:	1088a104 	addi	r2,r2,8836
 2014774:	e0fffe17 	ldw	r3,-8(fp)
 2014778:	18c00924 	muli	r3,r3,36
 201477c:	10c5883a 	add	r2,r2,r3
 2014780:	10800604 	addi	r2,r2,24
 2014784:	10800017 	ldw	r2,0(r2)
 2014788:	00c00284 	movi	r3,10
 201478c:	10c00315 	stw	r3,12(r2)
 2014790:	00000906 	br	20147b8 <tse_mac_init+0x6e4>
		}
	}
	/* default to 100 Mbps if returned invalid speed */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2014794:	e0fff317 	ldw	r3,-52(fp)
 2014798:	00bffdc4 	movi	r2,-9
 201479c:	1884703a 	and	r2,r3,r2
 20147a0:	e0bff315 	stw	r2,-52(fp)
		dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20147a4:	e0fff317 	ldw	r3,-52(fp)
 20147a8:	00bf8034 	movhi	r2,65024
 20147ac:	10bfffc4 	addi	r2,r2,-1
 20147b0:	1884703a 	and	r2,r3,r2
 20147b4:	e0bff315 	stw	r2,-52(fp)
	}

	/* Half Duplex */
	if(duplex == TSE_PHY_DUPLEX_HALF)
 20147b8:	e0bff417 	ldw	r2,-48(fp)
 20147bc:	10000c1e 	bne	r2,zero,20147f0 <tse_mac_init+0x71c>
	{
		dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 20147c0:	e0bff317 	ldw	r2,-52(fp)
 20147c4:	10810014 	ori	r2,r2,1024
 20147c8:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 0;
 20147cc:	008085b4 	movhi	r2,534
 20147d0:	1088a104 	addi	r2,r2,8836
 20147d4:	e0fffe17 	ldw	r3,-8(fp)
 20147d8:	18c00924 	muli	r3,r3,36
 20147dc:	10c5883a 	add	r2,r2,r3
 20147e0:	10800604 	addi	r2,r2,24
 20147e4:	10800017 	ldw	r2,0(r2)
 20147e8:	10000415 	stw	zero,16(r2)
 20147ec:	00000d06 	br	2014824 <tse_mac_init+0x750>
	}
	/* Full Duplex */
	else
	{
		dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 20147f0:	e0fff317 	ldw	r3,-52(fp)
 20147f4:	00beffc4 	movi	r2,-1025
 20147f8:	1884703a 	and	r2,r3,r2
 20147fc:	e0bff315 	stw	r2,-52(fp)
		tse[iface].ethernetif->full_duplex = 1;
 2014800:	008085b4 	movhi	r2,534
 2014804:	1088a104 	addi	r2,r2,8836
 2014808:	e0fffe17 	ldw	r3,-8(fp)
 201480c:	18c00924 	muli	r3,r3,36
 2014810:	10c5883a 	add	r2,r2,r3
 2014814:	10800604 	addi	r2,r2,24
 2014818:	10800017 	ldw	r2,0(r2)
 201481c:	00c00044 	movi	r3,1
 2014820:	10c00415 	stw	r3,16(r2)
	}

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 2014824:	008085b4 	movhi	r2,534
 2014828:	1088a104 	addi	r2,r2,8836
 201482c:	e0fffe17 	ldw	r3,-8(fp)
 2014830:	18c00924 	muli	r3,r3,36
 2014834:	10c5883a 	add	r2,r2,r3
 2014838:	10800017 	ldw	r2,0(r2)
 201483c:	10800204 	addi	r2,r2,8
 2014840:	e0fff317 	ldw	r3,-52(fp)
 2014844:	10c00035 	stwio	r3,0(r2)
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 2014848:	008085b4 	movhi	r2,534
 201484c:	1088a104 	addi	r2,r2,8836
 2014850:	e0fffe17 	ldw	r3,-8(fp)
 2014854:	18c00924 	muli	r3,r3,36
 2014858:	10c5883a 	add	r2,r2,r3
 201485c:	10800204 	addi	r2,r2,8
 2014860:	11000017 	ldw	r4,0(r2)
#ifndef ALTERA_TSE_IRQ_R
			(alt_avalon_sgdma_callback)&tse_sgdma_rx_isr,
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));
 2014864:	e0bffe17 	ldw	r2,-8(fp)
 2014868:	10c00924 	muli	r3,r2,36
 201486c:	008085b4 	movhi	r2,534
 2014870:	1088a104 	addi	r2,r2,8836
 2014874:	1885883a 	add	r2,r3,r2

	IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
	dprintf(("\nMAC post-initialization: CMD_CONFIG=0x%08x\n",
			IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base)));

	alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma,
 2014878:	100f883a 	mov	r7,r2
 201487c:	01800604 	movi	r6,24
 2014880:	01408074 	movhi	r5,513
 2014884:	29527104 	addi	r5,r5,18884
 2014888:	20257d00 	call	20257d0 <alt_avalon_sgdma_register_callback>
#else
			(alt_avalon_sgdma_callback)&ALTERA_TSE_IRQ_R,
#endif
			(alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,(void*)(&tse[iface]));

	tse_sgdma_read_init(&tse[iface]);
 201488c:	e0bffe17 	ldw	r2,-8(fp)
 2014890:	10c00924 	muli	r3,r2,36
 2014894:	008085b4 	movhi	r2,534
 2014898:	1088a104 	addi	r2,r2,8836
 201489c:	1885883a 	add	r2,r3,r2
 20148a0:	1009883a 	mov	r4,r2
 20148a4:	20149200 	call	2014920 <tse_sgdma_read_init>
	pmac_info = alt_tse_get_mac_info(mi_base);
 20148a8:	e13ffa17 	ldw	r4,-24(fp)
 20148ac:	20273840 	call	2027384 <alt_tse_get_mac_info>
 20148b0:	e0bffd15 	stw	r2,-12(fp)
	alt_tse_phy_wr_mdio_addr(pmac_info->pphy_info, pmac_info->pphy_info->mdio_address);
 20148b4:	e0bffd17 	ldw	r2,-12(fp)
 20148b8:	10c00117 	ldw	r3,4(r2)
 20148bc:	e0bffd17 	ldw	r2,-12(fp)
 20148c0:	10800117 	ldw	r2,4(r2)
 20148c4:	10800003 	ldbu	r2,0(r2)
 20148c8:	10803fcc 	andi	r2,r2,255
 20148cc:	100b883a 	mov	r5,r2
 20148d0:	1809883a 	mov	r4,r3
 20148d4:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
	ethernetif->link_alive = alt_tse_phy_rd_mdio_reg(pmac_info->pphy_info, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) != 0;// && (((IORD(&(mi_base->mdio1.reg10), 0) >> 4) & 0xF) <= 3);
 20148d8:	e0bffd17 	ldw	r2,-12(fp)
 20148dc:	10800117 	ldw	r2,4(r2)
 20148e0:	01c00044 	movi	r7,1
 20148e4:	01800144 	movi	r6,5
 20148e8:	01400044 	movi	r5,1
 20148ec:	1009883a 	mov	r4,r2
 20148f0:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 20148f4:	1004c03a 	cmpne	r2,r2,zero
 20148f8:	10c03fcc 	andi	r3,r2,255
 20148fc:	e0bfff17 	ldw	r2,-4(fp)
 2014900:	10c00215 	stw	r3,8(r2)
	return ethernetif->link_alive;
 2014904:	e0bfff17 	ldw	r2,-4(fp)
 2014908:	10800217 	ldw	r2,8(r2)
}
 201490c:	e037883a 	mov	sp,fp
 2014910:	dfc00117 	ldw	ra,4(sp)
 2014914:	df000017 	ldw	fp,0(sp)
 2014918:	dec00204 	addi	sp,sp,8
 201491c:	f800283a 	ret

02014920 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(lwip_tse_info* tse_ptr)
{     
 2014920:	defffb04 	addi	sp,sp,-20
 2014924:	dfc00415 	stw	ra,16(sp)
 2014928:	df000315 	stw	fp,12(sp)
 201492c:	df000304 	addi	fp,sp,12
 2014930:	e13fff15 	stw	r4,-4(fp)
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;
 2014934:	e0bfff17 	ldw	r2,-4(fp)
 2014938:	10800617 	ldw	r2,24(r2)
 201493c:	e0bffe15 	stw	r2,-8(fp)

	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 2014940:	e0bfff17 	ldw	r2,-4(fp)
 2014944:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014948:	11001004 	addi	r4,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 201494c:	e0bfff17 	ldw	r2,-4(fp)
 2014950:	10800517 	ldw	r2,20(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014954:	11401804 	addi	r5,r2,96
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
			(alt_u32 *) ethernetif->lwipRxPbuf[tse_ptr->ethernetif->lwipRxIndexIsr]->payload,          // starting write_address
 2014958:	e0bfff17 	ldw	r2,-4(fp)
 201495c:	10800617 	ldw	r2,24(r2)
 2014960:	10801317 	ldw	r2,76(r2)
 2014964:	e0fffe17 	ldw	r3,-8(fp)
 2014968:	108001c4 	addi	r2,r2,7
 201496c:	1085883a 	add	r2,r2,r2
 2014970:	1085883a 	add	r2,r2,r2
 2014974:	1885883a 	add	r2,r3,r2
 2014978:	10800017 	ldw	r2,0(r2)
 201497c:	10800117 	ldw	r2,4(r2)
{     
	struct ethernetif *ethernetif;

	ethernetif = tse_ptr->ethernetif;

	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014980:	d8000015 	stw	zero,0(sp)
 2014984:	000f883a 	mov	r7,zero
 2014988:	100d883a 	mov	r6,r2
 201498c:	20255ec0 	call	20255ec <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  // read until EOP
			0);          // don't write to constant address

	dprintf(("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n",0));

	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 2014990:	e0ffff17 	ldw	r3,-4(fp)
 2014994:	e0bfff17 	ldw	r2,-4(fp)
 2014998:	10800517 	ldw	r2,20(r2)
 201499c:	10801004 	addi	r2,r2,64
 20149a0:	100b883a 	mov	r5,r2
 20149a4:	1809883a 	mov	r4,r3
 20149a8:	20262800 	call	2026280 <tse_mac_aRxRead>

	return SUCCESS;
 20149ac:	0005883a 	mov	r2,zero
}
 20149b0:	e037883a 	mov	sp,fp
 20149b4:	dfc00117 	ldw	ra,4(sp)
 20149b8:	df000017 	ldw	fp,0(sp)
 20149bc:	dec00204 	addi	sp,sp,8
 20149c0:	f800283a 	ret

020149c4 <tse_sgdma_rx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
int tse_sgdma_rx_isr(void * context, __unused u_long intnum)
{
 20149c4:	defffb04 	addi	sp,sp,-20
 20149c8:	dfc00415 	stw	ra,16(sp)
 20149cc:	df000315 	stw	fp,12(sp)
 20149d0:	df000304 	addi	fp,sp,12
 20149d4:	e13ffe15 	stw	r4,-8(fp)
 20149d8:	e17fff15 	stw	r5,-4(fp)
	lwip_tse_info* tse_ptr = (lwip_tse_info *) context;
 20149dc:	e0bffe17 	ldw	r2,-8(fp)
 20149e0:	e0bffd15 	stw	r2,-12(fp)

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base,ALTERA_AVALON_SGDMA_CONTROL_CLEAR_INTERRUPT_MSK);
 20149e4:	e0bffd17 	ldw	r2,-12(fp)
 20149e8:	10800217 	ldw	r2,8(r2)
 20149ec:	10800304 	addi	r2,r2,12
 20149f0:	10800404 	addi	r2,r2,16
 20149f4:	00e00034 	movhi	r3,32768
 20149f8:	10c00035 	stwio	r3,0(r2)

	// process the newly received data and cycle to the next free pbuf for receive
	tse_mac_rcv(tse_ptr->ethernetif);
 20149fc:	e0bffd17 	ldw	r2,-12(fp)
 2014a00:	10800617 	ldw	r2,24(r2)
 2014a04:	1009883a 	mov	r4,r2
 2014a08:	2014bb80 	call	2014bb8 <tse_mac_rcv>

	// start a new async read transaction
	tse_mac_aRxRead( &tse_ptr->mi, &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 2014a0c:	e0fffd17 	ldw	r3,-12(fp)
 2014a10:	e0bffd17 	ldw	r2,-12(fp)
 2014a14:	10800517 	ldw	r2,20(r2)
 2014a18:	10801004 	addi	r2,r2,64
 2014a1c:	100b883a 	mov	r5,r2
 2014a20:	1809883a 	mov	r4,r3
 2014a24:	20262800 	call	2026280 <tse_mac_aRxRead>

	IOWR_ALTERA_AVALON_SGDMA_CONTROL(&tse_ptr->mi.rx_sgdma->base, ALTERA_TSE_SGDMA_INTR_MASK);
 2014a28:	e0bffd17 	ldw	r2,-12(fp)
 2014a2c:	10800217 	ldw	r2,8(r2)
 2014a30:	10800304 	addi	r2,r2,12
 2014a34:	10800404 	addi	r2,r2,16
 2014a38:	00c00604 	movi	r3,24
 2014a3c:	10c00035 	stwio	r3,0(r2)

	return SUCCESS;
 2014a40:	0005883a 	mov	r2,zero
}
 2014a44:	e037883a 	mov	sp,fp
 2014a48:	dfc00117 	ldw	ra,4(sp)
 2014a4c:	df000017 	ldw	fp,0(sp)
 2014a50:	dec00204 	addi	sp,sp,8
 2014a54:	f800283a 	ret

02014a58 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
err_t tse_mac_raw_send(struct netif *netif, struct pbuf *pkt)
{
 2014a58:	defe6a04 	addi	sp,sp,-1624
 2014a5c:	dfc19515 	stw	ra,1620(sp)
 2014a60:	df019415 	stw	fp,1616(sp)
 2014a64:	df019404 	addi	fp,sp,1616
 2014a68:	e13ffe15 	stw	r4,-8(fp)
 2014a6c:	e17fff15 	stw	r5,-4(fp)
	alt_u32			   *ActualData;

	/* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
	char buf2[1560];

	ethernetif = netif->state;
 2014a70:	e0bffe17 	ldw	r2,-8(fp)
 2014a74:	10800917 	ldw	r2,36(r2)
 2014a78:	e0be7215 	stw	r2,-1592(fp)
	tse_ptr = ethernetif->tse_info;
 2014a7c:	e0be7217 	ldw	r2,-1592(fp)
 2014a80:	10801717 	ldw	r2,92(r2)
 2014a84:	e0be7315 	stw	r2,-1588(fp)
	mi = &tse_ptr->mi;
 2014a88:	e0be7317 	ldw	r2,-1588(fp)
 2014a8c:	e0be7415 	stw	r2,-1584(fp)

	for(p = pkt; p != NULL; p = p->next)
 2014a90:	e0bfff17 	ldw	r2,-4(fp)
 2014a94:	e0be7015 	stw	r2,-1600(fp)
 2014a98:	00003806 	br	2014b7c <tse_mac_raw_send+0x124>
	{
		data = p->payload;
 2014a9c:	e0be7017 	ldw	r2,-1600(fp)
 2014aa0:	10800117 	ldw	r2,4(r2)
 2014aa4:	e0be7115 	stw	r2,-1596(fp)
		len = p->len;
 2014aa8:	e0be7017 	ldw	r2,-1600(fp)
 2014aac:	1080028b 	ldhu	r2,10(r2)
 2014ab0:	10bfffcc 	andi	r2,r2,65535
 2014ab4:	e0be7515 	stw	r2,-1580(fp)

		// just in case we have an unaligned buffer, this should never occur
		if(((unsigned long)data & 0x03) != 0)
 2014ab8:	e0be7117 	ldw	r2,-1596(fp)
 2014abc:	108000cc 	andi	r2,r2,3
 2014ac0:	10000726 	beq	r2,zero,2014ae0 <tse_mac_raw_send+0x88>
			/*
			 * Copy data to temporary buffer <buf2>. This is done because of alignment
			 * issues. The SGDMA cannot copy the data directly from (data + ETH_PAD_SIZE)
			 * because it needs a 32-bit aligned address space.
			 */
			memcpy(buf2,data,len);
 2014ac4:	e0be7804 	addi	r2,fp,-1568
 2014ac8:	e1be7517 	ldw	r6,-1580(fp)
 2014acc:	e17e7117 	ldw	r5,-1596(fp)
 2014ad0:	1009883a 	mov	r4,r2
 2014ad4:	20060240 	call	2006024 <memcpy>
			data = (alt_u32 *)buf2;
 2014ad8:	e0be7804 	addi	r2,fp,-1568
 2014adc:	e0be7115 	stw	r2,-1596(fp)
		}

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));
 2014ae0:	e0be7117 	ldw	r2,-1596(fp)
 2014ae4:	e0be7615 	stw	r2,-1576(fp)

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 2014ae8:	e0be7317 	ldw	r2,-1588(fp)
 2014aec:	11000517 	ldw	r4,20(r2)
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 2014af0:	e0be7317 	ldw	r2,-1588(fp)
 2014af4:	10800517 	ldw	r2,20(r2)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 2014af8:	11400804 	addi	r5,r2,32
 2014afc:	e0be7517 	ldw	r2,-1580(fp)
 2014b00:	11bfffcc 	andi	r6,r2,65535
 2014b04:	e0fe7017 	ldw	r3,-1600(fp)
 2014b08:	e0bfff17 	ldw	r2,-4(fp)
 2014b0c:	1885003a 	cmpeq	r2,r3,r2
 2014b10:	10803fcc 	andi	r2,r2,255
				(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
				(alt_u32*)ActualData,                    // starting read address
				(len),                                   // # bytes
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
 2014b14:	e0fe7017 	ldw	r3,-1600(fp)
 2014b18:	18c00017 	ldw	r3,0(r3)

		// uncache the ethernet frame
		ActualData = (void*)(((alt_u32)data));

		/* Write data to Tx FIFO using the DMA */
		alt_avalon_sgdma_construct_mem_to_stream_desc(
 2014b1c:	1807003a 	cmpeq	r3,r3,zero
 2014b20:	18c03fcc 	andi	r3,r3,255
 2014b24:	d8000315 	stw	zero,12(sp)
 2014b28:	d8c00215 	stw	r3,8(sp)
 2014b2c:	d8800115 	stw	r2,4(sp)
 2014b30:	d8000015 	stw	zero,0(sp)
 2014b34:	300f883a 	mov	r7,r6
 2014b38:	e1be7617 	ldw	r6,-1576(fp)
 2014b3c:	20256c40 	call	20256c4 <alt_avalon_sgdma_construct_mem_to_stream_desc>
				0,                                       // don't read from constant address
				p == pkt,                                // generate sop
				p->next == NULL,                         // generate endofpacket signal
				0);                                      // atlantic channel (don't know/don't care: set to 0)

		tx_length = tse_mac_sTxWrite(mi,&tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST]);
 2014b40:	e0be7317 	ldw	r2,-1588(fp)
 2014b44:	10800517 	ldw	r2,20(r2)
 2014b48:	100b883a 	mov	r5,r2
 2014b4c:	e13e7417 	ldw	r4,-1584(fp)
 2014b50:	202619c0 	call	202619c <tse_mac_sTxWrite>
 2014b54:	e0be7715 	stw	r2,-1572(fp)

		if (tx_length != p->len)
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
 2014b58:	e0be7217 	ldw	r2,-1592(fp)
 2014b5c:	10c00517 	ldw	r3,20(r2)
 2014b60:	e0be7717 	ldw	r2,-1572(fp)
 2014b64:	1887883a 	add	r3,r3,r2
 2014b68:	e0be7217 	ldw	r2,-1592(fp)
 2014b6c:	10c00515 	stw	r3,20(r2)

	ethernetif = netif->state;
	tse_ptr = ethernetif->tse_info;
	mi = &tse_ptr->mi;

	for(p = pkt; p != NULL; p = p->next)
 2014b70:	e0be7017 	ldw	r2,-1600(fp)
 2014b74:	10800017 	ldw	r2,0(r2)
 2014b78:	e0be7015 	stw	r2,-1600(fp)
 2014b7c:	e0be7017 	ldw	r2,-1600(fp)
 2014b80:	103fc61e 	bne	r2,zero,2014a9c <__alt_mem_mem_0+0xfcff4a9c>
			dprintf(("failed to send all bytes, send %d out of %d\r\n", tx_length, p->len));

		ethernetif->bytes_sent += tx_length;
	}

	LINK_STATS_INC(link.xmit);
 2014b84:	008085f4 	movhi	r2,535
 2014b88:	10a8bc04 	addi	r2,r2,-23824
 2014b8c:	10800017 	ldw	r2,0(r2)
 2014b90:	10c00044 	addi	r3,r2,1
 2014b94:	008085f4 	movhi	r2,535
 2014b98:	10a8bc04 	addi	r2,r2,-23824
 2014b9c:	10c00015 	stw	r3,0(r2)

	return ERR_OK;
 2014ba0:	0005883a 	mov	r2,zero
}
 2014ba4:	e037883a 	mov	sp,fp
 2014ba8:	dfc00117 	ldw	ra,4(sp)
 2014bac:	df000017 	ldw	fp,0(sp)
 2014bb0:	dec00204 	addi	sp,sp,8
 2014bb4:	f800283a 	ret

02014bb8 <tse_mac_rcv>:
 * 
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */
int tse_mac_rcv(struct ethernetif *ethernetif)
{
 2014bb8:	defff704 	addi	sp,sp,-36
 2014bbc:	dfc00815 	stw	ra,32(sp)
 2014bc0:	df000715 	stw	fp,28(sp)
 2014bc4:	df000704 	addi	fp,sp,28
 2014bc8:	e13fff15 	stw	r4,-4(fp)
#if LWIP_RECEIVE_SEMAPHORE
	signed portBASE_TYPE switch_context = 0;
 2014bcc:	e03ffe15 	stw	zero,-8(fp)
	int pklen;
	lwip_tse_info* tse_ptr;
	alt_u32 *uncached_packet_payload;
	struct pbuf *p;

	tse_ptr = ethernetif->tse_info;
 2014bd0:	e0bfff17 	ldw	r2,-4(fp)
 2014bd4:	10801717 	ldw	r2,92(r2)
 2014bd8:	e0bffa15 	stw	r2,-24(fp)
	pklen = IORD_16DIRECT(&(tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST].actual_bytes_transferred),0);
 2014bdc:	e0bffa17 	ldw	r2,-24(fp)
 2014be0:	10800517 	ldw	r2,20(r2)
 2014be4:	10801004 	addi	r2,r2,64
 2014be8:	10800704 	addi	r2,r2,28
 2014bec:	1080002b 	ldhuio	r2,0(r2)
 2014bf0:	10bfffcc 	andi	r2,r2,65535
 2014bf4:	e0bffb15 	stw	r2,-20(fp)
	p = ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr];
 2014bf8:	e0bfff17 	ldw	r2,-4(fp)
 2014bfc:	10801317 	ldw	r2,76(r2)
 2014c00:	e0ffff17 	ldw	r3,-4(fp)
 2014c04:	108001c4 	addi	r2,r2,7
 2014c08:	1085883a 	add	r2,r2,r2
 2014c0c:	1085883a 	add	r2,r2,r2
 2014c10:	1885883a 	add	r2,r3,r2
 2014c14:	10800017 	ldw	r2,0(r2)
 2014c18:	e0bffc15 	stw	r2,-16(fp)
	p->tot_len = pklen;
 2014c1c:	e0bffb17 	ldw	r2,-20(fp)
 2014c20:	1007883a 	mov	r3,r2
 2014c24:	e0bffc17 	ldw	r2,-16(fp)
 2014c28:	10c0020d 	sth	r3,8(r2)
	p->len = pklen;
 2014c2c:	e0bffb17 	ldw	r2,-20(fp)
 2014c30:	1007883a 	mov	r3,r2
 2014c34:	e0bffc17 	ldw	r2,-16(fp)
 2014c38:	10c0028d 	sth	r3,10(r2)
	if ((IORD_ALTERA_TSE_SGDMA_DESC_STATUS(&tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]) & ( ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_CRC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_PARITY_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK )) == 0)
 2014c3c:	e0bffa17 	ldw	r2,-24(fp)
 2014c40:	10800517 	ldw	r2,20(r2)
 2014c44:	10801704 	addi	r2,r2,92
 2014c48:	10800037 	ldwio	r2,0(r2)
 2014c4c:	1005d43a 	srai	r2,r2,16
 2014c50:	10801fcc 	andi	r2,r2,127
 2014c54:	10002d1e 	bne	r2,zero,2014d0c <tse_mac_rcv+0x154>
	{
		enh_alt_irq_disable_all();
 2014c58:	202bf880 	call	202bf88 <enh_alt_irq_disable_all>

		if (++ethernetif->lwipRxCount >= LWIP_RX_ETH_BUFFER)
 2014c5c:	e0bfff17 	ldw	r2,-4(fp)
 2014c60:	10801517 	ldw	r2,84(r2)
 2014c64:	10800044 	addi	r2,r2,1
 2014c68:	e0ffff17 	ldw	r3,-4(fp)
 2014c6c:	18801515 	stw	r2,84(r3)
 2014c70:	10800310 	cmplti	r2,r2,12
 2014c74:	10000e1e 	bne	r2,zero,2014cb0 <tse_mac_rcv+0xf8>
		{
			LINK_STATS_INC(link.drop);
 2014c78:	008085f4 	movhi	r2,535
 2014c7c:	10a8bc04 	addi	r2,r2,-23824
 2014c80:	10800317 	ldw	r2,12(r2)
 2014c84:	10c00044 	addi	r3,r2,1
 2014c88:	008085f4 	movhi	r2,535
 2014c8c:	10a8bc04 	addi	r2,r2,-23824
 2014c90:	10c00315 	stw	r3,12(r2)
			--ethernetif->lwipRxCount;
 2014c94:	e0bfff17 	ldw	r2,-4(fp)
 2014c98:	10801517 	ldw	r2,84(r2)
 2014c9c:	10ffffc4 	addi	r3,r2,-1
 2014ca0:	e0bfff17 	ldw	r2,-4(fp)
 2014ca4:	10c01515 	stw	r3,84(r2)

			enh_alt_irq_enable_all();
 2014ca8:	202bfd80 	call	202bfd8 <enh_alt_irq_enable_all>
 2014cac:	00001706 	br	2014d0c <tse_mac_rcv+0x154>

			dprintf(("No free buffers for RX on iface: %hhd\n", ethernetif->iface));
		}
		else
		{
			ethernetif->bytes_recv += pklen;
 2014cb0:	e0bfff17 	ldw	r2,-4(fp)
 2014cb4:	10c00617 	ldw	r3,24(r2)
 2014cb8:	e0bffb17 	ldw	r2,-20(fp)
 2014cbc:	1887883a 	add	r3,r3,r2
 2014cc0:	e0bfff17 	ldw	r2,-4(fp)
 2014cc4:	10c00615 	stw	r3,24(r2)

			//  Set up DMA for the next pbuf in the buffer
			if (++ethernetif->lwipRxIndexIsr >= LWIP_RX_ETH_BUFFER)
 2014cc8:	e0bfff17 	ldw	r2,-4(fp)
 2014ccc:	10801317 	ldw	r2,76(r2)
 2014cd0:	10800044 	addi	r2,r2,1
 2014cd4:	e0ffff17 	ldw	r3,-4(fp)
 2014cd8:	18801315 	stw	r2,76(r3)
 2014cdc:	10800310 	cmplti	r2,r2,12
 2014ce0:	1000021e 	bne	r2,zero,2014cec <tse_mac_rcv+0x134>
				ethernetif->lwipRxIndexIsr = 0;
 2014ce4:	e0bfff17 	ldw	r2,-4(fp)
 2014ce8:	10001315 	stw	zero,76(r2)

			enh_alt_irq_enable_all();
 2014cec:	202bfd80 	call	202bfd8 <enh_alt_irq_enable_all>

#if LWIP_RECEIVE_SEMAPHORE
			// we can't use the LwIP sys_signal_sem since this can't be used in an ISR
			// release the semaphore and check if a task with a higher priority then the current one is waiting for it
			xSemaphoreGiveFromISR(ethernetif->tse_info->rx_semaphore, &switch_context);
 2014cf0:	e0bfff17 	ldw	r2,-4(fp)
 2014cf4:	10801717 	ldw	r2,92(r2)
 2014cf8:	10800817 	ldw	r2,32(r2)
 2014cfc:	e0fffe04 	addi	r3,fp,-8
 2014d00:	180b883a 	mov	r5,r3
 2014d04:	1009883a 	mov	r4,r2
 2014d08:	200dcec0 	call	200dcec <xQueueGiveFromISR>
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
 2014d0c:	e0bfff17 	ldw	r2,-4(fp)
 2014d10:	10801317 	ldw	r2,76(r2)
 2014d14:	e0ffff17 	ldw	r3,-4(fp)
 2014d18:	108001c4 	addi	r2,r2,7
 2014d1c:	1085883a 	add	r2,r2,r2
 2014d20:	1085883a 	add	r2,r2,r2
 2014d24:	1885883a 	add	r2,r3,r2
 2014d28:	10800017 	ldw	r2,0(r2)
 2014d2c:	10800117 	ldw	r2,4(r2)
 2014d30:	e0bffd15 	stw	r2,-12(fp)
	alt_avalon_sgdma_construct_stream_to_mem_desc(
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
 2014d34:	e0bffa17 	ldw	r2,-24(fp)
 2014d38:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014d3c:	10c01004 	addi	r3,r2,64
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],	// descriptor I want to work with
			(alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST],  // pointer to "next"
 2014d40:	e0bffa17 	ldw	r2,-24(fp)
 2014d44:	10800517 	ldw	r2,20(r2)
#endif
		}
	}

	uncached_packet_payload = (alt_u32 *) ethernetif->lwipRxPbuf[ethernetif->lwipRxIndexIsr]->payload;
	alt_avalon_sgdma_construct_stream_to_mem_desc(
 2014d48:	10801804 	addi	r2,r2,96
 2014d4c:	d8000015 	stw	zero,0(sp)
 2014d50:	000f883a 	mov	r7,zero
 2014d54:	e1bffd17 	ldw	r6,-12(fp)
 2014d58:	100b883a 	mov	r5,r2
 2014d5c:	1809883a 	mov	r4,r3
 2014d60:	20255ec0 	call	20255ec <alt_avalon_sgdma_construct_stream_to_mem_desc>
			0,                                  											// read until EOP
			0);          																	// don't write to constant address

#if LWIP_RECEIVE_SEMAPHORE
	// if it's waiting we will force a context switch so this task will run right away
	portEND_SWITCHING_ISR(switch_context);
 2014d64:	e0bffe17 	ldw	r2,-8(fp)
 2014d68:	10000126 	beq	r2,zero,2014d70 <tse_mac_rcv+0x1b8>
 2014d6c:	201001c0 	call	201001c <vTaskSwitchContext>
#endif

	return ERR_OK;
 2014d70:	0005883a 	mov	r2,zero
}
 2014d74:	e037883a 	mov	sp,fp
 2014d78:	dfc00117 	ldw	ra,4(sp)
 2014d7c:	df000017 	ldw	fp,0(sp)
 2014d80:	dec00204 	addi	sp,sp,8
 2014d84:	f800283a 	ret

02014d88 <sys_init>:
#include <lwip/err.h>
#include <lwip/stats.h>

// LwIP FreeRTOS port
void sys_init(void)
{
 2014d88:	deffff04 	addi	sp,sp,-4
 2014d8c:	df000015 	stw	fp,0(sp)
 2014d90:	d839883a 	mov	fp,sp
	return;
 2014d94:	0001883a 	nop
}
 2014d98:	e037883a 	mov	sp,fp
 2014d9c:	df000017 	ldw	fp,0(sp)
 2014da0:	dec00104 	addi	sp,sp,4
 2014da4:	f800283a 	ret

02014da8 <sys_now>:

u32_t sys_now(void)
{
 2014da8:	defffb04 	addi	sp,sp,-20
 2014dac:	dfc00415 	stw	ra,16(sp)
 2014db0:	df000315 	stw	fp,12(sp)
 2014db4:	dc000215 	stw	r16,8(sp)
 2014db8:	df000304 	addi	fp,sp,12
	struct timeval tv;
	gettimeofday(&tv, NULL);
 2014dbc:	000b883a 	mov	r5,zero
 2014dc0:	e13ffd04 	addi	r4,fp,-12
 2014dc4:	202c97c0 	call	202c97c <gettimeofday>

	return ((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 2014dc8:	e0bffd17 	ldw	r2,-12(fp)
 2014dcc:	1400fa24 	muli	r16,r2,1000
 2014dd0:	e0bffe17 	ldw	r2,-8(fp)
 2014dd4:	0140fa04 	movi	r5,1000
 2014dd8:	1009883a 	mov	r4,r2
 2014ddc:	200abb00 	call	200abb0 <__divsi3>
 2014de0:	8085883a 	add	r2,r16,r2
}
 2014de4:	e6ffff04 	addi	sp,fp,-4
 2014de8:	dfc00217 	ldw	ra,8(sp)
 2014dec:	df000117 	ldw	fp,4(sp)
 2014df0:	dc000017 	ldw	r16,0(sp)
 2014df4:	dec00304 	addi	sp,sp,12
 2014df8:	f800283a 	ret

02014dfc <sys_sem_new>:
/**
 * Creates and returns a new semaphore. The "count" argument specifies
 * the initial state of the semaphore.
 */
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 2014dfc:	defffc04 	addi	sp,sp,-16
 2014e00:	dfc00315 	stw	ra,12(sp)
 2014e04:	df000215 	stw	fp,8(sp)
 2014e08:	df000204 	addi	fp,sp,8
 2014e0c:	e13ffe15 	stw	r4,-8(fp)
 2014e10:	2805883a 	mov	r2,r5
 2014e14:	e0bfff05 	stb	r2,-4(fp)
	// count 0 means a binary semaphore so max value should be 1
	*sem = xSemaphoreCreateCounting((count ? count : 1), count);
 2014e18:	e0bfff03 	ldbu	r2,-4(fp)
 2014e1c:	10000226 	beq	r2,zero,2014e28 <sys_sem_new+0x2c>
 2014e20:	e0bfff03 	ldbu	r2,-4(fp)
 2014e24:	00000106 	br	2014e2c <sys_sem_new+0x30>
 2014e28:	00800044 	movi	r2,1
 2014e2c:	e0ffff03 	ldbu	r3,-4(fp)
 2014e30:	180b883a 	mov	r5,r3
 2014e34:	1009883a 	mov	r4,r2
 2014e38:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 2014e3c:	1007883a 	mov	r3,r2
 2014e40:	e0bffe17 	ldw	r2,-8(fp)
 2014e44:	10c00015 	stw	r3,0(r2)

	if (*sem == NULL) {
 2014e48:	e0bffe17 	ldw	r2,-8(fp)
 2014e4c:	10800017 	ldw	r2,0(r2)
 2014e50:	1000091e 	bne	r2,zero,2014e78 <sys_sem_new+0x7c>
		SYS_STATS_INC(sem.err);
 2014e54:	008085f4 	movhi	r2,535
 2014e58:	10a8bc04 	addi	r2,r2,-23824
 2014e5c:	10809617 	ldw	r2,600(r2)
 2014e60:	10c00044 	addi	r3,r2,1
 2014e64:	008085f4 	movhi	r2,535
 2014e68:	10a8bc04 	addi	r2,r2,-23824
 2014e6c:	10c09615 	stw	r3,600(r2)
		return ERR_MEM;  // TBD need assert
 2014e70:	00bfffc4 	movi	r2,-1
 2014e74:	00001506 	br	2014ecc <sys_sem_new+0xd0>
	}

	SYS_STATS_INC_USED(sem);
 2014e78:	008085f4 	movhi	r2,535
 2014e7c:	10a8bc04 	addi	r2,r2,-23824
 2014e80:	10809417 	ldw	r2,592(r2)
 2014e84:	10c00044 	addi	r3,r2,1
 2014e88:	008085f4 	movhi	r2,535
 2014e8c:	10a8bc04 	addi	r2,r2,-23824
 2014e90:	10c09415 	stw	r3,592(r2)
 2014e94:	008085f4 	movhi	r2,535
 2014e98:	10a8bc04 	addi	r2,r2,-23824
 2014e9c:	10c09517 	ldw	r3,596(r2)
 2014ea0:	008085f4 	movhi	r2,535
 2014ea4:	10a8bc04 	addi	r2,r2,-23824
 2014ea8:	10809417 	ldw	r2,592(r2)
 2014eac:	1880062e 	bgeu	r3,r2,2014ec8 <sys_sem_new+0xcc>
 2014eb0:	008085f4 	movhi	r2,535
 2014eb4:	10a8bc04 	addi	r2,r2,-23824
 2014eb8:	10c09417 	ldw	r3,592(r2)
 2014ebc:	008085f4 	movhi	r2,535
 2014ec0:	10a8bc04 	addi	r2,r2,-23824
 2014ec4:	10c09515 	stw	r3,596(r2)

	return ERR_OK;
 2014ec8:	0005883a 	mov	r2,zero
}
 2014ecc:	e037883a 	mov	sp,fp
 2014ed0:	dfc00117 	ldw	ra,4(sp)
 2014ed4:	df000017 	ldw	fp,0(sp)
 2014ed8:	dec00204 	addi	sp,sp,8
 2014edc:	f800283a 	ret

02014ee0 <sys_sem_free>:

/**
 * Deallocates a semaphore.
 */
void sys_sem_free(sys_sem_t *sem)
{
 2014ee0:	defffd04 	addi	sp,sp,-12
 2014ee4:	dfc00215 	stw	ra,8(sp)
 2014ee8:	df000115 	stw	fp,4(sp)
 2014eec:	df000104 	addi	fp,sp,4
 2014ef0:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*sem);
 2014ef4:	e0bfff17 	ldw	r2,-4(fp)
 2014ef8:	10800017 	ldw	r2,0(r2)
 2014efc:	1009883a 	mov	r4,r2
 2014f00:	200e62c0 	call	200e62c <vQueueDelete>

	SYS_STATS_DEC(sem.used);
 2014f04:	008085f4 	movhi	r2,535
 2014f08:	10a8bc04 	addi	r2,r2,-23824
 2014f0c:	10809417 	ldw	r2,592(r2)
 2014f10:	10ffffc4 	addi	r3,r2,-1
 2014f14:	008085f4 	movhi	r2,535
 2014f18:	10a8bc04 	addi	r2,r2,-23824
 2014f1c:	10c09415 	stw	r3,592(r2)
}
 2014f20:	0001883a 	nop
 2014f24:	e037883a 	mov	sp,fp
 2014f28:	dfc00117 	ldw	ra,4(sp)
 2014f2c:	df000017 	ldw	fp,0(sp)
 2014f30:	dec00204 	addi	sp,sp,8
 2014f34:	f800283a 	ret

02014f38 <sys_sem_signal>:

/**
 * Signals a semaphore.
 */
void sys_sem_signal(sys_sem_t *sem)
{
 2014f38:	defffd04 	addi	sp,sp,-12
 2014f3c:	dfc00215 	stw	ra,8(sp)
 2014f40:	df000115 	stw	fp,4(sp)
 2014f44:	df000104 	addi	fp,sp,4
 2014f48:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*sem);
 2014f4c:	e0bfff17 	ldw	r2,-4(fp)
 2014f50:	10800017 	ldw	r2,0(r2)
 2014f54:	000f883a 	mov	r7,zero
 2014f58:	000d883a 	mov	r6,zero
 2014f5c:	000b883a 	mov	r5,zero
 2014f60:	1009883a 	mov	r4,r2
 2014f64:	200da140 	call	200da14 <xQueueGenericSend>
}
 2014f68:	0001883a 	nop
 2014f6c:	e037883a 	mov	sp,fp
 2014f70:	dfc00117 	ldw	ra,4(sp)
 2014f74:	df000017 	ldw	fp,0(sp)
 2014f78:	dec00204 	addi	sp,sp,8
 2014f7c:	f800283a 	ret

02014f80 <sys_arch_sem_wait>:
 *
 * Notice that lwIP implements a function with a similar name,
 * sys_sem_wait(), that uses the sys_arch_sem_wait() function.
 */
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 2014f80:	defff904 	addi	sp,sp,-28
 2014f84:	dfc00615 	stw	ra,24(sp)
 2014f88:	df000515 	stw	fp,20(sp)
 2014f8c:	df000504 	addi	fp,sp,20
 2014f90:	e13ffe15 	stw	r4,-8(fp)
 2014f94:	e17fff15 	stw	r5,-4(fp)
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
 2014f98:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2014f9c:	e0bffc15 	stw	r2,-16(fp)

	if (timeout != 0)
 2014fa0:	e0bfff17 	ldw	r2,-4(fp)
 2014fa4:	10001526 	beq	r2,zero,2014ffc <sys_arch_sem_wait+0x7c>
	{
		if (xSemaphoreTake(*sem, timeout) == pdTRUE)
 2014fa8:	e0bffe17 	ldw	r2,-8(fp)
 2014fac:	10800017 	ldw	r2,0(r2)
 2014fb0:	e17fff17 	ldw	r5,-4(fp)
 2014fb4:	1009883a 	mov	r4,r2
 2014fb8:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
 2014fbc:	10800058 	cmpnei	r2,r2,1
 2014fc0:	10000c1e 	bne	r2,zero,2014ff4 <sys_arch_sem_wait+0x74>
		{
			nEndTime = xTaskGetTickCount();
 2014fc4:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2014fc8:	e0bffd15 	stw	r2,-12(fp)
			nElapsed = nEndTime - nStartTime;
 2014fcc:	e0fffd17 	ldw	r3,-12(fp)
 2014fd0:	e0bffc17 	ldw	r2,-16(fp)
 2014fd4:	1885c83a 	sub	r2,r3,r2
 2014fd8:	e0bffb15 	stw	r2,-20(fp)

			if (nElapsed == 0)
 2014fdc:	e0bffb17 	ldw	r2,-20(fp)
 2014fe0:	1000021e 	bne	r2,zero,2014fec <sys_arch_sem_wait+0x6c>
				nElapsed = 1;
 2014fe4:	00800044 	movi	r2,1
 2014fe8:	e0bffb15 	stw	r2,-20(fp)

			return nElapsed; // return time blocked TBD test
 2014fec:	e0bffb17 	ldw	r2,-20(fp)
 2014ff0:	00001506 	br	2015048 <sys_arch_sem_wait+0xc8>
		}
		else
			return SYS_ARCH_TIMEOUT;
 2014ff4:	00bfffc4 	movi	r2,-1
 2014ff8:	00001306 	br	2015048 <sys_arch_sem_wait+0xc8>
	}
	else // must block without a timeout
	{
		while (xSemaphoreTake(*sem, 10000) != pdTRUE);
 2014ffc:	0001883a 	nop
 2015000:	e0bffe17 	ldw	r2,-8(fp)
 2015004:	10800017 	ldw	r2,0(r2)
 2015008:	0149c404 	movi	r5,10000
 201500c:	1009883a 	mov	r4,r2
 2015010:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
 2015014:	10800058 	cmpnei	r2,r2,1
 2015018:	103ff91e 	bne	r2,zero,2015000 <__alt_mem_mem_0+0xfcff5000>

		nEndTime = xTaskGetTickCount();
 201501c:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2015020:	e0bffd15 	stw	r2,-12(fp)
		nElapsed = nEndTime - nStartTime;
 2015024:	e0fffd17 	ldw	r3,-12(fp)
 2015028:	e0bffc17 	ldw	r2,-16(fp)
 201502c:	1885c83a 	sub	r2,r3,r2
 2015030:	e0bffb15 	stw	r2,-20(fp)
		if( nElapsed == 0 )
 2015034:	e0bffb17 	ldw	r2,-20(fp)
 2015038:	1000021e 	bne	r2,zero,2015044 <sys_arch_sem_wait+0xc4>
			nElapsed = 1;
 201503c:	00800044 	movi	r2,1
 2015040:	e0bffb15 	stw	r2,-20(fp)

		return nElapsed; // return time blocked
 2015044:	e0bffb17 	ldw	r2,-20(fp)
	}
}
 2015048:	e037883a 	mov	sp,fp
 201504c:	dfc00117 	ldw	ra,4(sp)
 2015050:	df000017 	ldw	fp,0(sp)
 2015054:	dec00204 	addi	sp,sp,8
 2015058:	f800283a 	ret

0201505c <sys_mutex_new>:
#if ! LWIP_COMPAT_MUTEX
/** Create a new mutex
 * @param mutex pointer to the mutex to create
 * @return a new mutex */
err_t sys_mutex_new(sys_mutex_t *mutex)
{
 201505c:	defffd04 	addi	sp,sp,-12
 2015060:	dfc00215 	stw	ra,8(sp)
 2015064:	df000115 	stw	fp,4(sp)
 2015068:	df000104 	addi	fp,sp,4
 201506c:	e13fff15 	stw	r4,-4(fp)
	*mutex = xSemaphoreCreateMutex();
 2015070:	01000044 	movi	r4,1
 2015074:	200d8340 	call	200d834 <xQueueCreateMutex>
 2015078:	1007883a 	mov	r3,r2
 201507c:	e0bfff17 	ldw	r2,-4(fp)
 2015080:	10c00015 	stw	r3,0(r2)

	if (!*mutex) {
 2015084:	e0bfff17 	ldw	r2,-4(fp)
 2015088:	10800017 	ldw	r2,0(r2)
 201508c:	1000091e 	bne	r2,zero,20150b4 <sys_mutex_new+0x58>
		SYS_STATS_INC(mutex.err);
 2015090:	008085f4 	movhi	r2,535
 2015094:	10a8bc04 	addi	r2,r2,-23824
 2015098:	10809917 	ldw	r2,612(r2)
 201509c:	10c00044 	addi	r3,r2,1
 20150a0:	008085f4 	movhi	r2,535
 20150a4:	10a8bc04 	addi	r2,r2,-23824
 20150a8:	10c09915 	stw	r3,612(r2)
		return ERR_MEM;
 20150ac:	00bfffc4 	movi	r2,-1
 20150b0:	00001506 	br	2015108 <sys_mutex_new+0xac>
	}

	SYS_STATS_INC_USED(mutex);
 20150b4:	008085f4 	movhi	r2,535
 20150b8:	10a8bc04 	addi	r2,r2,-23824
 20150bc:	10809717 	ldw	r2,604(r2)
 20150c0:	10c00044 	addi	r3,r2,1
 20150c4:	008085f4 	movhi	r2,535
 20150c8:	10a8bc04 	addi	r2,r2,-23824
 20150cc:	10c09715 	stw	r3,604(r2)
 20150d0:	008085f4 	movhi	r2,535
 20150d4:	10a8bc04 	addi	r2,r2,-23824
 20150d8:	10c09817 	ldw	r3,608(r2)
 20150dc:	008085f4 	movhi	r2,535
 20150e0:	10a8bc04 	addi	r2,r2,-23824
 20150e4:	10809717 	ldw	r2,604(r2)
 20150e8:	1880062e 	bgeu	r3,r2,2015104 <sys_mutex_new+0xa8>
 20150ec:	008085f4 	movhi	r2,535
 20150f0:	10a8bc04 	addi	r2,r2,-23824
 20150f4:	10c09717 	ldw	r3,604(r2)
 20150f8:	008085f4 	movhi	r2,535
 20150fc:	10a8bc04 	addi	r2,r2,-23824
 2015100:	10c09815 	stw	r3,608(r2)

	return ERR_OK;
 2015104:	0005883a 	mov	r2,zero
}
 2015108:	e037883a 	mov	sp,fp
 201510c:	dfc00117 	ldw	ra,4(sp)
 2015110:	df000017 	ldw	fp,0(sp)
 2015114:	dec00204 	addi	sp,sp,8
 2015118:	f800283a 	ret

0201511c <sys_mutex_lock>:

/** Lock a mutex
 * @param mutex the mutex to lock */
void sys_mutex_lock(sys_mutex_t *mutex)
{
 201511c:	defffd04 	addi	sp,sp,-12
 2015120:	dfc00215 	stw	ra,8(sp)
 2015124:	df000115 	stw	fp,4(sp)
 2015128:	df000104 	addi	fp,sp,4
 201512c:	e13fff15 	stw	r4,-4(fp)
	// wait on mutex forever
	while (xSemaphoreTake(*mutex, 10000) != pdTRUE);
 2015130:	0001883a 	nop
 2015134:	e0bfff17 	ldw	r2,-4(fp)
 2015138:	10800017 	ldw	r2,0(r2)
 201513c:	0149c404 	movi	r5,10000
 2015140:	1009883a 	mov	r4,r2
 2015144:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
 2015148:	10800058 	cmpnei	r2,r2,1
 201514c:	103ff91e 	bne	r2,zero,2015134 <__alt_mem_mem_0+0xfcff5134>
}
 2015150:	0001883a 	nop
 2015154:	e037883a 	mov	sp,fp
 2015158:	dfc00117 	ldw	ra,4(sp)
 201515c:	df000017 	ldw	fp,0(sp)
 2015160:	dec00204 	addi	sp,sp,8
 2015164:	f800283a 	ret

02015168 <sys_mutex_unlock>:

/** Unlock a mutex
 * @param mutex the mutex to unlock */
void sys_mutex_unlock(sys_mutex_t *mutex)
{
 2015168:	defffd04 	addi	sp,sp,-12
 201516c:	dfc00215 	stw	ra,8(sp)
 2015170:	df000115 	stw	fp,4(sp)
 2015174:	df000104 	addi	fp,sp,4
 2015178:	e13fff15 	stw	r4,-4(fp)
	xSemaphoreGive(*mutex);
 201517c:	e0bfff17 	ldw	r2,-4(fp)
 2015180:	10800017 	ldw	r2,0(r2)
 2015184:	000f883a 	mov	r7,zero
 2015188:	000d883a 	mov	r6,zero
 201518c:	000b883a 	mov	r5,zero
 2015190:	1009883a 	mov	r4,r2
 2015194:	200da140 	call	200da14 <xQueueGenericSend>
}
 2015198:	0001883a 	nop
 201519c:	e037883a 	mov	sp,fp
 20151a0:	dfc00117 	ldw	ra,4(sp)
 20151a4:	df000017 	ldw	fp,0(sp)
 20151a8:	dec00204 	addi	sp,sp,8
 20151ac:	f800283a 	ret

020151b0 <sys_mutex_free>:

/** Delete a semaphore
 * @param mutex the mutex to delete */
void sys_mutex_free(sys_mutex_t *mutex)
{
 20151b0:	defffd04 	addi	sp,sp,-12
 20151b4:	dfc00215 	stw	ra,8(sp)
 20151b8:	df000115 	stw	fp,4(sp)
 20151bc:	df000104 	addi	fp,sp,4
 20151c0:	e13fff15 	stw	r4,-4(fp)
	vQueueDelete(*mutex);
 20151c4:	e0bfff17 	ldw	r2,-4(fp)
 20151c8:	10800017 	ldw	r2,0(r2)
 20151cc:	1009883a 	mov	r4,r2
 20151d0:	200e62c0 	call	200e62c <vQueueDelete>
	SYS_STATS_DEC(mutex.used);
 20151d4:	008085f4 	movhi	r2,535
 20151d8:	10a8bc04 	addi	r2,r2,-23824
 20151dc:	10809717 	ldw	r2,604(r2)
 20151e0:	10ffffc4 	addi	r3,r2,-1
 20151e4:	008085f4 	movhi	r2,535
 20151e8:	10a8bc04 	addi	r2,r2,-23824
 20151ec:	10c09715 	stw	r3,604(r2)
}
 20151f0:	0001883a 	nop
 20151f4:	e037883a 	mov	sp,fp
 20151f8:	dfc00117 	ldw	ra,4(sp)
 20151fc:	df000017 	ldw	fp,0(sp)
 2015200:	dec00204 	addi	sp,sp,8
 2015204:	f800283a 	ret

02015208 <sys_mbox_new>:
 * in mailboxes are pointers. You have to define macros "_MBOX_SIZE"
 * in your lwipopts.h, or ignore this parameter in your implementation
 * and use a default size.
 */
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
 2015208:	defffc04 	addi	sp,sp,-16
 201520c:	dfc00315 	stw	ra,12(sp)
 2015210:	df000215 	stw	fp,8(sp)
 2015214:	df000204 	addi	fp,sp,8
 2015218:	e13ffe15 	stw	r4,-8(fp)
 201521c:	e17fff15 	stw	r5,-4(fp)
	*mbox = xQueueCreate(size, sizeof(void *)); // XXX correct? We are posting pointers so I guess it is...
 2015220:	e0bfff17 	ldw	r2,-4(fp)
 2015224:	000d883a 	mov	r6,zero
 2015228:	01400104 	movi	r5,4
 201522c:	1009883a 	mov	r4,r2
 2015230:	200d6ac0 	call	200d6ac <xQueueGenericCreate>
 2015234:	1007883a 	mov	r3,r2
 2015238:	e0bffe17 	ldw	r2,-8(fp)
 201523c:	10c00015 	stw	r3,0(r2)

	if (!*mbox) {
 2015240:	e0bffe17 	ldw	r2,-8(fp)
 2015244:	10800017 	ldw	r2,0(r2)
 2015248:	1000091e 	bne	r2,zero,2015270 <sys_mbox_new+0x68>
		SYS_STATS_INC(mbox.err);
 201524c:	008085f4 	movhi	r2,535
 2015250:	10a8bc04 	addi	r2,r2,-23824
 2015254:	10809c17 	ldw	r2,624(r2)
 2015258:	10c00044 	addi	r3,r2,1
 201525c:	008085f4 	movhi	r2,535
 2015260:	10a8bc04 	addi	r2,r2,-23824
 2015264:	10c09c15 	stw	r3,624(r2)
		return ERR_MEM;
 2015268:	00bfffc4 	movi	r2,-1
 201526c:	00001506 	br	20152c4 <sys_mbox_new+0xbc>
	}

	SYS_STATS_INC_USED(mbox);
 2015270:	008085f4 	movhi	r2,535
 2015274:	10a8bc04 	addi	r2,r2,-23824
 2015278:	10809a17 	ldw	r2,616(r2)
 201527c:	10c00044 	addi	r3,r2,1
 2015280:	008085f4 	movhi	r2,535
 2015284:	10a8bc04 	addi	r2,r2,-23824
 2015288:	10c09a15 	stw	r3,616(r2)
 201528c:	008085f4 	movhi	r2,535
 2015290:	10a8bc04 	addi	r2,r2,-23824
 2015294:	10c09b17 	ldw	r3,620(r2)
 2015298:	008085f4 	movhi	r2,535
 201529c:	10a8bc04 	addi	r2,r2,-23824
 20152a0:	10809a17 	ldw	r2,616(r2)
 20152a4:	1880062e 	bgeu	r3,r2,20152c0 <sys_mbox_new+0xb8>
 20152a8:	008085f4 	movhi	r2,535
 20152ac:	10a8bc04 	addi	r2,r2,-23824
 20152b0:	10c09a17 	ldw	r3,616(r2)
 20152b4:	008085f4 	movhi	r2,535
 20152b8:	10a8bc04 	addi	r2,r2,-23824
 20152bc:	10c09b15 	stw	r3,620(r2)

	return ERR_OK;
 20152c0:	0005883a 	mov	r2,zero
}
 20152c4:	e037883a 	mov	sp,fp
 20152c8:	dfc00117 	ldw	ra,4(sp)
 20152cc:	df000017 	ldw	fp,0(sp)
 20152d0:	dec00204 	addi	sp,sp,8
 20152d4:	f800283a 	ret

020152d8 <sys_mbox_free>:
 * Deallocates a mailbox. If there are messages still present in the
 * mailbox when the mailbox is deallocated, it is an indication of a
 * programming error in lwIP and the developer should be notified.
 */
void sys_mbox_free(sys_mbox_t *mbox)
{
 20152d8:	defffd04 	addi	sp,sp,-12
 20152dc:	dfc00215 	stw	ra,8(sp)
 20152e0:	df000115 	stw	fp,4(sp)
 20152e4:	df000104 	addi	fp,sp,4
 20152e8:	e13fff15 	stw	r4,-4(fp)
	if (uxQueueMessagesWaiting(*mbox))
 20152ec:	e0bfff17 	ldw	r2,-4(fp)
 20152f0:	10800017 	ldw	r2,0(r2)
 20152f4:	1009883a 	mov	r4,r2
 20152f8:	200e5400 	call	200e540 <uxQueueMessagesWaiting>
 20152fc:	10000126 	beq	r2,zero,2015304 <sys_mbox_free+0x2c>
	{
		// Line for breakpoint.  Should never break here!
		__asm__ __volatile__ ( "nop" );
 2015300:	0001883a 	nop
	}

	vQueueDelete(*mbox);
 2015304:	e0bfff17 	ldw	r2,-4(fp)
 2015308:	10800017 	ldw	r2,0(r2)
 201530c:	1009883a 	mov	r4,r2
 2015310:	200e62c0 	call	200e62c <vQueueDelete>

	SYS_STATS_DEC(mbox.used);
 2015314:	008085f4 	movhi	r2,535
 2015318:	10a8bc04 	addi	r2,r2,-23824
 201531c:	10809a17 	ldw	r2,616(r2)
 2015320:	10ffffc4 	addi	r3,r2,-1
 2015324:	008085f4 	movhi	r2,535
 2015328:	10a8bc04 	addi	r2,r2,-23824
 201532c:	10c09a15 	stw	r3,616(r2)
}
 2015330:	0001883a 	nop
 2015334:	e037883a 	mov	sp,fp
 2015338:	dfc00117 	ldw	ra,4(sp)
 201533c:	df000017 	ldw	fp,0(sp)
 2015340:	dec00204 	addi	sp,sp,8
 2015344:	f800283a 	ret

02015348 <sys_mbox_post>:
/**
 * Posts the "msg" to the mailbox. This function have to block until
 * the "msg" is really posted.
 */
void sys_mbox_post(sys_mbox_t *mbox, void *data)
{
 2015348:	defffc04 	addi	sp,sp,-16
 201534c:	dfc00315 	stw	ra,12(sp)
 2015350:	df000215 	stw	fp,8(sp)
 2015354:	df000204 	addi	fp,sp,8
 2015358:	e13ffe15 	stw	r4,-8(fp)
 201535c:	e17fff15 	stw	r5,-4(fp)
	xQueueSend(*mbox, &data, (portTickType)(archPOST_BLOCK_TIME_MS / portTICK_RATE_MS));
 2015360:	e0bffe17 	ldw	r2,-8(fp)
 2015364:	10800017 	ldw	r2,0(r2)
 2015368:	e0ffff04 	addi	r3,fp,-4
 201536c:	000f883a 	mov	r7,zero
 2015370:	0189c404 	movi	r6,10000
 2015374:	180b883a 	mov	r5,r3
 2015378:	1009883a 	mov	r4,r2
 201537c:	200da140 	call	200da14 <xQueueGenericSend>
}
 2015380:	0001883a 	nop
 2015384:	e037883a 	mov	sp,fp
 2015388:	dfc00117 	ldw	ra,4(sp)
 201538c:	df000017 	ldw	fp,0(sp)
 2015390:	dec00204 	addi	sp,sp,8
 2015394:	f800283a 	ret

02015398 <sys_mbox_trypost>:
/**
 * Try to post the "msg" to the mailbox. Returns ERR_MEM if this one
 * is full, else, ERR_OK if the "msg" is posted.
 */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *data)
{
 2015398:	defffc04 	addi	sp,sp,-16
 201539c:	dfc00315 	stw	ra,12(sp)
 20153a0:	df000215 	stw	fp,8(sp)
 20153a4:	df000204 	addi	fp,sp,8
 20153a8:	e13ffe15 	stw	r4,-8(fp)
 20153ac:	e17fff15 	stw	r5,-4(fp)
	return (xQueueSend(*mbox, &data, 0) == pdTRUE) ? ERR_OK : ERR_MEM;
 20153b0:	e0bffe17 	ldw	r2,-8(fp)
 20153b4:	10800017 	ldw	r2,0(r2)
 20153b8:	e0ffff04 	addi	r3,fp,-4
 20153bc:	000f883a 	mov	r7,zero
 20153c0:	000d883a 	mov	r6,zero
 20153c4:	180b883a 	mov	r5,r3
 20153c8:	1009883a 	mov	r4,r2
 20153cc:	200da140 	call	200da14 <xQueueGenericSend>
 20153d0:	10800058 	cmpnei	r2,r2,1
 20153d4:	1000021e 	bne	r2,zero,20153e0 <sys_mbox_trypost+0x48>
 20153d8:	0005883a 	mov	r2,zero
 20153dc:	00000106 	br	20153e4 <sys_mbox_trypost+0x4c>
 20153e0:	00bfffc4 	movi	r2,-1
}
 20153e4:	e037883a 	mov	sp,fp
 20153e8:	dfc00117 	ldw	ra,4(sp)
 20153ec:	df000017 	ldw	fp,0(sp)
 20153f0:	dec00204 	addi	sp,sp,8
 20153f4:	f800283a 	ret

020153f8 <sys_arch_mbox_fetch>:
 *
 * Note that a function with a similar name, sys_mbox_fetch(), is
 * implemented by lwIP.
 */
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 20153f8:	defff704 	addi	sp,sp,-36
 20153fc:	dfc00815 	stw	ra,32(sp)
 2015400:	df000715 	stw	fp,28(sp)
 2015404:	df000704 	addi	fp,sp,28
 2015408:	e13ffd15 	stw	r4,-12(fp)
 201540c:	e17ffe15 	stw	r5,-8(fp)
 2015410:	e1bfff15 	stw	r6,-4(fp)
	void *dummyptr;
	portTickType nStartTime, nEndTime, nElapsed;

	nStartTime = xTaskGetTickCount();
 2015414:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2015418:	e0bffa15 	stw	r2,-24(fp)

	if (msg == NULL)
 201541c:	e0bffe17 	ldw	r2,-8(fp)
 2015420:	1000021e 	bne	r2,zero,201542c <sys_arch_mbox_fetch+0x34>
		msg = &dummyptr;
 2015424:	e0bffc04 	addi	r2,fp,-16
 2015428:	e0bffe15 	stw	r2,-8(fp)

	if (timeout != 0)
 201542c:	e0bfff17 	ldw	r2,-4(fp)
 2015430:	10001826 	beq	r2,zero,2015494 <sys_arch_mbox_fetch+0x9c>
	{
		if (pdTRUE == xQueueReceive(*mbox, msg, timeout))
 2015434:	e0bffd17 	ldw	r2,-12(fp)
 2015438:	10800017 	ldw	r2,0(r2)
 201543c:	e1bfff17 	ldw	r6,-4(fp)
 2015440:	e17ffe17 	ldw	r5,-8(fp)
 2015444:	1009883a 	mov	r4,r2
 2015448:	200ddc80 	call	200ddc8 <xQueueReceive>
 201544c:	10800058 	cmpnei	r2,r2,1
 2015450:	10000c1e 	bne	r2,zero,2015484 <sys_arch_mbox_fetch+0x8c>
		{
			nEndTime = xTaskGetTickCount();
 2015454:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 2015458:	e0bffb15 	stw	r2,-20(fp)
			nElapsed = nEndTime - nStartTime;
 201545c:	e0fffb17 	ldw	r3,-20(fp)
 2015460:	e0bffa17 	ldw	r2,-24(fp)
 2015464:	1885c83a 	sub	r2,r3,r2
 2015468:	e0bff915 	stw	r2,-28(fp)

			if (nElapsed == 0)
 201546c:	e0bff917 	ldw	r2,-28(fp)
 2015470:	1000021e 	bne	r2,zero,201547c <sys_arch_mbox_fetch+0x84>
				nElapsed = 1;
 2015474:	00800044 	movi	r2,1
 2015478:	e0bff915 	stw	r2,-28(fp)

			return nElapsed;
 201547c:	e0bff917 	ldw	r2,-28(fp)
 2015480:	00001806 	br	20154e4 <sys_arch_mbox_fetch+0xec>
		}
		else // timed out blocking for message
		{
			*msg = NULL;
 2015484:	e0bffe17 	ldw	r2,-8(fp)
 2015488:	10000015 	stw	zero,0(r2)
			return SYS_ARCH_TIMEOUT;
 201548c:	00bfffc4 	movi	r2,-1
 2015490:	00001406 	br	20154e4 <sys_arch_mbox_fetch+0xec>
		}
	}
	else // block forever for a message.
	{
		// wait on message forever
		while (pdTRUE != xQueueReceive(*mbox, msg, 10000));
 2015494:	0001883a 	nop
 2015498:	e0bffd17 	ldw	r2,-12(fp)
 201549c:	10800017 	ldw	r2,0(r2)
 20154a0:	0189c404 	movi	r6,10000
 20154a4:	e17ffe17 	ldw	r5,-8(fp)
 20154a8:	1009883a 	mov	r4,r2
 20154ac:	200ddc80 	call	200ddc8 <xQueueReceive>
 20154b0:	10800058 	cmpnei	r2,r2,1
 20154b4:	103ff81e 	bne	r2,zero,2015498 <__alt_mem_mem_0+0xfcff5498>

		nEndTime = xTaskGetTickCount();
 20154b8:	200fbe40 	call	200fbe4 <xTaskGetTickCount>
 20154bc:	e0bffb15 	stw	r2,-20(fp)
		nElapsed = nEndTime - nStartTime;
 20154c0:	e0fffb17 	ldw	r3,-20(fp)
 20154c4:	e0bffa17 	ldw	r2,-24(fp)
 20154c8:	1885c83a 	sub	r2,r3,r2
 20154cc:	e0bff915 	stw	r2,-28(fp)

		if (nElapsed == 0)
 20154d0:	e0bff917 	ldw	r2,-28(fp)
 20154d4:	1000021e 	bne	r2,zero,20154e0 <sys_arch_mbox_fetch+0xe8>
			nElapsed = 1;
 20154d8:	00800044 	movi	r2,1
 20154dc:	e0bff915 	stw	r2,-28(fp)

		return nElapsed; // return time blocked TBD test
 20154e0:	e0bff917 	ldw	r2,-28(fp)
	}
}
 20154e4:	e037883a 	mov	sp,fp
 20154e8:	dfc00117 	ldw	ra,4(sp)
 20154ec:	df000017 	ldw	fp,0(sp)
 20154f0:	dec00204 	addi	sp,sp,8
 20154f4:	f800283a 	ret

020154f8 <sys_arch_mbox_tryfetch>:
 * #define sys_arch_mbox_tryfetch(mbox,msg) \
 * 		sys_arch_mbox_fetch(mbox,msg,1)
 * although this would introduce unnecessary delays.
 */
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 20154f8:	defffb04 	addi	sp,sp,-20
 20154fc:	dfc00415 	stw	ra,16(sp)
 2015500:	df000315 	stw	fp,12(sp)
 2015504:	df000304 	addi	fp,sp,12
 2015508:	e13ffe15 	stw	r4,-8(fp)
 201550c:	e17fff15 	stw	r5,-4(fp)
	void *dummyptr;

	if (msg == NULL)
 2015510:	e0bfff17 	ldw	r2,-4(fp)
 2015514:	1000021e 	bne	r2,zero,2015520 <sys_arch_mbox_tryfetch+0x28>
		msg = &dummyptr;
 2015518:	e0bffd04 	addi	r2,fp,-12
 201551c:	e0bfff15 	stw	r2,-4(fp)

	return (pdTRUE == xQueueReceive(*mbox, msg, 0)) ? 0 : SYS_MBOX_EMPTY;
 2015520:	e0bffe17 	ldw	r2,-8(fp)
 2015524:	10800017 	ldw	r2,0(r2)
 2015528:	000d883a 	mov	r6,zero
 201552c:	e17fff17 	ldw	r5,-4(fp)
 2015530:	1009883a 	mov	r4,r2
 2015534:	200ddc80 	call	200ddc8 <xQueueReceive>
 2015538:	10800058 	cmpnei	r2,r2,1
 201553c:	1000021e 	bne	r2,zero,2015548 <sys_arch_mbox_tryfetch+0x50>
 2015540:	0005883a 	mov	r2,zero
 2015544:	00000106 	br	201554c <sys_arch_mbox_tryfetch+0x54>
 2015548:	00bfffc4 	movi	r2,-1
}
 201554c:	e037883a 	mov	sp,fp
 2015550:	dfc00117 	ldw	ra,4(sp)
 2015554:	df000017 	ldw	fp,0(sp)
 2015558:	dec00204 	addi	sp,sp,8
 201555c:	f800283a 	ret

02015560 <sys_thread_new>:
 * argument to the thread() function. The stack size to used for this thread is
 * the "stacksize" parameter. The id of the new thread is returned. Both the id
 * and the priority are system dependent.
 */
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
 2015560:	defff604 	addi	sp,sp,-40
 2015564:	dfc00915 	stw	ra,36(sp)
 2015568:	df000815 	stw	fp,32(sp)
 201556c:	df000804 	addi	fp,sp,32
 2015570:	e13ffc15 	stw	r4,-16(fp)
 2015574:	e17ffd15 	stw	r5,-12(fp)
 2015578:	e1bffe15 	stw	r6,-8(fp)
 201557c:	e1ffff15 	stw	r7,-4(fp)
	xTaskHandle objTask;
	int result = pdFAIL;
 2015580:	e03ffa15 	stw	zero,-24(fp)

	result = xTaskCreate(thread, (signed portCHAR*)name, stacksize, arg, prio, &objTask);
 2015584:	e13fff17 	ldw	r4,-4(fp)
 2015588:	e0800217 	ldw	r2,8(fp)
 201558c:	e0fffb04 	addi	r3,fp,-20
 2015590:	d8c00115 	stw	r3,4(sp)
 2015594:	d8800015 	stw	r2,0(sp)
 2015598:	e1fffe17 	ldw	r7,-8(fp)
 201559c:	200d883a 	mov	r6,r4
 20155a0:	e17ffc17 	ldw	r5,-16(fp)
 20155a4:	e13ffd17 	ldw	r4,-12(fp)
 20155a8:	200eca00 	call	200eca0 <xTaskCreate>
 20155ac:	e0bffa15 	stw	r2,-24(fp)

	return (result == pdPASS) ? objTask : NULL;
 20155b0:	e0bffa17 	ldw	r2,-24(fp)
 20155b4:	10800058 	cmpnei	r2,r2,1
 20155b8:	1000021e 	bne	r2,zero,20155c4 <sys_thread_new+0x64>
 20155bc:	e0bffb17 	ldw	r2,-20(fp)
 20155c0:	00000106 	br	20155c8 <sys_thread_new+0x68>
 20155c4:	0005883a 	mov	r2,zero
}
 20155c8:	e037883a 	mov	sp,fp
 20155cc:	dfc00117 	ldw	ra,4(sp)
 20155d0:	df000017 	ldw	fp,0(sp)
 20155d4:	dec00204 	addi	sp,sp,8
 20155d8:	f800283a 	ret

020155dc <dhcp_clear_assignment>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_clear_assignment(struct netif *netif)
{
 20155dc:	defffd04 	addi	sp,sp,-12
 20155e0:	dfc00215 	stw	ra,8(sp)
 20155e4:	df000115 	stw	fp,4(sp)
 20155e8:	df000104 	addi	fp,sp,4
 20155ec:	e13fff15 	stw	r4,-4(fp)
  netif_set_down(netif);
 20155f0:	e13fff17 	ldw	r4,-4(fp)
 20155f4:	201a0140 	call	201a014 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 20155f8:	d1600d04 	addi	r5,gp,-32716
 20155fc:	e13fff17 	ldw	r4,-4(fp)
 2015600:	2019d800 	call	2019d80 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 2015604:	d1600d04 	addi	r5,gp,-32716
 2015608:	e13fff17 	ldw	r4,-4(fp)
 201560c:	2019ea80 	call	2019ea8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
 2015610:	d1600d04 	addi	r5,gp,-32716
 2015614:	e13fff17 	ldw	r4,-4(fp)
 2015618:	2019ef00 	call	2019ef0 <netif_set_netmask>
}
 201561c:	0001883a 	nop
 2015620:	e037883a 	mov	sp,fp
 2015624:	dfc00117 	ldw	ra,4(sp)
 2015628:	df000017 	ldw	fp,0(sp)
 201562c:	dec00204 	addi	sp,sp,8
 2015630:	f800283a 	ret

02015634 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
 2015634:	defffc04 	addi	sp,sp,-16
 2015638:	dfc00315 	stw	ra,12(sp)
 201563c:	df000215 	stw	fp,8(sp)
 2015640:	df000204 	addi	fp,sp,8
 2015644:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015648:	e0bfff17 	ldw	r2,-4(fp)
 201564c:	10800a17 	ldw	r2,40(r2)
 2015650:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  dhcp_clear_assignment(netif);
 2015654:	e13fff17 	ldw	r4,-4(fp)
 2015658:	20155dc0 	call	20155dc <dhcp_clear_assignment>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 201565c:	01400304 	movi	r5,12
 2015660:	e13ffe17 	ldw	r4,-8(fp)
 2015664:	20172480 	call	2017248 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
 2015668:	e13fff17 	ldw	r4,-4(fp)
 201566c:	201675c0 	call	201675c <dhcp_discover>
}
 2015670:	0001883a 	nop
 2015674:	e037883a 	mov	sp,fp
 2015678:	dfc00117 	ldw	ra,4(sp)
 201567c:	df000017 	ldw	fp,0(sp)
 2015680:	dec00204 	addi	sp,sp,8
 2015684:	f800283a 	ret

02015688 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
 2015688:	defffb04 	addi	sp,sp,-20
 201568c:	dfc00415 	stw	ra,16(sp)
 2015690:	df000315 	stw	fp,12(sp)
 2015694:	df000304 	addi	fp,sp,12
 2015698:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 201569c:	e0bfff17 	ldw	r2,-4(fp)
 20156a0:	10800a17 	ldw	r2,40(r2)
 20156a4:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
 20156a8:	01400204 	movi	r5,8
 20156ac:	e13ffd17 	ldw	r4,-12(fp)
 20156b0:	20172480 	call	2017248 <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
 20156b4:	e0bffd17 	ldw	r2,-12(fp)
 20156b8:	10800904 	addi	r2,r2,36
 20156bc:	000d883a 	mov	r6,zero
 20156c0:	100b883a 	mov	r5,r2
 20156c4:	e13fff17 	ldw	r4,-4(fp)
 20156c8:	2023d480 	call	2023d48 <etharp_query>
 20156cc:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
 20156d0:	e0bffd17 	ldw	r2,-12(fp)
 20156d4:	10800343 	ldbu	r2,13(r2)
 20156d8:	10800044 	addi	r2,r2,1
 20156dc:	1007883a 	mov	r3,r2
 20156e0:	e0bffd17 	ldw	r2,-12(fp)
 20156e4:	10c00345 	stb	r3,13(r2)
  msecs = 500;
 20156e8:	00807d04 	movi	r2,500
 20156ec:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 20156f0:	e0bffe8b 	ldhu	r2,-6(fp)
 20156f4:	10807cc4 	addi	r2,r2,499
 20156f8:	01407d04 	movi	r5,500
 20156fc:	1009883a 	mov	r4,r2
 2015700:	200abb00 	call	200abb0 <__divsi3>
 2015704:	1007883a 	mov	r3,r2
 2015708:	e0bffd17 	ldw	r2,-12(fp)
 201570c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
 2015710:	0001883a 	nop
 2015714:	e037883a 	mov	sp,fp
 2015718:	dfc00117 	ldw	ra,4(sp)
 201571c:	df000017 	ldw	fp,0(sp)
 2015720:	dec00204 	addi	sp,sp,8
 2015724:	f800283a 	ret

02015728 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
 2015728:	defffc04 	addi	sp,sp,-16
 201572c:	dfc00315 	stw	ra,12(sp)
 2015730:	df000215 	stw	fp,8(sp)
 2015734:	df000204 	addi	fp,sp,8
 2015738:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 201573c:	e0bfff17 	ldw	r2,-4(fp)
 2015740:	10800a17 	ldw	r2,40(r2)
 2015744:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
 2015748:	008085b4 	movhi	r2,534
 201574c:	1088aa04 	addi	r2,r2,8872
 2015750:	10800083 	ldbu	r2,2(r2)
 2015754:	10803fcc 	andi	r2,r2,255
 2015758:	10002826 	beq	r2,zero,20157fc <dhcp_handle_offer+0xd4>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
 201575c:	008085b4 	movhi	r2,534
 2015760:	1088ad04 	addi	r2,r2,8884
 2015764:	10800217 	ldw	r2,8(r2)
 2015768:	1006d63a 	srli	r3,r2,24
 201576c:	008085b4 	movhi	r2,534
 2015770:	1088ad04 	addi	r2,r2,8884
 2015774:	10800217 	ldw	r2,8(r2)
 2015778:	1004d23a 	srli	r2,r2,8
 201577c:	10bfc00c 	andi	r2,r2,65280
 2015780:	1886b03a 	or	r3,r3,r2
 2015784:	008085b4 	movhi	r2,534
 2015788:	1088ad04 	addi	r2,r2,8884
 201578c:	10800217 	ldw	r2,8(r2)
 2015790:	10bfc00c 	andi	r2,r2,65280
 2015794:	1004923a 	slli	r2,r2,8
 2015798:	1886b03a 	or	r3,r3,r2
 201579c:	008085b4 	movhi	r2,534
 20157a0:	1088ad04 	addi	r2,r2,8884
 20157a4:	10800217 	ldw	r2,8(r2)
 20157a8:	1004963a 	slli	r2,r2,24
 20157ac:	1886b03a 	or	r3,r3,r2
 20157b0:	e0bffe17 	ldw	r2,-8(fp)
 20157b4:	10c00815 	stw	r3,32(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 20157b8:	e0bffe17 	ldw	r2,-8(fp)
 20157bc:	10800217 	ldw	r2,8(r2)
 20157c0:	10c00403 	ldbu	r3,16(r2)
 20157c4:	11000443 	ldbu	r4,17(r2)
 20157c8:	2008923a 	slli	r4,r4,8
 20157cc:	20c6b03a 	or	r3,r4,r3
 20157d0:	11000483 	ldbu	r4,18(r2)
 20157d4:	2008943a 	slli	r4,r4,16
 20157d8:	20c6b03a 	or	r3,r4,r3
 20157dc:	108004c3 	ldbu	r2,19(r2)
 20157e0:	1004963a 	slli	r2,r2,24
 20157e4:	10c4b03a 	or	r2,r2,r3
 20157e8:	1007883a 	mov	r3,r2
 20157ec:	e0bffe17 	ldw	r2,-8(fp)
 20157f0:	10c00915 	stw	r3,36(r2)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
 20157f4:	e13fff17 	ldw	r4,-4(fp)
 20157f8:	20158140 	call	2015814 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
 20157fc:	0001883a 	nop
 2015800:	e037883a 	mov	sp,fp
 2015804:	dfc00117 	ldw	ra,4(sp)
 2015808:	df000017 	ldw	fp,0(sp)
 201580c:	dec00204 	addi	sp,sp,8
 2015810:	f800283a 	ret

02015814 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
 2015814:	defffa04 	addi	sp,sp,-24
 2015818:	dfc00515 	stw	ra,20(sp)
 201581c:	df000415 	stw	fp,16(sp)
 2015820:	df000404 	addi	fp,sp,16
 2015824:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015828:	e0bfff17 	ldw	r2,-4(fp)
 201582c:	10800a17 	ldw	r2,40(r2)
 2015830:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
 2015834:	01400044 	movi	r5,1
 2015838:	e13ffd17 	ldw	r4,-12(fp)
 201583c:	20172480 	call	2017248 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 2015840:	018000c4 	movi	r6,3
 2015844:	e17ffd17 	ldw	r5,-12(fp)
 2015848:	e13fff17 	ldw	r4,-4(fp)
 201584c:	20182200 	call	2018220 <dhcp_create_msg>
 2015850:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 2015854:	e0bffe07 	ldb	r2,-8(fp)
 2015858:	1000651e 	bne	r2,zero,20159f0 <dhcp_select+0x1dc>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 201585c:	01800084 	movi	r6,2
 2015860:	01400e44 	movi	r5,57
 2015864:	e13ffd17 	ldw	r4,-12(fp)
 2015868:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 201586c:	e0bfff17 	ldw	r2,-4(fp)
 2015870:	10800c0b 	ldhu	r2,48(r2)
 2015874:	10bfffcc 	andi	r2,r2,65535
 2015878:	100b883a 	mov	r5,r2
 201587c:	e13ffd17 	ldw	r4,-12(fp)
 2015880:	20173a00 	call	20173a0 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 2015884:	01800104 	movi	r6,4
 2015888:	01400c84 	movi	r5,50
 201588c:	e13ffd17 	ldw	r4,-12(fp)
 2015890:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 2015894:	e0bffd17 	ldw	r2,-12(fp)
 2015898:	10800917 	ldw	r2,36(r2)
 201589c:	1006d63a 	srli	r3,r2,24
 20158a0:	e0bffd17 	ldw	r2,-12(fp)
 20158a4:	10800917 	ldw	r2,36(r2)
 20158a8:	1004d23a 	srli	r2,r2,8
 20158ac:	10bfc00c 	andi	r2,r2,65280
 20158b0:	1886b03a 	or	r3,r3,r2
 20158b4:	e0bffd17 	ldw	r2,-12(fp)
 20158b8:	10800917 	ldw	r2,36(r2)
 20158bc:	10bfc00c 	andi	r2,r2,65280
 20158c0:	1004923a 	slli	r2,r2,8
 20158c4:	1886b03a 	or	r3,r3,r2
 20158c8:	e0bffd17 	ldw	r2,-12(fp)
 20158cc:	10800917 	ldw	r2,36(r2)
 20158d0:	1004963a 	slli	r2,r2,24
 20158d4:	1884b03a 	or	r2,r3,r2
 20158d8:	100b883a 	mov	r5,r2
 20158dc:	e13ffd17 	ldw	r4,-12(fp)
 20158e0:	20174380 	call	2017438 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
 20158e4:	01800104 	movi	r6,4
 20158e8:	01400d84 	movi	r5,54
 20158ec:	e13ffd17 	ldw	r4,-12(fp)
 20158f0:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
 20158f4:	e0bffd17 	ldw	r2,-12(fp)
 20158f8:	10800817 	ldw	r2,32(r2)
 20158fc:	1006d63a 	srli	r3,r2,24
 2015900:	e0bffd17 	ldw	r2,-12(fp)
 2015904:	10800817 	ldw	r2,32(r2)
 2015908:	1004d23a 	srli	r2,r2,8
 201590c:	10bfc00c 	andi	r2,r2,65280
 2015910:	1886b03a 	or	r3,r3,r2
 2015914:	e0bffd17 	ldw	r2,-12(fp)
 2015918:	10800817 	ldw	r2,32(r2)
 201591c:	10bfc00c 	andi	r2,r2,65280
 2015920:	1004923a 	slli	r2,r2,8
 2015924:	1886b03a 	or	r3,r3,r2
 2015928:	e0bffd17 	ldw	r2,-12(fp)
 201592c:	10800817 	ldw	r2,32(r2)
 2015930:	1004963a 	slli	r2,r2,24
 2015934:	1884b03a 	or	r2,r3,r2
 2015938:	100b883a 	mov	r5,r2
 201593c:	e13ffd17 	ldw	r4,-12(fp)
 2015940:	20174380 	call	2017438 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
 2015944:	01800104 	movi	r6,4
 2015948:	01400dc4 	movi	r5,55
 201594c:	e13ffd17 	ldw	r4,-12(fp)
 2015950:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
 2015954:	01400044 	movi	r5,1
 2015958:	e13ffd17 	ldw	r4,-12(fp)
 201595c:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
 2015960:	014000c4 	movi	r5,3
 2015964:	e13ffd17 	ldw	r4,-12(fp)
 2015968:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
 201596c:	01400704 	movi	r5,28
 2015970:	e13ffd17 	ldw	r4,-12(fp)
 2015974:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
 2015978:	01400184 	movi	r5,6
 201597c:	e13ffd17 	ldw	r4,-12(fp)
 2015980:	20173400 	call	2017340 <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 2015984:	e17fff17 	ldw	r5,-4(fp)
 2015988:	e13ffd17 	ldw	r4,-12(fp)
 201598c:	20175440 	call	2017544 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
 2015990:	e13ffd17 	ldw	r4,-12(fp)
 2015994:	20188280 	call	2018828 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2015998:	e0bffd17 	ldw	r2,-12(fp)
 201599c:	10c00417 	ldw	r3,16(r2)
 20159a0:	e0bffd17 	ldw	r2,-12(fp)
 20159a4:	1080060b 	ldhu	r2,24(r2)
 20159a8:	10803c04 	addi	r2,r2,240
 20159ac:	10bfffcc 	andi	r2,r2,65535
 20159b0:	100b883a 	mov	r5,r2
 20159b4:	1809883a 	mov	r4,r3
 20159b8:	201a8580 	call	201a858 <pbuf_realloc>

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 20159bc:	e0bffd17 	ldw	r2,-12(fp)
 20159c0:	10c00117 	ldw	r3,4(r2)
 20159c4:	e0bffd17 	ldw	r2,-12(fp)
 20159c8:	11000417 	ldw	r4,16(r2)
 20159cc:	e0bfff17 	ldw	r2,-4(fp)
 20159d0:	d8800015 	stw	r2,0(sp)
 20159d4:	01c010c4 	movi	r7,67
 20159d8:	d1a00e04 	addi	r6,gp,-32712
 20159dc:	200b883a 	mov	r5,r4
 20159e0:	1809883a 	mov	r4,r3
 20159e4:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 20159e8:	e13ffd17 	ldw	r4,-12(fp)
 20159ec:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 20159f0:	e0bffd17 	ldw	r2,-12(fp)
 20159f4:	10800343 	ldbu	r2,13(r2)
 20159f8:	10800044 	addi	r2,r2,1
 20159fc:	1007883a 	mov	r3,r2
 2015a00:	e0bffd17 	ldw	r2,-12(fp)
 2015a04:	10c00345 	stb	r3,13(r2)
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 2015a08:	e0bffd17 	ldw	r2,-12(fp)
 2015a0c:	10800343 	ldbu	r2,13(r2)
 2015a10:	10803fcc 	andi	r2,r2,255
 2015a14:	108001a8 	cmpgeui	r2,r2,6
 2015a18:	1000061e 	bne	r2,zero,2015a34 <dhcp_select+0x220>
 2015a1c:	e0bffd17 	ldw	r2,-12(fp)
 2015a20:	10800343 	ldbu	r2,13(r2)
 2015a24:	10803fcc 	andi	r2,r2,255
 2015a28:	00c0fa04 	movi	r3,1000
 2015a2c:	1884983a 	sll	r2,r3,r2
 2015a30:	00000106 	br	2015a38 <dhcp_select+0x224>
 2015a34:	00ba9804 	movi	r2,-5536
 2015a38:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 2015a3c:	e0bffe8b 	ldhu	r2,-6(fp)
 2015a40:	10807cc4 	addi	r2,r2,499
 2015a44:	01407d04 	movi	r5,500
 2015a48:	1009883a 	mov	r4,r2
 2015a4c:	200abb00 	call	200abb0 <__divsi3>
 2015a50:	1007883a 	mov	r3,r2
 2015a54:	e0bffd17 	ldw	r2,-12(fp)
 2015a58:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2015a5c:	e0bffe03 	ldbu	r2,-8(fp)
}
 2015a60:	e037883a 	mov	sp,fp
 2015a64:	dfc00117 	ldw	ra,4(sp)
 2015a68:	df000017 	ldw	fp,0(sp)
 2015a6c:	dec00204 	addi	sp,sp,8
 2015a70:	f800283a 	ret

02015a74 <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
 2015a74:	defffd04 	addi	sp,sp,-12
 2015a78:	dfc00215 	stw	ra,8(sp)
 2015a7c:	df000115 	stw	fp,4(sp)
 2015a80:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
 2015a84:	d0a7f317 	ldw	r2,-24628(gp)
 2015a88:	e0bfff15 	stw	r2,-4(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 2015a8c:	00001b06 	br	2015afc <dhcp_coarse_tmr+0x88>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 2015a90:	e0bfff17 	ldw	r2,-4(fp)
 2015a94:	10800a17 	ldw	r2,40(r2)
 2015a98:	10001526 	beq	r2,zero,2015af0 <dhcp_coarse_tmr+0x7c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
 2015a9c:	e0bfff17 	ldw	r2,-4(fp)
 2015aa0:	10800a17 	ldw	r2,40(r2)
 2015aa4:	10c0078b 	ldhu	r3,30(r2)
 2015aa8:	193fffc4 	addi	r4,r3,-1
 2015aac:	1100078d 	sth	r4,30(r2)
 2015ab0:	18bfffcc 	andi	r2,r3,65535
 2015ab4:	10800058 	cmpnei	r2,r2,1
 2015ab8:	1000031e 	bne	r2,zero,2015ac8 <dhcp_coarse_tmr+0x54>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
 2015abc:	e13fff17 	ldw	r4,-4(fp)
 2015ac0:	2015de80 	call	2015de8 <dhcp_t2_timeout>
 2015ac4:	00000a06 	br	2015af0 <dhcp_coarse_tmr+0x7c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
 2015ac8:	e0bfff17 	ldw	r2,-4(fp)
 2015acc:	10800a17 	ldw	r2,40(r2)
 2015ad0:	10c0070b 	ldhu	r3,28(r2)
 2015ad4:	193fffc4 	addi	r4,r3,-1
 2015ad8:	1100070d 	sth	r4,28(r2)
 2015adc:	18bfffcc 	andi	r2,r3,65535
 2015ae0:	10800058 	cmpnei	r2,r2,1
 2015ae4:	1000021e 	bne	r2,zero,2015af0 <dhcp_coarse_tmr+0x7c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
 2015ae8:	e13fff17 	ldw	r4,-4(fp)
 2015aec:	2015d6c0 	call	2015d6c <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
 2015af0:	e0bfff17 	ldw	r2,-4(fp)
 2015af4:	10800017 	ldw	r2,0(r2)
 2015af8:	e0bfff15 	stw	r2,-4(fp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
 2015afc:	e0bfff17 	ldw	r2,-4(fp)
 2015b00:	103fe31e 	bne	r2,zero,2015a90 <__alt_mem_mem_0+0xfcff5a90>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
 2015b04:	0001883a 	nop
 2015b08:	e037883a 	mov	sp,fp
 2015b0c:	dfc00117 	ldw	ra,4(sp)
 2015b10:	df000017 	ldw	fp,0(sp)
 2015b14:	dec00204 	addi	sp,sp,8
 2015b18:	f800283a 	ret

02015b1c <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
 2015b1c:	defffd04 	addi	sp,sp,-12
 2015b20:	dfc00215 	stw	ra,8(sp)
 2015b24:	df000115 	stw	fp,4(sp)
 2015b28:	df000104 	addi	fp,sp,4
  struct netif *netif = netif_list;
 2015b2c:	d0a7f317 	ldw	r2,-24628(gp)
 2015b30:	e0bfff15 	stw	r2,-4(fp)
  /* loop through netif's */
  while (netif != NULL) {
 2015b34:	00001f06 	br	2015bb4 <dhcp_fine_tmr+0x98>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
 2015b38:	e0bfff17 	ldw	r2,-4(fp)
 2015b3c:	10800a17 	ldw	r2,40(r2)
 2015b40:	10001926 	beq	r2,zero,2015ba8 <dhcp_fine_tmr+0x8c>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
 2015b44:	e0bfff17 	ldw	r2,-4(fp)
 2015b48:	10800a17 	ldw	r2,40(r2)
 2015b4c:	1080068b 	ldhu	r2,26(r2)
 2015b50:	10bfffcc 	andi	r2,r2,65535
 2015b54:	108000b0 	cmpltui	r2,r2,2
 2015b58:	1000061e 	bne	r2,zero,2015b74 <dhcp_fine_tmr+0x58>
        netif->dhcp->request_timeout--;
 2015b5c:	e0bfff17 	ldw	r2,-4(fp)
 2015b60:	10800a17 	ldw	r2,40(r2)
 2015b64:	10c0068b 	ldhu	r3,26(r2)
 2015b68:	18ffffc4 	addi	r3,r3,-1
 2015b6c:	10c0068d 	sth	r3,26(r2)
 2015b70:	00000d06 	br	2015ba8 <dhcp_fine_tmr+0x8c>
      }
      else if (netif->dhcp->request_timeout == 1) {
 2015b74:	e0bfff17 	ldw	r2,-4(fp)
 2015b78:	10800a17 	ldw	r2,40(r2)
 2015b7c:	1080068b 	ldhu	r2,26(r2)
 2015b80:	10bfffcc 	andi	r2,r2,65535
 2015b84:	10800058 	cmpnei	r2,r2,1
 2015b88:	1000071e 	bne	r2,zero,2015ba8 <dhcp_fine_tmr+0x8c>
        netif->dhcp->request_timeout--;
 2015b8c:	e0bfff17 	ldw	r2,-4(fp)
 2015b90:	10800a17 	ldw	r2,40(r2)
 2015b94:	10c0068b 	ldhu	r3,26(r2)
 2015b98:	18ffffc4 	addi	r3,r3,-1
 2015b9c:	10c0068d 	sth	r3,26(r2)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
 2015ba0:	e13fff17 	ldw	r4,-4(fp)
 2015ba4:	2015bd40 	call	2015bd4 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 2015ba8:	e0bfff17 	ldw	r2,-4(fp)
 2015bac:	10800017 	ldw	r2,0(r2)
 2015bb0:	e0bfff15 	stw	r2,-4(fp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
 2015bb4:	e0bfff17 	ldw	r2,-4(fp)
 2015bb8:	103fdf1e 	bne	r2,zero,2015b38 <__alt_mem_mem_0+0xfcff5b38>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
 2015bbc:	0001883a 	nop
 2015bc0:	e037883a 	mov	sp,fp
 2015bc4:	dfc00117 	ldw	ra,4(sp)
 2015bc8:	df000017 	ldw	fp,0(sp)
 2015bcc:	dec00204 	addi	sp,sp,8
 2015bd0:	f800283a 	ret

02015bd4 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
 2015bd4:	defffc04 	addi	sp,sp,-16
 2015bd8:	dfc00315 	stw	ra,12(sp)
 2015bdc:	df000215 	stw	fp,8(sp)
 2015be0:	df000204 	addi	fp,sp,8
 2015be4:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015be8:	e0bfff17 	ldw	r2,-4(fp)
 2015bec:	10800a17 	ldw	r2,40(r2)
 2015bf0:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
 2015bf4:	e0bffe17 	ldw	r2,-8(fp)
 2015bf8:	10800303 	ldbu	r2,12(r2)
 2015bfc:	10803fcc 	andi	r2,r2,255
 2015c00:	10800320 	cmpeqi	r2,r2,12
 2015c04:	1000051e 	bne	r2,zero,2015c1c <dhcp_timeout+0x48>
 2015c08:	e0bffe17 	ldw	r2,-8(fp)
 2015c0c:	10800303 	ldbu	r2,12(r2)
 2015c10:	10803fcc 	andi	r2,r2,255
 2015c14:	10800198 	cmpnei	r2,r2,6
 2015c18:	1000031e 	bne	r2,zero,2015c28 <dhcp_timeout+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
 2015c1c:	e13fff17 	ldw	r4,-4(fp)
 2015c20:	201675c0 	call	201675c <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015c24:	00004b06 	br	2015d54 <dhcp_timeout+0x180>
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
 2015c28:	e0bffe17 	ldw	r2,-8(fp)
 2015c2c:	10800303 	ldbu	r2,12(r2)
 2015c30:	10803fcc 	andi	r2,r2,255
 2015c34:	10800058 	cmpnei	r2,r2,1
 2015c38:	10000d1e 	bne	r2,zero,2015c70 <dhcp_timeout+0x9c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
 2015c3c:	e0bffe17 	ldw	r2,-8(fp)
 2015c40:	10800343 	ldbu	r2,13(r2)
 2015c44:	10803fcc 	andi	r2,r2,255
 2015c48:	108001a8 	cmpgeui	r2,r2,6
 2015c4c:	1000031e 	bne	r2,zero,2015c5c <dhcp_timeout+0x88>
      dhcp_select(netif);
 2015c50:	e13fff17 	ldw	r4,-4(fp)
 2015c54:	20158140 	call	2015814 <dhcp_select>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015c58:	00003e06 	br	2015d54 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
      dhcp_select(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
 2015c5c:	e13fff17 	ldw	r4,-4(fp)
 2015c60:	2016fec0 	call	2016fec <dhcp_release>
      dhcp_discover(netif);
 2015c64:	e13fff17 	ldw	r4,-4(fp)
 2015c68:	201675c0 	call	201675c <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015c6c:	00003906 	br	2015d54 <dhcp_timeout+0x180>
      dhcp_release(netif);
      dhcp_discover(netif);
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
 2015c70:	e0bffe17 	ldw	r2,-8(fp)
 2015c74:	10800303 	ldbu	r2,12(r2)
 2015c78:	10803fcc 	andi	r2,r2,255
 2015c7c:	10800218 	cmpnei	r2,r2,8
 2015c80:	10000b1e 	bne	r2,zero,2015cb0 <dhcp_timeout+0xdc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
 2015c84:	e0bffe17 	ldw	r2,-8(fp)
 2015c88:	10800343 	ldbu	r2,13(r2)
 2015c8c:	10803fcc 	andi	r2,r2,255
 2015c90:	108000a8 	cmpgeui	r2,r2,2
 2015c94:	1000031e 	bne	r2,zero,2015ca4 <dhcp_timeout+0xd0>
      dhcp_check(netif);
 2015c98:	e13fff17 	ldw	r4,-4(fp)
 2015c9c:	20156880 	call	2015688 <dhcp_check>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015ca0:	00002c06 	br	2015d54 <dhcp_timeout+0x180>
      dhcp_check(netif);
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
 2015ca4:	e13fff17 	ldw	r4,-4(fp)
 2015ca8:	20168fc0 	call	20168fc <dhcp_bind>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015cac:	00002906 	br	2015d54 <dhcp_timeout+0x180>
      dhcp_bind(netif);
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
 2015cb0:	e0bffe17 	ldw	r2,-8(fp)
 2015cb4:	10800303 	ldbu	r2,12(r2)
 2015cb8:	10803fcc 	andi	r2,r2,255
 2015cbc:	10800158 	cmpnei	r2,r2,5
 2015cc0:	1000031e 	bne	r2,zero,2015cd0 <dhcp_timeout+0xfc>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
 2015cc4:	e13fff17 	ldw	r4,-4(fp)
 2015cc8:	2016b880 	call	2016b88 <dhcp_renew>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015ccc:	00002106 	br	2015d54 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
 2015cd0:	e0bffe17 	ldw	r2,-8(fp)
 2015cd4:	10800303 	ldbu	r2,12(r2)
 2015cd8:	10803fcc 	andi	r2,r2,255
 2015cdc:	10800118 	cmpnei	r2,r2,4
 2015ce0:	10000d1e 	bne	r2,zero,2015d18 <dhcp_timeout+0x144>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
 2015ce4:	e0bffe17 	ldw	r2,-8(fp)
 2015ce8:	10800343 	ldbu	r2,13(r2)
 2015cec:	10803fcc 	andi	r2,r2,255
 2015cf0:	10800268 	cmpgeui	r2,r2,9
 2015cf4:	1000031e 	bne	r2,zero,2015d04 <dhcp_timeout+0x130>
      dhcp_rebind(netif);
 2015cf8:	e13fff17 	ldw	r4,-4(fp)
 2015cfc:	2016cec0 	call	2016cec <dhcp_rebind>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015d00:	00001406 	br	2015d54 <dhcp_timeout+0x180>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
      dhcp_rebind(netif);
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
 2015d04:	e13fff17 	ldw	r4,-4(fp)
 2015d08:	2016fec0 	call	2016fec <dhcp_release>
      dhcp_discover(netif);
 2015d0c:	e13fff17 	ldw	r4,-4(fp)
 2015d10:	201675c0 	call	201675c <dhcp_discover>
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015d14:	00000f06 	br	2015d54 <dhcp_timeout+0x180>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
      dhcp_discover(netif);
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
 2015d18:	e0bffe17 	ldw	r2,-8(fp)
 2015d1c:	10800303 	ldbu	r2,12(r2)
 2015d20:	10803fcc 	andi	r2,r2,255
 2015d24:	108000d8 	cmpnei	r2,r2,3
 2015d28:	10000a1e 	bne	r2,zero,2015d54 <dhcp_timeout+0x180>
    if (dhcp->tries < REBOOT_TRIES) {
 2015d2c:	e0bffe17 	ldw	r2,-8(fp)
 2015d30:	10800343 	ldbu	r2,13(r2)
 2015d34:	10803fcc 	andi	r2,r2,255
 2015d38:	108000a8 	cmpgeui	r2,r2,2
 2015d3c:	1000031e 	bne	r2,zero,2015d4c <dhcp_timeout+0x178>
      dhcp_reboot(netif);
 2015d40:	e13fff17 	ldw	r4,-4(fp)
 2015d44:	2016e480 	call	2016e48 <dhcp_reboot>
    } else {
      dhcp_discover(netif);
    }
  }
}
 2015d48:	00000206 	br	2015d54 <dhcp_timeout+0x180>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
    if (dhcp->tries < REBOOT_TRIES) {
      dhcp_reboot(netif);
    } else {
      dhcp_discover(netif);
 2015d4c:	e13fff17 	ldw	r4,-4(fp)
 2015d50:	201675c0 	call	201675c <dhcp_discover>
    }
  }
}
 2015d54:	0001883a 	nop
 2015d58:	e037883a 	mov	sp,fp
 2015d5c:	dfc00117 	ldw	ra,4(sp)
 2015d60:	df000017 	ldw	fp,0(sp)
 2015d64:	dec00204 	addi	sp,sp,8
 2015d68:	f800283a 	ret

02015d6c <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
 2015d6c:	defffc04 	addi	sp,sp,-16
 2015d70:	dfc00315 	stw	ra,12(sp)
 2015d74:	df000215 	stw	fp,8(sp)
 2015d78:	df000204 	addi	fp,sp,8
 2015d7c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015d80:	e0bfff17 	ldw	r2,-4(fp)
 2015d84:	10800a17 	ldw	r2,40(r2)
 2015d88:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 2015d8c:	e0bffe17 	ldw	r2,-8(fp)
 2015d90:	10800303 	ldbu	r2,12(r2)
 2015d94:	10803fcc 	andi	r2,r2,255
 2015d98:	10800060 	cmpeqi	r2,r2,1
 2015d9c:	10000a1e 	bne	r2,zero,2015dc8 <dhcp_t1_timeout+0x5c>
 2015da0:	e0bffe17 	ldw	r2,-8(fp)
 2015da4:	10800303 	ldbu	r2,12(r2)
 2015da8:	10803fcc 	andi	r2,r2,255
 2015dac:	108002a0 	cmpeqi	r2,r2,10
 2015db0:	1000051e 	bne	r2,zero,2015dc8 <dhcp_t1_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
 2015db4:	e0bffe17 	ldw	r2,-8(fp)
 2015db8:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 2015dbc:	10803fcc 	andi	r2,r2,255
 2015dc0:	10800158 	cmpnei	r2,r2,5
 2015dc4:	1000021e 	bne	r2,zero,2015dd0 <dhcp_t1_timeout+0x64>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
 2015dc8:	e13fff17 	ldw	r4,-4(fp)
 2015dcc:	2016b880 	call	2016b88 <dhcp_renew>
  }
}
 2015dd0:	0001883a 	nop
 2015dd4:	e037883a 	mov	sp,fp
 2015dd8:	dfc00117 	ldw	ra,4(sp)
 2015ddc:	df000017 	ldw	fp,0(sp)
 2015de0:	dec00204 	addi	sp,sp,8
 2015de4:	f800283a 	ret

02015de8 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
 2015de8:	defffc04 	addi	sp,sp,-16
 2015dec:	dfc00315 	stw	ra,12(sp)
 2015df0:	df000215 	stw	fp,8(sp)
 2015df4:	df000204 	addi	fp,sp,8
 2015df8:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015dfc:	e0bfff17 	ldw	r2,-4(fp)
 2015e00:	10800a17 	ldw	r2,40(r2)
 2015e04:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 2015e08:	e0bffe17 	ldw	r2,-8(fp)
 2015e0c:	10800303 	ldbu	r2,12(r2)
 2015e10:	10803fcc 	andi	r2,r2,255
 2015e14:	10800060 	cmpeqi	r2,r2,1
 2015e18:	10000a1e 	bne	r2,zero,2015e44 <dhcp_t2_timeout+0x5c>
 2015e1c:	e0bffe17 	ldw	r2,-8(fp)
 2015e20:	10800303 	ldbu	r2,12(r2)
 2015e24:	10803fcc 	andi	r2,r2,255
 2015e28:	108002a0 	cmpeqi	r2,r2,10
 2015e2c:	1000051e 	bne	r2,zero,2015e44 <dhcp_t2_timeout+0x5c>
      (dhcp->state == DHCP_RENEWING)) {
 2015e30:	e0bffe17 	ldw	r2,-8(fp)
 2015e34:	10800303 	ldbu	r2,12(r2)
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
 2015e38:	10803fcc 	andi	r2,r2,255
 2015e3c:	10800158 	cmpnei	r2,r2,5
 2015e40:	1000021e 	bne	r2,zero,2015e4c <dhcp_t2_timeout+0x64>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
 2015e44:	e13fff17 	ldw	r4,-4(fp)
 2015e48:	2016cec0 	call	2016cec <dhcp_rebind>
  }
}
 2015e4c:	0001883a 	nop
 2015e50:	e037883a 	mov	sp,fp
 2015e54:	dfc00117 	ldw	ra,4(sp)
 2015e58:	df000017 	ldw	fp,0(sp)
 2015e5c:	dec00204 	addi	sp,sp,8
 2015e60:	f800283a 	ret

02015e64 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
 2015e64:	defffd04 	addi	sp,sp,-12
 2015e68:	df000215 	stw	fp,8(sp)
 2015e6c:	df000204 	addi	fp,sp,8
 2015e70:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2015e74:	e0bfff17 	ldw	r2,-4(fp)
 2015e78:	10800a17 	ldw	r2,40(r2)
 2015e7c:	e0bffe15 	stw	r2,-8(fp)
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 2015e80:	e0bffe17 	ldw	r2,-8(fp)
 2015e84:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 2015e88:	e0bffe17 	ldw	r2,-8(fp)
 2015e8c:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
 2015e90:	008085b4 	movhi	r2,534
 2015e94:	1088aa04 	addi	r2,r2,8872
 2015e98:	108000c3 	ldbu	r2,3(r2)
 2015e9c:	10803fcc 	andi	r2,r2,255
 2015ea0:	10000526 	beq	r2,zero,2015eb8 <dhcp_handle_ack+0x54>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
 2015ea4:	008085b4 	movhi	r2,534
 2015ea8:	1088ad04 	addi	r2,r2,8884
 2015eac:	10c00317 	ldw	r3,12(r2)
 2015eb0:	e0bffe17 	ldw	r2,-8(fp)
 2015eb4:	10c00c15 	stw	r3,48(r2)
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
 2015eb8:	008085b4 	movhi	r2,534
 2015ebc:	1088aa04 	addi	r2,r2,8872
 2015ec0:	10800103 	ldbu	r2,4(r2)
 2015ec4:	10803fcc 	andi	r2,r2,255
 2015ec8:	10000626 	beq	r2,zero,2015ee4 <dhcp_handle_ack+0x80>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
 2015ecc:	008085b4 	movhi	r2,534
 2015ed0:	1088ad04 	addi	r2,r2,8884
 2015ed4:	10c00417 	ldw	r3,16(r2)
 2015ed8:	e0bffe17 	ldw	r2,-8(fp)
 2015edc:	10c00d15 	stw	r3,52(r2)
 2015ee0:	00000506 	br	2015ef8 <dhcp_handle_ack+0x94>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
 2015ee4:	e0bffe17 	ldw	r2,-8(fp)
 2015ee8:	10800c17 	ldw	r2,48(r2)
 2015eec:	1006d07a 	srli	r3,r2,1
 2015ef0:	e0bffe17 	ldw	r2,-8(fp)
 2015ef4:	10c00d15 	stw	r3,52(r2)
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
 2015ef8:	008085b4 	movhi	r2,534
 2015efc:	1088aa04 	addi	r2,r2,8872
 2015f00:	10800143 	ldbu	r2,5(r2)
 2015f04:	10803fcc 	andi	r2,r2,255
 2015f08:	10000626 	beq	r2,zero,2015f24 <dhcp_handle_ack+0xc0>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
 2015f0c:	008085b4 	movhi	r2,534
 2015f10:	1088ad04 	addi	r2,r2,8884
 2015f14:	10c00517 	ldw	r3,20(r2)
 2015f18:	e0bffe17 	ldw	r2,-8(fp)
 2015f1c:	10c00e15 	stw	r3,56(r2)
 2015f20:	00000406 	br	2015f34 <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
 2015f24:	e0bffe17 	ldw	r2,-8(fp)
 2015f28:	10c00c17 	ldw	r3,48(r2)
 2015f2c:	e0bffe17 	ldw	r2,-8(fp)
 2015f30:	10c00e15 	stw	r3,56(r2)
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
 2015f34:	e0bffe17 	ldw	r2,-8(fp)
 2015f38:	10800217 	ldw	r2,8(r2)
 2015f3c:	10c00403 	ldbu	r3,16(r2)
 2015f40:	11000443 	ldbu	r4,17(r2)
 2015f44:	2008923a 	slli	r4,r4,8
 2015f48:	20c6b03a 	or	r3,r4,r3
 2015f4c:	11000483 	ldbu	r4,18(r2)
 2015f50:	2008943a 	slli	r4,r4,16
 2015f54:	20c6b03a 	or	r3,r4,r3
 2015f58:	108004c3 	ldbu	r2,19(r2)
 2015f5c:	1004963a 	slli	r2,r2,24
 2015f60:	10c4b03a 	or	r2,r2,r3
 2015f64:	1007883a 	mov	r3,r2
 2015f68:	e0bffe17 	ldw	r2,-8(fp)
 2015f6c:	10c00915 	stw	r3,36(r2)
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
 2015f70:	008085b4 	movhi	r2,534
 2015f74:	1088aa04 	addi	r2,r2,8872
 2015f78:	10800183 	ldbu	r2,6(r2)
 2015f7c:	10803fcc 	andi	r2,r2,255
 2015f80:	10001b26 	beq	r2,zero,2015ff0 <dhcp_handle_ack+0x18c>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
 2015f84:	008085b4 	movhi	r2,534
 2015f88:	1088ad04 	addi	r2,r2,8884
 2015f8c:	10800617 	ldw	r2,24(r2)
 2015f90:	1006d63a 	srli	r3,r2,24
 2015f94:	008085b4 	movhi	r2,534
 2015f98:	1088ad04 	addi	r2,r2,8884
 2015f9c:	10800617 	ldw	r2,24(r2)
 2015fa0:	1004d23a 	srli	r2,r2,8
 2015fa4:	10bfc00c 	andi	r2,r2,65280
 2015fa8:	1886b03a 	or	r3,r3,r2
 2015fac:	008085b4 	movhi	r2,534
 2015fb0:	1088ad04 	addi	r2,r2,8884
 2015fb4:	10800617 	ldw	r2,24(r2)
 2015fb8:	10bfc00c 	andi	r2,r2,65280
 2015fbc:	1004923a 	slli	r2,r2,8
 2015fc0:	1886b03a 	or	r3,r3,r2
 2015fc4:	008085b4 	movhi	r2,534
 2015fc8:	1088ad04 	addi	r2,r2,8884
 2015fcc:	10800617 	ldw	r2,24(r2)
 2015fd0:	1004963a 	slli	r2,r2,24
 2015fd4:	1886b03a 	or	r3,r3,r2
 2015fd8:	e0bffe17 	ldw	r2,-8(fp)
 2015fdc:	10c00a15 	stw	r3,40(r2)
    dhcp->subnet_mask_given = 1;
 2015fe0:	e0bffe17 	ldw	r2,-8(fp)
 2015fe4:	00c00044 	movi	r3,1
 2015fe8:	10c00385 	stb	r3,14(r2)
 2015fec:	00000206 	br	2015ff8 <dhcp_handle_ack+0x194>
  } else {
    dhcp->subnet_mask_given = 0;
 2015ff0:	e0bffe17 	ldw	r2,-8(fp)
 2015ff4:	10000385 	stb	zero,14(r2)
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
 2015ff8:	008085b4 	movhi	r2,534
 2015ffc:	1088aa04 	addi	r2,r2,8872
 2016000:	108001c3 	ldbu	r2,7(r2)
 2016004:	10803fcc 	andi	r2,r2,255
 2016008:	10001726 	beq	r2,zero,2016068 <dhcp_handle_ack+0x204>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
 201600c:	008085b4 	movhi	r2,534
 2016010:	1088ad04 	addi	r2,r2,8884
 2016014:	10800717 	ldw	r2,28(r2)
 2016018:	1006d63a 	srli	r3,r2,24
 201601c:	008085b4 	movhi	r2,534
 2016020:	1088ad04 	addi	r2,r2,8884
 2016024:	10800717 	ldw	r2,28(r2)
 2016028:	1004d23a 	srli	r2,r2,8
 201602c:	10bfc00c 	andi	r2,r2,65280
 2016030:	1886b03a 	or	r3,r3,r2
 2016034:	008085b4 	movhi	r2,534
 2016038:	1088ad04 	addi	r2,r2,8884
 201603c:	10800717 	ldw	r2,28(r2)
 2016040:	10bfc00c 	andi	r2,r2,65280
 2016044:	1004923a 	slli	r2,r2,8
 2016048:	1886b03a 	or	r3,r3,r2
 201604c:	008085b4 	movhi	r2,534
 2016050:	1088ad04 	addi	r2,r2,8884
 2016054:	10800717 	ldw	r2,28(r2)
 2016058:	1004963a 	slli	r2,r2,24
 201605c:	1886b03a 	or	r3,r3,r2
 2016060:	e0bffe17 	ldw	r2,-8(fp)
 2016064:	10c00b15 	stw	r3,44(r2)
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
    n++;
  }
#endif /* LWIP_DNS */
}
 2016068:	0001883a 	nop
 201606c:	e037883a 	mov	sp,fp
 2016070:	df000017 	ldw	fp,0(sp)
 2016074:	dec00104 	addi	sp,sp,4
 2016078:	f800283a 	ret

0201607c <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
 201607c:	defffc04 	addi	sp,sp,-16
 2016080:	dfc00315 	stw	ra,12(sp)
 2016084:	df000215 	stw	fp,8(sp)
 2016088:	df000204 	addi	fp,sp,8
 201608c:	e13ffe15 	stw	r4,-8(fp)
 2016090:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 2016094:	01800f04 	movi	r6,60
 2016098:	000b883a 	mov	r5,zero
 201609c:	e13fff17 	ldw	r4,-4(fp)
 20160a0:	200616c0 	call	200616c <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
 20160a4:	e0bffe17 	ldw	r2,-8(fp)
 20160a8:	e0ffff17 	ldw	r3,-4(fp)
 20160ac:	10c00a15 	stw	r3,40(r2)
}
 20160b0:	0001883a 	nop
 20160b4:	e037883a 	mov	sp,fp
 20160b8:	dfc00117 	ldw	ra,4(sp)
 20160bc:	df000017 	ldw	fp,0(sp)
 20160c0:	dec00204 	addi	sp,sp,8
 20160c4:	f800283a 	ret

020160c8 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
 20160c8:	defffd04 	addi	sp,sp,-12
 20160cc:	dfc00215 	stw	ra,8(sp)
 20160d0:	df000115 	stw	fp,4(sp)
 20160d4:	df000104 	addi	fp,sp,4
 20160d8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);

  if (netif->dhcp != NULL) {
 20160dc:	e0bfff17 	ldw	r2,-4(fp)
 20160e0:	10800a17 	ldw	r2,40(r2)
 20160e4:	10000626 	beq	r2,zero,2016100 <dhcp_cleanup+0x38>
    mem_free(netif->dhcp);
 20160e8:	e0bfff17 	ldw	r2,-4(fp)
 20160ec:	10800a17 	ldw	r2,40(r2)
 20160f0:	1009883a 	mov	r4,r2
 20160f4:	20192a00 	call	20192a0 <mem_free>
    netif->dhcp = NULL;
 20160f8:	e0bfff17 	ldw	r2,-4(fp)
 20160fc:	10000a15 	stw	zero,40(r2)
  }
}
 2016100:	0001883a 	nop
 2016104:	e037883a 	mov	sp,fp
 2016108:	dfc00117 	ldw	ra,4(sp)
 201610c:	df000017 	ldw	fp,0(sp)
 2016110:	dec00204 	addi	sp,sp,8
 2016114:	f800283a 	ret

02016118 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
 2016118:	defffb04 	addi	sp,sp,-20
 201611c:	dfc00415 	stw	ra,16(sp)
 2016120:	df000315 	stw	fp,12(sp)
 2016124:	df000304 	addi	fp,sp,12
 2016128:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
 201612c:	e03ffe05 	stb	zero,-8(fp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
 2016130:	e0bfff17 	ldw	r2,-4(fp)
 2016134:	1000091e 	bne	r2,zero,201615c <dhcp_start+0x44>
 2016138:	01c08134 	movhi	r7,516
 201613c:	39c4d204 	addi	r7,r7,4936
 2016140:	0180a144 	movi	r6,645
 2016144:	01408134 	movhi	r5,516
 2016148:	2944d804 	addi	r5,r5,4960
 201614c:	01008134 	movhi	r4,516
 2016150:	2104dc04 	addi	r4,r4,4976
 2016154:	2000bb00 	call	2000bb0 <printf>
 2016158:	003fff06 	br	2016158 <__alt_mem_mem_0+0xfcff6158>
  dhcp = netif->dhcp;
 201615c:	e0bfff17 	ldw	r2,-4(fp)
 2016160:	10800a17 	ldw	r2,40(r2)
 2016164:	e0bffd15 	stw	r2,-12(fp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 2016168:	e0bfff17 	ldw	r2,-4(fp)
 201616c:	10c00e43 	ldbu	r3,57(r2)
 2016170:	00bffdc4 	movi	r2,-9
 2016174:	1884703a 	and	r2,r3,r2
 2016178:	1007883a 	mov	r3,r2
 201617c:	e0bfff17 	ldw	r2,-4(fp)
 2016180:	10c00e45 	stb	r3,57(r2)

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
 2016184:	e0bfff17 	ldw	r2,-4(fp)
 2016188:	10800e43 	ldbu	r2,57(r2)
 201618c:	10803fcc 	andi	r2,r2,255
 2016190:	1080080c 	andi	r2,r2,32
 2016194:	1000021e 	bne	r2,zero,20161a0 <dhcp_start+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
 2016198:	00bffc84 	movi	r2,-14
 201619c:	00005406 	br	20162f0 <dhcp_start+0x1d8>
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
 20161a0:	e0bfff17 	ldw	r2,-4(fp)
 20161a4:	10800c0b 	ldhu	r2,48(r2)
 20161a8:	10bfffcc 	andi	r2,r2,65535
 20161ac:	10809028 	cmpgeui	r2,r2,576
 20161b0:	1000021e 	bne	r2,zero,20161bc <dhcp_start+0xa4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
 20161b4:	00bfffc4 	movi	r2,-1
 20161b8:	00004d06 	br	20162f0 <dhcp_start+0x1d8>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
 20161bc:	e0bffd17 	ldw	r2,-12(fp)
 20161c0:	10000b1e 	bne	r2,zero,20161f0 <dhcp_start+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
 20161c4:	01000f04 	movi	r4,60
 20161c8:	20196b40 	call	20196b4 <mem_malloc>
 20161cc:	e0bffd15 	stw	r2,-12(fp)
    if (dhcp == NULL) {
 20161d0:	e0bffd17 	ldw	r2,-12(fp)
 20161d4:	1000021e 	bne	r2,zero,20161e0 <dhcp_start+0xc8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
 20161d8:	00bfffc4 	movi	r2,-1
 20161dc:	00004406 	br	20162f0 <dhcp_start+0x1d8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
 20161e0:	e0bfff17 	ldw	r2,-4(fp)
 20161e4:	e0fffd17 	ldw	r3,-12(fp)
 20161e8:	10c00a15 	stw	r3,40(r2)
 20161ec:	00000706 	br	201620c <dhcp_start+0xf4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
 20161f0:	e0bffd17 	ldw	r2,-12(fp)
 20161f4:	10800117 	ldw	r2,4(r2)
 20161f8:	10000426 	beq	r2,zero,201620c <dhcp_start+0xf4>
      udp_remove(dhcp->pcb);
 20161fc:	e0bffd17 	ldw	r2,-12(fp)
 2016200:	10800117 	ldw	r2,4(r2)
 2016204:	1009883a 	mov	r4,r2
 2016208:	2022a7c0 	call	2022a7c <udp_remove>
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear the previous IP assignment */
  dhcp_clear_assignment(netif);
 201620c:	e13fff17 	ldw	r4,-4(fp)
 2016210:	20155dc0 	call	20155dc <dhcp_clear_assignment>
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
 2016214:	01800f04 	movi	r6,60
 2016218:	000b883a 	mov	r5,zero
 201621c:	e13ffd17 	ldw	r4,-12(fp)
 2016220:	200616c0 	call	200616c <memset>
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
 2016224:	2022b1c0 	call	2022b1c <udp_new>
 2016228:	1007883a 	mov	r3,r2
 201622c:	e0bffd17 	ldw	r2,-12(fp)
 2016230:	10c00115 	stw	r3,4(r2)
  if (dhcp->pcb == NULL) {
 2016234:	e0bffd17 	ldw	r2,-12(fp)
 2016238:	10800117 	ldw	r2,4(r2)
 201623c:	1000021e 	bne	r2,zero,2016248 <dhcp_start+0x130>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
 2016240:	00bfffc4 	movi	r2,-1
 2016244:	00002a06 	br	20162f0 <dhcp_start+0x1d8>
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
 2016248:	e0bffd17 	ldw	r2,-12(fp)
 201624c:	10800117 	ldw	r2,4(r2)
 2016250:	e0fffd17 	ldw	r3,-12(fp)
 2016254:	18c00117 	ldw	r3,4(r3)
 2016258:	18c00203 	ldbu	r3,8(r3)
 201625c:	18c00814 	ori	r3,r3,32
 2016260:	10c00205 	stb	r3,8(r2)
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 2016264:	e0bffd17 	ldw	r2,-12(fp)
 2016268:	10800117 	ldw	r2,4(r2)
 201626c:	01801104 	movi	r6,68
 2016270:	d1600d04 	addi	r5,gp,-32716
 2016274:	1009883a 	mov	r4,r2
 2016278:	20227840 	call	2022784 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
 201627c:	e0bffd17 	ldw	r2,-12(fp)
 2016280:	10800117 	ldw	r2,4(r2)
 2016284:	018010c4 	movi	r6,67
 2016288:	d1600d04 	addi	r5,gp,-32716
 201628c:	1009883a 	mov	r4,r2
 2016290:	20228e00 	call	20228e0 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
 2016294:	e0bffd17 	ldw	r2,-12(fp)
 2016298:	10800117 	ldw	r2,4(r2)
 201629c:	e1bfff17 	ldw	r6,-4(fp)
 20162a0:	01408074 	movhi	r5,513
 20162a4:	295fb204 	addi	r5,r5,32456
 20162a8:	1009883a 	mov	r4,r2
 20162ac:	2022a380 	call	2022a38 <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
 20162b0:	e13fff17 	ldw	r4,-4(fp)
 20162b4:	201675c0 	call	201675c <dhcp_discover>
 20162b8:	e0bffe05 	stb	r2,-8(fp)
  if (result != ERR_OK) {
 20162bc:	e0bffe07 	ldb	r2,-8(fp)
 20162c0:	10000426 	beq	r2,zero,20162d4 <dhcp_start+0x1bc>
    /* free resources allocated above */
    dhcp_stop(netif);
 20162c4:	e13fff17 	ldw	r4,-4(fp)
 20162c8:	20171900 	call	2017190 <dhcp_stop>
    return ERR_MEM;
 20162cc:	00bfffc4 	movi	r2,-1
 20162d0:	00000706 	br	20162f0 <dhcp_start+0x1d8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
 20162d4:	e0bfff17 	ldw	r2,-4(fp)
 20162d8:	10800e43 	ldbu	r2,57(r2)
 20162dc:	10800214 	ori	r2,r2,8
 20162e0:	1007883a 	mov	r3,r2
 20162e4:	e0bfff17 	ldw	r2,-4(fp)
 20162e8:	10c00e45 	stb	r3,57(r2)
  return result;
 20162ec:	e0bffe03 	ldbu	r2,-8(fp)
}
 20162f0:	e037883a 	mov	sp,fp
 20162f4:	dfc00117 	ldw	ra,4(sp)
 20162f8:	df000017 	ldw	fp,0(sp)
 20162fc:	dec00204 	addi	sp,sp,8
 2016300:	f800283a 	ret

02016304 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
 2016304:	deffeb04 	addi	sp,sp,-84
 2016308:	dfc01415 	stw	ra,80(sp)
 201630c:	df001315 	stw	fp,76(sp)
 2016310:	df001304 	addi	fp,sp,76
 2016314:	e13fff15 	stw	r4,-4(fp)
  struct dhcp dhcp;
  err_t result = ERR_OK;
 2016318:	e03fef05 	stb	zero,-68(fp)
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 201631c:	e0bfff17 	ldw	r2,-4(fp)
 2016320:	1000091e 	bne	r2,zero,2016348 <dhcp_inform+0x44>
 2016324:	01c08134 	movhi	r7,516
 2016328:	39c4d204 	addi	r7,r7,4936
 201632c:	0180b6c4 	movi	r6,731
 2016330:	01408134 	movhi	r5,516
 2016334:	2944d804 	addi	r5,r5,4960
 2016338:	01008134 	movhi	r4,516
 201633c:	2104dc04 	addi	r4,r4,4976
 2016340:	2000bb00 	call	2000bb0 <printf>
 2016344:	003fff06 	br	2016344 <__alt_mem_mem_0+0xfcff6344>

  memset(&dhcp, 0, sizeof(struct dhcp));
 2016348:	e0bff004 	addi	r2,fp,-64
 201634c:	01800f04 	movi	r6,60
 2016350:	000b883a 	mov	r5,zero
 2016354:	1009883a 	mov	r4,r2
 2016358:	200616c0 	call	200616c <memset>
  dhcp_set_state(&dhcp, DHCP_INFORM);
 201635c:	e0bff004 	addi	r2,fp,-64
 2016360:	01400204 	movi	r5,8
 2016364:	1009883a 	mov	r4,r2
 2016368:	20172480 	call	2017248 <dhcp_set_state>

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
 201636c:	e0bfff17 	ldw	r2,-4(fp)
 2016370:	10800a17 	ldw	r2,40(r2)
 2016374:	10000926 	beq	r2,zero,201639c <dhcp_inform+0x98>
 2016378:	e0bfff17 	ldw	r2,-4(fp)
 201637c:	10800a17 	ldw	r2,40(r2)
 2016380:	10800117 	ldw	r2,4(r2)
 2016384:	10000526 	beq	r2,zero,201639c <dhcp_inform+0x98>
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
 2016388:	e0bfff17 	ldw	r2,-4(fp)
 201638c:	10800a17 	ldw	r2,40(r2)
 2016390:	10800117 	ldw	r2,4(r2)
 2016394:	e0bfee15 	stw	r2,-72(fp)
 2016398:	00001006 	br	20163dc <dhcp_inform+0xd8>
  } else {
    pcb = udp_new();
 201639c:	2022b1c0 	call	2022b1c <udp_new>
 20163a0:	e0bfee15 	stw	r2,-72(fp)
    if (pcb == NULL) {
 20163a4:	e0bfee17 	ldw	r2,-72(fp)
 20163a8:	10003b26 	beq	r2,zero,2016498 <dhcp_inform+0x194>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
 20163ac:	e0bfee17 	ldw	r2,-72(fp)
 20163b0:	e0bff115 	stw	r2,-60(fp)
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
 20163b4:	e0bff117 	ldw	r2,-60(fp)
 20163b8:	e0fff117 	ldw	r3,-60(fp)
 20163bc:	18c00203 	ldbu	r3,8(r3)
 20163c0:	18c00814 	ori	r3,r3,32
 20163c4:	10c00205 	stb	r3,8(r2)
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
 20163c8:	e0bff117 	ldw	r2,-60(fp)
 20163cc:	01801104 	movi	r6,68
 20163d0:	d1600d04 	addi	r5,gp,-32716
 20163d4:	1009883a 	mov	r4,r2
 20163d8:	20227840 	call	2022784 <udp_bind>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
 20163dc:	e0bff004 	addi	r2,fp,-64
 20163e0:	01800204 	movi	r6,8
 20163e4:	100b883a 	mov	r5,r2
 20163e8:	e13fff17 	ldw	r4,-4(fp)
 20163ec:	20182200 	call	2018220 <dhcp_create_msg>
 20163f0:	e0bfef05 	stb	r2,-68(fp)
  if (result == ERR_OK) {
 20163f4:	e0bfef07 	ldb	r2,-68(fp)
 20163f8:	1000211e 	bne	r2,zero,2016480 <dhcp_inform+0x17c>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 20163fc:	e0bff004 	addi	r2,fp,-64
 2016400:	01800084 	movi	r6,2
 2016404:	01400e44 	movi	r5,57
 2016408:	1009883a 	mov	r4,r2
 201640c:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
 2016410:	e0bfff17 	ldw	r2,-4(fp)
 2016414:	10800c0b 	ldhu	r2,48(r2)
 2016418:	10ffffcc 	andi	r3,r2,65535
 201641c:	e0bff004 	addi	r2,fp,-64
 2016420:	180b883a 	mov	r5,r3
 2016424:	1009883a 	mov	r4,r2
 2016428:	20173a00 	call	20173a0 <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
 201642c:	e0bff004 	addi	r2,fp,-64
 2016430:	1009883a 	mov	r4,r2
 2016434:	20188280 	call	2018828 <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
 2016438:	e0fff417 	ldw	r3,-48(fp)
 201643c:	e0bff60b 	ldhu	r2,-40(fp)
 2016440:	10803c04 	addi	r2,r2,240
 2016444:	10bfffcc 	andi	r2,r2,65535
 2016448:	100b883a 	mov	r5,r2
 201644c:	1809883a 	mov	r4,r3
 2016450:	201a8580 	call	201a858 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 2016454:	e0fff417 	ldw	r3,-48(fp)
 2016458:	e0bfff17 	ldw	r2,-4(fp)
 201645c:	d8800015 	stw	r2,0(sp)
 2016460:	01c010c4 	movi	r7,67
 2016464:	d1a00e04 	addi	r6,gp,-32712
 2016468:	180b883a 	mov	r5,r3
 201646c:	e13fee17 	ldw	r4,-72(fp)
 2016470:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(&dhcp);
 2016474:	e0bff004 	addi	r2,fp,-64
 2016478:	1009883a 	mov	r4,r2
 201647c:	20187a40 	call	20187a4 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
 2016480:	e0bff117 	ldw	r2,-60(fp)
 2016484:	10000526 	beq	r2,zero,201649c <dhcp_inform+0x198>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
 2016488:	e0bff117 	ldw	r2,-60(fp)
 201648c:	1009883a 	mov	r4,r2
 2016490:	2022a7c0 	call	2022a7c <udp_remove>
 2016494:	00000106 	br	201649c <dhcp_inform+0x198>
    pcb = netif->dhcp->pcb;
  } else {
    pcb = udp_new();
    if (pcb == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
 2016498:	0001883a 	nop

  if (dhcp.pcb != NULL) {
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
  }
}
 201649c:	e037883a 	mov	sp,fp
 20164a0:	dfc00117 	ldw	ra,4(sp)
 20164a4:	df000017 	ldw	fp,0(sp)
 20164a8:	dec00204 	addi	sp,sp,8
 20164ac:	f800283a 	ret

020164b0 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
 20164b0:	defffc04 	addi	sp,sp,-16
 20164b4:	dfc00315 	stw	ra,12(sp)
 20164b8:	df000215 	stw	fp,8(sp)
 20164bc:	df000204 	addi	fp,sp,8
 20164c0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 20164c4:	e0bfff17 	ldw	r2,-4(fp)
 20164c8:	10800a17 	ldw	r2,40(r2)
 20164cc:	e0bffe15 	stw	r2,-8(fp)
  if (!dhcp)
 20164d0:	e0bffe17 	ldw	r2,-8(fp)
 20164d4:	10001826 	beq	r2,zero,2016538 <dhcp_network_changed+0x88>
    return;
  switch (dhcp->state) {
 20164d8:	e0bffe17 	ldw	r2,-8(fp)
 20164dc:	10800303 	ldbu	r2,12(r2)
 20164e0:	10803fcc 	andi	r2,r2,255
 20164e4:	10c00188 	cmpgei	r3,r2,6
 20164e8:	1800041e 	bne	r3,zero,20164fc <dhcp_network_changed+0x4c>
 20164ec:	10c000c8 	cmpgei	r3,r2,3
 20164f0:	1800041e 	bne	r3,zero,2016504 <dhcp_network_changed+0x54>
 20164f4:	10001226 	beq	r2,zero,2016540 <dhcp_network_changed+0x90>
 20164f8:	00000906 	br	2016520 <dhcp_network_changed+0x70>
 20164fc:	108002a0 	cmpeqi	r2,r2,10
 2016500:	10000726 	beq	r2,zero,2016520 <dhcp_network_changed+0x70>
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
 2016504:	e13fff17 	ldw	r4,-4(fp)
 2016508:	201a0140 	call	201a014 <netif_set_down>
    dhcp->tries = 0;
 201650c:	e0bffe17 	ldw	r2,-8(fp)
 2016510:	10000345 	stb	zero,13(r2)
    dhcp_reboot(netif);
 2016514:	e13fff17 	ldw	r4,-4(fp)
 2016518:	2016e480 	call	2016e48 <dhcp_reboot>
    break;
 201651c:	00000906 	br	2016544 <dhcp_network_changed+0x94>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
 2016520:	e0bffe17 	ldw	r2,-8(fp)
 2016524:	10000345 	stb	zero,13(r2)
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
 2016528:	e13fff17 	ldw	r4,-4(fp)
 201652c:	201675c0 	call	201675c <dhcp_discover>
    break;
 2016530:	0001883a 	nop
 2016534:	00000306 	br	2016544 <dhcp_network_changed+0x94>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
 2016538:	0001883a 	nop
 201653c:	00000106 	br	2016544 <dhcp_network_changed+0x94>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
 2016540:	0001883a 	nop
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
 2016544:	e037883a 	mov	sp,fp
 2016548:	dfc00117 	ldw	ra,4(sp)
 201654c:	df000017 	ldw	fp,0(sp)
 2016550:	dec00204 	addi	sp,sp,8
 2016554:	f800283a 	ret

02016558 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
 2016558:	defffc04 	addi	sp,sp,-16
 201655c:	dfc00315 	stw	ra,12(sp)
 2016560:	df000215 	stw	fp,8(sp)
 2016564:	df000204 	addi	fp,sp,8
 2016568:	e13ffe15 	stw	r4,-8(fp)
 201656c:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 2016570:	e0bffe17 	ldw	r2,-8(fp)
 2016574:	1000091e 	bne	r2,zero,201659c <dhcp_arp_reply+0x44>
 2016578:	01c08134 	movhi	r7,516
 201657c:	39c4d204 	addi	r7,r7,4936
 2016580:	0180cc84 	movi	r6,818
 2016584:	01408134 	movhi	r5,516
 2016588:	2944d804 	addi	r5,r5,4960
 201658c:	01008134 	movhi	r4,516
 2016590:	2104dc04 	addi	r4,r4,4976
 2016594:	2000bb00 	call	2000bb0 <printf>
 2016598:	003fff06 	br	2016598 <__alt_mem_mem_0+0xfcff6598>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
 201659c:	e0bffe17 	ldw	r2,-8(fp)
 20165a0:	10800a17 	ldw	r2,40(r2)
 20165a4:	10000e26 	beq	r2,zero,20165e0 <dhcp_arp_reply+0x88>
 20165a8:	e0bffe17 	ldw	r2,-8(fp)
 20165ac:	10800a17 	ldw	r2,40(r2)
 20165b0:	10800303 	ldbu	r2,12(r2)
 20165b4:	10803fcc 	andi	r2,r2,255
 20165b8:	10800218 	cmpnei	r2,r2,8
 20165bc:	1000081e 	bne	r2,zero,20165e0 <dhcp_arp_reply+0x88>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
 20165c0:	e0bfff17 	ldw	r2,-4(fp)
 20165c4:	10c00017 	ldw	r3,0(r2)
 20165c8:	e0bffe17 	ldw	r2,-8(fp)
 20165cc:	10800a17 	ldw	r2,40(r2)
 20165d0:	10800917 	ldw	r2,36(r2)
 20165d4:	1880021e 	bne	r3,r2,20165e0 <dhcp_arp_reply+0x88>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
 20165d8:	e13ffe17 	ldw	r4,-8(fp)
 20165dc:	20165f80 	call	20165f8 <dhcp_decline>
    }
  }
}
 20165e0:	0001883a 	nop
 20165e4:	e037883a 	mov	sp,fp
 20165e8:	dfc00117 	ldw	ra,4(sp)
 20165ec:	df000017 	ldw	fp,0(sp)
 20165f0:	dec00204 	addi	sp,sp,8
 20165f4:	f800283a 	ret

020165f8 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
 20165f8:	defffa04 	addi	sp,sp,-24
 20165fc:	dfc00515 	stw	ra,20(sp)
 2016600:	df000415 	stw	fp,16(sp)
 2016604:	df000404 	addi	fp,sp,16
 2016608:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 201660c:	e0bfff17 	ldw	r2,-4(fp)
 2016610:	10800a17 	ldw	r2,40(r2)
 2016614:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
 2016618:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
 201661c:	01400304 	movi	r5,12
 2016620:	e13ffd17 	ldw	r4,-12(fp)
 2016624:	20172480 	call	2017248 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
 2016628:	01800104 	movi	r6,4
 201662c:	e17ffd17 	ldw	r5,-12(fp)
 2016630:	e13fff17 	ldw	r4,-4(fp)
 2016634:	20182200 	call	2018220 <dhcp_create_msg>
 2016638:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 201663c:	e0bffe07 	ldb	r2,-8(fp)
 2016640:	1000301e 	bne	r2,zero,2016704 <dhcp_decline+0x10c>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 2016644:	01800104 	movi	r6,4
 2016648:	01400c84 	movi	r5,50
 201664c:	e13ffd17 	ldw	r4,-12(fp)
 2016650:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 2016654:	e0bffd17 	ldw	r2,-12(fp)
 2016658:	10800917 	ldw	r2,36(r2)
 201665c:	1006d63a 	srli	r3,r2,24
 2016660:	e0bffd17 	ldw	r2,-12(fp)
 2016664:	10800917 	ldw	r2,36(r2)
 2016668:	1004d23a 	srli	r2,r2,8
 201666c:	10bfc00c 	andi	r2,r2,65280
 2016670:	1886b03a 	or	r3,r3,r2
 2016674:	e0bffd17 	ldw	r2,-12(fp)
 2016678:	10800917 	ldw	r2,36(r2)
 201667c:	10bfc00c 	andi	r2,r2,65280
 2016680:	1004923a 	slli	r2,r2,8
 2016684:	1886b03a 	or	r3,r3,r2
 2016688:	e0bffd17 	ldw	r2,-12(fp)
 201668c:	10800917 	ldw	r2,36(r2)
 2016690:	1004963a 	slli	r2,r2,24
 2016694:	1884b03a 	or	r2,r3,r2
 2016698:	100b883a 	mov	r5,r2
 201669c:	e13ffd17 	ldw	r4,-12(fp)
 20166a0:	20174380 	call	2017438 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
 20166a4:	e13ffd17 	ldw	r4,-12(fp)
 20166a8:	20188280 	call	2018828 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 20166ac:	e0bffd17 	ldw	r2,-12(fp)
 20166b0:	10c00417 	ldw	r3,16(r2)
 20166b4:	e0bffd17 	ldw	r2,-12(fp)
 20166b8:	1080060b 	ldhu	r2,24(r2)
 20166bc:	10803c04 	addi	r2,r2,240
 20166c0:	10bfffcc 	andi	r2,r2,65535
 20166c4:	100b883a 	mov	r5,r2
 20166c8:	1809883a 	mov	r4,r3
 20166cc:	201a8580 	call	201a858 <pbuf_realloc>

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 20166d0:	e0bffd17 	ldw	r2,-12(fp)
 20166d4:	10c00117 	ldw	r3,4(r2)
 20166d8:	e0bffd17 	ldw	r2,-12(fp)
 20166dc:	11000417 	ldw	r4,16(r2)
 20166e0:	e0bfff17 	ldw	r2,-4(fp)
 20166e4:	d8800015 	stw	r2,0(sp)
 20166e8:	01c010c4 	movi	r7,67
 20166ec:	d1a00e04 	addi	r6,gp,-32712
 20166f0:	200b883a 	mov	r5,r4
 20166f4:	1809883a 	mov	r4,r3
 20166f8:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 20166fc:	e13ffd17 	ldw	r4,-12(fp)
 2016700:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 2016704:	e0bffd17 	ldw	r2,-12(fp)
 2016708:	10800343 	ldbu	r2,13(r2)
 201670c:	10800044 	addi	r2,r2,1
 2016710:	1007883a 	mov	r3,r2
 2016714:	e0bffd17 	ldw	r2,-12(fp)
 2016718:	10c00345 	stb	r3,13(r2)
  msecs = 10*1000;
 201671c:	0089c404 	movi	r2,10000
 2016720:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 2016724:	e0bffe8b 	ldhu	r2,-6(fp)
 2016728:	10807cc4 	addi	r2,r2,499
 201672c:	01407d04 	movi	r5,500
 2016730:	1009883a 	mov	r4,r2
 2016734:	200abb00 	call	200abb0 <__divsi3>
 2016738:	1007883a 	mov	r3,r2
 201673c:	e0bffd17 	ldw	r2,-12(fp)
 2016740:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016744:	e0bffe03 	ldbu	r2,-8(fp)
}
 2016748:	e037883a 	mov	sp,fp
 201674c:	dfc00117 	ldw	ra,4(sp)
 2016750:	df000017 	ldw	fp,0(sp)
 2016754:	dec00204 	addi	sp,sp,8
 2016758:	f800283a 	ret

0201675c <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
 201675c:	defffa04 	addi	sp,sp,-24
 2016760:	dfc00515 	stw	ra,20(sp)
 2016764:	df000415 	stw	fp,16(sp)
 2016768:	df000404 	addi	fp,sp,16
 201676c:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2016770:	e0bfff17 	ldw	r2,-4(fp)
 2016774:	10800a17 	ldw	r2,40(r2)
 2016778:	e0bffd15 	stw	r2,-12(fp)
  err_t result = ERR_OK;
 201677c:	e03ffe05 	stb	zero,-8(fp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
 2016780:	e0bffd17 	ldw	r2,-12(fp)
 2016784:	10000915 	stw	zero,36(r2)
  dhcp_set_state(dhcp, DHCP_SELECTING);
 2016788:	01400184 	movi	r5,6
 201678c:	e13ffd17 	ldw	r4,-12(fp)
 2016790:	20172480 	call	2017248 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
 2016794:	01800044 	movi	r6,1
 2016798:	e17ffd17 	ldw	r5,-12(fp)
 201679c:	e13fff17 	ldw	r4,-4(fp)
 20167a0:	20182200 	call	2018220 <dhcp_create_msg>
 20167a4:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 20167a8:	e0bffe07 	ldb	r2,-8(fp)
 20167ac:	1000321e 	bne	r2,zero,2016878 <dhcp_discover+0x11c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 20167b0:	01800084 	movi	r6,2
 20167b4:	01400e44 	movi	r5,57
 20167b8:	e13ffd17 	ldw	r4,-12(fp)
 20167bc:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 20167c0:	e0bfff17 	ldw	r2,-4(fp)
 20167c4:	10800c0b 	ldhu	r2,48(r2)
 20167c8:	10bfffcc 	andi	r2,r2,65535
 20167cc:	100b883a 	mov	r5,r2
 20167d0:	e13ffd17 	ldw	r4,-12(fp)
 20167d4:	20173a00 	call	20173a0 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
 20167d8:	01800104 	movi	r6,4
 20167dc:	01400dc4 	movi	r5,55
 20167e0:	e13ffd17 	ldw	r4,-12(fp)
 20167e4:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
 20167e8:	01400044 	movi	r5,1
 20167ec:	e13ffd17 	ldw	r4,-12(fp)
 20167f0:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
 20167f4:	014000c4 	movi	r5,3
 20167f8:	e13ffd17 	ldw	r4,-12(fp)
 20167fc:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
 2016800:	01400704 	movi	r5,28
 2016804:	e13ffd17 	ldw	r4,-12(fp)
 2016808:	20173400 	call	2017340 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
 201680c:	01400184 	movi	r5,6
 2016810:	e13ffd17 	ldw	r4,-12(fp)
 2016814:	20173400 	call	2017340 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
 2016818:	e13ffd17 	ldw	r4,-12(fp)
 201681c:	20188280 	call	2018828 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2016820:	e0bffd17 	ldw	r2,-12(fp)
 2016824:	10c00417 	ldw	r3,16(r2)
 2016828:	e0bffd17 	ldw	r2,-12(fp)
 201682c:	1080060b 	ldhu	r2,24(r2)
 2016830:	10803c04 	addi	r2,r2,240
 2016834:	10bfffcc 	andi	r2,r2,65535
 2016838:	100b883a 	mov	r5,r2
 201683c:	1809883a 	mov	r4,r3
 2016840:	201a8580 	call	201a858 <pbuf_realloc>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 2016844:	e0bffd17 	ldw	r2,-12(fp)
 2016848:	10c00117 	ldw	r3,4(r2)
 201684c:	e0bffd17 	ldw	r2,-12(fp)
 2016850:	11000417 	ldw	r4,16(r2)
 2016854:	e0bfff17 	ldw	r2,-4(fp)
 2016858:	d8800015 	stw	r2,0(sp)
 201685c:	01c010c4 	movi	r7,67
 2016860:	d1a00e04 	addi	r6,gp,-32712
 2016864:	200b883a 	mov	r5,r4
 2016868:	1809883a 	mov	r4,r3
 201686c:	20222d00 	call	20222d0 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
 2016870:	e13ffd17 	ldw	r4,-12(fp)
 2016874:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 2016878:	e0bffd17 	ldw	r2,-12(fp)
 201687c:	10800343 	ldbu	r2,13(r2)
 2016880:	10800044 	addi	r2,r2,1
 2016884:	1007883a 	mov	r3,r2
 2016888:	e0bffd17 	ldw	r2,-12(fp)
 201688c:	10c00345 	stb	r3,13(r2)
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
 2016890:	e0bffd17 	ldw	r2,-12(fp)
 2016894:	10800343 	ldbu	r2,13(r2)
 2016898:	10803fcc 	andi	r2,r2,255
 201689c:	108001a8 	cmpgeui	r2,r2,6
 20168a0:	1000061e 	bne	r2,zero,20168bc <dhcp_discover+0x160>
 20168a4:	e0bffd17 	ldw	r2,-12(fp)
 20168a8:	10800343 	ldbu	r2,13(r2)
 20168ac:	10803fcc 	andi	r2,r2,255
 20168b0:	00c0fa04 	movi	r3,1000
 20168b4:	1884983a 	sll	r2,r3,r2
 20168b8:	00000106 	br	20168c0 <dhcp_discover+0x164>
 20168bc:	00ba9804 	movi	r2,-5536
 20168c0:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 20168c4:	e0bffe8b 	ldhu	r2,-6(fp)
 20168c8:	10807cc4 	addi	r2,r2,499
 20168cc:	01407d04 	movi	r5,500
 20168d0:	1009883a 	mov	r4,r2
 20168d4:	200abb00 	call	200abb0 <__divsi3>
 20168d8:	1007883a 	mov	r3,r2
 20168dc:	e0bffd17 	ldw	r2,-12(fp)
 20168e0:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 20168e4:	e0bffe03 	ldbu	r2,-8(fp)
}
 20168e8:	e037883a 	mov	sp,fp
 20168ec:	dfc00117 	ldw	ra,4(sp)
 20168f0:	df000017 	ldw	fp,0(sp)
 20168f4:	dec00204 	addi	sp,sp,8
 20168f8:	f800283a 	ret

020168fc <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
 20168fc:	defff804 	addi	sp,sp,-32
 2016900:	dfc00715 	stw	ra,28(sp)
 2016904:	df000615 	stw	fp,24(sp)
 2016908:	df000604 	addi	fp,sp,24
 201690c:	e13fff15 	stw	r4,-4(fp)
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
 2016910:	e0bfff17 	ldw	r2,-4(fp)
 2016914:	1000091e 	bne	r2,zero,201693c <dhcp_bind+0x40>
 2016918:	01c08134 	movhi	r7,516
 201691c:	39c4d204 	addi	r7,r7,4936
 2016920:	0180ec44 	movi	r6,945
 2016924:	01408134 	movhi	r5,516
 2016928:	2944e804 	addi	r5,r5,5024
 201692c:	01008134 	movhi	r4,516
 2016930:	2104dc04 	addi	r4,r4,4976
 2016934:	2000bb00 	call	2000bb0 <printf>
 2016938:	003fff06 	br	2016938 <__alt_mem_mem_0+0xfcff6938>
  dhcp = netif->dhcp;
 201693c:	e0bfff17 	ldw	r2,-4(fp)
 2016940:	10800a17 	ldw	r2,40(r2)
 2016944:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
 2016948:	e0bffb17 	ldw	r2,-20(fp)
 201694c:	1000091e 	bne	r2,zero,2016974 <dhcp_bind+0x78>
 2016950:	01c08134 	movhi	r7,516
 2016954:	39c4d204 	addi	r7,r7,4936
 2016958:	0180ecc4 	movi	r6,947
 201695c:	01408134 	movhi	r5,516
 2016960:	2944ef04 	addi	r5,r5,5052
 2016964:	01008134 	movhi	r4,516
 2016968:	2104dc04 	addi	r4,r4,4976
 201696c:	2000bb00 	call	2000bb0 <printf>
 2016970:	003fff06 	br	2016970 <__alt_mem_mem_0+0xfcff6970>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
 2016974:	e0bffb17 	ldw	r2,-20(fp)
 2016978:	10800d17 	ldw	r2,52(r2)
 201697c:	10bfffe0 	cmpeqi	r2,r2,-1
 2016980:	1000171e 	bne	r2,zero,20169e0 <dhcp_bind+0xe4>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 2016984:	e0bffb17 	ldw	r2,-20(fp)
 2016988:	10800d17 	ldw	r2,52(r2)
 201698c:	10800784 	addi	r2,r2,30
 2016990:	01400f04 	movi	r5,60
 2016994:	1009883a 	mov	r4,r2
 2016998:	200aca80 	call	200aca8 <__udivsi3>
 201699c:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
 20169a0:	e0bffa17 	ldw	r2,-24(fp)
 20169a4:	00ffffd4 	movui	r3,65535
 20169a8:	1880022e 	bgeu	r3,r2,20169b4 <dhcp_bind+0xb8>
      timeout = 0xffff;
 20169ac:	00bfffd4 	movui	r2,65535
 20169b0:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
 20169b4:	e0bffa17 	ldw	r2,-24(fp)
 20169b8:	1007883a 	mov	r3,r2
 20169bc:	e0bffb17 	ldw	r2,-20(fp)
 20169c0:	10c0070d 	sth	r3,28(r2)
    if (dhcp->t1_timeout == 0) {
 20169c4:	e0bffb17 	ldw	r2,-20(fp)
 20169c8:	1080070b 	ldhu	r2,28(r2)
 20169cc:	10bfffcc 	andi	r2,r2,65535
 20169d0:	1000031e 	bne	r2,zero,20169e0 <dhcp_bind+0xe4>
      dhcp->t1_timeout = 1;
 20169d4:	e0bffb17 	ldw	r2,-20(fp)
 20169d8:	00c00044 	movi	r3,1
 20169dc:	10c0070d 	sth	r3,28(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
 20169e0:	e0bffb17 	ldw	r2,-20(fp)
 20169e4:	10800e17 	ldw	r2,56(r2)
 20169e8:	10bfffe0 	cmpeqi	r2,r2,-1
 20169ec:	1000171e 	bne	r2,zero,2016a4c <dhcp_bind+0x150>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
 20169f0:	e0bffb17 	ldw	r2,-20(fp)
 20169f4:	10800e17 	ldw	r2,56(r2)
 20169f8:	10800784 	addi	r2,r2,30
 20169fc:	01400f04 	movi	r5,60
 2016a00:	1009883a 	mov	r4,r2
 2016a04:	200aca80 	call	200aca8 <__udivsi3>
 2016a08:	e0bffa15 	stw	r2,-24(fp)
    if(timeout > 0xffff) {
 2016a0c:	e0bffa17 	ldw	r2,-24(fp)
 2016a10:	00ffffd4 	movui	r3,65535
 2016a14:	1880022e 	bgeu	r3,r2,2016a20 <dhcp_bind+0x124>
      timeout = 0xffff;
 2016a18:	00bfffd4 	movui	r2,65535
 2016a1c:	e0bffa15 	stw	r2,-24(fp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
 2016a20:	e0bffa17 	ldw	r2,-24(fp)
 2016a24:	1007883a 	mov	r3,r2
 2016a28:	e0bffb17 	ldw	r2,-20(fp)
 2016a2c:	10c0078d 	sth	r3,30(r2)
    if (dhcp->t2_timeout == 0) {
 2016a30:	e0bffb17 	ldw	r2,-20(fp)
 2016a34:	1080078b 	ldhu	r2,30(r2)
 2016a38:	10bfffcc 	andi	r2,r2,65535
 2016a3c:	1000031e 	bne	r2,zero,2016a4c <dhcp_bind+0x150>
      dhcp->t2_timeout = 1;
 2016a40:	e0bffb17 	ldw	r2,-20(fp)
 2016a44:	00c00044 	movi	r3,1
 2016a48:	10c0078d 	sth	r3,30(r2)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
 2016a4c:	e0bffb17 	ldw	r2,-20(fp)
 2016a50:	10c0070b 	ldhu	r3,28(r2)
 2016a54:	e0bffb17 	ldw	r2,-20(fp)
 2016a58:	1080078b 	ldhu	r2,30(r2)
 2016a5c:	18ffffcc 	andi	r3,r3,65535
 2016a60:	10bfffcc 	andi	r2,r2,65535
 2016a64:	18800636 	bltu	r3,r2,2016a80 <dhcp_bind+0x184>
 2016a68:	e0bffb17 	ldw	r2,-20(fp)
 2016a6c:	1080078b 	ldhu	r2,30(r2)
 2016a70:	10bfffcc 	andi	r2,r2,65535
 2016a74:	10000226 	beq	r2,zero,2016a80 <dhcp_bind+0x184>
    dhcp->t1_timeout = 0;
 2016a78:	e0bffb17 	ldw	r2,-20(fp)
 2016a7c:	1000070d 	sth	zero,28(r2)
  }

  if (dhcp->subnet_mask_given) {
 2016a80:	e0bffb17 	ldw	r2,-20(fp)
 2016a84:	10800383 	ldbu	r2,14(r2)
 2016a88:	10803fcc 	andi	r2,r2,255
 2016a8c:	10000426 	beq	r2,zero,2016aa0 <dhcp_bind+0x1a4>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
 2016a90:	e0bffb17 	ldw	r2,-20(fp)
 2016a94:	10800a17 	ldw	r2,40(r2)
 2016a98:	e0bffd15 	stw	r2,-12(fp)
 2016a9c:	00001506 	br	2016af4 <dhcp_bind+0x1f8>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
 2016aa0:	e0bffb17 	ldw	r2,-20(fp)
 2016aa4:	10800904 	addi	r2,r2,36
 2016aa8:	10800003 	ldbu	r2,0(r2)
 2016aac:	e0bffc05 	stb	r2,-16(fp)
    if (first_octet <= 127) {
 2016ab0:	e0bffc03 	ldbu	r2,-16(fp)
 2016ab4:	10803fcc 	andi	r2,r2,255
 2016ab8:	1080201c 	xori	r2,r2,128
 2016abc:	10bfe004 	addi	r2,r2,-128
 2016ac0:	10000316 	blt	r2,zero,2016ad0 <dhcp_bind+0x1d4>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
 2016ac4:	00803fc4 	movi	r2,255
 2016ac8:	e0bffd15 	stw	r2,-12(fp)
 2016acc:	00000906 	br	2016af4 <dhcp_bind+0x1f8>
    } else if (first_octet >= 192) {
 2016ad0:	e0bffc03 	ldbu	r2,-16(fp)
 2016ad4:	10803030 	cmpltui	r2,r2,192
 2016ad8:	1000041e 	bne	r2,zero,2016aec <dhcp_bind+0x1f0>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
 2016adc:	00804034 	movhi	r2,256
 2016ae0:	10bfffc4 	addi	r2,r2,-1
 2016ae4:	e0bffd15 	stw	r2,-12(fp)
 2016ae8:	00000206 	br	2016af4 <dhcp_bind+0x1f8>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
 2016aec:	00bfffd4 	movui	r2,65535
 2016af0:	e0bffd15 	stw	r2,-12(fp)
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
 2016af4:	e0bffb17 	ldw	r2,-20(fp)
 2016af8:	10800b17 	ldw	r2,44(r2)
 2016afc:	e0bffe15 	stw	r2,-8(fp)
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
 2016b00:	e0bffe17 	ldw	r2,-8(fp)
 2016b04:	1000081e 	bne	r2,zero,2016b28 <dhcp_bind+0x22c>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
 2016b08:	e0bffb17 	ldw	r2,-20(fp)
 2016b0c:	10c00917 	ldw	r3,36(r2)
 2016b10:	e0bffd17 	ldw	r2,-12(fp)
 2016b14:	1884703a 	and	r2,r3,r2
 2016b18:	e0bffe15 	stw	r2,-8(fp)
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
 2016b1c:	e0bffe17 	ldw	r2,-8(fp)
 2016b20:	10804034 	orhi	r2,r2,256
 2016b24:	e0bffe15 	stw	r2,-8(fp)
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
 2016b28:	e0bffb17 	ldw	r2,-20(fp)
 2016b2c:	10800904 	addi	r2,r2,36
 2016b30:	100b883a 	mov	r5,r2
 2016b34:	e13fff17 	ldw	r4,-4(fp)
 2016b38:	2019d800 	call	2019d80 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
 2016b3c:	e0bffd04 	addi	r2,fp,-12
 2016b40:	100b883a 	mov	r5,r2
 2016b44:	e13fff17 	ldw	r4,-4(fp)
 2016b48:	2019ef00 	call	2019ef0 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
 2016b4c:	e0bffe04 	addi	r2,fp,-8
 2016b50:	100b883a 	mov	r5,r2
 2016b54:	e13fff17 	ldw	r4,-4(fp)
 2016b58:	2019ea80 	call	2019ea8 <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
 2016b5c:	e13fff17 	ldw	r4,-4(fp)
 2016b60:	2019f640 	call	2019f64 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
 2016b64:	01400284 	movi	r5,10
 2016b68:	e13ffb17 	ldw	r4,-20(fp)
 2016b6c:	20172480 	call	2017248 <dhcp_set_state>
}
 2016b70:	0001883a 	nop
 2016b74:	e037883a 	mov	sp,fp
 2016b78:	dfc00117 	ldw	ra,4(sp)
 2016b7c:	df000017 	ldw	fp,0(sp)
 2016b80:	dec00204 	addi	sp,sp,8
 2016b84:	f800283a 	ret

02016b88 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
 2016b88:	defffa04 	addi	sp,sp,-24
 2016b8c:	dfc00515 	stw	ra,20(sp)
 2016b90:	df000415 	stw	fp,16(sp)
 2016b94:	df000404 	addi	fp,sp,16
 2016b98:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2016b9c:	e0bfff17 	ldw	r2,-4(fp)
 2016ba0:	10800a17 	ldw	r2,40(r2)
 2016ba4:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
 2016ba8:	01400144 	movi	r5,5
 2016bac:	e13ffd17 	ldw	r4,-12(fp)
 2016bb0:	20172480 	call	2017248 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 2016bb4:	018000c4 	movi	r6,3
 2016bb8:	e17ffd17 	ldw	r5,-12(fp)
 2016bbc:	e13fff17 	ldw	r4,-4(fp)
 2016bc0:	20182200 	call	2018220 <dhcp_create_msg>
 2016bc4:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 2016bc8:	e0bffe07 	ldb	r2,-8(fp)
 2016bcc:	1000271e 	bne	r2,zero,2016c6c <dhcp_renew+0xe4>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2016bd0:	01800084 	movi	r6,2
 2016bd4:	01400e44 	movi	r5,57
 2016bd8:	e13ffd17 	ldw	r4,-12(fp)
 2016bdc:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 2016be0:	e0bfff17 	ldw	r2,-4(fp)
 2016be4:	10800c0b 	ldhu	r2,48(r2)
 2016be8:	10bfffcc 	andi	r2,r2,65535
 2016bec:	100b883a 	mov	r5,r2
 2016bf0:	e13ffd17 	ldw	r4,-12(fp)
 2016bf4:	20173a00 	call	20173a0 <dhcp_option_short>
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 2016bf8:	e17fff17 	ldw	r5,-4(fp)
 2016bfc:	e13ffd17 	ldw	r4,-12(fp)
 2016c00:	20175440 	call	2017544 <dhcp_option_hostname>
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
 2016c04:	e13ffd17 	ldw	r4,-12(fp)
 2016c08:	20188280 	call	2018828 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2016c0c:	e0bffd17 	ldw	r2,-12(fp)
 2016c10:	10c00417 	ldw	r3,16(r2)
 2016c14:	e0bffd17 	ldw	r2,-12(fp)
 2016c18:	1080060b 	ldhu	r2,24(r2)
 2016c1c:	10803c04 	addi	r2,r2,240
 2016c20:	10bfffcc 	andi	r2,r2,65535
 2016c24:	100b883a 	mov	r5,r2
 2016c28:	1809883a 	mov	r4,r3
 2016c2c:	201a8580 	call	201a858 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 2016c30:	e0bffd17 	ldw	r2,-12(fp)
 2016c34:	10c00117 	ldw	r3,4(r2)
 2016c38:	e0bffd17 	ldw	r2,-12(fp)
 2016c3c:	11000417 	ldw	r4,16(r2)
 2016c40:	e0bffd17 	ldw	r2,-12(fp)
 2016c44:	11400804 	addi	r5,r2,32
 2016c48:	e0bfff17 	ldw	r2,-4(fp)
 2016c4c:	d8800015 	stw	r2,0(sp)
 2016c50:	01c010c4 	movi	r7,67
 2016c54:	280d883a 	mov	r6,r5
 2016c58:	200b883a 	mov	r5,r4
 2016c5c:	1809883a 	mov	r4,r3
 2016c60:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 2016c64:	e13ffd17 	ldw	r4,-12(fp)
 2016c68:	20187a40 	call	20187a4 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 2016c6c:	e0bffd17 	ldw	r2,-12(fp)
 2016c70:	10800343 	ldbu	r2,13(r2)
 2016c74:	10800044 	addi	r2,r2,1
 2016c78:	1007883a 	mov	r3,r2
 2016c7c:	e0bffd17 	ldw	r2,-12(fp)
 2016c80:	10c00345 	stb	r3,13(r2)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
 2016c84:	e0bffd17 	ldw	r2,-12(fp)
 2016c88:	10800343 	ldbu	r2,13(r2)
 2016c8c:	10803fcc 	andi	r2,r2,255
 2016c90:	108002a8 	cmpgeui	r2,r2,10
 2016c94:	1000051e 	bne	r2,zero,2016cac <dhcp_renew+0x124>
 2016c98:	e0bffd17 	ldw	r2,-12(fp)
 2016c9c:	10800343 	ldbu	r2,13(r2)
 2016ca0:	10803fcc 	andi	r2,r2,255
 2016ca4:	1081f424 	muli	r2,r2,2000
 2016ca8:	00000106 	br	2016cb0 <dhcp_renew+0x128>
 2016cac:	00938804 	movi	r2,20000
 2016cb0:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 2016cb4:	e0bffe8b 	ldhu	r2,-6(fp)
 2016cb8:	10807cc4 	addi	r2,r2,499
 2016cbc:	01407d04 	movi	r5,500
 2016cc0:	1009883a 	mov	r4,r2
 2016cc4:	200abb00 	call	200abb0 <__divsi3>
 2016cc8:	1007883a 	mov	r3,r2
 2016ccc:	e0bffd17 	ldw	r2,-12(fp)
 2016cd0:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016cd4:	e0bffe03 	ldbu	r2,-8(fp)
}
 2016cd8:	e037883a 	mov	sp,fp
 2016cdc:	dfc00117 	ldw	ra,4(sp)
 2016ce0:	df000017 	ldw	fp,0(sp)
 2016ce4:	dec00204 	addi	sp,sp,8
 2016ce8:	f800283a 	ret

02016cec <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
 2016cec:	defffa04 	addi	sp,sp,-24
 2016cf0:	dfc00515 	stw	ra,20(sp)
 2016cf4:	df000415 	stw	fp,16(sp)
 2016cf8:	df000404 	addi	fp,sp,16
 2016cfc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2016d00:	e0bfff17 	ldw	r2,-4(fp)
 2016d04:	10800a17 	ldw	r2,40(r2)
 2016d08:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
 2016d0c:	01400104 	movi	r5,4
 2016d10:	e13ffd17 	ldw	r4,-12(fp)
 2016d14:	20172480 	call	2017248 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 2016d18:	018000c4 	movi	r6,3
 2016d1c:	e17ffd17 	ldw	r5,-12(fp)
 2016d20:	e13fff17 	ldw	r4,-4(fp)
 2016d24:	20182200 	call	2018220 <dhcp_create_msg>
 2016d28:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 2016d2c:	e0bffe07 	ldb	r2,-8(fp)
 2016d30:	1000251e 	bne	r2,zero,2016dc8 <dhcp_rebind+0xdc>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2016d34:	01800084 	movi	r6,2
 2016d38:	01400e44 	movi	r5,57
 2016d3c:	e13ffd17 	ldw	r4,-12(fp)
 2016d40:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
 2016d44:	e0bfff17 	ldw	r2,-4(fp)
 2016d48:	10800c0b 	ldhu	r2,48(r2)
 2016d4c:	10bfffcc 	andi	r2,r2,65535
 2016d50:	100b883a 	mov	r5,r2
 2016d54:	e13ffd17 	ldw	r4,-12(fp)
 2016d58:	20173a00 	call	20173a0 <dhcp_option_short>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
 2016d5c:	e17fff17 	ldw	r5,-4(fp)
 2016d60:	e13ffd17 	ldw	r4,-12(fp)
 2016d64:	20175440 	call	2017544 <dhcp_option_hostname>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
 2016d68:	e13ffd17 	ldw	r4,-12(fp)
 2016d6c:	20188280 	call	2018828 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2016d70:	e0bffd17 	ldw	r2,-12(fp)
 2016d74:	10c00417 	ldw	r3,16(r2)
 2016d78:	e0bffd17 	ldw	r2,-12(fp)
 2016d7c:	1080060b 	ldhu	r2,24(r2)
 2016d80:	10803c04 	addi	r2,r2,240
 2016d84:	10bfffcc 	andi	r2,r2,65535
 2016d88:	100b883a 	mov	r5,r2
 2016d8c:	1809883a 	mov	r4,r3
 2016d90:	201a8580 	call	201a858 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 2016d94:	e0bffd17 	ldw	r2,-12(fp)
 2016d98:	10c00117 	ldw	r3,4(r2)
 2016d9c:	e0bffd17 	ldw	r2,-12(fp)
 2016da0:	11000417 	ldw	r4,16(r2)
 2016da4:	e0bfff17 	ldw	r2,-4(fp)
 2016da8:	d8800015 	stw	r2,0(sp)
 2016dac:	01c010c4 	movi	r7,67
 2016db0:	d1a00e04 	addi	r6,gp,-32712
 2016db4:	200b883a 	mov	r5,r4
 2016db8:	1809883a 	mov	r4,r3
 2016dbc:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 2016dc0:	e13ffd17 	ldw	r4,-12(fp)
 2016dc4:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 2016dc8:	e0bffd17 	ldw	r2,-12(fp)
 2016dcc:	10800343 	ldbu	r2,13(r2)
 2016dd0:	10800044 	addi	r2,r2,1
 2016dd4:	1007883a 	mov	r3,r2
 2016dd8:	e0bffd17 	ldw	r2,-12(fp)
 2016ddc:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 2016de0:	e0bffd17 	ldw	r2,-12(fp)
 2016de4:	10800343 	ldbu	r2,13(r2)
 2016de8:	10803fcc 	andi	r2,r2,255
 2016dec:	108002a8 	cmpgeui	r2,r2,10
 2016df0:	1000051e 	bne	r2,zero,2016e08 <dhcp_rebind+0x11c>
 2016df4:	e0bffd17 	ldw	r2,-12(fp)
 2016df8:	10800343 	ldbu	r2,13(r2)
 2016dfc:	10803fcc 	andi	r2,r2,255
 2016e00:	1080fa24 	muli	r2,r2,1000
 2016e04:	00000106 	br	2016e0c <dhcp_rebind+0x120>
 2016e08:	0089c404 	movi	r2,10000
 2016e0c:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 2016e10:	e0bffe8b 	ldhu	r2,-6(fp)
 2016e14:	10807cc4 	addi	r2,r2,499
 2016e18:	01407d04 	movi	r5,500
 2016e1c:	1009883a 	mov	r4,r2
 2016e20:	200abb00 	call	200abb0 <__divsi3>
 2016e24:	1007883a 	mov	r3,r2
 2016e28:	e0bffd17 	ldw	r2,-12(fp)
 2016e2c:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016e30:	e0bffe03 	ldbu	r2,-8(fp)
}
 2016e34:	e037883a 	mov	sp,fp
 2016e38:	dfc00117 	ldw	ra,4(sp)
 2016e3c:	df000017 	ldw	fp,0(sp)
 2016e40:	dec00204 	addi	sp,sp,8
 2016e44:	f800283a 	ret

02016e48 <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
 2016e48:	defffa04 	addi	sp,sp,-24
 2016e4c:	dfc00515 	stw	ra,20(sp)
 2016e50:	df000415 	stw	fp,16(sp)
 2016e54:	df000404 	addi	fp,sp,16
 2016e58:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2016e5c:	e0bfff17 	ldw	r2,-4(fp)
 2016e60:	10800a17 	ldw	r2,40(r2)
 2016e64:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
 2016e68:	014000c4 	movi	r5,3
 2016e6c:	e13ffd17 	ldw	r4,-12(fp)
 2016e70:	20172480 	call	2017248 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
 2016e74:	018000c4 	movi	r6,3
 2016e78:	e17ffd17 	ldw	r5,-12(fp)
 2016e7c:	e13fff17 	ldw	r4,-4(fp)
 2016e80:	20182200 	call	2018220 <dhcp_create_msg>
 2016e84:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 2016e88:	e0bffe07 	ldb	r2,-8(fp)
 2016e8c:	1000371e 	bne	r2,zero,2016f6c <dhcp_reboot+0x124>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
 2016e90:	01800084 	movi	r6,2
 2016e94:	01400e44 	movi	r5,57
 2016e98:	e13ffd17 	ldw	r4,-12(fp)
 2016e9c:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_short(dhcp, 576);
 2016ea0:	01409004 	movi	r5,576
 2016ea4:	e13ffd17 	ldw	r4,-12(fp)
 2016ea8:	20173a00 	call	20173a0 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
 2016eac:	01800104 	movi	r6,4
 2016eb0:	01400c84 	movi	r5,50
 2016eb4:	e13ffd17 	ldw	r4,-12(fp)
 2016eb8:	20172a40 	call	20172a4 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
 2016ebc:	e0bffd17 	ldw	r2,-12(fp)
 2016ec0:	10800917 	ldw	r2,36(r2)
 2016ec4:	1006d63a 	srli	r3,r2,24
 2016ec8:	e0bffd17 	ldw	r2,-12(fp)
 2016ecc:	10800917 	ldw	r2,36(r2)
 2016ed0:	1004d23a 	srli	r2,r2,8
 2016ed4:	10bfc00c 	andi	r2,r2,65280
 2016ed8:	1886b03a 	or	r3,r3,r2
 2016edc:	e0bffd17 	ldw	r2,-12(fp)
 2016ee0:	10800917 	ldw	r2,36(r2)
 2016ee4:	10bfc00c 	andi	r2,r2,65280
 2016ee8:	1004923a 	slli	r2,r2,8
 2016eec:	1886b03a 	or	r3,r3,r2
 2016ef0:	e0bffd17 	ldw	r2,-12(fp)
 2016ef4:	10800917 	ldw	r2,36(r2)
 2016ef8:	1004963a 	slli	r2,r2,24
 2016efc:	1884b03a 	or	r2,r3,r2
 2016f00:	100b883a 	mov	r5,r2
 2016f04:	e13ffd17 	ldw	r4,-12(fp)
 2016f08:	20174380 	call	2017438 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
 2016f0c:	e13ffd17 	ldw	r4,-12(fp)
 2016f10:	20188280 	call	2018828 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2016f14:	e0bffd17 	ldw	r2,-12(fp)
 2016f18:	10c00417 	ldw	r3,16(r2)
 2016f1c:	e0bffd17 	ldw	r2,-12(fp)
 2016f20:	1080060b 	ldhu	r2,24(r2)
 2016f24:	10803c04 	addi	r2,r2,240
 2016f28:	10bfffcc 	andi	r2,r2,65535
 2016f2c:	100b883a 	mov	r5,r2
 2016f30:	1809883a 	mov	r4,r3
 2016f34:	201a8580 	call	201a858 <pbuf_realloc>

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
 2016f38:	e0bffd17 	ldw	r2,-12(fp)
 2016f3c:	10c00117 	ldw	r3,4(r2)
 2016f40:	e0bffd17 	ldw	r2,-12(fp)
 2016f44:	11000417 	ldw	r4,16(r2)
 2016f48:	e0bfff17 	ldw	r2,-4(fp)
 2016f4c:	d8800015 	stw	r2,0(sp)
 2016f50:	01c010c4 	movi	r7,67
 2016f54:	d1a00e04 	addi	r6,gp,-32712
 2016f58:	200b883a 	mov	r5,r4
 2016f5c:	1809883a 	mov	r4,r3
 2016f60:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 2016f64:	e13ffd17 	ldw	r4,-12(fp)
 2016f68:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 2016f6c:	e0bffd17 	ldw	r2,-12(fp)
 2016f70:	10800343 	ldbu	r2,13(r2)
 2016f74:	10800044 	addi	r2,r2,1
 2016f78:	1007883a 	mov	r3,r2
 2016f7c:	e0bffd17 	ldw	r2,-12(fp)
 2016f80:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 2016f84:	e0bffd17 	ldw	r2,-12(fp)
 2016f88:	10800343 	ldbu	r2,13(r2)
 2016f8c:	10803fcc 	andi	r2,r2,255
 2016f90:	108002a8 	cmpgeui	r2,r2,10
 2016f94:	1000051e 	bne	r2,zero,2016fac <dhcp_reboot+0x164>
 2016f98:	e0bffd17 	ldw	r2,-12(fp)
 2016f9c:	10800343 	ldbu	r2,13(r2)
 2016fa0:	10803fcc 	andi	r2,r2,255
 2016fa4:	1080fa24 	muli	r2,r2,1000
 2016fa8:	00000106 	br	2016fb0 <dhcp_reboot+0x168>
 2016fac:	0089c404 	movi	r2,10000
 2016fb0:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 2016fb4:	e0bffe8b 	ldhu	r2,-6(fp)
 2016fb8:	10807cc4 	addi	r2,r2,499
 2016fbc:	01407d04 	movi	r5,500
 2016fc0:	1009883a 	mov	r4,r2
 2016fc4:	200abb00 	call	200abb0 <__divsi3>
 2016fc8:	1007883a 	mov	r3,r2
 2016fcc:	e0bffd17 	ldw	r2,-12(fp)
 2016fd0:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
 2016fd4:	e0bffe03 	ldbu	r2,-8(fp)
}
 2016fd8:	e037883a 	mov	sp,fp
 2016fdc:	dfc00117 	ldw	ra,4(sp)
 2016fe0:	df000017 	ldw	fp,0(sp)
 2016fe4:	dec00204 	addi	sp,sp,8
 2016fe8:	f800283a 	ret

02016fec <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
 2016fec:	defffa04 	addi	sp,sp,-24
 2016ff0:	dfc00515 	stw	ra,20(sp)
 2016ff4:	df000415 	stw	fp,16(sp)
 2016ff8:	df000404 	addi	fp,sp,16
 2016ffc:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp = netif->dhcp;
 2017000:	e0bfff17 	ldw	r2,-4(fp)
 2017004:	10800a17 	ldw	r2,40(r2)
 2017008:	e0bffd15 	stw	r2,-12(fp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
 201700c:	000b883a 	mov	r5,zero
 2017010:	e13ffd17 	ldw	r4,-12(fp)
 2017014:	20172480 	call	2017248 <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
 2017018:	e0bffd17 	ldw	r2,-12(fp)
 201701c:	10000815 	stw	zero,32(r2)
  ip_addr_set_zero(&dhcp->offered_ip_addr);
 2017020:	e0bffd17 	ldw	r2,-12(fp)
 2017024:	10000915 	stw	zero,36(r2)
  ip_addr_set_zero(&dhcp->offered_sn_mask);
 2017028:	e0bffd17 	ldw	r2,-12(fp)
 201702c:	10000a15 	stw	zero,40(r2)
  ip_addr_set_zero(&dhcp->offered_gw_addr);
 2017030:	e0bffd17 	ldw	r2,-12(fp)
 2017034:	10000b15 	stw	zero,44(r2)
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
 2017038:	e0bffd17 	ldw	r2,-12(fp)
 201703c:	10000e15 	stw	zero,56(r2)
 2017040:	e0bffd17 	ldw	r2,-12(fp)
 2017044:	10c00e17 	ldw	r3,56(r2)
 2017048:	e0bffd17 	ldw	r2,-12(fp)
 201704c:	10c00d15 	stw	r3,52(r2)
 2017050:	e0bffd17 	ldw	r2,-12(fp)
 2017054:	10c00d17 	ldw	r3,52(r2)
 2017058:	e0bffd17 	ldw	r2,-12(fp)
 201705c:	10c00c15 	stw	r3,48(r2)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
 2017060:	018001c4 	movi	r6,7
 2017064:	e17ffd17 	ldw	r5,-12(fp)
 2017068:	e13fff17 	ldw	r4,-4(fp)
 201706c:	20182200 	call	2018220 <dhcp_create_msg>
 2017070:	e0bffe05 	stb	r2,-8(fp)
  if (result == ERR_OK) {
 2017074:	e0bffe07 	ldb	r2,-8(fp)
 2017078:	10001a1e 	bne	r2,zero,20170e4 <dhcp_release+0xf8>
    dhcp_option_trailer(dhcp);
 201707c:	e13ffd17 	ldw	r4,-12(fp)
 2017080:	20188280 	call	2018828 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
 2017084:	e0bffd17 	ldw	r2,-12(fp)
 2017088:	10c00417 	ldw	r3,16(r2)
 201708c:	e0bffd17 	ldw	r2,-12(fp)
 2017090:	1080060b 	ldhu	r2,24(r2)
 2017094:	10803c04 	addi	r2,r2,240
 2017098:	10bfffcc 	andi	r2,r2,65535
 201709c:	100b883a 	mov	r5,r2
 20170a0:	1809883a 	mov	r4,r3
 20170a4:	201a8580 	call	201a858 <pbuf_realloc>

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
 20170a8:	e0bffd17 	ldw	r2,-12(fp)
 20170ac:	10c00117 	ldw	r3,4(r2)
 20170b0:	e0bffd17 	ldw	r2,-12(fp)
 20170b4:	11000417 	ldw	r4,16(r2)
 20170b8:	e0bffd17 	ldw	r2,-12(fp)
 20170bc:	11400804 	addi	r5,r2,32
 20170c0:	e0bfff17 	ldw	r2,-4(fp)
 20170c4:	d8800015 	stw	r2,0(sp)
 20170c8:	01c010c4 	movi	r7,67
 20170cc:	280d883a 	mov	r6,r5
 20170d0:	200b883a 	mov	r5,r4
 20170d4:	1809883a 	mov	r4,r3
 20170d8:	20222d00 	call	20222d0 <udp_sendto_if>
    dhcp_delete_msg(dhcp);
 20170dc:	e13ffd17 	ldw	r4,-12(fp)
 20170e0:	20187a40 	call	20187a4 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
 20170e4:	e0bffd17 	ldw	r2,-12(fp)
 20170e8:	10800343 	ldbu	r2,13(r2)
 20170ec:	10800044 	addi	r2,r2,1
 20170f0:	1007883a 	mov	r3,r2
 20170f4:	e0bffd17 	ldw	r2,-12(fp)
 20170f8:	10c00345 	stb	r3,13(r2)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
 20170fc:	e0bffd17 	ldw	r2,-12(fp)
 2017100:	10800343 	ldbu	r2,13(r2)
 2017104:	10803fcc 	andi	r2,r2,255
 2017108:	108002a8 	cmpgeui	r2,r2,10
 201710c:	1000051e 	bne	r2,zero,2017124 <dhcp_release+0x138>
 2017110:	e0bffd17 	ldw	r2,-12(fp)
 2017114:	10800343 	ldbu	r2,13(r2)
 2017118:	10803fcc 	andi	r2,r2,255
 201711c:	1080fa24 	muli	r2,r2,1000
 2017120:	00000106 	br	2017128 <dhcp_release+0x13c>
 2017124:	0089c404 	movi	r2,10000
 2017128:	e0bffe8d 	sth	r2,-6(fp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
 201712c:	e0bffe8b 	ldhu	r2,-6(fp)
 2017130:	10807cc4 	addi	r2,r2,499
 2017134:	01407d04 	movi	r5,500
 2017138:	1009883a 	mov	r4,r2
 201713c:	200abb00 	call	200abb0 <__divsi3>
 2017140:	1007883a 	mov	r3,r2
 2017144:	e0bffd17 	ldw	r2,-12(fp)
 2017148:	10c0068d 	sth	r3,26(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
 201714c:	e13fff17 	ldw	r4,-4(fp)
 2017150:	201a0140 	call	201a014 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
 2017154:	d1600d04 	addi	r5,gp,-32716
 2017158:	e13fff17 	ldw	r4,-4(fp)
 201715c:	2019d800 	call	2019d80 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
 2017160:	d1600d04 	addi	r5,gp,-32716
 2017164:	e13fff17 	ldw	r4,-4(fp)
 2017168:	2019ea80 	call	2019ea8 <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
 201716c:	d1600d04 	addi	r5,gp,-32716
 2017170:	e13fff17 	ldw	r4,-4(fp)
 2017174:	2019ef00 	call	2019ef0 <netif_set_netmask>
  
  return result;
 2017178:	e0bffe03 	ldbu	r2,-8(fp)
}
 201717c:	e037883a 	mov	sp,fp
 2017180:	dfc00117 	ldw	ra,4(sp)
 2017184:	df000017 	ldw	fp,0(sp)
 2017188:	dec00204 	addi	sp,sp,8
 201718c:	f800283a 	ret

02017190 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
 2017190:	defffc04 	addi	sp,sp,-16
 2017194:	dfc00315 	stw	ra,12(sp)
 2017198:	df000215 	stw	fp,8(sp)
 201719c:	df000204 	addi	fp,sp,8
 20171a0:	e13fff15 	stw	r4,-4(fp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
 20171a4:	e0bfff17 	ldw	r2,-4(fp)
 20171a8:	1000091e 	bne	r2,zero,20171d0 <dhcp_stop+0x40>
 20171ac:	01c08134 	movhi	r7,516
 20171b0:	39c4d204 	addi	r7,r7,4936
 20171b4:	01813504 	movi	r6,1236
 20171b8:	01408134 	movhi	r5,516
 20171bc:	2944f504 	addi	r5,r5,5076
 20171c0:	01008134 	movhi	r4,516
 20171c4:	2104dc04 	addi	r4,r4,4976
 20171c8:	2000bb00 	call	2000bb0 <printf>
 20171cc:	003fff06 	br	20171cc <__alt_mem_mem_0+0xfcff71cc>
  dhcp = netif->dhcp;
 20171d0:	e0bfff17 	ldw	r2,-4(fp)
 20171d4:	10800a17 	ldw	r2,40(r2)
 20171d8:	e0bffe15 	stw	r2,-8(fp)
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
 20171dc:	e0bfff17 	ldw	r2,-4(fp)
 20171e0:	10c00e43 	ldbu	r3,57(r2)
 20171e4:	00bffdc4 	movi	r2,-9
 20171e8:	1884703a 	and	r2,r3,r2
 20171ec:	1007883a 	mov	r3,r2
 20171f0:	e0bfff17 	ldw	r2,-4(fp)
 20171f4:	10c00e45 	stb	r3,57(r2)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
 20171f8:	e0bffe17 	ldw	r2,-8(fp)
 20171fc:	10000c26 	beq	r2,zero,2017230 <dhcp_stop+0xa0>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
 2017200:	e0bffe17 	ldw	r2,-8(fp)
 2017204:	10800117 	ldw	r2,4(r2)
 2017208:	10000626 	beq	r2,zero,2017224 <dhcp_stop+0x94>
      udp_remove(dhcp->pcb);
 201720c:	e0bffe17 	ldw	r2,-8(fp)
 2017210:	10800117 	ldw	r2,4(r2)
 2017214:	1009883a 	mov	r4,r2
 2017218:	2022a7c0 	call	2022a7c <udp_remove>
      dhcp->pcb = NULL;
 201721c:	e0bffe17 	ldw	r2,-8(fp)
 2017220:	10000115 	stw	zero,4(r2)
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    dhcp_set_state(dhcp, DHCP_OFF);
 2017224:	000b883a 	mov	r5,zero
 2017228:	e13ffe17 	ldw	r4,-8(fp)
 201722c:	20172480 	call	2017248 <dhcp_set_state>
  }
}
 2017230:	0001883a 	nop
 2017234:	e037883a 	mov	sp,fp
 2017238:	dfc00117 	ldw	ra,4(sp)
 201723c:	df000017 	ldw	fp,0(sp)
 2017240:	dec00204 	addi	sp,sp,8
 2017244:	f800283a 	ret

02017248 <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
 2017248:	defffd04 	addi	sp,sp,-12
 201724c:	df000215 	stw	fp,8(sp)
 2017250:	df000204 	addi	fp,sp,8
 2017254:	e13ffe15 	stw	r4,-8(fp)
 2017258:	2805883a 	mov	r2,r5
 201725c:	e0bfff05 	stb	r2,-4(fp)
  if (new_state != dhcp->state) {
 2017260:	e0bffe17 	ldw	r2,-8(fp)
 2017264:	10800303 	ldbu	r2,12(r2)
 2017268:	10c03fcc 	andi	r3,r2,255
 201726c:	e0bfff03 	ldbu	r2,-4(fp)
 2017270:	18800726 	beq	r3,r2,2017290 <dhcp_set_state+0x48>
    dhcp->state = new_state;
 2017274:	e0bffe17 	ldw	r2,-8(fp)
 2017278:	e0ffff03 	ldbu	r3,-4(fp)
 201727c:	10c00305 	stb	r3,12(r2)
    dhcp->tries = 0;
 2017280:	e0bffe17 	ldw	r2,-8(fp)
 2017284:	10000345 	stb	zero,13(r2)
    dhcp->request_timeout = 0;
 2017288:	e0bffe17 	ldw	r2,-8(fp)
 201728c:	1000068d 	sth	zero,26(r2)
  }
}
 2017290:	0001883a 	nop
 2017294:	e037883a 	mov	sp,fp
 2017298:	df000017 	ldw	fp,0(sp)
 201729c:	dec00104 	addi	sp,sp,4
 20172a0:	f800283a 	ret

020172a4 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
 20172a4:	defffc04 	addi	sp,sp,-16
 20172a8:	df000315 	stw	fp,12(sp)
 20172ac:	df000304 	addi	fp,sp,12
 20172b0:	e13ffd15 	stw	r4,-12(fp)
 20172b4:	2807883a 	mov	r3,r5
 20172b8:	3005883a 	mov	r2,r6
 20172bc:	e0fffe05 	stb	r3,-8(fp)
 20172c0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
 20172c4:	e0bffd17 	ldw	r2,-12(fp)
 20172c8:	10c00517 	ldw	r3,20(r2)
 20172cc:	e0bffd17 	ldw	r2,-12(fp)
 20172d0:	1080060b 	ldhu	r2,24(r2)
 20172d4:	11000044 	addi	r4,r2,1
 20172d8:	200b883a 	mov	r5,r4
 20172dc:	e13ffd17 	ldw	r4,-12(fp)
 20172e0:	2140060d 	sth	r5,24(r4)
 20172e4:	10bfffcc 	andi	r2,r2,65535
 20172e8:	1885883a 	add	r2,r3,r2
 20172ec:	10803c04 	addi	r2,r2,240
 20172f0:	e0fffe03 	ldbu	r3,-8(fp)
 20172f4:	10c00005 	stb	r3,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
 20172f8:	e0bffd17 	ldw	r2,-12(fp)
 20172fc:	10c00517 	ldw	r3,20(r2)
 2017300:	e0bffd17 	ldw	r2,-12(fp)
 2017304:	1080060b 	ldhu	r2,24(r2)
 2017308:	11000044 	addi	r4,r2,1
 201730c:	200b883a 	mov	r5,r4
 2017310:	e13ffd17 	ldw	r4,-12(fp)
 2017314:	2140060d 	sth	r5,24(r4)
 2017318:	10bfffcc 	andi	r2,r2,65535
 201731c:	1885883a 	add	r2,r3,r2
 2017320:	10803c04 	addi	r2,r2,240
 2017324:	e0ffff03 	ldbu	r3,-4(fp)
 2017328:	10c00005 	stb	r3,0(r2)
}
 201732c:	0001883a 	nop
 2017330:	e037883a 	mov	sp,fp
 2017334:	df000017 	ldw	fp,0(sp)
 2017338:	dec00104 	addi	sp,sp,4
 201733c:	f800283a 	ret

02017340 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
 2017340:	defffd04 	addi	sp,sp,-12
 2017344:	df000215 	stw	fp,8(sp)
 2017348:	df000204 	addi	fp,sp,8
 201734c:	e13ffe15 	stw	r4,-8(fp)
 2017350:	2805883a 	mov	r2,r5
 2017354:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
 2017358:	e0bffe17 	ldw	r2,-8(fp)
 201735c:	10c00517 	ldw	r3,20(r2)
 2017360:	e0bffe17 	ldw	r2,-8(fp)
 2017364:	1080060b 	ldhu	r2,24(r2)
 2017368:	11000044 	addi	r4,r2,1
 201736c:	200b883a 	mov	r5,r4
 2017370:	e13ffe17 	ldw	r4,-8(fp)
 2017374:	2140060d 	sth	r5,24(r4)
 2017378:	10bfffcc 	andi	r2,r2,65535
 201737c:	1885883a 	add	r2,r3,r2
 2017380:	10803c04 	addi	r2,r2,240
 2017384:	e0ffff03 	ldbu	r3,-4(fp)
 2017388:	10c00005 	stb	r3,0(r2)
}
 201738c:	0001883a 	nop
 2017390:	e037883a 	mov	sp,fp
 2017394:	df000017 	ldw	fp,0(sp)
 2017398:	dec00104 	addi	sp,sp,4
 201739c:	f800283a 	ret

020173a0 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
 20173a0:	defffd04 	addi	sp,sp,-12
 20173a4:	df000215 	stw	fp,8(sp)
 20173a8:	df000204 	addi	fp,sp,8
 20173ac:	e13ffe15 	stw	r4,-8(fp)
 20173b0:	2805883a 	mov	r2,r5
 20173b4:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
 20173b8:	e0bffe17 	ldw	r2,-8(fp)
 20173bc:	10c00517 	ldw	r3,20(r2)
 20173c0:	e0bffe17 	ldw	r2,-8(fp)
 20173c4:	1080060b 	ldhu	r2,24(r2)
 20173c8:	11000044 	addi	r4,r2,1
 20173cc:	200b883a 	mov	r5,r4
 20173d0:	e13ffe17 	ldw	r4,-8(fp)
 20173d4:	2140060d 	sth	r5,24(r4)
 20173d8:	10bfffcc 	andi	r2,r2,65535
 20173dc:	e13fff0b 	ldhu	r4,-4(fp)
 20173e0:	2008d23a 	srli	r4,r4,8
 20173e4:	1885883a 	add	r2,r3,r2
 20173e8:	10803c04 	addi	r2,r2,240
 20173ec:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
 20173f0:	e0bffe17 	ldw	r2,-8(fp)
 20173f4:	10c00517 	ldw	r3,20(r2)
 20173f8:	e0bffe17 	ldw	r2,-8(fp)
 20173fc:	1080060b 	ldhu	r2,24(r2)
 2017400:	11000044 	addi	r4,r2,1
 2017404:	200b883a 	mov	r5,r4
 2017408:	e13ffe17 	ldw	r4,-8(fp)
 201740c:	2140060d 	sth	r5,24(r4)
 2017410:	10bfffcc 	andi	r2,r2,65535
 2017414:	e13fff0b 	ldhu	r4,-4(fp)
 2017418:	1885883a 	add	r2,r3,r2
 201741c:	10803c04 	addi	r2,r2,240
 2017420:	11000005 	stb	r4,0(r2)
}
 2017424:	0001883a 	nop
 2017428:	e037883a 	mov	sp,fp
 201742c:	df000017 	ldw	fp,0(sp)
 2017430:	dec00104 	addi	sp,sp,4
 2017434:	f800283a 	ret

02017438 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
 2017438:	defffd04 	addi	sp,sp,-12
 201743c:	df000215 	stw	fp,8(sp)
 2017440:	df000204 	addi	fp,sp,8
 2017444:	e13ffe15 	stw	r4,-8(fp)
 2017448:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
 201744c:	e0bffe17 	ldw	r2,-8(fp)
 2017450:	10c00517 	ldw	r3,20(r2)
 2017454:	e0bffe17 	ldw	r2,-8(fp)
 2017458:	1080060b 	ldhu	r2,24(r2)
 201745c:	11000044 	addi	r4,r2,1
 2017460:	200b883a 	mov	r5,r4
 2017464:	e13ffe17 	ldw	r4,-8(fp)
 2017468:	2140060d 	sth	r5,24(r4)
 201746c:	10bfffcc 	andi	r2,r2,65535
 2017470:	e13fff17 	ldw	r4,-4(fp)
 2017474:	2008d63a 	srli	r4,r4,24
 2017478:	1885883a 	add	r2,r3,r2
 201747c:	10803c04 	addi	r2,r2,240
 2017480:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
 2017484:	e0bffe17 	ldw	r2,-8(fp)
 2017488:	10c00517 	ldw	r3,20(r2)
 201748c:	e0bffe17 	ldw	r2,-8(fp)
 2017490:	1080060b 	ldhu	r2,24(r2)
 2017494:	11000044 	addi	r4,r2,1
 2017498:	200b883a 	mov	r5,r4
 201749c:	e13ffe17 	ldw	r4,-8(fp)
 20174a0:	2140060d 	sth	r5,24(r4)
 20174a4:	10bfffcc 	andi	r2,r2,65535
 20174a8:	e13fff17 	ldw	r4,-4(fp)
 20174ac:	21003fec 	andhi	r4,r4,255
 20174b0:	2008d43a 	srli	r4,r4,16
 20174b4:	1885883a 	add	r2,r3,r2
 20174b8:	10803c04 	addi	r2,r2,240
 20174bc:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
 20174c0:	e0bffe17 	ldw	r2,-8(fp)
 20174c4:	10c00517 	ldw	r3,20(r2)
 20174c8:	e0bffe17 	ldw	r2,-8(fp)
 20174cc:	1080060b 	ldhu	r2,24(r2)
 20174d0:	11000044 	addi	r4,r2,1
 20174d4:	200b883a 	mov	r5,r4
 20174d8:	e13ffe17 	ldw	r4,-8(fp)
 20174dc:	2140060d 	sth	r5,24(r4)
 20174e0:	10bfffcc 	andi	r2,r2,65535
 20174e4:	e13fff17 	ldw	r4,-4(fp)
 20174e8:	213fc00c 	andi	r4,r4,65280
 20174ec:	2008d23a 	srli	r4,r4,8
 20174f0:	1885883a 	add	r2,r3,r2
 20174f4:	10803c04 	addi	r2,r2,240
 20174f8:	11000005 	stb	r4,0(r2)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
 20174fc:	e0bffe17 	ldw	r2,-8(fp)
 2017500:	10c00517 	ldw	r3,20(r2)
 2017504:	e0bffe17 	ldw	r2,-8(fp)
 2017508:	1080060b 	ldhu	r2,24(r2)
 201750c:	11000044 	addi	r4,r2,1
 2017510:	200b883a 	mov	r5,r4
 2017514:	e13ffe17 	ldw	r4,-8(fp)
 2017518:	2140060d 	sth	r5,24(r4)
 201751c:	10bfffcc 	andi	r2,r2,65535
 2017520:	e13fff17 	ldw	r4,-4(fp)
 2017524:	1885883a 	add	r2,r3,r2
 2017528:	10803c04 	addi	r2,r2,240
 201752c:	11000005 	stb	r4,0(r2)
}
 2017530:	0001883a 	nop
 2017534:	e037883a 	mov	sp,fp
 2017538:	df000017 	ldw	fp,0(sp)
 201753c:	dec00104 	addi	sp,sp,4
 2017540:	f800283a 	ret

02017544 <dhcp_option_hostname>:

#if LWIP_NETIF_HOSTNAME
static void
dhcp_option_hostname(struct dhcp *dhcp, struct netif *netif)
{
 2017544:	defff804 	addi	sp,sp,-32
 2017548:	dfc00715 	stw	ra,28(sp)
 201754c:	df000615 	stw	fp,24(sp)
 2017550:	df000604 	addi	fp,sp,24
 2017554:	e13ffe15 	stw	r4,-8(fp)
 2017558:	e17fff15 	stw	r5,-4(fp)
  if (netif->hostname != NULL) {
 201755c:	e0bfff17 	ldw	r2,-4(fp)
 2017560:	10800b17 	ldw	r2,44(r2)
 2017564:	10002826 	beq	r2,zero,2017608 <dhcp_option_hostname+0xc4>
    size_t namelen = strlen(netif->hostname);
 2017568:	e0bfff17 	ldw	r2,-4(fp)
 201756c:	10800b17 	ldw	r2,44(r2)
 2017570:	1009883a 	mov	r4,r2
 2017574:	20075700 	call	2007570 <strlen>
 2017578:	e0bffc15 	stw	r2,-16(fp)
    if (namelen > 0) {
 201757c:	e0bffc17 	ldw	r2,-16(fp)
 2017580:	10002126 	beq	r2,zero,2017608 <dhcp_option_hostname+0xc4>
      u8_t len;
      const char *p = netif->hostname;
 2017584:	e0bfff17 	ldw	r2,-4(fp)
 2017588:	10800b17 	ldw	r2,44(r2)
 201758c:	e0bffb15 	stw	r2,-20(fp)
      /* Shrink len to available bytes (need 2 bytes for OPTION_HOSTNAME
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
 2017590:	e0bffe17 	ldw	r2,-8(fp)
 2017594:	1080060b 	ldhu	r2,24(r2)
 2017598:	10bfffcc 	andi	r2,r2,65535
 201759c:	00c01044 	movi	r3,65
 20175a0:	1885c83a 	sub	r2,r3,r2
 20175a4:	e0bffd15 	stw	r2,-12(fp)
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
 20175a8:	e0fffc17 	ldw	r3,-16(fp)
 20175ac:	e0bffd17 	ldw	r2,-12(fp)
 20175b0:	1880012e 	bgeu	r3,r2,20175b8 <dhcp_option_hostname+0x74>
 20175b4:	1805883a 	mov	r2,r3
 20175b8:	e0bffa05 	stb	r2,-24(fp)
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
 20175bc:	e0bffa03 	ldbu	r2,-24(fp)
 20175c0:	100d883a 	mov	r6,r2
 20175c4:	01400304 	movi	r5,12
 20175c8:	e13ffe17 	ldw	r4,-8(fp)
 20175cc:	20172a40 	call	20172a4 <dhcp_option>
      while (len--) {
 20175d0:	00000806 	br	20175f4 <dhcp_option_hostname+0xb0>
        dhcp_option_byte(dhcp, *p++);
 20175d4:	e0bffb17 	ldw	r2,-20(fp)
 20175d8:	10c00044 	addi	r3,r2,1
 20175dc:	e0fffb15 	stw	r3,-20(fp)
 20175e0:	10800003 	ldbu	r2,0(r2)
 20175e4:	10803fcc 	andi	r2,r2,255
 20175e8:	100b883a 	mov	r5,r2
 20175ec:	e13ffe17 	ldw	r4,-8(fp)
 20175f0:	20173400 	call	2017340 <dhcp_option_byte>
         and 1 byte for trailer) */
      size_t available = DHCP_OPTIONS_LEN - dhcp->options_out_len - 3;
      LWIP_ASSERT("DHCP: hostname is too long!", namelen <= available);
      len = LWIP_MIN(namelen, available);
      dhcp_option(dhcp, DHCP_OPTION_HOSTNAME, len);
      while (len--) {
 20175f4:	e0bffa03 	ldbu	r2,-24(fp)
 20175f8:	10ffffc4 	addi	r3,r2,-1
 20175fc:	e0fffa05 	stb	r3,-24(fp)
 2017600:	10803fcc 	andi	r2,r2,255
 2017604:	103ff31e 	bne	r2,zero,20175d4 <__alt_mem_mem_0+0xfcff75d4>
        dhcp_option_byte(dhcp, *p++);
      }
    }
  }
}
 2017608:	0001883a 	nop
 201760c:	e037883a 	mov	sp,fp
 2017610:	dfc00117 	ldw	ra,4(sp)
 2017614:	df000017 	ldw	fp,0(sp)
 2017618:	dec00204 	addi	sp,sp,8
 201761c:	f800283a 	ret

02017620 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
 2017620:	defff004 	addi	sp,sp,-64
 2017624:	dfc00f15 	stw	ra,60(sp)
 2017628:	df000e15 	stw	fp,56(sp)
 201762c:	df000e04 	addi	fp,sp,56
 2017630:	e13ffe15 	stw	r4,-8(fp)
 2017634:	e17fff15 	stw	r5,-4(fp)
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
 2017638:	e03ff615 	stw	zero,-40(fp)
  int parse_sname_as_options = 0;
 201763c:	e03ff715 	stw	zero,-36(fp)

  /* clear received options */
  dhcp_clear_all_options(dhcp);
 2017640:	01800284 	movi	r6,10
 2017644:	000b883a 	mov	r5,zero
 2017648:	010085b4 	movhi	r4,534
 201764c:	2108aa04 	addi	r4,r4,8872
 2017650:	200616c0 	call	200616c <memset>
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
 2017654:	e0bfff17 	ldw	r2,-4(fp)
 2017658:	1080028b 	ldhu	r2,10(r2)
 201765c:	10bfffcc 	andi	r2,r2,65535
 2017660:	10800b28 	cmpgeui	r2,r2,44
 2017664:	1000021e 	bne	r2,zero,2017670 <dhcp_parse_reply+0x50>
    return ERR_BUF;
 2017668:	00bfff84 	movi	r2,-2
 201766c:	00021106 	br	2017eb4 <dhcp_parse_reply+0x894>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
 2017670:	e0bfff17 	ldw	r2,-4(fp)
 2017674:	10c00117 	ldw	r3,4(r2)
 2017678:	e0bffe17 	ldw	r2,-8(fp)
 201767c:	10c00215 	stw	r3,8(r2)
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
 2017680:	00803c04 	movi	r2,240
 2017684:	e0bff40d 	sth	r2,-48(fp)
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
 2017688:	e0bfff17 	ldw	r2,-4(fp)
 201768c:	1080020b 	ldhu	r2,8(r2)
 2017690:	e0bff48d 	sth	r2,-46(fp)
again:
  q = p;
 2017694:	e0bfff17 	ldw	r2,-4(fp)
 2017698:	e0bff515 	stw	r2,-44(fp)
  while((q != NULL) && (options_idx >= q->len)) {
 201769c:	00000d06 	br	20176d4 <dhcp_parse_reply+0xb4>
    options_idx -= q->len;
 20176a0:	e0bff517 	ldw	r2,-44(fp)
 20176a4:	1080028b 	ldhu	r2,10(r2)
 20176a8:	e0fff40b 	ldhu	r3,-48(fp)
 20176ac:	1885c83a 	sub	r2,r3,r2
 20176b0:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max -= q->len;
 20176b4:	e0bff517 	ldw	r2,-44(fp)
 20176b8:	1080028b 	ldhu	r2,10(r2)
 20176bc:	e0fff48b 	ldhu	r3,-46(fp)
 20176c0:	1885c83a 	sub	r2,r3,r2
 20176c4:	e0bff48d 	sth	r2,-46(fp)
    q = q->next;
 20176c8:	e0bff517 	ldw	r2,-44(fp)
 20176cc:	10800017 	ldw	r2,0(r2)
 20176d0:	e0bff515 	stw	r2,-44(fp)
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
 20176d4:	e0bff517 	ldw	r2,-44(fp)
 20176d8:	10000526 	beq	r2,zero,20176f0 <dhcp_parse_reply+0xd0>
 20176dc:	e0bff517 	ldw	r2,-44(fp)
 20176e0:	1080028b 	ldhu	r2,10(r2)
 20176e4:	10bfffcc 	andi	r2,r2,65535
 20176e8:	e0fff40b 	ldhu	r3,-48(fp)
 20176ec:	18bfec2e 	bgeu	r3,r2,20176a0 <__alt_mem_mem_0+0xfcff76a0>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == NULL) {
 20176f0:	e0bff517 	ldw	r2,-44(fp)
 20176f4:	1000021e 	bne	r2,zero,2017700 <dhcp_parse_reply+0xe0>
    return ERR_BUF;
 20176f8:	00bfff84 	movi	r2,-2
 20176fc:	0001ed06 	br	2017eb4 <dhcp_parse_reply+0x894>
  }
  offset = options_idx;
 2017700:	e0bff40b 	ldhu	r2,-48(fp)
 2017704:	e0bff30d 	sth	r2,-52(fp)
  offset_max = options_idx_max;
 2017708:	e0bff48b 	ldhu	r2,-46(fp)
 201770c:	e0bff38d 	sth	r2,-50(fp)
  options = (u8_t*)q->payload;
 2017710:	e0bff517 	ldw	r2,-44(fp)
 2017714:	10800117 	ldw	r2,4(r2)
 2017718:	e0bff215 	stw	r2,-56(fp)
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
 201771c:	0001a906 	br	2017dc4 <dhcp_parse_reply+0x7a4>
    u8_t op = options[offset];
 2017720:	e0bff30b 	ldhu	r2,-52(fp)
 2017724:	e0fff217 	ldw	r3,-56(fp)
 2017728:	1885883a 	add	r2,r3,r2
 201772c:	10800003 	ldbu	r2,0(r2)
 2017730:	e0bffa85 	stb	r2,-22(fp)
    u8_t len;
    u8_t decode_len = 0;
 2017734:	e03ff845 	stb	zero,-31(fp)
    int decode_idx = -1;
 2017738:	00bfffc4 	movi	r2,-1
 201773c:	e0bff915 	stw	r2,-28(fp)
    u16_t val_offset = offset + 2;
 2017740:	e0bff30b 	ldhu	r2,-52(fp)
 2017744:	10800084 	addi	r2,r2,2
 2017748:	e0bffa0d 	sth	r2,-24(fp)
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
 201774c:	e0bff30b 	ldhu	r2,-52(fp)
 2017750:	10c00044 	addi	r3,r2,1
 2017754:	e0bff517 	ldw	r2,-44(fp)
 2017758:	1080028b 	ldhu	r2,10(r2)
 201775c:	10bfffcc 	andi	r2,r2,65535
 2017760:	1880070e 	bge	r3,r2,2017780 <dhcp_parse_reply+0x160>
      len = options[offset + 1];
 2017764:	e0bff30b 	ldhu	r2,-52(fp)
 2017768:	10800044 	addi	r2,r2,1
 201776c:	e0fff217 	ldw	r3,-56(fp)
 2017770:	1885883a 	add	r2,r3,r2
 2017774:	10800003 	ldbu	r2,0(r2)
 2017778:	e0bff805 	stb	r2,-32(fp)
 201777c:	00000a06 	br	20177a8 <dhcp_parse_reply+0x188>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
 2017780:	e0bff517 	ldw	r2,-44(fp)
 2017784:	10800017 	ldw	r2,0(r2)
 2017788:	10000526 	beq	r2,zero,20177a0 <dhcp_parse_reply+0x180>
 201778c:	e0bff517 	ldw	r2,-44(fp)
 2017790:	10800017 	ldw	r2,0(r2)
 2017794:	10800117 	ldw	r2,4(r2)
 2017798:	10800003 	ldbu	r2,0(r2)
 201779c:	00000106 	br	20177a4 <dhcp_parse_reply+0x184>
 20177a0:	0005883a 	mov	r2,zero
 20177a4:	e0bff805 	stb	r2,-32(fp)
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
 20177a8:	e0bff803 	ldbu	r2,-32(fp)
 20177ac:	e0bff845 	stb	r2,-31(fp)
    switch(op) {
 20177b0:	e0bffa83 	ldbu	r2,-22(fp)
 20177b4:	10c00f28 	cmpgeui	r3,r2,60
 20177b8:	1800e41e 	bne	r3,zero,2017b4c <dhcp_parse_reply+0x52c>
 20177bc:	100690ba 	slli	r3,r2,2
 20177c0:	00808074 	movhi	r2,513
 20177c4:	109df504 	addi	r2,r2,30676
 20177c8:	1885883a 	add	r2,r3,r2
 20177cc:	10800017 	ldw	r2,0(r2)
 20177d0:	1000683a 	jmp	r2
 20177d4:	020178c4 	movi	r8,1507
 20177d8:	020178e0 	cmpeqi	r8,zero,1507
 20177dc:	02017b4c 	andi	r8,zero,1517
 20177e0:	0201791c 	xori	r8,zero,1508
 20177e4:	02017b4c 	andi	r8,zero,1517
 20177e8:	02017b4c 	andi	r8,zero,1517
 20177ec:	02017960 	cmpeqi	r8,zero,1509
 20177f0:	02017b4c 	andi	r8,zero,1517
 20177f4:	02017b4c 	andi	r8,zero,1517
 20177f8:	02017b4c 	andi	r8,zero,1517
 20177fc:	02017b4c 	andi	r8,zero,1517
 2017800:	02017b4c 	andi	r8,zero,1517
 2017804:	02017b4c 	andi	r8,zero,1517
 2017808:	02017b4c 	andi	r8,zero,1517
 201780c:	02017b4c 	andi	r8,zero,1517
 2017810:	02017b4c 	andi	r8,zero,1517
 2017814:	02017b4c 	andi	r8,zero,1517
 2017818:	02017b4c 	andi	r8,zero,1517
 201781c:	02017b4c 	andi	r8,zero,1517
 2017820:	02017b4c 	andi	r8,zero,1517
 2017824:	02017b4c 	andi	r8,zero,1517
 2017828:	02017b4c 	andi	r8,zero,1517
 201782c:	02017b4c 	andi	r8,zero,1517
 2017830:	02017b4c 	andi	r8,zero,1517
 2017834:	02017b4c 	andi	r8,zero,1517
 2017838:	02017b4c 	andi	r8,zero,1517
 201783c:	02017b4c 	andi	r8,zero,1517
 2017840:	02017b4c 	andi	r8,zero,1517
 2017844:	02017b4c 	andi	r8,zero,1517
 2017848:	02017b4c 	andi	r8,zero,1517
 201784c:	02017b4c 	andi	r8,zero,1517
 2017850:	02017b4c 	andi	r8,zero,1517
 2017854:	02017b4c 	andi	r8,zero,1517
 2017858:	02017b4c 	andi	r8,zero,1517
 201785c:	02017b4c 	andi	r8,zero,1517
 2017860:	02017b4c 	andi	r8,zero,1517
 2017864:	02017b4c 	andi	r8,zero,1517
 2017868:	02017b4c 	andi	r8,zero,1517
 201786c:	02017b4c 	andi	r8,zero,1517
 2017870:	02017b4c 	andi	r8,zero,1517
 2017874:	02017b4c 	andi	r8,zero,1517
 2017878:	02017b4c 	andi	r8,zero,1517
 201787c:	02017b4c 	andi	r8,zero,1517
 2017880:	02017b4c 	andi	r8,zero,1517
 2017884:	02017b4c 	andi	r8,zero,1517
 2017888:	02017b4c 	andi	r8,zero,1517
 201788c:	02017b4c 	andi	r8,zero,1517
 2017890:	02017b4c 	andi	r8,zero,1517
 2017894:	02017b4c 	andi	r8,zero,1517
 2017898:	02017b4c 	andi	r8,zero,1517
 201789c:	02017b4c 	andi	r8,zero,1517
 20178a0:	020179e8 	cmpgeui	r8,zero,1511
 20178a4:	02017a24 	muli	r8,zero,1512
 20178a8:	02017a5c 	xori	r8,zero,1513
 20178ac:	02017a98 	cmpnei	r8,zero,1514
 20178b0:	02017b4c 	andi	r8,zero,1517
 20178b4:	02017b4c 	andi	r8,zero,1517
 20178b8:	02017b4c 	andi	r8,zero,1517
 20178bc:	02017ad4 	movui	r8,1515
 20178c0:	02017b10 	cmplti	r8,zero,1516
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
 20178c4:	e03ff805 	stb	zero,-32(fp)
 20178c8:	e0bff803 	ldbu	r2,-32(fp)
 20178cc:	e0bff845 	stb	r2,-31(fp)
        /* will be increased below */
        offset--;
 20178d0:	e0bff30b 	ldhu	r2,-52(fp)
 20178d4:	10bfffc4 	addi	r2,r2,-1
 20178d8:	e0bff30d 	sth	r2,-52(fp)
        break;
 20178dc:	00009d06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 20178e0:	e0bff803 	ldbu	r2,-32(fp)
 20178e4:	10800120 	cmpeqi	r2,r2,4
 20178e8:	1000091e 	bne	r2,zero,2017910 <dhcp_parse_reply+0x2f0>
 20178ec:	01c08134 	movhi	r7,516
 20178f0:	39c4d204 	addi	r7,r7,4936
 20178f4:	01816204 	movi	r6,1416
 20178f8:	01408134 	movhi	r5,516
 20178fc:	2944fc04 	addi	r5,r5,5104
 2017900:	01008134 	movhi	r4,516
 2017904:	2104dc04 	addi	r4,r4,4976
 2017908:	2000bb00 	call	2000bb0 <printf>
 201790c:	003fff06 	br	201790c <__alt_mem_mem_0+0xfcff790c>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
 2017910:	00800184 	movi	r2,6
 2017914:	e0bff915 	stw	r2,-28(fp)
        break;
 2017918:	00008e06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
 201791c:	00800104 	movi	r2,4
 2017920:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 2017924:	e0fff803 	ldbu	r3,-32(fp)
 2017928:	e0bff843 	ldbu	r2,-31(fp)
 201792c:	1880092e 	bgeu	r3,r2,2017954 <dhcp_parse_reply+0x334>
 2017930:	01c08134 	movhi	r7,516
 2017934:	39c4d204 	addi	r7,r7,4936
 2017938:	01816344 	movi	r6,1421
 201793c:	01408134 	movhi	r5,516
 2017940:	2944ff04 	addi	r5,r5,5116
 2017944:	01008134 	movhi	r4,516
 2017948:	2104dc04 	addi	r4,r4,4976
 201794c:	2000bb00 	call	2000bb0 <printf>
 2017950:	003fff06 	br	2017950 <__alt_mem_mem_0+0xfcff7950>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
 2017954:	008001c4 	movi	r2,7
 2017958:	e0bff915 	stw	r2,-28(fp)
        break;
 201795c:	00007d06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
 2017960:	e0bff803 	ldbu	r2,-32(fp)
 2017964:	108000cc 	andi	r2,r2,3
 2017968:	10803fcc 	andi	r2,r2,255
 201796c:	10000926 	beq	r2,zero,2017994 <dhcp_parse_reply+0x374>
 2017970:	01c08134 	movhi	r7,516
 2017974:	39c4d204 	addi	r7,r7,4936
 2017978:	01816484 	movi	r6,1426
 201797c:	01408134 	movhi	r5,516
 2017980:	29450404 	addi	r5,r5,5136
 2017984:	01008134 	movhi	r4,516
 2017988:	2104dc04 	addi	r4,r4,4976
 201798c:	2000bb00 	call	2000bb0 <printf>
 2017990:	003fff06 	br	2017990 <__alt_mem_mem_0+0xfcff7990>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
 2017994:	e0bff803 	ldbu	r2,-32(fp)
 2017998:	10c03fcc 	andi	r3,r2,255
 201799c:	18c00270 	cmpltui	r3,r3,9
 20179a0:	1800011e 	bne	r3,zero,20179a8 <dhcp_parse_reply+0x388>
 20179a4:	00800204 	movi	r2,8
 20179a8:	e0bff845 	stb	r2,-31(fp)
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
 20179ac:	e0fff803 	ldbu	r3,-32(fp)
 20179b0:	e0bff843 	ldbu	r2,-31(fp)
 20179b4:	1880092e 	bgeu	r3,r2,20179dc <dhcp_parse_reply+0x3bc>
 20179b8:	01c08134 	movhi	r7,516
 20179bc:	39c4d204 	addi	r7,r7,4936
 20179c0:	01816544 	movi	r6,1429
 20179c4:	01408134 	movhi	r5,516
 20179c8:	2944ff04 	addi	r5,r5,5116
 20179cc:	01008134 	movhi	r4,516
 20179d0:	2104dc04 	addi	r4,r4,4976
 20179d4:	2000bb00 	call	2000bb0 <printf>
 20179d8:	003fff06 	br	20179d8 <__alt_mem_mem_0+0xfcff79d8>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
 20179dc:	00800204 	movi	r2,8
 20179e0:	e0bff915 	stw	r2,-28(fp)
        break;
 20179e4:	00005b06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 20179e8:	e0bff803 	ldbu	r2,-32(fp)
 20179ec:	10800120 	cmpeqi	r2,r2,4
 20179f0:	1000091e 	bne	r2,zero,2017a18 <dhcp_parse_reply+0x3f8>
 20179f4:	01c08134 	movhi	r7,516
 20179f8:	39c4d204 	addi	r7,r7,4936
 20179fc:	01816644 	movi	r6,1433
 2017a00:	01408134 	movhi	r5,516
 2017a04:	2944fc04 	addi	r5,r5,5104
 2017a08:	01008134 	movhi	r4,516
 2017a0c:	2104dc04 	addi	r4,r4,4976
 2017a10:	2000bb00 	call	2000bb0 <printf>
 2017a14:	003fff06 	br	2017a14 <__alt_mem_mem_0+0xfcff7a14>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
 2017a18:	008000c4 	movi	r2,3
 2017a1c:	e0bff915 	stw	r2,-28(fp)
        break;
 2017a20:	00004c06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 2017a24:	e0bff803 	ldbu	r2,-32(fp)
 2017a28:	10800060 	cmpeqi	r2,r2,1
 2017a2c:	1000091e 	bne	r2,zero,2017a54 <dhcp_parse_reply+0x434>
 2017a30:	01c08134 	movhi	r7,516
 2017a34:	39c4d204 	addi	r7,r7,4936
 2017a38:	01816744 	movi	r6,1437
 2017a3c:	01408134 	movhi	r5,516
 2017a40:	29450804 	addi	r5,r5,5152
 2017a44:	01008134 	movhi	r4,516
 2017a48:	2104dc04 	addi	r4,r4,4976
 2017a4c:	2000bb00 	call	2000bb0 <printf>
 2017a50:	003fff06 	br	2017a50 <__alt_mem_mem_0+0xfcff7a50>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
 2017a54:	e03ff915 	stw	zero,-28(fp)
        break;
 2017a58:	00003e06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
 2017a5c:	e0bff803 	ldbu	r2,-32(fp)
 2017a60:	10800060 	cmpeqi	r2,r2,1
 2017a64:	1000091e 	bne	r2,zero,2017a8c <dhcp_parse_reply+0x46c>
 2017a68:	01c08134 	movhi	r7,516
 2017a6c:	39c4d204 	addi	r7,r7,4936
 2017a70:	01816844 	movi	r6,1441
 2017a74:	01408134 	movhi	r5,516
 2017a78:	29450804 	addi	r5,r5,5152
 2017a7c:	01008134 	movhi	r4,516
 2017a80:	2104dc04 	addi	r4,r4,4976
 2017a84:	2000bb00 	call	2000bb0 <printf>
 2017a88:	003fff06 	br	2017a88 <__alt_mem_mem_0+0xfcff7a88>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
 2017a8c:	00800044 	movi	r2,1
 2017a90:	e0bff915 	stw	r2,-28(fp)
        break;
 2017a94:	00002f06 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017a98:	e0bff803 	ldbu	r2,-32(fp)
 2017a9c:	10800120 	cmpeqi	r2,r2,4
 2017aa0:	1000091e 	bne	r2,zero,2017ac8 <dhcp_parse_reply+0x4a8>
 2017aa4:	01c08134 	movhi	r7,516
 2017aa8:	39c4d204 	addi	r7,r7,4936
 2017aac:	01816944 	movi	r6,1445
 2017ab0:	01408134 	movhi	r5,516
 2017ab4:	2944fc04 	addi	r5,r5,5104
 2017ab8:	01008134 	movhi	r4,516
 2017abc:	2104dc04 	addi	r4,r4,4976
 2017ac0:	2000bb00 	call	2000bb0 <printf>
 2017ac4:	003fff06 	br	2017ac4 <__alt_mem_mem_0+0xfcff7ac4>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
 2017ac8:	00800084 	movi	r2,2
 2017acc:	e0bff915 	stw	r2,-28(fp)
        break;
 2017ad0:	00002006 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017ad4:	e0bff803 	ldbu	r2,-32(fp)
 2017ad8:	10800120 	cmpeqi	r2,r2,4
 2017adc:	1000091e 	bne	r2,zero,2017b04 <dhcp_parse_reply+0x4e4>
 2017ae0:	01c08134 	movhi	r7,516
 2017ae4:	39c4d204 	addi	r7,r7,4936
 2017ae8:	01816a44 	movi	r6,1449
 2017aec:	01408134 	movhi	r5,516
 2017af0:	2944fc04 	addi	r5,r5,5104
 2017af4:	01008134 	movhi	r4,516
 2017af8:	2104dc04 	addi	r4,r4,4976
 2017afc:	2000bb00 	call	2000bb0 <printf>
 2017b00:	003fff06 	br	2017b00 <__alt_mem_mem_0+0xfcff7b00>
        decode_idx = DHCP_OPTION_IDX_T1;
 2017b04:	00800104 	movi	r2,4
 2017b08:	e0bff915 	stw	r2,-28(fp)
        break;
 2017b0c:	00001106 	br	2017b54 <dhcp_parse_reply+0x534>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
 2017b10:	e0bff803 	ldbu	r2,-32(fp)
 2017b14:	10800120 	cmpeqi	r2,r2,4
 2017b18:	1000091e 	bne	r2,zero,2017b40 <dhcp_parse_reply+0x520>
 2017b1c:	01c08134 	movhi	r7,516
 2017b20:	39c4d204 	addi	r7,r7,4936
 2017b24:	01816b44 	movi	r6,1453
 2017b28:	01408134 	movhi	r5,516
 2017b2c:	2944fc04 	addi	r5,r5,5104
 2017b30:	01008134 	movhi	r4,516
 2017b34:	2104dc04 	addi	r4,r4,4976
 2017b38:	2000bb00 	call	2000bb0 <printf>
 2017b3c:	003fff06 	br	2017b3c <__alt_mem_mem_0+0xfcff7b3c>
        decode_idx = DHCP_OPTION_IDX_T2;
 2017b40:	00800144 	movi	r2,5
 2017b44:	e0bff915 	stw	r2,-28(fp)
        break;
 2017b48:	00000206 	br	2017b54 <dhcp_parse_reply+0x534>
      default:
        decode_len = 0;
 2017b4c:	e03ff845 	stb	zero,-31(fp)
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
 2017b50:	0001883a 	nop
    }
    offset += len + 2;
 2017b54:	e0fff803 	ldbu	r3,-32(fp)
 2017b58:	e0bff30b 	ldhu	r2,-52(fp)
 2017b5c:	1885883a 	add	r2,r3,r2
 2017b60:	10800084 	addi	r2,r2,2
 2017b64:	e0bff30d 	sth	r2,-52(fp)
    if (decode_len > 0) {
 2017b68:	e0bff843 	ldbu	r2,-31(fp)
 2017b6c:	10007b26 	beq	r2,zero,2017d5c <dhcp_parse_reply+0x73c>
      u32_t value = 0;
 2017b70:	e03ffd15 	stw	zero,-12(fp)
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
 2017b74:	008085b4 	movhi	r2,534
 2017b78:	1088aa04 	addi	r2,r2,8872
 2017b7c:	e0fff917 	ldw	r3,-28(fp)
 2017b80:	10c5883a 	add	r2,r2,r3
 2017b84:	10800003 	ldbu	r2,0(r2)
 2017b88:	10803fcc 	andi	r2,r2,255
 2017b8c:	1000731e 	bne	r2,zero,2017d5c <dhcp_parse_reply+0x73c>
        copy_len = LWIP_MIN(decode_len, 4);
 2017b90:	e0bff843 	ldbu	r2,-31(fp)
 2017b94:	10800128 	cmpgeui	r2,r2,4
 2017b98:	1000021e 	bne	r2,zero,2017ba4 <dhcp_parse_reply+0x584>
 2017b9c:	e0bff843 	ldbu	r2,-31(fp)
 2017ba0:	00000106 	br	2017ba8 <dhcp_parse_reply+0x588>
 2017ba4:	00800104 	movi	r2,4
 2017ba8:	e0bffb0d 	sth	r2,-20(fp)
        pbuf_copy_partial(q, &value, copy_len, val_offset);
 2017bac:	e0fffb0b 	ldhu	r3,-20(fp)
 2017bb0:	e13ffa0b 	ldhu	r4,-24(fp)
 2017bb4:	e0bffd04 	addi	r2,fp,-12
 2017bb8:	200f883a 	mov	r7,r4
 2017bbc:	180d883a 	mov	r6,r3
 2017bc0:	100b883a 	mov	r5,r2
 2017bc4:	e13ff517 	ldw	r4,-44(fp)
 2017bc8:	201b16c0 	call	201b16c <pbuf_copy_partial>
        if (decode_len > 4) {
 2017bcc:	e0bff843 	ldbu	r2,-31(fp)
 2017bd0:	10800170 	cmpltui	r2,r2,5
 2017bd4:	1000311e 	bne	r2,zero,2017c9c <dhcp_parse_reply+0x67c>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
 2017bd8:	e0bff843 	ldbu	r2,-31(fp)
 2017bdc:	108000cc 	andi	r2,r2,3
 2017be0:	10803fcc 	andi	r2,r2,255
 2017be4:	10000926 	beq	r2,zero,2017c0c <dhcp_parse_reply+0x5ec>
 2017be8:	01c08134 	movhi	r7,516
 2017bec:	39c4d204 	addi	r7,r7,4936
 2017bf0:	01817004 	movi	r6,1472
 2017bf4:	01408134 	movhi	r5,516
 2017bf8:	29450b04 	addi	r5,r5,5164
 2017bfc:	01008134 	movhi	r4,516
 2017c00:	2104dc04 	addi	r4,r4,4976
 2017c04:	2000bb00 	call	2000bb0 <printf>
 2017c08:	003fff06 	br	2017c08 <__alt_mem_mem_0+0xfcff7c08>
          dhcp_got_option(dhcp, decode_idx);
 2017c0c:	008085b4 	movhi	r2,534
 2017c10:	1088aa04 	addi	r2,r2,8872
 2017c14:	e0fff917 	ldw	r3,-28(fp)
 2017c18:	10c5883a 	add	r2,r2,r3
 2017c1c:	00c00044 	movi	r3,1
 2017c20:	10c00005 	stb	r3,0(r2)
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
 2017c24:	e0bffd17 	ldw	r2,-12(fp)
 2017c28:	1006d63a 	srli	r3,r2,24
 2017c2c:	e0bffd17 	ldw	r2,-12(fp)
 2017c30:	1004d23a 	srli	r2,r2,8
 2017c34:	10bfc00c 	andi	r2,r2,65280
 2017c38:	1886b03a 	or	r3,r3,r2
 2017c3c:	e0bffd17 	ldw	r2,-12(fp)
 2017c40:	10bfc00c 	andi	r2,r2,65280
 2017c44:	1004923a 	slli	r2,r2,8
 2017c48:	1886b03a 	or	r3,r3,r2
 2017c4c:	e0bffd17 	ldw	r2,-12(fp)
 2017c50:	1004963a 	slli	r2,r2,24
 2017c54:	1888b03a 	or	r4,r3,r2
 2017c58:	008085b4 	movhi	r2,534
 2017c5c:	1088ad04 	addi	r2,r2,8884
 2017c60:	e0fff917 	ldw	r3,-28(fp)
 2017c64:	18c7883a 	add	r3,r3,r3
 2017c68:	18c7883a 	add	r3,r3,r3
 2017c6c:	10c5883a 	add	r2,r2,r3
 2017c70:	11000015 	stw	r4,0(r2)
          decode_len -= 4;
 2017c74:	e0bff843 	ldbu	r2,-31(fp)
 2017c78:	10bfff04 	addi	r2,r2,-4
 2017c7c:	e0bff845 	stb	r2,-31(fp)
          val_offset += 4;
 2017c80:	e0bffa0b 	ldhu	r2,-24(fp)
 2017c84:	10800104 	addi	r2,r2,4
 2017c88:	e0bffa0d 	sth	r2,-24(fp)
          decode_idx++;
 2017c8c:	e0bff917 	ldw	r2,-28(fp)
 2017c90:	10800044 	addi	r2,r2,1
 2017c94:	e0bff915 	stw	r2,-28(fp)
          goto decode_next;
 2017c98:	003fb606 	br	2017b74 <__alt_mem_mem_0+0xfcff7b74>
        } else if (decode_len == 4) {
 2017c9c:	e0bff843 	ldbu	r2,-31(fp)
 2017ca0:	10800118 	cmpnei	r2,r2,4
 2017ca4:	10000f1e 	bne	r2,zero,2017ce4 <dhcp_parse_reply+0x6c4>
          value = ntohl(value);
 2017ca8:	e0bffd17 	ldw	r2,-12(fp)
 2017cac:	1006d63a 	srli	r3,r2,24
 2017cb0:	e0bffd17 	ldw	r2,-12(fp)
 2017cb4:	1004d23a 	srli	r2,r2,8
 2017cb8:	10bfc00c 	andi	r2,r2,65280
 2017cbc:	1886b03a 	or	r3,r3,r2
 2017cc0:	e0bffd17 	ldw	r2,-12(fp)
 2017cc4:	10bfc00c 	andi	r2,r2,65280
 2017cc8:	1004923a 	slli	r2,r2,8
 2017ccc:	1886b03a 	or	r3,r3,r2
 2017cd0:	e0bffd17 	ldw	r2,-12(fp)
 2017cd4:	1004963a 	slli	r2,r2,24
 2017cd8:	1884b03a 	or	r2,r3,r2
 2017cdc:	e0bffd15 	stw	r2,-12(fp)
 2017ce0:	00001006 	br	2017d24 <dhcp_parse_reply+0x704>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
 2017ce4:	e0bff843 	ldbu	r2,-31(fp)
 2017ce8:	10800060 	cmpeqi	r2,r2,1
 2017cec:	1000091e 	bne	r2,zero,2017d14 <dhcp_parse_reply+0x6f4>
 2017cf0:	01c08134 	movhi	r7,516
 2017cf4:	39c4d204 	addi	r7,r7,4936
 2017cf8:	01817284 	movi	r6,1482
 2017cfc:	01408134 	movhi	r5,516
 2017d00:	29451004 	addi	r5,r5,5184
 2017d04:	01008134 	movhi	r4,516
 2017d08:	2104dc04 	addi	r4,r4,4976
 2017d0c:	2000bb00 	call	2000bb0 <printf>
 2017d10:	003fff06 	br	2017d10 <__alt_mem_mem_0+0xfcff7d10>
          value = ((u8_t*)&value)[0];
 2017d14:	e0bffd04 	addi	r2,fp,-12
 2017d18:	10800003 	ldbu	r2,0(r2)
 2017d1c:	10803fcc 	andi	r2,r2,255
 2017d20:	e0bffd15 	stw	r2,-12(fp)
        }
        dhcp_got_option(dhcp, decode_idx);
 2017d24:	008085b4 	movhi	r2,534
 2017d28:	1088aa04 	addi	r2,r2,8872
 2017d2c:	e0fff917 	ldw	r3,-28(fp)
 2017d30:	10c5883a 	add	r2,r2,r3
 2017d34:	00c00044 	movi	r3,1
 2017d38:	10c00005 	stb	r3,0(r2)
        dhcp_set_option_value(dhcp, decode_idx, value);
 2017d3c:	e13ffd17 	ldw	r4,-12(fp)
 2017d40:	008085b4 	movhi	r2,534
 2017d44:	1088ad04 	addi	r2,r2,8884
 2017d48:	e0fff917 	ldw	r3,-28(fp)
 2017d4c:	18c7883a 	add	r3,r3,r3
 2017d50:	18c7883a 	add	r3,r3,r3
 2017d54:	10c5883a 	add	r2,r2,r3
 2017d58:	11000015 	stw	r4,0(r2)
      }
    }
    if (offset >= q->len) {
 2017d5c:	e0bff517 	ldw	r2,-44(fp)
 2017d60:	1080028b 	ldhu	r2,10(r2)
 2017d64:	10bfffcc 	andi	r2,r2,65535
 2017d68:	e0fff30b 	ldhu	r3,-52(fp)
 2017d6c:	18801536 	bltu	r3,r2,2017dc4 <dhcp_parse_reply+0x7a4>
      offset -= q->len;
 2017d70:	e0bff517 	ldw	r2,-44(fp)
 2017d74:	1080028b 	ldhu	r2,10(r2)
 2017d78:	e0fff30b 	ldhu	r3,-52(fp)
 2017d7c:	1885c83a 	sub	r2,r3,r2
 2017d80:	e0bff30d 	sth	r2,-52(fp)
      offset_max -= q->len;
 2017d84:	e0bff517 	ldw	r2,-44(fp)
 2017d88:	1080028b 	ldhu	r2,10(r2)
 2017d8c:	e0fff38b 	ldhu	r3,-50(fp)
 2017d90:	1885c83a 	sub	r2,r3,r2
 2017d94:	e0bff38d 	sth	r2,-50(fp)
      if ((offset < offset_max) && offset_max) {
 2017d98:	e0fff30b 	ldhu	r3,-52(fp)
 2017d9c:	e0bff38b 	ldhu	r2,-50(fp)
 2017da0:	1880142e 	bgeu	r3,r2,2017df4 <dhcp_parse_reply+0x7d4>
 2017da4:	e0bff38b 	ldhu	r2,-50(fp)
 2017da8:	10001226 	beq	r2,zero,2017df4 <dhcp_parse_reply+0x7d4>
        q = q->next;
 2017dac:	e0bff517 	ldw	r2,-44(fp)
 2017db0:	10800017 	ldw	r2,0(r2)
 2017db4:	e0bff515 	stw	r2,-44(fp)
        LWIP_ASSERT("next pbuf was null", q);
        options = (u8_t*)q->payload;
 2017db8:	e0bff517 	ldw	r2,-44(fp)
 2017dbc:	10800117 	ldw	r2,4(r2)
 2017dc0:	e0bff215 	stw	r2,-56(fp)
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
 2017dc4:	e0bff517 	ldw	r2,-44(fp)
 2017dc8:	10000a26 	beq	r2,zero,2017df4 <dhcp_parse_reply+0x7d4>
 2017dcc:	e0bff30b 	ldhu	r2,-52(fp)
 2017dd0:	e0fff217 	ldw	r3,-56(fp)
 2017dd4:	1885883a 	add	r2,r3,r2
 2017dd8:	10800003 	ldbu	r2,0(r2)
 2017ddc:	10803fcc 	andi	r2,r2,255
 2017de0:	10803fe0 	cmpeqi	r2,r2,255
 2017de4:	1000031e 	bne	r2,zero,2017df4 <dhcp_parse_reply+0x7d4>
 2017de8:	e0fff30b 	ldhu	r3,-52(fp)
 2017dec:	e0bff38b 	ldhu	r2,-50(fp)
 2017df0:	18be4b36 	bltu	r3,r2,2017720 <__alt_mem_mem_0+0xfcff7720>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
 2017df4:	008085b4 	movhi	r2,534
 2017df8:	1088aa04 	addi	r2,r2,8872
 2017dfc:	10800003 	ldbu	r2,0(r2)
 2017e00:	10803fcc 	andi	r2,r2,255
 2017e04:	10001a26 	beq	r2,zero,2017e70 <dhcp_parse_reply+0x850>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 2017e08:	008085b4 	movhi	r2,534
 2017e0c:	1088ad04 	addi	r2,r2,8884
 2017e10:	10800017 	ldw	r2,0(r2)
 2017e14:	e0bffc15 	stw	r2,-16(fp)
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
 2017e18:	008085b4 	movhi	r2,534
 2017e1c:	1088aa04 	addi	r2,r2,8872
 2017e20:	10000005 	stb	zero,0(r2)
    if (overload == DHCP_OVERLOAD_FILE) {
 2017e24:	e0bffc17 	ldw	r2,-16(fp)
 2017e28:	10800058 	cmpnei	r2,r2,1
 2017e2c:	1000031e 	bne	r2,zero,2017e3c <dhcp_parse_reply+0x81c>
      parse_file_as_options = 1;
 2017e30:	00800044 	movi	r2,1
 2017e34:	e0bff615 	stw	r2,-40(fp)
 2017e38:	00000d06 	br	2017e70 <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
 2017e3c:	e0bffc17 	ldw	r2,-16(fp)
 2017e40:	10800098 	cmpnei	r2,r2,2
 2017e44:	1000031e 	bne	r2,zero,2017e54 <dhcp_parse_reply+0x834>
      parse_sname_as_options = 1;
 2017e48:	00800044 	movi	r2,1
 2017e4c:	e0bff715 	stw	r2,-36(fp)
 2017e50:	00000706 	br	2017e70 <dhcp_parse_reply+0x850>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
 2017e54:	e0bffc17 	ldw	r2,-16(fp)
 2017e58:	108000d8 	cmpnei	r2,r2,3
 2017e5c:	1000041e 	bne	r2,zero,2017e70 <dhcp_parse_reply+0x850>
      parse_sname_as_options = 1;
 2017e60:	00800044 	movi	r2,1
 2017e64:	e0bff715 	stw	r2,-36(fp)
      parse_file_as_options = 1;
 2017e68:	00800044 	movi	r2,1
 2017e6c:	e0bff615 	stw	r2,-40(fp)
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
 2017e70:	e0bff617 	ldw	r2,-40(fp)
 2017e74:	10000626 	beq	r2,zero,2017e90 <dhcp_parse_reply+0x870>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
 2017e78:	e03ff615 	stw	zero,-40(fp)
    options_idx = DHCP_FILE_OFS;
 2017e7c:	00801b04 	movi	r2,108
 2017e80:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
 2017e84:	00803b04 	movi	r2,236
 2017e88:	e0bff48d 	sth	r2,-46(fp)
    goto again;
 2017e8c:	003e0106 	br	2017694 <__alt_mem_mem_0+0xfcff7694>
  } else if (parse_sname_as_options) {
 2017e90:	e0bff717 	ldw	r2,-36(fp)
 2017e94:	10000626 	beq	r2,zero,2017eb0 <dhcp_parse_reply+0x890>
    parse_sname_as_options = 0;
 2017e98:	e03ff715 	stw	zero,-36(fp)
    options_idx = DHCP_SNAME_OFS;
 2017e9c:	00800b04 	movi	r2,44
 2017ea0:	e0bff40d 	sth	r2,-48(fp)
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
 2017ea4:	00801b04 	movi	r2,108
 2017ea8:	e0bff48d 	sth	r2,-46(fp)
    goto again;
 2017eac:	003df906 	br	2017694 <__alt_mem_mem_0+0xfcff7694>
  }
  return ERR_OK;
 2017eb0:	0005883a 	mov	r2,zero
}
 2017eb4:	e037883a 	mov	sp,fp
 2017eb8:	dfc00117 	ldw	ra,4(sp)
 2017ebc:	df000017 	ldw	fp,0(sp)
 2017ec0:	dec00204 	addi	sp,sp,8
 2017ec4:	f800283a 	ret

02017ec8 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
 2017ec8:	defff404 	addi	sp,sp,-48
 2017ecc:	dfc00b15 	stw	ra,44(sp)
 2017ed0:	df000a15 	stw	fp,40(sp)
 2017ed4:	df000a04 	addi	fp,sp,40
 2017ed8:	e13ffb15 	stw	r4,-20(fp)
 2017edc:	e17ffc15 	stw	r5,-16(fp)
 2017ee0:	e1bffd15 	stw	r6,-12(fp)
 2017ee4:	e1fffe15 	stw	r7,-8(fp)
 2017ee8:	e0800217 	ldw	r2,8(fp)
 2017eec:	e0bfff0d 	sth	r2,-4(fp)
  struct netif *netif = (struct netif *)arg;
 2017ef0:	e0bffb17 	ldw	r2,-20(fp)
 2017ef4:	e0bff715 	stw	r2,-36(fp)
  struct dhcp *dhcp = netif->dhcp;
 2017ef8:	e0bff717 	ldw	r2,-36(fp)
 2017efc:	10800a17 	ldw	r2,40(r2)
 2017f00:	e0bff815 	stw	r2,-32(fp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
 2017f04:	e0bffd17 	ldw	r2,-12(fp)
 2017f08:	10800117 	ldw	r2,4(r2)
 2017f0c:	e0bff915 	stw	r2,-28(fp)
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
 2017f10:	e0bffd17 	ldw	r2,-12(fp)
 2017f14:	1080028b 	ldhu	r2,10(r2)
 2017f18:	10bfffcc 	andi	r2,r2,65535
 2017f1c:	10800b28 	cmpgeui	r2,r2,44
 2017f20:	1000aa26 	beq	r2,zero,20181cc <dhcp_recv+0x304>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
 2017f24:	e0bff917 	ldw	r2,-28(fp)
 2017f28:	10800003 	ldbu	r2,0(r2)
 2017f2c:	10803fcc 	andi	r2,r2,255
 2017f30:	108000a0 	cmpeqi	r2,r2,2
 2017f34:	1000a726 	beq	r2,zero,20181d4 <dhcp_recv+0x30c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 2017f38:	e03ff605 	stb	zero,-40(fp)
 2017f3c:	00001006 	br	2017f80 <dhcp_recv+0xb8>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
 2017f40:	e0bff603 	ldbu	r2,-40(fp)
 2017f44:	e0fff717 	ldw	r3,-36(fp)
 2017f48:	1885883a 	add	r2,r3,r2
 2017f4c:	10800cc4 	addi	r2,r2,51
 2017f50:	11000003 	ldbu	r4,0(r2)
 2017f54:	e0bff603 	ldbu	r2,-40(fp)
 2017f58:	e0fff917 	ldw	r3,-28(fp)
 2017f5c:	1885883a 	add	r2,r3,r2
 2017f60:	10800704 	addi	r2,r2,28
 2017f64:	10800003 	ldbu	r2,0(r2)
 2017f68:	20c03fcc 	andi	r3,r4,255
 2017f6c:	10803fcc 	andi	r2,r2,255
 2017f70:	18809a1e 	bne	r3,r2,20181dc <dhcp_recv+0x314>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
 2017f74:	e0bff603 	ldbu	r2,-40(fp)
 2017f78:	10800044 	addi	r2,r2,1
 2017f7c:	e0bff605 	stb	r2,-40(fp)
 2017f80:	e0bff717 	ldw	r2,-36(fp)
 2017f84:	10800c83 	ldbu	r2,50(r2)
 2017f88:	10803fcc 	andi	r2,r2,255
 2017f8c:	e0fff603 	ldbu	r3,-40(fp)
 2017f90:	18bfeb36 	bltu	r3,r2,2017f40 <__alt_mem_mem_0+0xfcff7f40>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
 2017f94:	e0bff917 	ldw	r2,-28(fp)
 2017f98:	10c00103 	ldbu	r3,4(r2)
 2017f9c:	11000143 	ldbu	r4,5(r2)
 2017fa0:	2008923a 	slli	r4,r4,8
 2017fa4:	20c6b03a 	or	r3,r4,r3
 2017fa8:	11000183 	ldbu	r4,6(r2)
 2017fac:	2008943a 	slli	r4,r4,16
 2017fb0:	20c6b03a 	or	r3,r4,r3
 2017fb4:	108001c3 	ldbu	r2,7(r2)
 2017fb8:	1004963a 	slli	r2,r2,24
 2017fbc:	10c4b03a 	or	r2,r2,r3
 2017fc0:	1006d63a 	srli	r3,r2,24
 2017fc4:	e0bff917 	ldw	r2,-28(fp)
 2017fc8:	11000103 	ldbu	r4,4(r2)
 2017fcc:	11400143 	ldbu	r5,5(r2)
 2017fd0:	280a923a 	slli	r5,r5,8
 2017fd4:	2908b03a 	or	r4,r5,r4
 2017fd8:	11400183 	ldbu	r5,6(r2)
 2017fdc:	280a943a 	slli	r5,r5,16
 2017fe0:	2908b03a 	or	r4,r5,r4
 2017fe4:	108001c3 	ldbu	r2,7(r2)
 2017fe8:	1004963a 	slli	r2,r2,24
 2017fec:	1104b03a 	or	r2,r2,r4
 2017ff0:	1004d23a 	srli	r2,r2,8
 2017ff4:	10bfc00c 	andi	r2,r2,65280
 2017ff8:	1886b03a 	or	r3,r3,r2
 2017ffc:	e0bff917 	ldw	r2,-28(fp)
 2018000:	11000103 	ldbu	r4,4(r2)
 2018004:	11400143 	ldbu	r5,5(r2)
 2018008:	280a923a 	slli	r5,r5,8
 201800c:	2908b03a 	or	r4,r5,r4
 2018010:	11400183 	ldbu	r5,6(r2)
 2018014:	280a943a 	slli	r5,r5,16
 2018018:	2908b03a 	or	r4,r5,r4
 201801c:	108001c3 	ldbu	r2,7(r2)
 2018020:	1004963a 	slli	r2,r2,24
 2018024:	1104b03a 	or	r2,r2,r4
 2018028:	10bfc00c 	andi	r2,r2,65280
 201802c:	1004923a 	slli	r2,r2,8
 2018030:	1886b03a 	or	r3,r3,r2
 2018034:	e0bff917 	ldw	r2,-28(fp)
 2018038:	11000103 	ldbu	r4,4(r2)
 201803c:	11400143 	ldbu	r5,5(r2)
 2018040:	280a923a 	slli	r5,r5,8
 2018044:	2908b03a 	or	r4,r5,r4
 2018048:	11400183 	ldbu	r5,6(r2)
 201804c:	280a943a 	slli	r5,r5,16
 2018050:	2908b03a 	or	r4,r5,r4
 2018054:	108001c3 	ldbu	r2,7(r2)
 2018058:	1004963a 	slli	r2,r2,24
 201805c:	1104b03a 	or	r2,r2,r4
 2018060:	1004963a 	slli	r2,r2,24
 2018064:	1886b03a 	or	r3,r3,r2
 2018068:	e0bff817 	ldw	r2,-32(fp)
 201806c:	10800017 	ldw	r2,0(r2)
 2018070:	18805c1e 	bne	r3,r2,20181e4 <dhcp_recv+0x31c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
 2018074:	e17ffd17 	ldw	r5,-12(fp)
 2018078:	e13ff817 	ldw	r4,-32(fp)
 201807c:	20176200 	call	2017620 <dhcp_parse_reply>
 2018080:	10803fcc 	andi	r2,r2,255
 2018084:	1080201c 	xori	r2,r2,128
 2018088:	10bfe004 	addi	r2,r2,-128
 201808c:	1000571e 	bne	r2,zero,20181ec <dhcp_recv+0x324>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
 2018090:	008085b4 	movhi	r2,534
 2018094:	1088aa04 	addi	r2,r2,8872
 2018098:	10800043 	ldbu	r2,1(r2)
 201809c:	10803fcc 	andi	r2,r2,255
 20180a0:	10005426 	beq	r2,zero,20181f4 <dhcp_recv+0x32c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
 20180a4:	008085b4 	movhi	r2,534
 20180a8:	1088ad04 	addi	r2,r2,8884
 20180ac:	10800117 	ldw	r2,4(r2)
 20180b0:	e0bffa05 	stb	r2,-24(fp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
 20180b4:	e0bffa03 	ldbu	r2,-24(fp)
 20180b8:	10800158 	cmpnei	r2,r2,5
 20180bc:	10001c1e 	bne	r2,zero,2018130 <dhcp_recv+0x268>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
 20180c0:	e0bff817 	ldw	r2,-32(fp)
 20180c4:	10800303 	ldbu	r2,12(r2)
 20180c8:	10803fcc 	andi	r2,r2,255
 20180cc:	10800058 	cmpnei	r2,r2,1
 20180d0:	1000051e 	bne	r2,zero,20180e8 <dhcp_recv+0x220>
      dhcp_handle_ack(netif);
 20180d4:	e13ff717 	ldw	r4,-36(fp)
 20180d8:	2015e640 	call	2015e64 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
 20180dc:	e13ff717 	ldw	r4,-36(fp)
 20180e0:	20156880 	call	2015688 <dhcp_check>
 20180e4:	00004406 	br	20181f8 <dhcp_recv+0x330>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
 20180e8:	e0bff817 	ldw	r2,-32(fp)
 20180ec:	10800303 	ldbu	r2,12(r2)
 20180f0:	10803fcc 	andi	r2,r2,255
 20180f4:	108000e0 	cmpeqi	r2,r2,3
 20180f8:	10000a1e 	bne	r2,zero,2018124 <dhcp_recv+0x25c>
 20180fc:	e0bff817 	ldw	r2,-32(fp)
 2018100:	10800303 	ldbu	r2,12(r2)
 2018104:	10803fcc 	andi	r2,r2,255
 2018108:	10800120 	cmpeqi	r2,r2,4
 201810c:	1000051e 	bne	r2,zero,2018124 <dhcp_recv+0x25c>
 2018110:	e0bff817 	ldw	r2,-32(fp)
 2018114:	10800303 	ldbu	r2,12(r2)
 2018118:	10803fcc 	andi	r2,r2,255
 201811c:	10800158 	cmpnei	r2,r2,5
 2018120:	1000351e 	bne	r2,zero,20181f8 <dhcp_recv+0x330>
      dhcp_bind(netif);
 2018124:	e13ff717 	ldw	r4,-36(fp)
 2018128:	20168fc0 	call	20168fc <dhcp_bind>
 201812c:	00003206 	br	20181f8 <dhcp_recv+0x330>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 2018130:	e0bffa03 	ldbu	r2,-24(fp)
 2018134:	10800198 	cmpnei	r2,r2,6
 2018138:	1000171e 	bne	r2,zero,2018198 <dhcp_recv+0x2d0>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 201813c:	e0bff817 	ldw	r2,-32(fp)
 2018140:	10800303 	ldbu	r2,12(r2)
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
 2018144:	10803fcc 	andi	r2,r2,255
 2018148:	108000e0 	cmpeqi	r2,r2,3
 201814c:	10000f1e 	bne	r2,zero,201818c <dhcp_recv+0x2c4>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 2018150:	e0bff817 	ldw	r2,-32(fp)
 2018154:	10800303 	ldbu	r2,12(r2)
 2018158:	10803fcc 	andi	r2,r2,255
 201815c:	10800060 	cmpeqi	r2,r2,1
 2018160:	10000a1e 	bne	r2,zero,201818c <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
 2018164:	e0bff817 	ldw	r2,-32(fp)
 2018168:	10800303 	ldbu	r2,12(r2)
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
 201816c:	10803fcc 	andi	r2,r2,255
 2018170:	10800120 	cmpeqi	r2,r2,4
 2018174:	1000051e 	bne	r2,zero,201818c <dhcp_recv+0x2c4>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
 2018178:	e0bff817 	ldw	r2,-32(fp)
 201817c:	10800303 	ldbu	r2,12(r2)
 2018180:	10803fcc 	andi	r2,r2,255
 2018184:	10800158 	cmpnei	r2,r2,5
 2018188:	1000031e 	bne	r2,zero,2018198 <dhcp_recv+0x2d0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
 201818c:	e13ff717 	ldw	r4,-36(fp)
 2018190:	20156340 	call	2015634 <dhcp_handle_nak>
 2018194:	00001806 	br	20181f8 <dhcp_recv+0x330>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
 2018198:	e0bffa03 	ldbu	r2,-24(fp)
 201819c:	10800098 	cmpnei	r2,r2,2
 20181a0:	1000151e 	bne	r2,zero,20181f8 <dhcp_recv+0x330>
 20181a4:	e0bff817 	ldw	r2,-32(fp)
 20181a8:	10800303 	ldbu	r2,12(r2)
 20181ac:	10803fcc 	andi	r2,r2,255
 20181b0:	10800198 	cmpnei	r2,r2,6
 20181b4:	1000101e 	bne	r2,zero,20181f8 <dhcp_recv+0x330>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
 20181b8:	e0bff817 	ldw	r2,-32(fp)
 20181bc:	1000068d 	sth	zero,26(r2)
    /* remember offered lease */
    dhcp_handle_offer(netif);
 20181c0:	e13ff717 	ldw	r4,-36(fp)
 20181c4:	20157280 	call	2015728 <dhcp_handle_offer>
 20181c8:	00000b06 	br	20181f8 <dhcp_recv+0x330>

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
 20181cc:	0001883a 	nop
 20181d0:	00000906 	br	20181f8 <dhcp_recv+0x330>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
 20181d4:	0001883a 	nop
 20181d8:	00000706 	br	20181f8 <dhcp_recv+0x330>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
 20181dc:	0001883a 	nop
 20181e0:	00000506 	br	20181f8 <dhcp_recv+0x330>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
 20181e4:	0001883a 	nop
 20181e8:	00000306 	br	20181f8 <dhcp_recv+0x330>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
 20181ec:	0001883a 	nop
 20181f0:	00000106 	br	20181f8 <dhcp_recv+0x330>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
 20181f4:	0001883a 	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
 20181f8:	e0bff817 	ldw	r2,-32(fp)
 20181fc:	10000215 	stw	zero,8(r2)
  pbuf_free(p);
 2018200:	e13ffd17 	ldw	r4,-12(fp)
 2018204:	201ab680 	call	201ab68 <pbuf_free>
}
 2018208:	0001883a 	nop
 201820c:	e037883a 	mov	sp,fp
 2018210:	dfc00117 	ldw	ra,4(sp)
 2018214:	df000017 	ldw	fp,0(sp)
 2018218:	dec00204 	addi	sp,sp,8
 201821c:	f800283a 	ret

02018220 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
 2018220:	defffa04 	addi	sp,sp,-24
 2018224:	dfc00515 	stw	ra,20(sp)
 2018228:	df000415 	stw	fp,16(sp)
 201822c:	df000404 	addi	fp,sp,16
 2018230:	e13ffd15 	stw	r4,-12(fp)
 2018234:	e17ffe15 	stw	r5,-8(fp)
 2018238:	3005883a 	mov	r2,r6
 201823c:	e0bfff05 	stb	r2,-4(fp)
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
 2018240:	e0bffd17 	ldw	r2,-12(fp)
 2018244:	1000091e 	bne	r2,zero,201826c <dhcp_create_msg+0x4c>
 2018248:	01c08134 	movhi	r7,516
 201824c:	39c4d204 	addi	r7,r7,4936
 2018250:	0181a244 	movi	r6,1673
 2018254:	01408134 	movhi	r5,516
 2018258:	29451504 	addi	r5,r5,5204
 201825c:	01008134 	movhi	r4,516
 2018260:	2104dc04 	addi	r4,r4,4976
 2018264:	2000bb00 	call	2000bb0 <printf>
 2018268:	003fff06 	br	2018268 <__alt_mem_mem_0+0xfcff8268>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
 201826c:	e0bffe17 	ldw	r2,-8(fp)
 2018270:	1000091e 	bne	r2,zero,2018298 <dhcp_create_msg+0x78>
 2018274:	01c08134 	movhi	r7,516
 2018278:	39c4d204 	addi	r7,r7,4936
 201827c:	0181a284 	movi	r6,1674
 2018280:	01408134 	movhi	r5,516
 2018284:	29451d04 	addi	r5,r5,5236
 2018288:	01008134 	movhi	r4,516
 201828c:	2104dc04 	addi	r4,r4,4976
 2018290:	2000bb00 	call	2000bb0 <printf>
 2018294:	003fff06 	br	2018294 <__alt_mem_mem_0+0xfcff8294>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
 2018298:	000d883a 	mov	r6,zero
 201829c:	01404d04 	movi	r5,308
 20182a0:	0009883a 	mov	r4,zero
 20182a4:	201a3ac0 	call	201a3ac <pbuf_alloc>
 20182a8:	1007883a 	mov	r3,r2
 20182ac:	e0bffe17 	ldw	r2,-8(fp)
 20182b0:	10c00415 	stw	r3,16(r2)
  if (dhcp->p_out == NULL) {
 20182b4:	e0bffe17 	ldw	r2,-8(fp)
 20182b8:	10800417 	ldw	r2,16(r2)
 20182bc:	1000021e 	bne	r2,zero,20182c8 <dhcp_create_msg+0xa8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
 20182c0:	00bfffc4 	movi	r2,-1
 20182c4:	00013206 	br	2018790 <dhcp_create_msg+0x570>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
 20182c8:	e0bffe17 	ldw	r2,-8(fp)
 20182cc:	10800343 	ldbu	r2,13(r2)
 20182d0:	10803fcc 	andi	r2,r2,255
 20182d4:	1000031e 	bne	r2,zero,20182e4 <dhcp_create_msg+0xc4>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
 20182d8:	d0a00c17 	ldw	r2,-32720(gp)
 20182dc:	10800044 	addi	r2,r2,1
 20182e0:	d0a00c15 	stw	r2,-32720(gp)
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
 20182e4:	d0e00c17 	ldw	r3,-32720(gp)
 20182e8:	e0bffe17 	ldw	r2,-8(fp)
 20182ec:	10c00015 	stw	r3,0(r2)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
 20182f0:	e0bffe17 	ldw	r2,-8(fp)
 20182f4:	10800417 	ldw	r2,16(r2)
 20182f8:	10c00117 	ldw	r3,4(r2)
 20182fc:	e0bffe17 	ldw	r2,-8(fp)
 2018300:	10c00515 	stw	r3,20(r2)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
 2018304:	e0bffe17 	ldw	r2,-8(fp)
 2018308:	10800517 	ldw	r2,20(r2)
 201830c:	00c00044 	movi	r3,1
 2018310:	10c00005 	stb	r3,0(r2)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
 2018314:	e0bffe17 	ldw	r2,-8(fp)
 2018318:	10800517 	ldw	r2,20(r2)
 201831c:	00c00044 	movi	r3,1
 2018320:	10c00045 	stb	r3,1(r2)
  dhcp->msg_out->hlen = netif->hwaddr_len;
 2018324:	e0bffe17 	ldw	r2,-8(fp)
 2018328:	10800517 	ldw	r2,20(r2)
 201832c:	e0fffd17 	ldw	r3,-12(fp)
 2018330:	18c00c83 	ldbu	r3,50(r3)
 2018334:	10c00085 	stb	r3,2(r2)
  dhcp->msg_out->hops = 0;
 2018338:	e0bffe17 	ldw	r2,-8(fp)
 201833c:	10800517 	ldw	r2,20(r2)
 2018340:	100000c5 	stb	zero,3(r2)
  dhcp->msg_out->xid = htonl(dhcp->xid);
 2018344:	e0bffe17 	ldw	r2,-8(fp)
 2018348:	10800517 	ldw	r2,20(r2)
 201834c:	e0fffe17 	ldw	r3,-8(fp)
 2018350:	18c00017 	ldw	r3,0(r3)
 2018354:	1808d63a 	srli	r4,r3,24
 2018358:	e0fffe17 	ldw	r3,-8(fp)
 201835c:	18c00017 	ldw	r3,0(r3)
 2018360:	1806d23a 	srli	r3,r3,8
 2018364:	18ffc00c 	andi	r3,r3,65280
 2018368:	20c8b03a 	or	r4,r4,r3
 201836c:	e0fffe17 	ldw	r3,-8(fp)
 2018370:	18c00017 	ldw	r3,0(r3)
 2018374:	18ffc00c 	andi	r3,r3,65280
 2018378:	1806923a 	slli	r3,r3,8
 201837c:	20c8b03a 	or	r4,r4,r3
 2018380:	e0fffe17 	ldw	r3,-8(fp)
 2018384:	18c00017 	ldw	r3,0(r3)
 2018388:	1806963a 	slli	r3,r3,24
 201838c:	20c6b03a 	or	r3,r4,r3
 2018390:	19803fcc 	andi	r6,r3,255
 2018394:	11000103 	ldbu	r4,4(r2)
 2018398:	2008703a 	and	r4,r4,zero
 201839c:	200b883a 	mov	r5,r4
 20183a0:	3009883a 	mov	r4,r6
 20183a4:	2908b03a 	or	r4,r5,r4
 20183a8:	11000105 	stb	r4,4(r2)
 20183ac:	1808d23a 	srli	r4,r3,8
 20183b0:	21803fcc 	andi	r6,r4,255
 20183b4:	11000143 	ldbu	r4,5(r2)
 20183b8:	2008703a 	and	r4,r4,zero
 20183bc:	200b883a 	mov	r5,r4
 20183c0:	3009883a 	mov	r4,r6
 20183c4:	2908b03a 	or	r4,r5,r4
 20183c8:	11000145 	stb	r4,5(r2)
 20183cc:	1808d43a 	srli	r4,r3,16
 20183d0:	21803fcc 	andi	r6,r4,255
 20183d4:	11000183 	ldbu	r4,6(r2)
 20183d8:	2008703a 	and	r4,r4,zero
 20183dc:	200b883a 	mov	r5,r4
 20183e0:	3009883a 	mov	r4,r6
 20183e4:	2908b03a 	or	r4,r5,r4
 20183e8:	11000185 	stb	r4,6(r2)
 20183ec:	180ad63a 	srli	r5,r3,24
 20183f0:	10c001c3 	ldbu	r3,7(r2)
 20183f4:	1806703a 	and	r3,r3,zero
 20183f8:	1809883a 	mov	r4,r3
 20183fc:	2807883a 	mov	r3,r5
 2018400:	20c6b03a 	or	r3,r4,r3
 2018404:	10c001c5 	stb	r3,7(r2)
  dhcp->msg_out->secs = 0;
 2018408:	e0bffe17 	ldw	r2,-8(fp)
 201840c:	10800517 	ldw	r2,20(r2)
 2018410:	10c00203 	ldbu	r3,8(r2)
 2018414:	1806703a 	and	r3,r3,zero
 2018418:	10c00205 	stb	r3,8(r2)
 201841c:	10c00243 	ldbu	r3,9(r2)
 2018420:	1806703a 	and	r3,r3,zero
 2018424:	10c00245 	stb	r3,9(r2)
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
 2018428:	e0bffe17 	ldw	r2,-8(fp)
 201842c:	10800517 	ldw	r2,20(r2)
 2018430:	10c00283 	ldbu	r3,10(r2)
 2018434:	1806703a 	and	r3,r3,zero
 2018438:	10c00285 	stb	r3,10(r2)
 201843c:	10c002c3 	ldbu	r3,11(r2)
 2018440:	1806703a 	and	r3,r3,zero
 2018444:	10c002c5 	stb	r3,11(r2)
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
 2018448:	e0bffe17 	ldw	r2,-8(fp)
 201844c:	10800517 	ldw	r2,20(r2)
 2018450:	10c00303 	ldbu	r3,12(r2)
 2018454:	1806703a 	and	r3,r3,zero
 2018458:	10c00305 	stb	r3,12(r2)
 201845c:	10c00343 	ldbu	r3,13(r2)
 2018460:	1806703a 	and	r3,r3,zero
 2018464:	10c00345 	stb	r3,13(r2)
 2018468:	10c00383 	ldbu	r3,14(r2)
 201846c:	1806703a 	and	r3,r3,zero
 2018470:	10c00385 	stb	r3,14(r2)
 2018474:	10c003c3 	ldbu	r3,15(r2)
 2018478:	1806703a 	and	r3,r3,zero
 201847c:	10c003c5 	stb	r3,15(r2)
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
 2018480:	e0bfff03 	ldbu	r2,-4(fp)
 2018484:	10800220 	cmpeqi	r2,r2,8
 2018488:	1000101e 	bne	r2,zero,20184cc <dhcp_create_msg+0x2ac>
 201848c:	e0bfff03 	ldbu	r2,-4(fp)
 2018490:	10800120 	cmpeqi	r2,r2,4
 2018494:	10000d1e 	bne	r2,zero,20184cc <dhcp_create_msg+0x2ac>
 2018498:	e0bfff03 	ldbu	r2,-4(fp)
 201849c:	108000d8 	cmpnei	r2,r2,3
 20184a0:	10002c1e 	bne	r2,zero,2018554 <dhcp_create_msg+0x334>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
 20184a4:	e0bffe17 	ldw	r2,-8(fp)
 20184a8:	10800303 	ldbu	r2,12(r2)
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
 20184ac:	10803fcc 	andi	r2,r2,255
 20184b0:	10800160 	cmpeqi	r2,r2,5
 20184b4:	1000051e 	bne	r2,zero,20184cc <dhcp_create_msg+0x2ac>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
 20184b8:	e0bffe17 	ldw	r2,-8(fp)
 20184bc:	10800303 	ldbu	r2,12(r2)
 20184c0:	10803fcc 	andi	r2,r2,255
 20184c4:	10800118 	cmpnei	r2,r2,4
 20184c8:	1000221e 	bne	r2,zero,2018554 <dhcp_create_msg+0x334>
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
 20184cc:	e0bffe17 	ldw	r2,-8(fp)
 20184d0:	10800517 	ldw	r2,20(r2)
 20184d4:	e0fffd17 	ldw	r3,-12(fp)
 20184d8:	18c00117 	ldw	r3,4(r3)
 20184dc:	19803fcc 	andi	r6,r3,255
 20184e0:	11000303 	ldbu	r4,12(r2)
 20184e4:	2008703a 	and	r4,r4,zero
 20184e8:	200b883a 	mov	r5,r4
 20184ec:	3009883a 	mov	r4,r6
 20184f0:	2908b03a 	or	r4,r5,r4
 20184f4:	11000305 	stb	r4,12(r2)
 20184f8:	1808d23a 	srli	r4,r3,8
 20184fc:	21803fcc 	andi	r6,r4,255
 2018500:	11000343 	ldbu	r4,13(r2)
 2018504:	2008703a 	and	r4,r4,zero
 2018508:	200b883a 	mov	r5,r4
 201850c:	3009883a 	mov	r4,r6
 2018510:	2908b03a 	or	r4,r5,r4
 2018514:	11000345 	stb	r4,13(r2)
 2018518:	1808d43a 	srli	r4,r3,16
 201851c:	21803fcc 	andi	r6,r4,255
 2018520:	11000383 	ldbu	r4,14(r2)
 2018524:	2008703a 	and	r4,r4,zero
 2018528:	200b883a 	mov	r5,r4
 201852c:	3009883a 	mov	r4,r6
 2018530:	2908b03a 	or	r4,r5,r4
 2018534:	11000385 	stb	r4,14(r2)
 2018538:	180ad63a 	srli	r5,r3,24
 201853c:	10c003c3 	ldbu	r3,15(r2)
 2018540:	1806703a 	and	r3,r3,zero
 2018544:	1809883a 	mov	r4,r3
 2018548:	2807883a 	mov	r3,r5
 201854c:	20c6b03a 	or	r3,r4,r3
 2018550:	10c003c5 	stb	r3,15(r2)
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
 2018554:	e0bffe17 	ldw	r2,-8(fp)
 2018558:	10800517 	ldw	r2,20(r2)
 201855c:	10c00403 	ldbu	r3,16(r2)
 2018560:	1806703a 	and	r3,r3,zero
 2018564:	10c00405 	stb	r3,16(r2)
 2018568:	10c00443 	ldbu	r3,17(r2)
 201856c:	1806703a 	and	r3,r3,zero
 2018570:	10c00445 	stb	r3,17(r2)
 2018574:	10c00483 	ldbu	r3,18(r2)
 2018578:	1806703a 	and	r3,r3,zero
 201857c:	10c00485 	stb	r3,18(r2)
 2018580:	10c004c3 	ldbu	r3,19(r2)
 2018584:	1806703a 	and	r3,r3,zero
 2018588:	10c004c5 	stb	r3,19(r2)
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
 201858c:	e0bffe17 	ldw	r2,-8(fp)
 2018590:	10800517 	ldw	r2,20(r2)
 2018594:	10c00503 	ldbu	r3,20(r2)
 2018598:	1806703a 	and	r3,r3,zero
 201859c:	10c00505 	stb	r3,20(r2)
 20185a0:	10c00543 	ldbu	r3,21(r2)
 20185a4:	1806703a 	and	r3,r3,zero
 20185a8:	10c00545 	stb	r3,21(r2)
 20185ac:	10c00583 	ldbu	r3,22(r2)
 20185b0:	1806703a 	and	r3,r3,zero
 20185b4:	10c00585 	stb	r3,22(r2)
 20185b8:	10c005c3 	ldbu	r3,23(r2)
 20185bc:	1806703a 	and	r3,r3,zero
 20185c0:	10c005c5 	stb	r3,23(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
 20185c4:	e0bffe17 	ldw	r2,-8(fp)
 20185c8:	10800517 	ldw	r2,20(r2)
 20185cc:	10c00603 	ldbu	r3,24(r2)
 20185d0:	1806703a 	and	r3,r3,zero
 20185d4:	10c00605 	stb	r3,24(r2)
 20185d8:	10c00643 	ldbu	r3,25(r2)
 20185dc:	1806703a 	and	r3,r3,zero
 20185e0:	10c00645 	stb	r3,25(r2)
 20185e4:	10c00683 	ldbu	r3,26(r2)
 20185e8:	1806703a 	and	r3,r3,zero
 20185ec:	10c00685 	stb	r3,26(r2)
 20185f0:	10c006c3 	ldbu	r3,27(r2)
 20185f4:	1806703a 	and	r3,r3,zero
 20185f8:	10c006c5 	stb	r3,27(r2)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 20185fc:	e03ffc0d 	sth	zero,-16(fp)
 2018600:	00001606 	br	201865c <dhcp_create_msg+0x43c>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
 2018604:	e0bffe17 	ldw	r2,-8(fp)
 2018608:	11000517 	ldw	r4,20(r2)
 201860c:	e0fffc0b 	ldhu	r3,-16(fp)
 2018610:	e0bffd17 	ldw	r2,-12(fp)
 2018614:	10800c83 	ldbu	r2,50(r2)
 2018618:	10803fcc 	andi	r2,r2,255
 201861c:	10bfffcc 	andi	r2,r2,65535
 2018620:	e17ffc0b 	ldhu	r5,-16(fp)
 2018624:	2880062e 	bgeu	r5,r2,2018640 <dhcp_create_msg+0x420>
 2018628:	e0bffc0b 	ldhu	r2,-16(fp)
 201862c:	e17ffd17 	ldw	r5,-12(fp)
 2018630:	2885883a 	add	r2,r5,r2
 2018634:	10800cc4 	addi	r2,r2,51
 2018638:	10800003 	ldbu	r2,0(r2)
 201863c:	00000106 	br	2018644 <dhcp_create_msg+0x424>
 2018640:	0005883a 	mov	r2,zero
 2018644:	20c7883a 	add	r3,r4,r3
 2018648:	18c00704 	addi	r3,r3,28
 201864c:	18800005 	stb	r2,0(r3)
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
 2018650:	e0bffc0b 	ldhu	r2,-16(fp)
 2018654:	10800044 	addi	r2,r2,1
 2018658:	e0bffc0d 	sth	r2,-16(fp)
 201865c:	e0bffc0b 	ldhu	r2,-16(fp)
 2018660:	10800430 	cmpltui	r2,r2,16
 2018664:	103fe71e 	bne	r2,zero,2018604 <__alt_mem_mem_0+0xfcff8604>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 2018668:	e03ffc0d 	sth	zero,-16(fp)
 201866c:	00000906 	br	2018694 <dhcp_create_msg+0x474>
    dhcp->msg_out->sname[i] = 0;
 2018670:	e0bffe17 	ldw	r2,-8(fp)
 2018674:	10c00517 	ldw	r3,20(r2)
 2018678:	e0bffc0b 	ldhu	r2,-16(fp)
 201867c:	1885883a 	add	r2,r3,r2
 2018680:	10800b04 	addi	r2,r2,44
 2018684:	10000005 	stb	zero,0(r2)
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
 2018688:	e0bffc0b 	ldhu	r2,-16(fp)
 201868c:	10800044 	addi	r2,r2,1
 2018690:	e0bffc0d 	sth	r2,-16(fp)
 2018694:	e0bffc0b 	ldhu	r2,-16(fp)
 2018698:	10801030 	cmpltui	r2,r2,64
 201869c:	103ff41e 	bne	r2,zero,2018670 <__alt_mem_mem_0+0xfcff8670>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 20186a0:	e03ffc0d 	sth	zero,-16(fp)
 20186a4:	00000906 	br	20186cc <dhcp_create_msg+0x4ac>
    dhcp->msg_out->file[i] = 0;
 20186a8:	e0bffe17 	ldw	r2,-8(fp)
 20186ac:	10c00517 	ldw	r3,20(r2)
 20186b0:	e0bffc0b 	ldhu	r2,-16(fp)
 20186b4:	1885883a 	add	r2,r3,r2
 20186b8:	10801b04 	addi	r2,r2,108
 20186bc:	10000005 	stb	zero,0(r2)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
 20186c0:	e0bffc0b 	ldhu	r2,-16(fp)
 20186c4:	10800044 	addi	r2,r2,1
 20186c8:	e0bffc0d 	sth	r2,-16(fp)
 20186cc:	e0bffc0b 	ldhu	r2,-16(fp)
 20186d0:	10802030 	cmpltui	r2,r2,128
 20186d4:	103ff41e 	bne	r2,zero,20186a8 <__alt_mem_mem_0+0xfcff86a8>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
 20186d8:	e0bffe17 	ldw	r2,-8(fp)
 20186dc:	10800517 	ldw	r2,20(r2)
 20186e0:	10c03b03 	ldbu	r3,236(r2)
 20186e4:	1806703a 	and	r3,r3,zero
 20186e8:	18c018d4 	ori	r3,r3,99
 20186ec:	10c03b05 	stb	r3,236(r2)
 20186f0:	10c03b43 	ldbu	r3,237(r2)
 20186f4:	1806703a 	and	r3,r3,zero
 20186f8:	1809883a 	mov	r4,r3
 20186fc:	00ffe084 	movi	r3,-126
 2018700:	20c6b03a 	or	r3,r4,r3
 2018704:	10c03b45 	stb	r3,237(r2)
 2018708:	10c03b83 	ldbu	r3,238(r2)
 201870c:	1806703a 	and	r3,r3,zero
 2018710:	18c014d4 	ori	r3,r3,83
 2018714:	10c03b85 	stb	r3,238(r2)
 2018718:	10c03bc3 	ldbu	r3,239(r2)
 201871c:	1806703a 	and	r3,r3,zero
 2018720:	18c018d4 	ori	r3,r3,99
 2018724:	10c03bc5 	stb	r3,239(r2)
  dhcp->options_out_len = 0;
 2018728:	e0bffe17 	ldw	r2,-8(fp)
 201872c:	1000060d 	sth	zero,24(r2)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 2018730:	e03ffc0d 	sth	zero,-16(fp)
 2018734:	00000a06 	br	2018760 <dhcp_create_msg+0x540>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
 2018738:	e0bffe17 	ldw	r2,-8(fp)
 201873c:	10c00517 	ldw	r3,20(r2)
 2018740:	e0bffc0b 	ldhu	r2,-16(fp)
 2018744:	e13ffc0b 	ldhu	r4,-16(fp)
 2018748:	1885883a 	add	r2,r3,r2
 201874c:	10803c04 	addi	r2,r2,240
 2018750:	11000005 	stb	r4,0(r2)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
 2018754:	e0bffc0b 	ldhu	r2,-16(fp)
 2018758:	10800044 	addi	r2,r2,1
 201875c:	e0bffc0d 	sth	r2,-16(fp)
 2018760:	e0bffc0b 	ldhu	r2,-16(fp)
 2018764:	10801130 	cmpltui	r2,r2,68
 2018768:	103ff31e 	bne	r2,zero,2018738 <__alt_mem_mem_0+0xfcff8738>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
 201876c:	01800044 	movi	r6,1
 2018770:	01400d44 	movi	r5,53
 2018774:	e13ffe17 	ldw	r4,-8(fp)
 2018778:	20172a40 	call	20172a4 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
 201877c:	e0bfff03 	ldbu	r2,-4(fp)
 2018780:	100b883a 	mov	r5,r2
 2018784:	e13ffe17 	ldw	r4,-8(fp)
 2018788:	20173400 	call	2017340 <dhcp_option_byte>
  return ERR_OK;
 201878c:	0005883a 	mov	r2,zero
}
 2018790:	e037883a 	mov	sp,fp
 2018794:	dfc00117 	ldw	ra,4(sp)
 2018798:	df000017 	ldw	fp,0(sp)
 201879c:	dec00204 	addi	sp,sp,8
 20187a0:	f800283a 	ret

020187a4 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
 20187a4:	defffd04 	addi	sp,sp,-12
 20187a8:	dfc00215 	stw	ra,8(sp)
 20187ac:	df000115 	stw	fp,4(sp)
 20187b0:	df000104 	addi	fp,sp,4
 20187b4:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
 20187b8:	e0bfff17 	ldw	r2,-4(fp)
 20187bc:	1000091e 	bne	r2,zero,20187e4 <dhcp_delete_msg+0x40>
 20187c0:	01c08134 	movhi	r7,516
 20187c4:	39c4d204 	addi	r7,r7,4936
 20187c8:	0181b584 	movi	r6,1750
 20187cc:	01408134 	movhi	r5,516
 20187d0:	29452504 	addi	r5,r5,5268
 20187d4:	01008134 	movhi	r4,516
 20187d8:	2104dc04 	addi	r4,r4,4976
 20187dc:	2000bb00 	call	2000bb0 <printf>
 20187e0:	003fff06 	br	20187e0 <__alt_mem_mem_0+0xfcff87e0>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
 20187e4:	e0bfff17 	ldw	r2,-4(fp)
 20187e8:	10800417 	ldw	r2,16(r2)
 20187ec:	10000426 	beq	r2,zero,2018800 <dhcp_delete_msg+0x5c>
    pbuf_free(dhcp->p_out);
 20187f0:	e0bfff17 	ldw	r2,-4(fp)
 20187f4:	10800417 	ldw	r2,16(r2)
 20187f8:	1009883a 	mov	r4,r2
 20187fc:	201ab680 	call	201ab68 <pbuf_free>
  }
  dhcp->p_out = NULL;
 2018800:	e0bfff17 	ldw	r2,-4(fp)
 2018804:	10000415 	stw	zero,16(r2)
  dhcp->msg_out = NULL;
 2018808:	e0bfff17 	ldw	r2,-4(fp)
 201880c:	10000515 	stw	zero,20(r2)
}
 2018810:	0001883a 	nop
 2018814:	e037883a 	mov	sp,fp
 2018818:	dfc00117 	ldw	ra,4(sp)
 201881c:	df000017 	ldw	fp,0(sp)
 2018820:	dec00204 	addi	sp,sp,8
 2018824:	f800283a 	ret

02018828 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
 2018828:	defffd04 	addi	sp,sp,-12
 201882c:	dfc00215 	stw	ra,8(sp)
 2018830:	df000115 	stw	fp,4(sp)
 2018834:	df000104 	addi	fp,sp,4
 2018838:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
 201883c:	e0bfff17 	ldw	r2,-4(fp)
 2018840:	1000091e 	bne	r2,zero,2018868 <dhcp_option_trailer+0x40>
 2018844:	01c08134 	movhi	r7,516
 2018848:	39c4d204 	addi	r7,r7,4936
 201884c:	0181bac4 	movi	r6,1771
 2018850:	01408134 	movhi	r5,516
 2018854:	29452d04 	addi	r5,r5,5300
 2018858:	01008134 	movhi	r4,516
 201885c:	2104dc04 	addi	r4,r4,4976
 2018860:	2000bb00 	call	2000bb0 <printf>
 2018864:	003fff06 	br	2018864 <__alt_mem_mem_0+0xfcff8864>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
 2018868:	e0bfff17 	ldw	r2,-4(fp)
 201886c:	10c00517 	ldw	r3,20(r2)
 2018870:	e0bfff17 	ldw	r2,-4(fp)
 2018874:	1080060b 	ldhu	r2,24(r2)
 2018878:	11000044 	addi	r4,r2,1
 201887c:	200b883a 	mov	r5,r4
 2018880:	e13fff17 	ldw	r4,-4(fp)
 2018884:	2140060d 	sth	r5,24(r4)
 2018888:	10bfffcc 	andi	r2,r2,65535
 201888c:	1885883a 	add	r2,r3,r2
 2018890:	10803c04 	addi	r2,r2,240
 2018894:	00ffffc4 	movi	r3,-1
 2018898:	10c00005 	stb	r3,0(r2)
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 201889c:	00000c06 	br	20188d0 <dhcp_option_trailer+0xa8>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
 20188a0:	e0bfff17 	ldw	r2,-4(fp)
 20188a4:	10c00517 	ldw	r3,20(r2)
 20188a8:	e0bfff17 	ldw	r2,-4(fp)
 20188ac:	1080060b 	ldhu	r2,24(r2)
 20188b0:	11000044 	addi	r4,r2,1
 20188b4:	200b883a 	mov	r5,r4
 20188b8:	e13fff17 	ldw	r4,-4(fp)
 20188bc:	2140060d 	sth	r5,24(r4)
 20188c0:	10bfffcc 	andi	r2,r2,65535
 20188c4:	1885883a 	add	r2,r3,r2
 20188c8:	10803c04 	addi	r2,r2,240
 20188cc:	10000005 	stb	zero,0(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 20188d0:	e0bfff17 	ldw	r2,-4(fp)
 20188d4:	1080060b 	ldhu	r2,24(r2)
 20188d8:	10bfffcc 	andi	r2,r2,65535
 20188dc:	10801130 	cmpltui	r2,r2,68
 20188e0:	1000051e 	bne	r2,zero,20188f8 <dhcp_option_trailer+0xd0>
 20188e4:	e0bfff17 	ldw	r2,-4(fp)
 20188e8:	1080060b 	ldhu	r2,24(r2)
 20188ec:	10bfffcc 	andi	r2,r2,65535
 20188f0:	108000cc 	andi	r2,r2,3
 20188f4:	10000526 	beq	r2,zero,201890c <dhcp_option_trailer+0xe4>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
 20188f8:	e0bfff17 	ldw	r2,-4(fp)
 20188fc:	1080060b 	ldhu	r2,24(r2)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
 2018900:	10bfffcc 	andi	r2,r2,65535
 2018904:	10801130 	cmpltui	r2,r2,68
 2018908:	103fe51e 	bne	r2,zero,20188a0 <__alt_mem_mem_0+0xfcff88a0>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
 201890c:	0001883a 	nop
 2018910:	e037883a 	mov	sp,fp
 2018914:	dfc00117 	ldw	ra,4(sp)
 2018918:	df000017 	ldw	fp,0(sp)
 201891c:	dec00204 	addi	sp,sp,8
 2018920:	f800283a 	ret

02018924 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
 2018924:	defffc04 	addi	sp,sp,-16
 2018928:	df000315 	stw	fp,12(sp)
 201892c:	df000304 	addi	fp,sp,12
 2018930:	e13ffe15 	stw	r4,-8(fp)
 2018934:	e17fff15 	stw	r5,-4(fp)
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
 2018938:	e0bffe17 	ldw	r2,-8(fp)
 201893c:	e0bffd15 	stw	r2,-12(fp)

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 2018940:	e0bffe17 	ldw	r2,-8(fp)
 2018944:	10bfffe0 	cmpeqi	r2,r2,-1
 2018948:	1000021e 	bne	r2,zero,2018954 <ip4_addr_isbroadcast+0x30>
 201894c:	e0bffe17 	ldw	r2,-8(fp)
 2018950:	1000021e 	bne	r2,zero,201895c <ip4_addr_isbroadcast+0x38>
      (addr == IPADDR_ANY)) {
    return 1;
 2018954:	00800044 	movi	r2,1
 2018958:	00002106 	br	20189e0 <ip4_addr_isbroadcast+0xbc>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 201895c:	e0bfff17 	ldw	r2,-4(fp)
 2018960:	10800e43 	ldbu	r2,57(r2)
 2018964:	10803fcc 	andi	r2,r2,255
 2018968:	1080008c 	andi	r2,r2,2
 201896c:	1000021e 	bne	r2,zero,2018978 <ip4_addr_isbroadcast+0x54>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
 2018970:	0005883a 	mov	r2,zero
 2018974:	00001a06 	br	20189e0 <ip4_addr_isbroadcast+0xbc>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 2018978:	e0bfff17 	ldw	r2,-4(fp)
 201897c:	10c00117 	ldw	r3,4(r2)
 2018980:	e0bffe17 	ldw	r2,-8(fp)
 2018984:	1880021e 	bne	r3,r2,2018990 <ip4_addr_isbroadcast+0x6c>
    return 0;
 2018988:	0005883a 	mov	r2,zero
 201898c:	00001406 	br	20189e0 <ip4_addr_isbroadcast+0xbc>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 2018990:	e0fffd17 	ldw	r3,-12(fp)
 2018994:	e0bfff17 	ldw	r2,-4(fp)
 2018998:	10800117 	ldw	r2,4(r2)
 201899c:	1886f03a 	xor	r3,r3,r2
 20189a0:	e0bfff17 	ldw	r2,-4(fp)
 20189a4:	10800217 	ldw	r2,8(r2)
 20189a8:	1884703a 	and	r2,r3,r2
 20189ac:	10000b1e 	bne	r2,zero,20189dc <ip4_addr_isbroadcast+0xb8>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 20189b0:	e0bfff17 	ldw	r2,-4(fp)
 20189b4:	10800217 	ldw	r2,8(r2)
 20189b8:	0086303a 	nor	r3,zero,r2
 20189bc:	e0bffe17 	ldw	r2,-8(fp)
 20189c0:	1886703a 	and	r3,r3,r2
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
 20189c4:	e0bfff17 	ldw	r2,-4(fp)
 20189c8:	10800217 	ldw	r2,8(r2)
 20189cc:	0084303a 	nor	r2,zero,r2
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 20189d0:	1880021e 	bne	r3,r2,20189dc <ip4_addr_isbroadcast+0xb8>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
 20189d4:	00800044 	movi	r2,1
 20189d8:	00000106 	br	20189e0 <ip4_addr_isbroadcast+0xbc>
  } else {
    return 0;
 20189dc:	0005883a 	mov	r2,zero
  }
}
 20189e0:	e037883a 	mov	sp,fp
 20189e4:	df000017 	ldw	fp,0(sp)
 20189e8:	dec00104 	addi	sp,sp,4
 20189ec:	f800283a 	ret

020189f0 <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
 20189f0:	defffc04 	addi	sp,sp,-16
 20189f4:	df000315 	stw	fp,12(sp)
 20189f8:	df000304 	addi	fp,sp,12
 20189fc:	e13fff15 	stw	r4,-4(fp)
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
 2018a00:	e0bfff17 	ldw	r2,-4(fp)
 2018a04:	1006d63a 	srli	r3,r2,24
 2018a08:	e0bfff17 	ldw	r2,-4(fp)
 2018a0c:	1004d23a 	srli	r2,r2,8
 2018a10:	10bfc00c 	andi	r2,r2,65280
 2018a14:	1886b03a 	or	r3,r3,r2
 2018a18:	e0bfff17 	ldw	r2,-4(fp)
 2018a1c:	10bfc00c 	andi	r2,r2,65280
 2018a20:	1004923a 	slli	r2,r2,8
 2018a24:	1886b03a 	or	r3,r3,r2
 2018a28:	e0bfff17 	ldw	r2,-4(fp)
 2018a2c:	1004963a 	slli	r2,r2,24
 2018a30:	1884b03a 	or	r2,r3,r2
 2018a34:	e0bffe15 	stw	r2,-8(fp)

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 2018a38:	00a00034 	movhi	r2,32768
 2018a3c:	e0bffd15 	stw	r2,-12(fp)
 2018a40:	00000706 	br	2018a60 <ip4_addr_netmask_valid+0x70>
    if ((nm_hostorder & mask) == 0) {
 2018a44:	e0fffe17 	ldw	r3,-8(fp)
 2018a48:	e0bffd17 	ldw	r2,-12(fp)
 2018a4c:	1884703a 	and	r2,r3,r2
 2018a50:	10000626 	beq	r2,zero,2018a6c <ip4_addr_netmask_valid+0x7c>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 2018a54:	e0bffd17 	ldw	r2,-12(fp)
 2018a58:	1004d07a 	srli	r2,r2,1
 2018a5c:	e0bffd15 	stw	r2,-12(fp)
 2018a60:	e0bffd17 	ldw	r2,-12(fp)
 2018a64:	103ff71e 	bne	r2,zero,2018a44 <__alt_mem_mem_0+0xfcff8a44>
 2018a68:	00000b06 	br	2018a98 <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) == 0) {
      break;
 2018a6c:	0001883a 	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 2018a70:	00000906 	br	2018a98 <ip4_addr_netmask_valid+0xa8>
    if ((nm_hostorder & mask) != 0) {
 2018a74:	e0fffe17 	ldw	r3,-8(fp)
 2018a78:	e0bffd17 	ldw	r2,-12(fp)
 2018a7c:	1884703a 	and	r2,r3,r2
 2018a80:	10000226 	beq	r2,zero,2018a8c <ip4_addr_netmask_valid+0x9c>
      /* there is a one after the first zero -> invalid */
      return 0;
 2018a84:	0005883a 	mov	r2,zero
 2018a88:	00000606 	br	2018aa4 <ip4_addr_netmask_valid+0xb4>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 2018a8c:	e0bffd17 	ldw	r2,-12(fp)
 2018a90:	1004d07a 	srli	r2,r2,1
 2018a94:	e0bffd15 	stw	r2,-12(fp)
 2018a98:	e0bffd17 	ldw	r2,-12(fp)
 2018a9c:	103ff51e 	bne	r2,zero,2018a74 <__alt_mem_mem_0+0xfcff8a74>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
 2018aa0:	00800044 	movi	r2,1
}
 2018aa4:	e037883a 	mov	sp,fp
 2018aa8:	df000017 	ldw	fp,0(sp)
 2018aac:	dec00104 	addi	sp,sp,4
 2018ab0:	f800283a 	ret

02018ab4 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
 2018ab4:	defffc04 	addi	sp,sp,-16
 2018ab8:	dfc00315 	stw	ra,12(sp)
 2018abc:	df000215 	stw	fp,8(sp)
 2018ac0:	df000204 	addi	fp,sp,8
 2018ac4:	e13fff15 	stw	r4,-4(fp)
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
 2018ac8:	e17ffe04 	addi	r5,fp,-8
 2018acc:	e13fff17 	ldw	r4,-4(fp)
 2018ad0:	2018af80 	call	2018af8 <ipaddr_aton>
 2018ad4:	10000226 	beq	r2,zero,2018ae0 <ipaddr_addr+0x2c>
    return ip4_addr_get_u32(&val);
 2018ad8:	e0bffe17 	ldw	r2,-8(fp)
 2018adc:	00000106 	br	2018ae4 <ipaddr_addr+0x30>
  }
  return (IPADDR_NONE);
 2018ae0:	00bfffc4 	movi	r2,-1
}
 2018ae4:	e037883a 	mov	sp,fp
 2018ae8:	dfc00117 	ldw	ra,4(sp)
 2018aec:	df000017 	ldw	fp,0(sp)
 2018af0:	dec00204 	addi	sp,sp,8
 2018af4:	f800283a 	ret

02018af8 <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 2018af8:	defff604 	addi	sp,sp,-40
 2018afc:	df000915 	stw	fp,36(sp)
 2018b00:	df000904 	addi	fp,sp,36
 2018b04:	e13ffe15 	stw	r4,-8(fp)
 2018b08:	e17fff15 	stw	r5,-4(fp)
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 2018b0c:	e0bffa04 	addi	r2,fp,-24
 2018b10:	e0bff915 	stw	r2,-28(fp)

  c = *cp;
 2018b14:	e0bffe17 	ldw	r2,-8(fp)
 2018b18:	10800003 	ldbu	r2,0(r2)
 2018b1c:	e0bff845 	stb	r2,-31(fp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 2018b20:	e0bff843 	ldbu	r2,-31(fp)
 2018b24:	10803fcc 	andi	r2,r2,255
 2018b28:	10800c30 	cmpltui	r2,r2,48
 2018b2c:	1000041e 	bne	r2,zero,2018b40 <ipaddr_aton+0x48>
 2018b30:	e0bff843 	ldbu	r2,-31(fp)
 2018b34:	10803fcc 	andi	r2,r2,255
 2018b38:	10800eb0 	cmpltui	r2,r2,58
 2018b3c:	1000021e 	bne	r2,zero,2018b48 <ipaddr_aton+0x50>
      return (0);
 2018b40:	0005883a 	mov	r2,zero
 2018b44:	0000e606 	br	2018ee0 <ipaddr_aton+0x3e8>
    val = 0;
 2018b48:	e03ff715 	stw	zero,-36(fp)
    base = 10;
 2018b4c:	00800284 	movi	r2,10
 2018b50:	e0bff805 	stb	r2,-32(fp)
    if (c == '0') {
 2018b54:	e0bff847 	ldb	r2,-31(fp)
 2018b58:	10800c18 	cmpnei	r2,r2,48
 2018b5c:	1000171e 	bne	r2,zero,2018bbc <ipaddr_aton+0xc4>
      c = *++cp;
 2018b60:	e0bffe17 	ldw	r2,-8(fp)
 2018b64:	10800044 	addi	r2,r2,1
 2018b68:	e0bffe15 	stw	r2,-8(fp)
 2018b6c:	e0bffe17 	ldw	r2,-8(fp)
 2018b70:	10800003 	ldbu	r2,0(r2)
 2018b74:	e0bff845 	stb	r2,-31(fp)
      if (c == 'x' || c == 'X') {
 2018b78:	e0bff847 	ldb	r2,-31(fp)
 2018b7c:	10801e20 	cmpeqi	r2,r2,120
 2018b80:	1000031e 	bne	r2,zero,2018b90 <ipaddr_aton+0x98>
 2018b84:	e0bff847 	ldb	r2,-31(fp)
 2018b88:	10801618 	cmpnei	r2,r2,88
 2018b8c:	1000091e 	bne	r2,zero,2018bb4 <ipaddr_aton+0xbc>
        base = 16;
 2018b90:	00800404 	movi	r2,16
 2018b94:	e0bff805 	stb	r2,-32(fp)
        c = *++cp;
 2018b98:	e0bffe17 	ldw	r2,-8(fp)
 2018b9c:	10800044 	addi	r2,r2,1
 2018ba0:	e0bffe15 	stw	r2,-8(fp)
 2018ba4:	e0bffe17 	ldw	r2,-8(fp)
 2018ba8:	10800003 	ldbu	r2,0(r2)
 2018bac:	e0bff845 	stb	r2,-31(fp)
 2018bb0:	00000206 	br	2018bbc <ipaddr_aton+0xc4>
      } else
        base = 8;
 2018bb4:	00800204 	movi	r2,8
 2018bb8:	e0bff805 	stb	r2,-32(fp)
    }
    for (;;) {
      if (isdigit(c)) {
 2018bbc:	e0bff843 	ldbu	r2,-31(fp)
 2018bc0:	10803fcc 	andi	r2,r2,255
 2018bc4:	10800c30 	cmpltui	r2,r2,48
 2018bc8:	1000121e 	bne	r2,zero,2018c14 <ipaddr_aton+0x11c>
 2018bcc:	e0bff843 	ldbu	r2,-31(fp)
 2018bd0:	10803fcc 	andi	r2,r2,255
 2018bd4:	10800ea8 	cmpgeui	r2,r2,58
 2018bd8:	10000e1e 	bne	r2,zero,2018c14 <ipaddr_aton+0x11c>
        val = (val * base) + (int)(c - '0');
 2018bdc:	e0fff803 	ldbu	r3,-32(fp)
 2018be0:	e0bff717 	ldw	r2,-36(fp)
 2018be4:	1887383a 	mul	r3,r3,r2
 2018be8:	e0bff847 	ldb	r2,-31(fp)
 2018bec:	1885883a 	add	r2,r3,r2
 2018bf0:	10bff404 	addi	r2,r2,-48
 2018bf4:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 2018bf8:	e0bffe17 	ldw	r2,-8(fp)
 2018bfc:	10800044 	addi	r2,r2,1
 2018c00:	e0bffe15 	stw	r2,-8(fp)
 2018c04:	e0bffe17 	ldw	r2,-8(fp)
 2018c08:	10800003 	ldbu	r2,0(r2)
 2018c0c:	e0bff845 	stb	r2,-31(fp)
 2018c10:	00003306 	br	2018ce0 <ipaddr_aton+0x1e8>
      } else if (base == 16 && isxdigit(c)) {
 2018c14:	e0bff803 	ldbu	r2,-32(fp)
 2018c18:	10800418 	cmpnei	r2,r2,16
 2018c1c:	1000311e 	bne	r2,zero,2018ce4 <ipaddr_aton+0x1ec>
 2018c20:	e0bff843 	ldbu	r2,-31(fp)
 2018c24:	10803fcc 	andi	r2,r2,255
 2018c28:	10800c30 	cmpltui	r2,r2,48
 2018c2c:	1000041e 	bne	r2,zero,2018c40 <ipaddr_aton+0x148>
 2018c30:	e0bff843 	ldbu	r2,-31(fp)
 2018c34:	10803fcc 	andi	r2,r2,255
 2018c38:	10800eb0 	cmpltui	r2,r2,58
 2018c3c:	1000101e 	bne	r2,zero,2018c80 <ipaddr_aton+0x188>
 2018c40:	e0bff843 	ldbu	r2,-31(fp)
 2018c44:	10803fcc 	andi	r2,r2,255
 2018c48:	10801870 	cmpltui	r2,r2,97
 2018c4c:	1000041e 	bne	r2,zero,2018c60 <ipaddr_aton+0x168>
 2018c50:	e0bff843 	ldbu	r2,-31(fp)
 2018c54:	10803fcc 	andi	r2,r2,255
 2018c58:	108019f0 	cmpltui	r2,r2,103
 2018c5c:	1000081e 	bne	r2,zero,2018c80 <ipaddr_aton+0x188>
 2018c60:	e0bff843 	ldbu	r2,-31(fp)
 2018c64:	10803fcc 	andi	r2,r2,255
 2018c68:	10801070 	cmpltui	r2,r2,65
 2018c6c:	10001d1e 	bne	r2,zero,2018ce4 <ipaddr_aton+0x1ec>
 2018c70:	e0bff843 	ldbu	r2,-31(fp)
 2018c74:	10803fcc 	andi	r2,r2,255
 2018c78:	108011e8 	cmpgeui	r2,r2,71
 2018c7c:	1000191e 	bne	r2,zero,2018ce4 <ipaddr_aton+0x1ec>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 2018c80:	e0bff717 	ldw	r2,-36(fp)
 2018c84:	1006913a 	slli	r3,r2,4
 2018c88:	e0bff847 	ldb	r2,-31(fp)
 2018c8c:	11000284 	addi	r4,r2,10
 2018c90:	e0bff843 	ldbu	r2,-31(fp)
 2018c94:	10803fcc 	andi	r2,r2,255
 2018c98:	10801870 	cmpltui	r2,r2,97
 2018c9c:	1000061e 	bne	r2,zero,2018cb8 <ipaddr_aton+0x1c0>
 2018ca0:	e0bff843 	ldbu	r2,-31(fp)
 2018ca4:	10803fcc 	andi	r2,r2,255
 2018ca8:	10801ee8 	cmpgeui	r2,r2,123
 2018cac:	1000021e 	bne	r2,zero,2018cb8 <ipaddr_aton+0x1c0>
 2018cb0:	00801844 	movi	r2,97
 2018cb4:	00000106 	br	2018cbc <ipaddr_aton+0x1c4>
 2018cb8:	00801044 	movi	r2,65
 2018cbc:	2085c83a 	sub	r2,r4,r2
 2018cc0:	1884b03a 	or	r2,r3,r2
 2018cc4:	e0bff715 	stw	r2,-36(fp)
        c = *++cp;
 2018cc8:	e0bffe17 	ldw	r2,-8(fp)
 2018ccc:	10800044 	addi	r2,r2,1
 2018cd0:	e0bffe15 	stw	r2,-8(fp)
 2018cd4:	e0bffe17 	ldw	r2,-8(fp)
 2018cd8:	10800003 	ldbu	r2,0(r2)
 2018cdc:	e0bff845 	stb	r2,-31(fp)
      } else
        break;
    }
 2018ce0:	003fb606 	br	2018bbc <__alt_mem_mem_0+0xfcff8bbc>
    if (c == '.') {
 2018ce4:	e0bff847 	ldb	r2,-31(fp)
 2018ce8:	10800b98 	cmpnei	r2,r2,46
 2018cec:	1000121e 	bne	r2,zero,2018d38 <ipaddr_aton+0x240>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 2018cf0:	e0bffa04 	addi	r2,fp,-24
 2018cf4:	10800304 	addi	r2,r2,12
 2018cf8:	e0fff917 	ldw	r3,-28(fp)
 2018cfc:	18800236 	bltu	r3,r2,2018d08 <ipaddr_aton+0x210>
        return (0);
 2018d00:	0005883a 	mov	r2,zero
 2018d04:	00007606 	br	2018ee0 <ipaddr_aton+0x3e8>
      }
      *pp++ = val;
 2018d08:	e0bff917 	ldw	r2,-28(fp)
 2018d0c:	10c00104 	addi	r3,r2,4
 2018d10:	e0fff915 	stw	r3,-28(fp)
 2018d14:	e0fff717 	ldw	r3,-36(fp)
 2018d18:	10c00015 	stw	r3,0(r2)
      c = *++cp;
 2018d1c:	e0bffe17 	ldw	r2,-8(fp)
 2018d20:	10800044 	addi	r2,r2,1
 2018d24:	e0bffe15 	stw	r2,-8(fp)
 2018d28:	e0bffe17 	ldw	r2,-8(fp)
 2018d2c:	10800003 	ldbu	r2,0(r2)
 2018d30:	e0bff845 	stb	r2,-31(fp)
    } else
      break;
  }
 2018d34:	003f7a06 	br	2018b20 <__alt_mem_mem_0+0xfcff8b20>
        return (0);
      }
      *pp++ = val;
      c = *++cp;
    } else
      break;
 2018d38:	0001883a 	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 2018d3c:	e0bff847 	ldb	r2,-31(fp)
 2018d40:	10001426 	beq	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d44:	e0bff847 	ldb	r2,-31(fp)
 2018d48:	10800820 	cmpeqi	r2,r2,32
 2018d4c:	1000111e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d50:	e0bff847 	ldb	r2,-31(fp)
 2018d54:	10800320 	cmpeqi	r2,r2,12
 2018d58:	10000e1e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d5c:	e0bff847 	ldb	r2,-31(fp)
 2018d60:	108002a0 	cmpeqi	r2,r2,10
 2018d64:	10000b1e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d68:	e0bff847 	ldb	r2,-31(fp)
 2018d6c:	10800360 	cmpeqi	r2,r2,13
 2018d70:	1000081e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d74:	e0bff847 	ldb	r2,-31(fp)
 2018d78:	10800260 	cmpeqi	r2,r2,9
 2018d7c:	1000051e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
 2018d80:	e0bff847 	ldb	r2,-31(fp)
 2018d84:	108002e0 	cmpeqi	r2,r2,11
 2018d88:	1000021e 	bne	r2,zero,2018d94 <ipaddr_aton+0x29c>
    return (0);
 2018d8c:	0005883a 	mov	r2,zero
 2018d90:	00005306 	br	2018ee0 <ipaddr_aton+0x3e8>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 2018d94:	e0fff917 	ldw	r3,-28(fp)
 2018d98:	e0bffa04 	addi	r2,fp,-24
 2018d9c:	1885c83a 	sub	r2,r3,r2
 2018da0:	1005d0ba 	srai	r2,r2,2
 2018da4:	10800044 	addi	r2,r2,1
 2018da8:	10c00168 	cmpgeui	r3,r2,5
 2018dac:	1800371e 	bne	r3,zero,2018e8c <ipaddr_aton+0x394>
 2018db0:	100690ba 	slli	r3,r2,2
 2018db4:	008080b4 	movhi	r2,514
 2018db8:	10a37204 	addi	r2,r2,-29240
 2018dbc:	1885883a 	add	r2,r3,r2
 2018dc0:	10800017 	ldw	r2,0(r2)
 2018dc4:	1000683a 	jmp	r2
 2018dc8:	02018ddc 	xori	r8,zero,1591
 2018dcc:	02018e94 	movui	r8,1594
 2018dd0:	02018de4 	muli	r8,zero,1591
 2018dd4:	02018e10 	cmplti	r8,zero,1592
 2018dd8:	02018e48 	cmpgei	r8,zero,1593

  case 0:
    return (0);       /* initial nondigit */
 2018ddc:	0005883a 	mov	r2,zero
 2018de0:	00003f06 	br	2018ee0 <ipaddr_aton+0x3e8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 2018de4:	e0fff717 	ldw	r3,-36(fp)
 2018de8:	00804034 	movhi	r2,256
 2018dec:	18800236 	bltu	r3,r2,2018df8 <ipaddr_aton+0x300>
      return (0);
 2018df0:	0005883a 	mov	r2,zero
 2018df4:	00003a06 	br	2018ee0 <ipaddr_aton+0x3e8>
    }
    val |= parts[0] << 24;
 2018df8:	e0bffa17 	ldw	r2,-24(fp)
 2018dfc:	1004963a 	slli	r2,r2,24
 2018e00:	e0fff717 	ldw	r3,-36(fp)
 2018e04:	1884b03a 	or	r2,r3,r2
 2018e08:	e0bff715 	stw	r2,-36(fp)
    break;
 2018e0c:	00002206 	br	2018e98 <ipaddr_aton+0x3a0>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
 2018e10:	e0bff717 	ldw	r2,-36(fp)
 2018e14:	00ffffd4 	movui	r3,65535
 2018e18:	1880022e 	bgeu	r3,r2,2018e24 <ipaddr_aton+0x32c>
      return (0);
 2018e1c:	0005883a 	mov	r2,zero
 2018e20:	00002f06 	br	2018ee0 <ipaddr_aton+0x3e8>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
 2018e24:	e0bffa17 	ldw	r2,-24(fp)
 2018e28:	1006963a 	slli	r3,r2,24
 2018e2c:	e0bffb17 	ldw	r2,-20(fp)
 2018e30:	1004943a 	slli	r2,r2,16
 2018e34:	1884b03a 	or	r2,r3,r2
 2018e38:	e0fff717 	ldw	r3,-36(fp)
 2018e3c:	1884b03a 	or	r2,r3,r2
 2018e40:	e0bff715 	stw	r2,-36(fp)
    break;
 2018e44:	00001406 	br	2018e98 <ipaddr_aton+0x3a0>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
 2018e48:	e0bff717 	ldw	r2,-36(fp)
 2018e4c:	10804030 	cmpltui	r2,r2,256
 2018e50:	1000021e 	bne	r2,zero,2018e5c <ipaddr_aton+0x364>
      return (0);
 2018e54:	0005883a 	mov	r2,zero
 2018e58:	00002106 	br	2018ee0 <ipaddr_aton+0x3e8>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 2018e5c:	e0bffa17 	ldw	r2,-24(fp)
 2018e60:	1006963a 	slli	r3,r2,24
 2018e64:	e0bffb17 	ldw	r2,-20(fp)
 2018e68:	1004943a 	slli	r2,r2,16
 2018e6c:	1886b03a 	or	r3,r3,r2
 2018e70:	e0bffc17 	ldw	r2,-16(fp)
 2018e74:	1004923a 	slli	r2,r2,8
 2018e78:	1884b03a 	or	r2,r3,r2
 2018e7c:	e0fff717 	ldw	r3,-36(fp)
 2018e80:	1884b03a 	or	r2,r3,r2
 2018e84:	e0bff715 	stw	r2,-36(fp)
    break;
 2018e88:	00000306 	br	2018e98 <ipaddr_aton+0x3a0>
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
 2018e8c:	0001883a 	nop
 2018e90:	00000106 	br	2018e98 <ipaddr_aton+0x3a0>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
 2018e94:	0001883a 	nop
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
 2018e98:	e0bfff17 	ldw	r2,-4(fp)
 2018e9c:	10000f26 	beq	r2,zero,2018edc <ipaddr_aton+0x3e4>
    ip4_addr_set_u32(addr, htonl(val));
 2018ea0:	e0bff717 	ldw	r2,-36(fp)
 2018ea4:	1006d63a 	srli	r3,r2,24
 2018ea8:	e0bff717 	ldw	r2,-36(fp)
 2018eac:	1004d23a 	srli	r2,r2,8
 2018eb0:	10bfc00c 	andi	r2,r2,65280
 2018eb4:	1886b03a 	or	r3,r3,r2
 2018eb8:	e0bff717 	ldw	r2,-36(fp)
 2018ebc:	10bfc00c 	andi	r2,r2,65280
 2018ec0:	1004923a 	slli	r2,r2,8
 2018ec4:	1886b03a 	or	r3,r3,r2
 2018ec8:	e0bff717 	ldw	r2,-36(fp)
 2018ecc:	1004963a 	slli	r2,r2,24
 2018ed0:	1886b03a 	or	r3,r3,r2
 2018ed4:	e0bfff17 	ldw	r2,-4(fp)
 2018ed8:	10c00015 	stw	r3,0(r2)
  }
  return (1);
 2018edc:	00800044 	movi	r2,1
}
 2018ee0:	e037883a 	mov	sp,fp
 2018ee4:	df000017 	ldw	fp,0(sp)
 2018ee8:	dec00104 	addi	sp,sp,4
 2018eec:	f800283a 	ret

02018ef0 <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
 2018ef0:	defffd04 	addi	sp,sp,-12
 2018ef4:	dfc00215 	stw	ra,8(sp)
 2018ef8:	df000115 	stw	fp,4(sp)
 2018efc:	df000104 	addi	fp,sp,4
 2018f00:	e13fff15 	stw	r4,-4(fp)
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
 2018f04:	01800404 	movi	r6,16
 2018f08:	01408134 	movhi	r5,516
 2018f0c:	295ea304 	addi	r5,r5,31372
 2018f10:	e13fff17 	ldw	r4,-4(fp)
 2018f14:	2018f2c0 	call	2018f2c <ipaddr_ntoa_r>
}
 2018f18:	e037883a 	mov	sp,fp
 2018f1c:	dfc00117 	ldw	ra,4(sp)
 2018f20:	df000017 	ldw	fp,0(sp)
 2018f24:	dec00204 	addi	sp,sp,8
 2018f28:	f800283a 	ret

02018f2c <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
 2018f2c:	defff404 	addi	sp,sp,-48
 2018f30:	dfc00b15 	stw	ra,44(sp)
 2018f34:	df000a15 	stw	fp,40(sp)
 2018f38:	df000a04 	addi	fp,sp,40
 2018f3c:	e13ffd15 	stw	r4,-12(fp)
 2018f40:	e17ffe15 	stw	r5,-8(fp)
 2018f44:	e1bfff15 	stw	r6,-4(fp)
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 2018f48:	e03ff915 	stw	zero,-28(fp)

  s_addr = ip4_addr_get_u32(addr);
 2018f4c:	e0bffd17 	ldw	r2,-12(fp)
 2018f50:	10800017 	ldw	r2,0(r2)
 2018f54:	e0bffb15 	stw	r2,-20(fp)

  rp = buf;
 2018f58:	e0bffe17 	ldw	r2,-8(fp)
 2018f5c:	e0bff615 	stw	r2,-40(fp)
  ap = (u8_t *)&s_addr;
 2018f60:	e0bffb04 	addi	r2,fp,-20
 2018f64:	e0bff715 	stw	r2,-36(fp)
  for(n = 0; n < 4; n++) {
 2018f68:	e03ff805 	stb	zero,-32(fp)
 2018f6c:	00004606 	br	2019088 <ipaddr_ntoa_r+0x15c>
    i = 0;
 2018f70:	e03ff845 	stb	zero,-31(fp)
    do {
      rem = *ap % (u8_t)10;
 2018f74:	e0bff717 	ldw	r2,-36(fp)
 2018f78:	10800003 	ldbu	r2,0(r2)
 2018f7c:	10803fcc 	andi	r2,r2,255
 2018f80:	01400284 	movi	r5,10
 2018f84:	1009883a 	mov	r4,r2
 2018f88:	200ad0c0 	call	200ad0c <__umodsi3>
 2018f8c:	e0bffa05 	stb	r2,-24(fp)
      *ap /= (u8_t)10;
 2018f90:	e0bff717 	ldw	r2,-36(fp)
 2018f94:	10800003 	ldbu	r2,0(r2)
 2018f98:	10803fcc 	andi	r2,r2,255
 2018f9c:	01400284 	movi	r5,10
 2018fa0:	1009883a 	mov	r4,r2
 2018fa4:	200aca80 	call	200aca8 <__udivsi3>
 2018fa8:	1007883a 	mov	r3,r2
 2018fac:	e0bff717 	ldw	r2,-36(fp)
 2018fb0:	10c00005 	stb	r3,0(r2)
      inv[i++] = '0' + rem;
 2018fb4:	e0bff843 	ldbu	r2,-31(fp)
 2018fb8:	10c00044 	addi	r3,r2,1
 2018fbc:	e0fff845 	stb	r3,-31(fp)
 2018fc0:	10803fcc 	andi	r2,r2,255
 2018fc4:	e0fffa03 	ldbu	r3,-24(fp)
 2018fc8:	18c00c04 	addi	r3,r3,48
 2018fcc:	1809883a 	mov	r4,r3
 2018fd0:	e0fffc04 	addi	r3,fp,-16
 2018fd4:	1885883a 	add	r2,r3,r2
 2018fd8:	11000005 	stb	r4,0(r2)
    } while(*ap);
 2018fdc:	e0bff717 	ldw	r2,-36(fp)
 2018fe0:	10800003 	ldbu	r2,0(r2)
 2018fe4:	10803fcc 	andi	r2,r2,255
 2018fe8:	103fe21e 	bne	r2,zero,2018f74 <__alt_mem_mem_0+0xfcff8f74>
    while(i--) {
 2018fec:	00000f06 	br	201902c <ipaddr_ntoa_r+0x100>
      if (len++ >= buflen) {
 2018ff0:	e0bff917 	ldw	r2,-28(fp)
 2018ff4:	10c00044 	addi	r3,r2,1
 2018ff8:	e0fff915 	stw	r3,-28(fp)
 2018ffc:	e0ffff17 	ldw	r3,-4(fp)
 2019000:	10c00216 	blt	r2,r3,201900c <ipaddr_ntoa_r+0xe0>
        return NULL;
 2019004:	0005883a 	mov	r2,zero
 2019008:	00002806 	br	20190ac <ipaddr_ntoa_r+0x180>
      }
      *rp++ = inv[i];
 201900c:	e0bff617 	ldw	r2,-40(fp)
 2019010:	10c00044 	addi	r3,r2,1
 2019014:	e0fff615 	stw	r3,-40(fp)
 2019018:	e0fff843 	ldbu	r3,-31(fp)
 201901c:	e13ffc04 	addi	r4,fp,-16
 2019020:	20c7883a 	add	r3,r4,r3
 2019024:	18c00003 	ldbu	r3,0(r3)
 2019028:	10c00005 	stb	r3,0(r2)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 201902c:	e0bff843 	ldbu	r2,-31(fp)
 2019030:	10ffffc4 	addi	r3,r2,-1
 2019034:	e0fff845 	stb	r3,-31(fp)
 2019038:	10803fcc 	andi	r2,r2,255
 201903c:	103fec1e 	bne	r2,zero,2018ff0 <__alt_mem_mem_0+0xfcff8ff0>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
 2019040:	e0bff917 	ldw	r2,-28(fp)
 2019044:	10c00044 	addi	r3,r2,1
 2019048:	e0fff915 	stw	r3,-28(fp)
 201904c:	e0ffff17 	ldw	r3,-4(fp)
 2019050:	10c00216 	blt	r2,r3,201905c <ipaddr_ntoa_r+0x130>
      return NULL;
 2019054:	0005883a 	mov	r2,zero
 2019058:	00001406 	br	20190ac <ipaddr_ntoa_r+0x180>
    }
    *rp++ = '.';
 201905c:	e0bff617 	ldw	r2,-40(fp)
 2019060:	10c00044 	addi	r3,r2,1
 2019064:	e0fff615 	stw	r3,-40(fp)
 2019068:	00c00b84 	movi	r3,46
 201906c:	10c00005 	stb	r3,0(r2)
    ap++;
 2019070:	e0bff717 	ldw	r2,-36(fp)
 2019074:	10800044 	addi	r2,r2,1
 2019078:	e0bff715 	stw	r2,-36(fp)

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 201907c:	e0bff803 	ldbu	r2,-32(fp)
 2019080:	10800044 	addi	r2,r2,1
 2019084:	e0bff805 	stb	r2,-32(fp)
 2019088:	e0bff803 	ldbu	r2,-32(fp)
 201908c:	10800130 	cmpltui	r2,r2,4
 2019090:	103fb71e 	bne	r2,zero,2018f70 <__alt_mem_mem_0+0xfcff8f70>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 2019094:	e0bff617 	ldw	r2,-40(fp)
 2019098:	10bfffc4 	addi	r2,r2,-1
 201909c:	e0bff615 	stw	r2,-40(fp)
 20190a0:	e0bff617 	ldw	r2,-40(fp)
 20190a4:	10000005 	stb	zero,0(r2)
  return buf;
 20190a8:	e0bffe17 	ldw	r2,-8(fp)
}
 20190ac:	e037883a 	mov	sp,fp
 20190b0:	dfc00117 	ldw	ra,4(sp)
 20190b4:	df000017 	ldw	fp,0(sp)
 20190b8:	dec00204 	addi	sp,sp,8
 20190bc:	f800283a 	ret

020190c0 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
 20190c0:	defffc04 	addi	sp,sp,-16
 20190c4:	df000315 	stw	fp,12(sp)
 20190c8:	df000304 	addi	fp,sp,12
 20190cc:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
 20190d0:	d0e7ee17 	ldw	r3,-24648(gp)
 20190d4:	e0bfff17 	ldw	r2,-4(fp)
 20190d8:	1080000b 	ldhu	r2,0(r2)
 20190dc:	10bfffcc 	andi	r2,r2,65535
 20190e0:	1885883a 	add	r2,r3,r2
 20190e4:	e0bffd15 	stw	r2,-12(fp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 20190e8:	e0ffff17 	ldw	r3,-4(fp)
 20190ec:	e0bffd17 	ldw	r2,-12(fp)
 20190f0:	18801926 	beq	r3,r2,2019158 <plug_holes+0x98>
 20190f4:	e0bffd17 	ldw	r2,-12(fp)
 20190f8:	10800103 	ldbu	r2,4(r2)
 20190fc:	10803fcc 	andi	r2,r2,255
 2019100:	1000151e 	bne	r2,zero,2019158 <plug_holes+0x98>
 2019104:	d0a7ef17 	ldw	r2,-24644(gp)
 2019108:	e0fffd17 	ldw	r3,-12(fp)
 201910c:	18801226 	beq	r3,r2,2019158 <plug_holes+0x98>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 2019110:	d0e7f017 	ldw	r3,-24640(gp)
 2019114:	e0bffd17 	ldw	r2,-12(fp)
 2019118:	1880021e 	bne	r3,r2,2019124 <plug_holes+0x64>
      lfree = mem;
 201911c:	e0bfff17 	ldw	r2,-4(fp)
 2019120:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem->next = nmem->next;
 2019124:	e0bffd17 	ldw	r2,-12(fp)
 2019128:	10c0000b 	ldhu	r3,0(r2)
 201912c:	e0bfff17 	ldw	r2,-4(fp)
 2019130:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 2019134:	d0e7ee17 	ldw	r3,-24648(gp)
 2019138:	e0bffd17 	ldw	r2,-12(fp)
 201913c:	1080000b 	ldhu	r2,0(r2)
 2019140:	10bfffcc 	andi	r2,r2,65535
 2019144:	1885883a 	add	r2,r3,r2
 2019148:	e0ffff17 	ldw	r3,-4(fp)
 201914c:	d127ee17 	ldw	r4,-24648(gp)
 2019150:	1907c83a 	sub	r3,r3,r4
 2019154:	10c0008d 	sth	r3,2(r2)
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 2019158:	d0e7ee17 	ldw	r3,-24648(gp)
 201915c:	e0bfff17 	ldw	r2,-4(fp)
 2019160:	1080008b 	ldhu	r2,2(r2)
 2019164:	10bfffcc 	andi	r2,r2,65535
 2019168:	1885883a 	add	r2,r3,r2
 201916c:	e0bffe15 	stw	r2,-8(fp)
  if (pmem != mem && pmem->used == 0) {
 2019170:	e0fffe17 	ldw	r3,-8(fp)
 2019174:	e0bfff17 	ldw	r2,-4(fp)
 2019178:	18801626 	beq	r3,r2,20191d4 <plug_holes+0x114>
 201917c:	e0bffe17 	ldw	r2,-8(fp)
 2019180:	10800103 	ldbu	r2,4(r2)
 2019184:	10803fcc 	andi	r2,r2,255
 2019188:	1000121e 	bne	r2,zero,20191d4 <plug_holes+0x114>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 201918c:	d0e7f017 	ldw	r3,-24640(gp)
 2019190:	e0bfff17 	ldw	r2,-4(fp)
 2019194:	1880021e 	bne	r3,r2,20191a0 <plug_holes+0xe0>
      lfree = pmem;
 2019198:	e0bffe17 	ldw	r2,-8(fp)
 201919c:	d0a7f015 	stw	r2,-24640(gp)
    }
    pmem->next = mem->next;
 20191a0:	e0bfff17 	ldw	r2,-4(fp)
 20191a4:	10c0000b 	ldhu	r3,0(r2)
 20191a8:	e0bffe17 	ldw	r2,-8(fp)
 20191ac:	10c0000d 	sth	r3,0(r2)
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 20191b0:	d0e7ee17 	ldw	r3,-24648(gp)
 20191b4:	e0bfff17 	ldw	r2,-4(fp)
 20191b8:	1080000b 	ldhu	r2,0(r2)
 20191bc:	10bfffcc 	andi	r2,r2,65535
 20191c0:	1885883a 	add	r2,r3,r2
 20191c4:	e0fffe17 	ldw	r3,-8(fp)
 20191c8:	d127ee17 	ldw	r4,-24648(gp)
 20191cc:	1907c83a 	sub	r3,r3,r4
 20191d0:	10c0008d 	sth	r3,2(r2)
  }
}
 20191d4:	0001883a 	nop
 20191d8:	e037883a 	mov	sp,fp
 20191dc:	df000017 	ldw	fp,0(sp)
 20191e0:	dec00104 	addi	sp,sp,4
 20191e4:	f800283a 	ret

020191e8 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 20191e8:	defffd04 	addi	sp,sp,-12
 20191ec:	dfc00215 	stw	ra,8(sp)
 20191f0:	df000115 	stw	fp,4(sp)
 20191f4:	df000104 	addi	fp,sp,4

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 20191f8:	008085b4 	movhi	r2,534
 20191fc:	1088b704 	addi	r2,r2,8924
 2019200:	10c000c4 	addi	r3,r2,3
 2019204:	00bfff04 	movi	r2,-4
 2019208:	1884703a 	and	r2,r3,r2
 201920c:	d0a7ee15 	stw	r2,-24648(gp)
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
 2019210:	d0a7ee17 	ldw	r2,-24648(gp)
 2019214:	e0bfff15 	stw	r2,-4(fp)
  mem->next = MEM_SIZE_ALIGNED;
 2019218:	e0bfff17 	ldw	r2,-4(fp)
 201921c:	00e00004 	movi	r3,-32768
 2019220:	10c0000d 	sth	r3,0(r2)
  mem->prev = 0;
 2019224:	e0bfff17 	ldw	r2,-4(fp)
 2019228:	1000008d 	sth	zero,2(r2)
  mem->used = 0;
 201922c:	e0bfff17 	ldw	r2,-4(fp)
 2019230:	10000105 	stb	zero,4(r2)
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 2019234:	d0e7ee17 	ldw	r3,-24648(gp)
 2019238:	00a00014 	movui	r2,32768
 201923c:	1885883a 	add	r2,r3,r2
 2019240:	d0a7ef15 	stw	r2,-24644(gp)
  ram_end->used = 1;
 2019244:	d0a7ef17 	ldw	r2,-24644(gp)
 2019248:	00c00044 	movi	r3,1
 201924c:	10c00105 	stb	r3,4(r2)
  ram_end->next = MEM_SIZE_ALIGNED;
 2019250:	d0a7ef17 	ldw	r2,-24644(gp)
 2019254:	00e00004 	movi	r3,-32768
 2019258:	10c0000d 	sth	r3,0(r2)
  ram_end->prev = MEM_SIZE_ALIGNED;
 201925c:	d0a7ef17 	ldw	r2,-24644(gp)
 2019260:	00e00004 	movi	r3,-32768
 2019264:	10c0008d 	sth	r3,2(r2)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 2019268:	d0a7ee17 	ldw	r2,-24648(gp)
 201926c:	d0a7f015 	stw	r2,-24640(gp)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
 2019270:	008085f4 	movhi	r2,535
 2019274:	10a8bc04 	addi	r2,r2,-23824
 2019278:	00e00004 	movi	r3,-32768
 201927c:	10c0540d 	sth	r3,336(r2)

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 2019280:	d127f104 	addi	r4,gp,-24636
 2019284:	201505c0 	call	201505c <sys_mutex_new>
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 2019288:	0001883a 	nop
 201928c:	e037883a 	mov	sp,fp
 2019290:	dfc00117 	ldw	ra,4(sp)
 2019294:	df000017 	ldw	fp,0(sp)
 2019298:	dec00204 	addi	sp,sp,8
 201929c:	f800283a 	ret

020192a0 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 20192a0:	defffc04 	addi	sp,sp,-16
 20192a4:	dfc00315 	stw	ra,12(sp)
 20192a8:	df000215 	stw	fp,8(sp)
 20192ac:	df000204 	addi	fp,sp,8
 20192b0:	e13fff15 	stw	r4,-4(fp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 20192b4:	e0bfff17 	ldw	r2,-4(fp)
 20192b8:	10003426 	beq	r2,zero,201938c <mem_free+0xec>
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 20192bc:	d0a7ee17 	ldw	r2,-24648(gp)
 20192c0:	e0ffff17 	ldw	r3,-4(fp)
 20192c4:	18800336 	bltu	r3,r2,20192d4 <mem_free+0x34>
 20192c8:	d0a7ef17 	ldw	r2,-24644(gp)
 20192cc:	e0ffff17 	ldw	r3,-4(fp)
 20192d0:	18800e36 	bltu	r3,r2,201930c <mem_free+0x6c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 20192d4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20192d8:	10000126 	beq	r2,zero,20192e0 <mem_free+0x40>
 20192dc:	2010f300 	call	2010f30 <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
 20192e0:	008085f4 	movhi	r2,535
 20192e4:	10a8bc04 	addi	r2,r2,-23824
 20192e8:	10805717 	ldw	r2,348(r2)
 20192ec:	10c00044 	addi	r3,r2,1
 20192f0:	008085f4 	movhi	r2,535
 20192f4:	10a8bc04 	addi	r2,r2,-23824
 20192f8:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
 20192fc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2019300:	10002426 	beq	r2,zero,2019394 <mem_free+0xf4>
 2019304:	2010f780 	call	2010f78 <vTaskExitCritical>
    return;
 2019308:	00002206 	br	2019394 <mem_free+0xf4>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 201930c:	d127f104 	addi	r4,gp,-24636
 2019310:	201511c0 	call	201511c <sys_mutex_lock>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 2019314:	e0bfff17 	ldw	r2,-4(fp)
 2019318:	10bffe04 	addi	r2,r2,-8
 201931c:	e0bffe15 	stw	r2,-8(fp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 2019320:	e0bffe17 	ldw	r2,-8(fp)
 2019324:	10000105 	stb	zero,4(r2)

  if (mem < lfree) {
 2019328:	d0a7f017 	ldw	r2,-24640(gp)
 201932c:	e0fffe17 	ldw	r3,-8(fp)
 2019330:	1880022e 	bgeu	r3,r2,201933c <mem_free+0x9c>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 2019334:	e0bffe17 	ldw	r2,-8(fp)
 2019338:	d0a7f015 	stw	r2,-24640(gp)
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
 201933c:	008085f4 	movhi	r2,535
 2019340:	10a8bc04 	addi	r2,r2,-23824
 2019344:	1080548b 	ldhu	r2,338(r2)
 2019348:	e0fffe17 	ldw	r3,-8(fp)
 201934c:	d127ee17 	ldw	r4,-24648(gp)
 2019350:	1907c83a 	sub	r3,r3,r4
 2019354:	1809883a 	mov	r4,r3
 2019358:	e0fffe17 	ldw	r3,-8(fp)
 201935c:	18c0000b 	ldhu	r3,0(r3)
 2019360:	20c7c83a 	sub	r3,r4,r3
 2019364:	10c5883a 	add	r2,r2,r3
 2019368:	1007883a 	mov	r3,r2
 201936c:	008085f4 	movhi	r2,535
 2019370:	10a8bc04 	addi	r2,r2,-23824
 2019374:	10c0548d 	sth	r3,338(r2)

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 2019378:	e13ffe17 	ldw	r4,-8(fp)
 201937c:	20190c00 	call	20190c0 <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 2019380:	d127f104 	addi	r4,gp,-24636
 2019384:	20151680 	call	2015168 <sys_mutex_unlock>
 2019388:	00000306 	br	2019398 <mem_free+0xf8>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
 201938c:	0001883a 	nop
 2019390:	00000106 	br	2019398 <mem_free+0xf8>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
 2019394:	0001883a 	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 2019398:	e037883a 	mov	sp,fp
 201939c:	dfc00117 	ldw	ra,4(sp)
 20193a0:	df000017 	ldw	fp,0(sp)
 20193a4:	dec00204 	addi	sp,sp,8
 20193a8:	f800283a 	ret

020193ac <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 20193ac:	defff804 	addi	sp,sp,-32
 20193b0:	dfc00715 	stw	ra,28(sp)
 20193b4:	df000615 	stw	fp,24(sp)
 20193b8:	df000604 	addi	fp,sp,24
 20193bc:	e13ffe15 	stw	r4,-8(fp)
 20193c0:	2805883a 	mov	r2,r5
 20193c4:	e0bfff0d 	sth	r2,-4(fp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 20193c8:	e0bfff0b 	ldhu	r2,-4(fp)
 20193cc:	108000c4 	addi	r2,r2,3
 20193d0:	1007883a 	mov	r3,r2
 20193d4:	00bfff04 	movi	r2,-4
 20193d8:	1884703a 	and	r2,r3,r2
 20193dc:	e0bfff0d 	sth	r2,-4(fp)

  if(newsize < MIN_SIZE_ALIGNED) {
 20193e0:	e0bfff0b 	ldhu	r2,-4(fp)
 20193e4:	10800328 	cmpgeui	r2,r2,12
 20193e8:	1000021e 	bne	r2,zero,20193f4 <mem_trim+0x48>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 20193ec:	00800304 	movi	r2,12
 20193f0:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 20193f4:	e0bfff0b 	ldhu	r2,-4(fp)
 20193f8:	10a00070 	cmpltui	r2,r2,32769
 20193fc:	1000021e 	bne	r2,zero,2019408 <mem_trim+0x5c>
    return NULL;
 2019400:	0005883a 	mov	r2,zero
 2019404:	0000a606 	br	20196a0 <mem_trim+0x2f4>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 2019408:	d0a7ee17 	ldw	r2,-24648(gp)
 201940c:	e0fffe17 	ldw	r3,-8(fp)
 2019410:	18800336 	bltu	r3,r2,2019420 <mem_trim+0x74>
 2019414:	d0a7ef17 	ldw	r2,-24644(gp)
 2019418:	e0fffe17 	ldw	r3,-8(fp)
 201941c:	18800f36 	bltu	r3,r2,201945c <mem_trim+0xb0>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 2019420:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2019424:	10000126 	beq	r2,zero,201942c <mem_trim+0x80>
 2019428:	2010f300 	call	2010f30 <vTaskEnterCritical>
    MEM_STATS_INC(illegal);
 201942c:	008085f4 	movhi	r2,535
 2019430:	10a8bc04 	addi	r2,r2,-23824
 2019434:	10805717 	ldw	r2,348(r2)
 2019438:	10c00044 	addi	r3,r2,1
 201943c:	008085f4 	movhi	r2,535
 2019440:	10a8bc04 	addi	r2,r2,-23824
 2019444:	10c05715 	stw	r3,348(r2)
    SYS_ARCH_UNPROTECT(lev);
 2019448:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201944c:	10000126 	beq	r2,zero,2019454 <mem_trim+0xa8>
 2019450:	2010f780 	call	2010f78 <vTaskExitCritical>
    return rmem;
 2019454:	e0bffe17 	ldw	r2,-8(fp)
 2019458:	00009106 	br	20196a0 <mem_trim+0x2f4>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 201945c:	e0bffe17 	ldw	r2,-8(fp)
 2019460:	10bffe04 	addi	r2,r2,-8
 2019464:	e0bffa15 	stw	r2,-24(fp)
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 2019468:	e0bffa17 	ldw	r2,-24(fp)
 201946c:	d0e7ee17 	ldw	r3,-24648(gp)
 2019470:	10c5c83a 	sub	r2,r2,r3
 2019474:	e0bffb0d 	sth	r2,-20(fp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 2019478:	e0bffa17 	ldw	r2,-24(fp)
 201947c:	10c0000b 	ldhu	r3,0(r2)
 2019480:	e0bffb0b 	ldhu	r2,-20(fp)
 2019484:	1885c83a 	sub	r2,r3,r2
 2019488:	10bffe04 	addi	r2,r2,-8
 201948c:	e0bffb8d 	sth	r2,-18(fp)
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 2019490:	e0bfff0b 	ldhu	r2,-4(fp)
 2019494:	e0fffb8b 	ldhu	r3,-18(fp)
 2019498:	1880022e 	bgeu	r3,r2,20194a4 <mem_trim+0xf8>
    /* not supported */
    return NULL;
 201949c:	0005883a 	mov	r2,zero
 20194a0:	00007f06 	br	20196a0 <mem_trim+0x2f4>
  }
  if (newsize == size) {
 20194a4:	e0ffff0b 	ldhu	r3,-4(fp)
 20194a8:	e0bffb8b 	ldhu	r2,-18(fp)
 20194ac:	1880021e 	bne	r3,r2,20194b8 <mem_trim+0x10c>
    /* No change in size, simply return */
    return rmem;
 20194b0:	e0bffe17 	ldw	r2,-8(fp)
 20194b4:	00007a06 	br	20196a0 <mem_trim+0x2f4>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 20194b8:	d127f104 	addi	r4,gp,-24636
 20194bc:	201511c0 	call	201511c <sys_mutex_lock>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 20194c0:	d0e7ee17 	ldw	r3,-24648(gp)
 20194c4:	e0bffa17 	ldw	r2,-24(fp)
 20194c8:	1080000b 	ldhu	r2,0(r2)
 20194cc:	10bfffcc 	andi	r2,r2,65535
 20194d0:	1885883a 	add	r2,r3,r2
 20194d4:	e0bffc15 	stw	r2,-16(fp)
  if(mem2->used == 0) {
 20194d8:	e0bffc17 	ldw	r2,-16(fp)
 20194dc:	10800103 	ldbu	r2,4(r2)
 20194e0:	10803fcc 	andi	r2,r2,255
 20194e4:	1000361e 	bne	r2,zero,20195c0 <mem_trim+0x214>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 20194e8:	e0bffc17 	ldw	r2,-16(fp)
 20194ec:	1080000b 	ldhu	r2,0(r2)
 20194f0:	e0bffd0d 	sth	r2,-12(fp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 20194f4:	e0fffb0b 	ldhu	r3,-20(fp)
 20194f8:	e0bfff0b 	ldhu	r2,-4(fp)
 20194fc:	1885883a 	add	r2,r3,r2
 2019500:	10800204 	addi	r2,r2,8
 2019504:	e0bffd8d 	sth	r2,-10(fp)
    if (lfree == mem2) {
 2019508:	d0e7f017 	ldw	r3,-24640(gp)
 201950c:	e0bffc17 	ldw	r2,-16(fp)
 2019510:	1880041e 	bne	r3,r2,2019524 <mem_trim+0x178>
      lfree = (struct mem *)(void *)&ram[ptr2];
 2019514:	d0e7ee17 	ldw	r3,-24648(gp)
 2019518:	e0bffd8b 	ldhu	r2,-10(fp)
 201951c:	1885883a 	add	r2,r3,r2
 2019520:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 2019524:	d0e7ee17 	ldw	r3,-24648(gp)
 2019528:	e0bffd8b 	ldhu	r2,-10(fp)
 201952c:	1885883a 	add	r2,r3,r2
 2019530:	e0bffc15 	stw	r2,-16(fp)
    mem2->used = 0;
 2019534:	e0bffc17 	ldw	r2,-16(fp)
 2019538:	10000105 	stb	zero,4(r2)
    /* restore the next pointer */
    mem2->next = next;
 201953c:	e0bffc17 	ldw	r2,-16(fp)
 2019540:	e0fffd0b 	ldhu	r3,-12(fp)
 2019544:	10c0000d 	sth	r3,0(r2)
    /* link it back to mem */
    mem2->prev = ptr;
 2019548:	e0bffc17 	ldw	r2,-16(fp)
 201954c:	e0fffb0b 	ldhu	r3,-20(fp)
 2019550:	10c0008d 	sth	r3,2(r2)
    /* link mem to it */
    mem->next = ptr2;
 2019554:	e0bffa17 	ldw	r2,-24(fp)
 2019558:	e0fffd8b 	ldhu	r3,-10(fp)
 201955c:	10c0000d 	sth	r3,0(r2)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 2019560:	e0bffc17 	ldw	r2,-16(fp)
 2019564:	1080000b 	ldhu	r2,0(r2)
 2019568:	10ffffcc 	andi	r3,r2,65535
 201956c:	00a00014 	movui	r2,32768
 2019570:	18800726 	beq	r3,r2,2019590 <mem_trim+0x1e4>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 2019574:	d0e7ee17 	ldw	r3,-24648(gp)
 2019578:	e0bffc17 	ldw	r2,-16(fp)
 201957c:	1080000b 	ldhu	r2,0(r2)
 2019580:	10bfffcc 	andi	r2,r2,65535
 2019584:	1885883a 	add	r2,r3,r2
 2019588:	e0fffd8b 	ldhu	r3,-10(fp)
 201958c:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 2019590:	008085f4 	movhi	r2,535
 2019594:	10a8bc04 	addi	r2,r2,-23824
 2019598:	1080548b 	ldhu	r2,338(r2)
 201959c:	e13fff0b 	ldhu	r4,-4(fp)
 20195a0:	e0fffb8b 	ldhu	r3,-18(fp)
 20195a4:	20c7c83a 	sub	r3,r4,r3
 20195a8:	10c5883a 	add	r2,r2,r3
 20195ac:	1007883a 	mov	r3,r2
 20195b0:	008085f4 	movhi	r2,535
 20195b4:	10a8bc04 	addi	r2,r2,-23824
 20195b8:	10c0548d 	sth	r3,338(r2)
 20195bc:	00003506 	br	2019694 <mem_trim+0x2e8>
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 20195c0:	e0bfff0b 	ldhu	r2,-4(fp)
 20195c4:	10800504 	addi	r2,r2,20
 20195c8:	e0fffb8b 	ldhu	r3,-18(fp)
 20195cc:	18803136 	bltu	r3,r2,2019694 <mem_trim+0x2e8>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 20195d0:	e0fffb0b 	ldhu	r3,-20(fp)
 20195d4:	e0bfff0b 	ldhu	r2,-4(fp)
 20195d8:	1885883a 	add	r2,r3,r2
 20195dc:	10800204 	addi	r2,r2,8
 20195e0:	e0bffd8d 	sth	r2,-10(fp)
    mem2 = (struct mem *)(void *)&ram[ptr2];
 20195e4:	d0e7ee17 	ldw	r3,-24648(gp)
 20195e8:	e0bffd8b 	ldhu	r2,-10(fp)
 20195ec:	1885883a 	add	r2,r3,r2
 20195f0:	e0bffc15 	stw	r2,-16(fp)
    if (mem2 < lfree) {
 20195f4:	d0a7f017 	ldw	r2,-24640(gp)
 20195f8:	e0fffc17 	ldw	r3,-16(fp)
 20195fc:	1880022e 	bgeu	r3,r2,2019608 <mem_trim+0x25c>
      lfree = mem2;
 2019600:	e0bffc17 	ldw	r2,-16(fp)
 2019604:	d0a7f015 	stw	r2,-24640(gp)
    }
    mem2->used = 0;
 2019608:	e0bffc17 	ldw	r2,-16(fp)
 201960c:	10000105 	stb	zero,4(r2)
    mem2->next = mem->next;
 2019610:	e0bffa17 	ldw	r2,-24(fp)
 2019614:	10c0000b 	ldhu	r3,0(r2)
 2019618:	e0bffc17 	ldw	r2,-16(fp)
 201961c:	10c0000d 	sth	r3,0(r2)
    mem2->prev = ptr;
 2019620:	e0bffc17 	ldw	r2,-16(fp)
 2019624:	e0fffb0b 	ldhu	r3,-20(fp)
 2019628:	10c0008d 	sth	r3,2(r2)
    mem->next = ptr2;
 201962c:	e0bffa17 	ldw	r2,-24(fp)
 2019630:	e0fffd8b 	ldhu	r3,-10(fp)
 2019634:	10c0000d 	sth	r3,0(r2)
    if (mem2->next != MEM_SIZE_ALIGNED) {
 2019638:	e0bffc17 	ldw	r2,-16(fp)
 201963c:	1080000b 	ldhu	r2,0(r2)
 2019640:	10ffffcc 	andi	r3,r2,65535
 2019644:	00a00014 	movui	r2,32768
 2019648:	18800726 	beq	r3,r2,2019668 <mem_trim+0x2bc>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 201964c:	d0e7ee17 	ldw	r3,-24648(gp)
 2019650:	e0bffc17 	ldw	r2,-16(fp)
 2019654:	1080000b 	ldhu	r2,0(r2)
 2019658:	10bfffcc 	andi	r2,r2,65535
 201965c:	1885883a 	add	r2,r3,r2
 2019660:	e0fffd8b 	ldhu	r3,-10(fp)
 2019664:	10c0008d 	sth	r3,2(r2)
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
 2019668:	008085f4 	movhi	r2,535
 201966c:	10a8bc04 	addi	r2,r2,-23824
 2019670:	1080548b 	ldhu	r2,338(r2)
 2019674:	e13fff0b 	ldhu	r4,-4(fp)
 2019678:	e0fffb8b 	ldhu	r3,-18(fp)
 201967c:	20c7c83a 	sub	r3,r4,r3
 2019680:	10c5883a 	add	r2,r2,r3
 2019684:	1007883a 	mov	r3,r2
 2019688:	008085f4 	movhi	r2,535
 201968c:	10a8bc04 	addi	r2,r2,-23824
 2019690:	10c0548d 	sth	r3,338(r2)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 2019694:	d127f104 	addi	r4,gp,-24636
 2019698:	20151680 	call	2015168 <sys_mutex_unlock>
  return rmem;
 201969c:	e0bffe17 	ldw	r2,-8(fp)
}
 20196a0:	e037883a 	mov	sp,fp
 20196a4:	dfc00117 	ldw	ra,4(sp)
 20196a8:	df000017 	ldw	fp,0(sp)
 20196ac:	dec00204 	addi	sp,sp,8
 20196b0:	f800283a 	ret

020196b4 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 20196b4:	defff804 	addi	sp,sp,-32
 20196b8:	dfc00715 	stw	ra,28(sp)
 20196bc:	df000615 	stw	fp,24(sp)
 20196c0:	df000604 	addi	fp,sp,24
 20196c4:	2005883a 	mov	r2,r4
 20196c8:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 20196cc:	e0bfff0b 	ldhu	r2,-4(fp)
 20196d0:	1000021e 	bne	r2,zero,20196dc <mem_malloc+0x28>
    return NULL;
 20196d4:	0005883a 	mov	r2,zero
 20196d8:	0000bd06 	br	20199d0 <mem_malloc+0x31c>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 20196dc:	e0bfff0b 	ldhu	r2,-4(fp)
 20196e0:	108000c4 	addi	r2,r2,3
 20196e4:	1007883a 	mov	r3,r2
 20196e8:	00bfff04 	movi	r2,-4
 20196ec:	1884703a 	and	r2,r3,r2
 20196f0:	e0bfff0d 	sth	r2,-4(fp)

  if(size < MIN_SIZE_ALIGNED) {
 20196f4:	e0bfff0b 	ldhu	r2,-4(fp)
 20196f8:	10800328 	cmpgeui	r2,r2,12
 20196fc:	1000021e 	bne	r2,zero,2019708 <mem_malloc+0x54>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 2019700:	00800304 	movi	r2,12
 2019704:	e0bfff0d 	sth	r2,-4(fp)
  }

  if (size > MEM_SIZE_ALIGNED) {
 2019708:	e0bfff0b 	ldhu	r2,-4(fp)
 201970c:	10a00070 	cmpltui	r2,r2,32769
 2019710:	1000021e 	bne	r2,zero,201971c <mem_malloc+0x68>
    return NULL;
 2019714:	0005883a 	mov	r2,zero
 2019718:	0000ad06 	br	20199d0 <mem_malloc+0x31c>
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 201971c:	d127f104 	addi	r4,gp,-24636
 2019720:	201511c0 	call	201511c <sys_mutex_lock>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 2019724:	d0a7f017 	ldw	r2,-24640(gp)
 2019728:	1007883a 	mov	r3,r2
 201972c:	d0a7ee17 	ldw	r2,-24648(gp)
 2019730:	1885c83a 	sub	r2,r3,r2
 2019734:	e0bffa0d 	sth	r2,-24(fp)
 2019738:	00009606 	br	2019994 <mem_malloc+0x2e0>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 201973c:	d0e7ee17 	ldw	r3,-24648(gp)
 2019740:	e0bffa0b 	ldhu	r2,-24(fp)
 2019744:	1885883a 	add	r2,r3,r2
 2019748:	e0bffc15 	stw	r2,-16(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 201974c:	e0bffc17 	ldw	r2,-16(fp)
 2019750:	10800103 	ldbu	r2,4(r2)
 2019754:	10803fcc 	andi	r2,r2,255
 2019758:	1000891e 	bne	r2,zero,2019980 <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 201975c:	e0bffc17 	ldw	r2,-16(fp)
 2019760:	1080000b 	ldhu	r2,0(r2)
 2019764:	10ffffcc 	andi	r3,r2,65535
 2019768:	e0bffa0b 	ldhu	r2,-24(fp)
 201976c:	1885c83a 	sub	r2,r3,r2
 2019770:	10fffe04 	addi	r3,r2,-8
 2019774:	e0bfff0b 	ldhu	r2,-4(fp)
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 2019778:	18808136 	bltu	r3,r2,2019980 <mem_malloc+0x2cc>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 201977c:	e0bffc17 	ldw	r2,-16(fp)
 2019780:	1080000b 	ldhu	r2,0(r2)
 2019784:	10ffffcc 	andi	r3,r2,65535
 2019788:	e0bffa0b 	ldhu	r2,-24(fp)
 201978c:	1885c83a 	sub	r2,r3,r2
 2019790:	10fffe04 	addi	r3,r2,-8
 2019794:	e0bfff0b 	ldhu	r2,-4(fp)
 2019798:	10800504 	addi	r2,r2,20
 201979c:	18803e36 	bltu	r3,r2,2019898 <mem_malloc+0x1e4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 20197a0:	e0fffa0b 	ldhu	r3,-24(fp)
 20197a4:	e0bfff0b 	ldhu	r2,-4(fp)
 20197a8:	1885883a 	add	r2,r3,r2
 20197ac:	10800204 	addi	r2,r2,8
 20197b0:	e0bffd0d 	sth	r2,-12(fp)
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 20197b4:	d0e7ee17 	ldw	r3,-24648(gp)
 20197b8:	e0bffd0b 	ldhu	r2,-12(fp)
 20197bc:	1885883a 	add	r2,r3,r2
 20197c0:	e0bffe15 	stw	r2,-8(fp)
          mem2->used = 0;
 20197c4:	e0bffe17 	ldw	r2,-8(fp)
 20197c8:	10000105 	stb	zero,4(r2)
          mem2->next = mem->next;
 20197cc:	e0bffc17 	ldw	r2,-16(fp)
 20197d0:	10c0000b 	ldhu	r3,0(r2)
 20197d4:	e0bffe17 	ldw	r2,-8(fp)
 20197d8:	10c0000d 	sth	r3,0(r2)
          mem2->prev = ptr;
 20197dc:	e0bffe17 	ldw	r2,-8(fp)
 20197e0:	e0fffa0b 	ldhu	r3,-24(fp)
 20197e4:	10c0008d 	sth	r3,2(r2)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 20197e8:	e0bffc17 	ldw	r2,-16(fp)
 20197ec:	e0fffd0b 	ldhu	r3,-12(fp)
 20197f0:	10c0000d 	sth	r3,0(r2)
          mem->used = 1;
 20197f4:	e0bffc17 	ldw	r2,-16(fp)
 20197f8:	00c00044 	movi	r3,1
 20197fc:	10c00105 	stb	r3,4(r2)

          if (mem2->next != MEM_SIZE_ALIGNED) {
 2019800:	e0bffe17 	ldw	r2,-8(fp)
 2019804:	1080000b 	ldhu	r2,0(r2)
 2019808:	10ffffcc 	andi	r3,r2,65535
 201980c:	00a00014 	movui	r2,32768
 2019810:	18800726 	beq	r3,r2,2019830 <mem_malloc+0x17c>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 2019814:	d0e7ee17 	ldw	r3,-24648(gp)
 2019818:	e0bffe17 	ldw	r2,-8(fp)
 201981c:	1080000b 	ldhu	r2,0(r2)
 2019820:	10bfffcc 	andi	r2,r2,65535
 2019824:	1885883a 	add	r2,r3,r2
 2019828:	e0fffd0b 	ldhu	r3,-12(fp)
 201982c:	10c0008d 	sth	r3,2(r2)
          }
          MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
 2019830:	008085f4 	movhi	r2,535
 2019834:	10a8bc04 	addi	r2,r2,-23824
 2019838:	10c0548b 	ldhu	r3,338(r2)
 201983c:	e0bfff0b 	ldhu	r2,-4(fp)
 2019840:	1885883a 	add	r2,r3,r2
 2019844:	10800204 	addi	r2,r2,8
 2019848:	1007883a 	mov	r3,r2
 201984c:	008085f4 	movhi	r2,535
 2019850:	10a8bc04 	addi	r2,r2,-23824
 2019854:	10c0548d 	sth	r3,338(r2)
 2019858:	008085f4 	movhi	r2,535
 201985c:	10a8bc04 	addi	r2,r2,-23824
 2019860:	10c0550b 	ldhu	r3,340(r2)
 2019864:	008085f4 	movhi	r2,535
 2019868:	10a8bc04 	addi	r2,r2,-23824
 201986c:	1080548b 	ldhu	r2,338(r2)
 2019870:	18ffffcc 	andi	r3,r3,65535
 2019874:	10bfffcc 	andi	r2,r2,65535
 2019878:	1880272e 	bgeu	r3,r2,2019918 <mem_malloc+0x264>
 201987c:	008085f4 	movhi	r2,535
 2019880:	10a8bc04 	addi	r2,r2,-23824
 2019884:	10c0548b 	ldhu	r3,338(r2)
 2019888:	008085f4 	movhi	r2,535
 201988c:	10a8bc04 	addi	r2,r2,-23824
 2019890:	10c0550d 	sth	r3,340(r2)
 2019894:	00002006 	br	2019918 <mem_malloc+0x264>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 2019898:	e0bffc17 	ldw	r2,-16(fp)
 201989c:	00c00044 	movi	r3,1
 20198a0:	10c00105 	stb	r3,4(r2)
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
 20198a4:	008085f4 	movhi	r2,535
 20198a8:	10a8bc04 	addi	r2,r2,-23824
 20198ac:	1080548b 	ldhu	r2,338(r2)
 20198b0:	e0fffc17 	ldw	r3,-16(fp)
 20198b4:	18c0000b 	ldhu	r3,0(r3)
 20198b8:	e13ffc17 	ldw	r4,-16(fp)
 20198bc:	d167ee17 	ldw	r5,-24648(gp)
 20198c0:	2149c83a 	sub	r4,r4,r5
 20198c4:	1907c83a 	sub	r3,r3,r4
 20198c8:	10c5883a 	add	r2,r2,r3
 20198cc:	1007883a 	mov	r3,r2
 20198d0:	008085f4 	movhi	r2,535
 20198d4:	10a8bc04 	addi	r2,r2,-23824
 20198d8:	10c0548d 	sth	r3,338(r2)
 20198dc:	008085f4 	movhi	r2,535
 20198e0:	10a8bc04 	addi	r2,r2,-23824
 20198e4:	10c0550b 	ldhu	r3,340(r2)
 20198e8:	008085f4 	movhi	r2,535
 20198ec:	10a8bc04 	addi	r2,r2,-23824
 20198f0:	1080548b 	ldhu	r2,338(r2)
 20198f4:	18ffffcc 	andi	r3,r3,65535
 20198f8:	10bfffcc 	andi	r2,r2,65535
 20198fc:	1880062e 	bgeu	r3,r2,2019918 <mem_malloc+0x264>
 2019900:	008085f4 	movhi	r2,535
 2019904:	10a8bc04 	addi	r2,r2,-23824
 2019908:	10c0548b 	ldhu	r3,338(r2)
 201990c:	008085f4 	movhi	r2,535
 2019910:	10a8bc04 	addi	r2,r2,-23824
 2019914:	10c0550d 	sth	r3,340(r2)
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 2019918:	d0a7f017 	ldw	r2,-24640(gp)
 201991c:	e0fffc17 	ldw	r3,-16(fp)
 2019920:	1880121e 	bne	r3,r2,201996c <mem_malloc+0x2b8>
          struct mem *cur = lfree;
 2019924:	d0a7f017 	ldw	r2,-24640(gp)
 2019928:	e0bffb15 	stw	r2,-20(fp)
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 201992c:	00000606 	br	2019948 <mem_malloc+0x294>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 2019930:	d0e7ee17 	ldw	r3,-24648(gp)
 2019934:	e0bffb17 	ldw	r2,-20(fp)
 2019938:	1080000b 	ldhu	r2,0(r2)
 201993c:	10bfffcc 	andi	r2,r2,65535
 2019940:	1885883a 	add	r2,r3,r2
 2019944:	e0bffb15 	stw	r2,-20(fp)
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 2019948:	e0bffb17 	ldw	r2,-20(fp)
 201994c:	10800103 	ldbu	r2,4(r2)
 2019950:	10803fcc 	andi	r2,r2,255
 2019954:	10000326 	beq	r2,zero,2019964 <mem_malloc+0x2b0>
 2019958:	d0a7ef17 	ldw	r2,-24644(gp)
 201995c:	e0fffb17 	ldw	r3,-20(fp)
 2019960:	18bff31e 	bne	r3,r2,2019930 <__alt_mem_mem_0+0xfcff9930>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 2019964:	e0bffb17 	ldw	r2,-20(fp)
 2019968:	d0a7f015 	stw	r2,-24640(gp)
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 201996c:	d127f104 	addi	r4,gp,-24636
 2019970:	20151680 	call	2015168 <sys_mutex_unlock>
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 2019974:	e0bffc17 	ldw	r2,-16(fp)
 2019978:	10800204 	addi	r2,r2,8
 201997c:	00001406 	br	20199d0 <mem_malloc+0x31c>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 2019980:	d0e7ee17 	ldw	r3,-24648(gp)
 2019984:	e0bffa0b 	ldhu	r2,-24(fp)
 2019988:	1885883a 	add	r2,r3,r2
 201998c:	1080000b 	ldhu	r2,0(r2)
 2019990:	e0bffa0d 	sth	r2,-24(fp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 2019994:	e0fffa0b 	ldhu	r3,-24(fp)
 2019998:	e0bfff0b 	ldhu	r2,-4(fp)
 201999c:	01200014 	movui	r4,32768
 20199a0:	2085c83a 	sub	r2,r4,r2
 20199a4:	18bf6516 	blt	r3,r2,201973c <__alt_mem_mem_0+0xfcff973c>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
    /* if we got interrupted by a mem_free, try again */
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
 20199a8:	008085f4 	movhi	r2,535
 20199ac:	10a8bc04 	addi	r2,r2,-23824
 20199b0:	10805617 	ldw	r2,344(r2)
 20199b4:	10c00044 	addi	r3,r2,1
 20199b8:	008085f4 	movhi	r2,535
 20199bc:	10a8bc04 	addi	r2,r2,-23824
 20199c0:	10c05615 	stw	r3,344(r2)
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 20199c4:	d127f104 	addi	r4,gp,-24636
 20199c8:	20151680 	call	2015168 <sys_mutex_unlock>
  return NULL;
 20199cc:	0005883a 	mov	r2,zero
}
 20199d0:	e037883a 	mov	sp,fp
 20199d4:	dfc00117 	ldw	ra,4(sp)
 20199d8:	df000017 	ldw	fp,0(sp)
 20199dc:	dec00204 	addi	sp,sp,8
 20199e0:	f800283a 	ret

020199e4 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
 20199e4:	defffb04 	addi	sp,sp,-20
 20199e8:	dfc00415 	stw	ra,16(sp)
 20199ec:	df000315 	stw	fp,12(sp)
 20199f0:	df000304 	addi	fp,sp,12
 20199f4:	2007883a 	mov	r3,r4
 20199f8:	2805883a 	mov	r2,r5
 20199fc:	e0fffe0d 	sth	r3,-8(fp)
 2019a00:	e0bfff0d 	sth	r2,-4(fp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
 2019a04:	e0fffe0b 	ldhu	r3,-8(fp)
 2019a08:	e0bfff0b 	ldhu	r2,-4(fp)
 2019a0c:	1885383a 	mul	r2,r3,r2
 2019a10:	10bfffcc 	andi	r2,r2,65535
 2019a14:	1009883a 	mov	r4,r2
 2019a18:	20196b40 	call	20196b4 <mem_malloc>
 2019a1c:	e0bffd15 	stw	r2,-12(fp)
  if (p) {
 2019a20:	e0bffd17 	ldw	r2,-12(fp)
 2019a24:	10000726 	beq	r2,zero,2019a44 <mem_calloc+0x60>
    /* zero the memory */
    memset(p, 0, count * size);
 2019a28:	e0fffe0b 	ldhu	r3,-8(fp)
 2019a2c:	e0bfff0b 	ldhu	r2,-4(fp)
 2019a30:	1885383a 	mul	r2,r3,r2
 2019a34:	100d883a 	mov	r6,r2
 2019a38:	000b883a 	mov	r5,zero
 2019a3c:	e13ffd17 	ldw	r4,-12(fp)
 2019a40:	200616c0 	call	200616c <memset>
  }
  return p;
 2019a44:	e0bffd17 	ldw	r2,-12(fp)
}
 2019a48:	e037883a 	mov	sp,fp
 2019a4c:	dfc00117 	ldw	ra,4(sp)
 2019a50:	df000017 	ldw	fp,0(sp)
 2019a54:	dec00204 	addi	sp,sp,8
 2019a58:	f800283a 	ret

02019a5c <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 2019a5c:	deffff04 	addi	sp,sp,-4
 2019a60:	df000015 	stw	fp,0(sp)
 2019a64:	d839883a 	mov	fp,sp
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
 2019a68:	0001883a 	nop
 2019a6c:	e037883a 	mov	sp,fp
 2019a70:	df000017 	ldw	fp,0(sp)
 2019a74:	dec00104 	addi	sp,sp,4
 2019a78:	f800283a 	ret

02019a7c <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 2019a7c:	defffa04 	addi	sp,sp,-24
 2019a80:	dfc00515 	stw	ra,20(sp)
 2019a84:	df000415 	stw	fp,16(sp)
 2019a88:	df000404 	addi	fp,sp,16
 2019a8c:	e13ffc15 	stw	r4,-16(fp)
 2019a90:	e17ffd15 	stw	r5,-12(fp)
 2019a94:	e1bffe15 	stw	r6,-8(fp)
 2019a98:	e1ffff15 	stw	r7,-4(fp)

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 2019a9c:	e0bffc17 	ldw	r2,-16(fp)
 2019aa0:	10000115 	stw	zero,4(r2)
  ip_addr_set_zero(&netif->netmask);
 2019aa4:	e0bffc17 	ldw	r2,-16(fp)
 2019aa8:	10000215 	stw	zero,8(r2)
  ip_addr_set_zero(&netif->gw);
 2019aac:	e0bffc17 	ldw	r2,-16(fp)
 2019ab0:	10000315 	stw	zero,12(r2)
  netif->flags = 0;
 2019ab4:	e0bffc17 	ldw	r2,-16(fp)
 2019ab8:	10000e45 	stb	zero,57(r2)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
 2019abc:	e0bffc17 	ldw	r2,-16(fp)
 2019ac0:	10000a15 	stw	zero,40(r2)
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
 2019ac4:	e0bffc17 	ldw	r2,-16(fp)
 2019ac8:	10000715 	stw	zero,28(r2)
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
 2019acc:	e0bffc17 	ldw	r2,-16(fp)
 2019ad0:	10000815 	stw	zero,32(r2)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 2019ad4:	e0bffc17 	ldw	r2,-16(fp)
 2019ad8:	e0c00217 	ldw	r3,8(fp)
 2019adc:	10c00915 	stw	r3,36(r2)
  netif->num = netif_num++;
 2019ae0:	d0a7f203 	ldbu	r2,-24632(gp)
 2019ae4:	10c00044 	addi	r3,r2,1
 2019ae8:	d0e7f205 	stb	r3,-24632(gp)
 2019aec:	e0fffc17 	ldw	r3,-16(fp)
 2019af0:	18800f05 	stb	r2,60(r3)
  netif->input = input;
 2019af4:	e0bffc17 	ldw	r2,-16(fp)
 2019af8:	e0c00417 	ldw	r3,16(fp)
 2019afc:	10c00415 	stw	r3,16(r2)
  NETIF_SET_HWADDRHINT(netif, NULL);
 2019b00:	e0bffc17 	ldw	r2,-16(fp)
 2019b04:	10001015 	stw	zero,64(r2)
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
 2019b08:	e1ffff17 	ldw	r7,-4(fp)
 2019b0c:	e1bffe17 	ldw	r6,-8(fp)
 2019b10:	e17ffd17 	ldw	r5,-12(fp)
 2019b14:	e13ffc17 	ldw	r4,-16(fp)
 2019b18:	2019b6c0 	call	2019b6c <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 2019b1c:	e0800317 	ldw	r2,12(fp)
 2019b20:	e13ffc17 	ldw	r4,-16(fp)
 2019b24:	103ee83a 	callr	r2
 2019b28:	10803fcc 	andi	r2,r2,255
 2019b2c:	1080201c 	xori	r2,r2,128
 2019b30:	10bfe004 	addi	r2,r2,-128
 2019b34:	10000226 	beq	r2,zero,2019b40 <netif_add+0xc4>
    return NULL;
 2019b38:	0005883a 	mov	r2,zero
 2019b3c:	00000606 	br	2019b58 <netif_add+0xdc>
  }

  /* add this netif to the list */
  netif->next = netif_list;
 2019b40:	d0e7f317 	ldw	r3,-24628(gp)
 2019b44:	e0bffc17 	ldw	r2,-16(fp)
 2019b48:	10c00015 	stw	r3,0(r2)
  netif_list = netif;
 2019b4c:	e0bffc17 	ldw	r2,-16(fp)
 2019b50:	d0a7f315 	stw	r2,-24628(gp)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 2019b54:	e0bffc17 	ldw	r2,-16(fp)
}
 2019b58:	e037883a 	mov	sp,fp
 2019b5c:	dfc00117 	ldw	ra,4(sp)
 2019b60:	df000017 	ldw	fp,0(sp)
 2019b64:	dec00204 	addi	sp,sp,8
 2019b68:	f800283a 	ret

02019b6c <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
 2019b6c:	defffa04 	addi	sp,sp,-24
 2019b70:	dfc00515 	stw	ra,20(sp)
 2019b74:	df000415 	stw	fp,16(sp)
 2019b78:	df000404 	addi	fp,sp,16
 2019b7c:	e13ffc15 	stw	r4,-16(fp)
 2019b80:	e17ffd15 	stw	r5,-12(fp)
 2019b84:	e1bffe15 	stw	r6,-8(fp)
 2019b88:	e1ffff15 	stw	r7,-4(fp)
  netif_set_ipaddr(netif, ipaddr);
 2019b8c:	e17ffd17 	ldw	r5,-12(fp)
 2019b90:	e13ffc17 	ldw	r4,-16(fp)
 2019b94:	2019d800 	call	2019d80 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
 2019b98:	e17ffe17 	ldw	r5,-8(fp)
 2019b9c:	e13ffc17 	ldw	r4,-16(fp)
 2019ba0:	2019ef00 	call	2019ef0 <netif_set_netmask>
  netif_set_gw(netif, gw);
 2019ba4:	e17fff17 	ldw	r5,-4(fp)
 2019ba8:	e13ffc17 	ldw	r4,-16(fp)
 2019bac:	2019ea80 	call	2019ea8 <netif_set_gw>
}
 2019bb0:	0001883a 	nop
 2019bb4:	e037883a 	mov	sp,fp
 2019bb8:	dfc00117 	ldw	ra,4(sp)
 2019bbc:	df000017 	ldw	fp,0(sp)
 2019bc0:	dec00204 	addi	sp,sp,8
 2019bc4:	f800283a 	ret

02019bc8 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 2019bc8:	defffc04 	addi	sp,sp,-16
 2019bcc:	dfc00315 	stw	ra,12(sp)
 2019bd0:	df000215 	stw	fp,8(sp)
 2019bd4:	df000204 	addi	fp,sp,8
 2019bd8:	e13fff15 	stw	r4,-4(fp)
  if (netif == NULL) {
 2019bdc:	e0bfff17 	ldw	r2,-4(fp)
 2019be0:	10002726 	beq	r2,zero,2019c80 <netif_remove+0xb8>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
 2019be4:	e0bfff17 	ldw	r2,-4(fp)
 2019be8:	10800e43 	ldbu	r2,57(r2)
 2019bec:	10803fcc 	andi	r2,r2,255
 2019bf0:	1080004c 	andi	r2,r2,1
 2019bf4:	10000226 	beq	r2,zero,2019c00 <netif_remove+0x38>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 2019bf8:	e13fff17 	ldw	r4,-4(fp)
 2019bfc:	201a0140 	call	201a014 <netif_set_down>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
 2019c00:	d0e7f317 	ldw	r3,-24628(gp)
 2019c04:	e0bfff17 	ldw	r2,-4(fp)
 2019c08:	1880041e 	bne	r3,r2,2019c1c <netif_remove+0x54>
    netif_list = netif->next;
 2019c0c:	e0bfff17 	ldw	r2,-4(fp)
 2019c10:	10800017 	ldw	r2,0(r2)
 2019c14:	d0a7f315 	stw	r2,-24628(gp)
 2019c18:	00001306 	br	2019c68 <netif_remove+0xa0>
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 2019c1c:	d0a7f317 	ldw	r2,-24628(gp)
 2019c20:	e0bffe15 	stw	r2,-8(fp)
 2019c24:	00000c06 	br	2019c58 <netif_remove+0x90>
      if (tmpNetif->next == netif) {
 2019c28:	e0bffe17 	ldw	r2,-8(fp)
 2019c2c:	10c00017 	ldw	r3,0(r2)
 2019c30:	e0bfff17 	ldw	r2,-4(fp)
 2019c34:	1880051e 	bne	r3,r2,2019c4c <netif_remove+0x84>
        tmpNetif->next = netif->next;
 2019c38:	e0bfff17 	ldw	r2,-4(fp)
 2019c3c:	10c00017 	ldw	r3,0(r2)
 2019c40:	e0bffe17 	ldw	r2,-8(fp)
 2019c44:	10c00015 	stw	r3,0(r2)
        break;
 2019c48:	00000506 	br	2019c60 <netif_remove+0x98>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 2019c4c:	e0bffe17 	ldw	r2,-8(fp)
 2019c50:	10800017 	ldw	r2,0(r2)
 2019c54:	e0bffe15 	stw	r2,-8(fp)
 2019c58:	e0bffe17 	ldw	r2,-8(fp)
 2019c5c:	103ff21e 	bne	r2,zero,2019c28 <__alt_mem_mem_0+0xfcff9c28>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
 2019c60:	e0bffe17 	ldw	r2,-8(fp)
 2019c64:	10000826 	beq	r2,zero,2019c88 <netif_remove+0xc0>
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
 2019c68:	d0e7f417 	ldw	r3,-24624(gp)
 2019c6c:	e0bfff17 	ldw	r2,-4(fp)
 2019c70:	1880061e 	bne	r3,r2,2019c8c <netif_remove+0xc4>
    /* reset default netif */
    netif_set_default(NULL);
 2019c74:	0009883a 	mov	r4,zero
 2019c78:	2019f380 	call	2019f38 <netif_set_default>
 2019c7c:	00000306 	br	2019c8c <netif_remove+0xc4>
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
    return;
 2019c80:	0001883a 	nop
 2019c84:	00000106 	br	2019c8c <netif_remove+0xc4>
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
 2019c88:	0001883a 	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 2019c8c:	e037883a 	mov	sp,fp
 2019c90:	dfc00117 	ldw	ra,4(sp)
 2019c94:	df000017 	ldw	fp,0(sp)
 2019c98:	dec00204 	addi	sp,sp,8
 2019c9c:	f800283a 	ret

02019ca0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
 2019ca0:	defffc04 	addi	sp,sp,-16
 2019ca4:	df000315 	stw	fp,12(sp)
 2019ca8:	df000304 	addi	fp,sp,12
 2019cac:	e13fff15 	stw	r4,-4(fp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
 2019cb0:	e0bfff17 	ldw	r2,-4(fp)
 2019cb4:	1000021e 	bne	r2,zero,2019cc0 <netif_find+0x20>
    return NULL;
 2019cb8:	0005883a 	mov	r2,zero
 2019cbc:	00002c06 	br	2019d70 <netif_find+0xd0>
  }

  num = name[2] - '0';
 2019cc0:	e0bfff17 	ldw	r2,-4(fp)
 2019cc4:	10800084 	addi	r2,r2,2
 2019cc8:	10800003 	ldbu	r2,0(r2)
 2019ccc:	10bff404 	addi	r2,r2,-48
 2019cd0:	e0bffe05 	stb	r2,-8(fp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 2019cd4:	d0a7f317 	ldw	r2,-24628(gp)
 2019cd8:	e0bffd15 	stw	r2,-12(fp)
 2019cdc:	00002106 	br	2019d64 <netif_find+0xc4>
    if (num == netif->num &&
 2019ce0:	e0bffd17 	ldw	r2,-12(fp)
 2019ce4:	10800f03 	ldbu	r2,60(r2)
 2019ce8:	10c03fcc 	andi	r3,r2,255
 2019cec:	e0bffe03 	ldbu	r2,-8(fp)
 2019cf0:	1880191e 	bne	r3,r2,2019d58 <netif_find+0xb8>
       name[0] == netif->name[0] &&
 2019cf4:	e0bfff17 	ldw	r2,-4(fp)
 2019cf8:	10c00003 	ldbu	r3,0(r2)
 2019cfc:	e0bffd17 	ldw	r2,-12(fp)
 2019d00:	10800e83 	ldbu	r2,58(r2)
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
 2019d04:	18c03fcc 	andi	r3,r3,255
 2019d08:	18c0201c 	xori	r3,r3,128
 2019d0c:	18ffe004 	addi	r3,r3,-128
 2019d10:	10803fcc 	andi	r2,r2,255
 2019d14:	1080201c 	xori	r2,r2,128
 2019d18:	10bfe004 	addi	r2,r2,-128
 2019d1c:	18800e1e 	bne	r3,r2,2019d58 <netif_find+0xb8>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
 2019d20:	e0bfff17 	ldw	r2,-4(fp)
 2019d24:	10800044 	addi	r2,r2,1
 2019d28:	10c00003 	ldbu	r3,0(r2)
 2019d2c:	e0bffd17 	ldw	r2,-12(fp)
 2019d30:	10800ec3 	ldbu	r2,59(r2)

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
 2019d34:	18c03fcc 	andi	r3,r3,255
 2019d38:	18c0201c 	xori	r3,r3,128
 2019d3c:	18ffe004 	addi	r3,r3,-128
 2019d40:	10803fcc 	andi	r2,r2,255
 2019d44:	1080201c 	xori	r2,r2,128
 2019d48:	10bfe004 	addi	r2,r2,-128
 2019d4c:	1880021e 	bne	r3,r2,2019d58 <netif_find+0xb8>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
 2019d50:	e0bffd17 	ldw	r2,-12(fp)
 2019d54:	00000606 	br	2019d70 <netif_find+0xd0>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 2019d58:	e0bffd17 	ldw	r2,-12(fp)
 2019d5c:	10800017 	ldw	r2,0(r2)
 2019d60:	e0bffd15 	stw	r2,-12(fp)
 2019d64:	e0bffd17 	ldw	r2,-12(fp)
 2019d68:	103fdd1e 	bne	r2,zero,2019ce0 <__alt_mem_mem_0+0xfcff9ce0>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
 2019d6c:	0005883a 	mov	r2,zero
}
 2019d70:	e037883a 	mov	sp,fp
 2019d74:	df000017 	ldw	fp,0(sp)
 2019d78:	dec00104 	addi	sp,sp,4
 2019d7c:	f800283a 	ret

02019d80 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 2019d80:	defff904 	addi	sp,sp,-28
 2019d84:	dfc00615 	stw	ra,24(sp)
 2019d88:	df000515 	stw	fp,20(sp)
 2019d8c:	df000504 	addi	fp,sp,20
 2019d90:	e13ffe15 	stw	r4,-8(fp)
 2019d94:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 2019d98:	e0bfff17 	ldw	r2,-4(fp)
 2019d9c:	10003426 	beq	r2,zero,2019e70 <netif_set_ipaddr+0xf0>
 2019da0:	e0bfff17 	ldw	r2,-4(fp)
 2019da4:	10c00017 	ldw	r3,0(r2)
 2019da8:	e0bffe17 	ldw	r2,-8(fp)
 2019dac:	10800117 	ldw	r2,4(r2)
 2019db0:	18802f26 	beq	r3,r2,2019e70 <netif_set_ipaddr+0xf0>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 2019db4:	d0a7f717 	ldw	r2,-24612(gp)
 2019db8:	e0bffb15 	stw	r2,-20(fp)
    while (pcb != NULL) {
 2019dbc:	00001006 	br	2019e00 <netif_set_ipaddr+0x80>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 2019dc0:	e0bffb17 	ldw	r2,-20(fp)
 2019dc4:	10c00017 	ldw	r3,0(r2)
 2019dc8:	e0bffe17 	ldw	r2,-8(fp)
 2019dcc:	10800117 	ldw	r2,4(r2)
 2019dd0:	1880081e 	bne	r3,r2,2019df4 <netif_set_ipaddr+0x74>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 2019dd4:	e0bffb17 	ldw	r2,-20(fp)
 2019dd8:	10800317 	ldw	r2,12(r2)
 2019ddc:	e0bffd15 	stw	r2,-12(fp)
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 2019de0:	e13ffb17 	ldw	r4,-20(fp)
 2019de4:	201bfb40 	call	201bfb4 <tcp_abort>
        pcb = next;
 2019de8:	e0bffd17 	ldw	r2,-12(fp)
 2019dec:	e0bffb15 	stw	r2,-20(fp)
 2019df0:	00000306 	br	2019e00 <netif_set_ipaddr+0x80>
      } else {
        pcb = pcb->next;
 2019df4:	e0bffb17 	ldw	r2,-20(fp)
 2019df8:	10800317 	ldw	r2,12(r2)
 2019dfc:	e0bffb15 	stw	r2,-20(fp)
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 2019e00:	e0bffb17 	ldw	r2,-20(fp)
 2019e04:	103fee1e 	bne	r2,zero,2019dc0 <__alt_mem_mem_0+0xfcff9dc0>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2019e08:	d0a7f917 	ldw	r2,-24604(gp)
 2019e0c:	e0bffc15 	stw	r2,-16(fp)
 2019e10:	00001506 	br	2019e68 <netif_set_ipaddr+0xe8>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 2019e14:	e0bffc17 	ldw	r2,-16(fp)
 2019e18:	10001026 	beq	r2,zero,2019e5c <netif_set_ipaddr+0xdc>
 2019e1c:	e0bffc17 	ldw	r2,-16(fp)
 2019e20:	10800017 	ldw	r2,0(r2)
 2019e24:	10000d26 	beq	r2,zero,2019e5c <netif_set_ipaddr+0xdc>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
 2019e28:	e0bffc17 	ldw	r2,-16(fp)
 2019e2c:	10c00017 	ldw	r3,0(r2)
 2019e30:	e0bffe17 	ldw	r2,-8(fp)
 2019e34:	10800117 	ldw	r2,4(r2)
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 2019e38:	1880081e 	bne	r3,r2,2019e5c <netif_set_ipaddr+0xdc>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 2019e3c:	e0bfff17 	ldw	r2,-4(fp)
 2019e40:	10000326 	beq	r2,zero,2019e50 <netif_set_ipaddr+0xd0>
 2019e44:	e0bfff17 	ldw	r2,-4(fp)
 2019e48:	10800017 	ldw	r2,0(r2)
 2019e4c:	00000106 	br	2019e54 <netif_set_ipaddr+0xd4>
 2019e50:	0005883a 	mov	r2,zero
 2019e54:	e0fffc17 	ldw	r3,-16(fp)
 2019e58:	18800015 	stw	r2,0(r3)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2019e5c:	e0bffc17 	ldw	r2,-16(fp)
 2019e60:	10800317 	ldw	r2,12(r2)
 2019e64:	e0bffc15 	stw	r2,-16(fp)
 2019e68:	e0bffc17 	ldw	r2,-16(fp)
 2019e6c:	103fe91e 	bne	r2,zero,2019e14 <__alt_mem_mem_0+0xfcff9e14>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 2019e70:	e0bfff17 	ldw	r2,-4(fp)
 2019e74:	10000326 	beq	r2,zero,2019e84 <netif_set_ipaddr+0x104>
 2019e78:	e0bfff17 	ldw	r2,-4(fp)
 2019e7c:	10800017 	ldw	r2,0(r2)
 2019e80:	00000106 	br	2019e88 <netif_set_ipaddr+0x108>
 2019e84:	0005883a 	mov	r2,zero
 2019e88:	e0fffe17 	ldw	r3,-8(fp)
 2019e8c:	18800115 	stw	r2,4(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 2019e90:	0001883a 	nop
 2019e94:	e037883a 	mov	sp,fp
 2019e98:	dfc00117 	ldw	ra,4(sp)
 2019e9c:	df000017 	ldw	fp,0(sp)
 2019ea0:	dec00204 	addi	sp,sp,8
 2019ea4:	f800283a 	ret

02019ea8 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
 2019ea8:	defffd04 	addi	sp,sp,-12
 2019eac:	df000215 	stw	fp,8(sp)
 2019eb0:	df000204 	addi	fp,sp,8
 2019eb4:	e13ffe15 	stw	r4,-8(fp)
 2019eb8:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&(netif->gw), gw);
 2019ebc:	e0bfff17 	ldw	r2,-4(fp)
 2019ec0:	10000326 	beq	r2,zero,2019ed0 <netif_set_gw+0x28>
 2019ec4:	e0bfff17 	ldw	r2,-4(fp)
 2019ec8:	10800017 	ldw	r2,0(r2)
 2019ecc:	00000106 	br	2019ed4 <netif_set_gw+0x2c>
 2019ed0:	0005883a 	mov	r2,zero
 2019ed4:	e0fffe17 	ldw	r3,-8(fp)
 2019ed8:	18800315 	stw	r2,12(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
 2019edc:	0001883a 	nop
 2019ee0:	e037883a 	mov	sp,fp
 2019ee4:	df000017 	ldw	fp,0(sp)
 2019ee8:	dec00104 	addi	sp,sp,4
 2019eec:	f800283a 	ret

02019ef0 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
 2019ef0:	defffd04 	addi	sp,sp,-12
 2019ef4:	df000215 	stw	fp,8(sp)
 2019ef8:	df000204 	addi	fp,sp,8
 2019efc:	e13ffe15 	stw	r4,-8(fp)
 2019f00:	e17fff15 	stw	r5,-4(fp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 2019f04:	e0bfff17 	ldw	r2,-4(fp)
 2019f08:	10000326 	beq	r2,zero,2019f18 <netif_set_netmask+0x28>
 2019f0c:	e0bfff17 	ldw	r2,-4(fp)
 2019f10:	10800017 	ldw	r2,0(r2)
 2019f14:	00000106 	br	2019f1c <netif_set_netmask+0x2c>
 2019f18:	0005883a 	mov	r2,zero
 2019f1c:	e0fffe17 	ldw	r3,-8(fp)
 2019f20:	18800215 	stw	r2,8(r3)
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
 2019f24:	0001883a 	nop
 2019f28:	e037883a 	mov	sp,fp
 2019f2c:	df000017 	ldw	fp,0(sp)
 2019f30:	dec00104 	addi	sp,sp,4
 2019f34:	f800283a 	ret

02019f38 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 2019f38:	defffe04 	addi	sp,sp,-8
 2019f3c:	df000115 	stw	fp,4(sp)
 2019f40:	df000104 	addi	fp,sp,4
 2019f44:	e13fff15 	stw	r4,-4(fp)
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 2019f48:	e0bfff17 	ldw	r2,-4(fp)
 2019f4c:	d0a7f415 	stw	r2,-24624(gp)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 2019f50:	0001883a 	nop
 2019f54:	e037883a 	mov	sp,fp
 2019f58:	df000017 	ldw	fp,0(sp)
 2019f5c:	dec00104 	addi	sp,sp,4
 2019f60:	f800283a 	ret

02019f64 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 2019f64:	defffd04 	addi	sp,sp,-12
 2019f68:	dfc00215 	stw	ra,8(sp)
 2019f6c:	df000115 	stw	fp,4(sp)
 2019f70:	df000104 	addi	fp,sp,4
 2019f74:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_UP)) {
 2019f78:	e0bfff17 	ldw	r2,-4(fp)
 2019f7c:	10800e43 	ldbu	r2,57(r2)
 2019f80:	10803fcc 	andi	r2,r2,255
 2019f84:	1080004c 	andi	r2,r2,1
 2019f88:	10001c1e 	bne	r2,zero,2019ffc <netif_set_up+0x98>
    netif->flags |= NETIF_FLAG_UP;
 2019f8c:	e0bfff17 	ldw	r2,-4(fp)
 2019f90:	10800e43 	ldbu	r2,57(r2)
 2019f94:	10800054 	ori	r2,r2,1
 2019f98:	1007883a 	mov	r3,r2
 2019f9c:	e0bfff17 	ldw	r2,-4(fp)
 2019fa0:	10c00e45 	stb	r3,57(r2)
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);
 2019fa4:	e0bfff17 	ldw	r2,-4(fp)
 2019fa8:	10800717 	ldw	r2,28(r2)
 2019fac:	10000426 	beq	r2,zero,2019fc0 <netif_set_up+0x5c>
 2019fb0:	e0bfff17 	ldw	r2,-4(fp)
 2019fb4:	10800717 	ldw	r2,28(r2)
 2019fb8:	e13fff17 	ldw	r4,-4(fp)
 2019fbc:	103ee83a 	callr	r2

    if (netif->flags & NETIF_FLAG_LINK_UP) {
 2019fc0:	e0bfff17 	ldw	r2,-4(fp)
 2019fc4:	10800e43 	ldbu	r2,57(r2)
 2019fc8:	10803fcc 	andi	r2,r2,255
 2019fcc:	1080040c 	andi	r2,r2,16
 2019fd0:	10000a26 	beq	r2,zero,2019ffc <netif_set_up+0x98>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 2019fd4:	e0bfff17 	ldw	r2,-4(fp)
 2019fd8:	10800e43 	ldbu	r2,57(r2)
 2019fdc:	10803fcc 	andi	r2,r2,255
 2019fe0:	1080080c 	andi	r2,r2,32
 2019fe4:	10000526 	beq	r2,zero,2019ffc <netif_set_up+0x98>
        etharp_gratuitous(netif);
 2019fe8:	e0bfff17 	ldw	r2,-4(fp)
 2019fec:	10800104 	addi	r2,r2,4
 2019ff0:	100b883a 	mov	r5,r2
 2019ff4:	e13fff17 	ldw	r4,-4(fp)
 2019ff8:	20243480 	call	2024348 <etharp_request>
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
  }
}
 2019ffc:	0001883a 	nop
 201a000:	e037883a 	mov	sp,fp
 201a004:	dfc00117 	ldw	ra,4(sp)
 201a008:	df000017 	ldw	fp,0(sp)
 201a00c:	dec00204 	addi	sp,sp,8
 201a010:	f800283a 	ret

0201a014 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
 201a014:	defffd04 	addi	sp,sp,-12
 201a018:	dfc00215 	stw	ra,8(sp)
 201a01c:	df000115 	stw	fp,4(sp)
 201a020:	df000104 	addi	fp,sp,4
 201a024:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_UP) {
 201a028:	e0bfff17 	ldw	r2,-4(fp)
 201a02c:	10800e43 	ldbu	r2,57(r2)
 201a030:	10803fcc 	andi	r2,r2,255
 201a034:	1080004c 	andi	r2,r2,1
 201a038:	10001526 	beq	r2,zero,201a090 <netif_set_down+0x7c>
    netif->flags &= ~NETIF_FLAG_UP;
 201a03c:	e0bfff17 	ldw	r2,-4(fp)
 201a040:	10c00e43 	ldbu	r3,57(r2)
 201a044:	00bfff84 	movi	r2,-2
 201a048:	1884703a 	and	r2,r3,r2
 201a04c:	1007883a 	mov	r3,r2
 201a050:	e0bfff17 	ldw	r2,-4(fp)
 201a054:	10c00e45 	stb	r3,57(r2)
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 201a058:	e0bfff17 	ldw	r2,-4(fp)
 201a05c:	10800e43 	ldbu	r2,57(r2)
 201a060:	10803fcc 	andi	r2,r2,255
 201a064:	1080080c 	andi	r2,r2,32
 201a068:	10000226 	beq	r2,zero,201a074 <netif_set_down+0x60>
      etharp_cleanup_netif(netif);
 201a06c:	e13fff17 	ldw	r4,-4(fp)
 201a070:	20233780 	call	2023378 <etharp_cleanup_netif>
    }
#endif /* LWIP_ARP */
    NETIF_STATUS_CALLBACK(netif);
 201a074:	e0bfff17 	ldw	r2,-4(fp)
 201a078:	10800717 	ldw	r2,28(r2)
 201a07c:	10000426 	beq	r2,zero,201a090 <netif_set_down+0x7c>
 201a080:	e0bfff17 	ldw	r2,-4(fp)
 201a084:	10800717 	ldw	r2,28(r2)
 201a088:	e13fff17 	ldw	r4,-4(fp)
 201a08c:	103ee83a 	callr	r2
  }
}
 201a090:	0001883a 	nop
 201a094:	e037883a 	mov	sp,fp
 201a098:	dfc00117 	ldw	ra,4(sp)
 201a09c:	df000017 	ldw	fp,0(sp)
 201a0a0:	dec00204 	addi	sp,sp,8
 201a0a4:	f800283a 	ret

0201a0a8 <netif_set_status_callback>:
#if LWIP_NETIF_STATUS_CALLBACK
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
 201a0a8:	defffd04 	addi	sp,sp,-12
 201a0ac:	df000215 	stw	fp,8(sp)
 201a0b0:	df000204 	addi	fp,sp,8
 201a0b4:	e13ffe15 	stw	r4,-8(fp)
 201a0b8:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
 201a0bc:	e0bffe17 	ldw	r2,-8(fp)
 201a0c0:	10000326 	beq	r2,zero,201a0d0 <netif_set_status_callback+0x28>
    netif->status_callback = status_callback;
 201a0c4:	e0bffe17 	ldw	r2,-8(fp)
 201a0c8:	e0ffff17 	ldw	r3,-4(fp)
 201a0cc:	10c00715 	stw	r3,28(r2)
  }
}
 201a0d0:	0001883a 	nop
 201a0d4:	e037883a 	mov	sp,fp
 201a0d8:	df000017 	ldw	fp,0(sp)
 201a0dc:	dec00104 	addi	sp,sp,4
 201a0e0:	f800283a 	ret

0201a0e4 <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 201a0e4:	defffd04 	addi	sp,sp,-12
 201a0e8:	dfc00215 	stw	ra,8(sp)
 201a0ec:	df000115 	stw	fp,4(sp)
 201a0f0:	df000104 	addi	fp,sp,4
 201a0f4:	e13fff15 	stw	r4,-4(fp)
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 201a0f8:	e0bfff17 	ldw	r2,-4(fp)
 201a0fc:	10800e43 	ldbu	r2,57(r2)
 201a100:	10803fcc 	andi	r2,r2,255
 201a104:	1080040c 	andi	r2,r2,16
 201a108:	1000211e 	bne	r2,zero,201a190 <netif_set_link_up+0xac>
    netif->flags |= NETIF_FLAG_LINK_UP;
 201a10c:	e0bfff17 	ldw	r2,-4(fp)
 201a110:	10800e43 	ldbu	r2,57(r2)
 201a114:	10800414 	ori	r2,r2,16
 201a118:	1007883a 	mov	r3,r2
 201a11c:	e0bfff17 	ldw	r2,-4(fp)
 201a120:	10c00e45 	stb	r3,57(r2)

#if LWIP_DHCP
    if (netif->dhcp) {
 201a124:	e0bfff17 	ldw	r2,-4(fp)
 201a128:	10800a17 	ldw	r2,40(r2)
 201a12c:	10000226 	beq	r2,zero,201a138 <netif_set_link_up+0x54>
      dhcp_network_changed(netif);
 201a130:	e13fff17 	ldw	r4,-4(fp)
 201a134:	20164b00 	call	20164b0 <dhcp_network_changed>
    if (netif->autoip) {
      autoip_network_changed(netif);
    }
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
 201a138:	e0bfff17 	ldw	r2,-4(fp)
 201a13c:	10800e43 	ldbu	r2,57(r2)
 201a140:	10803fcc 	andi	r2,r2,255
 201a144:	1080004c 	andi	r2,r2,1
 201a148:	10000a26 	beq	r2,zero,201a174 <netif_set_link_up+0x90>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 201a14c:	e0bfff17 	ldw	r2,-4(fp)
 201a150:	10800e43 	ldbu	r2,57(r2)
 201a154:	10803fcc 	andi	r2,r2,255
 201a158:	1080080c 	andi	r2,r2,32
 201a15c:	10000526 	beq	r2,zero,201a174 <netif_set_link_up+0x90>
        etharp_gratuitous(netif);
 201a160:	e0bfff17 	ldw	r2,-4(fp)
 201a164:	10800104 	addi	r2,r2,4
 201a168:	100b883a 	mov	r5,r2
 201a16c:	e13fff17 	ldw	r4,-4(fp)
 201a170:	20243480 	call	2024348 <etharp_request>
      if (netif->flags & NETIF_FLAG_IGMP) {
        igmp_report_groups( netif);
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
 201a174:	e0bfff17 	ldw	r2,-4(fp)
 201a178:	10800817 	ldw	r2,32(r2)
 201a17c:	10000426 	beq	r2,zero,201a190 <netif_set_link_up+0xac>
 201a180:	e0bfff17 	ldw	r2,-4(fp)
 201a184:	10800817 	ldw	r2,32(r2)
 201a188:	e13fff17 	ldw	r4,-4(fp)
 201a18c:	103ee83a 	callr	r2
  }
}
 201a190:	0001883a 	nop
 201a194:	e037883a 	mov	sp,fp
 201a198:	dfc00117 	ldw	ra,4(sp)
 201a19c:	df000017 	ldw	fp,0(sp)
 201a1a0:	dec00204 	addi	sp,sp,8
 201a1a4:	f800283a 	ret

0201a1a8 <netif_set_link_down>:

/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
 201a1a8:	defffd04 	addi	sp,sp,-12
 201a1ac:	dfc00215 	stw	ra,8(sp)
 201a1b0:	df000115 	stw	fp,4(sp)
 201a1b4:	df000104 	addi	fp,sp,4
 201a1b8:	e13fff15 	stw	r4,-4(fp)
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 201a1bc:	e0bfff17 	ldw	r2,-4(fp)
 201a1c0:	10800e43 	ldbu	r2,57(r2)
 201a1c4:	10803fcc 	andi	r2,r2,255
 201a1c8:	1080040c 	andi	r2,r2,16
 201a1cc:	10000e26 	beq	r2,zero,201a208 <netif_set_link_down+0x60>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 201a1d0:	e0bfff17 	ldw	r2,-4(fp)
 201a1d4:	10c00e43 	ldbu	r3,57(r2)
 201a1d8:	00bffbc4 	movi	r2,-17
 201a1dc:	1884703a 	and	r2,r3,r2
 201a1e0:	1007883a 	mov	r3,r2
 201a1e4:	e0bfff17 	ldw	r2,-4(fp)
 201a1e8:	10c00e45 	stb	r3,57(r2)
    NETIF_LINK_CALLBACK(netif);
 201a1ec:	e0bfff17 	ldw	r2,-4(fp)
 201a1f0:	10800817 	ldw	r2,32(r2)
 201a1f4:	10000426 	beq	r2,zero,201a208 <netif_set_link_down+0x60>
 201a1f8:	e0bfff17 	ldw	r2,-4(fp)
 201a1fc:	10800817 	ldw	r2,32(r2)
 201a200:	e13fff17 	ldw	r4,-4(fp)
 201a204:	103ee83a 	callr	r2
  }
}
 201a208:	0001883a 	nop
 201a20c:	e037883a 	mov	sp,fp
 201a210:	dfc00117 	ldw	ra,4(sp)
 201a214:	df000017 	ldw	fp,0(sp)
 201a218:	dec00204 	addi	sp,sp,8
 201a21c:	f800283a 	ret

0201a220 <netif_set_link_callback>:
#if LWIP_NETIF_LINK_CALLBACK
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
 201a220:	defffd04 	addi	sp,sp,-12
 201a224:	df000215 	stw	fp,8(sp)
 201a228:	df000204 	addi	fp,sp,8
 201a22c:	e13ffe15 	stw	r4,-8(fp)
 201a230:	e17fff15 	stw	r5,-4(fp)
  if (netif) {
 201a234:	e0bffe17 	ldw	r2,-8(fp)
 201a238:	10000326 	beq	r2,zero,201a248 <netif_set_link_callback+0x28>
    netif->link_callback = link_callback;
 201a23c:	e0bffe17 	ldw	r2,-8(fp)
 201a240:	e0ffff17 	ldw	r3,-4(fp)
 201a244:	10c00815 	stw	r3,32(r2)
  }
}
 201a248:	0001883a 	nop
 201a24c:	e037883a 	mov	sp,fp
 201a250:	df000017 	ldw	fp,0(sp)
 201a254:	dec00104 	addi	sp,sp,4
 201a258:	f800283a 	ret

0201a25c <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
 201a25c:	defffd04 	addi	sp,sp,-12
 201a260:	dfc00215 	stw	ra,8(sp)
 201a264:	df000115 	stw	fp,4(sp)
 201a268:	df000104 	addi	fp,sp,4
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
 201a26c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a270:	10000126 	beq	r2,zero,201a278 <pbuf_free_ooseq+0x1c>
 201a274:	2010f300 	call	2010f30 <vTaskEnterCritical>
  pbuf_free_ooseq_pending = 0;
 201a278:	d027f505 	stb	zero,-24620(gp)
  SYS_ARCH_UNPROTECT(old_level);
 201a27c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a280:	10000126 	beq	r2,zero,201a288 <pbuf_free_ooseq+0x2c>
 201a284:	2010f780 	call	2010f78 <vTaskExitCritical>

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 201a288:	d0a7f717 	ldw	r2,-24612(gp)
 201a28c:	e0bfff15 	stw	r2,-4(fp)
 201a290:	00000d06 	br	201a2c8 <pbuf_free_ooseq+0x6c>
    if (NULL != pcb->ooseq) {
 201a294:	e0bfff17 	ldw	r2,-4(fp)
 201a298:	10801e17 	ldw	r2,120(r2)
 201a29c:	10000726 	beq	r2,zero,201a2bc <pbuf_free_ooseq+0x60>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
 201a2a0:	e0bfff17 	ldw	r2,-4(fp)
 201a2a4:	10801e17 	ldw	r2,120(r2)
 201a2a8:	1009883a 	mov	r4,r2
 201a2ac:	201d3dc0 	call	201d3dc <tcp_segs_free>
      pcb->ooseq = NULL;
 201a2b0:	e0bfff17 	ldw	r2,-4(fp)
 201a2b4:	10001e15 	stw	zero,120(r2)
      return;
 201a2b8:	00000506 	br	201a2d0 <pbuf_free_ooseq+0x74>

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
 201a2bc:	e0bfff17 	ldw	r2,-4(fp)
 201a2c0:	10800317 	ldw	r2,12(r2)
 201a2c4:	e0bfff15 	stw	r2,-4(fp)
 201a2c8:	e0bfff17 	ldw	r2,-4(fp)
 201a2cc:	103ff11e 	bne	r2,zero,201a294 <__alt_mem_mem_0+0xfcffa294>
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      return;
    }
  }
}
 201a2d0:	e037883a 	mov	sp,fp
 201a2d4:	dfc00117 	ldw	ra,4(sp)
 201a2d8:	df000017 	ldw	fp,0(sp)
 201a2dc:	dec00204 	addi	sp,sp,8
 201a2e0:	f800283a 	ret

0201a2e4 <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
 201a2e4:	defffd04 	addi	sp,sp,-12
 201a2e8:	dfc00215 	stw	ra,8(sp)
 201a2ec:	df000115 	stw	fp,4(sp)
 201a2f0:	df000104 	addi	fp,sp,4
 201a2f4:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
 201a2f8:	201a25c0 	call	201a25c <pbuf_free_ooseq>
}
 201a2fc:	0001883a 	nop
 201a300:	e037883a 	mov	sp,fp
 201a304:	dfc00117 	ldw	ra,4(sp)
 201a308:	df000017 	ldw	fp,0(sp)
 201a30c:	dec00204 	addi	sp,sp,8
 201a310:	f800283a 	ret

0201a314 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
 201a314:	defffd04 	addi	sp,sp,-12
 201a318:	dfc00215 	stw	ra,8(sp)
 201a31c:	df000115 	stw	fp,4(sp)
 201a320:	df000104 	addi	fp,sp,4
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
 201a324:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a328:	10000126 	beq	r2,zero,201a330 <pbuf_pool_is_empty+0x1c>
 201a32c:	2010f300 	call	2010f30 <vTaskEnterCritical>
  queued = pbuf_free_ooseq_pending;
 201a330:	d0a7f503 	ldbu	r2,-24620(gp)
 201a334:	e0bfff05 	stb	r2,-4(fp)
  pbuf_free_ooseq_pending = 1;
 201a338:	00800044 	movi	r2,1
 201a33c:	d0a7f505 	stb	r2,-24620(gp)
  SYS_ARCH_UNPROTECT(old_level);
 201a340:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a344:	10000126 	beq	r2,zero,201a34c <pbuf_pool_is_empty+0x38>
 201a348:	2010f780 	call	2010f78 <vTaskExitCritical>

  if(!queued) {
 201a34c:	e0bfff03 	ldbu	r2,-4(fp)
 201a350:	1000101e 	bne	r2,zero,201a394 <pbuf_pool_is_empty+0x80>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
 201a354:	000d883a 	mov	r6,zero
 201a358:	000b883a 	mov	r5,zero
 201a35c:	010080b4 	movhi	r4,514
 201a360:	2128b904 	addi	r4,r4,-23836
 201a364:	20307d40 	call	20307d4 <tcpip_callback_with_block>
 201a368:	10803fcc 	andi	r2,r2,255
 201a36c:	1080201c 	xori	r2,r2,128
 201a370:	10bfe004 	addi	r2,r2,-128
 201a374:	10000726 	beq	r2,zero,201a394 <pbuf_pool_is_empty+0x80>
 201a378:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a37c:	10000126 	beq	r2,zero,201a384 <pbuf_pool_is_empty+0x70>
 201a380:	2010f300 	call	2010f30 <vTaskEnterCritical>
 201a384:	d027f505 	stb	zero,-24620(gp)
 201a388:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201a38c:	10000126 	beq	r2,zero,201a394 <pbuf_pool_is_empty+0x80>
 201a390:	2010f780 	call	2010f78 <vTaskExitCritical>
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
 201a394:	0001883a 	nop
 201a398:	e037883a 	mov	sp,fp
 201a39c:	dfc00117 	ldw	ra,4(sp)
 201a3a0:	df000017 	ldw	fp,0(sp)
 201a3a4:	dec00204 	addi	sp,sp,8
 201a3a8:	f800283a 	ret

0201a3ac <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 201a3ac:	defff604 	addi	sp,sp,-40
 201a3b0:	dfc00915 	stw	ra,36(sp)
 201a3b4:	df000815 	stw	fp,32(sp)
 201a3b8:	df000804 	addi	fp,sp,32
 201a3bc:	e13ffd15 	stw	r4,-12(fp)
 201a3c0:	2805883a 	mov	r2,r5
 201a3c4:	e1bfff15 	stw	r6,-4(fp)
 201a3c8:	e0bffe0d 	sth	r2,-8(fp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 201a3cc:	e0bffd17 	ldw	r2,-12(fp)
 201a3d0:	10c00060 	cmpeqi	r3,r2,1
 201a3d4:	1800091e 	bne	r3,zero,201a3fc <pbuf_alloc+0x50>
 201a3d8:	0080052e 	bgeu	zero,r2,201a3f0 <pbuf_alloc+0x44>
 201a3dc:	10c000a0 	cmpeqi	r3,r2,2
 201a3e0:	1800091e 	bne	r3,zero,201a408 <pbuf_alloc+0x5c>
 201a3e4:	108000e0 	cmpeqi	r2,r2,3
 201a3e8:	10000a1e 	bne	r2,zero,201a414 <pbuf_alloc+0x68>
 201a3ec:	00000b06 	br	201a41c <pbuf_alloc+0x70>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 201a3f0:	00800e04 	movi	r2,56
 201a3f4:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a3f8:	00000a06 	br	201a424 <pbuf_alloc+0x78>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 201a3fc:	00800904 	movi	r2,36
 201a400:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a404:	00000706 	br	201a424 <pbuf_alloc+0x78>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 201a408:	00800404 	movi	r2,16
 201a40c:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a410:	00000406 	br	201a424 <pbuf_alloc+0x78>
  case PBUF_RAW:
    offset = 0;
 201a414:	e03ffa0d 	sth	zero,-24(fp)
    break;
 201a418:	00000206 	br	201a424 <pbuf_alloc+0x78>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
 201a41c:	0005883a 	mov	r2,zero
 201a420:	0000b806 	br	201a704 <pbuf_alloc+0x358>
  }

  switch (type) {
 201a424:	e0bfff17 	ldw	r2,-4(fp)
 201a428:	10c000e8 	cmpgeui	r3,r2,3
 201a42c:	1800021e 	bne	r3,zero,201a438 <pbuf_alloc+0x8c>
 201a430:	00809536 	bltu	zero,r2,201a688 <pbuf_alloc+0x2dc>
 201a434:	00006806 	br	201a5d8 <pbuf_alloc+0x22c>
 201a438:	108000e0 	cmpeqi	r2,r2,3
 201a43c:	1000a926 	beq	r2,zero,201a6e4 <pbuf_alloc+0x338>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 201a440:	01000384 	movi	r4,14
 201a444:	20344340 	call	2034434 <memp_malloc>
 201a448:	e0bff815 	stw	r2,-32(fp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 201a44c:	e0bff817 	ldw	r2,-32(fp)
 201a450:	1000031e 	bne	r2,zero,201a460 <pbuf_alloc+0xb4>
      PBUF_POOL_IS_EMPTY();
 201a454:	201a3140 	call	201a314 <pbuf_pool_is_empty>
      return NULL;
 201a458:	0005883a 	mov	r2,zero
 201a45c:	0000a906 	br	201a704 <pbuf_alloc+0x358>
    }
    p->type = type;
 201a460:	e0bfff17 	ldw	r2,-4(fp)
 201a464:	1007883a 	mov	r3,r2
 201a468:	e0bff817 	ldw	r2,-32(fp)
 201a46c:	10c00305 	stb	r3,12(r2)
    p->next = NULL;
 201a470:	e0bff817 	ldw	r2,-32(fp)
 201a474:	10000015 	stw	zero,0(r2)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 201a478:	e0bffa0b 	ldhu	r2,-24(fp)
 201a47c:	10800404 	addi	r2,r2,16
 201a480:	e0fff817 	ldw	r3,-32(fp)
 201a484:	1885883a 	add	r2,r3,r2
 201a488:	10c000c4 	addi	r3,r2,3
 201a48c:	00bfff04 	movi	r2,-4
 201a490:	1884703a 	and	r2,r3,r2
 201a494:	1007883a 	mov	r3,r2
 201a498:	e0bff817 	ldw	r2,-32(fp)
 201a49c:	10c00115 	stw	r3,4(r2)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 201a4a0:	e0bff817 	ldw	r2,-32(fp)
 201a4a4:	e0fffe0b 	ldhu	r3,-8(fp)
 201a4a8:	10c0020d 	sth	r3,8(r2)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 201a4ac:	e0bffa0b 	ldhu	r2,-24(fp)
 201a4b0:	10c000c4 	addi	r3,r2,3
 201a4b4:	00bfff04 	movi	r2,-4
 201a4b8:	1884703a 	and	r2,r3,r2
 201a4bc:	00c17b04 	movi	r3,1516
 201a4c0:	1885c83a 	sub	r2,r3,r2
 201a4c4:	e0fffe0b 	ldhu	r3,-8(fp)
 201a4c8:	1880010e 	bge	r3,r2,201a4d0 <pbuf_alloc+0x124>
 201a4cc:	1805883a 	mov	r2,r3
 201a4d0:	1007883a 	mov	r3,r2
 201a4d4:	e0bff817 	ldw	r2,-32(fp)
 201a4d8:	10c0028d 	sth	r3,10(r2)
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 201a4dc:	e0bff817 	ldw	r2,-32(fp)
 201a4e0:	00c00044 	movi	r3,1
 201a4e4:	10c0038d 	sth	r3,14(r2)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
 201a4e8:	e0bff817 	ldw	r2,-32(fp)
 201a4ec:	e0bff915 	stw	r2,-28(fp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
 201a4f0:	e0fffe0b 	ldhu	r3,-8(fp)
 201a4f4:	e0bff817 	ldw	r2,-32(fp)
 201a4f8:	1080028b 	ldhu	r2,10(r2)
 201a4fc:	10bfffcc 	andi	r2,r2,65535
 201a500:	1885c83a 	sub	r2,r3,r2
 201a504:	e0bffb15 	stw	r2,-20(fp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 201a508:	00003006 	br	201a5cc <pbuf_alloc+0x220>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 201a50c:	01000384 	movi	r4,14
 201a510:	20344340 	call	2034434 <memp_malloc>
 201a514:	e0bffc15 	stw	r2,-16(fp)
      if (q == NULL) {
 201a518:	e0bffc17 	ldw	r2,-16(fp)
 201a51c:	1000051e 	bne	r2,zero,201a534 <pbuf_alloc+0x188>
        PBUF_POOL_IS_EMPTY();
 201a520:	201a3140 	call	201a314 <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
 201a524:	e13ff817 	ldw	r4,-32(fp)
 201a528:	201ab680 	call	201ab68 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 201a52c:	0005883a 	mov	r2,zero
 201a530:	00007406 	br	201a704 <pbuf_alloc+0x358>
      }
      q->type = type;
 201a534:	e0bfff17 	ldw	r2,-4(fp)
 201a538:	1007883a 	mov	r3,r2
 201a53c:	e0bffc17 	ldw	r2,-16(fp)
 201a540:	10c00305 	stb	r3,12(r2)
      q->flags = 0;
 201a544:	e0bffc17 	ldw	r2,-16(fp)
 201a548:	10000345 	stb	zero,13(r2)
      q->next = NULL;
 201a54c:	e0bffc17 	ldw	r2,-16(fp)
 201a550:	10000015 	stw	zero,0(r2)
      /* make previous pbuf point to this pbuf */
      r->next = q;
 201a554:	e0bff917 	ldw	r2,-28(fp)
 201a558:	e0fffc17 	ldw	r3,-16(fp)
 201a55c:	10c00015 	stw	r3,0(r2)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 201a560:	e0bffb17 	ldw	r2,-20(fp)
 201a564:	1007883a 	mov	r3,r2
 201a568:	e0bffc17 	ldw	r2,-16(fp)
 201a56c:	10c0020d 	sth	r3,8(r2)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 201a570:	e0bffb17 	ldw	r2,-20(fp)
 201a574:	10bfffcc 	andi	r2,r2,65535
 201a578:	10c17b50 	cmplti	r3,r2,1517
 201a57c:	1800011e 	bne	r3,zero,201a584 <pbuf_alloc+0x1d8>
 201a580:	00817b04 	movi	r2,1516
 201a584:	1007883a 	mov	r3,r2
 201a588:	e0bffc17 	ldw	r2,-16(fp)
 201a58c:	10c0028d 	sth	r3,10(r2)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 201a590:	e0bffc17 	ldw	r2,-16(fp)
 201a594:	10c00404 	addi	r3,r2,16
 201a598:	e0bffc17 	ldw	r2,-16(fp)
 201a59c:	10c00115 	stw	r3,4(r2)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 201a5a0:	e0bffc17 	ldw	r2,-16(fp)
 201a5a4:	00c00044 	movi	r3,1
 201a5a8:	10c0038d 	sth	r3,14(r2)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 201a5ac:	e0bffc17 	ldw	r2,-16(fp)
 201a5b0:	1080028b 	ldhu	r2,10(r2)
 201a5b4:	10bfffcc 	andi	r2,r2,65535
 201a5b8:	e0fffb17 	ldw	r3,-20(fp)
 201a5bc:	1885c83a 	sub	r2,r3,r2
 201a5c0:	e0bffb15 	stw	r2,-20(fp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
 201a5c4:	e0bffc17 	ldw	r2,-16(fp)
 201a5c8:	e0bff915 	stw	r2,-28(fp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 201a5cc:	e0bffb17 	ldw	r2,-20(fp)
 201a5d0:	00bfce16 	blt	zero,r2,201a50c <__alt_mem_mem_0+0xfcffa50c>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
 201a5d4:	00004506 	br	201a6ec <pbuf_alloc+0x340>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 201a5d8:	e0bffa0b 	ldhu	r2,-24(fp)
 201a5dc:	108004c4 	addi	r2,r2,19
 201a5e0:	1007883a 	mov	r3,r2
 201a5e4:	00bfff04 	movi	r2,-4
 201a5e8:	1884703a 	and	r2,r3,r2
 201a5ec:	1007883a 	mov	r3,r2
 201a5f0:	e0bffe0b 	ldhu	r2,-8(fp)
 201a5f4:	108000c4 	addi	r2,r2,3
 201a5f8:	1009883a 	mov	r4,r2
 201a5fc:	00bfff04 	movi	r2,-4
 201a600:	2084703a 	and	r2,r4,r2
 201a604:	1885883a 	add	r2,r3,r2
 201a608:	10bfffcc 	andi	r2,r2,65535
 201a60c:	1009883a 	mov	r4,r2
 201a610:	20196b40 	call	20196b4 <mem_malloc>
 201a614:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
 201a618:	e0bff817 	ldw	r2,-32(fp)
 201a61c:	1000021e 	bne	r2,zero,201a628 <pbuf_alloc+0x27c>
      return NULL;
 201a620:	0005883a 	mov	r2,zero
 201a624:	00003706 	br	201a704 <pbuf_alloc+0x358>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 201a628:	e0bffa0b 	ldhu	r2,-24(fp)
 201a62c:	10800404 	addi	r2,r2,16
 201a630:	e0fff817 	ldw	r3,-32(fp)
 201a634:	1885883a 	add	r2,r3,r2
 201a638:	10c000c4 	addi	r3,r2,3
 201a63c:	00bfff04 	movi	r2,-4
 201a640:	1884703a 	and	r2,r3,r2
 201a644:	1007883a 	mov	r3,r2
 201a648:	e0bff817 	ldw	r2,-32(fp)
 201a64c:	10c00115 	stw	r3,4(r2)
    p->len = p->tot_len = length;
 201a650:	e0bff817 	ldw	r2,-32(fp)
 201a654:	e0fffe0b 	ldhu	r3,-8(fp)
 201a658:	10c0020d 	sth	r3,8(r2)
 201a65c:	e0bff817 	ldw	r2,-32(fp)
 201a660:	10c0020b 	ldhu	r3,8(r2)
 201a664:	e0bff817 	ldw	r2,-32(fp)
 201a668:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
 201a66c:	e0bff817 	ldw	r2,-32(fp)
 201a670:	10000015 	stw	zero,0(r2)
    p->type = type;
 201a674:	e0bfff17 	ldw	r2,-4(fp)
 201a678:	1007883a 	mov	r3,r2
 201a67c:	e0bff817 	ldw	r2,-32(fp)
 201a680:	10c00305 	stb	r3,12(r2)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
 201a684:	00001906 	br	201a6ec <pbuf_alloc+0x340>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 201a688:	01000344 	movi	r4,13
 201a68c:	20344340 	call	2034434 <memp_malloc>
 201a690:	e0bff815 	stw	r2,-32(fp)
    if (p == NULL) {
 201a694:	e0bff817 	ldw	r2,-32(fp)
 201a698:	1000021e 	bne	r2,zero,201a6a4 <pbuf_alloc+0x2f8>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
 201a69c:	0005883a 	mov	r2,zero
 201a6a0:	00001806 	br	201a704 <pbuf_alloc+0x358>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 201a6a4:	e0bff817 	ldw	r2,-32(fp)
 201a6a8:	10000115 	stw	zero,4(r2)
    p->len = p->tot_len = length;
 201a6ac:	e0bff817 	ldw	r2,-32(fp)
 201a6b0:	e0fffe0b 	ldhu	r3,-8(fp)
 201a6b4:	10c0020d 	sth	r3,8(r2)
 201a6b8:	e0bff817 	ldw	r2,-32(fp)
 201a6bc:	10c0020b 	ldhu	r3,8(r2)
 201a6c0:	e0bff817 	ldw	r2,-32(fp)
 201a6c4:	10c0028d 	sth	r3,10(r2)
    p->next = NULL;
 201a6c8:	e0bff817 	ldw	r2,-32(fp)
 201a6cc:	10000015 	stw	zero,0(r2)
    p->type = type;
 201a6d0:	e0bfff17 	ldw	r2,-4(fp)
 201a6d4:	1007883a 	mov	r3,r2
 201a6d8:	e0bff817 	ldw	r2,-32(fp)
 201a6dc:	10c00305 	stb	r3,12(r2)
    break;
 201a6e0:	00000206 	br	201a6ec <pbuf_alloc+0x340>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 201a6e4:	0005883a 	mov	r2,zero
 201a6e8:	00000606 	br	201a704 <pbuf_alloc+0x358>
  }
  /* set reference count */
  p->ref = 1;
 201a6ec:	e0bff817 	ldw	r2,-32(fp)
 201a6f0:	00c00044 	movi	r3,1
 201a6f4:	10c0038d 	sth	r3,14(r2)
  /* set flags */
  p->flags = 0;
 201a6f8:	e0bff817 	ldw	r2,-32(fp)
 201a6fc:	10000345 	stb	zero,13(r2)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 201a700:	e0bff817 	ldw	r2,-32(fp)
}
 201a704:	e037883a 	mov	sp,fp
 201a708:	dfc00117 	ldw	ra,4(sp)
 201a70c:	df000017 	ldw	fp,0(sp)
 201a710:	dec00204 	addi	sp,sp,8
 201a714:	f800283a 	ret

0201a718 <pbuf_alloced_custom>:
 *        big enough to hold 'length' plus the header size
 */
struct pbuf*
pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
                    void *payload_mem, u16_t payload_mem_len)
{
 201a718:	defff904 	addi	sp,sp,-28
 201a71c:	df000615 	stw	fp,24(sp)
 201a720:	df000604 	addi	fp,sp,24
 201a724:	e13ffb15 	stw	r4,-20(fp)
 201a728:	2807883a 	mov	r3,r5
 201a72c:	e1bffd15 	stw	r6,-12(fp)
 201a730:	e1fffe15 	stw	r7,-8(fp)
 201a734:	e0800217 	ldw	r2,8(fp)
 201a738:	e0fffc0d 	sth	r3,-16(fp)
 201a73c:	e0bfff0d 	sth	r2,-4(fp)
  u16_t offset;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (l) {
 201a740:	e0bffb17 	ldw	r2,-20(fp)
 201a744:	10c00060 	cmpeqi	r3,r2,1
 201a748:	1800091e 	bne	r3,zero,201a770 <pbuf_alloced_custom+0x58>
 201a74c:	0080052e 	bgeu	zero,r2,201a764 <pbuf_alloced_custom+0x4c>
 201a750:	10c000a0 	cmpeqi	r3,r2,2
 201a754:	1800091e 	bne	r3,zero,201a77c <pbuf_alloced_custom+0x64>
 201a758:	108000e0 	cmpeqi	r2,r2,3
 201a75c:	10000a1e 	bne	r2,zero,201a788 <pbuf_alloced_custom+0x70>
 201a760:	00000b06 	br	201a790 <pbuf_alloced_custom+0x78>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 201a764:	00800e04 	movi	r2,56
 201a768:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a76c:	00000a06 	br	201a798 <pbuf_alloced_custom+0x80>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 201a770:	00800904 	movi	r2,36
 201a774:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a778:	00000706 	br	201a798 <pbuf_alloced_custom+0x80>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 201a77c:	00800404 	movi	r2,16
 201a780:	e0bffa0d 	sth	r2,-24(fp)
    break;
 201a784:	00000406 	br	201a798 <pbuf_alloced_custom+0x80>
  case PBUF_RAW:
    offset = 0;
 201a788:	e03ffa0d 	sth	zero,-24(fp)
    break;
 201a78c:	00000206 	br	201a798 <pbuf_alloced_custom+0x80>
  default:
    LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
    return NULL;
 201a790:	0005883a 	mov	r2,zero
 201a794:	00002c06 	br	201a848 <pbuf_alloced_custom+0x130>
  }

  if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
 201a798:	e0bffa0b 	ldhu	r2,-24(fp)
 201a79c:	10c000c4 	addi	r3,r2,3
 201a7a0:	00bfff04 	movi	r2,-4
 201a7a4:	1886703a 	and	r3,r3,r2
 201a7a8:	e0bffc0b 	ldhu	r2,-16(fp)
 201a7ac:	1885883a 	add	r2,r3,r2
 201a7b0:	e0ffff0b 	ldhu	r3,-4(fp)
 201a7b4:	1880020e 	bge	r3,r2,201a7c0 <pbuf_alloced_custom+0xa8>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
    return NULL;
 201a7b8:	0005883a 	mov	r2,zero
 201a7bc:	00002206 	br	201a848 <pbuf_alloced_custom+0x130>
  }

  p->pbuf.next = NULL;
 201a7c0:	e0bffe17 	ldw	r2,-8(fp)
 201a7c4:	10000015 	stw	zero,0(r2)
  if (payload_mem != NULL) {
 201a7c8:	e0800117 	ldw	r2,4(fp)
 201a7cc:	10000a26 	beq	r2,zero,201a7f8 <pbuf_alloced_custom+0xe0>
    p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
 201a7d0:	e0bffa0b 	ldhu	r2,-24(fp)
 201a7d4:	108000c4 	addi	r2,r2,3
 201a7d8:	1007883a 	mov	r3,r2
 201a7dc:	00bfff04 	movi	r2,-4
 201a7e0:	1884703a 	and	r2,r3,r2
 201a7e4:	e0c00117 	ldw	r3,4(fp)
 201a7e8:	1887883a 	add	r3,r3,r2
 201a7ec:	e0bffe17 	ldw	r2,-8(fp)
 201a7f0:	10c00115 	stw	r3,4(r2)
 201a7f4:	00000206 	br	201a800 <pbuf_alloced_custom+0xe8>
  } else {
    p->pbuf.payload = NULL;
 201a7f8:	e0bffe17 	ldw	r2,-8(fp)
 201a7fc:	10000115 	stw	zero,4(r2)
  }
  p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
 201a800:	e0bffe17 	ldw	r2,-8(fp)
 201a804:	00c00084 	movi	r3,2
 201a808:	10c00345 	stb	r3,13(r2)
  p->pbuf.len = p->pbuf.tot_len = length;
 201a80c:	e0bffe17 	ldw	r2,-8(fp)
 201a810:	e0fffc0b 	ldhu	r3,-16(fp)
 201a814:	10c0020d 	sth	r3,8(r2)
 201a818:	e0bffe17 	ldw	r2,-8(fp)
 201a81c:	10c0020b 	ldhu	r3,8(r2)
 201a820:	e0bffe17 	ldw	r2,-8(fp)
 201a824:	10c0028d 	sth	r3,10(r2)
  p->pbuf.type = type;
 201a828:	e0bffd17 	ldw	r2,-12(fp)
 201a82c:	1007883a 	mov	r3,r2
 201a830:	e0bffe17 	ldw	r2,-8(fp)
 201a834:	10c00305 	stb	r3,12(r2)
  p->pbuf.ref = 1;
 201a838:	e0bffe17 	ldw	r2,-8(fp)
 201a83c:	00c00044 	movi	r3,1
 201a840:	10c0038d 	sth	r3,14(r2)
  return &p->pbuf;
 201a844:	e0bffe17 	ldw	r2,-8(fp)
}
 201a848:	e037883a 	mov	sp,fp
 201a84c:	df000017 	ldw	fp,0(sp)
 201a850:	dec00104 	addi	sp,sp,4
 201a854:	f800283a 	ret

0201a858 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 201a858:	defff904 	addi	sp,sp,-28
 201a85c:	dfc00615 	stw	ra,24(sp)
 201a860:	df000515 	stw	fp,20(sp)
 201a864:	df000504 	addi	fp,sp,20
 201a868:	e13ffe15 	stw	r4,-8(fp)
 201a86c:	2805883a 	mov	r2,r5
 201a870:	e0bfff0d 	sth	r2,-4(fp)
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 201a874:	e0bffe17 	ldw	r2,-8(fp)
 201a878:	1080020b 	ldhu	r2,8(r2)
 201a87c:	10bfffcc 	andi	r2,r2,65535
 201a880:	e0ffff0b 	ldhu	r3,-4(fp)
 201a884:	1880462e 	bgeu	r3,r2,201a9a0 <pbuf_realloc+0x148>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 201a888:	e0ffff0b 	ldhu	r3,-4(fp)
 201a88c:	e0bffe17 	ldw	r2,-8(fp)
 201a890:	1080020b 	ldhu	r2,8(r2)
 201a894:	10bfffcc 	andi	r2,r2,65535
 201a898:	1885c83a 	sub	r2,r3,r2
 201a89c:	e0bffd15 	stw	r2,-12(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 201a8a0:	e0bfff0b 	ldhu	r2,-4(fp)
 201a8a4:	e0bffc0d 	sth	r2,-16(fp)
  q = p;
 201a8a8:	e0bffe17 	ldw	r2,-8(fp)
 201a8ac:	e0bffb15 	stw	r2,-20(fp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 201a8b0:	00000f06 	br	201a8f0 <pbuf_realloc+0x98>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 201a8b4:	e0bffb17 	ldw	r2,-20(fp)
 201a8b8:	1080028b 	ldhu	r2,10(r2)
 201a8bc:	e0fffc0b 	ldhu	r3,-16(fp)
 201a8c0:	1885c83a 	sub	r2,r3,r2
 201a8c4:	e0bffc0d 	sth	r2,-16(fp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 201a8c8:	e0bffb17 	ldw	r2,-20(fp)
 201a8cc:	1080020b 	ldhu	r2,8(r2)
 201a8d0:	e0fffd17 	ldw	r3,-12(fp)
 201a8d4:	10c5883a 	add	r2,r2,r3
 201a8d8:	1007883a 	mov	r3,r2
 201a8dc:	e0bffb17 	ldw	r2,-20(fp)
 201a8e0:	10c0020d 	sth	r3,8(r2)
    /* proceed to next pbuf in chain */
    q = q->next;
 201a8e4:	e0bffb17 	ldw	r2,-20(fp)
 201a8e8:	10800017 	ldw	r2,0(r2)
 201a8ec:	e0bffb15 	stw	r2,-20(fp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 201a8f0:	e0bffb17 	ldw	r2,-20(fp)
 201a8f4:	1080028b 	ldhu	r2,10(r2)
 201a8f8:	10ffffcc 	andi	r3,r2,65535
 201a8fc:	e0bffc0b 	ldhu	r2,-16(fp)
 201a900:	18bfec36 	bltu	r3,r2,201a8b4 <__alt_mem_mem_0+0xfcffa8b4>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 201a904:	e0bffb17 	ldw	r2,-20(fp)
 201a908:	10800303 	ldbu	r2,12(r2)
 201a90c:	10803fcc 	andi	r2,r2,255
 201a910:	1000121e 	bne	r2,zero,201a95c <pbuf_realloc+0x104>
 201a914:	e0bffb17 	ldw	r2,-20(fp)
 201a918:	1080028b 	ldhu	r2,10(r2)
 201a91c:	10ffffcc 	andi	r3,r2,65535
 201a920:	e0bffc0b 	ldhu	r2,-16(fp)
 201a924:	18800d26 	beq	r3,r2,201a95c <pbuf_realloc+0x104>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 201a928:	e0bffb17 	ldw	r2,-20(fp)
 201a92c:	10800117 	ldw	r2,4(r2)
 201a930:	1007883a 	mov	r3,r2
 201a934:	e0bffb17 	ldw	r2,-20(fp)
 201a938:	1885c83a 	sub	r2,r3,r2
 201a93c:	1007883a 	mov	r3,r2
 201a940:	e0bffc0b 	ldhu	r2,-16(fp)
 201a944:	1885883a 	add	r2,r3,r2
 201a948:	10bfffcc 	andi	r2,r2,65535
 201a94c:	100b883a 	mov	r5,r2
 201a950:	e13ffb17 	ldw	r4,-20(fp)
 201a954:	20193ac0 	call	20193ac <mem_trim>
 201a958:	e0bffb15 	stw	r2,-20(fp)
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 201a95c:	e0bffb17 	ldw	r2,-20(fp)
 201a960:	e0fffc0b 	ldhu	r3,-16(fp)
 201a964:	10c0028d 	sth	r3,10(r2)
  q->tot_len = q->len;
 201a968:	e0bffb17 	ldw	r2,-20(fp)
 201a96c:	10c0028b 	ldhu	r3,10(r2)
 201a970:	e0bffb17 	ldw	r2,-20(fp)
 201a974:	10c0020d 	sth	r3,8(r2)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 201a978:	e0bffb17 	ldw	r2,-20(fp)
 201a97c:	10800017 	ldw	r2,0(r2)
 201a980:	10000426 	beq	r2,zero,201a994 <pbuf_realloc+0x13c>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 201a984:	e0bffb17 	ldw	r2,-20(fp)
 201a988:	10800017 	ldw	r2,0(r2)
 201a98c:	1009883a 	mov	r4,r2
 201a990:	201ab680 	call	201ab68 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 201a994:	e0bffb17 	ldw	r2,-20(fp)
 201a998:	10000015 	stw	zero,0(r2)
 201a99c:	00000106 	br	201a9a4 <pbuf_realloc+0x14c>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
 201a9a0:	0001883a 	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
 201a9a4:	e037883a 	mov	sp,fp
 201a9a8:	dfc00117 	ldw	ra,4(sp)
 201a9ac:	df000017 	ldw	fp,0(sp)
 201a9b0:	dec00204 	addi	sp,sp,8
 201a9b4:	f800283a 	ret

0201a9b8 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 201a9b8:	defffa04 	addi	sp,sp,-24
 201a9bc:	dfc00515 	stw	ra,20(sp)
 201a9c0:	df000415 	stw	fp,16(sp)
 201a9c4:	df000404 	addi	fp,sp,16
 201a9c8:	e13ffe15 	stw	r4,-8(fp)
 201a9cc:	2805883a 	mov	r2,r5
 201a9d0:	e0bfff0d 	sth	r2,-4(fp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 201a9d4:	e0bfff0f 	ldh	r2,-4(fp)
 201a9d8:	10000226 	beq	r2,zero,201a9e4 <pbuf_header+0x2c>
 201a9dc:	e0bffe17 	ldw	r2,-8(fp)
 201a9e0:	1000021e 	bne	r2,zero,201a9ec <pbuf_header+0x34>
    return 0;
 201a9e4:	0005883a 	mov	r2,zero
 201a9e8:	00005a06 	br	201ab54 <pbuf_header+0x19c>
  }
 
  if (header_size_increment < 0){
 201a9ec:	e0bfff0f 	ldh	r2,-4(fp)
 201a9f0:	1000110e 	bge	r2,zero,201aa38 <pbuf_header+0x80>
    increment_magnitude = -header_size_increment;
 201a9f4:	e0bfff0b 	ldhu	r2,-4(fp)
 201a9f8:	0085c83a 	sub	r2,zero,r2
 201a9fc:	e0bffc0d 	sth	r2,-16(fp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 201aa00:	e0bffe17 	ldw	r2,-8(fp)
 201aa04:	1080028b 	ldhu	r2,10(r2)
 201aa08:	10ffffcc 	andi	r3,r2,65535
 201aa0c:	e0bffc0b 	ldhu	r2,-16(fp)
 201aa10:	18800b2e 	bgeu	r3,r2,201aa40 <pbuf_header+0x88>
 201aa14:	01c08134 	movhi	r7,516
 201aa18:	39c53604 	addi	r7,r7,5336
 201aa1c:	01808344 	movi	r6,525
 201aa20:	01408134 	movhi	r5,516
 201aa24:	29453c04 	addi	r5,r5,5360
 201aa28:	01008134 	movhi	r4,516
 201aa2c:	21054404 	addi	r4,r4,5392
 201aa30:	2000bb00 	call	2000bb0 <printf>
 201aa34:	003fff06 	br	201aa34 <__alt_mem_mem_0+0xfcffaa34>
  } else {
    increment_magnitude = header_size_increment;
 201aa38:	e0bfff0b 	ldhu	r2,-4(fp)
 201aa3c:	e0bffc0d 	sth	r2,-16(fp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 201aa40:	e0bffe17 	ldw	r2,-8(fp)
 201aa44:	10800303 	ldbu	r2,12(r2)
 201aa48:	10803fcc 	andi	r2,r2,255
 201aa4c:	e0bffc8d 	sth	r2,-14(fp)
  /* remember current payload pointer */
  payload = p->payload;
 201aa50:	e0bffe17 	ldw	r2,-8(fp)
 201aa54:	10800117 	ldw	r2,4(r2)
 201aa58:	e0bffd15 	stw	r2,-12(fp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 201aa5c:	e0bffc8b 	ldhu	r2,-14(fp)
 201aa60:	10000326 	beq	r2,zero,201aa70 <pbuf_header+0xb8>
 201aa64:	e0bffc8b 	ldhu	r2,-14(fp)
 201aa68:	108000d8 	cmpnei	r2,r2,3
 201aa6c:	1000111e 	bne	r2,zero,201aab4 <pbuf_header+0xfc>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 201aa70:	e0bffe17 	ldw	r2,-8(fp)
 201aa74:	10c00117 	ldw	r3,4(r2)
 201aa78:	e0bfff0f 	ldh	r2,-4(fp)
 201aa7c:	0085c83a 	sub	r2,zero,r2
 201aa80:	1887883a 	add	r3,r3,r2
 201aa84:	e0bffe17 	ldw	r2,-8(fp)
 201aa88:	10c00115 	stw	r3,4(r2)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 201aa8c:	e0bffe17 	ldw	r2,-8(fp)
 201aa90:	10c00117 	ldw	r3,4(r2)
 201aa94:	e0bffe17 	ldw	r2,-8(fp)
 201aa98:	10800404 	addi	r2,r2,16
 201aa9c:	18801e2e 	bgeu	r3,r2,201ab18 <pbuf_header+0x160>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 201aaa0:	e0bffe17 	ldw	r2,-8(fp)
 201aaa4:	e0fffd17 	ldw	r3,-12(fp)
 201aaa8:	10c00115 	stw	r3,4(r2)
      /* bail out unsuccesfully */
      return 1;
 201aaac:	00800044 	movi	r2,1
 201aab0:	00002806 	br	201ab54 <pbuf_header+0x19c>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 201aab4:	e0bffc8b 	ldhu	r2,-14(fp)
 201aab8:	108000a0 	cmpeqi	r2,r2,2
 201aabc:	1000031e 	bne	r2,zero,201aacc <pbuf_header+0x114>
 201aac0:	e0bffc8b 	ldhu	r2,-14(fp)
 201aac4:	10800058 	cmpnei	r2,r2,1
 201aac8:	1000111e 	bne	r2,zero,201ab10 <pbuf_header+0x158>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 201aacc:	e0bfff0f 	ldh	r2,-4(fp)
 201aad0:	10000d0e 	bge	r2,zero,201ab08 <pbuf_header+0x150>
 201aad4:	e0bffe17 	ldw	r2,-8(fp)
 201aad8:	1080028b 	ldhu	r2,10(r2)
 201aadc:	10ffffcc 	andi	r3,r2,65535
 201aae0:	e0bffc0b 	ldhu	r2,-16(fp)
 201aae4:	18800836 	bltu	r3,r2,201ab08 <pbuf_header+0x150>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 201aae8:	e0bffe17 	ldw	r2,-8(fp)
 201aaec:	10c00117 	ldw	r3,4(r2)
 201aaf0:	e0bfff0f 	ldh	r2,-4(fp)
 201aaf4:	0085c83a 	sub	r2,zero,r2
 201aaf8:	1887883a 	add	r3,r3,r2
 201aafc:	e0bffe17 	ldw	r2,-8(fp)
 201ab00:	10c00115 	stw	r3,4(r2)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 201ab04:	00000406 	br	201ab18 <pbuf_header+0x160>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 201ab08:	00800044 	movi	r2,1
 201ab0c:	00001106 	br	201ab54 <pbuf_header+0x19c>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 201ab10:	00800044 	movi	r2,1
 201ab14:	00000f06 	br	201ab54 <pbuf_header+0x19c>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 201ab18:	e0bffe17 	ldw	r2,-8(fp)
 201ab1c:	10c0028b 	ldhu	r3,10(r2)
 201ab20:	e0bfff0b 	ldhu	r2,-4(fp)
 201ab24:	1885883a 	add	r2,r3,r2
 201ab28:	1007883a 	mov	r3,r2
 201ab2c:	e0bffe17 	ldw	r2,-8(fp)
 201ab30:	10c0028d 	sth	r3,10(r2)
  p->tot_len += header_size_increment;
 201ab34:	e0bffe17 	ldw	r2,-8(fp)
 201ab38:	10c0020b 	ldhu	r3,8(r2)
 201ab3c:	e0bfff0b 	ldhu	r2,-4(fp)
 201ab40:	1885883a 	add	r2,r3,r2
 201ab44:	1007883a 	mov	r3,r2
 201ab48:	e0bffe17 	ldw	r2,-8(fp)
 201ab4c:	10c0020d 	sth	r3,8(r2)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 201ab50:	0005883a 	mov	r2,zero
}
 201ab54:	e037883a 	mov	sp,fp
 201ab58:	dfc00117 	ldw	ra,4(sp)
 201ab5c:	df000017 	ldw	fp,0(sp)
 201ab60:	dec00204 	addi	sp,sp,8
 201ab64:	f800283a 	ret

0201ab68 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 201ab68:	defff904 	addi	sp,sp,-28
 201ab6c:	dfc00615 	stw	ra,24(sp)
 201ab70:	df000515 	stw	fp,20(sp)
 201ab74:	df000504 	addi	fp,sp,20
 201ab78:	e13fff15 	stw	r4,-4(fp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 201ab7c:	e0bfff17 	ldw	r2,-4(fp)
 201ab80:	1000021e 	bne	r2,zero,201ab8c <pbuf_free+0x24>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 201ab84:	0005883a 	mov	r2,zero
 201ab88:	00004306 	br	201ac98 <pbuf_free+0x130>

  LWIP_ASSERT("pbuf_free: sane type",
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
 201ab8c:	e03ffb05 	stb	zero,-20(fp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 201ab90:	00003e06 	br	201ac8c <pbuf_free+0x124>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 201ab94:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201ab98:	10000126 	beq	r2,zero,201aba0 <pbuf_free+0x38>
 201ab9c:	2010f300 	call	2010f30 <vTaskEnterCritical>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 201aba0:	e0bfff17 	ldw	r2,-4(fp)
 201aba4:	1080038b 	ldhu	r2,14(r2)
 201aba8:	10bfffc4 	addi	r2,r2,-1
 201abac:	1007883a 	mov	r3,r2
 201abb0:	e0bfff17 	ldw	r2,-4(fp)
 201abb4:	10c0038d 	sth	r3,14(r2)
 201abb8:	e0bfff17 	ldw	r2,-4(fp)
 201abbc:	1080038b 	ldhu	r2,14(r2)
 201abc0:	e0bffb8d 	sth	r2,-18(fp)
    SYS_ARCH_UNPROTECT(old_level);
 201abc4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201abc8:	10000126 	beq	r2,zero,201abd0 <pbuf_free+0x68>
 201abcc:	2010f780 	call	2010f78 <vTaskExitCritical>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 201abd0:	e0bffb8b 	ldhu	r2,-18(fp)
 201abd4:	10002c1e 	bne	r2,zero,201ac88 <pbuf_free+0x120>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 201abd8:	e0bfff17 	ldw	r2,-4(fp)
 201abdc:	10800017 	ldw	r2,0(r2)
 201abe0:	e0bffc15 	stw	r2,-16(fp)
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 201abe4:	e0bfff17 	ldw	r2,-4(fp)
 201abe8:	10800303 	ldbu	r2,12(r2)
 201abec:	10803fcc 	andi	r2,r2,255
 201abf0:	e0bffd0d 	sth	r2,-12(fp)
#if LWIP_SUPPORT_CUSTOM_PBUF
      /* is this a custom pbuf? */
      if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
 201abf4:	e0bfff17 	ldw	r2,-4(fp)
 201abf8:	10800343 	ldbu	r2,13(r2)
 201abfc:	10803fcc 	andi	r2,r2,255
 201ac00:	1080008c 	andi	r2,r2,2
 201ac04:	10000726 	beq	r2,zero,201ac24 <pbuf_free+0xbc>
        struct pbuf_custom *pc = (struct pbuf_custom*)p;
 201ac08:	e0bfff17 	ldw	r2,-4(fp)
 201ac0c:	e0bffe15 	stw	r2,-8(fp)
        LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
        pc->custom_free_function(p);
 201ac10:	e0bffe17 	ldw	r2,-8(fp)
 201ac14:	10800417 	ldw	r2,16(r2)
 201ac18:	e13fff17 	ldw	r4,-4(fp)
 201ac1c:	103ee83a 	callr	r2
 201ac20:	00001306 	br	201ac70 <pbuf_free+0x108>
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 201ac24:	e0bffd0b 	ldhu	r2,-12(fp)
 201ac28:	108000d8 	cmpnei	r2,r2,3
 201ac2c:	1000041e 	bne	r2,zero,201ac40 <pbuf_free+0xd8>
          memp_free(MEMP_PBUF_POOL, p);
 201ac30:	e17fff17 	ldw	r5,-4(fp)
 201ac34:	01000384 	movi	r4,14
 201ac38:	20346000 	call	2034600 <memp_free>
 201ac3c:	00000c06 	br	201ac70 <pbuf_free+0x108>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 201ac40:	e0bffd0b 	ldhu	r2,-12(fp)
 201ac44:	10800060 	cmpeqi	r2,r2,1
 201ac48:	1000031e 	bne	r2,zero,201ac58 <pbuf_free+0xf0>
 201ac4c:	e0bffd0b 	ldhu	r2,-12(fp)
 201ac50:	10800098 	cmpnei	r2,r2,2
 201ac54:	1000041e 	bne	r2,zero,201ac68 <pbuf_free+0x100>
          memp_free(MEMP_PBUF, p);
 201ac58:	e17fff17 	ldw	r5,-4(fp)
 201ac5c:	01000344 	movi	r4,13
 201ac60:	20346000 	call	2034600 <memp_free>
 201ac64:	00000206 	br	201ac70 <pbuf_free+0x108>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 201ac68:	e13fff17 	ldw	r4,-4(fp)
 201ac6c:	20192a00 	call	20192a0 <mem_free>
        }
      }
      count++;
 201ac70:	e0bffb03 	ldbu	r2,-20(fp)
 201ac74:	10800044 	addi	r2,r2,1
 201ac78:	e0bffb05 	stb	r2,-20(fp)
      /* proceed to next pbuf */
      p = q;
 201ac7c:	e0bffc17 	ldw	r2,-16(fp)
 201ac80:	e0bfff15 	stw	r2,-4(fp)
 201ac84:	00000106 	br	201ac8c <pbuf_free+0x124>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
 201ac88:	e03fff15 	stw	zero,-4(fp)
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 201ac8c:	e0bfff17 	ldw	r2,-4(fp)
 201ac90:	103fc01e 	bne	r2,zero,201ab94 <__alt_mem_mem_0+0xfcffab94>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 201ac94:	e0bffb03 	ldbu	r2,-20(fp)
}
 201ac98:	e037883a 	mov	sp,fp
 201ac9c:	dfc00117 	ldw	ra,4(sp)
 201aca0:	df000017 	ldw	fp,0(sp)
 201aca4:	dec00204 	addi	sp,sp,8
 201aca8:	f800283a 	ret

0201acac <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 201acac:	defffd04 	addi	sp,sp,-12
 201acb0:	df000215 	stw	fp,8(sp)
 201acb4:	df000204 	addi	fp,sp,8
 201acb8:	e13fff15 	stw	r4,-4(fp)
  u8_t len;

  len = 0;
 201acbc:	e03ffe05 	stb	zero,-8(fp)
  while (p != NULL) {
 201acc0:	00000606 	br	201acdc <pbuf_clen+0x30>
    ++len;
 201acc4:	e0bffe03 	ldbu	r2,-8(fp)
 201acc8:	10800044 	addi	r2,r2,1
 201accc:	e0bffe05 	stb	r2,-8(fp)
    p = p->next;
 201acd0:	e0bfff17 	ldw	r2,-4(fp)
 201acd4:	10800017 	ldw	r2,0(r2)
 201acd8:	e0bfff15 	stw	r2,-4(fp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 201acdc:	e0bfff17 	ldw	r2,-4(fp)
 201ace0:	103ff81e 	bne	r2,zero,201acc4 <__alt_mem_mem_0+0xfcffacc4>
    ++len;
    p = p->next;
  }
  return len;
 201ace4:	e0bffe03 	ldbu	r2,-8(fp)
}
 201ace8:	e037883a 	mov	sp,fp
 201acec:	df000017 	ldw	fp,0(sp)
 201acf0:	dec00104 	addi	sp,sp,4
 201acf4:	f800283a 	ret

0201acf8 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 201acf8:	defffd04 	addi	sp,sp,-12
 201acfc:	dfc00215 	stw	ra,8(sp)
 201ad00:	df000115 	stw	fp,4(sp)
 201ad04:	df000104 	addi	fp,sp,4
 201ad08:	e13fff15 	stw	r4,-4(fp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 201ad0c:	e0bfff17 	ldw	r2,-4(fp)
 201ad10:	10000c26 	beq	r2,zero,201ad44 <pbuf_ref+0x4c>
    SYS_ARCH_PROTECT(old_level);
 201ad14:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201ad18:	10000126 	beq	r2,zero,201ad20 <pbuf_ref+0x28>
 201ad1c:	2010f300 	call	2010f30 <vTaskEnterCritical>
    ++(p->ref);
 201ad20:	e0bfff17 	ldw	r2,-4(fp)
 201ad24:	1080038b 	ldhu	r2,14(r2)
 201ad28:	10800044 	addi	r2,r2,1
 201ad2c:	1007883a 	mov	r3,r2
 201ad30:	e0bfff17 	ldw	r2,-4(fp)
 201ad34:	10c0038d 	sth	r3,14(r2)
    SYS_ARCH_UNPROTECT(old_level);
 201ad38:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 201ad3c:	10000126 	beq	r2,zero,201ad44 <pbuf_ref+0x4c>
 201ad40:	2010f780 	call	2010f78 <vTaskExitCritical>
  }
}
 201ad44:	0001883a 	nop
 201ad48:	e037883a 	mov	sp,fp
 201ad4c:	dfc00117 	ldw	ra,4(sp)
 201ad50:	df000017 	ldw	fp,0(sp)
 201ad54:	dec00204 	addi	sp,sp,8
 201ad58:	f800283a 	ret

0201ad5c <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 201ad5c:	defffb04 	addi	sp,sp,-20
 201ad60:	dfc00415 	stw	ra,16(sp)
 201ad64:	df000315 	stw	fp,12(sp)
 201ad68:	df000304 	addi	fp,sp,12
 201ad6c:	e13ffe15 	stw	r4,-8(fp)
 201ad70:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 201ad74:	e0bffe17 	ldw	r2,-8(fp)
 201ad78:	10000226 	beq	r2,zero,201ad84 <pbuf_cat+0x28>
 201ad7c:	e0bfff17 	ldw	r2,-4(fp)
 201ad80:	1000091e 	bne	r2,zero,201ada8 <pbuf_cat+0x4c>
 201ad84:	01c08134 	movhi	r7,516
 201ad88:	39c53604 	addi	r7,r7,5336
 201ad8c:	0180bb84 	movi	r6,750
 201ad90:	01408134 	movhi	r5,516
 201ad94:	29455004 	addi	r5,r5,5440
 201ad98:	01008134 	movhi	r4,516
 201ad9c:	21054404 	addi	r4,r4,5392
 201ada0:	2000bb00 	call	2000bb0 <printf>
 201ada4:	003fff06 	br	201ada4 <__alt_mem_mem_0+0xfcffada4>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 201ada8:	e0bffe17 	ldw	r2,-8(fp)
 201adac:	e0bffd15 	stw	r2,-12(fp)
 201adb0:	00000b06 	br	201ade0 <pbuf_cat+0x84>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 201adb4:	e0bffd17 	ldw	r2,-12(fp)
 201adb8:	10c0020b 	ldhu	r3,8(r2)
 201adbc:	e0bfff17 	ldw	r2,-4(fp)
 201adc0:	1080020b 	ldhu	r2,8(r2)
 201adc4:	1885883a 	add	r2,r3,r2
 201adc8:	1007883a 	mov	r3,r2
 201adcc:	e0bffd17 	ldw	r2,-12(fp)
 201add0:	10c0020d 	sth	r3,8(r2)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 201add4:	e0bffd17 	ldw	r2,-12(fp)
 201add8:	10800017 	ldw	r2,0(r2)
 201addc:	e0bffd15 	stw	r2,-12(fp)
 201ade0:	e0bffd17 	ldw	r2,-12(fp)
 201ade4:	10800017 	ldw	r2,0(r2)
 201ade8:	103ff21e 	bne	r2,zero,201adb4 <__alt_mem_mem_0+0xfcffadb4>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 201adec:	e0bffd17 	ldw	r2,-12(fp)
 201adf0:	10c0020b 	ldhu	r3,8(r2)
 201adf4:	e0bfff17 	ldw	r2,-4(fp)
 201adf8:	1080020b 	ldhu	r2,8(r2)
 201adfc:	1885883a 	add	r2,r3,r2
 201ae00:	1007883a 	mov	r3,r2
 201ae04:	e0bffd17 	ldw	r2,-12(fp)
 201ae08:	10c0020d 	sth	r3,8(r2)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 201ae0c:	e0bffd17 	ldw	r2,-12(fp)
 201ae10:	e0ffff17 	ldw	r3,-4(fp)
 201ae14:	10c00015 	stw	r3,0(r2)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 201ae18:	0001883a 	nop
 201ae1c:	e037883a 	mov	sp,fp
 201ae20:	dfc00117 	ldw	ra,4(sp)
 201ae24:	df000017 	ldw	fp,0(sp)
 201ae28:	dec00204 	addi	sp,sp,8
 201ae2c:	f800283a 	ret

0201ae30 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 201ae30:	defffc04 	addi	sp,sp,-16
 201ae34:	dfc00315 	stw	ra,12(sp)
 201ae38:	df000215 	stw	fp,8(sp)
 201ae3c:	df000204 	addi	fp,sp,8
 201ae40:	e13ffe15 	stw	r4,-8(fp)
 201ae44:	e17fff15 	stw	r5,-4(fp)
  pbuf_cat(h, t);
 201ae48:	e17fff17 	ldw	r5,-4(fp)
 201ae4c:	e13ffe17 	ldw	r4,-8(fp)
 201ae50:	201ad5c0 	call	201ad5c <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 201ae54:	e13fff17 	ldw	r4,-4(fp)
 201ae58:	201acf80 	call	201acf8 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 201ae5c:	0001883a 	nop
 201ae60:	e037883a 	mov	sp,fp
 201ae64:	dfc00117 	ldw	ra,4(sp)
 201ae68:	df000017 	ldw	fp,0(sp)
 201ae6c:	dec00204 	addi	sp,sp,8
 201ae70:	f800283a 	ret

0201ae74 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 201ae74:	defffb04 	addi	sp,sp,-20
 201ae78:	dfc00415 	stw	ra,16(sp)
 201ae7c:	df000315 	stw	fp,12(sp)
 201ae80:	df000304 	addi	fp,sp,12
 201ae84:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q;
  u8_t tail_gone = 1;
 201ae88:	00800044 	movi	r2,1
 201ae8c:	e0bffd05 	stb	r2,-12(fp)
  /* tail */
  q = p->next;
 201ae90:	e0bfff17 	ldw	r2,-4(fp)
 201ae94:	10800017 	ldw	r2,0(r2)
 201ae98:	e0bffe15 	stw	r2,-8(fp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
 201ae9c:	e0bffe17 	ldw	r2,-8(fp)
 201aea0:	10001126 	beq	r2,zero,201aee8 <pbuf_dechain+0x74>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
 201aea4:	e0bfff17 	ldw	r2,-4(fp)
 201aea8:	10c0020b 	ldhu	r3,8(r2)
 201aeac:	e0bfff17 	ldw	r2,-4(fp)
 201aeb0:	1080028b 	ldhu	r2,10(r2)
 201aeb4:	1885c83a 	sub	r2,r3,r2
 201aeb8:	1007883a 	mov	r3,r2
 201aebc:	e0bffe17 	ldw	r2,-8(fp)
 201aec0:	10c0020d 	sth	r3,8(r2)
    /* decouple pbuf from remainder */
    p->next = NULL;
 201aec4:	e0bfff17 	ldw	r2,-4(fp)
 201aec8:	10000015 	stw	zero,0(r2)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 201aecc:	e0bfff17 	ldw	r2,-4(fp)
 201aed0:	10c0028b 	ldhu	r3,10(r2)
 201aed4:	e0bfff17 	ldw	r2,-4(fp)
 201aed8:	10c0020d 	sth	r3,8(r2)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 201aedc:	e13ffe17 	ldw	r4,-8(fp)
 201aee0:	201ab680 	call	201ab68 <pbuf_free>
 201aee4:	e0bffd05 	stb	r2,-12(fp)
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 201aee8:	e0bffd03 	ldbu	r2,-12(fp)
 201aeec:	1000021e 	bne	r2,zero,201aef8 <pbuf_dechain+0x84>
 201aef0:	e0bffe17 	ldw	r2,-8(fp)
 201aef4:	00000106 	br	201aefc <pbuf_dechain+0x88>
 201aef8:	0005883a 	mov	r2,zero
}
 201aefc:	e037883a 	mov	sp,fp
 201af00:	dfc00117 	ldw	ra,4(sp)
 201af04:	df000017 	ldw	fp,0(sp)
 201af08:	dec00204 	addi	sp,sp,8
 201af0c:	f800283a 	ret

0201af10 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 201af10:	defffa04 	addi	sp,sp,-24
 201af14:	dfc00515 	stw	ra,20(sp)
 201af18:	df000415 	stw	fp,16(sp)
 201af1c:	df000404 	addi	fp,sp,16
 201af20:	e13ffe15 	stw	r4,-8(fp)
 201af24:	e17fff15 	stw	r5,-4(fp)
  u16_t offset_to=0, offset_from=0, len;
 201af28:	e03ffc0d 	sth	zero,-16(fp)
 201af2c:	e03ffc8d 	sth	zero,-14(fp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 201af30:	e0bffe17 	ldw	r2,-8(fp)
 201af34:	10000926 	beq	r2,zero,201af5c <pbuf_copy+0x4c>
 201af38:	e0bfff17 	ldw	r2,-4(fp)
 201af3c:	10000726 	beq	r2,zero,201af5c <pbuf_copy+0x4c>
 201af40:	e0bffe17 	ldw	r2,-8(fp)
 201af44:	10c0020b 	ldhu	r3,8(r2)
 201af48:	e0bfff17 	ldw	r2,-4(fp)
 201af4c:	1080020b 	ldhu	r2,8(r2)
 201af50:	18ffffcc 	andi	r3,r3,65535
 201af54:	10bfffcc 	andi	r2,r2,65535
 201af58:	1880092e 	bgeu	r3,r2,201af80 <pbuf_copy+0x70>
 201af5c:	01c08134 	movhi	r7,516
 201af60:	39c53604 	addi	r7,r7,5336
 201af64:	0180d744 	movi	r6,861
 201af68:	01408134 	movhi	r5,516
 201af6c:	29455e04 	addi	r5,r5,5496
 201af70:	01008134 	movhi	r4,516
 201af74:	21054404 	addi	r4,r4,5392
 201af78:	2000bb00 	call	2000bb0 <printf>
 201af7c:	003fff06 	br	201af7c <__alt_mem_mem_0+0xfcffaf7c>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 201af80:	e0bffe17 	ldw	r2,-8(fp)
 201af84:	1080028b 	ldhu	r2,10(r2)
 201af88:	10ffffcc 	andi	r3,r2,65535
 201af8c:	e0bffc0b 	ldhu	r2,-16(fp)
 201af90:	1887c83a 	sub	r3,r3,r2
 201af94:	e0bfff17 	ldw	r2,-4(fp)
 201af98:	1080028b 	ldhu	r2,10(r2)
 201af9c:	113fffcc 	andi	r4,r2,65535
 201afa0:	e0bffc8b 	ldhu	r2,-14(fp)
 201afa4:	2085c83a 	sub	r2,r4,r2
 201afa8:	18800616 	blt	r3,r2,201afc4 <pbuf_copy+0xb4>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 201afac:	e0bfff17 	ldw	r2,-4(fp)
 201afb0:	10c0028b 	ldhu	r3,10(r2)
 201afb4:	e0bffc8b 	ldhu	r2,-14(fp)
 201afb8:	1885c83a 	sub	r2,r3,r2
 201afbc:	e0bffd0d 	sth	r2,-12(fp)
 201afc0:	00000506 	br	201afd8 <pbuf_copy+0xc8>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 201afc4:	e0bffe17 	ldw	r2,-8(fp)
 201afc8:	10c0028b 	ldhu	r3,10(r2)
 201afcc:	e0bffc0b 	ldhu	r2,-16(fp)
 201afd0:	1885c83a 	sub	r2,r3,r2
 201afd4:	e0bffd0d 	sth	r2,-12(fp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 201afd8:	e0bffe17 	ldw	r2,-8(fp)
 201afdc:	10c00117 	ldw	r3,4(r2)
 201afe0:	e0bffc0b 	ldhu	r2,-16(fp)
 201afe4:	1889883a 	add	r4,r3,r2
 201afe8:	e0bfff17 	ldw	r2,-4(fp)
 201afec:	10c00117 	ldw	r3,4(r2)
 201aff0:	e0bffc8b 	ldhu	r2,-14(fp)
 201aff4:	1885883a 	add	r2,r3,r2
 201aff8:	e0fffd0b 	ldhu	r3,-12(fp)
 201affc:	180d883a 	mov	r6,r3
 201b000:	100b883a 	mov	r5,r2
 201b004:	20060240 	call	2006024 <memcpy>
    offset_to += len;
 201b008:	e0fffc0b 	ldhu	r3,-16(fp)
 201b00c:	e0bffd0b 	ldhu	r2,-12(fp)
 201b010:	1885883a 	add	r2,r3,r2
 201b014:	e0bffc0d 	sth	r2,-16(fp)
    offset_from += len;
 201b018:	e0fffc8b 	ldhu	r3,-14(fp)
 201b01c:	e0bffd0b 	ldhu	r2,-12(fp)
 201b020:	1885883a 	add	r2,r3,r2
 201b024:	e0bffc8d 	sth	r2,-14(fp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 201b028:	e0bfff17 	ldw	r2,-4(fp)
 201b02c:	1080028b 	ldhu	r2,10(r2)
 201b030:	10bfffcc 	andi	r2,r2,65535
 201b034:	e0fffc8b 	ldhu	r3,-14(fp)
 201b038:	18800436 	bltu	r3,r2,201b04c <pbuf_copy+0x13c>
      /* on to next p_from (if any) */
      offset_from = 0;
 201b03c:	e03ffc8d 	sth	zero,-14(fp)
      p_from = p_from->next;
 201b040:	e0bfff17 	ldw	r2,-4(fp)
 201b044:	10800017 	ldw	r2,0(r2)
 201b048:	e0bfff15 	stw	r2,-4(fp)
    }
    if (offset_to == p_to->len) {
 201b04c:	e0bffe17 	ldw	r2,-8(fp)
 201b050:	1080028b 	ldhu	r2,10(r2)
 201b054:	10ffffcc 	andi	r3,r2,65535
 201b058:	e0bffc0b 	ldhu	r2,-16(fp)
 201b05c:	1880111e 	bne	r3,r2,201b0a4 <pbuf_copy+0x194>
      /* on to next p_to (if any) */
      offset_to = 0;
 201b060:	e03ffc0d 	sth	zero,-16(fp)
      p_to = p_to->next;
 201b064:	e0bffe17 	ldw	r2,-8(fp)
 201b068:	10800017 	ldw	r2,0(r2)
 201b06c:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 201b070:	e0bffe17 	ldw	r2,-8(fp)
 201b074:	10000b1e 	bne	r2,zero,201b0a4 <pbuf_copy+0x194>
 201b078:	e0bfff17 	ldw	r2,-4(fp)
 201b07c:	10000926 	beq	r2,zero,201b0a4 <pbuf_copy+0x194>
 201b080:	01c08134 	movhi	r7,516
 201b084:	39c53604 	addi	r7,r7,5336
 201b088:	0180de04 	movi	r6,888
 201b08c:	01408134 	movhi	r5,516
 201b090:	29456a04 	addi	r5,r5,5544
 201b094:	01008134 	movhi	r4,516
 201b098:	21054404 	addi	r4,r4,5392
 201b09c:	2000bb00 	call	2000bb0 <printf>
 201b0a0:	003fff06 	br	201b0a0 <__alt_mem_mem_0+0xfcffb0a0>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 201b0a4:	e0bfff17 	ldw	r2,-4(fp)
 201b0a8:	10001326 	beq	r2,zero,201b0f8 <pbuf_copy+0x1e8>
 201b0ac:	e0bfff17 	ldw	r2,-4(fp)
 201b0b0:	10c0028b 	ldhu	r3,10(r2)
 201b0b4:	e0bfff17 	ldw	r2,-4(fp)
 201b0b8:	1080020b 	ldhu	r2,8(r2)
 201b0bc:	18ffffcc 	andi	r3,r3,65535
 201b0c0:	10bfffcc 	andi	r2,r2,65535
 201b0c4:	18800c1e 	bne	r3,r2,201b0f8 <pbuf_copy+0x1e8>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 201b0c8:	e0bfff17 	ldw	r2,-4(fp)
 201b0cc:	10800017 	ldw	r2,0(r2)
 201b0d0:	10000926 	beq	r2,zero,201b0f8 <pbuf_copy+0x1e8>
 201b0d4:	01c08134 	movhi	r7,516
 201b0d8:	39c53604 	addi	r7,r7,5336
 201b0dc:	0180df84 	movi	r6,894
 201b0e0:	01408134 	movhi	r5,516
 201b0e4:	29456e04 	addi	r5,r5,5560
 201b0e8:	01008134 	movhi	r4,516
 201b0ec:	21054404 	addi	r4,r4,5392
 201b0f0:	2000bb00 	call	2000bb0 <printf>
 201b0f4:	003fff06 	br	201b0f4 <__alt_mem_mem_0+0xfcffb0f4>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 201b0f8:	e0bffe17 	ldw	r2,-8(fp)
 201b0fc:	10001326 	beq	r2,zero,201b14c <pbuf_copy+0x23c>
 201b100:	e0bffe17 	ldw	r2,-8(fp)
 201b104:	10c0028b 	ldhu	r3,10(r2)
 201b108:	e0bffe17 	ldw	r2,-8(fp)
 201b10c:	1080020b 	ldhu	r2,8(r2)
 201b110:	18ffffcc 	andi	r3,r3,65535
 201b114:	10bfffcc 	andi	r2,r2,65535
 201b118:	18800c1e 	bne	r3,r2,201b14c <pbuf_copy+0x23c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 201b11c:	e0bffe17 	ldw	r2,-8(fp)
 201b120:	10800017 	ldw	r2,0(r2)
 201b124:	10000926 	beq	r2,zero,201b14c <pbuf_copy+0x23c>
 201b128:	01c08134 	movhi	r7,516
 201b12c:	39c53604 	addi	r7,r7,5336
 201b130:	0180e0c4 	movi	r6,899
 201b134:	01408134 	movhi	r5,516
 201b138:	29456e04 	addi	r5,r5,5560
 201b13c:	01008134 	movhi	r4,516
 201b140:	21054404 	addi	r4,r4,5392
 201b144:	2000bb00 	call	2000bb0 <printf>
 201b148:	003fff06 	br	201b148 <__alt_mem_mem_0+0xfcffb148>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 201b14c:	e0bfff17 	ldw	r2,-4(fp)
 201b150:	103f8b1e 	bne	r2,zero,201af80 <__alt_mem_mem_0+0xfcffaf80>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 201b154:	0005883a 	mov	r2,zero
}
 201b158:	e037883a 	mov	sp,fp
 201b15c:	dfc00117 	ldw	ra,4(sp)
 201b160:	df000017 	ldw	fp,0(sp)
 201b164:	dec00204 	addi	sp,sp,8
 201b168:	f800283a 	ret

0201b16c <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 201b16c:	defff704 	addi	sp,sp,-36
 201b170:	dfc00815 	stw	ra,32(sp)
 201b174:	df000715 	stw	fp,28(sp)
 201b178:	df000704 	addi	fp,sp,28
 201b17c:	e13ffc15 	stw	r4,-16(fp)
 201b180:	e17ffd15 	stw	r5,-12(fp)
 201b184:	3007883a 	mov	r3,r6
 201b188:	3805883a 	mov	r2,r7
 201b18c:	e0fffe0d 	sth	r3,-8(fp)
 201b190:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 201b194:	e03ffb0d 	sth	zero,-20(fp)

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 201b198:	e0bffc17 	ldw	r2,-16(fp)
 201b19c:	1000091e 	bne	r2,zero,201b1c4 <pbuf_copy_partial+0x58>
 201b1a0:	01c08134 	movhi	r7,516
 201b1a4:	39c53604 	addi	r7,r7,5336
 201b1a8:	0180e744 	movi	r6,925
 201b1ac:	01408134 	movhi	r5,516
 201b1b0:	29457904 	addi	r5,r5,5604
 201b1b4:	01008134 	movhi	r4,516
 201b1b8:	21054404 	addi	r4,r4,5392
 201b1bc:	2000bb00 	call	2000bb0 <printf>
 201b1c0:	003fff06 	br	201b1c0 <__alt_mem_mem_0+0xfcffb1c0>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 201b1c4:	e0bffd17 	ldw	r2,-12(fp)
 201b1c8:	1000091e 	bne	r2,zero,201b1f0 <pbuf_copy_partial+0x84>
 201b1cc:	01c08134 	movhi	r7,516
 201b1d0:	39c53604 	addi	r7,r7,5336
 201b1d4:	0180e784 	movi	r6,926
 201b1d8:	01408134 	movhi	r5,516
 201b1dc:	29458104 	addi	r5,r5,5636
 201b1e0:	01008134 	movhi	r4,516
 201b1e4:	21054404 	addi	r4,r4,5392
 201b1e8:	2000bb00 	call	2000bb0 <printf>
 201b1ec:	003fff06 	br	201b1ec <__alt_mem_mem_0+0xfcffb1ec>

  left = 0;
 201b1f0:	e03ffa0d 	sth	zero,-24(fp)

  if((buf == NULL) || (dataptr == NULL)) {
 201b1f4:	e0bffc17 	ldw	r2,-16(fp)
 201b1f8:	10000226 	beq	r2,zero,201b204 <pbuf_copy_partial+0x98>
 201b1fc:	e0bffd17 	ldw	r2,-12(fp)
 201b200:	1000021e 	bne	r2,zero,201b20c <pbuf_copy_partial+0xa0>
    return 0;
 201b204:	0005883a 	mov	r2,zero
 201b208:	00003a06 	br	201b2f4 <pbuf_copy_partial+0x188>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 201b20c:	e0bffc17 	ldw	r2,-16(fp)
 201b210:	e0bff915 	stw	r2,-28(fp)
 201b214:	00003206 	br	201b2e0 <pbuf_copy_partial+0x174>
    if ((offset != 0) && (offset >= p->len)) {
 201b218:	e0bfff0b 	ldhu	r2,-4(fp)
 201b21c:	10000b26 	beq	r2,zero,201b24c <pbuf_copy_partial+0xe0>
 201b220:	e0bff917 	ldw	r2,-28(fp)
 201b224:	1080028b 	ldhu	r2,10(r2)
 201b228:	10bfffcc 	andi	r2,r2,65535
 201b22c:	e0ffff0b 	ldhu	r3,-4(fp)
 201b230:	18800636 	bltu	r3,r2,201b24c <pbuf_copy_partial+0xe0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 201b234:	e0bff917 	ldw	r2,-28(fp)
 201b238:	1080028b 	ldhu	r2,10(r2)
 201b23c:	e0ffff0b 	ldhu	r3,-4(fp)
 201b240:	1885c83a 	sub	r2,r3,r2
 201b244:	e0bfff0d 	sth	r2,-4(fp)
 201b248:	00002206 	br	201b2d4 <pbuf_copy_partial+0x168>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 201b24c:	e0bff917 	ldw	r2,-28(fp)
 201b250:	10c0028b 	ldhu	r3,10(r2)
 201b254:	e0bfff0b 	ldhu	r2,-4(fp)
 201b258:	1885c83a 	sub	r2,r3,r2
 201b25c:	e0bffa8d 	sth	r2,-22(fp)
      if (buf_copy_len > len)
 201b260:	e0bffa8b 	ldhu	r2,-22(fp)
 201b264:	e0fffe0b 	ldhu	r3,-8(fp)
 201b268:	1880022e 	bgeu	r3,r2,201b274 <pbuf_copy_partial+0x108>
          buf_copy_len = len;
 201b26c:	e0bffe0b 	ldhu	r2,-8(fp)
 201b270:	e0bffa8d 	sth	r2,-22(fp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 201b274:	e0bffa0b 	ldhu	r2,-24(fp)
 201b278:	e0fffd17 	ldw	r3,-12(fp)
 201b27c:	1889883a 	add	r4,r3,r2
 201b280:	e0bff917 	ldw	r2,-28(fp)
 201b284:	10c00117 	ldw	r3,4(r2)
 201b288:	e0bfff0b 	ldhu	r2,-4(fp)
 201b28c:	1885883a 	add	r2,r3,r2
 201b290:	e0fffa8b 	ldhu	r3,-22(fp)
 201b294:	180d883a 	mov	r6,r3
 201b298:	100b883a 	mov	r5,r2
 201b29c:	20060240 	call	2006024 <memcpy>
      copied_total += buf_copy_len;
 201b2a0:	e0fffb0b 	ldhu	r3,-20(fp)
 201b2a4:	e0bffa8b 	ldhu	r2,-22(fp)
 201b2a8:	1885883a 	add	r2,r3,r2
 201b2ac:	e0bffb0d 	sth	r2,-20(fp)
      left += buf_copy_len;
 201b2b0:	e0fffa0b 	ldhu	r3,-24(fp)
 201b2b4:	e0bffa8b 	ldhu	r2,-22(fp)
 201b2b8:	1885883a 	add	r2,r3,r2
 201b2bc:	e0bffa0d 	sth	r2,-24(fp)
      len -= buf_copy_len;
 201b2c0:	e0fffe0b 	ldhu	r3,-8(fp)
 201b2c4:	e0bffa8b 	ldhu	r2,-22(fp)
 201b2c8:	1885c83a 	sub	r2,r3,r2
 201b2cc:	e0bffe0d 	sth	r2,-8(fp)
      offset = 0;
 201b2d0:	e03fff0d 	sth	zero,-4(fp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 201b2d4:	e0bff917 	ldw	r2,-28(fp)
 201b2d8:	10800017 	ldw	r2,0(r2)
 201b2dc:	e0bff915 	stw	r2,-28(fp)
 201b2e0:	e0bffe0b 	ldhu	r2,-8(fp)
 201b2e4:	10000226 	beq	r2,zero,201b2f0 <pbuf_copy_partial+0x184>
 201b2e8:	e0bff917 	ldw	r2,-28(fp)
 201b2ec:	103fca1e 	bne	r2,zero,201b218 <__alt_mem_mem_0+0xfcffb218>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
 201b2f0:	e0bffb0b 	ldhu	r2,-20(fp)
}
 201b2f4:	e037883a 	mov	sp,fp
 201b2f8:	dfc00117 	ldw	ra,4(sp)
 201b2fc:	df000017 	ldw	fp,0(sp)
 201b300:	dec00204 	addi	sp,sp,8
 201b304:	f800283a 	ret

0201b308 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 201b308:	defff804 	addi	sp,sp,-32
 201b30c:	dfc00715 	stw	ra,28(sp)
 201b310:	df000615 	stw	fp,24(sp)
 201b314:	df000604 	addi	fp,sp,24
 201b318:	e13ffd15 	stw	r4,-12(fp)
 201b31c:	e17ffe15 	stw	r5,-8(fp)
 201b320:	3005883a 	mov	r2,r6
 201b324:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
 201b328:	e0bfff0b 	ldhu	r2,-4(fp)
 201b32c:	e0bffb8d 	sth	r2,-18(fp)
  u16_t copied_total = 0;
 201b330:	e03ffc0d 	sth	zero,-16(fp)

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 201b334:	e0bffd17 	ldw	r2,-12(fp)
 201b338:	1000091e 	bne	r2,zero,201b360 <pbuf_take+0x58>
 201b33c:	01c08134 	movhi	r7,516
 201b340:	39c53604 	addi	r7,r7,5336
 201b344:	0180f344 	movi	r6,973
 201b348:	01408134 	movhi	r5,516
 201b34c:	29458a04 	addi	r5,r5,5672
 201b350:	01008134 	movhi	r4,516
 201b354:	21054404 	addi	r4,r4,5392
 201b358:	2000bb00 	call	2000bb0 <printf>
 201b35c:	003fff06 	br	201b35c <__alt_mem_mem_0+0xfcffb35c>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 201b360:	e0bffe17 	ldw	r2,-8(fp)
 201b364:	1000091e 	bne	r2,zero,201b38c <pbuf_take+0x84>
 201b368:	01c08134 	movhi	r7,516
 201b36c:	39c53604 	addi	r7,r7,5336
 201b370:	0180f384 	movi	r6,974
 201b374:	01408134 	movhi	r5,516
 201b378:	29459004 	addi	r5,r5,5696
 201b37c:	01008134 	movhi	r4,516
 201b380:	21054404 	addi	r4,r4,5392
 201b384:	2000bb00 	call	2000bb0 <printf>
 201b388:	003fff06 	br	201b388 <__alt_mem_mem_0+0xfcffb388>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 201b38c:	e0bffd17 	ldw	r2,-12(fp)
 201b390:	10000726 	beq	r2,zero,201b3b0 <pbuf_take+0xa8>
 201b394:	e0bffe17 	ldw	r2,-8(fp)
 201b398:	10000526 	beq	r2,zero,201b3b0 <pbuf_take+0xa8>
 201b39c:	e0bffd17 	ldw	r2,-12(fp)
 201b3a0:	1080020b 	ldhu	r2,8(r2)
 201b3a4:	10ffffcc 	andi	r3,r2,65535
 201b3a8:	e0bfff0b 	ldhu	r2,-4(fp)
 201b3ac:	1880022e 	bgeu	r3,r2,201b3b8 <pbuf_take+0xb0>
    return ERR_ARG;
 201b3b0:	00bffc84 	movi	r2,-14
 201b3b4:	00002406 	br	201b448 <pbuf_take+0x140>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 201b3b8:	e0bffd17 	ldw	r2,-12(fp)
 201b3bc:	e0bffa15 	stw	r2,-24(fp)
 201b3c0:	00001e06 	br	201b43c <pbuf_take+0x134>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
 201b3c4:	e0bffb8b 	ldhu	r2,-18(fp)
 201b3c8:	e0bffb0d 	sth	r2,-20(fp)
    if (buf_copy_len > p->len) {
 201b3cc:	e0bffa17 	ldw	r2,-24(fp)
 201b3d0:	1080028b 	ldhu	r2,10(r2)
 201b3d4:	10ffffcc 	andi	r3,r2,65535
 201b3d8:	e0bffb0b 	ldhu	r2,-20(fp)
 201b3dc:	1880032e 	bgeu	r3,r2,201b3ec <pbuf_take+0xe4>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 201b3e0:	e0bffa17 	ldw	r2,-24(fp)
 201b3e4:	1080028b 	ldhu	r2,10(r2)
 201b3e8:	e0bffb0d 	sth	r2,-20(fp)
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 201b3ec:	e0bffa17 	ldw	r2,-24(fp)
 201b3f0:	11000117 	ldw	r4,4(r2)
 201b3f4:	e0bffc0b 	ldhu	r2,-16(fp)
 201b3f8:	e0fffe17 	ldw	r3,-8(fp)
 201b3fc:	1885883a 	add	r2,r3,r2
 201b400:	e0fffb0b 	ldhu	r3,-20(fp)
 201b404:	180d883a 	mov	r6,r3
 201b408:	100b883a 	mov	r5,r2
 201b40c:	20060240 	call	2006024 <memcpy>
    total_copy_len -= buf_copy_len;
 201b410:	e0fffb8b 	ldhu	r3,-18(fp)
 201b414:	e0bffb0b 	ldhu	r2,-20(fp)
 201b418:	1885c83a 	sub	r2,r3,r2
 201b41c:	e0bffb8d 	sth	r2,-18(fp)
    copied_total += buf_copy_len;
 201b420:	e0fffc0b 	ldhu	r3,-16(fp)
 201b424:	e0bffb0b 	ldhu	r2,-20(fp)
 201b428:	1885883a 	add	r2,r3,r2
 201b42c:	e0bffc0d 	sth	r2,-16(fp)
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 201b430:	e0bffa17 	ldw	r2,-24(fp)
 201b434:	10800017 	ldw	r2,0(r2)
 201b438:	e0bffa15 	stw	r2,-24(fp)
 201b43c:	e0bffb8b 	ldhu	r2,-18(fp)
 201b440:	103fe01e 	bne	r2,zero,201b3c4 <__alt_mem_mem_0+0xfcffb3c4>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 201b444:	0005883a 	mov	r2,zero
}
 201b448:	e037883a 	mov	sp,fp
 201b44c:	dfc00117 	ldw	ra,4(sp)
 201b450:	df000017 	ldw	fp,0(sp)
 201b454:	dec00204 	addi	sp,sp,8
 201b458:	f800283a 	ret

0201b45c <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 201b45c:	defffa04 	addi	sp,sp,-24
 201b460:	dfc00515 	stw	ra,20(sp)
 201b464:	df000415 	stw	fp,16(sp)
 201b468:	df000404 	addi	fp,sp,16
 201b46c:	e13ffe15 	stw	r4,-8(fp)
 201b470:	e17fff15 	stw	r5,-4(fp)
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 201b474:	e0bffe17 	ldw	r2,-8(fp)
 201b478:	10800017 	ldw	r2,0(r2)
 201b47c:	1000021e 	bne	r2,zero,201b488 <pbuf_coalesce+0x2c>
    return p;
 201b480:	e0bffe17 	ldw	r2,-8(fp)
 201b484:	00001306 	br	201b4d4 <pbuf_coalesce+0x78>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 201b488:	e0bffe17 	ldw	r2,-8(fp)
 201b48c:	1080020b 	ldhu	r2,8(r2)
 201b490:	10bfffcc 	andi	r2,r2,65535
 201b494:	000d883a 	mov	r6,zero
 201b498:	100b883a 	mov	r5,r2
 201b49c:	e13fff17 	ldw	r4,-4(fp)
 201b4a0:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201b4a4:	e0bffc15 	stw	r2,-16(fp)
  if (q == NULL) {
 201b4a8:	e0bffc17 	ldw	r2,-16(fp)
 201b4ac:	1000021e 	bne	r2,zero,201b4b8 <pbuf_coalesce+0x5c>
    /* @todo: what do we do now? */
    return p;
 201b4b0:	e0bffe17 	ldw	r2,-8(fp)
 201b4b4:	00000706 	br	201b4d4 <pbuf_coalesce+0x78>
  }
  err = pbuf_copy(q, p);
 201b4b8:	e17ffe17 	ldw	r5,-8(fp)
 201b4bc:	e13ffc17 	ldw	r4,-16(fp)
 201b4c0:	201af100 	call	201af10 <pbuf_copy>
 201b4c4:	e0bffd05 	stb	r2,-12(fp)
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
 201b4c8:	e13ffe17 	ldw	r4,-8(fp)
 201b4cc:	201ab680 	call	201ab68 <pbuf_free>
  return q;
 201b4d0:	e0bffc17 	ldw	r2,-16(fp)
}
 201b4d4:	e037883a 	mov	sp,fp
 201b4d8:	dfc00117 	ldw	ra,4(sp)
 201b4dc:	df000017 	ldw	fp,0(sp)
 201b4e0:	dec00204 	addi	sp,sp,8
 201b4e4:	f800283a 	ret

0201b4e8 <pbuf_fill_chksum>:
 *         within the (first) pbuf (no pbuf queues!)
 */
err_t
pbuf_fill_chksum(struct pbuf *p, u16_t start_offset, const void *dataptr,
                 u16_t len, u16_t *chksum)
{
 201b4e8:	defff704 	addi	sp,sp,-36
 201b4ec:	dfc00815 	stw	ra,32(sp)
 201b4f0:	df000715 	stw	fp,28(sp)
 201b4f4:	df000704 	addi	fp,sp,28
 201b4f8:	e13ffc15 	stw	r4,-16(fp)
 201b4fc:	2807883a 	mov	r3,r5
 201b500:	e1bffe15 	stw	r6,-8(fp)
 201b504:	3805883a 	mov	r2,r7
 201b508:	e0fffd0d 	sth	r3,-12(fp)
 201b50c:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  LWIP_ASSERT("dataptr != NULL", dataptr != NULL);
  LWIP_ASSERT("chksum != NULL", chksum != NULL);
  LWIP_ASSERT("len != 0", len != 0);

  if ((start_offset >= p->len) || (start_offset + len > p->len)) {
 201b510:	e0bffc17 	ldw	r2,-16(fp)
 201b514:	1080028b 	ldhu	r2,10(r2)
 201b518:	10bfffcc 	andi	r2,r2,65535
 201b51c:	e0fffd0b 	ldhu	r3,-12(fp)
 201b520:	1880072e 	bgeu	r3,r2,201b540 <pbuf_fill_chksum+0x58>
 201b524:	e0fffd0b 	ldhu	r3,-12(fp)
 201b528:	e0bfff0b 	ldhu	r2,-4(fp)
 201b52c:	1885883a 	add	r2,r3,r2
 201b530:	e0fffc17 	ldw	r3,-16(fp)
 201b534:	18c0028b 	ldhu	r3,10(r3)
 201b538:	18ffffcc 	andi	r3,r3,65535
 201b53c:	1880020e 	bge	r3,r2,201b548 <pbuf_fill_chksum+0x60>
    return ERR_ARG;
 201b540:	00bffc84 	movi	r2,-14
 201b544:	00002606 	br	201b5e0 <pbuf_fill_chksum+0xf8>
  }

  dst_ptr = ((char*)p->payload) + start_offset;
 201b548:	e0bffc17 	ldw	r2,-16(fp)
 201b54c:	10c00117 	ldw	r3,4(r2)
 201b550:	e0bffd0b 	ldhu	r2,-12(fp)
 201b554:	1885883a 	add	r2,r3,r2
 201b558:	e0bffa15 	stw	r2,-24(fp)
  copy_chksum = LWIP_CHKSUM_COPY(dst_ptr, dataptr, len);
 201b55c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b560:	100d883a 	mov	r6,r2
 201b564:	e17ffe17 	ldw	r5,-8(fp)
 201b568:	e13ffa17 	ldw	r4,-24(fp)
 201b56c:	2031cc40 	call	2031cc4 <lwip_chksum_copy>
 201b570:	e0bff90d 	sth	r2,-28(fp)
  if ((start_offset & 1) != 0) {
 201b574:	e0bffd0b 	ldhu	r2,-12(fp)
 201b578:	1080004c 	andi	r2,r2,1
 201b57c:	10000726 	beq	r2,zero,201b59c <pbuf_fill_chksum+0xb4>
    copy_chksum = SWAP_BYTES_IN_WORD(copy_chksum);
 201b580:	e0bff90b 	ldhu	r2,-28(fp)
 201b584:	1004d23a 	srli	r2,r2,8
 201b588:	1007883a 	mov	r3,r2
 201b58c:	e0bff90b 	ldhu	r2,-28(fp)
 201b590:	1004923a 	slli	r2,r2,8
 201b594:	1884b03a 	or	r2,r3,r2
 201b598:	e0bff90d 	sth	r2,-28(fp)
  }
  acc = *chksum;
 201b59c:	e0800217 	ldw	r2,8(fp)
 201b5a0:	1080000b 	ldhu	r2,0(r2)
 201b5a4:	10bfffcc 	andi	r2,r2,65535
 201b5a8:	e0bffb15 	stw	r2,-20(fp)
  acc += copy_chksum;
 201b5ac:	e0bff90b 	ldhu	r2,-28(fp)
 201b5b0:	e0fffb17 	ldw	r3,-20(fp)
 201b5b4:	1885883a 	add	r2,r3,r2
 201b5b8:	e0bffb15 	stw	r2,-20(fp)
  *chksum = FOLD_U32T(acc);
 201b5bc:	e0bffb17 	ldw	r2,-20(fp)
 201b5c0:	1004d43a 	srli	r2,r2,16
 201b5c4:	1007883a 	mov	r3,r2
 201b5c8:	e0bffb17 	ldw	r2,-20(fp)
 201b5cc:	1885883a 	add	r2,r3,r2
 201b5d0:	1007883a 	mov	r3,r2
 201b5d4:	e0800217 	ldw	r2,8(fp)
 201b5d8:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 201b5dc:	0005883a 	mov	r2,zero
}
 201b5e0:	e037883a 	mov	sp,fp
 201b5e4:	dfc00117 	ldw	ra,4(sp)
 201b5e8:	df000017 	ldw	fp,0(sp)
 201b5ec:	dec00204 	addi	sp,sp,8
 201b5f0:	f800283a 	ret

0201b5f4 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(struct pbuf* p, u16_t offset)
{
 201b5f4:	defffb04 	addi	sp,sp,-20
 201b5f8:	df000415 	stw	fp,16(sp)
 201b5fc:	df000404 	addi	fp,sp,16
 201b600:	e13ffe15 	stw	r4,-8(fp)
 201b604:	2805883a 	mov	r2,r5
 201b608:	e0bfff0d 	sth	r2,-4(fp)
  u16_t copy_from = offset;
 201b60c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b610:	e0bffc0d 	sth	r2,-16(fp)
  struct pbuf* q = p;
 201b614:	e0bffe17 	ldw	r2,-8(fp)
 201b618:	e0bffd15 	stw	r2,-12(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 201b61c:	00000806 	br	201b640 <pbuf_get_at+0x4c>
    copy_from -= q->len;
 201b620:	e0bffd17 	ldw	r2,-12(fp)
 201b624:	1080028b 	ldhu	r2,10(r2)
 201b628:	e0fffc0b 	ldhu	r3,-16(fp)
 201b62c:	1885c83a 	sub	r2,r3,r2
 201b630:	e0bffc0d 	sth	r2,-16(fp)
    q = q->next;
 201b634:	e0bffd17 	ldw	r2,-12(fp)
 201b638:	10800017 	ldw	r2,0(r2)
 201b63c:	e0bffd15 	stw	r2,-12(fp)
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 201b640:	e0bffd17 	ldw	r2,-12(fp)
 201b644:	10000526 	beq	r2,zero,201b65c <pbuf_get_at+0x68>
 201b648:	e0bffd17 	ldw	r2,-12(fp)
 201b64c:	1080028b 	ldhu	r2,10(r2)
 201b650:	10bfffcc 	andi	r2,r2,65535
 201b654:	e0fffc0b 	ldhu	r3,-16(fp)
 201b658:	18bff12e 	bgeu	r3,r2,201b620 <__alt_mem_mem_0+0xfcffb620>
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
 201b65c:	e0bffd17 	ldw	r2,-12(fp)
 201b660:	10000b26 	beq	r2,zero,201b690 <pbuf_get_at+0x9c>
 201b664:	e0bffd17 	ldw	r2,-12(fp)
 201b668:	1080028b 	ldhu	r2,10(r2)
 201b66c:	10bfffcc 	andi	r2,r2,65535
 201b670:	e0fffc0b 	ldhu	r3,-16(fp)
 201b674:	1880062e 	bgeu	r3,r2,201b690 <pbuf_get_at+0x9c>
    return ((u8_t*)q->payload)[copy_from];
 201b678:	e0bffd17 	ldw	r2,-12(fp)
 201b67c:	10c00117 	ldw	r3,4(r2)
 201b680:	e0bffc0b 	ldhu	r2,-16(fp)
 201b684:	1885883a 	add	r2,r3,r2
 201b688:	10800003 	ldbu	r2,0(r2)
 201b68c:	00000106 	br	201b694 <pbuf_get_at+0xa0>
  }
  return 0;
 201b690:	0005883a 	mov	r2,zero
}
 201b694:	e037883a 	mov	sp,fp
 201b698:	df000017 	ldw	fp,0(sp)
 201b69c:	dec00104 	addi	sp,sp,4
 201b6a0:	f800283a 	ret

0201b6a4 <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
 201b6a4:	defff704 	addi	sp,sp,-36
 201b6a8:	dfc00815 	stw	ra,32(sp)
 201b6ac:	df000715 	stw	fp,28(sp)
 201b6b0:	df000704 	addi	fp,sp,28
 201b6b4:	e13ffc15 	stw	r4,-16(fp)
 201b6b8:	2807883a 	mov	r3,r5
 201b6bc:	e1bffe15 	stw	r6,-8(fp)
 201b6c0:	3805883a 	mov	r2,r7
 201b6c4:	e0fffd0d 	sth	r3,-12(fp)
 201b6c8:	e0bfff0d 	sth	r2,-4(fp)
  u16_t start = offset;
 201b6cc:	e0bffd0b 	ldhu	r2,-12(fp)
 201b6d0:	e0bff90d 	sth	r2,-28(fp)
  struct pbuf* q = p;
 201b6d4:	e0bffc17 	ldw	r2,-16(fp)
 201b6d8:	e0bffa15 	stw	r2,-24(fp)

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 201b6dc:	00000806 	br	201b700 <pbuf_memcmp+0x5c>
    start -= q->len;
 201b6e0:	e0bffa17 	ldw	r2,-24(fp)
 201b6e4:	1080028b 	ldhu	r2,10(r2)
 201b6e8:	e0fff90b 	ldhu	r3,-28(fp)
 201b6ec:	1885c83a 	sub	r2,r3,r2
 201b6f0:	e0bff90d 	sth	r2,-28(fp)
    q = q->next;
 201b6f4:	e0bffa17 	ldw	r2,-24(fp)
 201b6f8:	10800017 	ldw	r2,0(r2)
 201b6fc:	e0bffa15 	stw	r2,-24(fp)
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 201b700:	e0bffa17 	ldw	r2,-24(fp)
 201b704:	10000526 	beq	r2,zero,201b71c <pbuf_memcmp+0x78>
 201b708:	e0bffa17 	ldw	r2,-24(fp)
 201b70c:	1080028b 	ldhu	r2,10(r2)
 201b710:	10bfffcc 	andi	r2,r2,65535
 201b714:	e0fff90b 	ldhu	r3,-28(fp)
 201b718:	18bff12e 	bgeu	r3,r2,201b6e0 <__alt_mem_mem_0+0xfcffb6e0>
    start -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
 201b71c:	e0bffa17 	ldw	r2,-24(fp)
 201b720:	10002226 	beq	r2,zero,201b7ac <pbuf_memcmp+0x108>
 201b724:	e0bffa17 	ldw	r2,-24(fp)
 201b728:	1080028b 	ldhu	r2,10(r2)
 201b72c:	10bfffcc 	andi	r2,r2,65535
 201b730:	e0fff90b 	ldhu	r3,-28(fp)
 201b734:	18801d2e 	bgeu	r3,r2,201b7ac <pbuf_memcmp+0x108>
    u16_t i;
    for(i = 0; i < n; i++) {
 201b738:	e03ffb0d 	sth	zero,-20(fp)
 201b73c:	00001606 	br	201b798 <pbuf_memcmp+0xf4>
      u8_t a = pbuf_get_at(q, start + i);
 201b740:	e0fff90b 	ldhu	r3,-28(fp)
 201b744:	e0bffb0b 	ldhu	r2,-20(fp)
 201b748:	1885883a 	add	r2,r3,r2
 201b74c:	10bfffcc 	andi	r2,r2,65535
 201b750:	100b883a 	mov	r5,r2
 201b754:	e13ffa17 	ldw	r4,-24(fp)
 201b758:	201b5f40 	call	201b5f4 <pbuf_get_at>
 201b75c:	e0bffb85 	stb	r2,-18(fp)
      u8_t b = ((u8_t*)s2)[i];
 201b760:	e0bffb0b 	ldhu	r2,-20(fp)
 201b764:	e0fffe17 	ldw	r3,-8(fp)
 201b768:	1885883a 	add	r2,r3,r2
 201b76c:	10800003 	ldbu	r2,0(r2)
 201b770:	e0bffbc5 	stb	r2,-17(fp)
      if (a != b) {
 201b774:	e0fffb83 	ldbu	r3,-18(fp)
 201b778:	e0bffbc3 	ldbu	r2,-17(fp)
 201b77c:	18800326 	beq	r3,r2,201b78c <pbuf_memcmp+0xe8>
        return i+1;
 201b780:	e0bffb0b 	ldhu	r2,-20(fp)
 201b784:	10800044 	addi	r2,r2,1
 201b788:	00000906 	br	201b7b0 <pbuf_memcmp+0x10c>
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
 201b78c:	e0bffb0b 	ldhu	r2,-20(fp)
 201b790:	10800044 	addi	r2,r2,1
 201b794:	e0bffb0d 	sth	r2,-20(fp)
 201b798:	e0fffb0b 	ldhu	r3,-20(fp)
 201b79c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b7a0:	18bfe736 	bltu	r3,r2,201b740 <__alt_mem_mem_0+0xfcffb740>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
 201b7a4:	0005883a 	mov	r2,zero
 201b7a8:	00000106 	br	201b7b0 <pbuf_memcmp+0x10c>
  }
  return 0xffff;
 201b7ac:	00bfffc4 	movi	r2,-1
}
 201b7b0:	e037883a 	mov	sp,fp
 201b7b4:	dfc00117 	ldw	ra,4(sp)
 201b7b8:	df000017 	ldw	fp,0(sp)
 201b7bc:	dec00204 	addi	sp,sp,8
 201b7c0:	f800283a 	ret

0201b7c4 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
 201b7c4:	defff804 	addi	sp,sp,-32
 201b7c8:	dfc00715 	stw	ra,28(sp)
 201b7cc:	df000615 	stw	fp,24(sp)
 201b7d0:	df000604 	addi	fp,sp,24
 201b7d4:	e13ffc15 	stw	r4,-16(fp)
 201b7d8:	e17ffd15 	stw	r5,-12(fp)
 201b7dc:	3007883a 	mov	r3,r6
 201b7e0:	3805883a 	mov	r2,r7
 201b7e4:	e0fffe0d 	sth	r3,-8(fp)
 201b7e8:	e0bfff0d 	sth	r2,-4(fp)
  u16_t i;
  u16_t max = p->tot_len - mem_len;
 201b7ec:	e0bffc17 	ldw	r2,-16(fp)
 201b7f0:	10c0020b 	ldhu	r3,8(r2)
 201b7f4:	e0bffe0b 	ldhu	r2,-8(fp)
 201b7f8:	1885c83a 	sub	r2,r3,r2
 201b7fc:	e0bffa8d 	sth	r2,-22(fp)
  if (p->tot_len >= mem_len + start_offset) {
 201b800:	e0bffc17 	ldw	r2,-16(fp)
 201b804:	1080020b 	ldhu	r2,8(r2)
 201b808:	10ffffcc 	andi	r3,r2,65535
 201b80c:	e13ffe0b 	ldhu	r4,-8(fp)
 201b810:	e0bfff0b 	ldhu	r2,-4(fp)
 201b814:	2085883a 	add	r2,r4,r2
 201b818:	18801616 	blt	r3,r2,201b874 <pbuf_memfind+0xb0>
    for(i = start_offset; i <= max; ) {
 201b81c:	e0bfff0b 	ldhu	r2,-4(fp)
 201b820:	e0bffa0d 	sth	r2,-24(fp)
 201b824:	00001006 	br	201b868 <pbuf_memfind+0xa4>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 201b828:	e0bffa0b 	ldhu	r2,-24(fp)
 201b82c:	e0fffe0b 	ldhu	r3,-8(fp)
 201b830:	180f883a 	mov	r7,r3
 201b834:	e1bffd17 	ldw	r6,-12(fp)
 201b838:	100b883a 	mov	r5,r2
 201b83c:	e13ffc17 	ldw	r4,-16(fp)
 201b840:	201b6a40 	call	201b6a4 <pbuf_memcmp>
 201b844:	e0bffb0d 	sth	r2,-20(fp)
      if (plus == 0) {
 201b848:	e0bffb0b 	ldhu	r2,-20(fp)
 201b84c:	1000021e 	bne	r2,zero,201b858 <pbuf_memfind+0x94>
        return i;
 201b850:	e0bffa0b 	ldhu	r2,-24(fp)
 201b854:	00000806 	br	201b878 <pbuf_memfind+0xb4>
      } else {
        i += plus;
 201b858:	e0fffa0b 	ldhu	r3,-24(fp)
 201b85c:	e0bffb0b 	ldhu	r2,-20(fp)
 201b860:	1885883a 	add	r2,r3,r2
 201b864:	e0bffa0d 	sth	r2,-24(fp)
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
 201b868:	e0bffa0b 	ldhu	r2,-24(fp)
 201b86c:	e0fffa8b 	ldhu	r3,-22(fp)
 201b870:	18bfed2e 	bgeu	r3,r2,201b828 <__alt_mem_mem_0+0xfcffb828>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
 201b874:	00bfffc4 	movi	r2,-1
}
 201b878:	e037883a 	mov	sp,fp
 201b87c:	dfc00117 	ldw	ra,4(sp)
 201b880:	df000017 	ldw	fp,0(sp)
 201b884:	dec00204 	addi	sp,sp,8
 201b888:	f800283a 	ret

0201b88c <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
 201b88c:	defffb04 	addi	sp,sp,-20
 201b890:	dfc00415 	stw	ra,16(sp)
 201b894:	df000315 	stw	fp,12(sp)
 201b898:	df000304 	addi	fp,sp,12
 201b89c:	e13ffe15 	stw	r4,-8(fp)
 201b8a0:	e17fff15 	stw	r5,-4(fp)
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 201b8a4:	e0bfff17 	ldw	r2,-4(fp)
 201b8a8:	10000b26 	beq	r2,zero,201b8d8 <pbuf_strstr+0x4c>
 201b8ac:	e0bfff17 	ldw	r2,-4(fp)
 201b8b0:	10800003 	ldbu	r2,0(r2)
 201b8b4:	10803fcc 	andi	r2,r2,255
 201b8b8:	1080201c 	xori	r2,r2,128
 201b8bc:	10bfe004 	addi	r2,r2,-128
 201b8c0:	10000526 	beq	r2,zero,201b8d8 <pbuf_strstr+0x4c>
 201b8c4:	e0bffe17 	ldw	r2,-8(fp)
 201b8c8:	1080020b 	ldhu	r2,8(r2)
 201b8cc:	10ffffcc 	andi	r3,r2,65535
 201b8d0:	00bfffd4 	movui	r2,65535
 201b8d4:	1880021e 	bne	r3,r2,201b8e0 <pbuf_strstr+0x54>
    return 0xFFFF;
 201b8d8:	00bfffc4 	movi	r2,-1
 201b8dc:	00000f06 	br	201b91c <pbuf_strstr+0x90>
  }
  substr_len = strlen(substr);
 201b8e0:	e13fff17 	ldw	r4,-4(fp)
 201b8e4:	20075700 	call	2007570 <strlen>
 201b8e8:	e0bffd15 	stw	r2,-12(fp)
  if (substr_len >= 0xFFFF) {
 201b8ec:	e0bffd17 	ldw	r2,-12(fp)
 201b8f0:	10bffff0 	cmpltui	r2,r2,65535
 201b8f4:	1000021e 	bne	r2,zero,201b900 <pbuf_strstr+0x74>
    return 0xFFFF;
 201b8f8:	00bfffc4 	movi	r2,-1
 201b8fc:	00000706 	br	201b91c <pbuf_strstr+0x90>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 201b900:	e0bffd17 	ldw	r2,-12(fp)
 201b904:	10bfffcc 	andi	r2,r2,65535
 201b908:	000f883a 	mov	r7,zero
 201b90c:	100d883a 	mov	r6,r2
 201b910:	e17fff17 	ldw	r5,-4(fp)
 201b914:	e13ffe17 	ldw	r4,-8(fp)
 201b918:	201b7c40 	call	201b7c4 <pbuf_memfind>
}
 201b91c:	e037883a 	mov	sp,fp
 201b920:	dfc00117 	ldw	ra,4(sp)
 201b924:	df000017 	ldw	fp,0(sp)
 201b928:	dec00204 	addi	sp,sp,8
 201b92c:	f800283a 	ret

0201b930 <stats_init>:
#include <string.h>

struct stats_ lwip_stats;

void stats_init(void)
{
 201b930:	deffff04 	addi	sp,sp,-4
 201b934:	df000015 	stw	fp,0(sp)
 201b938:	d839883a 	mov	fp,sp
#endif /* MEMP_STATS */
#if MEM_STATS
  lwip_stats.mem.name = "MEM";
#endif /* MEM_STATS */
#endif /* LWIP_DEBUG */
}
 201b93c:	0001883a 	nop
 201b940:	e037883a 	mov	sp,fp
 201b944:	df000017 	ldw	fp,0(sp)
 201b948:	dec00104 	addi	sp,sp,4
 201b94c:	f800283a 	ret

0201b950 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 201b950:	deffff04 	addi	sp,sp,-4
 201b954:	df000015 	stw	fp,0(sp)
 201b958:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
 201b95c:	0001883a 	nop
 201b960:	e037883a 	mov	sp,fp
 201b964:	df000017 	ldw	fp,0(sp)
 201b968:	dec00104 	addi	sp,sp,4
 201b96c:	f800283a 	ret

0201b970 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 201b970:	defffe04 	addi	sp,sp,-8
 201b974:	dfc00115 	stw	ra,4(sp)
 201b978:	df000015 	stw	fp,0(sp)
 201b97c:	d839883a 	mov	fp,sp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 201b980:	201d1940 	call	201d194 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 201b984:	d0a7f603 	ldbu	r2,-24616(gp)
 201b988:	10800044 	addi	r2,r2,1
 201b98c:	d0a7f605 	stb	r2,-24616(gp)
 201b990:	d0a7f603 	ldbu	r2,-24616(gp)
 201b994:	10803fcc 	andi	r2,r2,255
 201b998:	1080004c 	andi	r2,r2,1
 201b99c:	10000126 	beq	r2,zero,201b9a4 <tcp_tmr+0x34>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 201b9a0:	201ca5c0 	call	201ca5c <tcp_slowtmr>
  }
}
 201b9a4:	0001883a 	nop
 201b9a8:	e037883a 	mov	sp,fp
 201b9ac:	dfc00117 	ldw	ra,4(sp)
 201b9b0:	df000017 	ldw	fp,0(sp)
 201b9b4:	dec00204 	addi	sp,sp,8
 201b9b8:	f800283a 	ret

0201b9bc <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 201b9bc:	defff904 	addi	sp,sp,-28
 201b9c0:	dfc00615 	stw	ra,24(sp)
 201b9c4:	df000515 	stw	fp,20(sp)
 201b9c8:	df000504 	addi	fp,sp,20
 201b9cc:	e13ffe15 	stw	r4,-8(fp)
 201b9d0:	2805883a 	mov	r2,r5
 201b9d4:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 201b9d8:	e0bfff03 	ldbu	r2,-4(fp)
 201b9dc:	10005126 	beq	r2,zero,201bb24 <tcp_close_shutdown+0x168>
 201b9e0:	e0bffe17 	ldw	r2,-8(fp)
 201b9e4:	10800617 	ldw	r2,24(r2)
 201b9e8:	10800120 	cmpeqi	r2,r2,4
 201b9ec:	1000041e 	bne	r2,zero,201ba00 <tcp_close_shutdown+0x44>
 201b9f0:	e0bffe17 	ldw	r2,-8(fp)
 201b9f4:	10800617 	ldw	r2,24(r2)
 201b9f8:	108001d8 	cmpnei	r2,r2,7
 201b9fc:	1000491e 	bne	r2,zero,201bb24 <tcp_close_shutdown+0x168>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 201ba00:	e0bffe17 	ldw	r2,-8(fp)
 201ba04:	10801f17 	ldw	r2,124(r2)
 201ba08:	1000051e 	bne	r2,zero,201ba20 <tcp_close_shutdown+0x64>
 201ba0c:	e0bffe17 	ldw	r2,-8(fp)
 201ba10:	10800c0b 	ldhu	r2,48(r2)
 201ba14:	10bfffcc 	andi	r2,r2,65535
 201ba18:	10880020 	cmpeqi	r2,r2,8192
 201ba1c:	1000411e 	bne	r2,zero,201bb24 <tcp_close_shutdown+0x168>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201ba20:	e0bffe17 	ldw	r2,-8(fp)
 201ba24:	11001517 	ldw	r4,84(r2)
 201ba28:	e0bffe17 	ldw	r2,-8(fp)
 201ba2c:	11400b17 	ldw	r5,44(r2)
 201ba30:	e1bffe17 	ldw	r6,-8(fp)
 201ba34:	e0bffe17 	ldw	r2,-8(fp)
 201ba38:	11c00104 	addi	r7,r2,4
        pcb->local_port, pcb->remote_port);
 201ba3c:	e0bffe17 	ldw	r2,-8(fp)
 201ba40:	1080078b 	ldhu	r2,30(r2)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201ba44:	10bfffcc 	andi	r2,r2,65535
        pcb->local_port, pcb->remote_port);
 201ba48:	e0fffe17 	ldw	r3,-8(fp)
 201ba4c:	18c0080b 	ldhu	r3,32(r3)
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201ba50:	18ffffcc 	andi	r3,r3,65535
 201ba54:	d8c00115 	stw	r3,4(sp)
 201ba58:	d8800015 	stw	r2,0(sp)
 201ba5c:	202082c0 	call	202082c <tcp_rst>
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
 201ba60:	e13ffe17 	ldw	r4,-8(fp)
 201ba64:	201da8c0 	call	201da8c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 201ba68:	d0e7f717 	ldw	r3,-24612(gp)
 201ba6c:	e0bffe17 	ldw	r2,-8(fp)
 201ba70:	1880041e 	bne	r3,r2,201ba84 <tcp_close_shutdown+0xc8>
 201ba74:	d0a7f717 	ldw	r2,-24612(gp)
 201ba78:	10800317 	ldw	r2,12(r2)
 201ba7c:	d0a7f715 	stw	r2,-24612(gp)
 201ba80:	00001106 	br	201bac8 <tcp_close_shutdown+0x10c>
 201ba84:	d0a7f717 	ldw	r2,-24612(gp)
 201ba88:	d0a7fa15 	stw	r2,-24600(gp)
 201ba8c:	00000c06 	br	201bac0 <tcp_close_shutdown+0x104>
 201ba90:	d0a7fa17 	ldw	r2,-24600(gp)
 201ba94:	10c00317 	ldw	r3,12(r2)
 201ba98:	e0bffe17 	ldw	r2,-8(fp)
 201ba9c:	1880051e 	bne	r3,r2,201bab4 <tcp_close_shutdown+0xf8>
 201baa0:	d0a7fa17 	ldw	r2,-24600(gp)
 201baa4:	e0fffe17 	ldw	r3,-8(fp)
 201baa8:	18c00317 	ldw	r3,12(r3)
 201baac:	10c00315 	stw	r3,12(r2)
 201bab0:	00000506 	br	201bac8 <tcp_close_shutdown+0x10c>
 201bab4:	d0a7fa17 	ldw	r2,-24600(gp)
 201bab8:	10800317 	ldw	r2,12(r2)
 201babc:	d0a7fa15 	stw	r2,-24600(gp)
 201bac0:	d0a7fa17 	ldw	r2,-24600(gp)
 201bac4:	103ff21e 	bne	r2,zero,201ba90 <__alt_mem_mem_0+0xfcffba90>
 201bac8:	e0bffe17 	ldw	r2,-8(fp)
 201bacc:	10000315 	stw	zero,12(r2)
 201bad0:	00800044 	movi	r2,1
 201bad4:	d0a7f685 	stb	r2,-24614(gp)
      if (pcb->state == ESTABLISHED) {
 201bad8:	e0bffe17 	ldw	r2,-8(fp)
 201badc:	10800617 	ldw	r2,24(r2)
 201bae0:	10800118 	cmpnei	r2,r2,4
 201bae4:	10000a1e 	bne	r2,zero,201bb10 <tcp_close_shutdown+0x154>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 201bae8:	e0bffe17 	ldw	r2,-8(fp)
 201baec:	00c00284 	movi	r3,10
 201baf0:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 201baf4:	d0e7fc17 	ldw	r3,-24592(gp)
 201baf8:	e0bffe17 	ldw	r2,-8(fp)
 201bafc:	10c00315 	stw	r3,12(r2)
 201bb00:	e0bffe17 	ldw	r2,-8(fp)
 201bb04:	d0a7fc15 	stw	r2,-24592(gp)
 201bb08:	20215540 	call	2021554 <tcp_timer_needed>
 201bb0c:	00000306 	br	201bb1c <tcp_close_shutdown+0x160>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 201bb10:	e17ffe17 	ldw	r5,-8(fp)
 201bb14:	01000084 	movi	r4,2
 201bb18:	20346000 	call	2034600 <memp_free>
      }
      return ERR_OK;
 201bb1c:	0005883a 	mov	r2,zero
 201bb20:	00007406 	br	201bcf4 <tcp_close_shutdown+0x338>
    }
  }

  switch (pcb->state) {
 201bb24:	e0bffe17 	ldw	r2,-8(fp)
 201bb28:	10800617 	ldw	r2,24(r2)
 201bb2c:	10c00228 	cmpgeui	r3,r2,8
 201bb30:	1800611e 	bne	r3,zero,201bcb8 <tcp_close_shutdown+0x2fc>
 201bb34:	100690ba 	slli	r3,r2,2
 201bb38:	008080b4 	movhi	r2,514
 201bb3c:	10aed304 	addi	r2,r2,-17588
 201bb40:	1885883a 	add	r2,r3,r2
 201bb44:	10800017 	ldw	r2,0(r2)
 201bb48:	1000683a 	jmp	r2
 201bb4c:	0201bb6c 	andhi	r8,zero,1773
 201bb50:	0201bbfc 	xorhi	r8,zero,1775
 201bb54:	0201bc20 	cmpeqi	r8,zero,1776
 201bb58:	0201bc4c 	andi	r8,zero,1777
 201bb5c:	0201bc70 	cmpltui	r8,zero,1777
 201bb60:	0201bcb8 	rdprs	r8,zero,1778
 201bb64:	0201bcb8 	rdprs	r8,zero,1778
 201bb68:	0201bc94 	movui	r8,1778
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
 201bb6c:	e03ffd05 	stb	zero,-12(fp)
    if (pcb->local_port != 0) {
 201bb70:	e0bffe17 	ldw	r2,-8(fp)
 201bb74:	1080078b 	ldhu	r2,30(r2)
 201bb78:	10bfffcc 	andi	r2,r2,65535
 201bb7c:	10001a26 	beq	r2,zero,201bbe8 <tcp_close_shutdown+0x22c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 201bb80:	d0e7fb17 	ldw	r3,-24596(gp)
 201bb84:	e0bffe17 	ldw	r2,-8(fp)
 201bb88:	1880041e 	bne	r3,r2,201bb9c <tcp_close_shutdown+0x1e0>
 201bb8c:	d0a7fb17 	ldw	r2,-24596(gp)
 201bb90:	10800317 	ldw	r2,12(r2)
 201bb94:	d0a7fb15 	stw	r2,-24596(gp)
 201bb98:	00001106 	br	201bbe0 <tcp_close_shutdown+0x224>
 201bb9c:	d0a7fb17 	ldw	r2,-24596(gp)
 201bba0:	d0a7fa15 	stw	r2,-24600(gp)
 201bba4:	00000c06 	br	201bbd8 <tcp_close_shutdown+0x21c>
 201bba8:	d0a7fa17 	ldw	r2,-24600(gp)
 201bbac:	10c00317 	ldw	r3,12(r2)
 201bbb0:	e0bffe17 	ldw	r2,-8(fp)
 201bbb4:	1880051e 	bne	r3,r2,201bbcc <tcp_close_shutdown+0x210>
 201bbb8:	d0a7fa17 	ldw	r2,-24600(gp)
 201bbbc:	e0fffe17 	ldw	r3,-8(fp)
 201bbc0:	18c00317 	ldw	r3,12(r3)
 201bbc4:	10c00315 	stw	r3,12(r2)
 201bbc8:	00000506 	br	201bbe0 <tcp_close_shutdown+0x224>
 201bbcc:	d0a7fa17 	ldw	r2,-24600(gp)
 201bbd0:	10800317 	ldw	r2,12(r2)
 201bbd4:	d0a7fa15 	stw	r2,-24600(gp)
 201bbd8:	d0a7fa17 	ldw	r2,-24600(gp)
 201bbdc:	103ff21e 	bne	r2,zero,201bba8 <__alt_mem_mem_0+0xfcffbba8>
 201bbe0:	e0bffe17 	ldw	r2,-8(fp)
 201bbe4:	10000315 	stw	zero,12(r2)
    }
    memp_free(MEMP_TCP_PCB, pcb);
 201bbe8:	e17ffe17 	ldw	r5,-8(fp)
 201bbec:	01000084 	movi	r4,2
 201bbf0:	20346000 	call	2034600 <memp_free>
    pcb = NULL;
 201bbf4:	e03ffe15 	stw	zero,-8(fp)
    break;
 201bbf8:	00003706 	br	201bcd8 <tcp_close_shutdown+0x31c>
  case LISTEN:
    err = ERR_OK;
 201bbfc:	e03ffd05 	stb	zero,-12(fp)
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 201bc00:	e17ffe17 	ldw	r5,-8(fp)
 201bc04:	d127f904 	addi	r4,gp,-24604
 201bc08:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 201bc0c:	e17ffe17 	ldw	r5,-8(fp)
 201bc10:	010000c4 	movi	r4,3
 201bc14:	20346000 	call	2034600 <memp_free>
    pcb = NULL;
 201bc18:	e03ffe15 	stw	zero,-8(fp)
    break;
 201bc1c:	00002e06 	br	201bcd8 <tcp_close_shutdown+0x31c>
  case SYN_SENT:
    err = ERR_OK;
 201bc20:	e03ffd05 	stb	zero,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
 201bc24:	e17ffe17 	ldw	r5,-8(fp)
 201bc28:	d127f704 	addi	r4,gp,-24612
 201bc2c:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
 201bc30:	00800044 	movi	r2,1
 201bc34:	d0a7f685 	stb	r2,-24614(gp)
    memp_free(MEMP_TCP_PCB, pcb);
 201bc38:	e17ffe17 	ldw	r5,-8(fp)
 201bc3c:	01000084 	movi	r4,2
 201bc40:	20346000 	call	2034600 <memp_free>
    pcb = NULL;
 201bc44:	e03ffe15 	stw	zero,-8(fp)
    snmp_inc_tcpattemptfails();
    break;
 201bc48:	00002306 	br	201bcd8 <tcp_close_shutdown+0x31c>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 201bc4c:	e13ffe17 	ldw	r4,-8(fp)
 201bc50:	201e1e80 	call	201e1e8 <tcp_send_fin>
 201bc54:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 201bc58:	e0bffd07 	ldb	r2,-12(fp)
 201bc5c:	1000191e 	bne	r2,zero,201bcc4 <tcp_close_shutdown+0x308>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 201bc60:	e0bffe17 	ldw	r2,-8(fp)
 201bc64:	00c00144 	movi	r3,5
 201bc68:	10c00615 	stw	r3,24(r2)
    }
    break;
 201bc6c:	00001506 	br	201bcc4 <tcp_close_shutdown+0x308>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
 201bc70:	e13ffe17 	ldw	r4,-8(fp)
 201bc74:	201e1e80 	call	201e1e8 <tcp_send_fin>
 201bc78:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 201bc7c:	e0bffd07 	ldb	r2,-12(fp)
 201bc80:	1000121e 	bne	r2,zero,201bccc <tcp_close_shutdown+0x310>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
 201bc84:	e0bffe17 	ldw	r2,-8(fp)
 201bc88:	00c00144 	movi	r3,5
 201bc8c:	10c00615 	stw	r3,24(r2)
    }
    break;
 201bc90:	00000e06 	br	201bccc <tcp_close_shutdown+0x310>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 201bc94:	e13ffe17 	ldw	r4,-8(fp)
 201bc98:	201e1e80 	call	201e1e8 <tcp_send_fin>
 201bc9c:	e0bffd05 	stb	r2,-12(fp)
    if (err == ERR_OK) {
 201bca0:	e0bffd07 	ldb	r2,-12(fp)
 201bca4:	10000b1e 	bne	r2,zero,201bcd4 <tcp_close_shutdown+0x318>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 201bca8:	e0bffe17 	ldw	r2,-8(fp)
 201bcac:	00c00244 	movi	r3,9
 201bcb0:	10c00615 	stw	r3,24(r2)
    }
    break;
 201bcb4:	00000706 	br	201bcd4 <tcp_close_shutdown+0x318>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
 201bcb8:	e03ffd05 	stb	zero,-12(fp)
    pcb = NULL;
 201bcbc:	e03ffe15 	stw	zero,-8(fp)
    break;
 201bcc0:	00000506 	br	201bcd8 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
 201bcc4:	0001883a 	nop
 201bcc8:	00000306 	br	201bcd8 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
 201bccc:	0001883a 	nop
 201bcd0:	00000106 	br	201bcd8 <tcp_close_shutdown+0x31c>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
 201bcd4:	0001883a 	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
 201bcd8:	e0bffe17 	ldw	r2,-8(fp)
 201bcdc:	10000426 	beq	r2,zero,201bcf0 <tcp_close_shutdown+0x334>
 201bce0:	e0bffd07 	ldb	r2,-12(fp)
 201bce4:	1000021e 	bne	r2,zero,201bcf0 <tcp_close_shutdown+0x334>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 201bce8:	e13ffe17 	ldw	r4,-8(fp)
 201bcec:	201f7800 	call	201f780 <tcp_output>
  }
  return err;
 201bcf0:	e0bffd03 	ldbu	r2,-12(fp)
}
 201bcf4:	e037883a 	mov	sp,fp
 201bcf8:	dfc00117 	ldw	ra,4(sp)
 201bcfc:	df000017 	ldw	fp,0(sp)
 201bd00:	dec00204 	addi	sp,sp,8
 201bd04:	f800283a 	ret

0201bd08 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
 201bd08:	defffd04 	addi	sp,sp,-12
 201bd0c:	dfc00215 	stw	ra,8(sp)
 201bd10:	df000115 	stw	fp,4(sp)
 201bd14:	df000104 	addi	fp,sp,4
 201bd18:	e13fff15 	stw	r4,-4(fp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 201bd1c:	e0bfff17 	ldw	r2,-4(fp)
 201bd20:	10800617 	ldw	r2,24(r2)
 201bd24:	10800060 	cmpeqi	r2,r2,1
 201bd28:	1000061e 	bne	r2,zero,201bd44 <tcp_close+0x3c>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 201bd2c:	e0bfff17 	ldw	r2,-4(fp)
 201bd30:	10800883 	ldbu	r2,34(r2)
 201bd34:	10800414 	ori	r2,r2,16
 201bd38:	1007883a 	mov	r3,r2
 201bd3c:	e0bfff17 	ldw	r2,-4(fp)
 201bd40:	10c00885 	stb	r3,34(r2)
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 201bd44:	01400044 	movi	r5,1
 201bd48:	e13fff17 	ldw	r4,-4(fp)
 201bd4c:	201b9bc0 	call	201b9bc <tcp_close_shutdown>
}
 201bd50:	e037883a 	mov	sp,fp
 201bd54:	dfc00117 	ldw	ra,4(sp)
 201bd58:	df000017 	ldw	fp,0(sp)
 201bd5c:	dec00204 	addi	sp,sp,8
 201bd60:	f800283a 	ret

0201bd64 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 201bd64:	defffb04 	addi	sp,sp,-20
 201bd68:	dfc00415 	stw	ra,16(sp)
 201bd6c:	df000315 	stw	fp,12(sp)
 201bd70:	df000304 	addi	fp,sp,12
 201bd74:	e13ffd15 	stw	r4,-12(fp)
 201bd78:	e17ffe15 	stw	r5,-8(fp)
 201bd7c:	e1bfff15 	stw	r6,-4(fp)
  if (pcb->state == LISTEN) {
 201bd80:	e0bffd17 	ldw	r2,-12(fp)
 201bd84:	10800617 	ldw	r2,24(r2)
 201bd88:	10800058 	cmpnei	r2,r2,1
 201bd8c:	1000021e 	bne	r2,zero,201bd98 <tcp_shutdown+0x34>
    return ERR_CONN;
 201bd90:	00bffcc4 	movi	r2,-13
 201bd94:	00002a06 	br	201be40 <tcp_shutdown+0xdc>
  }
  if (shut_rx) {
 201bd98:	e0bffe17 	ldw	r2,-8(fp)
 201bd9c:	10001526 	beq	r2,zero,201bdf4 <tcp_shutdown+0x90>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 201bda0:	e0bffd17 	ldw	r2,-12(fp)
 201bda4:	10800883 	ldbu	r2,34(r2)
 201bda8:	10800414 	ori	r2,r2,16
 201bdac:	1007883a 	mov	r3,r2
 201bdb0:	e0bffd17 	ldw	r2,-12(fp)
 201bdb4:	10c00885 	stb	r3,34(r2)
    if (shut_tx) {
 201bdb8:	e0bfff17 	ldw	r2,-4(fp)
 201bdbc:	10000426 	beq	r2,zero,201bdd0 <tcp_shutdown+0x6c>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 201bdc0:	01400044 	movi	r5,1
 201bdc4:	e13ffd17 	ldw	r4,-12(fp)
 201bdc8:	201b9bc0 	call	201b9bc <tcp_close_shutdown>
 201bdcc:	00001c06 	br	201be40 <tcp_shutdown+0xdc>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
 201bdd0:	e0bffd17 	ldw	r2,-12(fp)
 201bdd4:	10801f17 	ldw	r2,124(r2)
 201bdd8:	10000626 	beq	r2,zero,201bdf4 <tcp_shutdown+0x90>
      pbuf_free(pcb->refused_data);
 201bddc:	e0bffd17 	ldw	r2,-12(fp)
 201bde0:	10801f17 	ldw	r2,124(r2)
 201bde4:	1009883a 	mov	r4,r2
 201bde8:	201ab680 	call	201ab68 <pbuf_free>
      pcb->refused_data = NULL;
 201bdec:	e0bffd17 	ldw	r2,-12(fp)
 201bdf0:	10001f15 	stw	zero,124(r2)
    }
  }
  if (shut_tx) {
 201bdf4:	e0bfff17 	ldw	r2,-4(fp)
 201bdf8:	10001026 	beq	r2,zero,201be3c <tcp_shutdown+0xd8>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
 201bdfc:	e0bffd17 	ldw	r2,-12(fp)
 201be00:	10800617 	ldw	r2,24(r2)
 201be04:	10c000f0 	cmpltui	r3,r2,3
 201be08:	18000a1e 	bne	r3,zero,201be34 <tcp_shutdown+0xd0>
 201be0c:	10c00170 	cmpltui	r3,r2,5
 201be10:	1800021e 	bne	r3,zero,201be1c <tcp_shutdown+0xb8>
 201be14:	108001e0 	cmpeqi	r2,r2,7
 201be18:	10000626 	beq	r2,zero,201be34 <tcp_shutdown+0xd0>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
 201be1c:	e0bffe17 	ldw	r2,-8(fp)
 201be20:	10803fcc 	andi	r2,r2,255
 201be24:	100b883a 	mov	r5,r2
 201be28:	e13ffd17 	ldw	r4,-12(fp)
 201be2c:	201b9bc0 	call	201b9bc <tcp_close_shutdown>
 201be30:	00000306 	br	201be40 <tcp_shutdown+0xdc>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
 201be34:	00bffcc4 	movi	r2,-13
 201be38:	00000106 	br	201be40 <tcp_shutdown+0xdc>
    }
  }
  return ERR_OK;
 201be3c:	0005883a 	mov	r2,zero
}
 201be40:	e037883a 	mov	sp,fp
 201be44:	dfc00117 	ldw	ra,4(sp)
 201be48:	df000017 	ldw	fp,0(sp)
 201be4c:	dec00204 	addi	sp,sp,8
 201be50:	f800283a 	ret

0201be54 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 201be54:	defff604 	addi	sp,sp,-40
 201be58:	dfc00915 	stw	ra,36(sp)
 201be5c:	df000815 	stw	fp,32(sp)
 201be60:	df000804 	addi	fp,sp,32
 201be64:	e13ffe15 	stw	r4,-8(fp)
 201be68:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 201be6c:	e0bffe17 	ldw	r2,-8(fp)
 201be70:	10800617 	ldw	r2,24(r2)
 201be74:	10800298 	cmpnei	r2,r2,10
 201be78:	1000071e 	bne	r2,zero,201be98 <tcp_abandon+0x44>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 201be7c:	e17ffe17 	ldw	r5,-8(fp)
 201be80:	d127fc04 	addi	r4,gp,-24592
 201be84:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 201be88:	e17ffe17 	ldw	r5,-8(fp)
 201be8c:	01000084 	movi	r4,2
 201be90:	20346000 	call	2034600 <memp_free>
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
 201be94:	00004106 	br	201bf9c <tcp_abandon+0x148>
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
 201be98:	e0bffe17 	ldw	r2,-8(fp)
 201be9c:	10801517 	ldw	r2,84(r2)
 201bea0:	e0bffa15 	stw	r2,-24(fp)
    ackno = pcb->rcv_nxt;
 201bea4:	e0bffe17 	ldw	r2,-8(fp)
 201bea8:	10800b17 	ldw	r2,44(r2)
 201beac:	e0bffb15 	stw	r2,-20(fp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 201beb0:	e0bffe17 	ldw	r2,-8(fp)
 201beb4:	10802417 	ldw	r2,144(r2)
 201beb8:	e0bffc15 	stw	r2,-16(fp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 201bebc:	e0bffe17 	ldw	r2,-8(fp)
 201bec0:	10800417 	ldw	r2,16(r2)
 201bec4:	e0bffd15 	stw	r2,-12(fp)
    TCP_PCB_REMOVE_ACTIVE(pcb);
 201bec8:	e17ffe17 	ldw	r5,-8(fp)
 201becc:	d127f704 	addi	r4,gp,-24612
 201bed0:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
 201bed4:	00800044 	movi	r2,1
 201bed8:	d0a7f685 	stb	r2,-24614(gp)
    if (pcb->unacked != NULL) {
 201bedc:	e0bffe17 	ldw	r2,-8(fp)
 201bee0:	10801d17 	ldw	r2,116(r2)
 201bee4:	10000426 	beq	r2,zero,201bef8 <tcp_abandon+0xa4>
      tcp_segs_free(pcb->unacked);
 201bee8:	e0bffe17 	ldw	r2,-8(fp)
 201beec:	10801d17 	ldw	r2,116(r2)
 201bef0:	1009883a 	mov	r4,r2
 201bef4:	201d3dc0 	call	201d3dc <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
 201bef8:	e0bffe17 	ldw	r2,-8(fp)
 201befc:	10801c17 	ldw	r2,112(r2)
 201bf00:	10000426 	beq	r2,zero,201bf14 <tcp_abandon+0xc0>
      tcp_segs_free(pcb->unsent);
 201bf04:	e0bffe17 	ldw	r2,-8(fp)
 201bf08:	10801c17 	ldw	r2,112(r2)
 201bf0c:	1009883a 	mov	r4,r2
 201bf10:	201d3dc0 	call	201d3dc <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
 201bf14:	e0bffe17 	ldw	r2,-8(fp)
 201bf18:	10801e17 	ldw	r2,120(r2)
 201bf1c:	10000426 	beq	r2,zero,201bf30 <tcp_abandon+0xdc>
      tcp_segs_free(pcb->ooseq);
 201bf20:	e0bffe17 	ldw	r2,-8(fp)
 201bf24:	10801e17 	ldw	r2,120(r2)
 201bf28:	1009883a 	mov	r4,r2
 201bf2c:	201d3dc0 	call	201d3dc <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
 201bf30:	e0bfff17 	ldw	r2,-4(fp)
 201bf34:	10001026 	beq	r2,zero,201bf78 <tcp_abandon+0x124>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 201bf38:	e13ffe17 	ldw	r4,-8(fp)
 201bf3c:	e0bffe17 	ldw	r2,-8(fp)
 201bf40:	11400104 	addi	r5,r2,4
 201bf44:	e0bffe17 	ldw	r2,-8(fp)
 201bf48:	1080078b 	ldhu	r2,30(r2)
 201bf4c:	10bfffcc 	andi	r2,r2,65535
 201bf50:	e0fffe17 	ldw	r3,-8(fp)
 201bf54:	18c0080b 	ldhu	r3,32(r3)
 201bf58:	18ffffcc 	andi	r3,r3,65535
 201bf5c:	d8c00115 	stw	r3,4(sp)
 201bf60:	d8800015 	stw	r2,0(sp)
 201bf64:	280f883a 	mov	r7,r5
 201bf68:	200d883a 	mov	r6,r4
 201bf6c:	e17ffb17 	ldw	r5,-20(fp)
 201bf70:	e13ffa17 	ldw	r4,-24(fp)
 201bf74:	202082c0 	call	202082c <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
 201bf78:	e17ffe17 	ldw	r5,-8(fp)
 201bf7c:	01000084 	movi	r4,2
 201bf80:	20346000 	call	2034600 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 201bf84:	e0bffc17 	ldw	r2,-16(fp)
 201bf88:	10000426 	beq	r2,zero,201bf9c <tcp_abandon+0x148>
 201bf8c:	e0bffc17 	ldw	r2,-16(fp)
 201bf90:	017ffd84 	movi	r5,-10
 201bf94:	e13ffd17 	ldw	r4,-12(fp)
 201bf98:	103ee83a 	callr	r2
  }
}
 201bf9c:	0001883a 	nop
 201bfa0:	e037883a 	mov	sp,fp
 201bfa4:	dfc00117 	ldw	ra,4(sp)
 201bfa8:	df000017 	ldw	fp,0(sp)
 201bfac:	dec00204 	addi	sp,sp,8
 201bfb0:	f800283a 	ret

0201bfb4 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
 201bfb4:	defffd04 	addi	sp,sp,-12
 201bfb8:	dfc00215 	stw	ra,8(sp)
 201bfbc:	df000115 	stw	fp,4(sp)
 201bfc0:	df000104 	addi	fp,sp,4
 201bfc4:	e13fff15 	stw	r4,-4(fp)
  tcp_abandon(pcb, 1);
 201bfc8:	01400044 	movi	r5,1
 201bfcc:	e13fff17 	ldw	r4,-4(fp)
 201bfd0:	201be540 	call	201be54 <tcp_abandon>
}
 201bfd4:	0001883a 	nop
 201bfd8:	e037883a 	mov	sp,fp
 201bfdc:	dfc00117 	ldw	ra,4(sp)
 201bfe0:	df000017 	ldw	fp,0(sp)
 201bfe4:	dec00204 	addi	sp,sp,8
 201bfe8:	f800283a 	ret

0201bfec <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 201bfec:	defff804 	addi	sp,sp,-32
 201bff0:	dfc00715 	stw	ra,28(sp)
 201bff4:	df000615 	stw	fp,24(sp)
 201bff8:	df000604 	addi	fp,sp,24
 201bffc:	e13ffd15 	stw	r4,-12(fp)
 201c000:	e17ffe15 	stw	r5,-8(fp)
 201c004:	3005883a 	mov	r2,r6
 201c008:	e0bfff0d 	sth	r2,-4(fp)
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
 201c00c:	00800104 	movi	r2,4
 201c010:	e0bffb15 	stw	r2,-20(fp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 201c014:	e0bffd17 	ldw	r2,-12(fp)
 201c018:	10800617 	ldw	r2,24(r2)
 201c01c:	10000926 	beq	r2,zero,201c044 <tcp_bind+0x58>
 201c020:	01c08134 	movhi	r7,516
 201c024:	39c5c804 	addi	r7,r7,5920
 201c028:	01806dc4 	movi	r6,439
 201c02c:	01408134 	movhi	r5,516
 201c030:	2945cd04 	addi	r5,r5,5940
 201c034:	01008134 	movhi	r4,516
 201c038:	2105d704 	addi	r4,r4,5980
 201c03c:	2000bb00 	call	2000bb0 <printf>
 201c040:	003fff06 	br	201c040 <__alt_mem_mem_0+0xfcffc040>
  /* Unless the REUSEADDR flag is set,
     we have to check the pcbs in TIME-WAIT state, also.
     We do not dump TIME_WAIT pcb's; they can still be matched by incoming
     packets using both local and remote IP addresses and ports to distinguish.
   */
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 201c044:	e0bffd17 	ldw	r2,-12(fp)
 201c048:	10800203 	ldbu	r2,8(r2)
 201c04c:	10803fcc 	andi	r2,r2,255
 201c050:	1080010c 	andi	r2,r2,4
 201c054:	10000226 	beq	r2,zero,201c060 <tcp_bind+0x74>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
 201c058:	008000c4 	movi	r2,3
 201c05c:	e0bffb15 	stw	r2,-20(fp)
  }
#endif /* SO_REUSE */

  if (port == 0) {
 201c060:	e0bfff0b 	ldhu	r2,-4(fp)
 201c064:	1000061e 	bne	r2,zero,201c080 <tcp_bind+0x94>
    port = tcp_new_port();
 201c068:	201c5ec0 	call	201c5ec <tcp_new_port>
 201c06c:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 201c070:	e0bfff0b 	ldhu	r2,-4(fp)
 201c074:	1000021e 	bne	r2,zero,201c080 <tcp_bind+0x94>
      return ERR_BUF;
 201c078:	00bfff84 	movi	r2,-2
 201c07c:	00004a06 	br	201c1a8 <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 201c080:	e03ffa15 	stw	zero,-24(fp)
 201c084:	00003206 	br	201c150 <tcp_bind+0x164>
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201c088:	00808134 	movhi	r2,516
 201c08c:	1085c404 	addi	r2,r2,5904
 201c090:	e0fffa17 	ldw	r3,-24(fp)
 201c094:	18c7883a 	add	r3,r3,r3
 201c098:	18c7883a 	add	r3,r3,r3
 201c09c:	10c5883a 	add	r2,r2,r3
 201c0a0:	10800017 	ldw	r2,0(r2)
 201c0a4:	10800017 	ldw	r2,0(r2)
 201c0a8:	e0bffc15 	stw	r2,-16(fp)
 201c0ac:	00002306 	br	201c13c <tcp_bind+0x150>
      if (cpcb->local_port == port) {
 201c0b0:	e0bffc17 	ldw	r2,-16(fp)
 201c0b4:	1080078b 	ldhu	r2,30(r2)
 201c0b8:	10ffffcc 	andi	r3,r2,65535
 201c0bc:	e0bfff0b 	ldhu	r2,-4(fp)
 201c0c0:	18801b1e 	bne	r3,r2,201c130 <tcp_bind+0x144>
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 201c0c4:	e0bffd17 	ldw	r2,-12(fp)
 201c0c8:	10800203 	ldbu	r2,8(r2)
 201c0cc:	10803fcc 	andi	r2,r2,255
 201c0d0:	1080010c 	andi	r2,r2,4
 201c0d4:	10000526 	beq	r2,zero,201c0ec <tcp_bind+0x100>
            !ip_get_option(cpcb, SOF_REUSEADDR))
 201c0d8:	e0bffc17 	ldw	r2,-16(fp)
 201c0dc:	10800203 	ldbu	r2,8(r2)
 201c0e0:	10803fcc 	andi	r2,r2,255
 201c0e4:	1080010c 	andi	r2,r2,4
      if (cpcb->local_port == port) {
#if SO_REUSE
        /* Omit checking for the same port if both pcbs have REUSEADDR set.
           For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
 201c0e8:	1000111e 	bne	r2,zero,201c130 <tcp_bind+0x144>
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
 201c0ec:	e0bffc17 	ldw	r2,-16(fp)
 201c0f0:	10000d26 	beq	r2,zero,201c128 <tcp_bind+0x13c>
 201c0f4:	e0bffc17 	ldw	r2,-16(fp)
 201c0f8:	10800017 	ldw	r2,0(r2)
 201c0fc:	10000a26 	beq	r2,zero,201c128 <tcp_bind+0x13c>
 201c100:	e0bffe17 	ldw	r2,-8(fp)
 201c104:	10000826 	beq	r2,zero,201c128 <tcp_bind+0x13c>
              ip_addr_isany(ipaddr) ||
 201c108:	e0bffe17 	ldw	r2,-8(fp)
 201c10c:	10800017 	ldw	r2,0(r2)
 201c110:	10000526 	beq	r2,zero,201c128 <tcp_bind+0x13c>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
 201c114:	e0bffc17 	ldw	r2,-16(fp)
 201c118:	10c00017 	ldw	r3,0(r2)
 201c11c:	e0bffe17 	ldw	r2,-8(fp)
 201c120:	10800017 	ldw	r2,0(r2)
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
 201c124:	1880021e 	bne	r3,r2,201c130 <tcp_bind+0x144>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 201c128:	00bffe04 	movi	r2,-8
 201c12c:	00001e06 	br	201c1a8 <tcp_bind+0x1bc>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201c130:	e0bffc17 	ldw	r2,-16(fp)
 201c134:	10800317 	ldw	r2,12(r2)
 201c138:	e0bffc15 	stw	r2,-16(fp)
 201c13c:	e0bffc17 	ldw	r2,-16(fp)
 201c140:	103fdb1e 	bne	r2,zero,201c0b0 <__alt_mem_mem_0+0xfcffc0b0>
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 201c144:	e0bffa17 	ldw	r2,-24(fp)
 201c148:	10800044 	addi	r2,r2,1
 201c14c:	e0bffa15 	stw	r2,-24(fp)
 201c150:	e0fffa17 	ldw	r3,-24(fp)
 201c154:	e0bffb17 	ldw	r2,-20(fp)
 201c158:	18bfcb16 	blt	r3,r2,201c088 <__alt_mem_mem_0+0xfcffc088>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 201c15c:	e0bffe17 	ldw	r2,-8(fp)
 201c160:	10000726 	beq	r2,zero,201c180 <tcp_bind+0x194>
 201c164:	e0bffe17 	ldw	r2,-8(fp)
 201c168:	10800017 	ldw	r2,0(r2)
 201c16c:	10000426 	beq	r2,zero,201c180 <tcp_bind+0x194>
    pcb->local_ip = *ipaddr;
 201c170:	e0bffd17 	ldw	r2,-12(fp)
 201c174:	e0fffe17 	ldw	r3,-8(fp)
 201c178:	18c00017 	ldw	r3,0(r3)
 201c17c:	10c00015 	stw	r3,0(r2)
  }
  pcb->local_port = port;
 201c180:	e0bffd17 	ldw	r2,-12(fp)
 201c184:	e0ffff0b 	ldhu	r3,-4(fp)
 201c188:	10c0078d 	sth	r3,30(r2)
  TCP_REG(&tcp_bound_pcbs, pcb);
 201c18c:	d0e7fb17 	ldw	r3,-24596(gp)
 201c190:	e0bffd17 	ldw	r2,-12(fp)
 201c194:	10c00315 	stw	r3,12(r2)
 201c198:	e0bffd17 	ldw	r2,-12(fp)
 201c19c:	d0a7fb15 	stw	r2,-24596(gp)
 201c1a0:	20215540 	call	2021554 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 201c1a4:	0005883a 	mov	r2,zero
}
 201c1a8:	e037883a 	mov	sp,fp
 201c1ac:	dfc00117 	ldw	ra,4(sp)
 201c1b0:	df000017 	ldw	fp,0(sp)
 201c1b4:	dec00204 	addi	sp,sp,8
 201c1b8:	f800283a 	ret

0201c1bc <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
 201c1bc:	defffc04 	addi	sp,sp,-16
 201c1c0:	df000315 	stw	fp,12(sp)
 201c1c4:	df000304 	addi	fp,sp,12
 201c1c8:	e13ffd15 	stw	r4,-12(fp)
 201c1cc:	e17ffe15 	stw	r5,-8(fp)
 201c1d0:	3005883a 	mov	r2,r6
 201c1d4:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
 201c1d8:	00bffd84 	movi	r2,-10
}
 201c1dc:	e037883a 	mov	sp,fp
 201c1e0:	df000017 	ldw	fp,0(sp)
 201c1e4:	dec00104 	addi	sp,sp,4
 201c1e8:	f800283a 	ret

0201c1ec <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 201c1ec:	defffb04 	addi	sp,sp,-20
 201c1f0:	dfc00415 	stw	ra,16(sp)
 201c1f4:	df000315 	stw	fp,12(sp)
 201c1f8:	df000304 	addi	fp,sp,12
 201c1fc:	e13ffe15 	stw	r4,-8(fp)
 201c200:	2805883a 	mov	r2,r5
 201c204:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 201c208:	e0bffe17 	ldw	r2,-8(fp)
 201c20c:	10800617 	ldw	r2,24(r2)
 201c210:	10000926 	beq	r2,zero,201c238 <tcp_listen_with_backlog+0x4c>
 201c214:	01c08134 	movhi	r7,516
 201c218:	39c5c804 	addi	r7,r7,5920
 201c21c:	01808304 	movi	r6,524
 201c220:	01408134 	movhi	r5,516
 201c224:	2945e304 	addi	r5,r5,6028
 201c228:	01008134 	movhi	r4,516
 201c22c:	2105d704 	addi	r4,r4,5980
 201c230:	2000bb00 	call	2000bb0 <printf>
 201c234:	003fff06 	br	201c234 <__alt_mem_mem_0+0xfcffc234>

  /* already listening? */
  if (pcb->state == LISTEN) {
 201c238:	e0bffe17 	ldw	r2,-8(fp)
 201c23c:	10800617 	ldw	r2,24(r2)
 201c240:	10800058 	cmpnei	r2,r2,1
 201c244:	1000021e 	bne	r2,zero,201c250 <tcp_listen_with_backlog+0x64>
    return pcb;
 201c248:	e0bffe17 	ldw	r2,-8(fp)
 201c24c:	00007c06 	br	201c440 <tcp_listen_with_backlog+0x254>
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 201c250:	e0bffe17 	ldw	r2,-8(fp)
 201c254:	10800203 	ldbu	r2,8(r2)
 201c258:	10803fcc 	andi	r2,r2,255
 201c25c:	1080010c 	andi	r2,r2,4
 201c260:	10001626 	beq	r2,zero,201c2bc <tcp_listen_with_backlog+0xd0>
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201c264:	d0a7f917 	ldw	r2,-24604(gp)
 201c268:	e0bffd15 	stw	r2,-12(fp)
 201c26c:	00001106 	br	201c2b4 <tcp_listen_with_backlog+0xc8>
      if (lpcb->local_port == pcb->local_port) {
 201c270:	e0bffd17 	ldw	r2,-12(fp)
 201c274:	10c0078b 	ldhu	r3,30(r2)
 201c278:	e0bffe17 	ldw	r2,-8(fp)
 201c27c:	1080078b 	ldhu	r2,30(r2)
 201c280:	18ffffcc 	andi	r3,r3,65535
 201c284:	10bfffcc 	andi	r2,r2,65535
 201c288:	1880071e 	bne	r3,r2,201c2a8 <tcp_listen_with_backlog+0xbc>
        if (ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
 201c28c:	e0bffd17 	ldw	r2,-12(fp)
 201c290:	10c00017 	ldw	r3,0(r2)
 201c294:	e0bffe17 	ldw	r2,-8(fp)
 201c298:	10800017 	ldw	r2,0(r2)
 201c29c:	1880021e 	bne	r3,r2,201c2a8 <tcp_listen_with_backlog+0xbc>
          /* this address/port is already used */
          return NULL;
 201c2a0:	0005883a 	mov	r2,zero
 201c2a4:	00006606 	br	201c440 <tcp_listen_with_backlog+0x254>
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
       is declared (listen-/connection-pcb), we have to make sure now that
       this port is only used once for every local IP. */
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201c2a8:	e0bffd17 	ldw	r2,-12(fp)
 201c2ac:	10800317 	ldw	r2,12(r2)
 201c2b0:	e0bffd15 	stw	r2,-12(fp)
 201c2b4:	e0bffd17 	ldw	r2,-12(fp)
 201c2b8:	103fed1e 	bne	r2,zero,201c270 <__alt_mem_mem_0+0xfcffc270>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 201c2bc:	010000c4 	movi	r4,3
 201c2c0:	20344340 	call	2034434 <memp_malloc>
 201c2c4:	e0bffd15 	stw	r2,-12(fp)
  if (lpcb == NULL) {
 201c2c8:	e0bffd17 	ldw	r2,-12(fp)
 201c2cc:	1000021e 	bne	r2,zero,201c2d8 <tcp_listen_with_backlog+0xec>
    return NULL;
 201c2d0:	0005883a 	mov	r2,zero
 201c2d4:	00005a06 	br	201c440 <tcp_listen_with_backlog+0x254>
  }
  lpcb->callback_arg = pcb->callback_arg;
 201c2d8:	e0bffe17 	ldw	r2,-8(fp)
 201c2dc:	10c00417 	ldw	r3,16(r2)
 201c2e0:	e0bffd17 	ldw	r2,-12(fp)
 201c2e4:	10c00415 	stw	r3,16(r2)
  lpcb->local_port = pcb->local_port;
 201c2e8:	e0bffe17 	ldw	r2,-8(fp)
 201c2ec:	10c0078b 	ldhu	r3,30(r2)
 201c2f0:	e0bffd17 	ldw	r2,-12(fp)
 201c2f4:	10c0078d 	sth	r3,30(r2)
  lpcb->state = LISTEN;
 201c2f8:	e0bffd17 	ldw	r2,-12(fp)
 201c2fc:	00c00044 	movi	r3,1
 201c300:	10c00615 	stw	r3,24(r2)
  lpcb->prio = pcb->prio;
 201c304:	e0bffe17 	ldw	r2,-8(fp)
 201c308:	10c00703 	ldbu	r3,28(r2)
 201c30c:	e0bffd17 	ldw	r2,-12(fp)
 201c310:	10c00705 	stb	r3,28(r2)
  lpcb->so_options = pcb->so_options;
 201c314:	e0bffe17 	ldw	r2,-8(fp)
 201c318:	10c00203 	ldbu	r3,8(r2)
 201c31c:	e0bffd17 	ldw	r2,-12(fp)
 201c320:	10c00205 	stb	r3,8(r2)
  ip_set_option(lpcb, SOF_ACCEPTCONN);
 201c324:	e0bffd17 	ldw	r2,-12(fp)
 201c328:	10800203 	ldbu	r2,8(r2)
 201c32c:	10800094 	ori	r2,r2,2
 201c330:	1007883a 	mov	r3,r2
 201c334:	e0bffd17 	ldw	r2,-12(fp)
 201c338:	10c00205 	stb	r3,8(r2)
  lpcb->ttl = pcb->ttl;
 201c33c:	e0bffe17 	ldw	r2,-8(fp)
 201c340:	10c00283 	ldbu	r3,10(r2)
 201c344:	e0bffd17 	ldw	r2,-12(fp)
 201c348:	10c00285 	stb	r3,10(r2)
  lpcb->tos = pcb->tos;
 201c34c:	e0bffe17 	ldw	r2,-8(fp)
 201c350:	10c00243 	ldbu	r3,9(r2)
 201c354:	e0bffd17 	ldw	r2,-12(fp)
 201c358:	10c00245 	stb	r3,9(r2)
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 201c35c:	e0bffe17 	ldw	r2,-8(fp)
 201c360:	10c00017 	ldw	r3,0(r2)
 201c364:	e0bffd17 	ldw	r2,-12(fp)
 201c368:	10c00015 	stw	r3,0(r2)
  if (pcb->local_port != 0) {
 201c36c:	e0bffe17 	ldw	r2,-8(fp)
 201c370:	1080078b 	ldhu	r2,30(r2)
 201c374:	10bfffcc 	andi	r2,r2,65535
 201c378:	10001a26 	beq	r2,zero,201c3e4 <tcp_listen_with_backlog+0x1f8>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 201c37c:	d0e7fb17 	ldw	r3,-24596(gp)
 201c380:	e0bffe17 	ldw	r2,-8(fp)
 201c384:	1880041e 	bne	r3,r2,201c398 <tcp_listen_with_backlog+0x1ac>
 201c388:	d0a7fb17 	ldw	r2,-24596(gp)
 201c38c:	10800317 	ldw	r2,12(r2)
 201c390:	d0a7fb15 	stw	r2,-24596(gp)
 201c394:	00001106 	br	201c3dc <tcp_listen_with_backlog+0x1f0>
 201c398:	d0a7fb17 	ldw	r2,-24596(gp)
 201c39c:	d0a7fa15 	stw	r2,-24600(gp)
 201c3a0:	00000c06 	br	201c3d4 <tcp_listen_with_backlog+0x1e8>
 201c3a4:	d0a7fa17 	ldw	r2,-24600(gp)
 201c3a8:	10c00317 	ldw	r3,12(r2)
 201c3ac:	e0bffe17 	ldw	r2,-8(fp)
 201c3b0:	1880051e 	bne	r3,r2,201c3c8 <tcp_listen_with_backlog+0x1dc>
 201c3b4:	d0a7fa17 	ldw	r2,-24600(gp)
 201c3b8:	e0fffe17 	ldw	r3,-8(fp)
 201c3bc:	18c00317 	ldw	r3,12(r3)
 201c3c0:	10c00315 	stw	r3,12(r2)
 201c3c4:	00000506 	br	201c3dc <tcp_listen_with_backlog+0x1f0>
 201c3c8:	d0a7fa17 	ldw	r2,-24600(gp)
 201c3cc:	10800317 	ldw	r2,12(r2)
 201c3d0:	d0a7fa15 	stw	r2,-24600(gp)
 201c3d4:	d0a7fa17 	ldw	r2,-24600(gp)
 201c3d8:	103ff21e 	bne	r2,zero,201c3a4 <__alt_mem_mem_0+0xfcffc3a4>
 201c3dc:	e0bffe17 	ldw	r2,-8(fp)
 201c3e0:	10000315 	stw	zero,12(r2)
  }
  memp_free(MEMP_TCP_PCB, pcb);
 201c3e4:	e17ffe17 	ldw	r5,-8(fp)
 201c3e8:	01000084 	movi	r4,2
 201c3ec:	20346000 	call	2034600 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 201c3f0:	e0fffd17 	ldw	r3,-12(fp)
 201c3f4:	008080b4 	movhi	r2,514
 201c3f8:	10b06f04 	addi	r2,r2,-15940
 201c3fc:	18800515 	stw	r2,20(r3)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
 201c400:	e0bffd17 	ldw	r2,-12(fp)
 201c404:	10000845 	stb	zero,33(r2)
  lpcb->backlog = (backlog ? backlog : 1);
 201c408:	e0bfff03 	ldbu	r2,-4(fp)
 201c40c:	10000226 	beq	r2,zero,201c418 <tcp_listen_with_backlog+0x22c>
 201c410:	e0bfff03 	ldbu	r2,-4(fp)
 201c414:	00000106 	br	201c41c <tcp_listen_with_backlog+0x230>
 201c418:	00800044 	movi	r2,1
 201c41c:	e0fffd17 	ldw	r3,-12(fp)
 201c420:	18800805 	stb	r2,32(r3)
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 201c424:	d0e7f917 	ldw	r3,-24604(gp)
 201c428:	e0bffd17 	ldw	r2,-12(fp)
 201c42c:	10c00315 	stw	r3,12(r2)
 201c430:	e0bffd17 	ldw	r2,-12(fp)
 201c434:	d0a7f915 	stw	r2,-24604(gp)
 201c438:	20215540 	call	2021554 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 201c43c:	e0bffd17 	ldw	r2,-12(fp)
}
 201c440:	e037883a 	mov	sp,fp
 201c444:	dfc00117 	ldw	ra,4(sp)
 201c448:	df000017 	ldw	fp,0(sp)
 201c44c:	dec00204 	addi	sp,sp,8
 201c450:	f800283a 	ret

0201c454 <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 201c454:	defffc04 	addi	sp,sp,-16
 201c458:	df000315 	stw	fp,12(sp)
 201c45c:	df000304 	addi	fp,sp,12
 201c460:	e13fff15 	stw	r4,-4(fp)
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 201c464:	e0bfff17 	ldw	r2,-4(fp)
 201c468:	10c00b17 	ldw	r3,44(r2)
 201c46c:	e0bfff17 	ldw	r2,-4(fp)
 201c470:	10800c0b 	ldhu	r2,48(r2)
 201c474:	10bfffcc 	andi	r2,r2,65535
 201c478:	1885883a 	add	r2,r3,r2
 201c47c:	e0bffd15 	stw	r2,-12(fp)

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 201c480:	e0bfff17 	ldw	r2,-4(fp)
 201c484:	10c00d17 	ldw	r3,52(r2)
 201c488:	e0bfff17 	ldw	r2,-4(fp)
 201c48c:	10800e8b 	ldhu	r2,58(r2)
 201c490:	10bfffcc 	andi	r2,r2,65535
 201c494:	10840068 	cmpgeui	r2,r2,4097
 201c498:	1000041e 	bne	r2,zero,201c4ac <tcp_update_rcv_ann_wnd+0x58>
 201c49c:	e0bfff17 	ldw	r2,-4(fp)
 201c4a0:	10800e8b 	ldhu	r2,58(r2)
 201c4a4:	10bfffcc 	andi	r2,r2,65535
 201c4a8:	00000106 	br	201c4b0 <tcp_update_rcv_ann_wnd+0x5c>
 201c4ac:	00840004 	movi	r2,4096
 201c4b0:	1885883a 	add	r2,r3,r2
 201c4b4:	e0fffd17 	ldw	r3,-12(fp)
 201c4b8:	1885c83a 	sub	r2,r3,r2
 201c4bc:	10000916 	blt	r2,zero,201c4e4 <tcp_update_rcv_ann_wnd+0x90>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 201c4c0:	e0bfff17 	ldw	r2,-4(fp)
 201c4c4:	10c00c0b 	ldhu	r3,48(r2)
 201c4c8:	e0bfff17 	ldw	r2,-4(fp)
 201c4cc:	10c00c8d 	sth	r3,50(r2)
    return new_right_edge - pcb->rcv_ann_right_edge;
 201c4d0:	e0bfff17 	ldw	r2,-4(fp)
 201c4d4:	10800d17 	ldw	r2,52(r2)
 201c4d8:	e0fffd17 	ldw	r3,-12(fp)
 201c4dc:	1885c83a 	sub	r2,r3,r2
 201c4e0:	00001406 	br	201c534 <tcp_update_rcv_ann_wnd+0xe0>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 201c4e4:	e0bfff17 	ldw	r2,-4(fp)
 201c4e8:	10c00b17 	ldw	r3,44(r2)
 201c4ec:	e0bfff17 	ldw	r2,-4(fp)
 201c4f0:	10800d17 	ldw	r2,52(r2)
 201c4f4:	1885c83a 	sub	r2,r3,r2
 201c4f8:	0080030e 	bge	zero,r2,201c508 <tcp_update_rcv_ann_wnd+0xb4>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 201c4fc:	e0bfff17 	ldw	r2,-4(fp)
 201c500:	10000c8d 	sth	zero,50(r2)
 201c504:	00000a06 	br	201c530 <tcp_update_rcv_ann_wnd+0xdc>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 201c508:	e0bfff17 	ldw	r2,-4(fp)
 201c50c:	10c00d17 	ldw	r3,52(r2)
 201c510:	e0bfff17 	ldw	r2,-4(fp)
 201c514:	10800b17 	ldw	r2,44(r2)
 201c518:	1885c83a 	sub	r2,r3,r2
 201c51c:	e0bffe15 	stw	r2,-8(fp)
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 201c520:	e0bffe17 	ldw	r2,-8(fp)
 201c524:	1007883a 	mov	r3,r2
 201c528:	e0bfff17 	ldw	r2,-4(fp)
 201c52c:	10c00c8d 	sth	r3,50(r2)
    }
    return 0;
 201c530:	0005883a 	mov	r2,zero
  }
}
 201c534:	e037883a 	mov	sp,fp
 201c538:	df000017 	ldw	fp,0(sp)
 201c53c:	dec00104 	addi	sp,sp,4
 201c540:	f800283a 	ret

0201c544 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 201c544:	defffb04 	addi	sp,sp,-20
 201c548:	dfc00415 	stw	ra,16(sp)
 201c54c:	df000315 	stw	fp,12(sp)
 201c550:	df000304 	addi	fp,sp,12
 201c554:	e13ffe15 	stw	r4,-8(fp)
 201c558:	2805883a 	mov	r2,r5
 201c55c:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 201c560:	e0bffe17 	ldw	r2,-8(fp)
 201c564:	10c00c0b 	ldhu	r3,48(r2)
 201c568:	e0bfff0b 	ldhu	r2,-4(fp)
 201c56c:	1885883a 	add	r2,r3,r2
 201c570:	1007883a 	mov	r3,r2
 201c574:	e0bffe17 	ldw	r2,-8(fp)
 201c578:	10c00c0d 	sth	r3,48(r2)
  if (pcb->rcv_wnd > TCP_WND) {
 201c57c:	e0bffe17 	ldw	r2,-8(fp)
 201c580:	10800c0b 	ldhu	r2,48(r2)
 201c584:	10bfffcc 	andi	r2,r2,65535
 201c588:	10880070 	cmpltui	r2,r2,8193
 201c58c:	1000031e 	bne	r2,zero,201c59c <tcp_recved+0x58>
    pcb->rcv_wnd = TCP_WND;
 201c590:	e0bffe17 	ldw	r2,-8(fp)
 201c594:	00c80004 	movi	r3,8192
 201c598:	10c00c0d 	sth	r3,48(r2)
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 201c59c:	e13ffe17 	ldw	r4,-8(fp)
 201c5a0:	201c4540 	call	201c454 <tcp_update_rcv_ann_wnd>
 201c5a4:	e0bffd15 	stw	r2,-12(fp)

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 201c5a8:	e0bffd17 	ldw	r2,-12(fp)
 201c5ac:	10820010 	cmplti	r2,r2,2048
 201c5b0:	1000081e 	bne	r2,zero,201c5d4 <tcp_recved+0x90>
    tcp_ack_now(pcb);
 201c5b4:	e0bffe17 	ldw	r2,-8(fp)
 201c5b8:	10800883 	ldbu	r2,34(r2)
 201c5bc:	10800094 	ori	r2,r2,2
 201c5c0:	1007883a 	mov	r3,r2
 201c5c4:	e0bffe17 	ldw	r2,-8(fp)
 201c5c8:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
 201c5cc:	e13ffe17 	ldw	r4,-8(fp)
 201c5d0:	201f7800 	call	201f780 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 201c5d4:	0001883a 	nop
 201c5d8:	e037883a 	mov	sp,fp
 201c5dc:	dfc00117 	ldw	ra,4(sp)
 201c5e0:	df000017 	ldw	fp,0(sp)
 201c5e4:	dec00204 	addi	sp,sp,8
 201c5e8:	f800283a 	ret

0201c5ec <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 201c5ec:	defffd04 	addi	sp,sp,-12
 201c5f0:	df000215 	stw	fp,8(sp)
 201c5f4:	df000204 	addi	fp,sp,8
  u8_t i;
  u16_t n = 0;
 201c5f8:	e03ffe8d 	sth	zero,-6(fp)
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 201c5fc:	d0a00f0b 	ldhu	r2,-32708(gp)
 201c600:	10c00044 	addi	r3,r2,1
 201c604:	d0e00f0d 	sth	r3,-32708(gp)
 201c608:	10ffffcc 	andi	r3,r2,65535
 201c60c:	00bfffd4 	movui	r2,65535
 201c610:	1880021e 	bne	r3,r2,201c61c <tcp_new_port+0x30>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
 201c614:	00b00004 	movi	r2,-16384
 201c618:	d0a00f0d 	sth	r2,-32708(gp)
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 201c61c:	e03ffe05 	stb	zero,-8(fp)
 201c620:	00002006 	br	201c6a4 <tcp_new_port+0xb8>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 201c624:	e0fffe03 	ldbu	r3,-8(fp)
 201c628:	00808134 	movhi	r2,516
 201c62c:	1085c404 	addi	r2,r2,5904
 201c630:	18c7883a 	add	r3,r3,r3
 201c634:	18c7883a 	add	r3,r3,r3
 201c638:	10c5883a 	add	r2,r2,r3
 201c63c:	10800017 	ldw	r2,0(r2)
 201c640:	10800017 	ldw	r2,0(r2)
 201c644:	e0bfff15 	stw	r2,-4(fp)
 201c648:	00001106 	br	201c690 <tcp_new_port+0xa4>
      if (pcb->local_port == tcp_port) {
 201c64c:	e0bfff17 	ldw	r2,-4(fp)
 201c650:	10c0078b 	ldhu	r3,30(r2)
 201c654:	d0a00f0b 	ldhu	r2,-32708(gp)
 201c658:	18ffffcc 	andi	r3,r3,65535
 201c65c:	10bfffcc 	andi	r2,r2,65535
 201c660:	1880081e 	bne	r3,r2,201c684 <tcp_new_port+0x98>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 201c664:	e0bffe8b 	ldhu	r2,-6(fp)
 201c668:	10800044 	addi	r2,r2,1
 201c66c:	e0bffe8d 	sth	r2,-6(fp)
 201c670:	e0bffe8b 	ldhu	r2,-6(fp)
 201c674:	10900030 	cmpltui	r2,r2,16384
 201c678:	103fe01e 	bne	r2,zero,201c5fc <__alt_mem_mem_0+0xfcffc5fc>
          return 0;
 201c67c:	0005883a 	mov	r2,zero
 201c680:	00000c06 	br	201c6b4 <tcp_new_port+0xc8>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 201c684:	e0bfff17 	ldw	r2,-4(fp)
 201c688:	10800317 	ldw	r2,12(r2)
 201c68c:	e0bfff15 	stw	r2,-4(fp)
 201c690:	e0bfff17 	ldw	r2,-4(fp)
 201c694:	103fed1e 	bne	r2,zero,201c64c <__alt_mem_mem_0+0xfcffc64c>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 201c698:	e0bffe03 	ldbu	r2,-8(fp)
 201c69c:	10800044 	addi	r2,r2,1
 201c6a0:	e0bffe05 	stb	r2,-8(fp)
 201c6a4:	e0bffe03 	ldbu	r2,-8(fp)
 201c6a8:	10800130 	cmpltui	r2,r2,4
 201c6ac:	103fdd1e 	bne	r2,zero,201c624 <__alt_mem_mem_0+0xfcffc624>
        }
        goto again;
      }
    }
  }
  return tcp_port;
 201c6b0:	d0a00f0b 	ldhu	r2,-32708(gp)
}
 201c6b4:	e037883a 	mov	sp,fp
 201c6b8:	df000017 	ldw	fp,0(sp)
 201c6bc:	dec00104 	addi	sp,sp,4
 201c6c0:	f800283a 	ret

0201c6c4 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
 201c6c4:	defff404 	addi	sp,sp,-48
 201c6c8:	dfc00b15 	stw	ra,44(sp)
 201c6cc:	df000a15 	stw	fp,40(sp)
 201c6d0:	df000a04 	addi	fp,sp,40
 201c6d4:	e13ffc15 	stw	r4,-16(fp)
 201c6d8:	e17ffd15 	stw	r5,-12(fp)
 201c6dc:	3005883a 	mov	r2,r6
 201c6e0:	e1ffff15 	stw	r7,-4(fp)
 201c6e4:	e0bffe0d 	sth	r2,-8(fp)
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 201c6e8:	e0bffc17 	ldw	r2,-16(fp)
 201c6ec:	10800617 	ldw	r2,24(r2)
 201c6f0:	10000926 	beq	r2,zero,201c718 <tcp_connect+0x54>
 201c6f4:	01c08134 	movhi	r7,516
 201c6f8:	39c5c804 	addi	r7,r7,5920
 201c6fc:	0180acc4 	movi	r6,691
 201c700:	01408134 	movhi	r5,516
 201c704:	2945ec04 	addi	r5,r5,6064
 201c708:	01008134 	movhi	r4,516
 201c70c:	2105d704 	addi	r4,r4,5980
 201c710:	2000bb00 	call	2000bb0 <printf>
 201c714:	003fff06 	br	201c714 <__alt_mem_mem_0+0xfcffc714>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
 201c718:	e0bffd17 	ldw	r2,-12(fp)
 201c71c:	10000a26 	beq	r2,zero,201c748 <tcp_connect+0x84>
    pcb->remote_ip = *ipaddr;
 201c720:	e0bffc17 	ldw	r2,-16(fp)
 201c724:	e0fffd17 	ldw	r3,-12(fp)
 201c728:	18c00017 	ldw	r3,0(r3)
 201c72c:	10c00115 	stw	r3,4(r2)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
 201c730:	e0bffc17 	ldw	r2,-16(fp)
 201c734:	e0fffe0b 	ldhu	r3,-8(fp)
 201c738:	10c0080d 	sth	r3,32(r2)

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 201c73c:	e0bffc17 	ldw	r2,-16(fp)
 201c740:	10000626 	beq	r2,zero,201c75c <tcp_connect+0x98>
 201c744:	00000206 	br	201c750 <tcp_connect+0x8c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
 201c748:	00bffe84 	movi	r2,-6
 201c74c:	0000be06 	br	201ca48 <tcp_connect+0x384>
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 201c750:	e0bffc17 	ldw	r2,-16(fp)
 201c754:	10800017 	ldw	r2,0(r2)
 201c758:	10000f1e 	bne	r2,zero,201c798 <tcp_connect+0xd4>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
 201c75c:	e0fffc17 	ldw	r3,-16(fp)
 201c760:	e0bffc17 	ldw	r2,-16(fp)
 201c764:	10800104 	addi	r2,r2,4
 201c768:	100b883a 	mov	r5,r2
 201c76c:	1809883a 	mov	r4,r3
 201c770:	2031d1c0 	call	2031d1c <ip_route>
 201c774:	e0bff815 	stw	r2,-32(fp)
    if (netif == NULL) {
 201c778:	e0bff817 	ldw	r2,-32(fp)
 201c77c:	1000021e 	bne	r2,zero,201c788 <tcp_connect+0xc4>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
 201c780:	00bfff04 	movi	r2,-4
 201c784:	0000b006 	br	201ca48 <tcp_connect+0x384>
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 201c788:	e0bff817 	ldw	r2,-32(fp)
 201c78c:	10c00117 	ldw	r3,4(r2)
 201c790:	e0bffc17 	ldw	r2,-16(fp)
 201c794:	10c00015 	stw	r3,0(r2)
  }

  old_local_port = pcb->local_port;
 201c798:	e0bffc17 	ldw	r2,-16(fp)
 201c79c:	1080078b 	ldhu	r2,30(r2)
 201c7a0:	e0bff90d 	sth	r2,-28(fp)
  if (pcb->local_port == 0) {
 201c7a4:	e0bffc17 	ldw	r2,-16(fp)
 201c7a8:	1080078b 	ldhu	r2,30(r2)
 201c7ac:	10bfffcc 	andi	r2,r2,65535
 201c7b0:	10000a1e 	bne	r2,zero,201c7dc <tcp_connect+0x118>
    pcb->local_port = tcp_new_port();
 201c7b4:	201c5ec0 	call	201c5ec <tcp_new_port>
 201c7b8:	1007883a 	mov	r3,r2
 201c7bc:	e0bffc17 	ldw	r2,-16(fp)
 201c7c0:	10c0078d 	sth	r3,30(r2)
    if (pcb->local_port == 0) {
 201c7c4:	e0bffc17 	ldw	r2,-16(fp)
 201c7c8:	1080078b 	ldhu	r2,30(r2)
 201c7cc:	10bfffcc 	andi	r2,r2,65535
 201c7d0:	1000021e 	bne	r2,zero,201c7dc <tcp_connect+0x118>
      return ERR_BUF;
 201c7d4:	00bfff84 	movi	r2,-2
 201c7d8:	00009b06 	br	201ca48 <tcp_connect+0x384>
    }
  }
#if SO_REUSE
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
 201c7dc:	e0bffc17 	ldw	r2,-16(fp)
 201c7e0:	10800203 	ldbu	r2,8(r2)
 201c7e4:	10803fcc 	andi	r2,r2,255
 201c7e8:	1080010c 	andi	r2,r2,4
 201c7ec:	10003026 	beq	r2,zero,201c8b0 <tcp_connect+0x1ec>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 201c7f0:	00800084 	movi	r2,2
 201c7f4:	e0bff715 	stw	r2,-36(fp)
 201c7f8:	00002a06 	br	201c8a4 <tcp_connect+0x1e0>
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201c7fc:	00808134 	movhi	r2,516
 201c800:	1085c404 	addi	r2,r2,5904
 201c804:	e0fff717 	ldw	r3,-36(fp)
 201c808:	18c7883a 	add	r3,r3,r3
 201c80c:	18c7883a 	add	r3,r3,r3
 201c810:	10c5883a 	add	r2,r2,r3
 201c814:	10800017 	ldw	r2,0(r2)
 201c818:	10800017 	ldw	r2,0(r2)
 201c81c:	e0bff615 	stw	r2,-40(fp)
 201c820:	00001b06 	br	201c890 <tcp_connect+0x1cc>
        if ((cpcb->local_port == pcb->local_port) &&
 201c824:	e0bff617 	ldw	r2,-40(fp)
 201c828:	10c0078b 	ldhu	r3,30(r2)
 201c82c:	e0bffc17 	ldw	r2,-16(fp)
 201c830:	1080078b 	ldhu	r2,30(r2)
 201c834:	18ffffcc 	andi	r3,r3,65535
 201c838:	10bfffcc 	andi	r2,r2,65535
 201c83c:	1880111e 	bne	r3,r2,201c884 <tcp_connect+0x1c0>
            (cpcb->remote_port == port) &&
 201c840:	e0bff617 	ldw	r2,-40(fp)
 201c844:	1080080b 	ldhu	r2,32(r2)
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
 201c848:	10ffffcc 	andi	r3,r2,65535
 201c84c:	e0bffe0b 	ldhu	r2,-8(fp)
 201c850:	18800c1e 	bne	r3,r2,201c884 <tcp_connect+0x1c0>
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 201c854:	e0bff617 	ldw	r2,-40(fp)
 201c858:	10c00017 	ldw	r3,0(r2)
 201c85c:	e0bffc17 	ldw	r2,-16(fp)
 201c860:	10800017 	ldw	r2,0(r2)
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
 201c864:	1880071e 	bne	r3,r2,201c884 <tcp_connect+0x1c0>
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
 201c868:	e0bff617 	ldw	r2,-40(fp)
 201c86c:	10c00117 	ldw	r3,4(r2)
 201c870:	e0bffd17 	ldw	r2,-12(fp)
 201c874:	10800017 	ldw	r2,0(r2)
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
        if ((cpcb->local_port == pcb->local_port) &&
            (cpcb->remote_port == port) &&
            ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
 201c878:	1880021e 	bne	r3,r2,201c884 <tcp_connect+0x1c0>
            ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
          /* linux returns EISCONN here, but ERR_USE should be OK for us */
          return ERR_USE;
 201c87c:	00bffe04 	movi	r2,-8
 201c880:	00007106 	br	201ca48 <tcp_connect+0x384>
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
      for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 201c884:	e0bff617 	ldw	r2,-40(fp)
 201c888:	10800317 	ldw	r2,12(r2)
 201c88c:	e0bff615 	stw	r2,-40(fp)
 201c890:	e0bff617 	ldw	r2,-40(fp)
 201c894:	103fe31e 	bne	r2,zero,201c824 <__alt_mem_mem_0+0xfcffc824>
    /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
       now that the 5-tuple is unique. */
    struct tcp_pcb *cpcb;
    int i;
    /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
    for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
 201c898:	e0bff717 	ldw	r2,-36(fp)
 201c89c:	10800044 	addi	r2,r2,1
 201c8a0:	e0bff715 	stw	r2,-36(fp)
 201c8a4:	e0bff717 	ldw	r2,-36(fp)
 201c8a8:	10800110 	cmplti	r2,r2,4
 201c8ac:	103fd31e 	bne	r2,zero,201c7fc <__alt_mem_mem_0+0xfcffc7fc>
        }
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
 201c8b0:	201dd080 	call	201dd08 <tcp_next_iss>
 201c8b4:	e0bffa15 	stw	r2,-24(fp)
  pcb->rcv_nxt = 0;
 201c8b8:	e0bffc17 	ldw	r2,-16(fp)
 201c8bc:	10000b15 	stw	zero,44(r2)
  pcb->snd_nxt = iss;
 201c8c0:	e0bffc17 	ldw	r2,-16(fp)
 201c8c4:	e0fffa17 	ldw	r3,-24(fp)
 201c8c8:	10c01515 	stw	r3,84(r2)
  pcb->lastack = iss - 1;
 201c8cc:	e0bffa17 	ldw	r2,-24(fp)
 201c8d0:	10ffffc4 	addi	r3,r2,-1
 201c8d4:	e0bffc17 	ldw	r2,-16(fp)
 201c8d8:	10c01315 	stw	r3,76(r2)
  pcb->snd_lbb = iss - 1;
 201c8dc:	e0bffa17 	ldw	r2,-24(fp)
 201c8e0:	10ffffc4 	addi	r3,r2,-1
 201c8e4:	e0bffc17 	ldw	r2,-16(fp)
 201c8e8:	10c01815 	stw	r3,96(r2)
  pcb->rcv_wnd = TCP_WND;
 201c8ec:	e0bffc17 	ldw	r2,-16(fp)
 201c8f0:	00c80004 	movi	r3,8192
 201c8f4:	10c00c0d 	sth	r3,48(r2)
  pcb->rcv_ann_wnd = TCP_WND;
 201c8f8:	e0bffc17 	ldw	r2,-16(fp)
 201c8fc:	00c80004 	movi	r3,8192
 201c900:	10c00c8d 	sth	r3,50(r2)
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 201c904:	e0bffc17 	ldw	r2,-16(fp)
 201c908:	10c00b17 	ldw	r3,44(r2)
 201c90c:	e0bffc17 	ldw	r2,-16(fp)
 201c910:	10c00d15 	stw	r3,52(r2)
  pcb->snd_wnd = TCP_WND;
 201c914:	e0bffc17 	ldw	r2,-16(fp)
 201c918:	00c80004 	movi	r3,8192
 201c91c:	10c0190d 	sth	r3,100(r2)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 201c920:	e0bffc17 	ldw	r2,-16(fp)
 201c924:	00c08604 	movi	r3,536
 201c928:	10c00e8d 	sth	r3,58(r2)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), ipaddr);
 201c92c:	e0bffc17 	ldw	r2,-16(fp)
 201c930:	10800e8b 	ldhu	r2,58(r2)
 201c934:	10bfffcc 	andi	r2,r2,65535
 201c938:	e0fffc17 	ldw	r3,-16(fp)
 201c93c:	e1bffd17 	ldw	r6,-12(fp)
 201c940:	180b883a 	mov	r5,r3
 201c944:	1009883a 	mov	r4,r2
 201c948:	201dd380 	call	201dd38 <tcp_eff_send_mss>
 201c94c:	1007883a 	mov	r3,r2
 201c950:	e0bffc17 	ldw	r2,-16(fp)
 201c954:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 201c958:	e0bffc17 	ldw	r2,-16(fp)
 201c95c:	00c00044 	movi	r3,1
 201c960:	10c0140d 	sth	r3,80(r2)
  pcb->ssthresh = pcb->mss * 10;
 201c964:	e0bffc17 	ldw	r2,-16(fp)
 201c968:	10800e8b 	ldhu	r2,58(r2)
 201c96c:	108002a4 	muli	r2,r2,10
 201c970:	1007883a 	mov	r3,r2
 201c974:	e0bffc17 	ldw	r2,-16(fp)
 201c978:	10c0148d 	sth	r3,82(r2)
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 201c97c:	e0bffc17 	ldw	r2,-16(fp)
 201c980:	e0ffff17 	ldw	r3,-4(fp)
 201c984:	10c02215 	stw	r3,136(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 201c988:	01400084 	movi	r5,2
 201c98c:	e13ffc17 	ldw	r4,-16(fp)
 201c990:	201f2fc0 	call	201f2fc <tcp_enqueue_flags>
 201c994:	e0bffb05 	stb	r2,-20(fp)
  if (ret == ERR_OK) {
 201c998:	e0bffb07 	ldb	r2,-20(fp)
 201c99c:	1000291e 	bne	r2,zero,201ca44 <tcp_connect+0x380>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 201c9a0:	e0bffc17 	ldw	r2,-16(fp)
 201c9a4:	00c00084 	movi	r3,2
 201c9a8:	10c00615 	stw	r3,24(r2)
    if (old_local_port != 0) {
 201c9ac:	e0bff90b 	ldhu	r2,-28(fp)
 201c9b0:	10001a26 	beq	r2,zero,201ca1c <tcp_connect+0x358>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 201c9b4:	d0e7fb17 	ldw	r3,-24596(gp)
 201c9b8:	e0bffc17 	ldw	r2,-16(fp)
 201c9bc:	1880041e 	bne	r3,r2,201c9d0 <tcp_connect+0x30c>
 201c9c0:	d0a7fb17 	ldw	r2,-24596(gp)
 201c9c4:	10800317 	ldw	r2,12(r2)
 201c9c8:	d0a7fb15 	stw	r2,-24596(gp)
 201c9cc:	00001106 	br	201ca14 <tcp_connect+0x350>
 201c9d0:	d0a7fb17 	ldw	r2,-24596(gp)
 201c9d4:	d0a7fa15 	stw	r2,-24600(gp)
 201c9d8:	00000c06 	br	201ca0c <tcp_connect+0x348>
 201c9dc:	d0a7fa17 	ldw	r2,-24600(gp)
 201c9e0:	10c00317 	ldw	r3,12(r2)
 201c9e4:	e0bffc17 	ldw	r2,-16(fp)
 201c9e8:	1880051e 	bne	r3,r2,201ca00 <tcp_connect+0x33c>
 201c9ec:	d0a7fa17 	ldw	r2,-24600(gp)
 201c9f0:	e0fffc17 	ldw	r3,-16(fp)
 201c9f4:	18c00317 	ldw	r3,12(r3)
 201c9f8:	10c00315 	stw	r3,12(r2)
 201c9fc:	00000506 	br	201ca14 <tcp_connect+0x350>
 201ca00:	d0a7fa17 	ldw	r2,-24600(gp)
 201ca04:	10800317 	ldw	r2,12(r2)
 201ca08:	d0a7fa15 	stw	r2,-24600(gp)
 201ca0c:	d0a7fa17 	ldw	r2,-24600(gp)
 201ca10:	103ff21e 	bne	r2,zero,201c9dc <__alt_mem_mem_0+0xfcffc9dc>
 201ca14:	e0bffc17 	ldw	r2,-16(fp)
 201ca18:	10000315 	stw	zero,12(r2)
    }
    TCP_REG_ACTIVE(pcb);
 201ca1c:	d0e7f717 	ldw	r3,-24612(gp)
 201ca20:	e0bffc17 	ldw	r2,-16(fp)
 201ca24:	10c00315 	stw	r3,12(r2)
 201ca28:	e0bffc17 	ldw	r2,-16(fp)
 201ca2c:	d0a7f715 	stw	r2,-24612(gp)
 201ca30:	20215540 	call	2021554 <tcp_timer_needed>
 201ca34:	00800044 	movi	r2,1
 201ca38:	d0a7f685 	stb	r2,-24614(gp)
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
 201ca3c:	e13ffc17 	ldw	r4,-16(fp)
 201ca40:	201f7800 	call	201f780 <tcp_output>
  }
  return ret;
 201ca44:	e0bffb03 	ldbu	r2,-20(fp)
}
 201ca48:	e037883a 	mov	sp,fp
 201ca4c:	dfc00117 	ldw	ra,4(sp)
 201ca50:	df000017 	ldw	fp,0(sp)
 201ca54:	dec00204 	addi	sp,sp,8
 201ca58:	f800283a 	ret

0201ca5c <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 201ca5c:	defff304 	addi	sp,sp,-52
 201ca60:	dfc00c15 	stw	ra,48(sp)
 201ca64:	df000b15 	stw	fp,44(sp)
 201ca68:	dc000a15 	stw	r16,40(sp)
 201ca6c:	df000b04 	addi	fp,sp,44
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
 201ca70:	e03ff985 	stb	zero,-26(fp)

  ++tcp_ticks;
 201ca74:	d0a7f817 	ldw	r2,-24608(gp)
 201ca78:	10800044 	addi	r2,r2,1
 201ca7c:	d0a7f815 	stw	r2,-24608(gp)
  ++tcp_timer_ctr;
 201ca80:	d0a7f643 	ldbu	r2,-24615(gp)
 201ca84:	10800044 	addi	r2,r2,1
 201ca88:	d0a7f645 	stb	r2,-24615(gp)

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
 201ca8c:	e03ff815 	stw	zero,-32(fp)
  pcb = tcp_active_pcbs;
 201ca90:	d0a7f717 	ldw	r2,-24612(gp)
 201ca94:	e0bff715 	stw	r2,-36(fp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 201ca98:	00018906 	br	201d0c0 <tcp_slowtmr+0x664>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
 201ca9c:	e0bff717 	ldw	r2,-36(fp)
 201caa0:	10c00943 	ldbu	r3,37(r2)
 201caa4:	d0a7f643 	ldbu	r2,-24615(gp)
 201caa8:	18c03fcc 	andi	r3,r3,255
 201caac:	10803fcc 	andi	r2,r2,255
 201cab0:	1880041e 	bne	r3,r2,201cac4 <tcp_slowtmr+0x68>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
 201cab4:	e0bff717 	ldw	r2,-36(fp)
 201cab8:	10800317 	ldw	r2,12(r2)
 201cabc:	e0bff715 	stw	r2,-36(fp)
      continue;
 201cac0:	00017f06 	br	201d0c0 <tcp_slowtmr+0x664>
    }
    pcb->last_timer = tcp_timer_ctr;
 201cac4:	d0e7f643 	ldbu	r3,-24615(gp)
 201cac8:	e0bff717 	ldw	r2,-36(fp)
 201cacc:	10c00945 	stb	r3,37(r2)

    pcb_remove = 0;
 201cad0:	e03ff905 	stb	zero,-28(fp)
    pcb_reset = 0;
 201cad4:	e03ff945 	stb	zero,-27(fp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 201cad8:	e0bff717 	ldw	r2,-36(fp)
 201cadc:	10800617 	ldw	r2,24(r2)
 201cae0:	10800098 	cmpnei	r2,r2,2
 201cae4:	1000091e 	bne	r2,zero,201cb0c <tcp_slowtmr+0xb0>
 201cae8:	e0bff717 	ldw	r2,-36(fp)
 201caec:	10801283 	ldbu	r2,74(r2)
 201caf0:	10803fcc 	andi	r2,r2,255
 201caf4:	10800198 	cmpnei	r2,r2,6
 201caf8:	1000041e 	bne	r2,zero,201cb0c <tcp_slowtmr+0xb0>
      ++pcb_remove;
 201cafc:	e0bff903 	ldbu	r2,-28(fp)
 201cb00:	10800044 	addi	r2,r2,1
 201cb04:	e0bff905 	stb	r2,-28(fp)
 201cb08:	00008d06 	br	201cd40 <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 201cb0c:	e0bff717 	ldw	r2,-36(fp)
 201cb10:	10801283 	ldbu	r2,74(r2)
 201cb14:	10803fcc 	andi	r2,r2,255
 201cb18:	10800318 	cmpnei	r2,r2,12
 201cb1c:	1000041e 	bne	r2,zero,201cb30 <tcp_slowtmr+0xd4>
      ++pcb_remove;
 201cb20:	e0bff903 	ldbu	r2,-28(fp)
 201cb24:	10800044 	addi	r2,r2,1
 201cb28:	e0bff905 	stb	r2,-28(fp)
 201cb2c:	00008406 	br	201cd40 <tcp_slowtmr+0x2e4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 201cb30:	e0bff717 	ldw	r2,-36(fp)
 201cb34:	10802843 	ldbu	r2,161(r2)
 201cb38:	10803fcc 	andi	r2,r2,255
 201cb3c:	10002226 	beq	r2,zero,201cbc8 <tcp_slowtmr+0x16c>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 201cb40:	e0bff717 	ldw	r2,-36(fp)
 201cb44:	10802803 	ldbu	r2,160(r2)
 201cb48:	10800044 	addi	r2,r2,1
 201cb4c:	1007883a 	mov	r3,r2
 201cb50:	e0bff717 	ldw	r2,-36(fp)
 201cb54:	10c02805 	stb	r3,160(r2)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 201cb58:	e0bff717 	ldw	r2,-36(fp)
 201cb5c:	11002803 	ldbu	r4,160(r2)
 201cb60:	e0bff717 	ldw	r2,-36(fp)
 201cb64:	10802843 	ldbu	r2,161(r2)
 201cb68:	10803fcc 	andi	r2,r2,255
 201cb6c:	10ffffc4 	addi	r3,r2,-1
 201cb70:	d0a00f84 	addi	r2,gp,-32706
 201cb74:	1885883a 	add	r2,r3,r2
 201cb78:	10800003 	ldbu	r2,0(r2)
 201cb7c:	20c03fcc 	andi	r3,r4,255
 201cb80:	10803fcc 	andi	r2,r2,255
 201cb84:	18806e36 	bltu	r3,r2,201cd40 <tcp_slowtmr+0x2e4>
          pcb->persist_cnt = 0;
 201cb88:	e0bff717 	ldw	r2,-36(fp)
 201cb8c:	10002805 	stb	zero,160(r2)
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 201cb90:	e0bff717 	ldw	r2,-36(fp)
 201cb94:	10802843 	ldbu	r2,161(r2)
 201cb98:	10803fcc 	andi	r2,r2,255
 201cb9c:	108001e8 	cmpgeui	r2,r2,7
 201cba0:	1000061e 	bne	r2,zero,201cbbc <tcp_slowtmr+0x160>
            pcb->persist_backoff++;
 201cba4:	e0bff717 	ldw	r2,-36(fp)
 201cba8:	10802843 	ldbu	r2,161(r2)
 201cbac:	10800044 	addi	r2,r2,1
 201cbb0:	1007883a 	mov	r3,r2
 201cbb4:	e0bff717 	ldw	r2,-36(fp)
 201cbb8:	10c02845 	stb	r3,161(r2)
          }
          tcp_zero_window_probe(pcb);
 201cbbc:	e13ff717 	ldw	r4,-36(fp)
 201cbc0:	20212100 	call	2021210 <tcp_zero_window_probe>
 201cbc4:	00005e06 	br	201cd40 <tcp_slowtmr+0x2e4>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
 201cbc8:	e0bff717 	ldw	r2,-36(fp)
 201cbcc:	10800e0b 	ldhu	r2,56(r2)
 201cbd0:	10bfffcc 	andi	r2,r2,65535
 201cbd4:	10a0001c 	xori	r2,r2,32768
 201cbd8:	10a00004 	addi	r2,r2,-32768
 201cbdc:	10000616 	blt	r2,zero,201cbf8 <tcp_slowtmr+0x19c>
          ++pcb->rtime;
 201cbe0:	e0bff717 	ldw	r2,-36(fp)
 201cbe4:	10800e0b 	ldhu	r2,56(r2)
 201cbe8:	10800044 	addi	r2,r2,1
 201cbec:	1007883a 	mov	r3,r2
 201cbf0:	e0bff717 	ldw	r2,-36(fp)
 201cbf4:	10c00e0d 	sth	r3,56(r2)
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 201cbf8:	e0bff717 	ldw	r2,-36(fp)
 201cbfc:	10801d17 	ldw	r2,116(r2)
 201cc00:	10004f26 	beq	r2,zero,201cd40 <tcp_slowtmr+0x2e4>
 201cc04:	e0bff717 	ldw	r2,-36(fp)
 201cc08:	10c00e0b 	ldhu	r3,56(r2)
 201cc0c:	e0bff717 	ldw	r2,-36(fp)
 201cc10:	1080120b 	ldhu	r2,72(r2)
 201cc14:	18ffffcc 	andi	r3,r3,65535
 201cc18:	18e0001c 	xori	r3,r3,32768
 201cc1c:	18e00004 	addi	r3,r3,-32768
 201cc20:	10bfffcc 	andi	r2,r2,65535
 201cc24:	10a0001c 	xori	r2,r2,32768
 201cc28:	10a00004 	addi	r2,r2,-32768
 201cc2c:	18804416 	blt	r3,r2,201cd40 <tcp_slowtmr+0x2e4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 201cc30:	e0bff717 	ldw	r2,-36(fp)
 201cc34:	10800617 	ldw	r2,24(r2)
 201cc38:	108000a0 	cmpeqi	r2,r2,2
 201cc3c:	10001b1e 	bne	r2,zero,201ccac <tcp_slowtmr+0x250>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 201cc40:	e0bff717 	ldw	r2,-36(fp)
 201cc44:	1080110b 	ldhu	r2,68(r2)
 201cc48:	10bfffcc 	andi	r2,r2,65535
 201cc4c:	10a0001c 	xori	r2,r2,32768
 201cc50:	10a00004 	addi	r2,r2,-32768
 201cc54:	1005d0fa 	srai	r2,r2,3
 201cc58:	10ffffcc 	andi	r3,r2,65535
 201cc5c:	18e0001c 	xori	r3,r3,32768
 201cc60:	18e00004 	addi	r3,r3,-32768
 201cc64:	e0bff717 	ldw	r2,-36(fp)
 201cc68:	1080118b 	ldhu	r2,70(r2)
 201cc6c:	10bfffcc 	andi	r2,r2,65535
 201cc70:	10a0001c 	xori	r2,r2,32768
 201cc74:	10a00004 	addi	r2,r2,-32768
 201cc78:	1887883a 	add	r3,r3,r2
 201cc7c:	e0bff717 	ldw	r2,-36(fp)
 201cc80:	10801283 	ldbu	r2,74(r2)
 201cc84:	11003fcc 	andi	r4,r2,255
 201cc88:	00808134 	movhi	r2,516
 201cc8c:	1085c004 	addi	r2,r2,5888
 201cc90:	1105883a 	add	r2,r2,r4
 201cc94:	10800003 	ldbu	r2,0(r2)
 201cc98:	10803fcc 	andi	r2,r2,255
 201cc9c:	1884983a 	sll	r2,r3,r2
 201cca0:	1007883a 	mov	r3,r2
 201cca4:	e0bff717 	ldw	r2,-36(fp)
 201cca8:	10c0120d 	sth	r3,72(r2)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 201ccac:	e0bff717 	ldw	r2,-36(fp)
 201ccb0:	10000e0d 	sth	zero,56(r2)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
 201ccb4:	e0bff717 	ldw	r2,-36(fp)
 201ccb8:	10c0190b 	ldhu	r3,100(r2)
 201ccbc:	e0bff717 	ldw	r2,-36(fp)
 201ccc0:	1140140b 	ldhu	r5,80(r2)
 201ccc4:	1805883a 	mov	r2,r3
 201ccc8:	10ffffcc 	andi	r3,r2,65535
 201cccc:	293fffcc 	andi	r4,r5,65535
 201ccd0:	20c0012e 	bgeu	r4,r3,201ccd8 <tcp_slowtmr+0x27c>
 201ccd4:	2805883a 	mov	r2,r5
 201ccd8:	e0bffa0d 	sth	r2,-24(fp)
          pcb->ssthresh = eff_wnd >> 1;
 201ccdc:	e0bffa0b 	ldhu	r2,-24(fp)
 201cce0:	1004d07a 	srli	r2,r2,1
 201cce4:	1007883a 	mov	r3,r2
 201cce8:	e0bff717 	ldw	r2,-36(fp)
 201ccec:	10c0148d 	sth	r3,82(r2)
          if (pcb->ssthresh < (pcb->mss << 1)) {
 201ccf0:	e0bff717 	ldw	r2,-36(fp)
 201ccf4:	1080148b 	ldhu	r2,82(r2)
 201ccf8:	10ffffcc 	andi	r3,r2,65535
 201ccfc:	e0bff717 	ldw	r2,-36(fp)
 201cd00:	10800e8b 	ldhu	r2,58(r2)
 201cd04:	10bfffcc 	andi	r2,r2,65535
 201cd08:	1085883a 	add	r2,r2,r2
 201cd0c:	1880060e 	bge	r3,r2,201cd28 <tcp_slowtmr+0x2cc>
            pcb->ssthresh = (pcb->mss << 1);
 201cd10:	e0bff717 	ldw	r2,-36(fp)
 201cd14:	10800e8b 	ldhu	r2,58(r2)
 201cd18:	1085883a 	add	r2,r2,r2
 201cd1c:	1007883a 	mov	r3,r2
 201cd20:	e0bff717 	ldw	r2,-36(fp)
 201cd24:	10c0148d 	sth	r3,82(r2)
          }
          pcb->cwnd = pcb->mss;
 201cd28:	e0bff717 	ldw	r2,-36(fp)
 201cd2c:	10c00e8b 	ldhu	r3,58(r2)
 201cd30:	e0bff717 	ldw	r2,-36(fp)
 201cd34:	10c0140d 	sth	r3,80(r2)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 201cd38:	e13ff717 	ldw	r4,-36(fp)
 201cd3c:	2020bf80 	call	2020bf8 <tcp_rexmit_rto>
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 201cd40:	e0bff717 	ldw	r2,-36(fp)
 201cd44:	10800617 	ldw	r2,24(r2)
 201cd48:	10800198 	cmpnei	r2,r2,6
 201cd4c:	10000e1e 	bne	r2,zero,201cd88 <tcp_slowtmr+0x32c>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 201cd50:	e0bff717 	ldw	r2,-36(fp)
 201cd54:	10800883 	ldbu	r2,34(r2)
 201cd58:	10803fcc 	andi	r2,r2,255
 201cd5c:	1080040c 	andi	r2,r2,16
 201cd60:	10000926 	beq	r2,zero,201cd88 <tcp_slowtmr+0x32c>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 201cd64:	d0e7f817 	ldw	r3,-24608(gp)
 201cd68:	e0bff717 	ldw	r2,-36(fp)
 201cd6c:	10800a17 	ldw	r2,40(r2)
 201cd70:	1885c83a 	sub	r2,r3,r2
 201cd74:	10800a70 	cmpltui	r2,r2,41
 201cd78:	1000031e 	bne	r2,zero,201cd88 <tcp_slowtmr+0x32c>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 201cd7c:	e0bff903 	ldbu	r2,-28(fp)
 201cd80:	10800044 	addi	r2,r2,1
 201cd84:	e0bff905 	stb	r2,-28(fp)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 201cd88:	e0bff717 	ldw	r2,-36(fp)
 201cd8c:	10800203 	ldbu	r2,8(r2)
 201cd90:	10803fcc 	andi	r2,r2,255
 201cd94:	1080020c 	andi	r2,r2,8
 201cd98:	10003826 	beq	r2,zero,201ce7c <tcp_slowtmr+0x420>
       ((pcb->state == ESTABLISHED) ||
 201cd9c:	e0bff717 	ldw	r2,-36(fp)
 201cda0:	10800617 	ldw	r2,24(r2)
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 201cda4:	10800120 	cmpeqi	r2,r2,4
 201cda8:	1000041e 	bne	r2,zero,201cdbc <tcp_slowtmr+0x360>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
 201cdac:	e0bff717 	ldw	r2,-36(fp)
 201cdb0:	10800617 	ldw	r2,24(r2)
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
 201cdb4:	108001d8 	cmpnei	r2,r2,7
 201cdb8:	1000301e 	bne	r2,zero,201ce7c <tcp_slowtmr+0x420>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 201cdbc:	d0e7f817 	ldw	r3,-24608(gp)
 201cdc0:	e0bff717 	ldw	r2,-36(fp)
 201cdc4:	10800a17 	ldw	r2,40(r2)
 201cdc8:	18a1c83a 	sub	r16,r3,r2
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 201cdcc:	e0bff717 	ldw	r2,-36(fp)
 201cdd0:	10c02517 	ldw	r3,148(r2)
 201cdd4:	e0bff717 	ldw	r2,-36(fp)
 201cdd8:	11002717 	ldw	r4,156(r2)
 201cddc:	e0bff717 	ldw	r2,-36(fp)
 201cde0:	10802617 	ldw	r2,152(r2)
 201cde4:	2085383a 	mul	r2,r4,r2
 201cde8:	1885883a 	add	r2,r3,r2
 201cdec:	01407d04 	movi	r5,500
 201cdf0:	1009883a 	mov	r4,r2
 201cdf4:	200aca80 	call	200aca8 <__udivsi3>

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 201cdf8:	1400072e 	bgeu	r2,r16,201ce18 <tcp_slowtmr+0x3bc>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
 201cdfc:	e0bff903 	ldbu	r2,-28(fp)
 201ce00:	10800044 	addi	r2,r2,1
 201ce04:	e0bff905 	stb	r2,-28(fp)
        ++pcb_reset;
 201ce08:	e0bff943 	ldbu	r2,-27(fp)
 201ce0c:	10800044 	addi	r2,r2,1
 201ce10:	e0bff945 	stb	r2,-27(fp)
 201ce14:	00001906 	br	201ce7c <tcp_slowtmr+0x420>
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 201ce18:	d0e7f817 	ldw	r3,-24608(gp)
 201ce1c:	e0bff717 	ldw	r2,-36(fp)
 201ce20:	10800a17 	ldw	r2,40(r2)
 201ce24:	18a1c83a 	sub	r16,r3,r2
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
 201ce28:	e0bff717 	ldw	r2,-36(fp)
 201ce2c:	10c02517 	ldw	r3,148(r2)
 201ce30:	e0bff717 	ldw	r2,-36(fp)
 201ce34:	10802883 	ldbu	r2,162(r2)
 201ce38:	11003fcc 	andi	r4,r2,255
 201ce3c:	e0bff717 	ldw	r2,-36(fp)
 201ce40:	10802617 	ldw	r2,152(r2)
 201ce44:	2085383a 	mul	r2,r4,r2
 201ce48:	1885883a 	add	r2,r3,r2
              / TCP_SLOW_INTERVAL)
 201ce4c:	01407d04 	movi	r5,500
 201ce50:	1009883a 	mov	r4,r2
 201ce54:	200aca80 	call	200aca8 <__udivsi3>
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 201ce58:	1400082e 	bgeu	r2,r16,201ce7c <tcp_slowtmr+0x420>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
 201ce5c:	e13ff717 	ldw	r4,-36(fp)
 201ce60:	202107c0 	call	202107c <tcp_keepalive>
        pcb->keep_cnt_sent++;
 201ce64:	e0bff717 	ldw	r2,-36(fp)
 201ce68:	10802883 	ldbu	r2,162(r2)
 201ce6c:	10800044 	addi	r2,r2,1
 201ce70:	1007883a 	mov	r3,r2
 201ce74:	e0bff717 	ldw	r2,-36(fp)
 201ce78:	10c02885 	stb	r3,162(r2)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 201ce7c:	e0bff717 	ldw	r2,-36(fp)
 201ce80:	10801e17 	ldw	r2,120(r2)
 201ce84:	10001126 	beq	r2,zero,201cecc <tcp_slowtmr+0x470>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
 201ce88:	d0e7f817 	ldw	r3,-24608(gp)
 201ce8c:	e0bff717 	ldw	r2,-36(fp)
 201ce90:	10800a17 	ldw	r2,40(r2)
 201ce94:	1887c83a 	sub	r3,r3,r2
 201ce98:	e0bff717 	ldw	r2,-36(fp)
 201ce9c:	1080120b 	ldhu	r2,72(r2)
 201cea0:	10bfffcc 	andi	r2,r2,65535
 201cea4:	10a0001c 	xori	r2,r2,32768
 201cea8:	10a00004 	addi	r2,r2,-32768
 201ceac:	108001a4 	muli	r2,r2,6

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
 201ceb0:	18800636 	bltu	r3,r2,201cecc <tcp_slowtmr+0x470>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
 201ceb4:	e0bff717 	ldw	r2,-36(fp)
 201ceb8:	10801e17 	ldw	r2,120(r2)
 201cebc:	1009883a 	mov	r4,r2
 201cec0:	201d3dc0 	call	201d3dc <tcp_segs_free>
      pcb->ooseq = NULL;
 201cec4:	e0bff717 	ldw	r2,-36(fp)
 201cec8:	10001e15 	stw	zero,120(r2)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 201cecc:	e0bff717 	ldw	r2,-36(fp)
 201ced0:	10800617 	ldw	r2,24(r2)
 201ced4:	108000d8 	cmpnei	r2,r2,3
 201ced8:	1000091e 	bne	r2,zero,201cf00 <tcp_slowtmr+0x4a4>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 201cedc:	d0e7f817 	ldw	r3,-24608(gp)
 201cee0:	e0bff717 	ldw	r2,-36(fp)
 201cee4:	10800a17 	ldw	r2,40(r2)
 201cee8:	1885c83a 	sub	r2,r3,r2
 201ceec:	10800a70 	cmpltui	r2,r2,41
 201cef0:	1000031e 	bne	r2,zero,201cf00 <tcp_slowtmr+0x4a4>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
 201cef4:	e0bff903 	ldbu	r2,-28(fp)
 201cef8:	10800044 	addi	r2,r2,1
 201cefc:	e0bff905 	stb	r2,-28(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 201cf00:	e0bff717 	ldw	r2,-36(fp)
 201cf04:	10800617 	ldw	r2,24(r2)
 201cf08:	10800258 	cmpnei	r2,r2,9
 201cf0c:	1000091e 	bne	r2,zero,201cf34 <tcp_slowtmr+0x4d8>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 201cf10:	d0e7f817 	ldw	r3,-24608(gp)
 201cf14:	e0bff717 	ldw	r2,-36(fp)
 201cf18:	10800a17 	ldw	r2,40(r2)
 201cf1c:	1885c83a 	sub	r2,r3,r2
 201cf20:	10803c70 	cmpltui	r2,r2,241
 201cf24:	1000031e 	bne	r2,zero,201cf34 <tcp_slowtmr+0x4d8>
        ++pcb_remove;
 201cf28:	e0bff903 	ldbu	r2,-28(fp)
 201cf2c:	10800044 	addi	r2,r2,1
 201cf30:	e0bff905 	stb	r2,-28(fp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 201cf34:	e0bff903 	ldbu	r2,-28(fp)
 201cf38:	10003726 	beq	r2,zero,201d018 <tcp_slowtmr+0x5bc>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
 201cf3c:	e13ff717 	ldw	r4,-36(fp)
 201cf40:	201da8c0 	call	201da8c <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 201cf44:	e0bff817 	ldw	r2,-32(fp)
 201cf48:	10000526 	beq	r2,zero,201cf60 <tcp_slowtmr+0x504>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
 201cf4c:	e0bff717 	ldw	r2,-36(fp)
 201cf50:	10c00317 	ldw	r3,12(r2)
 201cf54:	e0bff817 	ldw	r2,-32(fp)
 201cf58:	10c00315 	stw	r3,12(r2)
 201cf5c:	00000306 	br	201cf6c <tcp_slowtmr+0x510>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
 201cf60:	e0bff717 	ldw	r2,-36(fp)
 201cf64:	10800317 	ldw	r2,12(r2)
 201cf68:	d0a7f715 	stw	r2,-24612(gp)
      }

      if (pcb_reset) {
 201cf6c:	e0bff943 	ldbu	r2,-27(fp)
 201cf70:	10001026 	beq	r2,zero,201cfb4 <tcp_slowtmr+0x558>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201cf74:	e0bff717 	ldw	r2,-36(fp)
 201cf78:	11001517 	ldw	r4,84(r2)
 201cf7c:	e0bff717 	ldw	r2,-36(fp)
 201cf80:	11400b17 	ldw	r5,44(r2)
 201cf84:	e1bff717 	ldw	r6,-36(fp)
 201cf88:	e0bff717 	ldw	r2,-36(fp)
 201cf8c:	11c00104 	addi	r7,r2,4
          pcb->local_port, pcb->remote_port);
 201cf90:	e0bff717 	ldw	r2,-36(fp)
 201cf94:	1080078b 	ldhu	r2,30(r2)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201cf98:	10bfffcc 	andi	r2,r2,65535
          pcb->local_port, pcb->remote_port);
 201cf9c:	e0fff717 	ldw	r3,-36(fp)
 201cfa0:	18c0080b 	ldhu	r3,32(r3)
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 201cfa4:	18ffffcc 	andi	r3,r3,65535
 201cfa8:	d8c00115 	stw	r3,4(sp)
 201cfac:	d8800015 	stw	r2,0(sp)
 201cfb0:	202082c0 	call	202082c <tcp_rst>
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
 201cfb4:	e0bff717 	ldw	r2,-36(fp)
 201cfb8:	10802417 	ldw	r2,144(r2)
 201cfbc:	e0bffb15 	stw	r2,-20(fp)
      err_arg = pcb->callback_arg;
 201cfc0:	e0bff717 	ldw	r2,-36(fp)
 201cfc4:	10800417 	ldw	r2,16(r2)
 201cfc8:	e0bffc15 	stw	r2,-16(fp)
      pcb2 = pcb;
 201cfcc:	e0bff717 	ldw	r2,-36(fp)
 201cfd0:	e0bffd15 	stw	r2,-12(fp)
      pcb = pcb->next;
 201cfd4:	e0bff717 	ldw	r2,-36(fp)
 201cfd8:	10800317 	ldw	r2,12(r2)
 201cfdc:	e0bff715 	stw	r2,-36(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
 201cfe0:	e17ffd17 	ldw	r5,-12(fp)
 201cfe4:	01000084 	movi	r4,2
 201cfe8:	20346000 	call	2034600 <memp_free>

      tcp_active_pcbs_changed = 0;
 201cfec:	d027f685 	stb	zero,-24614(gp)
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 201cff0:	e0bffb17 	ldw	r2,-20(fp)
 201cff4:	10000426 	beq	r2,zero,201d008 <tcp_slowtmr+0x5ac>
 201cff8:	e0bffb17 	ldw	r2,-20(fp)
 201cffc:	017ffd84 	movi	r5,-10
 201d000:	e13ffc17 	ldw	r4,-16(fp)
 201d004:	103ee83a 	callr	r2
      if (tcp_active_pcbs_changed) {
 201d008:	d0a7f683 	ldbu	r2,-24614(gp)
 201d00c:	10803fcc 	andi	r2,r2,255
 201d010:	10002b26 	beq	r2,zero,201d0c0 <tcp_slowtmr+0x664>
        goto tcp_slowtmr_start;
 201d014:	003e9d06 	br	201ca8c <__alt_mem_mem_0+0xfcffca8c>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
 201d018:	e0bff717 	ldw	r2,-36(fp)
 201d01c:	e0bff815 	stw	r2,-32(fp)
      pcb = pcb->next;
 201d020:	e0bff717 	ldw	r2,-36(fp)
 201d024:	10800317 	ldw	r2,12(r2)
 201d028:	e0bff715 	stw	r2,-36(fp)

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 201d02c:	e0bff817 	ldw	r2,-32(fp)
 201d030:	108008c3 	ldbu	r2,35(r2)
 201d034:	10800044 	addi	r2,r2,1
 201d038:	1007883a 	mov	r3,r2
 201d03c:	e0bff817 	ldw	r2,-32(fp)
 201d040:	10c008c5 	stb	r3,35(r2)
      if (prev->polltmr >= prev->pollinterval) {
 201d044:	e0bff817 	ldw	r2,-32(fp)
 201d048:	10c008c3 	ldbu	r3,35(r2)
 201d04c:	e0bff817 	ldw	r2,-32(fp)
 201d050:	10800903 	ldbu	r2,36(r2)
 201d054:	18c03fcc 	andi	r3,r3,255
 201d058:	10803fcc 	andi	r2,r2,255
 201d05c:	18801836 	bltu	r3,r2,201d0c0 <tcp_slowtmr+0x664>
        prev->polltmr = 0;
 201d060:	e0bff817 	ldw	r2,-32(fp)
 201d064:	100008c5 	stb	zero,35(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 201d068:	d027f685 	stb	zero,-24614(gp)
        TCP_EVENT_POLL(prev, err);
 201d06c:	e0bff817 	ldw	r2,-32(fp)
 201d070:	10802317 	ldw	r2,140(r2)
 201d074:	10000926 	beq	r2,zero,201d09c <tcp_slowtmr+0x640>
 201d078:	e0bff817 	ldw	r2,-32(fp)
 201d07c:	10802317 	ldw	r2,140(r2)
 201d080:	e0fff817 	ldw	r3,-32(fp)
 201d084:	18c00417 	ldw	r3,16(r3)
 201d088:	e17ff817 	ldw	r5,-32(fp)
 201d08c:	1809883a 	mov	r4,r3
 201d090:	103ee83a 	callr	r2
 201d094:	e0bff985 	stb	r2,-26(fp)
 201d098:	00000106 	br	201d0a0 <tcp_slowtmr+0x644>
 201d09c:	e03ff985 	stb	zero,-26(fp)
        if (tcp_active_pcbs_changed) {
 201d0a0:	d0a7f683 	ldbu	r2,-24614(gp)
 201d0a4:	10803fcc 	andi	r2,r2,255
 201d0a8:	10000126 	beq	r2,zero,201d0b0 <tcp_slowtmr+0x654>
          goto tcp_slowtmr_start;
 201d0ac:	003e7706 	br	201ca8c <__alt_mem_mem_0+0xfcffca8c>
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 201d0b0:	e0bff987 	ldb	r2,-26(fp)
 201d0b4:	1000021e 	bne	r2,zero,201d0c0 <tcp_slowtmr+0x664>
          tcp_output(prev);
 201d0b8:	e13ff817 	ldw	r4,-32(fp)
 201d0bc:	201f7800 	call	201f780 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 201d0c0:	e0bff717 	ldw	r2,-36(fp)
 201d0c4:	103e751e 	bne	r2,zero,201ca9c <__alt_mem_mem_0+0xfcffca9c>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
 201d0c8:	e03ff815 	stw	zero,-32(fp)
  pcb = tcp_tw_pcbs;
 201d0cc:	d0a7fc17 	ldw	r2,-24592(gp)
 201d0d0:	e0bff715 	stw	r2,-36(fp)
  while (pcb != NULL) {
 201d0d4:	00002606 	br	201d170 <tcp_slowtmr+0x714>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
 201d0d8:	e03ff905 	stb	zero,-28(fp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 201d0dc:	d0e7f817 	ldw	r3,-24608(gp)
 201d0e0:	e0bff717 	ldw	r2,-36(fp)
 201d0e4:	10800a17 	ldw	r2,40(r2)
 201d0e8:	1885c83a 	sub	r2,r3,r2
 201d0ec:	10803c70 	cmpltui	r2,r2,241
 201d0f0:	1000031e 	bne	r2,zero,201d100 <tcp_slowtmr+0x6a4>
      ++pcb_remove;
 201d0f4:	e0bff903 	ldbu	r2,-28(fp)
 201d0f8:	10800044 	addi	r2,r2,1
 201d0fc:	e0bff905 	stb	r2,-28(fp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 201d100:	e0bff903 	ldbu	r2,-28(fp)
 201d104:	10001526 	beq	r2,zero,201d15c <tcp_slowtmr+0x700>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
 201d108:	e13ff717 	ldw	r4,-36(fp)
 201d10c:	201da8c0 	call	201da8c <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 201d110:	e0bff817 	ldw	r2,-32(fp)
 201d114:	10000526 	beq	r2,zero,201d12c <tcp_slowtmr+0x6d0>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
 201d118:	e0bff717 	ldw	r2,-36(fp)
 201d11c:	10c00317 	ldw	r3,12(r2)
 201d120:	e0bff817 	ldw	r2,-32(fp)
 201d124:	10c00315 	stw	r3,12(r2)
 201d128:	00000306 	br	201d138 <tcp_slowtmr+0x6dc>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
 201d12c:	e0bff717 	ldw	r2,-36(fp)
 201d130:	10800317 	ldw	r2,12(r2)
 201d134:	d0a7fc15 	stw	r2,-24592(gp)
      }
      pcb2 = pcb;
 201d138:	e0bff717 	ldw	r2,-36(fp)
 201d13c:	e0bffe15 	stw	r2,-8(fp)
      pcb = pcb->next;
 201d140:	e0bff717 	ldw	r2,-36(fp)
 201d144:	10800317 	ldw	r2,12(r2)
 201d148:	e0bff715 	stw	r2,-36(fp)
      memp_free(MEMP_TCP_PCB, pcb2);
 201d14c:	e17ffe17 	ldw	r5,-8(fp)
 201d150:	01000084 	movi	r4,2
 201d154:	20346000 	call	2034600 <memp_free>
 201d158:	00000506 	br	201d170 <tcp_slowtmr+0x714>
    } else {
      prev = pcb;
 201d15c:	e0bff717 	ldw	r2,-36(fp)
 201d160:	e0bff815 	stw	r2,-32(fp)
      pcb = pcb->next;
 201d164:	e0bff717 	ldw	r2,-36(fp)
 201d168:	10800317 	ldw	r2,12(r2)
 201d16c:	e0bff715 	stw	r2,-36(fp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 201d170:	e0bff717 	ldw	r2,-36(fp)
 201d174:	103fd81e 	bne	r2,zero,201d0d8 <__alt_mem_mem_0+0xfcffd0d8>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 201d178:	0001883a 	nop
 201d17c:	e6ffff04 	addi	sp,fp,-4
 201d180:	dfc00217 	ldw	ra,8(sp)
 201d184:	df000117 	ldw	fp,4(sp)
 201d188:	dc000017 	ldw	r16,0(sp)
 201d18c:	dec00304 	addi	sp,sp,12
 201d190:	f800283a 	ret

0201d194 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 201d194:	defffc04 	addi	sp,sp,-16
 201d198:	dfc00315 	stw	ra,12(sp)
 201d19c:	df000215 	stw	fp,8(sp)
 201d1a0:	df000204 	addi	fp,sp,8
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 201d1a4:	d0a7f643 	ldbu	r2,-24615(gp)
 201d1a8:	10800044 	addi	r2,r2,1
 201d1ac:	d0a7f645 	stb	r2,-24615(gp)

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 201d1b0:	d0a7f717 	ldw	r2,-24612(gp)
 201d1b4:	e0bffe15 	stw	r2,-8(fp)

  while(pcb != NULL) {
 201d1b8:	00002c06 	br	201d26c <tcp_fasttmr+0xd8>
    if (pcb->last_timer != tcp_timer_ctr) {
 201d1bc:	e0bffe17 	ldw	r2,-8(fp)
 201d1c0:	10c00943 	ldbu	r3,37(r2)
 201d1c4:	d0a7f643 	ldbu	r2,-24615(gp)
 201d1c8:	18c03fcc 	andi	r3,r3,255
 201d1cc:	10803fcc 	andi	r2,r2,255
 201d1d0:	18802626 	beq	r3,r2,201d26c <tcp_fasttmr+0xd8>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 201d1d4:	d0e7f643 	ldbu	r3,-24615(gp)
 201d1d8:	e0bffe17 	ldw	r2,-8(fp)
 201d1dc:	10c00945 	stb	r3,37(r2)
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 201d1e0:	e0bffe17 	ldw	r2,-8(fp)
 201d1e4:	10800883 	ldbu	r2,34(r2)
 201d1e8:	10803fcc 	andi	r2,r2,255
 201d1ec:	1080004c 	andi	r2,r2,1
 201d1f0:	10000f26 	beq	r2,zero,201d230 <tcp_fasttmr+0x9c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 201d1f4:	e0bffe17 	ldw	r2,-8(fp)
 201d1f8:	10800883 	ldbu	r2,34(r2)
 201d1fc:	10800094 	ori	r2,r2,2
 201d200:	1007883a 	mov	r3,r2
 201d204:	e0bffe17 	ldw	r2,-8(fp)
 201d208:	10c00885 	stb	r3,34(r2)
        tcp_output(pcb);
 201d20c:	e13ffe17 	ldw	r4,-8(fp)
 201d210:	201f7800 	call	201f780 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 201d214:	e0bffe17 	ldw	r2,-8(fp)
 201d218:	10c00883 	ldbu	r3,34(r2)
 201d21c:	00bfff04 	movi	r2,-4
 201d220:	1884703a 	and	r2,r3,r2
 201d224:	1007883a 	mov	r3,r2
 201d228:	e0bffe17 	ldw	r2,-8(fp)
 201d22c:	10c00885 	stb	r3,34(r2)
      }

      next = pcb->next;
 201d230:	e0bffe17 	ldw	r2,-8(fp)
 201d234:	10800317 	ldw	r2,12(r2)
 201d238:	e0bfff15 	stw	r2,-4(fp)

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 201d23c:	e0bffe17 	ldw	r2,-8(fp)
 201d240:	10801f17 	ldw	r2,124(r2)
 201d244:	10000726 	beq	r2,zero,201d264 <tcp_fasttmr+0xd0>
        tcp_active_pcbs_changed = 0;
 201d248:	d027f685 	stb	zero,-24614(gp)
        tcp_process_refused_data(pcb);
 201d24c:	e13ffe17 	ldw	r4,-8(fp)
 201d250:	201d28c0 	call	201d28c <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 201d254:	d0a7f683 	ldbu	r2,-24614(gp)
 201d258:	10803fcc 	andi	r2,r2,255
 201d25c:	10000126 	beq	r2,zero,201d264 <tcp_fasttmr+0xd0>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
 201d260:	003fd306 	br	201d1b0 <__alt_mem_mem_0+0xfcffd1b0>
        }
      }
      pcb = next;
 201d264:	e0bfff17 	ldw	r2,-4(fp)
 201d268:	e0bffe15 	stw	r2,-8(fp)
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
 201d26c:	e0bffe17 	ldw	r2,-8(fp)
 201d270:	103fd21e 	bne	r2,zero,201d1bc <__alt_mem_mem_0+0xfcffd1bc>
        }
      }
      pcb = next;
    }
  }
}
 201d274:	0001883a 	nop
 201d278:	e037883a 	mov	sp,fp
 201d27c:	dfc00117 	ldw	ra,4(sp)
 201d280:	df000017 	ldw	fp,0(sp)
 201d284:	dec00204 	addi	sp,sp,8
 201d288:	f800283a 	ret

0201d28c <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 201d28c:	defffb04 	addi	sp,sp,-20
 201d290:	dfc00415 	stw	ra,16(sp)
 201d294:	df000315 	stw	fp,12(sp)
 201d298:	df000304 	addi	fp,sp,12
 201d29c:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 201d2a0:	e0bfff17 	ldw	r2,-4(fp)
 201d2a4:	10801f17 	ldw	r2,124(r2)
 201d2a8:	10800343 	ldbu	r2,13(r2)
 201d2ac:	e0bffd45 	stb	r2,-11(fp)
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
 201d2b0:	e0bfff17 	ldw	r2,-4(fp)
 201d2b4:	10801f17 	ldw	r2,124(r2)
 201d2b8:	e0bffe15 	stw	r2,-8(fp)
  pcb->refused_data = NULL;
 201d2bc:	e0bfff17 	ldw	r2,-4(fp)
 201d2c0:	10001f15 	stw	zero,124(r2)
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 201d2c4:	e0bfff17 	ldw	r2,-4(fp)
 201d2c8:	10802117 	ldw	r2,132(r2)
 201d2cc:	10000b26 	beq	r2,zero,201d2fc <tcp_process_refused_data+0x70>
 201d2d0:	e0bfff17 	ldw	r2,-4(fp)
 201d2d4:	10802117 	ldw	r2,132(r2)
 201d2d8:	e0ffff17 	ldw	r3,-4(fp)
 201d2dc:	18c00417 	ldw	r3,16(r3)
 201d2e0:	000f883a 	mov	r7,zero
 201d2e4:	e1bffe17 	ldw	r6,-8(fp)
 201d2e8:	e17fff17 	ldw	r5,-4(fp)
 201d2ec:	1809883a 	mov	r4,r3
 201d2f0:	103ee83a 	callr	r2
 201d2f4:	e0bffd05 	stb	r2,-12(fp)
 201d2f8:	00000606 	br	201d314 <tcp_process_refused_data+0x88>
 201d2fc:	000f883a 	mov	r7,zero
 201d300:	e1bffe17 	ldw	r6,-8(fp)
 201d304:	e17fff17 	ldw	r5,-4(fp)
 201d308:	0009883a 	mov	r4,zero
 201d30c:	201d52c0 	call	201d52c <tcp_recv_null>
 201d310:	e0bffd05 	stb	r2,-12(fp)
  if (err == ERR_OK) {
 201d314:	e0bffd07 	ldb	r2,-12(fp)
 201d318:	1000221e 	bne	r2,zero,201d3a4 <tcp_process_refused_data+0x118>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 201d31c:	e0bffd43 	ldbu	r2,-11(fp)
 201d320:	1080080c 	andi	r2,r2,32
 201d324:	10002726 	beq	r2,zero,201d3c4 <tcp_process_refused_data+0x138>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 201d328:	e0bfff17 	ldw	r2,-4(fp)
 201d32c:	10800c0b 	ldhu	r2,48(r2)
 201d330:	10bfffcc 	andi	r2,r2,65535
 201d334:	10880020 	cmpeqi	r2,r2,8192
 201d338:	1000061e 	bne	r2,zero,201d354 <tcp_process_refused_data+0xc8>
        pcb->rcv_wnd++;
 201d33c:	e0bfff17 	ldw	r2,-4(fp)
 201d340:	10800c0b 	ldhu	r2,48(r2)
 201d344:	10800044 	addi	r2,r2,1
 201d348:	1007883a 	mov	r3,r2
 201d34c:	e0bfff17 	ldw	r2,-4(fp)
 201d350:	10c00c0d 	sth	r3,48(r2)
      }
      TCP_EVENT_CLOSED(pcb, err);
 201d354:	e0bfff17 	ldw	r2,-4(fp)
 201d358:	10802117 	ldw	r2,132(r2)
 201d35c:	10000b26 	beq	r2,zero,201d38c <tcp_process_refused_data+0x100>
 201d360:	e0bfff17 	ldw	r2,-4(fp)
 201d364:	10802117 	ldw	r2,132(r2)
 201d368:	e0ffff17 	ldw	r3,-4(fp)
 201d36c:	18c00417 	ldw	r3,16(r3)
 201d370:	000f883a 	mov	r7,zero
 201d374:	000d883a 	mov	r6,zero
 201d378:	e17fff17 	ldw	r5,-4(fp)
 201d37c:	1809883a 	mov	r4,r3
 201d380:	103ee83a 	callr	r2
 201d384:	e0bffd05 	stb	r2,-12(fp)
 201d388:	00000106 	br	201d390 <tcp_process_refused_data+0x104>
 201d38c:	e03ffd05 	stb	zero,-12(fp)
      if (err == ERR_ABRT) {
 201d390:	e0bffd07 	ldb	r2,-12(fp)
 201d394:	10bffd98 	cmpnei	r2,r2,-10
 201d398:	10000a1e 	bne	r2,zero,201d3c4 <tcp_process_refused_data+0x138>
        return ERR_ABRT;
 201d39c:	00bffd84 	movi	r2,-10
 201d3a0:	00000906 	br	201d3c8 <tcp_process_refused_data+0x13c>
      }
    }
  } else if (err == ERR_ABRT) {
 201d3a4:	e0bffd07 	ldb	r2,-12(fp)
 201d3a8:	10bffd98 	cmpnei	r2,r2,-10
 201d3ac:	1000021e 	bne	r2,zero,201d3b8 <tcp_process_refused_data+0x12c>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
 201d3b0:	00bffd84 	movi	r2,-10
 201d3b4:	00000406 	br	201d3c8 <tcp_process_refused_data+0x13c>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
 201d3b8:	e0bfff17 	ldw	r2,-4(fp)
 201d3bc:	e0fffe17 	ldw	r3,-8(fp)
 201d3c0:	10c01f15 	stw	r3,124(r2)
  }
  return ERR_OK;
 201d3c4:	0005883a 	mov	r2,zero
}
 201d3c8:	e037883a 	mov	sp,fp
 201d3cc:	dfc00117 	ldw	ra,4(sp)
 201d3d0:	df000017 	ldw	fp,0(sp)
 201d3d4:	dec00204 	addi	sp,sp,8
 201d3d8:	f800283a 	ret

0201d3dc <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 201d3dc:	defffc04 	addi	sp,sp,-16
 201d3e0:	dfc00315 	stw	ra,12(sp)
 201d3e4:	df000215 	stw	fp,8(sp)
 201d3e8:	df000204 	addi	fp,sp,8
 201d3ec:	e13fff15 	stw	r4,-4(fp)
  while (seg != NULL) {
 201d3f0:	00000706 	br	201d410 <tcp_segs_free+0x34>
    struct tcp_seg *next = seg->next;
 201d3f4:	e0bfff17 	ldw	r2,-4(fp)
 201d3f8:	10800017 	ldw	r2,0(r2)
 201d3fc:	e0bffe15 	stw	r2,-8(fp)
    tcp_seg_free(seg);
 201d400:	e13fff17 	ldw	r4,-4(fp)
 201d404:	201d4300 	call	201d430 <tcp_seg_free>
    seg = next;
 201d408:	e0bffe17 	ldw	r2,-8(fp)
 201d40c:	e0bfff15 	stw	r2,-4(fp)
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 201d410:	e0bfff17 	ldw	r2,-4(fp)
 201d414:	103ff71e 	bne	r2,zero,201d3f4 <__alt_mem_mem_0+0xfcffd3f4>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
 201d418:	0001883a 	nop
 201d41c:	e037883a 	mov	sp,fp
 201d420:	dfc00117 	ldw	ra,4(sp)
 201d424:	df000017 	ldw	fp,0(sp)
 201d428:	dec00204 	addi	sp,sp,8
 201d42c:	f800283a 	ret

0201d430 <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 201d430:	defffd04 	addi	sp,sp,-12
 201d434:	dfc00215 	stw	ra,8(sp)
 201d438:	df000115 	stw	fp,4(sp)
 201d43c:	df000104 	addi	fp,sp,4
 201d440:	e13fff15 	stw	r4,-4(fp)
  if (seg != NULL) {
 201d444:	e0bfff17 	ldw	r2,-4(fp)
 201d448:	10000a26 	beq	r2,zero,201d474 <tcp_seg_free+0x44>
    if (seg->p != NULL) {
 201d44c:	e0bfff17 	ldw	r2,-4(fp)
 201d450:	10800117 	ldw	r2,4(r2)
 201d454:	10000426 	beq	r2,zero,201d468 <tcp_seg_free+0x38>
      pbuf_free(seg->p);
 201d458:	e0bfff17 	ldw	r2,-4(fp)
 201d45c:	10800117 	ldw	r2,4(r2)
 201d460:	1009883a 	mov	r4,r2
 201d464:	201ab680 	call	201ab68 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 201d468:	e17fff17 	ldw	r5,-4(fp)
 201d46c:	01000104 	movi	r4,4
 201d470:	20346000 	call	2034600 <memp_free>
  }
}
 201d474:	0001883a 	nop
 201d478:	e037883a 	mov	sp,fp
 201d47c:	dfc00117 	ldw	ra,4(sp)
 201d480:	df000017 	ldw	fp,0(sp)
 201d484:	dec00204 	addi	sp,sp,8
 201d488:	f800283a 	ret

0201d48c <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
 201d48c:	defffd04 	addi	sp,sp,-12
 201d490:	df000215 	stw	fp,8(sp)
 201d494:	df000204 	addi	fp,sp,8
 201d498:	e13ffe15 	stw	r4,-8(fp)
 201d49c:	2805883a 	mov	r2,r5
 201d4a0:	e0bfff05 	stb	r2,-4(fp)
  pcb->prio = prio;
 201d4a4:	e0bffe17 	ldw	r2,-8(fp)
 201d4a8:	e0ffff03 	ldbu	r3,-4(fp)
 201d4ac:	10c00705 	stb	r3,28(r2)
}
 201d4b0:	0001883a 	nop
 201d4b4:	e037883a 	mov	sp,fp
 201d4b8:	df000017 	ldw	fp,0(sp)
 201d4bc:	dec00104 	addi	sp,sp,4
 201d4c0:	f800283a 	ret

0201d4c4 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
 201d4c4:	defffc04 	addi	sp,sp,-16
 201d4c8:	dfc00315 	stw	ra,12(sp)
 201d4cc:	df000215 	stw	fp,8(sp)
 201d4d0:	df000204 	addi	fp,sp,8
 201d4d4:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
 201d4d8:	01000104 	movi	r4,4
 201d4dc:	20344340 	call	2034434 <memp_malloc>
 201d4e0:	e0bffe15 	stw	r2,-8(fp)
  if (cseg == NULL) {
 201d4e4:	e0bffe17 	ldw	r2,-8(fp)
 201d4e8:	1000021e 	bne	r2,zero,201d4f4 <tcp_seg_copy+0x30>
    return NULL;
 201d4ec:	0005883a 	mov	r2,zero
 201d4f0:	00000906 	br	201d518 <tcp_seg_copy+0x54>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
 201d4f4:	01800504 	movi	r6,20
 201d4f8:	e17fff17 	ldw	r5,-4(fp)
 201d4fc:	e13ffe17 	ldw	r4,-8(fp)
 201d500:	20060240 	call	2006024 <memcpy>
  pbuf_ref(cseg->p);
 201d504:	e0bffe17 	ldw	r2,-8(fp)
 201d508:	10800117 	ldw	r2,4(r2)
 201d50c:	1009883a 	mov	r4,r2
 201d510:	201acf80 	call	201acf8 <pbuf_ref>
  return cseg;
 201d514:	e0bffe17 	ldw	r2,-8(fp)
}
 201d518:	e037883a 	mov	sp,fp
 201d51c:	dfc00117 	ldw	ra,4(sp)
 201d520:	df000017 	ldw	fp,0(sp)
 201d524:	dec00204 	addi	sp,sp,8
 201d528:	f800283a 	ret

0201d52c <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 201d52c:	defffa04 	addi	sp,sp,-24
 201d530:	dfc00515 	stw	ra,20(sp)
 201d534:	df000415 	stw	fp,16(sp)
 201d538:	df000404 	addi	fp,sp,16
 201d53c:	e13ffc15 	stw	r4,-16(fp)
 201d540:	e17ffd15 	stw	r5,-12(fp)
 201d544:	e1bffe15 	stw	r6,-8(fp)
 201d548:	3805883a 	mov	r2,r7
 201d54c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 201d550:	e0bffe17 	ldw	r2,-8(fp)
 201d554:	10000926 	beq	r2,zero,201d57c <tcp_recv_null+0x50>
    tcp_recved(pcb, p->tot_len);
 201d558:	e0bffe17 	ldw	r2,-8(fp)
 201d55c:	1080020b 	ldhu	r2,8(r2)
 201d560:	10bfffcc 	andi	r2,r2,65535
 201d564:	100b883a 	mov	r5,r2
 201d568:	e13ffd17 	ldw	r4,-12(fp)
 201d56c:	201c5440 	call	201c544 <tcp_recved>
    pbuf_free(p);
 201d570:	e13ffe17 	ldw	r4,-8(fp)
 201d574:	201ab680 	call	201ab68 <pbuf_free>
 201d578:	00000506 	br	201d590 <tcp_recv_null+0x64>
  } else if (err == ERR_OK) {
 201d57c:	e0bfff07 	ldb	r2,-4(fp)
 201d580:	1000031e 	bne	r2,zero,201d590 <tcp_recv_null+0x64>
    return tcp_close(pcb);
 201d584:	e13ffd17 	ldw	r4,-12(fp)
 201d588:	201bd080 	call	201bd08 <tcp_close>
 201d58c:	00000106 	br	201d594 <tcp_recv_null+0x68>
  }
  return ERR_OK;
 201d590:	0005883a 	mov	r2,zero
}
 201d594:	e037883a 	mov	sp,fp
 201d598:	dfc00117 	ldw	ra,4(sp)
 201d59c:	df000017 	ldw	fp,0(sp)
 201d5a0:	dec00204 	addi	sp,sp,8
 201d5a4:	f800283a 	ret

0201d5a8 <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
 201d5a8:	defff904 	addi	sp,sp,-28
 201d5ac:	dfc00615 	stw	ra,24(sp)
 201d5b0:	df000515 	stw	fp,20(sp)
 201d5b4:	df000504 	addi	fp,sp,20
 201d5b8:	2005883a 	mov	r2,r4
 201d5bc:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
 201d5c0:	00801fc4 	movi	r2,127
 201d5c4:	e0bffe05 	stb	r2,-8(fp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
 201d5c8:	e03ffd15 	stw	zero,-12(fp)
  inactive = NULL;
 201d5cc:	e03ffc15 	stw	zero,-16(fp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 201d5d0:	d0a7f717 	ldw	r2,-24612(gp)
 201d5d4:	e0bffb15 	stw	r2,-20(fp)
 201d5d8:	00001d06 	br	201d650 <tcp_kill_prio+0xa8>
    if (pcb->prio <= prio &&
 201d5dc:	e0bffb17 	ldw	r2,-20(fp)
 201d5e0:	10800703 	ldbu	r2,28(r2)
 201d5e4:	10803fcc 	andi	r2,r2,255
 201d5e8:	e0ffff03 	ldbu	r3,-4(fp)
 201d5ec:	18801536 	bltu	r3,r2,201d644 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
 201d5f0:	e0bffb17 	ldw	r2,-20(fp)
 201d5f4:	10800703 	ldbu	r2,28(r2)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 201d5f8:	10803fcc 	andi	r2,r2,255
 201d5fc:	e0fffe03 	ldbu	r3,-8(fp)
 201d600:	18801036 	bltu	r3,r2,201d644 <tcp_kill_prio+0x9c>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 201d604:	d0e7f817 	ldw	r3,-24608(gp)
 201d608:	e0bffb17 	ldw	r2,-20(fp)
 201d60c:	10800a17 	ldw	r2,40(r2)
 201d610:	1887c83a 	sub	r3,r3,r2
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 201d614:	e0bffd17 	ldw	r2,-12(fp)
 201d618:	18800a36 	bltu	r3,r2,201d644 <tcp_kill_prio+0x9c>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
 201d61c:	d0e7f817 	ldw	r3,-24608(gp)
 201d620:	e0bffb17 	ldw	r2,-20(fp)
 201d624:	10800a17 	ldw	r2,40(r2)
 201d628:	1885c83a 	sub	r2,r3,r2
 201d62c:	e0bffd15 	stw	r2,-12(fp)
      inactive = pcb;
 201d630:	e0bffb17 	ldw	r2,-20(fp)
 201d634:	e0bffc15 	stw	r2,-16(fp)
      mprio = pcb->prio;
 201d638:	e0bffb17 	ldw	r2,-20(fp)
 201d63c:	10800703 	ldbu	r2,28(r2)
 201d640:	e0bffe05 	stb	r2,-8(fp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 201d644:	e0bffb17 	ldw	r2,-20(fp)
 201d648:	10800317 	ldw	r2,12(r2)
 201d64c:	e0bffb15 	stw	r2,-20(fp)
 201d650:	e0bffb17 	ldw	r2,-20(fp)
 201d654:	103fe11e 	bne	r2,zero,201d5dc <__alt_mem_mem_0+0xfcffd5dc>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 201d658:	e0bffc17 	ldw	r2,-16(fp)
 201d65c:	10000226 	beq	r2,zero,201d668 <tcp_kill_prio+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 201d660:	e13ffc17 	ldw	r4,-16(fp)
 201d664:	201bfb40 	call	201bfb4 <tcp_abort>
  }
}
 201d668:	0001883a 	nop
 201d66c:	e037883a 	mov	sp,fp
 201d670:	dfc00117 	ldw	ra,4(sp)
 201d674:	df000017 	ldw	fp,0(sp)
 201d678:	dec00204 	addi	sp,sp,8
 201d67c:	f800283a 	ret

0201d680 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
 201d680:	defffb04 	addi	sp,sp,-20
 201d684:	dfc00415 	stw	ra,16(sp)
 201d688:	df000315 	stw	fp,12(sp)
 201d68c:	df000304 	addi	fp,sp,12
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
 201d690:	e03fff15 	stw	zero,-4(fp)
  inactive = NULL;
 201d694:	e03ffe15 	stw	zero,-8(fp)
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 201d698:	d0a7fc17 	ldw	r2,-24592(gp)
 201d69c:	e0bffd15 	stw	r2,-12(fp)
 201d6a0:	00001006 	br	201d6e4 <tcp_kill_timewait+0x64>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 201d6a4:	d0e7f817 	ldw	r3,-24608(gp)
 201d6a8:	e0bffd17 	ldw	r2,-12(fp)
 201d6ac:	10800a17 	ldw	r2,40(r2)
 201d6b0:	1887c83a 	sub	r3,r3,r2
 201d6b4:	e0bfff17 	ldw	r2,-4(fp)
 201d6b8:	18800736 	bltu	r3,r2,201d6d8 <tcp_kill_timewait+0x58>
      inactivity = tcp_ticks - pcb->tmr;
 201d6bc:	d0e7f817 	ldw	r3,-24608(gp)
 201d6c0:	e0bffd17 	ldw	r2,-12(fp)
 201d6c4:	10800a17 	ldw	r2,40(r2)
 201d6c8:	1885c83a 	sub	r2,r3,r2
 201d6cc:	e0bfff15 	stw	r2,-4(fp)
      inactive = pcb;
 201d6d0:	e0bffd17 	ldw	r2,-12(fp)
 201d6d4:	e0bffe15 	stw	r2,-8(fp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 201d6d8:	e0bffd17 	ldw	r2,-12(fp)
 201d6dc:	10800317 	ldw	r2,12(r2)
 201d6e0:	e0bffd15 	stw	r2,-12(fp)
 201d6e4:	e0bffd17 	ldw	r2,-12(fp)
 201d6e8:	103fee1e 	bne	r2,zero,201d6a4 <__alt_mem_mem_0+0xfcffd6a4>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
 201d6ec:	e0bffe17 	ldw	r2,-8(fp)
 201d6f0:	10000226 	beq	r2,zero,201d6fc <tcp_kill_timewait+0x7c>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
 201d6f4:	e13ffe17 	ldw	r4,-8(fp)
 201d6f8:	201bfb40 	call	201bfb4 <tcp_abort>
  }
}
 201d6fc:	0001883a 	nop
 201d700:	e037883a 	mov	sp,fp
 201d704:	dfc00117 	ldw	ra,4(sp)
 201d708:	df000017 	ldw	fp,0(sp)
 201d70c:	dec00204 	addi	sp,sp,8
 201d710:	f800283a 	ret

0201d714 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 201d714:	defffb04 	addi	sp,sp,-20
 201d718:	dfc00415 	stw	ra,16(sp)
 201d71c:	df000315 	stw	fp,12(sp)
 201d720:	df000304 	addi	fp,sp,12
 201d724:	2005883a 	mov	r2,r4
 201d728:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 201d72c:	01000084 	movi	r4,2
 201d730:	20344340 	call	2034434 <memp_malloc>
 201d734:	e0bffd15 	stw	r2,-12(fp)
  if (pcb == NULL) {
 201d738:	e0bffd17 	ldw	r2,-12(fp)
 201d73c:	10001e1e 	bne	r2,zero,201d7b8 <tcp_alloc+0xa4>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
 201d740:	201d6800 	call	201d680 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 201d744:	01000084 	movi	r4,2
 201d748:	20344340 	call	2034434 <memp_malloc>
 201d74c:	e0bffd15 	stw	r2,-12(fp)
    if (pcb == NULL) {
 201d750:	e0bffd17 	ldw	r2,-12(fp)
 201d754:	10000f1e 	bne	r2,zero,201d794 <tcp_alloc+0x80>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
 201d758:	e0bfff03 	ldbu	r2,-4(fp)
 201d75c:	1009883a 	mov	r4,r2
 201d760:	201d5a80 	call	201d5a8 <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 201d764:	01000084 	movi	r4,2
 201d768:	20344340 	call	2034434 <memp_malloc>
 201d76c:	e0bffd15 	stw	r2,-12(fp)
      if (pcb != NULL) {
 201d770:	e0bffd17 	ldw	r2,-12(fp)
 201d774:	10000726 	beq	r2,zero,201d794 <tcp_alloc+0x80>
        /* adjust err stats: memp_malloc failed twice before */
        MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 201d778:	008085f4 	movhi	r2,535
 201d77c:	10a8bc04 	addi	r2,r2,-23824
 201d780:	10806217 	ldw	r2,392(r2)
 201d784:	10ffffc4 	addi	r3,r2,-1
 201d788:	008085f4 	movhi	r2,535
 201d78c:	10a8bc04 	addi	r2,r2,-23824
 201d790:	10c06215 	stw	r3,392(r2)
      }
    }
    if (pcb != NULL) {
 201d794:	e0bffd17 	ldw	r2,-12(fp)
 201d798:	10000726 	beq	r2,zero,201d7b8 <tcp_alloc+0xa4>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
 201d79c:	008085f4 	movhi	r2,535
 201d7a0:	10a8bc04 	addi	r2,r2,-23824
 201d7a4:	10806217 	ldw	r2,392(r2)
 201d7a8:	10ffffc4 	addi	r3,r2,-1
 201d7ac:	008085f4 	movhi	r2,535
 201d7b0:	10a8bc04 	addi	r2,r2,-23824
 201d7b4:	10c06215 	stw	r3,392(r2)
    }
  }
  if (pcb != NULL) {
 201d7b8:	e0bffd17 	ldw	r2,-12(fp)
 201d7bc:	10004f26 	beq	r2,zero,201d8fc <tcp_alloc+0x1e8>
    memset(pcb, 0, sizeof(struct tcp_pcb));
 201d7c0:	01802904 	movi	r6,164
 201d7c4:	000b883a 	mov	r5,zero
 201d7c8:	e13ffd17 	ldw	r4,-12(fp)
 201d7cc:	200616c0 	call	200616c <memset>
    pcb->prio = prio;
 201d7d0:	e0bffd17 	ldw	r2,-12(fp)
 201d7d4:	e0ffff03 	ldbu	r3,-4(fp)
 201d7d8:	10c00705 	stb	r3,28(r2)
    pcb->snd_buf = TCP_SND_BUF;
 201d7dc:	e0bffd17 	ldw	r2,-12(fp)
 201d7e0:	00c2da04 	movi	r3,2920
 201d7e4:	10c01a8d 	sth	r3,106(r2)
    pcb->snd_queuelen = 0;
 201d7e8:	e0bffd17 	ldw	r2,-12(fp)
 201d7ec:	10001b0d 	sth	zero,108(r2)
    pcb->rcv_wnd = TCP_WND;
 201d7f0:	e0bffd17 	ldw	r2,-12(fp)
 201d7f4:	00c80004 	movi	r3,8192
 201d7f8:	10c00c0d 	sth	r3,48(r2)
    pcb->rcv_ann_wnd = TCP_WND;
 201d7fc:	e0bffd17 	ldw	r2,-12(fp)
 201d800:	00c80004 	movi	r3,8192
 201d804:	10c00c8d 	sth	r3,50(r2)
    pcb->tos = 0;
 201d808:	e0bffd17 	ldw	r2,-12(fp)
 201d80c:	10000245 	stb	zero,9(r2)
    pcb->ttl = TCP_TTL;
 201d810:	e0bffd17 	ldw	r2,-12(fp)
 201d814:	00c01004 	movi	r3,64
 201d818:	10c00285 	stb	r3,10(r2)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 201d81c:	e0bffd17 	ldw	r2,-12(fp)
 201d820:	00c08604 	movi	r3,536
 201d824:	10c00e8d 	sth	r3,58(r2)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 201d828:	e0bffd17 	ldw	r2,-12(fp)
 201d82c:	00c00184 	movi	r3,6
 201d830:	10c0120d 	sth	r3,72(r2)
    pcb->sa = 0;
 201d834:	e0bffd17 	ldw	r2,-12(fp)
 201d838:	1000110d 	sth	zero,68(r2)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 201d83c:	e0bffd17 	ldw	r2,-12(fp)
 201d840:	00c00184 	movi	r3,6
 201d844:	10c0118d 	sth	r3,70(r2)
    pcb->rtime = -1;
 201d848:	e0bffd17 	ldw	r2,-12(fp)
 201d84c:	00ffffc4 	movi	r3,-1
 201d850:	10c00e0d 	sth	r3,56(r2)
    pcb->cwnd = 1;
 201d854:	e0bffd17 	ldw	r2,-12(fp)
 201d858:	00c00044 	movi	r3,1
 201d85c:	10c0140d 	sth	r3,80(r2)
    iss = tcp_next_iss();
 201d860:	201dd080 	call	201dd08 <tcp_next_iss>
 201d864:	e0bffe15 	stw	r2,-8(fp)
    pcb->snd_wl2 = iss;
 201d868:	e0bffd17 	ldw	r2,-12(fp)
 201d86c:	e0fffe17 	ldw	r3,-8(fp)
 201d870:	10c01715 	stw	r3,92(r2)
    pcb->snd_nxt = iss;
 201d874:	e0bffd17 	ldw	r2,-12(fp)
 201d878:	e0fffe17 	ldw	r3,-8(fp)
 201d87c:	10c01515 	stw	r3,84(r2)
    pcb->lastack = iss;
 201d880:	e0bffd17 	ldw	r2,-12(fp)
 201d884:	e0fffe17 	ldw	r3,-8(fp)
 201d888:	10c01315 	stw	r3,76(r2)
    pcb->snd_lbb = iss;   
 201d88c:	e0bffd17 	ldw	r2,-12(fp)
 201d890:	e0fffe17 	ldw	r3,-8(fp)
 201d894:	10c01815 	stw	r3,96(r2)
    pcb->tmr = tcp_ticks;
 201d898:	d0e7f817 	ldw	r3,-24608(gp)
 201d89c:	e0bffd17 	ldw	r2,-12(fp)
 201d8a0:	10c00a15 	stw	r3,40(r2)
    pcb->last_timer = tcp_timer_ctr;
 201d8a4:	d0e7f643 	ldbu	r3,-24615(gp)
 201d8a8:	e0bffd17 	ldw	r2,-12(fp)
 201d8ac:	10c00945 	stb	r3,37(r2)

    pcb->polltmr = 0;
 201d8b0:	e0bffd17 	ldw	r2,-12(fp)
 201d8b4:	100008c5 	stb	zero,35(r2)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 201d8b8:	e0fffd17 	ldw	r3,-12(fp)
 201d8bc:	008080b4 	movhi	r2,514
 201d8c0:	10b54b04 	addi	r2,r2,-10964
 201d8c4:	18802115 	stw	r2,132(r3)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 201d8c8:	e0fffd17 	ldw	r3,-12(fp)
 201d8cc:	00801bb4 	movhi	r2,110
 201d8d0:	10b74004 	addi	r2,r2,-8960
 201d8d4:	18802515 	stw	r2,148(r3)
    
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
 201d8d8:	e0fffd17 	ldw	r3,-12(fp)
 201d8dc:	00800074 	movhi	r2,1
 201d8e0:	10893e04 	addi	r2,r2,9464
 201d8e4:	18802615 	stw	r2,152(r3)
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
 201d8e8:	e0bffd17 	ldw	r2,-12(fp)
 201d8ec:	00c00244 	movi	r3,9
 201d8f0:	10c02715 	stw	r3,156(r2)
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 201d8f4:	e0bffd17 	ldw	r2,-12(fp)
 201d8f8:	10002885 	stb	zero,162(r2)
  }
  return pcb;
 201d8fc:	e0bffd17 	ldw	r2,-12(fp)
}
 201d900:	e037883a 	mov	sp,fp
 201d904:	dfc00117 	ldw	ra,4(sp)
 201d908:	df000017 	ldw	fp,0(sp)
 201d90c:	dec00204 	addi	sp,sp,8
 201d910:	f800283a 	ret

0201d914 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
 201d914:	defffe04 	addi	sp,sp,-8
 201d918:	dfc00115 	stw	ra,4(sp)
 201d91c:	df000015 	stw	fp,0(sp)
 201d920:	d839883a 	mov	fp,sp
  return tcp_alloc(TCP_PRIO_NORMAL);
 201d924:	01001004 	movi	r4,64
 201d928:	201d7140 	call	201d714 <tcp_alloc>
}
 201d92c:	e037883a 	mov	sp,fp
 201d930:	dfc00117 	ldw	ra,4(sp)
 201d934:	df000017 	ldw	fp,0(sp)
 201d938:	dec00204 	addi	sp,sp,8
 201d93c:	f800283a 	ret

0201d940 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
 201d940:	defffd04 	addi	sp,sp,-12
 201d944:	df000215 	stw	fp,8(sp)
 201d948:	df000204 	addi	fp,sp,8
 201d94c:	e13ffe15 	stw	r4,-8(fp)
 201d950:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 201d954:	e0bffe17 	ldw	r2,-8(fp)
 201d958:	e0ffff17 	ldw	r3,-4(fp)
 201d95c:	10c00415 	stw	r3,16(r2)
}
 201d960:	0001883a 	nop
 201d964:	e037883a 	mov	sp,fp
 201d968:	df000017 	ldw	fp,0(sp)
 201d96c:	dec00104 	addi	sp,sp,4
 201d970:	f800283a 	ret

0201d974 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 201d974:	defffd04 	addi	sp,sp,-12
 201d978:	df000215 	stw	fp,8(sp)
 201d97c:	df000204 	addi	fp,sp,8
 201d980:	e13ffe15 	stw	r4,-8(fp)
 201d984:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
 201d988:	e0bffe17 	ldw	r2,-8(fp)
 201d98c:	e0ffff17 	ldw	r3,-4(fp)
 201d990:	10c02115 	stw	r3,132(r2)
}
 201d994:	0001883a 	nop
 201d998:	e037883a 	mov	sp,fp
 201d99c:	df000017 	ldw	fp,0(sp)
 201d9a0:	dec00104 	addi	sp,sp,4
 201d9a4:	f800283a 	ret

0201d9a8 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 201d9a8:	defffd04 	addi	sp,sp,-12
 201d9ac:	df000215 	stw	fp,8(sp)
 201d9b0:	df000204 	addi	fp,sp,8
 201d9b4:	e13ffe15 	stw	r4,-8(fp)
 201d9b8:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
 201d9bc:	e0bffe17 	ldw	r2,-8(fp)
 201d9c0:	e0ffff17 	ldw	r3,-4(fp)
 201d9c4:	10c02015 	stw	r3,128(r2)
}
 201d9c8:	0001883a 	nop
 201d9cc:	e037883a 	mov	sp,fp
 201d9d0:	df000017 	ldw	fp,0(sp)
 201d9d4:	dec00104 	addi	sp,sp,4
 201d9d8:	f800283a 	ret

0201d9dc <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 201d9dc:	defffd04 	addi	sp,sp,-12
 201d9e0:	df000215 	stw	fp,8(sp)
 201d9e4:	df000204 	addi	fp,sp,8
 201d9e8:	e13ffe15 	stw	r4,-8(fp)
 201d9ec:	e17fff15 	stw	r5,-4(fp)
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
 201d9f0:	e0bffe17 	ldw	r2,-8(fp)
 201d9f4:	e0ffff17 	ldw	r3,-4(fp)
 201d9f8:	10c02415 	stw	r3,144(r2)
}
 201d9fc:	0001883a 	nop
 201da00:	e037883a 	mov	sp,fp
 201da04:	df000017 	ldw	fp,0(sp)
 201da08:	dec00104 	addi	sp,sp,4
 201da0c:	f800283a 	ret

0201da10 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
 201da10:	defffd04 	addi	sp,sp,-12
 201da14:	df000215 	stw	fp,8(sp)
 201da18:	df000204 	addi	fp,sp,8
 201da1c:	e13ffe15 	stw	r4,-8(fp)
 201da20:	e17fff15 	stw	r5,-4(fp)
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 201da24:	e0bffe17 	ldw	r2,-8(fp)
 201da28:	e0ffff17 	ldw	r3,-4(fp)
 201da2c:	10c00515 	stw	r3,20(r2)
}
 201da30:	0001883a 	nop
 201da34:	e037883a 	mov	sp,fp
 201da38:	df000017 	ldw	fp,0(sp)
 201da3c:	dec00104 	addi	sp,sp,4
 201da40:	f800283a 	ret

0201da44 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 201da44:	defffc04 	addi	sp,sp,-16
 201da48:	df000315 	stw	fp,12(sp)
 201da4c:	df000304 	addi	fp,sp,12
 201da50:	e13ffd15 	stw	r4,-12(fp)
 201da54:	e17ffe15 	stw	r5,-8(fp)
 201da58:	3005883a 	mov	r2,r6
 201da5c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 201da60:	e0bffd17 	ldw	r2,-12(fp)
 201da64:	e0fffe17 	ldw	r3,-8(fp)
 201da68:	10c02315 	stw	r3,140(r2)
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 201da6c:	e0bffd17 	ldw	r2,-12(fp)
 201da70:	e0ffff03 	ldbu	r3,-4(fp)
 201da74:	10c00905 	stb	r3,36(r2)
}
 201da78:	0001883a 	nop
 201da7c:	e037883a 	mov	sp,fp
 201da80:	df000017 	ldw	fp,0(sp)
 201da84:	dec00104 	addi	sp,sp,4
 201da88:	f800283a 	ret

0201da8c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
 201da8c:	defffc04 	addi	sp,sp,-16
 201da90:	dfc00315 	stw	ra,12(sp)
 201da94:	df000215 	stw	fp,8(sp)
 201da98:	df000204 	addi	fp,sp,8
 201da9c:	e13fff15 	stw	r4,-4(fp)
  if (pcb->state != CLOSED &&
 201daa0:	e0bfff17 	ldw	r2,-4(fp)
 201daa4:	10800617 	ldw	r2,24(r2)
 201daa8:	10004e26 	beq	r2,zero,201dbe4 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
 201daac:	e0bfff17 	ldw	r2,-4(fp)
 201dab0:	10800617 	ldw	r2,24(r2)
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 201dab4:	108002a0 	cmpeqi	r2,r2,10
 201dab8:	10004a1e 	bne	r2,zero,201dbe4 <tcp_pcb_purge+0x158>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
 201dabc:	e0bfff17 	ldw	r2,-4(fp)
 201dac0:	10800617 	ldw	r2,24(r2)
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
 201dac4:	10800060 	cmpeqi	r2,r2,1
 201dac8:	1000461e 	bne	r2,zero,201dbe4 <tcp_pcb_purge+0x158>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

#if TCP_LISTEN_BACKLOG
    if (pcb->state == SYN_RCVD) {
 201dacc:	e0bfff17 	ldw	r2,-4(fp)
 201dad0:	10800617 	ldw	r2,24(r2)
 201dad4:	108000d8 	cmpnei	r2,r2,3
 201dad8:	1000201e 	bne	r2,zero,201db5c <tcp_pcb_purge+0xd0>
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201dadc:	d0a7f917 	ldw	r2,-24604(gp)
 201dae0:	e0bffe15 	stw	r2,-8(fp)
 201dae4:	00001b06 	br	201db54 <tcp_pcb_purge+0xc8>
        if ((lpcb->local_port == pcb->local_port) &&
 201dae8:	e0bffe17 	ldw	r2,-8(fp)
 201daec:	10c0078b 	ldhu	r3,30(r2)
 201daf0:	e0bfff17 	ldw	r2,-4(fp)
 201daf4:	1080078b 	ldhu	r2,30(r2)
 201daf8:	18ffffcc 	andi	r3,r3,65535
 201dafc:	10bfffcc 	andi	r2,r2,65535
 201db00:	1880111e 	bne	r3,r2,201db48 <tcp_pcb_purge+0xbc>
            (ip_addr_isany(&lpcb->local_ip) ||
 201db04:	e0bffe17 	ldw	r2,-8(fp)
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
 201db08:	10000826 	beq	r2,zero,201db2c <tcp_pcb_purge+0xa0>
            (ip_addr_isany(&lpcb->local_ip) ||
 201db0c:	e0bffe17 	ldw	r2,-8(fp)
 201db10:	10800017 	ldw	r2,0(r2)
 201db14:	10000526 	beq	r2,zero,201db2c <tcp_pcb_purge+0xa0>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
 201db18:	e0bfff17 	ldw	r2,-4(fp)
 201db1c:	10c00017 	ldw	r3,0(r2)
 201db20:	e0bffe17 	ldw	r2,-8(fp)
 201db24:	10800017 	ldw	r2,0(r2)
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
        if ((lpcb->local_port == pcb->local_port) &&
            (ip_addr_isany(&lpcb->local_ip) ||
 201db28:	1880071e 	bne	r3,r2,201db48 <tcp_pcb_purge+0xbc>
             ip_addr_cmp(&pcb->local_ip, &lpcb->local_ip))) {
            /* port and address of the listen pcb match the timed-out pcb */
            LWIP_ASSERT("tcp_pcb_purge: listen pcb does not have accepts pending",
              lpcb->accepts_pending > 0);
            lpcb->accepts_pending--;
 201db2c:	e0bffe17 	ldw	r2,-8(fp)
 201db30:	10800843 	ldbu	r2,33(r2)
 201db34:	10bfffc4 	addi	r2,r2,-1
 201db38:	1007883a 	mov	r3,r2
 201db3c:	e0bffe17 	ldw	r2,-8(fp)
 201db40:	10c00845 	stb	r3,33(r2)
            break;
 201db44:	00000506 	br	201db5c <tcp_pcb_purge+0xd0>
    if (pcb->state == SYN_RCVD) {
      /* Need to find the corresponding listen_pcb and decrease its accepts_pending */
      struct tcp_pcb_listen *lpcb;
      LWIP_ASSERT("tcp_pcb_purge: pcb->state == SYN_RCVD but tcp_listen_pcbs is NULL",
        tcp_listen_pcbs.listen_pcbs != NULL);
      for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 201db48:	e0bffe17 	ldw	r2,-8(fp)
 201db4c:	10800317 	ldw	r2,12(r2)
 201db50:	e0bffe15 	stw	r2,-8(fp)
 201db54:	e0bffe17 	ldw	r2,-8(fp)
 201db58:	103fe31e 	bne	r2,zero,201dae8 <__alt_mem_mem_0+0xfcffdae8>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 201db5c:	e0bfff17 	ldw	r2,-4(fp)
 201db60:	10801f17 	ldw	r2,124(r2)
 201db64:	10000626 	beq	r2,zero,201db80 <tcp_pcb_purge+0xf4>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 201db68:	e0bfff17 	ldw	r2,-4(fp)
 201db6c:	10801f17 	ldw	r2,124(r2)
 201db70:	1009883a 	mov	r4,r2
 201db74:	201ab680 	call	201ab68 <pbuf_free>
      pcb->refused_data = NULL;
 201db78:	e0bfff17 	ldw	r2,-4(fp)
 201db7c:	10001f15 	stw	zero,124(r2)
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
 201db80:	e0bfff17 	ldw	r2,-4(fp)
 201db84:	10801e17 	ldw	r2,120(r2)
 201db88:	1009883a 	mov	r4,r2
 201db8c:	201d3dc0 	call	201d3dc <tcp_segs_free>
    pcb->ooseq = NULL;
 201db90:	e0bfff17 	ldw	r2,-4(fp)
 201db94:	10001e15 	stw	zero,120(r2)
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 201db98:	e0bfff17 	ldw	r2,-4(fp)
 201db9c:	00ffffc4 	movi	r3,-1
 201dba0:	10c00e0d 	sth	r3,56(r2)

    tcp_segs_free(pcb->unsent);
 201dba4:	e0bfff17 	ldw	r2,-4(fp)
 201dba8:	10801c17 	ldw	r2,112(r2)
 201dbac:	1009883a 	mov	r4,r2
 201dbb0:	201d3dc0 	call	201d3dc <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
 201dbb4:	e0bfff17 	ldw	r2,-4(fp)
 201dbb8:	10801d17 	ldw	r2,116(r2)
 201dbbc:	1009883a 	mov	r4,r2
 201dbc0:	201d3dc0 	call	201d3dc <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
 201dbc4:	e0bfff17 	ldw	r2,-4(fp)
 201dbc8:	10001c15 	stw	zero,112(r2)
 201dbcc:	e0bfff17 	ldw	r2,-4(fp)
 201dbd0:	10c01c17 	ldw	r3,112(r2)
 201dbd4:	e0bfff17 	ldw	r2,-4(fp)
 201dbd8:	10c01d15 	stw	r3,116(r2)
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 201dbdc:	e0bfff17 	ldw	r2,-4(fp)
 201dbe0:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */
  }
}
 201dbe4:	0001883a 	nop
 201dbe8:	e037883a 	mov	sp,fp
 201dbec:	dfc00117 	ldw	ra,4(sp)
 201dbf0:	df000017 	ldw	fp,0(sp)
 201dbf4:	dec00204 	addi	sp,sp,8
 201dbf8:	f800283a 	ret

0201dbfc <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 201dbfc:	defffc04 	addi	sp,sp,-16
 201dc00:	dfc00315 	stw	ra,12(sp)
 201dc04:	df000215 	stw	fp,8(sp)
 201dc08:	df000204 	addi	fp,sp,8
 201dc0c:	e13ffe15 	stw	r4,-8(fp)
 201dc10:	e17fff15 	stw	r5,-4(fp)
  TCP_RMV(pcblist, pcb);
 201dc14:	e0bffe17 	ldw	r2,-8(fp)
 201dc18:	10c00017 	ldw	r3,0(r2)
 201dc1c:	e0bfff17 	ldw	r2,-4(fp)
 201dc20:	1880061e 	bne	r3,r2,201dc3c <tcp_pcb_remove+0x40>
 201dc24:	e0bffe17 	ldw	r2,-8(fp)
 201dc28:	10800017 	ldw	r2,0(r2)
 201dc2c:	10c00317 	ldw	r3,12(r2)
 201dc30:	e0bffe17 	ldw	r2,-8(fp)
 201dc34:	10c00015 	stw	r3,0(r2)
 201dc38:	00001206 	br	201dc84 <tcp_pcb_remove+0x88>
 201dc3c:	e0bffe17 	ldw	r2,-8(fp)
 201dc40:	10800017 	ldw	r2,0(r2)
 201dc44:	d0a7fa15 	stw	r2,-24600(gp)
 201dc48:	00000c06 	br	201dc7c <tcp_pcb_remove+0x80>
 201dc4c:	d0a7fa17 	ldw	r2,-24600(gp)
 201dc50:	10c00317 	ldw	r3,12(r2)
 201dc54:	e0bfff17 	ldw	r2,-4(fp)
 201dc58:	1880051e 	bne	r3,r2,201dc70 <tcp_pcb_remove+0x74>
 201dc5c:	d0a7fa17 	ldw	r2,-24600(gp)
 201dc60:	e0ffff17 	ldw	r3,-4(fp)
 201dc64:	18c00317 	ldw	r3,12(r3)
 201dc68:	10c00315 	stw	r3,12(r2)
 201dc6c:	00000506 	br	201dc84 <tcp_pcb_remove+0x88>
 201dc70:	d0a7fa17 	ldw	r2,-24600(gp)
 201dc74:	10800317 	ldw	r2,12(r2)
 201dc78:	d0a7fa15 	stw	r2,-24600(gp)
 201dc7c:	d0a7fa17 	ldw	r2,-24600(gp)
 201dc80:	103ff21e 	bne	r2,zero,201dc4c <__alt_mem_mem_0+0xfcffdc4c>
 201dc84:	e0bfff17 	ldw	r2,-4(fp)
 201dc88:	10000315 	stw	zero,12(r2)

  tcp_pcb_purge(pcb);
 201dc8c:	e13fff17 	ldw	r4,-4(fp)
 201dc90:	201da8c0 	call	201da8c <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 201dc94:	e0bfff17 	ldw	r2,-4(fp)
 201dc98:	10800617 	ldw	r2,24(r2)
 201dc9c:	108002a0 	cmpeqi	r2,r2,10
 201dca0:	1000111e 	bne	r2,zero,201dce8 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
 201dca4:	e0bfff17 	ldw	r2,-4(fp)
 201dca8:	10800617 	ldw	r2,24(r2)
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 201dcac:	10800060 	cmpeqi	r2,r2,1
 201dcb0:	10000d1e 	bne	r2,zero,201dce8 <tcp_pcb_remove+0xec>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 201dcb4:	e0bfff17 	ldw	r2,-4(fp)
 201dcb8:	10800883 	ldbu	r2,34(r2)
 201dcbc:	10803fcc 	andi	r2,r2,255
 201dcc0:	1080004c 	andi	r2,r2,1

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 201dcc4:	10000826 	beq	r2,zero,201dce8 <tcp_pcb_remove+0xec>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 201dcc8:	e0bfff17 	ldw	r2,-4(fp)
 201dccc:	10800883 	ldbu	r2,34(r2)
 201dcd0:	10800094 	ori	r2,r2,2
 201dcd4:	1007883a 	mov	r3,r2
 201dcd8:	e0bfff17 	ldw	r2,-4(fp)
 201dcdc:	10c00885 	stb	r3,34(r2)
    tcp_output(pcb);
 201dce0:	e13fff17 	ldw	r4,-4(fp)
 201dce4:	201f7800 	call	201f780 <tcp_output>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 201dce8:	e0bfff17 	ldw	r2,-4(fp)
 201dcec:	10000615 	stw	zero,24(r2)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 201dcf0:	0001883a 	nop
 201dcf4:	e037883a 	mov	sp,fp
 201dcf8:	dfc00117 	ldw	ra,4(sp)
 201dcfc:	df000017 	ldw	fp,0(sp)
 201dd00:	dec00204 	addi	sp,sp,8
 201dd04:	f800283a 	ret

0201dd08 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
 201dd08:	deffff04 	addi	sp,sp,-4
 201dd0c:	df000015 	stw	fp,0(sp)
 201dd10:	d839883a 	mov	fp,sp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 201dd14:	d0e01217 	ldw	r3,-32696(gp)
 201dd18:	d0a7f817 	ldw	r2,-24608(gp)
 201dd1c:	1885883a 	add	r2,r3,r2
 201dd20:	d0a01215 	stw	r2,-32696(gp)
  return iss;
 201dd24:	d0a01217 	ldw	r2,-32696(gp)
}
 201dd28:	e037883a 	mov	sp,fp
 201dd2c:	df000017 	ldw	fp,0(sp)
 201dd30:	dec00104 	addi	sp,sp,4
 201dd34:	f800283a 	ret

0201dd38 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *src, ip_addr_t *addr)
{
 201dd38:	defff904 	addi	sp,sp,-28
 201dd3c:	dfc00615 	stw	ra,24(sp)
 201dd40:	df000515 	stw	fp,20(sp)
 201dd44:	df000504 	addi	fp,sp,20
 201dd48:	2005883a 	mov	r2,r4
 201dd4c:	e17ffe15 	stw	r5,-8(fp)
 201dd50:	e1bfff15 	stw	r6,-4(fp)
 201dd54:	e0bffd0d 	sth	r2,-12(fp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(src, addr);
 201dd58:	e17fff17 	ldw	r5,-4(fp)
 201dd5c:	e13ffe17 	ldw	r4,-8(fp)
 201dd60:	2031d1c0 	call	2031d1c <ip_route>
 201dd64:	e0bffb15 	stw	r2,-20(fp)
  if ((outif != NULL) && (outif->mtu != 0)) {
 201dd68:	e0bffb17 	ldw	r2,-20(fp)
 201dd6c:	10000f26 	beq	r2,zero,201ddac <tcp_eff_send_mss+0x74>
 201dd70:	e0bffb17 	ldw	r2,-20(fp)
 201dd74:	10800c0b 	ldhu	r2,48(r2)
 201dd78:	10bfffcc 	andi	r2,r2,65535
 201dd7c:	10000b26 	beq	r2,zero,201ddac <tcp_eff_send_mss+0x74>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
 201dd80:	e0bffb17 	ldw	r2,-20(fp)
 201dd84:	10800c0b 	ldhu	r2,48(r2)
 201dd88:	10bff604 	addi	r2,r2,-40
 201dd8c:	e0bffc0d 	sth	r2,-16(fp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 201dd90:	e17ffd0b 	ldhu	r5,-12(fp)
 201dd94:	e0bffc0b 	ldhu	r2,-16(fp)
 201dd98:	10ffffcc 	andi	r3,r2,65535
 201dd9c:	293fffcc 	andi	r4,r5,65535
 201dda0:	20c0012e 	bgeu	r4,r3,201dda8 <tcp_eff_send_mss+0x70>
 201dda4:	2805883a 	mov	r2,r5
 201dda8:	e0bffd0d 	sth	r2,-12(fp)
  }
  return sendmss;
 201ddac:	e0bffd0b 	ldhu	r2,-12(fp)
}
 201ddb0:	e037883a 	mov	sp,fp
 201ddb4:	dfc00117 	ldw	ra,4(sp)
 201ddb8:	df000017 	ldw	fp,0(sp)
 201ddbc:	dec00204 	addi	sp,sp,8
 201ddc0:	f800283a 	ret

0201ddc4 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
 201ddc4:	defffe04 	addi	sp,sp,-8
 201ddc8:	df000115 	stw	fp,4(sp)
 201ddcc:	df000104 	addi	fp,sp,4
 201ddd0:	e13fff15 	stw	r4,-4(fp)
  return tcp_state_str[s];
 201ddd4:	00808134 	movhi	r2,516
 201ddd8:	1085b504 	addi	r2,r2,5844
 201dddc:	e0ffff17 	ldw	r3,-4(fp)
 201dde0:	18c7883a 	add	r3,r3,r3
 201dde4:	18c7883a 	add	r3,r3,r3
 201dde8:	10c5883a 	add	r2,r2,r3
 201ddec:	10800017 	ldw	r2,0(r2)
}
 201ddf0:	e037883a 	mov	sp,fp
 201ddf4:	df000017 	ldw	fp,0(sp)
 201ddf8:	dec00104 	addi	sp,sp,4
 201ddfc:	f800283a 	ret

0201de00 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
 201de00:	defff804 	addi	sp,sp,-32
 201de04:	dfc00715 	stw	ra,28(sp)
 201de08:	df000615 	stw	fp,24(sp)
 201de0c:	df000604 	addi	fp,sp,24
 201de10:	e13ffc15 	stw	r4,-16(fp)
 201de14:	2807883a 	mov	r3,r5
 201de18:	3005883a 	mov	r2,r6
 201de1c:	e1ffff15 	stw	r7,-4(fp)
 201de20:	e0fffd0d 	sth	r3,-12(fp)
 201de24:	e0bffe0d 	sth	r2,-8(fp)
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 201de28:	e0fffd0b 	ldhu	r3,-12(fp)
 201de2c:	e0bffe0b 	ldhu	r2,-8(fp)
 201de30:	1885883a 	add	r2,r3,r2
 201de34:	10800504 	addi	r2,r2,20
 201de38:	10bfffcc 	andi	r2,r2,65535
 201de3c:	000d883a 	mov	r6,zero
 201de40:	100b883a 	mov	r5,r2
 201de44:	01000044 	movi	r4,1
 201de48:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201de4c:	e0bffa15 	stw	r2,-24(fp)
  if (p != NULL) {
 201de50:	e0bffa17 	ldw	r2,-24(fp)
 201de54:	1000de26 	beq	r2,zero,201e1d0 <tcp_output_alloc_header+0x3d0>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 201de58:	e0bffa17 	ldw	r2,-24(fp)
 201de5c:	10800117 	ldw	r2,4(r2)
 201de60:	e0bffb15 	stw	r2,-20(fp)
    tcphdr->src = htons(pcb->local_port);
 201de64:	e0bffc17 	ldw	r2,-16(fp)
 201de68:	1080078b 	ldhu	r2,30(r2)
 201de6c:	10bfffcc 	andi	r2,r2,65535
 201de70:	1004d23a 	srli	r2,r2,8
 201de74:	1007883a 	mov	r3,r2
 201de78:	e0bffc17 	ldw	r2,-16(fp)
 201de7c:	1080078b 	ldhu	r2,30(r2)
 201de80:	10bfffcc 	andi	r2,r2,65535
 201de84:	1004923a 	slli	r2,r2,8
 201de88:	1884b03a 	or	r2,r3,r2
 201de8c:	100d883a 	mov	r6,r2
 201de90:	e0bffb17 	ldw	r2,-20(fp)
 201de94:	30ffffcc 	andi	r3,r6,65535
 201de98:	19403fcc 	andi	r5,r3,255
 201de9c:	10c00003 	ldbu	r3,0(r2)
 201dea0:	1806703a 	and	r3,r3,zero
 201dea4:	1809883a 	mov	r4,r3
 201dea8:	2807883a 	mov	r3,r5
 201deac:	20c6b03a 	or	r3,r4,r3
 201deb0:	10c00005 	stb	r3,0(r2)
 201deb4:	30ffffcc 	andi	r3,r6,65535
 201deb8:	1806d23a 	srli	r3,r3,8
 201debc:	197fffcc 	andi	r5,r3,65535
 201dec0:	10c00043 	ldbu	r3,1(r2)
 201dec4:	1806703a 	and	r3,r3,zero
 201dec8:	1809883a 	mov	r4,r3
 201decc:	2807883a 	mov	r3,r5
 201ded0:	20c6b03a 	or	r3,r4,r3
 201ded4:	10c00045 	stb	r3,1(r2)
    tcphdr->dest = htons(pcb->remote_port);
 201ded8:	e0bffc17 	ldw	r2,-16(fp)
 201dedc:	1080080b 	ldhu	r2,32(r2)
 201dee0:	10bfffcc 	andi	r2,r2,65535
 201dee4:	1004d23a 	srli	r2,r2,8
 201dee8:	1007883a 	mov	r3,r2
 201deec:	e0bffc17 	ldw	r2,-16(fp)
 201def0:	1080080b 	ldhu	r2,32(r2)
 201def4:	10bfffcc 	andi	r2,r2,65535
 201def8:	1004923a 	slli	r2,r2,8
 201defc:	1884b03a 	or	r2,r3,r2
 201df00:	100d883a 	mov	r6,r2
 201df04:	e0bffb17 	ldw	r2,-20(fp)
 201df08:	30ffffcc 	andi	r3,r6,65535
 201df0c:	19403fcc 	andi	r5,r3,255
 201df10:	10c00083 	ldbu	r3,2(r2)
 201df14:	1806703a 	and	r3,r3,zero
 201df18:	1809883a 	mov	r4,r3
 201df1c:	2807883a 	mov	r3,r5
 201df20:	20c6b03a 	or	r3,r4,r3
 201df24:	10c00085 	stb	r3,2(r2)
 201df28:	30ffffcc 	andi	r3,r6,65535
 201df2c:	1806d23a 	srli	r3,r3,8
 201df30:	197fffcc 	andi	r5,r3,65535
 201df34:	10c000c3 	ldbu	r3,3(r2)
 201df38:	1806703a 	and	r3,r3,zero
 201df3c:	1809883a 	mov	r4,r3
 201df40:	2807883a 	mov	r3,r5
 201df44:	20c6b03a 	or	r3,r4,r3
 201df48:	10c000c5 	stb	r3,3(r2)
    tcphdr->seqno = seqno_be;
 201df4c:	e0bffb17 	ldw	r2,-20(fp)
 201df50:	e0ffff17 	ldw	r3,-4(fp)
 201df54:	19403fcc 	andi	r5,r3,255
 201df58:	10c00103 	ldbu	r3,4(r2)
 201df5c:	1806703a 	and	r3,r3,zero
 201df60:	1809883a 	mov	r4,r3
 201df64:	2807883a 	mov	r3,r5
 201df68:	20c6b03a 	or	r3,r4,r3
 201df6c:	10c00105 	stb	r3,4(r2)
 201df70:	e0ffff17 	ldw	r3,-4(fp)
 201df74:	1806d23a 	srli	r3,r3,8
 201df78:	19403fcc 	andi	r5,r3,255
 201df7c:	10c00143 	ldbu	r3,5(r2)
 201df80:	1806703a 	and	r3,r3,zero
 201df84:	1809883a 	mov	r4,r3
 201df88:	2807883a 	mov	r3,r5
 201df8c:	20c6b03a 	or	r3,r4,r3
 201df90:	10c00145 	stb	r3,5(r2)
 201df94:	e0ffff17 	ldw	r3,-4(fp)
 201df98:	1806d43a 	srli	r3,r3,16
 201df9c:	19403fcc 	andi	r5,r3,255
 201dfa0:	10c00183 	ldbu	r3,6(r2)
 201dfa4:	1806703a 	and	r3,r3,zero
 201dfa8:	1809883a 	mov	r4,r3
 201dfac:	2807883a 	mov	r3,r5
 201dfb0:	20c6b03a 	or	r3,r4,r3
 201dfb4:	10c00185 	stb	r3,6(r2)
 201dfb8:	e0ffff17 	ldw	r3,-4(fp)
 201dfbc:	180ad63a 	srli	r5,r3,24
 201dfc0:	10c001c3 	ldbu	r3,7(r2)
 201dfc4:	1806703a 	and	r3,r3,zero
 201dfc8:	1809883a 	mov	r4,r3
 201dfcc:	2807883a 	mov	r3,r5
 201dfd0:	20c6b03a 	or	r3,r4,r3
 201dfd4:	10c001c5 	stb	r3,7(r2)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 201dfd8:	e0bffc17 	ldw	r2,-16(fp)
 201dfdc:	10800b17 	ldw	r2,44(r2)
 201dfe0:	1006d63a 	srli	r3,r2,24
 201dfe4:	e0bffc17 	ldw	r2,-16(fp)
 201dfe8:	10800b17 	ldw	r2,44(r2)
 201dfec:	1004d23a 	srli	r2,r2,8
 201dff0:	10bfc00c 	andi	r2,r2,65280
 201dff4:	1886b03a 	or	r3,r3,r2
 201dff8:	e0bffc17 	ldw	r2,-16(fp)
 201dffc:	10800b17 	ldw	r2,44(r2)
 201e000:	10bfc00c 	andi	r2,r2,65280
 201e004:	1004923a 	slli	r2,r2,8
 201e008:	1886b03a 	or	r3,r3,r2
 201e00c:	e0bffc17 	ldw	r2,-16(fp)
 201e010:	10800b17 	ldw	r2,44(r2)
 201e014:	1004963a 	slli	r2,r2,24
 201e018:	1886b03a 	or	r3,r3,r2
 201e01c:	e0bffb17 	ldw	r2,-20(fp)
 201e020:	19803fcc 	andi	r6,r3,255
 201e024:	11000203 	ldbu	r4,8(r2)
 201e028:	2008703a 	and	r4,r4,zero
 201e02c:	200b883a 	mov	r5,r4
 201e030:	3009883a 	mov	r4,r6
 201e034:	2908b03a 	or	r4,r5,r4
 201e038:	11000205 	stb	r4,8(r2)
 201e03c:	1808d23a 	srli	r4,r3,8
 201e040:	21803fcc 	andi	r6,r4,255
 201e044:	11000243 	ldbu	r4,9(r2)
 201e048:	2008703a 	and	r4,r4,zero
 201e04c:	200b883a 	mov	r5,r4
 201e050:	3009883a 	mov	r4,r6
 201e054:	2908b03a 	or	r4,r5,r4
 201e058:	11000245 	stb	r4,9(r2)
 201e05c:	1808d43a 	srli	r4,r3,16
 201e060:	21803fcc 	andi	r6,r4,255
 201e064:	11000283 	ldbu	r4,10(r2)
 201e068:	2008703a 	and	r4,r4,zero
 201e06c:	200b883a 	mov	r5,r4
 201e070:	3009883a 	mov	r4,r6
 201e074:	2908b03a 	or	r4,r5,r4
 201e078:	11000285 	stb	r4,10(r2)
 201e07c:	180ad63a 	srli	r5,r3,24
 201e080:	10c002c3 	ldbu	r3,11(r2)
 201e084:	1806703a 	and	r3,r3,zero
 201e088:	1809883a 	mov	r4,r3
 201e08c:	2807883a 	mov	r3,r5
 201e090:	20c6b03a 	or	r3,r4,r3
 201e094:	10c002c5 	stb	r3,11(r2)
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 201e098:	e0bffd0b 	ldhu	r2,-12(fp)
 201e09c:	1004d0ba 	srli	r2,r2,2
 201e0a0:	10bfffcc 	andi	r2,r2,65535
 201e0a4:	10800144 	addi	r2,r2,5
 201e0a8:	1004933a 	slli	r2,r2,12
 201e0ac:	10bfffcc 	andi	r2,r2,65535
 201e0b0:	1004d23a 	srli	r2,r2,8
 201e0b4:	10840014 	ori	r2,r2,4096
 201e0b8:	100d883a 	mov	r6,r2
 201e0bc:	e0bffb17 	ldw	r2,-20(fp)
 201e0c0:	30ffffcc 	andi	r3,r6,65535
 201e0c4:	19403fcc 	andi	r5,r3,255
 201e0c8:	10c00303 	ldbu	r3,12(r2)
 201e0cc:	1806703a 	and	r3,r3,zero
 201e0d0:	1809883a 	mov	r4,r3
 201e0d4:	2807883a 	mov	r3,r5
 201e0d8:	20c6b03a 	or	r3,r4,r3
 201e0dc:	10c00305 	stb	r3,12(r2)
 201e0e0:	30ffffcc 	andi	r3,r6,65535
 201e0e4:	1806d23a 	srli	r3,r3,8
 201e0e8:	197fffcc 	andi	r5,r3,65535
 201e0ec:	10c00343 	ldbu	r3,13(r2)
 201e0f0:	1806703a 	and	r3,r3,zero
 201e0f4:	1809883a 	mov	r4,r3
 201e0f8:	2807883a 	mov	r3,r5
 201e0fc:	20c6b03a 	or	r3,r4,r3
 201e100:	10c00345 	stb	r3,13(r2)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 201e104:	e0bffc17 	ldw	r2,-16(fp)
 201e108:	10800c8b 	ldhu	r2,50(r2)
 201e10c:	10bfffcc 	andi	r2,r2,65535
 201e110:	1004d23a 	srli	r2,r2,8
 201e114:	1007883a 	mov	r3,r2
 201e118:	e0bffc17 	ldw	r2,-16(fp)
 201e11c:	10800c8b 	ldhu	r2,50(r2)
 201e120:	10bfffcc 	andi	r2,r2,65535
 201e124:	1004923a 	slli	r2,r2,8
 201e128:	1884b03a 	or	r2,r3,r2
 201e12c:	100d883a 	mov	r6,r2
 201e130:	e0bffb17 	ldw	r2,-20(fp)
 201e134:	30ffffcc 	andi	r3,r6,65535
 201e138:	19403fcc 	andi	r5,r3,255
 201e13c:	10c00383 	ldbu	r3,14(r2)
 201e140:	1806703a 	and	r3,r3,zero
 201e144:	1809883a 	mov	r4,r3
 201e148:	2807883a 	mov	r3,r5
 201e14c:	20c6b03a 	or	r3,r4,r3
 201e150:	10c00385 	stb	r3,14(r2)
 201e154:	30ffffcc 	andi	r3,r6,65535
 201e158:	1806d23a 	srli	r3,r3,8
 201e15c:	197fffcc 	andi	r5,r3,65535
 201e160:	10c003c3 	ldbu	r3,15(r2)
 201e164:	1806703a 	and	r3,r3,zero
 201e168:	1809883a 	mov	r4,r3
 201e16c:	2807883a 	mov	r3,r5
 201e170:	20c6b03a 	or	r3,r4,r3
 201e174:	10c003c5 	stb	r3,15(r2)
    tcphdr->chksum = 0;
 201e178:	e0bffb17 	ldw	r2,-20(fp)
 201e17c:	10c00403 	ldbu	r3,16(r2)
 201e180:	1806703a 	and	r3,r3,zero
 201e184:	10c00405 	stb	r3,16(r2)
 201e188:	10c00443 	ldbu	r3,17(r2)
 201e18c:	1806703a 	and	r3,r3,zero
 201e190:	10c00445 	stb	r3,17(r2)
    tcphdr->urgp = 0;
 201e194:	e0bffb17 	ldw	r2,-20(fp)
 201e198:	10c00483 	ldbu	r3,18(r2)
 201e19c:	1806703a 	and	r3,r3,zero
 201e1a0:	10c00485 	stb	r3,18(r2)
 201e1a4:	10c004c3 	ldbu	r3,19(r2)
 201e1a8:	1806703a 	and	r3,r3,zero
 201e1ac:	10c004c5 	stb	r3,19(r2)

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 201e1b0:	e0bffc17 	ldw	r2,-16(fp)
 201e1b4:	10c00b17 	ldw	r3,44(r2)
 201e1b8:	e0bffc17 	ldw	r2,-16(fp)
 201e1bc:	10800c8b 	ldhu	r2,50(r2)
 201e1c0:	10bfffcc 	andi	r2,r2,65535
 201e1c4:	1887883a 	add	r3,r3,r2
 201e1c8:	e0bffc17 	ldw	r2,-16(fp)
 201e1cc:	10c00d15 	stw	r3,52(r2)
  }
  return p;
 201e1d0:	e0bffa17 	ldw	r2,-24(fp)
}
 201e1d4:	e037883a 	mov	sp,fp
 201e1d8:	dfc00117 	ldw	ra,4(sp)
 201e1dc:	df000017 	ldw	fp,0(sp)
 201e1e0:	dec00204 	addi	sp,sp,8
 201e1e4:	f800283a 	ret

0201e1e8 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 201e1e8:	defffc04 	addi	sp,sp,-16
 201e1ec:	dfc00315 	stw	ra,12(sp)
 201e1f0:	df000215 	stw	fp,8(sp)
 201e1f4:	df000204 	addi	fp,sp,8
 201e1f8:	e13fff15 	stw	r4,-4(fp)
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 201e1fc:	e0bfff17 	ldw	r2,-4(fp)
 201e200:	10801c17 	ldw	r2,112(r2)
 201e204:	10004226 	beq	r2,zero,201e310 <tcp_send_fin+0x128>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 201e208:	e0bfff17 	ldw	r2,-4(fp)
 201e20c:	10801c17 	ldw	r2,112(r2)
 201e210:	e0bffe15 	stw	r2,-8(fp)
 201e214:	00000306 	br	201e224 <tcp_send_fin+0x3c>
         last_unsent = last_unsent->next);
 201e218:	e0bffe17 	ldw	r2,-8(fp)
 201e21c:	10800017 	ldw	r2,0(r2)
 201e220:	e0bffe15 	stw	r2,-8(fp)
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 201e224:	e0bffe17 	ldw	r2,-8(fp)
 201e228:	10800017 	ldw	r2,0(r2)
 201e22c:	103ffa1e 	bne	r2,zero,201e218 <__alt_mem_mem_0+0xfcffe218>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 201e230:	e0bffe17 	ldw	r2,-8(fp)
 201e234:	10800417 	ldw	r2,16(r2)
 201e238:	10c00303 	ldbu	r3,12(r2)
 201e23c:	10800343 	ldbu	r2,13(r2)
 201e240:	1004923a 	slli	r2,r2,8
 201e244:	10c4b03a 	or	r2,r2,r3
 201e248:	10bfffcc 	andi	r2,r2,65535
 201e24c:	1004d23a 	srli	r2,r2,8
 201e250:	10ffffcc 	andi	r3,r2,65535
 201e254:	e0bffe17 	ldw	r2,-8(fp)
 201e258:	10800417 	ldw	r2,16(r2)
 201e25c:	11000303 	ldbu	r4,12(r2)
 201e260:	10800343 	ldbu	r2,13(r2)
 201e264:	1004923a 	slli	r2,r2,8
 201e268:	1104b03a 	or	r2,r2,r4
 201e26c:	10bfffcc 	andi	r2,r2,65535
 201e270:	1004923a 	slli	r2,r2,8
 201e274:	10bfffcc 	andi	r2,r2,65535
 201e278:	1884b03a 	or	r2,r3,r2
 201e27c:	108001cc 	andi	r2,r2,7
 201e280:	1000231e 	bne	r2,zero,201e310 <tcp_send_fin+0x128>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 201e284:	e0bffe17 	ldw	r2,-8(fp)
 201e288:	10800417 	ldw	r2,16(r2)
 201e28c:	e0fffe17 	ldw	r3,-8(fp)
 201e290:	18c00417 	ldw	r3,16(r3)
 201e294:	19000303 	ldbu	r4,12(r3)
 201e298:	18c00343 	ldbu	r3,13(r3)
 201e29c:	1806923a 	slli	r3,r3,8
 201e2a0:	1906b03a 	or	r3,r3,r4
 201e2a4:	18c04014 	ori	r3,r3,256
 201e2a8:	180d883a 	mov	r6,r3
 201e2ac:	30ffffcc 	andi	r3,r6,65535
 201e2b0:	19403fcc 	andi	r5,r3,255
 201e2b4:	10c00303 	ldbu	r3,12(r2)
 201e2b8:	1806703a 	and	r3,r3,zero
 201e2bc:	1809883a 	mov	r4,r3
 201e2c0:	2807883a 	mov	r3,r5
 201e2c4:	20c6b03a 	or	r3,r4,r3
 201e2c8:	10c00305 	stb	r3,12(r2)
 201e2cc:	30ffffcc 	andi	r3,r6,65535
 201e2d0:	1806d23a 	srli	r3,r3,8
 201e2d4:	197fffcc 	andi	r5,r3,65535
 201e2d8:	10c00343 	ldbu	r3,13(r2)
 201e2dc:	1806703a 	and	r3,r3,zero
 201e2e0:	1809883a 	mov	r4,r3
 201e2e4:	2807883a 	mov	r3,r5
 201e2e8:	20c6b03a 	or	r3,r4,r3
 201e2ec:	10c00345 	stb	r3,13(r2)
      pcb->flags |= TF_FIN;
 201e2f0:	e0bfff17 	ldw	r2,-4(fp)
 201e2f4:	10800883 	ldbu	r2,34(r2)
 201e2f8:	10800814 	ori	r2,r2,32
 201e2fc:	1007883a 	mov	r3,r2
 201e300:	e0bfff17 	ldw	r2,-4(fp)
 201e304:	10c00885 	stb	r3,34(r2)
      return ERR_OK;
 201e308:	0005883a 	mov	r2,zero
 201e30c:	00000306 	br	201e31c <tcp_send_fin+0x134>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 201e310:	01400044 	movi	r5,1
 201e314:	e13fff17 	ldw	r4,-4(fp)
 201e318:	201f2fc0 	call	201f2fc <tcp_enqueue_flags>
}
 201e31c:	e037883a 	mov	sp,fp
 201e320:	dfc00117 	ldw	ra,4(sp)
 201e324:	df000017 	ldw	fp,0(sp)
 201e328:	dec00204 	addi	sp,sp,8
 201e32c:	f800283a 	ret

0201e330 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
 201e330:	defff704 	addi	sp,sp,-36
 201e334:	dfc00815 	stw	ra,32(sp)
 201e338:	df000715 	stw	fp,28(sp)
 201e33c:	df000704 	addi	fp,sp,28
 201e340:	e13ffb15 	stw	r4,-20(fp)
 201e344:	e17ffc15 	stw	r5,-16(fp)
 201e348:	3007883a 	mov	r3,r6
 201e34c:	e1fffe15 	stw	r7,-8(fp)
 201e350:	e0800217 	ldw	r2,8(fp)
 201e354:	e0fffd05 	stb	r3,-12(fp)
 201e358:	e0bfff05 	stb	r2,-4(fp)
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 201e35c:	e0bfff03 	ldbu	r2,-4(fp)
 201e360:	1080004c 	andi	r2,r2,1
 201e364:	10000226 	beq	r2,zero,201e370 <tcp_create_segment+0x40>
 201e368:	00c00104 	movi	r3,4
 201e36c:	00000106 	br	201e374 <tcp_create_segment+0x44>
 201e370:	0007883a 	mov	r3,zero
 201e374:	e0bfff03 	ldbu	r2,-4(fp)
 201e378:	1080008c 	andi	r2,r2,2
 201e37c:	10000226 	beq	r2,zero,201e388 <tcp_create_segment+0x58>
 201e380:	00800304 	movi	r2,12
 201e384:	00000106 	br	201e38c <tcp_create_segment+0x5c>
 201e388:	0005883a 	mov	r2,zero
 201e38c:	1885883a 	add	r2,r3,r2
 201e390:	e0bff905 	stb	r2,-28(fp)

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 201e394:	01000104 	movi	r4,4
 201e398:	20344340 	call	2034434 <memp_malloc>
 201e39c:	e0bffa15 	stw	r2,-24(fp)
 201e3a0:	e0bffa17 	ldw	r2,-24(fp)
 201e3a4:	1000041e 	bne	r2,zero,201e3b8 <tcp_create_segment+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 201e3a8:	e13ffc17 	ldw	r4,-16(fp)
 201e3ac:	201ab680 	call	201ab68 <pbuf_free>
    return NULL;
 201e3b0:	0005883a 	mov	r2,zero
 201e3b4:	0000c106 	br	201e6bc <tcp_create_segment+0x38c>
  }
  seg->flags = optflags;
 201e3b8:	e0bffa17 	ldw	r2,-24(fp)
 201e3bc:	e0ffff03 	ldbu	r3,-4(fp)
 201e3c0:	10c00345 	stb	r3,13(r2)
  seg->next = NULL;
 201e3c4:	e0bffa17 	ldw	r2,-24(fp)
 201e3c8:	10000015 	stw	zero,0(r2)
  seg->p = p;
 201e3cc:	e0bffa17 	ldw	r2,-24(fp)
 201e3d0:	e0fffc17 	ldw	r3,-16(fp)
 201e3d4:	10c00115 	stw	r3,4(r2)
  seg->len = p->tot_len - optlen;
 201e3d8:	e0bffc17 	ldw	r2,-16(fp)
 201e3dc:	10c0020b 	ldhu	r3,8(r2)
 201e3e0:	e0bff903 	ldbu	r2,-28(fp)
 201e3e4:	1885c83a 	sub	r2,r3,r2
 201e3e8:	1007883a 	mov	r3,r2
 201e3ec:	e0bffa17 	ldw	r2,-24(fp)
 201e3f0:	10c0020d 	sth	r3,8(r2)
#if TCP_OVERSIZE_DBGCHECK
  seg->oversize_left = 0;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
  seg->chksum = 0;
 201e3f4:	e0bffa17 	ldw	r2,-24(fp)
 201e3f8:	1000028d 	sth	zero,10(r2)
  seg->chksum_swapped = 0;
 201e3fc:	e0bffa17 	ldw	r2,-24(fp)
 201e400:	10000305 	stb	zero,12(r2)
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 201e404:	01400504 	movi	r5,20
 201e408:	e13ffc17 	ldw	r4,-16(fp)
 201e40c:	201a9b80 	call	201a9b8 <pbuf_header>
 201e410:	10803fcc 	andi	r2,r2,255
 201e414:	10000b26 	beq	r2,zero,201e444 <tcp_create_segment+0x114>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
 201e418:	008085f4 	movhi	r2,535
 201e41c:	10a8bc04 	addi	r2,r2,-23824
 201e420:	10805217 	ldw	r2,328(r2)
 201e424:	10c00044 	addi	r3,r2,1
 201e428:	008085f4 	movhi	r2,535
 201e42c:	10a8bc04 	addi	r2,r2,-23824
 201e430:	10c05215 	stw	r3,328(r2)
    tcp_seg_free(seg);
 201e434:	e13ffa17 	ldw	r4,-24(fp)
 201e438:	201d4300 	call	201d430 <tcp_seg_free>
    return NULL;
 201e43c:	0005883a 	mov	r2,zero
 201e440:	00009e06 	br	201e6bc <tcp_create_segment+0x38c>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 201e444:	e0bffa17 	ldw	r2,-24(fp)
 201e448:	10800117 	ldw	r2,4(r2)
 201e44c:	10c00117 	ldw	r3,4(r2)
 201e450:	e0bffa17 	ldw	r2,-24(fp)
 201e454:	10c00415 	stw	r3,16(r2)
  seg->tcphdr->src = htons(pcb->local_port);
 201e458:	e0bffa17 	ldw	r2,-24(fp)
 201e45c:	10800417 	ldw	r2,16(r2)
 201e460:	e0fffb17 	ldw	r3,-20(fp)
 201e464:	18c0078b 	ldhu	r3,30(r3)
 201e468:	18ffffcc 	andi	r3,r3,65535
 201e46c:	1806d23a 	srli	r3,r3,8
 201e470:	1809883a 	mov	r4,r3
 201e474:	e0fffb17 	ldw	r3,-20(fp)
 201e478:	18c0078b 	ldhu	r3,30(r3)
 201e47c:	18ffffcc 	andi	r3,r3,65535
 201e480:	1806923a 	slli	r3,r3,8
 201e484:	20c6b03a 	or	r3,r4,r3
 201e488:	180d883a 	mov	r6,r3
 201e48c:	30ffffcc 	andi	r3,r6,65535
 201e490:	19403fcc 	andi	r5,r3,255
 201e494:	10c00003 	ldbu	r3,0(r2)
 201e498:	1806703a 	and	r3,r3,zero
 201e49c:	1809883a 	mov	r4,r3
 201e4a0:	2807883a 	mov	r3,r5
 201e4a4:	20c6b03a 	or	r3,r4,r3
 201e4a8:	10c00005 	stb	r3,0(r2)
 201e4ac:	30ffffcc 	andi	r3,r6,65535
 201e4b0:	1806d23a 	srli	r3,r3,8
 201e4b4:	197fffcc 	andi	r5,r3,65535
 201e4b8:	10c00043 	ldbu	r3,1(r2)
 201e4bc:	1806703a 	and	r3,r3,zero
 201e4c0:	1809883a 	mov	r4,r3
 201e4c4:	2807883a 	mov	r3,r5
 201e4c8:	20c6b03a 	or	r3,r4,r3
 201e4cc:	10c00045 	stb	r3,1(r2)
  seg->tcphdr->dest = htons(pcb->remote_port);
 201e4d0:	e0bffa17 	ldw	r2,-24(fp)
 201e4d4:	10800417 	ldw	r2,16(r2)
 201e4d8:	e0fffb17 	ldw	r3,-20(fp)
 201e4dc:	18c0080b 	ldhu	r3,32(r3)
 201e4e0:	18ffffcc 	andi	r3,r3,65535
 201e4e4:	1806d23a 	srli	r3,r3,8
 201e4e8:	1809883a 	mov	r4,r3
 201e4ec:	e0fffb17 	ldw	r3,-20(fp)
 201e4f0:	18c0080b 	ldhu	r3,32(r3)
 201e4f4:	18ffffcc 	andi	r3,r3,65535
 201e4f8:	1806923a 	slli	r3,r3,8
 201e4fc:	20c6b03a 	or	r3,r4,r3
 201e500:	180d883a 	mov	r6,r3
 201e504:	30ffffcc 	andi	r3,r6,65535
 201e508:	19403fcc 	andi	r5,r3,255
 201e50c:	10c00083 	ldbu	r3,2(r2)
 201e510:	1806703a 	and	r3,r3,zero
 201e514:	1809883a 	mov	r4,r3
 201e518:	2807883a 	mov	r3,r5
 201e51c:	20c6b03a 	or	r3,r4,r3
 201e520:	10c00085 	stb	r3,2(r2)
 201e524:	30ffffcc 	andi	r3,r6,65535
 201e528:	1806d23a 	srli	r3,r3,8
 201e52c:	197fffcc 	andi	r5,r3,65535
 201e530:	10c000c3 	ldbu	r3,3(r2)
 201e534:	1806703a 	and	r3,r3,zero
 201e538:	1809883a 	mov	r4,r3
 201e53c:	2807883a 	mov	r3,r5
 201e540:	20c6b03a 	or	r3,r4,r3
 201e544:	10c000c5 	stb	r3,3(r2)
  seg->tcphdr->seqno = htonl(seqno);
 201e548:	e0bffa17 	ldw	r2,-24(fp)
 201e54c:	10800417 	ldw	r2,16(r2)
 201e550:	e0fffe17 	ldw	r3,-8(fp)
 201e554:	1808d63a 	srli	r4,r3,24
 201e558:	e0fffe17 	ldw	r3,-8(fp)
 201e55c:	1806d23a 	srli	r3,r3,8
 201e560:	18ffc00c 	andi	r3,r3,65280
 201e564:	20c8b03a 	or	r4,r4,r3
 201e568:	e0fffe17 	ldw	r3,-8(fp)
 201e56c:	18ffc00c 	andi	r3,r3,65280
 201e570:	1806923a 	slli	r3,r3,8
 201e574:	20c8b03a 	or	r4,r4,r3
 201e578:	e0fffe17 	ldw	r3,-8(fp)
 201e57c:	1806963a 	slli	r3,r3,24
 201e580:	20c6b03a 	or	r3,r4,r3
 201e584:	19803fcc 	andi	r6,r3,255
 201e588:	11000103 	ldbu	r4,4(r2)
 201e58c:	2008703a 	and	r4,r4,zero
 201e590:	200b883a 	mov	r5,r4
 201e594:	3009883a 	mov	r4,r6
 201e598:	2908b03a 	or	r4,r5,r4
 201e59c:	11000105 	stb	r4,4(r2)
 201e5a0:	1808d23a 	srli	r4,r3,8
 201e5a4:	21803fcc 	andi	r6,r4,255
 201e5a8:	11000143 	ldbu	r4,5(r2)
 201e5ac:	2008703a 	and	r4,r4,zero
 201e5b0:	200b883a 	mov	r5,r4
 201e5b4:	3009883a 	mov	r4,r6
 201e5b8:	2908b03a 	or	r4,r5,r4
 201e5bc:	11000145 	stb	r4,5(r2)
 201e5c0:	1808d43a 	srli	r4,r3,16
 201e5c4:	21803fcc 	andi	r6,r4,255
 201e5c8:	11000183 	ldbu	r4,6(r2)
 201e5cc:	2008703a 	and	r4,r4,zero
 201e5d0:	200b883a 	mov	r5,r4
 201e5d4:	3009883a 	mov	r4,r6
 201e5d8:	2908b03a 	or	r4,r5,r4
 201e5dc:	11000185 	stb	r4,6(r2)
 201e5e0:	180ad63a 	srli	r5,r3,24
 201e5e4:	10c001c3 	ldbu	r3,7(r2)
 201e5e8:	1806703a 	and	r3,r3,zero
 201e5ec:	1809883a 	mov	r4,r3
 201e5f0:	2807883a 	mov	r3,r5
 201e5f4:	20c6b03a 	or	r3,r4,r3
 201e5f8:	10c001c5 	stb	r3,7(r2)
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 201e5fc:	e0bffa17 	ldw	r2,-24(fp)
 201e600:	10800417 	ldw	r2,16(r2)
 201e604:	e0fff903 	ldbu	r3,-28(fp)
 201e608:	1806d0ba 	srli	r3,r3,2
 201e60c:	18c03fcc 	andi	r3,r3,255
 201e610:	18c00144 	addi	r3,r3,5
 201e614:	1808933a 	slli	r4,r3,12
 201e618:	e0fffd03 	ldbu	r3,-12(fp)
 201e61c:	20c6b03a 	or	r3,r4,r3
 201e620:	18ffc00c 	andi	r3,r3,65280
 201e624:	1807d23a 	srai	r3,r3,8
 201e628:	180b883a 	mov	r5,r3
 201e62c:	e0fff903 	ldbu	r3,-28(fp)
 201e630:	1806d0ba 	srli	r3,r3,2
 201e634:	18c03fcc 	andi	r3,r3,255
 201e638:	18c00144 	addi	r3,r3,5
 201e63c:	1808933a 	slli	r4,r3,12
 201e640:	e0fffd03 	ldbu	r3,-12(fp)
 201e644:	20c6b03a 	or	r3,r4,r3
 201e648:	1806923a 	slli	r3,r3,8
 201e64c:	28c6b03a 	or	r3,r5,r3
 201e650:	180d883a 	mov	r6,r3
 201e654:	30ffffcc 	andi	r3,r6,65535
 201e658:	19403fcc 	andi	r5,r3,255
 201e65c:	10c00303 	ldbu	r3,12(r2)
 201e660:	1806703a 	and	r3,r3,zero
 201e664:	1809883a 	mov	r4,r3
 201e668:	2807883a 	mov	r3,r5
 201e66c:	20c6b03a 	or	r3,r4,r3
 201e670:	10c00305 	stb	r3,12(r2)
 201e674:	30ffffcc 	andi	r3,r6,65535
 201e678:	1806d23a 	srli	r3,r3,8
 201e67c:	197fffcc 	andi	r5,r3,65535
 201e680:	10c00343 	ldbu	r3,13(r2)
 201e684:	1806703a 	and	r3,r3,zero
 201e688:	1809883a 	mov	r4,r3
 201e68c:	2807883a 	mov	r3,r5
 201e690:	20c6b03a 	or	r3,r4,r3
 201e694:	10c00345 	stb	r3,13(r2)
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 201e698:	e0bffa17 	ldw	r2,-24(fp)
 201e69c:	10800417 	ldw	r2,16(r2)
 201e6a0:	10c00483 	ldbu	r3,18(r2)
 201e6a4:	1806703a 	and	r3,r3,zero
 201e6a8:	10c00485 	stb	r3,18(r2)
 201e6ac:	10c004c3 	ldbu	r3,19(r2)
 201e6b0:	1806703a 	and	r3,r3,zero
 201e6b4:	10c004c5 	stb	r3,19(r2)
  return seg;
 201e6b8:	e0bffa17 	ldw	r2,-24(fp)
} 
 201e6bc:	e037883a 	mov	sp,fp
 201e6c0:	dfc00117 	ldw	ra,4(sp)
 201e6c4:	df000017 	ldw	fp,0(sp)
 201e6c8:	dec00204 	addi	sp,sp,8
 201e6cc:	f800283a 	ret

0201e6d0 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 201e6d0:	defff604 	addi	sp,sp,-40
 201e6d4:	dfc00915 	stw	ra,36(sp)
 201e6d8:	df000815 	stw	fp,32(sp)
 201e6dc:	df000804 	addi	fp,sp,32
 201e6e0:	e13ffa15 	stw	r4,-24(fp)
 201e6e4:	3009883a 	mov	r4,r6
 201e6e8:	e1fffd15 	stw	r7,-12(fp)
 201e6ec:	e0c00317 	ldw	r3,12(fp)
 201e6f0:	e0800417 	ldw	r2,16(fp)
 201e6f4:	e17ffb0d 	sth	r5,-20(fp)
 201e6f8:	e13ffc0d 	sth	r4,-16(fp)
 201e6fc:	e0fffe05 	stb	r3,-8(fp)
 201e700:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  u16_t alloc = length;
 201e704:	e0bffb0b 	ldhu	r2,-20(fp)
 201e708:	e0bff80d 	sth	r2,-32(fp)
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 201e70c:	e0fffb0b 	ldhu	r3,-20(fp)
 201e710:	e0bffc0b 	ldhu	r2,-16(fp)
 201e714:	1880182e 	bgeu	r3,r2,201e778 <tcp_pbuf_prealloc+0xa8>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 201e718:	e0bffe03 	ldbu	r2,-8(fp)
 201e71c:	1080008c 	andi	r2,r2,2
 201e720:	10000d1e 	bne	r2,zero,201e758 <tcp_pbuf_prealloc+0x88>
        (!(pcb->flags & TF_NODELAY) &&
 201e724:	e0800217 	ldw	r2,8(fp)
 201e728:	10800883 	ldbu	r2,34(r2)
 201e72c:	10803fcc 	andi	r2,r2,255
 201e730:	1080100c 	andi	r2,r2,64
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 201e734:	1000101e 	bne	r2,zero,201e778 <tcp_pbuf_prealloc+0xa8>
        (!(pcb->flags & TF_NODELAY) &&
 201e738:	e0bfff03 	ldbu	r2,-4(fp)
 201e73c:	10000626 	beq	r2,zero,201e758 <tcp_pbuf_prealloc+0x88>
         (!first_seg ||
          pcb->unsent != NULL ||
 201e740:	e0800217 	ldw	r2,8(fp)
 201e744:	10801c17 	ldw	r2,112(r2)
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
 201e748:	1000031e 	bne	r2,zero,201e758 <tcp_pbuf_prealloc+0x88>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
 201e74c:	e0800217 	ldw	r2,8(fp)
 201e750:	10801d17 	ldw	r2,116(r2)
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
 201e754:	10000826 	beq	r2,zero,201e778 <tcp_pbuf_prealloc+0xa8>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 201e758:	e0bffb0b 	ldhu	r2,-20(fp)
 201e75c:	10c16dc4 	addi	r3,r2,1463
 201e760:	00bfff04 	movi	r2,-4
 201e764:	1884703a 	and	r2,r3,r2
 201e768:	e0fffc0b 	ldhu	r3,-16(fp)
 201e76c:	1880010e 	bge	r3,r2,201e774 <tcp_pbuf_prealloc+0xa4>
 201e770:	1805883a 	mov	r2,r3
 201e774:	e0bff80d 	sth	r2,-32(fp)
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 201e778:	e0bff80b 	ldhu	r2,-32(fp)
 201e77c:	000d883a 	mov	r6,zero
 201e780:	100b883a 	mov	r5,r2
 201e784:	e13ffa17 	ldw	r4,-24(fp)
 201e788:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201e78c:	e0bff915 	stw	r2,-28(fp)
  if (p == NULL) {
 201e790:	e0bff917 	ldw	r2,-28(fp)
 201e794:	1000021e 	bne	r2,zero,201e7a0 <tcp_pbuf_prealloc+0xd0>
    return NULL;
 201e798:	0005883a 	mov	r2,zero
 201e79c:	00000f06 	br	201e7dc <tcp_pbuf_prealloc+0x10c>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
 201e7a0:	e0bff917 	ldw	r2,-28(fp)
 201e7a4:	10c0028b 	ldhu	r3,10(r2)
 201e7a8:	e0bffb0b 	ldhu	r2,-20(fp)
 201e7ac:	1885c83a 	sub	r2,r3,r2
 201e7b0:	1007883a 	mov	r3,r2
 201e7b4:	e0bffd17 	ldw	r2,-12(fp)
 201e7b8:	10c0000d 	sth	r3,0(r2)
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 201e7bc:	e0bff917 	ldw	r2,-28(fp)
 201e7c0:	e0fffb0b 	ldhu	r3,-20(fp)
 201e7c4:	10c0020d 	sth	r3,8(r2)
 201e7c8:	e0bff917 	ldw	r2,-28(fp)
 201e7cc:	10c0020b 	ldhu	r3,8(r2)
 201e7d0:	e0bff917 	ldw	r2,-28(fp)
 201e7d4:	10c0028d 	sth	r3,10(r2)
  return p;
 201e7d8:	e0bff917 	ldw	r2,-28(fp)
}
 201e7dc:	e037883a 	mov	sp,fp
 201e7e0:	dfc00117 	ldw	ra,4(sp)
 201e7e4:	df000017 	ldw	fp,0(sp)
 201e7e8:	dec00204 	addi	sp,sp,8
 201e7ec:	f800283a 	ret

0201e7f0 <tcp_seg_add_chksum>:
#if TCP_CHECKSUM_ON_COPY
/** Add a checksum of newly added data to the segment */
static void
tcp_seg_add_chksum(u16_t chksum, u16_t len, u16_t *seg_chksum,
                   u8_t *seg_chksum_swapped)
{
 201e7f0:	defffa04 	addi	sp,sp,-24
 201e7f4:	df000515 	stw	fp,20(sp)
 201e7f8:	df000504 	addi	fp,sp,20
 201e7fc:	2007883a 	mov	r3,r4
 201e800:	2805883a 	mov	r2,r5
 201e804:	e1bffe15 	stw	r6,-8(fp)
 201e808:	e1ffff15 	stw	r7,-4(fp)
 201e80c:	e0fffc0d 	sth	r3,-16(fp)
 201e810:	e0bffd0d 	sth	r2,-12(fp)
  u32_t helper;
  /* add chksum to old chksum and fold to u16_t */
  helper = chksum + *seg_chksum;
 201e814:	e0fffc0b 	ldhu	r3,-16(fp)
 201e818:	e0bffe17 	ldw	r2,-8(fp)
 201e81c:	1080000b 	ldhu	r2,0(r2)
 201e820:	10bfffcc 	andi	r2,r2,65535
 201e824:	1885883a 	add	r2,r3,r2
 201e828:	e0bffb15 	stw	r2,-20(fp)
  chksum = FOLD_U32T(helper);
 201e82c:	e0bffb17 	ldw	r2,-20(fp)
 201e830:	1004d43a 	srli	r2,r2,16
 201e834:	1007883a 	mov	r3,r2
 201e838:	e0bffb17 	ldw	r2,-20(fp)
 201e83c:	1885883a 	add	r2,r3,r2
 201e840:	e0bffc0d 	sth	r2,-16(fp)
  if ((len & 1) != 0) {
 201e844:	e0bffd0b 	ldhu	r2,-12(fp)
 201e848:	1080004c 	andi	r2,r2,1
 201e84c:	10000e26 	beq	r2,zero,201e888 <tcp_seg_add_chksum+0x98>
    *seg_chksum_swapped = 1 - *seg_chksum_swapped;
 201e850:	e0bfff17 	ldw	r2,-4(fp)
 201e854:	10800003 	ldbu	r2,0(r2)
 201e858:	00c00044 	movi	r3,1
 201e85c:	1885c83a 	sub	r2,r3,r2
 201e860:	1007883a 	mov	r3,r2
 201e864:	e0bfff17 	ldw	r2,-4(fp)
 201e868:	10c00005 	stb	r3,0(r2)
    chksum = SWAP_BYTES_IN_WORD(chksum);
 201e86c:	e0bffc0b 	ldhu	r2,-16(fp)
 201e870:	1004d23a 	srli	r2,r2,8
 201e874:	1007883a 	mov	r3,r2
 201e878:	e0bffc0b 	ldhu	r2,-16(fp)
 201e87c:	1004923a 	slli	r2,r2,8
 201e880:	1884b03a 	or	r2,r3,r2
 201e884:	e0bffc0d 	sth	r2,-16(fp)
  }
  *seg_chksum = chksum;
 201e888:	e0bffe17 	ldw	r2,-8(fp)
 201e88c:	e0fffc0b 	ldhu	r3,-16(fp)
 201e890:	10c0000d 	sth	r3,0(r2)
}
 201e894:	0001883a 	nop
 201e898:	e037883a 	mov	sp,fp
 201e89c:	df000017 	ldw	fp,0(sp)
 201e8a0:	dec00104 	addi	sp,sp,4
 201e8a4:	f800283a 	ret

0201e8a8 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
 201e8a8:	defffd04 	addi	sp,sp,-12
 201e8ac:	df000215 	stw	fp,8(sp)
 201e8b0:	df000204 	addi	fp,sp,8
 201e8b4:	e13ffe15 	stw	r4,-8(fp)
 201e8b8:	2805883a 	mov	r2,r5
 201e8bc:	e0bfff0d 	sth	r2,-4(fp)
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 201e8c0:	e0bffe17 	ldw	r2,-8(fp)
 201e8c4:	10800617 	ldw	r2,24(r2)
 201e8c8:	10800120 	cmpeqi	r2,r2,4
 201e8cc:	10000e1e 	bne	r2,zero,201e908 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
 201e8d0:	e0bffe17 	ldw	r2,-8(fp)
 201e8d4:	10800617 	ldw	r2,24(r2)
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 201e8d8:	108001e0 	cmpeqi	r2,r2,7
 201e8dc:	10000a1e 	bne	r2,zero,201e908 <tcp_write_checks+0x60>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 201e8e0:	e0bffe17 	ldw	r2,-8(fp)
 201e8e4:	10800617 	ldw	r2,24(r2)
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
 201e8e8:	108000a0 	cmpeqi	r2,r2,2
 201e8ec:	1000061e 	bne	r2,zero,201e908 <tcp_write_checks+0x60>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
 201e8f0:	e0bffe17 	ldw	r2,-8(fp)
 201e8f4:	10800617 	ldw	r2,24(r2)
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
 201e8f8:	108000e0 	cmpeqi	r2,r2,3
 201e8fc:	1000021e 	bne	r2,zero,201e908 <tcp_write_checks+0x60>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 201e900:	00bffcc4 	movi	r2,-13
 201e904:	00002d06 	br	201e9bc <tcp_write_checks+0x114>
  } else if (len == 0) {
 201e908:	e0bfff0b 	ldhu	r2,-4(fp)
 201e90c:	1000021e 	bne	r2,zero,201e918 <tcp_write_checks+0x70>
    return ERR_OK;
 201e910:	0005883a 	mov	r2,zero
 201e914:	00002906 	br	201e9bc <tcp_write_checks+0x114>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 201e918:	e0bffe17 	ldw	r2,-8(fp)
 201e91c:	10801a8b 	ldhu	r2,106(r2)
 201e920:	10ffffcc 	andi	r3,r2,65535
 201e924:	e0bfff0b 	ldhu	r2,-4(fp)
 201e928:	1880092e 	bgeu	r3,r2,201e950 <tcp_write_checks+0xa8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 201e92c:	e0bffe17 	ldw	r2,-8(fp)
 201e930:	10c00883 	ldbu	r3,34(r2)
 201e934:	00bfe004 	movi	r2,-128
 201e938:	1884b03a 	or	r2,r3,r2
 201e93c:	1007883a 	mov	r3,r2
 201e940:	e0bffe17 	ldw	r2,-8(fp)
 201e944:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 201e948:	00bfffc4 	movi	r2,-1
 201e94c:	00001b06 	br	201e9bc <tcp_write_checks+0x114>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 201e950:	e0bffe17 	ldw	r2,-8(fp)
 201e954:	10801b0b 	ldhu	r2,108(r2)
 201e958:	10bfffcc 	andi	r2,r2,65535
 201e95c:	10800228 	cmpgeui	r2,r2,8
 201e960:	1000051e 	bne	r2,zero,201e978 <tcp_write_checks+0xd0>
 201e964:	e0bffe17 	ldw	r2,-8(fp)
 201e968:	10801b0b 	ldhu	r2,108(r2)
 201e96c:	10bfffcc 	andi	r2,r2,65535
 201e970:	10bfff70 	cmpltui	r2,r2,65533
 201e974:	1000101e 	bne	r2,zero,201e9b8 <tcp_write_checks+0x110>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 201e978:	008085f4 	movhi	r2,535
 201e97c:	10a8bc04 	addi	r2,r2,-23824
 201e980:	10804e17 	ldw	r2,312(r2)
 201e984:	10c00044 	addi	r3,r2,1
 201e988:	008085f4 	movhi	r2,535
 201e98c:	10a8bc04 	addi	r2,r2,-23824
 201e990:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
 201e994:	e0bffe17 	ldw	r2,-8(fp)
 201e998:	10c00883 	ldbu	r3,34(r2)
 201e99c:	00bfe004 	movi	r2,-128
 201e9a0:	1884b03a 	or	r2,r3,r2
 201e9a4:	1007883a 	mov	r3,r2
 201e9a8:	e0bffe17 	ldw	r2,-8(fp)
 201e9ac:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 201e9b0:	00bfffc4 	movi	r2,-1
 201e9b4:	00000106 	br	201e9bc <tcp_write_checks+0x114>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
 201e9b8:	0005883a 	mov	r2,zero
}
 201e9bc:	e037883a 	mov	sp,fp
 201e9c0:	df000017 	ldw	fp,0(sp)
 201e9c4:	dec00104 	addi	sp,sp,4
 201e9c8:	f800283a 	ret

0201e9cc <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 201e9cc:	deffe504 	addi	sp,sp,-108
 201e9d0:	dfc01a15 	stw	ra,104(sp)
 201e9d4:	df001915 	stw	fp,100(sp)
 201e9d8:	df001904 	addi	fp,sp,100
 201e9dc:	e13ffc15 	stw	r4,-16(fp)
 201e9e0:	e17ffd15 	stw	r5,-12(fp)
 201e9e4:	3007883a 	mov	r3,r6
 201e9e8:	3805883a 	mov	r2,r7
 201e9ec:	e0fffe0d 	sth	r3,-8(fp)
 201e9f0:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *concat_p = NULL;
 201e9f4:	e03fea15 	stw	zero,-88(fp)
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 201e9f8:	e03feb15 	stw	zero,-84(fp)
 201e9fc:	e03fec15 	stw	zero,-80(fp)
 201ea00:	e03fed15 	stw	zero,-76(fp)
 201ea04:	e03fee15 	stw	zero,-72(fp)
  u16_t pos = 0; /* position in 'arg' data */
 201ea08:	e03fef0d 	sth	zero,-68(fp)
  u16_t queuelen;
  u8_t optlen = 0;
 201ea0c:	e03ff405 	stb	zero,-48(fp)
  u8_t optflags = 0;
 201ea10:	e03ff445 	stb	zero,-47(fp)
#if TCP_OVERSIZE
  u16_t oversize = 0;
 201ea14:	e03ff90d 	sth	zero,-28(fp)
  u16_t oversize_used = 0;
 201ea18:	e03ff00d 	sth	zero,-64(fp)
#endif /* TCP_OVERSIZE */
#if TCP_CHECKSUM_ON_COPY
  u16_t concat_chksum = 0;
 201ea1c:	e03ff98d 	sth	zero,-26(fp)
  u8_t concat_chksum_swapped = 0;
 201ea20:	e03ffa05 	stb	zero,-24(fp)
  u16_t concat_chksummed = 0;
 201ea24:	e03ff08d 	sth	zero,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 201ea28:	e0bffc17 	ldw	r2,-16(fp)
 201ea2c:	1080198b 	ldhu	r2,102(r2)
 201ea30:	10bfffcc 	andi	r2,r2,65535
 201ea34:	1004d07a 	srli	r2,r2,1
 201ea38:	1007883a 	mov	r3,r2
 201ea3c:	e0bffc17 	ldw	r2,-16(fp)
 201ea40:	11400e8b 	ldhu	r5,58(r2)
 201ea44:	1805883a 	mov	r2,r3
 201ea48:	10ffffcc 	andi	r3,r2,65535
 201ea4c:	293fffcc 	andi	r4,r5,65535
 201ea50:	20c0012e 	bgeu	r4,r3,201ea58 <tcp_write+0x8c>
 201ea54:	2805883a 	mov	r2,r5
 201ea58:	e0bff48d 	sth	r2,-46(fp)
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 201ea5c:	e0bffd17 	ldw	r2,-12(fp)
 201ea60:	1000091e 	bne	r2,zero,201ea88 <tcp_write+0xbc>
 201ea64:	01c08134 	movhi	r7,516
 201ea68:	39c5f804 	addi	r7,r7,6112
 201ea6c:	01805fc4 	movi	r6,383
 201ea70:	01408134 	movhi	r5,516
 201ea74:	2945fe04 	addi	r5,r5,6136
 201ea78:	01008134 	movhi	r4,516
 201ea7c:	21060b04 	addi	r4,r4,6188
 201ea80:	2000bb00 	call	2000bb0 <printf>
 201ea84:	003fff06 	br	201ea84 <__alt_mem_mem_0+0xfcffea84>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
 201ea88:	e0bffe0b 	ldhu	r2,-8(fp)
 201ea8c:	100b883a 	mov	r5,r2
 201ea90:	e13ffc17 	ldw	r4,-16(fp)
 201ea94:	201e8a80 	call	201e8a8 <tcp_write_checks>
 201ea98:	e0bff505 	stb	r2,-44(fp)
  if (err != ERR_OK) {
 201ea9c:	e0bff507 	ldb	r2,-44(fp)
 201eaa0:	10000226 	beq	r2,zero,201eaac <tcp_write+0xe0>
    return err;
 201eaa4:	e0bff503 	ldbu	r2,-44(fp)
 201eaa8:	00020f06 	br	201f2e8 <tcp_write+0x91c>
  }
  queuelen = pcb->snd_queuelen;
 201eaac:	e0bffc17 	ldw	r2,-16(fp)
 201eab0:	10801b0b 	ldhu	r2,108(r2)
 201eab4:	e0bfef8d 	sth	r2,-66(fp)
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 201eab8:	e0bffc17 	ldw	r2,-16(fp)
 201eabc:	10801c17 	ldw	r2,112(r2)
 201eac0:	10014326 	beq	r2,zero,201efd0 <tcp_write+0x604>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 201eac4:	e0bffc17 	ldw	r2,-16(fp)
 201eac8:	10801c17 	ldw	r2,112(r2)
 201eacc:	e0bfeb15 	stw	r2,-84(fp)
 201ead0:	00000306 	br	201eae0 <tcp_write+0x114>
         last_unsent = last_unsent->next);
 201ead4:	e0bfeb17 	ldw	r2,-84(fp)
 201ead8:	10800017 	ldw	r2,0(r2)
 201eadc:	e0bfeb15 	stw	r2,-84(fp)
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 201eae0:	e0bfeb17 	ldw	r2,-84(fp)
 201eae4:	10800017 	ldw	r2,0(r2)
 201eae8:	103ffa1e 	bne	r2,zero,201ead4 <__alt_mem_mem_0+0xfcffead4>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 201eaec:	e0bfeb17 	ldw	r2,-84(fp)
 201eaf0:	10800343 	ldbu	r2,13(r2)
 201eaf4:	10803fcc 	andi	r2,r2,255
 201eaf8:	1080004c 	andi	r2,r2,1
 201eafc:	10000226 	beq	r2,zero,201eb08 <tcp_write+0x13c>
 201eb00:	00c00104 	movi	r3,4
 201eb04:	00000106 	br	201eb0c <tcp_write+0x140>
 201eb08:	0007883a 	mov	r3,zero
 201eb0c:	e0bfeb17 	ldw	r2,-84(fp)
 201eb10:	10800343 	ldbu	r2,13(r2)
 201eb14:	10803fcc 	andi	r2,r2,255
 201eb18:	1080008c 	andi	r2,r2,2
 201eb1c:	10000226 	beq	r2,zero,201eb28 <tcp_write+0x15c>
 201eb20:	00800304 	movi	r2,12
 201eb24:	00000106 	br	201eb2c <tcp_write+0x160>
 201eb28:	0005883a 	mov	r2,zero
 201eb2c:	1885883a 	add	r2,r3,r2
 201eb30:	e0bff58d 	sth	r2,-42(fp)
    space = mss_local - (last_unsent->len + unsent_optlen);
 201eb34:	e0bfeb17 	ldw	r2,-84(fp)
 201eb38:	10c0020b 	ldhu	r3,8(r2)
 201eb3c:	e0bff58b 	ldhu	r2,-42(fp)
 201eb40:	1885883a 	add	r2,r3,r2
 201eb44:	1007883a 	mov	r3,r2
 201eb48:	e0bff48b 	ldhu	r2,-46(fp)
 201eb4c:	10c5c83a 	sub	r2,r2,r3
 201eb50:	e0bff10d 	sth	r2,-60(fp)
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 201eb54:	e0bffc17 	ldw	r2,-16(fp)
 201eb58:	10801b8b 	ldhu	r2,110(r2)
 201eb5c:	e0bff90d 	sth	r2,-28(fp)
    if (oversize > 0) {
 201eb60:	e0bff90b 	ldhu	r2,-28(fp)
 201eb64:	10bfffcc 	andi	r2,r2,65535
 201eb68:	10001526 	beq	r2,zero,201ebc0 <tcp_write+0x1f4>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
 201eb6c:	e0bfeb17 	ldw	r2,-84(fp)
 201eb70:	e0bfec15 	stw	r2,-80(fp)
      oversize_used = oversize < len ? oversize : len;
 201eb74:	e17ff90b 	ldhu	r5,-28(fp)
 201eb78:	e0bffe0b 	ldhu	r2,-8(fp)
 201eb7c:	10ffffcc 	andi	r3,r2,65535
 201eb80:	293fffcc 	andi	r4,r5,65535
 201eb84:	20c0012e 	bgeu	r4,r3,201eb8c <tcp_write+0x1c0>
 201eb88:	2805883a 	mov	r2,r5
 201eb8c:	e0bff00d 	sth	r2,-64(fp)
      pos += oversize_used;
 201eb90:	e0ffef0b 	ldhu	r3,-68(fp)
 201eb94:	e0bff00b 	ldhu	r2,-64(fp)
 201eb98:	1885883a 	add	r2,r3,r2
 201eb9c:	e0bfef0d 	sth	r2,-68(fp)
      oversize -= oversize_used;
 201eba0:	e0fff90b 	ldhu	r3,-28(fp)
 201eba4:	e0bff00b 	ldhu	r2,-64(fp)
 201eba8:	1885c83a 	sub	r2,r3,r2
 201ebac:	e0bff90d 	sth	r2,-28(fp)
      space -= oversize_used;
 201ebb0:	e0fff10b 	ldhu	r3,-60(fp)
 201ebb4:	e0bff00b 	ldhu	r2,-64(fp)
 201ebb8:	1885c83a 	sub	r2,r3,r2
 201ebbc:	e0bff10d 	sth	r2,-60(fp)
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 201ebc0:	e0ffef0b 	ldhu	r3,-68(fp)
 201ebc4:	e0bffe0b 	ldhu	r2,-8(fp)
 201ebc8:	1881012e 	bgeu	r3,r2,201efd0 <tcp_write+0x604>
 201ebcc:	e0bff10b 	ldhu	r2,-60(fp)
 201ebd0:	1000ff26 	beq	r2,zero,201efd0 <tcp_write+0x604>
 201ebd4:	e0bfeb17 	ldw	r2,-84(fp)
 201ebd8:	1080020b 	ldhu	r2,8(r2)
 201ebdc:	10bfffcc 	andi	r2,r2,65535
 201ebe0:	1000fb26 	beq	r2,zero,201efd0 <tcp_write+0x604>
      u16_t seglen = space < len - pos ? space : len - pos;
 201ebe4:	e0fffe0b 	ldhu	r3,-8(fp)
 201ebe8:	e0bfef0b 	ldhu	r2,-68(fp)
 201ebec:	1885c83a 	sub	r2,r3,r2
 201ebf0:	e0fff10b 	ldhu	r3,-60(fp)
 201ebf4:	1880010e 	bge	r3,r2,201ebfc <tcp_write+0x230>
 201ebf8:	1805883a 	mov	r2,r3
 201ebfc:	e0bff60d 	sth	r2,-40(fp)
      seg = last_unsent;
 201ec00:	e0bfeb17 	ldw	r2,-84(fp)
 201ec04:	e0bfec15 	stw	r2,-80(fp)

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 201ec08:	e0bfff03 	ldbu	r2,-4(fp)
 201ec0c:	1080004c 	andi	r2,r2,1
 201ec10:	10002826 	beq	r2,zero,201ecb4 <tcp_write+0x2e8>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 201ec14:	e13ff60b 	ldhu	r4,-40(fp)
 201ec18:	e17ff10b 	ldhu	r5,-60(fp)
 201ec1c:	e0bfff03 	ldbu	r2,-4(fp)
 201ec20:	e1bff904 	addi	r6,fp,-28
 201ec24:	00c00044 	movi	r3,1
 201ec28:	d8c00215 	stw	r3,8(sp)
 201ec2c:	d8800115 	stw	r2,4(sp)
 201ec30:	e0bffc17 	ldw	r2,-16(fp)
 201ec34:	d8800015 	stw	r2,0(sp)
 201ec38:	300f883a 	mov	r7,r6
 201ec3c:	280d883a 	mov	r6,r5
 201ec40:	200b883a 	mov	r5,r4
 201ec44:	010000c4 	movi	r4,3
 201ec48:	201e6d00 	call	201e6d0 <tcp_pbuf_prealloc>
 201ec4c:	e0bfea15 	stw	r2,-88(fp)
 201ec50:	e0bfea17 	ldw	r2,-88(fp)
 201ec54:	10018426 	beq	r2,zero,201f268 <tcp_write+0x89c>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 201ec58:	e0bfea17 	ldw	r2,-88(fp)
 201ec5c:	11000117 	ldw	r4,4(r2)
 201ec60:	e0bfef0b 	ldhu	r2,-68(fp)
 201ec64:	e0fffd17 	ldw	r3,-12(fp)
 201ec68:	1885883a 	add	r2,r3,r2
 201ec6c:	e0fff60b 	ldhu	r3,-40(fp)
 201ec70:	180d883a 	mov	r6,r3
 201ec74:	100b883a 	mov	r5,r2
 201ec78:	2031cc40 	call	2031cc4 <lwip_chksum_copy>
 201ec7c:	10bfffcc 	andi	r2,r2,65535
 201ec80:	e0fff60b 	ldhu	r3,-40(fp)
 201ec84:	e17ffa04 	addi	r5,fp,-24
 201ec88:	e13ff984 	addi	r4,fp,-26
 201ec8c:	280f883a 	mov	r7,r5
 201ec90:	200d883a 	mov	r6,r4
 201ec94:	180b883a 	mov	r5,r3
 201ec98:	1009883a 	mov	r4,r2
 201ec9c:	201e7f00 	call	201e7f0 <tcp_seg_add_chksum>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
 201eca0:	e0fff08b 	ldhu	r3,-62(fp)
 201eca4:	e0bff60b 	ldhu	r2,-40(fp)
 201eca8:	1885883a 	add	r2,r3,r2
 201ecac:	e0bff08d 	sth	r2,-62(fp)
 201ecb0:	00002206 	br	201ed3c <tcp_write+0x370>
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 201ecb4:	e0bff60b 	ldhu	r2,-40(fp)
 201ecb8:	01800044 	movi	r6,1
 201ecbc:	100b883a 	mov	r5,r2
 201ecc0:	010000c4 	movi	r4,3
 201ecc4:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201ecc8:	e0bfea15 	stw	r2,-88(fp)
 201eccc:	e0bfea17 	ldw	r2,-88(fp)
 201ecd0:	10016726 	beq	r2,zero,201f270 <tcp_write+0x8a4>
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
        }
#if TCP_CHECKSUM_ON_COPY
        /* calculate the checksum of nocopy-data */
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
 201ecd4:	e0bfef0b 	ldhu	r2,-68(fp)
 201ecd8:	e0fffd17 	ldw	r3,-12(fp)
 201ecdc:	1885883a 	add	r2,r3,r2
 201ece0:	e0fff60b 	ldhu	r3,-40(fp)
 201ece4:	180b883a 	mov	r5,r3
 201ece8:	1009883a 	mov	r4,r2
 201ecec:	2031b740 	call	2031b74 <inet_chksum>
 201ecf0:	0084303a 	nor	r2,zero,r2
 201ecf4:	10bfffcc 	andi	r2,r2,65535
 201ecf8:	e0fff60b 	ldhu	r3,-40(fp)
 201ecfc:	e17ffa04 	addi	r5,fp,-24
 201ed00:	e13ff984 	addi	r4,fp,-26
 201ed04:	280f883a 	mov	r7,r5
 201ed08:	200d883a 	mov	r6,r4
 201ed0c:	180b883a 	mov	r5,r3
 201ed10:	1009883a 	mov	r4,r2
 201ed14:	201e7f00 	call	201e7f0 <tcp_seg_add_chksum>
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
 201ed18:	e0fff08b 	ldhu	r3,-62(fp)
 201ed1c:	e0bff60b 	ldhu	r2,-40(fp)
 201ed20:	1885883a 	add	r2,r3,r2
 201ed24:	e0bff08d 	sth	r2,-62(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 201ed28:	e0bfef0b 	ldhu	r2,-68(fp)
 201ed2c:	e0fffd17 	ldw	r3,-12(fp)
 201ed30:	1887883a 	add	r3,r3,r2
 201ed34:	e0bfea17 	ldw	r2,-88(fp)
 201ed38:	10c00115 	stw	r3,4(r2)
      }

      pos += seglen;
 201ed3c:	e0ffef0b 	ldhu	r3,-68(fp)
 201ed40:	e0bff60b 	ldhu	r2,-40(fp)
 201ed44:	1885883a 	add	r2,r3,r2
 201ed48:	e0bfef0d 	sth	r2,-68(fp)
      queuelen += pbuf_clen(concat_p);
 201ed4c:	e13fea17 	ldw	r4,-88(fp)
 201ed50:	201acac0 	call	201acac <pbuf_clen>
 201ed54:	10c03fcc 	andi	r3,r2,255
 201ed58:	e0bfef8b 	ldhu	r2,-66(fp)
 201ed5c:	1885883a 	add	r2,r3,r2
 201ed60:	e0bfef8d 	sth	r2,-66(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 201ed64:	00009a06 	br	201efd0 <tcp_write+0x604>
    struct pbuf *p;
    u16_t left = len - pos;
 201ed68:	e0fffe0b 	ldhu	r3,-8(fp)
 201ed6c:	e0bfef0b 	ldhu	r2,-68(fp)
 201ed70:	1885c83a 	sub	r2,r3,r2
 201ed74:	e0bff68d 	sth	r2,-38(fp)
    u16_t max_len = mss_local - optlen;
 201ed78:	e0bff403 	ldbu	r2,-48(fp)
 201ed7c:	e0fff48b 	ldhu	r3,-46(fp)
 201ed80:	1885c83a 	sub	r2,r3,r2
 201ed84:	e0bff70d 	sth	r2,-36(fp)
    u16_t seglen = left > max_len ? max_len : left;
 201ed88:	e17ff70b 	ldhu	r5,-36(fp)
 201ed8c:	e0bff68b 	ldhu	r2,-38(fp)
 201ed90:	10ffffcc 	andi	r3,r2,65535
 201ed94:	293fffcc 	andi	r4,r5,65535
 201ed98:	20c0012e 	bgeu	r4,r3,201eda0 <tcp_write+0x3d4>
 201ed9c:	2805883a 	mov	r2,r5
 201eda0:	e0bff78d 	sth	r2,-34(fp)
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
 201eda4:	e03ffa8d 	sth	zero,-22(fp)
    u8_t chksum_swapped = 0;
 201eda8:	e03ffb05 	stb	zero,-20(fp)
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 201edac:	e0bfff03 	ldbu	r2,-4(fp)
 201edb0:	1080004c 	andi	r2,r2,1
 201edb4:	10002b26 	beq	r2,zero,201ee64 <tcp_write+0x498>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 201edb8:	e0fff403 	ldbu	r3,-48(fp)
 201edbc:	e0bff78b 	ldhu	r2,-34(fp)
 201edc0:	1885883a 	add	r2,r3,r2
 201edc4:	113fffcc 	andi	r4,r2,65535
 201edc8:	e17ff48b 	ldhu	r5,-46(fp)
 201edcc:	e0bfff03 	ldbu	r2,-4(fp)
 201edd0:	e0ffee17 	ldw	r3,-72(fp)
 201edd4:	1807003a 	cmpeq	r3,r3,zero
 201edd8:	18c03fcc 	andi	r3,r3,255
 201eddc:	e1bff904 	addi	r6,fp,-28
 201ede0:	d8c00215 	stw	r3,8(sp)
 201ede4:	d8800115 	stw	r2,4(sp)
 201ede8:	e0bffc17 	ldw	r2,-16(fp)
 201edec:	d8800015 	stw	r2,0(sp)
 201edf0:	300f883a 	mov	r7,r6
 201edf4:	280d883a 	mov	r6,r5
 201edf8:	200b883a 	mov	r5,r4
 201edfc:	0009883a 	mov	r4,zero
 201ee00:	201e6d00 	call	201e6d0 <tcp_pbuf_prealloc>
 201ee04:	e0bff215 	stw	r2,-56(fp)
 201ee08:	e0bff217 	ldw	r2,-56(fp)
 201ee0c:	10011a26 	beq	r2,zero,201f278 <tcp_write+0x8ac>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 201ee10:	e0bff217 	ldw	r2,-56(fp)
 201ee14:	10c00117 	ldw	r3,4(r2)
 201ee18:	e0bff403 	ldbu	r2,-48(fp)
 201ee1c:	1889883a 	add	r4,r3,r2
 201ee20:	e0bfef0b 	ldhu	r2,-68(fp)
 201ee24:	e0fffd17 	ldw	r3,-12(fp)
 201ee28:	1885883a 	add	r2,r3,r2
 201ee2c:	e0fff78b 	ldhu	r3,-34(fp)
 201ee30:	180d883a 	mov	r6,r3
 201ee34:	100b883a 	mov	r5,r2
 201ee38:	2031cc40 	call	2031cc4 <lwip_chksum_copy>
 201ee3c:	10bfffcc 	andi	r2,r2,65535
 201ee40:	e0fff78b 	ldhu	r3,-34(fp)
 201ee44:	e17ffb04 	addi	r5,fp,-20
 201ee48:	e13ffa84 	addi	r4,fp,-22
 201ee4c:	280f883a 	mov	r7,r5
 201ee50:	200d883a 	mov	r6,r4
 201ee54:	180b883a 	mov	r5,r3
 201ee58:	1009883a 	mov	r4,r2
 201ee5c:	201e7f00 	call	201e7f0 <tcp_seg_add_chksum>
 201ee60:	00002406 	br	201eef4 <tcp_write+0x528>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 201ee64:	e0bff78b 	ldhu	r2,-34(fp)
 201ee68:	01800044 	movi	r6,1
 201ee6c:	100b883a 	mov	r5,r2
 201ee70:	0009883a 	mov	r4,zero
 201ee74:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201ee78:	e0bff815 	stw	r2,-32(fp)
 201ee7c:	e0bff817 	ldw	r2,-32(fp)
 201ee80:	1000ff26 	beq	r2,zero,201f280 <tcp_write+0x8b4>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
 201ee84:	e0bfef0b 	ldhu	r2,-68(fp)
 201ee88:	e0fffd17 	ldw	r3,-12(fp)
 201ee8c:	1885883a 	add	r2,r3,r2
 201ee90:	e0fff78b 	ldhu	r3,-34(fp)
 201ee94:	180b883a 	mov	r5,r3
 201ee98:	1009883a 	mov	r4,r2
 201ee9c:	2031b740 	call	2031b74 <inet_chksum>
 201eea0:	0084303a 	nor	r2,zero,r2
 201eea4:	e0bffa8d 	sth	r2,-22(fp)
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 201eea8:	e0bfef0b 	ldhu	r2,-68(fp)
 201eeac:	e0fffd17 	ldw	r3,-12(fp)
 201eeb0:	1887883a 	add	r3,r3,r2
 201eeb4:	e0bff817 	ldw	r2,-32(fp)
 201eeb8:	10c00115 	stw	r3,4(r2)

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 201eebc:	e0bff403 	ldbu	r2,-48(fp)
 201eec0:	000d883a 	mov	r6,zero
 201eec4:	100b883a 	mov	r5,r2
 201eec8:	0009883a 	mov	r4,zero
 201eecc:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201eed0:	e0bff215 	stw	r2,-56(fp)
 201eed4:	e0bff217 	ldw	r2,-56(fp)
 201eed8:	1000031e 	bne	r2,zero,201eee8 <tcp_write+0x51c>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 201eedc:	e13ff817 	ldw	r4,-32(fp)
 201eee0:	201ab680 	call	201ab68 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 201eee4:	0000e906 	br	201f28c <tcp_write+0x8c0>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 201eee8:	e17ff817 	ldw	r5,-32(fp)
 201eeec:	e13ff217 	ldw	r4,-56(fp)
 201eef0:	201ad5c0 	call	201ad5c <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 201eef4:	e13ff217 	ldw	r4,-56(fp)
 201eef8:	201acac0 	call	201acac <pbuf_clen>
 201eefc:	10c03fcc 	andi	r3,r2,255
 201ef00:	e0bfef8b 	ldhu	r2,-66(fp)
 201ef04:	1885883a 	add	r2,r3,r2
 201ef08:	e0bfef8d 	sth	r2,-66(fp)

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 201ef0c:	e0bfef8b 	ldhu	r2,-66(fp)
 201ef10:	10800268 	cmpgeui	r2,r2,9
 201ef14:	1000031e 	bne	r2,zero,201ef24 <tcp_write+0x558>
 201ef18:	e0bfef8b 	ldhu	r2,-66(fp)
 201ef1c:	10bfff70 	cmpltui	r2,r2,65533
 201ef20:	1000031e 	bne	r2,zero,201ef30 <tcp_write+0x564>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
 201ef24:	e13ff217 	ldw	r4,-56(fp)
 201ef28:	201ab680 	call	201ab68 <pbuf_free>
      goto memerr;
 201ef2c:	0000d706 	br	201f28c <tcp_write+0x8c0>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 201ef30:	e0bffc17 	ldw	r2,-16(fp)
 201ef34:	10c01817 	ldw	r3,96(r2)
 201ef38:	e0bfef0b 	ldhu	r2,-68(fp)
 201ef3c:	1887883a 	add	r3,r3,r2
 201ef40:	e0bff443 	ldbu	r2,-47(fp)
 201ef44:	d8800015 	stw	r2,0(sp)
 201ef48:	180f883a 	mov	r7,r3
 201ef4c:	000d883a 	mov	r6,zero
 201ef50:	e17ff217 	ldw	r5,-56(fp)
 201ef54:	e13ffc17 	ldw	r4,-16(fp)
 201ef58:	201e3300 	call	201e330 <tcp_create_segment>
 201ef5c:	e0bfec15 	stw	r2,-80(fp)
 201ef60:	e0bfec17 	ldw	r2,-80(fp)
 201ef64:	1000c826 	beq	r2,zero,201f288 <tcp_write+0x8bc>
    }
#if TCP_OVERSIZE_DBGCHECK
    seg->oversize_left = oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
#if TCP_CHECKSUM_ON_COPY
    seg->chksum = chksum;
 201ef68:	e0fffa8b 	ldhu	r3,-22(fp)
 201ef6c:	e0bfec17 	ldw	r2,-80(fp)
 201ef70:	10c0028d 	sth	r3,10(r2)
    seg->chksum_swapped = chksum_swapped;
 201ef74:	e0fffb03 	ldbu	r3,-20(fp)
 201ef78:	e0bfec17 	ldw	r2,-80(fp)
 201ef7c:	10c00305 	stb	r3,12(r2)
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
 201ef80:	e0bfec17 	ldw	r2,-80(fp)
 201ef84:	10800343 	ldbu	r2,13(r2)
 201ef88:	10800114 	ori	r2,r2,4
 201ef8c:	1007883a 	mov	r3,r2
 201ef90:	e0bfec17 	ldw	r2,-80(fp)
 201ef94:	10c00345 	stb	r3,13(r2)
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 201ef98:	e0bfee17 	ldw	r2,-72(fp)
 201ef9c:	1000031e 	bne	r2,zero,201efac <tcp_write+0x5e0>
      queue = seg;
 201efa0:	e0bfec17 	ldw	r2,-80(fp)
 201efa4:	e0bfee15 	stw	r2,-72(fp)
 201efa8:	00000306 	br	201efb8 <tcp_write+0x5ec>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
 201efac:	e0bfed17 	ldw	r2,-76(fp)
 201efb0:	e0ffec17 	ldw	r3,-80(fp)
 201efb4:	10c00015 	stw	r3,0(r2)
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
 201efb8:	e0bfec17 	ldw	r2,-80(fp)
 201efbc:	e0bfed15 	stw	r2,-76(fp)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 201efc0:	e0ffef0b 	ldhu	r3,-68(fp)
 201efc4:	e0bff78b 	ldhu	r2,-34(fp)
 201efc8:	1885883a 	add	r2,r3,r2
 201efcc:	e0bfef0d 	sth	r2,-68(fp)
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 201efd0:	e0ffef0b 	ldhu	r3,-68(fp)
 201efd4:	e0bffe0b 	ldhu	r2,-8(fp)
 201efd8:	18bf6336 	bltu	r3,r2,201ed68 <__alt_mem_mem_0+0xfcffed68>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 201efdc:	e0bff00b 	ldhu	r2,-64(fp)
 201efe0:	10003d26 	beq	r2,zero,201f0d8 <tcp_write+0x70c>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 201efe4:	e0bfeb17 	ldw	r2,-84(fp)
 201efe8:	10800117 	ldw	r2,4(r2)
 201efec:	e0bff315 	stw	r2,-52(fp)
 201eff0:	00003006 	br	201f0b4 <tcp_write+0x6e8>
      p->tot_len += oversize_used;
 201eff4:	e0bff317 	ldw	r2,-52(fp)
 201eff8:	10c0020b 	ldhu	r3,8(r2)
 201effc:	e0bff00b 	ldhu	r2,-64(fp)
 201f000:	1885883a 	add	r2,r3,r2
 201f004:	1007883a 	mov	r3,r2
 201f008:	e0bff317 	ldw	r2,-52(fp)
 201f00c:	10c0020d 	sth	r3,8(r2)
      if (p->next == NULL) {
 201f010:	e0bff317 	ldw	r2,-52(fp)
 201f014:	10800017 	ldw	r2,0(r2)
 201f018:	1000231e 	bne	r2,zero,201f0a8 <tcp_write+0x6dc>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 201f01c:	e0bff317 	ldw	r2,-52(fp)
 201f020:	10c00117 	ldw	r3,4(r2)
 201f024:	e0bff317 	ldw	r2,-52(fp)
 201f028:	1080028b 	ldhu	r2,10(r2)
 201f02c:	10bfffcc 	andi	r2,r2,65535
 201f030:	1885883a 	add	r2,r3,r2
 201f034:	e0fff00b 	ldhu	r3,-64(fp)
 201f038:	180d883a 	mov	r6,r3
 201f03c:	e17ffd17 	ldw	r5,-12(fp)
 201f040:	1009883a 	mov	r4,r2
 201f044:	2031cc40 	call	2031cc4 <lwip_chksum_copy>
 201f048:	10ffffcc 	andi	r3,r2,65535
 201f04c:	e13ff00b 	ldhu	r4,-64(fp)
 201f050:	e0bfeb17 	ldw	r2,-84(fp)
 201f054:	11400284 	addi	r5,r2,10
 201f058:	e0bfeb17 	ldw	r2,-84(fp)
 201f05c:	10800304 	addi	r2,r2,12
 201f060:	100f883a 	mov	r7,r2
 201f064:	280d883a 	mov	r6,r5
 201f068:	200b883a 	mov	r5,r4
 201f06c:	1809883a 	mov	r4,r3
 201f070:	201e7f00 	call	201e7f0 <tcp_seg_add_chksum>
 201f074:	e0bfeb17 	ldw	r2,-84(fp)
 201f078:	10800343 	ldbu	r2,13(r2)
 201f07c:	10800114 	ori	r2,r2,4
 201f080:	1007883a 	mov	r3,r2
 201f084:	e0bfeb17 	ldw	r2,-84(fp)
 201f088:	10c00345 	stb	r3,13(r2)
        p->len += oversize_used;
 201f08c:	e0bff317 	ldw	r2,-52(fp)
 201f090:	10c0028b 	ldhu	r3,10(r2)
 201f094:	e0bff00b 	ldhu	r2,-64(fp)
 201f098:	1885883a 	add	r2,r3,r2
 201f09c:	1007883a 	mov	r3,r2
 201f0a0:	e0bff317 	ldw	r2,-52(fp)
 201f0a4:	10c0028d 	sth	r3,10(r2)
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 201f0a8:	e0bff317 	ldw	r2,-52(fp)
 201f0ac:	10800017 	ldw	r2,0(r2)
 201f0b0:	e0bff315 	stw	r2,-52(fp)
 201f0b4:	e0bff317 	ldw	r2,-52(fp)
 201f0b8:	103fce1e 	bne	r2,zero,201eff4 <__alt_mem_mem_0+0xfcffeff4>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 201f0bc:	e0bfeb17 	ldw	r2,-84(fp)
 201f0c0:	10c0020b 	ldhu	r3,8(r2)
 201f0c4:	e0bff00b 	ldhu	r2,-64(fp)
 201f0c8:	1885883a 	add	r2,r3,r2
 201f0cc:	1007883a 	mov	r3,r2
 201f0d0:	e0bfeb17 	ldw	r2,-84(fp)
 201f0d4:	10c0020d 	sth	r3,8(r2)
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 201f0d8:	e0fff90b 	ldhu	r3,-28(fp)
 201f0dc:	e0bffc17 	ldw	r2,-16(fp)
 201f0e0:	10c01b8d 	sth	r3,110(r2)
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 201f0e4:	e0bfea17 	ldw	r2,-88(fp)
 201f0e8:	10002126 	beq	r2,zero,201f170 <tcp_write+0x7a4>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 201f0ec:	e0bfeb17 	ldw	r2,-84(fp)
 201f0f0:	10800117 	ldw	r2,4(r2)
 201f0f4:	e17fea17 	ldw	r5,-88(fp)
 201f0f8:	1009883a 	mov	r4,r2
 201f0fc:	201ad5c0 	call	201ad5c <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 201f100:	e0bfeb17 	ldw	r2,-84(fp)
 201f104:	10c0020b 	ldhu	r3,8(r2)
 201f108:	e0bfea17 	ldw	r2,-88(fp)
 201f10c:	1080020b 	ldhu	r2,8(r2)
 201f110:	1885883a 	add	r2,r3,r2
 201f114:	1007883a 	mov	r3,r2
 201f118:	e0bfeb17 	ldw	r2,-84(fp)
 201f11c:	10c0020d 	sth	r3,8(r2)
#if TCP_CHECKSUM_ON_COPY
    if (concat_chksummed) {
 201f120:	e0bff08b 	ldhu	r2,-62(fp)
 201f124:	10001226 	beq	r2,zero,201f170 <tcp_write+0x7a4>
      tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
 201f128:	e0bff98b 	ldhu	r2,-26(fp)
 201f12c:	10ffffcc 	andi	r3,r2,65535
 201f130:	e13ff08b 	ldhu	r4,-62(fp)
 201f134:	e0bfeb17 	ldw	r2,-84(fp)
 201f138:	11400284 	addi	r5,r2,10
 201f13c:	e0bfeb17 	ldw	r2,-84(fp)
 201f140:	10800304 	addi	r2,r2,12
 201f144:	100f883a 	mov	r7,r2
 201f148:	280d883a 	mov	r6,r5
 201f14c:	200b883a 	mov	r5,r4
 201f150:	1809883a 	mov	r4,r3
 201f154:	201e7f00 	call	201e7f0 <tcp_seg_add_chksum>
        &last_unsent->chksum_swapped);
      last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
 201f158:	e0bfeb17 	ldw	r2,-84(fp)
 201f15c:	10800343 	ldbu	r2,13(r2)
 201f160:	10800114 	ori	r2,r2,4
 201f164:	1007883a 	mov	r3,r2
 201f168:	e0bfeb17 	ldw	r2,-84(fp)
 201f16c:	10c00345 	stb	r3,13(r2)

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 201f170:	e0bfeb17 	ldw	r2,-84(fp)
 201f174:	1000041e 	bne	r2,zero,201f188 <tcp_write+0x7bc>
    pcb->unsent = queue;
 201f178:	e0bffc17 	ldw	r2,-16(fp)
 201f17c:	e0ffee17 	ldw	r3,-72(fp)
 201f180:	10c01c15 	stw	r3,112(r2)
 201f184:	00000306 	br	201f194 <tcp_write+0x7c8>
  } else {
    last_unsent->next = queue;
 201f188:	e0bfeb17 	ldw	r2,-84(fp)
 201f18c:	e0ffee17 	ldw	r3,-72(fp)
 201f190:	10c00015 	stw	r3,0(r2)
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 201f194:	e0bffc17 	ldw	r2,-16(fp)
 201f198:	10c01817 	ldw	r3,96(r2)
 201f19c:	e0bffe0b 	ldhu	r2,-8(fp)
 201f1a0:	1887883a 	add	r3,r3,r2
 201f1a4:	e0bffc17 	ldw	r2,-16(fp)
 201f1a8:	10c01815 	stw	r3,96(r2)
  pcb->snd_buf -= len;
 201f1ac:	e0bffc17 	ldw	r2,-16(fp)
 201f1b0:	10c01a8b 	ldhu	r3,106(r2)
 201f1b4:	e0bffe0b 	ldhu	r2,-8(fp)
 201f1b8:	1885c83a 	sub	r2,r3,r2
 201f1bc:	1007883a 	mov	r3,r2
 201f1c0:	e0bffc17 	ldw	r2,-16(fp)
 201f1c4:	10c01a8d 	sth	r3,106(r2)
  pcb->snd_queuelen = queuelen;
 201f1c8:	e0bffc17 	ldw	r2,-16(fp)
 201f1cc:	e0ffef8b 	ldhu	r3,-66(fp)
 201f1d0:	10c01b0d 	sth	r3,108(r2)
    LWIP_ASSERT("tcp_write: valid queue length",
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 201f1d4:	e0bfec17 	ldw	r2,-80(fp)
 201f1d8:	10002126 	beq	r2,zero,201f260 <tcp_write+0x894>
 201f1dc:	e0bfec17 	ldw	r2,-80(fp)
 201f1e0:	10800417 	ldw	r2,16(r2)
 201f1e4:	10001e26 	beq	r2,zero,201f260 <tcp_write+0x894>
 201f1e8:	e0bfff03 	ldbu	r2,-4(fp)
 201f1ec:	1080008c 	andi	r2,r2,2
 201f1f0:	10001b1e 	bne	r2,zero,201f260 <tcp_write+0x894>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 201f1f4:	e0bfec17 	ldw	r2,-80(fp)
 201f1f8:	10800417 	ldw	r2,16(r2)
 201f1fc:	e0ffec17 	ldw	r3,-80(fp)
 201f200:	18c00417 	ldw	r3,16(r3)
 201f204:	19000303 	ldbu	r4,12(r3)
 201f208:	18c00343 	ldbu	r3,13(r3)
 201f20c:	1806923a 	slli	r3,r3,8
 201f210:	1906b03a 	or	r3,r3,r4
 201f214:	18c20014 	ori	r3,r3,2048
 201f218:	180d883a 	mov	r6,r3
 201f21c:	30ffffcc 	andi	r3,r6,65535
 201f220:	19403fcc 	andi	r5,r3,255
 201f224:	10c00303 	ldbu	r3,12(r2)
 201f228:	1806703a 	and	r3,r3,zero
 201f22c:	1809883a 	mov	r4,r3
 201f230:	2807883a 	mov	r3,r5
 201f234:	20c6b03a 	or	r3,r4,r3
 201f238:	10c00305 	stb	r3,12(r2)
 201f23c:	30ffffcc 	andi	r3,r6,65535
 201f240:	1806d23a 	srli	r3,r3,8
 201f244:	197fffcc 	andi	r5,r3,65535
 201f248:	10c00343 	ldbu	r3,13(r2)
 201f24c:	1806703a 	and	r3,r3,zero
 201f250:	1809883a 	mov	r4,r3
 201f254:	2807883a 	mov	r3,r5
 201f258:	20c6b03a 	or	r3,r4,r3
 201f25c:	10c00345 	stb	r3,13(r2)
  }

  return ERR_OK;
 201f260:	0005883a 	mov	r2,zero
 201f264:	00002006 	br	201f2e8 <tcp_write+0x91c>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
 201f268:	0001883a 	nop
 201f26c:	00000706 	br	201f28c <tcp_write+0x8c0>
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
 201f270:	0001883a 	nop
 201f274:	00000506 	br	201f28c <tcp_write+0x8c0>
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
 201f278:	0001883a 	nop
 201f27c:	00000306 	br	201f28c <tcp_write+0x8c0>
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
 201f280:	0001883a 	nop
 201f284:	00000106 	br	201f28c <tcp_write+0x8c0>
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
 201f288:	0001883a 	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 201f28c:	e0bffc17 	ldw	r2,-16(fp)
 201f290:	10c00883 	ldbu	r3,34(r2)
 201f294:	00bfe004 	movi	r2,-128
 201f298:	1884b03a 	or	r2,r3,r2
 201f29c:	1007883a 	mov	r3,r2
 201f2a0:	e0bffc17 	ldw	r2,-16(fp)
 201f2a4:	10c00885 	stb	r3,34(r2)
  TCP_STATS_INC(tcp.memerr);
 201f2a8:	008085f4 	movhi	r2,535
 201f2ac:	10a8bc04 	addi	r2,r2,-23824
 201f2b0:	10804e17 	ldw	r2,312(r2)
 201f2b4:	10c00044 	addi	r3,r2,1
 201f2b8:	008085f4 	movhi	r2,535
 201f2bc:	10a8bc04 	addi	r2,r2,-23824
 201f2c0:	10c04e15 	stw	r3,312(r2)

  if (concat_p != NULL) {
 201f2c4:	e0bfea17 	ldw	r2,-88(fp)
 201f2c8:	10000226 	beq	r2,zero,201f2d4 <tcp_write+0x908>
    pbuf_free(concat_p);
 201f2cc:	e13fea17 	ldw	r4,-88(fp)
 201f2d0:	201ab680 	call	201ab68 <pbuf_free>
  }
  if (queue != NULL) {
 201f2d4:	e0bfee17 	ldw	r2,-72(fp)
 201f2d8:	10000226 	beq	r2,zero,201f2e4 <tcp_write+0x918>
    tcp_segs_free(queue);
 201f2dc:	e13fee17 	ldw	r4,-72(fp)
 201f2e0:	201d3dc0 	call	201d3dc <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 201f2e4:	00bfffc4 	movi	r2,-1
}
 201f2e8:	e037883a 	mov	sp,fp
 201f2ec:	dfc00117 	ldw	ra,4(sp)
 201f2f0:	df000017 	ldw	fp,0(sp)
 201f2f4:	dec00204 	addi	sp,sp,8
 201f2f8:	f800283a 	ret

0201f2fc <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 201f2fc:	defff604 	addi	sp,sp,-40
 201f300:	dfc00915 	stw	ra,36(sp)
 201f304:	df000815 	stw	fp,32(sp)
 201f308:	df000804 	addi	fp,sp,32
 201f30c:	e13ffe15 	stw	r4,-8(fp)
 201f310:	2805883a 	mov	r2,r5
 201f314:	e0bfff05 	stb	r2,-4(fp)
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 201f318:	e03ff905 	stb	zero,-28(fp)
  u8_t optlen = 0;
 201f31c:	e03ffb05 	stb	zero,-20(fp)

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 201f320:	e0bffe17 	ldw	r2,-8(fp)
 201f324:	10801b0b 	ldhu	r2,108(r2)
 201f328:	10bfffcc 	andi	r2,r2,65535
 201f32c:	10800228 	cmpgeui	r2,r2,8
 201f330:	1000051e 	bne	r2,zero,201f348 <tcp_enqueue_flags+0x4c>
 201f334:	e0bffe17 	ldw	r2,-8(fp)
 201f338:	10801b0b 	ldhu	r2,108(r2)
 201f33c:	10bfffcc 	andi	r2,r2,65535
 201f340:	10bfff70 	cmpltui	r2,r2,65533
 201f344:	1000101e 	bne	r2,zero,201f388 <tcp_enqueue_flags+0x8c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
 201f348:	008085f4 	movhi	r2,535
 201f34c:	10a8bc04 	addi	r2,r2,-23824
 201f350:	10804e17 	ldw	r2,312(r2)
 201f354:	10c00044 	addi	r3,r2,1
 201f358:	008085f4 	movhi	r2,535
 201f35c:	10a8bc04 	addi	r2,r2,-23824
 201f360:	10c04e15 	stw	r3,312(r2)
    pcb->flags |= TF_NAGLEMEMERR;
 201f364:	e0bffe17 	ldw	r2,-8(fp)
 201f368:	10c00883 	ldbu	r3,34(r2)
 201f36c:	00bfe004 	movi	r2,-128
 201f370:	1884b03a 	or	r2,r3,r2
 201f374:	1007883a 	mov	r3,r2
 201f378:	e0bffe17 	ldw	r2,-8(fp)
 201f37c:	10c00885 	stb	r3,34(r2)
    return ERR_MEM;
 201f380:	00bfffc4 	movi	r2,-1
 201f384:	00009206 	br	201f5d0 <tcp_enqueue_flags+0x2d4>
  }

  if (flags & TCP_SYN) {
 201f388:	e0bfff03 	ldbu	r2,-4(fp)
 201f38c:	1080008c 	andi	r2,r2,2
 201f390:	10000226 	beq	r2,zero,201f39c <tcp_enqueue_flags+0xa0>
    optflags = TF_SEG_OPTS_MSS;
 201f394:	00800044 	movi	r2,1
 201f398:	e0bff905 	stb	r2,-28(fp)
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
 201f39c:	e0bff903 	ldbu	r2,-28(fp)
 201f3a0:	1080004c 	andi	r2,r2,1
 201f3a4:	10000226 	beq	r2,zero,201f3b0 <tcp_enqueue_flags+0xb4>
 201f3a8:	00c00104 	movi	r3,4
 201f3ac:	00000106 	br	201f3b4 <tcp_enqueue_flags+0xb8>
 201f3b0:	0007883a 	mov	r3,zero
 201f3b4:	e0bff903 	ldbu	r2,-28(fp)
 201f3b8:	1080008c 	andi	r2,r2,2
 201f3bc:	10000226 	beq	r2,zero,201f3c8 <tcp_enqueue_flags+0xcc>
 201f3c0:	00800304 	movi	r2,12
 201f3c4:	00000106 	br	201f3cc <tcp_enqueue_flags+0xd0>
 201f3c8:	0005883a 	mov	r2,zero
 201f3cc:	1885883a 	add	r2,r3,r2
 201f3d0:	e0bffb05 	stb	r2,-20(fp)

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 201f3d4:	e0bffe17 	ldw	r2,-8(fp)
 201f3d8:	10801a8b 	ldhu	r2,106(r2)
 201f3dc:	10bfffcc 	andi	r2,r2,65535
 201f3e0:	1000091e 	bne	r2,zero,201f408 <tcp_enqueue_flags+0x10c>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
 201f3e4:	008085f4 	movhi	r2,535
 201f3e8:	10a8bc04 	addi	r2,r2,-23824
 201f3ec:	10804e17 	ldw	r2,312(r2)
 201f3f0:	10c00044 	addi	r3,r2,1
 201f3f4:	008085f4 	movhi	r2,535
 201f3f8:	10a8bc04 	addi	r2,r2,-23824
 201f3fc:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 201f400:	00bfffc4 	movi	r2,-1
 201f404:	00007206 	br	201f5d0 <tcp_enqueue_flags+0x2d4>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 201f408:	e0bffb03 	ldbu	r2,-20(fp)
 201f40c:	000d883a 	mov	r6,zero
 201f410:	100b883a 	mov	r5,r2
 201f414:	0009883a 	mov	r4,zero
 201f418:	201a3ac0 	call	201a3ac <pbuf_alloc>
 201f41c:	e0bffc15 	stw	r2,-16(fp)
 201f420:	e0bffc17 	ldw	r2,-16(fp)
 201f424:	1000101e 	bne	r2,zero,201f468 <tcp_enqueue_flags+0x16c>
    pcb->flags |= TF_NAGLEMEMERR;
 201f428:	e0bffe17 	ldw	r2,-8(fp)
 201f42c:	10c00883 	ldbu	r3,34(r2)
 201f430:	00bfe004 	movi	r2,-128
 201f434:	1884b03a 	or	r2,r3,r2
 201f438:	1007883a 	mov	r3,r2
 201f43c:	e0bffe17 	ldw	r2,-8(fp)
 201f440:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 201f444:	008085f4 	movhi	r2,535
 201f448:	10a8bc04 	addi	r2,r2,-23824
 201f44c:	10804e17 	ldw	r2,312(r2)
 201f450:	10c00044 	addi	r3,r2,1
 201f454:	008085f4 	movhi	r2,535
 201f458:	10a8bc04 	addi	r2,r2,-23824
 201f45c:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 201f460:	00bfffc4 	movi	r2,-1
 201f464:	00005a06 	br	201f5d0 <tcp_enqueue_flags+0x2d4>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 201f468:	e0ffff03 	ldbu	r3,-4(fp)
 201f46c:	e0bffe17 	ldw	r2,-8(fp)
 201f470:	11001817 	ldw	r4,96(r2)
 201f474:	e0bff903 	ldbu	r2,-28(fp)
 201f478:	d8800015 	stw	r2,0(sp)
 201f47c:	200f883a 	mov	r7,r4
 201f480:	180d883a 	mov	r6,r3
 201f484:	e17ffc17 	ldw	r5,-16(fp)
 201f488:	e13ffe17 	ldw	r4,-8(fp)
 201f48c:	201e3300 	call	201e330 <tcp_create_segment>
 201f490:	e0bffd15 	stw	r2,-12(fp)
 201f494:	e0bffd17 	ldw	r2,-12(fp)
 201f498:	1000101e 	bne	r2,zero,201f4dc <tcp_enqueue_flags+0x1e0>
    pcb->flags |= TF_NAGLEMEMERR;
 201f49c:	e0bffe17 	ldw	r2,-8(fp)
 201f4a0:	10c00883 	ldbu	r3,34(r2)
 201f4a4:	00bfe004 	movi	r2,-128
 201f4a8:	1884b03a 	or	r2,r3,r2
 201f4ac:	1007883a 	mov	r3,r2
 201f4b0:	e0bffe17 	ldw	r2,-8(fp)
 201f4b4:	10c00885 	stb	r3,34(r2)
    TCP_STATS_INC(tcp.memerr);
 201f4b8:	008085f4 	movhi	r2,535
 201f4bc:	10a8bc04 	addi	r2,r2,-23824
 201f4c0:	10804e17 	ldw	r2,312(r2)
 201f4c4:	10c00044 	addi	r3,r2,1
 201f4c8:	008085f4 	movhi	r2,535
 201f4cc:	10a8bc04 	addi	r2,r2,-23824
 201f4d0:	10c04e15 	stw	r3,312(r2)
    return ERR_MEM;
 201f4d4:	00bfffc4 	movi	r2,-1
 201f4d8:	00003d06 	br	201f5d0 <tcp_enqueue_flags+0x2d4>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 201f4dc:	e0bffe17 	ldw	r2,-8(fp)
 201f4e0:	10801c17 	ldw	r2,112(r2)
 201f4e4:	1000041e 	bne	r2,zero,201f4f8 <tcp_enqueue_flags+0x1fc>
    pcb->unsent = seg;
 201f4e8:	e0bffe17 	ldw	r2,-8(fp)
 201f4ec:	e0fffd17 	ldw	r3,-12(fp)
 201f4f0:	10c01c15 	stw	r3,112(r2)
 201f4f4:	00000d06 	br	201f52c <tcp_enqueue_flags+0x230>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 201f4f8:	e0bffe17 	ldw	r2,-8(fp)
 201f4fc:	10801c17 	ldw	r2,112(r2)
 201f500:	e0bffa15 	stw	r2,-24(fp)
 201f504:	00000306 	br	201f514 <tcp_enqueue_flags+0x218>
 201f508:	e0bffa17 	ldw	r2,-24(fp)
 201f50c:	10800017 	ldw	r2,0(r2)
 201f510:	e0bffa15 	stw	r2,-24(fp)
 201f514:	e0bffa17 	ldw	r2,-24(fp)
 201f518:	10800017 	ldw	r2,0(r2)
 201f51c:	103ffa1e 	bne	r2,zero,201f508 <__alt_mem_mem_0+0xfcfff508>
    useg->next = seg;
 201f520:	e0bffa17 	ldw	r2,-24(fp)
 201f524:	e0fffd17 	ldw	r3,-12(fp)
 201f528:	10c00015 	stw	r3,0(r2)
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 201f52c:	e0bffe17 	ldw	r2,-8(fp)
 201f530:	10001b8d 	sth	zero,110(r2)
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 201f534:	e0bfff03 	ldbu	r2,-4(fp)
 201f538:	1080008c 	andi	r2,r2,2
 201f53c:	1000031e 	bne	r2,zero,201f54c <tcp_enqueue_flags+0x250>
 201f540:	e0bfff03 	ldbu	r2,-4(fp)
 201f544:	1080004c 	andi	r2,r2,1
 201f548:	10000b26 	beq	r2,zero,201f578 <tcp_enqueue_flags+0x27c>
    pcb->snd_lbb++;
 201f54c:	e0bffe17 	ldw	r2,-8(fp)
 201f550:	10801817 	ldw	r2,96(r2)
 201f554:	10c00044 	addi	r3,r2,1
 201f558:	e0bffe17 	ldw	r2,-8(fp)
 201f55c:	10c01815 	stw	r3,96(r2)
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 201f560:	e0bffe17 	ldw	r2,-8(fp)
 201f564:	10801a8b 	ldhu	r2,106(r2)
 201f568:	10bfffc4 	addi	r2,r2,-1
 201f56c:	1007883a 	mov	r3,r2
 201f570:	e0bffe17 	ldw	r2,-8(fp)
 201f574:	10c01a8d 	sth	r3,106(r2)
  }
  if (flags & TCP_FIN) {
 201f578:	e0bfff03 	ldbu	r2,-4(fp)
 201f57c:	1080004c 	andi	r2,r2,1
 201f580:	10000626 	beq	r2,zero,201f59c <tcp_enqueue_flags+0x2a0>
    pcb->flags |= TF_FIN;
 201f584:	e0bffe17 	ldw	r2,-8(fp)
 201f588:	10800883 	ldbu	r2,34(r2)
 201f58c:	10800814 	ori	r2,r2,32
 201f590:	1007883a 	mov	r3,r2
 201f594:	e0bffe17 	ldw	r2,-8(fp)
 201f598:	10c00885 	stb	r3,34(r2)
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 201f59c:	e0bffd17 	ldw	r2,-12(fp)
 201f5a0:	10800117 	ldw	r2,4(r2)
 201f5a4:	1009883a 	mov	r4,r2
 201f5a8:	201acac0 	call	201acac <pbuf_clen>
 201f5ac:	1009883a 	mov	r4,r2
 201f5b0:	e0bffe17 	ldw	r2,-8(fp)
 201f5b4:	10c01b0b 	ldhu	r3,108(r2)
 201f5b8:	20803fcc 	andi	r2,r4,255
 201f5bc:	1885883a 	add	r2,r3,r2
 201f5c0:	1007883a 	mov	r3,r2
 201f5c4:	e0bffe17 	ldw	r2,-8(fp)
 201f5c8:	10c01b0d 	sth	r3,108(r2)
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 201f5cc:	0005883a 	mov	r2,zero
}
 201f5d0:	e037883a 	mov	sp,fp
 201f5d4:	dfc00117 	ldw	ra,4(sp)
 201f5d8:	df000017 	ldw	fp,0(sp)
 201f5dc:	dec00204 	addi	sp,sp,8
 201f5e0:	f800283a 	ret

0201f5e4 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 201f5e4:	defff704 	addi	sp,sp,-36
 201f5e8:	dfc00815 	stw	ra,32(sp)
 201f5ec:	df000715 	stw	fp,28(sp)
 201f5f0:	df000704 	addi	fp,sp,28
 201f5f4:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
 201f5f8:	e03ffc05 	stb	zero,-16(fp)
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 201f5fc:	e13ffc03 	ldbu	r4,-16(fp)
 201f600:	e0bfff17 	ldw	r2,-4(fp)
 201f604:	10801517 	ldw	r2,84(r2)
 201f608:	1006d63a 	srli	r3,r2,24
 201f60c:	e0bfff17 	ldw	r2,-4(fp)
 201f610:	10801517 	ldw	r2,84(r2)
 201f614:	1004d23a 	srli	r2,r2,8
 201f618:	10bfc00c 	andi	r2,r2,65280
 201f61c:	1886b03a 	or	r3,r3,r2
 201f620:	e0bfff17 	ldw	r2,-4(fp)
 201f624:	10801517 	ldw	r2,84(r2)
 201f628:	10bfc00c 	andi	r2,r2,65280
 201f62c:	1004923a 	slli	r2,r2,8
 201f630:	1886b03a 	or	r3,r3,r2
 201f634:	e0bfff17 	ldw	r2,-4(fp)
 201f638:	10801517 	ldw	r2,84(r2)
 201f63c:	1004963a 	slli	r2,r2,24
 201f640:	1884b03a 	or	r2,r3,r2
 201f644:	100f883a 	mov	r7,r2
 201f648:	000d883a 	mov	r6,zero
 201f64c:	200b883a 	mov	r5,r4
 201f650:	e13fff17 	ldw	r4,-4(fp)
 201f654:	201de000 	call	201de00 <tcp_output_alloc_header>
 201f658:	e0bffd15 	stw	r2,-12(fp)
  if (p == NULL) {
 201f65c:	e0bffd17 	ldw	r2,-12(fp)
 201f660:	1000021e 	bne	r2,zero,201f66c <tcp_send_empty_ack+0x88>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 201f664:	00bfff84 	movi	r2,-2
 201f668:	00004006 	br	201f76c <tcp_send_empty_ack+0x188>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 201f66c:	e0bffd17 	ldw	r2,-12(fp)
 201f670:	10800117 	ldw	r2,4(r2)
 201f674:	e0bffe15 	stw	r2,-8(fp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 201f678:	e0bfff17 	ldw	r2,-4(fp)
 201f67c:	10c00883 	ldbu	r3,34(r2)
 201f680:	00bfff04 	movi	r2,-4
 201f684:	1884703a 	and	r2,r3,r2
 201f688:	1007883a 	mov	r3,r2
 201f68c:	e0bfff17 	ldw	r2,-4(fp)
 201f690:	10c00885 	stb	r3,34(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 201f694:	e0ffff17 	ldw	r3,-4(fp)
 201f698:	e0bfff17 	ldw	r2,-4(fp)
 201f69c:	11000104 	addi	r4,r2,4
        IP_PROTO_TCP, p->tot_len);
 201f6a0:	e0bffd17 	ldw	r2,-12(fp)
 201f6a4:	1080020b 	ldhu	r2,8(r2)
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 201f6a8:	10bfffcc 	andi	r2,r2,65535
 201f6ac:	d8800015 	stw	r2,0(sp)
 201f6b0:	01c00184 	movi	r7,6
 201f6b4:	200d883a 	mov	r6,r4
 201f6b8:	180b883a 	mov	r5,r3
 201f6bc:	e13ffd17 	ldw	r4,-12(fp)
 201f6c0:	203173c0 	call	203173c <inet_chksum_pseudo>
 201f6c4:	100d883a 	mov	r6,r2
 201f6c8:	e0bffe17 	ldw	r2,-8(fp)
 201f6cc:	30ffffcc 	andi	r3,r6,65535
 201f6d0:	19403fcc 	andi	r5,r3,255
 201f6d4:	10c00403 	ldbu	r3,16(r2)
 201f6d8:	1806703a 	and	r3,r3,zero
 201f6dc:	1809883a 	mov	r4,r3
 201f6e0:	2807883a 	mov	r3,r5
 201f6e4:	20c6b03a 	or	r3,r4,r3
 201f6e8:	10c00405 	stb	r3,16(r2)
 201f6ec:	30ffffcc 	andi	r3,r6,65535
 201f6f0:	1806d23a 	srli	r3,r3,8
 201f6f4:	197fffcc 	andi	r5,r3,65535
 201f6f8:	10c00443 	ldbu	r3,17(r2)
 201f6fc:	1806703a 	and	r3,r3,zero
 201f700:	1809883a 	mov	r4,r3
 201f704:	2807883a 	mov	r3,r5
 201f708:	20c6b03a 	or	r3,r4,r3
 201f70c:	10c00445 	stb	r3,17(r2)
        IP_PROTO_TCP, p->tot_len);
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 201f710:	e13fff17 	ldw	r4,-4(fp)
 201f714:	e0bfff17 	ldw	r2,-4(fp)
 201f718:	11400104 	addi	r5,r2,4
 201f71c:	e0bfff17 	ldw	r2,-4(fp)
 201f720:	10800283 	ldbu	r2,10(r2)
 201f724:	11803fcc 	andi	r6,r2,255
 201f728:	e0bfff17 	ldw	r2,-4(fp)
 201f72c:	10800243 	ldbu	r2,9(r2)
 201f730:	10803fcc 	andi	r2,r2,255
 201f734:	e0ffff17 	ldw	r3,-4(fp)
 201f738:	18c002c4 	addi	r3,r3,11
 201f73c:	d8c00215 	stw	r3,8(sp)
 201f740:	00c00184 	movi	r3,6
 201f744:	d8c00115 	stw	r3,4(sp)
 201f748:	d8800015 	stw	r2,0(sp)
 201f74c:	300f883a 	mov	r7,r6
 201f750:	280d883a 	mov	r6,r5
 201f754:	200b883a 	mov	r5,r4
 201f758:	e13ffd17 	ldw	r4,-12(fp)
 201f75c:	2032a480 	call	2032a48 <ip_output_hinted>
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 201f760:	e13ffd17 	ldw	r4,-12(fp)
 201f764:	201ab680 	call	201ab68 <pbuf_free>

  return ERR_OK;
 201f768:	0005883a 	mov	r2,zero
}
 201f76c:	e037883a 	mov	sp,fp
 201f770:	dfc00117 	ldw	ra,4(sp)
 201f774:	df000017 	ldw	fp,0(sp)
 201f778:	dec00204 	addi	sp,sp,8
 201f77c:	f800283a 	ret

0201f780 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 201f780:	defff804 	addi	sp,sp,-32
 201f784:	dfc00715 	stw	ra,28(sp)
 201f788:	df000615 	stw	fp,24(sp)
 201f78c:	df000604 	addi	fp,sp,24
 201f790:	e13fff15 	stw	r4,-4(fp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 201f794:	d0e82017 	ldw	r3,-24448(gp)
 201f798:	e0bfff17 	ldw	r2,-4(fp)
 201f79c:	1880021e 	bne	r3,r2,201f7a8 <tcp_output+0x28>
    return ERR_OK;
 201f7a0:	0005883a 	mov	r2,zero
 201f7a4:	00029c06 	br	2020218 <tcp_output+0xa98>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 201f7a8:	e0bfff17 	ldw	r2,-4(fp)
 201f7ac:	10c0140b 	ldhu	r3,80(r2)
 201f7b0:	e0bfff17 	ldw	r2,-4(fp)
 201f7b4:	1140190b 	ldhu	r5,100(r2)
 201f7b8:	1809883a 	mov	r4,r3
 201f7bc:	20bfffcc 	andi	r2,r4,65535
 201f7c0:	28ffffcc 	andi	r3,r5,65535
 201f7c4:	1880012e 	bgeu	r3,r2,201f7cc <tcp_output+0x4c>
 201f7c8:	2809883a 	mov	r4,r5
 201f7cc:	20bfffcc 	andi	r2,r4,65535
 201f7d0:	e0bffd15 	stw	r2,-12(fp)

  seg = pcb->unsent;
 201f7d4:	e0bfff17 	ldw	r2,-4(fp)
 201f7d8:	10801c17 	ldw	r2,112(r2)
 201f7dc:	e0bffa15 	stw	r2,-24(fp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 201f7e0:	e0bfff17 	ldw	r2,-4(fp)
 201f7e4:	10800883 	ldbu	r2,34(r2)
 201f7e8:	10803fcc 	andi	r2,r2,255
 201f7ec:	1080008c 	andi	r2,r2,2
 201f7f0:	10004726 	beq	r2,zero,201f910 <tcp_output+0x190>
 201f7f4:	e0bffa17 	ldw	r2,-24(fp)
 201f7f8:	10004226 	beq	r2,zero,201f904 <tcp_output+0x184>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 201f7fc:	e0bffa17 	ldw	r2,-24(fp)
 201f800:	10800417 	ldw	r2,16(r2)
 201f804:	10c00103 	ldbu	r3,4(r2)
 201f808:	11000143 	ldbu	r4,5(r2)
 201f80c:	2008923a 	slli	r4,r4,8
 201f810:	20c6b03a 	or	r3,r4,r3
 201f814:	11000183 	ldbu	r4,6(r2)
 201f818:	2008943a 	slli	r4,r4,16
 201f81c:	20c6b03a 	or	r3,r4,r3
 201f820:	108001c3 	ldbu	r2,7(r2)
 201f824:	1004963a 	slli	r2,r2,24
 201f828:	10c4b03a 	or	r2,r2,r3
 201f82c:	1006d63a 	srli	r3,r2,24
 201f830:	e0bffa17 	ldw	r2,-24(fp)
 201f834:	10800417 	ldw	r2,16(r2)
 201f838:	11000103 	ldbu	r4,4(r2)
 201f83c:	11400143 	ldbu	r5,5(r2)
 201f840:	280a923a 	slli	r5,r5,8
 201f844:	2908b03a 	or	r4,r5,r4
 201f848:	11400183 	ldbu	r5,6(r2)
 201f84c:	280a943a 	slli	r5,r5,16
 201f850:	2908b03a 	or	r4,r5,r4
 201f854:	108001c3 	ldbu	r2,7(r2)
 201f858:	1004963a 	slli	r2,r2,24
 201f85c:	1104b03a 	or	r2,r2,r4
 201f860:	1004d23a 	srli	r2,r2,8
 201f864:	10bfc00c 	andi	r2,r2,65280
 201f868:	1886b03a 	or	r3,r3,r2
 201f86c:	e0bffa17 	ldw	r2,-24(fp)
 201f870:	10800417 	ldw	r2,16(r2)
 201f874:	11000103 	ldbu	r4,4(r2)
 201f878:	11400143 	ldbu	r5,5(r2)
 201f87c:	280a923a 	slli	r5,r5,8
 201f880:	2908b03a 	or	r4,r5,r4
 201f884:	11400183 	ldbu	r5,6(r2)
 201f888:	280a943a 	slli	r5,r5,16
 201f88c:	2908b03a 	or	r4,r5,r4
 201f890:	108001c3 	ldbu	r2,7(r2)
 201f894:	1004963a 	slli	r2,r2,24
 201f898:	1104b03a 	or	r2,r2,r4
 201f89c:	10bfc00c 	andi	r2,r2,65280
 201f8a0:	1004923a 	slli	r2,r2,8
 201f8a4:	1886b03a 	or	r3,r3,r2
 201f8a8:	e0bffa17 	ldw	r2,-24(fp)
 201f8ac:	10800417 	ldw	r2,16(r2)
 201f8b0:	11000103 	ldbu	r4,4(r2)
 201f8b4:	11400143 	ldbu	r5,5(r2)
 201f8b8:	280a923a 	slli	r5,r5,8
 201f8bc:	2908b03a 	or	r4,r5,r4
 201f8c0:	11400183 	ldbu	r5,6(r2)
 201f8c4:	280a943a 	slli	r5,r5,16
 201f8c8:	2908b03a 	or	r4,r5,r4
 201f8cc:	108001c3 	ldbu	r2,7(r2)
 201f8d0:	1004963a 	slli	r2,r2,24
 201f8d4:	1104b03a 	or	r2,r2,r4
 201f8d8:	1004963a 	slli	r2,r2,24
 201f8dc:	1886b03a 	or	r3,r3,r2
 201f8e0:	e0bfff17 	ldw	r2,-4(fp)
 201f8e4:	10801317 	ldw	r2,76(r2)
 201f8e8:	1887c83a 	sub	r3,r3,r2
 201f8ec:	e0bffa17 	ldw	r2,-24(fp)
 201f8f0:	1080020b 	ldhu	r2,8(r2)
 201f8f4:	10bfffcc 	andi	r2,r2,65535
 201f8f8:	1885883a 	add	r2,r3,r2
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 201f8fc:	e0fffd17 	ldw	r3,-12(fp)
 201f900:	1880032e 	bgeu	r3,r2,201f910 <tcp_output+0x190>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 201f904:	e13fff17 	ldw	r4,-4(fp)
 201f908:	201f5e40 	call	201f5e4 <tcp_send_empty_ack>
 201f90c:	00024206 	br	2020218 <tcp_output+0xa98>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 201f910:	e0bfff17 	ldw	r2,-4(fp)
 201f914:	10801d17 	ldw	r2,116(r2)
 201f918:	e0bffb15 	stw	r2,-20(fp)
  if (useg != NULL) {
 201f91c:	e0bffb17 	ldw	r2,-20(fp)
 201f920:	1001eb26 	beq	r2,zero,20200d0 <tcp_output+0x950>
    for (; useg->next != NULL; useg = useg->next);
 201f924:	00000306 	br	201f934 <tcp_output+0x1b4>
 201f928:	e0bffb17 	ldw	r2,-20(fp)
 201f92c:	10800017 	ldw	r2,0(r2)
 201f930:	e0bffb15 	stw	r2,-20(fp)
 201f934:	e0bffb17 	ldw	r2,-20(fp)
 201f938:	10800017 	ldw	r2,0(r2)
 201f93c:	103ffa1e 	bne	r2,zero,201f928 <__alt_mem_mem_0+0xfcfff928>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 201f940:	0001e306 	br	20200d0 <tcp_output+0x950>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 201f944:	e0bfff17 	ldw	r2,-4(fp)
 201f948:	10801d17 	ldw	r2,116(r2)
 201f94c:	10001d26 	beq	r2,zero,201f9c4 <tcp_output+0x244>
 201f950:	e0bfff17 	ldw	r2,-4(fp)
 201f954:	10800883 	ldbu	r2,34(r2)
 201f958:	10803fcc 	andi	r2,r2,255
 201f95c:	1080110c 	andi	r2,r2,68
 201f960:	1000181e 	bne	r2,zero,201f9c4 <tcp_output+0x244>
 201f964:	e0bfff17 	ldw	r2,-4(fp)
 201f968:	10801c17 	ldw	r2,112(r2)
 201f96c:	10000c26 	beq	r2,zero,201f9a0 <tcp_output+0x220>
 201f970:	e0bfff17 	ldw	r2,-4(fp)
 201f974:	10801c17 	ldw	r2,112(r2)
 201f978:	10800017 	ldw	r2,0(r2)
 201f97c:	1000111e 	bne	r2,zero,201f9c4 <tcp_output+0x244>
 201f980:	e0bfff17 	ldw	r2,-4(fp)
 201f984:	10801c17 	ldw	r2,112(r2)
 201f988:	10c0020b 	ldhu	r3,8(r2)
 201f98c:	e0bfff17 	ldw	r2,-4(fp)
 201f990:	10800e8b 	ldhu	r2,58(r2)
 201f994:	18ffffcc 	andi	r3,r3,65535
 201f998:	10bfffcc 	andi	r2,r2,65535
 201f99c:	1880092e 	bgeu	r3,r2,201f9c4 <tcp_output+0x244>
 201f9a0:	e0bfff17 	ldw	r2,-4(fp)
 201f9a4:	10801a8b 	ldhu	r2,106(r2)
 201f9a8:	10bfffcc 	andi	r2,r2,65535
 201f9ac:	10000526 	beq	r2,zero,201f9c4 <tcp_output+0x244>
 201f9b0:	e0bfff17 	ldw	r2,-4(fp)
 201f9b4:	10801b0b 	ldhu	r2,108(r2)
 201f9b8:	10bfffcc 	andi	r2,r2,65535
 201f9bc:	10800230 	cmpltui	r2,r2,8
 201f9c0:	1000021e 	bne	r2,zero,201f9cc <tcp_output+0x24c>
 201f9c4:	00800044 	movi	r2,1
 201f9c8:	00000106 	br	201f9d0 <tcp_output+0x250>
 201f9cc:	0005883a 	mov	r2,zero
 201f9d0:	1000051e 	bne	r2,zero,201f9e8 <tcp_output+0x268>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
 201f9d4:	e0bfff17 	ldw	r2,-4(fp)
 201f9d8:	10800883 	ldbu	r2,34(r2)
 201f9dc:	10803fcc 	andi	r2,r2,255
 201f9e0:	1080280c 	andi	r2,r2,160
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 201f9e4:	1001ff26 	beq	r2,zero,20201e4 <tcp_output+0xa64>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 201f9e8:	e0bffa17 	ldw	r2,-24(fp)
 201f9ec:	10c00017 	ldw	r3,0(r2)
 201f9f0:	e0bfff17 	ldw	r2,-4(fp)
 201f9f4:	10c01c15 	stw	r3,112(r2)

    if (pcb->state != SYN_SENT) {
 201f9f8:	e0bfff17 	ldw	r2,-4(fp)
 201f9fc:	10800617 	ldw	r2,24(r2)
 201fa00:	108000a0 	cmpeqi	r2,r2,2
 201fa04:	1000221e 	bne	r2,zero,201fa90 <tcp_output+0x310>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 201fa08:	e0bffa17 	ldw	r2,-24(fp)
 201fa0c:	10800417 	ldw	r2,16(r2)
 201fa10:	e0fffa17 	ldw	r3,-24(fp)
 201fa14:	18c00417 	ldw	r3,16(r3)
 201fa18:	19000303 	ldbu	r4,12(r3)
 201fa1c:	18c00343 	ldbu	r3,13(r3)
 201fa20:	1806923a 	slli	r3,r3,8
 201fa24:	1906b03a 	or	r3,r3,r4
 201fa28:	18c40014 	ori	r3,r3,4096
 201fa2c:	180d883a 	mov	r6,r3
 201fa30:	30ffffcc 	andi	r3,r6,65535
 201fa34:	19403fcc 	andi	r5,r3,255
 201fa38:	10c00303 	ldbu	r3,12(r2)
 201fa3c:	1806703a 	and	r3,r3,zero
 201fa40:	1809883a 	mov	r4,r3
 201fa44:	2807883a 	mov	r3,r5
 201fa48:	20c6b03a 	or	r3,r4,r3
 201fa4c:	10c00305 	stb	r3,12(r2)
 201fa50:	30ffffcc 	andi	r3,r6,65535
 201fa54:	1806d23a 	srli	r3,r3,8
 201fa58:	197fffcc 	andi	r5,r3,65535
 201fa5c:	10c00343 	ldbu	r3,13(r2)
 201fa60:	1806703a 	and	r3,r3,zero
 201fa64:	1809883a 	mov	r4,r3
 201fa68:	2807883a 	mov	r3,r5
 201fa6c:	20c6b03a 	or	r3,r4,r3
 201fa70:	10c00345 	stb	r3,13(r2)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 201fa74:	e0bfff17 	ldw	r2,-4(fp)
 201fa78:	10c00883 	ldbu	r3,34(r2)
 201fa7c:	00bfff04 	movi	r2,-4
 201fa80:	1884703a 	and	r2,r3,r2
 201fa84:	1007883a 	mov	r3,r2
 201fa88:	e0bfff17 	ldw	r2,-4(fp)
 201fa8c:	10c00885 	stb	r3,34(r2)
    }

    tcp_output_segment(seg, pcb);
 201fa90:	e17fff17 	ldw	r5,-4(fp)
 201fa94:	e13ffa17 	ldw	r4,-24(fp)
 201fa98:	202022c0 	call	202022c <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 201fa9c:	e0bffa17 	ldw	r2,-24(fp)
 201faa0:	10800417 	ldw	r2,16(r2)
 201faa4:	10c00103 	ldbu	r3,4(r2)
 201faa8:	11000143 	ldbu	r4,5(r2)
 201faac:	2008923a 	slli	r4,r4,8
 201fab0:	20c6b03a 	or	r3,r4,r3
 201fab4:	11000183 	ldbu	r4,6(r2)
 201fab8:	2008943a 	slli	r4,r4,16
 201fabc:	20c6b03a 	or	r3,r4,r3
 201fac0:	108001c3 	ldbu	r2,7(r2)
 201fac4:	1004963a 	slli	r2,r2,24
 201fac8:	10c4b03a 	or	r2,r2,r3
 201facc:	1006d63a 	srli	r3,r2,24
 201fad0:	e0bffa17 	ldw	r2,-24(fp)
 201fad4:	10800417 	ldw	r2,16(r2)
 201fad8:	11000103 	ldbu	r4,4(r2)
 201fadc:	11400143 	ldbu	r5,5(r2)
 201fae0:	280a923a 	slli	r5,r5,8
 201fae4:	2908b03a 	or	r4,r5,r4
 201fae8:	11400183 	ldbu	r5,6(r2)
 201faec:	280a943a 	slli	r5,r5,16
 201faf0:	2908b03a 	or	r4,r5,r4
 201faf4:	108001c3 	ldbu	r2,7(r2)
 201faf8:	1004963a 	slli	r2,r2,24
 201fafc:	1104b03a 	or	r2,r2,r4
 201fb00:	1004d23a 	srli	r2,r2,8
 201fb04:	10bfc00c 	andi	r2,r2,65280
 201fb08:	1886b03a 	or	r3,r3,r2
 201fb0c:	e0bffa17 	ldw	r2,-24(fp)
 201fb10:	10800417 	ldw	r2,16(r2)
 201fb14:	11000103 	ldbu	r4,4(r2)
 201fb18:	11400143 	ldbu	r5,5(r2)
 201fb1c:	280a923a 	slli	r5,r5,8
 201fb20:	2908b03a 	or	r4,r5,r4
 201fb24:	11400183 	ldbu	r5,6(r2)
 201fb28:	280a943a 	slli	r5,r5,16
 201fb2c:	2908b03a 	or	r4,r5,r4
 201fb30:	108001c3 	ldbu	r2,7(r2)
 201fb34:	1004963a 	slli	r2,r2,24
 201fb38:	1104b03a 	or	r2,r2,r4
 201fb3c:	10bfc00c 	andi	r2,r2,65280
 201fb40:	1004923a 	slli	r2,r2,8
 201fb44:	1886b03a 	or	r3,r3,r2
 201fb48:	e0bffa17 	ldw	r2,-24(fp)
 201fb4c:	10800417 	ldw	r2,16(r2)
 201fb50:	11000103 	ldbu	r4,4(r2)
 201fb54:	11400143 	ldbu	r5,5(r2)
 201fb58:	280a923a 	slli	r5,r5,8
 201fb5c:	2908b03a 	or	r4,r5,r4
 201fb60:	11400183 	ldbu	r5,6(r2)
 201fb64:	280a943a 	slli	r5,r5,16
 201fb68:	2908b03a 	or	r4,r5,r4
 201fb6c:	108001c3 	ldbu	r2,7(r2)
 201fb70:	1004963a 	slli	r2,r2,24
 201fb74:	1104b03a 	or	r2,r2,r4
 201fb78:	1004963a 	slli	r2,r2,24
 201fb7c:	1886b03a 	or	r3,r3,r2
 201fb80:	e0bffa17 	ldw	r2,-24(fp)
 201fb84:	1080020b 	ldhu	r2,8(r2)
 201fb88:	113fffcc 	andi	r4,r2,65535
 201fb8c:	e0bffa17 	ldw	r2,-24(fp)
 201fb90:	10800417 	ldw	r2,16(r2)
 201fb94:	11400303 	ldbu	r5,12(r2)
 201fb98:	10800343 	ldbu	r2,13(r2)
 201fb9c:	1004923a 	slli	r2,r2,8
 201fba0:	1144b03a 	or	r2,r2,r5
 201fba4:	10bfffcc 	andi	r2,r2,65535
 201fba8:	1004d23a 	srli	r2,r2,8
 201fbac:	117fffcc 	andi	r5,r2,65535
 201fbb0:	e0bffa17 	ldw	r2,-24(fp)
 201fbb4:	10800417 	ldw	r2,16(r2)
 201fbb8:	11800303 	ldbu	r6,12(r2)
 201fbbc:	10800343 	ldbu	r2,13(r2)
 201fbc0:	1004923a 	slli	r2,r2,8
 201fbc4:	1184b03a 	or	r2,r2,r6
 201fbc8:	10bfffcc 	andi	r2,r2,65535
 201fbcc:	1004923a 	slli	r2,r2,8
 201fbd0:	10bfffcc 	andi	r2,r2,65535
 201fbd4:	2884b03a 	or	r2,r5,r2
 201fbd8:	108000cc 	andi	r2,r2,3
 201fbdc:	1004c03a 	cmpne	r2,r2,zero
 201fbe0:	10803fcc 	andi	r2,r2,255
 201fbe4:	2085883a 	add	r2,r4,r2
 201fbe8:	1885883a 	add	r2,r3,r2
 201fbec:	e0bffe15 	stw	r2,-8(fp)
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 201fbf0:	e0bfff17 	ldw	r2,-4(fp)
 201fbf4:	10c01517 	ldw	r3,84(r2)
 201fbf8:	e0bffe17 	ldw	r2,-8(fp)
 201fbfc:	1885c83a 	sub	r2,r3,r2
 201fc00:	1000030e 	bge	r2,zero,201fc10 <tcp_output+0x490>
      pcb->snd_nxt = snd_nxt;
 201fc04:	e0bfff17 	ldw	r2,-4(fp)
 201fc08:	e0fffe17 	ldw	r3,-8(fp)
 201fc0c:	10c01515 	stw	r3,84(r2)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 201fc10:	e0bffa17 	ldw	r2,-24(fp)
 201fc14:	1080020b 	ldhu	r2,8(r2)
 201fc18:	10ffffcc 	andi	r3,r2,65535
 201fc1c:	e0bffa17 	ldw	r2,-24(fp)
 201fc20:	10800417 	ldw	r2,16(r2)
 201fc24:	11000303 	ldbu	r4,12(r2)
 201fc28:	10800343 	ldbu	r2,13(r2)
 201fc2c:	1004923a 	slli	r2,r2,8
 201fc30:	1104b03a 	or	r2,r2,r4
 201fc34:	10bfffcc 	andi	r2,r2,65535
 201fc38:	1004d23a 	srli	r2,r2,8
 201fc3c:	113fffcc 	andi	r4,r2,65535
 201fc40:	e0bffa17 	ldw	r2,-24(fp)
 201fc44:	10800417 	ldw	r2,16(r2)
 201fc48:	11400303 	ldbu	r5,12(r2)
 201fc4c:	10800343 	ldbu	r2,13(r2)
 201fc50:	1004923a 	slli	r2,r2,8
 201fc54:	1144b03a 	or	r2,r2,r5
 201fc58:	10bfffcc 	andi	r2,r2,65535
 201fc5c:	1004923a 	slli	r2,r2,8
 201fc60:	10bfffcc 	andi	r2,r2,65535
 201fc64:	2084b03a 	or	r2,r4,r2
 201fc68:	108000cc 	andi	r2,r2,3
 201fc6c:	1004c03a 	cmpne	r2,r2,zero
 201fc70:	10803fcc 	andi	r2,r2,255
 201fc74:	1885883a 	add	r2,r3,r2
 201fc78:	0081100e 	bge	zero,r2,20200bc <tcp_output+0x93c>
      seg->next = NULL;
 201fc7c:	e0bffa17 	ldw	r2,-24(fp)
 201fc80:	10000015 	stw	zero,0(r2)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 201fc84:	e0bfff17 	ldw	r2,-4(fp)
 201fc88:	10801d17 	ldw	r2,116(r2)
 201fc8c:	1000061e 	bne	r2,zero,201fca8 <tcp_output+0x528>
        pcb->unacked = seg;
 201fc90:	e0bfff17 	ldw	r2,-4(fp)
 201fc94:	e0fffa17 	ldw	r3,-24(fp)
 201fc98:	10c01d15 	stw	r3,116(r2)
        useg = seg;
 201fc9c:	e0bffa17 	ldw	r2,-24(fp)
 201fca0:	e0bffb15 	stw	r2,-20(fp)
 201fca4:	00010706 	br	20200c4 <tcp_output+0x944>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 201fca8:	e0bffa17 	ldw	r2,-24(fp)
 201fcac:	10800417 	ldw	r2,16(r2)
 201fcb0:	10c00103 	ldbu	r3,4(r2)
 201fcb4:	11000143 	ldbu	r4,5(r2)
 201fcb8:	2008923a 	slli	r4,r4,8
 201fcbc:	20c6b03a 	or	r3,r4,r3
 201fcc0:	11000183 	ldbu	r4,6(r2)
 201fcc4:	2008943a 	slli	r4,r4,16
 201fcc8:	20c6b03a 	or	r3,r4,r3
 201fccc:	108001c3 	ldbu	r2,7(r2)
 201fcd0:	1004963a 	slli	r2,r2,24
 201fcd4:	10c4b03a 	or	r2,r2,r3
 201fcd8:	1006d63a 	srli	r3,r2,24
 201fcdc:	e0bffa17 	ldw	r2,-24(fp)
 201fce0:	10800417 	ldw	r2,16(r2)
 201fce4:	11000103 	ldbu	r4,4(r2)
 201fce8:	11400143 	ldbu	r5,5(r2)
 201fcec:	280a923a 	slli	r5,r5,8
 201fcf0:	2908b03a 	or	r4,r5,r4
 201fcf4:	11400183 	ldbu	r5,6(r2)
 201fcf8:	280a943a 	slli	r5,r5,16
 201fcfc:	2908b03a 	or	r4,r5,r4
 201fd00:	108001c3 	ldbu	r2,7(r2)
 201fd04:	1004963a 	slli	r2,r2,24
 201fd08:	1104b03a 	or	r2,r2,r4
 201fd0c:	1004d23a 	srli	r2,r2,8
 201fd10:	10bfc00c 	andi	r2,r2,65280
 201fd14:	1886b03a 	or	r3,r3,r2
 201fd18:	e0bffa17 	ldw	r2,-24(fp)
 201fd1c:	10800417 	ldw	r2,16(r2)
 201fd20:	11000103 	ldbu	r4,4(r2)
 201fd24:	11400143 	ldbu	r5,5(r2)
 201fd28:	280a923a 	slli	r5,r5,8
 201fd2c:	2908b03a 	or	r4,r5,r4
 201fd30:	11400183 	ldbu	r5,6(r2)
 201fd34:	280a943a 	slli	r5,r5,16
 201fd38:	2908b03a 	or	r4,r5,r4
 201fd3c:	108001c3 	ldbu	r2,7(r2)
 201fd40:	1004963a 	slli	r2,r2,24
 201fd44:	1104b03a 	or	r2,r2,r4
 201fd48:	10bfc00c 	andi	r2,r2,65280
 201fd4c:	1004923a 	slli	r2,r2,8
 201fd50:	1886b03a 	or	r3,r3,r2
 201fd54:	e0bffa17 	ldw	r2,-24(fp)
 201fd58:	10800417 	ldw	r2,16(r2)
 201fd5c:	11000103 	ldbu	r4,4(r2)
 201fd60:	11400143 	ldbu	r5,5(r2)
 201fd64:	280a923a 	slli	r5,r5,8
 201fd68:	2908b03a 	or	r4,r5,r4
 201fd6c:	11400183 	ldbu	r5,6(r2)
 201fd70:	280a943a 	slli	r5,r5,16
 201fd74:	2908b03a 	or	r4,r5,r4
 201fd78:	108001c3 	ldbu	r2,7(r2)
 201fd7c:	1004963a 	slli	r2,r2,24
 201fd80:	1104b03a 	or	r2,r2,r4
 201fd84:	1004963a 	slli	r2,r2,24
 201fd88:	1886b03a 	or	r3,r3,r2
 201fd8c:	e0bffb17 	ldw	r2,-20(fp)
 201fd90:	10800417 	ldw	r2,16(r2)
 201fd94:	11000103 	ldbu	r4,4(r2)
 201fd98:	11400143 	ldbu	r5,5(r2)
 201fd9c:	280a923a 	slli	r5,r5,8
 201fda0:	2908b03a 	or	r4,r5,r4
 201fda4:	11400183 	ldbu	r5,6(r2)
 201fda8:	280a943a 	slli	r5,r5,16
 201fdac:	2908b03a 	or	r4,r5,r4
 201fdb0:	108001c3 	ldbu	r2,7(r2)
 201fdb4:	1004963a 	slli	r2,r2,24
 201fdb8:	1104b03a 	or	r2,r2,r4
 201fdbc:	1008d63a 	srli	r4,r2,24
 201fdc0:	e0bffb17 	ldw	r2,-20(fp)
 201fdc4:	10800417 	ldw	r2,16(r2)
 201fdc8:	11400103 	ldbu	r5,4(r2)
 201fdcc:	11800143 	ldbu	r6,5(r2)
 201fdd0:	300c923a 	slli	r6,r6,8
 201fdd4:	314ab03a 	or	r5,r6,r5
 201fdd8:	11800183 	ldbu	r6,6(r2)
 201fddc:	300c943a 	slli	r6,r6,16
 201fde0:	314ab03a 	or	r5,r6,r5
 201fde4:	108001c3 	ldbu	r2,7(r2)
 201fde8:	1004963a 	slli	r2,r2,24
 201fdec:	1144b03a 	or	r2,r2,r5
 201fdf0:	1004d23a 	srli	r2,r2,8
 201fdf4:	10bfc00c 	andi	r2,r2,65280
 201fdf8:	2088b03a 	or	r4,r4,r2
 201fdfc:	e0bffb17 	ldw	r2,-20(fp)
 201fe00:	10800417 	ldw	r2,16(r2)
 201fe04:	11400103 	ldbu	r5,4(r2)
 201fe08:	11800143 	ldbu	r6,5(r2)
 201fe0c:	300c923a 	slli	r6,r6,8
 201fe10:	314ab03a 	or	r5,r6,r5
 201fe14:	11800183 	ldbu	r6,6(r2)
 201fe18:	300c943a 	slli	r6,r6,16
 201fe1c:	314ab03a 	or	r5,r6,r5
 201fe20:	108001c3 	ldbu	r2,7(r2)
 201fe24:	1004963a 	slli	r2,r2,24
 201fe28:	1144b03a 	or	r2,r2,r5
 201fe2c:	10bfc00c 	andi	r2,r2,65280
 201fe30:	1004923a 	slli	r2,r2,8
 201fe34:	2088b03a 	or	r4,r4,r2
 201fe38:	e0bffb17 	ldw	r2,-20(fp)
 201fe3c:	10800417 	ldw	r2,16(r2)
 201fe40:	11400103 	ldbu	r5,4(r2)
 201fe44:	11800143 	ldbu	r6,5(r2)
 201fe48:	300c923a 	slli	r6,r6,8
 201fe4c:	314ab03a 	or	r5,r6,r5
 201fe50:	11800183 	ldbu	r6,6(r2)
 201fe54:	300c943a 	slli	r6,r6,16
 201fe58:	314ab03a 	or	r5,r6,r5
 201fe5c:	108001c3 	ldbu	r2,7(r2)
 201fe60:	1004963a 	slli	r2,r2,24
 201fe64:	1144b03a 	or	r2,r2,r5
 201fe68:	1004963a 	slli	r2,r2,24
 201fe6c:	2084b03a 	or	r2,r4,r2
 201fe70:	1885c83a 	sub	r2,r3,r2
 201fe74:	10008a0e 	bge	r2,zero,20200a0 <tcp_output+0x920>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 201fe78:	e0bfff17 	ldw	r2,-4(fp)
 201fe7c:	10801d04 	addi	r2,r2,116
 201fe80:	e0bffc15 	stw	r2,-16(fp)
          while (*cur_seg &&
 201fe84:	00000306 	br	201fe94 <tcp_output+0x714>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 201fe88:	e0bffc17 	ldw	r2,-16(fp)
 201fe8c:	10800017 	ldw	r2,0(r2)
 201fe90:	e0bffc15 	stw	r2,-16(fp)
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 201fe94:	e0bffc17 	ldw	r2,-16(fp)
 201fe98:	10800017 	ldw	r2,0(r2)
 201fe9c:	10007826 	beq	r2,zero,2020080 <tcp_output+0x900>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 201fea0:	e0bffc17 	ldw	r2,-16(fp)
 201fea4:	10800017 	ldw	r2,0(r2)
 201fea8:	10800417 	ldw	r2,16(r2)
 201feac:	10c00103 	ldbu	r3,4(r2)
 201feb0:	11000143 	ldbu	r4,5(r2)
 201feb4:	2008923a 	slli	r4,r4,8
 201feb8:	20c6b03a 	or	r3,r4,r3
 201febc:	11000183 	ldbu	r4,6(r2)
 201fec0:	2008943a 	slli	r4,r4,16
 201fec4:	20c6b03a 	or	r3,r4,r3
 201fec8:	108001c3 	ldbu	r2,7(r2)
 201fecc:	1004963a 	slli	r2,r2,24
 201fed0:	10c4b03a 	or	r2,r2,r3
 201fed4:	1006d63a 	srli	r3,r2,24
 201fed8:	e0bffc17 	ldw	r2,-16(fp)
 201fedc:	10800017 	ldw	r2,0(r2)
 201fee0:	10800417 	ldw	r2,16(r2)
 201fee4:	11000103 	ldbu	r4,4(r2)
 201fee8:	11400143 	ldbu	r5,5(r2)
 201feec:	280a923a 	slli	r5,r5,8
 201fef0:	2908b03a 	or	r4,r5,r4
 201fef4:	11400183 	ldbu	r5,6(r2)
 201fef8:	280a943a 	slli	r5,r5,16
 201fefc:	2908b03a 	or	r4,r5,r4
 201ff00:	108001c3 	ldbu	r2,7(r2)
 201ff04:	1004963a 	slli	r2,r2,24
 201ff08:	1104b03a 	or	r2,r2,r4
 201ff0c:	1004d23a 	srli	r2,r2,8
 201ff10:	10bfc00c 	andi	r2,r2,65280
 201ff14:	1886b03a 	or	r3,r3,r2
 201ff18:	e0bffc17 	ldw	r2,-16(fp)
 201ff1c:	10800017 	ldw	r2,0(r2)
 201ff20:	10800417 	ldw	r2,16(r2)
 201ff24:	11000103 	ldbu	r4,4(r2)
 201ff28:	11400143 	ldbu	r5,5(r2)
 201ff2c:	280a923a 	slli	r5,r5,8
 201ff30:	2908b03a 	or	r4,r5,r4
 201ff34:	11400183 	ldbu	r5,6(r2)
 201ff38:	280a943a 	slli	r5,r5,16
 201ff3c:	2908b03a 	or	r4,r5,r4
 201ff40:	108001c3 	ldbu	r2,7(r2)
 201ff44:	1004963a 	slli	r2,r2,24
 201ff48:	1104b03a 	or	r2,r2,r4
 201ff4c:	10bfc00c 	andi	r2,r2,65280
 201ff50:	1004923a 	slli	r2,r2,8
 201ff54:	1886b03a 	or	r3,r3,r2
 201ff58:	e0bffc17 	ldw	r2,-16(fp)
 201ff5c:	10800017 	ldw	r2,0(r2)
 201ff60:	10800417 	ldw	r2,16(r2)
 201ff64:	11000103 	ldbu	r4,4(r2)
 201ff68:	11400143 	ldbu	r5,5(r2)
 201ff6c:	280a923a 	slli	r5,r5,8
 201ff70:	2908b03a 	or	r4,r5,r4
 201ff74:	11400183 	ldbu	r5,6(r2)
 201ff78:	280a943a 	slli	r5,r5,16
 201ff7c:	2908b03a 	or	r4,r5,r4
 201ff80:	108001c3 	ldbu	r2,7(r2)
 201ff84:	1004963a 	slli	r2,r2,24
 201ff88:	1104b03a 	or	r2,r2,r4
 201ff8c:	1004963a 	slli	r2,r2,24
 201ff90:	1886b03a 	or	r3,r3,r2
 201ff94:	e0bffa17 	ldw	r2,-24(fp)
 201ff98:	10800417 	ldw	r2,16(r2)
 201ff9c:	11000103 	ldbu	r4,4(r2)
 201ffa0:	11400143 	ldbu	r5,5(r2)
 201ffa4:	280a923a 	slli	r5,r5,8
 201ffa8:	2908b03a 	or	r4,r5,r4
 201ffac:	11400183 	ldbu	r5,6(r2)
 201ffb0:	280a943a 	slli	r5,r5,16
 201ffb4:	2908b03a 	or	r4,r5,r4
 201ffb8:	108001c3 	ldbu	r2,7(r2)
 201ffbc:	1004963a 	slli	r2,r2,24
 201ffc0:	1104b03a 	or	r2,r2,r4
 201ffc4:	1008d63a 	srli	r4,r2,24
 201ffc8:	e0bffa17 	ldw	r2,-24(fp)
 201ffcc:	10800417 	ldw	r2,16(r2)
 201ffd0:	11400103 	ldbu	r5,4(r2)
 201ffd4:	11800143 	ldbu	r6,5(r2)
 201ffd8:	300c923a 	slli	r6,r6,8
 201ffdc:	314ab03a 	or	r5,r6,r5
 201ffe0:	11800183 	ldbu	r6,6(r2)
 201ffe4:	300c943a 	slli	r6,r6,16
 201ffe8:	314ab03a 	or	r5,r6,r5
 201ffec:	108001c3 	ldbu	r2,7(r2)
 201fff0:	1004963a 	slli	r2,r2,24
 201fff4:	1144b03a 	or	r2,r2,r5
 201fff8:	1004d23a 	srli	r2,r2,8
 201fffc:	10bfc00c 	andi	r2,r2,65280
 2020000:	2088b03a 	or	r4,r4,r2
 2020004:	e0bffa17 	ldw	r2,-24(fp)
 2020008:	10800417 	ldw	r2,16(r2)
 202000c:	11400103 	ldbu	r5,4(r2)
 2020010:	11800143 	ldbu	r6,5(r2)
 2020014:	300c923a 	slli	r6,r6,8
 2020018:	314ab03a 	or	r5,r6,r5
 202001c:	11800183 	ldbu	r6,6(r2)
 2020020:	300c943a 	slli	r6,r6,16
 2020024:	314ab03a 	or	r5,r6,r5
 2020028:	108001c3 	ldbu	r2,7(r2)
 202002c:	1004963a 	slli	r2,r2,24
 2020030:	1144b03a 	or	r2,r2,r5
 2020034:	10bfc00c 	andi	r2,r2,65280
 2020038:	1004923a 	slli	r2,r2,8
 202003c:	2088b03a 	or	r4,r4,r2
 2020040:	e0bffa17 	ldw	r2,-24(fp)
 2020044:	10800417 	ldw	r2,16(r2)
 2020048:	11400103 	ldbu	r5,4(r2)
 202004c:	11800143 	ldbu	r6,5(r2)
 2020050:	300c923a 	slli	r6,r6,8
 2020054:	314ab03a 	or	r5,r6,r5
 2020058:	11800183 	ldbu	r6,6(r2)
 202005c:	300c943a 	slli	r6,r6,16
 2020060:	314ab03a 	or	r5,r6,r5
 2020064:	108001c3 	ldbu	r2,7(r2)
 2020068:	1004963a 	slli	r2,r2,24
 202006c:	1144b03a 	or	r2,r2,r5
 2020070:	1004963a 	slli	r2,r2,24
 2020074:	2084b03a 	or	r2,r4,r2
 2020078:	1885c83a 	sub	r2,r3,r2
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 202007c:	103f8216 	blt	r2,zero,201fe88 <__alt_mem_mem_0+0xfcfffe88>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 2020080:	e0bffc17 	ldw	r2,-16(fp)
 2020084:	10c00017 	ldw	r3,0(r2)
 2020088:	e0bffa17 	ldw	r2,-24(fp)
 202008c:	10c00015 	stw	r3,0(r2)
          (*cur_seg) = seg;
 2020090:	e0bffc17 	ldw	r2,-16(fp)
 2020094:	e0fffa17 	ldw	r3,-24(fp)
 2020098:	10c00015 	stw	r3,0(r2)
 202009c:	00000906 	br	20200c4 <tcp_output+0x944>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 20200a0:	e0bffb17 	ldw	r2,-20(fp)
 20200a4:	e0fffa17 	ldw	r3,-24(fp)
 20200a8:	10c00015 	stw	r3,0(r2)
          useg = useg->next;
 20200ac:	e0bffb17 	ldw	r2,-20(fp)
 20200b0:	10800017 	ldw	r2,0(r2)
 20200b4:	e0bffb15 	stw	r2,-20(fp)
 20200b8:	00000206 	br	20200c4 <tcp_output+0x944>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 20200bc:	e13ffa17 	ldw	r4,-24(fp)
 20200c0:	201d4300 	call	201d430 <tcp_seg_free>
    }
    seg = pcb->unsent;
 20200c4:	e0bfff17 	ldw	r2,-4(fp)
 20200c8:	10801c17 	ldw	r2,112(r2)
 20200cc:	e0bffa15 	stw	r2,-24(fp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 20200d0:	e0bffa17 	ldw	r2,-24(fp)
 20200d4:	10004426 	beq	r2,zero,20201e8 <tcp_output+0xa68>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 20200d8:	e0bffa17 	ldw	r2,-24(fp)
 20200dc:	10800417 	ldw	r2,16(r2)
 20200e0:	10c00103 	ldbu	r3,4(r2)
 20200e4:	11000143 	ldbu	r4,5(r2)
 20200e8:	2008923a 	slli	r4,r4,8
 20200ec:	20c6b03a 	or	r3,r4,r3
 20200f0:	11000183 	ldbu	r4,6(r2)
 20200f4:	2008943a 	slli	r4,r4,16
 20200f8:	20c6b03a 	or	r3,r4,r3
 20200fc:	108001c3 	ldbu	r2,7(r2)
 2020100:	1004963a 	slli	r2,r2,24
 2020104:	10c4b03a 	or	r2,r2,r3
 2020108:	1006d63a 	srli	r3,r2,24
 202010c:	e0bffa17 	ldw	r2,-24(fp)
 2020110:	10800417 	ldw	r2,16(r2)
 2020114:	11000103 	ldbu	r4,4(r2)
 2020118:	11400143 	ldbu	r5,5(r2)
 202011c:	280a923a 	slli	r5,r5,8
 2020120:	2908b03a 	or	r4,r5,r4
 2020124:	11400183 	ldbu	r5,6(r2)
 2020128:	280a943a 	slli	r5,r5,16
 202012c:	2908b03a 	or	r4,r5,r4
 2020130:	108001c3 	ldbu	r2,7(r2)
 2020134:	1004963a 	slli	r2,r2,24
 2020138:	1104b03a 	or	r2,r2,r4
 202013c:	1004d23a 	srli	r2,r2,8
 2020140:	10bfc00c 	andi	r2,r2,65280
 2020144:	1886b03a 	or	r3,r3,r2
 2020148:	e0bffa17 	ldw	r2,-24(fp)
 202014c:	10800417 	ldw	r2,16(r2)
 2020150:	11000103 	ldbu	r4,4(r2)
 2020154:	11400143 	ldbu	r5,5(r2)
 2020158:	280a923a 	slli	r5,r5,8
 202015c:	2908b03a 	or	r4,r5,r4
 2020160:	11400183 	ldbu	r5,6(r2)
 2020164:	280a943a 	slli	r5,r5,16
 2020168:	2908b03a 	or	r4,r5,r4
 202016c:	108001c3 	ldbu	r2,7(r2)
 2020170:	1004963a 	slli	r2,r2,24
 2020174:	1104b03a 	or	r2,r2,r4
 2020178:	10bfc00c 	andi	r2,r2,65280
 202017c:	1004923a 	slli	r2,r2,8
 2020180:	1886b03a 	or	r3,r3,r2
 2020184:	e0bffa17 	ldw	r2,-24(fp)
 2020188:	10800417 	ldw	r2,16(r2)
 202018c:	11000103 	ldbu	r4,4(r2)
 2020190:	11400143 	ldbu	r5,5(r2)
 2020194:	280a923a 	slli	r5,r5,8
 2020198:	2908b03a 	or	r4,r5,r4
 202019c:	11400183 	ldbu	r5,6(r2)
 20201a0:	280a943a 	slli	r5,r5,16
 20201a4:	2908b03a 	or	r4,r5,r4
 20201a8:	108001c3 	ldbu	r2,7(r2)
 20201ac:	1004963a 	slli	r2,r2,24
 20201b0:	1104b03a 	or	r2,r2,r4
 20201b4:	1004963a 	slli	r2,r2,24
 20201b8:	1886b03a 	or	r3,r3,r2
 20201bc:	e0bfff17 	ldw	r2,-4(fp)
 20201c0:	10801317 	ldw	r2,76(r2)
 20201c4:	1887c83a 	sub	r3,r3,r2
 20201c8:	e0bffa17 	ldw	r2,-24(fp)
 20201cc:	1080020b 	ldhu	r2,8(r2)
 20201d0:	10bfffcc 	andi	r2,r2,65535
 20201d4:	1885883a 	add	r2,r3,r2
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 20201d8:	e0fffd17 	ldw	r3,-12(fp)
 20201dc:	18bdd92e 	bgeu	r3,r2,201f944 <__alt_mem_mem_0+0xfcfff944>
 20201e0:	00000106 	br	20201e8 <tcp_output+0xa68>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
 20201e4:	0001883a 	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 20201e8:	e0bfff17 	ldw	r2,-4(fp)
 20201ec:	10801c17 	ldw	r2,112(r2)
 20201f0:	1000021e 	bne	r2,zero,20201fc <tcp_output+0xa7c>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 20201f4:	e0bfff17 	ldw	r2,-4(fp)
 20201f8:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 20201fc:	e0bfff17 	ldw	r2,-4(fp)
 2020200:	10800883 	ldbu	r2,34(r2)
 2020204:	10801fcc 	andi	r2,r2,127
 2020208:	1007883a 	mov	r3,r2
 202020c:	e0bfff17 	ldw	r2,-4(fp)
 2020210:	10c00885 	stb	r3,34(r2)
  return ERR_OK;
 2020214:	0005883a 	mov	r2,zero
}
 2020218:	e037883a 	mov	sp,fp
 202021c:	dfc00117 	ldw	ra,4(sp)
 2020220:	df000017 	ldw	fp,0(sp)
 2020224:	dec00204 	addi	sp,sp,8
 2020228:	f800283a 	ret

0202022c <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
 202022c:	defff404 	addi	sp,sp,-48
 2020230:	dfc00b15 	stw	ra,44(sp)
 2020234:	df000a15 	stw	fp,40(sp)
 2020238:	df000a04 	addi	fp,sp,40
 202023c:	e13ffe15 	stw	r4,-8(fp)
 2020240:	e17fff15 	stw	r5,-4(fp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 2020244:	e0bffe17 	ldw	r2,-8(fp)
 2020248:	10800417 	ldw	r2,16(r2)
 202024c:	e0ffff17 	ldw	r3,-4(fp)
 2020250:	18c00b17 	ldw	r3,44(r3)
 2020254:	1808d63a 	srli	r4,r3,24
 2020258:	e0ffff17 	ldw	r3,-4(fp)
 202025c:	18c00b17 	ldw	r3,44(r3)
 2020260:	1806d23a 	srli	r3,r3,8
 2020264:	18ffc00c 	andi	r3,r3,65280
 2020268:	20c8b03a 	or	r4,r4,r3
 202026c:	e0ffff17 	ldw	r3,-4(fp)
 2020270:	18c00b17 	ldw	r3,44(r3)
 2020274:	18ffc00c 	andi	r3,r3,65280
 2020278:	1806923a 	slli	r3,r3,8
 202027c:	20c8b03a 	or	r4,r4,r3
 2020280:	e0ffff17 	ldw	r3,-4(fp)
 2020284:	18c00b17 	ldw	r3,44(r3)
 2020288:	1806963a 	slli	r3,r3,24
 202028c:	20c6b03a 	or	r3,r4,r3
 2020290:	19803fcc 	andi	r6,r3,255
 2020294:	11000203 	ldbu	r4,8(r2)
 2020298:	2008703a 	and	r4,r4,zero
 202029c:	200b883a 	mov	r5,r4
 20202a0:	3009883a 	mov	r4,r6
 20202a4:	2908b03a 	or	r4,r5,r4
 20202a8:	11000205 	stb	r4,8(r2)
 20202ac:	1808d23a 	srli	r4,r3,8
 20202b0:	21803fcc 	andi	r6,r4,255
 20202b4:	11000243 	ldbu	r4,9(r2)
 20202b8:	2008703a 	and	r4,r4,zero
 20202bc:	200b883a 	mov	r5,r4
 20202c0:	3009883a 	mov	r4,r6
 20202c4:	2908b03a 	or	r4,r5,r4
 20202c8:	11000245 	stb	r4,9(r2)
 20202cc:	1808d43a 	srli	r4,r3,16
 20202d0:	21803fcc 	andi	r6,r4,255
 20202d4:	11000283 	ldbu	r4,10(r2)
 20202d8:	2008703a 	and	r4,r4,zero
 20202dc:	200b883a 	mov	r5,r4
 20202e0:	3009883a 	mov	r4,r6
 20202e4:	2908b03a 	or	r4,r5,r4
 20202e8:	11000285 	stb	r4,10(r2)
 20202ec:	180ad63a 	srli	r5,r3,24
 20202f0:	10c002c3 	ldbu	r3,11(r2)
 20202f4:	1806703a 	and	r3,r3,zero
 20202f8:	1809883a 	mov	r4,r3
 20202fc:	2807883a 	mov	r3,r5
 2020300:	20c6b03a 	or	r3,r4,r3
 2020304:	10c002c5 	stb	r3,11(r2)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 2020308:	e0bffe17 	ldw	r2,-8(fp)
 202030c:	10800417 	ldw	r2,16(r2)
 2020310:	e0ffff17 	ldw	r3,-4(fp)
 2020314:	18c00c8b 	ldhu	r3,50(r3)
 2020318:	18ffffcc 	andi	r3,r3,65535
 202031c:	1806d23a 	srli	r3,r3,8
 2020320:	1809883a 	mov	r4,r3
 2020324:	e0ffff17 	ldw	r3,-4(fp)
 2020328:	18c00c8b 	ldhu	r3,50(r3)
 202032c:	18ffffcc 	andi	r3,r3,65535
 2020330:	1806923a 	slli	r3,r3,8
 2020334:	20c6b03a 	or	r3,r4,r3
 2020338:	180d883a 	mov	r6,r3
 202033c:	30ffffcc 	andi	r3,r6,65535
 2020340:	19403fcc 	andi	r5,r3,255
 2020344:	10c00383 	ldbu	r3,14(r2)
 2020348:	1806703a 	and	r3,r3,zero
 202034c:	1809883a 	mov	r4,r3
 2020350:	2807883a 	mov	r3,r5
 2020354:	20c6b03a 	or	r3,r4,r3
 2020358:	10c00385 	stb	r3,14(r2)
 202035c:	30ffffcc 	andi	r3,r6,65535
 2020360:	1806d23a 	srli	r3,r3,8
 2020364:	197fffcc 	andi	r5,r3,65535
 2020368:	10c003c3 	ldbu	r3,15(r2)
 202036c:	1806703a 	and	r3,r3,zero
 2020370:	1809883a 	mov	r4,r3
 2020374:	2807883a 	mov	r3,r5
 2020378:	20c6b03a 	or	r3,r4,r3
 202037c:	10c003c5 	stb	r3,15(r2)

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 2020380:	e0bfff17 	ldw	r2,-4(fp)
 2020384:	10c00b17 	ldw	r3,44(r2)
 2020388:	e0bfff17 	ldw	r2,-4(fp)
 202038c:	10800c8b 	ldhu	r2,50(r2)
 2020390:	10bfffcc 	andi	r2,r2,65535
 2020394:	1887883a 	add	r3,r3,r2
 2020398:	e0bfff17 	ldw	r2,-4(fp)
 202039c:	10c00d15 	stw	r3,52(r2)

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 20203a0:	e0bffe17 	ldw	r2,-8(fp)
 20203a4:	10800417 	ldw	r2,16(r2)
 20203a8:	10800504 	addi	r2,r2,20
 20203ac:	e0bff915 	stw	r2,-28(fp)
  if (seg->flags & TF_SEG_OPTS_MSS) {
 20203b0:	e0bffe17 	ldw	r2,-8(fp)
 20203b4:	10800343 	ldbu	r2,13(r2)
 20203b8:	10803fcc 	andi	r2,r2,255
 20203bc:	1080004c 	andi	r2,r2,1
 20203c0:	10001e26 	beq	r2,zero,202043c <tcp_output_segment+0x210>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &(pcb->local_ip), &(pcb->remote_ip));
 20203c4:	e0ffff17 	ldw	r3,-4(fp)
 20203c8:	e0bfff17 	ldw	r2,-4(fp)
 20203cc:	10800104 	addi	r2,r2,4
 20203d0:	100d883a 	mov	r6,r2
 20203d4:	180b883a 	mov	r5,r3
 20203d8:	01016d04 	movi	r4,1460
 20203dc:	201dd380 	call	201dd38 <tcp_eff_send_mss>
 20203e0:	e0bffa0d 	sth	r2,-24(fp)
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 20203e4:	e0bffa0b 	ldhu	r2,-24(fp)
 20203e8:	10808134 	orhi	r2,r2,516
 20203ec:	1004d63a 	srli	r2,r2,24
 20203f0:	1007883a 	mov	r3,r2
 20203f4:	e0bffa0b 	ldhu	r2,-24(fp)
 20203f8:	10808134 	orhi	r2,r2,516
 20203fc:	1005d23a 	srai	r2,r2,8
 2020400:	10bfc00c 	andi	r2,r2,65280
 2020404:	1886b03a 	or	r3,r3,r2
 2020408:	e0bffa0b 	ldhu	r2,-24(fp)
 202040c:	10bfc00c 	andi	r2,r2,65280
 2020410:	1004923a 	slli	r2,r2,8
 2020414:	1886b03a 	or	r3,r3,r2
 2020418:	e0bffa0b 	ldhu	r2,-24(fp)
 202041c:	1004963a 	slli	r2,r2,24
 2020420:	1884b03a 	or	r2,r3,r2
 2020424:	1007883a 	mov	r3,r2
 2020428:	e0bff917 	ldw	r2,-28(fp)
 202042c:	10c00015 	stw	r3,0(r2)
    opts += 1;
 2020430:	e0bff917 	ldw	r2,-28(fp)
 2020434:	10800104 	addi	r2,r2,4
 2020438:	e0bff915 	stw	r2,-28(fp)
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 202043c:	e0bfff17 	ldw	r2,-4(fp)
 2020440:	10800e0b 	ldhu	r2,56(r2)
 2020444:	10bfffcc 	andi	r2,r2,65535
 2020448:	10a0001c 	xori	r2,r2,32768
 202044c:	10a00004 	addi	r2,r2,-32768
 2020450:	10bfffd8 	cmpnei	r2,r2,-1
 2020454:	1000021e 	bne	r2,zero,2020460 <tcp_output_segment+0x234>
    pcb->rtime = 0;
 2020458:	e0bfff17 	ldw	r2,-4(fp)
 202045c:	10000e0d 	sth	zero,56(r2)
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 2020460:	e0bfff17 	ldw	r2,-4(fp)
 2020464:	10000326 	beq	r2,zero,2020474 <tcp_output_segment+0x248>
 2020468:	e0bfff17 	ldw	r2,-4(fp)
 202046c:	10800017 	ldw	r2,0(r2)
 2020470:	10000d1e 	bne	r2,zero,20204a8 <tcp_output_segment+0x27c>
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
 2020474:	e0ffff17 	ldw	r3,-4(fp)
 2020478:	e0bfff17 	ldw	r2,-4(fp)
 202047c:	10800104 	addi	r2,r2,4
 2020480:	100b883a 	mov	r5,r2
 2020484:	1809883a 	mov	r4,r3
 2020488:	2031d1c0 	call	2031d1c <ip_route>
 202048c:	e0bffb15 	stw	r2,-20(fp)
    if (netif == NULL) {
 2020490:	e0bffb17 	ldw	r2,-20(fp)
 2020494:	1000df26 	beq	r2,zero,2020814 <tcp_output_segment+0x5e8>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 2020498:	e0bffb17 	ldw	r2,-20(fp)
 202049c:	10c00117 	ldw	r3,4(r2)
 20204a0:	e0bfff17 	ldw	r2,-4(fp)
 20204a4:	10c00015 	stw	r3,0(r2)
  }

  if (pcb->rttest == 0) {
 20204a8:	e0bfff17 	ldw	r2,-4(fp)
 20204ac:	10800f17 	ldw	r2,60(r2)
 20204b0:	10003e1e 	bne	r2,zero,20205ac <tcp_output_segment+0x380>
    pcb->rttest = tcp_ticks;
 20204b4:	d0e7f817 	ldw	r3,-24608(gp)
 20204b8:	e0bfff17 	ldw	r2,-4(fp)
 20204bc:	10c00f15 	stw	r3,60(r2)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 20204c0:	e0bffe17 	ldw	r2,-8(fp)
 20204c4:	10800417 	ldw	r2,16(r2)
 20204c8:	10c00103 	ldbu	r3,4(r2)
 20204cc:	11000143 	ldbu	r4,5(r2)
 20204d0:	2008923a 	slli	r4,r4,8
 20204d4:	20c6b03a 	or	r3,r4,r3
 20204d8:	11000183 	ldbu	r4,6(r2)
 20204dc:	2008943a 	slli	r4,r4,16
 20204e0:	20c6b03a 	or	r3,r4,r3
 20204e4:	108001c3 	ldbu	r2,7(r2)
 20204e8:	1004963a 	slli	r2,r2,24
 20204ec:	10c4b03a 	or	r2,r2,r3
 20204f0:	1006d63a 	srli	r3,r2,24
 20204f4:	e0bffe17 	ldw	r2,-8(fp)
 20204f8:	10800417 	ldw	r2,16(r2)
 20204fc:	11000103 	ldbu	r4,4(r2)
 2020500:	11400143 	ldbu	r5,5(r2)
 2020504:	280a923a 	slli	r5,r5,8
 2020508:	2908b03a 	or	r4,r5,r4
 202050c:	11400183 	ldbu	r5,6(r2)
 2020510:	280a943a 	slli	r5,r5,16
 2020514:	2908b03a 	or	r4,r5,r4
 2020518:	108001c3 	ldbu	r2,7(r2)
 202051c:	1004963a 	slli	r2,r2,24
 2020520:	1104b03a 	or	r2,r2,r4
 2020524:	1004d23a 	srli	r2,r2,8
 2020528:	10bfc00c 	andi	r2,r2,65280
 202052c:	1886b03a 	or	r3,r3,r2
 2020530:	e0bffe17 	ldw	r2,-8(fp)
 2020534:	10800417 	ldw	r2,16(r2)
 2020538:	11000103 	ldbu	r4,4(r2)
 202053c:	11400143 	ldbu	r5,5(r2)
 2020540:	280a923a 	slli	r5,r5,8
 2020544:	2908b03a 	or	r4,r5,r4
 2020548:	11400183 	ldbu	r5,6(r2)
 202054c:	280a943a 	slli	r5,r5,16
 2020550:	2908b03a 	or	r4,r5,r4
 2020554:	108001c3 	ldbu	r2,7(r2)
 2020558:	1004963a 	slli	r2,r2,24
 202055c:	1104b03a 	or	r2,r2,r4
 2020560:	10bfc00c 	andi	r2,r2,65280
 2020564:	1004923a 	slli	r2,r2,8
 2020568:	1886b03a 	or	r3,r3,r2
 202056c:	e0bffe17 	ldw	r2,-8(fp)
 2020570:	10800417 	ldw	r2,16(r2)
 2020574:	11000103 	ldbu	r4,4(r2)
 2020578:	11400143 	ldbu	r5,5(r2)
 202057c:	280a923a 	slli	r5,r5,8
 2020580:	2908b03a 	or	r4,r5,r4
 2020584:	11400183 	ldbu	r5,6(r2)
 2020588:	280a943a 	slli	r5,r5,16
 202058c:	2908b03a 	or	r4,r5,r4
 2020590:	108001c3 	ldbu	r2,7(r2)
 2020594:	1004963a 	slli	r2,r2,24
 2020598:	1104b03a 	or	r2,r2,r4
 202059c:	1004963a 	slli	r2,r2,24
 20205a0:	1886b03a 	or	r3,r3,r2
 20205a4:	e0bfff17 	ldw	r2,-4(fp)
 20205a8:	10c01015 	stw	r3,64(r2)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 20205ac:	e0bffe17 	ldw	r2,-8(fp)
 20205b0:	10800417 	ldw	r2,16(r2)
 20205b4:	1007883a 	mov	r3,r2
 20205b8:	e0bffe17 	ldw	r2,-8(fp)
 20205bc:	10800117 	ldw	r2,4(r2)
 20205c0:	10800117 	ldw	r2,4(r2)
 20205c4:	1885c83a 	sub	r2,r3,r2
 20205c8:	e0bffc0d 	sth	r2,-16(fp)

  seg->p->len -= len;
 20205cc:	e0bffe17 	ldw	r2,-8(fp)
 20205d0:	10800117 	ldw	r2,4(r2)
 20205d4:	e0fffe17 	ldw	r3,-8(fp)
 20205d8:	18c00117 	ldw	r3,4(r3)
 20205dc:	1900028b 	ldhu	r4,10(r3)
 20205e0:	e0fffc0b 	ldhu	r3,-16(fp)
 20205e4:	20c7c83a 	sub	r3,r4,r3
 20205e8:	10c0028d 	sth	r3,10(r2)
  seg->p->tot_len -= len;
 20205ec:	e0bffe17 	ldw	r2,-8(fp)
 20205f0:	10800117 	ldw	r2,4(r2)
 20205f4:	e0fffe17 	ldw	r3,-8(fp)
 20205f8:	18c00117 	ldw	r3,4(r3)
 20205fc:	1900020b 	ldhu	r4,8(r3)
 2020600:	e0fffc0b 	ldhu	r3,-16(fp)
 2020604:	20c7c83a 	sub	r3,r4,r3
 2020608:	10c0020d 	sth	r3,8(r2)

  seg->p->payload = seg->tcphdr;
 202060c:	e0bffe17 	ldw	r2,-8(fp)
 2020610:	10800117 	ldw	r2,4(r2)
 2020614:	e0fffe17 	ldw	r3,-8(fp)
 2020618:	18c00417 	ldw	r3,16(r3)
 202061c:	10c00115 	stw	r3,4(r2)

  seg->tcphdr->chksum = 0;
 2020620:	e0bffe17 	ldw	r2,-8(fp)
 2020624:	10800417 	ldw	r2,16(r2)
 2020628:	10c00403 	ldbu	r3,16(r2)
 202062c:	1806703a 	and	r3,r3,zero
 2020630:	10c00405 	stb	r3,16(r2)
 2020634:	10c00443 	ldbu	r3,17(r2)
 2020638:	1806703a 	and	r3,r3,zero
 202063c:	10c00445 	stb	r3,17(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 2020640:	e0bffe17 	ldw	r2,-8(fp)
 2020644:	12000117 	ldw	r8,4(r2)
 2020648:	e27fff17 	ldw	r9,-4(fp)
 202064c:	e0bfff17 	ldw	r2,-4(fp)
 2020650:	11800104 	addi	r6,r2,4
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
 2020654:	e0bffe17 	ldw	r2,-8(fp)
 2020658:	10800117 	ldw	r2,4(r2)
 202065c:	1080020b 	ldhu	r2,8(r2)
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 2020660:	10ffffcc 	andi	r3,r2,65535
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
 2020664:	e0bffe17 	ldw	r2,-8(fp)
 2020668:	10800417 	ldw	r2,16(r2)
 202066c:	11000303 	ldbu	r4,12(r2)
 2020670:	10800343 	ldbu	r2,13(r2)
 2020674:	1004923a 	slli	r2,r2,8
 2020678:	1104b03a 	or	r2,r2,r4
 202067c:	10bfffcc 	andi	r2,r2,65535
 2020680:	1004d23a 	srli	r2,r2,8
 2020684:	113fffcc 	andi	r4,r2,65535
 2020688:	e0bffe17 	ldw	r2,-8(fp)
 202068c:	10800417 	ldw	r2,16(r2)
 2020690:	11400303 	ldbu	r5,12(r2)
 2020694:	10800343 	ldbu	r2,13(r2)
 2020698:	1004923a 	slli	r2,r2,8
 202069c:	1144b03a 	or	r2,r2,r5
 20206a0:	10bfffcc 	andi	r2,r2,65535
 20206a4:	1004923a 	slli	r2,r2,8
 20206a8:	10bfffcc 	andi	r2,r2,65535
 20206ac:	2084b03a 	or	r2,r4,r2
 20206b0:	1005d33a 	srai	r2,r2,12
      LWIP_ASSERT("data included but not checksummed",
        seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
    }

    /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
    acc = inet_chksum_pseudo_partial(seg->p, &(pcb->local_ip),
 20206b4:	1085883a 	add	r2,r2,r2
 20206b8:	1085883a 	add	r2,r2,r2
 20206bc:	10bfffcc 	andi	r2,r2,65535
 20206c0:	d8800115 	stw	r2,4(sp)
 20206c4:	d8c00015 	stw	r3,0(sp)
 20206c8:	01c00184 	movi	r7,6
 20206cc:	480b883a 	mov	r5,r9
 20206d0:	4009883a 	mov	r4,r8
 20206d4:	203193c0 	call	203193c <inet_chksum_pseudo_partial>
 20206d8:	10bfffcc 	andi	r2,r2,65535
 20206dc:	e0bffd15 	stw	r2,-12(fp)
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4);
    /* add payload checksum */
    if (seg->chksum_swapped) {
 20206e0:	e0bffe17 	ldw	r2,-8(fp)
 20206e4:	10800303 	ldbu	r2,12(r2)
 20206e8:	10803fcc 	andi	r2,r2,255
 20206ec:	10000f26 	beq	r2,zero,202072c <tcp_output_segment+0x500>
      seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
 20206f0:	e0bffe17 	ldw	r2,-8(fp)
 20206f4:	1080028b 	ldhu	r2,10(r2)
 20206f8:	10bfffcc 	andi	r2,r2,65535
 20206fc:	1004d23a 	srli	r2,r2,8
 2020700:	1007883a 	mov	r3,r2
 2020704:	e0bffe17 	ldw	r2,-8(fp)
 2020708:	1080028b 	ldhu	r2,10(r2)
 202070c:	10bfffcc 	andi	r2,r2,65535
 2020710:	1004923a 	slli	r2,r2,8
 2020714:	1884b03a 	or	r2,r3,r2
 2020718:	1007883a 	mov	r3,r2
 202071c:	e0bffe17 	ldw	r2,-8(fp)
 2020720:	10c0028d 	sth	r3,10(r2)
      seg->chksum_swapped = 0;
 2020724:	e0bffe17 	ldw	r2,-8(fp)
 2020728:	10000305 	stb	zero,12(r2)
    }
    acc += (u16_t)~(seg->chksum);
 202072c:	e0bffe17 	ldw	r2,-8(fp)
 2020730:	1080028b 	ldhu	r2,10(r2)
 2020734:	0084303a 	nor	r2,zero,r2
 2020738:	10bfffcc 	andi	r2,r2,65535
 202073c:	e0fffd17 	ldw	r3,-12(fp)
 2020740:	1885883a 	add	r2,r3,r2
 2020744:	e0bffd15 	stw	r2,-12(fp)
    seg->tcphdr->chksum = FOLD_U32T(acc);
 2020748:	e0bffe17 	ldw	r2,-8(fp)
 202074c:	10800417 	ldw	r2,16(r2)
 2020750:	e0fffd17 	ldw	r3,-12(fp)
 2020754:	1806d43a 	srli	r3,r3,16
 2020758:	1809883a 	mov	r4,r3
 202075c:	e0fffd17 	ldw	r3,-12(fp)
 2020760:	20c7883a 	add	r3,r4,r3
 2020764:	180d883a 	mov	r6,r3
 2020768:	30ffffcc 	andi	r3,r6,65535
 202076c:	19403fcc 	andi	r5,r3,255
 2020770:	10c00403 	ldbu	r3,16(r2)
 2020774:	1806703a 	and	r3,r3,zero
 2020778:	1809883a 	mov	r4,r3
 202077c:	2807883a 	mov	r3,r5
 2020780:	20c6b03a 	or	r3,r4,r3
 2020784:	10c00405 	stb	r3,16(r2)
 2020788:	30ffffcc 	andi	r3,r6,65535
 202078c:	1806d23a 	srli	r3,r3,8
 2020790:	197fffcc 	andi	r5,r3,65535
 2020794:	10c00443 	ldbu	r3,17(r2)
 2020798:	1806703a 	and	r3,r3,zero
 202079c:	1809883a 	mov	r4,r3
 20207a0:	2807883a 	mov	r3,r5
 20207a4:	20c6b03a 	or	r3,r4,r3
 20207a8:	10c00445 	stb	r3,17(r2)
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
         &(pcb->remote_ip),
         IP_PROTO_TCP, seg->p->tot_len);
#endif /* TCP_CHECKSUM_ON_COPY */
#endif /* CHECKSUM_GEN_TCP */
  TCP_STATS_INC(tcp.xmit);
 20207ac:	008085f4 	movhi	r2,535
 20207b0:	10a8bc04 	addi	r2,r2,-23824
 20207b4:	10804817 	ldw	r2,288(r2)
 20207b8:	10c00044 	addi	r3,r2,1
 20207bc:	008085f4 	movhi	r2,535
 20207c0:	10a8bc04 	addi	r2,r2,-23824
 20207c4:	10c04815 	stw	r3,288(r2)

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 20207c8:	e0bffe17 	ldw	r2,-8(fp)
 20207cc:	11000117 	ldw	r4,4(r2)
 20207d0:	e17fff17 	ldw	r5,-4(fp)
 20207d4:	e0bfff17 	ldw	r2,-4(fp)
 20207d8:	11800104 	addi	r6,r2,4
 20207dc:	e0bfff17 	ldw	r2,-4(fp)
 20207e0:	10800283 	ldbu	r2,10(r2)
 20207e4:	11c03fcc 	andi	r7,r2,255
 20207e8:	e0bfff17 	ldw	r2,-4(fp)
 20207ec:	10800243 	ldbu	r2,9(r2)
 20207f0:	10803fcc 	andi	r2,r2,255
 20207f4:	e0ffff17 	ldw	r3,-4(fp)
 20207f8:	18c002c4 	addi	r3,r3,11
 20207fc:	d8c00215 	stw	r3,8(sp)
 2020800:	00c00184 	movi	r3,6
 2020804:	d8c00115 	stw	r3,4(sp)
 2020808:	d8800015 	stw	r2,0(sp)
 202080c:	2032a480 	call	2032a48 <ip_output_hinted>
 2020810:	00000106 	br	2020818 <tcp_output_segment+0x5ec>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->local_ip), &(pcb->remote_ip));
    if (netif == NULL) {
      return;
 2020814:	0001883a 	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
 2020818:	e037883a 	mov	sp,fp
 202081c:	dfc00117 	ldw	ra,4(sp)
 2020820:	df000017 	ldw	fp,0(sp)
 2020824:	dec00204 	addi	sp,sp,8
 2020828:	f800283a 	ret

0202082c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 202082c:	defff404 	addi	sp,sp,-48
 2020830:	dfc00b15 	stw	ra,44(sp)
 2020834:	df000a15 	stw	fp,40(sp)
 2020838:	df000a04 	addi	fp,sp,40
 202083c:	e13ffa15 	stw	r4,-24(fp)
 2020840:	e17ffb15 	stw	r5,-20(fp)
 2020844:	e1bffc15 	stw	r6,-16(fp)
 2020848:	e1fffd15 	stw	r7,-12(fp)
 202084c:	e0c00217 	ldw	r3,8(fp)
 2020850:	e0800317 	ldw	r2,12(fp)
 2020854:	e0fffe0d 	sth	r3,-8(fp)
 2020858:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 202085c:	000d883a 	mov	r6,zero
 2020860:	01400504 	movi	r5,20
 2020864:	01000044 	movi	r4,1
 2020868:	201a3ac0 	call	201a3ac <pbuf_alloc>
 202086c:	e0bff815 	stw	r2,-32(fp)
  if (p == NULL) {
 2020870:	e0bff817 	ldw	r2,-32(fp)
 2020874:	1000da26 	beq	r2,zero,2020be0 <tcp_rst+0x3b4>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 2020878:	e0bff817 	ldw	r2,-32(fp)
 202087c:	10800117 	ldw	r2,4(r2)
 2020880:	e0bff915 	stw	r2,-28(fp)
  tcphdr->src = htons(local_port);
 2020884:	e0bffe0b 	ldhu	r2,-8(fp)
 2020888:	1004d23a 	srli	r2,r2,8
 202088c:	1007883a 	mov	r3,r2
 2020890:	e0bffe0b 	ldhu	r2,-8(fp)
 2020894:	1004923a 	slli	r2,r2,8
 2020898:	1884b03a 	or	r2,r3,r2
 202089c:	100d883a 	mov	r6,r2
 20208a0:	e0bff917 	ldw	r2,-28(fp)
 20208a4:	30ffffcc 	andi	r3,r6,65535
 20208a8:	19403fcc 	andi	r5,r3,255
 20208ac:	10c00003 	ldbu	r3,0(r2)
 20208b0:	1806703a 	and	r3,r3,zero
 20208b4:	1809883a 	mov	r4,r3
 20208b8:	2807883a 	mov	r3,r5
 20208bc:	20c6b03a 	or	r3,r4,r3
 20208c0:	10c00005 	stb	r3,0(r2)
 20208c4:	30ffffcc 	andi	r3,r6,65535
 20208c8:	1806d23a 	srli	r3,r3,8
 20208cc:	197fffcc 	andi	r5,r3,65535
 20208d0:	10c00043 	ldbu	r3,1(r2)
 20208d4:	1806703a 	and	r3,r3,zero
 20208d8:	1809883a 	mov	r4,r3
 20208dc:	2807883a 	mov	r3,r5
 20208e0:	20c6b03a 	or	r3,r4,r3
 20208e4:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = htons(remote_port);
 20208e8:	e0bfff0b 	ldhu	r2,-4(fp)
 20208ec:	1004d23a 	srli	r2,r2,8
 20208f0:	1007883a 	mov	r3,r2
 20208f4:	e0bfff0b 	ldhu	r2,-4(fp)
 20208f8:	1004923a 	slli	r2,r2,8
 20208fc:	1884b03a 	or	r2,r3,r2
 2020900:	100d883a 	mov	r6,r2
 2020904:	e0bff917 	ldw	r2,-28(fp)
 2020908:	30ffffcc 	andi	r3,r6,65535
 202090c:	19403fcc 	andi	r5,r3,255
 2020910:	10c00083 	ldbu	r3,2(r2)
 2020914:	1806703a 	and	r3,r3,zero
 2020918:	1809883a 	mov	r4,r3
 202091c:	2807883a 	mov	r3,r5
 2020920:	20c6b03a 	or	r3,r4,r3
 2020924:	10c00085 	stb	r3,2(r2)
 2020928:	30ffffcc 	andi	r3,r6,65535
 202092c:	1806d23a 	srli	r3,r3,8
 2020930:	197fffcc 	andi	r5,r3,65535
 2020934:	10c000c3 	ldbu	r3,3(r2)
 2020938:	1806703a 	and	r3,r3,zero
 202093c:	1809883a 	mov	r4,r3
 2020940:	2807883a 	mov	r3,r5
 2020944:	20c6b03a 	or	r3,r4,r3
 2020948:	10c000c5 	stb	r3,3(r2)
  tcphdr->seqno = htonl(seqno);
 202094c:	e0bffa17 	ldw	r2,-24(fp)
 2020950:	1006d63a 	srli	r3,r2,24
 2020954:	e0bffa17 	ldw	r2,-24(fp)
 2020958:	1004d23a 	srli	r2,r2,8
 202095c:	10bfc00c 	andi	r2,r2,65280
 2020960:	1886b03a 	or	r3,r3,r2
 2020964:	e0bffa17 	ldw	r2,-24(fp)
 2020968:	10bfc00c 	andi	r2,r2,65280
 202096c:	1004923a 	slli	r2,r2,8
 2020970:	1886b03a 	or	r3,r3,r2
 2020974:	e0bffa17 	ldw	r2,-24(fp)
 2020978:	1004963a 	slli	r2,r2,24
 202097c:	1886b03a 	or	r3,r3,r2
 2020980:	e0bff917 	ldw	r2,-28(fp)
 2020984:	19803fcc 	andi	r6,r3,255
 2020988:	11000103 	ldbu	r4,4(r2)
 202098c:	2008703a 	and	r4,r4,zero
 2020990:	200b883a 	mov	r5,r4
 2020994:	3009883a 	mov	r4,r6
 2020998:	2908b03a 	or	r4,r5,r4
 202099c:	11000105 	stb	r4,4(r2)
 20209a0:	1808d23a 	srli	r4,r3,8
 20209a4:	21803fcc 	andi	r6,r4,255
 20209a8:	11000143 	ldbu	r4,5(r2)
 20209ac:	2008703a 	and	r4,r4,zero
 20209b0:	200b883a 	mov	r5,r4
 20209b4:	3009883a 	mov	r4,r6
 20209b8:	2908b03a 	or	r4,r5,r4
 20209bc:	11000145 	stb	r4,5(r2)
 20209c0:	1808d43a 	srli	r4,r3,16
 20209c4:	21803fcc 	andi	r6,r4,255
 20209c8:	11000183 	ldbu	r4,6(r2)
 20209cc:	2008703a 	and	r4,r4,zero
 20209d0:	200b883a 	mov	r5,r4
 20209d4:	3009883a 	mov	r4,r6
 20209d8:	2908b03a 	or	r4,r5,r4
 20209dc:	11000185 	stb	r4,6(r2)
 20209e0:	180ad63a 	srli	r5,r3,24
 20209e4:	10c001c3 	ldbu	r3,7(r2)
 20209e8:	1806703a 	and	r3,r3,zero
 20209ec:	1809883a 	mov	r4,r3
 20209f0:	2807883a 	mov	r3,r5
 20209f4:	20c6b03a 	or	r3,r4,r3
 20209f8:	10c001c5 	stb	r3,7(r2)
  tcphdr->ackno = htonl(ackno);
 20209fc:	e0bffb17 	ldw	r2,-20(fp)
 2020a00:	1006d63a 	srli	r3,r2,24
 2020a04:	e0bffb17 	ldw	r2,-20(fp)
 2020a08:	1004d23a 	srli	r2,r2,8
 2020a0c:	10bfc00c 	andi	r2,r2,65280
 2020a10:	1886b03a 	or	r3,r3,r2
 2020a14:	e0bffb17 	ldw	r2,-20(fp)
 2020a18:	10bfc00c 	andi	r2,r2,65280
 2020a1c:	1004923a 	slli	r2,r2,8
 2020a20:	1886b03a 	or	r3,r3,r2
 2020a24:	e0bffb17 	ldw	r2,-20(fp)
 2020a28:	1004963a 	slli	r2,r2,24
 2020a2c:	1886b03a 	or	r3,r3,r2
 2020a30:	e0bff917 	ldw	r2,-28(fp)
 2020a34:	19803fcc 	andi	r6,r3,255
 2020a38:	11000203 	ldbu	r4,8(r2)
 2020a3c:	2008703a 	and	r4,r4,zero
 2020a40:	200b883a 	mov	r5,r4
 2020a44:	3009883a 	mov	r4,r6
 2020a48:	2908b03a 	or	r4,r5,r4
 2020a4c:	11000205 	stb	r4,8(r2)
 2020a50:	1808d23a 	srli	r4,r3,8
 2020a54:	21803fcc 	andi	r6,r4,255
 2020a58:	11000243 	ldbu	r4,9(r2)
 2020a5c:	2008703a 	and	r4,r4,zero
 2020a60:	200b883a 	mov	r5,r4
 2020a64:	3009883a 	mov	r4,r6
 2020a68:	2908b03a 	or	r4,r5,r4
 2020a6c:	11000245 	stb	r4,9(r2)
 2020a70:	1808d43a 	srli	r4,r3,16
 2020a74:	21803fcc 	andi	r6,r4,255
 2020a78:	11000283 	ldbu	r4,10(r2)
 2020a7c:	2008703a 	and	r4,r4,zero
 2020a80:	200b883a 	mov	r5,r4
 2020a84:	3009883a 	mov	r4,r6
 2020a88:	2908b03a 	or	r4,r5,r4
 2020a8c:	11000285 	stb	r4,10(r2)
 2020a90:	180ad63a 	srli	r5,r3,24
 2020a94:	10c002c3 	ldbu	r3,11(r2)
 2020a98:	1806703a 	and	r3,r3,zero
 2020a9c:	1809883a 	mov	r4,r3
 2020aa0:	2807883a 	mov	r3,r5
 2020aa4:	20c6b03a 	or	r3,r4,r3
 2020aa8:	10c002c5 	stb	r3,11(r2)
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 2020aac:	e0bff917 	ldw	r2,-28(fp)
 2020ab0:	10c00303 	ldbu	r3,12(r2)
 2020ab4:	1806703a 	and	r3,r3,zero
 2020ab8:	18c01414 	ori	r3,r3,80
 2020abc:	10c00305 	stb	r3,12(r2)
 2020ac0:	10c00343 	ldbu	r3,13(r2)
 2020ac4:	1806703a 	and	r3,r3,zero
 2020ac8:	18c00514 	ori	r3,r3,20
 2020acc:	10c00345 	stb	r3,13(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
 2020ad0:	e0bff917 	ldw	r2,-28(fp)
 2020ad4:	10c00383 	ldbu	r3,14(r2)
 2020ad8:	1806703a 	and	r3,r3,zero
 2020adc:	18c00814 	ori	r3,r3,32
 2020ae0:	10c00385 	stb	r3,14(r2)
 2020ae4:	10c003c3 	ldbu	r3,15(r2)
 2020ae8:	1806703a 	and	r3,r3,zero
 2020aec:	10c003c5 	stb	r3,15(r2)
  tcphdr->chksum = 0;
 2020af0:	e0bff917 	ldw	r2,-28(fp)
 2020af4:	10c00403 	ldbu	r3,16(r2)
 2020af8:	1806703a 	and	r3,r3,zero
 2020afc:	10c00405 	stb	r3,16(r2)
 2020b00:	10c00443 	ldbu	r3,17(r2)
 2020b04:	1806703a 	and	r3,r3,zero
 2020b08:	10c00445 	stb	r3,17(r2)
  tcphdr->urgp = 0;
 2020b0c:	e0bff917 	ldw	r2,-28(fp)
 2020b10:	10c00483 	ldbu	r3,18(r2)
 2020b14:	1806703a 	and	r3,r3,zero
 2020b18:	10c00485 	stb	r3,18(r2)
 2020b1c:	10c004c3 	ldbu	r3,19(r2)
 2020b20:	1806703a 	and	r3,r3,zero
 2020b24:	10c004c5 	stb	r3,19(r2)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
 2020b28:	e0bff817 	ldw	r2,-32(fp)
 2020b2c:	1080020b 	ldhu	r2,8(r2)
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 2020b30:	10bfffcc 	andi	r2,r2,65535
 2020b34:	d8800015 	stw	r2,0(sp)
 2020b38:	01c00184 	movi	r7,6
 2020b3c:	e1bffd17 	ldw	r6,-12(fp)
 2020b40:	e17ffc17 	ldw	r5,-16(fp)
 2020b44:	e13ff817 	ldw	r4,-32(fp)
 2020b48:	203173c0 	call	203173c <inet_chksum_pseudo>
 2020b4c:	100d883a 	mov	r6,r2
 2020b50:	e0bff917 	ldw	r2,-28(fp)
 2020b54:	30ffffcc 	andi	r3,r6,65535
 2020b58:	19403fcc 	andi	r5,r3,255
 2020b5c:	10c00403 	ldbu	r3,16(r2)
 2020b60:	1806703a 	and	r3,r3,zero
 2020b64:	1809883a 	mov	r4,r3
 2020b68:	2807883a 	mov	r3,r5
 2020b6c:	20c6b03a 	or	r3,r4,r3
 2020b70:	10c00405 	stb	r3,16(r2)
 2020b74:	30ffffcc 	andi	r3,r6,65535
 2020b78:	1806d23a 	srli	r3,r3,8
 2020b7c:	197fffcc 	andi	r5,r3,65535
 2020b80:	10c00443 	ldbu	r3,17(r2)
 2020b84:	1806703a 	and	r3,r3,zero
 2020b88:	1809883a 	mov	r4,r3
 2020b8c:	2807883a 	mov	r3,r5
 2020b90:	20c6b03a 	or	r3,r4,r3
 2020b94:	10c00445 	stb	r3,17(r2)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 2020b98:	008085f4 	movhi	r2,535
 2020b9c:	10a8bc04 	addi	r2,r2,-23824
 2020ba0:	10804817 	ldw	r2,288(r2)
 2020ba4:	10c00044 	addi	r3,r2,1
 2020ba8:	008085f4 	movhi	r2,535
 2020bac:	10a8bc04 	addi	r2,r2,-23824
 2020bb0:	10c04815 	stw	r3,288(r2)
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 2020bb4:	00800184 	movi	r2,6
 2020bb8:	d8800115 	stw	r2,4(sp)
 2020bbc:	d8000015 	stw	zero,0(sp)
 2020bc0:	01c01004 	movi	r7,64
 2020bc4:	e1bffd17 	ldw	r6,-12(fp)
 2020bc8:	e17ffc17 	ldw	r5,-16(fp)
 2020bcc:	e13ff817 	ldw	r4,-32(fp)
 2020bd0:	20329940 	call	2032994 <ip_output>
  pbuf_free(p);
 2020bd4:	e13ff817 	ldw	r4,-32(fp)
 2020bd8:	201ab680 	call	201ab68 <pbuf_free>
 2020bdc:	00000106 	br	2020be4 <tcp_rst+0x3b8>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
 2020be0:	0001883a 	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 2020be4:	e037883a 	mov	sp,fp
 2020be8:	dfc00117 	ldw	ra,4(sp)
 2020bec:	df000017 	ldw	fp,0(sp)
 2020bf0:	dec00204 	addi	sp,sp,8
 2020bf4:	f800283a 	ret

02020bf8 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 2020bf8:	defffc04 	addi	sp,sp,-16
 2020bfc:	dfc00315 	stw	ra,12(sp)
 2020c00:	df000215 	stw	fp,8(sp)
 2020c04:	df000204 	addi	fp,sp,8
 2020c08:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 2020c0c:	e0bfff17 	ldw	r2,-4(fp)
 2020c10:	10801d17 	ldw	r2,116(r2)
 2020c14:	10001f26 	beq	r2,zero,2020c94 <tcp_rexmit_rto+0x9c>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 2020c18:	e0bfff17 	ldw	r2,-4(fp)
 2020c1c:	10801d17 	ldw	r2,116(r2)
 2020c20:	e0bffe15 	stw	r2,-8(fp)
 2020c24:	00000306 	br	2020c34 <tcp_rexmit_rto+0x3c>
 2020c28:	e0bffe17 	ldw	r2,-8(fp)
 2020c2c:	10800017 	ldw	r2,0(r2)
 2020c30:	e0bffe15 	stw	r2,-8(fp)
 2020c34:	e0bffe17 	ldw	r2,-8(fp)
 2020c38:	10800017 	ldw	r2,0(r2)
 2020c3c:	103ffa1e 	bne	r2,zero,2020c28 <__alt_mem_mem_0+0xfd000c28>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 2020c40:	e0bfff17 	ldw	r2,-4(fp)
 2020c44:	10c01c17 	ldw	r3,112(r2)
 2020c48:	e0bffe17 	ldw	r2,-8(fp)
 2020c4c:	10c00015 	stw	r3,0(r2)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 2020c50:	e0bfff17 	ldw	r2,-4(fp)
 2020c54:	10c01d17 	ldw	r3,116(r2)
 2020c58:	e0bfff17 	ldw	r2,-4(fp)
 2020c5c:	10c01c15 	stw	r3,112(r2)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 2020c60:	e0bfff17 	ldw	r2,-4(fp)
 2020c64:	10001d15 	stw	zero,116(r2)
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 2020c68:	e0bfff17 	ldw	r2,-4(fp)
 2020c6c:	10801283 	ldbu	r2,74(r2)
 2020c70:	10800044 	addi	r2,r2,1
 2020c74:	1007883a 	mov	r3,r2
 2020c78:	e0bfff17 	ldw	r2,-4(fp)
 2020c7c:	10c01285 	stb	r3,74(r2)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 2020c80:	e0bfff17 	ldw	r2,-4(fp)
 2020c84:	10000f15 	stw	zero,60(r2)

  /* Do the actual retransmission */
  tcp_output(pcb);
 2020c88:	e13fff17 	ldw	r4,-4(fp)
 2020c8c:	201f7800 	call	201f780 <tcp_output>
 2020c90:	00000106 	br	2020c98 <tcp_rexmit_rto+0xa0>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
 2020c94:	0001883a 	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 2020c98:	e037883a 	mov	sp,fp
 2020c9c:	dfc00117 	ldw	ra,4(sp)
 2020ca0:	df000017 	ldw	fp,0(sp)
 2020ca4:	dec00204 	addi	sp,sp,8
 2020ca8:	f800283a 	ret

02020cac <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 2020cac:	defffc04 	addi	sp,sp,-16
 2020cb0:	df000315 	stw	fp,12(sp)
 2020cb4:	df000304 	addi	fp,sp,12
 2020cb8:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 2020cbc:	e0bfff17 	ldw	r2,-4(fp)
 2020cc0:	10801d17 	ldw	r2,116(r2)
 2020cc4:	10009e26 	beq	r2,zero,2020f40 <tcp_rexmit+0x294>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
 2020cc8:	e0bfff17 	ldw	r2,-4(fp)
 2020ccc:	10801d17 	ldw	r2,116(r2)
 2020cd0:	e0bffe15 	stw	r2,-8(fp)
  pcb->unacked = seg->next;
 2020cd4:	e0bffe17 	ldw	r2,-8(fp)
 2020cd8:	10c00017 	ldw	r3,0(r2)
 2020cdc:	e0bfff17 	ldw	r2,-4(fp)
 2020ce0:	10c01d15 	stw	r3,116(r2)

  cur_seg = &(pcb->unsent);
 2020ce4:	e0bfff17 	ldw	r2,-4(fp)
 2020ce8:	10801c04 	addi	r2,r2,112
 2020cec:	e0bffd15 	stw	r2,-12(fp)
  while (*cur_seg &&
 2020cf0:	00000306 	br	2020d00 <tcp_rexmit+0x54>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 2020cf4:	e0bffd17 	ldw	r2,-12(fp)
 2020cf8:	10800017 	ldw	r2,0(r2)
 2020cfc:	e0bffd15 	stw	r2,-12(fp)
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 2020d00:	e0bffd17 	ldw	r2,-12(fp)
 2020d04:	10800017 	ldw	r2,0(r2)
 2020d08:	10007826 	beq	r2,zero,2020eec <tcp_rexmit+0x240>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 2020d0c:	e0bffd17 	ldw	r2,-12(fp)
 2020d10:	10800017 	ldw	r2,0(r2)
 2020d14:	10800417 	ldw	r2,16(r2)
 2020d18:	10c00103 	ldbu	r3,4(r2)
 2020d1c:	11000143 	ldbu	r4,5(r2)
 2020d20:	2008923a 	slli	r4,r4,8
 2020d24:	20c6b03a 	or	r3,r4,r3
 2020d28:	11000183 	ldbu	r4,6(r2)
 2020d2c:	2008943a 	slli	r4,r4,16
 2020d30:	20c6b03a 	or	r3,r4,r3
 2020d34:	108001c3 	ldbu	r2,7(r2)
 2020d38:	1004963a 	slli	r2,r2,24
 2020d3c:	10c4b03a 	or	r2,r2,r3
 2020d40:	1006d63a 	srli	r3,r2,24
 2020d44:	e0bffd17 	ldw	r2,-12(fp)
 2020d48:	10800017 	ldw	r2,0(r2)
 2020d4c:	10800417 	ldw	r2,16(r2)
 2020d50:	11000103 	ldbu	r4,4(r2)
 2020d54:	11400143 	ldbu	r5,5(r2)
 2020d58:	280a923a 	slli	r5,r5,8
 2020d5c:	2908b03a 	or	r4,r5,r4
 2020d60:	11400183 	ldbu	r5,6(r2)
 2020d64:	280a943a 	slli	r5,r5,16
 2020d68:	2908b03a 	or	r4,r5,r4
 2020d6c:	108001c3 	ldbu	r2,7(r2)
 2020d70:	1004963a 	slli	r2,r2,24
 2020d74:	1104b03a 	or	r2,r2,r4
 2020d78:	1004d23a 	srli	r2,r2,8
 2020d7c:	10bfc00c 	andi	r2,r2,65280
 2020d80:	1886b03a 	or	r3,r3,r2
 2020d84:	e0bffd17 	ldw	r2,-12(fp)
 2020d88:	10800017 	ldw	r2,0(r2)
 2020d8c:	10800417 	ldw	r2,16(r2)
 2020d90:	11000103 	ldbu	r4,4(r2)
 2020d94:	11400143 	ldbu	r5,5(r2)
 2020d98:	280a923a 	slli	r5,r5,8
 2020d9c:	2908b03a 	or	r4,r5,r4
 2020da0:	11400183 	ldbu	r5,6(r2)
 2020da4:	280a943a 	slli	r5,r5,16
 2020da8:	2908b03a 	or	r4,r5,r4
 2020dac:	108001c3 	ldbu	r2,7(r2)
 2020db0:	1004963a 	slli	r2,r2,24
 2020db4:	1104b03a 	or	r2,r2,r4
 2020db8:	10bfc00c 	andi	r2,r2,65280
 2020dbc:	1004923a 	slli	r2,r2,8
 2020dc0:	1886b03a 	or	r3,r3,r2
 2020dc4:	e0bffd17 	ldw	r2,-12(fp)
 2020dc8:	10800017 	ldw	r2,0(r2)
 2020dcc:	10800417 	ldw	r2,16(r2)
 2020dd0:	11000103 	ldbu	r4,4(r2)
 2020dd4:	11400143 	ldbu	r5,5(r2)
 2020dd8:	280a923a 	slli	r5,r5,8
 2020ddc:	2908b03a 	or	r4,r5,r4
 2020de0:	11400183 	ldbu	r5,6(r2)
 2020de4:	280a943a 	slli	r5,r5,16
 2020de8:	2908b03a 	or	r4,r5,r4
 2020dec:	108001c3 	ldbu	r2,7(r2)
 2020df0:	1004963a 	slli	r2,r2,24
 2020df4:	1104b03a 	or	r2,r2,r4
 2020df8:	1004963a 	slli	r2,r2,24
 2020dfc:	1886b03a 	or	r3,r3,r2
 2020e00:	e0bffe17 	ldw	r2,-8(fp)
 2020e04:	10800417 	ldw	r2,16(r2)
 2020e08:	11000103 	ldbu	r4,4(r2)
 2020e0c:	11400143 	ldbu	r5,5(r2)
 2020e10:	280a923a 	slli	r5,r5,8
 2020e14:	2908b03a 	or	r4,r5,r4
 2020e18:	11400183 	ldbu	r5,6(r2)
 2020e1c:	280a943a 	slli	r5,r5,16
 2020e20:	2908b03a 	or	r4,r5,r4
 2020e24:	108001c3 	ldbu	r2,7(r2)
 2020e28:	1004963a 	slli	r2,r2,24
 2020e2c:	1104b03a 	or	r2,r2,r4
 2020e30:	1008d63a 	srli	r4,r2,24
 2020e34:	e0bffe17 	ldw	r2,-8(fp)
 2020e38:	10800417 	ldw	r2,16(r2)
 2020e3c:	11400103 	ldbu	r5,4(r2)
 2020e40:	11800143 	ldbu	r6,5(r2)
 2020e44:	300c923a 	slli	r6,r6,8
 2020e48:	314ab03a 	or	r5,r6,r5
 2020e4c:	11800183 	ldbu	r6,6(r2)
 2020e50:	300c943a 	slli	r6,r6,16
 2020e54:	314ab03a 	or	r5,r6,r5
 2020e58:	108001c3 	ldbu	r2,7(r2)
 2020e5c:	1004963a 	slli	r2,r2,24
 2020e60:	1144b03a 	or	r2,r2,r5
 2020e64:	1004d23a 	srli	r2,r2,8
 2020e68:	10bfc00c 	andi	r2,r2,65280
 2020e6c:	2088b03a 	or	r4,r4,r2
 2020e70:	e0bffe17 	ldw	r2,-8(fp)
 2020e74:	10800417 	ldw	r2,16(r2)
 2020e78:	11400103 	ldbu	r5,4(r2)
 2020e7c:	11800143 	ldbu	r6,5(r2)
 2020e80:	300c923a 	slli	r6,r6,8
 2020e84:	314ab03a 	or	r5,r6,r5
 2020e88:	11800183 	ldbu	r6,6(r2)
 2020e8c:	300c943a 	slli	r6,r6,16
 2020e90:	314ab03a 	or	r5,r6,r5
 2020e94:	108001c3 	ldbu	r2,7(r2)
 2020e98:	1004963a 	slli	r2,r2,24
 2020e9c:	1144b03a 	or	r2,r2,r5
 2020ea0:	10bfc00c 	andi	r2,r2,65280
 2020ea4:	1004923a 	slli	r2,r2,8
 2020ea8:	2088b03a 	or	r4,r4,r2
 2020eac:	e0bffe17 	ldw	r2,-8(fp)
 2020eb0:	10800417 	ldw	r2,16(r2)
 2020eb4:	11400103 	ldbu	r5,4(r2)
 2020eb8:	11800143 	ldbu	r6,5(r2)
 2020ebc:	300c923a 	slli	r6,r6,8
 2020ec0:	314ab03a 	or	r5,r6,r5
 2020ec4:	11800183 	ldbu	r6,6(r2)
 2020ec8:	300c943a 	slli	r6,r6,16
 2020ecc:	314ab03a 	or	r5,r6,r5
 2020ed0:	108001c3 	ldbu	r2,7(r2)
 2020ed4:	1004963a 	slli	r2,r2,24
 2020ed8:	1144b03a 	or	r2,r2,r5
 2020edc:	1004963a 	slli	r2,r2,24
 2020ee0:	2084b03a 	or	r2,r4,r2
 2020ee4:	1885c83a 	sub	r2,r3,r2
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 2020ee8:	103f8216 	blt	r2,zero,2020cf4 <__alt_mem_mem_0+0xfd000cf4>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 2020eec:	e0bffd17 	ldw	r2,-12(fp)
 2020ef0:	10c00017 	ldw	r3,0(r2)
 2020ef4:	e0bffe17 	ldw	r2,-8(fp)
 2020ef8:	10c00015 	stw	r3,0(r2)
  *cur_seg = seg;
 2020efc:	e0bffd17 	ldw	r2,-12(fp)
 2020f00:	e0fffe17 	ldw	r3,-8(fp)
 2020f04:	10c00015 	stw	r3,0(r2)
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 2020f08:	e0bffe17 	ldw	r2,-8(fp)
 2020f0c:	10800017 	ldw	r2,0(r2)
 2020f10:	1000021e 	bne	r2,zero,2020f1c <tcp_rexmit+0x270>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 2020f14:	e0bfff17 	ldw	r2,-4(fp)
 2020f18:	10001b8d 	sth	zero,110(r2)
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 2020f1c:	e0bfff17 	ldw	r2,-4(fp)
 2020f20:	10801283 	ldbu	r2,74(r2)
 2020f24:	10800044 	addi	r2,r2,1
 2020f28:	1007883a 	mov	r3,r2
 2020f2c:	e0bfff17 	ldw	r2,-4(fp)
 2020f30:	10c01285 	stb	r3,74(r2)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 2020f34:	e0bfff17 	ldw	r2,-4(fp)
 2020f38:	10000f15 	stw	zero,60(r2)
 2020f3c:	00000106 	br	2020f44 <tcp_rexmit+0x298>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
 2020f40:	0001883a 	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
 2020f44:	e037883a 	mov	sp,fp
 2020f48:	df000017 	ldw	fp,0(sp)
 2020f4c:	dec00104 	addi	sp,sp,4
 2020f50:	f800283a 	ret

02020f54 <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 2020f54:	defffd04 	addi	sp,sp,-12
 2020f58:	dfc00215 	stw	ra,8(sp)
 2020f5c:	df000115 	stw	fp,4(sp)
 2020f60:	df000104 	addi	fp,sp,4
 2020f64:	e13fff15 	stw	r4,-4(fp)
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 2020f68:	e0bfff17 	ldw	r2,-4(fp)
 2020f6c:	10801d17 	ldw	r2,116(r2)
 2020f70:	10003c26 	beq	r2,zero,2021064 <tcp_rexmit_fast+0x110>
 2020f74:	e0bfff17 	ldw	r2,-4(fp)
 2020f78:	10800883 	ldbu	r2,34(r2)
 2020f7c:	10803fcc 	andi	r2,r2,255
 2020f80:	1080010c 	andi	r2,r2,4
 2020f84:	1000371e 	bne	r2,zero,2021064 <tcp_rexmit_fast+0x110>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 2020f88:	e13fff17 	ldw	r4,-4(fp)
 2020f8c:	2020cac0 	call	2020cac <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 2020f90:	e0bfff17 	ldw	r2,-4(fp)
 2020f94:	1100140b 	ldhu	r4,80(r2)
 2020f98:	e0bfff17 	ldw	r2,-4(fp)
 2020f9c:	10c0190b 	ldhu	r3,100(r2)
 2020fa0:	20bfffcc 	andi	r2,r4,65535
 2020fa4:	18ffffcc 	andi	r3,r3,65535
 2020fa8:	1880082e 	bgeu	r3,r2,2020fcc <tcp_rexmit_fast+0x78>
      pcb->ssthresh = pcb->snd_wnd / 2;
 2020fac:	e0bfff17 	ldw	r2,-4(fp)
 2020fb0:	1080190b 	ldhu	r2,100(r2)
 2020fb4:	10bfffcc 	andi	r2,r2,65535
 2020fb8:	1004d07a 	srli	r2,r2,1
 2020fbc:	1007883a 	mov	r3,r2
 2020fc0:	e0bfff17 	ldw	r2,-4(fp)
 2020fc4:	10c0148d 	sth	r3,82(r2)
 2020fc8:	00000706 	br	2020fe8 <tcp_rexmit_fast+0x94>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 2020fcc:	e0bfff17 	ldw	r2,-4(fp)
 2020fd0:	1080140b 	ldhu	r2,80(r2)
 2020fd4:	10bfffcc 	andi	r2,r2,65535
 2020fd8:	1004d07a 	srli	r2,r2,1
 2020fdc:	1007883a 	mov	r3,r2
 2020fe0:	e0bfff17 	ldw	r2,-4(fp)
 2020fe4:	10c0148d 	sth	r3,82(r2)
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 2020fe8:	e0bfff17 	ldw	r2,-4(fp)
 2020fec:	1080148b 	ldhu	r2,82(r2)
 2020ff0:	10ffffcc 	andi	r3,r2,65535
 2020ff4:	e0bfff17 	ldw	r2,-4(fp)
 2020ff8:	10800e8b 	ldhu	r2,58(r2)
 2020ffc:	10bfffcc 	andi	r2,r2,65535
 2021000:	1085883a 	add	r2,r2,r2
 2021004:	1880060e 	bge	r3,r2,2021020 <tcp_rexmit_fast+0xcc>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 2021008:	e0bfff17 	ldw	r2,-4(fp)
 202100c:	10800e8b 	ldhu	r2,58(r2)
 2021010:	1085883a 	add	r2,r2,r2
 2021014:	1007883a 	mov	r3,r2
 2021018:	e0bfff17 	ldw	r2,-4(fp)
 202101c:	10c0148d 	sth	r3,82(r2)
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 2021020:	e0bfff17 	ldw	r2,-4(fp)
 2021024:	1100148b 	ldhu	r4,82(r2)
 2021028:	e0bfff17 	ldw	r2,-4(fp)
 202102c:	10c00e8b 	ldhu	r3,58(r2)
 2021030:	1805883a 	mov	r2,r3
 2021034:	1085883a 	add	r2,r2,r2
 2021038:	10c5883a 	add	r2,r2,r3
 202103c:	2085883a 	add	r2,r4,r2
 2021040:	1007883a 	mov	r3,r2
 2021044:	e0bfff17 	ldw	r2,-4(fp)
 2021048:	10c0140d 	sth	r3,80(r2)
    pcb->flags |= TF_INFR;
 202104c:	e0bfff17 	ldw	r2,-4(fp)
 2021050:	10800883 	ldbu	r2,34(r2)
 2021054:	10800114 	ori	r2,r2,4
 2021058:	1007883a 	mov	r3,r2
 202105c:	e0bfff17 	ldw	r2,-4(fp)
 2021060:	10c00885 	stb	r3,34(r2)
  } 
}
 2021064:	0001883a 	nop
 2021068:	e037883a 	mov	sp,fp
 202106c:	dfc00117 	ldw	ra,4(sp)
 2021070:	df000017 	ldw	fp,0(sp)
 2021074:	dec00204 	addi	sp,sp,8
 2021078:	f800283a 	ret

0202107c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 202107c:	defff804 	addi	sp,sp,-32
 2021080:	dfc00715 	stw	ra,28(sp)
 2021084:	df000615 	stw	fp,24(sp)
 2021088:	df000604 	addi	fp,sp,24
 202108c:	e13fff15 	stw	r4,-4(fp)
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 2021090:	e0bfff17 	ldw	r2,-4(fp)
 2021094:	10801517 	ldw	r2,84(r2)
 2021098:	10bfffc4 	addi	r2,r2,-1
 202109c:	1006d63a 	srli	r3,r2,24
 20210a0:	e0bfff17 	ldw	r2,-4(fp)
 20210a4:	10801517 	ldw	r2,84(r2)
 20210a8:	10bfffc4 	addi	r2,r2,-1
 20210ac:	1004d23a 	srli	r2,r2,8
 20210b0:	10bfc00c 	andi	r2,r2,65280
 20210b4:	1886b03a 	or	r3,r3,r2
 20210b8:	e0bfff17 	ldw	r2,-4(fp)
 20210bc:	10801517 	ldw	r2,84(r2)
 20210c0:	10bfffc4 	addi	r2,r2,-1
 20210c4:	10bfc00c 	andi	r2,r2,65280
 20210c8:	1004923a 	slli	r2,r2,8
 20210cc:	1886b03a 	or	r3,r3,r2
 20210d0:	e0bfff17 	ldw	r2,-4(fp)
 20210d4:	10801517 	ldw	r2,84(r2)
 20210d8:	10bfffc4 	addi	r2,r2,-1
 20210dc:	1004963a 	slli	r2,r2,24
 20210e0:	1884b03a 	or	r2,r3,r2
 20210e4:	100f883a 	mov	r7,r2
 20210e8:	000d883a 	mov	r6,zero
 20210ec:	000b883a 	mov	r5,zero
 20210f0:	e13fff17 	ldw	r4,-4(fp)
 20210f4:	201de000 	call	201de00 <tcp_output_alloc_header>
 20210f8:	e0bffd15 	stw	r2,-12(fp)
  if(p == NULL) {
 20210fc:	e0bffd17 	ldw	r2,-12(fp)
 2021100:	10003d26 	beq	r2,zero,20211f8 <tcp_keepalive+0x17c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 2021104:	e0bffd17 	ldw	r2,-12(fp)
 2021108:	10800117 	ldw	r2,4(r2)
 202110c:	e0bffe15 	stw	r2,-8(fp)

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 2021110:	e0ffff17 	ldw	r3,-4(fp)
 2021114:	e0bfff17 	ldw	r2,-4(fp)
 2021118:	11000104 	addi	r4,r2,4
                                      IP_PROTO_TCP, p->tot_len);
 202111c:	e0bffd17 	ldw	r2,-12(fp)
 2021120:	1080020b 	ldhu	r2,8(r2)
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 2021124:	10bfffcc 	andi	r2,r2,65535
 2021128:	d8800015 	stw	r2,0(sp)
 202112c:	01c00184 	movi	r7,6
 2021130:	200d883a 	mov	r6,r4
 2021134:	180b883a 	mov	r5,r3
 2021138:	e13ffd17 	ldw	r4,-12(fp)
 202113c:	203173c0 	call	203173c <inet_chksum_pseudo>
 2021140:	100d883a 	mov	r6,r2
 2021144:	e0bffe17 	ldw	r2,-8(fp)
 2021148:	30ffffcc 	andi	r3,r6,65535
 202114c:	19403fcc 	andi	r5,r3,255
 2021150:	10c00403 	ldbu	r3,16(r2)
 2021154:	1806703a 	and	r3,r3,zero
 2021158:	1809883a 	mov	r4,r3
 202115c:	2807883a 	mov	r3,r5
 2021160:	20c6b03a 	or	r3,r4,r3
 2021164:	10c00405 	stb	r3,16(r2)
 2021168:	30ffffcc 	andi	r3,r6,65535
 202116c:	1806d23a 	srli	r3,r3,8
 2021170:	197fffcc 	andi	r5,r3,65535
 2021174:	10c00443 	ldbu	r3,17(r2)
 2021178:	1806703a 	and	r3,r3,zero
 202117c:	1809883a 	mov	r4,r3
 2021180:	2807883a 	mov	r3,r5
 2021184:	20c6b03a 	or	r3,r4,r3
 2021188:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 202118c:	008085f4 	movhi	r2,535
 2021190:	10a8bc04 	addi	r2,r2,-23824
 2021194:	10804817 	ldw	r2,288(r2)
 2021198:	10c00044 	addi	r3,r2,1
 202119c:	008085f4 	movhi	r2,535
 20211a0:	10a8bc04 	addi	r2,r2,-23824
 20211a4:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
 20211a8:	e0ffff17 	ldw	r3,-4(fp)
 20211ac:	e0bfff17 	ldw	r2,-4(fp)
 20211b0:	11000104 	addi	r4,r2,4
 20211b4:	e0bfff17 	ldw	r2,-4(fp)
 20211b8:	10800283 	ldbu	r2,10(r2)
 20211bc:	11403fcc 	andi	r5,r2,255
 20211c0:	e0bfff17 	ldw	r2,-4(fp)
 20211c4:	108002c4 	addi	r2,r2,11
 20211c8:	d8800215 	stw	r2,8(sp)
 20211cc:	00800184 	movi	r2,6
 20211d0:	d8800115 	stw	r2,4(sp)
 20211d4:	d8000015 	stw	zero,0(sp)
 20211d8:	280f883a 	mov	r7,r5
 20211dc:	200d883a 	mov	r6,r4
 20211e0:	180b883a 	mov	r5,r3
 20211e4:	e13ffd17 	ldw	r4,-12(fp)
 20211e8:	2032a480 	call	2032a48 <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 20211ec:	e13ffd17 	ldw	r4,-12(fp)
 20211f0:	201ab680 	call	201ab68 <pbuf_free>
 20211f4:	00000106 	br	20211fc <tcp_keepalive+0x180>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
 20211f8:	0001883a 	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 20211fc:	e037883a 	mov	sp,fp
 2021200:	dfc00117 	ldw	ra,4(sp)
 2021204:	df000017 	ldw	fp,0(sp)
 2021208:	dec00204 	addi	sp,sp,8
 202120c:	f800283a 	ret

02021210 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 2021210:	defff504 	addi	sp,sp,-44
 2021214:	dfc00a15 	stw	ra,40(sp)
 2021218:	df000915 	stw	fp,36(sp)
 202121c:	df000904 	addi	fp,sp,36
 2021220:	e13fff15 	stw	r4,-4(fp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 2021224:	e0bfff17 	ldw	r2,-4(fp)
 2021228:	10801d17 	ldw	r2,116(r2)
 202122c:	e0bffa15 	stw	r2,-24(fp)

  if(seg == NULL) {
 2021230:	e0bffa17 	ldw	r2,-24(fp)
 2021234:	1000031e 	bne	r2,zero,2021244 <tcp_zero_window_probe+0x34>
    seg = pcb->unsent;
 2021238:	e0bfff17 	ldw	r2,-4(fp)
 202123c:	10801c17 	ldw	r2,112(r2)
 2021240:	e0bffa15 	stw	r2,-24(fp)
  }
  if(seg == NULL) {
 2021244:	e0bffa17 	ldw	r2,-24(fp)
 2021248:	1000a326 	beq	r2,zero,20214d8 <tcp_zero_window_probe+0x2c8>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 202124c:	e0bffa17 	ldw	r2,-24(fp)
 2021250:	10800417 	ldw	r2,16(r2)
 2021254:	10c00303 	ldbu	r3,12(r2)
 2021258:	10800343 	ldbu	r2,13(r2)
 202125c:	1004923a 	slli	r2,r2,8
 2021260:	10c4b03a 	or	r2,r2,r3
 2021264:	10bfffcc 	andi	r2,r2,65535
 2021268:	1004d23a 	srli	r2,r2,8
 202126c:	10ffffcc 	andi	r3,r2,65535
 2021270:	e0bffa17 	ldw	r2,-24(fp)
 2021274:	10800417 	ldw	r2,16(r2)
 2021278:	11000303 	ldbu	r4,12(r2)
 202127c:	10800343 	ldbu	r2,13(r2)
 2021280:	1004923a 	slli	r2,r2,8
 2021284:	1104b03a 	or	r2,r2,r4
 2021288:	10bfffcc 	andi	r2,r2,65535
 202128c:	1004923a 	slli	r2,r2,8
 2021290:	10bfffcc 	andi	r2,r2,65535
 2021294:	1884b03a 	or	r2,r3,r2
 2021298:	1080004c 	andi	r2,r2,1
 202129c:	10000626 	beq	r2,zero,20212b8 <tcp_zero_window_probe+0xa8>
 20212a0:	e0bffa17 	ldw	r2,-24(fp)
 20212a4:	1080020b 	ldhu	r2,8(r2)
 20212a8:	10bfffcc 	andi	r2,r2,65535
 20212ac:	1000021e 	bne	r2,zero,20212b8 <tcp_zero_window_probe+0xa8>
 20212b0:	00800044 	movi	r2,1
 20212b4:	00000106 	br	20212bc <tcp_zero_window_probe+0xac>
 20212b8:	0005883a 	mov	r2,zero
 20212bc:	e0bffb05 	stb	r2,-20(fp)
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
 20212c0:	e0bffb03 	ldbu	r2,-20(fp)
 20212c4:	1005003a 	cmpeq	r2,r2,zero
 20212c8:	10803fcc 	andi	r2,r2,255
 20212cc:	e0bffb8d 	sth	r2,-18(fp)

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 20212d0:	e17ffb8b 	ldhu	r5,-18(fp)
 20212d4:	e0bffa17 	ldw	r2,-24(fp)
 20212d8:	10800417 	ldw	r2,16(r2)
 20212dc:	10c00103 	ldbu	r3,4(r2)
 20212e0:	11000143 	ldbu	r4,5(r2)
 20212e4:	2008923a 	slli	r4,r4,8
 20212e8:	20c6b03a 	or	r3,r4,r3
 20212ec:	11000183 	ldbu	r4,6(r2)
 20212f0:	2008943a 	slli	r4,r4,16
 20212f4:	20c6b03a 	or	r3,r4,r3
 20212f8:	108001c3 	ldbu	r2,7(r2)
 20212fc:	1004963a 	slli	r2,r2,24
 2021300:	10c4b03a 	or	r2,r2,r3
 2021304:	100f883a 	mov	r7,r2
 2021308:	280d883a 	mov	r6,r5
 202130c:	000b883a 	mov	r5,zero
 2021310:	e13fff17 	ldw	r4,-4(fp)
 2021314:	201de000 	call	201de00 <tcp_output_alloc_header>
 2021318:	e0bffc15 	stw	r2,-16(fp)
  if(p == NULL) {
 202131c:	e0bffc17 	ldw	r2,-16(fp)
 2021320:	10006f26 	beq	r2,zero,20214e0 <tcp_zero_window_probe+0x2d0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 2021324:	e0bffc17 	ldw	r2,-16(fp)
 2021328:	10800117 	ldw	r2,4(r2)
 202132c:	e0bffd15 	stw	r2,-12(fp)

  if (is_fin) {
 2021330:	e0bffb03 	ldbu	r2,-20(fp)
 2021334:	10001d26 	beq	r2,zero,20213ac <tcp_zero_window_probe+0x19c>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 2021338:	e0bffd17 	ldw	r2,-12(fp)
 202133c:	10c00303 	ldbu	r3,12(r2)
 2021340:	10800343 	ldbu	r2,13(r2)
 2021344:	1004923a 	slli	r2,r2,8
 2021348:	10c4b03a 	or	r2,r2,r3
 202134c:	1007883a 	mov	r3,r2
 2021350:	00b03fc4 	movi	r2,-16129
 2021354:	1884703a 	and	r2,r3,r2
 2021358:	10844014 	ori	r2,r2,4352
 202135c:	100d883a 	mov	r6,r2
 2021360:	e0bffd17 	ldw	r2,-12(fp)
 2021364:	30ffffcc 	andi	r3,r6,65535
 2021368:	19403fcc 	andi	r5,r3,255
 202136c:	10c00303 	ldbu	r3,12(r2)
 2021370:	1806703a 	and	r3,r3,zero
 2021374:	1809883a 	mov	r4,r3
 2021378:	2807883a 	mov	r3,r5
 202137c:	20c6b03a 	or	r3,r4,r3
 2021380:	10c00305 	stb	r3,12(r2)
 2021384:	30ffffcc 	andi	r3,r6,65535
 2021388:	1806d23a 	srli	r3,r3,8
 202138c:	197fffcc 	andi	r5,r3,65535
 2021390:	10c00343 	ldbu	r3,13(r2)
 2021394:	1806703a 	and	r3,r3,zero
 2021398:	1809883a 	mov	r4,r3
 202139c:	2807883a 	mov	r3,r5
 20213a0:	20c6b03a 	or	r3,r4,r3
 20213a4:	10c00345 	stb	r3,13(r2)
 20213a8:	00001106 	br	20213f0 <tcp_zero_window_probe+0x1e0>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
 20213ac:	e0bffc17 	ldw	r2,-16(fp)
 20213b0:	10800117 	ldw	r2,4(r2)
 20213b4:	10800504 	addi	r2,r2,20
 20213b8:	e0bffe15 	stw	r2,-8(fp)
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 20213bc:	e0bffa17 	ldw	r2,-24(fp)
 20213c0:	11000117 	ldw	r4,4(r2)
 20213c4:	e0bffa17 	ldw	r2,-24(fp)
 20213c8:	10800117 	ldw	r2,4(r2)
 20213cc:	10c0020b 	ldhu	r3,8(r2)
 20213d0:	e0bffa17 	ldw	r2,-24(fp)
 20213d4:	1080020b 	ldhu	r2,8(r2)
 20213d8:	1885c83a 	sub	r2,r3,r2
 20213dc:	10bfffcc 	andi	r2,r2,65535
 20213e0:	100f883a 	mov	r7,r2
 20213e4:	01800044 	movi	r6,1
 20213e8:	e17ffe17 	ldw	r5,-8(fp)
 20213ec:	201b16c0 	call	201b16c <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 20213f0:	e0ffff17 	ldw	r3,-4(fp)
 20213f4:	e0bfff17 	ldw	r2,-4(fp)
 20213f8:	11000104 	addi	r4,r2,4
                                      IP_PROTO_TCP, p->tot_len);
 20213fc:	e0bffc17 	ldw	r2,-16(fp)
 2021400:	1080020b 	ldhu	r2,8(r2)
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 2021404:	10bfffcc 	andi	r2,r2,65535
 2021408:	d8800015 	stw	r2,0(sp)
 202140c:	01c00184 	movi	r7,6
 2021410:	200d883a 	mov	r6,r4
 2021414:	180b883a 	mov	r5,r3
 2021418:	e13ffc17 	ldw	r4,-16(fp)
 202141c:	203173c0 	call	203173c <inet_chksum_pseudo>
 2021420:	100d883a 	mov	r6,r2
 2021424:	e0bffd17 	ldw	r2,-12(fp)
 2021428:	30ffffcc 	andi	r3,r6,65535
 202142c:	19403fcc 	andi	r5,r3,255
 2021430:	10c00403 	ldbu	r3,16(r2)
 2021434:	1806703a 	and	r3,r3,zero
 2021438:	1809883a 	mov	r4,r3
 202143c:	2807883a 	mov	r3,r5
 2021440:	20c6b03a 	or	r3,r4,r3
 2021444:	10c00405 	stb	r3,16(r2)
 2021448:	30ffffcc 	andi	r3,r6,65535
 202144c:	1806d23a 	srli	r3,r3,8
 2021450:	197fffcc 	andi	r5,r3,65535
 2021454:	10c00443 	ldbu	r3,17(r2)
 2021458:	1806703a 	and	r3,r3,zero
 202145c:	1809883a 	mov	r4,r3
 2021460:	2807883a 	mov	r3,r5
 2021464:	20c6b03a 	or	r3,r4,r3
 2021468:	10c00445 	stb	r3,17(r2)
                                      IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
 202146c:	008085f4 	movhi	r2,535
 2021470:	10a8bc04 	addi	r2,r2,-23824
 2021474:	10804817 	ldw	r2,288(r2)
 2021478:	10c00044 	addi	r3,r2,1
 202147c:	008085f4 	movhi	r2,535
 2021480:	10a8bc04 	addi	r2,r2,-23824
 2021484:	10c04815 	stw	r3,288(r2)

  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
 2021488:	e0ffff17 	ldw	r3,-4(fp)
 202148c:	e0bfff17 	ldw	r2,-4(fp)
 2021490:	11000104 	addi	r4,r2,4
 2021494:	e0bfff17 	ldw	r2,-4(fp)
 2021498:	10800283 	ldbu	r2,10(r2)
 202149c:	11403fcc 	andi	r5,r2,255
 20214a0:	e0bfff17 	ldw	r2,-4(fp)
 20214a4:	108002c4 	addi	r2,r2,11
 20214a8:	d8800215 	stw	r2,8(sp)
 20214ac:	00800184 	movi	r2,6
 20214b0:	d8800115 	stw	r2,4(sp)
 20214b4:	d8000015 	stw	zero,0(sp)
 20214b8:	280f883a 	mov	r7,r5
 20214bc:	200d883a 	mov	r6,r4
 20214c0:	180b883a 	mov	r5,r3
 20214c4:	e13ffc17 	ldw	r4,-16(fp)
 20214c8:	2032a480 	call	2032a48 <ip_output_hinted>
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 20214cc:	e13ffc17 	ldw	r4,-16(fp)
 20214d0:	201ab680 	call	201ab68 <pbuf_free>
 20214d4:	00000306 	br	20214e4 <tcp_zero_window_probe+0x2d4>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
 20214d8:	0001883a 	nop
 20214dc:	00000106 	br	20214e4 <tcp_zero_window_probe+0x2d4>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
 20214e0:	0001883a 	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 20214e4:	e037883a 	mov	sp,fp
 20214e8:	dfc00117 	ldw	ra,4(sp)
 20214ec:	df000017 	ldw	fp,0(sp)
 20214f0:	dec00204 	addi	sp,sp,8
 20214f4:	f800283a 	ret

020214f8 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 20214f8:	defffd04 	addi	sp,sp,-12
 20214fc:	dfc00215 	stw	ra,8(sp)
 2021500:	df000115 	stw	fp,4(sp)
 2021504:	df000104 	addi	fp,sp,4
 2021508:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 202150c:	201b9700 	call	201b970 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 2021510:	d0a7f717 	ldw	r2,-24612(gp)
 2021514:	1000021e 	bne	r2,zero,2021520 <tcpip_tcp_timer+0x28>
 2021518:	d0a7fc17 	ldw	r2,-24592(gp)
 202151c:	10000626 	beq	r2,zero,2021538 <tcpip_tcp_timer+0x40>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 2021520:	000d883a 	mov	r6,zero
 2021524:	014080b4 	movhi	r5,514
 2021528:	29453e04 	addi	r5,r5,5368
 202152c:	01003e84 	movi	r4,250
 2021530:	20217380 	call	2021738 <sys_timeout>
 2021534:	00000106 	br	202153c <tcpip_tcp_timer+0x44>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 2021538:	d027fe15 	stw	zero,-24584(gp)
  }
}
 202153c:	0001883a 	nop
 2021540:	e037883a 	mov	sp,fp
 2021544:	dfc00117 	ldw	ra,4(sp)
 2021548:	df000017 	ldw	fp,0(sp)
 202154c:	dec00204 	addi	sp,sp,8
 2021550:	f800283a 	ret

02021554 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 2021554:	defffe04 	addi	sp,sp,-8
 2021558:	dfc00115 	stw	ra,4(sp)
 202155c:	df000015 	stw	fp,0(sp)
 2021560:	d839883a 	mov	fp,sp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 2021564:	d0a7fe17 	ldw	r2,-24584(gp)
 2021568:	10000b1e 	bne	r2,zero,2021598 <tcp_timer_needed+0x44>
 202156c:	d0a7f717 	ldw	r2,-24612(gp)
 2021570:	1000021e 	bne	r2,zero,202157c <tcp_timer_needed+0x28>
 2021574:	d0a7fc17 	ldw	r2,-24592(gp)
 2021578:	10000726 	beq	r2,zero,2021598 <tcp_timer_needed+0x44>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 202157c:	00800044 	movi	r2,1
 2021580:	d0a7fe15 	stw	r2,-24584(gp)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 2021584:	000d883a 	mov	r6,zero
 2021588:	014080b4 	movhi	r5,514
 202158c:	29453e04 	addi	r5,r5,5368
 2021590:	01003e84 	movi	r4,250
 2021594:	20217380 	call	2021738 <sys_timeout>
  }
}
 2021598:	0001883a 	nop
 202159c:	e037883a 	mov	sp,fp
 20215a0:	dfc00117 	ldw	ra,4(sp)
 20215a4:	df000017 	ldw	fp,0(sp)
 20215a8:	dec00204 	addi	sp,sp,8
 20215ac:	f800283a 	ret

020215b0 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
 20215b0:	defffd04 	addi	sp,sp,-12
 20215b4:	dfc00215 	stw	ra,8(sp)
 20215b8:	df000115 	stw	fp,4(sp)
 20215bc:	df000104 	addi	fp,sp,4
 20215c0:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
 20215c4:	2032b180 	call	2032b18 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 20215c8:	000d883a 	mov	r6,zero
 20215cc:	014080b4 	movhi	r5,514
 20215d0:	29456c04 	addi	r5,r5,5552
 20215d4:	0100fa04 	movi	r4,1000
 20215d8:	20217380 	call	2021738 <sys_timeout>
}
 20215dc:	0001883a 	nop
 20215e0:	e037883a 	mov	sp,fp
 20215e4:	dfc00117 	ldw	ra,4(sp)
 20215e8:	df000017 	ldw	fp,0(sp)
 20215ec:	dec00204 	addi	sp,sp,8
 20215f0:	f800283a 	ret

020215f4 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
 20215f4:	defffd04 	addi	sp,sp,-12
 20215f8:	dfc00215 	stw	ra,8(sp)
 20215fc:	df000115 	stw	fp,4(sp)
 2021600:	df000104 	addi	fp,sp,4
 2021604:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
 2021608:	2022c780 	call	2022c78 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 202160c:	000d883a 	mov	r6,zero
 2021610:	014080b4 	movhi	r5,514
 2021614:	29457d04 	addi	r5,r5,5620
 2021618:	0104e204 	movi	r4,5000
 202161c:	20217380 	call	2021738 <sys_timeout>
}
 2021620:	0001883a 	nop
 2021624:	e037883a 	mov	sp,fp
 2021628:	dfc00117 	ldw	ra,4(sp)
 202162c:	df000017 	ldw	fp,0(sp)
 2021630:	dec00204 	addi	sp,sp,8
 2021634:	f800283a 	ret

02021638 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
 2021638:	defffd04 	addi	sp,sp,-12
 202163c:	dfc00215 	stw	ra,8(sp)
 2021640:	df000115 	stw	fp,4(sp)
 2021644:	df000104 	addi	fp,sp,4
 2021648:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
 202164c:	2015a740 	call	2015a74 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
 2021650:	000d883a 	mov	r6,zero
 2021654:	014080b4 	movhi	r5,514
 2021658:	29458e04 	addi	r5,r5,5688
 202165c:	013a9814 	movui	r4,60000
 2021660:	20217380 	call	2021738 <sys_timeout>
}
 2021664:	0001883a 	nop
 2021668:	e037883a 	mov	sp,fp
 202166c:	dfc00117 	ldw	ra,4(sp)
 2021670:	df000017 	ldw	fp,0(sp)
 2021674:	dec00204 	addi	sp,sp,8
 2021678:	f800283a 	ret

0202167c <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
 202167c:	defffd04 	addi	sp,sp,-12
 2021680:	dfc00215 	stw	ra,8(sp)
 2021684:	df000115 	stw	fp,4(sp)
 2021688:	df000104 	addi	fp,sp,4
 202168c:	e13fff15 	stw	r4,-4(fp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
 2021690:	2015b1c0 	call	2015b1c <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 2021694:	000d883a 	mov	r6,zero
 2021698:	014080b4 	movhi	r5,514
 202169c:	29459f04 	addi	r5,r5,5756
 20216a0:	01007d04 	movi	r4,500
 20216a4:	20217380 	call	2021738 <sys_timeout>
}
 20216a8:	0001883a 	nop
 20216ac:	e037883a 	mov	sp,fp
 20216b0:	dfc00117 	ldw	ra,4(sp)
 20216b4:	df000017 	ldw	fp,0(sp)
 20216b8:	dec00204 	addi	sp,sp,8
 20216bc:	f800283a 	ret

020216c0 <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
 20216c0:	defffe04 	addi	sp,sp,-8
 20216c4:	dfc00115 	stw	ra,4(sp)
 20216c8:	df000015 	stw	fp,0(sp)
 20216cc:	d839883a 	mov	fp,sp
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 20216d0:	000d883a 	mov	r6,zero
 20216d4:	014080b4 	movhi	r5,514
 20216d8:	29456c04 	addi	r5,r5,5552
 20216dc:	0100fa04 	movi	r4,1000
 20216e0:	20217380 	call	2021738 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 20216e4:	000d883a 	mov	r6,zero
 20216e8:	014080b4 	movhi	r5,514
 20216ec:	29457d04 	addi	r5,r5,5620
 20216f0:	0104e204 	movi	r4,5000
 20216f4:	20217380 	call	2021738 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
 20216f8:	000d883a 	mov	r6,zero
 20216fc:	014080b4 	movhi	r5,514
 2021700:	29458e04 	addi	r5,r5,5688
 2021704:	013a9814 	movui	r4,60000
 2021708:	20217380 	call	2021738 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 202170c:	000d883a 	mov	r6,zero
 2021710:	014080b4 	movhi	r5,514
 2021714:	29459f04 	addi	r5,r5,5756
 2021718:	01007d04 	movi	r4,500
 202171c:	20217380 	call	2021738 <sys_timeout>

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
 2021720:	0001883a 	nop
 2021724:	e037883a 	mov	sp,fp
 2021728:	dfc00117 	ldw	ra,4(sp)
 202172c:	df000017 	ldw	fp,0(sp)
 2021730:	dec00204 	addi	sp,sp,8
 2021734:	f800283a 	ret

02021738 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 2021738:	defff904 	addi	sp,sp,-28
 202173c:	dfc00615 	stw	ra,24(sp)
 2021740:	df000515 	stw	fp,20(sp)
 2021744:	df000504 	addi	fp,sp,20
 2021748:	e13ffd15 	stw	r4,-12(fp)
 202174c:	e17ffe15 	stw	r5,-8(fp)
 2021750:	e1bfff15 	stw	r6,-4(fp)
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 2021754:	01000304 	movi	r4,12
 2021758:	20344340 	call	2034434 <memp_malloc>
 202175c:	e0bffc15 	stw	r2,-16(fp)
  if (timeout == NULL) {
 2021760:	e0bffc17 	ldw	r2,-16(fp)
 2021764:	10004d26 	beq	r2,zero,202189c <sys_timeout+0x164>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 2021768:	e0bffc17 	ldw	r2,-16(fp)
 202176c:	10000015 	stw	zero,0(r2)
  timeout->h = handler;
 2021770:	e0bffc17 	ldw	r2,-16(fp)
 2021774:	e0fffe17 	ldw	r3,-8(fp)
 2021778:	10c00215 	stw	r3,8(r2)
  timeout->arg = arg;
 202177c:	e0bffc17 	ldw	r2,-16(fp)
 2021780:	e0ffff17 	ldw	r3,-4(fp)
 2021784:	10c00315 	stw	r3,12(r2)
  timeout->time = msecs;
 2021788:	e0bffc17 	ldw	r2,-16(fp)
 202178c:	e0fffd17 	ldw	r3,-12(fp)
 2021790:	10c00115 	stw	r3,4(r2)
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 2021794:	d0a7fd17 	ldw	r2,-24588(gp)
 2021798:	1000031e 	bne	r2,zero,20217a8 <sys_timeout+0x70>
    next_timeout = timeout;
 202179c:	e0bffc17 	ldw	r2,-16(fp)
 20217a0:	d0a7fd15 	stw	r2,-24588(gp)
    return;
 20217a4:	00003e06 	br	20218a0 <sys_timeout+0x168>
  }

  if (next_timeout->time > msecs) {
 20217a8:	d0a7fd17 	ldw	r2,-24588(gp)
 20217ac:	10800117 	ldw	r2,4(r2)
 20217b0:	e0fffd17 	ldw	r3,-12(fp)
 20217b4:	18800c2e 	bgeu	r3,r2,20217e8 <sys_timeout+0xb0>
    next_timeout->time -= msecs;
 20217b8:	d0a7fd17 	ldw	r2,-24588(gp)
 20217bc:	d0e7fd17 	ldw	r3,-24588(gp)
 20217c0:	19000117 	ldw	r4,4(r3)
 20217c4:	e0fffd17 	ldw	r3,-12(fp)
 20217c8:	20c7c83a 	sub	r3,r4,r3
 20217cc:	10c00115 	stw	r3,4(r2)
    timeout->next = next_timeout;
 20217d0:	d0e7fd17 	ldw	r3,-24588(gp)
 20217d4:	e0bffc17 	ldw	r2,-16(fp)
 20217d8:	10c00015 	stw	r3,0(r2)
    next_timeout = timeout;
 20217dc:	e0bffc17 	ldw	r2,-16(fp)
 20217e0:	d0a7fd15 	stw	r2,-24588(gp)
 20217e4:	00002e06 	br	20218a0 <sys_timeout+0x168>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 20217e8:	d0a7fd17 	ldw	r2,-24588(gp)
 20217ec:	e0bffb15 	stw	r2,-20(fp)
 20217f0:	00002706 	br	2021890 <sys_timeout+0x158>
      timeout->time -= t->time;
 20217f4:	e0bffc17 	ldw	r2,-16(fp)
 20217f8:	10c00117 	ldw	r3,4(r2)
 20217fc:	e0bffb17 	ldw	r2,-20(fp)
 2021800:	10800117 	ldw	r2,4(r2)
 2021804:	1887c83a 	sub	r3,r3,r2
 2021808:	e0bffc17 	ldw	r2,-16(fp)
 202180c:	10c00115 	stw	r3,4(r2)
      if (t->next == NULL || t->next->time > timeout->time) {
 2021810:	e0bffb17 	ldw	r2,-20(fp)
 2021814:	10800017 	ldw	r2,0(r2)
 2021818:	10000626 	beq	r2,zero,2021834 <sys_timeout+0xfc>
 202181c:	e0bffb17 	ldw	r2,-20(fp)
 2021820:	10800017 	ldw	r2,0(r2)
 2021824:	10800117 	ldw	r2,4(r2)
 2021828:	e0fffc17 	ldw	r3,-16(fp)
 202182c:	18c00117 	ldw	r3,4(r3)
 2021830:	1880142e 	bgeu	r3,r2,2021884 <sys_timeout+0x14c>
        if (t->next != NULL) {
 2021834:	e0bffb17 	ldw	r2,-20(fp)
 2021838:	10800017 	ldw	r2,0(r2)
 202183c:	10000926 	beq	r2,zero,2021864 <sys_timeout+0x12c>
          t->next->time -= timeout->time;
 2021840:	e0bffb17 	ldw	r2,-20(fp)
 2021844:	10800017 	ldw	r2,0(r2)
 2021848:	e0fffb17 	ldw	r3,-20(fp)
 202184c:	18c00017 	ldw	r3,0(r3)
 2021850:	19000117 	ldw	r4,4(r3)
 2021854:	e0fffc17 	ldw	r3,-16(fp)
 2021858:	18c00117 	ldw	r3,4(r3)
 202185c:	20c7c83a 	sub	r3,r4,r3
 2021860:	10c00115 	stw	r3,4(r2)
        }
        timeout->next = t->next;
 2021864:	e0bffb17 	ldw	r2,-20(fp)
 2021868:	10c00017 	ldw	r3,0(r2)
 202186c:	e0bffc17 	ldw	r2,-16(fp)
 2021870:	10c00015 	stw	r3,0(r2)
        t->next = timeout;
 2021874:	e0bffb17 	ldw	r2,-20(fp)
 2021878:	e0fffc17 	ldw	r3,-16(fp)
 202187c:	10c00015 	stw	r3,0(r2)
        break;
 2021880:	00000706 	br	20218a0 <sys_timeout+0x168>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 2021884:	e0bffb17 	ldw	r2,-20(fp)
 2021888:	10800017 	ldw	r2,0(r2)
 202188c:	e0bffb15 	stw	r2,-20(fp)
 2021890:	e0bffb17 	ldw	r2,-20(fp)
 2021894:	103fd71e 	bne	r2,zero,20217f4 <__alt_mem_mem_0+0xfd0017f4>
 2021898:	00000106 	br	20218a0 <sys_timeout+0x168>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
 202189c:	0001883a 	nop
        t->next = timeout;
        break;
      }
    }
  }
}
 20218a0:	e037883a 	mov	sp,fp
 20218a4:	dfc00117 	ldw	ra,4(sp)
 20218a8:	df000017 	ldw	fp,0(sp)
 20218ac:	dec00204 	addi	sp,sp,8
 20218b0:	f800283a 	ret

020218b4 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 20218b4:	defffa04 	addi	sp,sp,-24
 20218b8:	dfc00515 	stw	ra,20(sp)
 20218bc:	df000415 	stw	fp,16(sp)
 20218c0:	df000404 	addi	fp,sp,16
 20218c4:	e13ffe15 	stw	r4,-8(fp)
 20218c8:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
 20218cc:	d0a7fd17 	ldw	r2,-24588(gp)
 20218d0:	10002f26 	beq	r2,zero,2021990 <sys_untimeout+0xdc>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 20218d4:	d0a7fd17 	ldw	r2,-24588(gp)
 20218d8:	e0bffd15 	stw	r2,-12(fp)
 20218dc:	e03ffc15 	stw	zero,-16(fp)
 20218e0:	00002706 	br	2021980 <sys_untimeout+0xcc>
    if ((t->h == handler) && (t->arg == arg)) {
 20218e4:	e0bffd17 	ldw	r2,-12(fp)
 20218e8:	10c00217 	ldw	r3,8(r2)
 20218ec:	e0bffe17 	ldw	r2,-8(fp)
 20218f0:	18801e1e 	bne	r3,r2,202196c <sys_untimeout+0xb8>
 20218f4:	e0bffd17 	ldw	r2,-12(fp)
 20218f8:	10c00317 	ldw	r3,12(r2)
 20218fc:	e0bfff17 	ldw	r2,-4(fp)
 2021900:	18801a1e 	bne	r3,r2,202196c <sys_untimeout+0xb8>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 2021904:	e0bffc17 	ldw	r2,-16(fp)
 2021908:	1000041e 	bne	r2,zero,202191c <sys_untimeout+0x68>
        next_timeout = t->next;
 202190c:	e0bffd17 	ldw	r2,-12(fp)
 2021910:	10800017 	ldw	r2,0(r2)
 2021914:	d0a7fd15 	stw	r2,-24588(gp)
 2021918:	00000406 	br	202192c <sys_untimeout+0x78>
      } else {
        prev_t->next = t->next;
 202191c:	e0bffd17 	ldw	r2,-12(fp)
 2021920:	10c00017 	ldw	r3,0(r2)
 2021924:	e0bffc17 	ldw	r2,-16(fp)
 2021928:	10c00015 	stw	r3,0(r2)
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
 202192c:	e0bffd17 	ldw	r2,-12(fp)
 2021930:	10800017 	ldw	r2,0(r2)
 2021934:	10000926 	beq	r2,zero,202195c <sys_untimeout+0xa8>
        t->next->time += t->time;
 2021938:	e0bffd17 	ldw	r2,-12(fp)
 202193c:	10800017 	ldw	r2,0(r2)
 2021940:	e0fffd17 	ldw	r3,-12(fp)
 2021944:	18c00017 	ldw	r3,0(r3)
 2021948:	19000117 	ldw	r4,4(r3)
 202194c:	e0fffd17 	ldw	r3,-12(fp)
 2021950:	18c00117 	ldw	r3,4(r3)
 2021954:	20c7883a 	add	r3,r4,r3
 2021958:	10c00115 	stw	r3,4(r2)
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 202195c:	e17ffd17 	ldw	r5,-12(fp)
 2021960:	01000304 	movi	r4,12
 2021964:	20346000 	call	2034600 <memp_free>
      return;
 2021968:	00000a06 	br	2021994 <sys_untimeout+0xe0>

  if (next_timeout == NULL) {
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 202196c:	e0bffd17 	ldw	r2,-12(fp)
 2021970:	e0bffc15 	stw	r2,-16(fp)
 2021974:	e0bffd17 	ldw	r2,-12(fp)
 2021978:	10800017 	ldw	r2,0(r2)
 202197c:	e0bffd15 	stw	r2,-12(fp)
 2021980:	e0bffd17 	ldw	r2,-12(fp)
 2021984:	103fd71e 	bne	r2,zero,20218e4 <__alt_mem_mem_0+0xfd0018e4>
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
 2021988:	0001883a 	nop
 202198c:	00000106 	br	2021994 <sys_untimeout+0xe0>
sys_untimeout(sys_timeout_handler handler, void *arg)
{
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
    return;
 2021990:	0001883a 	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
 2021994:	e037883a 	mov	sp,fp
 2021998:	dfc00117 	ldw	ra,4(sp)
 202199c:	df000017 	ldw	fp,0(sp)
 20219a0:	dec00204 	addi	sp,sp,8
 20219a4:	f800283a 	ret

020219a8 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 20219a8:	defff804 	addi	sp,sp,-32
 20219ac:	dfc00715 	stw	ra,28(sp)
 20219b0:	df000615 	stw	fp,24(sp)
 20219b4:	df000604 	addi	fp,sp,24
 20219b8:	e13ffe15 	stw	r4,-8(fp)
 20219bc:	e17fff15 	stw	r5,-4(fp)
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 20219c0:	d0a7fd17 	ldw	r2,-24588(gp)
 20219c4:	1000061e 	bne	r2,zero,20219e0 <sys_timeouts_mbox_fetch+0x38>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 20219c8:	000d883a 	mov	r6,zero
 20219cc:	e17fff17 	ldw	r5,-4(fp)
 20219d0:	e13ffe17 	ldw	r4,-8(fp)
 20219d4:	20153f80 	call	20153f8 <sys_arch_mbox_fetch>
 20219d8:	e0bffa15 	stw	r2,-24(fp)
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 20219dc:	00003106 	br	2021aa4 <sys_timeouts_mbox_fetch+0xfc>

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  } else {
    if (next_timeout->time > 0) {
 20219e0:	d0a7fd17 	ldw	r2,-24588(gp)
 20219e4:	10800117 	ldw	r2,4(r2)
 20219e8:	10000826 	beq	r2,zero,2021a0c <sys_timeouts_mbox_fetch+0x64>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 20219ec:	d0a7fd17 	ldw	r2,-24588(gp)
 20219f0:	10800117 	ldw	r2,4(r2)
 20219f4:	100d883a 	mov	r6,r2
 20219f8:	e17fff17 	ldw	r5,-4(fp)
 20219fc:	e13ffe17 	ldw	r4,-8(fp)
 2021a00:	20153f80 	call	20153f8 <sys_arch_mbox_fetch>
 2021a04:	e0bffa15 	stw	r2,-24(fp)
 2021a08:	00000206 	br	2021a14 <sys_timeouts_mbox_fetch+0x6c>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
 2021a0c:	00bfffc4 	movi	r2,-1
 2021a10:	e0bffa15 	stw	r2,-24(fp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
 2021a14:	e0bffa17 	ldw	r2,-24(fp)
 2021a18:	10bfffd8 	cmpnei	r2,r2,-1
 2021a1c:	1000141e 	bne	r2,zero,2021a70 <sys_timeouts_mbox_fetch+0xc8>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
 2021a20:	d0a7fd17 	ldw	r2,-24588(gp)
 2021a24:	e0bffb15 	stw	r2,-20(fp)
      next_timeout = tmptimeout->next;
 2021a28:	e0bffb17 	ldw	r2,-20(fp)
 2021a2c:	10800017 	ldw	r2,0(r2)
 2021a30:	d0a7fd15 	stw	r2,-24588(gp)
      handler = tmptimeout->h;
 2021a34:	e0bffb17 	ldw	r2,-20(fp)
 2021a38:	10800217 	ldw	r2,8(r2)
 2021a3c:	e0bffc15 	stw	r2,-16(fp)
      arg = tmptimeout->arg;
 2021a40:	e0bffb17 	ldw	r2,-20(fp)
 2021a44:	10800317 	ldw	r2,12(r2)
 2021a48:	e0bffd15 	stw	r2,-12(fp)
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 2021a4c:	e17ffb17 	ldw	r5,-20(fp)
 2021a50:	01000304 	movi	r4,12
 2021a54:	20346000 	call	2034600 <memp_free>
      if (handler != NULL) {
 2021a58:	e0bffc17 	ldw	r2,-16(fp)
 2021a5c:	103fd826 	beq	r2,zero,20219c0 <__alt_mem_mem_0+0xfd0019c0>
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
 2021a60:	e0bffc17 	ldw	r2,-16(fp)
 2021a64:	e13ffd17 	ldw	r4,-12(fp)
 2021a68:	103ee83a 	callr	r2
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
 2021a6c:	003fd406 	br	20219c0 <__alt_mem_mem_0+0xfd0019c0>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
 2021a70:	d0a7fd17 	ldw	r2,-24588(gp)
 2021a74:	10800117 	ldw	r2,4(r2)
 2021a78:	e0fffa17 	ldw	r3,-24(fp)
 2021a7c:	1880072e 	bgeu	r3,r2,2021a9c <sys_timeouts_mbox_fetch+0xf4>
        next_timeout->time -= time_needed;
 2021a80:	d0a7fd17 	ldw	r2,-24588(gp)
 2021a84:	d0e7fd17 	ldw	r3,-24588(gp)
 2021a88:	19000117 	ldw	r4,4(r3)
 2021a8c:	e0fffa17 	ldw	r3,-24(fp)
 2021a90:	20c7c83a 	sub	r3,r4,r3
 2021a94:	10c00115 	stw	r3,4(r2)
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 2021a98:	00000206 	br	2021aa4 <sys_timeouts_mbox_fetch+0xfc>
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
        next_timeout->time -= time_needed;
      } else {
        next_timeout->time = 0;
 2021a9c:	d0a7fd17 	ldw	r2,-24588(gp)
 2021aa0:	10000115 	stw	zero,4(r2)
      }
    }
  }
}
 2021aa4:	0001883a 	nop
 2021aa8:	e037883a 	mov	sp,fp
 2021aac:	dfc00117 	ldw	ra,4(sp)
 2021ab0:	df000017 	ldw	fp,0(sp)
 2021ab4:	dec00204 	addi	sp,sp,8
 2021ab8:	f800283a 	ret

02021abc <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 2021abc:	deffff04 	addi	sp,sp,-4
 2021ac0:	df000015 	stw	fp,0(sp)
 2021ac4:	d839883a 	mov	fp,sp
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
 2021ac8:	0001883a 	nop
 2021acc:	e037883a 	mov	sp,fp
 2021ad0:	df000017 	ldw	fp,0(sp)
 2021ad4:	dec00104 	addi	sp,sp,4
 2021ad8:	f800283a 	ret

02021adc <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
 2021adc:	defffd04 	addi	sp,sp,-12
 2021ae0:	df000215 	stw	fp,8(sp)
 2021ae4:	df000204 	addi	fp,sp,8
  u16_t n = 0;
 2021ae8:	e03ffe0d 	sth	zero,-8(fp)
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 2021aec:	d0a0130b 	ldhu	r2,-32692(gp)
 2021af0:	10c00044 	addi	r3,r2,1
 2021af4:	d0e0130d 	sth	r3,-32692(gp)
 2021af8:	10ffffcc 	andi	r3,r2,65535
 2021afc:	00bfffd4 	movui	r2,65535
 2021b00:	1880021e 	bne	r3,r2,2021b0c <udp_new_port+0x30>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
 2021b04:	00b00004 	movi	r2,-16384
 2021b08:	d0a0130d 	sth	r2,-32692(gp)
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2021b0c:	d0a7ff17 	ldw	r2,-24580(gp)
 2021b10:	e0bfff15 	stw	r2,-4(fp)
 2021b14:	00001106 	br	2021b5c <udp_new_port+0x80>
    if (pcb->local_port == udp_port) {
 2021b18:	e0bfff17 	ldw	r2,-4(fp)
 2021b1c:	10c0048b 	ldhu	r3,18(r2)
 2021b20:	d0a0130b 	ldhu	r2,-32692(gp)
 2021b24:	18ffffcc 	andi	r3,r3,65535
 2021b28:	10bfffcc 	andi	r2,r2,65535
 2021b2c:	1880081e 	bne	r3,r2,2021b50 <udp_new_port+0x74>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 2021b30:	e0bffe0b 	ldhu	r2,-8(fp)
 2021b34:	10800044 	addi	r2,r2,1
 2021b38:	e0bffe0d 	sth	r2,-8(fp)
 2021b3c:	e0bffe0b 	ldhu	r2,-8(fp)
 2021b40:	10900030 	cmpltui	r2,r2,16384
 2021b44:	103fe91e 	bne	r2,zero,2021aec <__alt_mem_mem_0+0xfd001aec>
        return 0;
 2021b48:	0005883a 	mov	r2,zero
 2021b4c:	00000606 	br	2021b68 <udp_new_port+0x8c>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2021b50:	e0bfff17 	ldw	r2,-4(fp)
 2021b54:	10800317 	ldw	r2,12(r2)
 2021b58:	e0bfff15 	stw	r2,-4(fp)
 2021b5c:	e0bfff17 	ldw	r2,-4(fp)
 2021b60:	103fed1e 	bne	r2,zero,2021b18 <__alt_mem_mem_0+0xfd001b18>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
 2021b64:	d0a0130b 	ldhu	r2,-32692(gp)
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
 2021b68:	e037883a 	mov	sp,fp
 2021b6c:	df000017 	ldw	fp,0(sp)
 2021b70:	dec00104 	addi	sp,sp,4
 2021b74:	f800283a 	ret

02021b78 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 2021b78:	defff304 	addi	sp,sp,-52
 2021b7c:	dfc00c15 	stw	ra,48(sp)
 2021b80:	df000b15 	stw	fp,44(sp)
 2021b84:	df000b04 	addi	fp,sp,44
 2021b88:	e13ffe15 	stw	r4,-8(fp)
 2021b8c:	e17fff15 	stw	r5,-4(fp)
  u8_t local_match;
  u8_t broadcast;

  PERF_START;

  UDP_STATS_INC(udp.recv);
 2021b90:	008085f4 	movhi	r2,535
 2021b94:	10a8bc04 	addi	r2,r2,-23824
 2021b98:	10803d17 	ldw	r2,244(r2)
 2021b9c:	10c00044 	addi	r3,r2,1
 2021ba0:	008085f4 	movhi	r2,535
 2021ba4:	10a8bc04 	addi	r2,r2,-23824
 2021ba8:	10c03d15 	stw	r3,244(r2)

  iphdr = (struct ip_hdr *)p->payload;
 2021bac:	e0bffe17 	ldw	r2,-8(fp)
 2021bb0:	10800117 	ldw	r2,4(r2)
 2021bb4:	e0bffa15 	stw	r2,-24(fp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 2021bb8:	e0bffe17 	ldw	r2,-8(fp)
 2021bbc:	1080020b 	ldhu	r2,8(r2)
 2021bc0:	10ffffcc 	andi	r3,r2,65535
 2021bc4:	e0bffa17 	ldw	r2,-24(fp)
 2021bc8:	10800003 	ldbu	r2,0(r2)
 2021bcc:	10803fcc 	andi	r2,r2,255
 2021bd0:	108003cc 	andi	r2,r2,15
 2021bd4:	10800084 	addi	r2,r2,2
 2021bd8:	1085883a 	add	r2,r2,r2
 2021bdc:	1085883a 	add	r2,r2,r2
 2021be0:	18800f16 	blt	r3,r2,2021c20 <udp_input+0xa8>
 2021be4:	e0bffa17 	ldw	r2,-24(fp)
 2021be8:	10800003 	ldbu	r2,0(r2)
 2021bec:	10803fcc 	andi	r2,r2,255
 2021bf0:	108003cc 	andi	r2,r2,15
 2021bf4:	1085883a 	add	r2,r2,r2
 2021bf8:	1085883a 	add	r2,r2,r2
 2021bfc:	0085c83a 	sub	r2,zero,r2
 2021c00:	10bfffcc 	andi	r2,r2,65535
 2021c04:	10a0001c 	xori	r2,r2,32768
 2021c08:	10a00004 	addi	r2,r2,-32768
 2021c0c:	100b883a 	mov	r5,r2
 2021c10:	e13ffe17 	ldw	r4,-8(fp)
 2021c14:	201a9b80 	call	201a9b8 <pbuf_header>
 2021c18:	10803fcc 	andi	r2,r2,255
 2021c1c:	10001126 	beq	r2,zero,2021c64 <udp_input+0xec>
    /* drop short packets */
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
 2021c20:	008085f4 	movhi	r2,535
 2021c24:	10a8bc04 	addi	r2,r2,-23824
 2021c28:	10804117 	ldw	r2,260(r2)
 2021c2c:	10c00044 	addi	r3,r2,1
 2021c30:	008085f4 	movhi	r2,535
 2021c34:	10a8bc04 	addi	r2,r2,-23824
 2021c38:	10c04115 	stw	r3,260(r2)
    UDP_STATS_INC(udp.drop);
 2021c3c:	008085f4 	movhi	r2,535
 2021c40:	10a8bc04 	addi	r2,r2,-23824
 2021c44:	10803f17 	ldw	r2,252(r2)
 2021c48:	10c00044 	addi	r3,r2,1
 2021c4c:	008085f4 	movhi	r2,535
 2021c50:	10a8bc04 	addi	r2,r2,-23824
 2021c54:	10c03f15 	stw	r3,252(r2)
    snmp_inc_udpinerrors();
    pbuf_free(p);
 2021c58:	e13ffe17 	ldw	r4,-8(fp)
 2021c5c:	201ab680 	call	201ab68 <pbuf_free>
    goto end;
 2021c60:	00011f06 	br	20220e0 <udp_input+0x568>
  }

  udphdr = (struct udp_hdr *)p->payload;
 2021c64:	e0bffe17 	ldw	r2,-8(fp)
 2021c68:	10800117 	ldw	r2,4(r2)
 2021c6c:	e0bffb15 	stw	r2,-20(fp)

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 2021c70:	d0a81417 	ldw	r2,-24496(gp)
 2021c74:	e17fff17 	ldw	r5,-4(fp)
 2021c78:	1009883a 	mov	r4,r2
 2021c7c:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2021c80:	e0bffc05 	stb	r2,-16(fp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 2021c84:	e0bffb17 	ldw	r2,-20(fp)
 2021c88:	10c00003 	ldbu	r3,0(r2)
 2021c8c:	10800043 	ldbu	r2,1(r2)
 2021c90:	1004923a 	slli	r2,r2,8
 2021c94:	10c4b03a 	or	r2,r2,r3
 2021c98:	10bfffcc 	andi	r2,r2,65535
 2021c9c:	1004d23a 	srli	r2,r2,8
 2021ca0:	1009883a 	mov	r4,r2
 2021ca4:	e0bffb17 	ldw	r2,-20(fp)
 2021ca8:	10c00003 	ldbu	r3,0(r2)
 2021cac:	10800043 	ldbu	r2,1(r2)
 2021cb0:	1004923a 	slli	r2,r2,8
 2021cb4:	10c4b03a 	or	r2,r2,r3
 2021cb8:	10bfffcc 	andi	r2,r2,65535
 2021cbc:	1004923a 	slli	r2,r2,8
 2021cc0:	2084b03a 	or	r2,r4,r2
 2021cc4:	e0bffc8d 	sth	r2,-14(fp)
  dest = ntohs(udphdr->dest);
 2021cc8:	e0bffb17 	ldw	r2,-20(fp)
 2021ccc:	10c00083 	ldbu	r3,2(r2)
 2021cd0:	108000c3 	ldbu	r2,3(r2)
 2021cd4:	1004923a 	slli	r2,r2,8
 2021cd8:	10c4b03a 	or	r2,r2,r3
 2021cdc:	10bfffcc 	andi	r2,r2,65535
 2021ce0:	1004d23a 	srli	r2,r2,8
 2021ce4:	1009883a 	mov	r4,r2
 2021ce8:	e0bffb17 	ldw	r2,-20(fp)
 2021cec:	10c00083 	ldbu	r3,2(r2)
 2021cf0:	108000c3 	ldbu	r2,3(r2)
 2021cf4:	1004923a 	slli	r2,r2,8
 2021cf8:	10c4b03a 	or	r2,r2,r3
 2021cfc:	10bfffcc 	andi	r2,r2,65535
 2021d00:	1004923a 	slli	r2,r2,8
 2021d04:	2084b03a 	or	r2,r4,r2
 2021d08:	e0bffd0d 	sth	r2,-12(fp)
               ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
               ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
 2021d0c:	e03ff615 	stw	zero,-40(fp)
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
 2021d10:	e0bffd0b 	ldhu	r2,-12(fp)
 2021d14:	10801118 	cmpnei	r2,r2,68
 2021d18:	10001f1e 	bne	r2,zero,2021d98 <udp_input+0x220>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
 2021d1c:	e0bffc8b 	ldhu	r2,-14(fp)
 2021d20:	108010d8 	cmpnei	r2,r2,67
 2021d24:	10007a1e 	bne	r2,zero,2021f10 <udp_input+0x398>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 2021d28:	e0bfff17 	ldw	r2,-4(fp)
 2021d2c:	10800a17 	ldw	r2,40(r2)
 2021d30:	10007726 	beq	r2,zero,2021f10 <udp_input+0x398>
 2021d34:	e0bfff17 	ldw	r2,-4(fp)
 2021d38:	10800a17 	ldw	r2,40(r2)
 2021d3c:	10800117 	ldw	r2,4(r2)
 2021d40:	10007326 	beq	r2,zero,2021f10 <udp_input+0x398>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 2021d44:	e0bfff17 	ldw	r2,-4(fp)
 2021d48:	10800a17 	ldw	r2,40(r2)
 2021d4c:	10800117 	ldw	r2,4(r2)
 2021d50:	10800104 	addi	r2,r2,4
 2021d54:	10000b26 	beq	r2,zero,2021d84 <udp_input+0x20c>
 2021d58:	e0bfff17 	ldw	r2,-4(fp)
 2021d5c:	10800a17 	ldw	r2,40(r2)
 2021d60:	10800117 	ldw	r2,4(r2)
 2021d64:	10800117 	ldw	r2,4(r2)
 2021d68:	10000626 	beq	r2,zero,2021d84 <udp_input+0x20c>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
 2021d6c:	e0bfff17 	ldw	r2,-4(fp)
 2021d70:	10800a17 	ldw	r2,40(r2)
 2021d74:	10800117 	ldw	r2,4(r2)
 2021d78:	10c00117 	ldw	r3,4(r2)
 2021d7c:	d0a81217 	ldw	r2,-24504(gp)
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 2021d80:	1880631e 	bne	r3,r2,2021f10 <udp_input+0x398>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
          pcb = inp->dhcp->pcb;
 2021d84:	e0bfff17 	ldw	r2,-4(fp)
 2021d88:	10800a17 	ldw	r2,40(r2)
 2021d8c:	10800117 	ldw	r2,4(r2)
 2021d90:	e0bff615 	stw	r2,-40(fp)
 2021d94:	00005e06 	br	2021f10 <udp_input+0x398>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
 2021d98:	e03ff715 	stw	zero,-36(fp)
    local_match = 0;
 2021d9c:	e03ff905 	stb	zero,-28(fp)
    uncon_pcb = NULL;
 2021da0:	e03ff815 	stw	zero,-32(fp)
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2021da4:	d0a7ff17 	ldw	r2,-24580(gp)
 2021da8:	e0bff615 	stw	r2,-40(fp)
 2021dac:	00005206 	br	2021ef8 <udp_input+0x380>
      local_match = 0;
 2021db0:	e03ff905 	stb	zero,-28(fp)
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
 2021db4:	e0bff617 	ldw	r2,-40(fp)
 2021db8:	1080048b 	ldhu	r2,18(r2)
 2021dbc:	10ffffcc 	andi	r3,r2,65535
 2021dc0:	e0bffd0b 	ldhu	r2,-12(fp)
 2021dc4:	1880221e 	bne	r3,r2,2021e50 <udp_input+0x2d8>
 2021dc8:	e0bffc03 	ldbu	r2,-16(fp)
 2021dcc:	1000051e 	bne	r2,zero,2021de4 <udp_input+0x26c>
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 2021dd0:	e0bff617 	ldw	r2,-40(fp)
 2021dd4:	10001326 	beq	r2,zero,2021e24 <udp_input+0x2ac>
 2021dd8:	e0bff617 	ldw	r2,-40(fp)
 2021ddc:	10800017 	ldw	r2,0(r2)
 2021de0:	10001026 	beq	r2,zero,2021e24 <udp_input+0x2ac>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 2021de4:	e0bff617 	ldw	r2,-40(fp)
 2021de8:	10c00017 	ldw	r3,0(r2)
 2021dec:	d0a81417 	ldw	r2,-24496(gp)
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          ((!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 2021df0:	18800c26 	beq	r3,r2,2021e24 <udp_input+0x2ac>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 2021df4:	e0bffc03 	ldbu	r2,-16(fp)
 2021df8:	10001526 	beq	r2,zero,2021e50 <udp_input+0x2d8>
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
 2021dfc:	e0bff617 	ldw	r2,-40(fp)
 2021e00:	10c00017 	ldw	r3,0(r2)
 2021e04:	e0bfff17 	ldw	r2,-4(fp)
 2021e08:	10800117 	ldw	r2,4(r2)
           ip_addr_ismulticast(&current_iphdr_dest) ||
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
 2021e0c:	18800526 	beq	r3,r2,2021e24 <udp_input+0x2ac>
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
 2021e10:	e0bff617 	ldw	r2,-40(fp)
#endif /* LWIP_IGMP */
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
 2021e14:	10000326 	beq	r2,zero,2021e24 <udp_input+0x2ac>
			 ip_addr_isany(&pcb->local_ip))))) {
 2021e18:	e0bff617 	ldw	r2,-40(fp)
 2021e1c:	10800017 	ldw	r2,0(r2)
 2021e20:	10000b1e 	bne	r2,zero,2021e50 <udp_input+0x2d8>
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
 2021e24:	00800044 	movi	r2,1
 2021e28:	e0bff905 	stb	r2,-28(fp)
          if ((uncon_pcb == NULL) && 
 2021e2c:	e0bff817 	ldw	r2,-32(fp)
 2021e30:	1000071e 	bne	r2,zero,2021e50 <udp_input+0x2d8>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 2021e34:	e0bff617 	ldw	r2,-40(fp)
 2021e38:	10800403 	ldbu	r2,16(r2)
 2021e3c:	10803fcc 	andi	r2,r2,255
 2021e40:	1080010c 	andi	r2,r2,4
            (broadcast &&
			(ip_addr_cmp(&(pcb->local_ip), &(inp->ip_addr)) || 
			 ip_addr_isany(&pcb->local_ip))))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 2021e44:	1000021e 	bne	r2,zero,2021e50 <udp_input+0x2d8>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
 2021e48:	e0bff617 	ldw	r2,-40(fp)
 2021e4c:	e0bff815 	stw	r2,-32(fp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 2021e50:	e0bff903 	ldbu	r2,-28(fp)
 2021e54:	10002326 	beq	r2,zero,2021ee4 <udp_input+0x36c>
          (pcb->remote_port == src) &&
 2021e58:	e0bff617 	ldw	r2,-40(fp)
 2021e5c:	1080050b 	ldhu	r2,20(r2)
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 2021e60:	10ffffcc 	andi	r3,r2,65535
 2021e64:	e0bffc8b 	ldhu	r2,-14(fp)
 2021e68:	18801e1e 	bne	r3,r2,2021ee4 <udp_input+0x36c>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 2021e6c:	e0bff617 	ldw	r2,-40(fp)
 2021e70:	10800104 	addi	r2,r2,4
            uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
 2021e74:	10000726 	beq	r2,zero,2021e94 <udp_input+0x31c>
          (ip_addr_isany(&pcb->remote_ip) ||
 2021e78:	e0bff617 	ldw	r2,-40(fp)
 2021e7c:	10800117 	ldw	r2,4(r2)
 2021e80:	10000426 	beq	r2,zero,2021e94 <udp_input+0x31c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 2021e84:	e0bff617 	ldw	r2,-40(fp)
 2021e88:	10c00117 	ldw	r3,4(r2)
 2021e8c:	d0a81217 	ldw	r2,-24504(gp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 2021e90:	1880141e 	bne	r3,r2,2021ee4 <udp_input+0x36c>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 2021e94:	e0bff717 	ldw	r2,-36(fp)
 2021e98:	10000a26 	beq	r2,zero,2021ec4 <udp_input+0x34c>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 2021e9c:	e0bff617 	ldw	r2,-40(fp)
 2021ea0:	10c00317 	ldw	r3,12(r2)
 2021ea4:	e0bff717 	ldw	r2,-36(fp)
 2021ea8:	10c00315 	stw	r3,12(r2)
          pcb->next = udp_pcbs;
 2021eac:	d0e7ff17 	ldw	r3,-24580(gp)
 2021eb0:	e0bff617 	ldw	r2,-40(fp)
 2021eb4:	10c00315 	stw	r3,12(r2)
          udp_pcbs = pcb;
 2021eb8:	e0bff617 	ldw	r2,-40(fp)
 2021ebc:	d0a7ff15 	stw	r2,-24580(gp)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 2021ec0:	00000f06 	br	2021f00 <udp_input+0x388>
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
 2021ec4:	008085f4 	movhi	r2,535
 2021ec8:	10a8bc04 	addi	r2,r2,-23824
 2021ecc:	10804717 	ldw	r2,284(r2)
 2021ed0:	10c00044 	addi	r3,r2,1
 2021ed4:	008085f4 	movhi	r2,535
 2021ed8:	10a8bc04 	addi	r2,r2,-23824
 2021edc:	10c04715 	stw	r3,284(r2)
        }
        break;
 2021ee0:	00000706 	br	2021f00 <udp_input+0x388>
      }
      prev = pcb;
 2021ee4:	e0bff617 	ldw	r2,-40(fp)
 2021ee8:	e0bff715 	stw	r2,-36(fp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 2021eec:	e0bff617 	ldw	r2,-40(fp)
 2021ef0:	10800317 	ldw	r2,12(r2)
 2021ef4:	e0bff615 	stw	r2,-40(fp)
 2021ef8:	e0bff617 	ldw	r2,-40(fp)
 2021efc:	103fac1e 	bne	r2,zero,2021db0 <__alt_mem_mem_0+0xfd001db0>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
 2021f00:	e0bff617 	ldw	r2,-40(fp)
 2021f04:	1000021e 	bne	r2,zero,2021f10 <udp_input+0x398>
      pcb = uncon_pcb;
 2021f08:	e0bff817 	ldw	r2,-32(fp)
 2021f0c:	e0bff615 	stw	r2,-40(fp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 2021f10:	e0bff617 	ldw	r2,-40(fp)
 2021f14:	1000041e 	bne	r2,zero,2021f28 <udp_input+0x3b0>
 2021f18:	e0bfff17 	ldw	r2,-4(fp)
 2021f1c:	10c00117 	ldw	r3,4(r2)
 2021f20:	d0a81417 	ldw	r2,-24496(gp)
 2021f24:	18806c1e 	bne	r3,r2,20220d8 <udp_input+0x560>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
 2021f28:	e0bffb17 	ldw	r2,-20(fp)
 2021f2c:	10c00183 	ldbu	r3,6(r2)
 2021f30:	108001c3 	ldbu	r2,7(r2)
 2021f34:	1004923a 	slli	r2,r2,8
 2021f38:	10c4b03a 	or	r2,r2,r3
 2021f3c:	10bfffcc 	andi	r2,r2,65535
 2021f40:	10001c26 	beq	r2,zero,2021fb4 <udp_input+0x43c>
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
                               IP_PROTO_UDP, p->tot_len) != 0) {
 2021f44:	e0bffe17 	ldw	r2,-8(fp)
 2021f48:	1080020b 	ldhu	r2,8(r2)
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 2021f4c:	10bfffcc 	andi	r2,r2,65535
 2021f50:	d8800015 	stw	r2,0(sp)
 2021f54:	01c00444 	movi	r7,17
 2021f58:	d1a81404 	addi	r6,gp,-24496
 2021f5c:	d1681204 	addi	r5,gp,-24504
 2021f60:	e13ffe17 	ldw	r4,-8(fp)
 2021f64:	203173c0 	call	203173c <inet_chksum_pseudo>
 2021f68:	10bfffcc 	andi	r2,r2,65535
 2021f6c:	10001126 	beq	r2,zero,2021fb4 <udp_input+0x43c>
                               IP_PROTO_UDP, p->tot_len) != 0) {
          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
 2021f70:	008085f4 	movhi	r2,535
 2021f74:	10a8bc04 	addi	r2,r2,-23824
 2021f78:	10804017 	ldw	r2,256(r2)
 2021f7c:	10c00044 	addi	r3,r2,1
 2021f80:	008085f4 	movhi	r2,535
 2021f84:	10a8bc04 	addi	r2,r2,-23824
 2021f88:	10c04015 	stw	r3,256(r2)
          UDP_STATS_INC(udp.drop);
 2021f8c:	008085f4 	movhi	r2,535
 2021f90:	10a8bc04 	addi	r2,r2,-23824
 2021f94:	10803f17 	ldw	r2,252(r2)
 2021f98:	10c00044 	addi	r3,r2,1
 2021f9c:	008085f4 	movhi	r2,535
 2021fa0:	10a8bc04 	addi	r2,r2,-23824
 2021fa4:	10c03f15 	stw	r3,252(r2)
          snmp_inc_udpinerrors();
          pbuf_free(p);
 2021fa8:	e13ffe17 	ldw	r4,-8(fp)
 2021fac:	201ab680 	call	201ab68 <pbuf_free>
          goto end;
 2021fb0:	00004b06 	br	20220e0 <udp_input+0x568>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 2021fb4:	017ffe04 	movi	r5,-8
 2021fb8:	e13ffe17 	ldw	r4,-8(fp)
 2021fbc:	201a9b80 	call	201a9b8 <pbuf_header>
 2021fc0:	10803fcc 	andi	r2,r2,255
 2021fc4:	10000a26 	beq	r2,zero,2021ff0 <udp_input+0x478>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
 2021fc8:	008085f4 	movhi	r2,535
 2021fcc:	10a8bc04 	addi	r2,r2,-23824
 2021fd0:	10803f17 	ldw	r2,252(r2)
 2021fd4:	10c00044 	addi	r3,r2,1
 2021fd8:	008085f4 	movhi	r2,535
 2021fdc:	10a8bc04 	addi	r2,r2,-23824
 2021fe0:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpinerrors();
      pbuf_free(p);
 2021fe4:	e13ffe17 	ldw	r4,-8(fp)
 2021fe8:	201ab680 	call	201ab68 <pbuf_free>
      goto end;
 2021fec:	00003c06 	br	20220e0 <udp_input+0x568>
    }
    if (pcb != NULL) {
 2021ff0:	e0bff617 	ldw	r2,-40(fp)
 2021ff4:	10001126 	beq	r2,zero,202203c <udp_input+0x4c4>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 2021ff8:	e0bff617 	ldw	r2,-40(fp)
 2021ffc:	10800617 	ldw	r2,24(r2)
 2022000:	10000b26 	beq	r2,zero,2022030 <udp_input+0x4b8>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 2022004:	e0bff617 	ldw	r2,-40(fp)
 2022008:	10800617 	ldw	r2,24(r2)
 202200c:	e0fff617 	ldw	r3,-40(fp)
 2022010:	19000717 	ldw	r4,28(r3)
 2022014:	e0fffc8b 	ldhu	r3,-14(fp)
 2022018:	d8c00015 	stw	r3,0(sp)
 202201c:	d1e81204 	addi	r7,gp,-24504
 2022020:	e1bffe17 	ldw	r6,-8(fp)
 2022024:	e17ff617 	ldw	r5,-40(fp)
 2022028:	103ee83a 	callr	r2
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 202202c:	00002c06 	br	20220e0 <udp_input+0x568>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 2022030:	e13ffe17 	ldw	r4,-8(fp)
 2022034:	201ab680 	call	201ab68 <pbuf_free>
        goto end;
 2022038:	00002906 	br	20220e0 <udp_input+0x568>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 202203c:	e0bffc03 	ldbu	r2,-16(fp)
 2022040:	1000141e 	bne	r2,zero,2022094 <udp_input+0x51c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 2022044:	d0a81417 	ldw	r2,-24496(gp)
 2022048:	10803c0c 	andi	r2,r2,240
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 202204c:	10803820 	cmpeqi	r2,r2,224
 2022050:	1000101e 	bne	r2,zero,2022094 <udp_input+0x51c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 2022054:	e0bffa17 	ldw	r2,-24(fp)
 2022058:	10800003 	ldbu	r2,0(r2)
 202205c:	10803fcc 	andi	r2,r2,255
 2022060:	108003cc 	andi	r2,r2,15
 2022064:	10800084 	addi	r2,r2,2
 2022068:	1085883a 	add	r2,r2,r2
 202206c:	1085883a 	add	r2,r2,r2
 2022070:	10bfffcc 	andi	r2,r2,65535
 2022074:	10a0001c 	xori	r2,r2,32768
 2022078:	10a00004 	addi	r2,r2,-32768
 202207c:	100b883a 	mov	r5,r2
 2022080:	e13ffe17 	ldw	r4,-8(fp)
 2022084:	201a9b80 	call	201a9b8 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 2022088:	014000c4 	movi	r5,3
 202208c:	e13ffe17 	ldw	r4,-8(fp)
 2022090:	20312980 	call	2031298 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
 2022094:	008085f4 	movhi	r2,535
 2022098:	10a8bc04 	addi	r2,r2,-23824
 202209c:	10804417 	ldw	r2,272(r2)
 20220a0:	10c00044 	addi	r3,r2,1
 20220a4:	008085f4 	movhi	r2,535
 20220a8:	10a8bc04 	addi	r2,r2,-23824
 20220ac:	10c04415 	stw	r3,272(r2)
      UDP_STATS_INC(udp.drop);
 20220b0:	008085f4 	movhi	r2,535
 20220b4:	10a8bc04 	addi	r2,r2,-23824
 20220b8:	10803f17 	ldw	r2,252(r2)
 20220bc:	10c00044 	addi	r3,r2,1
 20220c0:	008085f4 	movhi	r2,535
 20220c4:	10a8bc04 	addi	r2,r2,-23824
 20220c8:	10c03f15 	stw	r3,252(r2)
      snmp_inc_udpnoports();
      pbuf_free(p);
 20220cc:	e13ffe17 	ldw	r4,-8(fp)
 20220d0:	201ab680 	call	201ab68 <pbuf_free>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 20220d4:	00000206 	br	20220e0 <udp_input+0x568>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
 20220d8:	e13ffe17 	ldw	r4,-8(fp)
 20220dc:	201ab680 	call	201ab68 <pbuf_free>
  }
end:
  PERF_STOP("udp_input");
}
 20220e0:	0001883a 	nop
 20220e4:	e037883a 	mov	sp,fp
 20220e8:	dfc00117 	ldw	ra,4(sp)
 20220ec:	df000017 	ldw	fp,0(sp)
 20220f0:	dec00204 	addi	sp,sp,8
 20220f4:	f800283a 	ret

020220f8 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 20220f8:	defffc04 	addi	sp,sp,-16
 20220fc:	dfc00315 	stw	ra,12(sp)
 2022100:	df000215 	stw	fp,8(sp)
 2022104:	df000204 	addi	fp,sp,8
 2022108:	e13ffe15 	stw	r4,-8(fp)
 202210c:	e17fff15 	stw	r5,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 2022110:	e0bffe17 	ldw	r2,-8(fp)
 2022114:	10c00104 	addi	r3,r2,4
 2022118:	e0bffe17 	ldw	r2,-8(fp)
 202211c:	1080050b 	ldhu	r2,20(r2)
 2022120:	10bfffcc 	andi	r2,r2,65535
 2022124:	100f883a 	mov	r7,r2
 2022128:	180d883a 	mov	r6,r3
 202212c:	e17fff17 	ldw	r5,-4(fp)
 2022130:	e13ffe17 	ldw	r4,-8(fp)
 2022134:	20221c00 	call	20221c0 <udp_sendto>
}
 2022138:	e037883a 	mov	sp,fp
 202213c:	dfc00117 	ldw	ra,4(sp)
 2022140:	df000017 	ldw	fp,0(sp)
 2022144:	dec00204 	addi	sp,sp,8
 2022148:	f800283a 	ret

0202214c <udp_send_chksum>:
/** Same as udp_send() but with checksum
 */
err_t
udp_send_chksum(struct udp_pcb *pcb, struct pbuf *p,
                u8_t have_chksum, u16_t chksum)
{
 202214c:	defff804 	addi	sp,sp,-32
 2022150:	dfc00715 	stw	ra,28(sp)
 2022154:	df000615 	stw	fp,24(sp)
 2022158:	df000604 	addi	fp,sp,24
 202215c:	e13ffc15 	stw	r4,-16(fp)
 2022160:	e17ffd15 	stw	r5,-12(fp)
 2022164:	3007883a 	mov	r3,r6
 2022168:	3805883a 	mov	r2,r7
 202216c:	e0fffe05 	stb	r3,-8(fp)
 2022170:	e0bfff0d 	sth	r2,-4(fp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto_chksum(pcb, p, &pcb->remote_ip, pcb->remote_port,
 2022174:	e0bffc17 	ldw	r2,-16(fp)
 2022178:	11000104 	addi	r4,r2,4
 202217c:	e0bffc17 	ldw	r2,-16(fp)
 2022180:	1080050b 	ldhu	r2,20(r2)
 2022184:	117fffcc 	andi	r5,r2,65535
 2022188:	e0bffe03 	ldbu	r2,-8(fp)
 202218c:	e0ffff0b 	ldhu	r3,-4(fp)
 2022190:	d8c00115 	stw	r3,4(sp)
 2022194:	d8800015 	stw	r2,0(sp)
 2022198:	280f883a 	mov	r7,r5
 202219c:	200d883a 	mov	r6,r4
 20221a0:	e17ffd17 	ldw	r5,-12(fp)
 20221a4:	e13ffc17 	ldw	r4,-16(fp)
 20221a8:	20222180 	call	2022218 <udp_sendto_chksum>
    have_chksum, chksum);
}
 20221ac:	e037883a 	mov	sp,fp
 20221b0:	dfc00117 	ldw	ra,4(sp)
 20221b4:	df000017 	ldw	fp,0(sp)
 20221b8:	dec00204 	addi	sp,sp,8
 20221bc:	f800283a 	ret

020221c0 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
 20221c0:	defff804 	addi	sp,sp,-32
 20221c4:	dfc00715 	stw	ra,28(sp)
 20221c8:	df000615 	stw	fp,24(sp)
 20221cc:	df000604 	addi	fp,sp,24
 20221d0:	e13ffc15 	stw	r4,-16(fp)
 20221d4:	e17ffd15 	stw	r5,-12(fp)
 20221d8:	e1bffe15 	stw	r6,-8(fp)
 20221dc:	3805883a 	mov	r2,r7
 20221e0:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
 20221e4:	e0bfff0b 	ldhu	r2,-4(fp)
 20221e8:	d8000115 	stw	zero,4(sp)
 20221ec:	d8000015 	stw	zero,0(sp)
 20221f0:	100f883a 	mov	r7,r2
 20221f4:	e1bffe17 	ldw	r6,-8(fp)
 20221f8:	e17ffd17 	ldw	r5,-12(fp)
 20221fc:	e13ffc17 	ldw	r4,-16(fp)
 2022200:	20222180 	call	2022218 <udp_sendto_chksum>
}
 2022204:	e037883a 	mov	sp,fp
 2022208:	dfc00117 	ldw	ra,4(sp)
 202220c:	df000017 	ldw	fp,0(sp)
 2022210:	dec00204 	addi	sp,sp,8
 2022214:	f800283a 	ret

02022218 <udp_sendto_chksum>:

/** Same as udp_sendto(), but with checksum */
err_t
udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                  u16_t dst_port, u8_t have_chksum, u16_t chksum)
{
 2022218:	defff404 	addi	sp,sp,-48
 202221c:	dfc00b15 	stw	ra,44(sp)
 2022220:	df000a15 	stw	fp,40(sp)
 2022224:	df000a04 	addi	fp,sp,40
 2022228:	e13ffa15 	stw	r4,-24(fp)
 202222c:	e17ffb15 	stw	r5,-20(fp)
 2022230:	e1bffc15 	stw	r6,-16(fp)
 2022234:	3809883a 	mov	r4,r7
 2022238:	e0c00217 	ldw	r3,8(fp)
 202223c:	e0800317 	ldw	r2,12(fp)
 2022240:	e13ffd0d 	sth	r4,-12(fp)
 2022244:	e0fffe05 	stb	r3,-8(fp)
 2022248:	e0bfff0d 	sth	r2,-4(fp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(&(pcb->local_ip), dst_ip);
 202224c:	e0bffa17 	ldw	r2,-24(fp)
 2022250:	e17ffc17 	ldw	r5,-16(fp)
 2022254:	1009883a 	mov	r4,r2
 2022258:	2031d1c0 	call	2031d1c <ip_route>
 202225c:	e0bff915 	stw	r2,-28(fp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 2022260:	e0bff917 	ldw	r2,-28(fp)
 2022264:	1000091e 	bne	r2,zero,202228c <udp_sendto_chksum+0x74>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
 2022268:	008085f4 	movhi	r2,535
 202226c:	10a8bc04 	addi	r2,r2,-23824
 2022270:	10804317 	ldw	r2,268(r2)
 2022274:	10c00044 	addi	r3,r2,1
 2022278:	008085f4 	movhi	r2,535
 202227c:	10a8bc04 	addi	r2,r2,-23824
 2022280:	10c04315 	stw	r3,268(r2)
    return ERR_RTE;
 2022284:	00bfff04 	movi	r2,-4
 2022288:	00000c06 	br	20222bc <udp_sendto_chksum+0xa4>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
 202228c:	e13ffd0b 	ldhu	r4,-12(fp)
 2022290:	e0bffe03 	ldbu	r2,-8(fp)
 2022294:	e0ffff0b 	ldhu	r3,-4(fp)
 2022298:	d8c00215 	stw	r3,8(sp)
 202229c:	d8800115 	stw	r2,4(sp)
 20222a0:	e0bff917 	ldw	r2,-28(fp)
 20222a4:	d8800015 	stw	r2,0(sp)
 20222a8:	200f883a 	mov	r7,r4
 20222ac:	e1bffc17 	ldw	r6,-16(fp)
 20222b0:	e17ffb17 	ldw	r5,-20(fp)
 20222b4:	e13ffa17 	ldw	r4,-24(fp)
 20222b8:	20223300 	call	2022330 <udp_sendto_if_chksum>
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
#endif /* LWIP_CHECKSUM_ON_COPY */
}
 20222bc:	e037883a 	mov	sp,fp
 20222c0:	dfc00117 	ldw	ra,4(sp)
 20222c4:	df000017 	ldw	fp,0(sp)
 20222c8:	dec00204 	addi	sp,sp,8
 20222cc:	f800283a 	ret

020222d0 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 20222d0:	defff704 	addi	sp,sp,-36
 20222d4:	dfc00815 	stw	ra,32(sp)
 20222d8:	df000715 	stw	fp,28(sp)
 20222dc:	df000704 	addi	fp,sp,28
 20222e0:	e13ffc15 	stw	r4,-16(fp)
 20222e4:	e17ffd15 	stw	r5,-12(fp)
 20222e8:	e1bffe15 	stw	r6,-8(fp)
 20222ec:	3805883a 	mov	r2,r7
 20222f0:	e0bfff0d 	sth	r2,-4(fp)
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
 20222f4:	e0ffff0b 	ldhu	r3,-4(fp)
 20222f8:	d8000215 	stw	zero,8(sp)
 20222fc:	d8000115 	stw	zero,4(sp)
 2022300:	e0800217 	ldw	r2,8(fp)
 2022304:	d8800015 	stw	r2,0(sp)
 2022308:	180f883a 	mov	r7,r3
 202230c:	e1bffe17 	ldw	r6,-8(fp)
 2022310:	e17ffd17 	ldw	r5,-12(fp)
 2022314:	e13ffc17 	ldw	r4,-16(fp)
 2022318:	20223300 	call	2022330 <udp_sendto_if_chksum>
}
 202231c:	e037883a 	mov	sp,fp
 2022320:	dfc00117 	ldw	ra,4(sp)
 2022324:	df000017 	ldw	fp,0(sp)
 2022328:	dec00204 	addi	sp,sp,8
 202232c:	f800283a 	ret

02022330 <udp_sendto_if_chksum>:
/** Same as udp_sendto_if(), but with checksum */
err_t
udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *dst_ip,
                     u16_t dst_port, struct netif *netif, u8_t have_chksum,
                     u16_t chksum)
{
 2022330:	defff004 	addi	sp,sp,-64
 2022334:	dfc00f15 	stw	ra,60(sp)
 2022338:	df000e15 	stw	fp,56(sp)
 202233c:	df000e04 	addi	fp,sp,56
 2022340:	e13ffa15 	stw	r4,-24(fp)
 2022344:	e17ffb15 	stw	r5,-20(fp)
 2022348:	e1bffc15 	stw	r6,-16(fp)
 202234c:	3809883a 	mov	r4,r7
 2022350:	e0c00317 	ldw	r3,12(fp)
 2022354:	e0800417 	ldw	r2,16(fp)
 2022358:	e13ffd0d 	sth	r4,-12(fp)
 202235c:	e0fffe05 	stb	r3,-8(fp)
 2022360:	e0bfff0d 	sth	r2,-4(fp)
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 2022364:	e0bffa17 	ldw	r2,-24(fp)
 2022368:	1080048b 	ldhu	r2,18(r2)
 202236c:	10bfffcc 	andi	r2,r2,65535
 2022370:	10000d1e 	bne	r2,zero,20223a8 <udp_sendto_if_chksum+0x78>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 2022374:	e0fffa17 	ldw	r3,-24(fp)
 2022378:	e0bffa17 	ldw	r2,-24(fp)
 202237c:	1080048b 	ldhu	r2,18(r2)
 2022380:	10bfffcc 	andi	r2,r2,65535
 2022384:	100d883a 	mov	r6,r2
 2022388:	180b883a 	mov	r5,r3
 202238c:	e13ffa17 	ldw	r4,-24(fp)
 2022390:	20227840 	call	2022784 <udp_bind>
 2022394:	e0bff785 	stb	r2,-34(fp)
    if (err != ERR_OK) {
 2022398:	e0bff787 	ldb	r2,-34(fp)
 202239c:	10000226 	beq	r2,zero,20223a8 <udp_sendto_if_chksum+0x78>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 20223a0:	e0bff783 	ldbu	r2,-34(fp)
 20223a4:	0000f206 	br	2022770 <udp_sendto_if_chksum+0x440>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 20223a8:	01400204 	movi	r5,8
 20223ac:	e13ffb17 	ldw	r4,-20(fp)
 20223b0:	201a9b80 	call	201a9b8 <pbuf_header>
 20223b4:	10803fcc 	andi	r2,r2,255
 20223b8:	10001126 	beq	r2,zero,2022400 <udp_sendto_if_chksum+0xd0>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 20223bc:	000d883a 	mov	r6,zero
 20223c0:	01400204 	movi	r5,8
 20223c4:	01000044 	movi	r4,1
 20223c8:	201a3ac0 	call	201a3ac <pbuf_alloc>
 20223cc:	e0bff615 	stw	r2,-40(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 20223d0:	e0bff617 	ldw	r2,-40(fp)
 20223d4:	1000021e 	bne	r2,zero,20223e0 <udp_sendto_if_chksum+0xb0>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 20223d8:	00bfffc4 	movi	r2,-1
 20223dc:	0000e406 	br	2022770 <udp_sendto_if_chksum+0x440>
    }
    if (p->tot_len != 0) {
 20223e0:	e0bffb17 	ldw	r2,-20(fp)
 20223e4:	1080020b 	ldhu	r2,8(r2)
 20223e8:	10bfffcc 	andi	r2,r2,65535
 20223ec:	10000626 	beq	r2,zero,2022408 <udp_sendto_if_chksum+0xd8>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 20223f0:	e17ffb17 	ldw	r5,-20(fp)
 20223f4:	e13ff617 	ldw	r4,-40(fp)
 20223f8:	201ae300 	call	201ae30 <pbuf_chain>
 20223fc:	00000206 	br	2022408 <udp_sendto_if_chksum+0xd8>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 2022400:	e0bffb17 	ldw	r2,-20(fp)
 2022404:	e0bff615 	stw	r2,-40(fp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 2022408:	e0bff617 	ldw	r2,-40(fp)
 202240c:	10800117 	ldw	r2,4(r2)
 2022410:	e0bff815 	stw	r2,-32(fp)
  udphdr->src = htons(pcb->local_port);
 2022414:	e0bffa17 	ldw	r2,-24(fp)
 2022418:	1080048b 	ldhu	r2,18(r2)
 202241c:	10bfffcc 	andi	r2,r2,65535
 2022420:	1004d23a 	srli	r2,r2,8
 2022424:	1007883a 	mov	r3,r2
 2022428:	e0bffa17 	ldw	r2,-24(fp)
 202242c:	1080048b 	ldhu	r2,18(r2)
 2022430:	10bfffcc 	andi	r2,r2,65535
 2022434:	1004923a 	slli	r2,r2,8
 2022438:	1884b03a 	or	r2,r3,r2
 202243c:	100d883a 	mov	r6,r2
 2022440:	e0bff817 	ldw	r2,-32(fp)
 2022444:	30ffffcc 	andi	r3,r6,65535
 2022448:	19403fcc 	andi	r5,r3,255
 202244c:	10c00003 	ldbu	r3,0(r2)
 2022450:	1806703a 	and	r3,r3,zero
 2022454:	1809883a 	mov	r4,r3
 2022458:	2807883a 	mov	r3,r5
 202245c:	20c6b03a 	or	r3,r4,r3
 2022460:	10c00005 	stb	r3,0(r2)
 2022464:	30ffffcc 	andi	r3,r6,65535
 2022468:	1806d23a 	srli	r3,r3,8
 202246c:	197fffcc 	andi	r5,r3,65535
 2022470:	10c00043 	ldbu	r3,1(r2)
 2022474:	1806703a 	and	r3,r3,zero
 2022478:	1809883a 	mov	r4,r3
 202247c:	2807883a 	mov	r3,r5
 2022480:	20c6b03a 	or	r3,r4,r3
 2022484:	10c00045 	stb	r3,1(r2)
  udphdr->dest = htons(dst_port);
 2022488:	e0bffd0b 	ldhu	r2,-12(fp)
 202248c:	1004d23a 	srli	r2,r2,8
 2022490:	1007883a 	mov	r3,r2
 2022494:	e0bffd0b 	ldhu	r2,-12(fp)
 2022498:	1004923a 	slli	r2,r2,8
 202249c:	1884b03a 	or	r2,r3,r2
 20224a0:	100d883a 	mov	r6,r2
 20224a4:	e0bff817 	ldw	r2,-32(fp)
 20224a8:	30ffffcc 	andi	r3,r6,65535
 20224ac:	19403fcc 	andi	r5,r3,255
 20224b0:	10c00083 	ldbu	r3,2(r2)
 20224b4:	1806703a 	and	r3,r3,zero
 20224b8:	1809883a 	mov	r4,r3
 20224bc:	2807883a 	mov	r3,r5
 20224c0:	20c6b03a 	or	r3,r4,r3
 20224c4:	10c00085 	stb	r3,2(r2)
 20224c8:	30ffffcc 	andi	r3,r6,65535
 20224cc:	1806d23a 	srli	r3,r3,8
 20224d0:	197fffcc 	andi	r5,r3,65535
 20224d4:	10c000c3 	ldbu	r3,3(r2)
 20224d8:	1806703a 	and	r3,r3,zero
 20224dc:	1809883a 	mov	r4,r3
 20224e0:	2807883a 	mov	r3,r5
 20224e4:	20c6b03a 	or	r3,r4,r3
 20224e8:	10c000c5 	stb	r3,3(r2)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 20224ec:	e0bff817 	ldw	r2,-32(fp)
 20224f0:	10c00183 	ldbu	r3,6(r2)
 20224f4:	1806703a 	and	r3,r3,zero
 20224f8:	10c00185 	stb	r3,6(r2)
 20224fc:	10c001c3 	ldbu	r3,7(r2)
 2022500:	1806703a 	and	r3,r3,zero
 2022504:	10c001c5 	stb	r3,7(r2)
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 2022508:	e0bffa17 	ldw	r2,-24(fp)
 202250c:	10000326 	beq	r2,zero,202251c <udp_sendto_if_chksum+0x1ec>
 2022510:	e0bffa17 	ldw	r2,-24(fp)
 2022514:	10800017 	ldw	r2,0(r2)
 2022518:	1000041e 	bne	r2,zero,202252c <udp_sendto_if_chksum+0x1fc>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 202251c:	e0800217 	ldw	r2,8(fp)
 2022520:	10800104 	addi	r2,r2,4
 2022524:	e0bff515 	stw	r2,-44(fp)
 2022528:	00000f06 	br	2022568 <udp_sendto_if_chksum+0x238>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 202252c:	e0bffa17 	ldw	r2,-24(fp)
 2022530:	10c00017 	ldw	r3,0(r2)
 2022534:	e0800217 	ldw	r2,8(fp)
 2022538:	10800117 	ldw	r2,4(r2)
 202253c:	18800826 	beq	r3,r2,2022560 <udp_sendto_if_chksum+0x230>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 2022540:	e0fff617 	ldw	r3,-40(fp)
 2022544:	e0bffb17 	ldw	r2,-20(fp)
 2022548:	18800326 	beq	r3,r2,2022558 <udp_sendto_if_chksum+0x228>
        /* free the header pbuf */
        pbuf_free(q);
 202254c:	e13ff617 	ldw	r4,-40(fp)
 2022550:	201ab680 	call	201ab68 <pbuf_free>
        q = NULL;
 2022554:	e03ff615 	stw	zero,-40(fp)
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 2022558:	00bffe84 	movi	r2,-6
 202255c:	00008406 	br	2022770 <udp_sendto_if_chksum+0x440>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 2022560:	e0bffa17 	ldw	r2,-24(fp)
 2022564:	e0bff515 	stw	r2,-44(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 2022568:	e0bff617 	ldw	r2,-40(fp)
 202256c:	1080020b 	ldhu	r2,8(r2)
 2022570:	10bfffcc 	andi	r2,r2,65535
 2022574:	1004d23a 	srli	r2,r2,8
 2022578:	1007883a 	mov	r3,r2
 202257c:	e0bff617 	ldw	r2,-40(fp)
 2022580:	1080020b 	ldhu	r2,8(r2)
 2022584:	10bfffcc 	andi	r2,r2,65535
 2022588:	1004923a 	slli	r2,r2,8
 202258c:	1884b03a 	or	r2,r3,r2
 2022590:	100d883a 	mov	r6,r2
 2022594:	e0bff817 	ldw	r2,-32(fp)
 2022598:	30ffffcc 	andi	r3,r6,65535
 202259c:	19403fcc 	andi	r5,r3,255
 20225a0:	10c00103 	ldbu	r3,4(r2)
 20225a4:	1806703a 	and	r3,r3,zero
 20225a8:	1809883a 	mov	r4,r3
 20225ac:	2807883a 	mov	r3,r5
 20225b0:	20c6b03a 	or	r3,r4,r3
 20225b4:	10c00105 	stb	r3,4(r2)
 20225b8:	30ffffcc 	andi	r3,r6,65535
 20225bc:	1806d23a 	srli	r3,r3,8
 20225c0:	197fffcc 	andi	r5,r3,65535
 20225c4:	10c00143 	ldbu	r3,5(r2)
 20225c8:	1806703a 	and	r3,r3,zero
 20225cc:	1809883a 	mov	r4,r3
 20225d0:	2807883a 	mov	r3,r5
 20225d4:	20c6b03a 	or	r3,r4,r3
 20225d8:	10c00145 	stb	r3,5(r2)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 20225dc:	e0bffa17 	ldw	r2,-24(fp)
 20225e0:	10800403 	ldbu	r2,16(r2)
 20225e4:	10803fcc 	andi	r2,r2,255
 20225e8:	1080004c 	andi	r2,r2,1
 20225ec:	10003b1e 	bne	r2,zero,20226dc <udp_sendto_if_chksum+0x3ac>
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
 20225f0:	e0bffe03 	ldbu	r2,-8(fp)
 20225f4:	10001926 	beq	r2,zero,202265c <udp_sendto_if_chksum+0x32c>
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
          q->tot_len, UDP_HLEN);
 20225f8:	e0bff617 	ldw	r2,-40(fp)
 20225fc:	1080020b 	ldhu	r2,8(r2)
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
      u16_t udpchksum;
#if LWIP_CHECKSUM_ON_COPY
      if (have_chksum) {
        u32_t acc;
        udpchksum = inet_chksum_pseudo_partial(q, src_ip, dst_ip, IP_PROTO_UDP,
 2022600:	10bfffcc 	andi	r2,r2,65535
 2022604:	00c00204 	movi	r3,8
 2022608:	d8c00115 	stw	r3,4(sp)
 202260c:	d8800015 	stw	r2,0(sp)
 2022610:	01c00444 	movi	r7,17
 2022614:	e1bffc17 	ldw	r6,-16(fp)
 2022618:	e17ff517 	ldw	r5,-44(fp)
 202261c:	e13ff617 	ldw	r4,-40(fp)
 2022620:	203193c0 	call	203193c <inet_chksum_pseudo_partial>
 2022624:	e0bff70d 	sth	r2,-36(fp)
          q->tot_len, UDP_HLEN);
        acc = udpchksum + (u16_t)~(chksum);
 2022628:	e0fff70b 	ldhu	r3,-36(fp)
 202262c:	e0bfff0b 	ldhu	r2,-4(fp)
 2022630:	0084303a 	nor	r2,zero,r2
 2022634:	10bfffcc 	andi	r2,r2,65535
 2022638:	1885883a 	add	r2,r3,r2
 202263c:	e0bff915 	stw	r2,-28(fp)
        udpchksum = FOLD_U32T(acc);
 2022640:	e0bff917 	ldw	r2,-28(fp)
 2022644:	1004d43a 	srli	r2,r2,16
 2022648:	1007883a 	mov	r3,r2
 202264c:	e0bff917 	ldw	r2,-28(fp)
 2022650:	1885883a 	add	r2,r3,r2
 2022654:	e0bff70d 	sth	r2,-36(fp)
 2022658:	00000a06 	br	2022684 <udp_sendto_if_chksum+0x354>
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 202265c:	e0bff617 	ldw	r2,-40(fp)
 2022660:	1080020b 	ldhu	r2,8(r2)
 2022664:	10bfffcc 	andi	r2,r2,65535
 2022668:	d8800015 	stw	r2,0(sp)
 202266c:	01c00444 	movi	r7,17
 2022670:	e1bffc17 	ldw	r6,-16(fp)
 2022674:	e17ff517 	ldw	r5,-44(fp)
 2022678:	e13ff617 	ldw	r4,-40(fp)
 202267c:	203173c0 	call	203173c <inet_chksum_pseudo>
 2022680:	e0bff70d 	sth	r2,-36(fp)
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
 2022684:	e0bff70b 	ldhu	r2,-36(fp)
 2022688:	1000021e 	bne	r2,zero,2022694 <udp_sendto_if_chksum+0x364>
        udpchksum = 0xffff;
 202268c:	00bfffc4 	movi	r2,-1
 2022690:	e0bff70d 	sth	r2,-36(fp)
      }
      udphdr->chksum = udpchksum;
 2022694:	e0bff817 	ldw	r2,-32(fp)
 2022698:	e0fff70b 	ldhu	r3,-36(fp)
 202269c:	19403fcc 	andi	r5,r3,255
 20226a0:	10c00183 	ldbu	r3,6(r2)
 20226a4:	1806703a 	and	r3,r3,zero
 20226a8:	1809883a 	mov	r4,r3
 20226ac:	2807883a 	mov	r3,r5
 20226b0:	20c6b03a 	or	r3,r4,r3
 20226b4:	10c00185 	stb	r3,6(r2)
 20226b8:	e0fff70b 	ldhu	r3,-36(fp)
 20226bc:	1806d23a 	srli	r3,r3,8
 20226c0:	197fffcc 	andi	r5,r3,65535
 20226c4:	10c001c3 	ldbu	r3,7(r2)
 20226c8:	1806703a 	and	r3,r3,zero
 20226cc:	1809883a 	mov	r4,r3
 20226d0:	2807883a 	mov	r3,r5
 20226d4:	20c6b03a 	or	r3,r4,r3
 20226d8:	10c001c5 	stb	r3,7(r2)
    }
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 20226dc:	e0bffa17 	ldw	r2,-24(fp)
 20226e0:	10c002c4 	addi	r3,r2,11
 20226e4:	e0800217 	ldw	r2,8(fp)
 20226e8:	10c01015 	stw	r3,64(r2)
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 20226ec:	e0bffa17 	ldw	r2,-24(fp)
 20226f0:	10800283 	ldbu	r2,10(r2)
 20226f4:	11003fcc 	andi	r4,r2,255
 20226f8:	e0bffa17 	ldw	r2,-24(fp)
 20226fc:	10800243 	ldbu	r2,9(r2)
 2022700:	10803fcc 	andi	r2,r2,255
 2022704:	e0c00217 	ldw	r3,8(fp)
 2022708:	d8c00215 	stw	r3,8(sp)
 202270c:	00c00444 	movi	r3,17
 2022710:	d8c00115 	stw	r3,4(sp)
 2022714:	d8800015 	stw	r2,0(sp)
 2022718:	200f883a 	mov	r7,r4
 202271c:	e1bffc17 	ldw	r6,-16(fp)
 2022720:	e17ff517 	ldw	r5,-44(fp)
 2022724:	e13ff617 	ldw	r4,-40(fp)
 2022728:	20323480 	call	2032348 <ip_output_if>
 202272c:	e0bff785 	stb	r2,-34(fp)
    NETIF_SET_HWADDRHINT(netif, NULL);
 2022730:	e0800217 	ldw	r2,8(fp)
 2022734:	10001015 	stw	zero,64(r2)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 2022738:	e0fff617 	ldw	r3,-40(fp)
 202273c:	e0bffb17 	ldw	r2,-20(fp)
 2022740:	18800326 	beq	r3,r2,2022750 <udp_sendto_if_chksum+0x420>
    /* free the header pbuf */
    pbuf_free(q);
 2022744:	e13ff617 	ldw	r4,-40(fp)
 2022748:	201ab680 	call	201ab68 <pbuf_free>
    q = NULL;
 202274c:	e03ff615 	stw	zero,-40(fp)
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
 2022750:	008085f4 	movhi	r2,535
 2022754:	10a8bc04 	addi	r2,r2,-23824
 2022758:	10803c17 	ldw	r2,240(r2)
 202275c:	10c00044 	addi	r3,r2,1
 2022760:	008085f4 	movhi	r2,535
 2022764:	10a8bc04 	addi	r2,r2,-23824
 2022768:	10c03c15 	stw	r3,240(r2)
  return err;
 202276c:	e0bff783 	ldbu	r2,-34(fp)
}
 2022770:	e037883a 	mov	sp,fp
 2022774:	dfc00117 	ldw	ra,4(sp)
 2022778:	df000017 	ldw	fp,0(sp)
 202277c:	dec00204 	addi	sp,sp,8
 2022780:	f800283a 	ret

02022784 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 2022784:	defff904 	addi	sp,sp,-28
 2022788:	dfc00615 	stw	ra,24(sp)
 202278c:	df000515 	stw	fp,20(sp)
 2022790:	df000504 	addi	fp,sp,20
 2022794:	e13ffd15 	stw	r4,-12(fp)
 2022798:	e17ffe15 	stw	r5,-8(fp)
 202279c:	3005883a 	mov	r2,r6
 20227a0:	e0bfff0d 	sth	r2,-4(fp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 20227a4:	e03ffc05 	stb	zero,-16(fp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 20227a8:	d0a7ff17 	ldw	r2,-24580(gp)
 20227ac:	e0bffb15 	stw	r2,-20(fp)
 20227b0:	00002906 	br	2022858 <udp_bind+0xd4>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 20227b4:	e0fffd17 	ldw	r3,-12(fp)
 20227b8:	e0bffb17 	ldw	r2,-20(fp)
 20227bc:	1880031e 	bne	r3,r2,20227cc <udp_bind+0x48>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 20227c0:	00800044 	movi	r2,1
 20227c4:	e0bffc05 	stb	r2,-16(fp)
 20227c8:	00002006 	br	202284c <udp_bind+0xc8>

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
 20227cc:	e0bffd17 	ldw	r2,-12(fp)
 20227d0:	10800203 	ldbu	r2,8(r2)
 20227d4:	10803fcc 	andi	r2,r2,255
 20227d8:	1080010c 	andi	r2,r2,4
 20227dc:	10001b1e 	bne	r2,zero,202284c <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
 20227e0:	e0bffb17 	ldw	r2,-20(fp)
 20227e4:	10800203 	ldbu	r2,8(r2)
 20227e8:	10803fcc 	andi	r2,r2,255
 20227ec:	1080010c 	andi	r2,r2,4

    /* By default, we don't allow to bind to a port that any other udp
       PCB is alread bound to, unless *all* PCBs with that port have tha
       REUSEADDR flag set. */
#if SO_REUSE
    else if (!ip_get_option(pcb, SOF_REUSEADDR) &&
 20227f0:	1000161e 	bne	r2,zero,202284c <udp_bind+0xc8>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 20227f4:	e0bffb17 	ldw	r2,-20(fp)
 20227f8:	1080048b 	ldhu	r2,18(r2)
 20227fc:	10ffffcc 	andi	r3,r2,65535
 2022800:	e0bfff0b 	ldhu	r2,-4(fp)
 2022804:	1880111e 	bne	r3,r2,202284c <udp_bind+0xc8>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 2022808:	e0bffb17 	ldw	r2,-20(fp)
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 202280c:	10000d26 	beq	r2,zero,2022844 <udp_bind+0xc0>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 2022810:	e0bffb17 	ldw	r2,-20(fp)
 2022814:	10800017 	ldw	r2,0(r2)
 2022818:	10000a26 	beq	r2,zero,2022844 <udp_bind+0xc0>
 202281c:	e0bffe17 	ldw	r2,-8(fp)
 2022820:	10000826 	beq	r2,zero,2022844 <udp_bind+0xc0>
           ip_addr_isany(ipaddr) ||
 2022824:	e0bffe17 	ldw	r2,-8(fp)
 2022828:	10800017 	ldw	r2,0(r2)
 202282c:	10000526 	beq	r2,zero,2022844 <udp_bind+0xc0>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
 2022830:	e0bffb17 	ldw	r2,-20(fp)
 2022834:	10c00017 	ldw	r3,0(r2)
 2022838:	e0bffe17 	ldw	r2,-8(fp)
 202283c:	10800017 	ldw	r2,0(r2)
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
 2022840:	1880021e 	bne	r3,r2,202284c <udp_bind+0xc8>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 2022844:	00bffe04 	movi	r2,-8
 2022848:	00002006 	br	20228cc <udp_bind+0x148>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 202284c:	e0bffb17 	ldw	r2,-20(fp)
 2022850:	10800317 	ldw	r2,12(r2)
 2022854:	e0bffb15 	stw	r2,-20(fp)
 2022858:	e0bffb17 	ldw	r2,-20(fp)
 202285c:	103fd51e 	bne	r2,zero,20227b4 <__alt_mem_mem_0+0xfd0027b4>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 2022860:	e0bffe17 	ldw	r2,-8(fp)
 2022864:	10000326 	beq	r2,zero,2022874 <udp_bind+0xf0>
 2022868:	e0bffe17 	ldw	r2,-8(fp)
 202286c:	10800017 	ldw	r2,0(r2)
 2022870:	00000106 	br	2022878 <udp_bind+0xf4>
 2022874:	0005883a 	mov	r2,zero
 2022878:	e0fffd17 	ldw	r3,-12(fp)
 202287c:	18800015 	stw	r2,0(r3)

  /* no port specified? */
  if (port == 0) {
 2022880:	e0bfff0b 	ldhu	r2,-4(fp)
 2022884:	1000061e 	bne	r2,zero,20228a0 <udp_bind+0x11c>
    port = udp_new_port();
 2022888:	2021adc0 	call	2021adc <udp_new_port>
 202288c:	e0bfff0d 	sth	r2,-4(fp)
    if (port == 0) {
 2022890:	e0bfff0b 	ldhu	r2,-4(fp)
 2022894:	1000021e 	bne	r2,zero,20228a0 <udp_bind+0x11c>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 2022898:	00bffe04 	movi	r2,-8
 202289c:	00000b06 	br	20228cc <udp_bind+0x148>
    }
  }
  pcb->local_port = port;
 20228a0:	e0bffd17 	ldw	r2,-12(fp)
 20228a4:	e0ffff0b 	ldhu	r3,-4(fp)
 20228a8:	10c0048d 	sth	r3,18(r2)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 20228ac:	e0bffc03 	ldbu	r2,-16(fp)
 20228b0:	1000051e 	bne	r2,zero,20228c8 <udp_bind+0x144>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 20228b4:	d0e7ff17 	ldw	r3,-24580(gp)
 20228b8:	e0bffd17 	ldw	r2,-12(fp)
 20228bc:	10c00315 	stw	r3,12(r2)
    udp_pcbs = pcb;
 20228c0:	e0bffd17 	ldw	r2,-12(fp)
 20228c4:	d0a7ff15 	stw	r2,-24580(gp)
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 20228c8:	0005883a 	mov	r2,zero
}
 20228cc:	e037883a 	mov	sp,fp
 20228d0:	dfc00117 	ldw	ra,4(sp)
 20228d4:	df000017 	ldw	fp,0(sp)
 20228d8:	dec00204 	addi	sp,sp,8
 20228dc:	f800283a 	ret

020228e0 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 20228e0:	defff904 	addi	sp,sp,-28
 20228e4:	dfc00615 	stw	ra,24(sp)
 20228e8:	df000515 	stw	fp,20(sp)
 20228ec:	df000504 	addi	fp,sp,20
 20228f0:	e13ffd15 	stw	r4,-12(fp)
 20228f4:	e17ffe15 	stw	r5,-8(fp)
 20228f8:	3005883a 	mov	r2,r6
 20228fc:	e0bfff0d 	sth	r2,-4(fp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 2022900:	e0bffd17 	ldw	r2,-12(fp)
 2022904:	1080048b 	ldhu	r2,18(r2)
 2022908:	10bfffcc 	andi	r2,r2,65535
 202290c:	10000d1e 	bne	r2,zero,2022944 <udp_connect+0x64>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 2022910:	e0fffd17 	ldw	r3,-12(fp)
 2022914:	e0bffd17 	ldw	r2,-12(fp)
 2022918:	1080048b 	ldhu	r2,18(r2)
 202291c:	10bfffcc 	andi	r2,r2,65535
 2022920:	100d883a 	mov	r6,r2
 2022924:	180b883a 	mov	r5,r3
 2022928:	e13ffd17 	ldw	r4,-12(fp)
 202292c:	20227840 	call	2022784 <udp_bind>
 2022930:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 2022934:	e0bffc07 	ldb	r2,-16(fp)
 2022938:	10000226 	beq	r2,zero,2022944 <udp_connect+0x64>
      return err;
 202293c:	e0bffc03 	ldbu	r2,-16(fp)
 2022940:	00002406 	br	20229d4 <udp_connect+0xf4>
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 2022944:	e0bffe17 	ldw	r2,-8(fp)
 2022948:	10000326 	beq	r2,zero,2022958 <udp_connect+0x78>
 202294c:	e0bffe17 	ldw	r2,-8(fp)
 2022950:	10800017 	ldw	r2,0(r2)
 2022954:	00000106 	br	202295c <udp_connect+0x7c>
 2022958:	0005883a 	mov	r2,zero
 202295c:	e0fffd17 	ldw	r3,-12(fp)
 2022960:	18800115 	stw	r2,4(r3)
  pcb->remote_port = port;
 2022964:	e0bffd17 	ldw	r2,-12(fp)
 2022968:	e0ffff0b 	ldhu	r3,-4(fp)
 202296c:	10c0050d 	sth	r3,20(r2)
  pcb->flags |= UDP_FLAGS_CONNECTED;
 2022970:	e0bffd17 	ldw	r2,-12(fp)
 2022974:	10800403 	ldbu	r2,16(r2)
 2022978:	10800114 	ori	r2,r2,4
 202297c:	1007883a 	mov	r3,r2
 2022980:	e0bffd17 	ldw	r2,-12(fp)
 2022984:	10c00405 	stb	r3,16(r2)
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 2022988:	d0a7ff17 	ldw	r2,-24580(gp)
 202298c:	e0bffb15 	stw	r2,-20(fp)
 2022990:	00000806 	br	20229b4 <udp_connect+0xd4>
    if (pcb == ipcb) {
 2022994:	e0fffd17 	ldw	r3,-12(fp)
 2022998:	e0bffb17 	ldw	r2,-20(fp)
 202299c:	1880021e 	bne	r3,r2,20229a8 <udp_connect+0xc8>
      /* already on the list, just return */
      return ERR_OK;
 20229a0:	0005883a 	mov	r2,zero
 20229a4:	00000b06 	br	20229d4 <udp_connect+0xf4>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 20229a8:	e0bffb17 	ldw	r2,-20(fp)
 20229ac:	10800317 	ldw	r2,12(r2)
 20229b0:	e0bffb15 	stw	r2,-20(fp)
 20229b4:	e0bffb17 	ldw	r2,-20(fp)
 20229b8:	103ff61e 	bne	r2,zero,2022994 <__alt_mem_mem_0+0xfd002994>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 20229bc:	d0e7ff17 	ldw	r3,-24580(gp)
 20229c0:	e0bffd17 	ldw	r2,-12(fp)
 20229c4:	10c00315 	stw	r3,12(r2)
  udp_pcbs = pcb;
 20229c8:	e0bffd17 	ldw	r2,-12(fp)
 20229cc:	d0a7ff15 	stw	r2,-24580(gp)
  return ERR_OK;
 20229d0:	0005883a 	mov	r2,zero
}
 20229d4:	e037883a 	mov	sp,fp
 20229d8:	dfc00117 	ldw	ra,4(sp)
 20229dc:	df000017 	ldw	fp,0(sp)
 20229e0:	dec00204 	addi	sp,sp,8
 20229e4:	f800283a 	ret

020229e8 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 20229e8:	defffe04 	addi	sp,sp,-8
 20229ec:	df000115 	stw	fp,4(sp)
 20229f0:	df000104 	addi	fp,sp,4
 20229f4:	e13fff15 	stw	r4,-4(fp)
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
 20229f8:	e0bfff17 	ldw	r2,-4(fp)
 20229fc:	10000115 	stw	zero,4(r2)
  pcb->remote_port = 0;
 2022a00:	e0bfff17 	ldw	r2,-4(fp)
 2022a04:	1000050d 	sth	zero,20(r2)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 2022a08:	e0bfff17 	ldw	r2,-4(fp)
 2022a0c:	10c00403 	ldbu	r3,16(r2)
 2022a10:	00bffec4 	movi	r2,-5
 2022a14:	1884703a 	and	r2,r3,r2
 2022a18:	1007883a 	mov	r3,r2
 2022a1c:	e0bfff17 	ldw	r2,-4(fp)
 2022a20:	10c00405 	stb	r3,16(r2)
}
 2022a24:	0001883a 	nop
 2022a28:	e037883a 	mov	sp,fp
 2022a2c:	df000017 	ldw	fp,0(sp)
 2022a30:	dec00104 	addi	sp,sp,4
 2022a34:	f800283a 	ret

02022a38 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 2022a38:	defffc04 	addi	sp,sp,-16
 2022a3c:	df000315 	stw	fp,12(sp)
 2022a40:	df000304 	addi	fp,sp,12
 2022a44:	e13ffd15 	stw	r4,-12(fp)
 2022a48:	e17ffe15 	stw	r5,-8(fp)
 2022a4c:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
 2022a50:	e0bffd17 	ldw	r2,-12(fp)
 2022a54:	e0fffe17 	ldw	r3,-8(fp)
 2022a58:	10c00615 	stw	r3,24(r2)
  pcb->recv_arg = recv_arg;
 2022a5c:	e0bffd17 	ldw	r2,-12(fp)
 2022a60:	e0ffff17 	ldw	r3,-4(fp)
 2022a64:	10c00715 	stw	r3,28(r2)
}
 2022a68:	0001883a 	nop
 2022a6c:	e037883a 	mov	sp,fp
 2022a70:	df000017 	ldw	fp,0(sp)
 2022a74:	dec00104 	addi	sp,sp,4
 2022a78:	f800283a 	ret

02022a7c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 2022a7c:	defffc04 	addi	sp,sp,-16
 2022a80:	dfc00315 	stw	ra,12(sp)
 2022a84:	df000215 	stw	fp,8(sp)
 2022a88:	df000204 	addi	fp,sp,8
 2022a8c:	e13fff15 	stw	r4,-4(fp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 2022a90:	d0e7ff17 	ldw	r3,-24580(gp)
 2022a94:	e0bfff17 	ldw	r2,-4(fp)
 2022a98:	1880041e 	bne	r3,r2,2022aac <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 2022a9c:	d0a7ff17 	ldw	r2,-24580(gp)
 2022aa0:	10800317 	ldw	r2,12(r2)
 2022aa4:	d0a7ff15 	stw	r2,-24580(gp)
 2022aa8:	00001306 	br	2022af8 <udp_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 2022aac:	d0a7ff17 	ldw	r2,-24580(gp)
 2022ab0:	e0bffe15 	stw	r2,-8(fp)
 2022ab4:	00000e06 	br	2022af0 <udp_remove+0x74>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 2022ab8:	e0bffe17 	ldw	r2,-8(fp)
 2022abc:	10800317 	ldw	r2,12(r2)
 2022ac0:	10000826 	beq	r2,zero,2022ae4 <udp_remove+0x68>
 2022ac4:	e0bffe17 	ldw	r2,-8(fp)
 2022ac8:	10c00317 	ldw	r3,12(r2)
 2022acc:	e0bfff17 	ldw	r2,-4(fp)
 2022ad0:	1880041e 	bne	r3,r2,2022ae4 <udp_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 2022ad4:	e0bfff17 	ldw	r2,-4(fp)
 2022ad8:	10c00317 	ldw	r3,12(r2)
 2022adc:	e0bffe17 	ldw	r2,-8(fp)
 2022ae0:	10c00315 	stw	r3,12(r2)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 2022ae4:	e0bffe17 	ldw	r2,-8(fp)
 2022ae8:	10800317 	ldw	r2,12(r2)
 2022aec:	e0bffe15 	stw	r2,-8(fp)
 2022af0:	e0bffe17 	ldw	r2,-8(fp)
 2022af4:	103ff01e 	bne	r2,zero,2022ab8 <__alt_mem_mem_0+0xfd002ab8>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 2022af8:	e17fff17 	ldw	r5,-4(fp)
 2022afc:	01000044 	movi	r4,1
 2022b00:	20346000 	call	2034600 <memp_free>
}
 2022b04:	0001883a 	nop
 2022b08:	e037883a 	mov	sp,fp
 2022b0c:	dfc00117 	ldw	ra,4(sp)
 2022b10:	df000017 	ldw	fp,0(sp)
 2022b14:	dec00204 	addi	sp,sp,8
 2022b18:	f800283a 	ret

02022b1c <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 2022b1c:	defffd04 	addi	sp,sp,-12
 2022b20:	dfc00215 	stw	ra,8(sp)
 2022b24:	df000115 	stw	fp,4(sp)
 2022b28:	df000104 	addi	fp,sp,4
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 2022b2c:	01000044 	movi	r4,1
 2022b30:	20344340 	call	2034434 <memp_malloc>
 2022b34:	e0bfff15 	stw	r2,-4(fp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 2022b38:	e0bfff17 	ldw	r2,-4(fp)
 2022b3c:	10000726 	beq	r2,zero,2022b5c <udp_new+0x40>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 2022b40:	01800804 	movi	r6,32
 2022b44:	000b883a 	mov	r5,zero
 2022b48:	e13fff17 	ldw	r4,-4(fp)
 2022b4c:	200616c0 	call	200616c <memset>
    pcb->ttl = UDP_TTL;
 2022b50:	e0bfff17 	ldw	r2,-4(fp)
 2022b54:	00c01004 	movi	r3,64
 2022b58:	10c00285 	stb	r3,10(r2)
  }
  return pcb;
 2022b5c:	e0bfff17 	ldw	r2,-4(fp)
}
 2022b60:	e037883a 	mov	sp,fp
 2022b64:	dfc00117 	ldw	ra,4(sp)
 2022b68:	df000017 	ldw	fp,0(sp)
 2022b6c:	dec00204 	addi	sp,sp,8
 2022b70:	f800283a 	ret

02022b74 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 2022b74:	defffc04 	addi	sp,sp,-16
 2022b78:	dfc00315 	stw	ra,12(sp)
 2022b7c:	df000215 	stw	fp,8(sp)
 2022b80:	df000204 	addi	fp,sp,8
 2022b84:	e13fff15 	stw	r4,-4(fp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 2022b88:	00000c06 	br	2022bbc <free_etharp_q+0x48>
    r = q;
 2022b8c:	e0bfff17 	ldw	r2,-4(fp)
 2022b90:	e0bffe15 	stw	r2,-8(fp)
    q = q->next;
 2022b94:	e0bfff17 	ldw	r2,-4(fp)
 2022b98:	10800017 	ldw	r2,0(r2)
 2022b9c:	e0bfff15 	stw	r2,-4(fp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
 2022ba0:	e0bffe17 	ldw	r2,-8(fp)
 2022ba4:	10800117 	ldw	r2,4(r2)
 2022ba8:	1009883a 	mov	r4,r2
 2022bac:	201ab680 	call	201ab68 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 2022bb0:	e17ffe17 	ldw	r5,-8(fp)
 2022bb4:	010002c4 	movi	r4,11
 2022bb8:	20346000 	call	2034600 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 2022bbc:	e0bfff17 	ldw	r2,-4(fp)
 2022bc0:	103ff21e 	bne	r2,zero,2022b8c <__alt_mem_mem_0+0xfd002b8c>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
 2022bc4:	0001883a 	nop
 2022bc8:	e037883a 	mov	sp,fp
 2022bcc:	dfc00117 	ldw	ra,4(sp)
 2022bd0:	df000017 	ldw	fp,0(sp)
 2022bd4:	dec00204 	addi	sp,sp,8
 2022bd8:	f800283a 	ret

02022bdc <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
 2022bdc:	defffd04 	addi	sp,sp,-12
 2022be0:	dfc00215 	stw	ra,8(sp)
 2022be4:	df000115 	stw	fp,4(sp)
 2022be8:	df000104 	addi	fp,sp,4
 2022bec:	e13fff15 	stw	r4,-4(fp)
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 2022bf0:	00808134 	movhi	r2,516
 2022bf4:	109ea704 	addi	r2,r2,31388
 2022bf8:	e0ffff17 	ldw	r3,-4(fp)
 2022bfc:	18c00524 	muli	r3,r3,20
 2022c00:	10c5883a 	add	r2,r2,r3
 2022c04:	10800017 	ldw	r2,0(r2)
 2022c08:	10000e26 	beq	r2,zero,2022c44 <etharp_free_entry+0x68>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 2022c0c:	00808134 	movhi	r2,516
 2022c10:	109ea704 	addi	r2,r2,31388
 2022c14:	e0ffff17 	ldw	r3,-4(fp)
 2022c18:	18c00524 	muli	r3,r3,20
 2022c1c:	10c5883a 	add	r2,r2,r3
 2022c20:	10800017 	ldw	r2,0(r2)
 2022c24:	1009883a 	mov	r4,r2
 2022c28:	2022b740 	call	2022b74 <free_etharp_q>
    arp_table[i].q = NULL;
 2022c2c:	00808134 	movhi	r2,516
 2022c30:	109ea704 	addi	r2,r2,31388
 2022c34:	e0ffff17 	ldw	r3,-4(fp)
 2022c38:	18c00524 	muli	r3,r3,20
 2022c3c:	10c5883a 	add	r2,r2,r3
 2022c40:	10000015 	stw	zero,0(r2)
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 2022c44:	00808134 	movhi	r2,516
 2022c48:	109ea704 	addi	r2,r2,31388
 2022c4c:	e0ffff17 	ldw	r3,-4(fp)
 2022c50:	18c00524 	muli	r3,r3,20
 2022c54:	10c5883a 	add	r2,r2,r3
 2022c58:	10800484 	addi	r2,r2,18
 2022c5c:	10000005 	stb	zero,0(r2)
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
 2022c60:	0001883a 	nop
 2022c64:	e037883a 	mov	sp,fp
 2022c68:	dfc00117 	ldw	ra,4(sp)
 2022c6c:	df000017 	ldw	fp,0(sp)
 2022c70:	dec00204 	addi	sp,sp,8
 2022c74:	f800283a 	ret

02022c78 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 2022c78:	defffd04 	addi	sp,sp,-12
 2022c7c:	dfc00215 	stw	ra,8(sp)
 2022c80:	df000115 	stw	fp,4(sp)
 2022c84:	df000104 	addi	fp,sp,4
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2022c88:	e03fff05 	stb	zero,-4(fp)
 2022c8c:	00005006 	br	2022dd0 <etharp_tmr+0x158>
    u8_t state = arp_table[i].state;
 2022c90:	e0ffff03 	ldbu	r3,-4(fp)
 2022c94:	00808134 	movhi	r2,516
 2022c98:	109ea704 	addi	r2,r2,31388
 2022c9c:	18c00524 	muli	r3,r3,20
 2022ca0:	10c5883a 	add	r2,r2,r3
 2022ca4:	10800484 	addi	r2,r2,18
 2022ca8:	10800003 	ldbu	r2,0(r2)
 2022cac:	e0bfff45 	stb	r2,-3(fp)
    if (state != ETHARP_STATE_EMPTY
 2022cb0:	e0bfff43 	ldbu	r2,-3(fp)
 2022cb4:	10004326 	beq	r2,zero,2022dc4 <etharp_tmr+0x14c>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 2022cb8:	e0ffff03 	ldbu	r3,-4(fp)
 2022cbc:	00808134 	movhi	r2,516
 2022cc0:	109ea704 	addi	r2,r2,31388
 2022cc4:	19000524 	muli	r4,r3,20
 2022cc8:	1105883a 	add	r2,r2,r4
 2022ccc:	108004c4 	addi	r2,r2,19
 2022cd0:	10800003 	ldbu	r2,0(r2)
 2022cd4:	10800044 	addi	r2,r2,1
 2022cd8:	1009883a 	mov	r4,r2
 2022cdc:	00808134 	movhi	r2,516
 2022ce0:	109ea704 	addi	r2,r2,31388
 2022ce4:	18c00524 	muli	r3,r3,20
 2022ce8:	10c5883a 	add	r2,r2,r3
 2022cec:	108004c4 	addi	r2,r2,19
 2022cf0:	11000005 	stb	r4,0(r2)
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 2022cf4:	e0ffff03 	ldbu	r3,-4(fp)
 2022cf8:	00808134 	movhi	r2,516
 2022cfc:	109ea704 	addi	r2,r2,31388
 2022d00:	18c00524 	muli	r3,r3,20
 2022d04:	10c5883a 	add	r2,r2,r3
 2022d08:	108004c4 	addi	r2,r2,19
 2022d0c:	10800003 	ldbu	r2,0(r2)
 2022d10:	10803fcc 	andi	r2,r2,255
 2022d14:	10803c28 	cmpgeui	r2,r2,240
 2022d18:	1000141e 	bne	r2,zero,2022d6c <etharp_tmr+0xf4>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2022d1c:	e0ffff03 	ldbu	r3,-4(fp)
 2022d20:	00808134 	movhi	r2,516
 2022d24:	109ea704 	addi	r2,r2,31388
 2022d28:	18c00524 	muli	r3,r3,20
 2022d2c:	10c5883a 	add	r2,r2,r3
 2022d30:	10800484 	addi	r2,r2,18
 2022d34:	10800003 	ldbu	r2,0(r2)
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 2022d38:	10803fcc 	andi	r2,r2,255
 2022d3c:	10800058 	cmpnei	r2,r2,1
 2022d40:	10000e1e 	bne	r2,zero,2022d7c <etharp_tmr+0x104>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
 2022d44:	e0ffff03 	ldbu	r3,-4(fp)
 2022d48:	00808134 	movhi	r2,516
 2022d4c:	109ea704 	addi	r2,r2,31388
 2022d50:	18c00524 	muli	r3,r3,20
 2022d54:	10c5883a 	add	r2,r2,r3
 2022d58:	108004c4 	addi	r2,r2,19
 2022d5c:	10800003 	ldbu	r2,0(r2)
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 2022d60:	10803fcc 	andi	r2,r2,255
 2022d64:	108000b0 	cmpltui	r2,r2,2
 2022d68:	1000041e 	bne	r2,zero,2022d7c <etharp_tmr+0x104>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
 2022d6c:	e0bfff03 	ldbu	r2,-4(fp)
 2022d70:	1009883a 	mov	r4,r2
 2022d74:	2022bdc0 	call	2022bdc <etharp_free_entry>
 2022d78:	00001206 	br	2022dc4 <etharp_tmr+0x14c>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 2022d7c:	e0ffff03 	ldbu	r3,-4(fp)
 2022d80:	00808134 	movhi	r2,516
 2022d84:	109ea704 	addi	r2,r2,31388
 2022d88:	18c00524 	muli	r3,r3,20
 2022d8c:	10c5883a 	add	r2,r2,r3
 2022d90:	10800484 	addi	r2,r2,18
 2022d94:	10800003 	ldbu	r2,0(r2)
 2022d98:	10803fcc 	andi	r2,r2,255
 2022d9c:	108000d8 	cmpnei	r2,r2,3
 2022da0:	1000081e 	bne	r2,zero,2022dc4 <etharp_tmr+0x14c>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 2022da4:	e0ffff03 	ldbu	r3,-4(fp)
 2022da8:	00808134 	movhi	r2,516
 2022dac:	109ea704 	addi	r2,r2,31388
 2022db0:	18c00524 	muli	r3,r3,20
 2022db4:	10c5883a 	add	r2,r2,r3
 2022db8:	10800484 	addi	r2,r2,18
 2022dbc:	00c00084 	movi	r3,2
 2022dc0:	10c00005 	stb	r3,0(r2)
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2022dc4:	e0bfff03 	ldbu	r2,-4(fp)
 2022dc8:	10800044 	addi	r2,r2,1
 2022dcc:	e0bfff05 	stb	r2,-4(fp)
 2022dd0:	e0bfff03 	ldbu	r2,-4(fp)
 2022dd4:	10800670 	cmpltui	r2,r2,25
 2022dd8:	103fad1e 	bne	r2,zero,2022c90 <__alt_mem_mem_0+0xfd002c90>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
 2022ddc:	0001883a 	nop
 2022de0:	e037883a 	mov	sp,fp
 2022de4:	dfc00117 	ldw	ra,4(sp)
 2022de8:	df000017 	ldw	fp,0(sp)
 2022dec:	dec00204 	addi	sp,sp,8
 2022df0:	f800283a 	ret

02022df4 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 2022df4:	defff904 	addi	sp,sp,-28
 2022df8:	dfc00615 	stw	ra,24(sp)
 2022dfc:	df000515 	stw	fp,20(sp)
 2022e00:	df000504 	addi	fp,sp,20
 2022e04:	e13ffe15 	stw	r4,-8(fp)
 2022e08:	2805883a 	mov	r2,r5
 2022e0c:	e0bfff05 	stb	r2,-4(fp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 2022e10:	00800644 	movi	r2,25
 2022e14:	e0bffb05 	stb	r2,-20(fp)
 2022e18:	00800644 	movi	r2,25
 2022e1c:	e0bffb45 	stb	r2,-19(fp)
  s8_t empty = ARP_TABLE_SIZE;
 2022e20:	00800644 	movi	r2,25
 2022e24:	e0bffb85 	stb	r2,-18(fp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
 2022e28:	e03ffbc5 	stb	zero,-17(fp)
 2022e2c:	e03ffc05 	stb	zero,-16(fp)
 2022e30:	e03ffc45 	stb	zero,-15(fp)
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 2022e34:	00800644 	movi	r2,25
 2022e38:	e0bffc85 	stb	r2,-14(fp)
  /* its age */
  u8_t age_queue = 0;
 2022e3c:	e03ffcc5 	stb	zero,-13(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2022e40:	e03ffbc5 	stb	zero,-17(fp)
 2022e44:	00006e06 	br	2023000 <etharp_find_entry+0x20c>
    u8_t state = arp_table[i].state;
 2022e48:	e0fffbc3 	ldbu	r3,-17(fp)
 2022e4c:	00808134 	movhi	r2,516
 2022e50:	109ea704 	addi	r2,r2,31388
 2022e54:	18c00524 	muli	r3,r3,20
 2022e58:	10c5883a 	add	r2,r2,r3
 2022e5c:	10800484 	addi	r2,r2,18
 2022e60:	10800003 	ldbu	r2,0(r2)
 2022e64:	e0bffd05 	stb	r2,-12(fp)
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 2022e68:	e0bffb87 	ldb	r2,-18(fp)
 2022e6c:	10800658 	cmpnei	r2,r2,25
 2022e70:	1000051e 	bne	r2,zero,2022e88 <etharp_find_entry+0x94>
 2022e74:	e0bffd03 	ldbu	r2,-12(fp)
 2022e78:	1000031e 	bne	r2,zero,2022e88 <etharp_find_entry+0x94>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 2022e7c:	e0bffbc3 	ldbu	r2,-17(fp)
 2022e80:	e0bffb85 	stb	r2,-18(fp)
 2022e84:	00005b06 	br	2022ff4 <etharp_find_entry+0x200>
    } else if (state != ETHARP_STATE_EMPTY) {
 2022e88:	e0bffd03 	ldbu	r2,-12(fp)
 2022e8c:	10005926 	beq	r2,zero,2022ff4 <etharp_find_entry+0x200>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 2022e90:	e0bffe17 	ldw	r2,-8(fp)
 2022e94:	10000c26 	beq	r2,zero,2022ec8 <etharp_find_entry+0xd4>
 2022e98:	e0bffe17 	ldw	r2,-8(fp)
 2022e9c:	10c00017 	ldw	r3,0(r2)
 2022ea0:	e13ffbc3 	ldbu	r4,-17(fp)
 2022ea4:	00808134 	movhi	r2,516
 2022ea8:	109ea704 	addi	r2,r2,31388
 2022eac:	21000524 	muli	r4,r4,20
 2022eb0:	1105883a 	add	r2,r2,r4
 2022eb4:	10800104 	addi	r2,r2,4
 2022eb8:	10800017 	ldw	r2,0(r2)
 2022ebc:	1880021e 	bne	r3,r2,2022ec8 <etharp_find_entry+0xd4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
 2022ec0:	e0bffbc3 	ldbu	r2,-17(fp)
 2022ec4:	00008c06 	br	20230f8 <etharp_find_entry+0x304>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 2022ec8:	e0bffd03 	ldbu	r2,-12(fp)
 2022ecc:	10800058 	cmpnei	r2,r2,1
 2022ed0:	1000311e 	bne	r2,zero,2022f98 <etharp_find_entry+0x1a4>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 2022ed4:	e0fffbc3 	ldbu	r3,-17(fp)
 2022ed8:	00808134 	movhi	r2,516
 2022edc:	109ea704 	addi	r2,r2,31388
 2022ee0:	18c00524 	muli	r3,r3,20
 2022ee4:	10c5883a 	add	r2,r2,r3
 2022ee8:	10800017 	ldw	r2,0(r2)
 2022eec:	10001526 	beq	r2,zero,2022f44 <etharp_find_entry+0x150>
          if (arp_table[i].ctime >= age_queue) {
 2022ef0:	e0fffbc3 	ldbu	r3,-17(fp)
 2022ef4:	00808134 	movhi	r2,516
 2022ef8:	109ea704 	addi	r2,r2,31388
 2022efc:	18c00524 	muli	r3,r3,20
 2022f00:	10c5883a 	add	r2,r2,r3
 2022f04:	108004c4 	addi	r2,r2,19
 2022f08:	10800003 	ldbu	r2,0(r2)
 2022f0c:	10c03fcc 	andi	r3,r2,255
 2022f10:	e0bffcc3 	ldbu	r2,-13(fp)
 2022f14:	18803736 	bltu	r3,r2,2022ff4 <etharp_find_entry+0x200>
            old_queue = i;
 2022f18:	e0bffbc3 	ldbu	r2,-17(fp)
 2022f1c:	e0bffc85 	stb	r2,-14(fp)
            age_queue = arp_table[i].ctime;
 2022f20:	e0fffbc3 	ldbu	r3,-17(fp)
 2022f24:	00808134 	movhi	r2,516
 2022f28:	109ea704 	addi	r2,r2,31388
 2022f2c:	18c00524 	muli	r3,r3,20
 2022f30:	10c5883a 	add	r2,r2,r3
 2022f34:	108004c4 	addi	r2,r2,19
 2022f38:	10800003 	ldbu	r2,0(r2)
 2022f3c:	e0bffcc5 	stb	r2,-13(fp)
 2022f40:	00002c06 	br	2022ff4 <etharp_find_entry+0x200>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 2022f44:	e0fffbc3 	ldbu	r3,-17(fp)
 2022f48:	00808134 	movhi	r2,516
 2022f4c:	109ea704 	addi	r2,r2,31388
 2022f50:	18c00524 	muli	r3,r3,20
 2022f54:	10c5883a 	add	r2,r2,r3
 2022f58:	108004c4 	addi	r2,r2,19
 2022f5c:	10800003 	ldbu	r2,0(r2)
 2022f60:	10c03fcc 	andi	r3,r2,255
 2022f64:	e0bffc03 	ldbu	r2,-16(fp)
 2022f68:	18802236 	bltu	r3,r2,2022ff4 <etharp_find_entry+0x200>
            old_pending = i;
 2022f6c:	e0bffbc3 	ldbu	r2,-17(fp)
 2022f70:	e0bffb05 	stb	r2,-20(fp)
            age_pending = arp_table[i].ctime;
 2022f74:	e0fffbc3 	ldbu	r3,-17(fp)
 2022f78:	00808134 	movhi	r2,516
 2022f7c:	109ea704 	addi	r2,r2,31388
 2022f80:	18c00524 	muli	r3,r3,20
 2022f84:	10c5883a 	add	r2,r2,r3
 2022f88:	108004c4 	addi	r2,r2,19
 2022f8c:	10800003 	ldbu	r2,0(r2)
 2022f90:	e0bffc05 	stb	r2,-16(fp)
 2022f94:	00001706 	br	2022ff4 <etharp_find_entry+0x200>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
 2022f98:	e0bffd03 	ldbu	r2,-12(fp)
 2022f9c:	108000b0 	cmpltui	r2,r2,2
 2022fa0:	1000141e 	bne	r2,zero,2022ff4 <etharp_find_entry+0x200>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 2022fa4:	e0fffbc3 	ldbu	r3,-17(fp)
 2022fa8:	00808134 	movhi	r2,516
 2022fac:	109ea704 	addi	r2,r2,31388
 2022fb0:	18c00524 	muli	r3,r3,20
 2022fb4:	10c5883a 	add	r2,r2,r3
 2022fb8:	108004c4 	addi	r2,r2,19
 2022fbc:	10800003 	ldbu	r2,0(r2)
 2022fc0:	10c03fcc 	andi	r3,r2,255
 2022fc4:	e0bffc43 	ldbu	r2,-15(fp)
 2022fc8:	18800a36 	bltu	r3,r2,2022ff4 <etharp_find_entry+0x200>
            old_stable = i;
 2022fcc:	e0bffbc3 	ldbu	r2,-17(fp)
 2022fd0:	e0bffb45 	stb	r2,-19(fp)
            age_stable = arp_table[i].ctime;
 2022fd4:	e0fffbc3 	ldbu	r3,-17(fp)
 2022fd8:	00808134 	movhi	r2,516
 2022fdc:	109ea704 	addi	r2,r2,31388
 2022fe0:	18c00524 	muli	r3,r3,20
 2022fe4:	10c5883a 	add	r2,r2,r3
 2022fe8:	108004c4 	addi	r2,r2,19
 2022fec:	10800003 	ldbu	r2,0(r2)
 2022ff0:	e0bffc45 	stb	r2,-15(fp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 2022ff4:	e0bffbc3 	ldbu	r2,-17(fp)
 2022ff8:	10800044 	addi	r2,r2,1
 2022ffc:	e0bffbc5 	stb	r2,-17(fp)
 2023000:	e0bffbc3 	ldbu	r2,-17(fp)
 2023004:	10800670 	cmpltui	r2,r2,25
 2023008:	103f8f1e 	bne	r2,zero,2022e48 <__alt_mem_mem_0+0xfd002e48>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 202300c:	e0bfff03 	ldbu	r2,-4(fp)
 2023010:	1080008c 	andi	r2,r2,2
 2023014:	1000061e 	bne	r2,zero,2023030 <etharp_find_entry+0x23c>
 2023018:	e0bffb87 	ldb	r2,-18(fp)
 202301c:	10800658 	cmpnei	r2,r2,25
 2023020:	1000051e 	bne	r2,zero,2023038 <etharp_find_entry+0x244>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 2023024:	e0bfff03 	ldbu	r2,-4(fp)
 2023028:	1080004c 	andi	r2,r2,1
 202302c:	1000021e 	bne	r2,zero,2023038 <etharp_find_entry+0x244>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 2023030:	00bfffc4 	movi	r2,-1
 2023034:	00003006 	br	20230f8 <etharp_find_entry+0x304>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
 2023038:	e0bffb87 	ldb	r2,-18(fp)
 202303c:	10800648 	cmpgei	r2,r2,25
 2023040:	1000031e 	bne	r2,zero,2023050 <etharp_find_entry+0x25c>
    i = empty;
 2023044:	e0bffb83 	ldbu	r2,-18(fp)
 2023048:	e0bffbc5 	stb	r2,-17(fp)
 202304c:	00001706 	br	20230ac <etharp_find_entry+0x2b8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 2023050:	e0bffb47 	ldb	r2,-19(fp)
 2023054:	10800648 	cmpgei	r2,r2,25
 2023058:	1000031e 	bne	r2,zero,2023068 <etharp_find_entry+0x274>
      /* recycle oldest stable*/
      i = old_stable;
 202305c:	e0bffb43 	ldbu	r2,-19(fp)
 2023060:	e0bffbc5 	stb	r2,-17(fp)
 2023064:	00000e06 	br	20230a0 <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 2023068:	e0bffb07 	ldb	r2,-20(fp)
 202306c:	10800648 	cmpgei	r2,r2,25
 2023070:	1000031e 	bne	r2,zero,2023080 <etharp_find_entry+0x28c>
      /* recycle oldest pending */
      i = old_pending;
 2023074:	e0bffb03 	ldbu	r2,-20(fp)
 2023078:	e0bffbc5 	stb	r2,-17(fp)
 202307c:	00000806 	br	20230a0 <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 2023080:	e0bffc87 	ldb	r2,-14(fp)
 2023084:	10800648 	cmpgei	r2,r2,25
 2023088:	1000031e 	bne	r2,zero,2023098 <etharp_find_entry+0x2a4>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 202308c:	e0bffc83 	ldbu	r2,-14(fp)
 2023090:	e0bffbc5 	stb	r2,-17(fp)
 2023094:	00000206 	br	20230a0 <etharp_find_entry+0x2ac>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
 2023098:	00bfffc4 	movi	r2,-1
 202309c:	00001606 	br	20230f8 <etharp_find_entry+0x304>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
 20230a0:	e0bffbc3 	ldbu	r2,-17(fp)
 20230a4:	1009883a 	mov	r4,r2
 20230a8:	2022bdc0 	call	2022bdc <etharp_free_entry>
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 20230ac:	e0bffe17 	ldw	r2,-8(fp)
 20230b0:	10000926 	beq	r2,zero,20230d8 <etharp_find_entry+0x2e4>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 20230b4:	e13ffbc3 	ldbu	r4,-17(fp)
 20230b8:	e0bffe17 	ldw	r2,-8(fp)
 20230bc:	10c00017 	ldw	r3,0(r2)
 20230c0:	00808134 	movhi	r2,516
 20230c4:	109ea704 	addi	r2,r2,31388
 20230c8:	21000524 	muli	r4,r4,20
 20230cc:	1105883a 	add	r2,r2,r4
 20230d0:	10800104 	addi	r2,r2,4
 20230d4:	10c00015 	stw	r3,0(r2)
  }
  arp_table[i].ctime = 0;
 20230d8:	e0fffbc3 	ldbu	r3,-17(fp)
 20230dc:	00808134 	movhi	r2,516
 20230e0:	109ea704 	addi	r2,r2,31388
 20230e4:	18c00524 	muli	r3,r3,20
 20230e8:	10c5883a 	add	r2,r2,r3
 20230ec:	108004c4 	addi	r2,r2,19
 20230f0:	10000005 	stb	zero,0(r2)
  return (err_t)i;
 20230f4:	e0bffbc3 	ldbu	r2,-17(fp)
}
 20230f8:	e037883a 	mov	sp,fp
 20230fc:	dfc00117 	ldw	ra,4(sp)
 2023100:	df000017 	ldw	fp,0(sp)
 2023104:	dec00204 	addi	sp,sp,8
 2023108:	f800283a 	ret

0202310c <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 202310c:	defff904 	addi	sp,sp,-28
 2023110:	dfc00615 	stw	ra,24(sp)
 2023114:	df000515 	stw	fp,20(sp)
 2023118:	df000504 	addi	fp,sp,20
 202311c:	e13ffc15 	stw	r4,-16(fp)
 2023120:	e17ffd15 	stw	r5,-12(fp)
 2023124:	e1bffe15 	stw	r6,-8(fp)
 2023128:	e1ffff15 	stw	r7,-4(fp)
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 202312c:	e0bffd17 	ldw	r2,-12(fp)
 2023130:	10800117 	ldw	r2,4(r2)
 2023134:	e0bffb15 	stw	r2,-20(fp)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 2023138:	e0bffb17 	ldw	r2,-20(fp)
 202313c:	10800084 	addi	r2,r2,2
 2023140:	01800184 	movi	r6,6
 2023144:	e17fff17 	ldw	r5,-4(fp)
 2023148:	1009883a 	mov	r4,r2
 202314c:	20060240 	call	2006024 <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
 2023150:	e0bffb17 	ldw	r2,-20(fp)
 2023154:	10800204 	addi	r2,r2,8
 2023158:	01800184 	movi	r6,6
 202315c:	e17ffe17 	ldw	r5,-8(fp)
 2023160:	1009883a 	mov	r4,r2
 2023164:	20060240 	call	2006024 <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 2023168:	e0bffb17 	ldw	r2,-20(fp)
 202316c:	10c00383 	ldbu	r3,14(r2)
 2023170:	1806703a 	and	r3,r3,zero
 2023174:	18c00214 	ori	r3,r3,8
 2023178:	10c00385 	stb	r3,14(r2)
 202317c:	10c003c3 	ldbu	r3,15(r2)
 2023180:	1806703a 	and	r3,r3,zero
 2023184:	10c003c5 	stb	r3,15(r2)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 2023188:	e0bffc17 	ldw	r2,-16(fp)
 202318c:	10800617 	ldw	r2,24(r2)
 2023190:	e17ffd17 	ldw	r5,-12(fp)
 2023194:	e13ffc17 	ldw	r4,-16(fp)
 2023198:	103ee83a 	callr	r2
}
 202319c:	e037883a 	mov	sp,fp
 20231a0:	dfc00117 	ldw	ra,4(sp)
 20231a4:	df000017 	ldw	fp,0(sp)
 20231a8:	dec00204 	addi	sp,sp,8
 20231ac:	f800283a 	ret

020231b0 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 20231b0:	defff704 	addi	sp,sp,-36
 20231b4:	dfc00815 	stw	ra,32(sp)
 20231b8:	df000715 	stw	fp,28(sp)
 20231bc:	df000704 	addi	fp,sp,28
 20231c0:	e13ffc15 	stw	r4,-16(fp)
 20231c4:	e17ffd15 	stw	r5,-12(fp)
 20231c8:	e1bffe15 	stw	r6,-8(fp)
 20231cc:	3805883a 	mov	r2,r7
 20231d0:	e0bfff05 	stb	r2,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 20231d4:	e0bffd17 	ldw	r2,-12(fp)
 20231d8:	10000f26 	beq	r2,zero,2023218 <etharp_update_arp_entry+0x68>
 20231dc:	e0bffd17 	ldw	r2,-12(fp)
 20231e0:	10800017 	ldw	r2,0(r2)
 20231e4:	10000c26 	beq	r2,zero,2023218 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
 20231e8:	e0bffd17 	ldw	r2,-12(fp)
 20231ec:	10800017 	ldw	r2,0(r2)
 20231f0:	e17ffc17 	ldw	r5,-16(fp)
 20231f4:	1009883a 	mov	r4,r2
 20231f8:	20189240 	call	2018924 <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 20231fc:	10803fcc 	andi	r2,r2,255
 2023200:	1000051e 	bne	r2,zero,2023218 <etharp_update_arp_entry+0x68>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
 2023204:	e0bffd17 	ldw	r2,-12(fp)
 2023208:	10800017 	ldw	r2,0(r2)
 202320c:	10803c0c 	andi	r2,r2,240
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
 2023210:	10803818 	cmpnei	r2,r2,224
 2023214:	1000021e 	bne	r2,zero,2023220 <etharp_update_arp_entry+0x70>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 2023218:	00bffc84 	movi	r2,-14
 202321c:	00005106 	br	2023364 <etharp_update_arp_entry+0x1b4>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 2023220:	e0bfff03 	ldbu	r2,-4(fp)
 2023224:	100b883a 	mov	r5,r2
 2023228:	e13ffd17 	ldw	r4,-12(fp)
 202322c:	2022df40 	call	2022df4 <etharp_find_entry>
 2023230:	e0bff905 	stb	r2,-28(fp)
  /* bail out if no entry could be found */
  if (i < 0) {
 2023234:	e0bff907 	ldb	r2,-28(fp)
 2023238:	1000020e 	bge	r2,zero,2023244 <etharp_update_arp_entry+0x94>
    return (err_t)i;
 202323c:	e0bff903 	ldbu	r2,-28(fp)
 2023240:	00004806 	br	2023364 <etharp_update_arp_entry+0x1b4>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 2023244:	e0fff907 	ldb	r3,-28(fp)
 2023248:	00808134 	movhi	r2,516
 202324c:	109ea704 	addi	r2,r2,31388
 2023250:	18c00524 	muli	r3,r3,20
 2023254:	10c5883a 	add	r2,r2,r3
 2023258:	10800484 	addi	r2,r2,18
 202325c:	00c00084 	movi	r3,2
 2023260:	10c00005 	stb	r3,0(r2)
  }

  /* record network interface */
  arp_table[i].netif = netif;
 2023264:	e0fff907 	ldb	r3,-28(fp)
 2023268:	00808134 	movhi	r2,516
 202326c:	109ea704 	addi	r2,r2,31388
 2023270:	18c00524 	muli	r3,r3,20
 2023274:	10c5883a 	add	r2,r2,r3
 2023278:	10800204 	addi	r2,r2,8
 202327c:	e0fffc17 	ldw	r3,-16(fp)
 2023280:	10c00015 	stw	r3,0(r2)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 2023284:	e0bff907 	ldb	r2,-28(fp)
 2023288:	10800524 	muli	r2,r2,20
 202328c:	10c00304 	addi	r3,r2,12
 2023290:	00808134 	movhi	r2,516
 2023294:	109ea704 	addi	r2,r2,31388
 2023298:	1885883a 	add	r2,r3,r2
 202329c:	01800184 	movi	r6,6
 20232a0:	e17ffe17 	ldw	r5,-8(fp)
 20232a4:	1009883a 	mov	r4,r2
 20232a8:	20060240 	call	2006024 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
 20232ac:	e0fff907 	ldb	r3,-28(fp)
 20232b0:	00808134 	movhi	r2,516
 20232b4:	109ea704 	addi	r2,r2,31388
 20232b8:	18c00524 	muli	r3,r3,20
 20232bc:	10c5883a 	add	r2,r2,r3
 20232c0:	108004c4 	addi	r2,r2,19
 20232c4:	10000005 	stb	zero,0(r2)
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 20232c8:	00001e06 	br	2023344 <etharp_update_arp_entry+0x194>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
 20232cc:	e0fff907 	ldb	r3,-28(fp)
 20232d0:	00808134 	movhi	r2,516
 20232d4:	109ea704 	addi	r2,r2,31388
 20232d8:	18c00524 	muli	r3,r3,20
 20232dc:	10c5883a 	add	r2,r2,r3
 20232e0:	10800017 	ldw	r2,0(r2)
 20232e4:	e0bffa15 	stw	r2,-24(fp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 20232e8:	e13ff907 	ldb	r4,-28(fp)
 20232ec:	e0bffa17 	ldw	r2,-24(fp)
 20232f0:	10c00017 	ldw	r3,0(r2)
 20232f4:	00808134 	movhi	r2,516
 20232f8:	109ea704 	addi	r2,r2,31388
 20232fc:	21000524 	muli	r4,r4,20
 2023300:	1105883a 	add	r2,r2,r4
 2023304:	10c00015 	stw	r3,0(r2)
    /* get the packet pointer */
    p = q->p;
 2023308:	e0bffa17 	ldw	r2,-24(fp)
 202330c:	10800117 	ldw	r2,4(r2)
 2023310:	e0bffb15 	stw	r2,-20(fp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 2023314:	e17ffa17 	ldw	r5,-24(fp)
 2023318:	010002c4 	movi	r4,11
 202331c:	20346000 	call	2034600 <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 2023320:	e0bffc17 	ldw	r2,-16(fp)
 2023324:	10800cc4 	addi	r2,r2,51
 2023328:	e1fffe17 	ldw	r7,-8(fp)
 202332c:	100d883a 	mov	r6,r2
 2023330:	e17ffb17 	ldw	r5,-20(fp)
 2023334:	e13ffc17 	ldw	r4,-16(fp)
 2023338:	202310c0 	call	202310c <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 202333c:	e13ffb17 	ldw	r4,-20(fp)
 2023340:	201ab680 	call	201ab68 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 2023344:	e0fff907 	ldb	r3,-28(fp)
 2023348:	00808134 	movhi	r2,516
 202334c:	109ea704 	addi	r2,r2,31388
 2023350:	18c00524 	muli	r3,r3,20
 2023354:	10c5883a 	add	r2,r2,r3
 2023358:	10800017 	ldw	r2,0(r2)
 202335c:	103fdb1e 	bne	r2,zero,20232cc <__alt_mem_mem_0+0xfd0032cc>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
 2023360:	0005883a 	mov	r2,zero
}
 2023364:	e037883a 	mov	sp,fp
 2023368:	dfc00117 	ldw	ra,4(sp)
 202336c:	df000017 	ldw	fp,0(sp)
 2023370:	dec00204 	addi	sp,sp,8
 2023374:	f800283a 	ret

02023378 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
 2023378:	defffc04 	addi	sp,sp,-16
 202337c:	dfc00315 	stw	ra,12(sp)
 2023380:	df000215 	stw	fp,8(sp)
 2023384:	df000204 	addi	fp,sp,8
 2023388:	e13fff15 	stw	r4,-4(fp)
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 202338c:	e03ffe05 	stb	zero,-8(fp)
 2023390:	00001906 	br	20233f8 <etharp_cleanup_netif+0x80>
    u8_t state = arp_table[i].state;
 2023394:	e0fffe03 	ldbu	r3,-8(fp)
 2023398:	00808134 	movhi	r2,516
 202339c:	109ea704 	addi	r2,r2,31388
 20233a0:	18c00524 	muli	r3,r3,20
 20233a4:	10c5883a 	add	r2,r2,r3
 20233a8:	10800484 	addi	r2,r2,18
 20233ac:	10800003 	ldbu	r2,0(r2)
 20233b0:	e0bffe45 	stb	r2,-7(fp)
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 20233b4:	e0bffe43 	ldbu	r2,-7(fp)
 20233b8:	10000c26 	beq	r2,zero,20233ec <etharp_cleanup_netif+0x74>
 20233bc:	e0fffe03 	ldbu	r3,-8(fp)
 20233c0:	00808134 	movhi	r2,516
 20233c4:	109ea704 	addi	r2,r2,31388
 20233c8:	18c00524 	muli	r3,r3,20
 20233cc:	10c5883a 	add	r2,r2,r3
 20233d0:	10800204 	addi	r2,r2,8
 20233d4:	10c00017 	ldw	r3,0(r2)
 20233d8:	e0bfff17 	ldw	r2,-4(fp)
 20233dc:	1880031e 	bne	r3,r2,20233ec <etharp_cleanup_netif+0x74>
      etharp_free_entry(i);
 20233e0:	e0bffe03 	ldbu	r2,-8(fp)
 20233e4:	1009883a 	mov	r4,r2
 20233e8:	2022bdc0 	call	2022bdc <etharp_free_entry>
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 20233ec:	e0bffe03 	ldbu	r2,-8(fp)
 20233f0:	10800044 	addi	r2,r2,1
 20233f4:	e0bffe05 	stb	r2,-8(fp)
 20233f8:	e0bffe03 	ldbu	r2,-8(fp)
 20233fc:	10800670 	cmpltui	r2,r2,25
 2023400:	103fe41e 	bne	r2,zero,2023394 <__alt_mem_mem_0+0xfd003394>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
 2023404:	0001883a 	nop
 2023408:	e037883a 	mov	sp,fp
 202340c:	dfc00117 	ldw	ra,4(sp)
 2023410:	df000017 	ldw	fp,0(sp)
 2023414:	dec00204 	addi	sp,sp,8
 2023418:	f800283a 	ret

0202341c <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
 202341c:	defff904 	addi	sp,sp,-28
 2023420:	dfc00615 	stw	ra,24(sp)
 2023424:	df000515 	stw	fp,20(sp)
 2023428:	df000504 	addi	fp,sp,20
 202342c:	e13ffc15 	stw	r4,-16(fp)
 2023430:	e17ffd15 	stw	r5,-12(fp)
 2023434:	e1bffe15 	stw	r6,-8(fp)
 2023438:	e1ffff15 	stw	r7,-4(fp)
  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 202343c:	01400084 	movi	r5,2
 2023440:	e13ffd17 	ldw	r4,-12(fp)
 2023444:	2022df40 	call	2022df4 <etharp_find_entry>
 2023448:	e0bffb05 	stb	r2,-20(fp)
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 202344c:	e0bffb07 	ldb	r2,-20(fp)
 2023450:	10001c16 	blt	r2,zero,20234c4 <etharp_find_addr+0xa8>
 2023454:	e0fffb07 	ldb	r3,-20(fp)
 2023458:	00808134 	movhi	r2,516
 202345c:	109ea704 	addi	r2,r2,31388
 2023460:	18c00524 	muli	r3,r3,20
 2023464:	10c5883a 	add	r2,r2,r3
 2023468:	10800484 	addi	r2,r2,18
 202346c:	10800003 	ldbu	r2,0(r2)
 2023470:	10803fcc 	andi	r2,r2,255
 2023474:	108000b0 	cmpltui	r2,r2,2
 2023478:	1000121e 	bne	r2,zero,20234c4 <etharp_find_addr+0xa8>
      *eth_ret = &arp_table[i].ethaddr;
 202347c:	e0bffb07 	ldb	r2,-20(fp)
 2023480:	10800524 	muli	r2,r2,20
 2023484:	10c00304 	addi	r3,r2,12
 2023488:	00808134 	movhi	r2,516
 202348c:	109ea704 	addi	r2,r2,31388
 2023490:	1887883a 	add	r3,r3,r2
 2023494:	e0bffe17 	ldw	r2,-8(fp)
 2023498:	10c00015 	stw	r3,0(r2)
      *ip_ret = &arp_table[i].ipaddr;
 202349c:	e0bffb07 	ldb	r2,-20(fp)
 20234a0:	10800524 	muli	r2,r2,20
 20234a4:	10c00104 	addi	r3,r2,4
 20234a8:	00808134 	movhi	r2,516
 20234ac:	109ea704 	addi	r2,r2,31388
 20234b0:	1887883a 	add	r3,r3,r2
 20234b4:	e0bfff17 	ldw	r2,-4(fp)
 20234b8:	10c00015 	stw	r3,0(r2)
      return i;
 20234bc:	e0bffb03 	ldbu	r2,-20(fp)
 20234c0:	00000106 	br	20234c8 <etharp_find_addr+0xac>
  }
  return -1;
 20234c4:	00bfffc4 	movi	r2,-1
}
 20234c8:	e037883a 	mov	sp,fp
 20234cc:	dfc00117 	ldw	ra,4(sp)
 20234d0:	df000017 	ldw	fp,0(sp)
 20234d4:	dec00204 	addi	sp,sp,8
 20234d8:	f800283a 	ret

020234dc <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
 20234dc:	defff904 	addi	sp,sp,-28
 20234e0:	dfc00615 	stw	ra,24(sp)
 20234e4:	df000515 	stw	fp,20(sp)
 20234e8:	df000504 	addi	fp,sp,20
 20234ec:	e13ffe15 	stw	r4,-8(fp)
 20234f0:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 20234f4:	e0bffe17 	ldw	r2,-8(fp)
 20234f8:	1000091e 	bne	r2,zero,2023520 <etharp_ip_input+0x44>
 20234fc:	01c08134 	movhi	r7,516
 2023500:	39c61704 	addi	r7,r7,6236
 2023504:	0180a104 	movi	r6,644
 2023508:	01408134 	movhi	r5,516
 202350c:	29461d04 	addi	r5,r5,6260
 2023510:	01008134 	movhi	r4,516
 2023514:	21062104 	addi	r4,r4,6276
 2023518:	2000bb00 	call	2000bb0 <printf>
 202351c:	003fff06 	br	202351c <__alt_mem_mem_0+0xfd00351c>

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
 2023520:	e0bfff17 	ldw	r2,-4(fp)
 2023524:	10800117 	ldw	r2,4(r2)
 2023528:	e0bffb15 	stw	r2,-20(fp)
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 202352c:	e0bffb17 	ldw	r2,-20(fp)
 2023530:	10800404 	addi	r2,r2,16
 2023534:	e0bffc15 	stw	r2,-16(fp)
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
 2023538:	e0bffc17 	ldw	r2,-16(fp)
 202353c:	10c00303 	ldbu	r3,12(r2)
 2023540:	11000343 	ldbu	r4,13(r2)
 2023544:	2008923a 	slli	r4,r4,8
 2023548:	20c6b03a 	or	r3,r4,r3
 202354c:	11000383 	ldbu	r4,14(r2)
 2023550:	2008943a 	slli	r4,r4,16
 2023554:	20c6b03a 	or	r3,r4,r3
 2023558:	108003c3 	ldbu	r2,15(r2)
 202355c:	1004963a 	slli	r2,r2,24
 2023560:	10c4b03a 	or	r2,r2,r3
 2023564:	e0bffd15 	stw	r2,-12(fp)

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 2023568:	e0fffd17 	ldw	r3,-12(fp)
 202356c:	e0bffe17 	ldw	r2,-8(fp)
 2023570:	10800117 	ldw	r2,4(r2)
 2023574:	1886f03a 	xor	r3,r3,r2
 2023578:	e0bffe17 	ldw	r2,-8(fp)
 202357c:	10800217 	ldw	r2,8(r2)
 2023580:	1884703a 	and	r2,r3,r2
 2023584:	1000091e 	bne	r2,zero,20235ac <etharp_ip_input+0xd0>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
 2023588:	e0bffb17 	ldw	r2,-20(fp)
 202358c:	10c00204 	addi	r3,r2,8
 2023590:	e0bffd04 	addi	r2,fp,-12
 2023594:	01c00084 	movi	r7,2
 2023598:	180d883a 	mov	r6,r3
 202359c:	100b883a 	mov	r5,r2
 20235a0:	e13ffe17 	ldw	r4,-8(fp)
 20235a4:	20231b00 	call	20231b0 <etharp_update_arp_entry>
 20235a8:	00000106 	br	20235b0 <etharp_ip_input+0xd4>
  ip_addr_copy(iphdr_src, iphdr->src);

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
 20235ac:	0001883a 	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
}
 20235b0:	e037883a 	mov	sp,fp
 20235b4:	dfc00117 	ldw	ra,4(sp)
 20235b8:	df000017 	ldw	fp,0(sp)
 20235bc:	dec00204 	addi	sp,sp,8
 20235c0:	f800283a 	ret

020235c4 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
 20235c4:	defff404 	addi	sp,sp,-48
 20235c8:	dfc00b15 	stw	ra,44(sp)
 20235cc:	df000a15 	stw	fp,40(sp)
 20235d0:	df000a04 	addi	fp,sp,40
 20235d4:	e13ffb15 	stw	r4,-20(fp)
 20235d8:	e17ffc15 	stw	r5,-16(fp)
 20235dc:	e1bffd15 	stw	r6,-12(fp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
 20235e0:	e0bffb17 	ldw	r2,-20(fp)
 20235e4:	1000091e 	bne	r2,zero,202360c <etharp_arp_input+0x48>
 20235e8:	01c08134 	movhi	r7,516
 20235ec:	39c61704 	addi	r7,r7,6236
 20235f0:	0180aec4 	movi	r6,699
 20235f4:	01408134 	movhi	r5,516
 20235f8:	29461d04 	addi	r5,r5,6260
 20235fc:	01008134 	movhi	r4,516
 2023600:	21062104 	addi	r4,r4,6276
 2023604:	2000bb00 	call	2000bb0 <printf>
 2023608:	003fff06 	br	2023608 <__alt_mem_mem_0+0xfd003608>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 202360c:	e0bffd17 	ldw	r2,-12(fp)
 2023610:	1080028b 	ldhu	r2,10(r2)
 2023614:	10bfffcc 	andi	r2,r2,65535
 2023618:	10800b28 	cmpgeui	r2,r2,44
 202361c:	1000111e 	bne	r2,zero,2023664 <etharp_arp_input+0xa0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
 2023620:	008085f4 	movhi	r2,535
 2023624:	10a8bc04 	addi	r2,r2,-23824
 2023628:	10801117 	ldw	r2,68(r2)
 202362c:	10c00044 	addi	r3,r2,1
 2023630:	008085f4 	movhi	r2,535
 2023634:	10a8bc04 	addi	r2,r2,-23824
 2023638:	10c01115 	stw	r3,68(r2)
    ETHARP_STATS_INC(etharp.drop);
 202363c:	008085f4 	movhi	r2,535
 2023640:	10a8bc04 	addi	r2,r2,-23824
 2023644:	10800f17 	ldw	r2,60(r2)
 2023648:	10c00044 	addi	r3,r2,1
 202364c:	008085f4 	movhi	r2,535
 2023650:	10a8bc04 	addi	r2,r2,-23824
 2023654:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
 2023658:	e13ffd17 	ldw	r4,-12(fp)
 202365c:	201ab680 	call	201ab68 <pbuf_free>
    return;
 2023660:	0000b606 	br	202393c <etharp_arp_input+0x378>
  }

  ethhdr = (struct eth_hdr *)p->payload;
 2023664:	e0bffd17 	ldw	r2,-12(fp)
 2023668:	10800117 	ldw	r2,4(r2)
 202366c:	e0bff715 	stw	r2,-36(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 2023670:	e0bff717 	ldw	r2,-36(fp)
 2023674:	10800404 	addi	r2,r2,16
 2023678:	e0bff815 	stw	r2,-32(fp)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 202367c:	e0bff817 	ldw	r2,-32(fp)
 2023680:	10c00003 	ldbu	r3,0(r2)
 2023684:	10800043 	ldbu	r2,1(r2)
 2023688:	1004923a 	slli	r2,r2,8
 202368c:	10c4b03a 	or	r2,r2,r3
 2023690:	10bfffcc 	andi	r2,r2,65535
 2023694:	10804018 	cmpnei	r2,r2,256
 2023698:	1000121e 	bne	r2,zero,20236e4 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 202369c:	e0bff817 	ldw	r2,-32(fp)
 20236a0:	10800103 	ldbu	r2,4(r2)
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 20236a4:	10803fcc 	andi	r2,r2,255
 20236a8:	10800198 	cmpnei	r2,r2,6
 20236ac:	10000d1e 	bne	r2,zero,20236e4 <etharp_arp_input+0x120>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
 20236b0:	e0bff817 	ldw	r2,-32(fp)
 20236b4:	10800143 	ldbu	r2,5(r2)
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 20236b8:	10803fcc 	andi	r2,r2,255
 20236bc:	10800118 	cmpnei	r2,r2,4
 20236c0:	1000081e 	bne	r2,zero,20236e4 <etharp_arp_input+0x120>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
 20236c4:	e0bff817 	ldw	r2,-32(fp)
 20236c8:	10c00083 	ldbu	r3,2(r2)
 20236cc:	108000c3 	ldbu	r2,3(r2)
 20236d0:	1004923a 	slli	r2,r2,8
 20236d4:	10c4b03a 	or	r2,r2,r3
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
 20236d8:	10bfffcc 	andi	r2,r2,65535
 20236dc:	10800220 	cmpeqi	r2,r2,8
 20236e0:	1000111e 	bne	r2,zero,2023728 <etharp_arp_input+0x164>
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
 20236e4:	008085f4 	movhi	r2,535
 20236e8:	10a8bc04 	addi	r2,r2,-23824
 20236ec:	10801417 	ldw	r2,80(r2)
 20236f0:	10c00044 	addi	r3,r2,1
 20236f4:	008085f4 	movhi	r2,535
 20236f8:	10a8bc04 	addi	r2,r2,-23824
 20236fc:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 2023700:	008085f4 	movhi	r2,535
 2023704:	10a8bc04 	addi	r2,r2,-23824
 2023708:	10800f17 	ldw	r2,60(r2)
 202370c:	10c00044 	addi	r3,r2,1
 2023710:	008085f4 	movhi	r2,535
 2023714:	10a8bc04 	addi	r2,r2,-23824
 2023718:	10c00f15 	stw	r3,60(r2)
    pbuf_free(p);
 202371c:	e13ffd17 	ldw	r4,-12(fp)
 2023720:	201ab680 	call	201ab68 <pbuf_free>
    return;
 2023724:	00008506 	br	202393c <etharp_arp_input+0x378>
  }
  ETHARP_STATS_INC(etharp.recv);
 2023728:	008085f4 	movhi	r2,535
 202372c:	10a8bc04 	addi	r2,r2,-23824
 2023730:	10800d17 	ldw	r2,52(r2)
 2023734:	10c00044 	addi	r3,r2,1
 2023738:	008085f4 	movhi	r2,535
 202373c:	10a8bc04 	addi	r2,r2,-23824
 2023740:	10c00d15 	stw	r3,52(r2)
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 2023744:	e0bff817 	ldw	r2,-32(fp)
 2023748:	10c00384 	addi	r3,r2,14
 202374c:	e0bff904 	addi	r2,fp,-28
 2023750:	01800104 	movi	r6,4
 2023754:	180b883a 	mov	r5,r3
 2023758:	1009883a 	mov	r4,r2
 202375c:	20060240 	call	2006024 <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 2023760:	e0bff817 	ldw	r2,-32(fp)
 2023764:	10c00604 	addi	r3,r2,24
 2023768:	e0bffa04 	addi	r2,fp,-24
 202376c:	01800104 	movi	r6,4
 2023770:	180b883a 	mov	r5,r3
 2023774:	1009883a 	mov	r4,r2
 2023778:	20060240 	call	2006024 <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 202377c:	e0bffb17 	ldw	r2,-20(fp)
 2023780:	10800104 	addi	r2,r2,4
 2023784:	10000326 	beq	r2,zero,2023794 <etharp_arp_input+0x1d0>
 2023788:	e0bffb17 	ldw	r2,-20(fp)
 202378c:	10800117 	ldw	r2,4(r2)
 2023790:	1000021e 	bne	r2,zero,202379c <etharp_arp_input+0x1d8>
    for_us = 0;
 2023794:	e03ff605 	stb	zero,-40(fp)
 2023798:	00000506 	br	20237b0 <etharp_arp_input+0x1ec>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
 202379c:	e0fffa17 	ldw	r3,-24(fp)
 20237a0:	e0bffb17 	ldw	r2,-20(fp)
 20237a4:	10800117 	ldw	r2,4(r2)
 20237a8:	1885003a 	cmpeq	r2,r3,r2
 20237ac:	e0bff605 	stb	r2,-40(fp)
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 20237b0:	e0bff817 	ldw	r2,-32(fp)
 20237b4:	11000204 	addi	r4,r2,8
 20237b8:	e0bff603 	ldbu	r2,-40(fp)
 20237bc:	10000226 	beq	r2,zero,20237c8 <etharp_arp_input+0x204>
 20237c0:	00800044 	movi	r2,1
 20237c4:	00000106 	br	20237cc <etharp_arp_input+0x208>
 20237c8:	00800084 	movi	r2,2
 20237cc:	e0fff904 	addi	r3,fp,-28
 20237d0:	100f883a 	mov	r7,r2
 20237d4:	200d883a 	mov	r6,r4
 20237d8:	180b883a 	mov	r5,r3
 20237dc:	e13ffb17 	ldw	r4,-20(fp)
 20237e0:	20231b00 	call	20231b0 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 20237e4:	e0bff817 	ldw	r2,-32(fp)
 20237e8:	10c00183 	ldbu	r3,6(r2)
 20237ec:	108001c3 	ldbu	r2,7(r2)
 20237f0:	1004923a 	slli	r2,r2,8
 20237f4:	10c4b03a 	or	r2,r2,r3
 20237f8:	10bfffcc 	andi	r2,r2,65535
 20237fc:	10c04020 	cmpeqi	r3,r2,256
 2023800:	1800031e 	bne	r3,zero,2023810 <etharp_arp_input+0x24c>
 2023804:	10808020 	cmpeqi	r2,r2,512
 2023808:	10003d1e 	bne	r2,zero,2023900 <etharp_arp_input+0x33c>
 202380c:	00004106 	br	2023914 <etharp_arp_input+0x350>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
 2023810:	e0bff603 	ldbu	r2,-40(fp)
 2023814:	10004726 	beq	r2,zero,2023934 <etharp_arp_input+0x370>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 2023818:	e0bff817 	ldw	r2,-32(fp)
 202381c:	10c00183 	ldbu	r3,6(r2)
 2023820:	1806703a 	and	r3,r3,zero
 2023824:	10c00185 	stb	r3,6(r2)
 2023828:	10c001c3 	ldbu	r3,7(r2)
 202382c:	1806703a 	and	r3,r3,zero
 2023830:	18c00094 	ori	r3,r3,2
 2023834:	10c001c5 	stb	r3,7(r2)

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 2023838:	e0bff817 	ldw	r2,-32(fp)
 202383c:	10c00604 	addi	r3,r2,24
 2023840:	e0bff817 	ldw	r2,-32(fp)
 2023844:	10800384 	addi	r2,r2,14
 2023848:	01800104 	movi	r6,4
 202384c:	100b883a 	mov	r5,r2
 2023850:	1809883a 	mov	r4,r3
 2023854:	20060240 	call	2006024 <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 2023858:	e0bff817 	ldw	r2,-32(fp)
 202385c:	10c00384 	addi	r3,r2,14
 2023860:	e0bffb17 	ldw	r2,-20(fp)
 2023864:	10800104 	addi	r2,r2,4
 2023868:	01800104 	movi	r6,4
 202386c:	100b883a 	mov	r5,r2
 2023870:	1809883a 	mov	r4,r3
 2023874:	20060240 	call	2006024 <memcpy>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 2023878:	e0bff817 	ldw	r2,-32(fp)
 202387c:	10c00484 	addi	r3,r2,18
 2023880:	e0bff817 	ldw	r2,-32(fp)
 2023884:	10800204 	addi	r2,r2,8
 2023888:	01800184 	movi	r6,6
 202388c:	100b883a 	mov	r5,r2
 2023890:	1809883a 	mov	r4,r3
 2023894:	20060240 	call	2006024 <memcpy>
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 2023898:	e0bff717 	ldw	r2,-36(fp)
 202389c:	10c00084 	addi	r3,r2,2
 20238a0:	e0bff817 	ldw	r2,-32(fp)
 20238a4:	10800204 	addi	r2,r2,8
 20238a8:	01800184 	movi	r6,6
 20238ac:	100b883a 	mov	r5,r2
 20238b0:	1809883a 	mov	r4,r3
 20238b4:	20060240 	call	2006024 <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 20238b8:	e0bff817 	ldw	r2,-32(fp)
 20238bc:	10800204 	addi	r2,r2,8
 20238c0:	01800184 	movi	r6,6
 20238c4:	e17ffc17 	ldw	r5,-16(fp)
 20238c8:	1009883a 	mov	r4,r2
 20238cc:	20060240 	call	2006024 <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 20238d0:	e0bff717 	ldw	r2,-36(fp)
 20238d4:	10800204 	addi	r2,r2,8
 20238d8:	01800184 	movi	r6,6
 20238dc:	e17ffc17 	ldw	r5,-16(fp)
 20238e0:	1009883a 	mov	r4,r2
 20238e4:	20060240 	call	2006024 <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 20238e8:	e0bffb17 	ldw	r2,-20(fp)
 20238ec:	10800617 	ldw	r2,24(r2)
 20238f0:	e17ffd17 	ldw	r5,-12(fp)
 20238f4:	e13ffb17 	ldw	r4,-20(fp)
 20238f8:	103ee83a 	callr	r2
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
 20238fc:	00000d06 	br	2023934 <etharp_arp_input+0x370>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
 2023900:	e0bff904 	addi	r2,fp,-28
 2023904:	100b883a 	mov	r5,r2
 2023908:	e13ffb17 	ldw	r4,-20(fp)
 202390c:	20165580 	call	2016558 <dhcp_arp_reply>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
 2023910:	00000806 	br	2023934 <etharp_arp_input+0x370>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
 2023914:	008085f4 	movhi	r2,535
 2023918:	10a8bc04 	addi	r2,r2,-23824
 202391c:	10801617 	ldw	r2,88(r2)
 2023920:	10c00044 	addi	r3,r2,1
 2023924:	008085f4 	movhi	r2,535
 2023928:	10a8bc04 	addi	r2,r2,-23824
 202392c:	10c01615 	stw	r3,88(r2)
    break;
 2023930:	0001883a 	nop
  }
  /* free ARP packet */
  pbuf_free(p);
 2023934:	e13ffd17 	ldw	r4,-12(fp)
 2023938:	201ab680 	call	201ab68 <pbuf_free>
}
 202393c:	e037883a 	mov	sp,fp
 2023940:	dfc00117 	ldw	ra,4(sp)
 2023944:	df000017 	ldw	fp,0(sp)
 2023948:	dec00204 	addi	sp,sp,8
 202394c:	f800283a 	ret

02023950 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 2023950:	defffb04 	addi	sp,sp,-20
 2023954:	dfc00415 	stw	ra,16(sp)
 2023958:	df000315 	stw	fp,12(sp)
 202395c:	df000304 	addi	fp,sp,12
 2023960:	e13ffd15 	stw	r4,-12(fp)
 2023964:	e17ffe15 	stw	r5,-8(fp)
 2023968:	3005883a 	mov	r2,r6
 202396c:	e0bfff05 	stb	r2,-4(fp)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 2023970:	e0ffff03 	ldbu	r3,-4(fp)
 2023974:	00808134 	movhi	r2,516
 2023978:	109ea704 	addi	r2,r2,31388
 202397c:	18c00524 	muli	r3,r3,20
 2023980:	10c5883a 	add	r2,r2,r3
 2023984:	10800484 	addi	r2,r2,18
 2023988:	10800003 	ldbu	r2,0(r2)
 202398c:	10803fcc 	andi	r2,r2,255
 2023990:	10800098 	cmpnei	r2,r2,2
 2023994:	10001f1e 	bne	r2,zero,2023a14 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 2023998:	e0ffff03 	ldbu	r3,-4(fp)
 202399c:	00808134 	movhi	r2,516
 20239a0:	109ea704 	addi	r2,r2,31388
 20239a4:	18c00524 	muli	r3,r3,20
 20239a8:	10c5883a 	add	r2,r2,r3
 20239ac:	108004c4 	addi	r2,r2,19
 20239b0:	10800003 	ldbu	r2,0(r2)
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 20239b4:	10803fcc 	andi	r2,r2,255
 20239b8:	10803930 	cmpltui	r2,r2,228
 20239bc:	1000151e 	bne	r2,zero,2023a14 <etharp_output_to_arp_index+0xc4>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 20239c0:	e0bfff03 	ldbu	r2,-4(fp)
 20239c4:	10800524 	muli	r2,r2,20
 20239c8:	10c00104 	addi	r3,r2,4
 20239cc:	00808134 	movhi	r2,516
 20239d0:	109ea704 	addi	r2,r2,31388
 20239d4:	1885883a 	add	r2,r3,r2
 20239d8:	100b883a 	mov	r5,r2
 20239dc:	e13ffd17 	ldw	r4,-12(fp)
 20239e0:	20243480 	call	2024348 <etharp_request>
 20239e4:	10803fcc 	andi	r2,r2,255
 20239e8:	1080201c 	xori	r2,r2,128
 20239ec:	10bfe004 	addi	r2,r2,-128
 20239f0:	1000081e 	bne	r2,zero,2023a14 <etharp_output_to_arp_index+0xc4>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 20239f4:	e0ffff03 	ldbu	r3,-4(fp)
 20239f8:	00808134 	movhi	r2,516
 20239fc:	109ea704 	addi	r2,r2,31388
 2023a00:	18c00524 	muli	r3,r3,20
 2023a04:	10c5883a 	add	r2,r2,r3
 2023a08:	10800484 	addi	r2,r2,18
 2023a0c:	00c000c4 	movi	r3,3
 2023a10:	10c00005 	stb	r3,0(r2)
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 2023a14:	e0bffd17 	ldw	r2,-12(fp)
 2023a18:	11000cc4 	addi	r4,r2,51
    &arp_table[arp_idx].ethaddr);
 2023a1c:	e0bfff03 	ldbu	r2,-4(fp)
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 2023a20:	10800524 	muli	r2,r2,20
 2023a24:	10c00304 	addi	r3,r2,12
 2023a28:	00808134 	movhi	r2,516
 2023a2c:	109ea704 	addi	r2,r2,31388
 2023a30:	1885883a 	add	r2,r3,r2
 2023a34:	100f883a 	mov	r7,r2
 2023a38:	200d883a 	mov	r6,r4
 2023a3c:	e17ffe17 	ldw	r5,-8(fp)
 2023a40:	e13ffd17 	ldw	r4,-12(fp)
 2023a44:	202310c0 	call	202310c <etharp_send_ip>
    &arp_table[arp_idx].ethaddr);
}
 2023a48:	e037883a 	mov	sp,fp
 2023a4c:	dfc00117 	ldw	ra,4(sp)
 2023a50:	df000017 	ldw	fp,0(sp)
 2023a54:	dec00204 	addi	sp,sp,8
 2023a58:	f800283a 	ret

02023a5c <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 2023a5c:	defff704 	addi	sp,sp,-36
 2023a60:	dfc00815 	stw	ra,32(sp)
 2023a64:	df000715 	stw	fp,28(sp)
 2023a68:	df000704 	addi	fp,sp,28
 2023a6c:	e13ffd15 	stw	r4,-12(fp)
 2023a70:	e17ffe15 	stw	r5,-8(fp)
 2023a74:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
 2023a78:	e0bfff17 	ldw	r2,-4(fp)
 2023a7c:	e0bffa15 	stw	r2,-24(fp)
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 2023a80:	01400404 	movi	r5,16
 2023a84:	e13ffe17 	ldw	r4,-8(fp)
 2023a88:	201a9b80 	call	201a9b8 <pbuf_header>
 2023a8c:	10803fcc 	andi	r2,r2,255
 2023a90:	10000926 	beq	r2,zero,2023ab8 <etharp_output+0x5c>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
 2023a94:	008085f4 	movhi	r2,535
 2023a98:	10a8bc04 	addi	r2,r2,-23824
 2023a9c:	10800517 	ldw	r2,20(r2)
 2023aa0:	10c00044 	addi	r3,r2,1
 2023aa4:	008085f4 	movhi	r2,535
 2023aa8:	10a8bc04 	addi	r2,r2,-23824
 2023aac:	10c00515 	stw	r3,20(r2)
    return ERR_BUF;
 2023ab0:	00bfff84 	movi	r2,-2
 2023ab4:	00009f06 	br	2023d34 <etharp_output+0x2d8>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 2023ab8:	e0bfff17 	ldw	r2,-4(fp)
 2023abc:	10800017 	ldw	r2,0(r2)
 2023ac0:	e17ffd17 	ldw	r5,-12(fp)
 2023ac4:	1009883a 	mov	r4,r2
 2023ac8:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2023acc:	10803fcc 	andi	r2,r2,255
 2023ad0:	10000326 	beq	r2,zero,2023ae0 <etharp_output+0x84>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 2023ad4:	d0a01384 	addi	r2,gp,-32690
 2023ad8:	e0bff915 	stw	r2,-28(fp)
 2023adc:	00008e06 	br	2023d18 <etharp_output+0x2bc>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 2023ae0:	e0bfff17 	ldw	r2,-4(fp)
 2023ae4:	10800017 	ldw	r2,0(r2)
 2023ae8:	10803c0c 	andi	r2,r2,240
 2023aec:	10803818 	cmpnei	r2,r2,224
 2023af0:	1000131e 	bne	r2,zero,2023b40 <etharp_output+0xe4>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 2023af4:	00800044 	movi	r2,1
 2023af8:	e0bffb85 	stb	r2,-18(fp)
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 2023afc:	e03ffbc5 	stb	zero,-17(fp)
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 2023b00:	00801784 	movi	r2,94
 2023b04:	e0bffc05 	stb	r2,-16(fp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 2023b08:	e0bfff17 	ldw	r2,-4(fp)
 2023b0c:	10800044 	addi	r2,r2,1
 2023b10:	10800003 	ldbu	r2,0(r2)
 2023b14:	10801fcc 	andi	r2,r2,127
 2023b18:	e0bffc45 	stb	r2,-15(fp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 2023b1c:	e0bfff17 	ldw	r2,-4(fp)
 2023b20:	10800083 	ldbu	r2,2(r2)
 2023b24:	e0bffc85 	stb	r2,-14(fp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 2023b28:	e0bfff17 	ldw	r2,-4(fp)
 2023b2c:	108000c3 	ldbu	r2,3(r2)
 2023b30:	e0bffcc5 	stb	r2,-13(fp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 2023b34:	e0bffb84 	addi	r2,fp,-18
 2023b38:	e0bff915 	stw	r2,-28(fp)
 2023b3c:	00007606 	br	2023d18 <etharp_output+0x2bc>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 2023b40:	e0bfff17 	ldw	r2,-4(fp)
 2023b44:	10c00017 	ldw	r3,0(r2)
 2023b48:	e0bffd17 	ldw	r2,-12(fp)
 2023b4c:	10800117 	ldw	r2,4(r2)
 2023b50:	1886f03a 	xor	r3,r3,r2
 2023b54:	e0bffd17 	ldw	r2,-12(fp)
 2023b58:	10800217 	ldw	r2,8(r2)
 2023b5c:	1884703a 	and	r2,r3,r2
 2023b60:	10001126 	beq	r2,zero,2023ba8 <etharp_output+0x14c>
        !ip_addr_islinklocal(ipaddr)) {
 2023b64:	e0bfff17 	ldw	r2,-4(fp)
 2023b68:	10800017 	ldw	r2,0(r2)
 2023b6c:	10ffffcc 	andi	r3,r2,65535
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 2023b70:	00bfaa54 	movui	r2,65193
 2023b74:	18800c26 	beq	r3,r2,2023ba8 <etharp_output+0x14c>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
 2023b78:	e0bffd17 	ldw	r2,-12(fp)
 2023b7c:	10800304 	addi	r2,r2,12
 2023b80:	10000726 	beq	r2,zero,2023ba0 <etharp_output+0x144>
 2023b84:	e0bffd17 	ldw	r2,-12(fp)
 2023b88:	10800317 	ldw	r2,12(r2)
 2023b8c:	10000426 	beq	r2,zero,2023ba0 <etharp_output+0x144>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
 2023b90:	e0bffd17 	ldw	r2,-12(fp)
 2023b94:	10800304 	addi	r2,r2,12
 2023b98:	e0bffa15 	stw	r2,-24(fp)
 2023b9c:	00000206 	br	2023ba8 <etharp_output+0x14c>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
 2023ba0:	00bfff04 	movi	r2,-4
 2023ba4:	00006306 	br	2023d34 <etharp_output+0x2d8>
        }
      }
    }
#if LWIP_NETIF_HWADDRHINT
    if (netif->addr_hint != NULL) {
 2023ba8:	e0bffd17 	ldw	r2,-12(fp)
 2023bac:	10801017 	ldw	r2,64(r2)
 2023bb0:	10002826 	beq	r2,zero,2023c54 <etharp_output+0x1f8>
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
 2023bb4:	e0bffd17 	ldw	r2,-12(fp)
 2023bb8:	10801017 	ldw	r2,64(r2)
 2023bbc:	10800003 	ldbu	r2,0(r2)
 2023bc0:	e0bffb45 	stb	r2,-19(fp)
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
 2023bc4:	e0bffb43 	ldbu	r2,-19(fp)
 2023bc8:	10800668 	cmpgeui	r2,r2,25
 2023bcc:	1000211e 	bne	r2,zero,2023c54 <etharp_output+0x1f8>
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 2023bd0:	e0fffb43 	ldbu	r3,-19(fp)
 2023bd4:	00808134 	movhi	r2,516
 2023bd8:	109ea704 	addi	r2,r2,31388
 2023bdc:	18c00524 	muli	r3,r3,20
 2023be0:	10c5883a 	add	r2,r2,r3
 2023be4:	10800484 	addi	r2,r2,18
 2023be8:	10800003 	ldbu	r2,0(r2)
 2023bec:	10803fcc 	andi	r2,r2,255
 2023bf0:	108000b0 	cmpltui	r2,r2,2
 2023bf4:	1000171e 	bne	r2,zero,2023c54 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
 2023bf8:	e0bffa17 	ldw	r2,-24(fp)
 2023bfc:	10c00017 	ldw	r3,0(r2)
 2023c00:	e13ffb43 	ldbu	r4,-19(fp)
 2023c04:	00808134 	movhi	r2,516
 2023c08:	109ea704 	addi	r2,r2,31388
 2023c0c:	21000524 	muli	r4,r4,20
 2023c10:	1105883a 	add	r2,r2,r4
 2023c14:	10800104 	addi	r2,r2,4
 2023c18:	10800017 	ldw	r2,0(r2)
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 2023c1c:	18800d1e 	bne	r3,r2,2023c54 <etharp_output+0x1f8>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
 2023c20:	008085f4 	movhi	r2,535
 2023c24:	10a8bc04 	addi	r2,r2,-23824
 2023c28:	10801717 	ldw	r2,92(r2)
 2023c2c:	10c00044 	addi	r3,r2,1
 2023c30:	008085f4 	movhi	r2,535
 2023c34:	10a8bc04 	addi	r2,r2,-23824
 2023c38:	10c01715 	stw	r3,92(r2)
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 2023c3c:	e0bffb43 	ldbu	r2,-19(fp)
 2023c40:	100d883a 	mov	r6,r2
 2023c44:	e17ffe17 	ldw	r5,-8(fp)
 2023c48:	e13ffd17 	ldw	r4,-12(fp)
 2023c4c:	20239500 	call	2023950 <etharp_output_to_arp_index>
 2023c50:	00003806 	br	2023d34 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 2023c54:	e03ffb05 	stb	zero,-20(fp)
 2023c58:	00002706 	br	2023cf8 <etharp_output+0x29c>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 2023c5c:	e0fffb07 	ldb	r3,-20(fp)
 2023c60:	00808134 	movhi	r2,516
 2023c64:	109ea704 	addi	r2,r2,31388
 2023c68:	18c00524 	muli	r3,r3,20
 2023c6c:	10c5883a 	add	r2,r2,r3
 2023c70:	10800484 	addi	r2,r2,18
 2023c74:	10800003 	ldbu	r2,0(r2)
 2023c78:	10803fcc 	andi	r2,r2,255
 2023c7c:	108000b0 	cmpltui	r2,r2,2
 2023c80:	10001a1e 	bne	r2,zero,2023cec <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
 2023c84:	e0bffa17 	ldw	r2,-24(fp)
 2023c88:	10c00017 	ldw	r3,0(r2)
 2023c8c:	e13ffb07 	ldb	r4,-20(fp)
 2023c90:	00808134 	movhi	r2,516
 2023c94:	109ea704 	addi	r2,r2,31388
 2023c98:	21000524 	muli	r4,r4,20
 2023c9c:	1105883a 	add	r2,r2,r4
 2023ca0:	10800104 	addi	r2,r2,4
 2023ca4:	10800017 	ldw	r2,0(r2)
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 2023ca8:	1880101e 	bne	r3,r2,2023cec <etharp_output+0x290>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 2023cac:	e0bffd17 	ldw	r2,-12(fp)
 2023cb0:	10000726 	beq	r2,zero,2023cd0 <etharp_output+0x274>
 2023cb4:	e0bffd17 	ldw	r2,-12(fp)
 2023cb8:	10801017 	ldw	r2,64(r2)
 2023cbc:	10000426 	beq	r2,zero,2023cd0 <etharp_output+0x274>
 2023cc0:	e0bffd17 	ldw	r2,-12(fp)
 2023cc4:	10801017 	ldw	r2,64(r2)
 2023cc8:	e0fffb03 	ldbu	r3,-20(fp)
 2023ccc:	10c00005 	stb	r3,0(r2)
        return etharp_output_to_arp_index(netif, q, i);
 2023cd0:	e0bffb03 	ldbu	r2,-20(fp)
 2023cd4:	10803fcc 	andi	r2,r2,255
 2023cd8:	100d883a 	mov	r6,r2
 2023cdc:	e17ffe17 	ldw	r5,-8(fp)
 2023ce0:	e13ffd17 	ldw	r4,-12(fp)
 2023ce4:	20239500 	call	2023950 <etharp_output_to_arp_index>
 2023ce8:	00001206 	br	2023d34 <etharp_output+0x2d8>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 2023cec:	e0bffb03 	ldbu	r2,-20(fp)
 2023cf0:	10800044 	addi	r2,r2,1
 2023cf4:	e0bffb05 	stb	r2,-20(fp)
 2023cf8:	e0bffb07 	ldb	r2,-20(fp)
 2023cfc:	10800650 	cmplti	r2,r2,25
 2023d00:	103fd61e 	bne	r2,zero,2023c5c <__alt_mem_mem_0+0xfd003c5c>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 2023d04:	e1bffe17 	ldw	r6,-8(fp)
 2023d08:	e17ffa17 	ldw	r5,-24(fp)
 2023d0c:	e13ffd17 	ldw	r4,-12(fp)
 2023d10:	2023d480 	call	2023d48 <etharp_query>
 2023d14:	00000706 	br	2023d34 <etharp_output+0x2d8>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 2023d18:	e0bffd17 	ldw	r2,-12(fp)
 2023d1c:	10800cc4 	addi	r2,r2,51
 2023d20:	e1fff917 	ldw	r7,-28(fp)
 2023d24:	100d883a 	mov	r6,r2
 2023d28:	e17ffe17 	ldw	r5,-8(fp)
 2023d2c:	e13ffd17 	ldw	r4,-12(fp)
 2023d30:	202310c0 	call	202310c <etharp_send_ip>
}
 2023d34:	e037883a 	mov	sp,fp
 2023d38:	dfc00117 	ldw	ra,4(sp)
 2023d3c:	df000017 	ldw	fp,0(sp)
 2023d40:	dec00204 	addi	sp,sp,8
 2023d44:	f800283a 	ret

02023d48 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 2023d48:	defff404 	addi	sp,sp,-48
 2023d4c:	dfc00b15 	stw	ra,44(sp)
 2023d50:	df000a15 	stw	fp,40(sp)
 2023d54:	df000a04 	addi	fp,sp,40
 2023d58:	e13ffd15 	stw	r4,-12(fp)
 2023d5c:	e17ffe15 	stw	r5,-8(fp)
 2023d60:	e1bfff15 	stw	r6,-4(fp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 2023d64:	e0bffd17 	ldw	r2,-12(fp)
 2023d68:	10800cc4 	addi	r2,r2,51
 2023d6c:	e0bffa15 	stw	r2,-24(fp)
  err_t result = ERR_MEM;
 2023d70:	00bfffc4 	movi	r2,-1
 2023d74:	e0bff605 	stb	r2,-40(fp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 2023d78:	e0bffe17 	ldw	r2,-8(fp)
 2023d7c:	10800017 	ldw	r2,0(r2)
 2023d80:	e17ffd17 	ldw	r5,-12(fp)
 2023d84:	1009883a 	mov	r4,r2
 2023d88:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2023d8c:	10803fcc 	andi	r2,r2,255
 2023d90:	10000a1e 	bne	r2,zero,2023dbc <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
 2023d94:	e0bffe17 	ldw	r2,-8(fp)
 2023d98:	10800017 	ldw	r2,0(r2)
 2023d9c:	10803c0c 	andi	r2,r2,240
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 2023da0:	10803820 	cmpeqi	r2,r2,224
 2023da4:	1000051e 	bne	r2,zero,2023dbc <etharp_query+0x74>
      ip_addr_ismulticast(ipaddr) ||
 2023da8:	e0bffe17 	ldw	r2,-8(fp)
 2023dac:	10000326 	beq	r2,zero,2023dbc <etharp_query+0x74>
      ip_addr_isany(ipaddr)) {
 2023db0:	e0bffe17 	ldw	r2,-8(fp)
 2023db4:	10800017 	ldw	r2,0(r2)
 2023db8:	1000021e 	bne	r2,zero,2023dc4 <etharp_query+0x7c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 2023dbc:	00bffc84 	movi	r2,-14
 2023dc0:	0000c906 	br	20240e8 <etharp_query+0x3a0>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 2023dc4:	01400044 	movi	r5,1
 2023dc8:	e13ffe17 	ldw	r4,-8(fp)
 2023dcc:	2022df40 	call	2022df4 <etharp_find_entry>
 2023dd0:	e0bffb05 	stb	r2,-20(fp)

  /* could not find or create entry? */
  if (i < 0) {
 2023dd4:	e0bffb07 	ldb	r2,-20(fp)
 2023dd8:	10000b0e 	bge	r2,zero,2023e08 <etharp_query+0xc0>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
 2023ddc:	e0bfff17 	ldw	r2,-4(fp)
 2023de0:	10000726 	beq	r2,zero,2023e00 <etharp_query+0xb8>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
 2023de4:	008085f4 	movhi	r2,535
 2023de8:	10a8bc04 	addi	r2,r2,-23824
 2023dec:	10801217 	ldw	r2,72(r2)
 2023df0:	10c00044 	addi	r3,r2,1
 2023df4:	008085f4 	movhi	r2,535
 2023df8:	10a8bc04 	addi	r2,r2,-23824
 2023dfc:	10c01215 	stw	r3,72(r2)
    }
    return (err_t)i;
 2023e00:	e0bffb03 	ldbu	r2,-20(fp)
 2023e04:	0000b806 	br	20240e8 <etharp_query+0x3a0>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 2023e08:	e0fffb07 	ldb	r3,-20(fp)
 2023e0c:	00808134 	movhi	r2,516
 2023e10:	109ea704 	addi	r2,r2,31388
 2023e14:	18c00524 	muli	r3,r3,20
 2023e18:	10c5883a 	add	r2,r2,r3
 2023e1c:	10800484 	addi	r2,r2,18
 2023e20:	10800003 	ldbu	r2,0(r2)
 2023e24:	10803fcc 	andi	r2,r2,255
 2023e28:	1000081e 	bne	r2,zero,2023e4c <etharp_query+0x104>
    arp_table[i].state = ETHARP_STATE_PENDING;
 2023e2c:	e0fffb07 	ldb	r3,-20(fp)
 2023e30:	00808134 	movhi	r2,516
 2023e34:	109ea704 	addi	r2,r2,31388
 2023e38:	18c00524 	muli	r3,r3,20
 2023e3c:	10c5883a 	add	r2,r2,r3
 2023e40:	10800484 	addi	r2,r2,18
 2023e44:	00c00044 	movi	r3,1
 2023e48:	10c00005 	stb	r3,0(r2)
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 2023e4c:	e0fffb07 	ldb	r3,-20(fp)
 2023e50:	00808134 	movhi	r2,516
 2023e54:	109ea704 	addi	r2,r2,31388
 2023e58:	18c00524 	muli	r3,r3,20
 2023e5c:	10c5883a 	add	r2,r2,r3
 2023e60:	10800484 	addi	r2,r2,18
 2023e64:	10800003 	ldbu	r2,0(r2)
 2023e68:	10803fcc 	andi	r2,r2,255
 2023e6c:	10800060 	cmpeqi	r2,r2,1
 2023e70:	1000021e 	bne	r2,zero,2023e7c <etharp_query+0x134>
 2023e74:	e0bfff17 	ldw	r2,-4(fp)
 2023e78:	1000081e 	bne	r2,zero,2023e9c <etharp_query+0x154>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
 2023e7c:	e17ffe17 	ldw	r5,-8(fp)
 2023e80:	e13ffd17 	ldw	r4,-12(fp)
 2023e84:	20243480 	call	2024348 <etharp_request>
 2023e88:	e0bff605 	stb	r2,-40(fp)
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 2023e8c:	e0bfff17 	ldw	r2,-4(fp)
 2023e90:	1000021e 	bne	r2,zero,2023e9c <etharp_query+0x154>
      return result;
 2023e94:	e0bff603 	ldbu	r2,-40(fp)
 2023e98:	00009306 	br	20240e8 <etharp_query+0x3a0>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 2023e9c:	e0fffb07 	ldb	r3,-20(fp)
 2023ea0:	00808134 	movhi	r2,516
 2023ea4:	109ea704 	addi	r2,r2,31388
 2023ea8:	18c00524 	muli	r3,r3,20
 2023eac:	10c5883a 	add	r2,r2,r3
 2023eb0:	10800484 	addi	r2,r2,18
 2023eb4:	10800003 	ldbu	r2,0(r2)
 2023eb8:	10803fcc 	andi	r2,r2,255
 2023ebc:	108000b0 	cmpltui	r2,r2,2
 2023ec0:	1000161e 	bne	r2,zero,2023f1c <etharp_query+0x1d4>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 2023ec4:	e0bffd17 	ldw	r2,-12(fp)
 2023ec8:	10000726 	beq	r2,zero,2023ee8 <etharp_query+0x1a0>
 2023ecc:	e0bffd17 	ldw	r2,-12(fp)
 2023ed0:	10801017 	ldw	r2,64(r2)
 2023ed4:	10000426 	beq	r2,zero,2023ee8 <etharp_query+0x1a0>
 2023ed8:	e0bffd17 	ldw	r2,-12(fp)
 2023edc:	10801017 	ldw	r2,64(r2)
 2023ee0:	e0fffb03 	ldbu	r3,-20(fp)
 2023ee4:	10c00005 	stb	r3,0(r2)
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 2023ee8:	e0bffb07 	ldb	r2,-20(fp)
 2023eec:	10800524 	muli	r2,r2,20
 2023ef0:	10c00304 	addi	r3,r2,12
 2023ef4:	00808134 	movhi	r2,516
 2023ef8:	109ea704 	addi	r2,r2,31388
 2023efc:	1885883a 	add	r2,r3,r2
 2023f00:	100f883a 	mov	r7,r2
 2023f04:	e1bffa17 	ldw	r6,-24(fp)
 2023f08:	e17fff17 	ldw	r5,-4(fp)
 2023f0c:	e13ffd17 	ldw	r4,-12(fp)
 2023f10:	202310c0 	call	202310c <etharp_send_ip>
 2023f14:	e0bff605 	stb	r2,-40(fp)
 2023f18:	00007206 	br	20240e4 <etharp_query+0x39c>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 2023f1c:	e0fffb07 	ldb	r3,-20(fp)
 2023f20:	00808134 	movhi	r2,516
 2023f24:	109ea704 	addi	r2,r2,31388
 2023f28:	18c00524 	muli	r3,r3,20
 2023f2c:	10c5883a 	add	r2,r2,r3
 2023f30:	10800484 	addi	r2,r2,18
 2023f34:	10800003 	ldbu	r2,0(r2)
 2023f38:	10803fcc 	andi	r2,r2,255
 2023f3c:	10800058 	cmpnei	r2,r2,1
 2023f40:	1000681e 	bne	r2,zero,20240e4 <etharp_query+0x39c>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
 2023f44:	e03ff815 	stw	zero,-32(fp)
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
 2023f48:	e0bfff17 	ldw	r2,-4(fp)
 2023f4c:	e0bff715 	stw	r2,-36(fp)
    while (p) {
 2023f50:	00000b06 	br	2023f80 <etharp_query+0x238>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 2023f54:	e0bff717 	ldw	r2,-36(fp)
 2023f58:	10800303 	ldbu	r2,12(r2)
 2023f5c:	10803fcc 	andi	r2,r2,255
 2023f60:	10800060 	cmpeqi	r2,r2,1
 2023f64:	1000031e 	bne	r2,zero,2023f74 <etharp_query+0x22c>
        copy_needed = 1;
 2023f68:	00800044 	movi	r2,1
 2023f6c:	e0bff815 	stw	r2,-32(fp)
        break;
 2023f70:	00000506 	br	2023f88 <etharp_query+0x240>
      }
      p = p->next;
 2023f74:	e0bff717 	ldw	r2,-36(fp)
 2023f78:	10800017 	ldw	r2,0(r2)
 2023f7c:	e0bff715 	stw	r2,-36(fp)
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
 2023f80:	e0bff717 	ldw	r2,-36(fp)
 2023f84:	103ff31e 	bne	r2,zero,2023f54 <__alt_mem_mem_0+0xfd003f54>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
 2023f88:	e0bff817 	ldw	r2,-32(fp)
 2023f8c:	10001526 	beq	r2,zero,2023fe4 <etharp_query+0x29c>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 2023f90:	e0bff717 	ldw	r2,-36(fp)
 2023f94:	1080020b 	ldhu	r2,8(r2)
 2023f98:	10bfffcc 	andi	r2,r2,65535
 2023f9c:	000d883a 	mov	r6,zero
 2023fa0:	100b883a 	mov	r5,r2
 2023fa4:	010000c4 	movi	r4,3
 2023fa8:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2023fac:	e0bff715 	stw	r2,-36(fp)
      if(p != NULL) {
 2023fb0:	e0bff717 	ldw	r2,-36(fp)
 2023fb4:	10000f26 	beq	r2,zero,2023ff4 <etharp_query+0x2ac>
        if (pbuf_copy(p, q) != ERR_OK) {
 2023fb8:	e17fff17 	ldw	r5,-4(fp)
 2023fbc:	e13ff717 	ldw	r4,-36(fp)
 2023fc0:	201af100 	call	201af10 <pbuf_copy>
 2023fc4:	10803fcc 	andi	r2,r2,255
 2023fc8:	1080201c 	xori	r2,r2,128
 2023fcc:	10bfe004 	addi	r2,r2,-128
 2023fd0:	10000826 	beq	r2,zero,2023ff4 <etharp_query+0x2ac>
          pbuf_free(p);
 2023fd4:	e13ff717 	ldw	r4,-36(fp)
 2023fd8:	201ab680 	call	201ab68 <pbuf_free>
          p = NULL;
 2023fdc:	e03ff715 	stw	zero,-36(fp)
 2023fe0:	00000406 	br	2023ff4 <etharp_query+0x2ac>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
 2023fe4:	e0bfff17 	ldw	r2,-4(fp)
 2023fe8:	e0bff715 	stw	r2,-36(fp)
      pbuf_ref(p);
 2023fec:	e13ff717 	ldw	r4,-36(fp)
 2023ff0:	201acf80 	call	201acf8 <pbuf_ref>
    }
    /* packet could be taken over? */
    if (p != NULL) {
 2023ff4:	e0bff717 	ldw	r2,-36(fp)
 2023ff8:	10003126 	beq	r2,zero,20240c0 <etharp_query+0x378>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
 2023ffc:	010002c4 	movi	r4,11
 2024000:	20344340 	call	2034434 <memp_malloc>
 2024004:	e0bffc15 	stw	r2,-16(fp)
      if (new_entry != NULL) {
 2024008:	e0bffc17 	ldw	r2,-16(fp)
 202400c:	10002726 	beq	r2,zero,20240ac <etharp_query+0x364>
        new_entry->next = 0;
 2024010:	e0bffc17 	ldw	r2,-16(fp)
 2024014:	10000015 	stw	zero,0(r2)
        new_entry->p = p;
 2024018:	e0bffc17 	ldw	r2,-16(fp)
 202401c:	e0fff717 	ldw	r3,-36(fp)
 2024020:	10c00115 	stw	r3,4(r2)
        if(arp_table[i].q != NULL) {
 2024024:	e0fffb07 	ldb	r3,-20(fp)
 2024028:	00808134 	movhi	r2,516
 202402c:	109ea704 	addi	r2,r2,31388
 2024030:	18c00524 	muli	r3,r3,20
 2024034:	10c5883a 	add	r2,r2,r3
 2024038:	10800017 	ldw	r2,0(r2)
 202403c:	10001226 	beq	r2,zero,2024088 <etharp_query+0x340>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
 2024040:	e0fffb07 	ldb	r3,-20(fp)
 2024044:	00808134 	movhi	r2,516
 2024048:	109ea704 	addi	r2,r2,31388
 202404c:	18c00524 	muli	r3,r3,20
 2024050:	10c5883a 	add	r2,r2,r3
 2024054:	10800017 	ldw	r2,0(r2)
 2024058:	e0bff915 	stw	r2,-28(fp)
          while (r->next != NULL) {
 202405c:	00000306 	br	202406c <etharp_query+0x324>
            r = r->next;
 2024060:	e0bff917 	ldw	r2,-28(fp)
 2024064:	10800017 	ldw	r2,0(r2)
 2024068:	e0bff915 	stw	r2,-28(fp)
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
 202406c:	e0bff917 	ldw	r2,-28(fp)
 2024070:	10800017 	ldw	r2,0(r2)
 2024074:	103ffa1e 	bne	r2,zero,2024060 <__alt_mem_mem_0+0xfd004060>
            r = r->next;
          }
          r->next = new_entry;
 2024078:	e0bff917 	ldw	r2,-28(fp)
 202407c:	e0fffc17 	ldw	r3,-16(fp)
 2024080:	10c00015 	stw	r3,0(r2)
 2024084:	00000706 	br	20240a4 <etharp_query+0x35c>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
 2024088:	e0fffb07 	ldb	r3,-20(fp)
 202408c:	00808134 	movhi	r2,516
 2024090:	109ea704 	addi	r2,r2,31388
 2024094:	18c00524 	muli	r3,r3,20
 2024098:	10c5883a 	add	r2,r2,r3
 202409c:	e0fffc17 	ldw	r3,-16(fp)
 20240a0:	10c00015 	stw	r3,0(r2)
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
 20240a4:	e03ff605 	stb	zero,-40(fp)
 20240a8:	00000e06 	br	20240e4 <etharp_query+0x39c>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
 20240ac:	e13ff717 	ldw	r4,-36(fp)
 20240b0:	201ab680 	call	201ab68 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
 20240b4:	00bfffc4 	movi	r2,-1
 20240b8:	e0bff605 	stb	r2,-40(fp)
 20240bc:	00000906 	br	20240e4 <etharp_query+0x39c>
      arp_table[i].q = p;
      result = ERR_OK;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
 20240c0:	008085f4 	movhi	r2,535
 20240c4:	10a8bc04 	addi	r2,r2,-23824
 20240c8:	10801217 	ldw	r2,72(r2)
 20240cc:	10c00044 	addi	r3,r2,1
 20240d0:	008085f4 	movhi	r2,535
 20240d4:	10a8bc04 	addi	r2,r2,-23824
 20240d8:	10c01215 	stw	r3,72(r2)
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 20240dc:	00bfffc4 	movi	r2,-1
 20240e0:	e0bff605 	stb	r2,-40(fp)
    }
  }
  return result;
 20240e4:	e0bff603 	ldbu	r2,-40(fp)
}
 20240e8:	e037883a 	mov	sp,fp
 20240ec:	dfc00117 	ldw	ra,4(sp)
 20240f0:	df000017 	ldw	fp,0(sp)
 20240f4:	dec00204 	addi	sp,sp,8
 20240f8:	f800283a 	ret

020240fc <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
 20240fc:	defff504 	addi	sp,sp,-44
 2024100:	dfc00a15 	stw	ra,40(sp)
 2024104:	df000915 	stw	fp,36(sp)
 2024108:	df000904 	addi	fp,sp,36
 202410c:	e13ffb15 	stw	r4,-20(fp)
 2024110:	e17ffc15 	stw	r5,-16(fp)
 2024114:	e1bffd15 	stw	r6,-12(fp)
 2024118:	e1fffe15 	stw	r7,-8(fp)
 202411c:	e0800517 	ldw	r2,20(fp)
 2024120:	e0bfff0d 	sth	r2,-4(fp)
  struct pbuf *p;
  err_t result = ERR_OK;
 2024124:	e03ff705 	stb	zero,-36(fp)
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 2024128:	000d883a 	mov	r6,zero
 202412c:	01400b04 	movi	r5,44
 2024130:	010000c4 	movi	r4,3
 2024134:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2024138:	e0bff815 	stw	r2,-32(fp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 202413c:	e0bff817 	ldw	r2,-32(fp)
 2024140:	1000091e 	bne	r2,zero,2024168 <etharp_raw+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
 2024144:	008085f4 	movhi	r2,535
 2024148:	10a8bc04 	addi	r2,r2,-23824
 202414c:	10801217 	ldw	r2,72(r2)
 2024150:	10c00044 	addi	r3,r2,1
 2024154:	008085f4 	movhi	r2,535
 2024158:	10a8bc04 	addi	r2,r2,-23824
 202415c:	10c01215 	stw	r3,72(r2)
    return ERR_MEM;
 2024160:	00bfffc4 	movi	r2,-1
 2024164:	00007306 	br	2024334 <etharp_raw+0x238>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 2024168:	e0bff817 	ldw	r2,-32(fp)
 202416c:	10800117 	ldw	r2,4(r2)
 2024170:	e0bff915 	stw	r2,-28(fp)
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
 2024174:	e0bff917 	ldw	r2,-28(fp)
 2024178:	10800404 	addi	r2,r2,16
 202417c:	e0bffa15 	stw	r2,-24(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 2024180:	e0bfff0b 	ldhu	r2,-4(fp)
 2024184:	1004d23a 	srli	r2,r2,8
 2024188:	1007883a 	mov	r3,r2
 202418c:	e0bfff0b 	ldhu	r2,-4(fp)
 2024190:	1004923a 	slli	r2,r2,8
 2024194:	1884b03a 	or	r2,r3,r2
 2024198:	100d883a 	mov	r6,r2
 202419c:	e0bffa17 	ldw	r2,-24(fp)
 20241a0:	30ffffcc 	andi	r3,r6,65535
 20241a4:	19403fcc 	andi	r5,r3,255
 20241a8:	10c00183 	ldbu	r3,6(r2)
 20241ac:	1806703a 	and	r3,r3,zero
 20241b0:	1809883a 	mov	r4,r3
 20241b4:	2807883a 	mov	r3,r5
 20241b8:	20c6b03a 	or	r3,r4,r3
 20241bc:	10c00185 	stb	r3,6(r2)
 20241c0:	30ffffcc 	andi	r3,r6,65535
 20241c4:	1806d23a 	srli	r3,r3,8
 20241c8:	197fffcc 	andi	r5,r3,65535
 20241cc:	10c001c3 	ldbu	r3,7(r2)
 20241d0:	1806703a 	and	r3,r3,zero
 20241d4:	1809883a 	mov	r4,r3
 20241d8:	2807883a 	mov	r3,r5
 20241dc:	20c6b03a 	or	r3,r4,r3
 20241e0:	10c001c5 	stb	r3,7(r2)
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 20241e4:	e0bffa17 	ldw	r2,-24(fp)
 20241e8:	10800204 	addi	r2,r2,8
 20241ec:	01800184 	movi	r6,6
 20241f0:	e17ffe17 	ldw	r5,-8(fp)
 20241f4:	1009883a 	mov	r4,r2
 20241f8:	20060240 	call	2006024 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 20241fc:	e0bffa17 	ldw	r2,-24(fp)
 2024200:	10800484 	addi	r2,r2,18
 2024204:	01800184 	movi	r6,6
 2024208:	e1400317 	ldw	r5,12(fp)
 202420c:	1009883a 	mov	r4,r2
 2024210:	20060240 	call	2006024 <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 2024214:	e0bff917 	ldw	r2,-28(fp)
 2024218:	10800084 	addi	r2,r2,2
 202421c:	01800184 	movi	r6,6
 2024220:	e17ffd17 	ldw	r5,-12(fp)
 2024224:	1009883a 	mov	r4,r2
 2024228:	20060240 	call	2006024 <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 202422c:	e0bff917 	ldw	r2,-28(fp)
 2024230:	10800204 	addi	r2,r2,8
 2024234:	01800184 	movi	r6,6
 2024238:	e17ffc17 	ldw	r5,-16(fp)
 202423c:	1009883a 	mov	r4,r2
 2024240:	20060240 	call	2006024 <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 2024244:	e0bffa17 	ldw	r2,-24(fp)
 2024248:	10800384 	addi	r2,r2,14
 202424c:	01800104 	movi	r6,4
 2024250:	e1400217 	ldw	r5,8(fp)
 2024254:	1009883a 	mov	r4,r2
 2024258:	20060240 	call	2006024 <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 202425c:	e0bffa17 	ldw	r2,-24(fp)
 2024260:	10800604 	addi	r2,r2,24
 2024264:	01800104 	movi	r6,4
 2024268:	e1400417 	ldw	r5,16(fp)
 202426c:	1009883a 	mov	r4,r2
 2024270:	20060240 	call	2006024 <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 2024274:	e0bffa17 	ldw	r2,-24(fp)
 2024278:	10c00003 	ldbu	r3,0(r2)
 202427c:	1806703a 	and	r3,r3,zero
 2024280:	10c00005 	stb	r3,0(r2)
 2024284:	10c00043 	ldbu	r3,1(r2)
 2024288:	1806703a 	and	r3,r3,zero
 202428c:	18c00054 	ori	r3,r3,1
 2024290:	10c00045 	stb	r3,1(r2)
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 2024294:	e0bffa17 	ldw	r2,-24(fp)
 2024298:	10c00083 	ldbu	r3,2(r2)
 202429c:	1806703a 	and	r3,r3,zero
 20242a0:	18c00214 	ori	r3,r3,8
 20242a4:	10c00085 	stb	r3,2(r2)
 20242a8:	10c000c3 	ldbu	r3,3(r2)
 20242ac:	1806703a 	and	r3,r3,zero
 20242b0:	10c000c5 	stb	r3,3(r2)
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 20242b4:	e0bffa17 	ldw	r2,-24(fp)
 20242b8:	00c00184 	movi	r3,6
 20242bc:	10c00105 	stb	r3,4(r2)
  hdr->protolen = sizeof(ip_addr_t);
 20242c0:	e0bffa17 	ldw	r2,-24(fp)
 20242c4:	00c00104 	movi	r3,4
 20242c8:	10c00145 	stb	r3,5(r2)

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 20242cc:	e0bff917 	ldw	r2,-28(fp)
 20242d0:	10c00383 	ldbu	r3,14(r2)
 20242d4:	1806703a 	and	r3,r3,zero
 20242d8:	18c00214 	ori	r3,r3,8
 20242dc:	10c00385 	stb	r3,14(r2)
 20242e0:	10c003c3 	ldbu	r3,15(r2)
 20242e4:	1806703a 	and	r3,r3,zero
 20242e8:	18c00194 	ori	r3,r3,6
 20242ec:	10c003c5 	stb	r3,15(r2)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 20242f0:	e0bffb17 	ldw	r2,-20(fp)
 20242f4:	10800617 	ldw	r2,24(r2)
 20242f8:	e17ff817 	ldw	r5,-32(fp)
 20242fc:	e13ffb17 	ldw	r4,-20(fp)
 2024300:	103ee83a 	callr	r2
 2024304:	e0bff705 	stb	r2,-36(fp)
  ETHARP_STATS_INC(etharp.xmit);
 2024308:	008085f4 	movhi	r2,535
 202430c:	10a8bc04 	addi	r2,r2,-23824
 2024310:	10800c17 	ldw	r2,48(r2)
 2024314:	10c00044 	addi	r3,r2,1
 2024318:	008085f4 	movhi	r2,535
 202431c:	10a8bc04 	addi	r2,r2,-23824
 2024320:	10c00c15 	stw	r3,48(r2)
  /* free ARP query packet */
  pbuf_free(p);
 2024324:	e13ff817 	ldw	r4,-32(fp)
 2024328:	201ab680 	call	201ab68 <pbuf_free>
  p = NULL;
 202432c:	e03ff815 	stw	zero,-32(fp)
  /* could not allocate pbuf for ARP request */

  return result;
 2024330:	e0bff703 	ldbu	r2,-36(fp)
}
 2024334:	e037883a 	mov	sp,fp
 2024338:	dfc00117 	ldw	ra,4(sp)
 202433c:	df000017 	ldw	fp,0(sp)
 2024340:	dec00204 	addi	sp,sp,8
 2024344:	f800283a 	ret

02024348 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 2024348:	defff804 	addi	sp,sp,-32
 202434c:	dfc00715 	stw	ra,28(sp)
 2024350:	df000615 	stw	fp,24(sp)
 2024354:	df000604 	addi	fp,sp,24
 2024358:	e13ffe15 	stw	r4,-8(fp)
 202435c:	e17fff15 	stw	r5,-4(fp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 2024360:	e0bffe17 	ldw	r2,-8(fp)
 2024364:	11000cc4 	addi	r4,r2,51
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 2024368:	e0bffe17 	ldw	r2,-8(fp)
 202436c:	11400cc4 	addi	r5,r2,51
 2024370:	e0bffe17 	ldw	r2,-8(fp)
 2024374:	10800104 	addi	r2,r2,4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 2024378:	00c00044 	movi	r3,1
 202437c:	d8c00315 	stw	r3,12(sp)
 2024380:	e0ffff17 	ldw	r3,-4(fp)
 2024384:	d8c00215 	stw	r3,8(sp)
 2024388:	d0e01504 	addi	r3,gp,-32684
 202438c:	d8c00115 	stw	r3,4(sp)
 2024390:	d8800015 	stw	r2,0(sp)
 2024394:	280f883a 	mov	r7,r5
 2024398:	d1a01384 	addi	r6,gp,-32690
 202439c:	200b883a 	mov	r5,r4
 20243a0:	e13ffe17 	ldw	r4,-8(fp)
 20243a4:	20240fc0 	call	20240fc <etharp_raw>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 20243a8:	e037883a 	mov	sp,fp
 20243ac:	dfc00117 	ldw	ra,4(sp)
 20243b0:	df000017 	ldw	fp,0(sp)
 20243b4:	dec00204 	addi	sp,sp,8
 20243b8:	f800283a 	ret

020243bc <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 20243bc:	defff904 	addi	sp,sp,-28
 20243c0:	dfc00615 	stw	ra,24(sp)
 20243c4:	df000515 	stw	fp,20(sp)
 20243c8:	df000504 	addi	fp,sp,20
 20243cc:	e13ffe15 	stw	r4,-8(fp)
 20243d0:	e17fff15 	stw	r5,-4(fp)
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
 20243d4:	00800404 	movi	r2,16
 20243d8:	e0bffb0d 	sth	r2,-20(fp)
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 20243dc:	e0bffe17 	ldw	r2,-8(fp)
 20243e0:	1080028b 	ldhu	r2,10(r2)
 20243e4:	10bfffcc 	andi	r2,r2,65535
 20243e8:	10800468 	cmpgeui	r2,r2,17
 20243ec:	10000f1e 	bne	r2,zero,202442c <ethernet_input+0x70>
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
 20243f0:	008085f4 	movhi	r2,535
 20243f4:	10a8bc04 	addi	r2,r2,-23824
 20243f8:	10801417 	ldw	r2,80(r2)
 20243fc:	10c00044 	addi	r3,r2,1
 2024400:	008085f4 	movhi	r2,535
 2024404:	10a8bc04 	addi	r2,r2,-23824
 2024408:	10c01415 	stw	r3,80(r2)
    ETHARP_STATS_INC(etharp.drop);
 202440c:	008085f4 	movhi	r2,535
 2024410:	10a8bc04 	addi	r2,r2,-23824
 2024414:	10800f17 	ldw	r2,60(r2)
 2024418:	10c00044 	addi	r3,r2,1
 202441c:	008085f4 	movhi	r2,535
 2024420:	10a8bc04 	addi	r2,r2,-23824
 2024424:	10c00f15 	stw	r3,60(r2)
    goto free_and_return;
 2024428:	00006e06 	br	20245e4 <ethernet_input+0x228>
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 202442c:	e0bffe17 	ldw	r2,-8(fp)
 2024430:	10800117 	ldw	r2,4(r2)
 2024434:	e0bffc15 	stw	r2,-16(fp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
 2024438:	e0bffc17 	ldw	r2,-16(fp)
 202443c:	10c00383 	ldbu	r3,14(r2)
 2024440:	108003c3 	ldbu	r2,15(r2)
 2024444:	1004923a 	slli	r2,r2,8
 2024448:	10c4b03a 	or	r2,r2,r3
 202444c:	e0bffd0d 	sth	r2,-12(fp)

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 2024450:	e0bffc17 	ldw	r2,-16(fp)
 2024454:	10800083 	ldbu	r2,2(r2)
 2024458:	10803fcc 	andi	r2,r2,255
 202445c:	1080004c 	andi	r2,r2,1
 2024460:	10002226 	beq	r2,zero,20244ec <ethernet_input+0x130>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 2024464:	e0bffc17 	ldw	r2,-16(fp)
 2024468:	10800083 	ldbu	r2,2(r2)
 202446c:	10803fcc 	andi	r2,r2,255
 2024470:	10800058 	cmpnei	r2,r2,1
 2024474:	1000101e 	bne	r2,zero,20244b8 <ethernet_input+0xfc>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2024478:	e0bffc17 	ldw	r2,-16(fp)
 202447c:	108000c3 	ldbu	r2,3(r2)
 2024480:	10803fcc 	andi	r2,r2,255
 2024484:	1000191e 	bne	r2,zero,20244ec <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
 2024488:	e0bffc17 	ldw	r2,-16(fp)
 202448c:	10800103 	ldbu	r2,4(r2)
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 2024490:	10803fcc 	andi	r2,r2,255
 2024494:	10801798 	cmpnei	r2,r2,94
 2024498:	1000141e 	bne	r2,zero,20244ec <ethernet_input+0x130>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 202449c:	e0bffe17 	ldw	r2,-8(fp)
 20244a0:	10800343 	ldbu	r2,13(r2)
 20244a4:	10800414 	ori	r2,r2,16
 20244a8:	1007883a 	mov	r3,r2
 20244ac:	e0bffe17 	ldw	r2,-8(fp)
 20244b0:	10c00345 	stb	r3,13(r2)
 20244b4:	00000d06 	br	20244ec <ethernet_input+0x130>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 20244b8:	e0bffc17 	ldw	r2,-16(fp)
 20244bc:	10800084 	addi	r2,r2,2
 20244c0:	01800184 	movi	r6,6
 20244c4:	d1601384 	addi	r5,gp,-32690
 20244c8:	1009883a 	mov	r4,r2
 20244cc:	203cc100 	call	203cc10 <memcmp>
 20244d0:	1000061e 	bne	r2,zero,20244ec <ethernet_input+0x130>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 20244d4:	e0bffe17 	ldw	r2,-8(fp)
 20244d8:	10800343 	ldbu	r2,13(r2)
 20244dc:	10800214 	ori	r2,r2,8
 20244e0:	1007883a 	mov	r3,r2
 20244e4:	e0bffe17 	ldw	r2,-8(fp)
 20244e8:	10c00345 	stb	r3,13(r2)
    }
  }

  switch (type) {
 20244ec:	e0bffd0b 	ldhu	r2,-12(fp)
 20244f0:	10c00220 	cmpeqi	r3,r2,8
 20244f4:	1800031e 	bne	r3,zero,2024504 <ethernet_input+0x148>
 20244f8:	10818220 	cmpeqi	r2,r2,1544
 20244fc:	1000171e 	bne	r2,zero,202455c <ethernet_input+0x1a0>
 2024500:	00002206 	br	202458c <ethernet_input+0x1d0>
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 2024504:	e0bfff17 	ldw	r2,-4(fp)
 2024508:	10800e43 	ldbu	r2,57(r2)
 202450c:	10803fcc 	andi	r2,r2,255
 2024510:	1080080c 	andi	r2,r2,32
 2024514:	10002e26 	beq	r2,zero,20245d0 <ethernet_input+0x214>
        goto free_and_return;
      }
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
 2024518:	e17ffe17 	ldw	r5,-8(fp)
 202451c:	e13fff17 	ldw	r4,-4(fp)
 2024520:	20234dc0 	call	20234dc <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
 2024524:	e0bffb0b 	ldhu	r2,-20(fp)
 2024528:	0085c83a 	sub	r2,zero,r2
 202452c:	10bfffcc 	andi	r2,r2,65535
 2024530:	10a0001c 	xori	r2,r2,32768
 2024534:	10a00004 	addi	r2,r2,-32768
 2024538:	100b883a 	mov	r5,r2
 202453c:	e13ffe17 	ldw	r4,-8(fp)
 2024540:	201a9b80 	call	201a9b8 <pbuf_header>
 2024544:	10803fcc 	andi	r2,r2,255
 2024548:	1000231e 	bne	r2,zero,20245d8 <ethernet_input+0x21c>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 202454c:	e17fff17 	ldw	r5,-4(fp)
 2024550:	e13ffe17 	ldw	r4,-8(fp)
 2024554:	2031e0c0 	call	2031e0c <ip_input>
      }
      break;
 2024558:	00001b06 	br	20245c8 <ethernet_input+0x20c>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 202455c:	e0bfff17 	ldw	r2,-4(fp)
 2024560:	10800e43 	ldbu	r2,57(r2)
 2024564:	10803fcc 	andi	r2,r2,255
 2024568:	1080080c 	andi	r2,r2,32
 202456c:	10001c26 	beq	r2,zero,20245e0 <ethernet_input+0x224>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 2024570:	e0bfff17 	ldw	r2,-4(fp)
 2024574:	10800cc4 	addi	r2,r2,51
 2024578:	e1bffe17 	ldw	r6,-8(fp)
 202457c:	100b883a 	mov	r5,r2
 2024580:	e13fff17 	ldw	r4,-4(fp)
 2024584:	20235c40 	call	20235c4 <etharp_arp_input>
      break;
 2024588:	00000f06 	br	20245c8 <ethernet_input+0x20c>
      pppoe_data_input(netif, p);
      break;
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
 202458c:	008085f4 	movhi	r2,535
 2024590:	10a8bc04 	addi	r2,r2,-23824
 2024594:	10801417 	ldw	r2,80(r2)
 2024598:	10c00044 	addi	r3,r2,1
 202459c:	008085f4 	movhi	r2,535
 20245a0:	10a8bc04 	addi	r2,r2,-23824
 20245a4:	10c01415 	stw	r3,80(r2)
      ETHARP_STATS_INC(etharp.drop);
 20245a8:	008085f4 	movhi	r2,535
 20245ac:	10a8bc04 	addi	r2,r2,-23824
 20245b0:	10800f17 	ldw	r2,60(r2)
 20245b4:	10c00044 	addi	r3,r2,1
 20245b8:	008085f4 	movhi	r2,535
 20245bc:	10a8bc04 	addi	r2,r2,-23824
 20245c0:	10c00f15 	stw	r3,60(r2)
      goto free_and_return;
 20245c4:	00000706 	br	20245e4 <ethernet_input+0x228>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
 20245c8:	0005883a 	mov	r2,zero
 20245cc:	00000806 	br	20245f0 <ethernet_input+0x234>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 20245d0:	0001883a 	nop
 20245d4:	00000306 	br	20245e4 <ethernet_input+0x228>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
 20245d8:	0001883a 	nop
 20245dc:	00000106 	br	20245e4 <ethernet_input+0x228>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
 20245e0:	0001883a 	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 20245e4:	e13ffe17 	ldw	r4,-8(fp)
 20245e8:	201ab680 	call	201ab68 <pbuf_free>
  return ERR_OK;
 20245ec:	0005883a 	mov	r2,zero
}
 20245f0:	e037883a 	mov	sp,fp
 20245f4:	dfc00117 	ldw	ra,4(sp)
 20245f8:	df000017 	ldw	fp,0(sp)
 20245fc:	dec00204 	addi	sp,sp,8
 2024600:	f800283a 	ret

02024604 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 2024604:	defffd04 	addi	sp,sp,-12
 2024608:	dfc00215 	stw	ra,8(sp)
 202460c:	df000115 	stw	fp,4(sp)
 2024610:	df000104 	addi	fp,sp,4
 2024614:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 2024618:	d1600804 	addi	r5,gp,-32736
 202461c:	e13fff17 	ldw	r4,-4(fp)
 2024620:	202c6600 	call	202c660 <alt_dev_llist_insert>
}
 2024624:	e037883a 	mov	sp,fp
 2024628:	dfc00117 	ldw	ra,4(sp)
 202462c:	df000017 	ldw	fp,0(sp)
 2024630:	dec00204 	addi	sp,sp,8
 2024634:	f800283a 	ret

02024638 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 2024638:	defffd04 	addi	sp,sp,-12
 202463c:	dfc00215 	stw	ra,8(sp)
 2024640:	df000115 	stw	fp,4(sp)
 2024644:	df000104 	addi	fp,sp,4
 2024648:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( CPU_0, cpu_0);
 202464c:	202d2b40 	call	202d2b4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 2024650:	00800044 	movi	r2,1
 2024654:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 2024658:	0001883a 	nop
 202465c:	e037883a 	mov	sp,fp
 2024660:	dfc00117 	ldw	ra,4(sp)
 2024664:	df000017 	ldw	fp,0(sp)
 2024668:	dec00204 	addi	sp,sp,8
 202466c:	f800283a 	ret

02024670 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 2024670:	defffe04 	addi	sp,sp,-8
 2024674:	dfc00115 	stw	ra,4(sp)
 2024678:	df000015 	stw	fp,0(sp)
 202467c:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
 2024680:	01c0fa04 	movi	r7,1000
 2024684:	018000c4 	movi	r6,3
 2024688:	000b883a 	mov	r5,zero
 202468c:	01014134 	movhi	r4,1284
 2024690:	21040804 	addi	r4,r4,4128
 2024694:	20260900 	call	2026090 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
 2024698:	01800084 	movi	r6,2
 202469c:	000b883a 	mov	r5,zero
 20246a0:	01008134 	movhi	r4,516
 20246a4:	21115104 	addi	r4,r4,17732
 20246a8:	20248800 	call	2024880 <altera_avalon_jtag_uart_init>
 20246ac:	01008134 	movhi	r4,516
 20246b0:	21114704 	addi	r4,r4,17692
 20246b4:	20246040 	call	2024604 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_RX_0, sgdma_tse_rx_0);
 20246b8:	000d883a 	mov	r6,zero
 20246bc:	000b883a 	mov	r5,zero
 20246c0:	01008134 	movhi	r4,516
 20246c4:	21156104 	addi	r4,r4,21892
 20246c8:	2025f700 	call	2025f70 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TSE_TX_0, sgdma_tse_tx_0);
 20246cc:	01800044 	movi	r6,1
 20246d0:	000b883a 	mov	r5,zero
 20246d4:	01008134 	movhi	r4,516
 20246d8:	21156d04 	addi	r4,r4,21940
 20246dc:	2025f700 	call	2025f70 <alt_avalon_sgdma_init>
    ALTERA_AVALON_UART_INIT ( UART_0, uart_0);
 20246e0:	01800104 	movi	r6,4
 20246e4:	000b883a 	mov	r5,zero
 20246e8:	01008134 	movhi	r4,516
 20246ec:	21158304 	addi	r4,r4,22028
 20246f0:	202b1f80 	call	202b1f8 <altera_avalon_uart_init>
 20246f4:	01008134 	movhi	r4,516
 20246f8:	21157904 	addi	r4,r4,21988
 20246fc:	20246040 	call	2024604 <alt_dev_reg>
    ALTERA_ETH_TSE_INIT ( TSE_MAC_0, tse_mac_0);
 2024700:	0001883a 	nop
}
 2024704:	0001883a 	nop
 2024708:	e037883a 	mov	sp,fp
 202470c:	dfc00117 	ldw	ra,4(sp)
 2024710:	df000017 	ldw	fp,0(sp)
 2024714:	dec00204 	addi	sp,sp,8
 2024718:	f800283a 	ret

0202471c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 202471c:	defffa04 	addi	sp,sp,-24
 2024720:	dfc00515 	stw	ra,20(sp)
 2024724:	df000415 	stw	fp,16(sp)
 2024728:	df000404 	addi	fp,sp,16
 202472c:	e13ffd15 	stw	r4,-12(fp)
 2024730:	e17ffe15 	stw	r5,-8(fp)
 2024734:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 2024738:	e0bffd17 	ldw	r2,-12(fp)
 202473c:	10800017 	ldw	r2,0(r2)
 2024740:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 2024744:	e0bffc17 	ldw	r2,-16(fp)
 2024748:	10c00a04 	addi	r3,r2,40
 202474c:	e0bffd17 	ldw	r2,-12(fp)
 2024750:	10800217 	ldw	r2,8(r2)
 2024754:	100f883a 	mov	r7,r2
 2024758:	e1bfff17 	ldw	r6,-4(fp)
 202475c:	e17ffe17 	ldw	r5,-8(fp)
 2024760:	1809883a 	mov	r4,r3
 2024764:	2024dcc0 	call	2024dcc <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 2024768:	e037883a 	mov	sp,fp
 202476c:	dfc00117 	ldw	ra,4(sp)
 2024770:	df000017 	ldw	fp,0(sp)
 2024774:	dec00204 	addi	sp,sp,8
 2024778:	f800283a 	ret

0202477c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 202477c:	defffa04 	addi	sp,sp,-24
 2024780:	dfc00515 	stw	ra,20(sp)
 2024784:	df000415 	stw	fp,16(sp)
 2024788:	df000404 	addi	fp,sp,16
 202478c:	e13ffd15 	stw	r4,-12(fp)
 2024790:	e17ffe15 	stw	r5,-8(fp)
 2024794:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 2024798:	e0bffd17 	ldw	r2,-12(fp)
 202479c:	10800017 	ldw	r2,0(r2)
 20247a0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 20247a4:	e0bffc17 	ldw	r2,-16(fp)
 20247a8:	10c00a04 	addi	r3,r2,40
 20247ac:	e0bffd17 	ldw	r2,-12(fp)
 20247b0:	10800217 	ldw	r2,8(r2)
 20247b4:	100f883a 	mov	r7,r2
 20247b8:	e1bfff17 	ldw	r6,-4(fp)
 20247bc:	e17ffe17 	ldw	r5,-8(fp)
 20247c0:	1809883a 	mov	r4,r3
 20247c4:	20250240 	call	2025024 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 20247c8:	e037883a 	mov	sp,fp
 20247cc:	dfc00117 	ldw	ra,4(sp)
 20247d0:	df000017 	ldw	fp,0(sp)
 20247d4:	dec00204 	addi	sp,sp,8
 20247d8:	f800283a 	ret

020247dc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 20247dc:	defffc04 	addi	sp,sp,-16
 20247e0:	dfc00315 	stw	ra,12(sp)
 20247e4:	df000215 	stw	fp,8(sp)
 20247e8:	df000204 	addi	fp,sp,8
 20247ec:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 20247f0:	e0bfff17 	ldw	r2,-4(fp)
 20247f4:	10800017 	ldw	r2,0(r2)
 20247f8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 20247fc:	e0bffe17 	ldw	r2,-8(fp)
 2024800:	10c00a04 	addi	r3,r2,40
 2024804:	e0bfff17 	ldw	r2,-4(fp)
 2024808:	10800217 	ldw	r2,8(r2)
 202480c:	100b883a 	mov	r5,r2
 2024810:	1809883a 	mov	r4,r3
 2024814:	2024c740 	call	2024c74 <altera_avalon_jtag_uart_close>
}
 2024818:	e037883a 	mov	sp,fp
 202481c:	dfc00117 	ldw	ra,4(sp)
 2024820:	df000017 	ldw	fp,0(sp)
 2024824:	dec00204 	addi	sp,sp,8
 2024828:	f800283a 	ret

0202482c <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 202482c:	defffa04 	addi	sp,sp,-24
 2024830:	dfc00515 	stw	ra,20(sp)
 2024834:	df000415 	stw	fp,16(sp)
 2024838:	df000404 	addi	fp,sp,16
 202483c:	e13ffd15 	stw	r4,-12(fp)
 2024840:	e17ffe15 	stw	r5,-8(fp)
 2024844:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 2024848:	e0bffd17 	ldw	r2,-12(fp)
 202484c:	10800017 	ldw	r2,0(r2)
 2024850:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 2024854:	e0bffc17 	ldw	r2,-16(fp)
 2024858:	10800a04 	addi	r2,r2,40
 202485c:	e1bfff17 	ldw	r6,-4(fp)
 2024860:	e17ffe17 	ldw	r5,-8(fp)
 2024864:	1009883a 	mov	r4,r2
 2024868:	2024cdc0 	call	2024cdc <altera_avalon_jtag_uart_ioctl>
}
 202486c:	e037883a 	mov	sp,fp
 2024870:	dfc00117 	ldw	ra,4(sp)
 2024874:	df000017 	ldw	fp,0(sp)
 2024878:	dec00204 	addi	sp,sp,8
 202487c:	f800283a 	ret

02024880 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 2024880:	defff304 	addi	sp,sp,-52
 2024884:	dfc00c15 	stw	ra,48(sp)
 2024888:	df000b15 	stw	fp,44(sp)
 202488c:	df000b04 	addi	fp,sp,44
 2024890:	e13ff915 	stw	r4,-28(fp)
 2024894:	e17ffa15 	stw	r5,-24(fp)
 2024898:	e1bffb15 	stw	r6,-20(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
 202489c:	e0bff917 	ldw	r2,-28(fp)
 20248a0:	10800a04 	addi	r2,r2,40
 20248a4:	e0bff615 	stw	r2,-40(fp)
 20248a8:	00800044 	movi	r2,1
 20248ac:	e0bff88d 	sth	r2,-30(fp)
 20248b0:	e0bff88b 	ldhu	r2,-30(fp)
 20248b4:	10000226 	beq	r2,zero,20248c0 <altera_avalon_jtag_uart_init+0x40>
 20248b8:	e0bff88b 	ldhu	r2,-30(fp)
 20248bc:	00000106 	br	20248c4 <altera_avalon_jtag_uart_init+0x44>
 20248c0:	00800044 	movi	r2,1
 20248c4:	e0fff88b 	ldhu	r3,-30(fp)
 20248c8:	180b883a 	mov	r5,r3
 20248cc:	1009883a 	mov	r4,r2
 20248d0:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 20248d4:	1007883a 	mov	r3,r2
 20248d8:	e0bff617 	ldw	r2,-40(fp)
 20248dc:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 20248e0:	e0bff917 	ldw	r2,-28(fp)
 20248e4:	10800b04 	addi	r2,r2,44
 20248e8:	e0bff715 	stw	r2,-36(fp)
 20248ec:	00800044 	movi	r2,1
 20248f0:	e0bff80d 	sth	r2,-32(fp)
 20248f4:	e0bff80b 	ldhu	r2,-32(fp)
 20248f8:	10000226 	beq	r2,zero,2024904 <altera_avalon_jtag_uart_init+0x84>
 20248fc:	e0bff80b 	ldhu	r2,-32(fp)
 2024900:	00000106 	br	2024908 <altera_avalon_jtag_uart_init+0x88>
 2024904:	00800044 	movi	r2,1
 2024908:	e0fff80b 	ldhu	r3,-32(fp)
 202490c:	180b883a 	mov	r5,r3
 2024910:	1009883a 	mov	r4,r2
 2024914:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 2024918:	1007883a 	mov	r3,r2
 202491c:	e0bff717 	ldw	r2,-36(fp)
 2024920:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 2024924:	e0bff917 	ldw	r2,-28(fp)
 2024928:	00c00044 	movi	r3,1
 202492c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 2024930:	e0bff917 	ldw	r2,-28(fp)
 2024934:	10800017 	ldw	r2,0(r2)
 2024938:	10800104 	addi	r2,r2,4
 202493c:	1007883a 	mov	r3,r2
 2024940:	e0bff917 	ldw	r2,-28(fp)
 2024944:	10800817 	ldw	r2,32(r2)
 2024948:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 202494c:	e0bffa17 	ldw	r2,-24(fp)
 2024950:	e0fffb17 	ldw	r3,-20(fp)
 2024954:	d8000015 	stw	zero,0(sp)
 2024958:	e1fff917 	ldw	r7,-28(fp)
 202495c:	018080b4 	movhi	r6,514
 2024960:	31927204 	addi	r6,r6,18888
 2024964:	180b883a 	mov	r5,r3
 2024968:	1009883a 	mov	r4,r2
 202496c:	202cba40 	call	202cba4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 2024970:	e0bff917 	ldw	r2,-28(fp)
 2024974:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 2024978:	e0bff917 	ldw	r2,-28(fp)
 202497c:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 2024980:	d0e80a17 	ldw	r3,-24536(gp)
 2024984:	e1fff917 	ldw	r7,-28(fp)
 2024988:	018080b4 	movhi	r6,514
 202498c:	3192f504 	addi	r6,r6,19412
 2024990:	180b883a 	mov	r5,r3
 2024994:	1009883a 	mov	r4,r2
 2024998:	202c3a40 	call	202c3a4 <alt_alarm_start>
 202499c:	1000040e 	bge	r2,zero,20249b0 <altera_avalon_jtag_uart_init+0x130>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 20249a0:	e0fff917 	ldw	r3,-28(fp)
 20249a4:	00a00034 	movhi	r2,32768
 20249a8:	10bfffc4 	addi	r2,r2,-1
 20249ac:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 20249b0:	0001883a 	nop
 20249b4:	e037883a 	mov	sp,fp
 20249b8:	dfc00117 	ldw	ra,4(sp)
 20249bc:	df000017 	ldw	fp,0(sp)
 20249c0:	dec00204 	addi	sp,sp,8
 20249c4:	f800283a 	ret

020249c8 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 20249c8:	defff804 	addi	sp,sp,-32
 20249cc:	df000715 	stw	fp,28(sp)
 20249d0:	df000704 	addi	fp,sp,28
 20249d4:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 20249d8:	e0bfff17 	ldw	r2,-4(fp)
 20249dc:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 20249e0:	e0bffb17 	ldw	r2,-20(fp)
 20249e4:	10800017 	ldw	r2,0(r2)
 20249e8:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 20249ec:	e0bffc17 	ldw	r2,-16(fp)
 20249f0:	10800104 	addi	r2,r2,4
 20249f4:	10800037 	ldwio	r2,0(r2)
 20249f8:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 20249fc:	e0bffd17 	ldw	r2,-12(fp)
 2024a00:	1080c00c 	andi	r2,r2,768
 2024a04:	10006d26 	beq	r2,zero,2024bbc <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 2024a08:	e0bffd17 	ldw	r2,-12(fp)
 2024a0c:	1080400c 	andi	r2,r2,256
 2024a10:	10003526 	beq	r2,zero,2024ae8 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 2024a14:	00800074 	movhi	r2,1
 2024a18:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 2024a1c:	e0bffb17 	ldw	r2,-20(fp)
 2024a20:	10800c17 	ldw	r2,48(r2)
 2024a24:	10800044 	addi	r2,r2,1
 2024a28:	1081ffcc 	andi	r2,r2,2047
 2024a2c:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 2024a30:	e0bffb17 	ldw	r2,-20(fp)
 2024a34:	10c00d17 	ldw	r3,52(r2)
 2024a38:	e0bffe17 	ldw	r2,-8(fp)
 2024a3c:	18801526 	beq	r3,r2,2024a94 <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 2024a40:	e0bffc17 	ldw	r2,-16(fp)
 2024a44:	10800037 	ldwio	r2,0(r2)
 2024a48:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 2024a4c:	e0bff917 	ldw	r2,-28(fp)
 2024a50:	10a0000c 	andi	r2,r2,32768
 2024a54:	10001126 	beq	r2,zero,2024a9c <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 2024a58:	e0bffb17 	ldw	r2,-20(fp)
 2024a5c:	10800c17 	ldw	r2,48(r2)
 2024a60:	e0fff917 	ldw	r3,-28(fp)
 2024a64:	1809883a 	mov	r4,r3
 2024a68:	e0fffb17 	ldw	r3,-20(fp)
 2024a6c:	1885883a 	add	r2,r3,r2
 2024a70:	10801004 	addi	r2,r2,64
 2024a74:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 2024a78:	e0bffb17 	ldw	r2,-20(fp)
 2024a7c:	10800c17 	ldw	r2,48(r2)
 2024a80:	10800044 	addi	r2,r2,1
 2024a84:	10c1ffcc 	andi	r3,r2,2047
 2024a88:	e0bffb17 	ldw	r2,-20(fp)
 2024a8c:	10c00c15 	stw	r3,48(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 2024a90:	003fe206 	br	2024a1c <__alt_mem_mem_0+0xfd004a1c>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 2024a94:	0001883a 	nop
 2024a98:	00000106 	br	2024aa0 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 2024a9c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 2024aa0:	e0bff917 	ldw	r2,-28(fp)
 2024aa4:	10bfffec 	andhi	r2,r2,65535
 2024aa8:	10000f26 	beq	r2,zero,2024ae8 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 2024aac:	e0bffb17 	ldw	r2,-20(fp)
 2024ab0:	10c00817 	ldw	r3,32(r2)
 2024ab4:	00bfff84 	movi	r2,-2
 2024ab8:	1886703a 	and	r3,r3,r2
 2024abc:	e0bffb17 	ldw	r2,-20(fp)
 2024ac0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 2024ac4:	e0bffc17 	ldw	r2,-16(fp)
 2024ac8:	10800104 	addi	r2,r2,4
 2024acc:	1007883a 	mov	r3,r2
 2024ad0:	e0bffb17 	ldw	r2,-20(fp)
 2024ad4:	10800817 	ldw	r2,32(r2)
 2024ad8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 2024adc:	e0bffc17 	ldw	r2,-16(fp)
 2024ae0:	10800104 	addi	r2,r2,4
 2024ae4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 2024ae8:	e0bffd17 	ldw	r2,-12(fp)
 2024aec:	1080800c 	andi	r2,r2,512
 2024af0:	103fbe26 	beq	r2,zero,20249ec <__alt_mem_mem_0+0xfd0049ec>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 2024af4:	e0bffd17 	ldw	r2,-12(fp)
 2024af8:	1004d43a 	srli	r2,r2,16
 2024afc:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 2024b00:	00001406 	br	2024b54 <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 2024b04:	e0bffc17 	ldw	r2,-16(fp)
 2024b08:	e0fffb17 	ldw	r3,-20(fp)
 2024b0c:	18c00f17 	ldw	r3,60(r3)
 2024b10:	e13ffb17 	ldw	r4,-20(fp)
 2024b14:	20c7883a 	add	r3,r4,r3
 2024b18:	18c21004 	addi	r3,r3,2112
 2024b1c:	18c00003 	ldbu	r3,0(r3)
 2024b20:	18c03fcc 	andi	r3,r3,255
 2024b24:	18c0201c 	xori	r3,r3,128
 2024b28:	18ffe004 	addi	r3,r3,-128
 2024b2c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 2024b30:	e0bffb17 	ldw	r2,-20(fp)
 2024b34:	10800f17 	ldw	r2,60(r2)
 2024b38:	10800044 	addi	r2,r2,1
 2024b3c:	10c1ffcc 	andi	r3,r2,2047
 2024b40:	e0bffb17 	ldw	r2,-20(fp)
 2024b44:	10c00f15 	stw	r3,60(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 2024b48:	e0bffa17 	ldw	r2,-24(fp)
 2024b4c:	10bfffc4 	addi	r2,r2,-1
 2024b50:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 2024b54:	e0bffa17 	ldw	r2,-24(fp)
 2024b58:	10000526 	beq	r2,zero,2024b70 <altera_avalon_jtag_uart_irq+0x1a8>
 2024b5c:	e0bffb17 	ldw	r2,-20(fp)
 2024b60:	10c00f17 	ldw	r3,60(r2)
 2024b64:	e0bffb17 	ldw	r2,-20(fp)
 2024b68:	10800e17 	ldw	r2,56(r2)
 2024b6c:	18bfe51e 	bne	r3,r2,2024b04 <__alt_mem_mem_0+0xfd004b04>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 2024b70:	e0bffa17 	ldw	r2,-24(fp)
 2024b74:	103f9d26 	beq	r2,zero,20249ec <__alt_mem_mem_0+0xfd0049ec>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 2024b78:	e0bffb17 	ldw	r2,-20(fp)
 2024b7c:	10c00817 	ldw	r3,32(r2)
 2024b80:	00bfff44 	movi	r2,-3
 2024b84:	1886703a 	and	r3,r3,r2
 2024b88:	e0bffb17 	ldw	r2,-20(fp)
 2024b8c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 2024b90:	e0bffb17 	ldw	r2,-20(fp)
 2024b94:	10800017 	ldw	r2,0(r2)
 2024b98:	10800104 	addi	r2,r2,4
 2024b9c:	1007883a 	mov	r3,r2
 2024ba0:	e0bffb17 	ldw	r2,-20(fp)
 2024ba4:	10800817 	ldw	r2,32(r2)
 2024ba8:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 2024bac:	e0bffc17 	ldw	r2,-16(fp)
 2024bb0:	10800104 	addi	r2,r2,4
 2024bb4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 2024bb8:	003f8c06 	br	20249ec <__alt_mem_mem_0+0xfd0049ec>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 2024bbc:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 2024bc0:	0001883a 	nop
 2024bc4:	e037883a 	mov	sp,fp
 2024bc8:	df000017 	ldw	fp,0(sp)
 2024bcc:	dec00104 	addi	sp,sp,4
 2024bd0:	f800283a 	ret

02024bd4 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 2024bd4:	defff804 	addi	sp,sp,-32
 2024bd8:	df000715 	stw	fp,28(sp)
 2024bdc:	df000704 	addi	fp,sp,28
 2024be0:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 2024be4:	e0bffb17 	ldw	r2,-20(fp)
 2024be8:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 2024bec:	e0bff917 	ldw	r2,-28(fp)
 2024bf0:	10800017 	ldw	r2,0(r2)
 2024bf4:	10800104 	addi	r2,r2,4
 2024bf8:	10800037 	ldwio	r2,0(r2)
 2024bfc:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 2024c00:	e0bffa17 	ldw	r2,-24(fp)
 2024c04:	1081000c 	andi	r2,r2,1024
 2024c08:	10000b26 	beq	r2,zero,2024c38 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 2024c0c:	e0bff917 	ldw	r2,-28(fp)
 2024c10:	10800017 	ldw	r2,0(r2)
 2024c14:	10800104 	addi	r2,r2,4
 2024c18:	1007883a 	mov	r3,r2
 2024c1c:	e0bff917 	ldw	r2,-28(fp)
 2024c20:	10800817 	ldw	r2,32(r2)
 2024c24:	10810014 	ori	r2,r2,1024
 2024c28:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 2024c2c:	e0bff917 	ldw	r2,-28(fp)
 2024c30:	10000915 	stw	zero,36(r2)
 2024c34:	00000a06 	br	2024c60 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 2024c38:	e0bff917 	ldw	r2,-28(fp)
 2024c3c:	10c00917 	ldw	r3,36(r2)
 2024c40:	00a00034 	movhi	r2,32768
 2024c44:	10bfff04 	addi	r2,r2,-4
 2024c48:	10c00536 	bltu	r2,r3,2024c60 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 2024c4c:	e0bff917 	ldw	r2,-28(fp)
 2024c50:	10800917 	ldw	r2,36(r2)
 2024c54:	10c00044 	addi	r3,r2,1
 2024c58:	e0bff917 	ldw	r2,-28(fp)
 2024c5c:	10c00915 	stw	r3,36(r2)
 2024c60:	d0a80a17 	ldw	r2,-24536(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 2024c64:	e037883a 	mov	sp,fp
 2024c68:	df000017 	ldw	fp,0(sp)
 2024c6c:	dec00104 	addi	sp,sp,4
 2024c70:	f800283a 	ret

02024c74 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 2024c74:	defffd04 	addi	sp,sp,-12
 2024c78:	df000215 	stw	fp,8(sp)
 2024c7c:	df000204 	addi	fp,sp,8
 2024c80:	e13ffe15 	stw	r4,-8(fp)
 2024c84:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 2024c88:	00000506 	br	2024ca0 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 2024c8c:	e0bfff17 	ldw	r2,-4(fp)
 2024c90:	1090000c 	andi	r2,r2,16384
 2024c94:	10000226 	beq	r2,zero,2024ca0 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 2024c98:	00bffd44 	movi	r2,-11
 2024c9c:	00000b06 	br	2024ccc <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 2024ca0:	e0bffe17 	ldw	r2,-8(fp)
 2024ca4:	10c00f17 	ldw	r3,60(r2)
 2024ca8:	e0bffe17 	ldw	r2,-8(fp)
 2024cac:	10800e17 	ldw	r2,56(r2)
 2024cb0:	18800526 	beq	r3,r2,2024cc8 <altera_avalon_jtag_uart_close+0x54>
 2024cb4:	e0bffe17 	ldw	r2,-8(fp)
 2024cb8:	10c00917 	ldw	r3,36(r2)
 2024cbc:	e0bffe17 	ldw	r2,-8(fp)
 2024cc0:	10800117 	ldw	r2,4(r2)
 2024cc4:	18bff136 	bltu	r3,r2,2024c8c <__alt_mem_mem_0+0xfd004c8c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 2024cc8:	0005883a 	mov	r2,zero
}
 2024ccc:	e037883a 	mov	sp,fp
 2024cd0:	df000017 	ldw	fp,0(sp)
 2024cd4:	dec00104 	addi	sp,sp,4
 2024cd8:	f800283a 	ret

02024cdc <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 2024cdc:	defffa04 	addi	sp,sp,-24
 2024ce0:	df000515 	stw	fp,20(sp)
 2024ce4:	df000504 	addi	fp,sp,20
 2024ce8:	e13ffd15 	stw	r4,-12(fp)
 2024cec:	e17ffe15 	stw	r5,-8(fp)
 2024cf0:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 2024cf4:	00bff9c4 	movi	r2,-25
 2024cf8:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 2024cfc:	e0bffe17 	ldw	r2,-8(fp)
 2024d00:	10da8060 	cmpeqi	r3,r2,27137
 2024d04:	1800031e 	bne	r3,zero,2024d14 <altera_avalon_jtag_uart_ioctl+0x38>
 2024d08:	109a80a0 	cmpeqi	r2,r2,27138
 2024d0c:	1000181e 	bne	r2,zero,2024d70 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 2024d10:	00002906 	br	2024db8 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 2024d14:	e0bffd17 	ldw	r2,-12(fp)
 2024d18:	10c00117 	ldw	r3,4(r2)
 2024d1c:	00a00034 	movhi	r2,32768
 2024d20:	10bfffc4 	addi	r2,r2,-1
 2024d24:	18802126 	beq	r3,r2,2024dac <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 2024d28:	e0bfff17 	ldw	r2,-4(fp)
 2024d2c:	10800017 	ldw	r2,0(r2)
 2024d30:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 2024d34:	e0bffc17 	ldw	r2,-16(fp)
 2024d38:	10800090 	cmplti	r2,r2,2
 2024d3c:	1000061e 	bne	r2,zero,2024d58 <altera_avalon_jtag_uart_ioctl+0x7c>
 2024d40:	e0fffc17 	ldw	r3,-16(fp)
 2024d44:	00a00034 	movhi	r2,32768
 2024d48:	10bfffc4 	addi	r2,r2,-1
 2024d4c:	18800226 	beq	r3,r2,2024d58 <altera_avalon_jtag_uart_ioctl+0x7c>
 2024d50:	e0bffc17 	ldw	r2,-16(fp)
 2024d54:	00000206 	br	2024d60 <altera_avalon_jtag_uart_ioctl+0x84>
 2024d58:	00a00034 	movhi	r2,32768
 2024d5c:	10bfff84 	addi	r2,r2,-2
 2024d60:	e0fffd17 	ldw	r3,-12(fp)
 2024d64:	18800115 	stw	r2,4(r3)
      rc = 0;
 2024d68:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 2024d6c:	00000f06 	br	2024dac <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 2024d70:	e0bffd17 	ldw	r2,-12(fp)
 2024d74:	10c00117 	ldw	r3,4(r2)
 2024d78:	00a00034 	movhi	r2,32768
 2024d7c:	10bfffc4 	addi	r2,r2,-1
 2024d80:	18800c26 	beq	r3,r2,2024db4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 2024d84:	e0bffd17 	ldw	r2,-12(fp)
 2024d88:	10c00917 	ldw	r3,36(r2)
 2024d8c:	e0bffd17 	ldw	r2,-12(fp)
 2024d90:	10800117 	ldw	r2,4(r2)
 2024d94:	1885803a 	cmpltu	r2,r3,r2
 2024d98:	10c03fcc 	andi	r3,r2,255
 2024d9c:	e0bfff17 	ldw	r2,-4(fp)
 2024da0:	10c00015 	stw	r3,0(r2)
      rc = 0;
 2024da4:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 2024da8:	00000206 	br	2024db4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 2024dac:	0001883a 	nop
 2024db0:	00000106 	br	2024db8 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 2024db4:	0001883a 	nop

  default:
    break;
  }

  return rc;
 2024db8:	e0bffb17 	ldw	r2,-20(fp)
}
 2024dbc:	e037883a 	mov	sp,fp
 2024dc0:	df000017 	ldw	fp,0(sp)
 2024dc4:	dec00104 	addi	sp,sp,4
 2024dc8:	f800283a 	ret

02024dcc <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 2024dcc:	defff004 	addi	sp,sp,-64
 2024dd0:	dfc00f15 	stw	ra,60(sp)
 2024dd4:	df000e15 	stw	fp,56(sp)
 2024dd8:	df000e04 	addi	fp,sp,56
 2024ddc:	e13ffb15 	stw	r4,-20(fp)
 2024de0:	e17ffc15 	stw	r5,-16(fp)
 2024de4:	e1bffd15 	stw	r6,-12(fp)
 2024de8:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 2024dec:	e0bffc17 	ldw	r2,-16(fp)
 2024df0:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 2024df4:	e0bffb17 	ldw	r2,-20(fp)
 2024df8:	10800a17 	ldw	r2,40(r2)
 2024dfc:	e0bff915 	stw	r2,-28(fp)
 2024e00:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 2024e04:	e0bffa0b 	ldhu	r2,-24(fp)
 2024e08:	100b883a 	mov	r5,r2
 2024e0c:	e13ff917 	ldw	r4,-28(fp)
 2024e10:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>

  while (space > 0)
 2024e14:	00004706 	br	2024f34 <altera_avalon_jtag_uart_read+0x168>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 2024e18:	e0bffb17 	ldw	r2,-20(fp)
 2024e1c:	10800c17 	ldw	r2,48(r2)
 2024e20:	e0bff515 	stw	r2,-44(fp)
      out = sp->rx_out;
 2024e24:	e0bffb17 	ldw	r2,-20(fp)
 2024e28:	10800d17 	ldw	r2,52(r2)
 2024e2c:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 2024e30:	e0fff517 	ldw	r3,-44(fp)
 2024e34:	e0bff617 	ldw	r2,-40(fp)
 2024e38:	18800536 	bltu	r3,r2,2024e50 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 2024e3c:	e0fff517 	ldw	r3,-44(fp)
 2024e40:	e0bff617 	ldw	r2,-40(fp)
 2024e44:	1885c83a 	sub	r2,r3,r2
 2024e48:	e0bff315 	stw	r2,-52(fp)
 2024e4c:	00000406 	br	2024e60 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 2024e50:	00c20004 	movi	r3,2048
 2024e54:	e0bff617 	ldw	r2,-40(fp)
 2024e58:	1885c83a 	sub	r2,r3,r2
 2024e5c:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 2024e60:	e0bff317 	ldw	r2,-52(fp)
 2024e64:	10001e26 	beq	r2,zero,2024ee0 <altera_avalon_jtag_uart_read+0x114>
        break; /* No more data available */

      if (n > space)
 2024e68:	e0fffd17 	ldw	r3,-12(fp)
 2024e6c:	e0bff317 	ldw	r2,-52(fp)
 2024e70:	1880022e 	bgeu	r3,r2,2024e7c <altera_avalon_jtag_uart_read+0xb0>
        n = space;
 2024e74:	e0bffd17 	ldw	r2,-12(fp)
 2024e78:	e0bff315 	stw	r2,-52(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 2024e7c:	e0bffb17 	ldw	r2,-20(fp)
 2024e80:	10c01004 	addi	r3,r2,64
 2024e84:	e0bff617 	ldw	r2,-40(fp)
 2024e88:	1885883a 	add	r2,r3,r2
 2024e8c:	e1bff317 	ldw	r6,-52(fp)
 2024e90:	100b883a 	mov	r5,r2
 2024e94:	e13ff217 	ldw	r4,-56(fp)
 2024e98:	20060240 	call	2006024 <memcpy>
      ptr   += n;
 2024e9c:	e0fff217 	ldw	r3,-56(fp)
 2024ea0:	e0bff317 	ldw	r2,-52(fp)
 2024ea4:	1885883a 	add	r2,r3,r2
 2024ea8:	e0bff215 	stw	r2,-56(fp)
      space -= n;
 2024eac:	e0fffd17 	ldw	r3,-12(fp)
 2024eb0:	e0bff317 	ldw	r2,-52(fp)
 2024eb4:	1885c83a 	sub	r2,r3,r2
 2024eb8:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 2024ebc:	e0fff617 	ldw	r3,-40(fp)
 2024ec0:	e0bff317 	ldw	r2,-52(fp)
 2024ec4:	1885883a 	add	r2,r3,r2
 2024ec8:	10c1ffcc 	andi	r3,r2,2047
 2024ecc:	e0bffb17 	ldw	r2,-20(fp)
 2024ed0:	10c00d15 	stw	r3,52(r2)
    }
    while (space > 0);
 2024ed4:	e0bffd17 	ldw	r2,-12(fp)
 2024ed8:	00bfcf16 	blt	zero,r2,2024e18 <__alt_mem_mem_0+0xfd004e18>
 2024edc:	00000106 	br	2024ee4 <altera_avalon_jtag_uart_read+0x118>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 2024ee0:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 2024ee4:	e0fff217 	ldw	r3,-56(fp)
 2024ee8:	e0bffc17 	ldw	r2,-16(fp)
 2024eec:	1880141e 	bne	r3,r2,2024f40 <altera_avalon_jtag_uart_read+0x174>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 2024ef0:	e0bffe17 	ldw	r2,-8(fp)
 2024ef4:	1090000c 	andi	r2,r2,16384
 2024ef8:	1000131e 	bne	r2,zero,2024f48 <altera_avalon_jtag_uart_read+0x17c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 2024efc:	0001883a 	nop
 2024f00:	e0bffb17 	ldw	r2,-20(fp)
 2024f04:	10c00c17 	ldw	r3,48(r2)
 2024f08:	e0bff517 	ldw	r2,-44(fp)
 2024f0c:	1880051e 	bne	r3,r2,2024f24 <altera_avalon_jtag_uart_read+0x158>
 2024f10:	e0bffb17 	ldw	r2,-20(fp)
 2024f14:	10c00917 	ldw	r3,36(r2)
 2024f18:	e0bffb17 	ldw	r2,-20(fp)
 2024f1c:	10800117 	ldw	r2,4(r2)
 2024f20:	18bff736 	bltu	r3,r2,2024f00 <__alt_mem_mem_0+0xfd004f00>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 2024f24:	e0bffb17 	ldw	r2,-20(fp)
 2024f28:	10c00c17 	ldw	r3,48(r2)
 2024f2c:	e0bff517 	ldw	r2,-44(fp)
 2024f30:	18800726 	beq	r3,r2,2024f50 <altera_avalon_jtag_uart_read+0x184>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 2024f34:	e0bffd17 	ldw	r2,-12(fp)
 2024f38:	00bfb716 	blt	zero,r2,2024e18 <__alt_mem_mem_0+0xfd004e18>
 2024f3c:	00000506 	br	2024f54 <altera_avalon_jtag_uart_read+0x188>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 2024f40:	0001883a 	nop
 2024f44:	00000306 	br	2024f54 <altera_avalon_jtag_uart_read+0x188>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 2024f48:	0001883a 	nop
 2024f4c:	00000106 	br	2024f54 <altera_avalon_jtag_uart_read+0x188>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 2024f50:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 2024f54:	e0bffb17 	ldw	r2,-20(fp)
 2024f58:	10800a17 	ldw	r2,40(r2)
 2024f5c:	000f883a 	mov	r7,zero
 2024f60:	000d883a 	mov	r6,zero
 2024f64:	000b883a 	mov	r5,zero
 2024f68:	1009883a 	mov	r4,r2
 2024f6c:	200da140 	call	200da14 <xQueueGenericSend>

  if (ptr != buffer)
 2024f70:	e0fff217 	ldw	r3,-56(fp)
 2024f74:	e0bffc17 	ldw	r2,-16(fp)
 2024f78:	18801826 	beq	r3,r2,2024fdc <altera_avalon_jtag_uart_read+0x210>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2024f7c:	0005303a 	rdctl	r2,status
 2024f80:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2024f84:	e0fff817 	ldw	r3,-32(fp)
 2024f88:	00bfff84 	movi	r2,-2
 2024f8c:	1884703a 	and	r2,r3,r2
 2024f90:	1001703a 	wrctl	status,r2
  
  return context;
 2024f94:	e0bff817 	ldw	r2,-32(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 2024f98:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 2024f9c:	e0bffb17 	ldw	r2,-20(fp)
 2024fa0:	10800817 	ldw	r2,32(r2)
 2024fa4:	10c00054 	ori	r3,r2,1
 2024fa8:	e0bffb17 	ldw	r2,-20(fp)
 2024fac:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 2024fb0:	e0bffb17 	ldw	r2,-20(fp)
 2024fb4:	10800017 	ldw	r2,0(r2)
 2024fb8:	10800104 	addi	r2,r2,4
 2024fbc:	1007883a 	mov	r3,r2
 2024fc0:	e0bffb17 	ldw	r2,-20(fp)
 2024fc4:	10800817 	ldw	r2,32(r2)
 2024fc8:	18800035 	stwio	r2,0(r3)
 2024fcc:	e0bff717 	ldw	r2,-36(fp)
 2024fd0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2024fd4:	e0bff417 	ldw	r2,-48(fp)
 2024fd8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 2024fdc:	e0fff217 	ldw	r3,-56(fp)
 2024fe0:	e0bffc17 	ldw	r2,-16(fp)
 2024fe4:	18800426 	beq	r3,r2,2024ff8 <altera_avalon_jtag_uart_read+0x22c>
    return ptr - buffer;
 2024fe8:	e0fff217 	ldw	r3,-56(fp)
 2024fec:	e0bffc17 	ldw	r2,-16(fp)
 2024ff0:	1885c83a 	sub	r2,r3,r2
 2024ff4:	00000606 	br	2025010 <altera_avalon_jtag_uart_read+0x244>
  else if (flags & O_NONBLOCK)
 2024ff8:	e0bffe17 	ldw	r2,-8(fp)
 2024ffc:	1090000c 	andi	r2,r2,16384
 2025000:	10000226 	beq	r2,zero,202500c <altera_avalon_jtag_uart_read+0x240>
    return -EWOULDBLOCK;
 2025004:	00bffd44 	movi	r2,-11
 2025008:	00000106 	br	2025010 <altera_avalon_jtag_uart_read+0x244>
  else
    return -EIO;
 202500c:	00bffec4 	movi	r2,-5
}
 2025010:	e037883a 	mov	sp,fp
 2025014:	dfc00117 	ldw	ra,4(sp)
 2025018:	df000017 	ldw	fp,0(sp)
 202501c:	dec00204 	addi	sp,sp,8
 2025020:	f800283a 	ret

02025024 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 2025024:	defff004 	addi	sp,sp,-64
 2025028:	dfc00f15 	stw	ra,60(sp)
 202502c:	df000e15 	stw	fp,56(sp)
 2025030:	df000e04 	addi	fp,sp,56
 2025034:	e13ffb15 	stw	r4,-20(fp)
 2025038:	e17ffc15 	stw	r5,-16(fp)
 202503c:	e1bffd15 	stw	r6,-12(fp)
 2025040:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 2025044:	e03ff215 	stw	zero,-56(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 2025048:	e0bffc17 	ldw	r2,-16(fp)
 202504c:	e0bff415 	stw	r2,-48(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 2025050:	e0bffb17 	ldw	r2,-20(fp)
 2025054:	10800b17 	ldw	r2,44(r2)
 2025058:	e0bff915 	stw	r2,-28(fp)
 202505c:	e03ffa0d 	sth	zero,-24(fp)
 2025060:	e0bffa0b 	ldhu	r2,-24(fp)
 2025064:	100b883a 	mov	r5,r2
 2025068:	e13ff917 	ldw	r4,-28(fp)
 202506c:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 2025070:	00003706 	br	2025150 <altera_avalon_jtag_uart_write+0x12c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 2025074:	e0bffb17 	ldw	r2,-20(fp)
 2025078:	10800e17 	ldw	r2,56(r2)
 202507c:	e0bff615 	stw	r2,-40(fp)
      out = sp->tx_out;
 2025080:	e0bffb17 	ldw	r2,-20(fp)
 2025084:	10800f17 	ldw	r2,60(r2)
 2025088:	e0bff215 	stw	r2,-56(fp)

      if (in < out)
 202508c:	e0fff617 	ldw	r3,-40(fp)
 2025090:	e0bff217 	ldw	r2,-56(fp)
 2025094:	1880062e 	bgeu	r3,r2,20250b0 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 2025098:	e0fff217 	ldw	r3,-56(fp)
 202509c:	e0bff617 	ldw	r2,-40(fp)
 20250a0:	1885c83a 	sub	r2,r3,r2
 20250a4:	10bfffc4 	addi	r2,r2,-1
 20250a8:	e0bff315 	stw	r2,-52(fp)
 20250ac:	00000b06 	br	20250dc <altera_avalon_jtag_uart_write+0xb8>
      else if (out > 0)
 20250b0:	e0bff217 	ldw	r2,-56(fp)
 20250b4:	10000526 	beq	r2,zero,20250cc <altera_avalon_jtag_uart_write+0xa8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 20250b8:	00c20004 	movi	r3,2048
 20250bc:	e0bff617 	ldw	r2,-40(fp)
 20250c0:	1885c83a 	sub	r2,r3,r2
 20250c4:	e0bff315 	stw	r2,-52(fp)
 20250c8:	00000406 	br	20250dc <altera_avalon_jtag_uart_write+0xb8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 20250cc:	00c1ffc4 	movi	r3,2047
 20250d0:	e0bff617 	ldw	r2,-40(fp)
 20250d4:	1885c83a 	sub	r2,r3,r2
 20250d8:	e0bff315 	stw	r2,-52(fp)

      if (n == 0)
 20250dc:	e0bff317 	ldw	r2,-52(fp)
 20250e0:	10001e26 	beq	r2,zero,202515c <altera_avalon_jtag_uart_write+0x138>
        break;

      if (n > count)
 20250e4:	e0fffd17 	ldw	r3,-12(fp)
 20250e8:	e0bff317 	ldw	r2,-52(fp)
 20250ec:	1880022e 	bgeu	r3,r2,20250f8 <altera_avalon_jtag_uart_write+0xd4>
        n = count;
 20250f0:	e0bffd17 	ldw	r2,-12(fp)
 20250f4:	e0bff315 	stw	r2,-52(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 20250f8:	e0bffb17 	ldw	r2,-20(fp)
 20250fc:	10c21004 	addi	r3,r2,2112
 2025100:	e0bff617 	ldw	r2,-40(fp)
 2025104:	1885883a 	add	r2,r3,r2
 2025108:	e1bff317 	ldw	r6,-52(fp)
 202510c:	e17ffc17 	ldw	r5,-16(fp)
 2025110:	1009883a 	mov	r4,r2
 2025114:	20060240 	call	2006024 <memcpy>
      ptr   += n;
 2025118:	e0fffc17 	ldw	r3,-16(fp)
 202511c:	e0bff317 	ldw	r2,-52(fp)
 2025120:	1885883a 	add	r2,r3,r2
 2025124:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 2025128:	e0fffd17 	ldw	r3,-12(fp)
 202512c:	e0bff317 	ldw	r2,-52(fp)
 2025130:	1885c83a 	sub	r2,r3,r2
 2025134:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 2025138:	e0fff617 	ldw	r3,-40(fp)
 202513c:	e0bff317 	ldw	r2,-52(fp)
 2025140:	1885883a 	add	r2,r3,r2
 2025144:	10c1ffcc 	andi	r3,r2,2047
 2025148:	e0bffb17 	ldw	r2,-20(fp)
 202514c:	10c00e15 	stw	r3,56(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 2025150:	e0bffd17 	ldw	r2,-12(fp)
 2025154:	00bfc716 	blt	zero,r2,2025074 <__alt_mem_mem_0+0xfd005074>
 2025158:	00000106 	br	2025160 <altera_avalon_jtag_uart_write+0x13c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 202515c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2025160:	0005303a 	rdctl	r2,status
 2025164:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2025168:	e0fff817 	ldw	r3,-32(fp)
 202516c:	00bfff84 	movi	r2,-2
 2025170:	1884703a 	and	r2,r3,r2
 2025174:	1001703a 	wrctl	status,r2
  
  return context;
 2025178:	e0bff817 	ldw	r2,-32(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 202517c:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 2025180:	e0bffb17 	ldw	r2,-20(fp)
 2025184:	10800817 	ldw	r2,32(r2)
 2025188:	10c00094 	ori	r3,r2,2
 202518c:	e0bffb17 	ldw	r2,-20(fp)
 2025190:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 2025194:	e0bffb17 	ldw	r2,-20(fp)
 2025198:	10800017 	ldw	r2,0(r2)
 202519c:	10800104 	addi	r2,r2,4
 20251a0:	1007883a 	mov	r3,r2
 20251a4:	e0bffb17 	ldw	r2,-20(fp)
 20251a8:	10800817 	ldw	r2,32(r2)
 20251ac:	18800035 	stwio	r2,0(r3)
 20251b0:	e0bff717 	ldw	r2,-36(fp)
 20251b4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20251b8:	e0bff517 	ldw	r2,-44(fp)
 20251bc:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 20251c0:	e0bffd17 	ldw	r2,-12(fp)
 20251c4:	0080100e 	bge	zero,r2,2025208 <altera_avalon_jtag_uart_write+0x1e4>
    {
      if (flags & O_NONBLOCK)
 20251c8:	e0bffe17 	ldw	r2,-8(fp)
 20251cc:	1090000c 	andi	r2,r2,16384
 20251d0:	1000101e 	bne	r2,zero,2025214 <altera_avalon_jtag_uart_write+0x1f0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 20251d4:	0001883a 	nop
 20251d8:	e0bffb17 	ldw	r2,-20(fp)
 20251dc:	10c00f17 	ldw	r3,60(r2)
 20251e0:	e0bff217 	ldw	r2,-56(fp)
 20251e4:	1880051e 	bne	r3,r2,20251fc <altera_avalon_jtag_uart_write+0x1d8>
 20251e8:	e0bffb17 	ldw	r2,-20(fp)
 20251ec:	10c00917 	ldw	r3,36(r2)
 20251f0:	e0bffb17 	ldw	r2,-20(fp)
 20251f4:	10800117 	ldw	r2,4(r2)
 20251f8:	18bff736 	bltu	r3,r2,20251d8 <__alt_mem_mem_0+0xfd0051d8>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 20251fc:	e0bffb17 	ldw	r2,-20(fp)
 2025200:	10800917 	ldw	r2,36(r2)
 2025204:	1000051e 	bne	r2,zero,202521c <altera_avalon_jtag_uart_write+0x1f8>
         break;
    }
  }
  while (count > 0);
 2025208:	e0bffd17 	ldw	r2,-12(fp)
 202520c:	00bfd016 	blt	zero,r2,2025150 <__alt_mem_mem_0+0xfd005150>
 2025210:	00000306 	br	2025220 <altera_avalon_jtag_uart_write+0x1fc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 2025214:	0001883a 	nop
 2025218:	00000106 	br	2025220 <altera_avalon_jtag_uart_write+0x1fc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 202521c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 2025220:	e0bffb17 	ldw	r2,-20(fp)
 2025224:	10800b17 	ldw	r2,44(r2)
 2025228:	000f883a 	mov	r7,zero
 202522c:	000d883a 	mov	r6,zero
 2025230:	000b883a 	mov	r5,zero
 2025234:	1009883a 	mov	r4,r2
 2025238:	200da140 	call	200da14 <xQueueGenericSend>

  if (ptr != start)
 202523c:	e0fffc17 	ldw	r3,-16(fp)
 2025240:	e0bff417 	ldw	r2,-48(fp)
 2025244:	18800426 	beq	r3,r2,2025258 <altera_avalon_jtag_uart_write+0x234>
    return ptr - start;
 2025248:	e0fffc17 	ldw	r3,-16(fp)
 202524c:	e0bff417 	ldw	r2,-48(fp)
 2025250:	1885c83a 	sub	r2,r3,r2
 2025254:	00000606 	br	2025270 <altera_avalon_jtag_uart_write+0x24c>
  else if (flags & O_NONBLOCK)
 2025258:	e0bffe17 	ldw	r2,-8(fp)
 202525c:	1090000c 	andi	r2,r2,16384
 2025260:	10000226 	beq	r2,zero,202526c <altera_avalon_jtag_uart_write+0x248>
    return -EWOULDBLOCK;
 2025264:	00bffd44 	movi	r2,-11
 2025268:	00000106 	br	2025270 <altera_avalon_jtag_uart_write+0x24c>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 202526c:	00bffec4 	movi	r2,-5
}
 2025270:	e037883a 	mov	sp,fp
 2025274:	dfc00117 	ldw	ra,4(sp)
 2025278:	df000017 	ldw	fp,0(sp)
 202527c:	dec00204 	addi	sp,sp,8
 2025280:	f800283a 	ret

02025284 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2025284:	defffe04 	addi	sp,sp,-8
 2025288:	dfc00115 	stw	ra,4(sp)
 202528c:	df000015 	stw	fp,0(sp)
 2025290:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2025294:	d0a01a17 	ldw	r2,-32664(gp)
 2025298:	10000326 	beq	r2,zero,20252a8 <alt_get_errno+0x24>
 202529c:	d0a01a17 	ldw	r2,-32664(gp)
 20252a0:	103ee83a 	callr	r2
 20252a4:	00000106 	br	20252ac <alt_get_errno+0x28>
 20252a8:	d0a7ce04 	addi	r2,gp,-24776
}
 20252ac:	e037883a 	mov	sp,fp
 20252b0:	dfc00117 	ldw	ra,4(sp)
 20252b4:	df000017 	ldw	fp,0(sp)
 20252b8:	dec00204 	addi	sp,sp,8
 20252bc:	f800283a 	ret

020252c0 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 20252c0:	defffc04 	addi	sp,sp,-16
 20252c4:	df000315 	stw	fp,12(sp)
 20252c8:	df000304 	addi	fp,sp,12
 20252cc:	e13ffe15 	stw	r4,-8(fp)
 20252d0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 20252d4:	e0bffe17 	ldw	r2,-8(fp)
 20252d8:	10800317 	ldw	r2,12(r2)
 20252dc:	10800037 	ldwio	r2,0(r2)
 20252e0:	1080040c 	andi	r2,r2,16
 20252e4:	10000226 	beq	r2,zero,20252f0 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 20252e8:	00bffc04 	movi	r2,-16
 20252ec:	00003906 	br	20253d4 <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 20252f0:	e0bffe17 	ldw	r2,-8(fp)
 20252f4:	10800317 	ldw	r2,12(r2)
 20252f8:	10800404 	addi	r2,r2,16
 20252fc:	e0fffe17 	ldw	r3,-8(fp)
 2025300:	18c00317 	ldw	r3,12(r3)
 2025304:	18c00404 	addi	r3,r3,16
 2025308:	19000037 	ldwio	r4,0(r3)
 202530c:	00fff7c4 	movi	r3,-33
 2025310:	20c6703a 	and	r3,r4,r3
 2025314:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2025318:	e0bffe17 	ldw	r2,-8(fp)
 202531c:	10800317 	ldw	r2,12(r2)
 2025320:	00c03fc4 	movi	r3,255
 2025324:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 2025328:	e0bffe17 	ldw	r2,-8(fp)
 202532c:	10800317 	ldw	r2,12(r2)
 2025330:	10800804 	addi	r2,r2,32
 2025334:	e0ffff17 	ldw	r3,-4(fp)
 2025338:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 202533c:	e0bffe17 	ldw	r2,-8(fp)
 2025340:	10800917 	ldw	r2,36(r2)
 2025344:	10001126 	beq	r2,zero,202538c <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2025348:	e0bffe17 	ldw	r2,-8(fp)
 202534c:	10800317 	ldw	r2,12(r2)
 2025350:	10800404 	addi	r2,r2,16
 2025354:	10800037 	ldwio	r2,0(r2)
 2025358:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 202535c:	e0bffe17 	ldw	r2,-8(fp)
 2025360:	10c00b17 	ldw	r3,44(r2)
 2025364:	e0bffd17 	ldw	r2,-12(fp)
 2025368:	1884b03a 	or	r2,r3,r2
 202536c:	10801814 	ori	r2,r2,96
 2025370:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2025374:	e0bffe17 	ldw	r2,-8(fp)
 2025378:	10800317 	ldw	r2,12(r2)
 202537c:	10800404 	addi	r2,r2,16
 2025380:	e0fffd17 	ldw	r3,-12(fp)
 2025384:	10c00035 	stwio	r3,0(r2)
 2025388:	00001106 	br	20253d0 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202538c:	e0bffe17 	ldw	r2,-8(fp)
 2025390:	10800317 	ldw	r2,12(r2)
 2025394:	10800404 	addi	r2,r2,16
 2025398:	10800037 	ldwio	r2,0(r2)
 202539c:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 20253a0:	e0bffd17 	ldw	r2,-12(fp)
 20253a4:	10801814 	ori	r2,r2,96
 20253a8:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 20253ac:	e0fffd17 	ldw	r3,-12(fp)
 20253b0:	00bffbc4 	movi	r2,-17
 20253b4:	1884703a 	and	r2,r3,r2
 20253b8:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 20253bc:	e0bffe17 	ldw	r2,-8(fp)
 20253c0:	10800317 	ldw	r2,12(r2)
 20253c4:	10800404 	addi	r2,r2,16
 20253c8:	e0fffd17 	ldw	r3,-12(fp)
 20253cc:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 20253d0:	0005883a 	mov	r2,zero
}
 20253d4:	e037883a 	mov	sp,fp
 20253d8:	df000017 	ldw	fp,0(sp)
 20253dc:	dec00104 	addi	sp,sp,4
 20253e0:	f800283a 	ret

020253e4 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 20253e4:	defffc04 	addi	sp,sp,-16
 20253e8:	df000315 	stw	fp,12(sp)
 20253ec:	df000304 	addi	fp,sp,12
 20253f0:	e13ffe15 	stw	r4,-8(fp)
 20253f4:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 20253f8:	0001883a 	nop
 20253fc:	e0bffe17 	ldw	r2,-8(fp)
 2025400:	10800317 	ldw	r2,12(r2)
 2025404:	10800037 	ldwio	r2,0(r2)
 2025408:	1080040c 	andi	r2,r2,16
 202540c:	103ffb1e 	bne	r2,zero,20253fc <__alt_mem_mem_0+0xfd0053fc>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2025410:	e0bffe17 	ldw	r2,-8(fp)
 2025414:	10800317 	ldw	r2,12(r2)
 2025418:	10800404 	addi	r2,r2,16
 202541c:	e0fffe17 	ldw	r3,-8(fp)
 2025420:	18c00317 	ldw	r3,12(r3)
 2025424:	18c00404 	addi	r3,r3,16
 2025428:	19000037 	ldwio	r4,0(r3)
 202542c:	00fff7c4 	movi	r3,-33
 2025430:	20c6703a 	and	r3,r4,r3
 2025434:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2025438:	e0bffe17 	ldw	r2,-8(fp)
 202543c:	10800317 	ldw	r2,12(r2)
 2025440:	00c03fc4 	movi	r3,255
 2025444:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 2025448:	e0bffe17 	ldw	r2,-8(fp)
 202544c:	10800317 	ldw	r2,12(r2)
 2025450:	10800804 	addi	r2,r2,32
 2025454:	e0ffff17 	ldw	r3,-4(fp)
 2025458:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 202545c:	e0bffe17 	ldw	r2,-8(fp)
 2025460:	10800317 	ldw	r2,12(r2)
 2025464:	10800404 	addi	r2,r2,16
 2025468:	e0fffe17 	ldw	r3,-8(fp)
 202546c:	18c00317 	ldw	r3,12(r3)
 2025470:	18c00404 	addi	r3,r3,16
 2025474:	18c00037 	ldwio	r3,0(r3)
 2025478:	18c01814 	ori	r3,r3,96
 202547c:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 2025480:	0001883a 	nop
 2025484:	e0bffe17 	ldw	r2,-8(fp)
 2025488:	10800317 	ldw	r2,12(r2)
 202548c:	10800037 	ldwio	r2,0(r2)
 2025490:	1080040c 	andi	r2,r2,16
 2025494:	103ffb1e 	bne	r2,zero,2025484 <__alt_mem_mem_0+0xfd005484>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 2025498:	e0bffe17 	ldw	r2,-8(fp)
 202549c:	10800317 	ldw	r2,12(r2)
 20254a0:	10800404 	addi	r2,r2,16
 20254a4:	e0fffe17 	ldw	r3,-8(fp)
 20254a8:	18c00317 	ldw	r3,12(r3)
 20254ac:	18c00404 	addi	r3,r3,16
 20254b0:	19000037 	ldwio	r4,0(r3)
 20254b4:	00fff7c4 	movi	r3,-33
 20254b8:	20c6703a 	and	r3,r4,r3
 20254bc:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 20254c0:	e0bffe17 	ldw	r2,-8(fp)
 20254c4:	10800317 	ldw	r2,12(r2)
 20254c8:	10800037 	ldwio	r2,0(r2)
 20254cc:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 20254d0:	e0bffe17 	ldw	r2,-8(fp)
 20254d4:	10800317 	ldw	r2,12(r2)
 20254d8:	00c03fc4 	movi	r3,255
 20254dc:	10c00035 	stwio	r3,0(r2)

  return status;
 20254e0:	e0bffd03 	ldbu	r2,-12(fp)
}
 20254e4:	e037883a 	mov	sp,fp
 20254e8:	df000017 	ldw	fp,0(sp)
 20254ec:	dec00104 	addi	sp,sp,4
 20254f0:	f800283a 	ret

020254f4 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 20254f4:	defff404 	addi	sp,sp,-48
 20254f8:	dfc00b15 	stw	ra,44(sp)
 20254fc:	df000a15 	stw	fp,40(sp)
 2025500:	df000a04 	addi	fp,sp,40
 2025504:	e13ffb15 	stw	r4,-20(fp)
 2025508:	e17ffc15 	stw	r5,-16(fp)
 202550c:	e1bffd15 	stw	r6,-12(fp)
 2025510:	e1fffe15 	stw	r7,-8(fp)
 2025514:	e0800217 	ldw	r2,8(fp)
 2025518:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 202551c:	e0bfff0b 	ldhu	r2,-4(fp)
 2025520:	d8000415 	stw	zero,16(sp)
 2025524:	d8000315 	stw	zero,12(sp)
 2025528:	e0c00417 	ldw	r3,16(fp)
 202552c:	d8c00215 	stw	r3,8(sp)
 2025530:	e0c00317 	ldw	r3,12(fp)
 2025534:	d8c00115 	stw	r3,4(sp)
 2025538:	d8800015 	stw	r2,0(sp)
 202553c:	e1fffe17 	ldw	r7,-8(fp)
 2025540:	e1bffd17 	ldw	r6,-12(fp)
 2025544:	e17ffc17 	ldw	r5,-16(fp)
 2025548:	e13ffb17 	ldw	r4,-20(fp)
 202554c:	20255680 	call	2025568 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 2025550:	0001883a 	nop
 2025554:	e037883a 	mov	sp,fp
 2025558:	dfc00117 	ldw	ra,4(sp)
 202555c:	df000017 	ldw	fp,0(sp)
 2025560:	dec00204 	addi	sp,sp,8
 2025564:	f800283a 	ret

02025568 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 2025568:	defff204 	addi	sp,sp,-56
 202556c:	dfc00d15 	stw	ra,52(sp)
 2025570:	df000c15 	stw	fp,48(sp)
 2025574:	df000c04 	addi	fp,sp,48
 2025578:	e13ffb15 	stw	r4,-20(fp)
 202557c:	e17ffc15 	stw	r5,-16(fp)
 2025580:	e1bffd15 	stw	r6,-12(fp)
 2025584:	e1fffe15 	stw	r7,-8(fp)
 2025588:	e0800217 	ldw	r2,8(fp)
 202558c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 2025590:	e0bfff0b 	ldhu	r2,-4(fp)
 2025594:	d8000615 	stw	zero,24(sp)
 2025598:	e0c00617 	ldw	r3,24(fp)
 202559c:	d8c00515 	stw	r3,20(sp)
 20255a0:	e0c00517 	ldw	r3,20(fp)
 20255a4:	d8c00415 	stw	r3,16(sp)
 20255a8:	e0c00417 	ldw	r3,16(fp)
 20255ac:	d8c00315 	stw	r3,12(sp)
 20255b0:	e0c00317 	ldw	r3,12(fp)
 20255b4:	d8c00215 	stw	r3,8(sp)
 20255b8:	d8000115 	stw	zero,4(sp)
 20255bc:	d8800015 	stw	r2,0(sp)
 20255c0:	e1fffe17 	ldw	r7,-8(fp)
 20255c4:	e1bffd17 	ldw	r6,-12(fp)
 20255c8:	e17ffc17 	ldw	r5,-16(fp)
 20255cc:	e13ffb17 	ldw	r4,-20(fp)
 20255d0:	2025afc0 	call	2025afc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 20255d4:	0001883a 	nop
 20255d8:	e037883a 	mov	sp,fp
 20255dc:	dfc00117 	ldw	ra,4(sp)
 20255e0:	df000017 	ldw	fp,0(sp)
 20255e4:	dec00204 	addi	sp,sp,8
 20255e8:	f800283a 	ret

020255ec <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 20255ec:	defff804 	addi	sp,sp,-32
 20255f0:	dfc00715 	stw	ra,28(sp)
 20255f4:	df000615 	stw	fp,24(sp)
 20255f8:	df000604 	addi	fp,sp,24
 20255fc:	e13ffc15 	stw	r4,-16(fp)
 2025600:	e17ffd15 	stw	r5,-12(fp)
 2025604:	e1bffe15 	stw	r6,-8(fp)
 2025608:	3805883a 	mov	r2,r7
 202560c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 2025610:	e0ffff0b 	ldhu	r3,-4(fp)
 2025614:	d8000115 	stw	zero,4(sp)
 2025618:	e0800217 	ldw	r2,8(fp)
 202561c:	d8800015 	stw	r2,0(sp)
 2025620:	180f883a 	mov	r7,r3
 2025624:	e1bffe17 	ldw	r6,-8(fp)
 2025628:	e17ffd17 	ldw	r5,-12(fp)
 202562c:	e13ffc17 	ldw	r4,-16(fp)
 2025630:	202564c0 	call	202564c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 2025634:	0001883a 	nop
 2025638:	e037883a 	mov	sp,fp
 202563c:	dfc00117 	ldw	ra,4(sp)
 2025640:	df000017 	ldw	fp,0(sp)
 2025644:	dec00204 	addi	sp,sp,8
 2025648:	f800283a 	ret

0202564c <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 202564c:	defff304 	addi	sp,sp,-52
 2025650:	dfc00c15 	stw	ra,48(sp)
 2025654:	df000b15 	stw	fp,44(sp)
 2025658:	df000b04 	addi	fp,sp,44
 202565c:	e13ffc15 	stw	r4,-16(fp)
 2025660:	e17ffd15 	stw	r5,-12(fp)
 2025664:	e1bffe15 	stw	r6,-8(fp)
 2025668:	3805883a 	mov	r2,r7
 202566c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 2025670:	e0bfff0b 	ldhu	r2,-4(fp)
 2025674:	d8000615 	stw	zero,24(sp)
 2025678:	e0c00317 	ldw	r3,12(fp)
 202567c:	d8c00515 	stw	r3,20(sp)
 2025680:	d8000415 	stw	zero,16(sp)
 2025684:	e0c00217 	ldw	r3,8(fp)
 2025688:	d8c00315 	stw	r3,12(sp)
 202568c:	d8000215 	stw	zero,8(sp)
 2025690:	d8000115 	stw	zero,4(sp)
 2025694:	d8800015 	stw	r2,0(sp)
 2025698:	e1fffe17 	ldw	r7,-8(fp)
 202569c:	000d883a 	mov	r6,zero
 20256a0:	e17ffd17 	ldw	r5,-12(fp)
 20256a4:	e13ffc17 	ldw	r4,-16(fp)
 20256a8:	2025afc0 	call	2025afc <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 20256ac:	0001883a 	nop
 20256b0:	e037883a 	mov	sp,fp
 20256b4:	dfc00117 	ldw	ra,4(sp)
 20256b8:	df000017 	ldw	fp,0(sp)
 20256bc:	dec00204 	addi	sp,sp,8
 20256c0:	f800283a 	ret

020256c4 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 20256c4:	defff404 	addi	sp,sp,-48
 20256c8:	dfc00b15 	stw	ra,44(sp)
 20256cc:	df000a15 	stw	fp,40(sp)
 20256d0:	df000a04 	addi	fp,sp,40
 20256d4:	e13ffb15 	stw	r4,-20(fp)
 20256d8:	e17ffc15 	stw	r5,-16(fp)
 20256dc:	e1bffd15 	stw	r6,-12(fp)
 20256e0:	3807883a 	mov	r3,r7
 20256e4:	e0800517 	ldw	r2,20(fp)
 20256e8:	e0fffe0d 	sth	r3,-8(fp)
 20256ec:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 20256f0:	e0fffe0b 	ldhu	r3,-8(fp)
 20256f4:	e0bfff03 	ldbu	r2,-4(fp)
 20256f8:	d8800415 	stw	r2,16(sp)
 20256fc:	d8000315 	stw	zero,12(sp)
 2025700:	e0800417 	ldw	r2,16(fp)
 2025704:	d8800215 	stw	r2,8(sp)
 2025708:	e0800317 	ldw	r2,12(fp)
 202570c:	d8800115 	stw	r2,4(sp)
 2025710:	e0800217 	ldw	r2,8(fp)
 2025714:	d8800015 	stw	r2,0(sp)
 2025718:	180f883a 	mov	r7,r3
 202571c:	e1bffd17 	ldw	r6,-12(fp)
 2025720:	e17ffc17 	ldw	r5,-16(fp)
 2025724:	e13ffb17 	ldw	r4,-20(fp)
 2025728:	20257440 	call	2025744 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 202572c:	0001883a 	nop
 2025730:	e037883a 	mov	sp,fp
 2025734:	dfc00117 	ldw	ra,4(sp)
 2025738:	df000017 	ldw	fp,0(sp)
 202573c:	dec00204 	addi	sp,sp,8
 2025740:	f800283a 	ret

02025744 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 2025744:	defff204 	addi	sp,sp,-56
 2025748:	dfc00d15 	stw	ra,52(sp)
 202574c:	df000c15 	stw	fp,48(sp)
 2025750:	df000c04 	addi	fp,sp,48
 2025754:	e13ffb15 	stw	r4,-20(fp)
 2025758:	e17ffc15 	stw	r5,-16(fp)
 202575c:	e1bffd15 	stw	r6,-12(fp)
 2025760:	3807883a 	mov	r3,r7
 2025764:	e0800617 	ldw	r2,24(fp)
 2025768:	e0fffe0d 	sth	r3,-8(fp)
 202576c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 2025770:	e0bffe0b 	ldhu	r2,-8(fp)
 2025774:	e0ffff03 	ldbu	r3,-4(fp)
 2025778:	d8c00615 	stw	r3,24(sp)
 202577c:	d8000515 	stw	zero,20(sp)
 2025780:	e0c00517 	ldw	r3,20(fp)
 2025784:	d8c00415 	stw	r3,16(sp)
 2025788:	e0c00317 	ldw	r3,12(fp)
 202578c:	d8c00315 	stw	r3,12(sp)
 2025790:	e0c00217 	ldw	r3,8(fp)
 2025794:	d8c00215 	stw	r3,8(sp)
 2025798:	e0c00417 	ldw	r3,16(fp)
 202579c:	d8c00115 	stw	r3,4(sp)
 20257a0:	d8800015 	stw	r2,0(sp)
 20257a4:	000f883a 	mov	r7,zero
 20257a8:	e1bffd17 	ldw	r6,-12(fp)
 20257ac:	e17ffc17 	ldw	r5,-16(fp)
 20257b0:	e13ffb17 	ldw	r4,-20(fp)
 20257b4:	2025afc0 	call	2025afc <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 20257b8:	0001883a 	nop
 20257bc:	e037883a 	mov	sp,fp
 20257c0:	dfc00117 	ldw	ra,4(sp)
 20257c4:	df000017 	ldw	fp,0(sp)
 20257c8:	dec00204 	addi	sp,sp,8
 20257cc:	f800283a 	ret

020257d0 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 20257d0:	defffb04 	addi	sp,sp,-20
 20257d4:	df000415 	stw	fp,16(sp)
 20257d8:	df000404 	addi	fp,sp,16
 20257dc:	e13ffc15 	stw	r4,-16(fp)
 20257e0:	e17ffd15 	stw	r5,-12(fp)
 20257e4:	e1bffe15 	stw	r6,-8(fp)
 20257e8:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 20257ec:	e0bffc17 	ldw	r2,-16(fp)
 20257f0:	e0fffd17 	ldw	r3,-12(fp)
 20257f4:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 20257f8:	e0bffc17 	ldw	r2,-16(fp)
 20257fc:	e0ffff17 	ldw	r3,-4(fp)
 2025800:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 2025804:	e0bffc17 	ldw	r2,-16(fp)
 2025808:	e0fffe17 	ldw	r3,-8(fp)
 202580c:	10c00b15 	stw	r3,44(r2)
}
 2025810:	0001883a 	nop
 2025814:	e037883a 	mov	sp,fp
 2025818:	df000017 	ldw	fp,0(sp)
 202581c:	dec00104 	addi	sp,sp,4
 2025820:	f800283a 	ret

02025824 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 2025824:	defffd04 	addi	sp,sp,-12
 2025828:	df000215 	stw	fp,8(sp)
 202582c:	df000204 	addi	fp,sp,8
 2025830:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2025834:	e0bfff17 	ldw	r2,-4(fp)
 2025838:	10800317 	ldw	r2,12(r2)
 202583c:	10800404 	addi	r2,r2,16
 2025840:	10800037 	ldwio	r2,0(r2)
 2025844:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 2025848:	e0bffe17 	ldw	r2,-8(fp)
 202584c:	10800814 	ori	r2,r2,32
 2025850:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2025854:	e0bfff17 	ldw	r2,-4(fp)
 2025858:	10800317 	ldw	r2,12(r2)
 202585c:	10800404 	addi	r2,r2,16
 2025860:	e0fffe17 	ldw	r3,-8(fp)
 2025864:	10c00035 	stwio	r3,0(r2)
}
 2025868:	0001883a 	nop
 202586c:	e037883a 	mov	sp,fp
 2025870:	df000017 	ldw	fp,0(sp)
 2025874:	dec00104 	addi	sp,sp,4
 2025878:	f800283a 	ret

0202587c <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 202587c:	defffd04 	addi	sp,sp,-12
 2025880:	df000215 	stw	fp,8(sp)
 2025884:	df000204 	addi	fp,sp,8
 2025888:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202588c:	e0bfff17 	ldw	r2,-4(fp)
 2025890:	10800317 	ldw	r2,12(r2)
 2025894:	10800404 	addi	r2,r2,16
 2025898:	10800037 	ldwio	r2,0(r2)
 202589c:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 20258a0:	e0fffe17 	ldw	r3,-8(fp)
 20258a4:	00bff7c4 	movi	r2,-33
 20258a8:	1884703a 	and	r2,r3,r2
 20258ac:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 20258b0:	e0bfff17 	ldw	r2,-4(fp)
 20258b4:	10800317 	ldw	r2,12(r2)
 20258b8:	10800404 	addi	r2,r2,16
 20258bc:	e0fffe17 	ldw	r3,-8(fp)
 20258c0:	10c00035 	stwio	r3,0(r2)
}
 20258c4:	0001883a 	nop
 20258c8:	e037883a 	mov	sp,fp
 20258cc:	df000017 	ldw	fp,0(sp)
 20258d0:	dec00104 	addi	sp,sp,4
 20258d4:	f800283a 	ret

020258d8 <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 20258d8:	defffe04 	addi	sp,sp,-8
 20258dc:	df000115 	stw	fp,4(sp)
 20258e0:	df000104 	addi	fp,sp,4
 20258e4:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 20258e8:	e0bfff17 	ldw	r2,-4(fp)
 20258ec:	10800784 	addi	r2,r2,30
 20258f0:	10800023 	ldbuio	r2,0(r2)
 20258f4:	10803fcc 	andi	r2,r2,255
 20258f8:	10801fcc 	andi	r2,r2,127
 20258fc:	10000226 	beq	r2,zero,2025908 <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 2025900:	00bffec4 	movi	r2,-5
 2025904:	00000906 	br	202592c <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 2025908:	e0bfff17 	ldw	r2,-4(fp)
 202590c:	108007c4 	addi	r2,r2,31
 2025910:	10800023 	ldbuio	r2,0(r2)
 2025914:	10803fcc 	andi	r2,r2,255
 2025918:	1080200c 	andi	r2,r2,128
 202591c:	10000226 	beq	r2,zero,2025928 <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 2025920:	00bfe244 	movi	r2,-119
 2025924:	00000106 	br	202592c <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 2025928:	0005883a 	mov	r2,zero
}
 202592c:	e037883a 	mov	sp,fp
 2025930:	df000017 	ldw	fp,0(sp)
 2025934:	dec00104 	addi	sp,sp,4
 2025938:	f800283a 	ret

0202593c <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 202593c:	defffc04 	addi	sp,sp,-16
 2025940:	dfc00315 	stw	ra,12(sp)
 2025944:	df000215 	stw	fp,8(sp)
 2025948:	df000204 	addi	fp,sp,8
 202594c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 2025950:	d1601704 	addi	r5,gp,-32676
 2025954:	e13fff17 	ldw	r4,-4(fp)
 2025958:	202c7040 	call	202c704 <alt_find_dev>
 202595c:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 2025960:	e0bffe17 	ldw	r2,-8(fp)
 2025964:	1000041e 	bne	r2,zero,2025978 <alt_avalon_sgdma_open+0x3c>
    ALT_ERRNO = ENODEV;
 2025968:	20252840 	call	2025284 <alt_get_errno>
 202596c:	1007883a 	mov	r3,r2
 2025970:	008004c4 	movi	r2,19
 2025974:	18800015 	stw	r2,0(r3)
  }

  return dev;
 2025978:	e0bffe17 	ldw	r2,-8(fp)
}
 202597c:	e037883a 	mov	sp,fp
 2025980:	dfc00117 	ldw	ra,4(sp)
 2025984:	df000017 	ldw	fp,0(sp)
 2025988:	dec00204 	addi	sp,sp,8
 202598c:	f800283a 	ret

02025990 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 2025990:	defff104 	addi	sp,sp,-60
 2025994:	dfc00e15 	stw	ra,56(sp)
 2025998:	df000d15 	stw	fp,52(sp)
 202599c:	df000d04 	addi	fp,sp,52
 20259a0:	e13ffa15 	stw	r4,-24(fp)
 20259a4:	e17ffb15 	stw	r5,-20(fp)
 20259a8:	e1bffc15 	stw	r6,-16(fp)
 20259ac:	e1fffd15 	stw	r7,-12(fp)
 20259b0:	e0c00217 	ldw	r3,8(fp)
 20259b4:	e0800617 	ldw	r2,24(fp)
 20259b8:	e0fffe0d 	sth	r3,-8(fp)
 20259bc:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 20259c0:	e0bffe0b 	ldhu	r2,-8(fp)
 20259c4:	e0ffff03 	ldbu	r3,-4(fp)
 20259c8:	d8c00615 	stw	r3,24(sp)
 20259cc:	d8000515 	stw	zero,20(sp)
 20259d0:	d8000415 	stw	zero,16(sp)
 20259d4:	e0c00517 	ldw	r3,20(fp)
 20259d8:	d8c00315 	stw	r3,12(sp)
 20259dc:	e0c00417 	ldw	r3,16(fp)
 20259e0:	d8c00215 	stw	r3,8(sp)
 20259e4:	e0c00317 	ldw	r3,12(fp)
 20259e8:	d8c00115 	stw	r3,4(sp)
 20259ec:	d8800015 	stw	r2,0(sp)
 20259f0:	e1fffd17 	ldw	r7,-12(fp)
 20259f4:	e1bffc17 	ldw	r6,-16(fp)
 20259f8:	e17ffb17 	ldw	r5,-20(fp)
 20259fc:	e13ffa17 	ldw	r4,-24(fp)
 2025a00:	2025afc0 	call	2025afc <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 2025a04:	0001883a 	nop
 2025a08:	e037883a 	mov	sp,fp
 2025a0c:	dfc00117 	ldw	ra,4(sp)
 2025a10:	df000017 	ldw	fp,0(sp)
 2025a14:	dec00204 	addi	sp,sp,8
 2025a18:	f800283a 	ret

02025a1c <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 2025a1c:	defffc04 	addi	sp,sp,-16
 2025a20:	df000315 	stw	fp,12(sp)
 2025a24:	df000304 	addi	fp,sp,12
 2025a28:	e13ffe15 	stw	r4,-8(fp)
 2025a2c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2025a30:	e0bffe17 	ldw	r2,-8(fp)
 2025a34:	10800317 	ldw	r2,12(r2)
 2025a38:	10800404 	addi	r2,r2,16
 2025a3c:	10800037 	ldwio	r2,0(r2)
 2025a40:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 2025a44:	e0fffd17 	ldw	r3,-12(fp)
 2025a48:	00a00434 	movhi	r2,32784
 2025a4c:	10bfffc4 	addi	r2,r2,-1
 2025a50:	1884703a 	and	r2,r3,r2
 2025a54:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 2025a58:	e0bfff17 	ldw	r2,-4(fp)
 2025a5c:	1004953a 	slli	r2,r2,20
 2025a60:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 2025a64:	e0bffd17 	ldw	r2,-12(fp)
 2025a68:	1884b03a 	or	r2,r3,r2
 2025a6c:	10800134 	orhi	r2,r2,4
 2025a70:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2025a74:	e0bffe17 	ldw	r2,-8(fp)
 2025a78:	10800317 	ldw	r2,12(r2)
 2025a7c:	10800404 	addi	r2,r2,16
 2025a80:	e0fffd17 	ldw	r3,-12(fp)
 2025a84:	10c00035 	stwio	r3,0(r2)
  
  return;
 2025a88:	0001883a 	nop
}
 2025a8c:	e037883a 	mov	sp,fp
 2025a90:	df000017 	ldw	fp,0(sp)
 2025a94:	dec00104 	addi	sp,sp,4
 2025a98:	f800283a 	ret

02025a9c <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 2025a9c:	defffd04 	addi	sp,sp,-12
 2025aa0:	df000215 	stw	fp,8(sp)
 2025aa4:	df000204 	addi	fp,sp,8
 2025aa8:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2025aac:	e0bfff17 	ldw	r2,-4(fp)
 2025ab0:	10800317 	ldw	r2,12(r2)
 2025ab4:	10800404 	addi	r2,r2,16
 2025ab8:	10800037 	ldwio	r2,0(r2)
 2025abc:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 2025ac0:	e0fffe17 	ldw	r3,-8(fp)
 2025ac4:	00bfff34 	movhi	r2,65532
 2025ac8:	10bfffc4 	addi	r2,r2,-1
 2025acc:	1884703a 	and	r2,r3,r2
 2025ad0:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2025ad4:	e0bfff17 	ldw	r2,-4(fp)
 2025ad8:	10800317 	ldw	r2,12(r2)
 2025adc:	10800404 	addi	r2,r2,16
 2025ae0:	e0fffe17 	ldw	r3,-8(fp)
 2025ae4:	10c00035 	stwio	r3,0(r2)
  
  return;
 2025ae8:	0001883a 	nop
}
 2025aec:	e037883a 	mov	sp,fp
 2025af0:	df000017 	ldw	fp,0(sp)
 2025af4:	dec00104 	addi	sp,sp,4
 2025af8:	f800283a 	ret

02025afc <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 2025afc:	defff804 	addi	sp,sp,-32
 2025b00:	dfc00715 	stw	ra,28(sp)
 2025b04:	df000615 	stw	fp,24(sp)
 2025b08:	df000604 	addi	fp,sp,24
 2025b0c:	e13ffa15 	stw	r4,-24(fp)
 2025b10:	e17ffb15 	stw	r5,-20(fp)
 2025b14:	e1bffc15 	stw	r6,-16(fp)
 2025b18:	e1fffd15 	stw	r7,-12(fp)
 2025b1c:	e0c00217 	ldw	r3,8(fp)
 2025b20:	e0800817 	ldw	r2,32(fp)
 2025b24:	e0fffe0d 	sth	r3,-8(fp)
 2025b28:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 2025b2c:	e0bffb17 	ldw	r2,-20(fp)
 2025b30:	108007c4 	addi	r2,r2,31
 2025b34:	e0fffb17 	ldw	r3,-20(fp)
 2025b38:	18c007c3 	ldbu	r3,31(r3)
 2025b3c:	19003fcc 	andi	r4,r3,255
 2025b40:	00ffdfc4 	movi	r3,-129
 2025b44:	20c6703a 	and	r3,r4,r3
 2025b48:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 2025b4c:	e0bffa17 	ldw	r2,-24(fp)
 2025b50:	e0fffc17 	ldw	r3,-16(fp)
 2025b54:	19403fcc 	andi	r5,r3,255
 2025b58:	10c00003 	ldbu	r3,0(r2)
 2025b5c:	1806703a 	and	r3,r3,zero
 2025b60:	1809883a 	mov	r4,r3
 2025b64:	2807883a 	mov	r3,r5
 2025b68:	20c6b03a 	or	r3,r4,r3
 2025b6c:	10c00005 	stb	r3,0(r2)
 2025b70:	e0fffc17 	ldw	r3,-16(fp)
 2025b74:	1806d23a 	srli	r3,r3,8
 2025b78:	19403fcc 	andi	r5,r3,255
 2025b7c:	10c00043 	ldbu	r3,1(r2)
 2025b80:	1806703a 	and	r3,r3,zero
 2025b84:	1809883a 	mov	r4,r3
 2025b88:	2807883a 	mov	r3,r5
 2025b8c:	20c6b03a 	or	r3,r4,r3
 2025b90:	10c00045 	stb	r3,1(r2)
 2025b94:	e0fffc17 	ldw	r3,-16(fp)
 2025b98:	1806d43a 	srli	r3,r3,16
 2025b9c:	19403fcc 	andi	r5,r3,255
 2025ba0:	10c00083 	ldbu	r3,2(r2)
 2025ba4:	1806703a 	and	r3,r3,zero
 2025ba8:	1809883a 	mov	r4,r3
 2025bac:	2807883a 	mov	r3,r5
 2025bb0:	20c6b03a 	or	r3,r4,r3
 2025bb4:	10c00085 	stb	r3,2(r2)
 2025bb8:	e0fffc17 	ldw	r3,-16(fp)
 2025bbc:	180ad63a 	srli	r5,r3,24
 2025bc0:	10c000c3 	ldbu	r3,3(r2)
 2025bc4:	1806703a 	and	r3,r3,zero
 2025bc8:	1809883a 	mov	r4,r3
 2025bcc:	2807883a 	mov	r3,r5
 2025bd0:	20c6b03a 	or	r3,r4,r3
 2025bd4:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 2025bd8:	e0bffa17 	ldw	r2,-24(fp)
 2025bdc:	e0fffd17 	ldw	r3,-12(fp)
 2025be0:	19403fcc 	andi	r5,r3,255
 2025be4:	10c00203 	ldbu	r3,8(r2)
 2025be8:	1806703a 	and	r3,r3,zero
 2025bec:	1809883a 	mov	r4,r3
 2025bf0:	2807883a 	mov	r3,r5
 2025bf4:	20c6b03a 	or	r3,r4,r3
 2025bf8:	10c00205 	stb	r3,8(r2)
 2025bfc:	e0fffd17 	ldw	r3,-12(fp)
 2025c00:	1806d23a 	srli	r3,r3,8
 2025c04:	19403fcc 	andi	r5,r3,255
 2025c08:	10c00243 	ldbu	r3,9(r2)
 2025c0c:	1806703a 	and	r3,r3,zero
 2025c10:	1809883a 	mov	r4,r3
 2025c14:	2807883a 	mov	r3,r5
 2025c18:	20c6b03a 	or	r3,r4,r3
 2025c1c:	10c00245 	stb	r3,9(r2)
 2025c20:	e0fffd17 	ldw	r3,-12(fp)
 2025c24:	1806d43a 	srli	r3,r3,16
 2025c28:	19403fcc 	andi	r5,r3,255
 2025c2c:	10c00283 	ldbu	r3,10(r2)
 2025c30:	1806703a 	and	r3,r3,zero
 2025c34:	1809883a 	mov	r4,r3
 2025c38:	2807883a 	mov	r3,r5
 2025c3c:	20c6b03a 	or	r3,r4,r3
 2025c40:	10c00285 	stb	r3,10(r2)
 2025c44:	e0fffd17 	ldw	r3,-12(fp)
 2025c48:	180ad63a 	srli	r5,r3,24
 2025c4c:	10c002c3 	ldbu	r3,11(r2)
 2025c50:	1806703a 	and	r3,r3,zero
 2025c54:	1809883a 	mov	r4,r3
 2025c58:	2807883a 	mov	r3,r5
 2025c5c:	20c6b03a 	or	r3,r4,r3
 2025c60:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 2025c64:	e0bffa17 	ldw	r2,-24(fp)
 2025c68:	e0fffb17 	ldw	r3,-20(fp)
 2025c6c:	19403fcc 	andi	r5,r3,255
 2025c70:	10c00403 	ldbu	r3,16(r2)
 2025c74:	1806703a 	and	r3,r3,zero
 2025c78:	1809883a 	mov	r4,r3
 2025c7c:	2807883a 	mov	r3,r5
 2025c80:	20c6b03a 	or	r3,r4,r3
 2025c84:	10c00405 	stb	r3,16(r2)
 2025c88:	e0fffb17 	ldw	r3,-20(fp)
 2025c8c:	1806d23a 	srli	r3,r3,8
 2025c90:	19403fcc 	andi	r5,r3,255
 2025c94:	10c00443 	ldbu	r3,17(r2)
 2025c98:	1806703a 	and	r3,r3,zero
 2025c9c:	1809883a 	mov	r4,r3
 2025ca0:	2807883a 	mov	r3,r5
 2025ca4:	20c6b03a 	or	r3,r4,r3
 2025ca8:	10c00445 	stb	r3,17(r2)
 2025cac:	e0fffb17 	ldw	r3,-20(fp)
 2025cb0:	1806d43a 	srli	r3,r3,16
 2025cb4:	19403fcc 	andi	r5,r3,255
 2025cb8:	10c00483 	ldbu	r3,18(r2)
 2025cbc:	1806703a 	and	r3,r3,zero
 2025cc0:	1809883a 	mov	r4,r3
 2025cc4:	2807883a 	mov	r3,r5
 2025cc8:	20c6b03a 	or	r3,r4,r3
 2025ccc:	10c00485 	stb	r3,18(r2)
 2025cd0:	e0fffb17 	ldw	r3,-20(fp)
 2025cd4:	180ad63a 	srli	r5,r3,24
 2025cd8:	10c004c3 	ldbu	r3,19(r2)
 2025cdc:	1806703a 	and	r3,r3,zero
 2025ce0:	1809883a 	mov	r4,r3
 2025ce4:	2807883a 	mov	r3,r5
 2025ce8:	20c6b03a 	or	r3,r4,r3
 2025cec:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 2025cf0:	e0bffa17 	ldw	r2,-24(fp)
 2025cf4:	10c00103 	ldbu	r3,4(r2)
 2025cf8:	1806703a 	and	r3,r3,zero
 2025cfc:	10c00105 	stb	r3,4(r2)
 2025d00:	10c00143 	ldbu	r3,5(r2)
 2025d04:	1806703a 	and	r3,r3,zero
 2025d08:	10c00145 	stb	r3,5(r2)
 2025d0c:	10c00183 	ldbu	r3,6(r2)
 2025d10:	1806703a 	and	r3,r3,zero
 2025d14:	10c00185 	stb	r3,6(r2)
 2025d18:	10c001c3 	ldbu	r3,7(r2)
 2025d1c:	1806703a 	and	r3,r3,zero
 2025d20:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 2025d24:	e0bffa17 	ldw	r2,-24(fp)
 2025d28:	10c00303 	ldbu	r3,12(r2)
 2025d2c:	1806703a 	and	r3,r3,zero
 2025d30:	10c00305 	stb	r3,12(r2)
 2025d34:	10c00343 	ldbu	r3,13(r2)
 2025d38:	1806703a 	and	r3,r3,zero
 2025d3c:	10c00345 	stb	r3,13(r2)
 2025d40:	10c00383 	ldbu	r3,14(r2)
 2025d44:	1806703a 	and	r3,r3,zero
 2025d48:	10c00385 	stb	r3,14(r2)
 2025d4c:	10c003c3 	ldbu	r3,15(r2)
 2025d50:	1806703a 	and	r3,r3,zero
 2025d54:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 2025d58:	e0bffa17 	ldw	r2,-24(fp)
 2025d5c:	10c00503 	ldbu	r3,20(r2)
 2025d60:	1806703a 	and	r3,r3,zero
 2025d64:	10c00505 	stb	r3,20(r2)
 2025d68:	10c00543 	ldbu	r3,21(r2)
 2025d6c:	1806703a 	and	r3,r3,zero
 2025d70:	10c00545 	stb	r3,21(r2)
 2025d74:	10c00583 	ldbu	r3,22(r2)
 2025d78:	1806703a 	and	r3,r3,zero
 2025d7c:	10c00585 	stb	r3,22(r2)
 2025d80:	10c005c3 	ldbu	r3,23(r2)
 2025d84:	1806703a 	and	r3,r3,zero
 2025d88:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 2025d8c:	e0bffa17 	ldw	r2,-24(fp)
 2025d90:	e0fffe17 	ldw	r3,-8(fp)
 2025d94:	19403fcc 	andi	r5,r3,255
 2025d98:	10c00603 	ldbu	r3,24(r2)
 2025d9c:	1806703a 	and	r3,r3,zero
 2025da0:	1809883a 	mov	r4,r3
 2025da4:	2807883a 	mov	r3,r5
 2025da8:	20c6b03a 	or	r3,r4,r3
 2025dac:	10c00605 	stb	r3,24(r2)
 2025db0:	e0fffe17 	ldw	r3,-8(fp)
 2025db4:	1806d23a 	srli	r3,r3,8
 2025db8:	19403fcc 	andi	r5,r3,255
 2025dbc:	10c00643 	ldbu	r3,25(r2)
 2025dc0:	1806703a 	and	r3,r3,zero
 2025dc4:	1809883a 	mov	r4,r3
 2025dc8:	2807883a 	mov	r3,r5
 2025dcc:	20c6b03a 	or	r3,r4,r3
 2025dd0:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 2025dd4:	e0bffa17 	ldw	r2,-24(fp)
 2025dd8:	10c00703 	ldbu	r3,28(r2)
 2025ddc:	1806703a 	and	r3,r3,zero
 2025de0:	10c00705 	stb	r3,28(r2)
 2025de4:	10c00743 	ldbu	r3,29(r2)
 2025de8:	1806703a 	and	r3,r3,zero
 2025dec:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 2025df0:	e0bffa17 	ldw	r2,-24(fp)
 2025df4:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 2025df8:	e0800617 	ldw	r2,24(fp)
 2025dfc:	1007883a 	mov	r3,r2
 2025e00:	e0bffa17 	ldw	r2,-24(fp)
 2025e04:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 2025e08:	e0800717 	ldw	r2,28(fp)
 2025e0c:	1007883a 	mov	r3,r2
 2025e10:	e0bffa17 	ldw	r2,-24(fp)
 2025e14:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 2025e18:	e0800317 	ldw	r2,12(fp)
 2025e1c:	10000226 	beq	r2,zero,2025e28 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 2025e20:	00bfe044 	movi	r2,-127
 2025e24:	00000106 	br	2025e2c <alt_avalon_sgdma_construct_descriptor_burst+0x330>
 2025e28:	00bfe004 	movi	r2,-128
 2025e2c:	e0c00417 	ldw	r3,16(fp)
 2025e30:	18000226 	beq	r3,zero,2025e3c <alt_avalon_sgdma_construct_descriptor_burst+0x340>
 2025e34:	00c00084 	movi	r3,2
 2025e38:	00000106 	br	2025e40 <alt_avalon_sgdma_construct_descriptor_burst+0x344>
 2025e3c:	0007883a 	mov	r3,zero
 2025e40:	10c4b03a 	or	r2,r2,r3
 2025e44:	1007883a 	mov	r3,r2
 2025e48:	e0800517 	ldw	r2,20(fp)
 2025e4c:	10000226 	beq	r2,zero,2025e58 <alt_avalon_sgdma_construct_descriptor_burst+0x35c>
 2025e50:	00800104 	movi	r2,4
 2025e54:	00000106 	br	2025e5c <alt_avalon_sgdma_construct_descriptor_burst+0x360>
 2025e58:	0005883a 	mov	r2,zero
 2025e5c:	1884b03a 	or	r2,r3,r2
 2025e60:	1007883a 	mov	r3,r2
 2025e64:	e0bfff03 	ldbu	r2,-4(fp)
 2025e68:	10000426 	beq	r2,zero,2025e7c <alt_avalon_sgdma_construct_descriptor_burst+0x380>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 2025e6c:	e0bfff03 	ldbu	r2,-4(fp)
 2025e70:	108003cc 	andi	r2,r2,15
 2025e74:	100490fa 	slli	r2,r2,3
 2025e78:	00000106 	br	2025e80 <alt_avalon_sgdma_construct_descriptor_burst+0x384>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 2025e7c:	0005883a 	mov	r2,zero
 2025e80:	1884b03a 	or	r2,r3,r2
 2025e84:	1007883a 	mov	r3,r2
 2025e88:	e0bffa17 	ldw	r2,-24(fp)
 2025e8c:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to.
   */
  alt_dcache_flush(desc, sizeof(alt_sgdma_descriptor));
 2025e90:	01400804 	movi	r5,32
 2025e94:	e13ffa17 	ldw	r4,-24(fp)
 2025e98:	202c5dc0 	call	202c5dc <alt_dcache_flush>
}
 2025e9c:	0001883a 	nop
 2025ea0:	e037883a 	mov	sp,fp
 2025ea4:	dfc00117 	ldw	ra,4(sp)
 2025ea8:	df000017 	ldw	fp,0(sp)
 2025eac:	dec00204 	addi	sp,sp,8
 2025eb0:	f800283a 	ret

02025eb4 <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 2025eb4:	defff904 	addi	sp,sp,-28
 2025eb8:	dfc00615 	stw	ra,24(sp)
 2025ebc:	df000515 	stw	fp,20(sp)
 2025ec0:	df000504 	addi	fp,sp,20
 2025ec4:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 2025ec8:	e0bfff17 	ldw	r2,-4(fp)
 2025ecc:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 2025ed0:	e0bffb17 	ldw	r2,-20(fp)
 2025ed4:	10800317 	ldw	r2,12(r2)
 2025ed8:	10800404 	addi	r2,r2,16
 2025edc:	e0fffb17 	ldw	r3,-20(fp)
 2025ee0:	18c00317 	ldw	r3,12(r3)
 2025ee4:	18c00404 	addi	r3,r3,16
 2025ee8:	18c00037 	ldwio	r3,0(r3)
 2025eec:	18e00034 	orhi	r3,r3,32768
 2025ef0:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2025ef4:	e0bffb17 	ldw	r2,-20(fp)
 2025ef8:	10800317 	ldw	r2,12(r2)
 2025efc:	10800404 	addi	r2,r2,16
 2025f00:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 2025f04:	e0bffb17 	ldw	r2,-20(fp)
 2025f08:	10800917 	ldw	r2,36(r2)
 2025f0c:	10001226 	beq	r2,zero,2025f58 <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2025f10:	0005303a 	rdctl	r2,status
 2025f14:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2025f18:	e0fffd17 	ldw	r3,-12(fp)
 2025f1c:	00bfff84 	movi	r2,-2
 2025f20:	1884703a 	and	r2,r3,r2
 2025f24:	1001703a 	wrctl	status,r2
  
  return context;
 2025f28:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 2025f2c:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 2025f30:	e0bffb17 	ldw	r2,-20(fp)
 2025f34:	10800917 	ldw	r2,36(r2)
 2025f38:	e0fffb17 	ldw	r3,-20(fp)
 2025f3c:	18c00a17 	ldw	r3,40(r3)
 2025f40:	1809883a 	mov	r4,r3
 2025f44:	103ee83a 	callr	r2
 2025f48:	e0bffc17 	ldw	r2,-16(fp)
 2025f4c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2025f50:	e0bffe17 	ldw	r2,-8(fp)
 2025f54:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 2025f58:	0001883a 	nop
 2025f5c:	e037883a 	mov	sp,fp
 2025f60:	dfc00117 	ldw	ra,4(sp)
 2025f64:	df000017 	ldw	fp,0(sp)
 2025f68:	dec00204 	addi	sp,sp,8
 2025f6c:	f800283a 	ret

02025f70 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 2025f70:	defffa04 	addi	sp,sp,-24
 2025f74:	dfc00515 	stw	ra,20(sp)
 2025f78:	df000415 	stw	fp,16(sp)
 2025f7c:	df000404 	addi	fp,sp,16
 2025f80:	e13ffd15 	stw	r4,-12(fp)
 2025f84:	e17ffe15 	stw	r5,-8(fp)
 2025f88:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2025f8c:	e0bffd17 	ldw	r2,-12(fp)
 2025f90:	10800317 	ldw	r2,12(r2)
 2025f94:	10800404 	addi	r2,r2,16
 2025f98:	00c00074 	movhi	r3,1
 2025f9c:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2025fa0:	e0bffd17 	ldw	r2,-12(fp)
 2025fa4:	10800317 	ldw	r2,12(r2)
 2025fa8:	10800404 	addi	r2,r2,16
 2025fac:	00c00074 	movhi	r3,1
 2025fb0:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 2025fb4:	e0bffd17 	ldw	r2,-12(fp)
 2025fb8:	10800317 	ldw	r2,12(r2)
 2025fbc:	10800404 	addi	r2,r2,16
 2025fc0:	0007883a 	mov	r3,zero
 2025fc4:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2025fc8:	e0bffd17 	ldw	r2,-12(fp)
 2025fcc:	10800317 	ldw	r2,12(r2)
 2025fd0:	00c03fc4 	movi	r3,255
 2025fd4:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 2025fd8:	d1601704 	addi	r5,gp,-32676
 2025fdc:	e13ffd17 	ldw	r4,-12(fp)
 2025fe0:	202c6600 	call	202c660 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 2025fe4:	d8000015 	stw	zero,0(sp)
 2025fe8:	e1fffd17 	ldw	r7,-12(fp)
 2025fec:	018080b4 	movhi	r6,514
 2025ff0:	3197ad04 	addi	r6,r6,24244
 2025ff4:	e17fff17 	ldw	r5,-4(fp)
 2025ff8:	e13ffe17 	ldw	r4,-8(fp)
 2025ffc:	202cba40 	call	202cba4 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 2026000:	0001883a 	nop
 2026004:	e037883a 	mov	sp,fp
 2026008:	dfc00117 	ldw	ra,4(sp)
 202600c:	df000017 	ldw	fp,0(sp)
 2026010:	dec00204 	addi	sp,sp,8
 2026014:	f800283a 	ret

02026018 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 2026018:	defffa04 	addi	sp,sp,-24
 202601c:	dfc00515 	stw	ra,20(sp)
 2026020:	df000415 	stw	fp,16(sp)
 2026024:	df000404 	addi	fp,sp,16
 2026028:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 202602c:	0007883a 	mov	r3,zero
 2026030:	e0bfff17 	ldw	r2,-4(fp)
 2026034:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 2026038:	e0bfff17 	ldw	r2,-4(fp)
 202603c:	10800104 	addi	r2,r2,4
 2026040:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2026044:	0005303a 	rdctl	r2,status
 2026048:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202604c:	e0fffd17 	ldw	r3,-12(fp)
 2026050:	00bfff84 	movi	r2,-2
 2026054:	1884703a 	and	r2,r3,r2
 2026058:	1001703a 	wrctl	status,r2
  
  return context;
 202605c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 2026060:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 2026064:	202d0180 	call	202d018 <alt_tick>
 2026068:	e0bffc17 	ldw	r2,-16(fp)
 202606c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2026070:	e0bffe17 	ldw	r2,-8(fp)
 2026074:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 2026078:	0001883a 	nop
 202607c:	e037883a 	mov	sp,fp
 2026080:	dfc00117 	ldw	ra,4(sp)
 2026084:	df000017 	ldw	fp,0(sp)
 2026088:	dec00204 	addi	sp,sp,8
 202608c:	f800283a 	ret

02026090 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 2026090:	defff804 	addi	sp,sp,-32
 2026094:	dfc00715 	stw	ra,28(sp)
 2026098:	df000615 	stw	fp,24(sp)
 202609c:	df000604 	addi	fp,sp,24
 20260a0:	e13ffc15 	stw	r4,-16(fp)
 20260a4:	e17ffd15 	stw	r5,-12(fp)
 20260a8:	e1bffe15 	stw	r6,-8(fp)
 20260ac:	e1ffff15 	stw	r7,-4(fp)
 20260b0:	e0bfff17 	ldw	r2,-4(fp)
 20260b4:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 20260b8:	d0a80a17 	ldw	r2,-24536(gp)
 20260bc:	1000021e 	bne	r2,zero,20260c8 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 20260c0:	e0bffb17 	ldw	r2,-20(fp)
 20260c4:	d0a80a15 	stw	r2,-24536(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 20260c8:	e0bffc17 	ldw	r2,-16(fp)
 20260cc:	10800104 	addi	r2,r2,4
 20260d0:	00c001c4 	movi	r3,7
 20260d4:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 20260d8:	d8000015 	stw	zero,0(sp)
 20260dc:	e1fffc17 	ldw	r7,-16(fp)
 20260e0:	018080b4 	movhi	r6,514
 20260e4:	31980604 	addi	r6,r6,24600
 20260e8:	e17ffe17 	ldw	r5,-8(fp)
 20260ec:	e13ffd17 	ldw	r4,-12(fp)
 20260f0:	202cba40 	call	202cba4 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 20260f4:	0001883a 	nop
 20260f8:	e037883a 	mov	sp,fp
 20260fc:	dfc00117 	ldw	ra,4(sp)
 2026100:	df000017 	ldw	fp,0(sp)
 2026104:	dec00204 	addi	sp,sp,8
 2026108:	f800283a 	ret

0202610c <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 202610c:	defffb04 	addi	sp,sp,-20
 2026110:	df000115 	stw	fp,4(sp)
 2026114:	df000104 	addi	fp,sp,4
 2026118:	e13fff15 	stw	r4,-4(fp)
 202611c:	e1400115 	stw	r5,4(fp)
 2026120:	e1800215 	stw	r6,8(fp)
 2026124:	e1c00315 	stw	r7,12(fp)
 2026128:	0001883a 	nop
 202612c:	e037883a 	mov	sp,fp
 2026130:	df000017 	ldw	fp,0(sp)
 2026134:	dec00404 	addi	sp,sp,16
 2026138:	f800283a 	ret

0202613c <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 202613c:	defffb04 	addi	sp,sp,-20
 2026140:	df000415 	stw	fp,16(sp)
 2026144:	df000404 	addi	fp,sp,16
 2026148:	e13ffc15 	stw	r4,-16(fp)
 202614c:	e17ffd15 	stw	r5,-12(fp)
 2026150:	e1bffe15 	stw	r6,-8(fp)
 2026154:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 2026158:	e0fffd17 	ldw	r3,-12(fp)
 202615c:	e0bffc17 	ldw	r2,-16(fp)
 2026160:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 2026164:	e0fffe17 	ldw	r3,-8(fp)
 2026168:	e0bffc17 	ldw	r2,-16(fp)
 202616c:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 2026170:	e0ffff17 	ldw	r3,-4(fp)
 2026174:	e0bffc17 	ldw	r2,-16(fp)
 2026178:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 202617c:	e0c00117 	ldw	r3,4(fp)
 2026180:	e0bffc17 	ldw	r2,-16(fp)
 2026184:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 2026188:	0005883a 	mov	r2,zero
}
 202618c:	e037883a 	mov	sp,fp
 2026190:	df000017 	ldw	fp,0(sp)
 2026194:	dec00104 	addi	sp,sp,4
 2026198:	f800283a 	ret

0202619c <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 202619c:	defffa04 	addi	sp,sp,-24
 20261a0:	dfc00515 	stw	ra,20(sp)
 20261a4:	df000415 	stw	fp,16(sp)
 20261a8:	df000404 	addi	fp,sp,16
 20261ac:	e13ffe15 	stw	r4,-8(fp)
 20261b0:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 20261b4:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 20261b8:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 20261bc:	00000b06 	br	20261ec <tse_mac_sTxWrite+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 20261c0:	e0fffc17 	ldw	r3,-16(fp)
 20261c4:	18800044 	addi	r2,r3,1
 20261c8:	e0bffc15 	stw	r2,-16(fp)
 20261cc:	008003f4 	movhi	r2,15
 20261d0:	10909004 	addi	r2,r2,16960
 20261d4:	1880051e 	bne	r3,r2,20261ec <tse_mac_sTxWrite+0x50>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 20261d8:	01008134 	movhi	r4,516
 20261dc:	21063f04 	addi	r4,r4,6396
 20261e0:	203ceb40 	call	203ceb4 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 20261e4:	00bffa84 	movi	r2,-22
 20261e8:	00002006 	br	202626c <tse_mac_sTxWrite+0xd0>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 20261ec:	e0bffe17 	ldw	r2,-8(fp)
 20261f0:	10800117 	ldw	r2,4(r2)
 20261f4:	10800317 	ldw	r2,12(r2)
 20261f8:	10800037 	ldwio	r2,0(r2)
 20261fc:	1080040c 	andi	r2,r2,16
 2026200:	103fef1e 	bne	r2,zero,20261c0 <__alt_mem_mem_0+0xfd0061c0>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 2026204:	e0bffe17 	ldw	r2,-8(fp)
 2026208:	10800117 	ldw	r2,4(r2)
 202620c:	10800317 	ldw	r2,12(r2)
 2026210:	10800404 	addi	r2,r2,16
 2026214:	0007883a 	mov	r3,zero
 2026218:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 202621c:	e0bffe17 	ldw	r2,-8(fp)
 2026220:	10800117 	ldw	r2,4(r2)
 2026224:	10800317 	ldw	r2,12(r2)
 2026228:	00c03fc4 	movi	r3,255
 202622c:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 2026230:	e0bffe17 	ldw	r2,-8(fp)
 2026234:	10800117 	ldw	r2,4(r2)
 2026238:	e17fff17 	ldw	r5,-4(fp)
 202623c:	1009883a 	mov	r4,r2
 2026240:	20253e40 	call	20253e4 <alt_avalon_sgdma_do_sync_transfer>
 2026244:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  if (result != 0)
 2026248:	e0bffd03 	ldbu	r2,-12(fp)
 202624c:	10000226 	beq	r2,zero,2026258 <tse_mac_sTxWrite+0xbc>
    return -1;
 2026250:	00bfffc4 	movi	r2,-1
 2026254:	00000506 	br	202626c <tse_mac_sTxWrite+0xd0>
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 2026258:	e0bfff17 	ldw	r2,-4(fp)
 202625c:	10800704 	addi	r2,r2,28
 2026260:	10800037 	ldwio	r2,0(r2)
 2026264:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 2026268:	e0bffd8b 	ldhu	r2,-10(fp)
}
 202626c:	e037883a 	mov	sp,fp
 2026270:	dfc00117 	ldw	ra,4(sp)
 2026274:	df000017 	ldw	fp,0(sp)
 2026278:	dec00204 	addi	sp,sp,8
 202627c:	f800283a 	ret

02026280 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 2026280:	defffa04 	addi	sp,sp,-24
 2026284:	dfc00515 	stw	ra,20(sp)
 2026288:	df000415 	stw	fp,16(sp)
 202628c:	df000404 	addi	fp,sp,16
 2026290:	e13ffe15 	stw	r4,-8(fp)
 2026294:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 2026298:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 202629c:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 20262a0:	00000b06 	br	20262d0 <tse_mac_aRxRead+0x50>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 20262a4:	e0fffc17 	ldw	r3,-16(fp)
 20262a8:	18800044 	addi	r2,r3,1
 20262ac:	e0bffc15 	stw	r2,-16(fp)
 20262b0:	008003f4 	movhi	r2,15
 20262b4:	10909004 	addi	r2,r2,16960
 20262b8:	1880051e 	bne	r3,r2,20262d0 <tse_mac_aRxRead+0x50>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 20262bc:	01008134 	movhi	r4,516
 20262c0:	21064604 	addi	r4,r4,6424
 20262c4:	203ceb40 	call	203ceb4 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 20262c8:	00bffa84 	movi	r2,-22
 20262cc:	00001106 	br	2026314 <tse_mac_aRxRead+0x94>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 20262d0:	e0bffe17 	ldw	r2,-8(fp)
 20262d4:	10800217 	ldw	r2,8(r2)
 20262d8:	10800317 	ldw	r2,12(r2)
 20262dc:	10800037 	ldwio	r2,0(r2)
 20262e0:	1080040c 	andi	r2,r2,16
 20262e4:	103fef1e 	bne	r2,zero,20262a4 <__alt_mem_mem_0+0xfd0062a4>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 20262e8:	e0bffe17 	ldw	r2,-8(fp)
 20262ec:	10800217 	ldw	r2,8(r2)
 20262f0:	e17fff17 	ldw	r5,-4(fp)
 20262f4:	1009883a 	mov	r4,r2
 20262f8:	20252c00 	call	20252c0 <alt_avalon_sgdma_do_async_transfer>
 20262fc:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);
  
  if (result != 0)
 2026300:	e0bffd03 	ldbu	r2,-12(fp)
 2026304:	10000226 	beq	r2,zero,2026310 <tse_mac_aRxRead+0x90>
    return -1;
 2026308:	00bfffc4 	movi	r2,-1
 202630c:	00000106 	br	2026314 <tse_mac_aRxRead+0x94>
 
  return SUCCESS;
 2026310:	0005883a 	mov	r2,zero
}
 2026314:	e037883a 	mov	sp,fp
 2026318:	dfc00117 	ldw	ra,4(sp)
 202631c:	df000017 	ldw	fp,0(sp)
 2026320:	dec00204 	addi	sp,sp,8
 2026324:	f800283a 	ret

02026328 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 2026328:	defffc04 	addi	sp,sp,-16
 202632c:	df000315 	stw	fp,12(sp)
 2026330:	df000304 	addi	fp,sp,12
 2026334:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2026338:	e0bfff17 	ldw	r2,-4(fp)
 202633c:	10800204 	addi	r2,r2,8
 2026340:	10800037 	ldwio	r2,0(r2)
 2026344:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 2026348:	e0bfff17 	ldw	r2,-4(fp)
 202634c:	10800204 	addi	r2,r2,8
 2026350:	00c80204 	movi	r3,8200
 2026354:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 2026358:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 202635c:	00000306 	br	202636c <tse_mac_SwReset+0x44>
 2026360:	e0bffd17 	ldw	r2,-12(fp)
 2026364:	10800044 	addi	r2,r2,1
 2026368:	e0bffd15 	stw	r2,-12(fp)
 202636c:	e0bfff17 	ldw	r2,-4(fp)
 2026370:	10800204 	addi	r2,r2,8
 2026374:	10800037 	ldwio	r2,0(r2)
 2026378:	1088000c 	andi	r2,r2,8192
 202637c:	10000326 	beq	r2,zero,202638c <tse_mac_SwReset+0x64>
 2026380:	e0bffd17 	ldw	r2,-12(fp)
 2026384:	1089c410 	cmplti	r2,r2,10000
 2026388:	103ff51e 	bne	r2,zero,2026360 <__alt_mem_mem_0+0xfd006360>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 202638c:	e0bfff17 	ldw	r2,-4(fp)
 2026390:	10800204 	addi	r2,r2,8
 2026394:	e0fffe17 	ldw	r3,-8(fp)
 2026398:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 202639c:	0005883a 	mov	r2,zero
}
 20263a0:	e037883a 	mov	sp,fp
 20263a4:	df000017 	ldw	fp,0(sp)
 20263a8:	dec00104 	addi	sp,sp,4
 20263ac:	f800283a 	ret

020263b0 <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 20263b0:	defffd04 	addi	sp,sp,-12
 20263b4:	df000215 	stw	fp,8(sp)
 20263b8:	df000204 	addi	fp,sp,8
 20263bc:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 20263c0:	e0bfff17 	ldw	r2,-4(fp)
 20263c4:	10800204 	addi	r2,r2,8
 20263c8:	10800037 	ldwio	r2,0(r2)
 20263cc:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 20263d0:	e0fffe17 	ldw	r3,-8(fp)
 20263d4:	00bffdc4 	movi	r2,-9
 20263d8:	1884703a 	and	r2,r3,r2
 20263dc:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 20263e0:	e0bfff17 	ldw	r2,-4(fp)
 20263e4:	10800204 	addi	r2,r2,8
 20263e8:	e0fffe17 	ldw	r3,-8(fp)
 20263ec:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20263f0:	0005883a 	mov	r2,zero
}
 20263f4:	e037883a 	mov	sp,fp
 20263f8:	df000017 	ldw	fp,0(sp)
 20263fc:	dec00104 	addi	sp,sp,4
 2026400:	f800283a 	ret

02026404 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 2026404:	defffd04 	addi	sp,sp,-12
 2026408:	df000215 	stw	fp,8(sp)
 202640c:	df000204 	addi	fp,sp,8
 2026410:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2026414:	e0bfff17 	ldw	r2,-4(fp)
 2026418:	10800204 	addi	r2,r2,8
 202641c:	10800037 	ldwio	r2,0(r2)
 2026420:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2026424:	e0bffe17 	ldw	r2,-8(fp)
 2026428:	10800214 	ori	r2,r2,8
 202642c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 2026430:	e0bfff17 	ldw	r2,-4(fp)
 2026434:	10800204 	addi	r2,r2,8
 2026438:	e0fffe17 	ldw	r3,-8(fp)
 202643c:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 2026440:	0005883a 	mov	r2,zero
}
 2026444:	e037883a 	mov	sp,fp
 2026448:	df000017 	ldw	fp,0(sp)
 202644c:	dec00104 	addi	sp,sp,4
 2026450:	f800283a 	ret

02026454 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 2026454:	defffb04 	addi	sp,sp,-20
 2026458:	dfc00415 	stw	ra,16(sp)
 202645c:	df000315 	stw	fp,12(sp)
 2026460:	dc000215 	stw	r16,8(sp)
 2026464:	df000304 	addi	fp,sp,12
 2026468:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 202646c:	e03ffd15 	stw	zero,-12(fp)
 2026470:	00002906 	br	2026518 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 2026474:	008085f4 	movhi	r2,535
 2026478:	10a96104 	addi	r2,r2,-23164
 202647c:	e0fffd17 	ldw	r3,-12(fp)
 2026480:	18c7883a 	add	r3,r3,r3
 2026484:	18c7883a 	add	r3,r3,r3
 2026488:	10c5883a 	add	r2,r2,r3
 202648c:	10800017 	ldw	r2,0(r2)
 2026490:	10c01417 	ldw	r3,80(r2)
 2026494:	e0bffe17 	ldw	r2,-8(fp)
 2026498:	10801417 	ldw	r2,80(r2)
 202649c:	18801b1e 	bne	r3,r2,202650c <alt_tse_phy_add_profile+0xb8>
 20264a0:	008085f4 	movhi	r2,535
 20264a4:	10a96104 	addi	r2,r2,-23164
 20264a8:	e0fffd17 	ldw	r3,-12(fp)
 20264ac:	18c7883a 	add	r3,r3,r3
 20264b0:	18c7883a 	add	r3,r3,r3
 20264b4:	10c5883a 	add	r2,r2,r3
 20264b8:	10800017 	ldw	r2,0(r2)
 20264bc:	10c01503 	ldbu	r3,84(r2)
 20264c0:	e0bffe17 	ldw	r2,-8(fp)
 20264c4:	10801503 	ldbu	r2,84(r2)
 20264c8:	18c03fcc 	andi	r3,r3,255
 20264cc:	10803fcc 	andi	r2,r2,255
 20264d0:	18800e1e 	bne	r3,r2,202650c <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 20264d4:	e0bffe17 	ldw	r2,-8(fp)
 20264d8:	10801417 	ldw	r2,80(r2)
 20264dc:	1007883a 	mov	r3,r2
 20264e0:	e0bffe17 	ldw	r2,-8(fp)
 20264e4:	10801503 	ldbu	r2,84(r2)
 20264e8:	10803fcc 	andi	r2,r2,255
 20264ec:	100d883a 	mov	r6,r2
 20264f0:	180b883a 	mov	r5,r3
 20264f4:	01008134 	movhi	r4,516
 20264f8:	21064d04 	addi	r4,r4,6452
 20264fc:	2000bb00 	call	2000bb0 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 2026500:	01008134 	movhi	r4,516
 2026504:	21066104 	addi	r4,r4,6532
 2026508:	203ceb40 	call	203ceb4 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 202650c:	e0bffd17 	ldw	r2,-12(fp)
 2026510:	10800044 	addi	r2,r2,1
 2026514:	e0bffd15 	stw	r2,-12(fp)
 2026518:	d0a80003 	ldbu	r2,-24576(gp)
 202651c:	10803fcc 	andi	r2,r2,255
 2026520:	e0fffd17 	ldw	r3,-12(fp)
 2026524:	18bfd316 	blt	r3,r2,2026474 <__alt_mem_mem_0+0xfd006474>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 2026528:	d0a80003 	ldbu	r2,-24576(gp)
 202652c:	14003fcc 	andi	r16,r2,255
 2026530:	01001904 	movi	r4,100
 2026534:	203cbe80 	call	203cbe8 <malloc>
 2026538:	1009883a 	mov	r4,r2
 202653c:	008085f4 	movhi	r2,535
 2026540:	10a96104 	addi	r2,r2,-23164
 2026544:	8407883a 	add	r3,r16,r16
 2026548:	18c7883a 	add	r3,r3,r3
 202654c:	10c5883a 	add	r2,r2,r3
 2026550:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 2026554:	d0a80003 	ldbu	r2,-24576(gp)
 2026558:	10c03fcc 	andi	r3,r2,255
 202655c:	008085f4 	movhi	r2,535
 2026560:	10a96104 	addi	r2,r2,-23164
 2026564:	18c7883a 	add	r3,r3,r3
 2026568:	18c7883a 	add	r3,r3,r3
 202656c:	10c5883a 	add	r2,r2,r3
 2026570:	10800017 	ldw	r2,0(r2)
 2026574:	1000081e 	bne	r2,zero,2026598 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 2026578:	d0a80003 	ldbu	r2,-24576(gp)
 202657c:	10803fcc 	andi	r2,r2,255
 2026580:	100b883a 	mov	r5,r2
 2026584:	01008134 	movhi	r4,516
 2026588:	21067904 	addi	r4,r4,6628
 202658c:	2000bb00 	call	2000bb0 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 2026590:	00bfffc4 	movi	r2,-1
 2026594:	00002206 	br	2026620 <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 2026598:	d0a80003 	ldbu	r2,-24576(gp)
 202659c:	10c03fcc 	andi	r3,r2,255
 20265a0:	008085f4 	movhi	r2,535
 20265a4:	10a96104 	addi	r2,r2,-23164
 20265a8:	18c7883a 	add	r3,r3,r3
 20265ac:	18c7883a 	add	r3,r3,r3
 20265b0:	10c5883a 	add	r2,r2,r3
 20265b4:	10c00017 	ldw	r3,0(r2)
 20265b8:	e0bffe17 	ldw	r2,-8(fp)
 20265bc:	1009883a 	mov	r4,r2
 20265c0:	00801904 	movi	r2,100
 20265c4:	100d883a 	mov	r6,r2
 20265c8:	200b883a 	mov	r5,r4
 20265cc:	1809883a 	mov	r4,r3
 20265d0:	20060240 	call	2006024 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 20265d4:	d0a80003 	ldbu	r2,-24576(gp)
 20265d8:	10c03fcc 	andi	r3,r2,255
 20265dc:	008085f4 	movhi	r2,535
 20265e0:	10a96104 	addi	r2,r2,-23164
 20265e4:	18c7883a 	add	r3,r3,r3
 20265e8:	18c7883a 	add	r3,r3,r3
 20265ec:	10c5883a 	add	r2,r2,r3
 20265f0:	10800017 	ldw	r2,0(r2)
 20265f4:	1007883a 	mov	r3,r2
 20265f8:	e0bffe17 	ldw	r2,-8(fp)
 20265fc:	100b883a 	mov	r5,r2
 2026600:	1809883a 	mov	r4,r3
 2026604:	203d0840 	call	203d084 <strcpy>
    
    phy_profile_count++;
 2026608:	d0a80003 	ldbu	r2,-24576(gp)
 202660c:	10800044 	addi	r2,r2,1
 2026610:	d0a80005 	stb	r2,-24576(gp)
    
    return phy_profile_count - 1;
 2026614:	d0a80003 	ldbu	r2,-24576(gp)
 2026618:	10803fcc 	andi	r2,r2,255
 202661c:	10bfffc4 	addi	r2,r2,-1
}
 2026620:	e6ffff04 	addi	sp,fp,-4
 2026624:	dfc00217 	ldw	ra,8(sp)
 2026628:	df000117 	ldw	fp,4(sp)
 202662c:	dc000017 	ldw	r16,0(sp)
 2026630:	dec00304 	addi	sp,sp,12
 2026634:	f800283a 	ret

02026638 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 2026638:	defff204 	addi	sp,sp,-56
 202663c:	dfc00d15 	stw	ra,52(sp)
 2026640:	df000c15 	stw	fp,48(sp)
 2026644:	dc000b15 	stw	r16,44(sp)
 2026648:	df000c04 	addi	fp,sp,48
 202664c:	e13ffb15 	stw	r4,-20(fp)
 2026650:	e17ffc15 	stw	r5,-16(fp)
 2026654:	e1bffd15 	stw	r6,-12(fp)
 2026658:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 202665c:	e0bffb17 	ldw	r2,-20(fp)
 2026660:	e0bffa15 	stw	r2,-24(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 2026664:	e0bffc17 	ldw	r2,-16(fp)
 2026668:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 202666c:	e0bffd17 	ldw	r2,-12(fp)
 2026670:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 2026674:	e0bffe17 	ldw	r2,-8(fp)
 2026678:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 202667c:	e0800217 	ldw	r2,8(fp)
 2026680:	e0bff915 	stw	r2,-28(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 2026684:	e0bffa17 	ldw	r2,-24(fp)
 2026688:	10800303 	ldbu	r2,12(r2)
 202668c:	10803fcc 	andi	r2,r2,255
 2026690:	1000031e 	bne	r2,zero,20266a0 <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 2026694:	00800044 	movi	r2,1
 2026698:	e0bff515 	stw	r2,-44(fp)
 202669c:	00000e06 	br	20266d8 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 20266a0:	e0bffa17 	ldw	r2,-24(fp)
 20266a4:	10800303 	ldbu	r2,12(r2)
 20266a8:	10803fcc 	andi	r2,r2,255
 20266ac:	10000526 	beq	r2,zero,20266c4 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 20266b0:	e0bffa17 	ldw	r2,-24(fp)
 20266b4:	10800303 	ldbu	r2,12(r2)
 20266b8:	10803fcc 	andi	r2,r2,255
 20266bc:	e0bff515 	stw	r2,-44(fp)
 20266c0:	00000506 	br	20266d8 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 20266c4:	01008134 	movhi	r4,516
 20266c8:	21068804 	addi	r4,r4,6688
 20266cc:	203ceb40 	call	203ceb4 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 20266d0:	00bfffc4 	movi	r2,-1
 20266d4:	00025106 	br	202701c <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 20266d8:	e03ff415 	stw	zero,-48(fp)
 20266dc:	00024b06 	br	202700c <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 20266e0:	d0a80083 	ldbu	r2,-24574(gp)
 20266e4:	10803fcc 	andi	r2,r2,255
 20266e8:	1080201c 	xori	r2,r2,128
 20266ec:	10bfe004 	addi	r2,r2,-128
 20266f0:	10800210 	cmplti	r2,r2,8
 20266f4:	10000c1e 	bne	r2,zero,2026728 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 20266f8:	01008134 	movhi	r4,516
 20266fc:	21069404 	addi	r4,r4,6736
 2026700:	203ceb40 	call	203ceb4 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 2026704:	d0a80083 	ldbu	r2,-24574(gp)
 2026708:	10803fcc 	andi	r2,r2,255
 202670c:	1080201c 	xori	r2,r2,128
 2026710:	10bfe004 	addi	r2,r2,-128
 2026714:	100d883a 	mov	r6,r2
 2026718:	01400204 	movi	r5,8
 202671c:	01008134 	movhi	r4,516
 2026720:	2106a404 	addi	r4,r4,6800
 2026724:	2000bb00 	call	2000bb0 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 2026728:	e0bffa17 	ldw	r2,-24(fp)
 202672c:	1000081e 	bne	r2,zero,2026750 <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 2026730:	01008134 	movhi	r4,516
 2026734:	2106b304 	addi	r4,r4,6860
 2026738:	203ceb40 	call	203ceb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 202673c:	01008134 	movhi	r4,516
 2026740:	2106bd04 	addi	r4,r4,6900
 2026744:	203ceb40 	call	203ceb4 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2026748:	00bfffc4 	movi	r2,-1
 202674c:	00023306 	br	202701c <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 2026750:	d0a80083 	ldbu	r2,-24574(gp)
 2026754:	11003fcc 	andi	r4,r2,255
 2026758:	2100201c 	xori	r4,r4,128
 202675c:	213fe004 	addi	r4,r4,-128
 2026760:	e0bffa17 	ldw	r2,-24(fp)
 2026764:	10800017 	ldw	r2,0(r2)
 2026768:	e0fff417 	ldw	r3,-48(fp)
 202676c:	180692ba 	slli	r3,r3,10
 2026770:	10c7883a 	add	r3,r2,r3
 2026774:	00808134 	movhi	r2,516
 2026778:	1095ac04 	addi	r2,r2,22192
 202677c:	21001224 	muli	r4,r4,72
 2026780:	1105883a 	add	r2,r2,r4
 2026784:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 2026788:	d0a80083 	ldbu	r2,-24574(gp)
 202678c:	11003fcc 	andi	r4,r2,255
 2026790:	2100201c 	xori	r4,r4,128
 2026794:	213fe004 	addi	r4,r4,-128
 2026798:	e0bffa17 	ldw	r2,-24(fp)
 202679c:	10c0010b 	ldhu	r3,4(r2)
 20267a0:	00808134 	movhi	r2,516
 20267a4:	1095ac04 	addi	r2,r2,22192
 20267a8:	21001224 	muli	r4,r4,72
 20267ac:	1105883a 	add	r2,r2,r4
 20267b0:	10800104 	addi	r2,r2,4
 20267b4:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 20267b8:	d0a80083 	ldbu	r2,-24574(gp)
 20267bc:	11003fcc 	andi	r4,r2,255
 20267c0:	2100201c 	xori	r4,r4,128
 20267c4:	213fe004 	addi	r4,r4,-128
 20267c8:	e0bffa17 	ldw	r2,-24(fp)
 20267cc:	10c0018b 	ldhu	r3,6(r2)
 20267d0:	00808134 	movhi	r2,516
 20267d4:	1095ac04 	addi	r2,r2,22192
 20267d8:	21001224 	muli	r4,r4,72
 20267dc:	1105883a 	add	r2,r2,r4
 20267e0:	10800184 	addi	r2,r2,6
 20267e4:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 20267e8:	d0a80083 	ldbu	r2,-24574(gp)
 20267ec:	11003fcc 	andi	r4,r2,255
 20267f0:	2100201c 	xori	r4,r4,128
 20267f4:	213fe004 	addi	r4,r4,-128
 20267f8:	e0bffa17 	ldw	r2,-24(fp)
 20267fc:	10c00203 	ldbu	r3,8(r2)
 2026800:	00808134 	movhi	r2,516
 2026804:	1095ac04 	addi	r2,r2,22192
 2026808:	21001224 	muli	r4,r4,72
 202680c:	1105883a 	add	r2,r2,r4
 2026810:	10800204 	addi	r2,r2,8
 2026814:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 2026818:	d0a80083 	ldbu	r2,-24574(gp)
 202681c:	11003fcc 	andi	r4,r2,255
 2026820:	2100201c 	xori	r4,r4,128
 2026824:	213fe004 	addi	r4,r4,-128
 2026828:	e0bffa17 	ldw	r2,-24(fp)
 202682c:	10c00243 	ldbu	r3,9(r2)
 2026830:	00808134 	movhi	r2,516
 2026834:	1095ac04 	addi	r2,r2,22192
 2026838:	21001224 	muli	r4,r4,72
 202683c:	1105883a 	add	r2,r2,r4
 2026840:	10800244 	addi	r2,r2,9
 2026844:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 2026848:	d0a80083 	ldbu	r2,-24574(gp)
 202684c:	11003fcc 	andi	r4,r2,255
 2026850:	2100201c 	xori	r4,r4,128
 2026854:	213fe004 	addi	r4,r4,-128
 2026858:	e0bffa17 	ldw	r2,-24(fp)
 202685c:	10c00283 	ldbu	r3,10(r2)
 2026860:	00808134 	movhi	r2,516
 2026864:	1095ac04 	addi	r2,r2,22192
 2026868:	21001224 	muli	r4,r4,72
 202686c:	1105883a 	add	r2,r2,r4
 2026870:	10800284 	addi	r2,r2,10
 2026874:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 2026878:	d0a80083 	ldbu	r2,-24574(gp)
 202687c:	11003fcc 	andi	r4,r2,255
 2026880:	2100201c 	xori	r4,r4,128
 2026884:	213fe004 	addi	r4,r4,-128
 2026888:	e0bffa17 	ldw	r2,-24(fp)
 202688c:	10c002c3 	ldbu	r3,11(r2)
 2026890:	00808134 	movhi	r2,516
 2026894:	1095ac04 	addi	r2,r2,22192
 2026898:	21001224 	muli	r4,r4,72
 202689c:	1105883a 	add	r2,r2,r4
 20268a0:	108002c4 	addi	r2,r2,11
 20268a4:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 20268a8:	d0a80083 	ldbu	r2,-24574(gp)
 20268ac:	11003fcc 	andi	r4,r2,255
 20268b0:	2100201c 	xori	r4,r4,128
 20268b4:	213fe004 	addi	r4,r4,-128
 20268b8:	e0bffa17 	ldw	r2,-24(fp)
 20268bc:	10c00303 	ldbu	r3,12(r2)
 20268c0:	00808134 	movhi	r2,516
 20268c4:	1095ac04 	addi	r2,r2,22192
 20268c8:	21001224 	muli	r4,r4,72
 20268cc:	1105883a 	add	r2,r2,r4
 20268d0:	10800304 	addi	r2,r2,12
 20268d4:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 20268d8:	d0a80083 	ldbu	r2,-24574(gp)
 20268dc:	11003fcc 	andi	r4,r2,255
 20268e0:	2100201c 	xori	r4,r4,128
 20268e4:	213fe004 	addi	r4,r4,-128
 20268e8:	e0bffa17 	ldw	r2,-24(fp)
 20268ec:	10c00343 	ldbu	r3,13(r2)
 20268f0:	00808134 	movhi	r2,516
 20268f4:	1095ac04 	addi	r2,r2,22192
 20268f8:	21001224 	muli	r4,r4,72
 20268fc:	1105883a 	add	r2,r2,r4
 2026900:	10800344 	addi	r2,r2,13
 2026904:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 2026908:	d0a80083 	ldbu	r2,-24574(gp)
 202690c:	11003fcc 	andi	r4,r2,255
 2026910:	2100201c 	xori	r4,r4,128
 2026914:	213fe004 	addi	r4,r4,-128
 2026918:	e0bffa17 	ldw	r2,-24(fp)
 202691c:	10c00383 	ldbu	r3,14(r2)
 2026920:	00808134 	movhi	r2,516
 2026924:	1095ac04 	addi	r2,r2,22192
 2026928:	21001224 	muli	r4,r4,72
 202692c:	1105883a 	add	r2,r2,r4
 2026930:	10800384 	addi	r2,r2,14
 2026934:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 2026938:	d0a80083 	ldbu	r2,-24574(gp)
 202693c:	11003fcc 	andi	r4,r2,255
 2026940:	2100201c 	xori	r4,r4,128
 2026944:	213fe004 	addi	r4,r4,-128
 2026948:	e0bffa17 	ldw	r2,-24(fp)
 202694c:	10c003c3 	ldbu	r3,15(r2)
 2026950:	00808134 	movhi	r2,516
 2026954:	1095ac04 	addi	r2,r2,22192
 2026958:	21001224 	muli	r4,r4,72
 202695c:	1105883a 	add	r2,r2,r4
 2026960:	108003c4 	addi	r2,r2,15
 2026964:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 2026968:	d0a80083 	ldbu	r2,-24574(gp)
 202696c:	11003fcc 	andi	r4,r2,255
 2026970:	2100201c 	xori	r4,r4,128
 2026974:	213fe004 	addi	r4,r4,-128
 2026978:	e0bffa17 	ldw	r2,-24(fp)
 202697c:	10c00403 	ldbu	r3,16(r2)
 2026980:	00808134 	movhi	r2,516
 2026984:	1095ac04 	addi	r2,r2,22192
 2026988:	21001224 	muli	r4,r4,72
 202698c:	1105883a 	add	r2,r2,r4
 2026990:	10800404 	addi	r2,r2,16
 2026994:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 2026998:	e0bff617 	ldw	r2,-40(fp)
 202699c:	10000d1e 	bne	r2,zero,20269d4 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 20269a0:	01008134 	movhi	r4,516
 20269a4:	2106cf04 	addi	r4,r4,6972
 20269a8:	203ceb40 	call	203ceb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 20269ac:	d0a80083 	ldbu	r2,-24574(gp)
 20269b0:	10803fcc 	andi	r2,r2,255
 20269b4:	1080201c 	xori	r2,r2,128
 20269b8:	10bfe004 	addi	r2,r2,-128
 20269bc:	100b883a 	mov	r5,r2
 20269c0:	01008134 	movhi	r4,516
 20269c4:	2106da04 	addi	r4,r4,7016
 20269c8:	2000bb00 	call	2000bb0 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 20269cc:	00bfffc4 	movi	r2,-1
 20269d0:	00019206 	br	202701c <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 20269d4:	d0a80083 	ldbu	r2,-24574(gp)
 20269d8:	14003fcc 	andi	r16,r2,255
 20269dc:	8400201c 	xori	r16,r16,128
 20269e0:	843fe004 	addi	r16,r16,-128
 20269e4:	e0bff617 	ldw	r2,-40(fp)
 20269e8:	10800017 	ldw	r2,0(r2)
 20269ec:	1009883a 	mov	r4,r2
 20269f0:	20075700 	call	2007570 <strlen>
 20269f4:	10800044 	addi	r2,r2,1
 20269f8:	1009883a 	mov	r4,r2
 20269fc:	203cbe80 	call	203cbe8 <malloc>
 2026a00:	1009883a 	mov	r4,r2
 2026a04:	00808134 	movhi	r2,516
 2026a08:	1095ac04 	addi	r2,r2,22192
 2026a0c:	80c01224 	muli	r3,r16,72
 2026a10:	10c5883a 	add	r2,r2,r3
 2026a14:	10800504 	addi	r2,r2,20
 2026a18:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 2026a1c:	d0a80083 	ldbu	r2,-24574(gp)
 2026a20:	10c03fcc 	andi	r3,r2,255
 2026a24:	18c0201c 	xori	r3,r3,128
 2026a28:	18ffe004 	addi	r3,r3,-128
 2026a2c:	00808134 	movhi	r2,516
 2026a30:	1095ac04 	addi	r2,r2,22192
 2026a34:	18c01224 	muli	r3,r3,72
 2026a38:	10c5883a 	add	r2,r2,r3
 2026a3c:	10800504 	addi	r2,r2,20
 2026a40:	10800017 	ldw	r2,0(r2)
 2026a44:	10000a1e 	bne	r2,zero,2026a70 <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 2026a48:	d0a80083 	ldbu	r2,-24574(gp)
 2026a4c:	10803fcc 	andi	r2,r2,255
 2026a50:	1080201c 	xori	r2,r2,128
 2026a54:	10bfe004 	addi	r2,r2,-128
 2026a58:	100b883a 	mov	r5,r2
 2026a5c:	01008134 	movhi	r4,516
 2026a60:	2106f204 	addi	r4,r4,7112
 2026a64:	2000bb00 	call	2000bb0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2026a68:	00bfffc4 	movi	r2,-1
 2026a6c:	00016b06 	br	202701c <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 2026a70:	d0a80083 	ldbu	r2,-24574(gp)
 2026a74:	10c03fcc 	andi	r3,r2,255
 2026a78:	18c0201c 	xori	r3,r3,128
 2026a7c:	18ffe004 	addi	r3,r3,-128
 2026a80:	00808134 	movhi	r2,516
 2026a84:	1095ac04 	addi	r2,r2,22192
 2026a88:	18c01224 	muli	r3,r3,72
 2026a8c:	10c5883a 	add	r2,r2,r3
 2026a90:	10800504 	addi	r2,r2,20
 2026a94:	10c00017 	ldw	r3,0(r2)
 2026a98:	e0bff617 	ldw	r2,-40(fp)
 2026a9c:	10800017 	ldw	r2,0(r2)
 2026aa0:	100b883a 	mov	r5,r2
 2026aa4:	1809883a 	mov	r4,r3
 2026aa8:	203d0840 	call	203d084 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 2026aac:	d0a80083 	ldbu	r2,-24574(gp)
 2026ab0:	14003fcc 	andi	r16,r2,255
 2026ab4:	8400201c 	xori	r16,r16,128
 2026ab8:	843fe004 	addi	r16,r16,-128
 2026abc:	e0bff617 	ldw	r2,-40(fp)
 2026ac0:	10800117 	ldw	r2,4(r2)
 2026ac4:	1009883a 	mov	r4,r2
 2026ac8:	20075700 	call	2007570 <strlen>
 2026acc:	10800044 	addi	r2,r2,1
 2026ad0:	1009883a 	mov	r4,r2
 2026ad4:	203cbe80 	call	203cbe8 <malloc>
 2026ad8:	1009883a 	mov	r4,r2
 2026adc:	00808134 	movhi	r2,516
 2026ae0:	1095ac04 	addi	r2,r2,22192
 2026ae4:	80c01224 	muli	r3,r16,72
 2026ae8:	10c5883a 	add	r2,r2,r3
 2026aec:	10800604 	addi	r2,r2,24
 2026af0:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 2026af4:	d0a80083 	ldbu	r2,-24574(gp)
 2026af8:	10c03fcc 	andi	r3,r2,255
 2026afc:	18c0201c 	xori	r3,r3,128
 2026b00:	18ffe004 	addi	r3,r3,-128
 2026b04:	00808134 	movhi	r2,516
 2026b08:	1095ac04 	addi	r2,r2,22192
 2026b0c:	18c01224 	muli	r3,r3,72
 2026b10:	10c5883a 	add	r2,r2,r3
 2026b14:	10800604 	addi	r2,r2,24
 2026b18:	10800017 	ldw	r2,0(r2)
 2026b1c:	10000a1e 	bne	r2,zero,2026b48 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 2026b20:	d0a80083 	ldbu	r2,-24574(gp)
 2026b24:	10803fcc 	andi	r2,r2,255
 2026b28:	1080201c 	xori	r2,r2,128
 2026b2c:	10bfe004 	addi	r2,r2,-128
 2026b30:	100b883a 	mov	r5,r2
 2026b34:	01008134 	movhi	r4,516
 2026b38:	21070504 	addi	r4,r4,7188
 2026b3c:	2000bb00 	call	2000bb0 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2026b40:	00bfffc4 	movi	r2,-1
 2026b44:	00013506 	br	202701c <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 2026b48:	d0a80083 	ldbu	r2,-24574(gp)
 2026b4c:	10c03fcc 	andi	r3,r2,255
 2026b50:	18c0201c 	xori	r3,r3,128
 2026b54:	18ffe004 	addi	r3,r3,-128
 2026b58:	00808134 	movhi	r2,516
 2026b5c:	1095ac04 	addi	r2,r2,22192
 2026b60:	18c01224 	muli	r3,r3,72
 2026b64:	10c5883a 	add	r2,r2,r3
 2026b68:	10800604 	addi	r2,r2,24
 2026b6c:	10c00017 	ldw	r3,0(r2)
 2026b70:	e0bff617 	ldw	r2,-40(fp)
 2026b74:	10800117 	ldw	r2,4(r2)
 2026b78:	100b883a 	mov	r5,r2
 2026b7c:	1809883a 	mov	r4,r3
 2026b80:	203d0840 	call	203d084 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 2026b84:	d0a80083 	ldbu	r2,-24574(gp)
 2026b88:	11003fcc 	andi	r4,r2,255
 2026b8c:	2100201c 	xori	r4,r4,128
 2026b90:	213fe004 	addi	r4,r4,-128
 2026b94:	e0bff617 	ldw	r2,-40(fp)
 2026b98:	10c0020b 	ldhu	r3,8(r2)
 2026b9c:	00808134 	movhi	r2,516
 2026ba0:	1095ac04 	addi	r2,r2,22192
 2026ba4:	21001224 	muli	r4,r4,72
 2026ba8:	1105883a 	add	r2,r2,r4
 2026bac:	10800704 	addi	r2,r2,28
 2026bb0:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 2026bb4:	e0bff717 	ldw	r2,-36(fp)
 2026bb8:	1000151e 	bne	r2,zero,2026c10 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 2026bbc:	d0a80083 	ldbu	r2,-24574(gp)
 2026bc0:	10c03fcc 	andi	r3,r2,255
 2026bc4:	18c0201c 	xori	r3,r3,128
 2026bc8:	18ffe004 	addi	r3,r3,-128
 2026bcc:	00808134 	movhi	r2,516
 2026bd0:	1095ac04 	addi	r2,r2,22192
 2026bd4:	18c01224 	muli	r3,r3,72
 2026bd8:	10c5883a 	add	r2,r2,r3
 2026bdc:	10800784 	addi	r2,r2,30
 2026be0:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 2026be4:	d0a80083 	ldbu	r2,-24574(gp)
 2026be8:	10c03fcc 	andi	r3,r2,255
 2026bec:	18c0201c 	xori	r3,r3,128
 2026bf0:	18ffe004 	addi	r3,r3,-128
 2026bf4:	00808134 	movhi	r2,516
 2026bf8:	1095ac04 	addi	r2,r2,22192
 2026bfc:	18c01224 	muli	r3,r3,72
 2026c00:	10c5883a 	add	r2,r2,r3
 2026c04:	10800804 	addi	r2,r2,32
 2026c08:	10000015 	stw	zero,0(r2)
 2026c0c:	00001806 	br	2026c70 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 2026c10:	d0a80083 	ldbu	r2,-24574(gp)
 2026c14:	11003fcc 	andi	r4,r2,255
 2026c18:	2100201c 	xori	r4,r4,128
 2026c1c:	213fe004 	addi	r4,r4,-128
 2026c20:	e0bff717 	ldw	r2,-36(fp)
 2026c24:	10c00003 	ldbu	r3,0(r2)
 2026c28:	00808134 	movhi	r2,516
 2026c2c:	1095ac04 	addi	r2,r2,22192
 2026c30:	21001224 	muli	r4,r4,72
 2026c34:	1105883a 	add	r2,r2,r4
 2026c38:	10800784 	addi	r2,r2,30
 2026c3c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 2026c40:	d0a80083 	ldbu	r2,-24574(gp)
 2026c44:	11003fcc 	andi	r4,r2,255
 2026c48:	2100201c 	xori	r4,r4,128
 2026c4c:	213fe004 	addi	r4,r4,-128
 2026c50:	e0bff717 	ldw	r2,-36(fp)
 2026c54:	10c00117 	ldw	r3,4(r2)
 2026c58:	00808134 	movhi	r2,516
 2026c5c:	1095ac04 	addi	r2,r2,22192
 2026c60:	21001224 	muli	r4,r4,72
 2026c64:	1105883a 	add	r2,r2,r4
 2026c68:	10800804 	addi	r2,r2,32
 2026c6c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 2026c70:	e0bff817 	ldw	r2,-32(fp)
 2026c74:	1000471e 	bne	r2,zero,2026d94 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 2026c78:	d0a80083 	ldbu	r2,-24574(gp)
 2026c7c:	10c03fcc 	andi	r3,r2,255
 2026c80:	18c0201c 	xori	r3,r3,128
 2026c84:	18ffe004 	addi	r3,r3,-128
 2026c88:	00808134 	movhi	r2,516
 2026c8c:	1095ac04 	addi	r2,r2,22192
 2026c90:	18c01224 	muli	r3,r3,72
 2026c94:	10c5883a 	add	r2,r2,r3
 2026c98:	10800904 	addi	r2,r2,36
 2026c9c:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 2026ca0:	d0a80083 	ldbu	r2,-24574(gp)
 2026ca4:	10c03fcc 	andi	r3,r2,255
 2026ca8:	18c0201c 	xori	r3,r3,128
 2026cac:	18ffe004 	addi	r3,r3,-128
 2026cb0:	00808134 	movhi	r2,516
 2026cb4:	1095ac04 	addi	r2,r2,22192
 2026cb8:	18c01224 	muli	r3,r3,72
 2026cbc:	10c5883a 	add	r2,r2,r3
 2026cc0:	10800a04 	addi	r2,r2,40
 2026cc4:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 2026cc8:	d0a80083 	ldbu	r2,-24574(gp)
 2026ccc:	10c03fcc 	andi	r3,r2,255
 2026cd0:	18c0201c 	xori	r3,r3,128
 2026cd4:	18ffe004 	addi	r3,r3,-128
 2026cd8:	00808134 	movhi	r2,516
 2026cdc:	1095ac04 	addi	r2,r2,22192
 2026ce0:	18c01224 	muli	r3,r3,72
 2026ce4:	10c5883a 	add	r2,r2,r3
 2026ce8:	10800b04 	addi	r2,r2,44
 2026cec:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 2026cf0:	d0a80083 	ldbu	r2,-24574(gp)
 2026cf4:	10c03fcc 	andi	r3,r2,255
 2026cf8:	18c0201c 	xori	r3,r3,128
 2026cfc:	18ffe004 	addi	r3,r3,-128
 2026d00:	00808134 	movhi	r2,516
 2026d04:	1095ac04 	addi	r2,r2,22192
 2026d08:	18c01224 	muli	r3,r3,72
 2026d0c:	10c5883a 	add	r2,r2,r3
 2026d10:	10800c04 	addi	r2,r2,48
 2026d14:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 2026d18:	d0a80083 	ldbu	r2,-24574(gp)
 2026d1c:	10c03fcc 	andi	r3,r2,255
 2026d20:	18c0201c 	xori	r3,r3,128
 2026d24:	18ffe004 	addi	r3,r3,-128
 2026d28:	00808134 	movhi	r2,516
 2026d2c:	1095ac04 	addi	r2,r2,22192
 2026d30:	18c01224 	muli	r3,r3,72
 2026d34:	10c5883a 	add	r2,r2,r3
 2026d38:	10800d04 	addi	r2,r2,52
 2026d3c:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 2026d40:	d0a80083 	ldbu	r2,-24574(gp)
 2026d44:	10c03fcc 	andi	r3,r2,255
 2026d48:	18c0201c 	xori	r3,r3,128
 2026d4c:	18ffe004 	addi	r3,r3,-128
 2026d50:	00808134 	movhi	r2,516
 2026d54:	1095ac04 	addi	r2,r2,22192
 2026d58:	18c01224 	muli	r3,r3,72
 2026d5c:	10c5883a 	add	r2,r2,r3
 2026d60:	10800e04 	addi	r2,r2,56
 2026d64:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 2026d68:	d0a80083 	ldbu	r2,-24574(gp)
 2026d6c:	10c03fcc 	andi	r3,r2,255
 2026d70:	18c0201c 	xori	r3,r3,128
 2026d74:	18ffe004 	addi	r3,r3,-128
 2026d78:	00808134 	movhi	r2,516
 2026d7c:	1095ac04 	addi	r2,r2,22192
 2026d80:	18c01224 	muli	r3,r3,72
 2026d84:	10c5883a 	add	r2,r2,r3
 2026d88:	10800f04 	addi	r2,r2,60
 2026d8c:	10000015 	stw	zero,0(r2)
 2026d90:	00005406 	br	2026ee4 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 2026d94:	d0a80083 	ldbu	r2,-24574(gp)
 2026d98:	11003fcc 	andi	r4,r2,255
 2026d9c:	2100201c 	xori	r4,r4,128
 2026da0:	213fe004 	addi	r4,r4,-128
 2026da4:	e0bff817 	ldw	r2,-32(fp)
 2026da8:	10c00003 	ldbu	r3,0(r2)
 2026dac:	00808134 	movhi	r2,516
 2026db0:	1095ac04 	addi	r2,r2,22192
 2026db4:	21001224 	muli	r4,r4,72
 2026db8:	1105883a 	add	r2,r2,r4
 2026dbc:	10800904 	addi	r2,r2,36
 2026dc0:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 2026dc4:	d0a80083 	ldbu	r2,-24574(gp)
 2026dc8:	11003fcc 	andi	r4,r2,255
 2026dcc:	2100201c 	xori	r4,r4,128
 2026dd0:	213fe004 	addi	r4,r4,-128
 2026dd4:	e0bff817 	ldw	r2,-32(fp)
 2026dd8:	10c00117 	ldw	r3,4(r2)
 2026ddc:	00808134 	movhi	r2,516
 2026de0:	1095ac04 	addi	r2,r2,22192
 2026de4:	21001224 	muli	r4,r4,72
 2026de8:	1105883a 	add	r2,r2,r4
 2026dec:	10800a04 	addi	r2,r2,40
 2026df0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 2026df4:	d0a80083 	ldbu	r2,-24574(gp)
 2026df8:	11003fcc 	andi	r4,r2,255
 2026dfc:	2100201c 	xori	r4,r4,128
 2026e00:	213fe004 	addi	r4,r4,-128
 2026e04:	e0bff817 	ldw	r2,-32(fp)
 2026e08:	10c00217 	ldw	r3,8(r2)
 2026e0c:	00808134 	movhi	r2,516
 2026e10:	1095ac04 	addi	r2,r2,22192
 2026e14:	21001224 	muli	r4,r4,72
 2026e18:	1105883a 	add	r2,r2,r4
 2026e1c:	10800b04 	addi	r2,r2,44
 2026e20:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 2026e24:	d0a80083 	ldbu	r2,-24574(gp)
 2026e28:	11003fcc 	andi	r4,r2,255
 2026e2c:	2100201c 	xori	r4,r4,128
 2026e30:	213fe004 	addi	r4,r4,-128
 2026e34:	e0bff817 	ldw	r2,-32(fp)
 2026e38:	10c00317 	ldw	r3,12(r2)
 2026e3c:	00808134 	movhi	r2,516
 2026e40:	1095ac04 	addi	r2,r2,22192
 2026e44:	21001224 	muli	r4,r4,72
 2026e48:	1105883a 	add	r2,r2,r4
 2026e4c:	10800c04 	addi	r2,r2,48
 2026e50:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 2026e54:	d0a80083 	ldbu	r2,-24574(gp)
 2026e58:	11003fcc 	andi	r4,r2,255
 2026e5c:	2100201c 	xori	r4,r4,128
 2026e60:	213fe004 	addi	r4,r4,-128
 2026e64:	e0bff817 	ldw	r2,-32(fp)
 2026e68:	10c00417 	ldw	r3,16(r2)
 2026e6c:	00808134 	movhi	r2,516
 2026e70:	1095ac04 	addi	r2,r2,22192
 2026e74:	21001224 	muli	r4,r4,72
 2026e78:	1105883a 	add	r2,r2,r4
 2026e7c:	10800d04 	addi	r2,r2,52
 2026e80:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 2026e84:	d0a80083 	ldbu	r2,-24574(gp)
 2026e88:	11003fcc 	andi	r4,r2,255
 2026e8c:	2100201c 	xori	r4,r4,128
 2026e90:	213fe004 	addi	r4,r4,-128
 2026e94:	e0bff817 	ldw	r2,-32(fp)
 2026e98:	10c00517 	ldw	r3,20(r2)
 2026e9c:	00808134 	movhi	r2,516
 2026ea0:	1095ac04 	addi	r2,r2,22192
 2026ea4:	21001224 	muli	r4,r4,72
 2026ea8:	1105883a 	add	r2,r2,r4
 2026eac:	10800e04 	addi	r2,r2,56
 2026eb0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 2026eb4:	d0a80083 	ldbu	r2,-24574(gp)
 2026eb8:	11003fcc 	andi	r4,r2,255
 2026ebc:	2100201c 	xori	r4,r4,128
 2026ec0:	213fe004 	addi	r4,r4,-128
 2026ec4:	e0bff817 	ldw	r2,-32(fp)
 2026ec8:	10c00617 	ldw	r3,24(r2)
 2026ecc:	00808134 	movhi	r2,516
 2026ed0:	1095ac04 	addi	r2,r2,22192
 2026ed4:	21001224 	muli	r4,r4,72
 2026ed8:	1105883a 	add	r2,r2,r4
 2026edc:	10800f04 	addi	r2,r2,60
 2026ee0:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 2026ee4:	e0bff917 	ldw	r2,-28(fp)
 2026ee8:	1000161e 	bne	r2,zero,2026f44 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 2026eec:	d0a80083 	ldbu	r2,-24574(gp)
 2026ef0:	10c03fcc 	andi	r3,r2,255
 2026ef4:	18c0201c 	xori	r3,r3,128
 2026ef8:	18ffe004 	addi	r3,r3,-128
 2026efc:	00808134 	movhi	r2,516
 2026f00:	1095ac04 	addi	r2,r2,22192
 2026f04:	18c01224 	muli	r3,r3,72
 2026f08:	10c5883a 	add	r2,r2,r3
 2026f0c:	10801004 	addi	r2,r2,64
 2026f10:	00ffffc4 	movi	r3,-1
 2026f14:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 2026f18:	d0a80083 	ldbu	r2,-24574(gp)
 2026f1c:	10c03fcc 	andi	r3,r2,255
 2026f20:	18c0201c 	xori	r3,r3,128
 2026f24:	18ffe004 	addi	r3,r3,-128
 2026f28:	00808134 	movhi	r2,516
 2026f2c:	1095ac04 	addi	r2,r2,22192
 2026f30:	18c01224 	muli	r3,r3,72
 2026f34:	10c5883a 	add	r2,r2,r3
 2026f38:	10801104 	addi	r2,r2,68
 2026f3c:	10000015 	stw	zero,0(r2)
 2026f40:	00001806 	br	2026fa4 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 2026f44:	d0a80083 	ldbu	r2,-24574(gp)
 2026f48:	11003fcc 	andi	r4,r2,255
 2026f4c:	2100201c 	xori	r4,r4,128
 2026f50:	213fe004 	addi	r4,r4,-128
 2026f54:	e0bff917 	ldw	r2,-28(fp)
 2026f58:	10c00017 	ldw	r3,0(r2)
 2026f5c:	00808134 	movhi	r2,516
 2026f60:	1095ac04 	addi	r2,r2,22192
 2026f64:	21001224 	muli	r4,r4,72
 2026f68:	1105883a 	add	r2,r2,r4
 2026f6c:	10801004 	addi	r2,r2,64
 2026f70:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 2026f74:	d0a80083 	ldbu	r2,-24574(gp)
 2026f78:	11003fcc 	andi	r4,r2,255
 2026f7c:	2100201c 	xori	r4,r4,128
 2026f80:	213fe004 	addi	r4,r4,-128
 2026f84:	e0bff917 	ldw	r2,-28(fp)
 2026f88:	10c00117 	ldw	r3,4(r2)
 2026f8c:	00808134 	movhi	r2,516
 2026f90:	1095ac04 	addi	r2,r2,22192
 2026f94:	21001224 	muli	r4,r4,72
 2026f98:	1105883a 	add	r2,r2,r4
 2026f9c:	10801104 	addi	r2,r2,68
 2026fa0:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 2026fa4:	e0bff617 	ldw	r2,-40(fp)
 2026fa8:	10800304 	addi	r2,r2,12
 2026fac:	e0bff615 	stw	r2,-40(fp)
		if(pmem) pmem++;
 2026fb0:	e0bff717 	ldw	r2,-36(fp)
 2026fb4:	10000326 	beq	r2,zero,2026fc4 <alt_tse_system_add_sys+0x98c>
 2026fb8:	e0bff717 	ldw	r2,-36(fp)
 2026fbc:	10800204 	addi	r2,r2,8
 2026fc0:	e0bff715 	stw	r2,-36(fp)
		if(pfifo) pfifo++;
 2026fc4:	e0bff817 	ldw	r2,-32(fp)
 2026fc8:	10000326 	beq	r2,zero,2026fd8 <alt_tse_system_add_sys+0x9a0>
 2026fcc:	e0bff817 	ldw	r2,-32(fp)
 2026fd0:	10800704 	addi	r2,r2,28
 2026fd4:	e0bff815 	stw	r2,-32(fp)
		if(pphy) pphy++;
 2026fd8:	e0bff917 	ldw	r2,-28(fp)
 2026fdc:	10000326 	beq	r2,zero,2026fec <alt_tse_system_add_sys+0x9b4>
 2026fe0:	e0bff917 	ldw	r2,-28(fp)
 2026fe4:	10800204 	addi	r2,r2,8
 2026fe8:	e0bff915 	stw	r2,-28(fp)
		
		tse_system_count++;
 2026fec:	d0a80083 	ldbu	r2,-24574(gp)
 2026ff0:	10800044 	addi	r2,r2,1
 2026ff4:	d0a80085 	stb	r2,-24574(gp)
		max_mac_system = tse_system_count;
 2026ff8:	d0a80083 	ldbu	r2,-24574(gp)
 2026ffc:	d0a01905 	stb	r2,-32668(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 2027000:	e0bff417 	ldw	r2,-48(fp)
 2027004:	10800044 	addi	r2,r2,1
 2027008:	e0bff415 	stw	r2,-48(fp)
 202700c:	e0fff417 	ldw	r3,-48(fp)
 2027010:	e0bff517 	ldw	r2,-44(fp)
 2027014:	18bdb216 	blt	r3,r2,20266e0 <__alt_mem_mem_0+0xfd0066e0>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 2027018:	0005883a 	mov	r2,zero
	
}
 202701c:	e6ffff04 	addi	sp,fp,-4
 2027020:	dfc00217 	ldw	ra,8(sp)
 2027024:	df000117 	ldw	fp,4(sp)
 2027028:	dc000017 	ldw	r16,0(sp)
 202702c:	dec00304 	addi	sp,sp,12
 2027030:	f800283a 	ret

02027034 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 2027034:	defff904 	addi	sp,sp,-28
 2027038:	dfc00615 	stw	ra,24(sp)
 202703c:	df000515 	stw	fp,20(sp)
 2027040:	df000504 	addi	fp,sp,20
 2027044:	e13ffe15 	stw	r4,-8(fp)
 2027048:	2805883a 	mov	r2,r5
 202704c:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 2027050:	e03ffb15 	stw	zero,-20(fp)
 2027054:	00004806 	br	2027178 <alt_tse_sys_enable_mdio_sharing+0x144>
		psys_mac = psys_mac_list[i];
 2027058:	e0bffb17 	ldw	r2,-20(fp)
 202705c:	1085883a 	add	r2,r2,r2
 2027060:	1085883a 	add	r2,r2,r2
 2027064:	1007883a 	mov	r3,r2
 2027068:	e0bffe17 	ldw	r2,-8(fp)
 202706c:	10c5883a 	add	r2,r2,r3
 2027070:	10800017 	ldw	r2,0(r2)
 2027074:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 2027078:	e0bffd17 	ldw	r2,-12(fp)
 202707c:	1000081e 	bne	r2,zero,20270a0 <alt_tse_sys_enable_mdio_sharing+0x6c>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 2027080:	01008134 	movhi	r4,516
 2027084:	2106b304 	addi	r4,r4,6860
 2027088:	203ceb40 	call	203ceb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 202708c:	01008134 	movhi	r4,516
 2027090:	21071804 	addi	r4,r4,7264
 2027094:	203ceb40 	call	203ceb4 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2027098:	00bfffc4 	movi	r2,-1
 202709c:	00003a06 	br	2027188 <alt_tse_sys_enable_mdio_sharing+0x154>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 20270a0:	e03ffc15 	stw	zero,-16(fp)
 20270a4:	00002d06 	br	202715c <alt_tse_sys_enable_mdio_sharing+0x128>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 20270a8:	e0bffd17 	ldw	r2,-12(fp)
 20270ac:	10c00017 	ldw	r3,0(r2)
 20270b0:	00808134 	movhi	r2,516
 20270b4:	1095ac04 	addi	r2,r2,22192
 20270b8:	e13ffc17 	ldw	r4,-16(fp)
 20270bc:	21001224 	muli	r4,r4,72
 20270c0:	1105883a 	add	r2,r2,r4
 20270c4:	10800017 	ldw	r2,0(r2)
 20270c8:	1880211e 	bne	r3,r2,2027150 <alt_tse_sys_enable_mdio_sharing+0x11c>
				if(tse_mac_device[j].tse_multichannel_mac) {
 20270cc:	00808134 	movhi	r2,516
 20270d0:	1095ac04 	addi	r2,r2,22192
 20270d4:	e0fffc17 	ldw	r3,-16(fp)
 20270d8:	18c01224 	muli	r3,r3,72
 20270dc:	10c5883a 	add	r2,r2,r3
 20270e0:	108002c4 	addi	r2,r2,11
 20270e4:	10800003 	ldbu	r2,0(r2)
 20270e8:	10803fcc 	andi	r2,r2,255
 20270ec:	10000826 	beq	r2,zero,2027110 <alt_tse_sys_enable_mdio_sharing+0xdc>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 20270f0:	01008134 	movhi	r4,516
 20270f4:	21072c04 	addi	r4,r4,7344
 20270f8:	203ceb40 	call	203ceb4 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 20270fc:	01008134 	movhi	r4,516
 2027100:	21073d04 	addi	r4,r4,7412
 2027104:	203ceb40 	call	203ceb4 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2027108:	00bfffc4 	movi	r2,-1
 202710c:	00001e06 	br	2027188 <alt_tse_sys_enable_mdio_sharing+0x154>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 2027110:	00808134 	movhi	r2,516
 2027114:	1095ac04 	addi	r2,r2,22192
 2027118:	e0fffc17 	ldw	r3,-16(fp)
 202711c:	18c01224 	muli	r3,r3,72
 2027120:	10c5883a 	add	r2,r2,r3
 2027124:	10800344 	addi	r2,r2,13
 2027128:	00c00044 	movi	r3,1
 202712c:	10c00005 	stb	r3,0(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 2027130:	00808134 	movhi	r2,516
 2027134:	1095ac04 	addi	r2,r2,22192
 2027138:	e0fffc17 	ldw	r3,-16(fp)
 202713c:	18c01224 	muli	r3,r3,72
 2027140:	10c5883a 	add	r2,r2,r3
 2027144:	10800384 	addi	r2,r2,14
 2027148:	e0ffff03 	ldbu	r3,-4(fp)
 202714c:	10c00005 	stb	r3,0(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 2027150:	e0bffc17 	ldw	r2,-16(fp)
 2027154:	10800044 	addi	r2,r2,1
 2027158:	e0bffc15 	stw	r2,-16(fp)
 202715c:	d0a01903 	ldbu	r2,-32668(gp)
 2027160:	10803fcc 	andi	r2,r2,255
 2027164:	e0fffc17 	ldw	r3,-16(fp)
 2027168:	18bfcf16 	blt	r3,r2,20270a8 <__alt_mem_mem_0+0xfd0070a8>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 202716c:	e0bffb17 	ldw	r2,-20(fp)
 2027170:	10800044 	addi	r2,r2,1
 2027174:	e0bffb15 	stw	r2,-20(fp)
 2027178:	e0bfff03 	ldbu	r2,-4(fp)
 202717c:	e0fffb17 	ldw	r3,-20(fp)
 2027180:	18bfb516 	blt	r3,r2,2027058 <__alt_mem_mem_0+0xfd007058>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 2027184:	0005883a 	mov	r2,zero
}
 2027188:	e037883a 	mov	sp,fp
 202718c:	dfc00117 	ldw	ra,4(sp)
 2027190:	df000017 	ldw	fp,0(sp)
 2027194:	dec00204 	addi	sp,sp,8
 2027198:	f800283a 	ret

0202719c <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 202719c:	defffc04 	addi	sp,sp,-16
 20271a0:	dfc00315 	stw	ra,12(sp)
 20271a4:	df000215 	stw	fp,8(sp)
 20271a8:	df000204 	addi	fp,sp,8
 20271ac:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 20271b0:	e13fff17 	ldw	r4,-4(fp)
 20271b4:	20273840 	call	2027384 <alt_tse_get_mac_info>
 20271b8:	10800317 	ldw	r2,12(r2)
 20271bc:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 20271c0:	e13ffe17 	ldw	r4,-8(fp)
 20271c4:	202a5440 	call	202a544 <alt_tse_phy_get_common_speed>
}
 20271c8:	e037883a 	mov	sp,fp
 20271cc:	dfc00117 	ldw	ra,4(sp)
 20271d0:	df000017 	ldw	fp,0(sp)
 20271d4:	dec00204 	addi	sp,sp,8
 20271d8:	f800283a 	ret

020271dc <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 20271dc:	defffb04 	addi	sp,sp,-20
 20271e0:	dfc00415 	stw	ra,16(sp)
 20271e4:	df000315 	stw	fp,12(sp)
 20271e8:	df000304 	addi	fp,sp,12
 20271ec:	e13ffe15 	stw	r4,-8(fp)
 20271f0:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 20271f4:	e13ffe17 	ldw	r4,-8(fp)
 20271f8:	20273840 	call	2027384 <alt_tse_get_mac_info>
 20271fc:	10800317 	ldw	r2,12(r2)
 2027200:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 2027204:	e17fff17 	ldw	r5,-4(fp)
 2027208:	e13ffd17 	ldw	r4,-12(fp)
 202720c:	202a86c0 	call	202a86c <alt_tse_phy_set_common_speed>
}
 2027210:	e037883a 	mov	sp,fp
 2027214:	dfc00117 	ldw	ra,4(sp)
 2027218:	df000017 	ldw	fp,0(sp)
 202721c:	dec00204 	addi	sp,sp,8
 2027220:	f800283a 	ret

02027224 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 2027224:	defffd04 	addi	sp,sp,-12
 2027228:	df000215 	stw	fp,8(sp)
 202722c:	df000204 	addi	fp,sp,8
 2027230:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 2027234:	e03ffe15 	stw	zero,-8(fp)
 2027238:	00000c06 	br	202726c <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 202723c:	e0bffe17 	ldw	r2,-8(fp)
 2027240:	10c01224 	muli	r3,r2,72
 2027244:	00808134 	movhi	r2,516
 2027248:	1095ac04 	addi	r2,r2,22192
 202724c:	1887883a 	add	r3,r3,r2
 2027250:	e0bfff17 	ldw	r2,-4(fp)
 2027254:	1880021e 	bne	r3,r2,2027260 <alt_tse_get_system_index+0x3c>
            return i;
 2027258:	e0bffe17 	ldw	r2,-8(fp)
 202725c:	00000806 	br	2027280 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 2027260:	e0bffe17 	ldw	r2,-8(fp)
 2027264:	10800044 	addi	r2,r2,1
 2027268:	e0bffe15 	stw	r2,-8(fp)
 202726c:	d0a01903 	ldbu	r2,-32668(gp)
 2027270:	10803fcc 	andi	r2,r2,255
 2027274:	e0fffe17 	ldw	r3,-8(fp)
 2027278:	18bff016 	blt	r3,r2,202723c <__alt_mem_mem_0+0xfd00723c>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 202727c:	00bfffc4 	movi	r2,-1
}
 2027280:	e037883a 	mov	sp,fp
 2027284:	df000017 	ldw	fp,0(sp)
 2027288:	dec00104 	addi	sp,sp,4
 202728c:	f800283a 	ret

02027290 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 2027290:	defffd04 	addi	sp,sp,-12
 2027294:	df000215 	stw	fp,8(sp)
 2027298:	df000204 	addi	fp,sp,8
 202729c:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 20272a0:	e03ffe15 	stw	zero,-8(fp)
 20272a4:	00000e06 	br	20272e0 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 20272a8:	008085f4 	movhi	r2,535
 20272ac:	10a95904 	addi	r2,r2,-23196
 20272b0:	e0fffe17 	ldw	r3,-8(fp)
 20272b4:	18c7883a 	add	r3,r3,r3
 20272b8:	18c7883a 	add	r3,r3,r3
 20272bc:	10c5883a 	add	r2,r2,r3
 20272c0:	10c00017 	ldw	r3,0(r2)
 20272c4:	e0bfff17 	ldw	r2,-4(fp)
 20272c8:	1880021e 	bne	r3,r2,20272d4 <alt_tse_get_mac_group_index+0x44>
            return i;
 20272cc:	e0bffe17 	ldw	r2,-8(fp)
 20272d0:	00000806 	br	20272f4 <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 20272d4:	e0bffe17 	ldw	r2,-8(fp)
 20272d8:	10800044 	addi	r2,r2,1
 20272dc:	e0bffe15 	stw	r2,-8(fp)
 20272e0:	d0a80043 	ldbu	r2,-24575(gp)
 20272e4:	10803fcc 	andi	r2,r2,255
 20272e8:	e0fffe17 	ldw	r3,-8(fp)
 20272ec:	18bfee16 	blt	r3,r2,20272a8 <__alt_mem_mem_0+0xfd0072a8>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 20272f0:	00bfffc4 	movi	r2,-1
}
 20272f4:	e037883a 	mov	sp,fp
 20272f8:	df000017 	ldw	fp,0(sp)
 20272fc:	dec00104 	addi	sp,sp,4
 2027300:	f800283a 	ret

02027304 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 2027304:	defffd04 	addi	sp,sp,-12
 2027308:	df000215 	stw	fp,8(sp)
 202730c:	df000204 	addi	fp,sp,8
 2027310:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 2027314:	e03ffe15 	stw	zero,-8(fp)
 2027318:	00000f06 	br	2027358 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 202731c:	e0bfff17 	ldw	r2,-4(fp)
 2027320:	10c00317 	ldw	r3,12(r2)
 2027324:	e0bffe17 	ldw	r2,-8(fp)
 2027328:	10800044 	addi	r2,r2,1
 202732c:	1085883a 	add	r2,r2,r2
 2027330:	1085883a 	add	r2,r2,r2
 2027334:	1885883a 	add	r2,r3,r2
 2027338:	10c00017 	ldw	r3,0(r2)
 202733c:	e0bfff17 	ldw	r2,-4(fp)
 2027340:	1880021e 	bne	r3,r2,202734c <alt_tse_get_mac_info_index+0x48>
            return i;
 2027344:	e0bffe17 	ldw	r2,-8(fp)
 2027348:	00000a06 	br	2027374 <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 202734c:	e0bffe17 	ldw	r2,-8(fp)
 2027350:	10800044 	addi	r2,r2,1
 2027354:	e0bffe15 	stw	r2,-8(fp)
 2027358:	e0bfff17 	ldw	r2,-4(fp)
 202735c:	10800317 	ldw	r2,12(r2)
 2027360:	10800003 	ldbu	r2,0(r2)
 2027364:	10803fcc 	andi	r2,r2,255
 2027368:	e0fffe17 	ldw	r3,-8(fp)
 202736c:	18bfeb16 	blt	r3,r2,202731c <__alt_mem_mem_0+0xfd00731c>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 2027370:	00bfffc4 	movi	r2,-1
}
 2027374:	e037883a 	mov	sp,fp
 2027378:	df000017 	ldw	fp,0(sp)
 202737c:	dec00104 	addi	sp,sp,4
 2027380:	f800283a 	ret

02027384 <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 2027384:	defffa04 	addi	sp,sp,-24
 2027388:	df000515 	stw	fp,20(sp)
 202738c:	df000504 	addi	fp,sp,20
 2027390:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 2027394:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 2027398:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 202739c:	e03ffb15 	stw	zero,-20(fp)
 20273a0:	00002506 	br	2027438 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 20273a4:	008085f4 	movhi	r2,535
 20273a8:	10a95904 	addi	r2,r2,-23196
 20273ac:	e0fffb17 	ldw	r3,-20(fp)
 20273b0:	18c7883a 	add	r3,r3,r3
 20273b4:	18c7883a 	add	r3,r3,r3
 20273b8:	10c5883a 	add	r2,r2,r3
 20273bc:	10800017 	ldw	r2,0(r2)
 20273c0:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 20273c4:	e03ffc15 	stw	zero,-16(fp)
 20273c8:	00001306 	br	2027418 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 20273cc:	e0fffd17 	ldw	r3,-12(fp)
 20273d0:	e0bffc17 	ldw	r2,-16(fp)
 20273d4:	10800044 	addi	r2,r2,1
 20273d8:	1085883a 	add	r2,r2,r2
 20273dc:	1085883a 	add	r2,r2,r2
 20273e0:	1885883a 	add	r2,r3,r2
 20273e4:	10800017 	ldw	r2,0(r2)
 20273e8:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 20273ec:	e0bffe17 	ldw	r2,-8(fp)
 20273f0:	10800217 	ldw	r2,8(r2)
 20273f4:	10800017 	ldw	r2,0(r2)
 20273f8:	1007883a 	mov	r3,r2
 20273fc:	e0bfff17 	ldw	r2,-4(fp)
 2027400:	1880021e 	bne	r3,r2,202740c <alt_tse_get_mac_info+0x88>
                return pmac_info;
 2027404:	e0bffe17 	ldw	r2,-8(fp)
 2027408:	00001006 	br	202744c <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 202740c:	e0bffc17 	ldw	r2,-16(fp)
 2027410:	10800044 	addi	r2,r2,1
 2027414:	e0bffc15 	stw	r2,-16(fp)
 2027418:	e0bffd17 	ldw	r2,-12(fp)
 202741c:	10800003 	ldbu	r2,0(r2)
 2027420:	10803fcc 	andi	r2,r2,255
 2027424:	e0fffc17 	ldw	r3,-16(fp)
 2027428:	18bfe816 	blt	r3,r2,20273cc <__alt_mem_mem_0+0xfd0073cc>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 202742c:	e0bffb17 	ldw	r2,-20(fp)
 2027430:	10800044 	addi	r2,r2,1
 2027434:	e0bffb15 	stw	r2,-20(fp)
 2027438:	d0a80043 	ldbu	r2,-24575(gp)
 202743c:	10803fcc 	andi	r2,r2,255
 2027440:	e0fffb17 	ldw	r3,-20(fp)
 2027444:	18bfd716 	blt	r3,r2,20273a4 <__alt_mem_mem_0+0xfd0073a4>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 2027448:	0005883a 	mov	r2,zero
}
 202744c:	e037883a 	mov	sp,fp
 2027450:	df000017 	ldw	fp,0(sp)
 2027454:	dec00104 	addi	sp,sp,4
 2027458:	f800283a 	ret

0202745c <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 202745c:	defffc04 	addi	sp,sp,-16
 2027460:	df000315 	stw	fp,12(sp)
 2027464:	df000304 	addi	fp,sp,12
 2027468:	e13ffe15 	stw	r4,-8(fp)
 202746c:	2805883a 	mov	r2,r5
 2027470:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2027474:	e0bffe17 	ldw	r2,-8(fp)
 2027478:	10800204 	addi	r2,r2,8
 202747c:	10800037 	ldwio	r2,0(r2)
 2027480:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 2027484:	e0bfff03 	ldbu	r2,-4(fp)
 2027488:	10800098 	cmpnei	r2,r2,2
 202748c:	1000091e 	bne	r2,zero,20274b4 <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2027490:	e0bffd17 	ldw	r2,-12(fp)
 2027494:	10800214 	ori	r2,r2,8
 2027498:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 202749c:	e0fffd17 	ldw	r3,-12(fp)
 20274a0:	00bf8034 	movhi	r2,65024
 20274a4:	10bfffc4 	addi	r2,r2,-1
 20274a8:	1884703a 	and	r2,r3,r2
 20274ac:	e0bffd15 	stw	r2,-12(fp)
 20274b0:	00001906 	br	2027518 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 20274b4:	e0bfff03 	ldbu	r2,-4(fp)
 20274b8:	10800058 	cmpnei	r2,r2,1
 20274bc:	10000a1e 	bne	r2,zero,20274e8 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20274c0:	e0fffd17 	ldw	r3,-12(fp)
 20274c4:	00bffdc4 	movi	r2,-9
 20274c8:	1884703a 	and	r2,r3,r2
 20274cc:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20274d0:	e0fffd17 	ldw	r3,-12(fp)
 20274d4:	00bf8034 	movhi	r2,65024
 20274d8:	10bfffc4 	addi	r2,r2,-1
 20274dc:	1884703a 	and	r2,r3,r2
 20274e0:	e0bffd15 	stw	r2,-12(fp)
 20274e4:	00000c06 	br	2027518 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 20274e8:	e0bfff03 	ldbu	r2,-4(fp)
 20274ec:	1000081e 	bne	r2,zero,2027510 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20274f0:	e0fffd17 	ldw	r3,-12(fp)
 20274f4:	00bffdc4 	movi	r2,-9
 20274f8:	1884703a 	and	r2,r3,r2
 20274fc:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2027500:	e0bffd17 	ldw	r2,-12(fp)
 2027504:	10808034 	orhi	r2,r2,512
 2027508:	e0bffd15 	stw	r2,-12(fp)
 202750c:	00000206 	br	2027518 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 2027510:	00bffd84 	movi	r2,-10
 2027514:	00000506 	br	202752c <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 2027518:	e0bffe17 	ldw	r2,-8(fp)
 202751c:	10800204 	addi	r2,r2,8
 2027520:	e0fffd17 	ldw	r3,-12(fp)
 2027524:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 2027528:	0005883a 	mov	r2,zero
}
 202752c:	e037883a 	mov	sp,fp
 2027530:	df000017 	ldw	fp,0(sp)
 2027534:	dec00104 	addi	sp,sp,4
 2027538:	f800283a 	ret

0202753c <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 202753c:	defffc04 	addi	sp,sp,-16
 2027540:	df000315 	stw	fp,12(sp)
 2027544:	df000304 	addi	fp,sp,12
 2027548:	e13ffe15 	stw	r4,-8(fp)
 202754c:	2805883a 	mov	r2,r5
 2027550:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2027554:	e0bffe17 	ldw	r2,-8(fp)
 2027558:	10800204 	addi	r2,r2,8
 202755c:	10800037 	ldwio	r2,0(r2)
 2027560:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 2027564:	e0bfff03 	ldbu	r2,-4(fp)
 2027568:	1000041e 	bne	r2,zero,202757c <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 202756c:	e0bffd17 	ldw	r2,-12(fp)
 2027570:	10810014 	ori	r2,r2,1024
 2027574:	e0bffd15 	stw	r2,-12(fp)
 2027578:	00000a06 	br	20275a4 <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 202757c:	e0bfff03 	ldbu	r2,-4(fp)
 2027580:	10800058 	cmpnei	r2,r2,1
 2027584:	1000051e 	bne	r2,zero,202759c <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2027588:	e0fffd17 	ldw	r3,-12(fp)
 202758c:	00beffc4 	movi	r2,-1025
 2027590:	1884703a 	and	r2,r3,r2
 2027594:	e0bffd15 	stw	r2,-12(fp)
 2027598:	00000206 	br	20275a4 <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 202759c:	00bffd84 	movi	r2,-10
 20275a0:	00000506 	br	20275b8 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 20275a4:	e0bffe17 	ldw	r2,-8(fp)
 20275a8:	10800204 	addi	r2,r2,8
 20275ac:	e0fffd17 	ldw	r3,-12(fp)
 20275b0:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20275b4:	0005883a 	mov	r2,zero

}
 20275b8:	e037883a 	mov	sp,fp
 20275bc:	df000017 	ldw	fp,0(sp)
 20275c0:	dec00104 	addi	sp,sp,4
 20275c4:	f800283a 	ret

020275c8 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 20275c8:	defff404 	addi	sp,sp,-48
 20275cc:	dfc00b15 	stw	ra,44(sp)
 20275d0:	df000a15 	stw	fp,40(sp)
 20275d4:	df000a04 	addi	fp,sp,40
 20275d8:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20275dc:	00800044 	movi	r2,1
 20275e0:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 20275e4:	00800044 	movi	r2,1
 20275e8:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 20275ec:	e0bff743 	ldbu	r2,-35(fp)
 20275f0:	10c0004c 	andi	r3,r2,1
 20275f4:	e0bff703 	ldbu	r2,-36(fp)
 20275f8:	10800098 	cmpnei	r2,r2,2
 20275fc:	1000021e 	bne	r2,zero,2027608 <getPHYSpeed+0x40>
 2027600:	00800084 	movi	r2,2
 2027604:	00000106 	br	202760c <getPHYSpeed+0x44>
 2027608:	0005883a 	mov	r2,zero
 202760c:	1886b03a 	or	r3,r3,r2
 2027610:	e0bff703 	ldbu	r2,-36(fp)
 2027614:	10800058 	cmpnei	r2,r2,1
 2027618:	1000021e 	bne	r2,zero,2027624 <getPHYSpeed+0x5c>
 202761c:	00800104 	movi	r2,4
 2027620:	00000106 	br	2027628 <getPHYSpeed+0x60>
 2027624:	0005883a 	mov	r2,zero
 2027628:	1886b03a 	or	r3,r3,r2
 202762c:	e0bff703 	ldbu	r2,-36(fp)
 2027630:	1000021e 	bne	r2,zero,202763c <getPHYSpeed+0x74>
 2027634:	00800204 	movi	r2,8
 2027638:	00000106 	br	2027640 <getPHYSpeed+0x78>
 202763c:	0005883a 	mov	r2,zero
 2027640:	1886b03a 	or	r3,r3,r2
 2027644:	e0bff703 	ldbu	r2,-36(fp)
 2027648:	108000d8 	cmpnei	r2,r2,3
 202764c:	1000021e 	bne	r2,zero,2027658 <getPHYSpeed+0x90>
 2027650:	00800074 	movhi	r2,1
 2027654:	00000106 	br	202765c <getPHYSpeed+0x94>
 2027658:	0005883a 	mov	r2,zero
 202765c:	1884b03a 	or	r2,r3,r2
 2027660:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 2027664:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 2027668:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 202766c:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 2027670:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 2027674:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 2027678:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 202767c:	d0a800c3 	ldbu	r2,-24573(gp)
 2027680:	10803fcc 	andi	r2,r2,255
 2027684:	1000031e 	bne	r2,zero,2027694 <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 2027688:	20295bc0 	call	20295bc <alt_tse_phy_init>
        is_init = 1;
 202768c:	00800044 	movi	r2,1
 2027690:	d0a800c5 	stb	r2,-24573(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 2027694:	e13fff17 	ldw	r4,-4(fp)
 2027698:	20273840 	call	2027384 <alt_tse_get_mac_info>
 202769c:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 20276a0:	e0bffa17 	ldw	r2,-24(fp)
 20276a4:	1000481e 	bne	r2,zero,20277c8 <getPHYSpeed+0x200>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20276a8:	00800044 	movi	r2,1
 20276ac:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 20276b0:	00800044 	movi	r2,1
 20276b4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 20276b8:	e0bff743 	ldbu	r2,-35(fp)
 20276bc:	10c0004c 	andi	r3,r2,1
 20276c0:	e0bff703 	ldbu	r2,-36(fp)
 20276c4:	10800098 	cmpnei	r2,r2,2
 20276c8:	1000021e 	bne	r2,zero,20276d4 <getPHYSpeed+0x10c>
 20276cc:	00800084 	movi	r2,2
 20276d0:	00000106 	br	20276d8 <getPHYSpeed+0x110>
 20276d4:	0005883a 	mov	r2,zero
 20276d8:	1886b03a 	or	r3,r3,r2
 20276dc:	e0bff703 	ldbu	r2,-36(fp)
 20276e0:	10800058 	cmpnei	r2,r2,1
 20276e4:	1000021e 	bne	r2,zero,20276f0 <getPHYSpeed+0x128>
 20276e8:	00800104 	movi	r2,4
 20276ec:	00000106 	br	20276f4 <getPHYSpeed+0x12c>
 20276f0:	0005883a 	mov	r2,zero
 20276f4:	1886b03a 	or	r3,r3,r2
 20276f8:	e0bff703 	ldbu	r2,-36(fp)
 20276fc:	1000021e 	bne	r2,zero,2027708 <getPHYSpeed+0x140>
 2027700:	00800204 	movi	r2,8
 2027704:	00000106 	br	202770c <getPHYSpeed+0x144>
 2027708:	0005883a 	mov	r2,zero
 202770c:	1886b03a 	or	r3,r3,r2
 2027710:	e0bff703 	ldbu	r2,-36(fp)
 2027714:	108000d8 	cmpnei	r2,r2,3
 2027718:	1000021e 	bne	r2,zero,2027724 <getPHYSpeed+0x15c>
 202771c:	00800074 	movhi	r2,1
 2027720:	00000106 	br	2027728 <getPHYSpeed+0x160>
 2027724:	0005883a 	mov	r2,zero
 2027728:	1884b03a 	or	r2,r3,r2
 202772c:	10802034 	orhi	r2,r2,128
 2027730:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 2027734:	e0bff703 	ldbu	r2,-36(fp)
 2027738:	108000a0 	cmpeqi	r2,r2,2
 202773c:	10000e1e 	bne	r2,zero,2027778 <getPHYSpeed+0x1b0>
 2027740:	e0bff703 	ldbu	r2,-36(fp)
 2027744:	10800060 	cmpeqi	r2,r2,1
 2027748:	1000081e 	bne	r2,zero,202776c <getPHYSpeed+0x1a4>
 202774c:	e0bff703 	ldbu	r2,-36(fp)
 2027750:	1000031e 	bne	r2,zero,2027760 <getPHYSpeed+0x198>
 2027754:	00808134 	movhi	r2,516
 2027758:	10874c04 	addi	r2,r2,7472
 202775c:	00000806 	br	2027780 <getPHYSpeed+0x1b8>
 2027760:	00808134 	movhi	r2,516
 2027764:	10874d04 	addi	r2,r2,7476
 2027768:	00000506 	br	2027780 <getPHYSpeed+0x1b8>
 202776c:	00808134 	movhi	r2,516
 2027770:	10874f04 	addi	r2,r2,7484
 2027774:	00000206 	br	2027780 <getPHYSpeed+0x1b8>
 2027778:	00808134 	movhi	r2,516
 202777c:	10875004 	addi	r2,r2,7488
 2027780:	e0fff743 	ldbu	r3,-35(fp)
 2027784:	18c00058 	cmpnei	r3,r3,1
 2027788:	1800031e 	bne	r3,zero,2027798 <getPHYSpeed+0x1d0>
 202778c:	00c08134 	movhi	r3,516
 2027790:	18c75204 	addi	r3,r3,7496
 2027794:	00000206 	br	20277a0 <getPHYSpeed+0x1d8>
 2027798:	00c08134 	movhi	r3,516
 202779c:	18c75404 	addi	r3,r3,7504
 20277a0:	180d883a 	mov	r6,r3
 20277a4:	100b883a 	mov	r5,r2
 20277a8:	01008134 	movhi	r4,516
 20277ac:	21075604 	addi	r4,r4,7512
 20277b0:	2000bb00 	call	2000bb0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 20277b4:	01008134 	movhi	r4,516
 20277b8:	21076e04 	addi	r4,r4,7608
 20277bc:	203ceb40 	call	203ceb4 <puts>
        return result;
 20277c0:	e0bff817 	ldw	r2,-32(fp)
 20277c4:	00021a06 	br	2028030 <getPHYSpeed+0xa68>
    }
    
    pphy = pmac_info->pphy_info;
 20277c8:	e0bffa17 	ldw	r2,-24(fp)
 20277cc:	10800117 	ldw	r2,4(r2)
 20277d0:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 20277d4:	e0bffa17 	ldw	r2,-24(fp)
 20277d8:	10800317 	ldw	r2,12(r2)
 20277dc:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 20277e0:	e0bffa17 	ldw	r2,-24(fp)
 20277e4:	10800217 	ldw	r2,8(r2)
 20277e8:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20277ec:	e13ffa17 	ldw	r4,-24(fp)
 20277f0:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 20277f4:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 20277f8:	e13ffb17 	ldw	r4,-20(fp)
 20277fc:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 2027800:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 2027804:	e0bffb17 	ldw	r2,-20(fp)
 2027808:	10800117 	ldw	r2,4(r2)
 202780c:	10800217 	ldw	r2,8(r2)
 2027810:	10800203 	ldbu	r2,8(r2)
 2027814:	10803fcc 	andi	r2,r2,255
 2027818:	10005a1e 	bne	r2,zero,2027984 <getPHYSpeed+0x3bc>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 202781c:	00800044 	movi	r2,1
 2027820:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2027824:	00800044 	movi	r2,1
 2027828:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 202782c:	e0bff743 	ldbu	r2,-35(fp)
 2027830:	10c0004c 	andi	r3,r2,1
 2027834:	e0bff703 	ldbu	r2,-36(fp)
 2027838:	10800098 	cmpnei	r2,r2,2
 202783c:	1000021e 	bne	r2,zero,2027848 <getPHYSpeed+0x280>
 2027840:	00800084 	movi	r2,2
 2027844:	00000106 	br	202784c <getPHYSpeed+0x284>
 2027848:	0005883a 	mov	r2,zero
 202784c:	1886b03a 	or	r3,r3,r2
 2027850:	e0bff703 	ldbu	r2,-36(fp)
 2027854:	10800058 	cmpnei	r2,r2,1
 2027858:	1000021e 	bne	r2,zero,2027864 <getPHYSpeed+0x29c>
 202785c:	00800104 	movi	r2,4
 2027860:	00000106 	br	2027868 <getPHYSpeed+0x2a0>
 2027864:	0005883a 	mov	r2,zero
 2027868:	1886b03a 	or	r3,r3,r2
 202786c:	e0bff703 	ldbu	r2,-36(fp)
 2027870:	1000021e 	bne	r2,zero,202787c <getPHYSpeed+0x2b4>
 2027874:	00800204 	movi	r2,8
 2027878:	00000106 	br	2027880 <getPHYSpeed+0x2b8>
 202787c:	0005883a 	mov	r2,zero
 2027880:	1886b03a 	or	r3,r3,r2
 2027884:	e0bff703 	ldbu	r2,-36(fp)
 2027888:	108000d8 	cmpnei	r2,r2,3
 202788c:	1000021e 	bne	r2,zero,2027898 <getPHYSpeed+0x2d0>
 2027890:	00800074 	movhi	r2,1
 2027894:	00000106 	br	202789c <getPHYSpeed+0x2d4>
 2027898:	0005883a 	mov	r2,zero
 202789c:	1884b03a 	or	r2,r3,r2
 20278a0:	10801034 	orhi	r2,r2,64
 20278a4:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 20278a8:	010003f4 	movhi	r4,15
 20278ac:	21109004 	addi	r4,r4,16960
 20278b0:	202d1500 	call	202d150 <usleep>
        if(psys->tse_phy_cfg) {
 20278b4:	e0bffc17 	ldw	r2,-16(fp)
 20278b8:	10801117 	ldw	r2,68(r2)
 20278bc:	10000d26 	beq	r2,zero,20278f4 <getPHYSpeed+0x32c>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 20278c0:	e0bffd47 	ldb	r2,-11(fp)
 20278c4:	e0fffd07 	ldb	r3,-12(fp)
 20278c8:	180d883a 	mov	r6,r3
 20278cc:	100b883a 	mov	r5,r2
 20278d0:	01008134 	movhi	r4,516
 20278d4:	21077f04 	addi	r4,r4,7676
 20278d8:	2000bb00 	call	2000bb0 <printf>
        	result = psys->tse_phy_cfg(pmac);
 20278dc:	e0bffc17 	ldw	r2,-16(fp)
 20278e0:	10801117 	ldw	r2,68(r2)
 20278e4:	e13fff17 	ldw	r4,-4(fp)
 20278e8:	103ee83a 	callr	r2
 20278ec:	e0bff815 	stw	r2,-32(fp)
 20278f0:	00002206 	br	202797c <getPHYSpeed+0x3b4>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 20278f4:	e13ffd47 	ldb	r4,-11(fp)
 20278f8:	e0bff703 	ldbu	r2,-36(fp)
 20278fc:	108000a0 	cmpeqi	r2,r2,2
 2027900:	10000e1e 	bne	r2,zero,202793c <getPHYSpeed+0x374>
 2027904:	e0bff703 	ldbu	r2,-36(fp)
 2027908:	10800060 	cmpeqi	r2,r2,1
 202790c:	1000081e 	bne	r2,zero,2027930 <getPHYSpeed+0x368>
 2027910:	e0bff703 	ldbu	r2,-36(fp)
 2027914:	1000031e 	bne	r2,zero,2027924 <getPHYSpeed+0x35c>
 2027918:	00808134 	movhi	r2,516
 202791c:	10874c04 	addi	r2,r2,7472
 2027920:	00000806 	br	2027944 <getPHYSpeed+0x37c>
 2027924:	00808134 	movhi	r2,516
 2027928:	10874d04 	addi	r2,r2,7476
 202792c:	00000506 	br	2027944 <getPHYSpeed+0x37c>
 2027930:	00808134 	movhi	r2,516
 2027934:	10874f04 	addi	r2,r2,7484
 2027938:	00000206 	br	2027944 <getPHYSpeed+0x37c>
 202793c:	00808134 	movhi	r2,516
 2027940:	10875004 	addi	r2,r2,7488
 2027944:	e0fff743 	ldbu	r3,-35(fp)
 2027948:	18c00058 	cmpnei	r3,r3,1
 202794c:	1800031e 	bne	r3,zero,202795c <getPHYSpeed+0x394>
 2027950:	00c08134 	movhi	r3,516
 2027954:	18c75204 	addi	r3,r3,7496
 2027958:	00000206 	br	2027964 <getPHYSpeed+0x39c>
 202795c:	00c08134 	movhi	r3,516
 2027960:	18c75404 	addi	r3,r3,7504
 2027964:	180f883a 	mov	r7,r3
 2027968:	100d883a 	mov	r6,r2
 202796c:	200b883a 	mov	r5,r4
 2027970:	01008134 	movhi	r4,516
 2027974:	21079104 	addi	r4,r4,7748
 2027978:	2000bb00 	call	2000bb0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 202797c:	e0bff817 	ldw	r2,-32(fp)
 2027980:	0001ab06 	br	2028030 <getPHYSpeed+0xa68>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2027984:	e0bffb17 	ldw	r2,-20(fp)
 2027988:	10800117 	ldw	r2,4(r2)
 202798c:	10800217 	ldw	r2,8(r2)
 2027990:	10800017 	ldw	r2,0(r2)
 2027994:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 2027998:	e0bff917 	ldw	r2,-28(fp)
 202799c:	1000491e 	bne	r2,zero,2027ac4 <getPHYSpeed+0x4fc>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20279a0:	00800044 	movi	r2,1
 20279a4:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 20279a8:	00800044 	movi	r2,1
 20279ac:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 20279b0:	e0bff743 	ldbu	r2,-35(fp)
 20279b4:	10c0004c 	andi	r3,r2,1
 20279b8:	e0bff703 	ldbu	r2,-36(fp)
 20279bc:	10800098 	cmpnei	r2,r2,2
 20279c0:	1000021e 	bne	r2,zero,20279cc <getPHYSpeed+0x404>
 20279c4:	00800084 	movi	r2,2
 20279c8:	00000106 	br	20279d0 <getPHYSpeed+0x408>
 20279cc:	0005883a 	mov	r2,zero
 20279d0:	1886b03a 	or	r3,r3,r2
 20279d4:	e0bff703 	ldbu	r2,-36(fp)
 20279d8:	10800058 	cmpnei	r2,r2,1
 20279dc:	1000021e 	bne	r2,zero,20279e8 <getPHYSpeed+0x420>
 20279e0:	00800104 	movi	r2,4
 20279e4:	00000106 	br	20279ec <getPHYSpeed+0x424>
 20279e8:	0005883a 	mov	r2,zero
 20279ec:	1886b03a 	or	r3,r3,r2
 20279f0:	e0bff703 	ldbu	r2,-36(fp)
 20279f4:	1000021e 	bne	r2,zero,2027a00 <getPHYSpeed+0x438>
 20279f8:	00800204 	movi	r2,8
 20279fc:	00000106 	br	2027a04 <getPHYSpeed+0x43c>
 2027a00:	0005883a 	mov	r2,zero
 2027a04:	1886b03a 	or	r3,r3,r2
 2027a08:	e0bff703 	ldbu	r2,-36(fp)
 2027a0c:	108000d8 	cmpnei	r2,r2,3
 2027a10:	1000021e 	bne	r2,zero,2027a1c <getPHYSpeed+0x454>
 2027a14:	00800074 	movhi	r2,1
 2027a18:	00000106 	br	2027a20 <getPHYSpeed+0x458>
 2027a1c:	0005883a 	mov	r2,zero
 2027a20:	1884b03a 	or	r2,r3,r2
 2027a24:	10800834 	orhi	r2,r2,32
 2027a28:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2027a2c:	e13ffd47 	ldb	r4,-11(fp)
 2027a30:	e17ffd07 	ldb	r5,-12(fp)
 2027a34:	e0bff703 	ldbu	r2,-36(fp)
 2027a38:	108000a0 	cmpeqi	r2,r2,2
 2027a3c:	10000e1e 	bne	r2,zero,2027a78 <getPHYSpeed+0x4b0>
 2027a40:	e0bff703 	ldbu	r2,-36(fp)
 2027a44:	10800060 	cmpeqi	r2,r2,1
 2027a48:	1000081e 	bne	r2,zero,2027a6c <getPHYSpeed+0x4a4>
 2027a4c:	e0bff703 	ldbu	r2,-36(fp)
 2027a50:	1000031e 	bne	r2,zero,2027a60 <getPHYSpeed+0x498>
 2027a54:	00808134 	movhi	r2,516
 2027a58:	10874c04 	addi	r2,r2,7472
 2027a5c:	00000806 	br	2027a80 <getPHYSpeed+0x4b8>
 2027a60:	00808134 	movhi	r2,516
 2027a64:	10874d04 	addi	r2,r2,7476
 2027a68:	00000506 	br	2027a80 <getPHYSpeed+0x4b8>
 2027a6c:	00808134 	movhi	r2,516
 2027a70:	10874f04 	addi	r2,r2,7484
 2027a74:	00000206 	br	2027a80 <getPHYSpeed+0x4b8>
 2027a78:	00808134 	movhi	r2,516
 2027a7c:	10875004 	addi	r2,r2,7488
 2027a80:	e0fff743 	ldbu	r3,-35(fp)
 2027a84:	18c00058 	cmpnei	r3,r3,1
 2027a88:	1800031e 	bne	r3,zero,2027a98 <getPHYSpeed+0x4d0>
 2027a8c:	00c08134 	movhi	r3,516
 2027a90:	18c75204 	addi	r3,r3,7496
 2027a94:	00000206 	br	2027aa0 <getPHYSpeed+0x4d8>
 2027a98:	00c08134 	movhi	r3,516
 2027a9c:	18c75404 	addi	r3,r3,7504
 2027aa0:	d8c00015 	stw	r3,0(sp)
 2027aa4:	100f883a 	mov	r7,r2
 2027aa8:	280d883a 	mov	r6,r5
 2027aac:	200b883a 	mov	r5,r4
 2027ab0:	01008134 	movhi	r4,516
 2027ab4:	2107a304 	addi	r4,r4,7820
 2027ab8:	2000bb00 	call	2000bb0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 2027abc:	e0bff817 	ldw	r2,-32(fp)
 2027ac0:	00015b06 	br	2028030 <getPHYSpeed+0xa68>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 2027ac4:	e0bffa17 	ldw	r2,-24(fp)
 2027ac8:	10800003 	ldbu	r2,0(r2)
 2027acc:	10803fcc 	andi	r2,r2,255
 2027ad0:	10800058 	cmpnei	r2,r2,1
 2027ad4:	1000071e 	bne	r2,zero,2027af4 <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
 2027ad8:	000b883a 	mov	r5,zero
 2027adc:	e13ff917 	ldw	r4,-28(fp)
 2027ae0:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2027ae4:	017e0034 	movhi	r5,63488
 2027ae8:	e13ff917 	ldw	r4,-28(fp)
 2027aec:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
 2027af0:	00000e06 	br	2027b2c <getPHYSpeed+0x564>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 2027af4:	e0bffa17 	ldw	r2,-24(fp)
 2027af8:	10800003 	ldbu	r2,0(r2)
 2027afc:	10803fcc 	andi	r2,r2,255
 2027b00:	10800098 	cmpnei	r2,r2,2
 2027b04:	1000091e 	bne	r2,zero,2027b2c <getPHYSpeed+0x564>
			alt_tse_phy_set_adv_100(pphy, 0);
 2027b08:	000b883a 	mov	r5,zero
 2027b0c:	e13ff917 	ldw	r4,-28(fp)
 2027b10:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 2027b14:	000b883a 	mov	r5,zero
 2027b18:	e13ff917 	ldw	r4,-28(fp)
 2027b1c:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2027b20:	017e0034 	movhi	r5,63488
 2027b24:	e13ff917 	ldw	r4,-28(fp)
 2027b28:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 2027b2c:	017e0034 	movhi	r5,63488
 2027b30:	e13ff917 	ldw	r4,-28(fp)
 2027b34:	20298900 	call	2029890 <alt_tse_phy_check_link>
 2027b38:	10bfffd8 	cmpnei	r2,r2,-1
 2027b3c:	1000491e 	bne	r2,zero,2027c64 <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2027b40:	00800044 	movi	r2,1
 2027b44:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2027b48:	00800044 	movi	r2,1
 2027b4c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 2027b50:	e0bff743 	ldbu	r2,-35(fp)
 2027b54:	10c0004c 	andi	r3,r2,1
 2027b58:	e0bff703 	ldbu	r2,-36(fp)
 2027b5c:	10800098 	cmpnei	r2,r2,2
 2027b60:	1000021e 	bne	r2,zero,2027b6c <getPHYSpeed+0x5a4>
 2027b64:	00800084 	movi	r2,2
 2027b68:	00000106 	br	2027b70 <getPHYSpeed+0x5a8>
 2027b6c:	0005883a 	mov	r2,zero
 2027b70:	1886b03a 	or	r3,r3,r2
 2027b74:	e0bff703 	ldbu	r2,-36(fp)
 2027b78:	10800058 	cmpnei	r2,r2,1
 2027b7c:	1000021e 	bne	r2,zero,2027b88 <getPHYSpeed+0x5c0>
 2027b80:	00800104 	movi	r2,4
 2027b84:	00000106 	br	2027b8c <getPHYSpeed+0x5c4>
 2027b88:	0005883a 	mov	r2,zero
 2027b8c:	1886b03a 	or	r3,r3,r2
 2027b90:	e0bff703 	ldbu	r2,-36(fp)
 2027b94:	1000021e 	bne	r2,zero,2027ba0 <getPHYSpeed+0x5d8>
 2027b98:	00800204 	movi	r2,8
 2027b9c:	00000106 	br	2027ba4 <getPHYSpeed+0x5dc>
 2027ba0:	0005883a 	mov	r2,zero
 2027ba4:	1886b03a 	or	r3,r3,r2
 2027ba8:	e0bff703 	ldbu	r2,-36(fp)
 2027bac:	108000d8 	cmpnei	r2,r2,3
 2027bb0:	1000021e 	bne	r2,zero,2027bbc <getPHYSpeed+0x5f4>
 2027bb4:	00800074 	movhi	r2,1
 2027bb8:	00000106 	br	2027bc0 <getPHYSpeed+0x5f8>
 2027bbc:	0005883a 	mov	r2,zero
 2027bc0:	1884b03a 	or	r2,r3,r2
 2027bc4:	10800234 	orhi	r2,r2,8
 2027bc8:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2027bcc:	e13ffd47 	ldb	r4,-11(fp)
 2027bd0:	e17ffd07 	ldb	r5,-12(fp)
 2027bd4:	e0bff703 	ldbu	r2,-36(fp)
 2027bd8:	108000a0 	cmpeqi	r2,r2,2
 2027bdc:	10000e1e 	bne	r2,zero,2027c18 <getPHYSpeed+0x650>
 2027be0:	e0bff703 	ldbu	r2,-36(fp)
 2027be4:	10800060 	cmpeqi	r2,r2,1
 2027be8:	1000081e 	bne	r2,zero,2027c0c <getPHYSpeed+0x644>
 2027bec:	e0bff703 	ldbu	r2,-36(fp)
 2027bf0:	1000031e 	bne	r2,zero,2027c00 <getPHYSpeed+0x638>
 2027bf4:	00808134 	movhi	r2,516
 2027bf8:	10874c04 	addi	r2,r2,7472
 2027bfc:	00000806 	br	2027c20 <getPHYSpeed+0x658>
 2027c00:	00808134 	movhi	r2,516
 2027c04:	10874d04 	addi	r2,r2,7476
 2027c08:	00000506 	br	2027c20 <getPHYSpeed+0x658>
 2027c0c:	00808134 	movhi	r2,516
 2027c10:	10874f04 	addi	r2,r2,7484
 2027c14:	00000206 	br	2027c20 <getPHYSpeed+0x658>
 2027c18:	00808134 	movhi	r2,516
 2027c1c:	10875004 	addi	r2,r2,7488
 2027c20:	e0fff743 	ldbu	r3,-35(fp)
 2027c24:	18c00058 	cmpnei	r3,r3,1
 2027c28:	1800031e 	bne	r3,zero,2027c38 <getPHYSpeed+0x670>
 2027c2c:	00c08134 	movhi	r3,516
 2027c30:	18c75204 	addi	r3,r3,7496
 2027c34:	00000206 	br	2027c40 <getPHYSpeed+0x678>
 2027c38:	00c08134 	movhi	r3,516
 2027c3c:	18c75404 	addi	r3,r3,7504
 2027c40:	d8c00015 	stw	r3,0(sp)
 2027c44:	100f883a 	mov	r7,r2
 2027c48:	280d883a 	mov	r6,r5
 2027c4c:	200b883a 	mov	r5,r4
 2027c50:	01008134 	movhi	r4,516
 2027c54:	2107b404 	addi	r4,r4,7888
 2027c58:	2000bb00 	call	2000bb0 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 2027c5c:	e0bff817 	ldw	r2,-32(fp)
 2027c60:	0000f306 	br	2028030 <getPHYSpeed+0xa68>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 2027c64:	e0bffe17 	ldw	r2,-8(fp)
 2027c68:	10801004 	addi	r2,r2,64
 2027c6c:	e0fff917 	ldw	r3,-28(fp)
 2027c70:	18c00003 	ldbu	r3,0(r3)
 2027c74:	18c03fcc 	andi	r3,r3,255
 2027c78:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 2027c7c:	d8000015 	stw	zero,0(sp)
 2027c80:	01c00044 	movi	r7,1
 2027c84:	01800384 	movi	r6,14
 2027c88:	000b883a 	mov	r5,zero
 2027c8c:	e13ff917 	ldw	r4,-28(fp)
 2027c90:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 2027c94:	e0bff917 	ldw	r2,-28(fp)
 2027c98:	10800517 	ldw	r2,20(r2)
 2027c9c:	10002b1e 	bne	r2,zero,2027d4c <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 2027ca0:	e0bffd47 	ldb	r2,-11(fp)
 2027ca4:	e0fffd07 	ldb	r3,-12(fp)
 2027ca8:	180d883a 	mov	r6,r3
 2027cac:	100b883a 	mov	r5,r2
 2027cb0:	01008134 	movhi	r4,516
 2027cb4:	2107c804 	addi	r4,r4,7968
 2027cb8:	2000bb00 	call	2000bb0 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2027cbc:	00800044 	movi	r2,1
 2027cc0:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2027cc4:	00800044 	movi	r2,1
 2027cc8:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 2027ccc:	e0bff743 	ldbu	r2,-35(fp)
 2027cd0:	10c0004c 	andi	r3,r2,1
 2027cd4:	e0bff703 	ldbu	r2,-36(fp)
 2027cd8:	10800098 	cmpnei	r2,r2,2
 2027cdc:	1000021e 	bne	r2,zero,2027ce8 <getPHYSpeed+0x720>
 2027ce0:	00800084 	movi	r2,2
 2027ce4:	00000106 	br	2027cec <getPHYSpeed+0x724>
 2027ce8:	0005883a 	mov	r2,zero
 2027cec:	1886b03a 	or	r3,r3,r2
 2027cf0:	e0bff703 	ldbu	r2,-36(fp)
 2027cf4:	10800058 	cmpnei	r2,r2,1
 2027cf8:	1000021e 	bne	r2,zero,2027d04 <getPHYSpeed+0x73c>
 2027cfc:	00800104 	movi	r2,4
 2027d00:	00000106 	br	2027d08 <getPHYSpeed+0x740>
 2027d04:	0005883a 	mov	r2,zero
 2027d08:	1886b03a 	or	r3,r3,r2
 2027d0c:	e0bff703 	ldbu	r2,-36(fp)
 2027d10:	1000021e 	bne	r2,zero,2027d1c <getPHYSpeed+0x754>
 2027d14:	00800204 	movi	r2,8
 2027d18:	00000106 	br	2027d20 <getPHYSpeed+0x758>
 2027d1c:	0005883a 	mov	r2,zero
 2027d20:	1886b03a 	or	r3,r3,r2
 2027d24:	e0bff703 	ldbu	r2,-36(fp)
 2027d28:	108000d8 	cmpnei	r2,r2,3
 2027d2c:	1000021e 	bne	r2,zero,2027d38 <getPHYSpeed+0x770>
 2027d30:	00800074 	movhi	r2,1
 2027d34:	00000106 	br	2027d3c <getPHYSpeed+0x774>
 2027d38:	0005883a 	mov	r2,zero
 2027d3c:	1884b03a 	or	r2,r3,r2
 2027d40:	10800134 	orhi	r2,r2,4
 2027d44:	e0bff815 	stw	r2,-32(fp)
 2027d48:	00009406 	br	2027f9c <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 2027d4c:	e0bff917 	ldw	r2,-28(fp)
 2027d50:	10800517 	ldw	r2,20(r2)
 2027d54:	10801817 	ldw	r2,96(r2)
 2027d58:	10002626 	beq	r2,zero,2027df4 <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 2027d5c:	e0bff917 	ldw	r2,-28(fp)
 2027d60:	10800517 	ldw	r2,20(r2)
 2027d64:	10801817 	ldw	r2,96(r2)
 2027d68:	e13ffe17 	ldw	r4,-8(fp)
 2027d6c:	103ee83a 	callr	r2
 2027d70:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2027d74:	e0bff817 	ldw	r2,-32(fp)
 2027d78:	1080008c 	andi	r2,r2,2
 2027d7c:	10000c1e 	bne	r2,zero,2027db0 <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 2027d80:	e0bff817 	ldw	r2,-32(fp)
 2027d84:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2027d88:	1000071e 	bne	r2,zero,2027da8 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 2027d8c:	e0bff817 	ldw	r2,-32(fp)
 2027d90:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2027d94:	10000226 	beq	r2,zero,2027da0 <getPHYSpeed+0x7d8>
 2027d98:	0005883a 	mov	r2,zero
 2027d9c:	00000506 	br	2027db4 <getPHYSpeed+0x7ec>
 2027da0:	008000c4 	movi	r2,3
 2027da4:	00000306 	br	2027db4 <getPHYSpeed+0x7ec>
 2027da8:	00800044 	movi	r2,1
 2027dac:	00000106 	br	2027db4 <getPHYSpeed+0x7ec>
 2027db0:	00800084 	movi	r2,2
 2027db4:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 2027db8:	e0bff817 	ldw	r2,-32(fp)
 2027dbc:	1080004c 	andi	r2,r2,1
 2027dc0:	1004c03a 	cmpne	r2,r2,zero
 2027dc4:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 2027dc8:	e0bff817 	ldw	r2,-32(fp)
 2027dcc:	1080006c 	andhi	r2,r2,1
 2027dd0:	10007226 	beq	r2,zero,2027f9c <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 2027dd4:	e0bffd47 	ldb	r2,-11(fp)
 2027dd8:	e0fffd07 	ldb	r3,-12(fp)
 2027ddc:	180d883a 	mov	r6,r3
 2027de0:	100b883a 	mov	r5,r2
 2027de4:	01008134 	movhi	r4,516
 2027de8:	2107d604 	addi	r4,r4,8024
 2027dec:	2000bb00 	call	2000bb0 <printf>
 2027df0:	00006a06 	br	2027f9c <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 2027df4:	e0bff917 	ldw	r2,-28(fp)
 2027df8:	10800517 	ldw	r2,20(r2)
 2027dfc:	10801583 	ldbu	r2,86(r2)
 2027e00:	10803fcc 	andi	r2,r2,255
 2027e04:	10002b1e 	bne	r2,zero,2027eb4 <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 2027e08:	e0bffd47 	ldb	r2,-11(fp)
 2027e0c:	e0fffd07 	ldb	r3,-12(fp)
 2027e10:	180d883a 	mov	r6,r3
 2027e14:	100b883a 	mov	r5,r2
 2027e18:	01008134 	movhi	r4,516
 2027e1c:	2107e304 	addi	r4,r4,8076
 2027e20:	2000bb00 	call	2000bb0 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2027e24:	00800044 	movi	r2,1
 2027e28:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2027e2c:	00800044 	movi	r2,1
 2027e30:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 2027e34:	e0bff743 	ldbu	r2,-35(fp)
 2027e38:	10c0004c 	andi	r3,r2,1
 2027e3c:	e0bff703 	ldbu	r2,-36(fp)
 2027e40:	10800098 	cmpnei	r2,r2,2
 2027e44:	1000021e 	bne	r2,zero,2027e50 <getPHYSpeed+0x888>
 2027e48:	00800084 	movi	r2,2
 2027e4c:	00000106 	br	2027e54 <getPHYSpeed+0x88c>
 2027e50:	0005883a 	mov	r2,zero
 2027e54:	1886b03a 	or	r3,r3,r2
 2027e58:	e0bff703 	ldbu	r2,-36(fp)
 2027e5c:	10800058 	cmpnei	r2,r2,1
 2027e60:	1000021e 	bne	r2,zero,2027e6c <getPHYSpeed+0x8a4>
 2027e64:	00800104 	movi	r2,4
 2027e68:	00000106 	br	2027e70 <getPHYSpeed+0x8a8>
 2027e6c:	0005883a 	mov	r2,zero
 2027e70:	1886b03a 	or	r3,r3,r2
 2027e74:	e0bff703 	ldbu	r2,-36(fp)
 2027e78:	1000021e 	bne	r2,zero,2027e84 <getPHYSpeed+0x8bc>
 2027e7c:	00800204 	movi	r2,8
 2027e80:	00000106 	br	2027e88 <getPHYSpeed+0x8c0>
 2027e84:	0005883a 	mov	r2,zero
 2027e88:	1886b03a 	or	r3,r3,r2
 2027e8c:	e0bff703 	ldbu	r2,-36(fp)
 2027e90:	108000d8 	cmpnei	r2,r2,3
 2027e94:	1000021e 	bne	r2,zero,2027ea0 <getPHYSpeed+0x8d8>
 2027e98:	00800074 	movhi	r2,1
 2027e9c:	00000106 	br	2027ea4 <getPHYSpeed+0x8dc>
 2027ea0:	0005883a 	mov	r2,zero
 2027ea4:	1884b03a 	or	r2,r3,r2
 2027ea8:	108000b4 	orhi	r2,r2,2
 2027eac:	e0bff815 	stw	r2,-32(fp)
 2027eb0:	00003a06 	br	2027f9c <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 2027eb4:	e0bff917 	ldw	r2,-28(fp)
 2027eb8:	10800517 	ldw	r2,20(r2)
 2027ebc:	10801583 	ldbu	r2,86(r2)
 2027ec0:	10c03fcc 	andi	r3,r2,255
 2027ec4:	e0bff917 	ldw	r2,-28(fp)
 2027ec8:	10800517 	ldw	r2,20(r2)
 2027ecc:	108015c3 	ldbu	r2,87(r2)
 2027ed0:	10803fcc 	andi	r2,r2,255
 2027ed4:	01c00084 	movi	r7,2
 2027ed8:	100d883a 	mov	r6,r2
 2027edc:	180b883a 	mov	r5,r3
 2027ee0:	e13ff917 	ldw	r4,-28(fp)
 2027ee4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2027ee8:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 2027eec:	e0bff917 	ldw	r2,-28(fp)
 2027ef0:	10800517 	ldw	r2,20(r2)
 2027ef4:	10801583 	ldbu	r2,86(r2)
 2027ef8:	10c03fcc 	andi	r3,r2,255
 2027efc:	e0bff917 	ldw	r2,-28(fp)
 2027f00:	10800517 	ldw	r2,20(r2)
 2027f04:	10801603 	ldbu	r2,88(r2)
 2027f08:	10803fcc 	andi	r2,r2,255
 2027f0c:	01c00044 	movi	r7,1
 2027f10:	100d883a 	mov	r6,r2
 2027f14:	180b883a 	mov	r5,r3
 2027f18:	e13ff917 	ldw	r4,-28(fp)
 2027f1c:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2027f20:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 2027f24:	e0bff743 	ldbu	r2,-35(fp)
 2027f28:	10c0004c 	andi	r3,r2,1
 2027f2c:	e0bff703 	ldbu	r2,-36(fp)
 2027f30:	10800098 	cmpnei	r2,r2,2
 2027f34:	1000021e 	bne	r2,zero,2027f40 <getPHYSpeed+0x978>
 2027f38:	00800084 	movi	r2,2
 2027f3c:	00000106 	br	2027f44 <getPHYSpeed+0x97c>
 2027f40:	0005883a 	mov	r2,zero
 2027f44:	1886b03a 	or	r3,r3,r2
 2027f48:	e0bff703 	ldbu	r2,-36(fp)
 2027f4c:	10800058 	cmpnei	r2,r2,1
 2027f50:	1000021e 	bne	r2,zero,2027f5c <getPHYSpeed+0x994>
 2027f54:	00800104 	movi	r2,4
 2027f58:	00000106 	br	2027f60 <getPHYSpeed+0x998>
 2027f5c:	0005883a 	mov	r2,zero
 2027f60:	1886b03a 	or	r3,r3,r2
 2027f64:	e0bff703 	ldbu	r2,-36(fp)
 2027f68:	1000021e 	bne	r2,zero,2027f74 <getPHYSpeed+0x9ac>
 2027f6c:	00800204 	movi	r2,8
 2027f70:	00000106 	br	2027f78 <getPHYSpeed+0x9b0>
 2027f74:	0005883a 	mov	r2,zero
 2027f78:	1886b03a 	or	r3,r3,r2
 2027f7c:	e0bff703 	ldbu	r2,-36(fp)
 2027f80:	108000d8 	cmpnei	r2,r2,3
 2027f84:	1000021e 	bne	r2,zero,2027f90 <getPHYSpeed+0x9c8>
 2027f88:	00800074 	movhi	r2,1
 2027f8c:	00000106 	br	2027f94 <getPHYSpeed+0x9cc>
 2027f90:	0005883a 	mov	r2,zero
 2027f94:	1884b03a 	or	r2,r3,r2
 2027f98:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2027f9c:	e13ffd47 	ldb	r4,-11(fp)
 2027fa0:	e17ffd07 	ldb	r5,-12(fp)
 2027fa4:	e0bff703 	ldbu	r2,-36(fp)
 2027fa8:	108000a0 	cmpeqi	r2,r2,2
 2027fac:	10000e1e 	bne	r2,zero,2027fe8 <getPHYSpeed+0xa20>
 2027fb0:	e0bff703 	ldbu	r2,-36(fp)
 2027fb4:	10800060 	cmpeqi	r2,r2,1
 2027fb8:	1000081e 	bne	r2,zero,2027fdc <getPHYSpeed+0xa14>
 2027fbc:	e0bff703 	ldbu	r2,-36(fp)
 2027fc0:	1000031e 	bne	r2,zero,2027fd0 <getPHYSpeed+0xa08>
 2027fc4:	00808134 	movhi	r2,516
 2027fc8:	10874c04 	addi	r2,r2,7472
 2027fcc:	00000806 	br	2027ff0 <getPHYSpeed+0xa28>
 2027fd0:	00808134 	movhi	r2,516
 2027fd4:	10874d04 	addi	r2,r2,7476
 2027fd8:	00000506 	br	2027ff0 <getPHYSpeed+0xa28>
 2027fdc:	00808134 	movhi	r2,516
 2027fe0:	10874f04 	addi	r2,r2,7484
 2027fe4:	00000206 	br	2027ff0 <getPHYSpeed+0xa28>
 2027fe8:	00808134 	movhi	r2,516
 2027fec:	10875004 	addi	r2,r2,7488
 2027ff0:	e0fff743 	ldbu	r3,-35(fp)
 2027ff4:	18c00058 	cmpnei	r3,r3,1
 2027ff8:	1800031e 	bne	r3,zero,2028008 <getPHYSpeed+0xa40>
 2027ffc:	00c08134 	movhi	r3,516
 2028000:	18c75204 	addi	r3,r3,7496
 2028004:	00000206 	br	2028010 <getPHYSpeed+0xa48>
 2028008:	00c08134 	movhi	r3,516
 202800c:	18c75404 	addi	r3,r3,7504
 2028010:	d8c00015 	stw	r3,0(sp)
 2028014:	100f883a 	mov	r7,r2
 2028018:	280d883a 	mov	r6,r5
 202801c:	200b883a 	mov	r5,r4
 2028020:	01008134 	movhi	r4,516
 2028024:	2107fa04 	addi	r4,r4,8168
 2028028:	2000bb00 	call	2000bb0 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 202802c:	e0bff817 	ldw	r2,-32(fp)
}
 2028030:	e037883a 	mov	sp,fp
 2028034:	dfc00117 	ldw	ra,4(sp)
 2028038:	df000017 	ldw	fp,0(sp)
 202803c:	dec00204 	addi	sp,sp,8
 2028040:	f800283a 	ret

02028044 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 2028044:	defffd04 	addi	sp,sp,-12
 2028048:	df000215 	stw	fp,8(sp)
 202804c:	df000204 	addi	fp,sp,8
 2028050:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2028054:	e0bfff17 	ldw	r2,-4(fp)
 2028058:	10800617 	ldw	r2,24(r2)
 202805c:	10800317 	ldw	r2,12(r2)
 2028060:	10800117 	ldw	r2,4(r2)
 2028064:	10800217 	ldw	r2,8(r2)
 2028068:	10800017 	ldw	r2,0(r2)
 202806c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 2028070:	e0bffe17 	ldw	r2,-8(fp)
 2028074:	10801004 	addi	r2,r2,64
 2028078:	10800037 	ldwio	r2,0(r2)
}
 202807c:	e037883a 	mov	sp,fp
 2028080:	df000017 	ldw	fp,0(sp)
 2028084:	dec00104 	addi	sp,sp,4
 2028088:	f800283a 	ret

0202808c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 202808c:	defffc04 	addi	sp,sp,-16
 2028090:	df000315 	stw	fp,12(sp)
 2028094:	df000304 	addi	fp,sp,12
 2028098:	e13ffe15 	stw	r4,-8(fp)
 202809c:	2805883a 	mov	r2,r5
 20280a0:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 20280a4:	e0bffe17 	ldw	r2,-8(fp)
 20280a8:	10800617 	ldw	r2,24(r2)
 20280ac:	10800317 	ldw	r2,12(r2)
 20280b0:	10800117 	ldw	r2,4(r2)
 20280b4:	10800217 	ldw	r2,8(r2)
 20280b8:	10800017 	ldw	r2,0(r2)
 20280bc:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 20280c0:	e0bffd17 	ldw	r2,-12(fp)
 20280c4:	10801004 	addi	r2,r2,64
 20280c8:	e0ffff03 	ldbu	r3,-4(fp)
 20280cc:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 20280d0:	0005883a 	mov	r2,zero
}
 20280d4:	e037883a 	mov	sp,fp
 20280d8:	df000017 	ldw	fp,0(sp)
 20280dc:	dec00104 	addi	sp,sp,4
 20280e0:	f800283a 	ret

020280e4 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 20280e4:	defff604 	addi	sp,sp,-40
 20280e8:	df000915 	stw	fp,36(sp)
 20280ec:	df000904 	addi	fp,sp,36
 20280f0:	e13ffb15 	stw	r4,-20(fp)
 20280f4:	3009883a 	mov	r4,r6
 20280f8:	3807883a 	mov	r3,r7
 20280fc:	e0800117 	ldw	r2,4(fp)
 2028100:	e17ffc05 	stb	r5,-16(fp)
 2028104:	e13ffd05 	stb	r4,-12(fp)
 2028108:	e0fffe05 	stb	r3,-8(fp)
 202810c:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2028110:	e0bffb17 	ldw	r2,-20(fp)
 2028114:	10800617 	ldw	r2,24(r2)
 2028118:	10800317 	ldw	r2,12(r2)
 202811c:	10800117 	ldw	r2,4(r2)
 2028120:	10800217 	ldw	r2,8(r2)
 2028124:	10800017 	ldw	r2,0(r2)
 2028128:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 202812c:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 2028130:	e03ff815 	stw	zero,-32(fp)
 2028134:	00000906 	br	202815c <alt_tse_phy_wr_mdio_reg+0x78>
    {
        bit_mask <<= 1;
 2028138:	e0bff70b 	ldhu	r2,-36(fp)
 202813c:	1085883a 	add	r2,r2,r2
 2028140:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 2028144:	e0bff70b 	ldhu	r2,-36(fp)
 2028148:	10800054 	ori	r2,r2,1
 202814c:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 2028150:	e0bff817 	ldw	r2,-32(fp)
 2028154:	10800044 	addi	r2,r2,1
 2028158:	e0bff815 	stw	r2,-32(fp)
 202815c:	e0bffe03 	ldbu	r2,-8(fp)
 2028160:	e0fff817 	ldw	r3,-32(fp)
 2028164:	18bff416 	blt	r3,r2,2028138 <__alt_mem_mem_0+0xfd008138>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 2028168:	e0fff70b 	ldhu	r3,-36(fp)
 202816c:	e0bffd03 	ldbu	r2,-12(fp)
 2028170:	1884983a 	sll	r2,r3,r2
 2028174:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 2028178:	e0bff917 	ldw	r2,-28(fp)
 202817c:	10c0a004 	addi	r3,r2,640
 2028180:	e0bffc03 	ldbu	r2,-16(fp)
 2028184:	1085883a 	add	r2,r2,r2
 2028188:	1085883a 	add	r2,r2,r2
 202818c:	1885883a 	add	r2,r3,r2
 2028190:	10800037 	ldwio	r2,0(r2)
 2028194:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 2028198:	e0bff70b 	ldhu	r2,-36(fp)
 202819c:	0084303a 	nor	r2,zero,r2
 20281a0:	1007883a 	mov	r3,r2
 20281a4:	e0bffa0b 	ldhu	r2,-24(fp)
 20281a8:	1884703a 	and	r2,r3,r2
 20281ac:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 20281b0:	e0ffff0b 	ldhu	r3,-4(fp)
 20281b4:	e0bffd03 	ldbu	r2,-12(fp)
 20281b8:	1884983a 	sll	r2,r3,r2
 20281bc:	1007883a 	mov	r3,r2
 20281c0:	e0bff70b 	ldhu	r2,-36(fp)
 20281c4:	1884703a 	and	r2,r3,r2
 20281c8:	1007883a 	mov	r3,r2
 20281cc:	e0bffa0b 	ldhu	r2,-24(fp)
 20281d0:	1884b03a 	or	r2,r3,r2
 20281d4:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 20281d8:	e0bff917 	ldw	r2,-28(fp)
 20281dc:	10c0a004 	addi	r3,r2,640
 20281e0:	e0bffc03 	ldbu	r2,-16(fp)
 20281e4:	1085883a 	add	r2,r2,r2
 20281e8:	1085883a 	add	r2,r2,r2
 20281ec:	1885883a 	add	r2,r3,r2
 20281f0:	e0fffa0b 	ldhu	r3,-24(fp)
 20281f4:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 20281f8:	0005883a 	mov	r2,zero
    
}
 20281fc:	e037883a 	mov	sp,fp
 2028200:	df000017 	ldw	fp,0(sp)
 2028204:	dec00104 	addi	sp,sp,4
 2028208:	f800283a 	ret

0202820c <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 202820c:	defff704 	addi	sp,sp,-36
 2028210:	df000815 	stw	fp,32(sp)
 2028214:	df000804 	addi	fp,sp,32
 2028218:	e13ffc15 	stw	r4,-16(fp)
 202821c:	2809883a 	mov	r4,r5
 2028220:	3007883a 	mov	r3,r6
 2028224:	3805883a 	mov	r2,r7
 2028228:	e13ffd05 	stb	r4,-12(fp)
 202822c:	e0fffe05 	stb	r3,-8(fp)
 2028230:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2028234:	e0bffc17 	ldw	r2,-16(fp)
 2028238:	10800617 	ldw	r2,24(r2)
 202823c:	10800317 	ldw	r2,12(r2)
 2028240:	10800117 	ldw	r2,4(r2)
 2028244:	10800217 	ldw	r2,8(r2)
 2028248:	10800017 	ldw	r2,0(r2)
 202824c:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 2028250:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 2028254:	e03ff915 	stw	zero,-28(fp)
 2028258:	00000906 	br	2028280 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 202825c:	e0bff817 	ldw	r2,-32(fp)
 2028260:	1085883a 	add	r2,r2,r2
 2028264:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 2028268:	e0bff817 	ldw	r2,-32(fp)
 202826c:	10800054 	ori	r2,r2,1
 2028270:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 2028274:	e0bff917 	ldw	r2,-28(fp)
 2028278:	10800044 	addi	r2,r2,1
 202827c:	e0bff915 	stw	r2,-28(fp)
 2028280:	e0bfff03 	ldbu	r2,-4(fp)
 2028284:	e0fff917 	ldw	r3,-28(fp)
 2028288:	18bff416 	blt	r3,r2,202825c <__alt_mem_mem_0+0xfd00825c>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 202828c:	e0bffa17 	ldw	r2,-24(fp)
 2028290:	10c0a004 	addi	r3,r2,640
 2028294:	e0bffd03 	ldbu	r2,-12(fp)
 2028298:	1085883a 	add	r2,r2,r2
 202829c:	1085883a 	add	r2,r2,r2
 20282a0:	1885883a 	add	r2,r3,r2
 20282a4:	10800037 	ldwio	r2,0(r2)
 20282a8:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 20282ac:	e0fffb0b 	ldhu	r3,-20(fp)
 20282b0:	e0bffe03 	ldbu	r2,-8(fp)
 20282b4:	1885d83a 	sra	r2,r3,r2
 20282b8:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 20282bc:	e0fffb0b 	ldhu	r3,-20(fp)
 20282c0:	e0bff817 	ldw	r2,-32(fp)
 20282c4:	1884703a 	and	r2,r3,r2
}
 20282c8:	e037883a 	mov	sp,fp
 20282cc:	df000017 	ldw	fp,0(sp)
 20282d0:	dec00104 	addi	sp,sp,4
 20282d4:	f800283a 	ret

020282d8 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 20282d8:	deff9a04 	addi	sp,sp,-408
 20282dc:	dfc06515 	stw	ra,404(sp)
 20282e0:	df006415 	stw	fp,400(sp)
 20282e4:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 20282e8:	e0ff9c04 	addi	r3,fp,-400
 20282ec:	00801904 	movi	r2,100
 20282f0:	100d883a 	mov	r6,r2
 20282f4:	000b883a 	mov	r5,zero
 20282f8:	1809883a 	mov	r4,r3
 20282fc:	200616c0 	call	200616c <memset>
 2028300:	009d9cb4 	movhi	r2,30322
 2028304:	10985344 	addi	r2,r2,24909
 2028308:	e0bf9c15 	stw	r2,-400(fp)
 202830c:	00881b34 	movhi	r2,8300
 2028310:	109b1944 	addi	r2,r2,27749
 2028314:	e0bf9d15 	stw	r2,-396(fp)
 2028318:	008c5174 	movhi	r2,12613
 202831c:	108e0e04 	addi	r2,r2,14392
 2028320:	e0bf9e15 	stw	r2,-392(fp)
 2028324:	00800c74 	movhi	r2,49
 2028328:	108c4c44 	addi	r2,r2,12593
 202832c:	e0bf9f15 	stw	r2,-388(fp)
 2028330:	e0bfa004 	addi	r2,fp,-384
 2028334:	00c01004 	movi	r3,64
 2028338:	180d883a 	mov	r6,r3
 202833c:	000b883a 	mov	r5,zero
 2028340:	1009883a 	mov	r4,r2
 2028344:	200616c0 	call	200616c <memset>
 2028348:	009410c4 	movi	r2,20547
 202834c:	e0bfb015 	stw	r2,-320(fp)
 2028350:	00800304 	movi	r2,12
 2028354:	e0bfb105 	stb	r2,-316(fp)
 2028358:	00800084 	movi	r2,2
 202835c:	e0bfb145 	stb	r2,-315(fp)
 2028360:	00800444 	movi	r2,17
 2028364:	e0bfb185 	stb	r2,-314(fp)
 2028368:	00800384 	movi	r2,14
 202836c:	e0bfb1c5 	stb	r2,-313(fp)
 2028370:	00800344 	movi	r2,13
 2028374:	e0bfb205 	stb	r2,-312(fp)
 2028378:	00800284 	movi	r2,10
 202837c:	e0bfb245 	stb	r2,-311(fp)
 2028380:	008080f4 	movhi	r2,515
 2028384:	10ab4804 	addi	r2,r2,-21216
 2028388:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 202838c:	e0bfb504 	addi	r2,fp,-300
 2028390:	00c01904 	movi	r3,100
 2028394:	180d883a 	mov	r6,r3
 2028398:	000b883a 	mov	r5,zero
 202839c:	1009883a 	mov	r4,r2
 20283a0:	200616c0 	call	200616c <memset>
 20283a4:	009d9cb4 	movhi	r2,30322
 20283a8:	10985344 	addi	r2,r2,24909
 20283ac:	e0bfb515 	stw	r2,-300(fp)
 20283b0:	00881b34 	movhi	r2,8300
 20283b4:	109b1944 	addi	r2,r2,27749
 20283b8:	e0bfb615 	stw	r2,-296(fp)
 20283bc:	00991874 	movhi	r2,25697
 20283c0:	109d5444 	addi	r2,r2,30033
 20283c4:	e0bfb715 	stw	r2,-292(fp)
 20283c8:	00965234 	movhi	r2,22856
 20283cc:	10940804 	addi	r2,r2,20512
 20283d0:	e0bfb815 	stw	r2,-288(fp)
 20283d4:	00914e34 	movhi	r2,17720
 20283d8:	108e0804 	addi	r2,r2,14368
 20283dc:	e0bfb915 	stw	r2,-284(fp)
 20283e0:	008d4d34 	movhi	r2,13620
 20283e4:	108c4c44 	addi	r2,r2,12593
 20283e8:	e0bfba15 	stw	r2,-280(fp)
 20283ec:	e03fbb15 	stw	zero,-276(fp)
 20283f0:	e03fbc15 	stw	zero,-272(fp)
 20283f4:	e03fbd15 	stw	zero,-268(fp)
 20283f8:	e03fbe15 	stw	zero,-264(fp)
 20283fc:	e03fbf15 	stw	zero,-260(fp)
 2028400:	e03fc015 	stw	zero,-256(fp)
 2028404:	e03fc115 	stw	zero,-252(fp)
 2028408:	e03fc215 	stw	zero,-248(fp)
 202840c:	e03fc315 	stw	zero,-244(fp)
 2028410:	e03fc415 	stw	zero,-240(fp)
 2028414:	e03fc515 	stw	zero,-236(fp)
 2028418:	e03fc615 	stw	zero,-232(fp)
 202841c:	e03fc715 	stw	zero,-228(fp)
 2028420:	e03fc815 	stw	zero,-224(fp)
 2028424:	009410c4 	movi	r2,20547
 2028428:	e0bfc915 	stw	r2,-220(fp)
 202842c:	00800344 	movi	r2,13
 2028430:	e0bfca05 	stb	r2,-216(fp)
 2028434:	00800084 	movi	r2,2
 2028438:	e0bfca45 	stb	r2,-215(fp)
 202843c:	00800444 	movi	r2,17
 2028440:	e0bfca85 	stb	r2,-214(fp)
 2028444:	00800384 	movi	r2,14
 2028448:	e0bfcac5 	stb	r2,-213(fp)
 202844c:	00800344 	movi	r2,13
 2028450:	e0bfcb05 	stb	r2,-212(fp)
 2028454:	00800284 	movi	r2,10
 2028458:	e0bfcb45 	stb	r2,-211(fp)
 202845c:	008080f4 	movhi	r2,515
 2028460:	10ab4804 	addi	r2,r2,-21216
 2028464:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 2028468:	e0bfce04 	addi	r2,fp,-200
 202846c:	00c01904 	movi	r3,100
 2028470:	180d883a 	mov	r6,r3
 2028474:	000b883a 	mov	r5,zero
 2028478:	1009883a 	mov	r4,r2
 202847c:	200616c0 	call	200616c <memset>
 2028480:	009a5d34 	movhi	r2,26996
 2028484:	10985384 	addi	r2,r2,24910
 2028488:	e0bfce15 	stw	r2,-200(fp)
 202848c:	009b1874 	movhi	r2,27745
 2028490:	109b9bc4 	addi	r2,r2,28271
 2028494:	e0bfcf15 	stw	r2,-196(fp)
 2028498:	008e1434 	movhi	r2,14416
 202849c:	10910804 	addi	r2,r2,17440
 20284a0:	e0bfd015 	stw	r2,-192(fp)
 20284a4:	008d4db4 	movhi	r2,13622
 20284a8:	108e0cc4 	addi	r2,r2,14387
 20284ac:	e0bfd115 	stw	r2,-188(fp)
 20284b0:	e03fd215 	stw	zero,-184(fp)
 20284b4:	e0bfd304 	addi	r2,fp,-180
 20284b8:	00c00f04 	movi	r3,60
 20284bc:	180d883a 	mov	r6,r3
 20284c0:	000b883a 	mov	r5,zero
 20284c4:	1009883a 	mov	r4,r2
 20284c8:	200616c0 	call	200616c <memset>
 20284cc:	00800234 	movhi	r2,8
 20284d0:	108005c4 	addi	r2,r2,23
 20284d4:	e0bfe215 	stw	r2,-120(fp)
 20284d8:	008001c4 	movi	r2,7
 20284dc:	e0bfe305 	stb	r2,-116(fp)
 20284e0:	00800284 	movi	r2,10
 20284e4:	e0bfe345 	stb	r2,-115(fp)
 20284e8:	00800444 	movi	r2,17
 20284ec:	e0bfe385 	stb	r2,-114(fp)
 20284f0:	008000c4 	movi	r2,3
 20284f4:	e0bfe3c5 	stb	r2,-113(fp)
 20284f8:	00800044 	movi	r2,1
 20284fc:	e0bfe405 	stb	r2,-112(fp)
 2028500:	00800084 	movi	r2,2
 2028504:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 2028508:	00808134 	movhi	r2,516
 202850c:	10880604 	addi	r2,r2,8216
 2028510:	e0ffe704 	addi	r3,fp,-100
 2028514:	1009883a 	mov	r4,r2
 2028518:	00801904 	movi	r2,100
 202851c:	100d883a 	mov	r6,r2
 2028520:	200b883a 	mov	r5,r4
 2028524:	1809883a 	mov	r4,r3
 2028528:	20060240 	call	2006024 <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 202852c:	e13f9c04 	addi	r4,fp,-400
 2028530:	20264540 	call	2026454 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 2028534:	e0bfb504 	addi	r2,fp,-300
 2028538:	1009883a 	mov	r4,r2
 202853c:	20264540 	call	2026454 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 2028540:	e0bfce04 	addi	r2,fp,-200
 2028544:	1009883a 	mov	r4,r2
 2028548:	20264540 	call	2026454 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 202854c:	e0bfe704 	addi	r2,fp,-100
 2028550:	1009883a 	mov	r4,r2
 2028554:	20264540 	call	2026454 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 2028558:	d0a80003 	ldbu	r2,-24576(gp)
 202855c:	10803fcc 	andi	r2,r2,255
}
 2028560:	e037883a 	mov	sp,fp
 2028564:	dfc00117 	ldw	ra,4(sp)
 2028568:	df000017 	ldw	fp,0(sp)
 202856c:	dec00204 	addi	sp,sp,8
 2028570:	f800283a 	ret

02028574 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 2028574:	defffd04 	addi	sp,sp,-12
 2028578:	dfc00215 	stw	ra,8(sp)
 202857c:	df000115 	stw	fp,4(sp)
 2028580:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 2028584:	d0a80003 	ldbu	r2,-24576(gp)
 2028588:	10803fcc 	andi	r2,r2,255
 202858c:	100b883a 	mov	r5,r2
 2028590:	01008134 	movhi	r4,516
 2028594:	21081f04 	addi	r4,r4,8316
 2028598:	202610c0 	call	202610c <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 202859c:	e03fff05 	stb	zero,-4(fp)
 20285a0:	00006d06 	br	2028758 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 20285a4:	e0bfff07 	ldb	r2,-4(fp)
 20285a8:	100b883a 	mov	r5,r2
 20285ac:	01008134 	movhi	r4,516
 20285b0:	21082e04 	addi	r4,r4,8376
 20285b4:	202610c0 	call	202610c <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 20285b8:	e0ffff07 	ldb	r3,-4(fp)
 20285bc:	008085f4 	movhi	r2,535
 20285c0:	10a96104 	addi	r2,r2,-23164
 20285c4:	18c7883a 	add	r3,r3,r3
 20285c8:	18c7883a 	add	r3,r3,r3
 20285cc:	10c5883a 	add	r2,r2,r3
 20285d0:	10800017 	ldw	r2,0(r2)
 20285d4:	100b883a 	mov	r5,r2
 20285d8:	01008134 	movhi	r4,516
 20285dc:	21083304 	addi	r4,r4,8396
 20285e0:	202610c0 	call	202610c <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 20285e4:	e0ffff07 	ldb	r3,-4(fp)
 20285e8:	008085f4 	movhi	r2,535
 20285ec:	10a96104 	addi	r2,r2,-23164
 20285f0:	18c7883a 	add	r3,r3,r3
 20285f4:	18c7883a 	add	r3,r3,r3
 20285f8:	10c5883a 	add	r2,r2,r3
 20285fc:	10800017 	ldw	r2,0(r2)
 2028600:	10801417 	ldw	r2,80(r2)
 2028604:	100b883a 	mov	r5,r2
 2028608:	01008134 	movhi	r4,516
 202860c:	21083904 	addi	r4,r4,8420
 2028610:	202610c0 	call	202610c <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 2028614:	e0ffff07 	ldb	r3,-4(fp)
 2028618:	008085f4 	movhi	r2,535
 202861c:	10a96104 	addi	r2,r2,-23164
 2028620:	18c7883a 	add	r3,r3,r3
 2028624:	18c7883a 	add	r3,r3,r3
 2028628:	10c5883a 	add	r2,r2,r3
 202862c:	10800017 	ldw	r2,0(r2)
 2028630:	10801503 	ldbu	r2,84(r2)
 2028634:	10803fcc 	andi	r2,r2,255
 2028638:	100b883a 	mov	r5,r2
 202863c:	01008134 	movhi	r4,516
 2028640:	21084004 	addi	r4,r4,8448
 2028644:	202610c0 	call	202610c <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 2028648:	e0ffff07 	ldb	r3,-4(fp)
 202864c:	008085f4 	movhi	r2,535
 2028650:	10a96104 	addi	r2,r2,-23164
 2028654:	18c7883a 	add	r3,r3,r3
 2028658:	18c7883a 	add	r3,r3,r3
 202865c:	10c5883a 	add	r2,r2,r3
 2028660:	10800017 	ldw	r2,0(r2)
 2028664:	10801543 	ldbu	r2,85(r2)
 2028668:	10803fcc 	andi	r2,r2,255
 202866c:	100b883a 	mov	r5,r2
 2028670:	01008134 	movhi	r4,516
 2028674:	21084704 	addi	r4,r4,8476
 2028678:	202610c0 	call	202610c <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 202867c:	e0ffff07 	ldb	r3,-4(fp)
 2028680:	008085f4 	movhi	r2,535
 2028684:	10a96104 	addi	r2,r2,-23164
 2028688:	18c7883a 	add	r3,r3,r3
 202868c:	18c7883a 	add	r3,r3,r3
 2028690:	10c5883a 	add	r2,r2,r3
 2028694:	10800017 	ldw	r2,0(r2)
 2028698:	10801583 	ldbu	r2,86(r2)
 202869c:	10803fcc 	andi	r2,r2,255
 20286a0:	100b883a 	mov	r5,r2
 20286a4:	01008134 	movhi	r4,516
 20286a8:	21084e04 	addi	r4,r4,8504
 20286ac:	202610c0 	call	202610c <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 20286b0:	e0ffff07 	ldb	r3,-4(fp)
 20286b4:	008085f4 	movhi	r2,535
 20286b8:	10a96104 	addi	r2,r2,-23164
 20286bc:	18c7883a 	add	r3,r3,r3
 20286c0:	18c7883a 	add	r3,r3,r3
 20286c4:	10c5883a 	add	r2,r2,r3
 20286c8:	10800017 	ldw	r2,0(r2)
 20286cc:	108015c3 	ldbu	r2,87(r2)
 20286d0:	10803fcc 	andi	r2,r2,255
 20286d4:	100b883a 	mov	r5,r2
 20286d8:	01008134 	movhi	r4,516
 20286dc:	21085504 	addi	r4,r4,8532
 20286e0:	202610c0 	call	202610c <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 20286e4:	e0ffff07 	ldb	r3,-4(fp)
 20286e8:	008085f4 	movhi	r2,535
 20286ec:	10a96104 	addi	r2,r2,-23164
 20286f0:	18c7883a 	add	r3,r3,r3
 20286f4:	18c7883a 	add	r3,r3,r3
 20286f8:	10c5883a 	add	r2,r2,r3
 20286fc:	10800017 	ldw	r2,0(r2)
 2028700:	10801603 	ldbu	r2,88(r2)
 2028704:	10803fcc 	andi	r2,r2,255
 2028708:	100b883a 	mov	r5,r2
 202870c:	01008134 	movhi	r4,516
 2028710:	21085b04 	addi	r4,r4,8556
 2028714:	202610c0 	call	202610c <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 2028718:	e0ffff07 	ldb	r3,-4(fp)
 202871c:	008085f4 	movhi	r2,535
 2028720:	10a96104 	addi	r2,r2,-23164
 2028724:	18c7883a 	add	r3,r3,r3
 2028728:	18c7883a 	add	r3,r3,r3
 202872c:	10c5883a 	add	r2,r2,r3
 2028730:	10800017 	ldw	r2,0(r2)
 2028734:	10801643 	ldbu	r2,89(r2)
 2028738:	10803fcc 	andi	r2,r2,255
 202873c:	100b883a 	mov	r5,r2
 2028740:	01008134 	movhi	r4,516
 2028744:	21086104 	addi	r4,r4,8580
 2028748:	202610c0 	call	202610c <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 202874c:	e0bfff03 	ldbu	r2,-4(fp)
 2028750:	10800044 	addi	r2,r2,1
 2028754:	e0bfff05 	stb	r2,-4(fp)
 2028758:	e0ffff07 	ldb	r3,-4(fp)
 202875c:	d0a80003 	ldbu	r2,-24576(gp)
 2028760:	10803fcc 	andi	r2,r2,255
 2028764:	18bf8f16 	blt	r3,r2,20285a4 <__alt_mem_mem_0+0xfd0085a4>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 2028768:	d0a80003 	ldbu	r2,-24576(gp)
 202876c:	10803fcc 	andi	r2,r2,255
}
 2028770:	e037883a 	mov	sp,fp
 2028774:	dfc00117 	ldw	ra,4(sp)
 2028778:	df000017 	ldw	fp,0(sp)
 202877c:	dec00204 	addi	sp,sp,8
 2028780:	f800283a 	ret

02028784 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 2028784:	defffa04 	addi	sp,sp,-24
 2028788:	dfc00515 	stw	ra,20(sp)
 202878c:	df000415 	stw	fp,16(sp)
 2028790:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 2028794:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 2028798:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 202879c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 20287a0:	d0280045 	stb	zero,-24575(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 20287a4:	e03ffc05 	stb	zero,-16(fp)
 20287a8:	00019506 	br	2028e00 <alt_tse_mac_group_init+0x67c>
        psys = &tse_mac_device[i];
 20287ac:	e0bffc07 	ldb	r2,-16(fp)
 20287b0:	10c01224 	muli	r3,r2,72
 20287b4:	00808134 	movhi	r2,516
 20287b8:	1095ac04 	addi	r2,r2,22192
 20287bc:	1885883a 	add	r2,r3,r2
 20287c0:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 20287c4:	e0bfff17 	ldw	r2,-4(fp)
 20287c8:	10800517 	ldw	r2,20(r2)
 20287cc:	10018926 	beq	r2,zero,2028df4 <alt_tse_mac_group_init+0x670>
 20287d0:	e0bfff17 	ldw	r2,-4(fp)
 20287d4:	10800617 	ldw	r2,24(r2)
 20287d8:	10018626 	beq	r2,zero,2028df4 <alt_tse_mac_group_init+0x670>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 20287dc:	d0a80043 	ldbu	r2,-24575(gp)
 20287e0:	10c03fcc 	andi	r3,r2,255
 20287e4:	e0bfff17 	ldw	r2,-4(fp)
 20287e8:	10800017 	ldw	r2,0(r2)
 20287ec:	100d883a 	mov	r6,r2
 20287f0:	180b883a 	mov	r5,r3
 20287f4:	01008134 	movhi	r4,516
 20287f8:	21086704 	addi	r4,r4,8604
 20287fc:	2000bb00 	call	2000bb0 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 2028800:	01000904 	movi	r4,36
 2028804:	203cbe80 	call	203cbe8 <malloc>
 2028808:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 202880c:	e0bffd17 	ldw	r2,-12(fp)
 2028810:	1000081e 	bne	r2,zero,2028834 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 2028814:	d0a80043 	ldbu	r2,-24575(gp)
 2028818:	10803fcc 	andi	r2,r2,255
 202881c:	100b883a 	mov	r5,r2
 2028820:	01008134 	movhi	r4,516
 2028824:	21087304 	addi	r4,r4,8652
 2028828:	2000bb00 	call	2000bb0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 202882c:	00bfffc4 	movi	r2,-1
 2028830:	00017806 	br	2028e14 <alt_tse_mac_group_init+0x690>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 2028834:	e0bfff17 	ldw	r2,-4(fp)
 2028838:	108002c3 	ldbu	r2,11(r2)
 202883c:	10803fcc 	andi	r2,r2,255
 2028840:	10001226 	beq	r2,zero,202888c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 2028844:	e0bfff17 	ldw	r2,-4(fp)
 2028848:	10c00303 	ldbu	r3,12(r2)
 202884c:	e0bffd17 	ldw	r2,-12(fp)
 2028850:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 2028854:	01008134 	movhi	r4,516
 2028858:	21088104 	addi	r4,r4,8708
 202885c:	202610c0 	call	202610c <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 2028860:	e0bffd17 	ldw	r2,-12(fp)
 2028864:	10800003 	ldbu	r2,0(r2)
 2028868:	10803fcc 	andi	r2,r2,255
 202886c:	100b883a 	mov	r5,r2
 2028870:	01008134 	movhi	r4,516
 2028874:	21088c04 	addi	r4,r4,8752
 2028878:	202610c0 	call	202610c <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 202887c:	01008134 	movhi	r4,516
 2028880:	21089704 	addi	r4,r4,8796
 2028884:	202610c0 	call	202610c <no_printf>
 2028888:	00001f06 	br	2028908 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 202888c:	e0bfff17 	ldw	r2,-4(fp)
 2028890:	10800343 	ldbu	r2,13(r2)
 2028894:	10803fcc 	andi	r2,r2,255
 2028898:	10001226 	beq	r2,zero,20288e4 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 202889c:	e0bfff17 	ldw	r2,-4(fp)
 20288a0:	10c00383 	ldbu	r3,14(r2)
 20288a4:	e0bffd17 	ldw	r2,-12(fp)
 20288a8:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 20288ac:	01008134 	movhi	r4,516
 20288b0:	2108a204 	addi	r4,r4,8840
 20288b4:	202610c0 	call	202610c <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 20288b8:	01008134 	movhi	r4,516
 20288bc:	21089704 	addi	r4,r4,8796
 20288c0:	202610c0 	call	202610c <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 20288c4:	e0bffd17 	ldw	r2,-12(fp)
 20288c8:	10800003 	ldbu	r2,0(r2)
 20288cc:	10803fcc 	andi	r2,r2,255
 20288d0:	100b883a 	mov	r5,r2
 20288d4:	01008134 	movhi	r4,516
 20288d8:	2108ad04 	addi	r4,r4,8884
 20288dc:	202610c0 	call	202610c <no_printf>
 20288e0:	00000906 	br	2028908 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 20288e4:	e0bffd17 	ldw	r2,-12(fp)
 20288e8:	00c00044 	movi	r3,1
 20288ec:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 20288f0:	01008134 	movhi	r4,516
 20288f4:	2108a204 	addi	r4,r4,8840
 20288f8:	202610c0 	call	202610c <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 20288fc:	01008134 	movhi	r4,516
 2028900:	2108b804 	addi	r4,r4,8928
 2028904:	202610c0 	call	202610c <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 2028908:	e03ffc45 	stb	zero,-15(fp)
 202890c:	00012206 	br	2028d98 <alt_tse_mac_group_init+0x614>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 2028910:	01000404 	movi	r4,16
 2028914:	203cbe80 	call	203cbe8 <malloc>
 2028918:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 202891c:	e0bffe17 	ldw	r2,-8(fp)
 2028920:	10000a1e 	bne	r2,zero,202894c <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 2028924:	d0a80043 	ldbu	r2,-24575(gp)
 2028928:	10803fcc 	andi	r2,r2,255
 202892c:	e0fffc47 	ldb	r3,-15(fp)
 2028930:	180d883a 	mov	r6,r3
 2028934:	100b883a 	mov	r5,r2
 2028938:	01008134 	movhi	r4,516
 202893c:	2108c304 	addi	r4,r4,8972
 2028940:	2000bb00 	call	2000bb0 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 2028944:	00bfffc4 	movi	r2,-1
 2028948:	00013206 	br	2028e14 <alt_tse_mac_group_init+0x690>
                }
                
                pmac_info->pmac_group = pmac_group;
 202894c:	e0bffe17 	ldw	r2,-8(fp)
 2028950:	e0fffd17 	ldw	r3,-12(fp)
 2028954:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 2028958:	e0bffe17 	ldw	r2,-8(fp)
 202895c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 2028960:	e0fffc07 	ldb	r3,-16(fp)
 2028964:	e0bffc47 	ldb	r2,-15(fp)
 2028968:	1885883a 	add	r2,r3,r2
 202896c:	10c01224 	muli	r3,r2,72
 2028970:	00808134 	movhi	r2,516
 2028974:	1095ac04 	addi	r2,r2,22192
 2028978:	1887883a 	add	r3,r3,r2
 202897c:	e0bffe17 	ldw	r2,-8(fp)
 2028980:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 2028984:	e0bffe17 	ldw	r2,-8(fp)
 2028988:	10800217 	ldw	r2,8(r2)
 202898c:	10800517 	ldw	r2,20(r2)
 2028990:	10000426 	beq	r2,zero,20289a4 <alt_tse_mac_group_init+0x220>
 2028994:	e0bffe17 	ldw	r2,-8(fp)
 2028998:	10800217 	ldw	r2,8(r2)
 202899c:	10800617 	ldw	r2,24(r2)
 20289a0:	1000091e 	bne	r2,zero,20289c8 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 20289a4:	e0fffc07 	ldb	r3,-16(fp)
 20289a8:	e0bffc47 	ldb	r2,-15(fp)
 20289ac:	1885883a 	add	r2,r3,r2
 20289b0:	100b883a 	mov	r5,r2
 20289b4:	01008134 	movhi	r4,516
 20289b8:	2108d504 	addi	r4,r4,9044
 20289bc:	2000bb00 	call	2000bb0 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 20289c0:	00bfffc4 	movi	r2,-1
 20289c4:	00011306 	br	2028e14 <alt_tse_mac_group_init+0x690>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 20289c8:	e0bffe17 	ldw	r2,-8(fp)
 20289cc:	10800217 	ldw	r2,8(r2)
 20289d0:	10800243 	ldbu	r2,9(r2)
 20289d4:	10803fcc 	andi	r2,r2,255
 20289d8:	10000d26 	beq	r2,zero,2028a10 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 20289dc:	e0bffe17 	ldw	r2,-8(fp)
 20289e0:	10800217 	ldw	r2,8(r2)
 20289e4:	10800283 	ldbu	r2,10(r2)
 20289e8:	10803fcc 	andi	r2,r2,255
 20289ec:	10000426 	beq	r2,zero,2028a00 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 20289f0:	e0bffe17 	ldw	r2,-8(fp)
 20289f4:	00c00084 	movi	r3,2
 20289f8:	10c00005 	stb	r3,0(r2)
 20289fc:	00000606 	br	2028a18 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 2028a00:	e0bffe17 	ldw	r2,-8(fp)
 2028a04:	00c00044 	movi	r3,1
 2028a08:	10c00005 	stb	r3,0(r2)
 2028a0c:	00000206 	br	2028a18 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 2028a10:	e0bffe17 	ldw	r2,-8(fp)
 2028a14:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 2028a18:	e0bffe17 	ldw	r2,-8(fp)
 2028a1c:	10800217 	ldw	r2,8(r2)
 2028a20:	10800343 	ldbu	r2,13(r2)
 2028a24:	10803fcc 	andi	r2,r2,255
 2028a28:	10006626 	beq	r2,zero,2028bc4 <alt_tse_mac_group_init+0x440>
 2028a2c:	e0bffe17 	ldw	r2,-8(fp)
 2028a30:	10800217 	ldw	r2,8(r2)
 2028a34:	108002c3 	ldbu	r2,11(r2)
 2028a38:	10803fcc 	andi	r2,r2,255
 2028a3c:	1000611e 	bne	r2,zero,2028bc4 <alt_tse_mac_group_init+0x440>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 2028a40:	e0fffc47 	ldb	r3,-15(fp)
 2028a44:	e0bffe17 	ldw	r2,-8(fp)
 2028a48:	10800217 	ldw	r2,8(r2)
 2028a4c:	10800017 	ldw	r2,0(r2)
 2028a50:	100d883a 	mov	r6,r2
 2028a54:	180b883a 	mov	r5,r3
 2028a58:	01008134 	movhi	r4,516
 2028a5c:	2108e404 	addi	r4,r4,9104
 2028a60:	202610c0 	call	202610c <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 2028a64:	e13ffc47 	ldb	r4,-15(fp)
 2028a68:	e0fffc07 	ldb	r3,-16(fp)
 2028a6c:	e0bffc47 	ldb	r2,-15(fp)
 2028a70:	1885883a 	add	r2,r3,r2
 2028a74:	100d883a 	mov	r6,r2
 2028a78:	200b883a 	mov	r5,r4
 2028a7c:	01008134 	movhi	r4,516
 2028a80:	2108f004 	addi	r4,r4,9152
 2028a84:	202610c0 	call	202610c <no_printf>
                    
                	switch(pmac_info->mac_type) {
 2028a88:	e0bffe17 	ldw	r2,-8(fp)
 2028a8c:	10800003 	ldbu	r2,0(r2)
 2028a90:	10803fcc 	andi	r2,r2,255
 2028a94:	10c00060 	cmpeqi	r3,r2,1
 2028a98:	18000c1e 	bne	r3,zero,2028acc <alt_tse_mac_group_init+0x348>
 2028a9c:	10c000a0 	cmpeqi	r3,r2,2
 2028aa0:	1800021e 	bne	r3,zero,2028aac <alt_tse_mac_group_init+0x328>
 2028aa4:	10001126 	beq	r2,zero,2028aec <alt_tse_mac_group_init+0x368>
 2028aa8:	00001806 	br	2028b0c <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 2028aac:	e0bffc47 	ldb	r2,-15(fp)
 2028ab0:	01808134 	movhi	r6,516
 2028ab4:	3188ff04 	addi	r6,r6,9212
 2028ab8:	100b883a 	mov	r5,r2
 2028abc:	01008134 	movhi	r4,516
 2028ac0:	21090404 	addi	r4,r4,9232
 2028ac4:	202610c0 	call	202610c <no_printf>
                            break;
 2028ac8:	00001806 	br	2028b2c <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 2028acc:	e0bffc47 	ldb	r2,-15(fp)
 2028ad0:	01808134 	movhi	r6,516
 2028ad4:	31890f04 	addi	r6,r6,9276
 2028ad8:	100b883a 	mov	r5,r2
 2028adc:	01008134 	movhi	r4,516
 2028ae0:	21090404 	addi	r4,r4,9232
 2028ae4:	202610c0 	call	202610c <no_printf>
                            break;
 2028ae8:	00001006 	br	2028b2c <alt_tse_mac_group_init+0x3a8>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 2028aec:	e0bffc47 	ldb	r2,-15(fp)
 2028af0:	01808134 	movhi	r6,516
 2028af4:	31891504 	addi	r6,r6,9300
 2028af8:	100b883a 	mov	r5,r2
 2028afc:	01008134 	movhi	r4,516
 2028b00:	21090404 	addi	r4,r4,9232
 2028b04:	202610c0 	call	202610c <no_printf>
                            break;
 2028b08:	00000806 	br	2028b2c <alt_tse_mac_group_init+0x3a8>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 2028b0c:	e0bffc47 	ldb	r2,-15(fp)
 2028b10:	01808134 	movhi	r6,516
 2028b14:	31874d04 	addi	r6,r6,7476
 2028b18:	100b883a 	mov	r5,r2
 2028b1c:	01008134 	movhi	r4,516
 2028b20:	21090404 	addi	r4,r4,9232
 2028b24:	202610c0 	call	202610c <no_printf>
                            break;
 2028b28:	0001883a 	nop
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 2028b2c:	e0bffe17 	ldw	r2,-8(fp)
 2028b30:	10800217 	ldw	r2,8(r2)
 2028b34:	108003c3 	ldbu	r2,15(r2)
 2028b38:	10803fcc 	andi	r2,r2,255
 2028b3c:	10008b26 	beq	r2,zero,2028d6c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 2028b40:	e0fffc47 	ldb	r3,-15(fp)
 2028b44:	e0bffe17 	ldw	r2,-8(fp)
 2028b48:	10800217 	ldw	r2,8(r2)
 2028b4c:	108003c3 	ldbu	r2,15(r2)
 2028b50:	10803fcc 	andi	r2,r2,255
 2028b54:	10000326 	beq	r2,zero,2028b64 <alt_tse_mac_group_init+0x3e0>
 2028b58:	00808134 	movhi	r2,516
 2028b5c:	10891c04 	addi	r2,r2,9328
 2028b60:	00000206 	br	2028b6c <alt_tse_mac_group_init+0x3e8>
 2028b64:	00808134 	movhi	r2,516
 2028b68:	10891d04 	addi	r2,r2,9332
 2028b6c:	100d883a 	mov	r6,r2
 2028b70:	180b883a 	mov	r5,r3
 2028b74:	01008134 	movhi	r4,516
 2028b78:	21091e04 	addi	r4,r4,9336
 2028b7c:	202610c0 	call	202610c <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 2028b80:	e0fffc47 	ldb	r3,-15(fp)
 2028b84:	e0bffe17 	ldw	r2,-8(fp)
 2028b88:	10800217 	ldw	r2,8(r2)
 2028b8c:	10800403 	ldbu	r2,16(r2)
 2028b90:	10803fcc 	andi	r2,r2,255
 2028b94:	10000326 	beq	r2,zero,2028ba4 <alt_tse_mac_group_init+0x420>
 2028b98:	00808134 	movhi	r2,516
 2028b9c:	10891c04 	addi	r2,r2,9328
 2028ba0:	00000206 	br	2028bac <alt_tse_mac_group_init+0x428>
 2028ba4:	00808134 	movhi	r2,516
 2028ba8:	10891d04 	addi	r2,r2,9332
 2028bac:	100d883a 	mov	r6,r2
 2028bb0:	180b883a 	mov	r5,r3
 2028bb4:	01008134 	movhi	r4,516
 2028bb8:	21092904 	addi	r4,r4,9380
 2028bbc:	202610c0 	call	202610c <no_printf>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                            break;
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 2028bc0:	00006a06 	br	2028d6c <alt_tse_mac_group_init+0x5e8>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 2028bc4:	e0bffc47 	ldb	r2,-15(fp)
 2028bc8:	1000421e 	bne	r2,zero,2028cd4 <alt_tse_mac_group_init+0x550>
	                    switch(pmac_info->mac_type) {
 2028bcc:	e0bffe17 	ldw	r2,-8(fp)
 2028bd0:	10800003 	ldbu	r2,0(r2)
 2028bd4:	10803fcc 	andi	r2,r2,255
 2028bd8:	10c00060 	cmpeqi	r3,r2,1
 2028bdc:	18000a1e 	bne	r3,zero,2028c08 <alt_tse_mac_group_init+0x484>
 2028be0:	10c000a0 	cmpeqi	r3,r2,2
 2028be4:	1800021e 	bne	r3,zero,2028bf0 <alt_tse_mac_group_init+0x46c>
 2028be8:	10000d26 	beq	r2,zero,2028c20 <alt_tse_mac_group_init+0x49c>
 2028bec:	00001206 	br	2028c38 <alt_tse_mac_group_init+0x4b4>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 2028bf0:	01408134 	movhi	r5,516
 2028bf4:	2948ff04 	addi	r5,r5,9212
 2028bf8:	01008134 	movhi	r4,516
 2028bfc:	21093404 	addi	r4,r4,9424
 2028c00:	202610c0 	call	202610c <no_printf>
	                            break;
 2028c04:	00001206 	br	2028c50 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 2028c08:	01408134 	movhi	r5,516
 2028c0c:	29490f04 	addi	r5,r5,9276
 2028c10:	01008134 	movhi	r4,516
 2028c14:	21093404 	addi	r4,r4,9424
 2028c18:	202610c0 	call	202610c <no_printf>
	                            break;
 2028c1c:	00000c06 	br	2028c50 <alt_tse_mac_group_init+0x4cc>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 2028c20:	01408134 	movhi	r5,516
 2028c24:	29491504 	addi	r5,r5,9300
 2028c28:	01008134 	movhi	r4,516
 2028c2c:	21093404 	addi	r4,r4,9424
 2028c30:	202610c0 	call	202610c <no_printf>
	                            break;
 2028c34:	00000606 	br	2028c50 <alt_tse_mac_group_init+0x4cc>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 2028c38:	01408134 	movhi	r5,516
 2028c3c:	29474d04 	addi	r5,r5,7476
 2028c40:	01008134 	movhi	r4,516
 2028c44:	21093404 	addi	r4,r4,9424
 2028c48:	202610c0 	call	202610c <no_printf>
                                    break;
 2028c4c:	0001883a 	nop
			    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 2028c50:	e0bffe17 	ldw	r2,-8(fp)
 2028c54:	10800217 	ldw	r2,8(r2)
 2028c58:	108003c3 	ldbu	r2,15(r2)
 2028c5c:	10803fcc 	andi	r2,r2,255
 2028c60:	10001c26 	beq	r2,zero,2028cd4 <alt_tse_mac_group_init+0x550>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 2028c64:	e0bffe17 	ldw	r2,-8(fp)
 2028c68:	10800217 	ldw	r2,8(r2)
 2028c6c:	108003c3 	ldbu	r2,15(r2)
 2028c70:	10803fcc 	andi	r2,r2,255
 2028c74:	10000326 	beq	r2,zero,2028c84 <alt_tse_mac_group_init+0x500>
 2028c78:	00808134 	movhi	r2,516
 2028c7c:	10891c04 	addi	r2,r2,9328
 2028c80:	00000206 	br	2028c8c <alt_tse_mac_group_init+0x508>
 2028c84:	00808134 	movhi	r2,516
 2028c88:	10891d04 	addi	r2,r2,9332
 2028c8c:	100b883a 	mov	r5,r2
 2028c90:	01008134 	movhi	r4,516
 2028c94:	21093f04 	addi	r4,r4,9468
 2028c98:	202610c0 	call	202610c <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 2028c9c:	e0bffe17 	ldw	r2,-8(fp)
 2028ca0:	10800217 	ldw	r2,8(r2)
 2028ca4:	10800403 	ldbu	r2,16(r2)
 2028ca8:	10803fcc 	andi	r2,r2,255
 2028cac:	10000326 	beq	r2,zero,2028cbc <alt_tse_mac_group_init+0x538>
 2028cb0:	00808134 	movhi	r2,516
 2028cb4:	10891c04 	addi	r2,r2,9328
 2028cb8:	00000206 	br	2028cc4 <alt_tse_mac_group_init+0x540>
 2028cbc:	00808134 	movhi	r2,516
 2028cc0:	10891d04 	addi	r2,r2,9332
 2028cc4:	100b883a 	mov	r5,r2
 2028cc8:	01008134 	movhi	r4,516
 2028ccc:	21094a04 	addi	r4,r4,9512
 2028cd0:	202610c0 	call	202610c <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 2028cd4:	e0bffe17 	ldw	r2,-8(fp)
 2028cd8:	10800217 	ldw	r2,8(r2)
 2028cdc:	108002c3 	ldbu	r2,11(r2)
 2028ce0:	10803fcc 	andi	r2,r2,255
 2028ce4:	10001326 	beq	r2,zero,2028d34 <alt_tse_mac_group_init+0x5b0>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 2028ce8:	e0fffc47 	ldb	r3,-15(fp)
 2028cec:	e0bffe17 	ldw	r2,-8(fp)
 2028cf0:	10800217 	ldw	r2,8(r2)
 2028cf4:	10800017 	ldw	r2,0(r2)
 2028cf8:	100d883a 	mov	r6,r2
 2028cfc:	180b883a 	mov	r5,r3
 2028d00:	01008134 	movhi	r4,516
 2028d04:	21095504 	addi	r4,r4,9556
 2028d08:	202610c0 	call	202610c <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 2028d0c:	e13ffc47 	ldb	r4,-15(fp)
 2028d10:	e0fffc07 	ldb	r3,-16(fp)
 2028d14:	e0bffc47 	ldb	r2,-15(fp)
 2028d18:	1885883a 	add	r2,r3,r2
 2028d1c:	100d883a 	mov	r6,r2
 2028d20:	200b883a 	mov	r5,r4
 2028d24:	01008134 	movhi	r4,516
 2028d28:	21096104 	addi	r4,r4,9604
 2028d2c:	202610c0 	call	202610c <no_printf>
 2028d30:	00000e06 	br	2028d6c <alt_tse_mac_group_init+0x5e8>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 2028d34:	e0bffe17 	ldw	r2,-8(fp)
 2028d38:	10800217 	ldw	r2,8(r2)
 2028d3c:	10800017 	ldw	r2,0(r2)
 2028d40:	100b883a 	mov	r5,r2
 2028d44:	01008134 	movhi	r4,516
 2028d48:	21097004 	addi	r4,r4,9664
 2028d4c:	202610c0 	call	202610c <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 2028d50:	e0fffc07 	ldb	r3,-16(fp)
 2028d54:	e0bffc47 	ldb	r2,-15(fp)
 2028d58:	1885883a 	add	r2,r3,r2
 2028d5c:	100b883a 	mov	r5,r2
 2028d60:	01008134 	movhi	r4,516
 2028d64:	21097c04 	addi	r4,r4,9712
 2028d68:	202610c0 	call	202610c <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 2028d6c:	e0bffc47 	ldb	r2,-15(fp)
 2028d70:	e0fffd17 	ldw	r3,-12(fp)
 2028d74:	10800044 	addi	r2,r2,1
 2028d78:	1085883a 	add	r2,r2,r2
 2028d7c:	1085883a 	add	r2,r2,r2
 2028d80:	1885883a 	add	r2,r3,r2
 2028d84:	e0fffe17 	ldw	r3,-8(fp)
 2028d88:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 2028d8c:	e0bffc43 	ldbu	r2,-15(fp)
 2028d90:	10800044 	addi	r2,r2,1
 2028d94:	e0bffc45 	stb	r2,-15(fp)
 2028d98:	e0fffc47 	ldb	r3,-15(fp)
 2028d9c:	e0bffd17 	ldw	r2,-12(fp)
 2028da0:	10800003 	ldbu	r2,0(r2)
 2028da4:	10803fcc 	andi	r2,r2,255
 2028da8:	18bed916 	blt	r3,r2,2028910 <__alt_mem_mem_0+0xfd008910>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 2028dac:	d0a80043 	ldbu	r2,-24575(gp)
 2028db0:	10c03fcc 	andi	r3,r2,255
 2028db4:	008085f4 	movhi	r2,535
 2028db8:	10a95904 	addi	r2,r2,-23196
 2028dbc:	18c7883a 	add	r3,r3,r3
 2028dc0:	18c7883a 	add	r3,r3,r3
 2028dc4:	10c5883a 	add	r2,r2,r3
 2028dc8:	e0fffd17 	ldw	r3,-12(fp)
 2028dcc:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 2028dd0:	d0a80043 	ldbu	r2,-24575(gp)
 2028dd4:	10800044 	addi	r2,r2,1
 2028dd8:	d0a80045 	stb	r2,-24575(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 2028ddc:	e0bffd17 	ldw	r2,-12(fp)
 2028de0:	10c00003 	ldbu	r3,0(r2)
 2028de4:	e0bffc03 	ldbu	r2,-16(fp)
 2028de8:	1885883a 	add	r2,r3,r2
 2028dec:	10bfffc4 	addi	r2,r2,-1
 2028df0:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 2028df4:	e0bffc03 	ldbu	r2,-16(fp)
 2028df8:	10800044 	addi	r2,r2,1
 2028dfc:	e0bffc05 	stb	r2,-16(fp)
 2028e00:	e0fffc07 	ldb	r3,-16(fp)
 2028e04:	d0a01903 	ldbu	r2,-32668(gp)
 2028e08:	10803fcc 	andi	r2,r2,255
 2028e0c:	18be6716 	blt	r3,r2,20287ac <__alt_mem_mem_0+0xfd0087ac>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 2028e10:	0005883a 	mov	r2,zero
}
 2028e14:	e037883a 	mov	sp,fp
 2028e18:	dfc00117 	ldw	ra,4(sp)
 2028e1c:	df000017 	ldw	fp,0(sp)
 2028e20:	dec00204 	addi	sp,sp,8
 2028e24:	f800283a 	ret

02028e28 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 2028e28:	deffed04 	addi	sp,sp,-76
 2028e2c:	dfc01215 	stw	ra,72(sp)
 2028e30:	df001115 	stw	fp,68(sp)
 2028e34:	df001104 	addi	fp,sp,68
 2028e38:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 2028e3c:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 2028e40:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 2028e44:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 2028e48:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 2028e4c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 2028e50:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2028e54:	e0bfff17 	ldw	r2,-4(fp)
 2028e58:	10800117 	ldw	r2,4(r2)
 2028e5c:	10800217 	ldw	r2,8(r2)
 2028e60:	10800017 	ldw	r2,0(r2)
 2028e64:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 2028e68:	e0bff917 	ldw	r2,-28(fp)
 2028e6c:	10801004 	addi	r2,r2,64
 2028e70:	10800037 	ldwio	r2,0(r2)
 2028e74:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2028e78:	e13fff17 	ldw	r4,-4(fp)
 2028e7c:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 2028e80:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 2028e84:	00800044 	movi	r2,1
 2028e88:	e0bff005 	stb	r2,-64(fp)
 2028e8c:	0000ca06 	br	20291b8 <alt_tse_mac_get_phy+0x390>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 2028e90:	e0bff917 	ldw	r2,-28(fp)
 2028e94:	10801004 	addi	r2,r2,64
 2028e98:	e0fff003 	ldbu	r3,-64(fp)
 2028e9c:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 2028ea0:	e0bff917 	ldw	r2,-28(fp)
 2028ea4:	1080a204 	addi	r2,r2,648
 2028ea8:	10800037 	ldwio	r2,0(r2)
 2028eac:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 2028eb0:	e0bff917 	ldw	r2,-28(fp)
 2028eb4:	1080a304 	addi	r2,r2,652
 2028eb8:	10800037 	ldwio	r2,0(r2)
 2028ebc:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 2028ec0:	e0fffc17 	ldw	r3,-16(fp)
 2028ec4:	e0bff517 	ldw	r2,-44(fp)
 2028ec8:	1880b826 	beq	r3,r2,20291ac <alt_tse_mac_get_phy+0x384>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 2028ecc:	01000704 	movi	r4,28
 2028ed0:	203cbe80 	call	203cbe8 <malloc>
 2028ed4:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 2028ed8:	e0bff617 	ldw	r2,-40(fp)
 2028edc:	1000091e 	bne	r2,zero,2028f04 <alt_tse_mac_get_phy+0xdc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 2028ee0:	e0bffb07 	ldb	r2,-20(fp)
 2028ee4:	e0fff407 	ldb	r3,-48(fp)
 2028ee8:	180d883a 	mov	r6,r3
 2028eec:	100b883a 	mov	r5,r2
 2028ef0:	01008134 	movhi	r4,516
 2028ef4:	21098b04 	addi	r4,r4,9772
 2028ef8:	2000bb00 	call	2000bb0 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 2028efc:	00bfffc4 	movi	r2,-1
 2028f00:	0000cd06 	br	2029238 <alt_tse_mac_get_phy+0x410>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 2028f04:	e0bff617 	ldw	r2,-40(fp)
 2028f08:	e0fff003 	ldbu	r3,-64(fp)
 2028f0c:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 2028f10:	e0bffc17 	ldw	r2,-16(fp)
 2028f14:	100691ba 	slli	r3,r2,6
 2028f18:	e0bff517 	ldw	r2,-44(fp)
 2028f1c:	1005d2ba 	srai	r2,r2,10
 2028f20:	10800fcc 	andi	r2,r2,63
 2028f24:	1884b03a 	or	r2,r3,r2
 2028f28:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 2028f2c:	e0bff517 	ldw	r2,-44(fp)
 2028f30:	1005d13a 	srai	r2,r2,4
 2028f34:	10800fcc 	andi	r2,r2,63
 2028f38:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 2028f3c:	e0bff517 	ldw	r2,-44(fp)
 2028f40:	108003cc 	andi	r2,r2,15
 2028f44:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 2028f48:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 2028f4c:	e03ff115 	stw	zero,-60(fp)
 2028f50:	00003406 	br	2029024 <alt_tse_mac_get_phy+0x1fc>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 2028f54:	008085f4 	movhi	r2,535
 2028f58:	10a96104 	addi	r2,r2,-23164
 2028f5c:	e0fff117 	ldw	r3,-60(fp)
 2028f60:	18c7883a 	add	r3,r3,r3
 2028f64:	18c7883a 	add	r3,r3,r3
 2028f68:	10c5883a 	add	r2,r2,r3
 2028f6c:	10800017 	ldw	r2,0(r2)
 2028f70:	10c01417 	ldw	r3,80(r2)
 2028f74:	e0bffd17 	ldw	r2,-12(fp)
 2028f78:	1880271e 	bne	r3,r2,2029018 <alt_tse_mac_get_phy+0x1f0>
 2028f7c:	008085f4 	movhi	r2,535
 2028f80:	10a96104 	addi	r2,r2,-23164
 2028f84:	e0fff117 	ldw	r3,-60(fp)
 2028f88:	18c7883a 	add	r3,r3,r3
 2028f8c:	18c7883a 	add	r3,r3,r3
 2028f90:	10c5883a 	add	r2,r2,r3
 2028f94:	10800017 	ldw	r2,0(r2)
 2028f98:	10801503 	ldbu	r2,84(r2)
 2028f9c:	10c03fcc 	andi	r3,r2,255
 2028fa0:	e0bffe03 	ldbu	r2,-8(fp)
 2028fa4:	18801c1e 	bne	r3,r2,2029018 <alt_tse_mac_get_phy+0x1f0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 2028fa8:	008085f4 	movhi	r2,535
 2028fac:	10a96104 	addi	r2,r2,-23164
 2028fb0:	e0fff117 	ldw	r3,-60(fp)
 2028fb4:	18c7883a 	add	r3,r3,r3
 2028fb8:	18c7883a 	add	r3,r3,r3
 2028fbc:	10c5883a 	add	r2,r2,r3
 2028fc0:	10c00017 	ldw	r3,0(r2)
 2028fc4:	e0bff617 	ldw	r2,-40(fp)
 2028fc8:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 2028fcc:	008085f4 	movhi	r2,535
 2028fd0:	10a96104 	addi	r2,r2,-23164
 2028fd4:	e0fff117 	ldw	r3,-60(fp)
 2028fd8:	18c7883a 	add	r3,r3,r3
 2028fdc:	18c7883a 	add	r3,r3,r3
 2028fe0:	10c5883a 	add	r2,r2,r3
 2028fe4:	10800017 	ldw	r2,0(r2)
 2028fe8:	1009883a 	mov	r4,r2
 2028fec:	e0bff003 	ldbu	r2,-64(fp)
 2028ff0:	e0fffb07 	ldb	r3,-20(fp)
 2028ff4:	180f883a 	mov	r7,r3
 2028ff8:	100d883a 	mov	r6,r2
 2028ffc:	200b883a 	mov	r5,r4
 2029000:	01008134 	movhi	r4,516
 2029004:	21099a04 	addi	r4,r4,9832
 2029008:	2000bb00 	call	2000bb0 <printf>
                    is_phy_in_profile = 1;
 202900c:	00800044 	movi	r2,1
 2029010:	e0bff205 	stb	r2,-56(fp)
                    break;
 2029014:	00000706 	br	2029034 <alt_tse_mac_get_phy+0x20c>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 2029018:	e0bff117 	ldw	r2,-60(fp)
 202901c:	10800044 	addi	r2,r2,1
 2029020:	e0bff115 	stw	r2,-60(fp)
 2029024:	d0a80003 	ldbu	r2,-24576(gp)
 2029028:	10803fcc 	andi	r2,r2,255
 202902c:	e0fff117 	ldw	r3,-60(fp)
 2029030:	18bfc816 	blt	r3,r2,2028f54 <__alt_mem_mem_0+0xfd008f54>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 2029034:	e0bff203 	ldbu	r2,-56(fp)
 2029038:	10000f1e 	bne	r2,zero,2029078 <alt_tse_mac_get_phy+0x250>
                pphy->pphy_profile = 0;
 202903c:	e0bff617 	ldw	r2,-40(fp)
 2029040:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 2029044:	e0bff003 	ldbu	r2,-64(fp)
 2029048:	e0fffb07 	ldb	r3,-20(fp)
 202904c:	180d883a 	mov	r6,r3
 2029050:	100b883a 	mov	r5,r2
 2029054:	01008134 	movhi	r4,516
 2029058:	2109aa04 	addi	r4,r4,9896
 202905c:	2000bb00 	call	2000bb0 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 2029060:	01008134 	movhi	r4,516
 2029064:	2109bb04 	addi	r4,r4,9964
 2029068:	203ceb40 	call	203ceb4 <puts>
                return_value++;
 202906c:	e0bff317 	ldw	r2,-52(fp)
 2029070:	10800044 	addi	r2,r2,1
 2029074:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 2029078:	e0bffd17 	ldw	r2,-12(fp)
 202907c:	100b883a 	mov	r5,r2
 2029080:	01008134 	movhi	r4,516
 2029084:	2109c804 	addi	r4,r4,10016
 2029088:	202610c0 	call	202610c <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 202908c:	e0bffe03 	ldbu	r2,-8(fp)
 2029090:	100b883a 	mov	r5,r2
 2029094:	01008134 	movhi	r4,516
 2029098:	2109d304 	addi	r4,r4,10060
 202909c:	202610c0 	call	202610c <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 20290a0:	e0bffe43 	ldbu	r2,-7(fp)
 20290a4:	100b883a 	mov	r5,r2
 20290a8:	01008134 	movhi	r4,516
 20290ac:	2109de04 	addi	r4,r4,10104
 20290b0:	202610c0 	call	202610c <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 20290b4:	e17ff617 	ldw	r5,-40(fp)
 20290b8:	e13fff17 	ldw	r4,-4(fp)
 20290bc:	202924c0 	call	202924c <alt_tse_mac_associate_phy>
 20290c0:	1000341e 	bne	r2,zero,2029194 <alt_tse_mac_get_phy+0x36c>
            	
            	pmac_info = pphy->pmac_info;
 20290c4:	e0bff617 	ldw	r2,-40(fp)
 20290c8:	10800617 	ldw	r2,24(r2)
 20290cc:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 20290d0:	e0bff717 	ldw	r2,-36(fp)
 20290d4:	10800217 	ldw	r2,8(r2)
 20290d8:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 20290dc:	d8000015 	stw	zero,0(sp)
 20290e0:	01c00044 	movi	r7,1
 20290e4:	01800384 	movi	r6,14
 20290e8:	000b883a 	mov	r5,zero
 20290ec:	e13ff617 	ldw	r4,-40(fp)
 20290f0:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 20290f4:	01400044 	movi	r5,1
 20290f8:	e13ff617 	ldw	r4,-40(fp)
 20290fc:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 2029100:	01400044 	movi	r5,1
 2029104:	e13ff617 	ldw	r4,-40(fp)
 2029108:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 202910c:	01400044 	movi	r5,1
 2029110:	e13ff617 	ldw	r4,-40(fp)
 2029114:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 2029118:	017e0034 	movhi	r5,63488
 202911c:	e13ff617 	ldw	r4,-40(fp)
 2029120:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 2029124:	e0bff617 	ldw	r2,-40(fp)
 2029128:	10800517 	ldw	r2,20(r2)
 202912c:	10000f26 	beq	r2,zero,202916c <alt_tse_mac_get_phy+0x344>
		            if(pphy->pphy_profile->phy_cfg) {
 2029130:	e0bff617 	ldw	r2,-40(fp)
 2029134:	10800517 	ldw	r2,20(r2)
 2029138:	10801717 	ldw	r2,92(r2)
 202913c:	10000b26 	beq	r2,zero,202916c <alt_tse_mac_get_phy+0x344>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 2029140:	e0bff617 	ldw	r2,-40(fp)
 2029144:	10800517 	ldw	r2,20(r2)
 2029148:	100b883a 	mov	r5,r2
 202914c:	01008134 	movhi	r4,516
 2029150:	2109e904 	addi	r4,r4,10148
 2029154:	202610c0 	call	202610c <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 2029158:	e0bff617 	ldw	r2,-40(fp)
 202915c:	10800517 	ldw	r2,20(r2)
 2029160:	10801717 	ldw	r2,92(r2)
 2029164:	e13ff917 	ldw	r4,-28(fp)
 2029168:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 202916c:	e0bff817 	ldw	r2,-32(fp)
 2029170:	10801117 	ldw	r2,68(r2)
 2029174:	10000726 	beq	r2,zero,2029194 <alt_tse_mac_get_phy+0x36c>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 2029178:	01008134 	movhi	r4,516
 202917c:	2109f704 	addi	r4,r4,10204
 2029180:	202610c0 	call	202610c <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 2029184:	e0bff817 	ldw	r2,-32(fp)
 2029188:	10801117 	ldw	r2,68(r2)
 202918c:	e13ff917 	ldw	r4,-28(fp)
 2029190:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 2029194:	01008134 	movhi	r4,516
 2029198:	210a0504 	addi	r4,r4,10260
 202919c:	202610c0 	call	202610c <no_printf>
	            
            phy_info_count++;
 20291a0:	e0bff403 	ldbu	r2,-48(fp)
 20291a4:	10800044 	addi	r2,r2,1
 20291a8:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x01; phyadd < 0x20; phyadd++)
 20291ac:	e0bff003 	ldbu	r2,-64(fp)
 20291b0:	10800044 	addi	r2,r2,1
 20291b4:	e0bff005 	stb	r2,-64(fp)
 20291b8:	e0bff003 	ldbu	r2,-64(fp)
 20291bc:	10800830 	cmpltui	r2,r2,32
 20291c0:	103f331e 	bne	r2,zero,2028e90 <__alt_mem_mem_0+0xfd008e90>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 20291c4:	e0bfff17 	ldw	r2,-4(fp)
 20291c8:	10800003 	ldbu	r2,0(r2)
 20291cc:	10c03fcc 	andi	r3,r2,255
 20291d0:	e0bff407 	ldb	r2,-48(fp)
 20291d4:	18801326 	beq	r3,r2,2029224 <alt_tse_mac_get_phy+0x3fc>
        if(phy_info_count == 0) {
 20291d8:	e0bff407 	ldb	r2,-48(fp)
 20291dc:	1000061e 	bne	r2,zero,20291f8 <alt_tse_mac_get_phy+0x3d0>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 20291e0:	e0bffb07 	ldb	r2,-20(fp)
 20291e4:	100b883a 	mov	r5,r2
 20291e8:	01008134 	movhi	r4,516
 20291ec:	210a0604 	addi	r4,r4,10264
 20291f0:	2000bb00 	call	2000bb0 <printf>
 20291f4:	00000b06 	br	2029224 <alt_tse_mac_get_phy+0x3fc>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 20291f8:	e0fffb07 	ldb	r3,-20(fp)
 20291fc:	e13ff407 	ldb	r4,-48(fp)
 2029200:	e0bfff17 	ldw	r2,-4(fp)
 2029204:	10800003 	ldbu	r2,0(r2)
 2029208:	10803fcc 	andi	r2,r2,255
 202920c:	100f883a 	mov	r7,r2
 2029210:	200d883a 	mov	r6,r4
 2029214:	180b883a 	mov	r5,r3
 2029218:	01008134 	movhi	r4,516
 202921c:	210a1204 	addi	r4,r4,10312
 2029220:	2000bb00 	call	2000bb0 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 2029224:	e0bff917 	ldw	r2,-28(fp)
 2029228:	10801004 	addi	r2,r2,64
 202922c:	e0fffa17 	ldw	r3,-24(fp)
 2029230:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 2029234:	e0bff317 	ldw	r2,-52(fp)
}
 2029238:	e037883a 	mov	sp,fp
 202923c:	dfc00117 	ldw	ra,4(sp)
 2029240:	df000017 	ldw	fp,0(sp)
 2029244:	dec00204 	addi	sp,sp,8
 2029248:	f800283a 	ret

0202924c <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 202924c:	defff604 	addi	sp,sp,-40
 2029250:	dfc00915 	stw	ra,36(sp)
 2029254:	df000815 	stw	fp,32(sp)
 2029258:	df000804 	addi	fp,sp,32
 202925c:	e13ffe15 	stw	r4,-8(fp)
 2029260:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 2029264:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 2029268:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 202926c:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 2029270:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2029274:	e13ffe17 	ldw	r4,-8(fp)
 2029278:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 202927c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 2029280:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 2029284:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 2029288:	e03ff815 	stw	zero,-32(fp)
 202928c:	00002c06 	br	2029340 <alt_tse_mac_associate_phy+0xf4>
        pmac_info = pmac_group->pmac_info[i];
 2029290:	e0fffe17 	ldw	r3,-8(fp)
 2029294:	e0bff817 	ldw	r2,-32(fp)
 2029298:	10800044 	addi	r2,r2,1
 202929c:	1085883a 	add	r2,r2,r2
 20292a0:	1085883a 	add	r2,r2,r2
 20292a4:	1885883a 	add	r2,r3,r2
 20292a8:	10800017 	ldw	r2,0(r2)
 20292ac:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 20292b0:	e0bffc17 	ldw	r2,-16(fp)
 20292b4:	10800217 	ldw	r2,8(r2)
 20292b8:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 20292bc:	e0bffb17 	ldw	r2,-20(fp)
 20292c0:	10c01017 	ldw	r3,64(r2)
 20292c4:	e0bfff17 	ldw	r2,-4(fp)
 20292c8:	10800003 	ldbu	r2,0(r2)
 20292cc:	10803fcc 	andi	r2,r2,255
 20292d0:	1880181e 	bne	r3,r2,2029334 <alt_tse_mac_associate_phy+0xe8>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20292d4:	e13ffc17 	ldw	r4,-16(fp)
 20292d8:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 20292dc:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 20292e0:	e13ffb17 	ldw	r4,-20(fp)
 20292e4:	20272240 	call	2027224 <alt_tse_get_system_index>
 20292e8:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 20292ec:	e0bffc17 	ldw	r2,-16(fp)
 20292f0:	e0ffff17 	ldw	r3,-4(fp)
 20292f4:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 20292f8:	e0bfff17 	ldw	r2,-4(fp)
 20292fc:	e0fffc17 	ldw	r3,-16(fp)
 2029300:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 2029304:	e0bffd47 	ldb	r2,-11(fp)
 2029308:	e0fffd07 	ldb	r3,-12(fp)
 202930c:	e13ffd87 	ldb	r4,-10(fp)
 2029310:	200f883a 	mov	r7,r4
 2029314:	180d883a 	mov	r6,r3
 2029318:	100b883a 	mov	r5,r2
 202931c:	01008134 	movhi	r4,516
 2029320:	210a3104 	addi	r4,r4,10436
 2029324:	2000bb00 	call	2000bb0 <printf>
            is_mapped = 1;
 2029328:	00800044 	movi	r2,1
 202932c:	e0bffa05 	stb	r2,-24(fp)
            break;
 2029330:	00000806 	br	2029354 <alt_tse_mac_associate_phy+0x108>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 2029334:	e0bff817 	ldw	r2,-32(fp)
 2029338:	10800044 	addi	r2,r2,1
 202933c:	e0bff815 	stw	r2,-32(fp)
 2029340:	e0bffe17 	ldw	r2,-8(fp)
 2029344:	10800003 	ldbu	r2,0(r2)
 2029348:	10803fcc 	andi	r2,r2,255
 202934c:	e0fff817 	ldw	r3,-32(fp)
 2029350:	18bfcf16 	blt	r3,r2,2029290 <__alt_mem_mem_0+0xfd009290>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 2029354:	e0bffa03 	ldbu	r2,-24(fp)
 2029358:	10003d1e 	bne	r2,zero,2029450 <alt_tse_mac_associate_phy+0x204>
        for(i = 0; i < pmac_group->channel; i++) {
 202935c:	e03ff815 	stw	zero,-32(fp)
 2029360:	00003606 	br	202943c <alt_tse_mac_associate_phy+0x1f0>
            pmac_info = pmac_group->pmac_info[i];
 2029364:	e0fffe17 	ldw	r3,-8(fp)
 2029368:	e0bff817 	ldw	r2,-32(fp)
 202936c:	10800044 	addi	r2,r2,1
 2029370:	1085883a 	add	r2,r2,r2
 2029374:	1085883a 	add	r2,r2,r2
 2029378:	1885883a 	add	r2,r3,r2
 202937c:	10800017 	ldw	r2,0(r2)
 2029380:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 2029384:	e0bffc17 	ldw	r2,-16(fp)
 2029388:	10800217 	ldw	r2,8(r2)
 202938c:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 2029390:	e0bffb17 	ldw	r2,-20(fp)
 2029394:	10800517 	ldw	r2,20(r2)
 2029398:	10002426 	beq	r2,zero,202942c <alt_tse_mac_associate_phy+0x1e0>
 202939c:	e0bffb17 	ldw	r2,-20(fp)
 20293a0:	10800617 	ldw	r2,24(r2)
 20293a4:	10002126 	beq	r2,zero,202942c <alt_tse_mac_associate_phy+0x1e0>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 20293a8:	e0bffb17 	ldw	r2,-20(fp)
 20293ac:	10801017 	ldw	r2,64(r2)
 20293b0:	10bfffd8 	cmpnei	r2,r2,-1
 20293b4:	10001e1e 	bne	r2,zero,2029430 <alt_tse_mac_associate_phy+0x1e4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20293b8:	e13ffc17 	ldw	r4,-16(fp)
 20293bc:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 20293c0:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 20293c4:	e13ffb17 	ldw	r4,-20(fp)
 20293c8:	20272240 	call	2027224 <alt_tse_get_system_index>
 20293cc:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 20293d0:	e0bffc17 	ldw	r2,-16(fp)
 20293d4:	e0ffff17 	ldw	r3,-4(fp)
 20293d8:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 20293dc:	e0bfff17 	ldw	r2,-4(fp)
 20293e0:	e0fffc17 	ldw	r3,-16(fp)
 20293e4:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 20293e8:	e0bfff17 	ldw	r2,-4(fp)
 20293ec:	10800003 	ldbu	r2,0(r2)
 20293f0:	10c03fcc 	andi	r3,r2,255
 20293f4:	e0bffb17 	ldw	r2,-20(fp)
 20293f8:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 20293fc:	e0bffd47 	ldb	r2,-11(fp)
 2029400:	e0fffd07 	ldb	r3,-12(fp)
 2029404:	e13ffd87 	ldb	r4,-10(fp)
 2029408:	200f883a 	mov	r7,r4
 202940c:	180d883a 	mov	r6,r3
 2029410:	100b883a 	mov	r5,r2
 2029414:	01008134 	movhi	r4,516
 2029418:	210a4104 	addi	r4,r4,10500
 202941c:	2000bb00 	call	2000bb0 <printf>
                is_mapped = 1;
 2029420:	00800044 	movi	r2,1
 2029424:	e0bffa05 	stb	r2,-24(fp)
                break;
 2029428:	00000906 	br	2029450 <alt_tse_mac_associate_phy+0x204>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 202942c:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 2029430:	e0bff817 	ldw	r2,-32(fp)
 2029434:	10800044 	addi	r2,r2,1
 2029438:	e0bff815 	stw	r2,-32(fp)
 202943c:	e0bffe17 	ldw	r2,-8(fp)
 2029440:	10800003 	ldbu	r2,0(r2)
 2029444:	10803fcc 	andi	r2,r2,255
 2029448:	e0fff817 	ldw	r3,-32(fp)
 202944c:	18bfc516 	blt	r3,r2,2029364 <__alt_mem_mem_0+0xfd009364>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 2029450:	e0bffa03 	ldbu	r2,-24(fp)
 2029454:	1000091e 	bne	r2,zero,202947c <alt_tse_mac_associate_phy+0x230>
    	pphy->pmac_info = 0;
 2029458:	e0bfff17 	ldw	r2,-4(fp)
 202945c:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 2029460:	e0bffd47 	ldb	r2,-11(fp)
 2029464:	100b883a 	mov	r5,r2
 2029468:	01008134 	movhi	r4,516
 202946c:	210a5204 	addi	r4,r4,10568
 2029470:	2000bb00 	call	2000bb0 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 2029474:	00bfffc4 	movi	r2,-1
 2029478:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 202947c:	e0bff917 	ldw	r2,-28(fp)
}
 2029480:	e037883a 	mov	sp,fp
 2029484:	dfc00117 	ldw	ra,4(sp)
 2029488:	df000017 	ldw	fp,0(sp)
 202948c:	dec00204 	addi	sp,sp,8
 2029490:	f800283a 	ret

02029494 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 2029494:	defff804 	addi	sp,sp,-32
 2029498:	dfc00715 	stw	ra,28(sp)
 202949c:	df000615 	stw	fp,24(sp)
 20294a0:	df000604 	addi	fp,sp,24
 20294a4:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 20294a8:	e0bfff17 	ldw	r2,-4(fp)
 20294ac:	10800217 	ldw	r2,8(r2)
 20294b0:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 20294b4:	e0bffa17 	ldw	r2,-24(fp)
 20294b8:	10800017 	ldw	r2,0(r2)
 20294bc:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 20294c0:	e0bfff17 	ldw	r2,-4(fp)
 20294c4:	10800317 	ldw	r2,12(r2)
 20294c8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20294cc:	e13fff17 	ldw	r4,-4(fp)
 20294d0:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 20294d4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 20294d8:	e13ffc17 	ldw	r4,-16(fp)
 20294dc:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 20294e0:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 20294e4:	e0bffa17 	ldw	r2,-24(fp)
 20294e8:	108003c3 	ldbu	r2,15(r2)
 20294ec:	10803fcc 	andi	r2,r2,255
 20294f0:	10002c26 	beq	r2,zero,20295a4 <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 20294f4:	e0bffd47 	ldb	r2,-11(fp)
 20294f8:	e0fffd07 	ldb	r3,-12(fp)
 20294fc:	180d883a 	mov	r6,r3
 2029500:	100b883a 	mov	r5,r2
 2029504:	01008134 	movhi	r4,516
 2029508:	210a8304 	addi	r4,r4,10764
 202950c:	2000bb00 	call	2000bb0 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 2029510:	e0bffb17 	ldw	r2,-20(fp)
 2029514:	10808004 	addi	r2,r2,512
 2029518:	10801404 	addi	r2,r2,80
 202951c:	10800037 	ldwio	r2,0(r2)
 2029520:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 2029524:	e0bffa17 	ldw	r2,-24(fp)
 2029528:	10800403 	ldbu	r2,16(r2)
 202952c:	10803fcc 	andi	r2,r2,255
 2029530:	10000e26 	beq	r2,zero,202956c <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 2029534:	e0bffd47 	ldb	r2,-11(fp)
 2029538:	e0fffd07 	ldb	r3,-12(fp)
 202953c:	180d883a 	mov	r6,r3
 2029540:	100b883a 	mov	r5,r2
 2029544:	01008134 	movhi	r4,516
 2029548:	210a9104 	addi	r4,r4,10820
 202954c:	2000bb00 	call	2000bb0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 2029550:	e0bffb17 	ldw	r2,-20(fp)
 2029554:	10808004 	addi	r2,r2,512
 2029558:	10801404 	addi	r2,r2,80
 202955c:	e0fffe17 	ldw	r3,-8(fp)
 2029560:	18c000d4 	ori	r3,r3,3
 2029564:	10c00035 	stwio	r3,0(r2)
 2029568:	00000e06 	br	20295a4 <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 202956c:	e0bffd47 	ldb	r2,-11(fp)
 2029570:	e0fffd07 	ldb	r3,-12(fp)
 2029574:	180d883a 	mov	r6,r3
 2029578:	100b883a 	mov	r5,r2
 202957c:	01008134 	movhi	r4,516
 2029580:	210a9d04 	addi	r4,r4,10868
 2029584:	2000bb00 	call	2000bb0 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 2029588:	e0bffb17 	ldw	r2,-20(fp)
 202958c:	10808004 	addi	r2,r2,512
 2029590:	10801404 	addi	r2,r2,80
 2029594:	e13ffe17 	ldw	r4,-8(fp)
 2029598:	00ffff04 	movi	r3,-4
 202959c:	20c6703a 	and	r3,r4,r3
 20295a0:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 20295a4:	0005883a 	mov	r2,zero
}
 20295a8:	e037883a 	mov	sp,fp
 20295ac:	dfc00117 	ldw	ra,4(sp)
 20295b0:	df000017 	ldw	fp,0(sp)
 20295b4:	dec00204 	addi	sp,sp,8
 20295b8:	f800283a 	ret

020295bc <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 20295bc:	defffb04 	addi	sp,sp,-20
 20295c0:	dfc00415 	stw	ra,16(sp)
 20295c4:	df000315 	stw	fp,12(sp)
 20295c8:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 20295cc:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 20295d0:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 20295d4:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 20295d8:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 20295dc:	20282d80 	call	20282d8 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 20295e0:	20285740 	call	2028574 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 20295e4:	20287840 	call	2028784 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 20295e8:	e03ffd05 	stb	zero,-12(fp)
 20295ec:	00002f06 	br	20296ac <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 20295f0:	e0fffd07 	ldb	r3,-12(fp)
 20295f4:	008085f4 	movhi	r2,535
 20295f8:	10a95904 	addi	r2,r2,-23196
 20295fc:	18c7883a 	add	r3,r3,r3
 2029600:	18c7883a 	add	r3,r3,r3
 2029604:	10c5883a 	add	r2,r2,r3
 2029608:	10800017 	ldw	r2,0(r2)
 202960c:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 2029610:	e0bffe17 	ldw	r2,-8(fp)
 2029614:	10800117 	ldw	r2,4(r2)
 2029618:	10800217 	ldw	r2,8(r2)
 202961c:	10800203 	ldbu	r2,8(r2)
 2029620:	10803fcc 	andi	r2,r2,255
 2029624:	10000326 	beq	r2,zero,2029634 <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 2029628:	e13ffe17 	ldw	r4,-8(fp)
 202962c:	2028e280 	call	2028e28 <alt_tse_mac_get_phy>
 2029630:	00000706 	br	2029650 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 2029634:	e0bffd07 	ldb	r2,-12(fp)
 2029638:	e0fffd47 	ldb	r3,-11(fp)
 202963c:	180d883a 	mov	r6,r3
 2029640:	100b883a 	mov	r5,r2
 2029644:	01008134 	movhi	r4,516
 2029648:	210aa904 	addi	r4,r4,10916
 202964c:	2000bb00 	call	2000bb0 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 2029650:	e03ffd45 	stb	zero,-11(fp)
 2029654:	00000d06 	br	202968c <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 2029658:	e0bffd47 	ldb	r2,-11(fp)
 202965c:	e0fffe17 	ldw	r3,-8(fp)
 2029660:	10800044 	addi	r2,r2,1
 2029664:	1085883a 	add	r2,r2,r2
 2029668:	1085883a 	add	r2,r2,r2
 202966c:	1885883a 	add	r2,r3,r2
 2029670:	10800017 	ldw	r2,0(r2)
 2029674:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 2029678:	e13fff17 	ldw	r4,-4(fp)
 202967c:	20294940 	call	2029494 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 2029680:	e0bffd43 	ldbu	r2,-11(fp)
 2029684:	10800044 	addi	r2,r2,1
 2029688:	e0bffd45 	stb	r2,-11(fp)
 202968c:	e0fffd47 	ldb	r3,-11(fp)
 2029690:	e0bffe17 	ldw	r2,-8(fp)
 2029694:	10800003 	ldbu	r2,0(r2)
 2029698:	10803fcc 	andi	r2,r2,255
 202969c:	18bfee16 	blt	r3,r2,2029658 <__alt_mem_mem_0+0xfd009658>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 20296a0:	e0bffd03 	ldbu	r2,-12(fp)
 20296a4:	10800044 	addi	r2,r2,1
 20296a8:	e0bffd05 	stb	r2,-12(fp)
 20296ac:	e0fffd07 	ldb	r3,-12(fp)
 20296b0:	d0a80043 	ldbu	r2,-24575(gp)
 20296b4:	10803fcc 	andi	r2,r2,255
 20296b8:	18bfcd16 	blt	r3,r2,20295f0 <__alt_mem_mem_0+0xfd0095f0>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 20296bc:	0005883a 	mov	r2,zero
}
 20296c0:	e037883a 	mov	sp,fp
 20296c4:	dfc00117 	ldw	ra,4(sp)
 20296c8:	df000017 	ldw	fp,0(sp)
 20296cc:	dec00204 	addi	sp,sp,8
 20296d0:	f800283a 	ret

020296d4 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 20296d4:	defff704 	addi	sp,sp,-36
 20296d8:	dfc00815 	stw	ra,32(sp)
 20296dc:	df000715 	stw	fp,28(sp)
 20296e0:	df000704 	addi	fp,sp,28
 20296e4:	e13ffe15 	stw	r4,-8(fp)
 20296e8:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 20296ec:	e0bffe17 	ldw	r2,-8(fp)
 20296f0:	10800617 	ldw	r2,24(r2)
 20296f4:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 20296f8:	e0bffb17 	ldw	r2,-20(fp)
 20296fc:	10800317 	ldw	r2,12(r2)
 2029700:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2029704:	e13ffb17 	ldw	r4,-20(fp)
 2029708:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 202970c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2029710:	e13ffc17 	ldw	r4,-16(fp)
 2029714:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 2029718:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 202971c:	e13ffe17 	ldw	r4,-8(fp)
 2029720:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 2029724:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2029728:	e0bffe17 	ldw	r2,-8(fp)
 202972c:	10800003 	ldbu	r2,0(r2)
 2029730:	10803fcc 	andi	r2,r2,255
 2029734:	100b883a 	mov	r5,r2
 2029738:	e13ffe17 	ldw	r4,-8(fp)
 202973c:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 2029740:	01c00044 	movi	r7,1
 2029744:	018000c4 	movi	r6,3
 2029748:	01400044 	movi	r5,1
 202974c:	e13ffe17 	ldw	r4,-8(fp)
 2029750:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029754:	10000d1e 	bne	r2,zero,202978c <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 2029758:	e0bffd47 	ldb	r2,-11(fp)
 202975c:	e0fffd07 	ldb	r3,-12(fp)
 2029760:	180d883a 	mov	r6,r3
 2029764:	100b883a 	mov	r5,r2
 2029768:	01008134 	movhi	r4,516
 202976c:	210abf04 	addi	r4,r4,11004
 2029770:	2000bb00 	call	2000bb0 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2029774:	e0bffd83 	ldbu	r2,-10(fp)
 2029778:	100b883a 	mov	r5,r2
 202977c:	e13ffe17 	ldw	r4,-8(fp)
 2029780:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 2029784:	00bfff84 	movi	r2,-2
 2029788:	00003c06 	br	202987c <alt_tse_phy_restart_an+0x1a8>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 202978c:	00800044 	movi	r2,1
 2029790:	d8800015 	stw	r2,0(sp)
 2029794:	01c00044 	movi	r7,1
 2029798:	01800304 	movi	r6,12
 202979c:	000b883a 	mov	r5,zero
 20297a0:	e13ffe17 	ldw	r4,-8(fp)
 20297a4:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 20297a8:	00800044 	movi	r2,1
 20297ac:	d8800015 	stw	r2,0(sp)
 20297b0:	01c00044 	movi	r7,1
 20297b4:	01800244 	movi	r6,9
 20297b8:	000b883a 	mov	r5,zero
 20297bc:	e13ffe17 	ldw	r4,-8(fp)
 20297c0:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 20297c4:	e0bffd47 	ldb	r2,-11(fp)
 20297c8:	e0fffd07 	ldb	r3,-12(fp)
 20297cc:	180d883a 	mov	r6,r3
 20297d0:	100b883a 	mov	r5,r2
 20297d4:	01008134 	movhi	r4,516
 20297d8:	210acf04 	addi	r4,r4,11068
 20297dc:	2000bb00 	call	2000bb0 <printf>
    
    alt_32 timeout = 0;
 20297e0:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 20297e4:	00001306 	br	2029834 <alt_tse_phy_restart_an+0x160>
        if(timeout++ > timeout_threshold) {
 20297e8:	e0bffa17 	ldw	r2,-24(fp)
 20297ec:	10c00044 	addi	r3,r2,1
 20297f0:	e0fffa15 	stw	r3,-24(fp)
 20297f4:	1007883a 	mov	r3,r2
 20297f8:	e0bfff17 	ldw	r2,-4(fp)
 20297fc:	10c00d2e 	bgeu	r2,r3,2029834 <alt_tse_phy_restart_an+0x160>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 2029800:	e0bffd47 	ldb	r2,-11(fp)
 2029804:	e0fffd07 	ldb	r3,-12(fp)
 2029808:	180d883a 	mov	r6,r3
 202980c:	100b883a 	mov	r5,r2
 2029810:	01008134 	movhi	r4,516
 2029814:	210ae104 	addi	r4,r4,11140
 2029818:	2000bb00 	call	2000bb0 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 202981c:	e0bffd83 	ldbu	r2,-10(fp)
 2029820:	100b883a 	mov	r5,r2
 2029824:	e13ffe17 	ldw	r4,-8(fp)
 2029828:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 202982c:	00bfffc4 	movi	r2,-1
 2029830:	00001206 	br	202987c <alt_tse_phy_restart_an+0x1a8>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 2029834:	01c00044 	movi	r7,1
 2029838:	01800144 	movi	r6,5
 202983c:	01400044 	movi	r5,1
 2029840:	e13ffe17 	ldw	r4,-8(fp)
 2029844:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029848:	103fe726 	beq	r2,zero,20297e8 <__alt_mem_mem_0+0xfd0097e8>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 202984c:	e0bffd47 	ldb	r2,-11(fp)
 2029850:	e0fffd07 	ldb	r3,-12(fp)
 2029854:	180d883a 	mov	r6,r3
 2029858:	100b883a 	mov	r5,r2
 202985c:	01008134 	movhi	r4,516
 2029860:	210aed04 	addi	r4,r4,11188
 2029864:	2000bb00 	call	2000bb0 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2029868:	e0bffd83 	ldbu	r2,-10(fp)
 202986c:	100b883a 	mov	r5,r2
 2029870:	e13ffe17 	ldw	r4,-8(fp)
 2029874:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 2029878:	0005883a 	mov	r2,zero
}
 202987c:	e037883a 	mov	sp,fp
 2029880:	dfc00117 	ldw	ra,4(sp)
 2029884:	df000017 	ldw	fp,0(sp)
 2029888:	dec00204 	addi	sp,sp,8
 202988c:	f800283a 	ret

02029890 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 2029890:	defff904 	addi	sp,sp,-28
 2029894:	dfc00615 	stw	ra,24(sp)
 2029898:	df000515 	stw	fp,20(sp)
 202989c:	df000504 	addi	fp,sp,20
 20298a0:	e13ffe15 	stw	r4,-8(fp)
 20298a4:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 20298a8:	e0bffe17 	ldw	r2,-8(fp)
 20298ac:	10800617 	ldw	r2,24(r2)
 20298b0:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 20298b4:	e0bffb17 	ldw	r2,-20(fp)
 20298b8:	10800317 	ldw	r2,12(r2)
 20298bc:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20298c0:	e13ffb17 	ldw	r4,-20(fp)
 20298c4:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 20298c8:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 20298cc:	e13ffc17 	ldw	r4,-16(fp)
 20298d0:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 20298d4:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 20298d8:	e13ffe17 	ldw	r4,-8(fp)
 20298dc:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 20298e0:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 20298e4:	e0bffe17 	ldw	r2,-8(fp)
 20298e8:	10800003 	ldbu	r2,0(r2)
 20298ec:	10803fcc 	andi	r2,r2,255
 20298f0:	100b883a 	mov	r5,r2
 20298f4:	e13ffe17 	ldw	r4,-8(fp)
 20298f8:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 20298fc:	e0bffd47 	ldb	r2,-11(fp)
 2029900:	e0fffd07 	ldb	r3,-12(fp)
 2029904:	180d883a 	mov	r6,r3
 2029908:	100b883a 	mov	r5,r2
 202990c:	01008134 	movhi	r4,516
 2029910:	210af904 	addi	r4,r4,11236
 2029914:	2000bb00 	call	2000bb0 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 2029918:	01c00044 	movi	r7,1
 202991c:	01800384 	movi	r6,14
 2029920:	000b883a 	mov	r5,zero
 2029924:	e13ffe17 	ldw	r4,-8(fp)
 2029928:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202992c:	1000061e 	bne	r2,zero,2029948 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 2029930:	01c00044 	movi	r7,1
 2029934:	01800144 	movi	r6,5
 2029938:	01400044 	movi	r5,1
 202993c:	e13ffe17 	ldw	r4,-8(fp)
 2029940:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 2029944:	1000191e 	bne	r2,zero,20299ac <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 2029948:	e0bffd47 	ldb	r2,-11(fp)
 202994c:	e0fffd07 	ldb	r3,-12(fp)
 2029950:	180d883a 	mov	r6,r3
 2029954:	100b883a 	mov	r5,r2
 2029958:	01008134 	movhi	r4,516
 202995c:	210b0404 	addi	r4,r4,11280
 2029960:	2000bb00 	call	2000bb0 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 2029964:	e17fff17 	ldw	r5,-4(fp)
 2029968:	e13ffe17 	ldw	r4,-8(fp)
 202996c:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
 2029970:	10bfffd8 	cmpnei	r2,r2,-1
 2029974:	10000d1e 	bne	r2,zero,20299ac <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 2029978:	e0bffd47 	ldb	r2,-11(fp)
 202997c:	e0fffd07 	ldb	r3,-12(fp)
 2029980:	180d883a 	mov	r6,r3
 2029984:	100b883a 	mov	r5,r2
 2029988:	01008134 	movhi	r4,516
 202998c:	210b1804 	addi	r4,r4,11360
 2029990:	2000bb00 	call	2000bb0 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2029994:	e0bffd83 	ldbu	r2,-10(fp)
 2029998:	100b883a 	mov	r5,r2
 202999c:	e13ffe17 	ldw	r4,-8(fp)
 20299a0:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 20299a4:	00bfffc4 	movi	r2,-1
 20299a8:	00000c06 	br	20299dc <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 20299ac:	e0bffd47 	ldb	r2,-11(fp)
 20299b0:	e0fffd07 	ldb	r3,-12(fp)
 20299b4:	180d883a 	mov	r6,r3
 20299b8:	100b883a 	mov	r5,r2
 20299bc:	01008134 	movhi	r4,516
 20299c0:	210b2504 	addi	r4,r4,11412
 20299c4:	2000bb00 	call	2000bb0 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 20299c8:	e0bffd83 	ldbu	r2,-10(fp)
 20299cc:	100b883a 	mov	r5,r2
 20299d0:	e13ffe17 	ldw	r4,-8(fp)
 20299d4:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 20299d8:	0005883a 	mov	r2,zero
}
 20299dc:	e037883a 	mov	sp,fp
 20299e0:	dfc00117 	ldw	ra,4(sp)
 20299e4:	df000017 	ldw	fp,0(sp)
 20299e8:	dec00204 	addi	sp,sp,8
 20299ec:	f800283a 	ret

020299f0 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 20299f0:	defff904 	addi	sp,sp,-28
 20299f4:	dfc00615 	stw	ra,24(sp)
 20299f8:	df000515 	stw	fp,20(sp)
 20299fc:	df000504 	addi	fp,sp,20
 2029a00:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 2029a04:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2029a08:	e0bfff17 	ldw	r2,-4(fp)
 2029a0c:	10800617 	ldw	r2,24(r2)
 2029a10:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2029a14:	e0bffc17 	ldw	r2,-16(fp)
 2029a18:	10800317 	ldw	r2,12(r2)
 2029a1c:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2029a20:	e13ffc17 	ldw	r4,-16(fp)
 2029a24:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 2029a28:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 2029a2c:	e13ffd17 	ldw	r4,-12(fp)
 2029a30:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 2029a34:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2029a38:	e13fff17 	ldw	r4,-4(fp)
 2029a3c:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 2029a40:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2029a44:	e0bfff17 	ldw	r2,-4(fp)
 2029a48:	10800003 	ldbu	r2,0(r2)
 2029a4c:	10803fcc 	andi	r2,r2,255
 2029a50:	100b883a 	mov	r5,r2
 2029a54:	e13fff17 	ldw	r4,-4(fp)
 2029a58:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 2029a5c:	01c00044 	movi	r7,1
 2029a60:	018000c4 	movi	r6,3
 2029a64:	01400044 	movi	r5,1
 2029a68:	e13fff17 	ldw	r4,-4(fp)
 2029a6c:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029a70:	10000d1e 	bne	r2,zero,2029aa8 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 2029a74:	e0bffe47 	ldb	r2,-7(fp)
 2029a78:	e0fffe07 	ldb	r3,-8(fp)
 2029a7c:	180d883a 	mov	r6,r3
 2029a80:	100b883a 	mov	r5,r2
 2029a84:	01008134 	movhi	r4,516
 2029a88:	210abf04 	addi	r4,r4,11004
 2029a8c:	2000bb00 	call	2000bb0 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2029a90:	e0bffe83 	ldbu	r2,-6(fp)
 2029a94:	100b883a 	mov	r5,r2
 2029a98:	e13fff17 	ldw	r4,-4(fp)
 2029a9c:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 2029aa0:	00bfff84 	movi	r2,-2
 2029aa4:	00013206 	br	2029f70 <alt_tse_phy_get_cap+0x580>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2029aa8:	017e0034 	movhi	r5,63488
 2029aac:	e13fff17 	ldw	r4,-4(fp)
 2029ab0:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 2029ab4:	01c00044 	movi	r7,1
 2029ab8:	01800144 	movi	r6,5
 2029abc:	01400044 	movi	r5,1
 2029ac0:	e13fff17 	ldw	r4,-4(fp)
 2029ac4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029ac8:	1000021e 	bne	r2,zero,2029ad4 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 2029acc:	00bfffc4 	movi	r2,-1
 2029ad0:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 2029ad4:	01c00044 	movi	r7,1
 2029ad8:	018003c4 	movi	r6,15
 2029adc:	014003c4 	movi	r5,15
 2029ae0:	e13fff17 	ldw	r4,-4(fp)
 2029ae4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029ae8:	1007883a 	mov	r3,r2
 2029aec:	e0bfff17 	ldw	r2,-4(fp)
 2029af0:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 2029af4:	01c00044 	movi	r7,1
 2029af8:	01800384 	movi	r6,14
 2029afc:	014003c4 	movi	r5,15
 2029b00:	e13fff17 	ldw	r4,-4(fp)
 2029b04:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029b08:	1007883a 	mov	r3,r2
 2029b0c:	e0bfff17 	ldw	r2,-4(fp)
 2029b10:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 2029b14:	01c00044 	movi	r7,1
 2029b18:	01800344 	movi	r6,13
 2029b1c:	014003c4 	movi	r5,15
 2029b20:	e13fff17 	ldw	r4,-4(fp)
 2029b24:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029b28:	1007883a 	mov	r3,r2
 2029b2c:	e0bfff17 	ldw	r2,-4(fp)
 2029b30:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 2029b34:	01c00044 	movi	r7,1
 2029b38:	01800304 	movi	r6,12
 2029b3c:	014003c4 	movi	r5,15
 2029b40:	e13fff17 	ldw	r4,-4(fp)
 2029b44:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029b48:	1007883a 	mov	r3,r2
 2029b4c:	e0bfff17 	ldw	r2,-4(fp)
 2029b50:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 2029b54:	01c00044 	movi	r7,1
 2029b58:	018003c4 	movi	r6,15
 2029b5c:	01400044 	movi	r5,1
 2029b60:	e13fff17 	ldw	r4,-4(fp)
 2029b64:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029b68:	1007883a 	mov	r3,r2
 2029b6c:	e0bfff17 	ldw	r2,-4(fp)
 2029b70:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 2029b74:	01c00044 	movi	r7,1
 2029b78:	01800384 	movi	r6,14
 2029b7c:	01400044 	movi	r5,1
 2029b80:	e13fff17 	ldw	r4,-4(fp)
 2029b84:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029b88:	1007883a 	mov	r3,r2
 2029b8c:	e0bfff17 	ldw	r2,-4(fp)
 2029b90:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 2029b94:	01c00044 	movi	r7,1
 2029b98:	01800344 	movi	r6,13
 2029b9c:	01400044 	movi	r5,1
 2029ba0:	e13fff17 	ldw	r4,-4(fp)
 2029ba4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029ba8:	1007883a 	mov	r3,r2
 2029bac:	e0bfff17 	ldw	r2,-4(fp)
 2029bb0:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 2029bb4:	01c00044 	movi	r7,1
 2029bb8:	01800284 	movi	r6,10
 2029bbc:	01400044 	movi	r5,1
 2029bc0:	e13fff17 	ldw	r4,-4(fp)
 2029bc4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029bc8:	1007883a 	mov	r3,r2
 2029bcc:	e0bfff17 	ldw	r2,-4(fp)
 2029bd0:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 2029bd4:	01c00044 	movi	r7,1
 2029bd8:	01800244 	movi	r6,9
 2029bdc:	01400044 	movi	r5,1
 2029be0:	e13fff17 	ldw	r4,-4(fp)
 2029be4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029be8:	1007883a 	mov	r3,r2
 2029bec:	e0bfff17 	ldw	r2,-4(fp)
 2029bf0:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 2029bf4:	01c00044 	movi	r7,1
 2029bf8:	01800304 	movi	r6,12
 2029bfc:	01400044 	movi	r5,1
 2029c00:	e13fff17 	ldw	r4,-4(fp)
 2029c04:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029c08:	1007883a 	mov	r3,r2
 2029c0c:	e0bfff17 	ldw	r2,-4(fp)
 2029c10:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 2029c14:	01c00044 	movi	r7,1
 2029c18:	018002c4 	movi	r6,11
 2029c1c:	01400044 	movi	r5,1
 2029c20:	e13fff17 	ldw	r4,-4(fp)
 2029c24:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029c28:	1007883a 	mov	r3,r2
 2029c2c:	e0bfff17 	ldw	r2,-4(fp)
 2029c30:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 2029c34:	01c00044 	movi	r7,1
 2029c38:	018002c4 	movi	r6,11
 2029c3c:	01400284 	movi	r5,10
 2029c40:	e13fff17 	ldw	r4,-4(fp)
 2029c44:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029c48:	1007883a 	mov	r3,r2
 2029c4c:	e0bfff17 	ldw	r2,-4(fp)
 2029c50:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 2029c54:	01c00044 	movi	r7,1
 2029c58:	01800284 	movi	r6,10
 2029c5c:	01400284 	movi	r5,10
 2029c60:	e13fff17 	ldw	r4,-4(fp)
 2029c64:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029c68:	1007883a 	mov	r3,r2
 2029c6c:	e0bfff17 	ldw	r2,-4(fp)
 2029c70:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 2029c74:	01c00044 	movi	r7,1
 2029c78:	01800244 	movi	r6,9
 2029c7c:	01400144 	movi	r5,5
 2029c80:	e13fff17 	ldw	r4,-4(fp)
 2029c84:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029c88:	1007883a 	mov	r3,r2
 2029c8c:	e0bfff17 	ldw	r2,-4(fp)
 2029c90:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 2029c94:	01c00044 	movi	r7,1
 2029c98:	01800204 	movi	r6,8
 2029c9c:	01400144 	movi	r5,5
 2029ca0:	e13fff17 	ldw	r4,-4(fp)
 2029ca4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029ca8:	1007883a 	mov	r3,r2
 2029cac:	e0bfff17 	ldw	r2,-4(fp)
 2029cb0:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 2029cb4:	01c00044 	movi	r7,1
 2029cb8:	018001c4 	movi	r6,7
 2029cbc:	01400144 	movi	r5,5
 2029cc0:	e13fff17 	ldw	r4,-4(fp)
 2029cc4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029cc8:	1007883a 	mov	r3,r2
 2029ccc:	e0bfff17 	ldw	r2,-4(fp)
 2029cd0:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 2029cd4:	01c00044 	movi	r7,1
 2029cd8:	01800184 	movi	r6,6
 2029cdc:	01400144 	movi	r5,5
 2029ce0:	e13fff17 	ldw	r4,-4(fp)
 2029ce4:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029ce8:	1007883a 	mov	r3,r2
 2029cec:	e0bfff17 	ldw	r2,-4(fp)
 2029cf0:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 2029cf4:	01c00044 	movi	r7,1
 2029cf8:	01800144 	movi	r6,5
 2029cfc:	01400144 	movi	r5,5
 2029d00:	e13fff17 	ldw	r4,-4(fp)
 2029d04:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 2029d08:	1007883a 	mov	r3,r2
 2029d0c:	e0bfff17 	ldw	r2,-4(fp)
 2029d10:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 2029d14:	e0bffe47 	ldb	r2,-7(fp)
 2029d18:	e0fffe07 	ldb	r3,-8(fp)
 2029d1c:	180d883a 	mov	r6,r3
 2029d20:	100b883a 	mov	r5,r2
 2029d24:	01008134 	movhi	r4,516
 2029d28:	210b3004 	addi	r4,r4,11456
 2029d2c:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 2029d30:	e0bfff17 	ldw	r2,-4(fp)
 2029d34:	10800043 	ldbu	r2,1(r2)
 2029d38:	10803fcc 	andi	r2,r2,255
 2029d3c:	100b883a 	mov	r5,r2
 2029d40:	01008134 	movhi	r4,516
 2029d44:	210b3b04 	addi	r4,r4,11500
 2029d48:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 2029d4c:	e0bfff17 	ldw	r2,-4(fp)
 2029d50:	10800083 	ldbu	r2,2(r2)
 2029d54:	10803fcc 	andi	r2,r2,255
 2029d58:	100b883a 	mov	r5,r2
 2029d5c:	01008134 	movhi	r4,516
 2029d60:	210b4504 	addi	r4,r4,11540
 2029d64:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 2029d68:	e0bfff17 	ldw	r2,-4(fp)
 2029d6c:	108000c3 	ldbu	r2,3(r2)
 2029d70:	10803fcc 	andi	r2,r2,255
 2029d74:	100b883a 	mov	r5,r2
 2029d78:	01008134 	movhi	r4,516
 2029d7c:	210b4f04 	addi	r4,r4,11580
 2029d80:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 2029d84:	e0bfff17 	ldw	r2,-4(fp)
 2029d88:	10800103 	ldbu	r2,4(r2)
 2029d8c:	10803fcc 	andi	r2,r2,255
 2029d90:	100b883a 	mov	r5,r2
 2029d94:	01008134 	movhi	r4,516
 2029d98:	210b5904 	addi	r4,r4,11620
 2029d9c:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 2029da0:	e0bfff17 	ldw	r2,-4(fp)
 2029da4:	10800143 	ldbu	r2,5(r2)
 2029da8:	10803fcc 	andi	r2,r2,255
 2029dac:	100b883a 	mov	r5,r2
 2029db0:	01008134 	movhi	r4,516
 2029db4:	210b6304 	addi	r4,r4,11660
 2029db8:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 2029dbc:	e0bfff17 	ldw	r2,-4(fp)
 2029dc0:	10800183 	ldbu	r2,6(r2)
 2029dc4:	10803fcc 	andi	r2,r2,255
 2029dc8:	100b883a 	mov	r5,r2
 2029dcc:	01008134 	movhi	r4,516
 2029dd0:	210b6d04 	addi	r4,r4,11700
 2029dd4:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 2029dd8:	e0bfff17 	ldw	r2,-4(fp)
 2029ddc:	108001c3 	ldbu	r2,7(r2)
 2029de0:	10803fcc 	andi	r2,r2,255
 2029de4:	100b883a 	mov	r5,r2
 2029de8:	01008134 	movhi	r4,516
 2029dec:	210b7704 	addi	r4,r4,11740
 2029df0:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 2029df4:	e0bfff17 	ldw	r2,-4(fp)
 2029df8:	10800203 	ldbu	r2,8(r2)
 2029dfc:	10803fcc 	andi	r2,r2,255
 2029e00:	100b883a 	mov	r5,r2
 2029e04:	01008134 	movhi	r4,516
 2029e08:	210b8104 	addi	r4,r4,11780
 2029e0c:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 2029e10:	e0bfff17 	ldw	r2,-4(fp)
 2029e14:	10800243 	ldbu	r2,9(r2)
 2029e18:	10803fcc 	andi	r2,r2,255
 2029e1c:	100b883a 	mov	r5,r2
 2029e20:	01008134 	movhi	r4,516
 2029e24:	210b8b04 	addi	r4,r4,11820
 2029e28:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 2029e2c:	e0bfff17 	ldw	r2,-4(fp)
 2029e30:	10800283 	ldbu	r2,10(r2)
 2029e34:	10803fcc 	andi	r2,r2,255
 2029e38:	100b883a 	mov	r5,r2
 2029e3c:	01008134 	movhi	r4,516
 2029e40:	210b9504 	addi	r4,r4,11860
 2029e44:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 2029e48:	e0bfff17 	ldw	r2,-4(fp)
 2029e4c:	108002c3 	ldbu	r2,11(r2)
 2029e50:	10803fcc 	andi	r2,r2,255
 2029e54:	100b883a 	mov	r5,r2
 2029e58:	01008134 	movhi	r4,516
 2029e5c:	210b9f04 	addi	r4,r4,11900
 2029e60:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "\n");
 2029e64:	01008134 	movhi	r4,516
 2029e68:	210a0504 	addi	r4,r4,10260
 2029e6c:	202610c0 	call	202610c <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 2029e70:	e0bffe47 	ldb	r2,-7(fp)
 2029e74:	e0fffe07 	ldb	r3,-8(fp)
 2029e78:	180d883a 	mov	r6,r3
 2029e7c:	100b883a 	mov	r5,r2
 2029e80:	01008134 	movhi	r4,516
 2029e84:	210ba904 	addi	r4,r4,11940
 2029e88:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 2029e8c:	e0bfff17 	ldw	r2,-4(fp)
 2029e90:	10800303 	ldbu	r2,12(r2)
 2029e94:	10803fcc 	andi	r2,r2,255
 2029e98:	100b883a 	mov	r5,r2
 2029e9c:	01008134 	movhi	r4,516
 2029ea0:	210b4f04 	addi	r4,r4,11580
 2029ea4:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 2029ea8:	e0bfff17 	ldw	r2,-4(fp)
 2029eac:	10800343 	ldbu	r2,13(r2)
 2029eb0:	10803fcc 	andi	r2,r2,255
 2029eb4:	100b883a 	mov	r5,r2
 2029eb8:	01008134 	movhi	r4,516
 2029ebc:	210b5904 	addi	r4,r4,11620
 2029ec0:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 2029ec4:	e0bfff17 	ldw	r2,-4(fp)
 2029ec8:	10800383 	ldbu	r2,14(r2)
 2029ecc:	10803fcc 	andi	r2,r2,255
 2029ed0:	100b883a 	mov	r5,r2
 2029ed4:	01008134 	movhi	r4,516
 2029ed8:	210b6304 	addi	r4,r4,11660
 2029edc:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 2029ee0:	e0bfff17 	ldw	r2,-4(fp)
 2029ee4:	108003c3 	ldbu	r2,15(r2)
 2029ee8:	10803fcc 	andi	r2,r2,255
 2029eec:	100b883a 	mov	r5,r2
 2029ef0:	01008134 	movhi	r4,516
 2029ef4:	210bb604 	addi	r4,r4,11992
 2029ef8:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 2029efc:	e0bfff17 	ldw	r2,-4(fp)
 2029f00:	10800403 	ldbu	r2,16(r2)
 2029f04:	10803fcc 	andi	r2,r2,255
 2029f08:	100b883a 	mov	r5,r2
 2029f0c:	01008134 	movhi	r4,516
 2029f10:	210bc004 	addi	r4,r4,12032
 2029f14:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 2029f18:	e0bfff17 	ldw	r2,-4(fp)
 2029f1c:	10800443 	ldbu	r2,17(r2)
 2029f20:	10803fcc 	andi	r2,r2,255
 2029f24:	100b883a 	mov	r5,r2
 2029f28:	01008134 	movhi	r4,516
 2029f2c:	210bca04 	addi	r4,r4,12072
 2029f30:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 2029f34:	e0bfff17 	ldw	r2,-4(fp)
 2029f38:	10800483 	ldbu	r2,18(r2)
 2029f3c:	10803fcc 	andi	r2,r2,255
 2029f40:	100b883a 	mov	r5,r2
 2029f44:	01008134 	movhi	r4,516
 2029f48:	210bd404 	addi	r4,r4,12112
 2029f4c:	202610c0 	call	202610c <no_printf>
    tse_dprintf(6, "\n");
 2029f50:	01008134 	movhi	r4,516
 2029f54:	210a0504 	addi	r4,r4,10260
 2029f58:	202610c0 	call	202610c <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 2029f5c:	e0bffe83 	ldbu	r2,-6(fp)
 2029f60:	100b883a 	mov	r5,r2
 2029f64:	e13fff17 	ldw	r4,-4(fp)
 2029f68:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 2029f6c:	e0bffb17 	ldw	r2,-20(fp)
    
}
 2029f70:	e037883a 	mov	sp,fp
 2029f74:	dfc00117 	ldw	ra,4(sp)
 2029f78:	df000017 	ldw	fp,0(sp)
 2029f7c:	dec00204 	addi	sp,sp,8
 2029f80:	f800283a 	ret

02029f84 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 2029f84:	defff804 	addi	sp,sp,-32
 2029f88:	dfc00715 	stw	ra,28(sp)
 2029f8c:	df000615 	stw	fp,24(sp)
 2029f90:	df000604 	addi	fp,sp,24
 2029f94:	e13ffe15 	stw	r4,-8(fp)
 2029f98:	2805883a 	mov	r2,r5
 2029f9c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 2029fa0:	e0bffe17 	ldw	r2,-8(fp)
 2029fa4:	10800617 	ldw	r2,24(r2)
 2029fa8:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 2029fac:	e0bffb17 	ldw	r2,-20(fp)
 2029fb0:	10800317 	ldw	r2,12(r2)
 2029fb4:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 2029fb8:	e13ffb17 	ldw	r4,-20(fp)
 2029fbc:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 2029fc0:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 2029fc4:	e13ffc17 	ldw	r4,-16(fp)
 2029fc8:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 2029fcc:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 2029fd0:	e13ffe17 	ldw	r4,-8(fp)
 2029fd4:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 2029fd8:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 2029fdc:	e0bffe17 	ldw	r2,-8(fp)
 2029fe0:	10800003 	ldbu	r2,0(r2)
 2029fe4:	10803fcc 	andi	r2,r2,255
 2029fe8:	100b883a 	mov	r5,r2
 2029fec:	e13ffe17 	ldw	r4,-8(fp)
 2029ff0:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 2029ff4:	e0bfff03 	ldbu	r2,-4(fp)
 2029ff8:	10002d26 	beq	r2,zero,202a0b0 <alt_tse_phy_set_adv_1000+0x12c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 2029ffc:	01c00044 	movi	r7,1
 202a000:	01800344 	movi	r6,13
 202a004:	014003c4 	movi	r5,15
 202a008:	e13ffe17 	ldw	r4,-8(fp)
 202a00c:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a010:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 202a014:	e0bffdc3 	ldbu	r2,-9(fp)
 202a018:	d8800015 	stw	r2,0(sp)
 202a01c:	01c00044 	movi	r7,1
 202a020:	01800244 	movi	r6,9
 202a024:	01400244 	movi	r5,9
 202a028:	e13ffe17 	ldw	r4,-8(fp)
 202a02c:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a030:	e0bffd47 	ldb	r2,-11(fp)
 202a034:	e0fffd07 	ldb	r3,-12(fp)
 202a038:	e13ffdc3 	ldbu	r4,-9(fp)
 202a03c:	200f883a 	mov	r7,r4
 202a040:	180d883a 	mov	r6,r3
 202a044:	100b883a 	mov	r5,r2
 202a048:	01008134 	movhi	r4,516
 202a04c:	210bde04 	addi	r4,r4,12152
 202a050:	202610c0 	call	202610c <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 202a054:	01c00044 	movi	r7,1
 202a058:	01800304 	movi	r6,12
 202a05c:	014003c4 	movi	r5,15
 202a060:	e13ffe17 	ldw	r4,-8(fp)
 202a064:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a068:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 202a06c:	e0bffdc3 	ldbu	r2,-9(fp)
 202a070:	d8800015 	stw	r2,0(sp)
 202a074:	01c00044 	movi	r7,1
 202a078:	01800204 	movi	r6,8
 202a07c:	01400244 	movi	r5,9
 202a080:	e13ffe17 	ldw	r4,-8(fp)
 202a084:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a088:	e0bffd47 	ldb	r2,-11(fp)
 202a08c:	e0fffd07 	ldb	r3,-12(fp)
 202a090:	e13ffdc3 	ldbu	r4,-9(fp)
 202a094:	200f883a 	mov	r7,r4
 202a098:	180d883a 	mov	r6,r3
 202a09c:	100b883a 	mov	r5,r2
 202a0a0:	01008134 	movhi	r4,516
 202a0a4:	210bf104 	addi	r4,r4,12228
 202a0a8:	202610c0 	call	202610c <no_printf>
 202a0ac:	00001c06 	br	202a120 <alt_tse_phy_set_adv_1000+0x19c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 202a0b0:	d8000015 	stw	zero,0(sp)
 202a0b4:	01c00044 	movi	r7,1
 202a0b8:	01800244 	movi	r6,9
 202a0bc:	01400244 	movi	r5,9
 202a0c0:	e13ffe17 	ldw	r4,-8(fp)
 202a0c4:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a0c8:	e0bffd47 	ldb	r2,-11(fp)
 202a0cc:	e0fffd07 	ldb	r3,-12(fp)
 202a0d0:	000f883a 	mov	r7,zero
 202a0d4:	180d883a 	mov	r6,r3
 202a0d8:	100b883a 	mov	r5,r2
 202a0dc:	01008134 	movhi	r4,516
 202a0e0:	210bde04 	addi	r4,r4,12152
 202a0e4:	202610c0 	call	202610c <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 202a0e8:	d8000015 	stw	zero,0(sp)
 202a0ec:	01c00044 	movi	r7,1
 202a0f0:	01800204 	movi	r6,8
 202a0f4:	01400244 	movi	r5,9
 202a0f8:	e13ffe17 	ldw	r4,-8(fp)
 202a0fc:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a100:	e0bffd47 	ldb	r2,-11(fp)
 202a104:	e0fffd07 	ldb	r3,-12(fp)
 202a108:	000f883a 	mov	r7,zero
 202a10c:	180d883a 	mov	r6,r3
 202a110:	100b883a 	mov	r5,r2
 202a114:	01008134 	movhi	r4,516
 202a118:	210c0404 	addi	r4,r4,12304
 202a11c:	202610c0 	call	202610c <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 202a120:	e0bffd83 	ldbu	r2,-10(fp)
 202a124:	100b883a 	mov	r5,r2
 202a128:	e13ffe17 	ldw	r4,-8(fp)
 202a12c:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 202a130:	0005883a 	mov	r2,zero
}
 202a134:	e037883a 	mov	sp,fp
 202a138:	dfc00117 	ldw	ra,4(sp)
 202a13c:	df000017 	ldw	fp,0(sp)
 202a140:	dec00204 	addi	sp,sp,8
 202a144:	f800283a 	ret

0202a148 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 202a148:	defff804 	addi	sp,sp,-32
 202a14c:	dfc00715 	stw	ra,28(sp)
 202a150:	df000615 	stw	fp,24(sp)
 202a154:	df000604 	addi	fp,sp,24
 202a158:	e13ffe15 	stw	r4,-8(fp)
 202a15c:	2805883a 	mov	r2,r5
 202a160:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 202a164:	e0bffe17 	ldw	r2,-8(fp)
 202a168:	10800617 	ldw	r2,24(r2)
 202a16c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 202a170:	e0bffb17 	ldw	r2,-20(fp)
 202a174:	10800317 	ldw	r2,12(r2)
 202a178:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 202a17c:	e13ffb17 	ldw	r4,-20(fp)
 202a180:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 202a184:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 202a188:	e13ffc17 	ldw	r4,-16(fp)
 202a18c:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 202a190:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 202a194:	e13ffe17 	ldw	r4,-8(fp)
 202a198:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 202a19c:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 202a1a0:	e0bffe17 	ldw	r2,-8(fp)
 202a1a4:	10800003 	ldbu	r2,0(r2)
 202a1a8:	10803fcc 	andi	r2,r2,255
 202a1ac:	100b883a 	mov	r5,r2
 202a1b0:	e13ffe17 	ldw	r4,-8(fp)
 202a1b4:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 202a1b8:	e0bfff03 	ldbu	r2,-4(fp)
 202a1bc:	10004326 	beq	r2,zero,202a2cc <alt_tse_phy_set_adv_100+0x184>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 202a1c0:	01c00044 	movi	r7,1
 202a1c4:	018003c4 	movi	r6,15
 202a1c8:	01400044 	movi	r5,1
 202a1cc:	e13ffe17 	ldw	r4,-8(fp)
 202a1d0:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a1d4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 202a1d8:	e0bffdc3 	ldbu	r2,-9(fp)
 202a1dc:	d8800015 	stw	r2,0(sp)
 202a1e0:	01c00044 	movi	r7,1
 202a1e4:	01800244 	movi	r6,9
 202a1e8:	01400104 	movi	r5,4
 202a1ec:	e13ffe17 	ldw	r4,-8(fp)
 202a1f0:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 202a1f4:	e0bffd47 	ldb	r2,-11(fp)
 202a1f8:	e0fffd07 	ldb	r3,-12(fp)
 202a1fc:	e13ffdc3 	ldbu	r4,-9(fp)
 202a200:	200f883a 	mov	r7,r4
 202a204:	180d883a 	mov	r6,r3
 202a208:	100b883a 	mov	r5,r2
 202a20c:	01008134 	movhi	r4,516
 202a210:	210c1604 	addi	r4,r4,12376
 202a214:	202610c0 	call	202610c <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 202a218:	01c00044 	movi	r7,1
 202a21c:	01800384 	movi	r6,14
 202a220:	01400044 	movi	r5,1
 202a224:	e13ffe17 	ldw	r4,-8(fp)
 202a228:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a22c:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 202a230:	e0bffdc3 	ldbu	r2,-9(fp)
 202a234:	d8800015 	stw	r2,0(sp)
 202a238:	01c00044 	movi	r7,1
 202a23c:	01800204 	movi	r6,8
 202a240:	01400104 	movi	r5,4
 202a244:	e13ffe17 	ldw	r4,-8(fp)
 202a248:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a24c:	e0bffd47 	ldb	r2,-11(fp)
 202a250:	e0fffd07 	ldb	r3,-12(fp)
 202a254:	e13ffdc3 	ldbu	r4,-9(fp)
 202a258:	200f883a 	mov	r7,r4
 202a25c:	180d883a 	mov	r6,r3
 202a260:	100b883a 	mov	r5,r2
 202a264:	01008134 	movhi	r4,516
 202a268:	210c2604 	addi	r4,r4,12440
 202a26c:	202610c0 	call	202610c <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 202a270:	01c00044 	movi	r7,1
 202a274:	01800344 	movi	r6,13
 202a278:	01400044 	movi	r5,1
 202a27c:	e13ffe17 	ldw	r4,-8(fp)
 202a280:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a284:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 202a288:	e0bffdc3 	ldbu	r2,-9(fp)
 202a28c:	d8800015 	stw	r2,0(sp)
 202a290:	01c00044 	movi	r7,1
 202a294:	018001c4 	movi	r6,7
 202a298:	01400104 	movi	r5,4
 202a29c:	e13ffe17 	ldw	r4,-8(fp)
 202a2a0:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a2a4:	e0bffd47 	ldb	r2,-11(fp)
 202a2a8:	e0fffd07 	ldb	r3,-12(fp)
 202a2ac:	e13ffdc3 	ldbu	r4,-9(fp)
 202a2b0:	200f883a 	mov	r7,r4
 202a2b4:	180d883a 	mov	r6,r3
 202a2b8:	100b883a 	mov	r5,r2
 202a2bc:	01008134 	movhi	r4,516
 202a2c0:	210c3904 	addi	r4,r4,12516
 202a2c4:	202610c0 	call	202610c <no_printf>
 202a2c8:	00002a06 	br	202a374 <alt_tse_phy_set_adv_100+0x22c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 202a2cc:	d8000015 	stw	zero,0(sp)
 202a2d0:	01c00044 	movi	r7,1
 202a2d4:	01800244 	movi	r6,9
 202a2d8:	01400104 	movi	r5,4
 202a2dc:	e13ffe17 	ldw	r4,-8(fp)
 202a2e0:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 202a2e4:	e0bffd47 	ldb	r2,-11(fp)
 202a2e8:	e0fffd07 	ldb	r3,-12(fp)
 202a2ec:	000f883a 	mov	r7,zero
 202a2f0:	180d883a 	mov	r6,r3
 202a2f4:	100b883a 	mov	r5,r2
 202a2f8:	01008134 	movhi	r4,516
 202a2fc:	210c1604 	addi	r4,r4,12376
 202a300:	202610c0 	call	202610c <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 202a304:	d8000015 	stw	zero,0(sp)
 202a308:	01c00044 	movi	r7,1
 202a30c:	01800204 	movi	r6,8
 202a310:	01400104 	movi	r5,4
 202a314:	e13ffe17 	ldw	r4,-8(fp)
 202a318:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a31c:	e0bffd47 	ldb	r2,-11(fp)
 202a320:	e0fffd07 	ldb	r3,-12(fp)
 202a324:	000f883a 	mov	r7,zero
 202a328:	180d883a 	mov	r6,r3
 202a32c:	100b883a 	mov	r5,r2
 202a330:	01008134 	movhi	r4,516
 202a334:	210c2604 	addi	r4,r4,12440
 202a338:	202610c0 	call	202610c <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 202a33c:	d8000015 	stw	zero,0(sp)
 202a340:	01c00044 	movi	r7,1
 202a344:	018001c4 	movi	r6,7
 202a348:	01400104 	movi	r5,4
 202a34c:	e13ffe17 	ldw	r4,-8(fp)
 202a350:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a354:	e0bffd47 	ldb	r2,-11(fp)
 202a358:	e0fffd07 	ldb	r3,-12(fp)
 202a35c:	000f883a 	mov	r7,zero
 202a360:	180d883a 	mov	r6,r3
 202a364:	100b883a 	mov	r5,r2
 202a368:	01008134 	movhi	r4,516
 202a36c:	210c3904 	addi	r4,r4,12516
 202a370:	202610c0 	call	202610c <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 202a374:	e0bffd83 	ldbu	r2,-10(fp)
 202a378:	100b883a 	mov	r5,r2
 202a37c:	e13ffe17 	ldw	r4,-8(fp)
 202a380:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 202a384:	0005883a 	mov	r2,zero
}
 202a388:	e037883a 	mov	sp,fp
 202a38c:	dfc00117 	ldw	ra,4(sp)
 202a390:	df000017 	ldw	fp,0(sp)
 202a394:	dec00204 	addi	sp,sp,8
 202a398:	f800283a 	ret

0202a39c <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 202a39c:	defff504 	addi	sp,sp,-44
 202a3a0:	dfc00a15 	stw	ra,40(sp)
 202a3a4:	df000915 	stw	fp,36(sp)
 202a3a8:	df000904 	addi	fp,sp,36
 202a3ac:	e13ffe15 	stw	r4,-8(fp)
 202a3b0:	2805883a 	mov	r2,r5
 202a3b4:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 202a3b8:	e0bffe17 	ldw	r2,-8(fp)
 202a3bc:	10800617 	ldw	r2,24(r2)
 202a3c0:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 202a3c4:	e0bff817 	ldw	r2,-32(fp)
 202a3c8:	10800317 	ldw	r2,12(r2)
 202a3cc:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 202a3d0:	e13ff817 	ldw	r4,-32(fp)
 202a3d4:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 202a3d8:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 202a3dc:	e13ff917 	ldw	r4,-28(fp)
 202a3e0:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 202a3e4:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 202a3e8:	e13ffe17 	ldw	r4,-8(fp)
 202a3ec:	20280440 	call	2028044 <alt_tse_phy_rd_mdio_addr>
 202a3f0:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 202a3f4:	e0bffe17 	ldw	r2,-8(fp)
 202a3f8:	10800003 	ldbu	r2,0(r2)
 202a3fc:	10803fcc 	andi	r2,r2,255
 202a400:	100b883a 	mov	r5,r2
 202a404:	e13ffe17 	ldw	r4,-8(fp)
 202a408:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 202a40c:	e0bfff03 	ldbu	r2,-4(fp)
 202a410:	10002926 	beq	r2,zero,202a4b8 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 202a414:	01c00044 	movi	r7,1
 202a418:	01800304 	movi	r6,12
 202a41c:	01400044 	movi	r5,1
 202a420:	e13ffe17 	ldw	r4,-8(fp)
 202a424:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a428:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 202a42c:	e0bffd03 	ldbu	r2,-12(fp)
 202a430:	d8800015 	stw	r2,0(sp)
 202a434:	01c00044 	movi	r7,1
 202a438:	01800184 	movi	r6,6
 202a43c:	01400104 	movi	r5,4
 202a440:	e13ffe17 	ldw	r4,-8(fp)
 202a444:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a448:	e0bffd03 	ldbu	r2,-12(fp)
 202a44c:	100f883a 	mov	r7,r2
 202a450:	e1bffa17 	ldw	r6,-24(fp)
 202a454:	e17ffb17 	ldw	r5,-20(fp)
 202a458:	01008134 	movhi	r4,516
 202a45c:	210c4c04 	addi	r4,r4,12592
 202a460:	202610c0 	call	202610c <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 202a464:	01c00044 	movi	r7,1
 202a468:	018002c4 	movi	r6,11
 202a46c:	01400044 	movi	r5,1
 202a470:	e13ffe17 	ldw	r4,-8(fp)
 202a474:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202a478:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 202a47c:	e0bffd03 	ldbu	r2,-12(fp)
 202a480:	d8800015 	stw	r2,0(sp)
 202a484:	01c00044 	movi	r7,1
 202a488:	01800144 	movi	r6,5
 202a48c:	01400104 	movi	r5,4
 202a490:	e13ffe17 	ldw	r4,-8(fp)
 202a494:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 202a498:	e0bffd03 	ldbu	r2,-12(fp)
 202a49c:	100f883a 	mov	r7,r2
 202a4a0:	e1bffa17 	ldw	r6,-24(fp)
 202a4a4:	e17ffb17 	ldw	r5,-20(fp)
 202a4a8:	01008134 	movhi	r4,516
 202a4ac:	210c5f04 	addi	r4,r4,12668
 202a4b0:	202610c0 	call	202610c <no_printf>
 202a4b4:	00001806 	br	202a518 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 202a4b8:	d8000015 	stw	zero,0(sp)
 202a4bc:	01c00044 	movi	r7,1
 202a4c0:	01800184 	movi	r6,6
 202a4c4:	01400104 	movi	r5,4
 202a4c8:	e13ffe17 	ldw	r4,-8(fp)
 202a4cc:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a4d0:	000f883a 	mov	r7,zero
 202a4d4:	e1bffa17 	ldw	r6,-24(fp)
 202a4d8:	e17ffb17 	ldw	r5,-20(fp)
 202a4dc:	01008134 	movhi	r4,516
 202a4e0:	210c4c04 	addi	r4,r4,12592
 202a4e4:	202610c0 	call	202610c <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 202a4e8:	d8000015 	stw	zero,0(sp)
 202a4ec:	01c00044 	movi	r7,1
 202a4f0:	01800144 	movi	r6,5
 202a4f4:	01400104 	movi	r5,4
 202a4f8:	e13ffe17 	ldw	r4,-8(fp)
 202a4fc:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 202a500:	000f883a 	mov	r7,zero
 202a504:	e1bffa17 	ldw	r6,-24(fp)
 202a508:	e17ffb17 	ldw	r5,-20(fp)
 202a50c:	01008134 	movhi	r4,516
 202a510:	210c5f04 	addi	r4,r4,12668
 202a514:	202610c0 	call	202610c <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 202a518:	e0bffc17 	ldw	r2,-16(fp)
 202a51c:	10803fcc 	andi	r2,r2,255
 202a520:	100b883a 	mov	r5,r2
 202a524:	e13ffe17 	ldw	r4,-8(fp)
 202a528:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 202a52c:	0005883a 	mov	r2,zero
}
 202a530:	e037883a 	mov	sp,fp
 202a534:	dfc00117 	ldw	ra,4(sp)
 202a538:	df000017 	ldw	fp,0(sp)
 202a53c:	dec00204 	addi	sp,sp,8
 202a540:	f800283a 	ret

0202a544 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 202a544:	defff604 	addi	sp,sp,-40
 202a548:	dfc00915 	stw	ra,36(sp)
 202a54c:	df000815 	stw	fp,32(sp)
 202a550:	df000804 	addi	fp,sp,32
 202a554:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 202a558:	00800044 	movi	r2,1
 202a55c:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 202a560:	00800044 	movi	r2,1
 202a564:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 202a568:	00800044 	movi	r2,1
 202a56c:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 202a570:	00800044 	movi	r2,1
 202a574:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 202a578:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 202a57c:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 202a580:	e13fff17 	ldw	r4,-4(fp)
 202a584:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 202a588:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 202a58c:	e03ff815 	stw	zero,-32(fp)
 202a590:	00001c06 	br	202a604 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 202a594:	e0ffff17 	ldw	r3,-4(fp)
 202a598:	e0bff817 	ldw	r2,-32(fp)
 202a59c:	10800044 	addi	r2,r2,1
 202a5a0:	1085883a 	add	r2,r2,r2
 202a5a4:	1085883a 	add	r2,r2,r2
 202a5a8:	1885883a 	add	r2,r3,r2
 202a5ac:	10800017 	ldw	r2,0(r2)
 202a5b0:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 202a5b4:	e0bffc17 	ldw	r2,-16(fp)
 202a5b8:	10800117 	ldw	r2,4(r2)
 202a5bc:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 202a5c0:	e0bffd17 	ldw	r2,-12(fp)
 202a5c4:	10000926 	beq	r2,zero,202a5ec <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 202a5c8:	01400044 	movi	r5,1
 202a5cc:	e13ffd17 	ldw	r4,-12(fp)
 202a5d0:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 202a5d4:	01400044 	movi	r5,1
 202a5d8:	e13ffd17 	ldw	r4,-12(fp)
 202a5dc:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 202a5e0:	01400044 	movi	r5,1
 202a5e4:	e13ffd17 	ldw	r4,-12(fp)
 202a5e8:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 202a5ec:	01008134 	movhi	r4,516
 202a5f0:	210a0504 	addi	r4,r4,10260
 202a5f4:	202610c0 	call	202610c <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 202a5f8:	e0bff817 	ldw	r2,-32(fp)
 202a5fc:	10800044 	addi	r2,r2,1
 202a600:	e0bff815 	stw	r2,-32(fp)
 202a604:	e0bfff17 	ldw	r2,-4(fp)
 202a608:	10800003 	ldbu	r2,0(r2)
 202a60c:	10803fcc 	andi	r2,r2,255
 202a610:	e0fff817 	ldw	r3,-32(fp)
 202a614:	18bfdf16 	blt	r3,r2,202a594 <__alt_mem_mem_0+0xfd00a594>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 202a618:	e03ff815 	stw	zero,-32(fp)
 202a61c:	00005606 	br	202a778 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 202a620:	e0ffff17 	ldw	r3,-4(fp)
 202a624:	e0bff817 	ldw	r2,-32(fp)
 202a628:	10800044 	addi	r2,r2,1
 202a62c:	1085883a 	add	r2,r2,r2
 202a630:	1085883a 	add	r2,r2,r2
 202a634:	1885883a 	add	r2,r3,r2
 202a638:	10800017 	ldw	r2,0(r2)
 202a63c:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 202a640:	e0bffc17 	ldw	r2,-16(fp)
 202a644:	10800117 	ldw	r2,4(r2)
 202a648:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 202a64c:	e0bffd17 	ldw	r2,-12(fp)
 202a650:	10004326 	beq	r2,zero,202a760 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 202a654:	e13ffd17 	ldw	r4,-12(fp)
 202a658:	20299f00 	call	20299f0 <alt_tse_phy_get_cap>
 202a65c:	1000421e 	bne	r2,zero,202a768 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 202a660:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 202a664:	e0bffc17 	ldw	r2,-16(fp)
 202a668:	10800003 	ldbu	r2,0(r2)
 202a66c:	10803fcc 	andi	r2,r2,255
 202a670:	10800058 	cmpnei	r2,r2,1
 202a674:	1000021e 	bne	r2,zero,202a680 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 202a678:	e03ff905 	stb	zero,-28(fp)
 202a67c:	00000706 	br	202a69c <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 202a680:	e0bffc17 	ldw	r2,-16(fp)
 202a684:	10800003 	ldbu	r2,0(r2)
 202a688:	10803fcc 	andi	r2,r2,255
 202a68c:	10800098 	cmpnei	r2,r2,2
 202a690:	1000021e 	bne	r2,zero,202a69c <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 202a694:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 202a698:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 202a69c:	e0bffd17 	ldw	r2,-12(fp)
 202a6a0:	10c000c3 	ldbu	r3,3(r2)
 202a6a4:	e0bffd17 	ldw	r2,-12(fp)
 202a6a8:	10800303 	ldbu	r2,12(r2)
 202a6ac:	1884703a 	and	r2,r3,r2
 202a6b0:	1007883a 	mov	r3,r2
 202a6b4:	e0bff903 	ldbu	r2,-28(fp)
 202a6b8:	1884703a 	and	r2,r3,r2
 202a6bc:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 202a6c0:	e0bffd17 	ldw	r2,-12(fp)
 202a6c4:	10c00183 	ldbu	r3,6(r2)
 202a6c8:	e0bffd17 	ldw	r2,-12(fp)
 202a6cc:	108003c3 	ldbu	r2,15(r2)
 202a6d0:	1884703a 	and	r2,r3,r2
 202a6d4:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 202a6d8:	e0bffd17 	ldw	r2,-12(fp)
 202a6dc:	10c001c3 	ldbu	r3,7(r2)
 202a6e0:	e0bffd17 	ldw	r2,-12(fp)
 202a6e4:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 202a6e8:	1884703a 	and	r2,r3,r2
 202a6ec:	2084b03a 	or	r2,r4,r2
 202a6f0:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 202a6f4:	e0bffd17 	ldw	r2,-12(fp)
 202a6f8:	10c00143 	ldbu	r3,5(r2)
 202a6fc:	e0bffd17 	ldw	r2,-12(fp)
 202a700:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 202a704:	1884703a 	and	r2,r3,r2
 202a708:	2084b03a 	or	r2,r4,r2
 202a70c:	1007883a 	mov	r3,r2
 202a710:	e0bff943 	ldbu	r2,-27(fp)
 202a714:	1884703a 	and	r2,r3,r2
 202a718:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 202a71c:	e0bffd17 	ldw	r2,-12(fp)
 202a720:	10c00283 	ldbu	r3,10(r2)
 202a724:	e0bffd17 	ldw	r2,-12(fp)
 202a728:	10800443 	ldbu	r2,17(r2)
 202a72c:	1884703a 	and	r2,r3,r2
 202a730:	1009883a 	mov	r4,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 202a734:	e0bffd17 	ldw	r2,-12(fp)
 202a738:	10c002c3 	ldbu	r3,11(r2)
 202a73c:	e0bffd17 	ldw	r2,-12(fp)
 202a740:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 202a744:	1884703a 	and	r2,r3,r2
 202a748:	2084b03a 	or	r2,r4,r2
 202a74c:	1007883a 	mov	r3,r2
 202a750:	e0bff983 	ldbu	r2,-26(fp)
 202a754:	1884703a 	and	r2,r3,r2
 202a758:	e0bff985 	stb	r2,-26(fp)
 202a75c:	00000306 	br	202a76c <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 202a760:	0001883a 	nop
 202a764:	00000106 	br	202a76c <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 202a768:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 202a76c:	e0bff817 	ldw	r2,-32(fp)
 202a770:	10800044 	addi	r2,r2,1
 202a774:	e0bff815 	stw	r2,-32(fp)
 202a778:	e0bfff17 	ldw	r2,-4(fp)
 202a77c:	10800003 	ldbu	r2,0(r2)
 202a780:	10803fcc 	andi	r2,r2,255
 202a784:	e0fff817 	ldw	r3,-32(fp)
 202a788:	18bfa516 	blt	r3,r2,202a620 <__alt_mem_mem_0+0xfd00a620>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 202a78c:	e0bffb03 	ldbu	r2,-20(fp)
 202a790:	10800058 	cmpnei	r2,r2,1
 202a794:	1000081e 	bne	r2,zero,202a7b8 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 202a798:	00bfffc4 	movi	r2,-1
 202a79c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 202a7a0:	e0bffe07 	ldb	r2,-8(fp)
 202a7a4:	100b883a 	mov	r5,r2
 202a7a8:	01008134 	movhi	r4,516
 202a7ac:	210c7204 	addi	r4,r4,12744
 202a7b0:	2000bb00 	call	2000bb0 <printf>
 202a7b4:	00002706 	br	202a854 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 202a7b8:	e0bff903 	ldbu	r2,-28(fp)
 202a7bc:	10000926 	beq	r2,zero,202a7e4 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 202a7c0:	00800084 	movi	r2,2
 202a7c4:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 202a7c8:	e0bffe07 	ldb	r2,-8(fp)
 202a7cc:	0180fa04 	movi	r6,1000
 202a7d0:	100b883a 	mov	r5,r2
 202a7d4:	01008134 	movhi	r4,516
 202a7d8:	210c8404 	addi	r4,r4,12816
 202a7dc:	2000bb00 	call	2000bb0 <printf>
 202a7e0:	00001c06 	br	202a854 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 202a7e4:	e0bff943 	ldbu	r2,-27(fp)
 202a7e8:	10000926 	beq	r2,zero,202a810 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 202a7ec:	00800044 	movi	r2,1
 202a7f0:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 202a7f4:	e0bffe07 	ldb	r2,-8(fp)
 202a7f8:	01801904 	movi	r6,100
 202a7fc:	100b883a 	mov	r5,r2
 202a800:	01008134 	movhi	r4,516
 202a804:	210c8404 	addi	r4,r4,12816
 202a808:	2000bb00 	call	2000bb0 <printf>
 202a80c:	00001106 	br	202a854 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 202a810:	e0bff983 	ldbu	r2,-26(fp)
 202a814:	10000826 	beq	r2,zero,202a838 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 202a818:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 202a81c:	e0bffe07 	ldb	r2,-8(fp)
 202a820:	01800284 	movi	r6,10
 202a824:	100b883a 	mov	r5,r2
 202a828:	01008134 	movhi	r4,516
 202a82c:	210c8404 	addi	r4,r4,12816
 202a830:	2000bb00 	call	2000bb0 <printf>
 202a834:	00000706 	br	202a854 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 202a838:	00bfffc4 	movi	r2,-1
 202a83c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 202a840:	e0bffe07 	ldb	r2,-8(fp)
 202a844:	100b883a 	mov	r5,r2
 202a848:	01008134 	movhi	r4,516
 202a84c:	210c9104 	addi	r4,r4,12868
 202a850:	2000bb00 	call	2000bb0 <printf>

    return common_speed;
 202a854:	e0bffa17 	ldw	r2,-24(fp)
}
 202a858:	e037883a 	mov	sp,fp
 202a85c:	dfc00117 	ldw	ra,4(sp)
 202a860:	df000017 	ldw	fp,0(sp)
 202a864:	dec00204 	addi	sp,sp,8
 202a868:	f800283a 	ret

0202a86c <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 202a86c:	defff004 	addi	sp,sp,-64
 202a870:	dfc00f15 	stw	ra,60(sp)
 202a874:	df000e15 	stw	fp,56(sp)
 202a878:	dc400d15 	stw	r17,52(sp)
 202a87c:	dc000c15 	stw	r16,48(sp)
 202a880:	df000e04 	addi	fp,sp,56
 202a884:	e13ffc15 	stw	r4,-16(fp)
 202a888:	e17ffd15 	stw	r5,-12(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 202a88c:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 202a890:	e03ff615 	stw	zero,-40(fp)
    alt_tse_system_info *psys = 0;
 202a894:	e03ff715 	stw	zero,-36(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 202a898:	e03ff805 	stb	zero,-32(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 202a89c:	e13ffc17 	ldw	r4,-16(fp)
 202a8a0:	20272900 	call	2027290 <alt_tse_get_mac_group_index>
 202a8a4:	e0bff845 	stb	r2,-31(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 202a8a8:	e0bffc17 	ldw	r2,-16(fp)
 202a8ac:	10800117 	ldw	r2,4(r2)
 202a8b0:	10800217 	ldw	r2,8(r2)
 202a8b4:	10800017 	ldw	r2,0(r2)
 202a8b8:	e0bff915 	stw	r2,-28(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 202a8bc:	e0bff917 	ldw	r2,-28(fp)
 202a8c0:	10801004 	addi	r2,r2,64
 202a8c4:	10800037 	ldwio	r2,0(r2)
 202a8c8:	e0bffa15 	stw	r2,-24(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 202a8cc:	e0bffd17 	ldw	r2,-12(fp)
 202a8d0:	10000316 	blt	r2,zero,202a8e0 <alt_tse_phy_set_common_speed+0x74>
 202a8d4:	e0bffd17 	ldw	r2,-12(fp)
 202a8d8:	108000d0 	cmplti	r2,r2,3
 202a8dc:	10000c1e 	bne	r2,zero,202a910 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 202a8e0:	e0bff847 	ldb	r2,-31(fp)
 202a8e4:	e1bffd17 	ldw	r6,-12(fp)
 202a8e8:	100b883a 	mov	r5,r2
 202a8ec:	01008134 	movhi	r4,516
 202a8f0:	210c9e04 	addi	r4,r4,12920
 202a8f4:	2000bb00 	call	2000bb0 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 202a8f8:	e0bff917 	ldw	r2,-28(fp)
 202a8fc:	10801004 	addi	r2,r2,64
 202a900:	e0fffa17 	ldw	r3,-24(fp)
 202a904:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 202a908:	00bfffc4 	movi	r2,-1
 202a90c:	0000fd06 	br	202ad04 <alt_tse_phy_set_common_speed+0x498>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 202a910:	e03ff315 	stw	zero,-52(fp)
 202a914:	0000db06 	br	202ac84 <alt_tse_phy_set_common_speed+0x418>
        pmac_info = pmac_group->pmac_info[i];
 202a918:	e0fffc17 	ldw	r3,-16(fp)
 202a91c:	e0bff317 	ldw	r2,-52(fp)
 202a920:	10800044 	addi	r2,r2,1
 202a924:	1085883a 	add	r2,r2,r2
 202a928:	1085883a 	add	r2,r2,r2
 202a92c:	1885883a 	add	r2,r3,r2
 202a930:	10800017 	ldw	r2,0(r2)
 202a934:	e0bff615 	stw	r2,-40(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 202a938:	e13ff617 	ldw	r4,-40(fp)
 202a93c:	20273040 	call	2027304 <alt_tse_get_mac_info_index>
 202a940:	e0bff805 	stb	r2,-32(fp)

        pphy = pmac_info->pphy_info;
 202a944:	e0bff617 	ldw	r2,-40(fp)
 202a948:	10800117 	ldw	r2,4(r2)
 202a94c:	e0bff515 	stw	r2,-44(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 202a950:	e0bff517 	ldw	r2,-44(fp)
 202a954:	1000c726 	beq	r2,zero,202ac74 <alt_tse_phy_set_common_speed+0x408>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 202a958:	e0bff617 	ldw	r2,-40(fp)
 202a95c:	10800217 	ldw	r2,8(r2)
 202a960:	e0bff715 	stw	r2,-36(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 202a964:	e0bff517 	ldw	r2,-44(fp)
 202a968:	10800003 	ldbu	r2,0(r2)
 202a96c:	10803fcc 	andi	r2,r2,255
 202a970:	100b883a 	mov	r5,r2
 202a974:	e13ff517 	ldw	r4,-44(fp)
 202a978:	202808c0 	call	202808c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 202a97c:	e0bff517 	ldw	r2,-44(fp)
 202a980:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 202a984:	10803fcc 	andi	r2,r2,255
 202a988:	10000c1e 	bne	r2,zero,202a9bc <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 202a98c:	e0bff517 	ldw	r2,-44(fp)
 202a990:	10800103 	ldbu	r2,4(r2)
 202a994:	10803fcc 	andi	r2,r2,255
 202a998:	1000081e 	bne	r2,zero,202a9bc <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 202a99c:	e0bff517 	ldw	r2,-44(fp)
 202a9a0:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 202a9a4:	10803fcc 	andi	r2,r2,255
 202a9a8:	1000041e 	bne	r2,zero,202a9bc <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 202a9ac:	e0bff517 	ldw	r2,-44(fp)
 202a9b0:	10800083 	ldbu	r2,2(r2)
 202a9b4:	10803fcc 	andi	r2,r2,255
 202a9b8:	10000226 	beq	r2,zero,202a9c4 <alt_tse_phy_set_common_speed+0x158>
 202a9bc:	00800044 	movi	r2,1
 202a9c0:	00000106 	br	202a9c8 <alt_tse_phy_set_common_speed+0x15c>
 202a9c4:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 202a9c8:	e0bffb05 	stb	r2,-20(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 202a9cc:	e0bffb03 	ldbu	r2,-20(fp)
 202a9d0:	1000101e 	bne	r2,zero,202aa14 <alt_tse_phy_set_common_speed+0x1a8>
 202a9d4:	e0bffd17 	ldw	r2,-12(fp)
 202a9d8:	10800098 	cmpnei	r2,r2,2
 202a9dc:	10000d1e 	bne	r2,zero,202aa14 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 202a9e0:	e0bff847 	ldb	r2,-31(fp)
 202a9e4:	e0fff807 	ldb	r3,-32(fp)
 202a9e8:	180d883a 	mov	r6,r3
 202a9ec:	100b883a 	mov	r5,r2
 202a9f0:	01008134 	movhi	r4,516
 202a9f4:	210cb204 	addi	r4,r4,13000
 202a9f8:	2000bb00 	call	2000bb0 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 202a9fc:	e0bff917 	ldw	r2,-28(fp)
 202aa00:	10801004 	addi	r2,r2,64
 202aa04:	e0fffa17 	ldw	r3,-24(fp)
 202aa08:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 202aa0c:	00bfffc4 	movi	r2,-1
 202aa10:	0000bc06 	br	202ad04 <alt_tse_phy_set_common_speed+0x498>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 202aa14:	01c00044 	movi	r7,1
 202aa18:	018000c4 	movi	r6,3
 202aa1c:	01400044 	movi	r5,1
 202aa20:	e13ff517 	ldw	r4,-44(fp)
 202aa24:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202aa28:	1000141e 	bne	r2,zero,202aa7c <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 202aa2c:	e0bffb03 	ldbu	r2,-20(fp)
 202aa30:	10000926 	beq	r2,zero,202aa58 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 202aa34:	e0bffd17 	ldw	r2,-12(fp)
 202aa38:	1005d07a 	srai	r2,r2,1
 202aa3c:	10bfffcc 	andi	r2,r2,65535
 202aa40:	d8800015 	stw	r2,0(sp)
 202aa44:	01c00044 	movi	r7,1
 202aa48:	01800184 	movi	r6,6
 202aa4c:	000b883a 	mov	r5,zero
 202aa50:	e13ff517 	ldw	r4,-44(fp)
 202aa54:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 202aa58:	e0bffd17 	ldw	r2,-12(fp)
 202aa5c:	10bfffcc 	andi	r2,r2,65535
 202aa60:	d8800015 	stw	r2,0(sp)
 202aa64:	01c00044 	movi	r7,1
 202aa68:	01800344 	movi	r6,13
 202aa6c:	000b883a 	mov	r5,zero
 202aa70:	e13ff517 	ldw	r4,-44(fp)
 202aa74:	20280e40 	call	20280e4 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 202aa78:	00007f06 	br	202ac78 <alt_tse_phy_set_common_speed+0x40c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 202aa7c:	e0bffd17 	ldw	r2,-12(fp)
 202aa80:	10800098 	cmpnei	r2,r2,2
 202aa84:	10000a1e 	bne	r2,zero,202aab0 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 202aa88:	01400044 	movi	r5,1
 202aa8c:	e13ff517 	ldw	r4,-44(fp)
 202aa90:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 202aa94:	01400044 	movi	r5,1
 202aa98:	e13ff517 	ldw	r4,-44(fp)
 202aa9c:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 202aaa0:	01400044 	movi	r5,1
 202aaa4:	e13ff517 	ldw	r4,-44(fp)
 202aaa8:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
 202aaac:	00002206 	br	202ab38 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 202aab0:	e0bffd17 	ldw	r2,-12(fp)
 202aab4:	10800058 	cmpnei	r2,r2,1
 202aab8:	10000a1e 	bne	r2,zero,202aae4 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 202aabc:	000b883a 	mov	r5,zero
 202aac0:	e13ff517 	ldw	r4,-44(fp)
 202aac4:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 202aac8:	01400044 	movi	r5,1
 202aacc:	e13ff517 	ldw	r4,-44(fp)
 202aad0:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 202aad4:	01400044 	movi	r5,1
 202aad8:	e13ff517 	ldw	r4,-44(fp)
 202aadc:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
 202aae0:	00001506 	br	202ab38 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 202aae4:	e0bffd17 	ldw	r2,-12(fp)
 202aae8:	10000a1e 	bne	r2,zero,202ab14 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 202aaec:	000b883a 	mov	r5,zero
 202aaf0:	e13ff517 	ldw	r4,-44(fp)
 202aaf4:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 202aaf8:	000b883a 	mov	r5,zero
 202aafc:	e13ff517 	ldw	r4,-44(fp)
 202ab00:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 202ab04:	01400044 	movi	r5,1
 202ab08:	e13ff517 	ldw	r4,-44(fp)
 202ab0c:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
 202ab10:	00000906 	br	202ab38 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 202ab14:	000b883a 	mov	r5,zero
 202ab18:	e13ff517 	ldw	r4,-44(fp)
 202ab1c:	2029f840 	call	2029f84 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 202ab20:	000b883a 	mov	r5,zero
 202ab24:	e13ff517 	ldw	r4,-44(fp)
 202ab28:	202a1480 	call	202a148 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 202ab2c:	000b883a 	mov	r5,zero
 202ab30:	e13ff517 	ldw	r4,-44(fp)
 202ab34:	202a39c0 	call	202a39c <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 202ab38:	01c00044 	movi	r7,1
 202ab3c:	01800144 	movi	r6,5
 202ab40:	01400044 	movi	r5,1
 202ab44:	e13ff517 	ldw	r4,-44(fp)
 202ab48:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202ab4c:	10800058 	cmpnei	r2,r2,1
 202ab50:	10003a1e 	bne	r2,zero,202ac3c <alt_tse_phy_set_common_speed+0x3d0>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 202ab54:	e0bffb03 	ldbu	r2,-20(fp)
 202ab58:	10000f26 	beq	r2,zero,202ab98 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 202ab5c:	e0bff517 	ldw	r2,-44(fp)
 202ab60:	10800517 	ldw	r2,20(r2)
 202ab64:	10801583 	ldbu	r2,86(r2)
 202ab68:	10c03fcc 	andi	r3,r2,255
 202ab6c:	e0bff517 	ldw	r2,-44(fp)
 202ab70:	10800517 	ldw	r2,20(r2)
 202ab74:	108015c3 	ldbu	r2,87(r2)
 202ab78:	10803fcc 	andi	r2,r2,255
 202ab7c:	01c00084 	movi	r7,2
 202ab80:	100d883a 	mov	r6,r2
 202ab84:	180b883a 	mov	r5,r3
 202ab88:	e13ff517 	ldw	r4,-44(fp)
 202ab8c:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202ab90:	e0bff405 	stb	r2,-48(fp)
 202ab94:	00000e06 	br	202abd0 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 202ab98:	e0bff517 	ldw	r2,-44(fp)
 202ab9c:	10800517 	ldw	r2,20(r2)
 202aba0:	10801583 	ldbu	r2,86(r2)
 202aba4:	10c03fcc 	andi	r3,r2,255
 202aba8:	e0bff517 	ldw	r2,-44(fp)
 202abac:	10800517 	ldw	r2,20(r2)
 202abb0:	108015c3 	ldbu	r2,87(r2)
 202abb4:	10803fcc 	andi	r2,r2,255
 202abb8:	01c00044 	movi	r7,1
 202abbc:	100d883a 	mov	r6,r2
 202abc0:	180b883a 	mov	r5,r3
 202abc4:	e13ff517 	ldw	r4,-44(fp)
 202abc8:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202abcc:	e0bff405 	stb	r2,-48(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 202abd0:	e0fff403 	ldbu	r3,-48(fp)
 202abd4:	e0bffd17 	ldw	r2,-12(fp)
 202abd8:	18800326 	beq	r3,r2,202abe8 <alt_tse_phy_set_common_speed+0x37c>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 202abdc:	017e0034 	movhi	r5,63488
 202abe0:	e13ff517 	ldw	r4,-44(fp)
 202abe4:	20296d40 	call	20296d4 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 202abe8:	e0bff517 	ldw	r2,-44(fp)
 202abec:	10800517 	ldw	r2,20(r2)
 202abf0:	10801583 	ldbu	r2,86(r2)
 202abf4:	10c03fcc 	andi	r3,r2,255
 202abf8:	e0bff517 	ldw	r2,-44(fp)
 202abfc:	10800517 	ldw	r2,20(r2)
 202ac00:	10801603 	ldbu	r2,88(r2)
 202ac04:	10803fcc 	andi	r2,r2,255
 202ac08:	01c00044 	movi	r7,1
 202ac0c:	100d883a 	mov	r6,r2
 202ac10:	180b883a 	mov	r5,r3
 202ac14:	e13ff517 	ldw	r4,-44(fp)
 202ac18:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202ac1c:	e0bffb45 	stb	r2,-19(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 202ac20:	e0bff717 	ldw	r2,-36(fp)
 202ac24:	10800017 	ldw	r2,0(r2)
 202ac28:	1007883a 	mov	r3,r2
 202ac2c:	e0bffb43 	ldbu	r2,-19(fp)
 202ac30:	100b883a 	mov	r5,r2
 202ac34:	1809883a 	mov	r4,r3
 202ac38:	202753c0 	call	202753c <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 202ac3c:	e43ff847 	ldb	r16,-31(fp)
 202ac40:	e47ff807 	ldb	r17,-32(fp)
 202ac44:	01c00404 	movi	r7,16
 202ac48:	000d883a 	mov	r6,zero
 202ac4c:	01400044 	movi	r5,1
 202ac50:	e13ff517 	ldw	r4,-44(fp)
 202ac54:	202820c0 	call	202820c <alt_tse_phy_rd_mdio_reg>
 202ac58:	100f883a 	mov	r7,r2
 202ac5c:	880d883a 	mov	r6,r17
 202ac60:	800b883a 	mov	r5,r16
 202ac64:	01008134 	movhi	r4,516
 202ac68:	210cc904 	addi	r4,r4,13092
 202ac6c:	2000bb00 	call	2000bb0 <printf>
 202ac70:	00000106 	br	202ac78 <alt_tse_phy_set_common_speed+0x40c>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 202ac74:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 202ac78:	e0bff317 	ldw	r2,-52(fp)
 202ac7c:	10800044 	addi	r2,r2,1
 202ac80:	e0bff315 	stw	r2,-52(fp)
 202ac84:	e0bffc17 	ldw	r2,-16(fp)
 202ac88:	10800003 	ldbu	r2,0(r2)
 202ac8c:	10803fcc 	andi	r2,r2,255
 202ac90:	e0fff317 	ldw	r3,-52(fp)
 202ac94:	18bf2016 	blt	r3,r2,202a918 <__alt_mem_mem_0+0xfd00a918>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 202ac98:	e0fff847 	ldb	r3,-31(fp)
 202ac9c:	e0bffd17 	ldw	r2,-12(fp)
 202aca0:	108000a0 	cmpeqi	r2,r2,2
 202aca4:	1000071e 	bne	r2,zero,202acc4 <alt_tse_phy_set_common_speed+0x458>
 202aca8:	e0bffd17 	ldw	r2,-12(fp)
 202acac:	10800058 	cmpnei	r2,r2,1
 202acb0:	1000021e 	bne	r2,zero,202acbc <alt_tse_phy_set_common_speed+0x450>
 202acb4:	00801904 	movi	r2,100
 202acb8:	00000306 	br	202acc8 <alt_tse_phy_set_common_speed+0x45c>
 202acbc:	00800284 	movi	r2,10
 202acc0:	00000106 	br	202acc8 <alt_tse_phy_set_common_speed+0x45c>
 202acc4:	0080fa04 	movi	r2,1000
 202acc8:	100d883a 	mov	r6,r2
 202accc:	180b883a 	mov	r5,r3
 202acd0:	01008134 	movhi	r4,516
 202acd4:	210cd504 	addi	r4,r4,13140
 202acd8:	2000bb00 	call	2000bb0 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 202acdc:	e0bffd17 	ldw	r2,-12(fp)
 202ace0:	10803fcc 	andi	r2,r2,255
 202ace4:	100b883a 	mov	r5,r2
 202ace8:	e13ff917 	ldw	r4,-28(fp)
 202acec:	202745c0 	call	202745c <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 202acf0:	e0bff917 	ldw	r2,-28(fp)
 202acf4:	10801004 	addi	r2,r2,64
 202acf8:	e0fffa17 	ldw	r3,-24(fp)
 202acfc:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 202ad00:	e0bffd17 	ldw	r2,-12(fp)
}
 202ad04:	e6fffe04 	addi	sp,fp,-8
 202ad08:	dfc00317 	ldw	ra,12(sp)
 202ad0c:	df000217 	ldw	fp,8(sp)
 202ad10:	dc400117 	ldw	r17,4(sp)
 202ad14:	dc000017 	ldw	r16,0(sp)
 202ad18:	dec00404 	addi	sp,sp,16
 202ad1c:	f800283a 	ret

0202ad20 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 202ad20:	defffc04 	addi	sp,sp,-16
 202ad24:	dfc00315 	stw	ra,12(sp)
 202ad28:	df000215 	stw	fp,8(sp)
 202ad2c:	df000204 	addi	fp,sp,8
 202ad30:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & 1<<5) == 0) {
 202ad34:	e0bfff17 	ldw	r2,-4(fp)
 202ad38:	1080a104 	addi	r2,r2,644
 202ad3c:	10800037 	ldwio	r2,0(r2)
 202ad40:	1080080c 	andi	r2,r2,32
 202ad44:	1000161e 	bne	r2,zero,202ada0 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 202ad48:	01008134 	movhi	r4,516
 202ad4c:	210ce604 	addi	r4,r4,13208
 202ad50:	203ceb40 	call	203ceb4 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 202ad54:	e0bfff17 	ldw	r2,-4(fp)
 202ad58:	1080a004 	addi	r2,r2,640
 202ad5c:	10801004 	addi	r2,r2,64
 202ad60:	00c01e04 	movi	r3,120
 202ad64:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 202ad68:	01008134 	movhi	r4,516
 202ad6c:	210cef04 	addi	r4,r4,13244
 202ad70:	203ceb40 	call	203ceb4 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 202ad74:	e0bfff17 	ldw	r2,-4(fp)
 202ad78:	1080a004 	addi	r2,r2,640
 202ad7c:	10800037 	ldwio	r2,0(r2)
 202ad80:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);        
 202ad84:	e0bfff17 	ldw	r2,-4(fp)
 202ad88:	1080a004 	addi	r2,r2,640
 202ad8c:	e13ffe0b 	ldhu	r4,-8(fp)
 202ad90:	00e00004 	movi	r3,-32768
 202ad94:	20c6b03a 	or	r3,r4,r3
 202ad98:	18ffffcc 	andi	r3,r3,65535
 202ad9c:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 202ada0:	0005883a 	mov	r2,zero
}
 202ada4:	e037883a 	mov	sp,fp
 202ada8:	dfc00117 	ldw	ra,4(sp)
 202adac:	df000017 	ldw	fp,0(sp)
 202adb0:	dec00204 	addi	sp,sp,8
 202adb4:	f800283a 	ret

0202adb8 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 202adb8:	defffc04 	addi	sp,sp,-16
 202adbc:	dfc00315 	stw	ra,12(sp)
 202adc0:	df000215 	stw	fp,8(sp)
 202adc4:	df000204 	addi	fp,sp,8
 202adc8:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 202adcc:	e0bfff17 	ldw	r2,-4(fp)
 202add0:	1080bb04 	addi	r2,r2,748
 202add4:	10800037 	ldwio	r2,0(r2)
 202add8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 202addc:	e0fffe0b 	ldhu	r3,-8(fp)
 202ade0:	00bffc04 	movi	r2,-16
 202ade4:	1884703a 	and	r2,r3,r2
 202ade8:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 202adec:	01008134 	movhi	r4,516
 202adf0:	210cf404 	addi	r4,r4,13264
 202adf4:	203ceb40 	call	203ceb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 202adf8:	e0bfff17 	ldw	r2,-4(fp)
 202adfc:	1080bb04 	addi	r2,r2,748
 202ae00:	e0fffe0b 	ldhu	r3,-8(fp)
 202ae04:	18c003d4 	ori	r3,r3,15
 202ae08:	18ffffcc 	andi	r3,r3,65535
 202ae0c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 202ae10:	01008134 	movhi	r4,516
 202ae14:	210d0004 	addi	r4,r4,13312
 202ae18:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 202ae1c:	e0bfff17 	ldw	r2,-4(fp)
 202ae20:	1080b404 	addi	r2,r2,720
 202ae24:	10800037 	ldwio	r2,0(r2)
 202ae28:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 202ae2c:	e0fffe0b 	ldhu	r3,-8(fp)
 202ae30:	00bfdf44 	movi	r2,-131
 202ae34:	1884703a 	and	r2,r3,r2
 202ae38:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 202ae3c:	e0bfff17 	ldw	r2,-4(fp)
 202ae40:	1080b404 	addi	r2,r2,720
 202ae44:	e0fffe0b 	ldhu	r3,-8(fp)
 202ae48:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 202ae4c:	01008134 	movhi	r4,516
 202ae50:	210cef04 	addi	r4,r4,13244
 202ae54:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 202ae58:	e0bfff17 	ldw	r2,-4(fp)
 202ae5c:	1080a004 	addi	r2,r2,640
 202ae60:	10800037 	ldwio	r2,0(r2)
 202ae64:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 202ae68:	e0bfff17 	ldw	r2,-4(fp)
 202ae6c:	1080a004 	addi	r2,r2,640
 202ae70:	e13ffe0b 	ldhu	r4,-8(fp)
 202ae74:	00e00004 	movi	r3,-32768
 202ae78:	20c6b03a 	or	r3,r4,r3
 202ae7c:	18ffffcc 	andi	r3,r3,65535
 202ae80:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 202ae84:	00800044 	movi	r2,1
}
 202ae88:	e037883a 	mov	sp,fp
 202ae8c:	dfc00117 	ldw	ra,4(sp)
 202ae90:	df000017 	ldw	fp,0(sp)
 202ae94:	dec00204 	addi	sp,sp,8
 202ae98:	f800283a 	ret

0202ae9c <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 202ae9c:	defffc04 	addi	sp,sp,-16
 202aea0:	dfc00315 	stw	ra,12(sp)
 202aea4:	df000215 	stw	fp,8(sp)
 202aea8:	df000204 	addi	fp,sp,8
 202aeac:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 202aeb0:	e0bfff17 	ldw	r2,-4(fp)
 202aeb4:	1080bb04 	addi	r2,r2,748
 202aeb8:	10800037 	ldwio	r2,0(r2)
 202aebc:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 202aec0:	e0fffe0b 	ldhu	r3,-8(fp)
 202aec4:	00bffc04 	movi	r2,-16
 202aec8:	1884703a 	and	r2,r3,r2
 202aecc:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 202aed0:	01008134 	movhi	r4,516
 202aed4:	210d0a04 	addi	r4,r4,13352
 202aed8:	203ceb40 	call	203ceb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 202aedc:	e0bfff17 	ldw	r2,-4(fp)
 202aee0:	1080bb04 	addi	r2,r2,748
 202aee4:	e0fffe0b 	ldhu	r3,-8(fp)
 202aee8:	18c00114 	ori	r3,r3,4
 202aeec:	18ffffcc 	andi	r3,r3,65535
 202aef0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 202aef4:	01008134 	movhi	r4,516
 202aef8:	210d0004 	addi	r4,r4,13312
 202aefc:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 202af00:	e0bfff17 	ldw	r2,-4(fp)
 202af04:	1080b404 	addi	r2,r2,720
 202af08:	10800037 	ldwio	r2,0(r2)
 202af0c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 202af10:	e0fffe0b 	ldhu	r3,-8(fp)
 202af14:	00bfdf44 	movi	r2,-131
 202af18:	1884703a 	and	r2,r3,r2
 202af1c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 202af20:	e0bfff17 	ldw	r2,-4(fp)
 202af24:	1080b404 	addi	r2,r2,720
 202af28:	e0fffe0b 	ldhu	r3,-8(fp)
 202af2c:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 202af30:	01008134 	movhi	r4,516
 202af34:	210cef04 	addi	r4,r4,13244
 202af38:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 202af3c:	e0bfff17 	ldw	r2,-4(fp)
 202af40:	1080a004 	addi	r2,r2,640
 202af44:	10800037 	ldwio	r2,0(r2)
 202af48:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 202af4c:	e0bfff17 	ldw	r2,-4(fp)
 202af50:	1080a004 	addi	r2,r2,640
 202af54:	e13ffe0b 	ldhu	r4,-8(fp)
 202af58:	00e00004 	movi	r3,-32768
 202af5c:	20c6b03a 	or	r3,r4,r3
 202af60:	18ffffcc 	andi	r3,r3,65535
 202af64:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 202af68:	00800044 	movi	r2,1
}
 202af6c:	e037883a 	mov	sp,fp
 202af70:	dfc00117 	ldw	ra,4(sp)
 202af74:	df000017 	ldw	fp,0(sp)
 202af78:	dec00204 	addi	sp,sp,8
 202af7c:	f800283a 	ret

0202af80 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 202af80:	defffc04 	addi	sp,sp,-16
 202af84:	dfc00315 	stw	ra,12(sp)
 202af88:	df000215 	stw	fp,8(sp)
 202af8c:	df000204 	addi	fp,sp,8
 202af90:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 202af94:	e0bfff17 	ldw	r2,-4(fp)
 202af98:	1080bb04 	addi	r2,r2,748
 202af9c:	10800037 	ldwio	r2,0(r2)
 202afa0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 202afa4:	e0fffe0b 	ldhu	r3,-8(fp)
 202afa8:	00bffc04 	movi	r2,-16
 202afac:	1884703a 	and	r2,r3,r2
 202afb0:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 202afb4:	01008134 	movhi	r4,516
 202afb8:	210d1f04 	addi	r4,r4,13436
 202afbc:	203ceb40 	call	203ceb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 202afc0:	e0bfff17 	ldw	r2,-4(fp)
 202afc4:	1080bb04 	addi	r2,r2,748
 202afc8:	e0fffe0b 	ldhu	r3,-8(fp)
 202afcc:	18c002d4 	ori	r3,r3,11
 202afd0:	18ffffcc 	andi	r3,r3,65535
 202afd4:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 202afd8:	01008134 	movhi	r4,516
 202afdc:	210d2e04 	addi	r4,r4,13496
 202afe0:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 202afe4:	e0bfff17 	ldw	r2,-4(fp)
 202afe8:	1080b404 	addi	r2,r2,720
 202afec:	10800037 	ldwio	r2,0(r2)
 202aff0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 202aff4:	e0fffe0b 	ldhu	r3,-8(fp)
 202aff8:	00bfdf44 	movi	r2,-131
 202affc:	1884703a 	and	r2,r3,r2
 202b000:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 202b004:	e0bffe0b 	ldhu	r2,-8(fp)
 202b008:	10802094 	ori	r2,r2,130
 202b00c:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 202b010:	e0bfff17 	ldw	r2,-4(fp)
 202b014:	1080b404 	addi	r2,r2,720
 202b018:	e0fffe0b 	ldhu	r3,-8(fp)
 202b01c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 202b020:	01008134 	movhi	r4,516
 202b024:	210cef04 	addi	r4,r4,13244
 202b028:	203ceb40 	call	203ceb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 202b02c:	e0bfff17 	ldw	r2,-4(fp)
 202b030:	1080a004 	addi	r2,r2,640
 202b034:	10800037 	ldwio	r2,0(r2)
 202b038:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | 1<<15);
 202b03c:	e0bfff17 	ldw	r2,-4(fp)
 202b040:	1080a004 	addi	r2,r2,640
 202b044:	e13ffe0b 	ldhu	r4,-8(fp)
 202b048:	00e00004 	movi	r3,-32768
 202b04c:	20c6b03a 	or	r3,r4,r3
 202b050:	18ffffcc 	andi	r3,r3,65535
 202b054:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 202b058:	00800044 	movi	r2,1
    
}
 202b05c:	e037883a 	mov	sp,fp
 202b060:	dfc00117 	ldw	ra,4(sp)
 202b064:	df000017 	ldw	fp,0(sp)
 202b068:	dec00204 	addi	sp,sp,8
 202b06c:	f800283a 	ret

0202b070 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 202b070:	defffc04 	addi	sp,sp,-16
 202b074:	df000315 	stw	fp,12(sp)
 202b078:	df000304 	addi	fp,sp,12
 202b07c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 202b080:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 202b084:	e0bfff17 	ldw	r2,-4(fp)
 202b088:	1080b004 	addi	r2,r2,704
 202b08c:	10800037 	ldwio	r2,0(r2)
 202b090:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 202b094:	e0bffe17 	ldw	r2,-8(fp)
 202b098:	1080008c 	andi	r2,r2,2
 202b09c:	10000426 	beq	r2,zero,202b0b0 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 202b0a0:	e0bffd17 	ldw	r2,-12(fp)
 202b0a4:	10800214 	ori	r2,r2,8
 202b0a8:	e0bffd15 	stw	r2,-12(fp)
 202b0ac:	00000306 	br	202b0bc <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 202b0b0:	e0bffd17 	ldw	r2,-12(fp)
 202b0b4:	10800114 	ori	r2,r2,4
 202b0b8:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 202b0bc:	e0bffe17 	ldw	r2,-8(fp)
 202b0c0:	1080010c 	andi	r2,r2,4
 202b0c4:	10000326 	beq	r2,zero,202b0d4 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 202b0c8:	e0bffd17 	ldw	r2,-12(fp)
 202b0cc:	10800054 	ori	r2,r2,1
 202b0d0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 202b0d4:	e0bffd17 	ldw	r2,-12(fp)
}
 202b0d8:	e037883a 	mov	sp,fp
 202b0dc:	df000017 	ldw	fp,0(sp)
 202b0e0:	dec00104 	addi	sp,sp,4
 202b0e4:	f800283a 	ret

0202b0e8 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 202b0e8:	defffa04 	addi	sp,sp,-24
 202b0ec:	dfc00515 	stw	ra,20(sp)
 202b0f0:	df000415 	stw	fp,16(sp)
 202b0f4:	df000404 	addi	fp,sp,16
 202b0f8:	e13ffd15 	stw	r4,-12(fp)
 202b0fc:	e17ffe15 	stw	r5,-8(fp)
 202b100:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202b104:	e0bffd17 	ldw	r2,-12(fp)
 202b108:	10800017 	ldw	r2,0(r2)
 202b10c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 202b110:	e0bffc17 	ldw	r2,-16(fp)
 202b114:	10c00a04 	addi	r3,r2,40
 202b118:	e0bffd17 	ldw	r2,-12(fp)
 202b11c:	10800217 	ldw	r2,8(r2)
 202b120:	100f883a 	mov	r7,r2
 202b124:	e1bfff17 	ldw	r6,-4(fp)
 202b128:	e17ffe17 	ldw	r5,-8(fp)
 202b12c:	1809883a 	mov	r4,r3
 202b130:	202b6ac0 	call	202b6ac <altera_avalon_uart_read>
      fd->fd_flags);
}
 202b134:	e037883a 	mov	sp,fp
 202b138:	dfc00117 	ldw	ra,4(sp)
 202b13c:	df000017 	ldw	fp,0(sp)
 202b140:	dec00204 	addi	sp,sp,8
 202b144:	f800283a 	ret

0202b148 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 202b148:	defffa04 	addi	sp,sp,-24
 202b14c:	dfc00515 	stw	ra,20(sp)
 202b150:	df000415 	stw	fp,16(sp)
 202b154:	df000404 	addi	fp,sp,16
 202b158:	e13ffd15 	stw	r4,-12(fp)
 202b15c:	e17ffe15 	stw	r5,-8(fp)
 202b160:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202b164:	e0bffd17 	ldw	r2,-12(fp)
 202b168:	10800017 	ldw	r2,0(r2)
 202b16c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 202b170:	e0bffc17 	ldw	r2,-16(fp)
 202b174:	10c00a04 	addi	r3,r2,40
 202b178:	e0bffd17 	ldw	r2,-12(fp)
 202b17c:	10800217 	ldw	r2,8(r2)
 202b180:	100f883a 	mov	r7,r2
 202b184:	e1bfff17 	ldw	r6,-4(fp)
 202b188:	e17ffe17 	ldw	r5,-8(fp)
 202b18c:	1809883a 	mov	r4,r3
 202b190:	202b9000 	call	202b900 <altera_avalon_uart_write>
      fd->fd_flags);
}
 202b194:	e037883a 	mov	sp,fp
 202b198:	dfc00117 	ldw	ra,4(sp)
 202b19c:	df000017 	ldw	fp,0(sp)
 202b1a0:	dec00204 	addi	sp,sp,8
 202b1a4:	f800283a 	ret

0202b1a8 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 202b1a8:	defffc04 	addi	sp,sp,-16
 202b1ac:	dfc00315 	stw	ra,12(sp)
 202b1b0:	df000215 	stw	fp,8(sp)
 202b1b4:	df000204 	addi	fp,sp,8
 202b1b8:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 202b1bc:	e0bfff17 	ldw	r2,-4(fp)
 202b1c0:	10800017 	ldw	r2,0(r2)
 202b1c4:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 202b1c8:	e0bffe17 	ldw	r2,-8(fp)
 202b1cc:	10c00a04 	addi	r3,r2,40
 202b1d0:	e0bfff17 	ldw	r2,-4(fp)
 202b1d4:	10800217 	ldw	r2,8(r2)
 202b1d8:	100b883a 	mov	r5,r2
 202b1dc:	1809883a 	mov	r4,r3
 202b1e0:	202b61c0 	call	202b61c <altera_avalon_uart_close>
}
 202b1e4:	e037883a 	mov	sp,fp
 202b1e8:	dfc00117 	ldw	ra,4(sp)
 202b1ec:	df000017 	ldw	fp,0(sp)
 202b1f0:	dec00204 	addi	sp,sp,8
 202b1f4:	f800283a 	ret

0202b1f8 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 202b1f8:	defff504 	addi	sp,sp,-44
 202b1fc:	dfc00a15 	stw	ra,40(sp)
 202b200:	df000915 	stw	fp,36(sp)
 202b204:	df000904 	addi	fp,sp,36
 202b208:	e13ffd15 	stw	r4,-12(fp)
 202b20c:	e17ffe15 	stw	r5,-8(fp)
 202b210:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 202b214:	e0bffd17 	ldw	r2,-12(fp)
 202b218:	10800017 	ldw	r2,0(r2)
 202b21c:	e0bff815 	stw	r2,-32(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 202b220:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 202b224:	1000301e 	bne	r2,zero,202b2e8 <altera_avalon_uart_init+0xf0>
 202b228:	e0bffd17 	ldw	r2,-12(fp)
 202b22c:	10800704 	addi	r2,r2,28
 202b230:	e0bff915 	stw	r2,-28(fp)
 202b234:	00800044 	movi	r2,1
 202b238:	e0bffc0d 	sth	r2,-16(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 202b23c:	e0bffc0b 	ldhu	r2,-16(fp)
 202b240:	10000226 	beq	r2,zero,202b24c <altera_avalon_uart_init+0x54>
 202b244:	e0bffc0b 	ldhu	r2,-16(fp)
 202b248:	00000106 	br	202b250 <altera_avalon_uart_init+0x58>
 202b24c:	00800044 	movi	r2,1
 202b250:	e0fffc0b 	ldhu	r3,-16(fp)
 202b254:	180b883a 	mov	r5,r3
 202b258:	1009883a 	mov	r4,r2
 202b25c:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 202b260:	1007883a 	mov	r3,r2
 202b264:	e0bff917 	ldw	r2,-28(fp)
 202b268:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 202b26c:	e0bff917 	ldw	r2,-28(fp)
 202b270:	10800017 	ldw	r2,0(r2)
 202b274:	10000226 	beq	r2,zero,202b280 <altera_avalon_uart_init+0x88>
 202b278:	0005883a 	mov	r2,zero
 202b27c:	00000106 	br	202b284 <altera_avalon_uart_init+0x8c>
 202b280:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 202b284:	1000181e 	bne	r2,zero,202b2e8 <altera_avalon_uart_init+0xf0>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
 202b288:	e0bffd17 	ldw	r2,-12(fp)
 202b28c:	10800804 	addi	r2,r2,32
 202b290:	e0bffa15 	stw	r2,-24(fp)
 202b294:	00800044 	movi	r2,1
 202b298:	e0bffc8d 	sth	r2,-14(fp)
 * alt_sem_create() is a wrapper for xSemaphoreCreateCounting(). The return value is 0 if 
 * the semaphore has been successfully created, or non-zero otherwise.
 */
static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (xSemaphoreHandle* sem, alt_u16 value)
{
	*sem = xSemaphoreCreateCounting(value ? value : 1, value);
 202b29c:	e0bffc8b 	ldhu	r2,-14(fp)
 202b2a0:	10000226 	beq	r2,zero,202b2ac <altera_avalon_uart_init+0xb4>
 202b2a4:	e0bffc8b 	ldhu	r2,-14(fp)
 202b2a8:	00000106 	br	202b2b0 <altera_avalon_uart_init+0xb8>
 202b2ac:	00800044 	movi	r2,1
 202b2b0:	e0fffc8b 	ldhu	r3,-14(fp)
 202b2b4:	180b883a 	mov	r5,r3
 202b2b8:	1009883a 	mov	r4,r2
 202b2bc:	200d9bc0 	call	200d9bc <xQueueCreateCountingSemaphore>
 202b2c0:	1007883a 	mov	r3,r2
 202b2c4:	e0bffa17 	ldw	r2,-24(fp)
 202b2c8:	10c00015 	stw	r3,0(r2)
	return *sem ? 0 : -1;
 202b2cc:	e0bffa17 	ldw	r2,-24(fp)
 202b2d0:	10800017 	ldw	r2,0(r2)
 202b2d4:	10000226 	beq	r2,zero,202b2e0 <altera_avalon_uart_init+0xe8>
 202b2d8:	0005883a 	mov	r2,zero
 202b2dc:	00000106 	br	202b2e4 <altera_avalon_uart_init+0xec>
 202b2e0:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 202b2e4:	10000226 	beq	r2,zero,202b2f0 <altera_avalon_uart_init+0xf8>
 202b2e8:	00800044 	movi	r2,1
 202b2ec:	00000106 	br	202b2f4 <altera_avalon_uart_init+0xfc>
 202b2f0:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 202b2f4:	e0bffb15 	stw	r2,-20(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 202b2f8:	e0bffb17 	ldw	r2,-20(fp)
 202b2fc:	10000f1e 	bne	r2,zero,202b33c <altera_avalon_uart_init+0x144>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 202b300:	e0bffd17 	ldw	r2,-12(fp)
 202b304:	00c32004 	movi	r3,3200
 202b308:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 202b30c:	e0bff817 	ldw	r2,-32(fp)
 202b310:	10800304 	addi	r2,r2,12
 202b314:	e0fffd17 	ldw	r3,-12(fp)
 202b318:	18c00117 	ldw	r3,4(r3)
 202b31c:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 202b320:	d8000015 	stw	zero,0(sp)
 202b324:	e1fffd17 	ldw	r7,-12(fp)
 202b328:	018080f4 	movhi	r6,515
 202b32c:	31acd504 	addi	r6,r6,-19628
 202b330:	e17fff17 	ldw	r5,-4(fp)
 202b334:	e13ffe17 	ldw	r4,-8(fp)
 202b338:	202cba40 	call	202cba4 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 202b33c:	0001883a 	nop
 202b340:	e037883a 	mov	sp,fp
 202b344:	dfc00117 	ldw	ra,4(sp)
 202b348:	df000017 	ldw	fp,0(sp)
 202b34c:	dec00204 	addi	sp,sp,8
 202b350:	f800283a 	ret

0202b354 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 202b354:	defffa04 	addi	sp,sp,-24
 202b358:	dfc00515 	stw	ra,20(sp)
 202b35c:	df000415 	stw	fp,16(sp)
 202b360:	df000404 	addi	fp,sp,16
 202b364:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 202b368:	e0bfff17 	ldw	r2,-4(fp)
 202b36c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 202b370:	e0bffc17 	ldw	r2,-16(fp)
 202b374:	10800017 	ldw	r2,0(r2)
 202b378:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 202b37c:	e0bffd17 	ldw	r2,-12(fp)
 202b380:	10800204 	addi	r2,r2,8
 202b384:	10800037 	ldwio	r2,0(r2)
 202b388:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 202b38c:	e0bffd17 	ldw	r2,-12(fp)
 202b390:	10800204 	addi	r2,r2,8
 202b394:	0007883a 	mov	r3,zero
 202b398:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 202b39c:	e0bffd17 	ldw	r2,-12(fp)
 202b3a0:	10800204 	addi	r2,r2,8
 202b3a4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 202b3a8:	e0bffe17 	ldw	r2,-8(fp)
 202b3ac:	1080200c 	andi	r2,r2,128
 202b3b0:	10000326 	beq	r2,zero,202b3c0 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 202b3b4:	e17ffe17 	ldw	r5,-8(fp)
 202b3b8:	e13ffc17 	ldw	r4,-16(fp)
 202b3bc:	202b3f00 	call	202b3f0 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 202b3c0:	e0bffe17 	ldw	r2,-8(fp)
 202b3c4:	1081100c 	andi	r2,r2,1088
 202b3c8:	10000326 	beq	r2,zero,202b3d8 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 202b3cc:	e17ffe17 	ldw	r5,-8(fp)
 202b3d0:	e13ffc17 	ldw	r4,-16(fp)
 202b3d4:	202b4d40 	call	202b4d4 <altera_avalon_uart_txirq>
  }
  

}
 202b3d8:	0001883a 	nop
 202b3dc:	e037883a 	mov	sp,fp
 202b3e0:	dfc00117 	ldw	ra,4(sp)
 202b3e4:	df000017 	ldw	fp,0(sp)
 202b3e8:	dec00204 	addi	sp,sp,8
 202b3ec:	f800283a 	ret

0202b3f0 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 202b3f0:	defffc04 	addi	sp,sp,-16
 202b3f4:	df000315 	stw	fp,12(sp)
 202b3f8:	df000304 	addi	fp,sp,12
 202b3fc:	e13ffe15 	stw	r4,-8(fp)
 202b400:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 202b404:	e0bfff17 	ldw	r2,-4(fp)
 202b408:	108000cc 	andi	r2,r2,3
 202b40c:	10002c1e 	bne	r2,zero,202b4c0 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 202b410:	e0bffe17 	ldw	r2,-8(fp)
 202b414:	10800317 	ldw	r2,12(r2)
 202b418:	e0bffe17 	ldw	r2,-8(fp)
 202b41c:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202b420:	e0bffe17 	ldw	r2,-8(fp)
 202b424:	10800317 	ldw	r2,12(r2)
 202b428:	10800044 	addi	r2,r2,1
 202b42c:	10800fcc 	andi	r2,r2,63
 202b430:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 202b434:	e0bffe17 	ldw	r2,-8(fp)
 202b438:	10800317 	ldw	r2,12(r2)
 202b43c:	e0fffe17 	ldw	r3,-8(fp)
 202b440:	18c00017 	ldw	r3,0(r3)
 202b444:	18c00037 	ldwio	r3,0(r3)
 202b448:	1809883a 	mov	r4,r3
 202b44c:	e0fffe17 	ldw	r3,-8(fp)
 202b450:	1885883a 	add	r2,r3,r2
 202b454:	10800904 	addi	r2,r2,36
 202b458:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 202b45c:	e0bffe17 	ldw	r2,-8(fp)
 202b460:	e0fffd17 	ldw	r3,-12(fp)
 202b464:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202b468:	e0bffe17 	ldw	r2,-8(fp)
 202b46c:	10800317 	ldw	r2,12(r2)
 202b470:	10800044 	addi	r2,r2,1
 202b474:	10800fcc 	andi	r2,r2,63
 202b478:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 202b47c:	e0bffe17 	ldw	r2,-8(fp)
 202b480:	10c00217 	ldw	r3,8(r2)
 202b484:	e0bffd17 	ldw	r2,-12(fp)
 202b488:	18800e1e 	bne	r3,r2,202b4c4 <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202b48c:	e0bffe17 	ldw	r2,-8(fp)
 202b490:	10c00117 	ldw	r3,4(r2)
 202b494:	00bfdfc4 	movi	r2,-129
 202b498:	1886703a 	and	r3,r3,r2
 202b49c:	e0bffe17 	ldw	r2,-8(fp)
 202b4a0:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 202b4a4:	e0bffe17 	ldw	r2,-8(fp)
 202b4a8:	10800017 	ldw	r2,0(r2)
 202b4ac:	10800304 	addi	r2,r2,12
 202b4b0:	e0fffe17 	ldw	r3,-8(fp)
 202b4b4:	18c00117 	ldw	r3,4(r3)
 202b4b8:	10c00035 	stwio	r3,0(r2)
 202b4bc:	00000106 	br	202b4c4 <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 202b4c0:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 202b4c4:	e037883a 	mov	sp,fp
 202b4c8:	df000017 	ldw	fp,0(sp)
 202b4cc:	dec00104 	addi	sp,sp,4
 202b4d0:	f800283a 	ret

0202b4d4 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 202b4d4:	defffb04 	addi	sp,sp,-20
 202b4d8:	df000415 	stw	fp,16(sp)
 202b4dc:	df000404 	addi	fp,sp,16
 202b4e0:	e13ffc15 	stw	r4,-16(fp)
 202b4e4:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 202b4e8:	e0bffc17 	ldw	r2,-16(fp)
 202b4ec:	10c00417 	ldw	r3,16(r2)
 202b4f0:	e0bffc17 	ldw	r2,-16(fp)
 202b4f4:	10800517 	ldw	r2,20(r2)
 202b4f8:	18803226 	beq	r3,r2,202b5c4 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 202b4fc:	e0bffc17 	ldw	r2,-16(fp)
 202b500:	10800617 	ldw	r2,24(r2)
 202b504:	1080008c 	andi	r2,r2,2
 202b508:	10000326 	beq	r2,zero,202b518 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 202b50c:	e0bffd17 	ldw	r2,-12(fp)
 202b510:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 202b514:	10001d26 	beq	r2,zero,202b58c <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 202b518:	e0bffc17 	ldw	r2,-16(fp)
 202b51c:	10800417 	ldw	r2,16(r2)
 202b520:	e0bffc17 	ldw	r2,-16(fp)
 202b524:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 202b528:	e0bffc17 	ldw	r2,-16(fp)
 202b52c:	10800017 	ldw	r2,0(r2)
 202b530:	10800104 	addi	r2,r2,4
 202b534:	e0fffc17 	ldw	r3,-16(fp)
 202b538:	18c00417 	ldw	r3,16(r3)
 202b53c:	e13ffc17 	ldw	r4,-16(fp)
 202b540:	20c7883a 	add	r3,r4,r3
 202b544:	18c01904 	addi	r3,r3,100
 202b548:	18c00003 	ldbu	r3,0(r3)
 202b54c:	18c03fcc 	andi	r3,r3,255
 202b550:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 202b554:	e0bffc17 	ldw	r2,-16(fp)
 202b558:	10800417 	ldw	r2,16(r2)
 202b55c:	10800044 	addi	r2,r2,1
 202b560:	e0fffc17 	ldw	r3,-16(fp)
 202b564:	18800415 	stw	r2,16(r3)
 202b568:	10c00fcc 	andi	r3,r2,63
 202b56c:	e0bffc17 	ldw	r2,-16(fp)
 202b570:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 202b574:	e0bffc17 	ldw	r2,-16(fp)
 202b578:	10800117 	ldw	r2,4(r2)
 202b57c:	10c01014 	ori	r3,r2,64
 202b580:	e0bffc17 	ldw	r2,-16(fp)
 202b584:	10c00115 	stw	r3,4(r2)
 202b588:	00000e06 	br	202b5c4 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 202b58c:	e0bffc17 	ldw	r2,-16(fp)
 202b590:	10800017 	ldw	r2,0(r2)
 202b594:	10800204 	addi	r2,r2,8
 202b598:	10800037 	ldwio	r2,0(r2)
 202b59c:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 202b5a0:	e0bffd17 	ldw	r2,-12(fp)
 202b5a4:	1082000c 	andi	r2,r2,2048
 202b5a8:	1000061e 	bne	r2,zero,202b5c4 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 202b5ac:	e0bffc17 	ldw	r2,-16(fp)
 202b5b0:	10c00117 	ldw	r3,4(r2)
 202b5b4:	00bfefc4 	movi	r2,-65
 202b5b8:	1886703a 	and	r3,r3,r2
 202b5bc:	e0bffc17 	ldw	r2,-16(fp)
 202b5c0:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 202b5c4:	e0bffc17 	ldw	r2,-16(fp)
 202b5c8:	10c00417 	ldw	r3,16(r2)
 202b5cc:	e0bffc17 	ldw	r2,-16(fp)
 202b5d0:	10800517 	ldw	r2,20(r2)
 202b5d4:	1880061e 	bne	r3,r2,202b5f0 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202b5d8:	e0bffc17 	ldw	r2,-16(fp)
 202b5dc:	10c00117 	ldw	r3,4(r2)
 202b5e0:	00beefc4 	movi	r2,-1089
 202b5e4:	1886703a 	and	r3,r3,r2
 202b5e8:	e0bffc17 	ldw	r2,-16(fp)
 202b5ec:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202b5f0:	e0bffc17 	ldw	r2,-16(fp)
 202b5f4:	10800017 	ldw	r2,0(r2)
 202b5f8:	10800304 	addi	r2,r2,12
 202b5fc:	e0fffc17 	ldw	r3,-16(fp)
 202b600:	18c00117 	ldw	r3,4(r3)
 202b604:	10c00035 	stwio	r3,0(r2)
}
 202b608:	0001883a 	nop
 202b60c:	e037883a 	mov	sp,fp
 202b610:	df000017 	ldw	fp,0(sp)
 202b614:	dec00104 	addi	sp,sp,4
 202b618:	f800283a 	ret

0202b61c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 202b61c:	defffd04 	addi	sp,sp,-12
 202b620:	df000215 	stw	fp,8(sp)
 202b624:	df000204 	addi	fp,sp,8
 202b628:	e13ffe15 	stw	r4,-8(fp)
 202b62c:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 202b630:	00000506 	br	202b648 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 202b634:	e0bfff17 	ldw	r2,-4(fp)
 202b638:	1090000c 	andi	r2,r2,16384
 202b63c:	10000226 	beq	r2,zero,202b648 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 202b640:	00bffd44 	movi	r2,-11
 202b644:	00000606 	br	202b660 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 202b648:	e0bffe17 	ldw	r2,-8(fp)
 202b64c:	10c00417 	ldw	r3,16(r2)
 202b650:	e0bffe17 	ldw	r2,-8(fp)
 202b654:	10800517 	ldw	r2,20(r2)
 202b658:	18bff61e 	bne	r3,r2,202b634 <__alt_mem_mem_0+0xfd00b634>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 202b65c:	0005883a 	mov	r2,zero
}
 202b660:	e037883a 	mov	sp,fp
 202b664:	df000017 	ldw	fp,0(sp)
 202b668:	dec00104 	addi	sp,sp,4
 202b66c:	f800283a 	ret

0202b670 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202b670:	defffe04 	addi	sp,sp,-8
 202b674:	dfc00115 	stw	ra,4(sp)
 202b678:	df000015 	stw	fp,0(sp)
 202b67c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202b680:	d0a01a17 	ldw	r2,-32664(gp)
 202b684:	10000326 	beq	r2,zero,202b694 <alt_get_errno+0x24>
 202b688:	d0a01a17 	ldw	r2,-32664(gp)
 202b68c:	103ee83a 	callr	r2
 202b690:	00000106 	br	202b698 <alt_get_errno+0x28>
 202b694:	d0a7ce04 	addi	r2,gp,-24776
}
 202b698:	e037883a 	mov	sp,fp
 202b69c:	dfc00117 	ldw	ra,4(sp)
 202b6a0:	df000017 	ldw	fp,0(sp)
 202b6a4:	dec00204 	addi	sp,sp,8
 202b6a8:	f800283a 	ret

0202b6ac <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 202b6ac:	deffef04 	addi	sp,sp,-68
 202b6b0:	dfc01015 	stw	ra,64(sp)
 202b6b4:	df000f15 	stw	fp,60(sp)
 202b6b8:	df000f04 	addi	fp,sp,60
 202b6bc:	e13ffb15 	stw	r4,-20(fp)
 202b6c0:	e17ffc15 	stw	r5,-16(fp)
 202b6c4:	e1bffd15 	stw	r6,-12(fp)
 202b6c8:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 202b6cc:	e03ff105 	stb	zero,-60(fp)
  int             count = 0;
 202b6d0:	e03ff215 	stw	zero,-56(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 202b6d4:	e0bffe17 	ldw	r2,-8(fp)
 202b6d8:	1090000c 	andi	r2,r2,16384
 202b6dc:	1005003a 	cmpeq	r2,r2,zero
 202b6e0:	10803fcc 	andi	r2,r2,255
 202b6e4:	e0bff315 	stw	r2,-52(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
 202b6e8:	e0bffb17 	ldw	r2,-20(fp)
 202b6ec:	10800717 	ldw	r2,28(r2)
 202b6f0:	e0bff915 	stw	r2,-28(fp)
 202b6f4:	e03ffa0d 	sth	zero,-24(fp)
 * converted into the functions return value.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (xSemaphoreHandle sem, alt_u16 timeout)
{
	return xSemaphoreTake(sem, timeout) ? 0 : -1;
 202b6f8:	e0bffa0b 	ldhu	r2,-24(fp)
 202b6fc:	100b883a 	mov	r5,r2
 202b700:	e13ff917 	ldw	r4,-28(fp)
 202b704:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 202b708:	00001306 	br	202b758 <altera_avalon_uart_read+0xac>
    {
      count++;
 202b70c:	e0bff217 	ldw	r2,-56(fp)
 202b710:	10800044 	addi	r2,r2,1
 202b714:	e0bff215 	stw	r2,-56(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 202b718:	e0bffc17 	ldw	r2,-16(fp)
 202b71c:	10c00044 	addi	r3,r2,1
 202b720:	e0fffc15 	stw	r3,-16(fp)
 202b724:	e0fffb17 	ldw	r3,-20(fp)
 202b728:	18c00217 	ldw	r3,8(r3)
 202b72c:	e13ffb17 	ldw	r4,-20(fp)
 202b730:	20c7883a 	add	r3,r4,r3
 202b734:	18c00904 	addi	r3,r3,36
 202b738:	18c00003 	ldbu	r3,0(r3)
 202b73c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 202b740:	e0bffb17 	ldw	r2,-20(fp)
 202b744:	10800217 	ldw	r2,8(r2)
 202b748:	10800044 	addi	r2,r2,1
 202b74c:	10c00fcc 	andi	r3,r2,63
 202b750:	e0bffb17 	ldw	r2,-20(fp)
 202b754:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 202b758:	e0fff217 	ldw	r3,-56(fp)
 202b75c:	e0bffd17 	ldw	r2,-12(fp)
 202b760:	1880050e 	bge	r3,r2,202b778 <altera_avalon_uart_read+0xcc>
 202b764:	e0bffb17 	ldw	r2,-20(fp)
 202b768:	10c00217 	ldw	r3,8(r2)
 202b76c:	e0bffb17 	ldw	r2,-20(fp)
 202b770:	10800317 	ldw	r2,12(r2)
 202b774:	18bfe51e 	bne	r3,r2,202b70c <__alt_mem_mem_0+0xfd00b70c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 202b778:	e0bff217 	ldw	r2,-56(fp)
 202b77c:	1000251e 	bne	r2,zero,202b814 <altera_avalon_uart_read+0x168>
 202b780:	e0bffb17 	ldw	r2,-20(fp)
 202b784:	10c00217 	ldw	r3,8(r2)
 202b788:	e0bffb17 	ldw	r2,-20(fp)
 202b78c:	10800317 	ldw	r2,12(r2)
 202b790:	1880201e 	bne	r3,r2,202b814 <altera_avalon_uart_read+0x168>
    {
      if (!block)
 202b794:	e0bff317 	ldw	r2,-52(fp)
 202b798:	1000071e 	bne	r2,zero,202b7b8 <altera_avalon_uart_read+0x10c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 202b79c:	202b6700 	call	202b670 <alt_get_errno>
 202b7a0:	1007883a 	mov	r3,r2
 202b7a4:	008002c4 	movi	r2,11
 202b7a8:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 202b7ac:	00800044 	movi	r2,1
 202b7b0:	e0bff105 	stb	r2,-60(fp)
        break;
 202b7b4:	00001b06 	br	202b824 <altera_avalon_uart_read+0x178>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202b7b8:	0005303a 	rdctl	r2,status
 202b7bc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202b7c0:	e0fff617 	ldw	r3,-40(fp)
 202b7c4:	00bfff84 	movi	r2,-2
 202b7c8:	1884703a 	and	r2,r3,r2
 202b7cc:	1001703a 	wrctl	status,r2
  
  return context;
 202b7d0:	e0bff617 	ldw	r2,-40(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 202b7d4:	e0bff515 	stw	r2,-44(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202b7d8:	e0bffb17 	ldw	r2,-20(fp)
 202b7dc:	10800117 	ldw	r2,4(r2)
 202b7e0:	10c02014 	ori	r3,r2,128
 202b7e4:	e0bffb17 	ldw	r2,-20(fp)
 202b7e8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202b7ec:	e0bffb17 	ldw	r2,-20(fp)
 202b7f0:	10800017 	ldw	r2,0(r2)
 202b7f4:	10800304 	addi	r2,r2,12
 202b7f8:	e0fffb17 	ldw	r3,-20(fp)
 202b7fc:	18c00117 	ldw	r3,4(r3)
 202b800:	10c00035 	stwio	r3,0(r2)
 202b804:	e0bff517 	ldw	r2,-44(fp)
 202b808:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202b80c:	e0bff717 	ldw	r2,-36(fp)
 202b810:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 202b814:	e0bff217 	ldw	r2,-56(fp)
 202b818:	1000021e 	bne	r2,zero,202b824 <altera_avalon_uart_read+0x178>
 202b81c:	e0bffd17 	ldw	r2,-12(fp)
 202b820:	103fcd1e 	bne	r2,zero,202b758 <__alt_mem_mem_0+0xfd00b758>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 202b824:	e0bffb17 	ldw	r2,-20(fp)
 202b828:	10800717 	ldw	r2,28(r2)
 202b82c:	000f883a 	mov	r7,zero
 202b830:	000d883a 	mov	r6,zero
 202b834:	000b883a 	mov	r5,zero
 202b838:	1009883a 	mov	r4,r2
 202b83c:	200da140 	call	200da14 <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202b840:	0005303a 	rdctl	r2,status
 202b844:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202b848:	e0fff817 	ldw	r3,-32(fp)
 202b84c:	00bfff84 	movi	r2,-2
 202b850:	1884703a 	and	r2,r3,r2
 202b854:	1001703a 	wrctl	status,r2
  
  return context;
 202b858:	e0bff817 	ldw	r2,-32(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 202b85c:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 202b860:	e0bffb17 	ldw	r2,-20(fp)
 202b864:	10800117 	ldw	r2,4(r2)
 202b868:	10c02014 	ori	r3,r2,128
 202b86c:	e0bffb17 	ldw	r2,-20(fp)
 202b870:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202b874:	e0bffb17 	ldw	r2,-20(fp)
 202b878:	10800017 	ldw	r2,0(r2)
 202b87c:	10800304 	addi	r2,r2,12
 202b880:	e0fffb17 	ldw	r3,-20(fp)
 202b884:	18c00117 	ldw	r3,4(r3)
 202b888:	10c00035 	stwio	r3,0(r2)
 202b88c:	e0bff517 	ldw	r2,-44(fp)
 202b890:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202b894:	e0bff417 	ldw	r2,-48(fp)
 202b898:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 202b89c:	e0bff103 	ldbu	r2,-60(fp)
 202b8a0:	10000226 	beq	r2,zero,202b8ac <altera_avalon_uart_read+0x200>
    return -EWOULDBLOCK;
 202b8a4:	00bffd44 	movi	r2,-11
 202b8a8:	00000106 	br	202b8b0 <altera_avalon_uart_read+0x204>
  }
  else {
    return count;
 202b8ac:	e0bff217 	ldw	r2,-56(fp)
  }
}
 202b8b0:	e037883a 	mov	sp,fp
 202b8b4:	dfc00117 	ldw	ra,4(sp)
 202b8b8:	df000017 	ldw	fp,0(sp)
 202b8bc:	dec00204 	addi	sp,sp,8
 202b8c0:	f800283a 	ret

0202b8c4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202b8c4:	defffe04 	addi	sp,sp,-8
 202b8c8:	dfc00115 	stw	ra,4(sp)
 202b8cc:	df000015 	stw	fp,0(sp)
 202b8d0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202b8d4:	d0a01a17 	ldw	r2,-32664(gp)
 202b8d8:	10000326 	beq	r2,zero,202b8e8 <alt_get_errno+0x24>
 202b8dc:	d0a01a17 	ldw	r2,-32664(gp)
 202b8e0:	103ee83a 	callr	r2
 202b8e4:	00000106 	br	202b8ec <alt_get_errno+0x28>
 202b8e8:	d0a7ce04 	addi	r2,gp,-24776
}
 202b8ec:	e037883a 	mov	sp,fp
 202b8f0:	dfc00117 	ldw	ra,4(sp)
 202b8f4:	df000017 	ldw	fp,0(sp)
 202b8f8:	dec00204 	addi	sp,sp,8
 202b8fc:	f800283a 	ret

0202b900 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 202b900:	deffef04 	addi	sp,sp,-68
 202b904:	dfc01015 	stw	ra,64(sp)
 202b908:	df000f15 	stw	fp,60(sp)
 202b90c:	df000f04 	addi	fp,sp,60
 202b910:	e13ffb15 	stw	r4,-20(fp)
 202b914:	e17ffc15 	stw	r5,-16(fp)
 202b918:	e1bffd15 	stw	r6,-12(fp)
 202b91c:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 202b920:	e0bffd17 	ldw	r2,-12(fp)
 202b924:	e0bff115 	stw	r2,-60(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 202b928:	e0bffe17 	ldw	r2,-8(fp)
 202b92c:	1090000c 	andi	r2,r2,16384
 202b930:	e0bff215 	stw	r2,-56(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 202b934:	e0bffb17 	ldw	r2,-20(fp)
 202b938:	10800817 	ldw	r2,32(r2)
 202b93c:	e0bff915 	stw	r2,-28(fp)
 202b940:	e03ffa0d 	sth	zero,-24(fp)
 202b944:	e0bffa0b 	ldhu	r2,-24(fp)
 202b948:	100b883a 	mov	r5,r2
 202b94c:	e13ff917 	ldw	r4,-28(fp)
 202b950:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 202b954:	00003c06 	br	202ba48 <altera_avalon_uart_write+0x148>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 202b958:	e0bffb17 	ldw	r2,-20(fp)
 202b95c:	10800517 	ldw	r2,20(r2)
 202b960:	10800044 	addi	r2,r2,1
 202b964:	10800fcc 	andi	r2,r2,63
 202b968:	e0bff415 	stw	r2,-48(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 202b96c:	e0bffb17 	ldw	r2,-20(fp)
 202b970:	10c00417 	ldw	r3,16(r2)
 202b974:	e0bff417 	ldw	r2,-48(fp)
 202b978:	1880221e 	bne	r3,r2,202ba04 <altera_avalon_uart_write+0x104>
    {
      if (no_block)
 202b97c:	e0bff217 	ldw	r2,-56(fp)
 202b980:	10000526 	beq	r2,zero,202b998 <altera_avalon_uart_write+0x98>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 202b984:	202b8c40 	call	202b8c4 <alt_get_errno>
 202b988:	1007883a 	mov	r3,r2
 202b98c:	008002c4 	movi	r2,11
 202b990:	18800015 	stw	r2,0(r3)
        break;
 202b994:	00002e06 	br	202ba50 <altera_avalon_uart_write+0x150>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202b998:	0005303a 	rdctl	r2,status
 202b99c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202b9a0:	e0fff617 	ldw	r3,-40(fp)
 202b9a4:	00bfff84 	movi	r2,-2
 202b9a8:	1884703a 	and	r2,r3,r2
 202b9ac:	1001703a 	wrctl	status,r2
  
  return context;
 202b9b0:	e0bff617 	ldw	r2,-40(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 202b9b4:	e0bff515 	stw	r2,-44(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202b9b8:	e0bffb17 	ldw	r2,-20(fp)
 202b9bc:	10800117 	ldw	r2,4(r2)
 202b9c0:	10c11014 	ori	r3,r2,1088
 202b9c4:	e0bffb17 	ldw	r2,-20(fp)
 202b9c8:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202b9cc:	e0bffb17 	ldw	r2,-20(fp)
 202b9d0:	10800017 	ldw	r2,0(r2)
 202b9d4:	10800304 	addi	r2,r2,12
 202b9d8:	e0fffb17 	ldw	r3,-20(fp)
 202b9dc:	18c00117 	ldw	r3,4(r3)
 202b9e0:	10c00035 	stwio	r3,0(r2)
 202b9e4:	e0bff517 	ldw	r2,-44(fp)
 202b9e8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202b9ec:	e0bff317 	ldw	r2,-52(fp)
 202b9f0:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 202b9f4:	e0bffb17 	ldw	r2,-20(fp)
 202b9f8:	10c00417 	ldw	r3,16(r2)
 202b9fc:	e0bff417 	ldw	r2,-48(fp)
 202ba00:	18bffc26 	beq	r3,r2,202b9f4 <__alt_mem_mem_0+0xfd00b9f4>
      }
    }

    count--;
 202ba04:	e0bff117 	ldw	r2,-60(fp)
 202ba08:	10bfffc4 	addi	r2,r2,-1
 202ba0c:	e0bff115 	stw	r2,-60(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 202ba10:	e0bffb17 	ldw	r2,-20(fp)
 202ba14:	10c00517 	ldw	r3,20(r2)
 202ba18:	e0bffc17 	ldw	r2,-16(fp)
 202ba1c:	11000044 	addi	r4,r2,1
 202ba20:	e13ffc15 	stw	r4,-16(fp)
 202ba24:	10800003 	ldbu	r2,0(r2)
 202ba28:	1009883a 	mov	r4,r2
 202ba2c:	e0bffb17 	ldw	r2,-20(fp)
 202ba30:	10c5883a 	add	r2,r2,r3
 202ba34:	10801904 	addi	r2,r2,100
 202ba38:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 202ba3c:	e0bffb17 	ldw	r2,-20(fp)
 202ba40:	e0fff417 	ldw	r3,-48(fp)
 202ba44:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 202ba48:	e0bff117 	ldw	r2,-60(fp)
 202ba4c:	103fc21e 	bne	r2,zero,202b958 <__alt_mem_mem_0+0xfd00b958>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 202ba50:	e0bffb17 	ldw	r2,-20(fp)
 202ba54:	10800817 	ldw	r2,32(r2)
 202ba58:	000f883a 	mov	r7,zero
 202ba5c:	000d883a 	mov	r6,zero
 202ba60:	000b883a 	mov	r5,zero
 202ba64:	1009883a 	mov	r4,r2
 202ba68:	200da140 	call	200da14 <xQueueGenericSend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202ba6c:	0005303a 	rdctl	r2,status
 202ba70:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202ba74:	e0fff817 	ldw	r3,-32(fp)
 202ba78:	00bfff84 	movi	r2,-2
 202ba7c:	1884703a 	and	r2,r3,r2
 202ba80:	1001703a 	wrctl	status,r2
  
  return context;
 202ba84:	e0bff817 	ldw	r2,-32(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 202ba88:	e0bff515 	stw	r2,-44(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 202ba8c:	e0bffb17 	ldw	r2,-20(fp)
 202ba90:	10800117 	ldw	r2,4(r2)
 202ba94:	10c11014 	ori	r3,r2,1088
 202ba98:	e0bffb17 	ldw	r2,-20(fp)
 202ba9c:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 202baa0:	e0bffb17 	ldw	r2,-20(fp)
 202baa4:	10800017 	ldw	r2,0(r2)
 202baa8:	10800304 	addi	r2,r2,12
 202baac:	e0fffb17 	ldw	r3,-20(fp)
 202bab0:	18c00117 	ldw	r3,4(r3)
 202bab4:	10c00035 	stwio	r3,0(r2)
 202bab8:	e0bff517 	ldw	r2,-44(fp)
 202babc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202bac0:	e0bff717 	ldw	r2,-36(fp)
 202bac4:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 202bac8:	e0fffd17 	ldw	r3,-12(fp)
 202bacc:	e0bff117 	ldw	r2,-60(fp)
 202bad0:	1885c83a 	sub	r2,r3,r2
}
 202bad4:	e037883a 	mov	sp,fp
 202bad8:	dfc00117 	ldw	ra,4(sp)
 202badc:	df000017 	ldw	fp,0(sp)
 202bae0:	dec00204 	addi	sp,sp,8
 202bae4:	f800283a 	ret

0202bae8 <__env_lock>:
xSemaphoreHandle alt_envsem;

/* __env_lock needs to provide recursive mutex locking */

void __env_lock ( struct _reent *_r )
{
 202bae8:	defffd04 	addi	sp,sp,-12
 202baec:	dfc00215 	stw	ra,8(sp)
 202baf0:	df000115 	stw	fp,4(sp)
 202baf4:	df000104 	addi	fp,sp,4
 202baf8:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 202bafc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202bb00:	10000b26 	beq	r2,zero,202bb30 <__env_lock+0x48>
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 202bb04:	00000206 	br	202bb10 <__env_lock+0x28>
		vTaskDelay(1);
 202bb08:	01000044 	movi	r4,1
 202bb0c:	200f2640 	call	200f264 <vTaskDelay>
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;

	// wait for the mutex to be released
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
 202bb10:	d0a80117 	ldw	r2,-24572(gp)
 202bb14:	01400284 	movi	r5,10
 202bb18:	1009883a 	mov	r4,r2
 202bb1c:	200d9200 	call	200d920 <xQueueTakeMutexRecursive>
 202bb20:	10800058 	cmpnei	r2,r2,1
 202bb24:	103ff81e 	bne	r2,zero,202bb08 <__alt_mem_mem_0+0xfd00bb08>
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
 202bb28:	0001883a 	nop
 202bb2c:	00000106 	br	202bb34 <__env_lock+0x4c>

void __env_lock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 202bb30:	0001883a 	nop
	while (xSemaphoreTakeRecursive(alt_envsem, 10) != pdTRUE)
		vTaskDelay(1);

#endif /* OS_THREAD_SAFE_NEWLIB */
	return;
}
 202bb34:	e037883a 	mov	sp,fp
 202bb38:	dfc00117 	ldw	ra,4(sp)
 202bb3c:	df000017 	ldw	fp,0(sp)
 202bb40:	dec00204 	addi	sp,sp,8
 202bb44:	f800283a 	ret

0202bb48 <__env_unlock>:

/* __env_unlock needs to provide recursive mutex unlocking */

void __env_unlock ( struct _reent *_r )
{
 202bb48:	defffd04 	addi	sp,sp,-12
 202bb4c:	dfc00215 	stw	ra,8(sp)
 202bb50:	df000115 	stw	fp,4(sp)
 202bb54:	df000104 	addi	fp,sp,4
 202bb58:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
 202bb5c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202bb60:	10000426 	beq	r2,zero,202bb74 <__env_unlock+0x2c>
		return;
	  
	xSemaphoreGiveRecursive(alt_envsem);
 202bb64:	d0a80117 	ldw	r2,-24572(gp)
 202bb68:	1009883a 	mov	r4,r2
 202bb6c:	200d8900 	call	200d890 <xQueueGiveMutexRecursive>
 202bb70:	00000106 	br	202bb78 <__env_unlock+0x30>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
	if (!xTaskGetSchedulerState())
		return;
 202bb74:	0001883a 	nop
	  
	xSemaphoreGiveRecursive(alt_envsem);
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 202bb78:	e037883a 	mov	sp,fp
 202bb7c:	dfc00117 	ldw	ra,4(sp)
 202bb80:	df000017 	ldw	fp,0(sp)
 202bb84:	dec00204 	addi	sp,sp,8
 202bb88:	f800283a 	ret

0202bb8c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 202bb8c:	defffc04 	addi	sp,sp,-16
 202bb90:	dfc00315 	stw	ra,12(sp)
 202bb94:	df000215 	stw	fp,8(sp)
 202bb98:	df000204 	addi	fp,sp,8
 202bb9c:	e13fff15 	stw	r4,-4(fp)
void *pvReturn = NULL;
 202bba0:	e03ffe15 	stw	zero,-8(fp)
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 202bba4:	e0bfff17 	ldw	r2,-4(fp)
 202bba8:	108000cc 	andi	r2,r2,3
 202bbac:	10000526 	beq	r2,zero,202bbc4 <pvPortMalloc+0x38>
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 202bbb0:	e0ffff17 	ldw	r3,-4(fp)
 202bbb4:	00bfff04 	movi	r2,-4
 202bbb8:	1884703a 	and	r2,r3,r2
 202bbbc:	10800104 	addi	r2,r2,4
 202bbc0:	e0bfff15 	stw	r2,-4(fp)
		}
	}
	#endif

	vTaskSuspendAll();
 202bbc4:	200fa500 	call	200fa50 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 202bbc8:	d0a80317 	ldw	r2,-24564(gp)
 202bbcc:	1000051e 	bne	r2,zero,202bbe4 <pvPortMalloc+0x58>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 202bbd0:	00808134 	movhi	r2,516
 202bbd4:	109f2504 	addi	r2,r2,31892
 202bbd8:	00ffff04 	movi	r3,-4
 202bbdc:	10c4703a 	and	r2,r2,r3
 202bbe0:	d0a80315 	stw	r2,-24564(gp)
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 202bbe4:	d0e80217 	ldw	r3,-24568(gp)
 202bbe8:	e0bfff17 	ldw	r2,-4(fp)
 202bbec:	1887883a 	add	r3,r3,r2
 202bbf0:	00800434 	movhi	r2,16
 202bbf4:	10bffec4 	addi	r2,r2,-5
 202bbf8:	10c00d36 	bltu	r2,r3,202bc30 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
 202bbfc:	d0e80217 	ldw	r3,-24568(gp)
 202bc00:	e0bfff17 	ldw	r2,-4(fp)
 202bc04:	1885883a 	add	r2,r3,r2
 202bc08:	d0e80217 	ldw	r3,-24568(gp)
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 202bc0c:	1880082e 	bgeu	r3,r2,202bc30 <pvPortMalloc+0xa4>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 202bc10:	d0e80317 	ldw	r3,-24564(gp)
 202bc14:	d0a80217 	ldw	r2,-24568(gp)
 202bc18:	1885883a 	add	r2,r3,r2
 202bc1c:	e0bffe15 	stw	r2,-8(fp)
			xNextFreeByte += xWantedSize;
 202bc20:	d0e80217 	ldw	r3,-24568(gp)
 202bc24:	e0bfff17 	ldw	r2,-4(fp)
 202bc28:	1885883a 	add	r2,r3,r2
 202bc2c:	d0a80215 	stw	r2,-24568(gp)
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 202bc30:	200fa7c0 	call	200fa7c <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 202bc34:	e0bffe17 	ldw	r2,-8(fp)
 202bc38:	1000011e 	bne	r2,zero,202bc40 <pvPortMalloc+0xb4>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 202bc3c:	20004500 	call	2000450 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
 202bc40:	e0bffe17 	ldw	r2,-8(fp)
}
 202bc44:	e037883a 	mov	sp,fp
 202bc48:	dfc00117 	ldw	ra,4(sp)
 202bc4c:	df000017 	ldw	fp,0(sp)
 202bc50:	dec00204 	addi	sp,sp,8
 202bc54:	f800283a 	ret

0202bc58 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 202bc58:	defffe04 	addi	sp,sp,-8
 202bc5c:	df000115 	stw	fp,4(sp)
 202bc60:	df000104 	addi	fp,sp,4
 202bc64:	e13fff15 	stw	r4,-4(fp)
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
 202bc68:	0001883a 	nop
 202bc6c:	e037883a 	mov	sp,fp
 202bc70:	df000017 	ldw	fp,0(sp)
 202bc74:	dec00104 	addi	sp,sp,4
 202bc78:	f800283a 	ret

0202bc7c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 202bc7c:	deffff04 	addi	sp,sp,-4
 202bc80:	df000015 	stw	fp,0(sp)
 202bc84:	d839883a 	mov	fp,sp
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 202bc88:	d0280215 	stw	zero,-24568(gp)
}
 202bc8c:	0001883a 	nop
 202bc90:	e037883a 	mov	sp,fp
 202bc94:	df000017 	ldw	fp,0(sp)
 202bc98:	dec00104 	addi	sp,sp,4
 202bc9c:	f800283a 	ret

0202bca0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 202bca0:	deffff04 	addi	sp,sp,-4
 202bca4:	df000015 	stw	fp,0(sp)
 202bca8:	d839883a 	mov	fp,sp
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 202bcac:	d0e80217 	ldw	r3,-24568(gp)
 202bcb0:	00800434 	movhi	r2,16
 202bcb4:	10bfff04 	addi	r2,r2,-4
 202bcb8:	10c5c83a 	sub	r2,r2,r3
}
 202bcbc:	e037883a 	mov	sp,fp
 202bcc0:	df000017 	ldw	fp,0(sp)
 202bcc4:	dec00104 	addi	sp,sp,4
 202bcc8:	f800283a 	ret

0202bccc <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 202bccc:	defffe04 	addi	sp,sp,-8
 202bcd0:	df000115 	stw	fp,4(sp)
 202bcd4:	df000104 	addi	fp,sp,4
 202bcd8:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202bcdc:	e0bfff17 	ldw	r2,-4(fp)
 202bce0:	10c00204 	addi	r3,r2,8
 202bce4:	e0bfff17 	ldw	r2,-4(fp)
 202bce8:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 202bcec:	e0bfff17 	ldw	r2,-4(fp)
 202bcf0:	00ffffc4 	movi	r3,-1
 202bcf4:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202bcf8:	e0bfff17 	ldw	r2,-4(fp)
 202bcfc:	10c00204 	addi	r3,r2,8
 202bd00:	e0bfff17 	ldw	r2,-4(fp)
 202bd04:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 202bd08:	e0bfff17 	ldw	r2,-4(fp)
 202bd0c:	10c00204 	addi	r3,r2,8
 202bd10:	e0bfff17 	ldw	r2,-4(fp)
 202bd14:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 202bd18:	e0bfff17 	ldw	r2,-4(fp)
 202bd1c:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 202bd20:	0001883a 	nop
 202bd24:	e037883a 	mov	sp,fp
 202bd28:	df000017 	ldw	fp,0(sp)
 202bd2c:	dec00104 	addi	sp,sp,4
 202bd30:	f800283a 	ret

0202bd34 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 202bd34:	defffe04 	addi	sp,sp,-8
 202bd38:	df000115 	stw	fp,4(sp)
 202bd3c:	df000104 	addi	fp,sp,4
 202bd40:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 202bd44:	e0bfff17 	ldw	r2,-4(fp)
 202bd48:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 202bd4c:	0001883a 	nop
 202bd50:	e037883a 	mov	sp,fp
 202bd54:	df000017 	ldw	fp,0(sp)
 202bd58:	dec00104 	addi	sp,sp,4
 202bd5c:	f800283a 	ret

0202bd60 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 202bd60:	defffc04 	addi	sp,sp,-16
 202bd64:	df000315 	stw	fp,12(sp)
 202bd68:	df000304 	addi	fp,sp,12
 202bd6c:	e13ffe15 	stw	r4,-8(fp)
 202bd70:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 202bd74:	e0bffe17 	ldw	r2,-8(fp)
 202bd78:	10800117 	ldw	r2,4(r2)
 202bd7c:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 202bd80:	e0bfff17 	ldw	r2,-4(fp)
 202bd84:	e0fffd17 	ldw	r3,-12(fp)
 202bd88:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 202bd8c:	e0bffd17 	ldw	r2,-12(fp)
 202bd90:	10c00217 	ldw	r3,8(r2)
 202bd94:	e0bfff17 	ldw	r2,-4(fp)
 202bd98:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 202bd9c:	e0bffd17 	ldw	r2,-12(fp)
 202bda0:	10800217 	ldw	r2,8(r2)
 202bda4:	e0ffff17 	ldw	r3,-4(fp)
 202bda8:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 202bdac:	e0bffd17 	ldw	r2,-12(fp)
 202bdb0:	e0ffff17 	ldw	r3,-4(fp)
 202bdb4:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 202bdb8:	e0bfff17 	ldw	r2,-4(fp)
 202bdbc:	e0fffe17 	ldw	r3,-8(fp)
 202bdc0:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 202bdc4:	e0bffe17 	ldw	r2,-8(fp)
 202bdc8:	10800017 	ldw	r2,0(r2)
 202bdcc:	10c00044 	addi	r3,r2,1
 202bdd0:	e0bffe17 	ldw	r2,-8(fp)
 202bdd4:	10c00015 	stw	r3,0(r2)
}
 202bdd8:	0001883a 	nop
 202bddc:	e037883a 	mov	sp,fp
 202bde0:	df000017 	ldw	fp,0(sp)
 202bde4:	dec00104 	addi	sp,sp,4
 202bde8:	f800283a 	ret

0202bdec <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 202bdec:	defffb04 	addi	sp,sp,-20
 202bdf0:	df000415 	stw	fp,16(sp)
 202bdf4:	df000404 	addi	fp,sp,16
 202bdf8:	e13ffe15 	stw	r4,-8(fp)
 202bdfc:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 202be00:	e0bfff17 	ldw	r2,-4(fp)
 202be04:	10800017 	ldw	r2,0(r2)
 202be08:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 202be0c:	e0bffd17 	ldw	r2,-12(fp)
 202be10:	10bfffd8 	cmpnei	r2,r2,-1
 202be14:	1000041e 	bne	r2,zero,202be28 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 202be18:	e0bffe17 	ldw	r2,-8(fp)
 202be1c:	10800417 	ldw	r2,16(r2)
 202be20:	e0bffc15 	stw	r2,-16(fp)
 202be24:	00000c06 	br	202be58 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 202be28:	e0bffe17 	ldw	r2,-8(fp)
 202be2c:	10800204 	addi	r2,r2,8
 202be30:	e0bffc15 	stw	r2,-16(fp)
 202be34:	00000306 	br	202be44 <vListInsert+0x58>
 202be38:	e0bffc17 	ldw	r2,-16(fp)
 202be3c:	10800117 	ldw	r2,4(r2)
 202be40:	e0bffc15 	stw	r2,-16(fp)
 202be44:	e0bffc17 	ldw	r2,-16(fp)
 202be48:	10800117 	ldw	r2,4(r2)
 202be4c:	10800017 	ldw	r2,0(r2)
 202be50:	e0fffd17 	ldw	r3,-12(fp)
 202be54:	18bff82e 	bgeu	r3,r2,202be38 <__alt_mem_mem_0+0xfd00be38>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 202be58:	e0bffc17 	ldw	r2,-16(fp)
 202be5c:	10c00117 	ldw	r3,4(r2)
 202be60:	e0bfff17 	ldw	r2,-4(fp)
 202be64:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 202be68:	e0bfff17 	ldw	r2,-4(fp)
 202be6c:	10800117 	ldw	r2,4(r2)
 202be70:	e0ffff17 	ldw	r3,-4(fp)
 202be74:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 202be78:	e0bfff17 	ldw	r2,-4(fp)
 202be7c:	e0fffc17 	ldw	r3,-16(fp)
 202be80:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 202be84:	e0bffc17 	ldw	r2,-16(fp)
 202be88:	e0ffff17 	ldw	r3,-4(fp)
 202be8c:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 202be90:	e0bfff17 	ldw	r2,-4(fp)
 202be94:	e0fffe17 	ldw	r3,-8(fp)
 202be98:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 202be9c:	e0bffe17 	ldw	r2,-8(fp)
 202bea0:	10800017 	ldw	r2,0(r2)
 202bea4:	10c00044 	addi	r3,r2,1
 202bea8:	e0bffe17 	ldw	r2,-8(fp)
 202beac:	10c00015 	stw	r3,0(r2)
}
 202beb0:	0001883a 	nop
 202beb4:	e037883a 	mov	sp,fp
 202beb8:	df000017 	ldw	fp,0(sp)
 202bebc:	dec00104 	addi	sp,sp,4
 202bec0:	f800283a 	ret

0202bec4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 202bec4:	defffd04 	addi	sp,sp,-12
 202bec8:	df000215 	stw	fp,8(sp)
 202becc:	df000204 	addi	fp,sp,8
 202bed0:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 202bed4:	e0bfff17 	ldw	r2,-4(fp)
 202bed8:	10800417 	ldw	r2,16(r2)
 202bedc:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 202bee0:	e0bfff17 	ldw	r2,-4(fp)
 202bee4:	10800117 	ldw	r2,4(r2)
 202bee8:	e0ffff17 	ldw	r3,-4(fp)
 202beec:	18c00217 	ldw	r3,8(r3)
 202bef0:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 202bef4:	e0bfff17 	ldw	r2,-4(fp)
 202bef8:	10800217 	ldw	r2,8(r2)
 202befc:	e0ffff17 	ldw	r3,-4(fp)
 202bf00:	18c00117 	ldw	r3,4(r3)
 202bf04:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 202bf08:	e0bffe17 	ldw	r2,-8(fp)
 202bf0c:	10c00117 	ldw	r3,4(r2)
 202bf10:	e0bfff17 	ldw	r2,-4(fp)
 202bf14:	1880041e 	bne	r3,r2,202bf28 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 202bf18:	e0bfff17 	ldw	r2,-4(fp)
 202bf1c:	10c00217 	ldw	r3,8(r2)
 202bf20:	e0bffe17 	ldw	r2,-8(fp)
 202bf24:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 202bf28:	e0bfff17 	ldw	r2,-4(fp)
 202bf2c:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 202bf30:	e0bffe17 	ldw	r2,-8(fp)
 202bf34:	10800017 	ldw	r2,0(r2)
 202bf38:	10ffffc4 	addi	r3,r2,-1
 202bf3c:	e0bffe17 	ldw	r2,-8(fp)
 202bf40:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 202bf44:	e0bffe17 	ldw	r2,-8(fp)
 202bf48:	10800017 	ldw	r2,0(r2)
}
 202bf4c:	e037883a 	mov	sp,fp
 202bf50:	df000017 	ldw	fp,0(sp)
 202bf54:	dec00104 	addi	sp,sp,4
 202bf58:	f800283a 	ret

0202bf5c <prvReadGp>:
void vPortSysTickHandler( void * context, alt_u32 id );

/*-----------------------------------------------------------*/

static void prvReadGp( uint32_t *ulValue )
{
 202bf5c:	defffe04 	addi	sp,sp,-8
 202bf60:	df000115 	stw	fp,4(sp)
 202bf64:	df000104 	addi	fp,sp,4
 202bf68:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (%0)" :: "r"(ulValue) );
 202bf6c:	e0bfff17 	ldw	r2,-4(fp)
 202bf70:	16800015 	stw	gp,0(r2)
}
 202bf74:	0001883a 	nop
 202bf78:	e037883a 	mov	sp,fp
 202bf7c:	df000017 	ldw	fp,0(sp)
 202bf80:	dec00104 	addi	sp,sp,4
 202bf84:	f800283a 	ret

0202bf88 <enh_alt_irq_disable_all>:


static volatile alt_irq_context lastContext;

void enh_alt_irq_disable_all()
{
 202bf88:	defffd04 	addi	sp,sp,-12
 202bf8c:	df000215 	stw	fp,8(sp)
 202bf90:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202bf94:	0005303a 	rdctl	r2,status
 202bf98:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202bf9c:	e0ffff17 	ldw	r3,-4(fp)
 202bfa0:	00bfff84 	movi	r2,-2
 202bfa4:	1884703a 	and	r2,r3,r2
 202bfa8:	1001703a 	wrctl	status,r2
  
  return context;
 202bfac:	e0bfff17 	ldw	r2,-4(fp)
	alt_irq_context ctxt = alt_irq_disable_all();
 202bfb0:	e0bffe15 	stw	r2,-8(fp)
	lastContext |= ctxt;
 202bfb4:	d0e80417 	ldw	r3,-24560(gp)
 202bfb8:	e0bffe17 	ldw	r2,-8(fp)
 202bfbc:	1884b03a 	or	r2,r3,r2
 202bfc0:	d0a80415 	stw	r2,-24560(gp)
}
 202bfc4:	0001883a 	nop
 202bfc8:	e037883a 	mov	sp,fp
 202bfcc:	df000017 	ldw	fp,0(sp)
 202bfd0:	dec00104 	addi	sp,sp,4
 202bfd4:	f800283a 	ret

0202bfd8 <enh_alt_irq_enable_all>:

void enh_alt_irq_enable_all()
{
 202bfd8:	defffd04 	addi	sp,sp,-12
 202bfdc:	df000215 	stw	fp,8(sp)
 202bfe0:	df000204 	addi	fp,sp,8
	alt_irq_context restore = lastContext;
 202bfe4:	d0a80417 	ldw	r2,-24560(gp)
 202bfe8:	e0bffe15 	stw	r2,-8(fp)
	lastContext = 0;
 202bfec:	d0280415 	stw	zero,-24560(gp)
 202bff0:	e0bffe17 	ldw	r2,-8(fp)
 202bff4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202bff8:	e0bfff17 	ldw	r2,-4(fp)
 202bffc:	1001703a 	wrctl	status,r2
	alt_irq_enable_all(restore);
}
 202c000:	0001883a 	nop
 202c004:	e037883a 	mov	sp,fp
 202c008:	df000017 	ldw	fp,0(sp)
 202c00c:	dec00104 	addi	sp,sp,4
 202c010:	f800283a 	ret

0202c014 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{    
 202c014:	defff904 	addi	sp,sp,-28
 202c018:	dfc00615 	stw	ra,24(sp)
 202c01c:	df000515 	stw	fp,20(sp)
 202c020:	df000504 	addi	fp,sp,20
 202c024:	e13ffd15 	stw	r4,-12(fp)
 202c028:	e17ffe15 	stw	r5,-8(fp)
 202c02c:	e1bfff15 	stw	r6,-4(fp)
StackType_t *pxFramePointer = pxTopOfStack - 1;
 202c030:	e0bffd17 	ldw	r2,-12(fp)
 202c034:	10bfff04 	addi	r2,r2,-4
 202c038:	e0bffb15 	stw	r2,-20(fp)
StackType_t xGlobalPointer;

    prvReadGp( &xGlobalPointer ); 
 202c03c:	e0bffc04 	addi	r2,fp,-16
 202c040:	1009883a 	mov	r4,r2
 202c044:	202bf5c0 	call	202bf5c <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 202c048:	e0fffd17 	ldw	r3,-12(fp)
 202c04c:	00b7abb4 	movhi	r2,57006
 202c050:	10afbbc4 	addi	r2,r2,-16657
 202c054:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 202c058:	e0bffd17 	ldw	r2,-12(fp)
 202c05c:	10bfff04 	addi	r2,r2,-4
 202c060:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pxFramePointer; 
 202c064:	e0fffb17 	ldw	r3,-20(fp)
 202c068:	e0bffd17 	ldw	r2,-12(fp)
 202c06c:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 202c070:	e0bffd17 	ldw	r2,-12(fp)
 202c074:	10bfff04 	addi	r2,r2,-4
 202c078:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = xGlobalPointer; 
 202c07c:	e0fffc17 	ldw	r3,-16(fp)
 202c080:	e0bffd17 	ldw	r2,-12(fp)
 202c084:	10c00015 	stw	r3,0(r2)
    
    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 202c088:	e0bffd17 	ldw	r2,-12(fp)
 202c08c:	10bff704 	addi	r2,r2,-36
 202c090:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( StackType_t ) pxCode; 
 202c094:	e0fffe17 	ldw	r3,-8(fp)
 202c098:	e0bffd17 	ldw	r2,-12(fp)
 202c09c:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 202c0a0:	e0bffd17 	ldw	r2,-12(fp)
 202c0a4:	10bfff04 	addi	r2,r2,-4
 202c0a8:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS; 
 202c0ac:	e0bffd17 	ldw	r2,-12(fp)
 202c0b0:	00c00044 	movi	r3,1
 202c0b4:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */    
    pxTopOfStack -= 12;
 202c0b8:	e0bffd17 	ldw	r2,-12(fp)
 202c0bc:	10bff404 	addi	r2,r2,-48
 202c0c0:	e0bffd15 	stw	r2,-12(fp)
    
    *pxTopOfStack = ( StackType_t ) pvParameters; 
 202c0c4:	e0ffff17 	ldw	r3,-4(fp)
 202c0c8:	e0bffd17 	ldw	r2,-12(fp)
 202c0cc:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 202c0d0:	e0bffd17 	ldw	r2,-12(fp)
 202c0d4:	10bffb04 	addi	r2,r2,-20
 202c0d8:	e0bffd15 	stw	r2,-12(fp)
    
    return pxTopOfStack;
 202c0dc:	e0bffd17 	ldw	r2,-12(fp)
}
 202c0e0:	e037883a 	mov	sp,fp
 202c0e4:	dfc00117 	ldw	ra,4(sp)
 202c0e8:	df000017 	ldw	fp,0(sp)
 202c0ec:	dec00204 	addi	sp,sp,8
 202c0f0:	f800283a 	ret

0202c0f4 <xPortStartScheduler>:

/* 
 * See header file for description. 
 */
BaseType_t xPortStartScheduler( void )
{
 202c0f4:	defffe04 	addi	sp,sp,-8
 202c0f8:	dfc00115 	stw	ra,4(sp)
 202c0fc:	df000015 	stw	fp,0(sp)
 202c100:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 202c104:	202c14c0 	call	202c14c <prvSetupTimerInterrupt>
 202c108:	00808034 	movhi	r2,512
	
	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 202c10c:	10803104 	addi	r2,r2,196
 202c110:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 202c114:	0005883a 	mov	r2,zero
}
 202c118:	e037883a 	mov	sp,fp
 202c11c:	dfc00117 	ldw	ra,4(sp)
 202c120:	df000017 	ldw	fp,0(sp)
 202c124:	dec00204 	addi	sp,sp,8
 202c128:	f800283a 	ret

0202c12c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 202c12c:	deffff04 	addi	sp,sp,-4
 202c130:	df000015 	stw	fp,0(sp)
 202c134:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 202c138:	0001883a 	nop
 202c13c:	e037883a 	mov	sp,fp
 202c140:	df000017 	ldw	fp,0(sp)
 202c144:	dec00104 	addi	sp,sp,4
 202c148:	f800283a 	ret

0202c14c <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 202c14c:	defffe04 	addi	sp,sp,-8
 202c150:	dfc00115 	stw	ra,4(sp)
 202c154:	df000015 	stw	fp,0(sp)
 202c158:	d839883a 	mov	fp,sp
	/* Try to register the interrupt handler. */
	if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
 202c15c:	018080f4 	movhi	r6,515
 202c160:	31b07a04 	addi	r6,r6,-15896
 202c164:	000b883a 	mov	r5,zero
 202c168:	010000c4 	movi	r4,3
 202c16c:	202c2340 	call	202c234 <alt_irq_register>
 202c170:	10bffa98 	cmpnei	r2,r2,-22
 202c174:	1000021e 	bne	r2,zero,202c180 <prvSetupTimerInterrupt+0x34>
	{ 
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 202c178:	003da03a 	break	0
 202c17c:	00001006 	br	202c1c0 <prvSetupTimerInterrupt+0x74>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 202c180:	00c00204 	movi	r3,8
 202c184:	00814134 	movhi	r2,1284
 202c188:	10840904 	addi	r2,r2,4132
 202c18c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 202c190:	00e1a814 	movui	r3,34464
 202c194:	00814134 	movhi	r2,1284
 202c198:	10840a04 	addi	r2,r2,4136
 202c19c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 202c1a0:	00c00044 	movi	r3,1
 202c1a4:	00814134 	movhi	r2,1284
 202c1a8:	10840b04 	addi	r2,r2,4140
 202c1ac:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
 202c1b0:	00c001c4 	movi	r3,7
 202c1b4:	00814134 	movhi	r2,1284
 202c1b8:	10840904 	addi	r2,r2,4132
 202c1bc:	10c00035 	stwio	r3,0(r2)
	} 

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 202c1c0:	00ffff84 	movi	r3,-2
 202c1c4:	00814134 	movhi	r2,1284
 202c1c8:	10840804 	addi	r2,r2,4128
 202c1cc:	10c00035 	stwio	r3,0(r2)
}
 202c1d0:	0001883a 	nop
 202c1d4:	e037883a 	mov	sp,fp
 202c1d8:	dfc00117 	ldw	ra,4(sp)
 202c1dc:	df000017 	ldw	fp,0(sp)
 202c1e0:	dec00204 	addi	sp,sp,8
 202c1e4:	f800283a 	ret

0202c1e8 <vPortSysTickHandler>:
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void * context, alt_u32 id )
{
 202c1e8:	defffc04 	addi	sp,sp,-16
 202c1ec:	dfc00315 	stw	ra,12(sp)
 202c1f0:	df000215 	stw	fp,8(sp)
 202c1f4:	df000204 	addi	fp,sp,8
 202c1f8:	e13ffe15 	stw	r4,-8(fp)
 202c1fc:	e17fff15 	stw	r5,-4(fp)
	/* Increment the kernel tick. */
	if( xTaskIncrementTick() != pdFALSE )
 202c200:	200fe6c0 	call	200fe6c <xTaskIncrementTick>
 202c204:	10000126 	beq	r2,zero,202c20c <vPortSysTickHandler+0x24>
	{
        vTaskSwitchContext();
 202c208:	201001c0 	call	201001c <vTaskSwitchContext>
	}
		
	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 202c20c:	00ffff84 	movi	r3,-2
 202c210:	00814134 	movhi	r2,1284
 202c214:	10840804 	addi	r2,r2,4128
 202c218:	10c00035 	stwio	r3,0(r2)
}
 202c21c:	0001883a 	nop
 202c220:	e037883a 	mov	sp,fp
 202c224:	dfc00117 	ldw	ra,4(sp)
 202c228:	df000017 	ldw	fp,0(sp)
 202c22c:	dec00204 	addi	sp,sp,8
 202c230:	f800283a 	ret

0202c234 <alt_irq_register>:
 * when it is registered. Interrupts should only be enabled after the FreeRTOS.org
 * kernel has its scheduler started so that contexts are saved and switched 
 * correctly.
 */
int alt_irq_register( alt_u32 id, void* context, alt_isr_func handler)
{
 202c234:	defff104 	addi	sp,sp,-60
 202c238:	df000e15 	stw	fp,56(sp)
 202c23c:	df000e04 	addi	fp,sp,56
 202c240:	e13ffd15 	stw	r4,-12(fp)
 202c244:	e17ffe15 	stw	r5,-8(fp)
 202c248:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;  
 202c24c:	00bffa84 	movi	r2,-22
 202c250:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 202c254:	e0bffd17 	ldw	r2,-12(fp)
 202c258:	10800828 	cmpgeui	r2,r2,32
 202c25c:	10004c1e 	bne	r2,zero,202c390 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202c260:	0005303a 	rdctl	r2,status
 202c264:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202c268:	e0fff617 	ldw	r3,-40(fp)
 202c26c:	00bfff84 	movi	r2,-2
 202c270:	1884703a 	and	r2,r3,r2
 202c274:	1001703a 	wrctl	status,r2
  
  return context;
 202c278:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */
	
		status = alt_irq_disable_all();
 202c27c:	e0bff415 	stw	r2,-48(fp)
	
		alt_irq[id].handler = handler;
 202c280:	008085f4 	movhi	r2,535
 202c284:	10a96904 	addi	r2,r2,-23132
 202c288:	e0fffd17 	ldw	r3,-12(fp)
 202c28c:	180690fa 	slli	r3,r3,3
 202c290:	10c5883a 	add	r2,r2,r3
 202c294:	e0ffff17 	ldw	r3,-4(fp)
 202c298:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 202c29c:	008085f4 	movhi	r2,535
 202c2a0:	10a96904 	addi	r2,r2,-23132
 202c2a4:	e0fffd17 	ldw	r3,-12(fp)
 202c2a8:	180690fa 	slli	r3,r3,3
 202c2ac:	10c5883a 	add	r2,r2,r3
 202c2b0:	10800104 	addi	r2,r2,4
 202c2b4:	e0fffe17 	ldw	r3,-8(fp)
 202c2b8:	10c00015 	stw	r3,0(r2)
	
		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 202c2bc:	e0bfff17 	ldw	r2,-4(fp)
 202c2c0:	10001926 	beq	r2,zero,202c328 <alt_irq_register+0xf4>
 202c2c4:	e0bffd17 	ldw	r2,-12(fp)
 202c2c8:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202c2cc:	0005303a 	rdctl	r2,status
 202c2d0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202c2d4:	e0fff717 	ldw	r3,-36(fp)
 202c2d8:	00bfff84 	movi	r2,-2
 202c2dc:	1884703a 	and	r2,r3,r2
 202c2e0:	1001703a 	wrctl	status,r2
  
  return context;
 202c2e4:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202c2e8:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 202c2ec:	00c00044 	movi	r3,1
 202c2f0:	e0bff317 	ldw	r2,-52(fp)
 202c2f4:	1884983a 	sll	r2,r3,r2
 202c2f8:	1007883a 	mov	r3,r2
 202c2fc:	d0a80917 	ldw	r2,-24540(gp)
 202c300:	1884b03a 	or	r2,r3,r2
 202c304:	d0a80915 	stw	r2,-24540(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202c308:	d0a80917 	ldw	r2,-24540(gp)
 202c30c:	100170fa 	wrctl	ienable,r2
 202c310:	e0bff817 	ldw	r2,-32(fp)
 202c314:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202c318:	e0bff917 	ldw	r2,-28(fp)
 202c31c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202c320:	0005883a 	mov	r2,zero
 202c324:	00001906 	br	202c38c <alt_irq_register+0x158>
 202c328:	e0bffd17 	ldw	r2,-12(fp)
 202c32c:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202c330:	0005303a 	rdctl	r2,status
 202c334:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202c338:	e0fffa17 	ldw	r3,-24(fp)
 202c33c:	00bfff84 	movi	r2,-2
 202c340:	1884703a 	and	r2,r3,r2
 202c344:	1001703a 	wrctl	status,r2
  
  return context;
 202c348:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202c34c:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 202c350:	00c00044 	movi	r3,1
 202c354:	e0bff517 	ldw	r2,-44(fp)
 202c358:	1884983a 	sll	r2,r3,r2
 202c35c:	0084303a 	nor	r2,zero,r2
 202c360:	1007883a 	mov	r3,r2
 202c364:	d0a80917 	ldw	r2,-24540(gp)
 202c368:	1884703a 	and	r2,r3,r2
 202c36c:	d0a80915 	stw	r2,-24540(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202c370:	d0a80917 	ldw	r2,-24540(gp)
 202c374:	100170fa 	wrctl	ienable,r2
 202c378:	e0bffb17 	ldw	r2,-20(fp)
 202c37c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202c380:	e0bffc17 	ldw	r2,-16(fp)
 202c384:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202c388:	0005883a 	mov	r2,zero
 202c38c:	e0bff215 	stw	r2,-56(fp)
	
		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}
    
	return rc; 
 202c390:	e0bff217 	ldw	r2,-56(fp)
}
 202c394:	e037883a 	mov	sp,fp
 202c398:	df000017 	ldw	fp,0(sp)
 202c39c:	dec00104 	addi	sp,sp,4
 202c3a0:	f800283a 	ret

0202c3a4 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 202c3a4:	defff504 	addi	sp,sp,-44
 202c3a8:	df000a15 	stw	fp,40(sp)
 202c3ac:	df000a04 	addi	fp,sp,40
 202c3b0:	e13ffc15 	stw	r4,-16(fp)
 202c3b4:	e17ffd15 	stw	r5,-12(fp)
 202c3b8:	e1bffe15 	stw	r6,-8(fp)
 202c3bc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 202c3c0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 202c3c4:	d0a80a17 	ldw	r2,-24536(gp)
  
  if (alt_ticks_per_second ())
 202c3c8:	10003c26 	beq	r2,zero,202c4bc <alt_alarm_start+0x118>
  {
    if (alarm)
 202c3cc:	e0bffc17 	ldw	r2,-16(fp)
 202c3d0:	10003826 	beq	r2,zero,202c4b4 <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 202c3d4:	e0bffc17 	ldw	r2,-16(fp)
 202c3d8:	e0fffe17 	ldw	r3,-8(fp)
 202c3dc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 202c3e0:	e0bffc17 	ldw	r2,-16(fp)
 202c3e4:	e0ffff17 	ldw	r3,-4(fp)
 202c3e8:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202c3ec:	0005303a 	rdctl	r2,status
 202c3f0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202c3f4:	e0fff917 	ldw	r3,-28(fp)
 202c3f8:	00bfff84 	movi	r2,-2
 202c3fc:	1884703a 	and	r2,r3,r2
 202c400:	1001703a 	wrctl	status,r2
  
  return context;
 202c404:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 202c408:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 202c40c:	d0a80b17 	ldw	r2,-24532(gp)
      
      current_nticks = alt_nticks();
 202c410:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 202c414:	e0fffd17 	ldw	r3,-12(fp)
 202c418:	e0bff617 	ldw	r2,-40(fp)
 202c41c:	1885883a 	add	r2,r3,r2
 202c420:	10c00044 	addi	r3,r2,1
 202c424:	e0bffc17 	ldw	r2,-16(fp)
 202c428:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 202c42c:	e0bffc17 	ldw	r2,-16(fp)
 202c430:	10c00217 	ldw	r3,8(r2)
 202c434:	e0bff617 	ldw	r2,-40(fp)
 202c438:	1880042e 	bgeu	r3,r2,202c44c <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 202c43c:	e0bffc17 	ldw	r2,-16(fp)
 202c440:	00c00044 	movi	r3,1
 202c444:	10c00405 	stb	r3,16(r2)
 202c448:	00000206 	br	202c454 <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 202c44c:	e0bffc17 	ldw	r2,-16(fp)
 202c450:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 202c454:	e0bffc17 	ldw	r2,-16(fp)
 202c458:	d0e01c04 	addi	r3,gp,-32656
 202c45c:	e0fffa15 	stw	r3,-24(fp)
 202c460:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 202c464:	e0bffb17 	ldw	r2,-20(fp)
 202c468:	e0fffa17 	ldw	r3,-24(fp)
 202c46c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 202c470:	e0bffa17 	ldw	r2,-24(fp)
 202c474:	10c00017 	ldw	r3,0(r2)
 202c478:	e0bffb17 	ldw	r2,-20(fp)
 202c47c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 202c480:	e0bffa17 	ldw	r2,-24(fp)
 202c484:	10800017 	ldw	r2,0(r2)
 202c488:	e0fffb17 	ldw	r3,-20(fp)
 202c48c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 202c490:	e0bffa17 	ldw	r2,-24(fp)
 202c494:	e0fffb17 	ldw	r3,-20(fp)
 202c498:	10c00015 	stw	r3,0(r2)
 202c49c:	e0bff817 	ldw	r2,-32(fp)
 202c4a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202c4a4:	e0bff717 	ldw	r2,-36(fp)
 202c4a8:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 202c4ac:	0005883a 	mov	r2,zero
 202c4b0:	00000306 	br	202c4c0 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 202c4b4:	00bffa84 	movi	r2,-22
 202c4b8:	00000106 	br	202c4c0 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 202c4bc:	00bfde84 	movi	r2,-134
  }
}
 202c4c0:	e037883a 	mov	sp,fp
 202c4c4:	df000017 	ldw	fp,0(sp)
 202c4c8:	dec00104 	addi	sp,sp,4
 202c4cc:	f800283a 	ret

0202c4d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202c4d0:	defffe04 	addi	sp,sp,-8
 202c4d4:	dfc00115 	stw	ra,4(sp)
 202c4d8:	df000015 	stw	fp,0(sp)
 202c4dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202c4e0:	d0a01a17 	ldw	r2,-32664(gp)
 202c4e4:	10000326 	beq	r2,zero,202c4f4 <alt_get_errno+0x24>
 202c4e8:	d0a01a17 	ldw	r2,-32664(gp)
 202c4ec:	103ee83a 	callr	r2
 202c4f0:	00000106 	br	202c4f8 <alt_get_errno+0x28>
 202c4f4:	d0a7ce04 	addi	r2,gp,-24776
}
 202c4f8:	e037883a 	mov	sp,fp
 202c4fc:	dfc00117 	ldw	ra,4(sp)
 202c500:	df000017 	ldw	fp,0(sp)
 202c504:	dec00204 	addi	sp,sp,8
 202c508:	f800283a 	ret

0202c50c <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 202c50c:	defffb04 	addi	sp,sp,-20
 202c510:	dfc00415 	stw	ra,16(sp)
 202c514:	df000315 	stw	fp,12(sp)
 202c518:	df000304 	addi	fp,sp,12
 202c51c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 202c520:	e0bfff17 	ldw	r2,-4(fp)
 202c524:	10000616 	blt	r2,zero,202c540 <alt_close+0x34>
 202c528:	e0bfff17 	ldw	r2,-4(fp)
 202c52c:	10c00324 	muli	r3,r2,12
 202c530:	00808134 	movhi	r2,516
 202c534:	1090e704 	addi	r2,r2,17308
 202c538:	1885883a 	add	r2,r3,r2
 202c53c:	00000106 	br	202c544 <alt_close+0x38>
 202c540:	0005883a 	mov	r2,zero
 202c544:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 202c548:	e0bffd17 	ldw	r2,-12(fp)
 202c54c:	10001926 	beq	r2,zero,202c5b4 <alt_close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 202c550:	e0bffd17 	ldw	r2,-12(fp)
 202c554:	10800017 	ldw	r2,0(r2)
 202c558:	10800417 	ldw	r2,16(r2)
 202c55c:	10000626 	beq	r2,zero,202c578 <alt_close+0x6c>
 202c560:	e0bffd17 	ldw	r2,-12(fp)
 202c564:	10800017 	ldw	r2,0(r2)
 202c568:	10800417 	ldw	r2,16(r2)
 202c56c:	e13ffd17 	ldw	r4,-12(fp)
 202c570:	103ee83a 	callr	r2
 202c574:	00000106 	br	202c57c <alt_close+0x70>
 202c578:	0005883a 	mov	r2,zero
 202c57c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 202c580:	e13fff17 	ldw	r4,-4(fp)
 202c584:	20130700 	call	2013070 <alt_release_fd>
    if (rval < 0)
 202c588:	e0bffe17 	ldw	r2,-8(fp)
 202c58c:	1000070e 	bge	r2,zero,202c5ac <alt_close+0xa0>
    {
      ALT_ERRNO = -rval;
 202c590:	202c4d00 	call	202c4d0 <alt_get_errno>
 202c594:	1007883a 	mov	r3,r2
 202c598:	e0bffe17 	ldw	r2,-8(fp)
 202c59c:	0085c83a 	sub	r2,zero,r2
 202c5a0:	18800015 	stw	r2,0(r3)
      return -1;
 202c5a4:	00bfffc4 	movi	r2,-1
 202c5a8:	00000706 	br	202c5c8 <alt_close+0xbc>
    }
    return 0;
 202c5ac:	0005883a 	mov	r2,zero
 202c5b0:	00000506 	br	202c5c8 <alt_close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 202c5b4:	202c4d00 	call	202c4d0 <alt_get_errno>
 202c5b8:	1007883a 	mov	r3,r2
 202c5bc:	00801444 	movi	r2,81
 202c5c0:	18800015 	stw	r2,0(r3)
    return -1;
 202c5c4:	00bfffc4 	movi	r2,-1
  }
}
 202c5c8:	e037883a 	mov	sp,fp
 202c5cc:	dfc00117 	ldw	ra,4(sp)
 202c5d0:	df000017 	ldw	fp,0(sp)
 202c5d4:	dec00204 	addi	sp,sp,8
 202c5d8:	f800283a 	ret

0202c5dc <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 202c5dc:	defffd04 	addi	sp,sp,-12
 202c5e0:	df000215 	stw	fp,8(sp)
 202c5e4:	df000204 	addi	fp,sp,8
 202c5e8:	e13ffe15 	stw	r4,-8(fp)
 202c5ec:	e17fff15 	stw	r5,-4(fp)
  {
    ALT_FLUSH_DATA(i);
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 202c5f0:	0001883a 	nop
 202c5f4:	e037883a 	mov	sp,fp
 202c5f8:	df000017 	ldw	fp,0(sp)
 202c5fc:	dec00104 	addi	sp,sp,4
 202c600:	f800283a 	ret

0202c604 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
 202c604:	deffff04 	addi	sp,sp,-4
 202c608:	df000015 	stw	fp,0(sp)
 202c60c:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 202c610:	0001883a 	nop
 202c614:	e037883a 	mov	sp,fp
 202c618:	df000017 	ldw	fp,0(sp)
 202c61c:	dec00104 	addi	sp,sp,4
 202c620:	f800283a 	ret

0202c624 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202c624:	defffe04 	addi	sp,sp,-8
 202c628:	dfc00115 	stw	ra,4(sp)
 202c62c:	df000015 	stw	fp,0(sp)
 202c630:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202c634:	d0a01a17 	ldw	r2,-32664(gp)
 202c638:	10000326 	beq	r2,zero,202c648 <alt_get_errno+0x24>
 202c63c:	d0a01a17 	ldw	r2,-32664(gp)
 202c640:	103ee83a 	callr	r2
 202c644:	00000106 	br	202c64c <alt_get_errno+0x28>
 202c648:	d0a7ce04 	addi	r2,gp,-24776
}
 202c64c:	e037883a 	mov	sp,fp
 202c650:	dfc00117 	ldw	ra,4(sp)
 202c654:	df000017 	ldw	fp,0(sp)
 202c658:	dec00204 	addi	sp,sp,8
 202c65c:	f800283a 	ret

0202c660 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 202c660:	defffa04 	addi	sp,sp,-24
 202c664:	dfc00515 	stw	ra,20(sp)
 202c668:	df000415 	stw	fp,16(sp)
 202c66c:	df000404 	addi	fp,sp,16
 202c670:	e13ffe15 	stw	r4,-8(fp)
 202c674:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 202c678:	e0bffe17 	ldw	r2,-8(fp)
 202c67c:	10000326 	beq	r2,zero,202c68c <alt_dev_llist_insert+0x2c>
 202c680:	e0bffe17 	ldw	r2,-8(fp)
 202c684:	10800217 	ldw	r2,8(r2)
 202c688:	1000061e 	bne	r2,zero,202c6a4 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 202c68c:	202c6240 	call	202c624 <alt_get_errno>
 202c690:	1007883a 	mov	r3,r2
 202c694:	00800584 	movi	r2,22
 202c698:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 202c69c:	00bffa84 	movi	r2,-22
 202c6a0:	00001306 	br	202c6f0 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 202c6a4:	e0bffe17 	ldw	r2,-8(fp)
 202c6a8:	e0ffff17 	ldw	r3,-4(fp)
 202c6ac:	e0fffc15 	stw	r3,-16(fp)
 202c6b0:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 202c6b4:	e0bffd17 	ldw	r2,-12(fp)
 202c6b8:	e0fffc17 	ldw	r3,-16(fp)
 202c6bc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 202c6c0:	e0bffc17 	ldw	r2,-16(fp)
 202c6c4:	10c00017 	ldw	r3,0(r2)
 202c6c8:	e0bffd17 	ldw	r2,-12(fp)
 202c6cc:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 202c6d0:	e0bffc17 	ldw	r2,-16(fp)
 202c6d4:	10800017 	ldw	r2,0(r2)
 202c6d8:	e0fffd17 	ldw	r3,-12(fp)
 202c6dc:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 202c6e0:	e0bffc17 	ldw	r2,-16(fp)
 202c6e4:	e0fffd17 	ldw	r3,-12(fp)
 202c6e8:	10c00015 	stw	r3,0(r2)

  return 0;  
 202c6ec:	0005883a 	mov	r2,zero
}
 202c6f0:	e037883a 	mov	sp,fp
 202c6f4:	dfc00117 	ldw	ra,4(sp)
 202c6f8:	df000017 	ldw	fp,0(sp)
 202c6fc:	dec00204 	addi	sp,sp,8
 202c700:	f800283a 	ret

0202c704 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 202c704:	defffa04 	addi	sp,sp,-24
 202c708:	dfc00515 	stw	ra,20(sp)
 202c70c:	df000415 	stw	fp,16(sp)
 202c710:	df000404 	addi	fp,sp,16
 202c714:	e13ffe15 	stw	r4,-8(fp)
 202c718:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 202c71c:	e0bfff17 	ldw	r2,-4(fp)
 202c720:	10800017 	ldw	r2,0(r2)
 202c724:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 202c728:	e13ffe17 	ldw	r4,-8(fp)
 202c72c:	20075700 	call	2007570 <strlen>
 202c730:	10800044 	addi	r2,r2,1
 202c734:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 202c738:	00000d06 	br	202c770 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 202c73c:	e0bffc17 	ldw	r2,-16(fp)
 202c740:	10800217 	ldw	r2,8(r2)
 202c744:	e0fffd17 	ldw	r3,-12(fp)
 202c748:	180d883a 	mov	r6,r3
 202c74c:	e17ffe17 	ldw	r5,-8(fp)
 202c750:	1009883a 	mov	r4,r2
 202c754:	203cc100 	call	203cc10 <memcmp>
 202c758:	1000021e 	bne	r2,zero,202c764 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 202c75c:	e0bffc17 	ldw	r2,-16(fp)
 202c760:	00000706 	br	202c780 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 202c764:	e0bffc17 	ldw	r2,-16(fp)
 202c768:	10800017 	ldw	r2,0(r2)
 202c76c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 202c770:	e0fffc17 	ldw	r3,-16(fp)
 202c774:	e0bfff17 	ldw	r2,-4(fp)
 202c778:	18bff01e 	bne	r3,r2,202c73c <__alt_mem_mem_0+0xfd00c73c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 202c77c:	0005883a 	mov	r2,zero
}
 202c780:	e037883a 	mov	sp,fp
 202c784:	dfc00117 	ldw	ra,4(sp)
 202c788:	df000017 	ldw	fp,0(sp)
 202c78c:	dec00204 	addi	sp,sp,8
 202c790:	f800283a 	ret

0202c794 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 202c794:	defffb04 	addi	sp,sp,-20
 202c798:	dfc00415 	stw	ra,16(sp)
 202c79c:	df000315 	stw	fp,12(sp)
 202c7a0:	df000304 	addi	fp,sp,12
 202c7a4:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 202c7a8:	d0a00617 	ldw	r2,-32744(gp)
 202c7ac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 202c7b0:	00003106 	br	202c878 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 202c7b4:	e0bffd17 	ldw	r2,-12(fp)
 202c7b8:	10800217 	ldw	r2,8(r2)
 202c7bc:	1009883a 	mov	r4,r2
 202c7c0:	20075700 	call	2007570 <strlen>
 202c7c4:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 202c7c8:	e0bffd17 	ldw	r2,-12(fp)
 202c7cc:	10c00217 	ldw	r3,8(r2)
 202c7d0:	e0bffe17 	ldw	r2,-8(fp)
 202c7d4:	10bfffc4 	addi	r2,r2,-1
 202c7d8:	1885883a 	add	r2,r3,r2
 202c7dc:	10800003 	ldbu	r2,0(r2)
 202c7e0:	10803fcc 	andi	r2,r2,255
 202c7e4:	1080201c 	xori	r2,r2,128
 202c7e8:	10bfe004 	addi	r2,r2,-128
 202c7ec:	10800bd8 	cmpnei	r2,r2,47
 202c7f0:	1000031e 	bne	r2,zero,202c800 <alt_find_file+0x6c>
    {
      len -= 1;
 202c7f4:	e0bffe17 	ldw	r2,-8(fp)
 202c7f8:	10bfffc4 	addi	r2,r2,-1
 202c7fc:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 202c800:	e0bffe17 	ldw	r2,-8(fp)
 202c804:	e0ffff17 	ldw	r3,-4(fp)
 202c808:	1885883a 	add	r2,r3,r2
 202c80c:	10800003 	ldbu	r2,0(r2)
 202c810:	10803fcc 	andi	r2,r2,255
 202c814:	1080201c 	xori	r2,r2,128
 202c818:	10bfe004 	addi	r2,r2,-128
 202c81c:	10800be0 	cmpeqi	r2,r2,47
 202c820:	1000081e 	bne	r2,zero,202c844 <alt_find_file+0xb0>
 202c824:	e0bffe17 	ldw	r2,-8(fp)
 202c828:	e0ffff17 	ldw	r3,-4(fp)
 202c82c:	1885883a 	add	r2,r3,r2
 202c830:	10800003 	ldbu	r2,0(r2)
 202c834:	10803fcc 	andi	r2,r2,255
 202c838:	1080201c 	xori	r2,r2,128
 202c83c:	10bfe004 	addi	r2,r2,-128
 202c840:	10000a1e 	bne	r2,zero,202c86c <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 202c844:	e0bffd17 	ldw	r2,-12(fp)
 202c848:	10800217 	ldw	r2,8(r2)
 202c84c:	e0fffe17 	ldw	r3,-8(fp)
 202c850:	180d883a 	mov	r6,r3
 202c854:	e17fff17 	ldw	r5,-4(fp)
 202c858:	1009883a 	mov	r4,r2
 202c85c:	203cc100 	call	203cc10 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 202c860:	1000021e 	bne	r2,zero,202c86c <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 202c864:	e0bffd17 	ldw	r2,-12(fp)
 202c868:	00000706 	br	202c888 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 202c86c:	e0bffd17 	ldw	r2,-12(fp)
 202c870:	10800017 	ldw	r2,0(r2)
 202c874:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 202c878:	e0fffd17 	ldw	r3,-12(fp)
 202c87c:	d0a00604 	addi	r2,gp,-32744
 202c880:	18bfcc1e 	bne	r3,r2,202c7b4 <__alt_mem_mem_0+0xfd00c7b4>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 202c884:	0005883a 	mov	r2,zero
}
 202c888:	e037883a 	mov	sp,fp
 202c88c:	dfc00117 	ldw	ra,4(sp)
 202c890:	df000017 	ldw	fp,0(sp)
 202c894:	dec00204 	addi	sp,sp,8
 202c898:	f800283a 	ret

0202c89c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 202c89c:	defff804 	addi	sp,sp,-32
 202c8a0:	dfc00715 	stw	ra,28(sp)
 202c8a4:	df000615 	stw	fp,24(sp)
 202c8a8:	df000604 	addi	fp,sp,24
 202c8ac:	e13ffe15 	stw	r4,-8(fp)
  alt_32 i;
  int rc = -EMFILE;
 202c8b0:	00bffa04 	movi	r2,-24
 202c8b4:	e0bffb15 	stw	r2,-20(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 202c8b8:	d0a7e717 	ldw	r2,-24676(gp)
 202c8bc:	e0bffc15 	stw	r2,-16(fp)
 202c8c0:	e03ffd0d 	sth	zero,-12(fp)
 202c8c4:	e0bffd0b 	ldhu	r2,-12(fp)
 202c8c8:	100b883a 	mov	r5,r2
 202c8cc:	e13ffc17 	ldw	r4,-16(fp)
 202c8d0:	200dfa00 	call	200dfa0 <xQueueSemaphoreTake>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 202c8d4:	e03ffa15 	stw	zero,-24(fp)
 202c8d8:	00001906 	br	202c940 <alt_get_fd+0xa4>
  {
    if (!alt_fd_list[i].dev)
 202c8dc:	00808134 	movhi	r2,516
 202c8e0:	1090e704 	addi	r2,r2,17308
 202c8e4:	e0fffa17 	ldw	r3,-24(fp)
 202c8e8:	18c00324 	muli	r3,r3,12
 202c8ec:	10c5883a 	add	r2,r2,r3
 202c8f0:	10800017 	ldw	r2,0(r2)
 202c8f4:	10000f1e 	bne	r2,zero,202c934 <alt_get_fd+0x98>
    {
      alt_fd_list[i].dev = dev;
 202c8f8:	00808134 	movhi	r2,516
 202c8fc:	1090e704 	addi	r2,r2,17308
 202c900:	e0fffa17 	ldw	r3,-24(fp)
 202c904:	18c00324 	muli	r3,r3,12
 202c908:	10c5883a 	add	r2,r2,r3
 202c90c:	e0fffe17 	ldw	r3,-8(fp)
 202c910:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 202c914:	d0e00a17 	ldw	r3,-32728(gp)
 202c918:	e0bffa17 	ldw	r2,-24(fp)
 202c91c:	1880020e 	bge	r3,r2,202c928 <alt_get_fd+0x8c>
      {
        alt_max_fd = i;
 202c920:	e0bffa17 	ldw	r2,-24(fp)
 202c924:	d0a00a15 	stw	r2,-32728(gp)
      }
      rc = i;
 202c928:	e0bffa17 	ldw	r2,-24(fp)
 202c92c:	e0bffb15 	stw	r2,-20(fp)
      goto alt_get_fd_exit;
 202c930:	00000606 	br	202c94c <alt_get_fd+0xb0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 202c934:	e0bffa17 	ldw	r2,-24(fp)
 202c938:	10800044 	addi	r2,r2,1
 202c93c:	e0bffa15 	stw	r2,-24(fp)
 202c940:	e0bffa17 	ldw	r2,-24(fp)
 202c944:	10800810 	cmplti	r2,r2,32
 202c948:	103fe41e 	bne	r2,zero,202c8dc <__alt_mem_mem_0+0xfd00c8dc>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 202c94c:	d0a7e717 	ldw	r2,-24676(gp)
 202c950:	000f883a 	mov	r7,zero
 202c954:	000d883a 	mov	r6,zero
 202c958:	000b883a 	mov	r5,zero
 202c95c:	1009883a 	mov	r4,r2
 202c960:	200da140 	call	200da14 <xQueueGenericSend>

  return rc;
 202c964:	e0bffb17 	ldw	r2,-20(fp)
}
 202c968:	e037883a 	mov	sp,fp
 202c96c:	dfc00117 	ldw	ra,4(sp)
 202c970:	df000017 	ldw	fp,0(sp)
 202c974:	dec00204 	addi	sp,sp,8
 202c978:	f800283a 	ret

0202c97c <gettimeofday>:
 */
 

#if defined (__GNUC__) && (__GNUC__ >= 4)
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, void *ptimezone_vptr)
{
 202c97c:	defff404 	addi	sp,sp,-48
 202c980:	dfc00b15 	stw	ra,44(sp)
 202c984:	df000a15 	stw	fp,40(sp)
 202c988:	dd000915 	stw	r20,36(sp)
 202c98c:	dcc00815 	stw	r19,32(sp)
 202c990:	dc800715 	stw	r18,28(sp)
 202c994:	dc400615 	stw	r17,24(sp)
 202c998:	dc000515 	stw	r16,20(sp)
 202c99c:	df000a04 	addi	fp,sp,40
 202c9a0:	e13ff915 	stw	r4,-28(fp)
 202c9a4:	e17ffa15 	stw	r5,-24(fp)
  struct timezone *ptimezone = (struct timezone*)ptimezone_vptr;
 202c9a8:	e0bffa17 	ldw	r2,-24(fp)
 202c9ac:	e0bff615 	stw	r2,-40(fp)
 202c9b0:	d0a80b17 	ldw	r2,-24532(gp)
#else
int ALT_GETTIMEOFDAY (struct timeval  *ptimeval, struct timezone *ptimezone)
{
#endif
  
  alt_u32 nticks = alt_nticks (); 
 202c9b4:	e0bff715 	stw	r2,-36(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 202c9b8:	d0a80a17 	ldw	r2,-24536(gp)
  alt_u32 tick_rate = alt_ticks_per_second ();
 202c9bc:	e0bff815 	stw	r2,-32(fp)
   * non-zero system clock rate. If the system clock is not running, an error
   * is generated and the contents of "ptimeval" and "ptimezone" are not
   * updated.
   */

  if (tick_rate)
 202c9c0:	e0bff817 	ldw	r2,-32(fp)
 202c9c4:	10005f26 	beq	r2,zero,202cb44 <gettimeofday+0x1c8>
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
 202c9c8:	d0a80717 	ldw	r2,-24548(gp)
 202c9cc:	1029883a 	mov	r20,r2
 202c9d0:	e17ff817 	ldw	r5,-32(fp)
 202c9d4:	e13ff717 	ldw	r4,-36(fp)
 202c9d8:	200aca80 	call	200aca8 <__udivsi3>
 202c9dc:	a085883a 	add	r2,r20,r2
 202c9e0:	1007883a 	mov	r3,r2
 202c9e4:	e0bff917 	ldw	r2,-28(fp)
 202c9e8:	10c00015 	stw	r3,0(r2)
    ptimeval->tv_usec = alt_resettime.tv_usec +
 202c9ec:	d0a80817 	ldw	r2,-24544(gp)
 202c9f0:	1029883a 	mov	r20,r2
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
 202c9f4:	e0bff717 	ldw	r2,-36(fp)
 202c9f8:	1021883a 	mov	r16,r2
 202c9fc:	0023883a 	mov	r17,zero
 202ca00:	e17ff817 	ldw	r5,-32(fp)
 202ca04:	010003f4 	movhi	r4,15
 202ca08:	21109004 	addi	r4,r4,16960
 202ca0c:	200aca80 	call	200aca8 <__udivsi3>
 202ca10:	1025883a 	mov	r18,r2
 202ca14:	0027883a 	mov	r19,zero
 202ca18:	900d883a 	mov	r6,r18
 202ca1c:	980f883a 	mov	r7,r19
 202ca20:	8009883a 	mov	r4,r16
 202ca24:	880b883a 	mov	r5,r17
 202ca28:	20409900 	call	2040990 <__muldi3>
 202ca2c:	1009883a 	mov	r4,r2
 202ca30:	180b883a 	mov	r5,r3
 202ca34:	2005883a 	mov	r2,r4
 202ca38:	2807883a 	mov	r3,r5
 202ca3c:	018003f4 	movhi	r6,15
 202ca40:	31909004 	addi	r6,r6,16960
 202ca44:	000f883a 	mov	r7,zero
 202ca48:	1009883a 	mov	r4,r2
 202ca4c:	180b883a 	mov	r5,r3
 202ca50:	200a6780 	call	200a678 <__umoddi3>
 202ca54:	1009883a 	mov	r4,r2
 202ca58:	180b883a 	mov	r5,r3
 202ca5c:	2005883a 	mov	r2,r4
 202ca60:	2807883a 	mov	r3,r5
   */

  if (tick_rate)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
 202ca64:	a085883a 	add	r2,r20,r2
 202ca68:	1007883a 	mov	r3,r2
 202ca6c:	e0bff917 	ldw	r2,-28(fp)
 202ca70:	10c00115 	stw	r3,4(r2)
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
 202ca74:	00001406 	br	202cac8 <gettimeofday+0x14c>
      if (ptimeval->tv_sec <= 0)
 202ca78:	e0bff917 	ldw	r2,-28(fp)
 202ca7c:	10800017 	ldw	r2,0(r2)
 202ca80:	00800516 	blt	zero,r2,202ca98 <gettimeofday+0x11c>
      {
          ptimeval->tv_sec = 0;
 202ca84:	e0bff917 	ldw	r2,-28(fp)
 202ca88:	10000015 	stw	zero,0(r2)
          ptimeval->tv_usec = 0;
 202ca8c:	e0bff917 	ldw	r2,-28(fp)
 202ca90:	10000115 	stw	zero,4(r2)
          break;
 202ca94:	00000f06 	br	202cad4 <gettimeofday+0x158>
      }
      else
      {
          ptimeval->tv_sec--;
 202ca98:	e0bff917 	ldw	r2,-28(fp)
 202ca9c:	10800017 	ldw	r2,0(r2)
 202caa0:	10ffffc4 	addi	r3,r2,-1
 202caa4:	e0bff917 	ldw	r2,-28(fp)
 202caa8:	10c00015 	stw	r3,0(r2)
          ptimeval->tv_usec += ALT_US;
 202caac:	e0bff917 	ldw	r2,-28(fp)
 202cab0:	10c00117 	ldw	r3,4(r2)
 202cab4:	008003f4 	movhi	r2,15
 202cab8:	10909004 	addi	r2,r2,16960
 202cabc:	1887883a 	add	r3,r3,r2
 202cac0:	e0bff917 	ldw	r2,-28(fp)
 202cac4:	10c00115 	stw	r3,4(r2)
  {
    ptimeval->tv_sec  = alt_resettime.tv_sec  + nticks/tick_rate;
    ptimeval->tv_usec = alt_resettime.tv_usec +
     (alt_u32)(((alt_u64)nticks*(ALT_US/tick_rate))%ALT_US);
      
    while(ptimeval->tv_usec < 0) {
 202cac8:	e0bff917 	ldw	r2,-28(fp)
 202cacc:	10800117 	ldw	r2,4(r2)
 202cad0:	103fe916 	blt	r2,zero,202ca78 <__alt_mem_mem_0+0xfd00ca78>
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 202cad4:	00000c06 	br	202cb08 <gettimeofday+0x18c>
      ptimeval->tv_sec++;
 202cad8:	e0bff917 	ldw	r2,-28(fp)
 202cadc:	10800017 	ldw	r2,0(r2)
 202cae0:	10c00044 	addi	r3,r2,1
 202cae4:	e0bff917 	ldw	r2,-28(fp)
 202cae8:	10c00015 	stw	r3,0(r2)
      ptimeval->tv_usec -= ALT_US;
 202caec:	e0bff917 	ldw	r2,-28(fp)
 202caf0:	10c00117 	ldw	r3,4(r2)
 202caf4:	00bffc74 	movhi	r2,65521
 202caf8:	10af7004 	addi	r2,r2,-16960
 202cafc:	1887883a 	add	r3,r3,r2
 202cb00:	e0bff917 	ldw	r2,-28(fp)
 202cb04:	10c00115 	stw	r3,4(r2)
          ptimeval->tv_sec--;
          ptimeval->tv_usec += ALT_US;
      }
    }
    
    while(ptimeval->tv_usec >= ALT_US) {
 202cb08:	e0bff917 	ldw	r2,-28(fp)
 202cb0c:	10c00117 	ldw	r3,4(r2)
 202cb10:	008003f4 	movhi	r2,15
 202cb14:	10908fc4 	addi	r2,r2,16959
 202cb18:	10ffef16 	blt	r2,r3,202cad8 <__alt_mem_mem_0+0xfd00cad8>
      ptimeval->tv_sec++;
      ptimeval->tv_usec -= ALT_US;
    }
      
    if (ptimezone)
 202cb1c:	e0bff617 	ldw	r2,-40(fp)
 202cb20:	10000626 	beq	r2,zero,202cb3c <gettimeofday+0x1c0>
    { 
      ptimezone->tz_minuteswest = alt_timezone.tz_minuteswest;
 202cb24:	d0e80517 	ldw	r3,-24556(gp)
 202cb28:	e0bff617 	ldw	r2,-40(fp)
 202cb2c:	10c00015 	stw	r3,0(r2)
      ptimezone->tz_dsttime     = alt_timezone.tz_dsttime;
 202cb30:	d0e80617 	ldw	r3,-24552(gp)
 202cb34:	e0bff617 	ldw	r2,-40(fp)
 202cb38:	10c00115 	stw	r3,4(r2)
    }

    return 0;
 202cb3c:	0005883a 	mov	r2,zero
 202cb40:	00000106 	br	202cb48 <gettimeofday+0x1cc>
  }

  return -ENOTSUP;
 202cb44:	00bfde84 	movi	r2,-134
}
 202cb48:	e6fffb04 	addi	sp,fp,-20
 202cb4c:	dfc00617 	ldw	ra,24(sp)
 202cb50:	df000517 	ldw	fp,20(sp)
 202cb54:	dd000417 	ldw	r20,16(sp)
 202cb58:	dcc00317 	ldw	r19,12(sp)
 202cb5c:	dc800217 	ldw	r18,8(sp)
 202cb60:	dc400117 	ldw	r17,4(sp)
 202cb64:	dc000017 	ldw	r16,0(sp)
 202cb68:	dec00704 	addi	sp,sp,28
 202cb6c:	f800283a 	ret

0202cb70 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
 202cb70:	defffe04 	addi	sp,sp,-8
 202cb74:	dfc00115 	stw	ra,4(sp)
 202cb78:	df000015 	stw	fp,0(sp)
 202cb7c:	d839883a 	mov	fp,sp
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
 202cb80:	01500004 	movi	r5,16384
 202cb84:	0009883a 	mov	r4,zero
 202cb88:	2038f3c0 	call	2038f3c <alt_icache_flush>
#endif
}
 202cb8c:	0001883a 	nop
 202cb90:	e037883a 	mov	sp,fp
 202cb94:	dfc00117 	ldw	ra,4(sp)
 202cb98:	df000017 	ldw	fp,0(sp)
 202cb9c:	dec00204 	addi	sp,sp,8
 202cba0:	f800283a 	ret

0202cba4 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 202cba4:	defff904 	addi	sp,sp,-28
 202cba8:	dfc00615 	stw	ra,24(sp)
 202cbac:	df000515 	stw	fp,20(sp)
 202cbb0:	df000504 	addi	fp,sp,20
 202cbb4:	e13ffc15 	stw	r4,-16(fp)
 202cbb8:	e17ffd15 	stw	r5,-12(fp)
 202cbbc:	e1bffe15 	stw	r6,-8(fp)
 202cbc0:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 202cbc4:	e0800217 	ldw	r2,8(fp)
 202cbc8:	d8800015 	stw	r2,0(sp)
 202cbcc:	e1ffff17 	ldw	r7,-4(fp)
 202cbd0:	e1bffe17 	ldw	r6,-8(fp)
 202cbd4:	e17ffd17 	ldw	r5,-12(fp)
 202cbd8:	e13ffc17 	ldw	r4,-16(fp)
 202cbdc:	202cd540 	call	202cd54 <alt_iic_isr_register>
}  
 202cbe0:	e037883a 	mov	sp,fp
 202cbe4:	dfc00117 	ldw	ra,4(sp)
 202cbe8:	df000017 	ldw	fp,0(sp)
 202cbec:	dec00204 	addi	sp,sp,8
 202cbf0:	f800283a 	ret

0202cbf4 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 202cbf4:	defff904 	addi	sp,sp,-28
 202cbf8:	df000615 	stw	fp,24(sp)
 202cbfc:	df000604 	addi	fp,sp,24
 202cc00:	e13ffe15 	stw	r4,-8(fp)
 202cc04:	e17fff15 	stw	r5,-4(fp)
 202cc08:	e0bfff17 	ldw	r2,-4(fp)
 202cc0c:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202cc10:	0005303a 	rdctl	r2,status
 202cc14:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202cc18:	e0fffb17 	ldw	r3,-20(fp)
 202cc1c:	00bfff84 	movi	r2,-2
 202cc20:	1884703a 	and	r2,r3,r2
 202cc24:	1001703a 	wrctl	status,r2
  
  return context;
 202cc28:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202cc2c:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 202cc30:	00c00044 	movi	r3,1
 202cc34:	e0bffa17 	ldw	r2,-24(fp)
 202cc38:	1884983a 	sll	r2,r3,r2
 202cc3c:	1007883a 	mov	r3,r2
 202cc40:	d0a80917 	ldw	r2,-24540(gp)
 202cc44:	1884b03a 	or	r2,r3,r2
 202cc48:	d0a80915 	stw	r2,-24540(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202cc4c:	d0a80917 	ldw	r2,-24540(gp)
 202cc50:	100170fa 	wrctl	ienable,r2
 202cc54:	e0bffc17 	ldw	r2,-16(fp)
 202cc58:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202cc5c:	e0bffd17 	ldw	r2,-12(fp)
 202cc60:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202cc64:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 202cc68:	0001883a 	nop
}
 202cc6c:	e037883a 	mov	sp,fp
 202cc70:	df000017 	ldw	fp,0(sp)
 202cc74:	dec00104 	addi	sp,sp,4
 202cc78:	f800283a 	ret

0202cc7c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 202cc7c:	defff904 	addi	sp,sp,-28
 202cc80:	df000615 	stw	fp,24(sp)
 202cc84:	df000604 	addi	fp,sp,24
 202cc88:	e13ffe15 	stw	r4,-8(fp)
 202cc8c:	e17fff15 	stw	r5,-4(fp)
 202cc90:	e0bfff17 	ldw	r2,-4(fp)
 202cc94:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202cc98:	0005303a 	rdctl	r2,status
 202cc9c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202cca0:	e0fffb17 	ldw	r3,-20(fp)
 202cca4:	00bfff84 	movi	r2,-2
 202cca8:	1884703a 	and	r2,r3,r2
 202ccac:	1001703a 	wrctl	status,r2
  
  return context;
 202ccb0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 202ccb4:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 202ccb8:	00c00044 	movi	r3,1
 202ccbc:	e0bffa17 	ldw	r2,-24(fp)
 202ccc0:	1884983a 	sll	r2,r3,r2
 202ccc4:	0084303a 	nor	r2,zero,r2
 202ccc8:	1007883a 	mov	r3,r2
 202cccc:	d0a80917 	ldw	r2,-24540(gp)
 202ccd0:	1884703a 	and	r2,r3,r2
 202ccd4:	d0a80915 	stw	r2,-24540(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 202ccd8:	d0a80917 	ldw	r2,-24540(gp)
 202ccdc:	100170fa 	wrctl	ienable,r2
 202cce0:	e0bffc17 	ldw	r2,-16(fp)
 202cce4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202cce8:	e0bffd17 	ldw	r2,-12(fp)
 202ccec:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 202ccf0:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 202ccf4:	0001883a 	nop
}
 202ccf8:	e037883a 	mov	sp,fp
 202ccfc:	df000017 	ldw	fp,0(sp)
 202cd00:	dec00104 	addi	sp,sp,4
 202cd04:	f800283a 	ret

0202cd08 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 202cd08:	defffc04 	addi	sp,sp,-16
 202cd0c:	df000315 	stw	fp,12(sp)
 202cd10:	df000304 	addi	fp,sp,12
 202cd14:	e13ffe15 	stw	r4,-8(fp)
 202cd18:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 202cd1c:	000530fa 	rdctl	r2,ienable
 202cd20:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 202cd24:	00c00044 	movi	r3,1
 202cd28:	e0bfff17 	ldw	r2,-4(fp)
 202cd2c:	1884983a 	sll	r2,r3,r2
 202cd30:	1007883a 	mov	r3,r2
 202cd34:	e0bffd17 	ldw	r2,-12(fp)
 202cd38:	1884703a 	and	r2,r3,r2
 202cd3c:	1004c03a 	cmpne	r2,r2,zero
 202cd40:	10803fcc 	andi	r2,r2,255
}
 202cd44:	e037883a 	mov	sp,fp
 202cd48:	df000017 	ldw	fp,0(sp)
 202cd4c:	dec00104 	addi	sp,sp,4
 202cd50:	f800283a 	ret

0202cd54 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 202cd54:	defff504 	addi	sp,sp,-44
 202cd58:	dfc00a15 	stw	ra,40(sp)
 202cd5c:	df000915 	stw	fp,36(sp)
 202cd60:	df000904 	addi	fp,sp,36
 202cd64:	e13ffc15 	stw	r4,-16(fp)
 202cd68:	e17ffd15 	stw	r5,-12(fp)
 202cd6c:	e1bffe15 	stw	r6,-8(fp)
 202cd70:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 202cd74:	00bffa84 	movi	r2,-22
 202cd78:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 202cd7c:	e0bffd17 	ldw	r2,-12(fp)
 202cd80:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 202cd84:	e0bff817 	ldw	r2,-32(fp)
 202cd88:	10800808 	cmpgei	r2,r2,32
 202cd8c:	1000271e 	bne	r2,zero,202ce2c <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202cd90:	0005303a 	rdctl	r2,status
 202cd94:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202cd98:	e0fffb17 	ldw	r3,-20(fp)
 202cd9c:	00bfff84 	movi	r2,-2
 202cda0:	1884703a 	and	r2,r3,r2
 202cda4:	1001703a 	wrctl	status,r2
  
  return context;
 202cda8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 202cdac:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 202cdb0:	008085f4 	movhi	r2,535
 202cdb4:	10a96904 	addi	r2,r2,-23132
 202cdb8:	e0fff817 	ldw	r3,-32(fp)
 202cdbc:	180690fa 	slli	r3,r3,3
 202cdc0:	10c5883a 	add	r2,r2,r3
 202cdc4:	e0fffe17 	ldw	r3,-8(fp)
 202cdc8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 202cdcc:	008085f4 	movhi	r2,535
 202cdd0:	10a96904 	addi	r2,r2,-23132
 202cdd4:	e0fff817 	ldw	r3,-32(fp)
 202cdd8:	180690fa 	slli	r3,r3,3
 202cddc:	10c5883a 	add	r2,r2,r3
 202cde0:	10800104 	addi	r2,r2,4
 202cde4:	e0ffff17 	ldw	r3,-4(fp)
 202cde8:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 202cdec:	e0bffe17 	ldw	r2,-8(fp)
 202cdf0:	10000526 	beq	r2,zero,202ce08 <alt_iic_isr_register+0xb4>
 202cdf4:	e0bff817 	ldw	r2,-32(fp)
 202cdf8:	100b883a 	mov	r5,r2
 202cdfc:	e13ffc17 	ldw	r4,-16(fp)
 202ce00:	202cbf40 	call	202cbf4 <alt_ic_irq_enable>
 202ce04:	00000406 	br	202ce18 <alt_iic_isr_register+0xc4>
 202ce08:	e0bff817 	ldw	r2,-32(fp)
 202ce0c:	100b883a 	mov	r5,r2
 202ce10:	e13ffc17 	ldw	r4,-16(fp)
 202ce14:	202cc7c0 	call	202cc7c <alt_ic_irq_disable>
 202ce18:	e0bff715 	stw	r2,-36(fp)
 202ce1c:	e0bffa17 	ldw	r2,-24(fp)
 202ce20:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202ce24:	e0bff917 	ldw	r2,-28(fp)
 202ce28:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 202ce2c:	e0bff717 	ldw	r2,-36(fp)
}
 202ce30:	e037883a 	mov	sp,fp
 202ce34:	dfc00117 	ldw	ra,4(sp)
 202ce38:	df000017 	ldw	fp,0(sp)
 202ce3c:	dec00204 	addi	sp,sp,8
 202ce40:	f800283a 	ret

0202ce44 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202ce44:	defffe04 	addi	sp,sp,-8
 202ce48:	dfc00115 	stw	ra,4(sp)
 202ce4c:	df000015 	stw	fp,0(sp)
 202ce50:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202ce54:	d0a01a17 	ldw	r2,-32664(gp)
 202ce58:	10000326 	beq	r2,zero,202ce68 <alt_get_errno+0x24>
 202ce5c:	d0a01a17 	ldw	r2,-32664(gp)
 202ce60:	103ee83a 	callr	r2
 202ce64:	00000106 	br	202ce6c <alt_get_errno+0x28>
 202ce68:	d0a7ce04 	addi	r2,gp,-24776
}
 202ce6c:	e037883a 	mov	sp,fp
 202ce70:	dfc00117 	ldw	ra,4(sp)
 202ce74:	df000017 	ldw	fp,0(sp)
 202ce78:	dec00204 	addi	sp,sp,8
 202ce7c:	f800283a 	ret

0202ce80 <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 202ce80:	defff904 	addi	sp,sp,-28
 202ce84:	dfc00615 	stw	ra,24(sp)
 202ce88:	df000515 	stw	fp,20(sp)
 202ce8c:	df000504 	addi	fp,sp,20
 202ce90:	e13ffd15 	stw	r4,-12(fp)
 202ce94:	e17ffe15 	stw	r5,-8(fp)
 202ce98:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 202ce9c:	e0bffd17 	ldw	r2,-12(fp)
 202cea0:	10000616 	blt	r2,zero,202cebc <alt_read+0x3c>
 202cea4:	e0bffd17 	ldw	r2,-12(fp)
 202cea8:	10c00324 	muli	r3,r2,12
 202ceac:	00808134 	movhi	r2,516
 202ceb0:	1090e704 	addi	r2,r2,17308
 202ceb4:	1885883a 	add	r2,r3,r2
 202ceb8:	00000106 	br	202cec0 <alt_read+0x40>
 202cebc:	0005883a 	mov	r2,zero
 202cec0:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 202cec4:	e0bffb17 	ldw	r2,-20(fp)
 202cec8:	10002226 	beq	r2,zero,202cf54 <alt_read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 202cecc:	e0bffb17 	ldw	r2,-20(fp)
 202ced0:	10800217 	ldw	r2,8(r2)
 202ced4:	108000cc 	andi	r2,r2,3
 202ced8:	10800060 	cmpeqi	r2,r2,1
 202cedc:	1000181e 	bne	r2,zero,202cf40 <alt_read+0xc0>
        (fd->dev->read))
 202cee0:	e0bffb17 	ldw	r2,-20(fp)
 202cee4:	10800017 	ldw	r2,0(r2)
 202cee8:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 202ceec:	10001426 	beq	r2,zero,202cf40 <alt_read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 202cef0:	e0bffb17 	ldw	r2,-20(fp)
 202cef4:	10800017 	ldw	r2,0(r2)
 202cef8:	10800517 	ldw	r2,20(r2)
 202cefc:	e0ffff17 	ldw	r3,-4(fp)
 202cf00:	180d883a 	mov	r6,r3
 202cf04:	e17ffe17 	ldw	r5,-8(fp)
 202cf08:	e13ffb17 	ldw	r4,-20(fp)
 202cf0c:	103ee83a 	callr	r2
 202cf10:	e0bffc15 	stw	r2,-16(fp)
 202cf14:	e0bffc17 	ldw	r2,-16(fp)
 202cf18:	1000070e 	bge	r2,zero,202cf38 <alt_read+0xb8>
        {
          ALT_ERRNO = -rval;
 202cf1c:	202ce440 	call	202ce44 <alt_get_errno>
 202cf20:	1007883a 	mov	r3,r2
 202cf24:	e0bffc17 	ldw	r2,-16(fp)
 202cf28:	0085c83a 	sub	r2,zero,r2
 202cf2c:	18800015 	stw	r2,0(r3)
          return -1;
 202cf30:	00bfffc4 	movi	r2,-1
 202cf34:	00000c06 	br	202cf68 <alt_read+0xe8>
        }
        return rval;
 202cf38:	e0bffc17 	ldw	r2,-16(fp)
 202cf3c:	00000a06 	br	202cf68 <alt_read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 202cf40:	202ce440 	call	202ce44 <alt_get_errno>
 202cf44:	1007883a 	mov	r3,r2
 202cf48:	00800344 	movi	r2,13
 202cf4c:	18800015 	stw	r2,0(r3)
 202cf50:	00000406 	br	202cf64 <alt_read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 202cf54:	202ce440 	call	202ce44 <alt_get_errno>
 202cf58:	1007883a 	mov	r3,r2
 202cf5c:	00801444 	movi	r2,81
 202cf60:	18800015 	stw	r2,0(r3)
  }
  return -1;
 202cf64:	00bfffc4 	movi	r2,-1
}
 202cf68:	e037883a 	mov	sp,fp
 202cf6c:	dfc00117 	ldw	ra,4(sp)
 202cf70:	df000017 	ldw	fp,0(sp)
 202cf74:	dec00204 	addi	sp,sp,8
 202cf78:	f800283a 	ret

0202cf7c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 202cf7c:	defffa04 	addi	sp,sp,-24
 202cf80:	df000515 	stw	fp,20(sp)
 202cf84:	df000504 	addi	fp,sp,20
 202cf88:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202cf8c:	0005303a 	rdctl	r2,status
 202cf90:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 202cf94:	e0fffc17 	ldw	r3,-16(fp)
 202cf98:	00bfff84 	movi	r2,-2
 202cf9c:	1884703a 	and	r2,r3,r2
 202cfa0:	1001703a 	wrctl	status,r2
  
  return context;
 202cfa4:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 202cfa8:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 202cfac:	e0bfff17 	ldw	r2,-4(fp)
 202cfb0:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 202cfb4:	e0bffd17 	ldw	r2,-12(fp)
 202cfb8:	10800017 	ldw	r2,0(r2)
 202cfbc:	e0fffd17 	ldw	r3,-12(fp)
 202cfc0:	18c00117 	ldw	r3,4(r3)
 202cfc4:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 202cfc8:	e0bffd17 	ldw	r2,-12(fp)
 202cfcc:	10800117 	ldw	r2,4(r2)
 202cfd0:	e0fffd17 	ldw	r3,-12(fp)
 202cfd4:	18c00017 	ldw	r3,0(r3)
 202cfd8:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 202cfdc:	e0bffd17 	ldw	r2,-12(fp)
 202cfe0:	e0fffd17 	ldw	r3,-12(fp)
 202cfe4:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 202cfe8:	e0bffd17 	ldw	r2,-12(fp)
 202cfec:	e0fffd17 	ldw	r3,-12(fp)
 202cff0:	10c00015 	stw	r3,0(r2)
 202cff4:	e0bffb17 	ldw	r2,-20(fp)
 202cff8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 202cffc:	e0bffe17 	ldw	r2,-8(fp)
 202d000:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 202d004:	0001883a 	nop
 202d008:	e037883a 	mov	sp,fp
 202d00c:	df000017 	ldw	fp,0(sp)
 202d010:	dec00104 	addi	sp,sp,4
 202d014:	f800283a 	ret

0202d018 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 202d018:	defffb04 	addi	sp,sp,-20
 202d01c:	dfc00415 	stw	ra,16(sp)
 202d020:	df000315 	stw	fp,12(sp)
 202d024:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 202d028:	d0a01c17 	ldw	r2,-32656(gp)
 202d02c:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 202d030:	d0a80b17 	ldw	r2,-24532(gp)
 202d034:	10800044 	addi	r2,r2,1
 202d038:	d0a80b15 	stw	r2,-24532(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 202d03c:	00002e06 	br	202d0f8 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 202d040:	e0bffd17 	ldw	r2,-12(fp)
 202d044:	10800017 	ldw	r2,0(r2)
 202d048:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 202d04c:	e0bffd17 	ldw	r2,-12(fp)
 202d050:	10800403 	ldbu	r2,16(r2)
 202d054:	10803fcc 	andi	r2,r2,255
 202d058:	10000426 	beq	r2,zero,202d06c <alt_tick+0x54>
 202d05c:	d0a80b17 	ldw	r2,-24532(gp)
 202d060:	1000021e 	bne	r2,zero,202d06c <alt_tick+0x54>
    {
      alarm->rollover = 0;
 202d064:	e0bffd17 	ldw	r2,-12(fp)
 202d068:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 202d06c:	e0bffd17 	ldw	r2,-12(fp)
 202d070:	10800217 	ldw	r2,8(r2)
 202d074:	d0e80b17 	ldw	r3,-24532(gp)
 202d078:	18801d36 	bltu	r3,r2,202d0f0 <alt_tick+0xd8>
 202d07c:	e0bffd17 	ldw	r2,-12(fp)
 202d080:	10800403 	ldbu	r2,16(r2)
 202d084:	10803fcc 	andi	r2,r2,255
 202d088:	1000191e 	bne	r2,zero,202d0f0 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 202d08c:	e0bffd17 	ldw	r2,-12(fp)
 202d090:	10800317 	ldw	r2,12(r2)
 202d094:	e0fffd17 	ldw	r3,-12(fp)
 202d098:	18c00517 	ldw	r3,20(r3)
 202d09c:	1809883a 	mov	r4,r3
 202d0a0:	103ee83a 	callr	r2
 202d0a4:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 202d0a8:	e0bfff17 	ldw	r2,-4(fp)
 202d0ac:	1000031e 	bne	r2,zero,202d0bc <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 202d0b0:	e13ffd17 	ldw	r4,-12(fp)
 202d0b4:	202cf7c0 	call	202cf7c <alt_alarm_stop>
 202d0b8:	00000d06 	br	202d0f0 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 202d0bc:	e0bffd17 	ldw	r2,-12(fp)
 202d0c0:	10c00217 	ldw	r3,8(r2)
 202d0c4:	e0bfff17 	ldw	r2,-4(fp)
 202d0c8:	1887883a 	add	r3,r3,r2
 202d0cc:	e0bffd17 	ldw	r2,-12(fp)
 202d0d0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 202d0d4:	e0bffd17 	ldw	r2,-12(fp)
 202d0d8:	10c00217 	ldw	r3,8(r2)
 202d0dc:	d0a80b17 	ldw	r2,-24532(gp)
 202d0e0:	1880032e 	bgeu	r3,r2,202d0f0 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 202d0e4:	e0bffd17 	ldw	r2,-12(fp)
 202d0e8:	00c00044 	movi	r3,1
 202d0ec:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 202d0f0:	e0bffe17 	ldw	r2,-8(fp)
 202d0f4:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 202d0f8:	e0fffd17 	ldw	r3,-12(fp)
 202d0fc:	d0a01c04 	addi	r2,gp,-32656
 202d100:	18bfcf1e 	bne	r3,r2,202d040 <__alt_mem_mem_0+0xfd00d040>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 202d104:	202c1e80 	call	202c1e8 <vPortSysTickHandler>
}
 202d108:	0001883a 	nop
 202d10c:	e037883a 	mov	sp,fp
 202d110:	dfc00117 	ldw	ra,4(sp)
 202d114:	df000017 	ldw	fp,0(sp)
 202d118:	dec00204 	addi	sp,sp,8
 202d11c:	f800283a 	ret

0202d120 <alt_uncached_malloc>:
 * Return pointer to the block of memory or NULL if can't allocate it.
 */

volatile void* 
alt_uncached_malloc(size_t size)
{
 202d120:	defffd04 	addi	sp,sp,-12
 202d124:	dfc00215 	stw	ra,8(sp)
 202d128:	df000115 	stw	fp,4(sp)
 202d12c:	df000104 	addi	fp,sp,4
 202d130:	e13fff15 	stw	r4,-4(fp)
  ALT_LINK_ERROR("alt_uncached_malloc() is not available because CPU is not configured to use bit 31 of address to bypass data cache");
  return NULL;
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Just use regular malloc. */
  return malloc(size);
 202d134:	e13fff17 	ldw	r4,-4(fp)
 202d138:	203cbe80 	call	203cbe8 <malloc>
#endif /* No data cache */
}
 202d13c:	e037883a 	mov	sp,fp
 202d140:	dfc00117 	ldw	ra,4(sp)
 202d144:	df000017 	ldw	fp,0(sp)
 202d148:	dec00204 	addi	sp,sp,8
 202d14c:	f800283a 	ret

0202d150 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 202d150:	defffd04 	addi	sp,sp,-12
 202d154:	dfc00215 	stw	ra,8(sp)
 202d158:	df000115 	stw	fp,4(sp)
 202d15c:	df000104 	addi	fp,sp,4
 202d160:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 202d164:	e13fff17 	ldw	r4,-4(fp)
 202d168:	2038de40 	call	2038de4 <alt_busy_sleep>
}
 202d16c:	e037883a 	mov	sp,fp
 202d170:	dfc00117 	ldw	ra,4(sp)
 202d174:	df000017 	ldw	fp,0(sp)
 202d178:	dec00204 	addi	sp,sp,8
 202d17c:	f800283a 	ret

0202d180 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 202d180:	defffe04 	addi	sp,sp,-8
 202d184:	dfc00115 	stw	ra,4(sp)
 202d188:	df000015 	stw	fp,0(sp)
 202d18c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 202d190:	d0a01a17 	ldw	r2,-32664(gp)
 202d194:	10000326 	beq	r2,zero,202d1a4 <alt_get_errno+0x24>
 202d198:	d0a01a17 	ldw	r2,-32664(gp)
 202d19c:	103ee83a 	callr	r2
 202d1a0:	00000106 	br	202d1a8 <alt_get_errno+0x28>
 202d1a4:	d0a7ce04 	addi	r2,gp,-24776
}
 202d1a8:	e037883a 	mov	sp,fp
 202d1ac:	dfc00117 	ldw	ra,4(sp)
 202d1b0:	df000017 	ldw	fp,0(sp)
 202d1b4:	dec00204 	addi	sp,sp,8
 202d1b8:	f800283a 	ret

0202d1bc <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 202d1bc:	defff904 	addi	sp,sp,-28
 202d1c0:	dfc00615 	stw	ra,24(sp)
 202d1c4:	df000515 	stw	fp,20(sp)
 202d1c8:	df000504 	addi	fp,sp,20
 202d1cc:	e13ffd15 	stw	r4,-12(fp)
 202d1d0:	e17ffe15 	stw	r5,-8(fp)
 202d1d4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 202d1d8:	e0bffd17 	ldw	r2,-12(fp)
 202d1dc:	10000616 	blt	r2,zero,202d1f8 <alt_write+0x3c>
 202d1e0:	e0bffd17 	ldw	r2,-12(fp)
 202d1e4:	10c00324 	muli	r3,r2,12
 202d1e8:	00808134 	movhi	r2,516
 202d1ec:	1090e704 	addi	r2,r2,17308
 202d1f0:	1885883a 	add	r2,r3,r2
 202d1f4:	00000106 	br	202d1fc <alt_write+0x40>
 202d1f8:	0005883a 	mov	r2,zero
 202d1fc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 202d200:	e0bffb17 	ldw	r2,-20(fp)
 202d204:	10002126 	beq	r2,zero,202d28c <alt_write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 202d208:	e0bffb17 	ldw	r2,-20(fp)
 202d20c:	10800217 	ldw	r2,8(r2)
 202d210:	108000cc 	andi	r2,r2,3
 202d214:	10001826 	beq	r2,zero,202d278 <alt_write+0xbc>
 202d218:	e0bffb17 	ldw	r2,-20(fp)
 202d21c:	10800017 	ldw	r2,0(r2)
 202d220:	10800617 	ldw	r2,24(r2)
 202d224:	10001426 	beq	r2,zero,202d278 <alt_write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 202d228:	e0bffb17 	ldw	r2,-20(fp)
 202d22c:	10800017 	ldw	r2,0(r2)
 202d230:	10800617 	ldw	r2,24(r2)
 202d234:	e0ffff17 	ldw	r3,-4(fp)
 202d238:	180d883a 	mov	r6,r3
 202d23c:	e17ffe17 	ldw	r5,-8(fp)
 202d240:	e13ffb17 	ldw	r4,-20(fp)
 202d244:	103ee83a 	callr	r2
 202d248:	e0bffc15 	stw	r2,-16(fp)
 202d24c:	e0bffc17 	ldw	r2,-16(fp)
 202d250:	1000070e 	bge	r2,zero,202d270 <alt_write+0xb4>
      {
        ALT_ERRNO = -rval;
 202d254:	202d1800 	call	202d180 <alt_get_errno>
 202d258:	1007883a 	mov	r3,r2
 202d25c:	e0bffc17 	ldw	r2,-16(fp)
 202d260:	0085c83a 	sub	r2,zero,r2
 202d264:	18800015 	stw	r2,0(r3)
        return -1;
 202d268:	00bfffc4 	movi	r2,-1
 202d26c:	00000c06 	br	202d2a0 <alt_write+0xe4>
      }
      return rval;
 202d270:	e0bffc17 	ldw	r2,-16(fp)
 202d274:	00000a06 	br	202d2a0 <alt_write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 202d278:	202d1800 	call	202d180 <alt_get_errno>
 202d27c:	1007883a 	mov	r3,r2
 202d280:	00800344 	movi	r2,13
 202d284:	18800015 	stw	r2,0(r3)
 202d288:	00000406 	br	202d29c <alt_write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 202d28c:	202d1800 	call	202d180 <alt_get_errno>
 202d290:	1007883a 	mov	r3,r2
 202d294:	00801444 	movi	r2,81
 202d298:	18800015 	stw	r2,0(r3)
  }
  return -1;
 202d29c:	00bfffc4 	movi	r2,-1
}
 202d2a0:	e037883a 	mov	sp,fp
 202d2a4:	dfc00117 	ldw	ra,4(sp)
 202d2a8:	df000017 	ldw	fp,0(sp)
 202d2ac:	dec00204 	addi	sp,sp,8
 202d2b0:	f800283a 	ret

0202d2b4 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 202d2b4:	deffff04 	addi	sp,sp,-4
 202d2b8:	df000015 	stw	fp,0(sp)
 202d2bc:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 202d2c0:	000170fa 	wrctl	ienable,zero
}
 202d2c4:	0001883a 	nop
 202d2c8:	e037883a 	mov	sp,fp
 202d2cc:	df000017 	ldw	fp,0(sp)
 202d2d0:	dec00104 	addi	sp,sp,4
 202d2d4:	f800283a 	ret

0202d2d8 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
 202d2d8:	deffff04 	addi	sp,sp,-4
 202d2dc:	df000015 	stw	fp,0(sp)
 202d2e0:	d839883a 	mov	fp,sp
}
 202d2e4:	0001883a 	nop
 202d2e8:	e037883a 	mov	sp,fp
 202d2ec:	df000017 	ldw	fp,0(sp)
 202d2f0:	dec00104 	addi	sp,sp,4
 202d2f4:	f800283a 	ret

0202d2f8 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
get_socket(int s)
{
 202d2f8:	defffd04 	addi	sp,sp,-12
 202d2fc:	df000215 	stw	fp,8(sp)
 202d300:	df000204 	addi	fp,sp,8
 202d304:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;

  s -= LWIP_SOCKET_OFFSET;
 202d308:	e0bfff17 	ldw	r2,-4(fp)
 202d30c:	10bff804 	addi	r2,r2,-32
 202d310:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 202d314:	e0bfff17 	ldw	r2,-4(fp)
 202d318:	10000316 	blt	r2,zero,202d328 <get_socket+0x30>
 202d31c:	e0bfff17 	ldw	r2,-4(fp)
 202d320:	10800a90 	cmplti	r2,r2,42
 202d324:	1000021e 	bne	r2,zero,202d330 <get_socket+0x38>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
 202d328:	0005883a 	mov	r2,zero
 202d32c:	00000c06 	br	202d360 <get_socket+0x68>
  }

  sock = &sockets[s];
 202d330:	e0bfff17 	ldw	r2,-4(fp)
 202d334:	10c00624 	muli	r3,r2,24
 202d338:	00808534 	movhi	r2,532
 202d33c:	109f2404 	addi	r2,r2,31888
 202d340:	1885883a 	add	r2,r3,r2
 202d344:	e0bffe15 	stw	r2,-8(fp)

  if (!sock->conn) {
 202d348:	e0bffe17 	ldw	r2,-8(fp)
 202d34c:	10800017 	ldw	r2,0(r2)
 202d350:	1000021e 	bne	r2,zero,202d35c <get_socket+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
 202d354:	0005883a 	mov	r2,zero
 202d358:	00000106 	br	202d360 <get_socket+0x68>
  }

  return sock;
 202d35c:	e0bffe17 	ldw	r2,-8(fp)
}
 202d360:	e037883a 	mov	sp,fp
 202d364:	df000017 	ldw	fp,0(sp)
 202d368:	dec00104 	addi	sp,sp,4
 202d36c:	f800283a 	ret

0202d370 <tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
 202d370:	defffe04 	addi	sp,sp,-8
 202d374:	df000115 	stw	fp,4(sp)
 202d378:	df000104 	addi	fp,sp,4
 202d37c:	e13fff15 	stw	r4,-4(fp)
	s -= LWIP_SOCKET_OFFSET;
 202d380:	e0bfff17 	ldw	r2,-4(fp)
 202d384:	10bff804 	addi	r2,r2,-32
 202d388:	e0bfff15 	stw	r2,-4(fp)

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 202d38c:	e0bfff17 	ldw	r2,-4(fp)
 202d390:	10000316 	blt	r2,zero,202d3a0 <tryget_socket+0x30>
 202d394:	e0bfff17 	ldw	r2,-4(fp)
 202d398:	10800a90 	cmplti	r2,r2,42
 202d39c:	1000021e 	bne	r2,zero,202d3a8 <tryget_socket+0x38>
    return NULL;
 202d3a0:	0005883a 	mov	r2,zero
 202d3a4:	00000e06 	br	202d3e0 <tryget_socket+0x70>
  }
  if (!sockets[s].conn) {
 202d3a8:	00808534 	movhi	r2,532
 202d3ac:	109f2404 	addi	r2,r2,31888
 202d3b0:	e0ffff17 	ldw	r3,-4(fp)
 202d3b4:	18c00624 	muli	r3,r3,24
 202d3b8:	10c5883a 	add	r2,r2,r3
 202d3bc:	10800017 	ldw	r2,0(r2)
 202d3c0:	1000021e 	bne	r2,zero,202d3cc <tryget_socket+0x5c>
    return NULL;
 202d3c4:	0005883a 	mov	r2,zero
 202d3c8:	00000506 	br	202d3e0 <tryget_socket+0x70>
  }
  return &sockets[s];
 202d3cc:	e0bfff17 	ldw	r2,-4(fp)
 202d3d0:	10c00624 	muli	r3,r2,24
 202d3d4:	00808534 	movhi	r2,532
 202d3d8:	109f2404 	addi	r2,r2,31888
 202d3dc:	1885883a 	add	r2,r3,r2
}
 202d3e0:	e037883a 	mov	sp,fp
 202d3e4:	df000017 	ldw	fp,0(sp)
 202d3e8:	dec00104 	addi	sp,sp,4
 202d3ec:	f800283a 	ret

0202d3f0 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
 202d3f0:	defffb04 	addi	sp,sp,-20
 202d3f4:	dfc00415 	stw	ra,16(sp)
 202d3f8:	df000315 	stw	fp,12(sp)
 202d3fc:	df000304 	addi	fp,sp,12
 202d400:	e13ffe15 	stw	r4,-8(fp)
 202d404:	e17fff15 	stw	r5,-4(fp)
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 202d408:	e03ffd15 	stw	zero,-12(fp)
 202d40c:	00005706 	br	202d56c <alloc_socket+0x17c>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
 202d410:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d414:	10000126 	beq	r2,zero,202d41c <alloc_socket+0x2c>
 202d418:	2010f300 	call	2010f30 <vTaskEnterCritical>
    if (!sockets[i].conn) {
 202d41c:	00808534 	movhi	r2,532
 202d420:	109f2404 	addi	r2,r2,31888
 202d424:	e0fffd17 	ldw	r3,-12(fp)
 202d428:	18c00624 	muli	r3,r3,24
 202d42c:	10c5883a 	add	r2,r2,r3
 202d430:	10800017 	ldw	r2,0(r2)
 202d434:	1000471e 	bne	r2,zero,202d554 <alloc_socket+0x164>
      sockets[i].conn       = newconn;
 202d438:	00808534 	movhi	r2,532
 202d43c:	109f2404 	addi	r2,r2,31888
 202d440:	e0fffd17 	ldw	r3,-12(fp)
 202d444:	18c00624 	muli	r3,r3,24
 202d448:	10c5883a 	add	r2,r2,r3
 202d44c:	e0fffe17 	ldw	r3,-8(fp)
 202d450:	10c00015 	stw	r3,0(r2)
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
 202d454:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d458:	10000126 	beq	r2,zero,202d460 <alloc_socket+0x70>
 202d45c:	2010f780 	call	2010f78 <vTaskExitCritical>
      sockets[i].lastdata   = NULL;
 202d460:	00808534 	movhi	r2,532
 202d464:	109f2404 	addi	r2,r2,31888
 202d468:	e0fffd17 	ldw	r3,-12(fp)
 202d46c:	18c00624 	muli	r3,r3,24
 202d470:	10c5883a 	add	r2,r2,r3
 202d474:	10800104 	addi	r2,r2,4
 202d478:	10000015 	stw	zero,0(r2)
      sockets[i].lastoffset = 0;
 202d47c:	00808534 	movhi	r2,532
 202d480:	109f2404 	addi	r2,r2,31888
 202d484:	e0fffd17 	ldw	r3,-12(fp)
 202d488:	18c00624 	muli	r3,r3,24
 202d48c:	10c5883a 	add	r2,r2,r3
 202d490:	10800204 	addi	r2,r2,8
 202d494:	1000000d 	sth	zero,0(r2)
      sockets[i].rcvevent   = 0;
 202d498:	00808534 	movhi	r2,532
 202d49c:	109f2404 	addi	r2,r2,31888
 202d4a0:	e0fffd17 	ldw	r3,-12(fp)
 202d4a4:	18c00624 	muli	r3,r3,24
 202d4a8:	10c5883a 	add	r2,r2,r3
 202d4ac:	10800284 	addi	r2,r2,10
 202d4b0:	1000000d 	sth	zero,0(r2)
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 202d4b4:	e0bffe17 	ldw	r2,-8(fp)
 202d4b8:	10800017 	ldw	r2,0(r2)
 202d4bc:	10800418 	cmpnei	r2,r2,16
 202d4c0:	1000021e 	bne	r2,zero,202d4cc <alloc_socket+0xdc>
 202d4c4:	e0bfff17 	ldw	r2,-4(fp)
 202d4c8:	10000226 	beq	r2,zero,202d4d4 <alloc_socket+0xe4>
 202d4cc:	00800044 	movi	r2,1
 202d4d0:	00000106 	br	202d4d8 <alloc_socket+0xe8>
 202d4d4:	0005883a 	mov	r2,zero
 202d4d8:	1009883a 	mov	r4,r2
 202d4dc:	00808534 	movhi	r2,532
 202d4e0:	109f2404 	addi	r2,r2,31888
 202d4e4:	e0fffd17 	ldw	r3,-12(fp)
 202d4e8:	18c00624 	muli	r3,r3,24
 202d4ec:	10c5883a 	add	r2,r2,r3
 202d4f0:	10800304 	addi	r2,r2,12
 202d4f4:	1100000d 	sth	r4,0(r2)
      sockets[i].errevent   = 0;
 202d4f8:	00808534 	movhi	r2,532
 202d4fc:	109f2404 	addi	r2,r2,31888
 202d500:	e0fffd17 	ldw	r3,-12(fp)
 202d504:	18c00624 	muli	r3,r3,24
 202d508:	10c5883a 	add	r2,r2,r3
 202d50c:	10800384 	addi	r2,r2,14
 202d510:	1000000d 	sth	zero,0(r2)
      sockets[i].err        = 0;
 202d514:	00808534 	movhi	r2,532
 202d518:	109f2404 	addi	r2,r2,31888
 202d51c:	e0fffd17 	ldw	r3,-12(fp)
 202d520:	18c00624 	muli	r3,r3,24
 202d524:	10c5883a 	add	r2,r2,r3
 202d528:	10800404 	addi	r2,r2,16
 202d52c:	10000015 	stw	zero,0(r2)
      sockets[i].select_waiting = 0;
 202d530:	00808534 	movhi	r2,532
 202d534:	109f2404 	addi	r2,r2,31888
 202d538:	e0fffd17 	ldw	r3,-12(fp)
 202d53c:	18c00624 	muli	r3,r3,24
 202d540:	10c5883a 	add	r2,r2,r3
 202d544:	10800504 	addi	r2,r2,20
 202d548:	10000015 	stw	zero,0(r2)
      return i;
 202d54c:	e0bffd17 	ldw	r2,-12(fp)
 202d550:	00000a06 	br	202d57c <alloc_socket+0x18c>
    }
    SYS_ARCH_UNPROTECT(lev);
 202d554:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d558:	10000126 	beq	r2,zero,202d560 <alloc_socket+0x170>
 202d55c:	2010f780 	call	2010f78 <vTaskExitCritical>
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 202d560:	e0bffd17 	ldw	r2,-12(fp)
 202d564:	10800044 	addi	r2,r2,1
 202d568:	e0bffd15 	stw	r2,-12(fp)
 202d56c:	e0bffd17 	ldw	r2,-12(fp)
 202d570:	10800a90 	cmplti	r2,r2,42
 202d574:	103fa61e 	bne	r2,zero,202d410 <__alt_mem_mem_0+0xfd00d410>
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
 202d578:	00bfffc4 	movi	r2,-1
}
 202d57c:	e037883a 	mov	sp,fp
 202d580:	dfc00117 	ldw	ra,4(sp)
 202d584:	df000017 	ldw	fp,0(sp)
 202d588:	dec00204 	addi	sp,sp,8
 202d58c:	f800283a 	ret

0202d590 <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
 202d590:	defffb04 	addi	sp,sp,-20
 202d594:	dfc00415 	stw	ra,16(sp)
 202d598:	df000315 	stw	fp,12(sp)
 202d59c:	df000304 	addi	fp,sp,12
 202d5a0:	e13ffe15 	stw	r4,-8(fp)
 202d5a4:	e17fff15 	stw	r5,-4(fp)
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
 202d5a8:	e0bffe17 	ldw	r2,-8(fp)
 202d5ac:	10800117 	ldw	r2,4(r2)
 202d5b0:	e0bffd15 	stw	r2,-12(fp)
  sock->lastdata   = NULL;
 202d5b4:	e0bffe17 	ldw	r2,-8(fp)
 202d5b8:	10000115 	stw	zero,4(r2)
  sock->lastoffset = 0;
 202d5bc:	e0bffe17 	ldw	r2,-8(fp)
 202d5c0:	1000020d 	sth	zero,8(r2)
  sock->err        = 0;
 202d5c4:	e0bffe17 	ldw	r2,-8(fp)
 202d5c8:	10000415 	stw	zero,16(r2)

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
 202d5cc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d5d0:	10000126 	beq	r2,zero,202d5d8 <free_socket+0x48>
 202d5d4:	2010f300 	call	2010f30 <vTaskEnterCritical>
  sock->conn       = NULL;
 202d5d8:	e0bffe17 	ldw	r2,-8(fp)
 202d5dc:	10000015 	stw	zero,0(r2)
  SYS_ARCH_UNPROTECT(lev);
 202d5e0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d5e4:	10000126 	beq	r2,zero,202d5ec <free_socket+0x5c>
 202d5e8:	2010f780 	call	2010f78 <vTaskExitCritical>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
 202d5ec:	e0bffd17 	ldw	r2,-12(fp)
 202d5f0:	10000726 	beq	r2,zero,202d610 <free_socket+0x80>
    if (is_tcp) {
 202d5f4:	e0bfff17 	ldw	r2,-4(fp)
 202d5f8:	10000326 	beq	r2,zero,202d608 <free_socket+0x78>
      pbuf_free((struct pbuf *)lastdata);
 202d5fc:	e13ffd17 	ldw	r4,-12(fp)
 202d600:	201ab680 	call	201ab68 <pbuf_free>
    } else {
      netbuf_delete((struct netbuf *)lastdata);
    }
  }
}
 202d604:	00000206 	br	202d610 <free_socket+0x80>

  if (lastdata != NULL) {
    if (is_tcp) {
      pbuf_free((struct pbuf *)lastdata);
    } else {
      netbuf_delete((struct netbuf *)lastdata);
 202d608:	e13ffd17 	ldw	r4,-12(fp)
 202d60c:	203c6240 	call	203c624 <netbuf_delete>
    }
  }
}
 202d610:	0001883a 	nop
 202d614:	e037883a 	mov	sp,fp
 202d618:	dfc00117 	ldw	ra,4(sp)
 202d61c:	df000017 	ldw	fp,0(sp)
 202d620:	dec00204 	addi	sp,sp,8
 202d624:	f800283a 	ret

0202d628 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
 202d628:	defff004 	addi	sp,sp,-64
 202d62c:	dfc00f15 	stw	ra,60(sp)
 202d630:	df000e15 	stw	fp,56(sp)
 202d634:	df000e04 	addi	fp,sp,56
 202d638:	e13ffd15 	stw	r4,-12(fp)
 202d63c:	e17ffe15 	stw	r5,-8(fp)
 202d640:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in sin;
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
 202d644:	e13ffd17 	ldw	r4,-12(fp)
 202d648:	202d2f80 	call	202d2f8 <get_socket>
 202d64c:	e0bff215 	stw	r2,-56(fp)
  if (!sock) {
 202d650:	e0bff217 	ldw	r2,-56(fp)
 202d654:	1000021e 	bne	r2,zero,202d660 <lwip_accept+0x38>
    return -1;
 202d658:	00bfffc4 	movi	r2,-1
 202d65c:	0000ae06 	br	202d918 <lwip_accept+0x2f0>
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
 202d660:	e0bff217 	ldw	r2,-56(fp)
 202d664:	10800017 	ldw	r2,0(r2)
 202d668:	10800903 	ldbu	r2,36(r2)
 202d66c:	10803fcc 	andi	r2,r2,255
 202d670:	1080008c 	andi	r2,r2,2
 202d674:	10000b26 	beq	r2,zero,202d6a4 <lwip_accept+0x7c>
 202d678:	e0bff217 	ldw	r2,-56(fp)
 202d67c:	1080028b 	ldhu	r2,10(r2)
 202d680:	10bfffcc 	andi	r2,r2,65535
 202d684:	10a0001c 	xori	r2,r2,32768
 202d688:	10a00004 	addi	r2,r2,-32768
 202d68c:	00800516 	blt	zero,r2,202d6a4 <lwip_accept+0x7c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    sock_set_errno(sock, EWOULDBLOCK);
 202d690:	e0bff217 	ldw	r2,-56(fp)
 202d694:	00c002c4 	movi	r3,11
 202d698:	10c00415 	stw	r3,16(r2)
    return -1;
 202d69c:	00bfffc4 	movi	r2,-1
 202d6a0:	00009d06 	br	202d918 <lwip_accept+0x2f0>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
 202d6a4:	e0bff217 	ldw	r2,-56(fp)
 202d6a8:	10800017 	ldw	r2,0(r2)
 202d6ac:	e0fff604 	addi	r3,fp,-40
 202d6b0:	180b883a 	mov	r5,r3
 202d6b4:	1009883a 	mov	r4,r2
 202d6b8:	203955c0 	call	203955c <netconn_accept>
 202d6bc:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
 202d6c0:	e0bff307 	ldb	r2,-52(fp)
 202d6c4:	10001c26 	beq	r2,zero,202d738 <lwip_accept+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 202d6c8:	e0bff217 	ldw	r2,-56(fp)
 202d6cc:	10800017 	ldw	r2,0(r2)
 202d6d0:	10800017 	ldw	r2,0(r2)
 202d6d4:	10800420 	cmpeqi	r2,r2,16
 202d6d8:	1000051e 	bne	r2,zero,202d6f0 <lwip_accept+0xc8>
      sock_set_errno(sock, EOPNOTSUPP);
 202d6dc:	e0bff217 	ldw	r2,-56(fp)
 202d6e0:	00c017c4 	movi	r3,95
 202d6e4:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 202d6e8:	008017c4 	movi	r2,95
 202d6ec:	00008a06 	br	202d918 <lwip_accept+0x2f0>
    }
    sock_set_errno(sock, err_to_errno(err));
 202d6f0:	e0bff307 	ldb	r2,-52(fp)
 202d6f4:	0085c83a 	sub	r2,zero,r2
 202d6f8:	10800428 	cmpgeui	r2,r2,16
 202d6fc:	1000091e 	bne	r2,zero,202d724 <lwip_accept+0xfc>
 202d700:	e0bff307 	ldb	r2,-52(fp)
 202d704:	0087c83a 	sub	r3,zero,r2
 202d708:	00808134 	movhi	r2,516
 202d70c:	108d4204 	addi	r2,r2,13576
 202d710:	18c7883a 	add	r3,r3,r3
 202d714:	18c7883a 	add	r3,r3,r3
 202d718:	10c5883a 	add	r2,r2,r3
 202d71c:	10800017 	ldw	r2,0(r2)
 202d720:	00000106 	br	202d728 <lwip_accept+0x100>
 202d724:	00800144 	movi	r2,5
 202d728:	e0fff217 	ldw	r3,-56(fp)
 202d72c:	18800415 	stw	r2,16(r3)
    return -1;
 202d730:	00bfffc4 	movi	r2,-1
 202d734:	00007806 	br	202d918 <lwip_accept+0x2f0>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
 202d738:	e0bff617 	ldw	r2,-40(fp)
 202d73c:	e0fff617 	ldw	r3,-40(fp)
 202d740:	18c00903 	ldbu	r3,36(r3)
 202d744:	18c00214 	ori	r3,r3,8
 202d748:	10c00905 	stb	r3,36(r2)

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
 202d74c:	e0bff617 	ldw	r2,-40(fp)
 202d750:	e13ff804 	addi	r4,fp,-32
 202d754:	e0fff704 	addi	r3,fp,-36
 202d758:	000f883a 	mov	r7,zero
 202d75c:	200d883a 	mov	r6,r4
 202d760:	180b883a 	mov	r5,r3
 202d764:	1009883a 	mov	r4,r2
 202d768:	20390e80 	call	20390e8 <netconn_getaddr>
 202d76c:	e0bff305 	stb	r2,-52(fp)
  if (err != ERR_OK) {
 202d770:	e0bff307 	ldb	r2,-52(fp)
 202d774:	10001526 	beq	r2,zero,202d7cc <lwip_accept+0x1a4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
 202d778:	e0bff617 	ldw	r2,-40(fp)
 202d77c:	1009883a 	mov	r4,r2
 202d780:	20390880 	call	2039088 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
 202d784:	e0bff307 	ldb	r2,-52(fp)
 202d788:	0085c83a 	sub	r2,zero,r2
 202d78c:	10800428 	cmpgeui	r2,r2,16
 202d790:	1000091e 	bne	r2,zero,202d7b8 <lwip_accept+0x190>
 202d794:	e0bff307 	ldb	r2,-52(fp)
 202d798:	0087c83a 	sub	r3,zero,r2
 202d79c:	00808134 	movhi	r2,516
 202d7a0:	108d4204 	addi	r2,r2,13576
 202d7a4:	18c7883a 	add	r3,r3,r3
 202d7a8:	18c7883a 	add	r3,r3,r3
 202d7ac:	10c5883a 	add	r2,r2,r3
 202d7b0:	10800017 	ldw	r2,0(r2)
 202d7b4:	00000106 	br	202d7bc <lwip_accept+0x194>
 202d7b8:	00800144 	movi	r2,5
 202d7bc:	e0fff217 	ldw	r3,-56(fp)
 202d7c0:	18800415 	stw	r2,16(r3)
    return -1;
 202d7c4:	00bfffc4 	movi	r2,-1
 202d7c8:	00005306 	br	202d918 <lwip_accept+0x2f0>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
 202d7cc:	e0bffe17 	ldw	r2,-8(fp)
 202d7d0:	10002226 	beq	r2,zero,202d85c <lwip_accept+0x234>
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
 202d7d4:	e0bff904 	addi	r2,fp,-28
 202d7d8:	01800404 	movi	r6,16
 202d7dc:	000b883a 	mov	r5,zero
 202d7e0:	1009883a 	mov	r4,r2
 202d7e4:	200616c0 	call	200616c <memset>
    sin.sin_len = sizeof(sin);
 202d7e8:	00800404 	movi	r2,16
 202d7ec:	e0bff905 	stb	r2,-28(fp)
    sin.sin_family = AF_INET;
 202d7f0:	00800084 	movi	r2,2
 202d7f4:	e0bff945 	stb	r2,-27(fp)
    sin.sin_port = htons(port);
 202d7f8:	e0bff80b 	ldhu	r2,-32(fp)
 202d7fc:	10bfffcc 	andi	r2,r2,65535
 202d800:	1004d23a 	srli	r2,r2,8
 202d804:	1007883a 	mov	r3,r2
 202d808:	e0bff80b 	ldhu	r2,-32(fp)
 202d80c:	10bfffcc 	andi	r2,r2,65535
 202d810:	1004923a 	slli	r2,r2,8
 202d814:	1884b03a 	or	r2,r3,r2
 202d818:	e0bff98d 	sth	r2,-26(fp)
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 202d81c:	e0bff717 	ldw	r2,-36(fp)
 202d820:	e0bffa15 	stw	r2,-24(fp)

    if (*addrlen > sizeof(sin))
 202d824:	e0bfff17 	ldw	r2,-4(fp)
 202d828:	10800017 	ldw	r2,0(r2)
 202d82c:	10800470 	cmpltui	r2,r2,17
 202d830:	1000031e 	bne	r2,zero,202d840 <lwip_accept+0x218>
      *addrlen = sizeof(sin);
 202d834:	e0bfff17 	ldw	r2,-4(fp)
 202d838:	00c00404 	movi	r3,16
 202d83c:	10c00015 	stw	r3,0(r2)

    MEMCPY(addr, &sin, *addrlen);
 202d840:	e0bfff17 	ldw	r2,-4(fp)
 202d844:	10c00017 	ldw	r3,0(r2)
 202d848:	e0bff904 	addi	r2,fp,-28
 202d84c:	180d883a 	mov	r6,r3
 202d850:	100b883a 	mov	r5,r2
 202d854:	e13ffe17 	ldw	r4,-8(fp)
 202d858:	20060240 	call	2006024 <memcpy>
  }

  newsock = alloc_socket(newconn, 1);
 202d85c:	e0bff617 	ldw	r2,-40(fp)
 202d860:	01400044 	movi	r5,1
 202d864:	1009883a 	mov	r4,r2
 202d868:	202d3f00 	call	202d3f0 <alloc_socket>
 202d86c:	e0bff415 	stw	r2,-48(fp)
  if (newsock == -1) {
 202d870:	e0bff417 	ldw	r2,-48(fp)
 202d874:	10bfffd8 	cmpnei	r2,r2,-1
 202d878:	1000081e 	bne	r2,zero,202d89c <lwip_accept+0x274>
    netconn_delete(newconn);
 202d87c:	e0bff617 	ldw	r2,-40(fp)
 202d880:	1009883a 	mov	r4,r2
 202d884:	20390880 	call	2039088 <netconn_delete>
    sock_set_errno(sock, ENFILE);
 202d888:	e0bff217 	ldw	r2,-56(fp)
 202d88c:	00c005c4 	movi	r3,23
 202d890:	10c00415 	stw	r3,16(r2)
    return -1;
 202d894:	00bfffc4 	movi	r2,-1
 202d898:	00001f06 	br	202d918 <lwip_accept+0x2f0>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
  nsock = &sockets[newsock];
 202d89c:	e0bff417 	ldw	r2,-48(fp)
 202d8a0:	10c00624 	muli	r3,r2,24
 202d8a4:	00808534 	movhi	r2,532
 202d8a8:	109f2404 	addi	r2,r2,31888
 202d8ac:	1885883a 	add	r2,r3,r2
 202d8b0:	e0bff515 	stw	r2,-44(fp)

  newsock += LWIP_SOCKET_OFFSET;
 202d8b4:	e0bff417 	ldw	r2,-48(fp)
 202d8b8:	10800804 	addi	r2,r2,32
 202d8bc:	e0bff415 	stw	r2,-48(fp)
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
 202d8c0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d8c4:	10000126 	beq	r2,zero,202d8cc <lwip_accept+0x2a4>
 202d8c8:	2010f300 	call	2010f30 <vTaskEnterCritical>
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
 202d8cc:	e0bff517 	ldw	r2,-44(fp)
 202d8d0:	1080028b 	ldhu	r2,10(r2)
 202d8d4:	1007883a 	mov	r3,r2
 202d8d8:	e0bff617 	ldw	r2,-40(fp)
 202d8dc:	10800717 	ldw	r2,28(r2)
 202d8e0:	1885c83a 	sub	r2,r3,r2
 202d8e4:	10bfffc4 	addi	r2,r2,-1
 202d8e8:	1007883a 	mov	r3,r2
 202d8ec:	e0bff517 	ldw	r2,-44(fp)
 202d8f0:	10c0028d 	sth	r3,10(r2)
  newconn->socket = newsock;
 202d8f4:	e0bff617 	ldw	r2,-40(fp)
 202d8f8:	e0fff417 	ldw	r3,-48(fp)
 202d8fc:	10c00715 	stw	r3,28(r2)
  SYS_ARCH_UNPROTECT(lev);
 202d900:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202d904:	10000126 	beq	r2,zero,202d90c <lwip_accept+0x2e4>
 202d908:	2010f780 	call	2010f78 <vTaskExitCritical>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
 202d90c:	e0bff217 	ldw	r2,-56(fp)
 202d910:	10000415 	stw	zero,16(r2)
  return newsock;
 202d914:	e0bff417 	ldw	r2,-48(fp)
}
 202d918:	e037883a 	mov	sp,fp
 202d91c:	dfc00117 	ldw	ra,4(sp)
 202d920:	df000017 	ldw	fp,0(sp)
 202d924:	dec00204 	addi	sp,sp,8
 202d928:	f800283a 	ret

0202d92c <lwip_bind>:

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
 202d92c:	defff704 	addi	sp,sp,-36
 202d930:	dfc00815 	stw	ra,32(sp)
 202d934:	df000715 	stw	fp,28(sp)
 202d938:	df000704 	addi	fp,sp,28
 202d93c:	e13ffd15 	stw	r4,-12(fp)
 202d940:	e17ffe15 	stw	r5,-8(fp)
 202d944:	e1bfff15 	stw	r6,-4(fp)
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
 202d948:	e13ffd17 	ldw	r4,-12(fp)
 202d94c:	202d2f80 	call	202d2f8 <get_socket>
 202d950:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 202d954:	e0bff917 	ldw	r2,-28(fp)
 202d958:	1000021e 	bne	r2,zero,202d964 <lwip_bind+0x38>
    return -1;
 202d95c:	00bfffc4 	movi	r2,-1
 202d960:	00004206 	br	202da6c <lwip_bind+0x140>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 202d964:	e0bfff17 	ldw	r2,-4(fp)
 202d968:	10800418 	cmpnei	r2,r2,16
 202d96c:	1000081e 	bne	r2,zero,202d990 <lwip_bind+0x64>
 202d970:	e0bffe17 	ldw	r2,-8(fp)
 202d974:	10800043 	ldbu	r2,1(r2)
 202d978:	10803fcc 	andi	r2,r2,255
 202d97c:	10800098 	cmpnei	r2,r2,2
 202d980:	1000031e 	bne	r2,zero,202d990 <lwip_bind+0x64>
 202d984:	e0bffe17 	ldw	r2,-8(fp)
 202d988:	108000cc 	andi	r2,r2,3
 202d98c:	10000926 	beq	r2,zero,202d9b4 <lwip_bind+0x88>
 202d990:	01c08134 	movhi	r7,516
 202d994:	39cd5204 	addi	r7,r7,13640
 202d998:	01806ac4 	movi	r6,427
 202d99c:	01408134 	movhi	r5,516
 202d9a0:	294d5804 	addi	r5,r5,13664
 202d9a4:	01008134 	movhi	r4,516
 202d9a8:	210d5f04 	addi	r4,r4,13692
 202d9ac:	2000bb00 	call	2000bb0 <printf>
 202d9b0:	003fff06 	br	202d9b0 <__alt_mem_mem_0+0xfd00d9b0>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
 202d9b4:	e0bffe17 	ldw	r2,-8(fp)
 202d9b8:	e0bffa15 	stw	r2,-24(fp)

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
 202d9bc:	e0bffa17 	ldw	r2,-24(fp)
 202d9c0:	10800117 	ldw	r2,4(r2)
 202d9c4:	e0bffc15 	stw	r2,-16(fp)
  local_port = name_in->sin_port;
 202d9c8:	e0bffa17 	ldw	r2,-24(fp)
 202d9cc:	1080008b 	ldhu	r2,2(r2)
 202d9d0:	e0bffb0d 	sth	r2,-20(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
 202d9d4:	e0bff917 	ldw	r2,-28(fp)
 202d9d8:	10c00017 	ldw	r3,0(r2)
 202d9dc:	e0bffb0b 	ldhu	r2,-20(fp)
 202d9e0:	1004d23a 	srli	r2,r2,8
 202d9e4:	1009883a 	mov	r4,r2
 202d9e8:	e0bffb0b 	ldhu	r2,-20(fp)
 202d9ec:	1004923a 	slli	r2,r2,8
 202d9f0:	2084b03a 	or	r2,r4,r2
 202d9f4:	113fffcc 	andi	r4,r2,65535
 202d9f8:	e0bffc04 	addi	r2,fp,-16
 202d9fc:	200d883a 	mov	r6,r4
 202da00:	100b883a 	mov	r5,r2
 202da04:	1809883a 	mov	r4,r3
 202da08:	20392240 	call	2039224 <netconn_bind>
 202da0c:	e0bffb85 	stb	r2,-18(fp)

  if (err != ERR_OK) {
 202da10:	e0bffb87 	ldb	r2,-18(fp)
 202da14:	10001226 	beq	r2,zero,202da60 <lwip_bind+0x134>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 202da18:	e0bffb87 	ldb	r2,-18(fp)
 202da1c:	0085c83a 	sub	r2,zero,r2
 202da20:	10800428 	cmpgeui	r2,r2,16
 202da24:	1000091e 	bne	r2,zero,202da4c <lwip_bind+0x120>
 202da28:	e0bffb87 	ldb	r2,-18(fp)
 202da2c:	0087c83a 	sub	r3,zero,r2
 202da30:	00808134 	movhi	r2,516
 202da34:	108d4204 	addi	r2,r2,13576
 202da38:	18c7883a 	add	r3,r3,r3
 202da3c:	18c7883a 	add	r3,r3,r3
 202da40:	10c5883a 	add	r2,r2,r3
 202da44:	10800017 	ldw	r2,0(r2)
 202da48:	00000106 	br	202da50 <lwip_bind+0x124>
 202da4c:	00800144 	movi	r2,5
 202da50:	e0fff917 	ldw	r3,-28(fp)
 202da54:	18800415 	stw	r2,16(r3)
    return -1;
 202da58:	00bfffc4 	movi	r2,-1
 202da5c:	00000306 	br	202da6c <lwip_bind+0x140>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 202da60:	e0bff917 	ldw	r2,-28(fp)
 202da64:	10000415 	stw	zero,16(r2)
  return 0;
 202da68:	0005883a 	mov	r2,zero
}
 202da6c:	e037883a 	mov	sp,fp
 202da70:	dfc00117 	ldw	ra,4(sp)
 202da74:	df000017 	ldw	fp,0(sp)
 202da78:	dec00204 	addi	sp,sp,8
 202da7c:	f800283a 	ret

0202da80 <lwip_close>:

int
lwip_close(int s)
{
 202da80:	defffb04 	addi	sp,sp,-20
 202da84:	dfc00415 	stw	ra,16(sp)
 202da88:	df000315 	stw	fp,12(sp)
 202da8c:	df000304 	addi	fp,sp,12
 202da90:	e13fff15 	stw	r4,-4(fp)
  struct lwip_sock *sock;
  int is_tcp = 0;
 202da94:	e03ffd15 	stw	zero,-12(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
 202da98:	e13fff17 	ldw	r4,-4(fp)
 202da9c:	202d2f80 	call	202d2f8 <get_socket>
 202daa0:	e0bffe15 	stw	r2,-8(fp)
  if (!sock) {
 202daa4:	e0bffe17 	ldw	r2,-8(fp)
 202daa8:	1000021e 	bne	r2,zero,202dab4 <lwip_close+0x34>
    return -1;
 202daac:	00bfffc4 	movi	r2,-1
 202dab0:	00001106 	br	202daf8 <lwip_close+0x78>
  }

  if(sock->conn != NULL) {
 202dab4:	e0bffe17 	ldw	r2,-8(fp)
 202dab8:	10800017 	ldw	r2,0(r2)
 202dabc:	10000626 	beq	r2,zero,202dad8 <lwip_close+0x58>
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
 202dac0:	e0bffe17 	ldw	r2,-8(fp)
 202dac4:	10800017 	ldw	r2,0(r2)
 202dac8:	10800017 	ldw	r2,0(r2)
 202dacc:	10800420 	cmpeqi	r2,r2,16
 202dad0:	10803fcc 	andi	r2,r2,255
 202dad4:	e0bffd15 	stw	r2,-12(fp)
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
 202dad8:	e0bffe17 	ldw	r2,-8(fp)
 202dadc:	10800017 	ldw	r2,0(r2)
 202dae0:	1009883a 	mov	r4,r2
 202dae4:	20390880 	call	2039088 <netconn_delete>

  free_socket(sock, is_tcp);
 202dae8:	e17ffd17 	ldw	r5,-12(fp)
 202daec:	e13ffe17 	ldw	r4,-8(fp)
 202daf0:	202d5900 	call	202d590 <free_socket>
  set_errno(0);
  return 0;
 202daf4:	0005883a 	mov	r2,zero
}
 202daf8:	e037883a 	mov	sp,fp
 202dafc:	dfc00117 	ldw	ra,4(sp)
 202db00:	df000017 	ldw	fp,0(sp)
 202db04:	dec00204 	addi	sp,sp,8
 202db08:	f800283a 	ret

0202db0c <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
 202db0c:	defff604 	addi	sp,sp,-40
 202db10:	dfc00915 	stw	ra,36(sp)
 202db14:	df000815 	stw	fp,32(sp)
 202db18:	df000804 	addi	fp,sp,32
 202db1c:	e13ffd15 	stw	r4,-12(fp)
 202db20:	e17ffe15 	stw	r5,-8(fp)
 202db24:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
 202db28:	e13ffd17 	ldw	r4,-12(fp)
 202db2c:	202d2f80 	call	202d2f8 <get_socket>
 202db30:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 202db34:	e0bff917 	ldw	r2,-28(fp)
 202db38:	1000021e 	bne	r2,zero,202db44 <lwip_connect+0x38>
    return -1;
 202db3c:	00bfffc4 	movi	r2,-1
 202db40:	00004c06 	br	202dc74 <lwip_connect+0x168>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 202db44:	e0bfff17 	ldw	r2,-4(fp)
 202db48:	10800418 	cmpnei	r2,r2,16
 202db4c:	1000081e 	bne	r2,zero,202db70 <lwip_connect+0x64>
 202db50:	e0bffe17 	ldw	r2,-8(fp)
 202db54:	10800043 	ldbu	r2,1(r2)
 202db58:	10803fcc 	andi	r2,r2,255
 202db5c:	10800098 	cmpnei	r2,r2,2
 202db60:	1000031e 	bne	r2,zero,202db70 <lwip_connect+0x64>
 202db64:	e0bffe17 	ldw	r2,-8(fp)
 202db68:	108000cc 	andi	r2,r2,3
 202db6c:	10000926 	beq	r2,zero,202db94 <lwip_connect+0x88>
 202db70:	01c08134 	movhi	r7,516
 202db74:	39cd5204 	addi	r7,r7,13640
 202db78:	01807ac4 	movi	r6,491
 202db7c:	01408134 	movhi	r5,516
 202db80:	294d6b04 	addi	r5,r5,13740
 202db84:	01008134 	movhi	r4,516
 202db88:	210d5f04 	addi	r4,r4,13692
 202db8c:	2000bb00 	call	2000bb0 <printf>
 202db90:	003fff06 	br	202db90 <__alt_mem_mem_0+0xfd00db90>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
 202db94:	e0bffe17 	ldw	r2,-8(fp)
 202db98:	e0bffa15 	stw	r2,-24(fp)

  if (name_in->sin_family == AF_UNSPEC) {
 202db9c:	e0bffa17 	ldw	r2,-24(fp)
 202dba0:	10800043 	ldbu	r2,1(r2)
 202dba4:	10803fcc 	andi	r2,r2,255
 202dba8:	1000061e 	bne	r2,zero,202dbc4 <lwip_connect+0xb8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
 202dbac:	e0bff917 	ldw	r2,-28(fp)
 202dbb0:	10800017 	ldw	r2,0(r2)
 202dbb4:	1009883a 	mov	r4,r2
 202dbb8:	20393d40 	call	20393d4 <netconn_disconnect>
 202dbbc:	e0bff805 	stb	r2,-32(fp)
 202dbc0:	00001506 	br	202dc18 <lwip_connect+0x10c>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
 202dbc4:	e0bffa17 	ldw	r2,-24(fp)
 202dbc8:	10800117 	ldw	r2,4(r2)
 202dbcc:	e0bffc15 	stw	r2,-16(fp)
    remote_port = name_in->sin_port;
 202dbd0:	e0bffa17 	ldw	r2,-24(fp)
 202dbd4:	1080008b 	ldhu	r2,2(r2)
 202dbd8:	e0bffb0d 	sth	r2,-20(fp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
 202dbdc:	e0bff917 	ldw	r2,-28(fp)
 202dbe0:	10c00017 	ldw	r3,0(r2)
 202dbe4:	e0bffb0b 	ldhu	r2,-20(fp)
 202dbe8:	1004d23a 	srli	r2,r2,8
 202dbec:	1009883a 	mov	r4,r2
 202dbf0:	e0bffb0b 	ldhu	r2,-20(fp)
 202dbf4:	1004923a 	slli	r2,r2,8
 202dbf8:	2084b03a 	or	r2,r4,r2
 202dbfc:	113fffcc 	andi	r4,r2,65535
 202dc00:	e0bffc04 	addi	r2,fp,-16
 202dc04:	200d883a 	mov	r6,r4
 202dc08:	100b883a 	mov	r5,r2
 202dc0c:	1809883a 	mov	r4,r3
 202dc10:	20392fc0 	call	20392fc <netconn_connect>
 202dc14:	e0bff805 	stb	r2,-32(fp)
  }

  if (err != ERR_OK) {
 202dc18:	e0bff807 	ldb	r2,-32(fp)
 202dc1c:	10001226 	beq	r2,zero,202dc68 <lwip_connect+0x15c>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 202dc20:	e0bff807 	ldb	r2,-32(fp)
 202dc24:	0085c83a 	sub	r2,zero,r2
 202dc28:	10800428 	cmpgeui	r2,r2,16
 202dc2c:	1000091e 	bne	r2,zero,202dc54 <lwip_connect+0x148>
 202dc30:	e0bff807 	ldb	r2,-32(fp)
 202dc34:	0087c83a 	sub	r3,zero,r2
 202dc38:	00808134 	movhi	r2,516
 202dc3c:	108d4204 	addi	r2,r2,13576
 202dc40:	18c7883a 	add	r3,r3,r3
 202dc44:	18c7883a 	add	r3,r3,r3
 202dc48:	10c5883a 	add	r2,r2,r3
 202dc4c:	10800017 	ldw	r2,0(r2)
 202dc50:	00000106 	br	202dc58 <lwip_connect+0x14c>
 202dc54:	00800144 	movi	r2,5
 202dc58:	e0fff917 	ldw	r3,-28(fp)
 202dc5c:	18800415 	stw	r2,16(r3)
    return -1;
 202dc60:	00bfffc4 	movi	r2,-1
 202dc64:	00000306 	br	202dc74 <lwip_connect+0x168>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 202dc68:	e0bff917 	ldw	r2,-28(fp)
 202dc6c:	10000415 	stw	zero,16(r2)
  return 0;
 202dc70:	0005883a 	mov	r2,zero
}
 202dc74:	e037883a 	mov	sp,fp
 202dc78:	dfc00117 	ldw	ra,4(sp)
 202dc7c:	df000017 	ldw	fp,0(sp)
 202dc80:	dec00204 	addi	sp,sp,8
 202dc84:	f800283a 	ret

0202dc88 <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
 202dc88:	defffa04 	addi	sp,sp,-24
 202dc8c:	dfc00515 	stw	ra,20(sp)
 202dc90:	df000415 	stw	fp,16(sp)
 202dc94:	df000404 	addi	fp,sp,16
 202dc98:	e13ffe15 	stw	r4,-8(fp)
 202dc9c:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
 202dca0:	e13ffe17 	ldw	r4,-8(fp)
 202dca4:	202d2f80 	call	202d2f8 <get_socket>
 202dca8:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
 202dcac:	e0bffc17 	ldw	r2,-16(fp)
 202dcb0:	1000021e 	bne	r2,zero,202dcbc <lwip_listen+0x34>
    return -1;
 202dcb4:	00bfffc4 	movi	r2,-1
 202dcb8:	00003206 	br	202dd84 <lwip_listen+0xfc>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
 202dcbc:	e0bfff17 	ldw	r2,-4(fp)
 202dcc0:	10803fc8 	cmpgei	r2,r2,255
 202dcc4:	1000041e 	bne	r2,zero,202dcd8 <lwip_listen+0x50>
 202dcc8:	e0bfff17 	ldw	r2,-4(fp)
 202dccc:	1000030e 	bge	r2,zero,202dcdc <lwip_listen+0x54>
 202dcd0:	0005883a 	mov	r2,zero
 202dcd4:	00000106 	br	202dcdc <lwip_listen+0x54>
 202dcd8:	00803fc4 	movi	r2,255
 202dcdc:	e0bfff15 	stw	r2,-4(fp)

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
 202dce0:	e0bffc17 	ldw	r2,-16(fp)
 202dce4:	10c00017 	ldw	r3,0(r2)
 202dce8:	e0bfff17 	ldw	r2,-4(fp)
 202dcec:	10803fcc 	andi	r2,r2,255
 202dcf0:	100b883a 	mov	r5,r2
 202dcf4:	1809883a 	mov	r4,r3
 202dcf8:	20394900 	call	2039490 <netconn_listen_with_backlog>
 202dcfc:	e0bffd05 	stb	r2,-12(fp)

  if (err != ERR_OK) {
 202dd00:	e0bffd07 	ldb	r2,-12(fp)
 202dd04:	10001c26 	beq	r2,zero,202dd78 <lwip_listen+0xf0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 202dd08:	e0bffc17 	ldw	r2,-16(fp)
 202dd0c:	10800017 	ldw	r2,0(r2)
 202dd10:	10800017 	ldw	r2,0(r2)
 202dd14:	10800420 	cmpeqi	r2,r2,16
 202dd18:	1000051e 	bne	r2,zero,202dd30 <lwip_listen+0xa8>
      sock_set_errno(sock, EOPNOTSUPP);
 202dd1c:	e0bffc17 	ldw	r2,-16(fp)
 202dd20:	00c017c4 	movi	r3,95
 202dd24:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 202dd28:	008017c4 	movi	r2,95
 202dd2c:	00001506 	br	202dd84 <lwip_listen+0xfc>
    }
    sock_set_errno(sock, err_to_errno(err));
 202dd30:	e0bffd07 	ldb	r2,-12(fp)
 202dd34:	0085c83a 	sub	r2,zero,r2
 202dd38:	10800428 	cmpgeui	r2,r2,16
 202dd3c:	1000091e 	bne	r2,zero,202dd64 <lwip_listen+0xdc>
 202dd40:	e0bffd07 	ldb	r2,-12(fp)
 202dd44:	0087c83a 	sub	r3,zero,r2
 202dd48:	00808134 	movhi	r2,516
 202dd4c:	108d4204 	addi	r2,r2,13576
 202dd50:	18c7883a 	add	r3,r3,r3
 202dd54:	18c7883a 	add	r3,r3,r3
 202dd58:	10c5883a 	add	r2,r2,r3
 202dd5c:	10800017 	ldw	r2,0(r2)
 202dd60:	00000106 	br	202dd68 <lwip_listen+0xe0>
 202dd64:	00800144 	movi	r2,5
 202dd68:	e0fffc17 	ldw	r3,-16(fp)
 202dd6c:	18800415 	stw	r2,16(r3)
    return -1;
 202dd70:	00bfffc4 	movi	r2,-1
 202dd74:	00000306 	br	202dd84 <lwip_listen+0xfc>
  }

  sock_set_errno(sock, 0);
 202dd78:	e0bffc17 	ldw	r2,-16(fp)
 202dd7c:	10000415 	stw	zero,16(r2)
  return 0;
 202dd80:	0005883a 	mov	r2,zero
}
 202dd84:	e037883a 	mov	sp,fp
 202dd88:	dfc00117 	ldw	ra,4(sp)
 202dd8c:	df000017 	ldw	fp,0(sp)
 202dd90:	dec00204 	addi	sp,sp,8
 202dd94:	f800283a 	ret

0202dd98 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
 202dd98:	deffec04 	addi	sp,sp,-80
 202dd9c:	dfc01315 	stw	ra,76(sp)
 202dda0:	df001215 	stw	fp,72(sp)
 202dda4:	df001204 	addi	fp,sp,72
 202dda8:	e13ffc15 	stw	r4,-16(fp)
 202ddac:	e17ffd15 	stw	r5,-12(fp)
 202ddb0:	e1bffe15 	stw	r6,-8(fp)
 202ddb4:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock;
  void             *buf = NULL;
 202ddb8:	e03ff515 	stw	zero,-44(fp)
  struct pbuf      *p;
  u16_t            buflen, copylen;
  int              off = 0;
 202ddbc:	e03ff015 	stw	zero,-64(fp)
  ip_addr_t        *addr;
  u16_t            port;
  u8_t             done = 0;
 202ddc0:	e03ff205 	stb	zero,-56(fp)
  err_t            err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
 202ddc4:	e13ffc17 	ldw	r4,-16(fp)
 202ddc8:	202d2f80 	call	202d2f8 <get_socket>
 202ddcc:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 202ddd0:	e0bff317 	ldw	r2,-52(fp)
 202ddd4:	1000021e 	bne	r2,zero,202dde0 <lwip_recvfrom+0x48>
    return -1;
 202ddd8:	00bfffc4 	movi	r2,-1
 202dddc:	00011f06 	br	202e25c <lwip_recvfrom+0x4c4>
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
 202dde0:	e0bff317 	ldw	r2,-52(fp)
 202dde4:	10800117 	ldw	r2,4(r2)
 202dde8:	10000426 	beq	r2,zero,202ddfc <lwip_recvfrom+0x64>
      buf = sock->lastdata;
 202ddec:	e0bff317 	ldw	r2,-52(fp)
 202ddf0:	10800117 	ldw	r2,4(r2)
 202ddf4:	e0bff515 	stw	r2,-44(fp)
 202ddf8:	00005c06 	br	202df6c <lwip_recvfrom+0x1d4>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 202ddfc:	e0bfff17 	ldw	r2,-4(fp)
 202de00:	1080020c 	andi	r2,r2,8
 202de04:	1000061e 	bne	r2,zero,202de20 <lwip_recvfrom+0x88>
 202de08:	e0bff317 	ldw	r2,-52(fp)
 202de0c:	10800017 	ldw	r2,0(r2)
 202de10:	10800903 	ldbu	r2,36(r2)
 202de14:	10803fcc 	andi	r2,r2,255
 202de18:	1080008c 	andi	r2,r2,2
 202de1c:	10001726 	beq	r2,zero,202de7c <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
 202de20:	e0bff317 	ldw	r2,-52(fp)
 202de24:	1080028b 	ldhu	r2,10(r2)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 202de28:	10bfffcc 	andi	r2,r2,65535
 202de2c:	10a0001c 	xori	r2,r2,32768
 202de30:	10a00004 	addi	r2,r2,-32768
 202de34:	00801116 	blt	zero,r2,202de7c <lwip_recvfrom+0xe4>
          (sock->rcvevent <= 0)) {
        if (off > 0) {
 202de38:	e0bff017 	ldw	r2,-64(fp)
 202de3c:	00800a0e 	bge	zero,r2,202de68 <lwip_recvfrom+0xd0>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 202de40:	e0bff317 	ldw	r2,-52(fp)
 202de44:	10800017 	ldw	r2,0(r2)
 202de48:	e0fff017 	ldw	r3,-64(fp)
 202de4c:	180b883a 	mov	r5,r3
 202de50:	1009883a 	mov	r4,r2
 202de54:	2039c040 	call	2039c04 <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 202de58:	e0bff317 	ldw	r2,-52(fp)
 202de5c:	10000415 	stw	zero,16(r2)
          return off;
 202de60:	e0bff017 	ldw	r2,-64(fp)
 202de64:	0000fd06 	br	202e25c <lwip_recvfrom+0x4c4>
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
 202de68:	e0bff317 	ldw	r2,-52(fp)
 202de6c:	00c002c4 	movi	r3,11
 202de70:	10c00415 	stw	r3,16(r2)
        return -1;
 202de74:	00bfffc4 	movi	r2,-1
 202de78:	0000f806 	br	202e25c <lwip_recvfrom+0x4c4>
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
 202de7c:	e0bff317 	ldw	r2,-52(fp)
 202de80:	10800017 	ldw	r2,0(r2)
 202de84:	10800017 	ldw	r2,0(r2)
 202de88:	10800418 	cmpnei	r2,r2,16
 202de8c:	1000081e 	bne	r2,zero,202deb0 <lwip_recvfrom+0x118>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 202de90:	e0bff317 	ldw	r2,-52(fp)
 202de94:	10800017 	ldw	r2,0(r2)
 202de98:	e0fff504 	addi	r3,fp,-44
 202de9c:	180b883a 	mov	r5,r3
 202dea0:	1009883a 	mov	r4,r2
 202dea4:	20399e80 	call	20399e8 <netconn_recv_tcp_pbuf>
 202dea8:	e0bff245 	stb	r2,-55(fp)
 202deac:	00000706 	br	202decc <lwip_recvfrom+0x134>
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
 202deb0:	e0bff317 	ldw	r2,-52(fp)
 202deb4:	10800017 	ldw	r2,0(r2)
 202deb8:	e0fff504 	addi	r3,fp,-44
 202debc:	180b883a 	mov	r5,r3
 202dec0:	1009883a 	mov	r4,r2
 202dec4:	2039a5c0 	call	2039a5c <netconn_recv>
 202dec8:	e0bff245 	stb	r2,-55(fp)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
 202decc:	e0bff247 	ldb	r2,-55(fp)
 202ded0:	10002326 	beq	r2,zero,202df60 <lwip_recvfrom+0x1c8>
        if (off > 0) {
 202ded4:	e0bff017 	ldw	r2,-64(fp)
 202ded8:	00800a0e 	bge	zero,r2,202df04 <lwip_recvfrom+0x16c>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 202dedc:	e0bff317 	ldw	r2,-52(fp)
 202dee0:	10800017 	ldw	r2,0(r2)
 202dee4:	e0fff017 	ldw	r3,-64(fp)
 202dee8:	180b883a 	mov	r5,r3
 202deec:	1009883a 	mov	r4,r2
 202def0:	2039c040 	call	2039c04 <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 202def4:	e0bff317 	ldw	r2,-52(fp)
 202def8:	10000415 	stw	zero,16(r2)
          return off;
 202defc:	e0bff017 	ldw	r2,-64(fp)
 202df00:	0000d606 	br	202e25c <lwip_recvfrom+0x4c4>
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
 202df04:	e0bff247 	ldb	r2,-55(fp)
 202df08:	0085c83a 	sub	r2,zero,r2
 202df0c:	10800428 	cmpgeui	r2,r2,16
 202df10:	1000091e 	bne	r2,zero,202df38 <lwip_recvfrom+0x1a0>
 202df14:	e0bff247 	ldb	r2,-55(fp)
 202df18:	0087c83a 	sub	r3,zero,r2
 202df1c:	00808134 	movhi	r2,516
 202df20:	108d4204 	addi	r2,r2,13576
 202df24:	18c7883a 	add	r3,r3,r3
 202df28:	18c7883a 	add	r3,r3,r3
 202df2c:	10c5883a 	add	r2,r2,r3
 202df30:	10800017 	ldw	r2,0(r2)
 202df34:	00000106 	br	202df3c <lwip_recvfrom+0x1a4>
 202df38:	00800144 	movi	r2,5
 202df3c:	e0fff317 	ldw	r3,-52(fp)
 202df40:	18800415 	stw	r2,16(r3)
        if (err == ERR_CLSD) {
 202df44:	e0bff247 	ldb	r2,-55(fp)
 202df48:	10bffd18 	cmpnei	r2,r2,-12
 202df4c:	1000021e 	bne	r2,zero,202df58 <lwip_recvfrom+0x1c0>
          return 0;
 202df50:	0005883a 	mov	r2,zero
 202df54:	0000c106 	br	202e25c <lwip_recvfrom+0x4c4>
        } else {
          return -1;
 202df58:	00bfffc4 	movi	r2,-1
 202df5c:	0000bf06 	br	202e25c <lwip_recvfrom+0x4c4>
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
 202df60:	e0fff517 	ldw	r3,-44(fp)
 202df64:	e0bff317 	ldw	r2,-52(fp)
 202df68:	10c00115 	stw	r3,4(r2)
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 202df6c:	e0bff317 	ldw	r2,-52(fp)
 202df70:	10800017 	ldw	r2,0(r2)
 202df74:	10800017 	ldw	r2,0(r2)
 202df78:	10800418 	cmpnei	r2,r2,16
 202df7c:	1000031e 	bne	r2,zero,202df8c <lwip_recvfrom+0x1f4>
      p = (struct pbuf *)buf;
 202df80:	e0bff517 	ldw	r2,-44(fp)
 202df84:	e0bfee15 	stw	r2,-72(fp)
 202df88:	00000306 	br	202df98 <lwip_recvfrom+0x200>
    } else {
      p = ((struct netbuf *)buf)->p;
 202df8c:	e0bff517 	ldw	r2,-44(fp)
 202df90:	10800017 	ldw	r2,0(r2)
 202df94:	e0bfee15 	stw	r2,-72(fp)
    }
    buflen = p->tot_len;
 202df98:	e0bfee17 	ldw	r2,-72(fp)
 202df9c:	1080020b 	ldhu	r2,8(r2)
 202dfa0:	e0bff40d 	sth	r2,-48(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
 202dfa4:	e0bff317 	ldw	r2,-52(fp)
 202dfa8:	1080020b 	ldhu	r2,8(r2)
 202dfac:	e0fff40b 	ldhu	r3,-48(fp)
 202dfb0:	1885c83a 	sub	r2,r3,r2
 202dfb4:	e0bff40d 	sth	r2,-48(fp)

    if (len > buflen) {
 202dfb8:	e0fff40b 	ldhu	r3,-48(fp)
 202dfbc:	e0bffe17 	ldw	r2,-8(fp)
 202dfc0:	1880032e 	bgeu	r3,r2,202dfd0 <lwip_recvfrom+0x238>
      copylen = buflen;
 202dfc4:	e0bff40b 	ldhu	r2,-48(fp)
 202dfc8:	e0bfef0d 	sth	r2,-68(fp)
 202dfcc:	00000206 	br	202dfd8 <lwip_recvfrom+0x240>
    } else {
      copylen = (u16_t)len;
 202dfd0:	e0bffe17 	ldw	r2,-8(fp)
 202dfd4:	e0bfef0d 	sth	r2,-68(fp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 202dfd8:	e0bff017 	ldw	r2,-64(fp)
 202dfdc:	e0fffd17 	ldw	r3,-12(fp)
 202dfe0:	1887883a 	add	r3,r3,r2
 202dfe4:	e13fef0b 	ldhu	r4,-68(fp)
 202dfe8:	e0bff317 	ldw	r2,-52(fp)
 202dfec:	1080020b 	ldhu	r2,8(r2)
 202dff0:	10bfffcc 	andi	r2,r2,65535
 202dff4:	100f883a 	mov	r7,r2
 202dff8:	200d883a 	mov	r6,r4
 202dffc:	180b883a 	mov	r5,r3
 202e000:	e13fee17 	ldw	r4,-72(fp)
 202e004:	201b16c0 	call	201b16c <pbuf_copy_partial>

    off += copylen;
 202e008:	e0bfef0b 	ldhu	r2,-68(fp)
 202e00c:	e0fff017 	ldw	r3,-64(fp)
 202e010:	1885883a 	add	r2,r3,r2
 202e014:	e0bff015 	stw	r2,-64(fp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 202e018:	e0bff317 	ldw	r2,-52(fp)
 202e01c:	10800017 	ldw	r2,0(r2)
 202e020:	10800017 	ldw	r2,0(r2)
 202e024:	10800418 	cmpnei	r2,r2,16
 202e028:	1000171e 	bne	r2,zero,202e088 <lwip_recvfrom+0x2f0>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
 202e02c:	e0bfef0b 	ldhu	r2,-68(fp)
 202e030:	e0fffe17 	ldw	r3,-8(fp)
 202e034:	1885c83a 	sub	r2,r3,r2
 202e038:	e0bffe15 	stw	r2,-8(fp)
      if ( (len <= 0) || 
 202e03c:	e0bffe17 	ldw	r2,-8(fp)
 202e040:	10000e26 	beq	r2,zero,202e07c <lwip_recvfrom+0x2e4>
           (p->flags & PBUF_FLAG_PUSH) || 
 202e044:	e0bfee17 	ldw	r2,-72(fp)
 202e048:	10800343 	ldbu	r2,13(r2)
 202e04c:	10803fcc 	andi	r2,r2,255
 202e050:	1080004c 	andi	r2,r2,1
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
 202e054:	1000091e 	bne	r2,zero,202e07c <lwip_recvfrom+0x2e4>
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
 202e058:	e0bff317 	ldw	r2,-52(fp)
 202e05c:	1080028b 	ldhu	r2,10(r2)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
 202e060:	10bfffcc 	andi	r2,r2,65535
 202e064:	10a0001c 	xori	r2,r2,32768
 202e068:	10a00004 	addi	r2,r2,-32768
 202e06c:	0080030e 	bge	zero,r2,202e07c <lwip_recvfrom+0x2e4>
           (sock->rcvevent <= 0) || 
           ((flags & MSG_PEEK)!=0)) {
 202e070:	e0bfff17 	ldw	r2,-4(fp)
 202e074:	1080004c 	andi	r2,r2,1
    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
 202e078:	10000526 	beq	r2,zero,202e090 <lwip_recvfrom+0x2f8>
           ((flags & MSG_PEEK)!=0)) {
        done = 1;
 202e07c:	00800044 	movi	r2,1
 202e080:	e0bff205 	stb	r2,-56(fp)
 202e084:	00000206 	br	202e090 <lwip_recvfrom+0x2f8>
      }
    } else {
      done = 1;
 202e088:	00800044 	movi	r2,1
 202e08c:	e0bff205 	stb	r2,-56(fp)
    }

    /* Check to see from where the data was.*/
    if (done) {
 202e090:	e0bff203 	ldbu	r2,-56(fp)
 202e094:	10003d26 	beq	r2,zero,202e18c <lwip_recvfrom+0x3f4>
      ip_addr_t fromaddr;
      if (from && fromlen) {
 202e098:	e0800217 	ldw	r2,8(fp)
 202e09c:	10003b26 	beq	r2,zero,202e18c <lwip_recvfrom+0x3f4>
 202e0a0:	e0800317 	ldw	r2,12(fp)
 202e0a4:	10003926 	beq	r2,zero,202e18c <lwip_recvfrom+0x3f4>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
 202e0a8:	e0bff317 	ldw	r2,-52(fp)
 202e0ac:	10800017 	ldw	r2,0(r2)
 202e0b0:	10800017 	ldw	r2,0(r2)
 202e0b4:	10800418 	cmpnei	r2,r2,16
 202e0b8:	10000b1e 	bne	r2,zero,202e0e8 <lwip_recvfrom+0x350>
          addr = &fromaddr;
 202e0bc:	e0bff704 	addi	r2,fp,-36
 202e0c0:	e0bff115 	stw	r2,-60(fp)
          netconn_getaddr(sock->conn, addr, &port, 0);
 202e0c4:	e0bff317 	ldw	r2,-52(fp)
 202e0c8:	10800017 	ldw	r2,0(r2)
 202e0cc:	e0fff604 	addi	r3,fp,-40
 202e0d0:	000f883a 	mov	r7,zero
 202e0d4:	180d883a 	mov	r6,r3
 202e0d8:	e17ff117 	ldw	r5,-60(fp)
 202e0dc:	1009883a 	mov	r4,r2
 202e0e0:	20390e80 	call	20390e8 <netconn_getaddr>
 202e0e4:	00000606 	br	202e100 <lwip_recvfrom+0x368>
        } else {
          addr = netbuf_fromaddr((struct netbuf *)buf);
 202e0e8:	e0bff517 	ldw	r2,-44(fp)
 202e0ec:	10800204 	addi	r2,r2,8
 202e0f0:	e0bff115 	stw	r2,-60(fp)
          port = netbuf_fromport((struct netbuf *)buf);
 202e0f4:	e0bff517 	ldw	r2,-44(fp)
 202e0f8:	1080030b 	ldhu	r2,12(r2)
 202e0fc:	e0bff60d 	sth	r2,-40(fp)
        }

        memset(&sin, 0, sizeof(sin));
 202e100:	e0bff804 	addi	r2,fp,-32
 202e104:	01800404 	movi	r6,16
 202e108:	000b883a 	mov	r5,zero
 202e10c:	1009883a 	mov	r4,r2
 202e110:	200616c0 	call	200616c <memset>
        sin.sin_len = sizeof(sin);
 202e114:	00800404 	movi	r2,16
 202e118:	e0bff805 	stb	r2,-32(fp)
        sin.sin_family = AF_INET;
 202e11c:	00800084 	movi	r2,2
 202e120:	e0bff845 	stb	r2,-31(fp)
        sin.sin_port = htons(port);
 202e124:	e0bff60b 	ldhu	r2,-40(fp)
 202e128:	10bfffcc 	andi	r2,r2,65535
 202e12c:	1004d23a 	srli	r2,r2,8
 202e130:	1007883a 	mov	r3,r2
 202e134:	e0bff60b 	ldhu	r2,-40(fp)
 202e138:	10bfffcc 	andi	r2,r2,65535
 202e13c:	1004923a 	slli	r2,r2,8
 202e140:	1884b03a 	or	r2,r3,r2
 202e144:	e0bff88d 	sth	r2,-30(fp)
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
 202e148:	e0bff117 	ldw	r2,-60(fp)
 202e14c:	10800017 	ldw	r2,0(r2)
 202e150:	e0bff915 	stw	r2,-28(fp)

        if (*fromlen > sizeof(sin)) {
 202e154:	e0800317 	ldw	r2,12(fp)
 202e158:	10800017 	ldw	r2,0(r2)
 202e15c:	10800470 	cmpltui	r2,r2,17
 202e160:	1000031e 	bne	r2,zero,202e170 <lwip_recvfrom+0x3d8>
          *fromlen = sizeof(sin);
 202e164:	e0800317 	ldw	r2,12(fp)
 202e168:	00c00404 	movi	r3,16
 202e16c:	10c00015 	stw	r3,0(r2)
        }

        MEMCPY(from, &sin, *fromlen);
 202e170:	e0800317 	ldw	r2,12(fp)
 202e174:	10c00017 	ldw	r3,0(r2)
 202e178:	e0bff804 	addi	r2,fp,-32
 202e17c:	180d883a 	mov	r6,r3
 202e180:	100b883a 	mov	r5,r2
 202e184:	e1000217 	ldw	r4,8(fp)
 202e188:	20060240 	call	2006024 <memcpy>
#endif /*  SOCKETS_DEBUG */
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
 202e18c:	e0bfff17 	ldw	r2,-4(fp)
 202e190:	1080004c 	andi	r2,r2,1
 202e194:	1000241e 	bne	r2,zero,202e228 <lwip_recvfrom+0x490>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
 202e198:	e0bff317 	ldw	r2,-52(fp)
 202e19c:	10800017 	ldw	r2,0(r2)
 202e1a0:	10800017 	ldw	r2,0(r2)
 202e1a4:	10800418 	cmpnei	r2,r2,16
 202e1a8:	10000f1e 	bne	r2,zero,202e1e8 <lwip_recvfrom+0x450>
 202e1ac:	e0fff40b 	ldhu	r3,-48(fp)
 202e1b0:	e0bfef0b 	ldhu	r2,-68(fp)
 202e1b4:	1885c83a 	sub	r2,r3,r2
 202e1b8:	00800b0e 	bge	zero,r2,202e1e8 <lwip_recvfrom+0x450>
        sock->lastdata = buf;
 202e1bc:	e0fff517 	ldw	r3,-44(fp)
 202e1c0:	e0bff317 	ldw	r2,-52(fp)
 202e1c4:	10c00115 	stw	r3,4(r2)
        sock->lastoffset += copylen;
 202e1c8:	e0bff317 	ldw	r2,-52(fp)
 202e1cc:	10c0020b 	ldhu	r3,8(r2)
 202e1d0:	e0bfef0b 	ldhu	r2,-68(fp)
 202e1d4:	1885883a 	add	r2,r3,r2
 202e1d8:	1007883a 	mov	r3,r2
 202e1dc:	e0bff317 	ldw	r2,-52(fp)
 202e1e0:	10c0020d 	sth	r3,8(r2)
 202e1e4:	00001006 	br	202e228 <lwip_recvfrom+0x490>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 202e1e8:	e0bff317 	ldw	r2,-52(fp)
 202e1ec:	10000115 	stw	zero,4(r2)
        sock->lastoffset = 0;
 202e1f0:	e0bff317 	ldw	r2,-52(fp)
 202e1f4:	1000020d 	sth	zero,8(r2)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
 202e1f8:	e0bff317 	ldw	r2,-52(fp)
 202e1fc:	10800017 	ldw	r2,0(r2)
 202e200:	10800017 	ldw	r2,0(r2)
 202e204:	10800418 	cmpnei	r2,r2,16
 202e208:	1000041e 	bne	r2,zero,202e21c <lwip_recvfrom+0x484>
          pbuf_free((struct pbuf *)buf);
 202e20c:	e0bff517 	ldw	r2,-44(fp)
 202e210:	1009883a 	mov	r4,r2
 202e214:	201ab680 	call	201ab68 <pbuf_free>
 202e218:	00000306 	br	202e228 <lwip_recvfrom+0x490>
        } else {
          netbuf_delete((struct netbuf *)buf);
 202e21c:	e0bff517 	ldw	r2,-44(fp)
 202e220:	1009883a 	mov	r4,r2
 202e224:	203c6240 	call	203c624 <netbuf_delete>
        }
      }
    }
  } while (!done);
 202e228:	e0bff203 	ldbu	r2,-56(fp)
 202e22c:	103eec26 	beq	r2,zero,202dde0 <__alt_mem_mem_0+0xfd00dde0>

  if (off > 0) {
 202e230:	e0bff017 	ldw	r2,-64(fp)
 202e234:	0080060e 	bge	zero,r2,202e250 <lwip_recvfrom+0x4b8>
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
 202e238:	e0bff317 	ldw	r2,-52(fp)
 202e23c:	10800017 	ldw	r2,0(r2)
 202e240:	e0fff017 	ldw	r3,-64(fp)
 202e244:	180b883a 	mov	r5,r3
 202e248:	1009883a 	mov	r4,r2
 202e24c:	2039c040 	call	2039c04 <netconn_recved>
  }
  sock_set_errno(sock, 0);
 202e250:	e0bff317 	ldw	r2,-52(fp)
 202e254:	10000415 	stw	zero,16(r2)
  return off;
 202e258:	e0bff017 	ldw	r2,-64(fp)
}
 202e25c:	e037883a 	mov	sp,fp
 202e260:	dfc00117 	ldw	ra,4(sp)
 202e264:	df000017 	ldw	fp,0(sp)
 202e268:	dec00204 	addi	sp,sp,8
 202e26c:	f800283a 	ret

0202e270 <lwip_read>:

int
lwip_read(int s, void *mem, size_t len)
{
 202e270:	defff904 	addi	sp,sp,-28
 202e274:	dfc00615 	stw	ra,24(sp)
 202e278:	df000515 	stw	fp,20(sp)
 202e27c:	df000504 	addi	fp,sp,20
 202e280:	e13ffd15 	stw	r4,-12(fp)
 202e284:	e17ffe15 	stw	r5,-8(fp)
 202e288:	e1bfff15 	stw	r6,-4(fp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 202e28c:	d8000115 	stw	zero,4(sp)
 202e290:	d8000015 	stw	zero,0(sp)
 202e294:	000f883a 	mov	r7,zero
 202e298:	e1bfff17 	ldw	r6,-4(fp)
 202e29c:	e17ffe17 	ldw	r5,-8(fp)
 202e2a0:	e13ffd17 	ldw	r4,-12(fp)
 202e2a4:	202dd980 	call	202dd98 <lwip_recvfrom>
}
 202e2a8:	e037883a 	mov	sp,fp
 202e2ac:	dfc00117 	ldw	ra,4(sp)
 202e2b0:	df000017 	ldw	fp,0(sp)
 202e2b4:	dec00204 	addi	sp,sp,8
 202e2b8:	f800283a 	ret

0202e2bc <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
 202e2bc:	defff804 	addi	sp,sp,-32
 202e2c0:	dfc00715 	stw	ra,28(sp)
 202e2c4:	df000615 	stw	fp,24(sp)
 202e2c8:	df000604 	addi	fp,sp,24
 202e2cc:	e13ffc15 	stw	r4,-16(fp)
 202e2d0:	e17ffd15 	stw	r5,-12(fp)
 202e2d4:	e1bffe15 	stw	r6,-8(fp)
 202e2d8:	e1ffff15 	stw	r7,-4(fp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 202e2dc:	d8000115 	stw	zero,4(sp)
 202e2e0:	d8000015 	stw	zero,0(sp)
 202e2e4:	e1ffff17 	ldw	r7,-4(fp)
 202e2e8:	e1bffe17 	ldw	r6,-8(fp)
 202e2ec:	e17ffd17 	ldw	r5,-12(fp)
 202e2f0:	e13ffc17 	ldw	r4,-16(fp)
 202e2f4:	202dd980 	call	202dd98 <lwip_recvfrom>
}
 202e2f8:	e037883a 	mov	sp,fp
 202e2fc:	dfc00117 	ldw	ra,4(sp)
 202e300:	df000017 	ldw	fp,0(sp)
 202e304:	dec00204 	addi	sp,sp,8
 202e308:	f800283a 	ret

0202e30c <lwip_send>:

int
lwip_send(int s, const void *data, size_t size, int flags)
{
 202e30c:	defff504 	addi	sp,sp,-44
 202e310:	dfc00a15 	stw	ra,40(sp)
 202e314:	df000915 	stw	fp,36(sp)
 202e318:	df000904 	addi	fp,sp,36
 202e31c:	e13ffc15 	stw	r4,-16(fp)
 202e320:	e17ffd15 	stw	r5,-12(fp)
 202e324:	e1bffe15 	stw	r6,-8(fp)
 202e328:	e1ffff15 	stw	r7,-4(fp)
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
 202e32c:	e13ffc17 	ldw	r4,-16(fp)
 202e330:	202d2f80 	call	202d2f8 <get_socket>
 202e334:	e0bff915 	stw	r2,-28(fp)
  if (!sock) {
 202e338:	e0bff917 	ldw	r2,-28(fp)
 202e33c:	1000021e 	bne	r2,zero,202e348 <lwip_send+0x3c>
    return -1;
 202e340:	00bfffc4 	movi	r2,-1
 202e344:	00003d06 	br	202e43c <lwip_send+0x130>
  }

  if (sock->conn->type != NETCONN_TCP) {
 202e348:	e0bff917 	ldw	r2,-28(fp)
 202e34c:	10800017 	ldw	r2,0(r2)
 202e350:	10800017 	ldw	r2,0(r2)
 202e354:	10800420 	cmpeqi	r2,r2,16
 202e358:	1000081e 	bne	r2,zero,202e37c <lwip_send+0x70>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
 202e35c:	d8000115 	stw	zero,4(sp)
 202e360:	d8000015 	stw	zero,0(sp)
 202e364:	e1ffff17 	ldw	r7,-4(fp)
 202e368:	e1bffe17 	ldw	r6,-8(fp)
 202e36c:	e17ffd17 	ldw	r5,-12(fp)
 202e370:	e13ffc17 	ldw	r4,-16(fp)
 202e374:	202e4500 	call	202e450 <lwip_sendto>
 202e378:	00003006 	br	202e43c <lwip_send+0x130>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
 202e37c:	e0bfff17 	ldw	r2,-4(fp)
 202e380:	1080040c 	andi	r2,r2,16
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 202e384:	10000226 	beq	r2,zero,202e390 <lwip_send+0x84>
 202e388:	008000c4 	movi	r2,3
 202e38c:	00000106 	br	202e394 <lwip_send+0x88>
 202e390:	00800044 	movi	r2,1
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
 202e394:	e0ffff17 	ldw	r3,-4(fp)
 202e398:	18c0020c 	andi	r3,r3,8
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 202e39c:	18000226 	beq	r3,zero,202e3a8 <lwip_send+0x9c>
 202e3a0:	00c00104 	movi	r3,4
 202e3a4:	00000106 	br	202e3ac <lwip_send+0xa0>
 202e3a8:	0007883a 	mov	r3,zero
 202e3ac:	10c4b03a 	or	r2,r2,r3
 202e3b0:	e0bffa05 	stb	r2,-24(fp)
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
 202e3b4:	e03ffb15 	stw	zero,-20(fp)
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
 202e3b8:	e0bff917 	ldw	r2,-28(fp)
 202e3bc:	10c00017 	ldw	r3,0(r2)
 202e3c0:	e13ffa03 	ldbu	r4,-24(fp)
 202e3c4:	e0bffb04 	addi	r2,fp,-20
 202e3c8:	d8800015 	stw	r2,0(sp)
 202e3cc:	200f883a 	mov	r7,r4
 202e3d0:	e1bffe17 	ldw	r6,-8(fp)
 202e3d4:	e17ffd17 	ldw	r5,-12(fp)
 202e3d8:	1809883a 	mov	r4,r3
 202e3dc:	2039dcc0 	call	2039dcc <netconn_write_partly>
 202e3e0:	e0bffa45 	stb	r2,-23(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
 202e3e4:	e0bffa47 	ldb	r2,-23(fp)
 202e3e8:	0085c83a 	sub	r2,zero,r2
 202e3ec:	10800428 	cmpgeui	r2,r2,16
 202e3f0:	1000091e 	bne	r2,zero,202e418 <lwip_send+0x10c>
 202e3f4:	e0bffa47 	ldb	r2,-23(fp)
 202e3f8:	0087c83a 	sub	r3,zero,r2
 202e3fc:	00808134 	movhi	r2,516
 202e400:	108d4204 	addi	r2,r2,13576
 202e404:	18c7883a 	add	r3,r3,r3
 202e408:	18c7883a 	add	r3,r3,r3
 202e40c:	10c5883a 	add	r2,r2,r3
 202e410:	10800017 	ldw	r2,0(r2)
 202e414:	00000106 	br	202e41c <lwip_send+0x110>
 202e418:	00800144 	movi	r2,5
 202e41c:	e0fff917 	ldw	r3,-28(fp)
 202e420:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? (int)written : -1);
 202e424:	e0bffa47 	ldb	r2,-23(fp)
 202e428:	1000021e 	bne	r2,zero,202e434 <lwip_send+0x128>
 202e42c:	e0bffb17 	ldw	r2,-20(fp)
 202e430:	00000206 	br	202e43c <lwip_send+0x130>
 202e434:	00bfffc4 	movi	r2,-1
 202e438:	0001883a 	nop
}
 202e43c:	e037883a 	mov	sp,fp
 202e440:	dfc00117 	ldw	ra,4(sp)
 202e444:	df000017 	ldw	fp,0(sp)
 202e448:	dec00204 	addi	sp,sp,8
 202e44c:	f800283a 	ret

0202e450 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
 202e450:	defff004 	addi	sp,sp,-64
 202e454:	dfc00f15 	stw	ra,60(sp)
 202e458:	df000e15 	stw	fp,56(sp)
 202e45c:	df000e04 	addi	fp,sp,56
 202e460:	e13ffc15 	stw	r4,-16(fp)
 202e464:	e17ffd15 	stw	r5,-12(fp)
 202e468:	e1bffe15 	stw	r6,-8(fp)
 202e46c:	e1ffff15 	stw	r7,-4(fp)
  u16_t remote_port;
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
#endif

  sock = get_socket(s);
 202e470:	e13ffc17 	ldw	r4,-16(fp)
 202e474:	202d2f80 	call	202d2f8 <get_socket>
 202e478:	e0bff315 	stw	r2,-52(fp)
  if (!sock) {
 202e47c:	e0bff317 	ldw	r2,-52(fp)
 202e480:	1000021e 	bne	r2,zero,202e48c <lwip_sendto+0x3c>
    return -1;
 202e484:	00bfffc4 	movi	r2,-1
 202e488:	00006a06 	br	202e634 <lwip_sendto+0x1e4>
  }

  if (sock->conn->type == NETCONN_TCP) {
 202e48c:	e0bff317 	ldw	r2,-52(fp)
 202e490:	10800017 	ldw	r2,0(r2)
 202e494:	10800017 	ldw	r2,0(r2)
 202e498:	10800418 	cmpnei	r2,r2,16
 202e49c:	1000061e 	bne	r2,zero,202e4b8 <lwip_sendto+0x68>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
 202e4a0:	e1ffff17 	ldw	r7,-4(fp)
 202e4a4:	e1bffe17 	ldw	r6,-8(fp)
 202e4a8:	e17ffd17 	ldw	r5,-12(fp)
 202e4ac:	e13ffc17 	ldw	r4,-16(fp)
 202e4b0:	202e30c0 	call	202e30c <lwip_send>
 202e4b4:	00005f06 	br	202e634 <lwip_sendto+0x1e4>
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  short_size = (u16_t)size;
 202e4b8:	e0bffe17 	ldw	r2,-8(fp)
 202e4bc:	e0bff40d 	sth	r2,-48(fp)
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 202e4c0:	e0800217 	ldw	r2,8(fp)
 202e4c4:	1000021e 	bne	r2,zero,202e4d0 <lwip_sendto+0x80>
 202e4c8:	e0800317 	ldw	r2,12(fp)
 202e4cc:	10001426 	beq	r2,zero,202e520 <lwip_sendto+0xd0>
 202e4d0:	e0800317 	ldw	r2,12(fp)
 202e4d4:	10800418 	cmpnei	r2,r2,16
 202e4d8:	1000081e 	bne	r2,zero,202e4fc <lwip_sendto+0xac>
 202e4dc:	e0800217 	ldw	r2,8(fp)
 202e4e0:	10800043 	ldbu	r2,1(r2)
 202e4e4:	10803fcc 	andi	r2,r2,255
 202e4e8:	10800098 	cmpnei	r2,r2,2
 202e4ec:	1000031e 	bne	r2,zero,202e4fc <lwip_sendto+0xac>
 202e4f0:	e0800217 	ldw	r2,8(fp)
 202e4f4:	108000cc 	andi	r2,r2,3
 202e4f8:	10000926 	beq	r2,zero,202e520 <lwip_sendto+0xd0>
 202e4fc:	01c08134 	movhi	r7,516
 202e500:	39cd5204 	addi	r7,r7,13640
 202e504:	0180cf44 	movi	r6,829
 202e508:	01408134 	movhi	r5,516
 202e50c:	294d7304 	addi	r5,r5,13772
 202e510:	01008134 	movhi	r4,516
 202e514:	210d5f04 	addi	r4,r4,13692
 202e518:	2000bb00 	call	2000bb0 <printf>
 202e51c:	003fff06 	br	202e51c <__alt_mem_mem_0+0xfd00e51c>
             ((tolen == sizeof(struct sockaddr_in)) &&
             ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  to_in = (const struct sockaddr_in *)(void*)to;
 202e520:	e0800217 	ldw	r2,8(fp)
 202e524:	e0bff515 	stw	r2,-44(fp)
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
 202e528:	e03ff815 	stw	zero,-32(fp)
 202e52c:	e0bff817 	ldw	r2,-32(fp)
 202e530:	e0bff715 	stw	r2,-36(fp)
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
 202e534:	e03ffa85 	stb	zero,-22(fp)
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
 202e538:	e0800217 	ldw	r2,8(fp)
 202e53c:	10001126 	beq	r2,zero,202e584 <lwip_sendto+0x134>
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
 202e540:	e0bff517 	ldw	r2,-44(fp)
 202e544:	10800117 	ldw	r2,4(r2)
 202e548:	e0bff915 	stw	r2,-28(fp)
    remote_port           = ntohs(to_in->sin_port);
 202e54c:	e0bff517 	ldw	r2,-44(fp)
 202e550:	1080008b 	ldhu	r2,2(r2)
 202e554:	10bfffcc 	andi	r2,r2,65535
 202e558:	1004d23a 	srli	r2,r2,8
 202e55c:	1007883a 	mov	r3,r2
 202e560:	e0bff517 	ldw	r2,-44(fp)
 202e564:	1080008b 	ldhu	r2,2(r2)
 202e568:	10bfffcc 	andi	r2,r2,65535
 202e56c:	1004923a 	slli	r2,r2,8
 202e570:	1884b03a 	or	r2,r3,r2
 202e574:	e0bff60d 	sth	r2,-40(fp)
    netbuf_fromport(&buf) = remote_port;
 202e578:	e0bff60b 	ldhu	r2,-40(fp)
 202e57c:	e0bffa0d 	sth	r2,-24(fp)
 202e580:	00000306 	br	202e590 <lwip_sendto+0x140>
  } else {
    remote_port           = 0;
 202e584:	e03ff60d 	sth	zero,-40(fp)
    ip_addr_set_any(&buf.addr);
 202e588:	e03ff915 	stw	zero,-28(fp)
    netbuf_fromport(&buf) = 0;
 202e58c:	e03ffa0d 	sth	zero,-24(fp)
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 202e590:	e0fff40b 	ldhu	r3,-48(fp)
 202e594:	e0bff704 	addi	r2,fp,-36
 202e598:	180d883a 	mov	r6,r3
 202e59c:	e17ffd17 	ldw	r5,-12(fp)
 202e5a0:	1009883a 	mov	r4,r2
 202e5a4:	203c7ec0 	call	203c7ec <netbuf_ref>
 202e5a8:	e0bff205 	stb	r2,-56(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
 202e5ac:	e0bff207 	ldb	r2,-56(fp)
 202e5b0:	1000071e 	bne	r2,zero,202e5d0 <lwip_sendto+0x180>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
 202e5b4:	e0bff317 	ldw	r2,-52(fp)
 202e5b8:	10800017 	ldw	r2,0(r2)
 202e5bc:	e0fff704 	addi	r3,fp,-36
 202e5c0:	180b883a 	mov	r5,r3
 202e5c4:	1009883a 	mov	r4,r2
 202e5c8:	2039d040 	call	2039d04 <netconn_send>
 202e5cc:	e0bff205 	stb	r2,-56(fp)
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
 202e5d0:	e0bff704 	addi	r2,fp,-36
 202e5d4:	1009883a 	mov	r4,r2
 202e5d8:	203c7600 	call	203c760 <netbuf_free>
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
 202e5dc:	e0bff207 	ldb	r2,-56(fp)
 202e5e0:	0085c83a 	sub	r2,zero,r2
 202e5e4:	10800428 	cmpgeui	r2,r2,16
 202e5e8:	1000091e 	bne	r2,zero,202e610 <lwip_sendto+0x1c0>
 202e5ec:	e0bff207 	ldb	r2,-56(fp)
 202e5f0:	0087c83a 	sub	r3,zero,r2
 202e5f4:	00808134 	movhi	r2,516
 202e5f8:	108d4204 	addi	r2,r2,13576
 202e5fc:	18c7883a 	add	r3,r3,r3
 202e600:	18c7883a 	add	r3,r3,r3
 202e604:	10c5883a 	add	r2,r2,r3
 202e608:	10800017 	ldw	r2,0(r2)
 202e60c:	00000106 	br	202e614 <lwip_sendto+0x1c4>
 202e610:	00800144 	movi	r2,5
 202e614:	e0fff317 	ldw	r3,-52(fp)
 202e618:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? short_size : -1);
 202e61c:	e0bff207 	ldb	r2,-56(fp)
 202e620:	1000021e 	bne	r2,zero,202e62c <lwip_sendto+0x1dc>
 202e624:	e0bff40b 	ldhu	r2,-48(fp)
 202e628:	00000206 	br	202e634 <lwip_sendto+0x1e4>
 202e62c:	00bfffc4 	movi	r2,-1
 202e630:	0001883a 	nop
}
 202e634:	e037883a 	mov	sp,fp
 202e638:	dfc00117 	ldw	ra,4(sp)
 202e63c:	df000017 	ldw	fp,0(sp)
 202e640:	dec00204 	addi	sp,sp,8
 202e644:	f800283a 	ret

0202e648 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
 202e648:	defff904 	addi	sp,sp,-28
 202e64c:	dfc00615 	stw	ra,24(sp)
 202e650:	df000515 	stw	fp,20(sp)
 202e654:	df000504 	addi	fp,sp,20
 202e658:	e13ffd15 	stw	r4,-12(fp)
 202e65c:	e17ffe15 	stw	r5,-8(fp)
 202e660:	e1bfff15 	stw	r6,-4(fp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
 202e664:	e0bffe17 	ldw	r2,-8(fp)
 202e668:	10c000a0 	cmpeqi	r3,r2,2
 202e66c:	18000e1e 	bne	r3,zero,202e6a8 <lwip_socket+0x60>
 202e670:	10c000e0 	cmpeqi	r3,r2,3
 202e674:	1800031e 	bne	r3,zero,202e684 <lwip_socket+0x3c>
 202e678:	10800060 	cmpeqi	r2,r2,1
 202e67c:	1000171e 	bne	r2,zero,202e6dc <lwip_socket+0x94>
 202e680:	00002506 	br	202e718 <lwip_socket+0xd0>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
 202e684:	e0bfff17 	ldw	r2,-4(fp)
 202e688:	10803fcc 	andi	r2,r2,255
 202e68c:	018080f4 	movhi	r6,515
 202e690:	31bc0d04 	addi	r6,r6,-4044
 202e694:	100b883a 	mov	r5,r2
 202e698:	01001004 	movi	r4,64
 202e69c:	2038fcc0 	call	2038fcc <netconn_new_with_proto_and_callback>
 202e6a0:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
 202e6a4:	00001f06 	br	202e724 <lwip_socket+0xdc>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
 202e6a8:	e0bfff17 	ldw	r2,-4(fp)
 202e6ac:	10802218 	cmpnei	r2,r2,136
 202e6b0:	1000021e 	bne	r2,zero,202e6bc <lwip_socket+0x74>
 202e6b4:	00800844 	movi	r2,33
 202e6b8:	00000106 	br	202e6c0 <lwip_socket+0x78>
 202e6bc:	00800804 	movi	r2,32
 202e6c0:	018080f4 	movhi	r6,515
 202e6c4:	31bc0d04 	addi	r6,r6,-4044
 202e6c8:	000b883a 	mov	r5,zero
 202e6cc:	1009883a 	mov	r4,r2
 202e6d0:	2038fcc0 	call	2038fcc <netconn_new_with_proto_and_callback>
 202e6d4:	e0bffb15 	stw	r2,-20(fp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
 202e6d8:	00001206 	br	202e724 <lwip_socket+0xdc>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
 202e6dc:	018080f4 	movhi	r6,515
 202e6e0:	31bc0d04 	addi	r6,r6,-4044
 202e6e4:	000b883a 	mov	r5,zero
 202e6e8:	01000404 	movi	r4,16
 202e6ec:	2038fcc0 	call	2038fcc <netconn_new_with_proto_and_callback>
 202e6f0:	e0bffb15 	stw	r2,-20(fp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
 202e6f4:	e0bffb17 	ldw	r2,-20(fp)
 202e6f8:	10000926 	beq	r2,zero,202e720 <lwip_socket+0xd8>
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
 202e6fc:	e0bffb17 	ldw	r2,-20(fp)
 202e700:	10800903 	ldbu	r2,36(r2)
 202e704:	10800214 	ori	r2,r2,8
 202e708:	1007883a 	mov	r3,r2
 202e70c:	e0bffb17 	ldw	r2,-20(fp)
 202e710:	10c00905 	stb	r3,36(r2)
    }
    break;
 202e714:	00000206 	br	202e720 <lwip_socket+0xd8>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
 202e718:	00bfffc4 	movi	r2,-1
 202e71c:	00001706 	br	202e77c <lwip_socket+0x134>
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
    }
    break;
 202e720:	0001883a 	nop
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
 202e724:	e0bffb17 	ldw	r2,-20(fp)
 202e728:	1000021e 	bne	r2,zero,202e734 <lwip_socket+0xec>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
 202e72c:	00bfffc4 	movi	r2,-1
 202e730:	00001206 	br	202e77c <lwip_socket+0x134>
  }

  i = alloc_socket(conn, 0);
 202e734:	000b883a 	mov	r5,zero
 202e738:	e13ffb17 	ldw	r4,-20(fp)
 202e73c:	202d3f00 	call	202d3f0 <alloc_socket>
 202e740:	e0bffc15 	stw	r2,-16(fp)

  if (i == -1) {
 202e744:	e0bffc17 	ldw	r2,-16(fp)
 202e748:	10bfffd8 	cmpnei	r2,r2,-1
 202e74c:	1000041e 	bne	r2,zero,202e760 <lwip_socket+0x118>
    netconn_delete(conn);
 202e750:	e13ffb17 	ldw	r4,-20(fp)
 202e754:	20390880 	call	2039088 <netconn_delete>
    set_errno(ENFILE);
    return -1;
 202e758:	00bfffc4 	movi	r2,-1
 202e75c:	00000706 	br	202e77c <lwip_socket+0x134>
  }

  i += LWIP_SOCKET_OFFSET;
 202e760:	e0bffc17 	ldw	r2,-16(fp)
 202e764:	10800804 	addi	r2,r2,32
 202e768:	e0bffc15 	stw	r2,-16(fp)

  conn->socket = i;
 202e76c:	e0bffb17 	ldw	r2,-20(fp)
 202e770:	e0fffc17 	ldw	r3,-16(fp)
 202e774:	10c00715 	stw	r3,28(r2)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
 202e778:	e0bffc17 	ldw	r2,-16(fp)
}
 202e77c:	e037883a 	mov	sp,fp
 202e780:	dfc00117 	ldw	ra,4(sp)
 202e784:	df000017 	ldw	fp,0(sp)
 202e788:	dec00204 	addi	sp,sp,8
 202e78c:	f800283a 	ret

0202e790 <lwip_write>:

int
lwip_write(int s, const void *data, size_t size)
{
 202e790:	defffb04 	addi	sp,sp,-20
 202e794:	dfc00415 	stw	ra,16(sp)
 202e798:	df000315 	stw	fp,12(sp)
 202e79c:	df000304 	addi	fp,sp,12
 202e7a0:	e13ffd15 	stw	r4,-12(fp)
 202e7a4:	e17ffe15 	stw	r5,-8(fp)
 202e7a8:	e1bfff15 	stw	r6,-4(fp)
  return lwip_send(s, data, size, 0);
 202e7ac:	000f883a 	mov	r7,zero
 202e7b0:	e1bfff17 	ldw	r6,-4(fp)
 202e7b4:	e17ffe17 	ldw	r5,-8(fp)
 202e7b8:	e13ffd17 	ldw	r4,-12(fp)
 202e7bc:	202e30c0 	call	202e30c <lwip_send>
}
 202e7c0:	e037883a 	mov	sp,fp
 202e7c4:	dfc00117 	ldw	ra,4(sp)
 202e7c8:	df000017 	ldw	fp,0(sp)
 202e7cc:	dec00204 	addi	sp,sp,8
 202e7d0:	f800283a 	ret

0202e7d4 <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
 202e7d4:	deffe804 	addi	sp,sp,-96
 202e7d8:	dfc01715 	stw	ra,92(sp)
 202e7dc:	df001615 	stw	fp,88(sp)
 202e7e0:	df001604 	addi	fp,sp,88
 202e7e4:	e13ffc15 	stw	r4,-16(fp)
 202e7e8:	e17ffd15 	stw	r5,-12(fp)
 202e7ec:	e1bffe15 	stw	r6,-8(fp)
 202e7f0:	e1ffff15 	stw	r7,-4(fp)
  int i, nready = 0;
 202e7f4:	e03feb15 	stw	zero,-84(fp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
 202e7f8:	e0bff604 	addi	r2,fp,-40
 202e7fc:	e0bfed15 	stw	r2,-76(fp)
 202e800:	e03fec15 	stw	zero,-80(fp)
 202e804:	00000706 	br	202e824 <lwip_selscan+0x50>
 202e808:	e0bfed17 	ldw	r2,-76(fp)
 202e80c:	10c00044 	addi	r3,r2,1
 202e810:	e0ffed15 	stw	r3,-76(fp)
 202e814:	10000005 	stb	zero,0(r2)
 202e818:	e0bfec17 	ldw	r2,-80(fp)
 202e81c:	10800044 	addi	r2,r2,1
 202e820:	e0bfec15 	stw	r2,-80(fp)
 202e824:	e0bfec17 	ldw	r2,-80(fp)
 202e828:	10800230 	cmpltui	r2,r2,8
 202e82c:	103ff61e 	bne	r2,zero,202e808 <__alt_mem_mem_0+0xfd00e808>
  FD_ZERO(&lwriteset);
 202e830:	e0bff804 	addi	r2,fp,-32
 202e834:	e0bfef15 	stw	r2,-68(fp)
 202e838:	e03fee15 	stw	zero,-72(fp)
 202e83c:	00000706 	br	202e85c <lwip_selscan+0x88>
 202e840:	e0bfef17 	ldw	r2,-68(fp)
 202e844:	10c00044 	addi	r3,r2,1
 202e848:	e0ffef15 	stw	r3,-68(fp)
 202e84c:	10000005 	stb	zero,0(r2)
 202e850:	e0bfee17 	ldw	r2,-72(fp)
 202e854:	10800044 	addi	r2,r2,1
 202e858:	e0bfee15 	stw	r2,-72(fp)
 202e85c:	e0bfee17 	ldw	r2,-72(fp)
 202e860:	10800230 	cmpltui	r2,r2,8
 202e864:	103ff61e 	bne	r2,zero,202e840 <__alt_mem_mem_0+0xfd00e840>
  FD_ZERO(&lexceptset);
 202e868:	e0bffa04 	addi	r2,fp,-24
 202e86c:	e0bff115 	stw	r2,-60(fp)
 202e870:	e03ff015 	stw	zero,-64(fp)
 202e874:	00000706 	br	202e894 <lwip_selscan+0xc0>
 202e878:	e0bff117 	ldw	r2,-60(fp)
 202e87c:	10c00044 	addi	r3,r2,1
 202e880:	e0fff115 	stw	r3,-60(fp)
 202e884:	10000005 	stb	zero,0(r2)
 202e888:	e0bff017 	ldw	r2,-64(fp)
 202e88c:	10800044 	addi	r2,r2,1
 202e890:	e0bff015 	stw	r2,-64(fp)
 202e894:	e0bff017 	ldw	r2,-64(fp)
 202e898:	10800230 	cmpltui	r2,r2,8
 202e89c:	103ff61e 	bne	r2,zero,202e878 <__alt_mem_mem_0+0xfd00e878>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202e8a0:	00800804 	movi	r2,32
 202e8a4:	e0bfea15 	stw	r2,-88(fp)
 202e8a8:	00009206 	br	202eaf4 <lwip_selscan+0x320>
    void* lastdata = NULL;
 202e8ac:	e03ff215 	stw	zero,-56(fp)
    s16_t rcvevent = 0;
 202e8b0:	e03ff30d 	sth	zero,-52(fp)
    u16_t sendevent = 0;
 202e8b4:	e03ff38d 	sth	zero,-50(fp)
    u16_t errevent = 0;
 202e8b8:	e03ff40d 	sth	zero,-48(fp)
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
 202e8bc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202e8c0:	10000126 	beq	r2,zero,202e8c8 <lwip_selscan+0xf4>
 202e8c4:	2010f300 	call	2010f30 <vTaskEnterCritical>
    sock = tryget_socket(i);
 202e8c8:	e13fea17 	ldw	r4,-88(fp)
 202e8cc:	202d3700 	call	202d370 <tryget_socket>
 202e8d0:	e0bff515 	stw	r2,-44(fp)
    if (sock != NULL) {
 202e8d4:	e0bff517 	ldw	r2,-44(fp)
 202e8d8:	10000c26 	beq	r2,zero,202e90c <lwip_selscan+0x138>
      lastdata = sock->lastdata;
 202e8dc:	e0bff517 	ldw	r2,-44(fp)
 202e8e0:	10800117 	ldw	r2,4(r2)
 202e8e4:	e0bff215 	stw	r2,-56(fp)
      rcvevent = sock->rcvevent;
 202e8e8:	e0bff517 	ldw	r2,-44(fp)
 202e8ec:	1080028b 	ldhu	r2,10(r2)
 202e8f0:	e0bff30d 	sth	r2,-52(fp)
      sendevent = sock->sendevent;
 202e8f4:	e0bff517 	ldw	r2,-44(fp)
 202e8f8:	1080030b 	ldhu	r2,12(r2)
 202e8fc:	e0bff38d 	sth	r2,-50(fp)
      errevent = sock->errevent;
 202e900:	e0bff517 	ldw	r2,-44(fp)
 202e904:	1080038b 	ldhu	r2,14(r2)
 202e908:	e0bff40d 	sth	r2,-48(fp)
    }
    SYS_ARCH_UNPROTECT(lev);
 202e90c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202e910:	10000126 	beq	r2,zero,202e918 <lwip_selscan+0x144>
 202e914:	2010f780 	call	2010f78 <vTaskExitCritical>
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 202e918:	e0bffd17 	ldw	r2,-12(fp)
 202e91c:	10002626 	beq	r2,zero,202e9b8 <lwip_selscan+0x1e4>
 202e920:	e0bfea17 	ldw	r2,-88(fp)
 202e924:	1004d17a 	srli	r2,r2,5
 202e928:	e0fffd17 	ldw	r3,-12(fp)
 202e92c:	1085883a 	add	r2,r2,r2
 202e930:	1085883a 	add	r2,r2,r2
 202e934:	1885883a 	add	r2,r3,r2
 202e938:	10c00017 	ldw	r3,0(r2)
 202e93c:	e0bfea17 	ldw	r2,-88(fp)
 202e940:	108007cc 	andi	r2,r2,31
 202e944:	1885d83a 	sra	r2,r3,r2
 202e948:	1080004c 	andi	r2,r2,1
 202e94c:	10001a26 	beq	r2,zero,202e9b8 <lwip_selscan+0x1e4>
 202e950:	e0bff217 	ldw	r2,-56(fp)
 202e954:	1000021e 	bne	r2,zero,202e960 <lwip_selscan+0x18c>
 202e958:	e0bff30f 	ldh	r2,-52(fp)
 202e95c:	0080160e 	bge	zero,r2,202e9b8 <lwip_selscan+0x1e4>
      FD_SET(i, &lreadset);
 202e960:	e0bfea17 	ldw	r2,-88(fp)
 202e964:	1004d17a 	srli	r2,r2,5
 202e968:	1087883a 	add	r3,r2,r2
 202e96c:	18c7883a 	add	r3,r3,r3
 202e970:	e13fea04 	addi	r4,fp,-88
 202e974:	20c7883a 	add	r3,r4,r3
 202e978:	18c00c04 	addi	r3,r3,48
 202e97c:	19000017 	ldw	r4,0(r3)
 202e980:	e0ffea17 	ldw	r3,-88(fp)
 202e984:	18c007cc 	andi	r3,r3,31
 202e988:	01400044 	movi	r5,1
 202e98c:	28c6983a 	sll	r3,r5,r3
 202e990:	20c6b03a 	or	r3,r4,r3
 202e994:	1085883a 	add	r2,r2,r2
 202e998:	1085883a 	add	r2,r2,r2
 202e99c:	e13fea04 	addi	r4,fp,-88
 202e9a0:	2085883a 	add	r2,r4,r2
 202e9a4:	10800c04 	addi	r2,r2,48
 202e9a8:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
 202e9ac:	e0bfeb17 	ldw	r2,-84(fp)
 202e9b0:	10800044 	addi	r2,r2,1
 202e9b4:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
 202e9b8:	e0bffe17 	ldw	r2,-8(fp)
 202e9bc:	10002426 	beq	r2,zero,202ea50 <lwip_selscan+0x27c>
 202e9c0:	e0bfea17 	ldw	r2,-88(fp)
 202e9c4:	1004d17a 	srli	r2,r2,5
 202e9c8:	e0fffe17 	ldw	r3,-8(fp)
 202e9cc:	1085883a 	add	r2,r2,r2
 202e9d0:	1085883a 	add	r2,r2,r2
 202e9d4:	1885883a 	add	r2,r3,r2
 202e9d8:	10c00017 	ldw	r3,0(r2)
 202e9dc:	e0bfea17 	ldw	r2,-88(fp)
 202e9e0:	108007cc 	andi	r2,r2,31
 202e9e4:	1885d83a 	sra	r2,r3,r2
 202e9e8:	1080004c 	andi	r2,r2,1
 202e9ec:	10001826 	beq	r2,zero,202ea50 <lwip_selscan+0x27c>
 202e9f0:	e0bff38b 	ldhu	r2,-50(fp)
 202e9f4:	10001626 	beq	r2,zero,202ea50 <lwip_selscan+0x27c>
      FD_SET(i, &lwriteset);
 202e9f8:	e0bfea17 	ldw	r2,-88(fp)
 202e9fc:	1004d17a 	srli	r2,r2,5
 202ea00:	1087883a 	add	r3,r2,r2
 202ea04:	18c7883a 	add	r3,r3,r3
 202ea08:	e13fea04 	addi	r4,fp,-88
 202ea0c:	20c7883a 	add	r3,r4,r3
 202ea10:	18c00e04 	addi	r3,r3,56
 202ea14:	19000017 	ldw	r4,0(r3)
 202ea18:	e0ffea17 	ldw	r3,-88(fp)
 202ea1c:	18c007cc 	andi	r3,r3,31
 202ea20:	01400044 	movi	r5,1
 202ea24:	28c6983a 	sll	r3,r5,r3
 202ea28:	20c6b03a 	or	r3,r4,r3
 202ea2c:	1085883a 	add	r2,r2,r2
 202ea30:	1085883a 	add	r2,r2,r2
 202ea34:	e13fea04 	addi	r4,fp,-88
 202ea38:	2085883a 	add	r2,r4,r2
 202ea3c:	10800e04 	addi	r2,r2,56
 202ea40:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
 202ea44:	e0bfeb17 	ldw	r2,-84(fp)
 202ea48:	10800044 	addi	r2,r2,1
 202ea4c:	e0bfeb15 	stw	r2,-84(fp)
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
 202ea50:	e0bfff17 	ldw	r2,-4(fp)
 202ea54:	10002426 	beq	r2,zero,202eae8 <lwip_selscan+0x314>
 202ea58:	e0bfea17 	ldw	r2,-88(fp)
 202ea5c:	1004d17a 	srli	r2,r2,5
 202ea60:	e0ffff17 	ldw	r3,-4(fp)
 202ea64:	1085883a 	add	r2,r2,r2
 202ea68:	1085883a 	add	r2,r2,r2
 202ea6c:	1885883a 	add	r2,r3,r2
 202ea70:	10c00017 	ldw	r3,0(r2)
 202ea74:	e0bfea17 	ldw	r2,-88(fp)
 202ea78:	108007cc 	andi	r2,r2,31
 202ea7c:	1885d83a 	sra	r2,r3,r2
 202ea80:	1080004c 	andi	r2,r2,1
 202ea84:	10001826 	beq	r2,zero,202eae8 <lwip_selscan+0x314>
 202ea88:	e0bff40b 	ldhu	r2,-48(fp)
 202ea8c:	10001626 	beq	r2,zero,202eae8 <lwip_selscan+0x314>
      FD_SET(i, &lexceptset);
 202ea90:	e0bfea17 	ldw	r2,-88(fp)
 202ea94:	1004d17a 	srli	r2,r2,5
 202ea98:	1087883a 	add	r3,r2,r2
 202ea9c:	18c7883a 	add	r3,r3,r3
 202eaa0:	e13fea04 	addi	r4,fp,-88
 202eaa4:	20c7883a 	add	r3,r4,r3
 202eaa8:	18c01004 	addi	r3,r3,64
 202eaac:	19000017 	ldw	r4,0(r3)
 202eab0:	e0ffea17 	ldw	r3,-88(fp)
 202eab4:	18c007cc 	andi	r3,r3,31
 202eab8:	01400044 	movi	r5,1
 202eabc:	28c6983a 	sll	r3,r5,r3
 202eac0:	20c6b03a 	or	r3,r4,r3
 202eac4:	1085883a 	add	r2,r2,r2
 202eac8:	1085883a 	add	r2,r2,r2
 202eacc:	e13fea04 	addi	r4,fp,-88
 202ead0:	2085883a 	add	r2,r4,r2
 202ead4:	10801004 	addi	r2,r2,64
 202ead8:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
 202eadc:	e0bfeb17 	ldw	r2,-84(fp)
 202eae0:	10800044 	addi	r2,r2,1
 202eae4:	e0bfeb15 	stw	r2,-84(fp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202eae8:	e0bfea17 	ldw	r2,-88(fp)
 202eaec:	10800044 	addi	r2,r2,1
 202eaf0:	e0bfea15 	stw	r2,-88(fp)
 202eaf4:	e0ffea17 	ldw	r3,-88(fp)
 202eaf8:	e0bffc17 	ldw	r2,-16(fp)
 202eafc:	18bf6b16 	blt	r3,r2,202e8ac <__alt_mem_mem_0+0xfd00e8ac>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
 202eb00:	e0800217 	ldw	r2,8(fp)
 202eb04:	e0fff617 	ldw	r3,-40(fp)
 202eb08:	10c00015 	stw	r3,0(r2)
 202eb0c:	e0fff717 	ldw	r3,-36(fp)
 202eb10:	10c00115 	stw	r3,4(r2)
  *writeset_out = lwriteset;
 202eb14:	e0800317 	ldw	r2,12(fp)
 202eb18:	e0fff817 	ldw	r3,-32(fp)
 202eb1c:	10c00015 	stw	r3,0(r2)
 202eb20:	e0fff917 	ldw	r3,-28(fp)
 202eb24:	10c00115 	stw	r3,4(r2)
  *exceptset_out = lexceptset;
 202eb28:	e0800417 	ldw	r2,16(fp)
 202eb2c:	e0fffa17 	ldw	r3,-24(fp)
 202eb30:	10c00015 	stw	r3,0(r2)
 202eb34:	e0fffb17 	ldw	r3,-20(fp)
 202eb38:	10c00115 	stw	r3,4(r2)

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
 202eb3c:	e0bfeb17 	ldw	r2,-84(fp)
}
 202eb40:	e037883a 	mov	sp,fp
 202eb44:	dfc00117 	ldw	ra,4(sp)
 202eb48:	df000017 	ldw	fp,0(sp)
 202eb4c:	dec00204 	addi	sp,sp,8
 202eb50:	f800283a 	ret

0202eb54 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
 202eb54:	deffe204 	addi	sp,sp,-120
 202eb58:	dfc01d15 	stw	ra,116(sp)
 202eb5c:	df001c15 	stw	fp,112(sp)
 202eb60:	dc001b15 	stw	r16,108(sp)
 202eb64:	df001c04 	addi	fp,sp,112
 202eb68:	e13ffb15 	stw	r4,-20(fp)
 202eb6c:	e17ffc15 	stw	r5,-16(fp)
 202eb70:	e1bffd15 	stw	r6,-12(fp)
 202eb74:	e1fffe15 	stw	r7,-8(fp)
  u32_t waitres = 0;
 202eb78:	e03fe715 	stw	zero,-100(fp)
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 202eb7c:	e0bff204 	addi	r2,fp,-56
 202eb80:	d8800215 	stw	r2,8(sp)
 202eb84:	e0bff004 	addi	r2,fp,-64
 202eb88:	d8800115 	stw	r2,4(sp)
 202eb8c:	e0bfee04 	addi	r2,fp,-72
 202eb90:	d8800015 	stw	r2,0(sp)
 202eb94:	e1fffe17 	ldw	r7,-8(fp)
 202eb98:	e1bffd17 	ldw	r6,-12(fp)
 202eb9c:	e17ffc17 	ldw	r5,-16(fp)
 202eba0:	e13ffb17 	ldw	r4,-20(fp)
 202eba4:	202e7d40 	call	202e7d4 <lwip_selscan>
 202eba8:	e0bfe815 	stw	r2,-96(fp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
 202ebac:	e0bfe817 	ldw	r2,-96(fp)
 202ebb0:	1001041e 	bne	r2,zero,202efc4 <lwip_select+0x470>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
 202ebb4:	e0800217 	ldw	r2,8(fp)
 202ebb8:	10000626 	beq	r2,zero,202ebd4 <lwip_select+0x80>
 202ebbc:	e0800217 	ldw	r2,8(fp)
 202ebc0:	10800017 	ldw	r2,0(r2)
 202ebc4:	1000031e 	bne	r2,zero,202ebd4 <lwip_select+0x80>
 202ebc8:	e0800217 	ldw	r2,8(fp)
 202ebcc:	10800117 	ldw	r2,4(r2)
 202ebd0:	1000f926 	beq	r2,zero,202efb8 <lwip_select+0x464>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
 202ebd4:	e03ff415 	stw	zero,-48(fp)
    select_cb.prev = NULL;
 202ebd8:	e03ff515 	stw	zero,-44(fp)
    select_cb.readset = readset;
 202ebdc:	e0bffc17 	ldw	r2,-16(fp)
 202ebe0:	e0bff615 	stw	r2,-40(fp)
    select_cb.writeset = writeset;
 202ebe4:	e0bffd17 	ldw	r2,-12(fp)
 202ebe8:	e0bff715 	stw	r2,-36(fp)
    select_cb.exceptset = exceptset;
 202ebec:	e0bffe17 	ldw	r2,-8(fp)
 202ebf0:	e0bff815 	stw	r2,-32(fp)
    select_cb.sem_signalled = 0;
 202ebf4:	e03ff915 	stw	zero,-28(fp)
    err = sys_sem_new(&select_cb.sem, 0);
 202ebf8:	e0bff404 	addi	r2,fp,-48
 202ebfc:	10800604 	addi	r2,r2,24
 202ec00:	000b883a 	mov	r5,zero
 202ec04:	1009883a 	mov	r4,r2
 202ec08:	2014dfc0 	call	2014dfc <sys_sem_new>
 202ec0c:	e0bfeb05 	stb	r2,-84(fp)
    if (err != ERR_OK) {
 202ec10:	e0bfeb07 	ldb	r2,-84(fp)
 202ec14:	10000226 	beq	r2,zero,202ec20 <lwip_select+0xcc>
      /* failed to create semaphore */
      set_errno(ENOMEM);
      return -1;
 202ec18:	00bfffc4 	movi	r2,-1
 202ec1c:	0000ff06 	br	202f01c <lwip_select+0x4c8>
    }

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
 202ec20:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ec24:	10000126 	beq	r2,zero,202ec2c <lwip_select+0xd8>
 202ec28:	2010f300 	call	2010f30 <vTaskEnterCritical>

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
 202ec2c:	d0a80c17 	ldw	r2,-24528(gp)
 202ec30:	e0bff415 	stw	r2,-48(fp)
    if (select_cb_list != NULL) {
 202ec34:	d0a80c17 	ldw	r2,-24528(gp)
 202ec38:	10000326 	beq	r2,zero,202ec48 <lwip_select+0xf4>
      select_cb_list->prev = &select_cb;
 202ec3c:	d0a80c17 	ldw	r2,-24528(gp)
 202ec40:	e0fff404 	addi	r3,fp,-48
 202ec44:	10c00115 	stw	r3,4(r2)
    }
    select_cb_list = &select_cb;
 202ec48:	e0bff404 	addi	r2,fp,-48
 202ec4c:	d0a80c15 	stw	r2,-24528(gp)
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 202ec50:	d0a80d17 	ldw	r2,-24524(gp)
 202ec54:	10800044 	addi	r2,r2,1
 202ec58:	d0a80d15 	stw	r2,-24524(gp)

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
 202ec5c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ec60:	10000126 	beq	r2,zero,202ec68 <lwip_select+0x114>
 202ec64:	2010f780 	call	2010f78 <vTaskExitCritical>

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202ec68:	00800804 	movi	r2,32
 202ec6c:	e0bfea15 	stw	r2,-88(fp)
 202ec70:	00003b06 	br	202ed60 <lwip_select+0x20c>
      if ((readset && FD_ISSET(i, readset)) ||
 202ec74:	e0bffc17 	ldw	r2,-16(fp)
 202ec78:	10000c26 	beq	r2,zero,202ecac <lwip_select+0x158>
 202ec7c:	e0bfea17 	ldw	r2,-88(fp)
 202ec80:	1004d17a 	srli	r2,r2,5
 202ec84:	e0fffc17 	ldw	r3,-16(fp)
 202ec88:	1085883a 	add	r2,r2,r2
 202ec8c:	1085883a 	add	r2,r2,r2
 202ec90:	1885883a 	add	r2,r3,r2
 202ec94:	10c00017 	ldw	r3,0(r2)
 202ec98:	e0bfea17 	ldw	r2,-88(fp)
 202ec9c:	108007cc 	andi	r2,r2,31
 202eca0:	1885d83a 	sra	r2,r3,r2
 202eca4:	1080004c 	andi	r2,r2,1
 202eca8:	10001c1e 	bne	r2,zero,202ed1c <lwip_select+0x1c8>
 202ecac:	e0bffd17 	ldw	r2,-12(fp)
 202ecb0:	10000c26 	beq	r2,zero,202ece4 <lwip_select+0x190>
          (writeset && FD_ISSET(i, writeset)) ||
 202ecb4:	e0bfea17 	ldw	r2,-88(fp)
 202ecb8:	1004d17a 	srli	r2,r2,5
 202ecbc:	e0fffd17 	ldw	r3,-12(fp)
 202ecc0:	1085883a 	add	r2,r2,r2
 202ecc4:	1085883a 	add	r2,r2,r2
 202ecc8:	1885883a 	add	r2,r3,r2
 202eccc:	10c00017 	ldw	r3,0(r2)
 202ecd0:	e0bfea17 	ldw	r2,-88(fp)
 202ecd4:	108007cc 	andi	r2,r2,31
 202ecd8:	1885d83a 	sra	r2,r3,r2
 202ecdc:	1080004c 	andi	r2,r2,1
 202ece0:	10000e1e 	bne	r2,zero,202ed1c <lwip_select+0x1c8>
 202ece4:	e0bffe17 	ldw	r2,-8(fp)
 202ece8:	10001a26 	beq	r2,zero,202ed54 <lwip_select+0x200>
          (exceptset && FD_ISSET(i, exceptset))) {
 202ecec:	e0bfea17 	ldw	r2,-88(fp)
 202ecf0:	1004d17a 	srli	r2,r2,5
 202ecf4:	e0fffe17 	ldw	r3,-8(fp)
 202ecf8:	1085883a 	add	r2,r2,r2
 202ecfc:	1085883a 	add	r2,r2,r2
 202ed00:	1885883a 	add	r2,r3,r2
 202ed04:	10c00017 	ldw	r3,0(r2)
 202ed08:	e0bfea17 	ldw	r2,-88(fp)
 202ed0c:	108007cc 	andi	r2,r2,31
 202ed10:	1885d83a 	sra	r2,r3,r2
 202ed14:	1080004c 	andi	r2,r2,1
 202ed18:	10000e26 	beq	r2,zero,202ed54 <lwip_select+0x200>
        struct lwip_sock *sock = tryget_socket(i);
 202ed1c:	e13fea17 	ldw	r4,-88(fp)
 202ed20:	202d3700 	call	202d370 <tryget_socket>
 202ed24:	e0bfec15 	stw	r2,-80(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 202ed28:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ed2c:	10000126 	beq	r2,zero,202ed34 <lwip_select+0x1e0>
 202ed30:	2010f300 	call	2010f30 <vTaskEnterCritical>
        sock->select_waiting++;
 202ed34:	e0bfec17 	ldw	r2,-80(fp)
 202ed38:	10800517 	ldw	r2,20(r2)
 202ed3c:	10c00044 	addi	r3,r2,1
 202ed40:	e0bfec17 	ldw	r2,-80(fp)
 202ed44:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
        SYS_ARCH_UNPROTECT(lev);
 202ed48:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ed4c:	10000126 	beq	r2,zero,202ed54 <lwip_select+0x200>
 202ed50:	2010f780 	call	2010f78 <vTaskExitCritical>

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202ed54:	e0bfea17 	ldw	r2,-88(fp)
 202ed58:	10800044 	addi	r2,r2,1
 202ed5c:	e0bfea15 	stw	r2,-88(fp)
 202ed60:	e0ffea17 	ldw	r3,-88(fp)
 202ed64:	e0bffb17 	ldw	r2,-20(fp)
 202ed68:	18bfc216 	blt	r3,r2,202ec74 <__alt_mem_mem_0+0xfd00ec74>
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 202ed6c:	e0bff204 	addi	r2,fp,-56
 202ed70:	d8800215 	stw	r2,8(sp)
 202ed74:	e0bff004 	addi	r2,fp,-64
 202ed78:	d8800115 	stw	r2,4(sp)
 202ed7c:	e0bfee04 	addi	r2,fp,-72
 202ed80:	d8800015 	stw	r2,0(sp)
 202ed84:	e1fffe17 	ldw	r7,-8(fp)
 202ed88:	e1bffd17 	ldw	r6,-12(fp)
 202ed8c:	e17ffc17 	ldw	r5,-16(fp)
 202ed90:	e13ffb17 	ldw	r4,-20(fp)
 202ed94:	202e7d40 	call	202e7d4 <lwip_selscan>
 202ed98:	e0bfe815 	stw	r2,-96(fp)
    if (!nready) {
 202ed9c:	e0bfe817 	ldw	r2,-96(fp)
 202eda0:	1000191e 	bne	r2,zero,202ee08 <lwip_select+0x2b4>
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
 202eda4:	e0800217 	ldw	r2,8(fp)
 202eda8:	1000021e 	bne	r2,zero,202edb4 <lwip_select+0x260>
        /* Wait forever */
        msectimeout = 0;
 202edac:	e03fe915 	stw	zero,-92(fp)
 202edb0:	00000f06 	br	202edf0 <lwip_select+0x29c>
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
 202edb4:	e0800217 	ldw	r2,8(fp)
 202edb8:	10800017 	ldw	r2,0(r2)
 202edbc:	1400fa24 	muli	r16,r2,1000
 202edc0:	e0800217 	ldw	r2,8(fp)
 202edc4:	10800117 	ldw	r2,4(r2)
 202edc8:	10807d04 	addi	r2,r2,500
 202edcc:	0140fa04 	movi	r5,1000
 202edd0:	1009883a 	mov	r4,r2
 202edd4:	200abb00 	call	200abb0 <__divsi3>
 202edd8:	8085883a 	add	r2,r16,r2
 202eddc:	e0bfe915 	stw	r2,-92(fp)
        if (msectimeout == 0) {
 202ede0:	e0bfe917 	ldw	r2,-92(fp)
 202ede4:	1000021e 	bne	r2,zero,202edf0 <lwip_select+0x29c>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
 202ede8:	00800044 	movi	r2,1
 202edec:	e0bfe915 	stw	r2,-92(fp)
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 202edf0:	e0bff404 	addi	r2,fp,-48
 202edf4:	10800604 	addi	r2,r2,24
 202edf8:	e17fe917 	ldw	r5,-92(fp)
 202edfc:	1009883a 	mov	r4,r2
 202ee00:	2014f800 	call	2014f80 <sys_arch_sem_wait>
 202ee04:	e0bfe715 	stw	r2,-100(fp)
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202ee08:	00800804 	movi	r2,32
 202ee0c:	e0bfea15 	stw	r2,-88(fp)
 202ee10:	00003b06 	br	202ef00 <lwip_select+0x3ac>
      if ((readset && FD_ISSET(i, readset)) ||
 202ee14:	e0bffc17 	ldw	r2,-16(fp)
 202ee18:	10000c26 	beq	r2,zero,202ee4c <lwip_select+0x2f8>
 202ee1c:	e0bfea17 	ldw	r2,-88(fp)
 202ee20:	1004d17a 	srli	r2,r2,5
 202ee24:	e0fffc17 	ldw	r3,-16(fp)
 202ee28:	1085883a 	add	r2,r2,r2
 202ee2c:	1085883a 	add	r2,r2,r2
 202ee30:	1885883a 	add	r2,r3,r2
 202ee34:	10c00017 	ldw	r3,0(r2)
 202ee38:	e0bfea17 	ldw	r2,-88(fp)
 202ee3c:	108007cc 	andi	r2,r2,31
 202ee40:	1885d83a 	sra	r2,r3,r2
 202ee44:	1080004c 	andi	r2,r2,1
 202ee48:	10001c1e 	bne	r2,zero,202eebc <lwip_select+0x368>
 202ee4c:	e0bffd17 	ldw	r2,-12(fp)
 202ee50:	10000c26 	beq	r2,zero,202ee84 <lwip_select+0x330>
          (writeset && FD_ISSET(i, writeset)) ||
 202ee54:	e0bfea17 	ldw	r2,-88(fp)
 202ee58:	1004d17a 	srli	r2,r2,5
 202ee5c:	e0fffd17 	ldw	r3,-12(fp)
 202ee60:	1085883a 	add	r2,r2,r2
 202ee64:	1085883a 	add	r2,r2,r2
 202ee68:	1885883a 	add	r2,r3,r2
 202ee6c:	10c00017 	ldw	r3,0(r2)
 202ee70:	e0bfea17 	ldw	r2,-88(fp)
 202ee74:	108007cc 	andi	r2,r2,31
 202ee78:	1885d83a 	sra	r2,r3,r2
 202ee7c:	1080004c 	andi	r2,r2,1
 202ee80:	10000e1e 	bne	r2,zero,202eebc <lwip_select+0x368>
 202ee84:	e0bffe17 	ldw	r2,-8(fp)
 202ee88:	10001a26 	beq	r2,zero,202eef4 <lwip_select+0x3a0>
          (exceptset && FD_ISSET(i, exceptset))) {
 202ee8c:	e0bfea17 	ldw	r2,-88(fp)
 202ee90:	1004d17a 	srli	r2,r2,5
 202ee94:	e0fffe17 	ldw	r3,-8(fp)
 202ee98:	1085883a 	add	r2,r2,r2
 202ee9c:	1085883a 	add	r2,r2,r2
 202eea0:	1885883a 	add	r2,r3,r2
 202eea4:	10c00017 	ldw	r3,0(r2)
 202eea8:	e0bfea17 	ldw	r2,-88(fp)
 202eeac:	108007cc 	andi	r2,r2,31
 202eeb0:	1885d83a 	sra	r2,r3,r2
 202eeb4:	1080004c 	andi	r2,r2,1
 202eeb8:	10000e26 	beq	r2,zero,202eef4 <lwip_select+0x3a0>
        struct lwip_sock *sock = tryget_socket(i);
 202eebc:	e13fea17 	ldw	r4,-88(fp)
 202eec0:	202d3700 	call	202d370 <tryget_socket>
 202eec4:	e0bfed15 	stw	r2,-76(fp)
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 202eec8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202eecc:	10000126 	beq	r2,zero,202eed4 <lwip_select+0x380>
 202eed0:	2010f300 	call	2010f30 <vTaskEnterCritical>
        sock->select_waiting--;
 202eed4:	e0bfed17 	ldw	r2,-76(fp)
 202eed8:	10800517 	ldw	r2,20(r2)
 202eedc:	10ffffc4 	addi	r3,r2,-1
 202eee0:	e0bfed17 	ldw	r2,-76(fp)
 202eee4:	10c00515 	stw	r3,20(r2)
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
 202eee8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202eeec:	10000126 	beq	r2,zero,202eef4 <lwip_select+0x3a0>
 202eef0:	2010f780 	call	2010f78 <vTaskExitCritical>
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = LWIP_SOCKET_OFFSET; i < maxfdp1; i++) {
 202eef4:	e0bfea17 	ldw	r2,-88(fp)
 202eef8:	10800044 	addi	r2,r2,1
 202eefc:	e0bfea15 	stw	r2,-88(fp)
 202ef00:	e0ffea17 	ldw	r3,-88(fp)
 202ef04:	e0bffb17 	ldw	r2,-20(fp)
 202ef08:	18bfc216 	blt	r3,r2,202ee14 <__alt_mem_mem_0+0xfd00ee14>
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
 202ef0c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ef10:	10000126 	beq	r2,zero,202ef18 <lwip_select+0x3c4>
 202ef14:	2010f300 	call	2010f30 <vTaskEnterCritical>
    if (select_cb.next != NULL) {
 202ef18:	e0bff417 	ldw	r2,-48(fp)
 202ef1c:	10000326 	beq	r2,zero,202ef2c <lwip_select+0x3d8>
      select_cb.next->prev = select_cb.prev;
 202ef20:	e0bff417 	ldw	r2,-48(fp)
 202ef24:	e0fff517 	ldw	r3,-44(fp)
 202ef28:	10c00115 	stw	r3,4(r2)
    }
    if (select_cb_list == &select_cb) {
 202ef2c:	d0e80c17 	ldw	r3,-24528(gp)
 202ef30:	e0bff404 	addi	r2,fp,-48
 202ef34:	1880031e 	bne	r3,r2,202ef44 <lwip_select+0x3f0>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
 202ef38:	e0bff417 	ldw	r2,-48(fp)
 202ef3c:	d0a80c15 	stw	r2,-24528(gp)
 202ef40:	00000306 	br	202ef50 <lwip_select+0x3fc>
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
      select_cb.prev->next = select_cb.next;
 202ef44:	e0bff517 	ldw	r2,-44(fp)
 202ef48:	e0fff417 	ldw	r3,-48(fp)
 202ef4c:	10c00015 	stw	r3,0(r2)
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 202ef50:	d0a80d17 	ldw	r2,-24524(gp)
 202ef54:	10800044 	addi	r2,r2,1
 202ef58:	d0a80d15 	stw	r2,-24524(gp)
    SYS_ARCH_UNPROTECT(lev);
 202ef5c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202ef60:	10000126 	beq	r2,zero,202ef68 <lwip_select+0x414>
 202ef64:	2010f780 	call	2010f78 <vTaskExitCritical>

    sys_sem_free(&select_cb.sem);
 202ef68:	e0bff404 	addi	r2,fp,-48
 202ef6c:	10800604 	addi	r2,r2,24
 202ef70:	1009883a 	mov	r4,r2
 202ef74:	2014ee00 	call	2014ee0 <sys_sem_free>
    if (waitres == SYS_ARCH_TIMEOUT)  {
 202ef78:	e0bfe717 	ldw	r2,-100(fp)
 202ef7c:	10bfffd8 	cmpnei	r2,r2,-1
 202ef80:	10000f26 	beq	r2,zero,202efc0 <lwip_select+0x46c>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 202ef84:	e0bff204 	addi	r2,fp,-56
 202ef88:	d8800215 	stw	r2,8(sp)
 202ef8c:	e0bff004 	addi	r2,fp,-64
 202ef90:	d8800115 	stw	r2,4(sp)
 202ef94:	e0bfee04 	addi	r2,fp,-72
 202ef98:	d8800015 	stw	r2,0(sp)
 202ef9c:	e1fffe17 	ldw	r7,-8(fp)
 202efa0:	e1bffd17 	ldw	r6,-12(fp)
 202efa4:	e17ffc17 	ldw	r5,-16(fp)
 202efa8:	e13ffb17 	ldw	r4,-20(fp)
 202efac:	202e7d40 	call	202e7d4 <lwip_selscan>
 202efb0:	e0bfe815 	stw	r2,-96(fp)
 202efb4:	00000306 	br	202efc4 <lwip_select+0x470>
  if (!nready) {
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
 202efb8:	0001883a 	nop
 202efbc:	00000106 	br	202efc4 <lwip_select+0x470>
    if (waitres == SYS_ARCH_TIMEOUT)  {
      /* Timeout */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
 202efc0:	0001883a 	nop
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  set_errno(0);
  if (readset) {
 202efc4:	e0bffc17 	ldw	r2,-16(fp)
 202efc8:	10000526 	beq	r2,zero,202efe0 <lwip_select+0x48c>
    *readset = lreadset;
 202efcc:	e0bffc17 	ldw	r2,-16(fp)
 202efd0:	e0ffee17 	ldw	r3,-72(fp)
 202efd4:	10c00015 	stw	r3,0(r2)
 202efd8:	e0ffef17 	ldw	r3,-68(fp)
 202efdc:	10c00115 	stw	r3,4(r2)
  }
  if (writeset) {
 202efe0:	e0bffd17 	ldw	r2,-12(fp)
 202efe4:	10000526 	beq	r2,zero,202effc <lwip_select+0x4a8>
    *writeset = lwriteset;
 202efe8:	e0bffd17 	ldw	r2,-12(fp)
 202efec:	e0fff017 	ldw	r3,-64(fp)
 202eff0:	10c00015 	stw	r3,0(r2)
 202eff4:	e0fff117 	ldw	r3,-60(fp)
 202eff8:	10c00115 	stw	r3,4(r2)
  }
  if (exceptset) {
 202effc:	e0bffe17 	ldw	r2,-8(fp)
 202f000:	10000526 	beq	r2,zero,202f018 <lwip_select+0x4c4>
    *exceptset = lexceptset;
 202f004:	e0bffe17 	ldw	r2,-8(fp)
 202f008:	e0fff217 	ldw	r3,-56(fp)
 202f00c:	10c00015 	stw	r3,0(r2)
 202f010:	e0fff317 	ldw	r3,-52(fp)
 202f014:	10c00115 	stw	r3,4(r2)
  }


  return nready;
 202f018:	e0bfe817 	ldw	r2,-96(fp)
}
 202f01c:	e6ffff04 	addi	sp,fp,-4
 202f020:	dfc00217 	ldw	ra,8(sp)
 202f024:	df000117 	ldw	fp,4(sp)
 202f028:	dc000017 	ldw	r16,0(sp)
 202f02c:	dec00304 	addi	sp,sp,12
 202f030:	f800283a 	ret

0202f034 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
 202f034:	defff604 	addi	sp,sp,-40
 202f038:	dfc00915 	stw	ra,36(sp)
 202f03c:	df000815 	stw	fp,32(sp)
 202f040:	df000804 	addi	fp,sp,32
 202f044:	e13ffd15 	stw	r4,-12(fp)
 202f048:	e17ffe15 	stw	r5,-8(fp)
 202f04c:	3005883a 	mov	r2,r6
 202f050:	e0bfff0d 	sth	r2,-4(fp)
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
 202f054:	e0bffd17 	ldw	r2,-12(fp)
 202f058:	1000d526 	beq	r2,zero,202f3b0 <event_callback+0x37c>
    s = conn->socket;
 202f05c:	e0bffd17 	ldw	r2,-12(fp)
 202f060:	10800717 	ldw	r2,28(r2)
 202f064:	e0bff815 	stw	r2,-32(fp)
    if (s < 0) {
 202f068:	e0bff817 	ldw	r2,-32(fp)
 202f06c:	1000170e 	bge	r2,zero,202f0cc <event_callback+0x98>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 202f070:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f074:	10000126 	beq	r2,zero,202f07c <event_callback+0x48>
 202f078:	2010f300 	call	2010f30 <vTaskEnterCritical>
      if (conn->socket < 0) {
 202f07c:	e0bffd17 	ldw	r2,-12(fp)
 202f080:	10800717 	ldw	r2,28(r2)
 202f084:	10000b0e 	bge	r2,zero,202f0b4 <event_callback+0x80>
        if (evt == NETCONN_EVT_RCVPLUS) {
 202f088:	e0bffe17 	ldw	r2,-8(fp)
 202f08c:	1000051e 	bne	r2,zero,202f0a4 <event_callback+0x70>
          conn->socket--;
 202f090:	e0bffd17 	ldw	r2,-12(fp)
 202f094:	10800717 	ldw	r2,28(r2)
 202f098:	10ffffc4 	addi	r3,r2,-1
 202f09c:	e0bffd17 	ldw	r2,-12(fp)
 202f0a0:	10c00715 	stw	r3,28(r2)
        }
        SYS_ARCH_UNPROTECT(lev);
 202f0a4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f0a8:	1000c326 	beq	r2,zero,202f3b8 <event_callback+0x384>
 202f0ac:	2010f780 	call	2010f78 <vTaskExitCritical>
        return;
 202f0b0:	0000c106 	br	202f3b8 <event_callback+0x384>
      }
      s = conn->socket;
 202f0b4:	e0bffd17 	ldw	r2,-12(fp)
 202f0b8:	10800717 	ldw	r2,28(r2)
 202f0bc:	e0bff815 	stw	r2,-32(fp)
      SYS_ARCH_UNPROTECT(lev);
 202f0c0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f0c4:	10000126 	beq	r2,zero,202f0cc <event_callback+0x98>
 202f0c8:	2010f780 	call	2010f78 <vTaskExitCritical>
    }

    sock = get_socket(s);
 202f0cc:	e13ff817 	ldw	r4,-32(fp)
 202f0d0:	202d2f80 	call	202d2f8 <get_socket>
 202f0d4:	e0bffb15 	stw	r2,-20(fp)
    if (!sock) {
 202f0d8:	e0bffb17 	ldw	r2,-20(fp)
 202f0dc:	1000b826 	beq	r2,zero,202f3c0 <event_callback+0x38c>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
 202f0e0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f0e4:	10000126 	beq	r2,zero,202f0ec <event_callback+0xb8>
 202f0e8:	2010f300 	call	2010f30 <vTaskEnterCritical>
  /* Set event as required */
  switch (evt) {
 202f0ec:	e0bffe17 	ldw	r2,-8(fp)
 202f0f0:	10800168 	cmpgeui	r2,r2,5
 202f0f4:	1000251e 	bne	r2,zero,202f18c <event_callback+0x158>
 202f0f8:	e0bffe17 	ldw	r2,-8(fp)
 202f0fc:	100690ba 	slli	r3,r2,2
 202f100:	008080f4 	movhi	r2,515
 202f104:	10bc4504 	addi	r2,r2,-3820
 202f108:	1885883a 	add	r2,r3,r2
 202f10c:	10800017 	ldw	r2,0(r2)
 202f110:	1000683a 	jmp	r2
 202f114:	0202f128 	cmpgeui	r8,zero,3012
 202f118:	0202f144 	movi	r8,3013
 202f11c:	0202f160 	cmpeqi	r8,zero,3013
 202f120:	0202f170 	cmpltui	r8,zero,3013
 202f124:	0202f17c 	xorhi	r8,zero,3013
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
 202f128:	e0bffb17 	ldw	r2,-20(fp)
 202f12c:	1080028b 	ldhu	r2,10(r2)
 202f130:	10800044 	addi	r2,r2,1
 202f134:	1007883a 	mov	r3,r2
 202f138:	e0bffb17 	ldw	r2,-20(fp)
 202f13c:	10c0028d 	sth	r3,10(r2)
      break;
 202f140:	00001306 	br	202f190 <event_callback+0x15c>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
 202f144:	e0bffb17 	ldw	r2,-20(fp)
 202f148:	1080028b 	ldhu	r2,10(r2)
 202f14c:	10bfffc4 	addi	r2,r2,-1
 202f150:	1007883a 	mov	r3,r2
 202f154:	e0bffb17 	ldw	r2,-20(fp)
 202f158:	10c0028d 	sth	r3,10(r2)
      break;
 202f15c:	00000c06 	br	202f190 <event_callback+0x15c>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
 202f160:	e0bffb17 	ldw	r2,-20(fp)
 202f164:	00c00044 	movi	r3,1
 202f168:	10c0030d 	sth	r3,12(r2)
      break;
 202f16c:	00000806 	br	202f190 <event_callback+0x15c>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 202f170:	e0bffb17 	ldw	r2,-20(fp)
 202f174:	1000030d 	sth	zero,12(r2)
      break;
 202f178:	00000506 	br	202f190 <event_callback+0x15c>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
 202f17c:	e0bffb17 	ldw	r2,-20(fp)
 202f180:	00c00044 	movi	r3,1
 202f184:	10c0038d 	sth	r3,14(r2)
      break;
 202f188:	00000106 	br	202f190 <event_callback+0x15c>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
 202f18c:	0001883a 	nop
  }

  if (sock->select_waiting == 0) {
 202f190:	e0bffb17 	ldw	r2,-20(fp)
 202f194:	10800517 	ldw	r2,20(r2)
 202f198:	1000041e 	bne	r2,zero,202f1ac <event_callback+0x178>
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
 202f19c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f1a0:	10008926 	beq	r2,zero,202f3c8 <event_callback+0x394>
 202f1a4:	2010f780 	call	2010f78 <vTaskExitCritical>
    return;
 202f1a8:	00008706 	br	202f3c8 <event_callback+0x394>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 202f1ac:	d0a80c17 	ldw	r2,-24528(gp)
 202f1b0:	e0bff915 	stw	r2,-28(fp)
 202f1b4:	00007806 	br	202f398 <event_callback+0x364>
    if (scb->sem_signalled == 0) {
 202f1b8:	e0bff917 	ldw	r2,-28(fp)
 202f1bc:	10800517 	ldw	r2,20(r2)
 202f1c0:	1000521e 	bne	r2,zero,202f30c <event_callback+0x2d8>
      /* semaphore not signalled yet */
      int do_signal = 0;
 202f1c4:	e03ffa15 	stw	zero,-24(fp)
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
 202f1c8:	e0bffb17 	ldw	r2,-20(fp)
 202f1cc:	1080028b 	ldhu	r2,10(r2)
 202f1d0:	10bfffcc 	andi	r2,r2,65535
 202f1d4:	10a0001c 	xori	r2,r2,32768
 202f1d8:	10a00004 	addi	r2,r2,-32768
 202f1dc:	0080120e 	bge	zero,r2,202f228 <event_callback+0x1f4>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 202f1e0:	e0bff917 	ldw	r2,-28(fp)
 202f1e4:	10800217 	ldw	r2,8(r2)
 202f1e8:	10000f26 	beq	r2,zero,202f228 <event_callback+0x1f4>
 202f1ec:	e0bff917 	ldw	r2,-28(fp)
 202f1f0:	10c00217 	ldw	r3,8(r2)
 202f1f4:	e0bff817 	ldw	r2,-32(fp)
 202f1f8:	1004d17a 	srli	r2,r2,5
 202f1fc:	1085883a 	add	r2,r2,r2
 202f200:	1085883a 	add	r2,r2,r2
 202f204:	1885883a 	add	r2,r3,r2
 202f208:	10c00017 	ldw	r3,0(r2)
 202f20c:	e0bff817 	ldw	r2,-32(fp)
 202f210:	108007cc 	andi	r2,r2,31
 202f214:	1885d83a 	sra	r2,r3,r2
 202f218:	1080004c 	andi	r2,r2,1
 202f21c:	10000226 	beq	r2,zero,202f228 <event_callback+0x1f4>
          do_signal = 1;
 202f220:	00800044 	movi	r2,1
 202f224:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->sendevent != 0) {
 202f228:	e0bffb17 	ldw	r2,-20(fp)
 202f22c:	1080030b 	ldhu	r2,12(r2)
 202f230:	10bfffcc 	andi	r2,r2,65535
 202f234:	10001426 	beq	r2,zero,202f288 <event_callback+0x254>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
 202f238:	e0bffa17 	ldw	r2,-24(fp)
 202f23c:	1000121e 	bne	r2,zero,202f288 <event_callback+0x254>
 202f240:	e0bff917 	ldw	r2,-28(fp)
 202f244:	10800317 	ldw	r2,12(r2)
 202f248:	10000f26 	beq	r2,zero,202f288 <event_callback+0x254>
 202f24c:	e0bff917 	ldw	r2,-28(fp)
 202f250:	10c00317 	ldw	r3,12(r2)
 202f254:	e0bff817 	ldw	r2,-32(fp)
 202f258:	1004d17a 	srli	r2,r2,5
 202f25c:	1085883a 	add	r2,r2,r2
 202f260:	1085883a 	add	r2,r2,r2
 202f264:	1885883a 	add	r2,r3,r2
 202f268:	10c00017 	ldw	r3,0(r2)
 202f26c:	e0bff817 	ldw	r2,-32(fp)
 202f270:	108007cc 	andi	r2,r2,31
 202f274:	1885d83a 	sra	r2,r3,r2
 202f278:	1080004c 	andi	r2,r2,1
 202f27c:	10000226 	beq	r2,zero,202f288 <event_callback+0x254>
          do_signal = 1;
 202f280:	00800044 	movi	r2,1
 202f284:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (sock->errevent != 0) {
 202f288:	e0bffb17 	ldw	r2,-20(fp)
 202f28c:	1080038b 	ldhu	r2,14(r2)
 202f290:	10bfffcc 	andi	r2,r2,65535
 202f294:	10001426 	beq	r2,zero,202f2e8 <event_callback+0x2b4>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
 202f298:	e0bffa17 	ldw	r2,-24(fp)
 202f29c:	1000121e 	bne	r2,zero,202f2e8 <event_callback+0x2b4>
 202f2a0:	e0bff917 	ldw	r2,-28(fp)
 202f2a4:	10800417 	ldw	r2,16(r2)
 202f2a8:	10000f26 	beq	r2,zero,202f2e8 <event_callback+0x2b4>
 202f2ac:	e0bff917 	ldw	r2,-28(fp)
 202f2b0:	10c00417 	ldw	r3,16(r2)
 202f2b4:	e0bff817 	ldw	r2,-32(fp)
 202f2b8:	1004d17a 	srli	r2,r2,5
 202f2bc:	1085883a 	add	r2,r2,r2
 202f2c0:	1085883a 	add	r2,r2,r2
 202f2c4:	1885883a 	add	r2,r3,r2
 202f2c8:	10c00017 	ldw	r3,0(r2)
 202f2cc:	e0bff817 	ldw	r2,-32(fp)
 202f2d0:	108007cc 	andi	r2,r2,31
 202f2d4:	1885d83a 	sra	r2,r3,r2
 202f2d8:	1080004c 	andi	r2,r2,1
 202f2dc:	10000226 	beq	r2,zero,202f2e8 <event_callback+0x2b4>
          do_signal = 1;
 202f2e0:	00800044 	movi	r2,1
 202f2e4:	e0bffa15 	stw	r2,-24(fp)
        }
      }
      if (do_signal) {
 202f2e8:	e0bffa17 	ldw	r2,-24(fp)
 202f2ec:	10000726 	beq	r2,zero,202f30c <event_callback+0x2d8>
        scb->sem_signalled = 1;
 202f2f0:	e0bff917 	ldw	r2,-28(fp)
 202f2f4:	00c00044 	movi	r3,1
 202f2f8:	10c00515 	stw	r3,20(r2)
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
 202f2fc:	e0bff917 	ldw	r2,-28(fp)
 202f300:	10800604 	addi	r2,r2,24
 202f304:	1009883a 	mov	r4,r2
 202f308:	2014f380 	call	2014f38 <sys_sem_signal>
      }
    }

    if ((scb->next) && (scb->next < 0x00800000 || scb->next > 0x00ffffff))
 202f30c:	e0bff917 	ldw	r2,-28(fp)
 202f310:	10800017 	ldw	r2,0(r2)
 202f314:	10000a26 	beq	r2,zero,202f340 <event_callback+0x30c>
 202f318:	e0bff917 	ldw	r2,-28(fp)
 202f31c:	10c00017 	ldw	r3,0(r2)
 202f320:	00802034 	movhi	r2,128
 202f324:	18800436 	bltu	r3,r2,202f338 <event_callback+0x304>
 202f328:	e0bff917 	ldw	r2,-28(fp)
 202f32c:	10c00017 	ldw	r3,0(r2)
 202f330:	00804034 	movhi	r2,256
 202f334:	18800236 	bltu	r3,r2,202f340 <event_callback+0x30c>
    {
    	NIOS2_BREAK();
 202f338:	003da03a 	break	0
 202f33c:	00000706 	br	202f35c <event_callback+0x328>
    }
    else if (scb < 0x00800000 || scb > 0x00ffffff)
 202f340:	e0fff917 	ldw	r3,-28(fp)
 202f344:	00802034 	movhi	r2,128
 202f348:	18800336 	bltu	r3,r2,202f358 <event_callback+0x324>
 202f34c:	e0fff917 	ldw	r3,-28(fp)
 202f350:	00804034 	movhi	r2,256
 202f354:	18800136 	bltu	r3,r2,202f35c <event_callback+0x328>
    {
    	NIOS2_BREAK();
 202f358:	003da03a 	break	0
    }

    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
 202f35c:	d0a80d17 	ldw	r2,-24524(gp)
 202f360:	e0bffc15 	stw	r2,-16(fp)
    SYS_ARCH_UNPROTECT(lev);
 202f364:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f368:	10000126 	beq	r2,zero,202f370 <event_callback+0x33c>
 202f36c:	2010f780 	call	2010f78 <vTaskExitCritical>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
 202f370:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f374:	10000126 	beq	r2,zero,202f37c <event_callback+0x348>
 202f378:	2010f300 	call	2010f30 <vTaskEnterCritical>
    if (last_select_cb_ctr != select_cb_ctr) {
 202f37c:	d0a80d17 	ldw	r2,-24524(gp)
 202f380:	e0fffc17 	ldw	r3,-16(fp)
 202f384:	18800126 	beq	r3,r2,202f38c <event_callback+0x358>
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
 202f388:	003f8806 	br	202f1ac <__alt_mem_mem_0+0xfd00f1ac>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 202f38c:	e0bff917 	ldw	r2,-28(fp)
 202f390:	10800017 	ldw	r2,0(r2)
 202f394:	e0bff915 	stw	r2,-28(fp)
 202f398:	e0bff917 	ldw	r2,-28(fp)
 202f39c:	103f861e 	bne	r2,zero,202f1b8 <__alt_mem_mem_0+0xfd00f1b8>
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
 202f3a0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 202f3a4:	10000926 	beq	r2,zero,202f3cc <event_callback+0x398>
 202f3a8:	2010f780 	call	2010f78 <vTaskExitCritical>
 202f3ac:	00000706 	br	202f3cc <event_callback+0x398>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
 202f3b0:	0001883a 	nop
 202f3b4:	00000506 	br	202f3cc <event_callback+0x398>
      if (conn->socket < 0) {
        if (evt == NETCONN_EVT_RCVPLUS) {
          conn->socket--;
        }
        SYS_ARCH_UNPROTECT(lev);
        return;
 202f3b8:	0001883a 	nop
 202f3bc:	00000306 	br	202f3cc <event_callback+0x398>
      SYS_ARCH_UNPROTECT(lev);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
 202f3c0:	0001883a 	nop
 202f3c4:	00000106 	br	202f3cc <event_callback+0x398>
  }

  if (sock->select_waiting == 0) {
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
    return;
 202f3c8:	0001883a 	nop
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
 202f3cc:	e037883a 	mov	sp,fp
 202f3d0:	dfc00117 	ldw	ra,4(sp)
 202f3d4:	df000017 	ldw	fp,0(sp)
 202f3d8:	dec00204 	addi	sp,sp,8
 202f3dc:	f800283a 	ret

0202f3e0 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
 202f3e0:	defff904 	addi	sp,sp,-28
 202f3e4:	dfc00615 	stw	ra,24(sp)
 202f3e8:	df000515 	stw	fp,20(sp)
 202f3ec:	df000504 	addi	fp,sp,20
 202f3f0:	e13ffe15 	stw	r4,-8(fp)
 202f3f4:	e17fff15 	stw	r5,-4(fp)
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
 202f3f8:	e03ffb05 	stb	zero,-20(fp)
 202f3fc:	e03ffb45 	stb	zero,-19(fp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
 202f400:	e13ffe17 	ldw	r4,-8(fp)
 202f404:	202d2f80 	call	202d2f8 <get_socket>
 202f408:	e0bffc15 	stw	r2,-16(fp)
  if (!sock) {
 202f40c:	e0bffc17 	ldw	r2,-16(fp)
 202f410:	1000021e 	bne	r2,zero,202f41c <lwip_shutdown+0x3c>
    return -1;
 202f414:	00bfffc4 	movi	r2,-1
 202f418:	00004906 	br	202f540 <lwip_shutdown+0x160>
  }

  if (sock->conn != NULL) {
 202f41c:	e0bffc17 	ldw	r2,-16(fp)
 202f420:	10800017 	ldw	r2,0(r2)
 202f424:	10000a26 	beq	r2,zero,202f450 <lwip_shutdown+0x70>
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 202f428:	e0bffc17 	ldw	r2,-16(fp)
 202f42c:	10800017 	ldw	r2,0(r2)
 202f430:	10800017 	ldw	r2,0(r2)
 202f434:	10800420 	cmpeqi	r2,r2,16
 202f438:	10000a1e 	bne	r2,zero,202f464 <lwip_shutdown+0x84>
      sock_set_errno(sock, EOPNOTSUPP);
 202f43c:	e0bffc17 	ldw	r2,-16(fp)
 202f440:	00c017c4 	movi	r3,95
 202f444:	10c00415 	stw	r3,16(r2)
      return EOPNOTSUPP;
 202f448:	008017c4 	movi	r2,95
 202f44c:	00003c06 	br	202f540 <lwip_shutdown+0x160>
    }
  } else {
    sock_set_errno(sock, ENOTCONN);
 202f450:	e0bffc17 	ldw	r2,-16(fp)
 202f454:	00c02004 	movi	r3,128
 202f458:	10c00415 	stw	r3,16(r2)
    return ENOTCONN;
 202f45c:	00802004 	movi	r2,128
 202f460:	00003706 	br	202f540 <lwip_shutdown+0x160>
  }

  if (how == SHUT_RD) {
 202f464:	e0bfff17 	ldw	r2,-4(fp)
 202f468:	1000031e 	bne	r2,zero,202f478 <lwip_shutdown+0x98>
    shut_rx = 1;
 202f46c:	00800044 	movi	r2,1
 202f470:	e0bffb05 	stb	r2,-20(fp)
 202f474:	00001306 	br	202f4c4 <lwip_shutdown+0xe4>
  } else if (how == SHUT_WR) {
 202f478:	e0bfff17 	ldw	r2,-4(fp)
 202f47c:	10800058 	cmpnei	r2,r2,1
 202f480:	1000031e 	bne	r2,zero,202f490 <lwip_shutdown+0xb0>
    shut_tx = 1;
 202f484:	00800044 	movi	r2,1
 202f488:	e0bffb45 	stb	r2,-19(fp)
 202f48c:	00000d06 	br	202f4c4 <lwip_shutdown+0xe4>
  } else if(how == SHUT_RDWR) {
 202f490:	e0bfff17 	ldw	r2,-4(fp)
 202f494:	10800098 	cmpnei	r2,r2,2
 202f498:	1000051e 	bne	r2,zero,202f4b0 <lwip_shutdown+0xd0>
    shut_rx = 1;
 202f49c:	00800044 	movi	r2,1
 202f4a0:	e0bffb05 	stb	r2,-20(fp)
    shut_tx = 1;
 202f4a4:	00800044 	movi	r2,1
 202f4a8:	e0bffb45 	stb	r2,-19(fp)
 202f4ac:	00000506 	br	202f4c4 <lwip_shutdown+0xe4>
  } else {
    sock_set_errno(sock, EINVAL);
 202f4b0:	e0bffc17 	ldw	r2,-16(fp)
 202f4b4:	00c00584 	movi	r3,22
 202f4b8:	10c00415 	stw	r3,16(r2)
    return EINVAL;
 202f4bc:	00800584 	movi	r2,22
 202f4c0:	00001f06 	br	202f540 <lwip_shutdown+0x160>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
 202f4c4:	e0bffc17 	ldw	r2,-16(fp)
 202f4c8:	10800017 	ldw	r2,0(r2)
 202f4cc:	e0fffb03 	ldbu	r3,-20(fp)
 202f4d0:	e13ffb43 	ldbu	r4,-19(fp)
 202f4d4:	200d883a 	mov	r6,r4
 202f4d8:	180b883a 	mov	r5,r3
 202f4dc:	1009883a 	mov	r4,r2
 202f4e0:	203a0700 	call	203a070 <netconn_shutdown>
 202f4e4:	e0bffd05 	stb	r2,-12(fp)

  sock_set_errno(sock, err_to_errno(err));
 202f4e8:	e0bffd07 	ldb	r2,-12(fp)
 202f4ec:	0085c83a 	sub	r2,zero,r2
 202f4f0:	10800428 	cmpgeui	r2,r2,16
 202f4f4:	1000091e 	bne	r2,zero,202f51c <lwip_shutdown+0x13c>
 202f4f8:	e0bffd07 	ldb	r2,-12(fp)
 202f4fc:	0087c83a 	sub	r3,zero,r2
 202f500:	00808134 	movhi	r2,516
 202f504:	108d4204 	addi	r2,r2,13576
 202f508:	18c7883a 	add	r3,r3,r3
 202f50c:	18c7883a 	add	r3,r3,r3
 202f510:	10c5883a 	add	r2,r2,r3
 202f514:	10800017 	ldw	r2,0(r2)
 202f518:	00000106 	br	202f520 <lwip_shutdown+0x140>
 202f51c:	00800144 	movi	r2,5
 202f520:	e0fffc17 	ldw	r3,-16(fp)
 202f524:	18800415 	stw	r2,16(r3)
  return (err == ERR_OK ? 0 : -1);
 202f528:	e0bffd07 	ldb	r2,-12(fp)
 202f52c:	1000021e 	bne	r2,zero,202f538 <lwip_shutdown+0x158>
 202f530:	0005883a 	mov	r2,zero
 202f534:	00000106 	br	202f53c <lwip_shutdown+0x15c>
 202f538:	00bfffc4 	movi	r2,-1
 202f53c:	0001883a 	nop
}
 202f540:	e037883a 	mov	sp,fp
 202f544:	dfc00117 	ldw	ra,4(sp)
 202f548:	df000017 	ldw	fp,0(sp)
 202f54c:	dec00204 	addi	sp,sp,8
 202f550:	f800283a 	ret

0202f554 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
 202f554:	defff404 	addi	sp,sp,-48
 202f558:	dfc00b15 	stw	ra,44(sp)
 202f55c:	df000a15 	stw	fp,40(sp)
 202f560:	df000a04 	addi	fp,sp,40
 202f564:	e13ffc15 	stw	r4,-16(fp)
 202f568:	e17ffd15 	stw	r5,-12(fp)
 202f56c:	e1bffe15 	stw	r6,-8(fp)
 202f570:	3805883a 	mov	r2,r7
 202f574:	e0bfff05 	stb	r2,-4(fp)
  struct lwip_sock *sock;
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
 202f578:	e13ffc17 	ldw	r4,-16(fp)
 202f57c:	202d2f80 	call	202d2f8 <get_socket>
 202f580:	e0bff615 	stw	r2,-40(fp)
  if (!sock) {
 202f584:	e0bff617 	ldw	r2,-40(fp)
 202f588:	1000021e 	bne	r2,zero,202f594 <lwip_getaddrname+0x40>
    return -1;
 202f58c:	00bfffc4 	movi	r2,-1
 202f590:	00003006 	br	202f654 <lwip_getaddrname+0x100>
  }

  memset(&sin, 0, sizeof(sin));
 202f594:	e0bff704 	addi	r2,fp,-36
 202f598:	01800404 	movi	r6,16
 202f59c:	000b883a 	mov	r5,zero
 202f5a0:	1009883a 	mov	r4,r2
 202f5a4:	200616c0 	call	200616c <memset>
  sin.sin_len = sizeof(sin);
 202f5a8:	00800404 	movi	r2,16
 202f5ac:	e0bff705 	stb	r2,-36(fp)
  sin.sin_family = AF_INET;
 202f5b0:	00800084 	movi	r2,2
 202f5b4:	e0bff745 	stb	r2,-35(fp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
 202f5b8:	e0bff617 	ldw	r2,-40(fp)
 202f5bc:	10c00017 	ldw	r3,0(r2)
 202f5c0:	e17fff03 	ldbu	r5,-4(fp)
 202f5c4:	e0bff704 	addi	r2,fp,-36
 202f5c8:	11000084 	addi	r4,r2,2
 202f5cc:	e0bffb04 	addi	r2,fp,-20
 202f5d0:	280f883a 	mov	r7,r5
 202f5d4:	200d883a 	mov	r6,r4
 202f5d8:	100b883a 	mov	r5,r2
 202f5dc:	1809883a 	mov	r4,r3
 202f5e0:	20390e80 	call	20390e8 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
 202f5e4:	e0bff78b 	ldhu	r2,-34(fp)
 202f5e8:	10bfffcc 	andi	r2,r2,65535
 202f5ec:	1004d23a 	srli	r2,r2,8
 202f5f0:	1007883a 	mov	r3,r2
 202f5f4:	e0bff78b 	ldhu	r2,-34(fp)
 202f5f8:	10bfffcc 	andi	r2,r2,65535
 202f5fc:	1004923a 	slli	r2,r2,8
 202f600:	1884b03a 	or	r2,r3,r2
 202f604:	e0bff78d 	sth	r2,-34(fp)
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 202f608:	e0bffb17 	ldw	r2,-20(fp)
 202f60c:	e0bff815 	stw	r2,-32(fp)

  if (*namelen > sizeof(sin)) {
 202f610:	e0bffe17 	ldw	r2,-8(fp)
 202f614:	10800017 	ldw	r2,0(r2)
 202f618:	10800470 	cmpltui	r2,r2,17
 202f61c:	1000031e 	bne	r2,zero,202f62c <lwip_getaddrname+0xd8>
    *namelen = sizeof(sin);
 202f620:	e0bffe17 	ldw	r2,-8(fp)
 202f624:	00c00404 	movi	r3,16
 202f628:	10c00015 	stw	r3,0(r2)
  }

  MEMCPY(name, &sin, *namelen);
 202f62c:	e0bffe17 	ldw	r2,-8(fp)
 202f630:	10c00017 	ldw	r3,0(r2)
 202f634:	e0bff704 	addi	r2,fp,-36
 202f638:	180d883a 	mov	r6,r3
 202f63c:	100b883a 	mov	r5,r2
 202f640:	e13ffd17 	ldw	r4,-12(fp)
 202f644:	20060240 	call	2006024 <memcpy>
  sock_set_errno(sock, 0);
 202f648:	e0bff617 	ldw	r2,-40(fp)
 202f64c:	10000415 	stw	zero,16(r2)
  return 0;
 202f650:	0005883a 	mov	r2,zero
}
 202f654:	e037883a 	mov	sp,fp
 202f658:	dfc00117 	ldw	ra,4(sp)
 202f65c:	df000017 	ldw	fp,0(sp)
 202f660:	dec00204 	addi	sp,sp,8
 202f664:	f800283a 	ret

0202f668 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
 202f668:	defffb04 	addi	sp,sp,-20
 202f66c:	dfc00415 	stw	ra,16(sp)
 202f670:	df000315 	stw	fp,12(sp)
 202f674:	df000304 	addi	fp,sp,12
 202f678:	e13ffd15 	stw	r4,-12(fp)
 202f67c:	e17ffe15 	stw	r5,-8(fp)
 202f680:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 0);
 202f684:	000f883a 	mov	r7,zero
 202f688:	e1bfff17 	ldw	r6,-4(fp)
 202f68c:	e17ffe17 	ldw	r5,-8(fp)
 202f690:	e13ffd17 	ldw	r4,-12(fp)
 202f694:	202f5540 	call	202f554 <lwip_getaddrname>
}
 202f698:	e037883a 	mov	sp,fp
 202f69c:	dfc00117 	ldw	ra,4(sp)
 202f6a0:	df000017 	ldw	fp,0(sp)
 202f6a4:	dec00204 	addi	sp,sp,8
 202f6a8:	f800283a 	ret

0202f6ac <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
 202f6ac:	defffb04 	addi	sp,sp,-20
 202f6b0:	dfc00415 	stw	ra,16(sp)
 202f6b4:	df000315 	stw	fp,12(sp)
 202f6b8:	df000304 	addi	fp,sp,12
 202f6bc:	e13ffd15 	stw	r4,-12(fp)
 202f6c0:	e17ffe15 	stw	r5,-8(fp)
 202f6c4:	e1bfff15 	stw	r6,-4(fp)
  return lwip_getaddrname(s, name, namelen, 1);
 202f6c8:	01c00044 	movi	r7,1
 202f6cc:	e1bfff17 	ldw	r6,-4(fp)
 202f6d0:	e17ffe17 	ldw	r5,-8(fp)
 202f6d4:	e13ffd17 	ldw	r4,-12(fp)
 202f6d8:	202f5540 	call	202f554 <lwip_getaddrname>
}
 202f6dc:	e037883a 	mov	sp,fp
 202f6e0:	dfc00117 	ldw	ra,4(sp)
 202f6e4:	df000017 	ldw	fp,0(sp)
 202f6e8:	dec00204 	addi	sp,sp,8
 202f6ec:	f800283a 	ret

0202f6f0 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 202f6f0:	defff204 	addi	sp,sp,-56
 202f6f4:	dfc00d15 	stw	ra,52(sp)
 202f6f8:	df000c15 	stw	fp,48(sp)
 202f6fc:	df000c04 	addi	fp,sp,48
 202f700:	e13ffc15 	stw	r4,-16(fp)
 202f704:	e17ffd15 	stw	r5,-12(fp)
 202f708:	e1bffe15 	stw	r6,-8(fp)
 202f70c:	e1ffff15 	stw	r7,-4(fp)
  err_t err = ERR_OK;
 202f710:	e03ff405 	stb	zero,-48(fp)
  struct lwip_sock *sock = get_socket(s);
 202f714:	e13ffc17 	ldw	r4,-16(fp)
 202f718:	202d2f80 	call	202d2f8 <get_socket>
 202f71c:	e0bff515 	stw	r2,-44(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
 202f720:	e0bff517 	ldw	r2,-44(fp)
 202f724:	1000021e 	bne	r2,zero,202f730 <lwip_getsockopt+0x40>
    return -1;
 202f728:	00bfffc4 	movi	r2,-1
 202f72c:	00009c06 	br	202f9a0 <lwip_getsockopt+0x2b0>
  }

  if ((NULL == optval) || (NULL == optlen)) {
 202f730:	e0bfff17 	ldw	r2,-4(fp)
 202f734:	10000226 	beq	r2,zero,202f740 <lwip_getsockopt+0x50>
 202f738:	e0800217 	ldw	r2,8(fp)
 202f73c:	1000051e 	bne	r2,zero,202f754 <lwip_getsockopt+0x64>
    sock_set_errno(sock, EFAULT);
 202f740:	e0bff517 	ldw	r2,-44(fp)
 202f744:	00c00384 	movi	r3,14
 202f748:	10c00415 	stw	r3,16(r2)
    return -1;
 202f74c:	00bfffc4 	movi	r2,-1
 202f750:	00009306 	br	202f9a0 <lwip_getsockopt+0x2b0>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 202f754:	e0bffd17 	ldw	r2,-12(fp)
 202f758:	10c001a0 	cmpeqi	r3,r2,6
 202f75c:	18004d1e 	bne	r3,zero,202f894 <lwip_getsockopt+0x1a4>
 202f760:	10c3ffe0 	cmpeqi	r3,r2,4095
 202f764:	1800021e 	bne	r3,zero,202f770 <lwip_getsockopt+0x80>
 202f768:	10003a26 	beq	r2,zero,202f854 <lwip_getsockopt+0x164>
 202f76c:	00006006 	br	202f8f0 <lwip_getsockopt+0x200>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202f770:	e0bffe17 	ldw	r2,-8(fp)
 202f774:	10c00820 	cmpeqi	r3,r2,32
 202f778:	1800131e 	bne	r3,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f77c:	10c00848 	cmpgei	r3,r2,33
 202f780:	1800071e 	bne	r3,zero,202f7a0 <lwip_getsockopt+0xb0>
 202f784:	10c00120 	cmpeqi	r3,r2,4
 202f788:	18000f1e 	bne	r3,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f78c:	10c00220 	cmpeqi	r3,r2,8
 202f790:	18000d1e 	bne	r3,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f794:	108000a0 	cmpeqi	r2,r2,2
 202f798:	10000b1e 	bne	r2,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f79c:	00002606 	br	202f838 <lwip_getsockopt+0x148>
 202f7a0:	10c40248 	cmpgei	r3,r2,4105
 202f7a4:	1800051e 	bne	r3,zero,202f7bc <lwip_getsockopt+0xcc>
 202f7a8:	10c40188 	cmpgei	r3,r2,4102
 202f7ac:	1800061e 	bne	r3,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f7b0:	10808020 	cmpeqi	r2,r2,512
 202f7b4:	1000041e 	bne	r2,zero,202f7c8 <lwip_getsockopt+0xd8>
 202f7b8:	00001f06 	br	202f838 <lwip_getsockopt+0x148>
 202f7bc:	108402a0 	cmpeqi	r2,r2,4106
 202f7c0:	1000081e 	bne	r2,zero,202f7e4 <lwip_getsockopt+0xf4>
 202f7c4:	00001c06 	br	202f838 <lwip_getsockopt+0x148>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
 202f7c8:	e0800217 	ldw	r2,8(fp)
 202f7cc:	10800017 	ldw	r2,0(r2)
 202f7d0:	10800128 	cmpgeui	r2,r2,4
 202f7d4:	10001b1e 	bne	r2,zero,202f844 <lwip_getsockopt+0x154>
        err = EINVAL;
 202f7d8:	00800584 	movi	r2,22
 202f7dc:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 202f7e0:	00001806 	br	202f844 <lwip_getsockopt+0x154>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
 202f7e4:	e0800217 	ldw	r2,8(fp)
 202f7e8:	10800017 	ldw	r2,0(r2)
 202f7ec:	10800128 	cmpgeui	r2,r2,4
 202f7f0:	1000021e 	bne	r2,zero,202f7fc <lwip_getsockopt+0x10c>
        err = EINVAL;
 202f7f4:	00800584 	movi	r2,22
 202f7f8:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 202f7fc:	e0bff517 	ldw	r2,-44(fp)
 202f800:	10800017 	ldw	r2,0(r2)
 202f804:	10800017 	ldw	r2,0(r2)
 202f808:	10800818 	cmpnei	r2,r2,32
 202f80c:	1000071e 	bne	r2,zero,202f82c <lwip_getsockopt+0x13c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 202f810:	e0bff517 	ldw	r2,-44(fp)
 202f814:	10800017 	ldw	r2,0(r2)
 202f818:	10800217 	ldw	r2,8(r2)
 202f81c:	10800403 	ldbu	r2,16(r2)
 202f820:	10803fcc 	andi	r2,r2,255
 202f824:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 202f828:	10000826 	beq	r2,zero,202f84c <lwip_getsockopt+0x15c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
 202f82c:	00801a84 	movi	r2,106
 202f830:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
 202f834:	00000506 	br	202f84c <lwip_getsockopt+0x15c>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 202f838:	00801b44 	movi	r2,109
 202f83c:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202f840:	00002d06 	br	202f8f8 <lwip_getsockopt+0x208>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 202f844:	0001883a 	nop
 202f848:	00002b06 	br	202f8f8 <lwip_getsockopt+0x208>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
 202f84c:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202f850:	00002906 	br	202f8f8 <lwip_getsockopt+0x208>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 202f854:	e0bffe17 	ldw	r2,-8(fp)
 202f858:	10bfffc4 	addi	r2,r2,-1
 202f85c:	108000a8 	cmpgeui	r2,r2,2
 202f860:	1000071e 	bne	r2,zero,202f880 <lwip_getsockopt+0x190>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
 202f864:	e0800217 	ldw	r2,8(fp)
 202f868:	10800017 	ldw	r2,0(r2)
 202f86c:	10800128 	cmpgeui	r2,r2,4
 202f870:	1000061e 	bne	r2,zero,202f88c <lwip_getsockopt+0x19c>
        err = EINVAL;
 202f874:	00800584 	movi	r2,22
 202f878:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 202f87c:	00000306 	br	202f88c <lwip_getsockopt+0x19c>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 202f880:	00801b44 	movi	r2,109
 202f884:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202f888:	00001b06 	br	202f8f8 <lwip_getsockopt+0x208>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 202f88c:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202f890:	00001906 	br	202f8f8 <lwip_getsockopt+0x208>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
 202f894:	e0800217 	ldw	r2,8(fp)
 202f898:	10800017 	ldw	r2,0(r2)
 202f89c:	10800128 	cmpgeui	r2,r2,4
 202f8a0:	1000031e 	bne	r2,zero,202f8b0 <lwip_getsockopt+0x1c0>
      err = EINVAL;
 202f8a4:	00800584 	movi	r2,22
 202f8a8:	e0bff405 	stb	r2,-48(fp)
      break;
 202f8ac:	00001206 	br	202f8f8 <lwip_getsockopt+0x208>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 202f8b0:	e0bff517 	ldw	r2,-44(fp)
 202f8b4:	10800017 	ldw	r2,0(r2)
 202f8b8:	10800017 	ldw	r2,0(r2)
 202f8bc:	10800420 	cmpeqi	r2,r2,16
 202f8c0:	1000021e 	bne	r2,zero,202f8cc <lwip_getsockopt+0x1dc>
      return 0;
 202f8c4:	0005883a 	mov	r2,zero
 202f8c8:	00003506 	br	202f9a0 <lwip_getsockopt+0x2b0>

    switch (optname) {
 202f8cc:	e0bffe17 	ldw	r2,-8(fp)
 202f8d0:	10bfffc4 	addi	r2,r2,-1
 202f8d4:	10800168 	cmpgeui	r2,r2,5
 202f8d8:	10000326 	beq	r2,zero,202f8e8 <lwip_getsockopt+0x1f8>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
 202f8dc:	00801b44 	movi	r2,109
 202f8e0:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202f8e4:	00000406 	br	202f8f8 <lwip_getsockopt+0x208>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
 202f8e8:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202f8ec:	00000206 	br	202f8f8 <lwip_getsockopt+0x208>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
 202f8f0:	00801b44 	movi	r2,109
 202f8f4:	e0bff405 	stb	r2,-48(fp)
  }  /* switch */

   
  if (err != ERR_OK) {
 202f8f8:	e0bff407 	ldb	r2,-48(fp)
 202f8fc:	10000526 	beq	r2,zero,202f914 <lwip_getsockopt+0x224>
    sock_set_errno(sock, err);
 202f900:	e0fff407 	ldb	r3,-48(fp)
 202f904:	e0bff517 	ldw	r2,-44(fp)
 202f908:	10c00415 	stw	r3,16(r2)
    return -1;
 202f90c:	00bfffc4 	movi	r2,-1
 202f910:	00002306 	br	202f9a0 <lwip_getsockopt+0x2b0>
  }

  /* Now do the actual option processing */
  data.sock = sock;
 202f914:	e0bff517 	ldw	r2,-44(fp)
 202f918:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 202f91c:	e0bffd17 	ldw	r2,-12(fp)
 202f920:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
 202f924:	e0bffe17 	ldw	r2,-8(fp)
 202f928:	e0bff815 	stw	r2,-32(fp)
  data.optval = optval;
 202f92c:	e0bfff17 	ldw	r2,-4(fp)
 202f930:	e0bff915 	stw	r2,-28(fp)
  data.optlen = optlen;
 202f934:	e0800217 	ldw	r2,8(fp)
 202f938:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
 202f93c:	e0bff403 	ldbu	r2,-48(fp)
 202f940:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_getsockopt_internal, &data);
 202f944:	e0bff604 	addi	r2,fp,-40
 202f948:	01800044 	movi	r6,1
 202f94c:	100b883a 	mov	r5,r2
 202f950:	010080f4 	movhi	r4,515
 202f954:	213e6d04 	addi	r4,r4,-1612
 202f958:	20307d40 	call	20307d4 <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 202f95c:	e0bff517 	ldw	r2,-44(fp)
 202f960:	10800017 	ldw	r2,0(r2)
 202f964:	10800404 	addi	r2,r2,16
 202f968:	000b883a 	mov	r5,zero
 202f96c:	1009883a 	mov	r4,r2
 202f970:	2014f800 	call	2014f80 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
 202f974:	e0bffb03 	ldbu	r2,-20(fp)
 202f978:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
 202f97c:	e0fff407 	ldb	r3,-48(fp)
 202f980:	e0bff517 	ldw	r2,-44(fp)
 202f984:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
 202f988:	e0bff407 	ldb	r2,-48(fp)
 202f98c:	10000226 	beq	r2,zero,202f998 <lwip_getsockopt+0x2a8>
 202f990:	00bfffc4 	movi	r2,-1
 202f994:	00000206 	br	202f9a0 <lwip_getsockopt+0x2b0>
 202f998:	0005883a 	mov	r2,zero
 202f99c:	0001883a 	nop
}
 202f9a0:	e037883a 	mov	sp,fp
 202f9a4:	dfc00117 	ldw	ra,4(sp)
 202f9a8:	df000017 	ldw	fp,0(sp)
 202f9ac:	dec00204 	addi	sp,sp,8
 202f9b0:	f800283a 	ret

0202f9b4 <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
 202f9b4:	defff804 	addi	sp,sp,-32
 202f9b8:	dfc00715 	stw	ra,28(sp)
 202f9bc:	df000615 	stw	fp,24(sp)
 202f9c0:	df000604 	addi	fp,sp,24
 202f9c4:	e13fff15 	stw	r4,-4(fp)
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
 202f9c8:	e0bfff17 	ldw	r2,-4(fp)
 202f9cc:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
 202f9d0:	e0bffa17 	ldw	r2,-24(fp)
 202f9d4:	10800017 	ldw	r2,0(r2)
 202f9d8:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
 202f9dc:	e0bffa17 	ldw	r2,-24(fp)
 202f9e0:	10800117 	ldw	r2,4(r2)
 202f9e4:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
 202f9e8:	e0bffa17 	ldw	r2,-24(fp)
 202f9ec:	10800217 	ldw	r2,8(r2)
 202f9f0:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
 202f9f4:	e0bffa17 	ldw	r2,-24(fp)
 202f9f8:	10800317 	ldw	r2,12(r2)
 202f9fc:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
 202fa00:	e0bffc17 	ldw	r2,-16(fp)
 202fa04:	10c001a0 	cmpeqi	r3,r2,6
 202fa08:	18009b1e 	bne	r3,zero,202fc78 <lwip_getsockopt_internal+0x2c4>
 202fa0c:	10c3ffe0 	cmpeqi	r3,r2,4095
 202fa10:	1800021e 	bne	r3,zero,202fa1c <lwip_getsockopt_internal+0x68>
 202fa14:	10008126 	beq	r2,zero,202fc1c <lwip_getsockopt_internal+0x268>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
 202fa18:	0000da06 	br	202fd84 <lwip_getsockopt_internal+0x3d0>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202fa1c:	e0bffd17 	ldw	r2,-12(fp)
 202fa20:	10c08020 	cmpeqi	r3,r2,512
 202fa24:	18001a1e 	bne	r3,zero,202fa90 <lwip_getsockopt_internal+0xdc>
 202fa28:	10c08048 	cmpgei	r3,r2,513
 202fa2c:	18000c1e 	bne	r3,zero,202fa60 <lwip_getsockopt_internal+0xac>
 202fa30:	10c00120 	cmpeqi	r3,r2,4
 202fa34:	1800161e 	bne	r3,zero,202fa90 <lwip_getsockopt_internal+0xdc>
 202fa38:	10c00148 	cmpgei	r3,r2,5
 202fa3c:	1800031e 	bne	r3,zero,202fa4c <lwip_getsockopt_internal+0x98>
 202fa40:	108000a0 	cmpeqi	r2,r2,2
 202fa44:	1000121e 	bne	r2,zero,202fa90 <lwip_getsockopt_internal+0xdc>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fa48:	00007306 	br	202fc18 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202fa4c:	10c00220 	cmpeqi	r3,r2,8
 202fa50:	18000f1e 	bne	r3,zero,202fa90 <lwip_getsockopt_internal+0xdc>
 202fa54:	10800820 	cmpeqi	r2,r2,32
 202fa58:	10000d1e 	bne	r2,zero,202fa90 <lwip_getsockopt_internal+0xdc>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fa5c:	00006e06 	br	202fc18 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202fa60:	10c401e0 	cmpeqi	r3,r2,4103
 202fa64:	1800331e 	bne	r3,zero,202fb34 <lwip_getsockopt_internal+0x180>
 202fa68:	10c40208 	cmpgei	r3,r2,4104
 202fa6c:	1800031e 	bne	r3,zero,202fa7c <lwip_getsockopt_internal+0xc8>
 202fa70:	108401a0 	cmpeqi	r2,r2,4102
 202fa74:	1000571e 	bne	r2,zero,202fbd4 <lwip_getsockopt_internal+0x220>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fa78:	00006706 	br	202fc18 <lwip_getsockopt_internal+0x264>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202fa7c:	10c40220 	cmpeqi	r3,r2,4104
 202fa80:	18000d1e 	bne	r3,zero,202fab8 <lwip_getsockopt_internal+0x104>
 202fa84:	108402a0 	cmpeqi	r2,r2,4106
 202fa88:	1000581e 	bne	r2,zero,202fbec <lwip_getsockopt_internal+0x238>
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fa8c:	00006206 	br	202fc18 <lwip_getsockopt_internal+0x264>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
 202fa90:	e0bffb17 	ldw	r2,-20(fp)
 202fa94:	10800017 	ldw	r2,0(r2)
 202fa98:	10800217 	ldw	r2,8(r2)
 202fa9c:	10800203 	ldbu	r2,8(r2)
 202faa0:	10c03fcc 	andi	r3,r2,255
 202faa4:	e0bffd17 	ldw	r2,-12(fp)
 202faa8:	1886703a 	and	r3,r3,r2
 202faac:	e0bffe17 	ldw	r2,-8(fp)
 202fab0:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
 202fab4:	00005806 	br	202fc18 <lwip_getsockopt_internal+0x264>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
 202fab8:	e0bffb17 	ldw	r2,-20(fp)
 202fabc:	10800017 	ldw	r2,0(r2)
 202fac0:	10800017 	ldw	r2,0(r2)
 202fac4:	10803c0c 	andi	r2,r2,240
 202fac8:	10c00820 	cmpeqi	r3,r2,32
 202facc:	18000d1e 	bne	r3,zero,202fb04 <lwip_getsockopt_internal+0x150>
 202fad0:	10c01020 	cmpeqi	r3,r2,64
 202fad4:	1800031e 	bne	r3,zero,202fae4 <lwip_getsockopt_internal+0x130>
 202fad8:	10800420 	cmpeqi	r2,r2,16
 202fadc:	1000051e 	bne	r2,zero,202faf4 <lwip_getsockopt_internal+0x140>
 202fae0:	00000c06 	br	202fb14 <lwip_getsockopt_internal+0x160>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
 202fae4:	e0bffe17 	ldw	r2,-8(fp)
 202fae8:	00c000c4 	movi	r3,3
 202faec:	10c00015 	stw	r3,0(r2)
        break;
 202faf0:	00000f06 	br	202fb30 <lwip_getsockopt_internal+0x17c>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
 202faf4:	e0bffe17 	ldw	r2,-8(fp)
 202faf8:	00c00044 	movi	r3,1
 202fafc:	10c00015 	stw	r3,0(r2)
        break;
 202fb00:	00000b06 	br	202fb30 <lwip_getsockopt_internal+0x17c>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
 202fb04:	e0bffe17 	ldw	r2,-8(fp)
 202fb08:	00c00084 	movi	r3,2
 202fb0c:	10c00015 	stw	r3,0(r2)
        break;
 202fb10:	00000706 	br	202fb30 <lwip_getsockopt_internal+0x17c>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
 202fb14:	e0bffb17 	ldw	r2,-20(fp)
 202fb18:	10800017 	ldw	r2,0(r2)
 202fb1c:	10800017 	ldw	r2,0(r2)
 202fb20:	1007883a 	mov	r3,r2
 202fb24:	e0bffe17 	ldw	r2,-8(fp)
 202fb28:	10c00015 	stw	r3,0(r2)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
 202fb2c:	00003a06 	br	202fc18 <lwip_getsockopt_internal+0x264>
 202fb30:	00003906 	br	202fc18 <lwip_getsockopt_internal+0x264>

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
 202fb34:	e0bffb17 	ldw	r2,-20(fp)
 202fb38:	10800417 	ldw	r2,16(r2)
 202fb3c:	10000426 	beq	r2,zero,202fb50 <lwip_getsockopt_internal+0x19c>
 202fb40:	e0bffb17 	ldw	r2,-20(fp)
 202fb44:	10800417 	ldw	r2,16(r2)
 202fb48:	10801dd8 	cmpnei	r2,r2,119
 202fb4c:	10001a1e 	bne	r2,zero,202fbb8 <lwip_getsockopt_internal+0x204>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
 202fb50:	e0bffb17 	ldw	r2,-20(fp)
 202fb54:	10800017 	ldw	r2,0(r2)
 202fb58:	10800303 	ldbu	r2,12(r2)
 202fb5c:	10803fcc 	andi	r2,r2,255
 202fb60:	1080201c 	xori	r2,r2,128
 202fb64:	10bfe004 	addi	r2,r2,-128
 202fb68:	0085c83a 	sub	r2,zero,r2
 202fb6c:	10800428 	cmpgeui	r2,r2,16
 202fb70:	10000e1e 	bne	r2,zero,202fbac <lwip_getsockopt_internal+0x1f8>
 202fb74:	e0bffb17 	ldw	r2,-20(fp)
 202fb78:	10800017 	ldw	r2,0(r2)
 202fb7c:	10800303 	ldbu	r2,12(r2)
 202fb80:	10803fcc 	andi	r2,r2,255
 202fb84:	1080201c 	xori	r2,r2,128
 202fb88:	10bfe004 	addi	r2,r2,-128
 202fb8c:	0087c83a 	sub	r3,zero,r2
 202fb90:	00808134 	movhi	r2,516
 202fb94:	108d4204 	addi	r2,r2,13576
 202fb98:	18c7883a 	add	r3,r3,r3
 202fb9c:	18c7883a 	add	r3,r3,r3
 202fba0:	10c5883a 	add	r2,r2,r3
 202fba4:	10800017 	ldw	r2,0(r2)
 202fba8:	00000106 	br	202fbb0 <lwip_getsockopt_internal+0x1fc>
 202fbac:	00800144 	movi	r2,5
 202fbb0:	e0fffb17 	ldw	r3,-20(fp)
 202fbb4:	18800415 	stw	r2,16(r3)
      } 
      *(int *)optval = sock->err;
 202fbb8:	e0bffb17 	ldw	r2,-20(fp)
 202fbbc:	10c00417 	ldw	r3,16(r2)
 202fbc0:	e0bffe17 	ldw	r2,-8(fp)
 202fbc4:	10c00015 	stw	r3,0(r2)
      sock->err = 0;
 202fbc8:	e0bffb17 	ldw	r2,-20(fp)
 202fbcc:	10000415 	stw	zero,16(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
 202fbd0:	00001106 	br	202fc18 <lwip_getsockopt_internal+0x264>
      *(int *)optval = netconn_get_sendtimeout(sock->conn);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      *(int *)optval = netconn_get_recvtimeout(sock->conn);
 202fbd4:	e0bffb17 	ldw	r2,-20(fp)
 202fbd8:	10800017 	ldw	r2,0(r2)
 202fbdc:	10c00817 	ldw	r3,32(r2)
 202fbe0:	e0bffe17 	ldw	r2,-8(fp)
 202fbe4:	10c00015 	stw	r3,0(r2)
      break;
 202fbe8:	00000b06 	br	202fc18 <lwip_getsockopt_internal+0x264>
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
 202fbec:	e0bffb17 	ldw	r2,-20(fp)
 202fbf0:	10800017 	ldw	r2,0(r2)
 202fbf4:	10800217 	ldw	r2,8(r2)
 202fbf8:	10800403 	ldbu	r2,16(r2)
 202fbfc:	10803fcc 	andi	r2,r2,255
 202fc00:	1080004c 	andi	r2,r2,1
 202fc04:	1004c03a 	cmpne	r2,r2,zero
 202fc08:	10c03fcc 	andi	r3,r2,255
 202fc0c:	e0bffe17 	ldw	r2,-8(fp)
 202fc10:	10c00015 	stw	r3,0(r2)
      break;
 202fc14:	0001883a 	nop
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 202fc18:	00005a06 	br	202fd84 <lwip_getsockopt_internal+0x3d0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 202fc1c:	e0bffd17 	ldw	r2,-12(fp)
 202fc20:	10c00060 	cmpeqi	r3,r2,1
 202fc24:	18000b1e 	bne	r3,zero,202fc54 <lwip_getsockopt_internal+0x2a0>
 202fc28:	108000a0 	cmpeqi	r2,r2,2
 202fc2c:	1000011e 	bne	r2,zero,202fc34 <lwip_getsockopt_internal+0x280>
                  s, *(int *)optval));
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fc30:	00001006 	br	202fc74 <lwip_getsockopt_internal+0x2c0>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
 202fc34:	e0bffb17 	ldw	r2,-20(fp)
 202fc38:	10800017 	ldw	r2,0(r2)
 202fc3c:	10800217 	ldw	r2,8(r2)
 202fc40:	10800283 	ldbu	r2,10(r2)
 202fc44:	10c03fcc 	andi	r3,r2,255
 202fc48:	e0bffe17 	ldw	r2,-8(fp)
 202fc4c:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
 202fc50:	00000806 	br	202fc74 <lwip_getsockopt_internal+0x2c0>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
 202fc54:	e0bffb17 	ldw	r2,-20(fp)
 202fc58:	10800017 	ldw	r2,0(r2)
 202fc5c:	10800217 	ldw	r2,8(r2)
 202fc60:	10800243 	ldbu	r2,9(r2)
 202fc64:	10c03fcc 	andi	r3,r2,255
 202fc68:	e0bffe17 	ldw	r2,-8(fp)
 202fc6c:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
 202fc70:	0001883a 	nop
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 202fc74:	00004306 	br	202fd84 <lwip_getsockopt_internal+0x3d0>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 202fc78:	e0bffd17 	ldw	r2,-12(fp)
 202fc7c:	108001a8 	cmpgeui	r2,r2,6
 202fc80:	10003e1e 	bne	r2,zero,202fd7c <lwip_getsockopt_internal+0x3c8>
 202fc84:	e0bffd17 	ldw	r2,-12(fp)
 202fc88:	100690ba 	slli	r3,r2,2
 202fc8c:	008080f4 	movhi	r2,515
 202fc90:	10bf2804 	addi	r2,r2,-864
 202fc94:	1885883a 	add	r2,r3,r2
 202fc98:	10800017 	ldw	r2,0(r2)
 202fc9c:	1000683a 	jmp	r2
 202fca0:	0202fd7c 	xorhi	r8,zero,3061
 202fca4:	0202fcb8 	rdprs	r8,zero,3058
 202fca8:	0202fce4 	muli	r8,zero,3059
 202fcac:	0202fd04 	movi	r8,3060
 202fcb0:	0202fd30 	cmpltui	r8,zero,3060
 202fcb4:	0202fd5c 	xori	r8,zero,3061
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
 202fcb8:	e0bffb17 	ldw	r2,-20(fp)
 202fcbc:	10800017 	ldw	r2,0(r2)
 202fcc0:	10800217 	ldw	r2,8(r2)
 202fcc4:	10800883 	ldbu	r2,34(r2)
 202fcc8:	10803fcc 	andi	r2,r2,255
 202fccc:	1080100c 	andi	r2,r2,64
 202fcd0:	1004c03a 	cmpne	r2,r2,zero
 202fcd4:	10c03fcc 	andi	r3,r2,255
 202fcd8:	e0bffe17 	ldw	r2,-8(fp)
 202fcdc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
 202fce0:	00002706 	br	202fd80 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
 202fce4:	e0bffb17 	ldw	r2,-20(fp)
 202fce8:	10800017 	ldw	r2,0(r2)
 202fcec:	10800217 	ldw	r2,8(r2)
 202fcf0:	10802517 	ldw	r2,148(r2)
 202fcf4:	1007883a 	mov	r3,r2
 202fcf8:	e0bffe17 	ldw	r2,-8(fp)
 202fcfc:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
 202fd00:	00001f06 	br	202fd80 <lwip_getsockopt_internal+0x3cc>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_idle/1000);
 202fd04:	e0bffb17 	ldw	r2,-20(fp)
 202fd08:	10800017 	ldw	r2,0(r2)
 202fd0c:	10800217 	ldw	r2,8(r2)
 202fd10:	10802517 	ldw	r2,148(r2)
 202fd14:	0140fa04 	movi	r5,1000
 202fd18:	1009883a 	mov	r4,r2
 202fd1c:	200aca80 	call	200aca8 <__udivsi3>
 202fd20:	1007883a 	mov	r3,r2
 202fd24:	e0bffe17 	ldw	r2,-8(fp)
 202fd28:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPIDLE) = %d\n",
                  s, *(int *)optval));
      break;
 202fd2c:	00001406 	br	202fd80 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPINTVL:
      *(int*)optval = (int)(sock->conn->pcb.tcp->keep_intvl/1000);
 202fd30:	e0bffb17 	ldw	r2,-20(fp)
 202fd34:	10800017 	ldw	r2,0(r2)
 202fd38:	10800217 	ldw	r2,8(r2)
 202fd3c:	10802617 	ldw	r2,152(r2)
 202fd40:	0140fa04 	movi	r5,1000
 202fd44:	1009883a 	mov	r4,r2
 202fd48:	200aca80 	call	200aca8 <__udivsi3>
 202fd4c:	1007883a 	mov	r3,r2
 202fd50:	e0bffe17 	ldw	r2,-8(fp)
 202fd54:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPINTVL) = %d\n",
                  s, *(int *)optval));
      break;
 202fd58:	00000906 	br	202fd80 <lwip_getsockopt_internal+0x3cc>
    case TCP_KEEPCNT:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_cnt;
 202fd5c:	e0bffb17 	ldw	r2,-20(fp)
 202fd60:	10800017 	ldw	r2,0(r2)
 202fd64:	10800217 	ldw	r2,8(r2)
 202fd68:	10802717 	ldw	r2,156(r2)
 202fd6c:	1007883a 	mov	r3,r2
 202fd70:	e0bffe17 	ldw	r2,-8(fp)
 202fd74:	10c00015 	stw	r3,0(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
 202fd78:	00000106 	br	202fd80 <lwip_getsockopt_internal+0x3cc>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 202fd7c:	0001883a 	nop
    }  /* switch (optname) */
    break;
 202fd80:	0001883a 	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 202fd84:	e0bffb17 	ldw	r2,-20(fp)
 202fd88:	10800017 	ldw	r2,0(r2)
 202fd8c:	10800404 	addi	r2,r2,16
 202fd90:	1009883a 	mov	r4,r2
 202fd94:	2014f380 	call	2014f38 <sys_sem_signal>
}
 202fd98:	0001883a 	nop
 202fd9c:	e037883a 	mov	sp,fp
 202fda0:	dfc00117 	ldw	ra,4(sp)
 202fda4:	df000017 	ldw	fp,0(sp)
 202fda8:	dec00204 	addi	sp,sp,8
 202fdac:	f800283a 	ret

0202fdb0 <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 202fdb0:	defff204 	addi	sp,sp,-56
 202fdb4:	dfc00d15 	stw	ra,52(sp)
 202fdb8:	df000c15 	stw	fp,48(sp)
 202fdbc:	df000c04 	addi	fp,sp,48
 202fdc0:	e13ffc15 	stw	r4,-16(fp)
 202fdc4:	e17ffd15 	stw	r5,-12(fp)
 202fdc8:	e1bffe15 	stw	r6,-8(fp)
 202fdcc:	e1ffff15 	stw	r7,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 202fdd0:	e13ffc17 	ldw	r4,-16(fp)
 202fdd4:	202d2f80 	call	202d2f8 <get_socket>
 202fdd8:	e0bff515 	stw	r2,-44(fp)
  err_t err = ERR_OK;
 202fddc:	e03ff405 	stb	zero,-48(fp)
  struct lwip_setgetsockopt_data data;

  if (!sock) {
 202fde0:	e0bff517 	ldw	r2,-44(fp)
 202fde4:	1000021e 	bne	r2,zero,202fdf0 <lwip_setsockopt+0x40>
    return -1;
 202fde8:	00bfffc4 	movi	r2,-1
 202fdec:	00009006 	br	2030030 <lwip_setsockopt+0x280>
  }

  if (NULL == optval) {
 202fdf0:	e0bfff17 	ldw	r2,-4(fp)
 202fdf4:	1000051e 	bne	r2,zero,202fe0c <lwip_setsockopt+0x5c>
    sock_set_errno(sock, EFAULT);
 202fdf8:	e0bff517 	ldw	r2,-44(fp)
 202fdfc:	00c00384 	movi	r3,14
 202fe00:	10c00415 	stw	r3,16(r2)
    return -1;
 202fe04:	00bfffc4 	movi	r2,-1
 202fe08:	00008906 	br	2030030 <lwip_setsockopt+0x280>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 202fe0c:	e0bffd17 	ldw	r2,-12(fp)
 202fe10:	10c001a0 	cmpeqi	r3,r2,6
 202fe14:	1800441e 	bne	r3,zero,202ff28 <lwip_setsockopt+0x178>
 202fe18:	10c3ffe0 	cmpeqi	r3,r2,4095
 202fe1c:	1800021e 	bne	r3,zero,202fe28 <lwip_setsockopt+0x78>
 202fe20:	10003226 	beq	r2,zero,202feec <lwip_setsockopt+0x13c>
 202fe24:	00005606 	br	202ff80 <lwip_setsockopt+0x1d0>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 202fe28:	e0bffe17 	ldw	r2,-8(fp)
 202fe2c:	10c00820 	cmpeqi	r3,r2,32
 202fe30:	18000d1e 	bne	r3,zero,202fe68 <lwip_setsockopt+0xb8>
 202fe34:	10c00848 	cmpgei	r3,r2,33
 202fe38:	1800051e 	bne	r3,zero,202fe50 <lwip_setsockopt+0xa0>
 202fe3c:	10c00120 	cmpeqi	r3,r2,4
 202fe40:	1800091e 	bne	r3,zero,202fe68 <lwip_setsockopt+0xb8>
 202fe44:	10800220 	cmpeqi	r2,r2,8
 202fe48:	1000071e 	bne	r2,zero,202fe68 <lwip_setsockopt+0xb8>
 202fe4c:	00002006 	br	202fed0 <lwip_setsockopt+0x120>
 202fe50:	10c401a0 	cmpeqi	r3,r2,4102
 202fe54:	1800041e 	bne	r3,zero,202fe68 <lwip_setsockopt+0xb8>
 202fe58:	10c402a0 	cmpeqi	r3,r2,4106
 202fe5c:	1800081e 	bne	r3,zero,202fe80 <lwip_setsockopt+0xd0>
 202fe60:	10808020 	cmpeqi	r2,r2,512
 202fe64:	10001a26 	beq	r2,zero,202fed0 <lwip_setsockopt+0x120>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
 202fe68:	e0800217 	ldw	r2,8(fp)
 202fe6c:	10800128 	cmpgeui	r2,r2,4
 202fe70:	10001a1e 	bne	r2,zero,202fedc <lwip_setsockopt+0x12c>
        err = EINVAL;
 202fe74:	00800584 	movi	r2,22
 202fe78:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 202fe7c:	00001706 	br	202fedc <lwip_setsockopt+0x12c>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
 202fe80:	e0800217 	ldw	r2,8(fp)
 202fe84:	10800128 	cmpgeui	r2,r2,4
 202fe88:	1000021e 	bne	r2,zero,202fe94 <lwip_setsockopt+0xe4>
        err = EINVAL;
 202fe8c:	00800584 	movi	r2,22
 202fe90:	e0bff405 	stb	r2,-48(fp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 202fe94:	e0bff517 	ldw	r2,-44(fp)
 202fe98:	10800017 	ldw	r2,0(r2)
 202fe9c:	10800017 	ldw	r2,0(r2)
 202fea0:	10800818 	cmpnei	r2,r2,32
 202fea4:	1000071e 	bne	r2,zero,202fec4 <lwip_setsockopt+0x114>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 202fea8:	e0bff517 	ldw	r2,-44(fp)
 202feac:	10800017 	ldw	r2,0(r2)
 202feb0:	10800217 	ldw	r2,8(r2)
 202feb4:	10800403 	ldbu	r2,16(r2)
 202feb8:	10803fcc 	andi	r2,r2,255
 202febc:	1080008c 	andi	r2,r2,2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 202fec0:	10000826 	beq	r2,zero,202fee4 <lwip_setsockopt+0x134>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
 202fec4:	00801a84 	movi	r2,106
 202fec8:	e0bff405 	stb	r2,-48(fp)
      }
#endif /* LWIP_UDP */
      break;
 202fecc:	00000506 	br	202fee4 <lwip_setsockopt+0x134>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
 202fed0:	00801b44 	movi	r2,109
 202fed4:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202fed8:	00002b06 	br	202ff88 <lwip_setsockopt+0x1d8>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 202fedc:	0001883a 	nop
 202fee0:	00002906 	br	202ff88 <lwip_setsockopt+0x1d8>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
 202fee4:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202fee8:	00002706 	br	202ff88 <lwip_setsockopt+0x1d8>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 202feec:	e0bffe17 	ldw	r2,-8(fp)
 202fef0:	10bfffc4 	addi	r2,r2,-1
 202fef4:	108000a8 	cmpgeui	r2,r2,2
 202fef8:	1000061e 	bne	r2,zero,202ff14 <lwip_setsockopt+0x164>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
 202fefc:	e0800217 	ldw	r2,8(fp)
 202ff00:	10800128 	cmpgeui	r2,r2,4
 202ff04:	1000061e 	bne	r2,zero,202ff20 <lwip_setsockopt+0x170>
        err = EINVAL;
 202ff08:	00800584 	movi	r2,22
 202ff0c:	e0bff405 	stb	r2,-48(fp)
      }
      break;
 202ff10:	00000306 	br	202ff20 <lwip_setsockopt+0x170>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
 202ff14:	00801b44 	movi	r2,109
 202ff18:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202ff1c:	00001a06 	br	202ff88 <lwip_setsockopt+0x1d8>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
 202ff20:	0001883a 	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202ff24:	00001806 	br	202ff88 <lwip_setsockopt+0x1d8>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
 202ff28:	e0800217 	ldw	r2,8(fp)
 202ff2c:	10800128 	cmpgeui	r2,r2,4
 202ff30:	1000031e 	bne	r2,zero,202ff40 <lwip_setsockopt+0x190>
      err = EINVAL;
 202ff34:	00800584 	movi	r2,22
 202ff38:	e0bff405 	stb	r2,-48(fp)
      break;
 202ff3c:	00001206 	br	202ff88 <lwip_setsockopt+0x1d8>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 202ff40:	e0bff517 	ldw	r2,-44(fp)
 202ff44:	10800017 	ldw	r2,0(r2)
 202ff48:	10800017 	ldw	r2,0(r2)
 202ff4c:	10800420 	cmpeqi	r2,r2,16
 202ff50:	1000021e 	bne	r2,zero,202ff5c <lwip_setsockopt+0x1ac>
      return 0;
 202ff54:	0005883a 	mov	r2,zero
 202ff58:	00003506 	br	2030030 <lwip_setsockopt+0x280>

    switch (optname) {
 202ff5c:	e0bffe17 	ldw	r2,-8(fp)
 202ff60:	10bfffc4 	addi	r2,r2,-1
 202ff64:	10800168 	cmpgeui	r2,r2,5
 202ff68:	10000326 	beq	r2,zero,202ff78 <lwip_setsockopt+0x1c8>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
 202ff6c:	00801b44 	movi	r2,109
 202ff70:	e0bff405 	stb	r2,-48(fp)
    }  /* switch (optname) */
    break;
 202ff74:	00000406 	br	202ff88 <lwip_setsockopt+0x1d8>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
 202ff78:	0001883a 	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
 202ff7c:	00000206 	br	202ff88 <lwip_setsockopt+0x1d8>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
 202ff80:	00801b44 	movi	r2,109
 202ff84:	e0bff405 	stb	r2,-48(fp)
  }  /* switch (level) */


  if (err != ERR_OK) {
 202ff88:	e0bff407 	ldb	r2,-48(fp)
 202ff8c:	10000526 	beq	r2,zero,202ffa4 <lwip_setsockopt+0x1f4>
    sock_set_errno(sock, err);
 202ff90:	e0fff407 	ldb	r3,-48(fp)
 202ff94:	e0bff517 	ldw	r2,-44(fp)
 202ff98:	10c00415 	stw	r3,16(r2)
    return -1;
 202ff9c:	00bfffc4 	movi	r2,-1
 202ffa0:	00002306 	br	2030030 <lwip_setsockopt+0x280>
  }


  /* Now do the actual option processing */
  data.sock = sock;
 202ffa4:	e0bff517 	ldw	r2,-44(fp)
 202ffa8:	e0bff615 	stw	r2,-40(fp)
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 202ffac:	e0bffd17 	ldw	r2,-12(fp)
 202ffb0:	e0bff715 	stw	r2,-36(fp)
  data.optname = optname;
 202ffb4:	e0bffe17 	ldw	r2,-8(fp)
 202ffb8:	e0bff815 	stw	r2,-32(fp)
  data.optval = (void*)optval;
 202ffbc:	e0bfff17 	ldw	r2,-4(fp)
 202ffc0:	e0bff915 	stw	r2,-28(fp)
  data.optlen = &optlen;
 202ffc4:	e0800204 	addi	r2,fp,8
 202ffc8:	e0bffa15 	stw	r2,-24(fp)
  data.err = err;
 202ffcc:	e0bff403 	ldbu	r2,-48(fp)
 202ffd0:	e0bffb05 	stb	r2,-20(fp)
  tcpip_callback(lwip_setsockopt_internal, &data);
 202ffd4:	e0bff604 	addi	r2,fp,-40
 202ffd8:	01800044 	movi	r6,1
 202ffdc:	100b883a 	mov	r5,r2
 202ffe0:	010080f4 	movhi	r4,515
 202ffe4:	21001104 	addi	r4,r4,68
 202ffe8:	20307d40 	call	20307d4 <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 202ffec:	e0bff517 	ldw	r2,-44(fp)
 202fff0:	10800017 	ldw	r2,0(r2)
 202fff4:	10800404 	addi	r2,r2,16
 202fff8:	000b883a 	mov	r5,zero
 202fffc:	1009883a 	mov	r4,r2
 2030000:	2014f800 	call	2014f80 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
 2030004:	e0bffb03 	ldbu	r2,-20(fp)
 2030008:	e0bff405 	stb	r2,-48(fp)

  sock_set_errno(sock, err);
 203000c:	e0fff407 	ldb	r3,-48(fp)
 2030010:	e0bff517 	ldw	r2,-44(fp)
 2030014:	10c00415 	stw	r3,16(r2)
  return err ? -1 : 0;
 2030018:	e0bff407 	ldb	r2,-48(fp)
 203001c:	10000226 	beq	r2,zero,2030028 <lwip_setsockopt+0x278>
 2030020:	00bfffc4 	movi	r2,-1
 2030024:	00000206 	br	2030030 <lwip_setsockopt+0x280>
 2030028:	0005883a 	mov	r2,zero
 203002c:	0001883a 	nop
}
 2030030:	e037883a 	mov	sp,fp
 2030034:	dfc00117 	ldw	ra,4(sp)
 2030038:	df000017 	ldw	fp,0(sp)
 203003c:	dec00204 	addi	sp,sp,8
 2030040:	f800283a 	ret

02030044 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
 2030044:	defff804 	addi	sp,sp,-32
 2030048:	dfc00715 	stw	ra,28(sp)
 203004c:	df000615 	stw	fp,24(sp)
 2030050:	df000604 	addi	fp,sp,24
 2030054:	e13fff15 	stw	r4,-4(fp)
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
 2030058:	e0bfff17 	ldw	r2,-4(fp)
 203005c:	e0bffa15 	stw	r2,-24(fp)
  sock = data->sock;
 2030060:	e0bffa17 	ldw	r2,-24(fp)
 2030064:	10800017 	ldw	r2,0(r2)
 2030068:	e0bffb15 	stw	r2,-20(fp)
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
 203006c:	e0bffa17 	ldw	r2,-24(fp)
 2030070:	10800117 	ldw	r2,4(r2)
 2030074:	e0bffc15 	stw	r2,-16(fp)
  optname = data->optname;
 2030078:	e0bffa17 	ldw	r2,-24(fp)
 203007c:	10800217 	ldw	r2,8(r2)
 2030080:	e0bffd15 	stw	r2,-12(fp)
  optval = data->optval;
 2030084:	e0bffa17 	ldw	r2,-24(fp)
 2030088:	10800317 	ldw	r2,12(r2)
 203008c:	e0bffe15 	stw	r2,-8(fp)

  switch (level) {
 2030090:	e0bffc17 	ldw	r2,-16(fp)
 2030094:	10c001a0 	cmpeqi	r3,r2,6
 2030098:	1800651e 	bne	r3,zero,2030230 <lwip_setsockopt_internal+0x1ec>
 203009c:	10c3ffe0 	cmpeqi	r3,r2,4095
 20300a0:	1800021e 	bne	r3,zero,20300ac <lwip_setsockopt_internal+0x68>
 20300a4:	10004d26 	beq	r2,zero,20301dc <lwip_setsockopt_internal+0x198>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
 20300a8:	0000a906 	br	2030350 <lwip_setsockopt_internal+0x30c>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 20300ac:	e0bffd17 	ldw	r2,-12(fp)
 20300b0:	10c00820 	cmpeqi	r3,r2,32
 20300b4:	18000e1e 	bne	r3,zero,20300f0 <lwip_setsockopt_internal+0xac>
 20300b8:	10c00848 	cmpgei	r3,r2,33
 20300bc:	1800051e 	bne	r3,zero,20300d4 <lwip_setsockopt_internal+0x90>
 20300c0:	10c00120 	cmpeqi	r3,r2,4
 20300c4:	18000a1e 	bne	r3,zero,20300f0 <lwip_setsockopt_internal+0xac>
 20300c8:	10800220 	cmpeqi	r2,r2,8
 20300cc:	1000081e 	bne	r2,zero,20300f0 <lwip_setsockopt_internal+0xac>
      }
      break;
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 20300d0:	00004106 	br	20301d8 <lwip_setsockopt_internal+0x194>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 20300d4:	10c401a0 	cmpeqi	r3,r2,4102
 20300d8:	1800211e 	bne	r3,zero,2030160 <lwip_setsockopt_internal+0x11c>
 20300dc:	10c402a0 	cmpeqi	r3,r2,4106
 20300e0:	1800251e 	bne	r3,zero,2030178 <lwip_setsockopt_internal+0x134>
 20300e4:	10808020 	cmpeqi	r2,r2,512
 20300e8:	1000011e 	bne	r2,zero,20300f0 <lwip_setsockopt_internal+0xac>
      }
      break;
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 20300ec:	00003a06 	br	20301d8 <lwip_setsockopt_internal+0x194>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
 20300f0:	e0bffe17 	ldw	r2,-8(fp)
 20300f4:	10800017 	ldw	r2,0(r2)
 20300f8:	10000c26 	beq	r2,zero,203012c <lwip_setsockopt_internal+0xe8>
        ip_set_option(sock->conn->pcb.ip, optname);
 20300fc:	e0bffb17 	ldw	r2,-20(fp)
 2030100:	10800017 	ldw	r2,0(r2)
 2030104:	10800217 	ldw	r2,8(r2)
 2030108:	e0fffb17 	ldw	r3,-20(fp)
 203010c:	18c00017 	ldw	r3,0(r3)
 2030110:	18c00217 	ldw	r3,8(r3)
 2030114:	18c00203 	ldbu	r3,8(r3)
 2030118:	1809883a 	mov	r4,r3
 203011c:	e0fffd17 	ldw	r3,-12(fp)
 2030120:	20c6b03a 	or	r3,r4,r3
 2030124:	10c00205 	stb	r3,8(r2)
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
 2030128:	00002b06 	br	20301d8 <lwip_setsockopt_internal+0x194>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        ip_set_option(sock->conn->pcb.ip, optname);
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
 203012c:	e0bffb17 	ldw	r2,-20(fp)
 2030130:	10800017 	ldw	r2,0(r2)
 2030134:	10800217 	ldw	r2,8(r2)
 2030138:	e0fffb17 	ldw	r3,-20(fp)
 203013c:	18c00017 	ldw	r3,0(r3)
 2030140:	18c00217 	ldw	r3,8(r3)
 2030144:	18c00203 	ldbu	r3,8(r3)
 2030148:	1809883a 	mov	r4,r3
 203014c:	e0fffd17 	ldw	r3,-12(fp)
 2030150:	00c6303a 	nor	r3,zero,r3
 2030154:	20c6703a 	and	r3,r4,r3
 2030158:	10c00205 	stb	r3,8(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
 203015c:	00001e06 	br	20301d8 <lwip_setsockopt_internal+0x194>
      netconn_set_sendtimeout(sock->conn, (s32_t)*(int*)optval);
      break;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
    case SO_RCVTIMEO:
      netconn_set_recvtimeout(sock->conn, *(int*)optval);
 2030160:	e0bffb17 	ldw	r2,-20(fp)
 2030164:	10800017 	ldw	r2,0(r2)
 2030168:	e0fffe17 	ldw	r3,-8(fp)
 203016c:	18c00017 	ldw	r3,0(r3)
 2030170:	10c00815 	stw	r3,32(r2)
      break;
 2030174:	00001806 	br	20301d8 <lwip_setsockopt_internal+0x194>
      netconn_set_recvbufsize(sock->conn, *(int*)optval);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
 2030178:	e0bffe17 	ldw	r2,-8(fp)
 203017c:	10800017 	ldw	r2,0(r2)
 2030180:	10000a26 	beq	r2,zero,20301ac <lwip_setsockopt_internal+0x168>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
 2030184:	e0bffb17 	ldw	r2,-20(fp)
 2030188:	10800017 	ldw	r2,0(r2)
 203018c:	10800217 	ldw	r2,8(r2)
 2030190:	e0fffb17 	ldw	r3,-20(fp)
 2030194:	18c00017 	ldw	r3,0(r3)
 2030198:	18c00217 	ldw	r3,8(r3)
 203019c:	18c00403 	ldbu	r3,16(r3)
 20301a0:	18c00054 	ori	r3,r3,1
 20301a4:	10c00405 	stb	r3,16(r2)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
 20301a8:	00000a06 	br	20301d4 <lwip_setsockopt_internal+0x190>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
 20301ac:	e0bffb17 	ldw	r2,-20(fp)
 20301b0:	10800017 	ldw	r2,0(r2)
 20301b4:	10800217 	ldw	r2,8(r2)
 20301b8:	e0fffb17 	ldw	r3,-20(fp)
 20301bc:	18c00017 	ldw	r3,0(r3)
 20301c0:	18c00217 	ldw	r3,8(r3)
 20301c4:	19000403 	ldbu	r4,16(r3)
 20301c8:	00ffff84 	movi	r3,-2
 20301cc:	20c6703a 	and	r3,r4,r3
 20301d0:	10c00405 	stb	r3,16(r2)
      }
      break;
 20301d4:	0001883a 	nop
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 20301d8:	00005d06 	br	2030350 <lwip_setsockopt_internal+0x30c>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 20301dc:	e0bffd17 	ldw	r2,-12(fp)
 20301e0:	10c00060 	cmpeqi	r3,r2,1
 20301e4:	18000a1e 	bne	r3,zero,2030210 <lwip_setsockopt_internal+0x1cc>
 20301e8:	108000a0 	cmpeqi	r2,r2,2
 20301ec:	1000011e 	bne	r2,zero,20301f4 <lwip_setsockopt_internal+0x1b0>
      }
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 20301f0:	00000e06 	br	203022c <lwip_setsockopt_internal+0x1e8>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
 20301f4:	e0bffb17 	ldw	r2,-20(fp)
 20301f8:	10800017 	ldw	r2,0(r2)
 20301fc:	10800217 	ldw	r2,8(r2)
 2030200:	e0fffe17 	ldw	r3,-8(fp)
 2030204:	18c00017 	ldw	r3,0(r3)
 2030208:	10c00285 	stb	r3,10(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
 203020c:	00000706 	br	203022c <lwip_setsockopt_internal+0x1e8>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
 2030210:	e0bffb17 	ldw	r2,-20(fp)
 2030214:	10800017 	ldw	r2,0(r2)
 2030218:	10800217 	ldw	r2,8(r2)
 203021c:	e0fffe17 	ldw	r3,-8(fp)
 2030220:	18c00017 	ldw	r3,0(r3)
 2030224:	10c00245 	stb	r3,9(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
 2030228:	0001883a 	nop
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
 203022c:	00004806 	br	2030350 <lwip_setsockopt_internal+0x30c>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 2030230:	e0bffd17 	ldw	r2,-12(fp)
 2030234:	108001a8 	cmpgeui	r2,r2,6
 2030238:	1000431e 	bne	r2,zero,2030348 <lwip_setsockopt_internal+0x304>
 203023c:	e0bffd17 	ldw	r2,-12(fp)
 2030240:	100690ba 	slli	r3,r2,2
 2030244:	008080f4 	movhi	r2,515
 2030248:	10809604 	addi	r2,r2,600
 203024c:	1885883a 	add	r2,r3,r2
 2030250:	10800017 	ldw	r2,0(r2)
 2030254:	1000683a 	jmp	r2
 2030258:	02030348 	cmpgei	r8,zero,3085
 203025c:	02030270 	cmpltui	r8,zero,3081
 2030260:	020302d0 	cmplti	r8,zero,3083
 2030264:	020302ec 	andhi	r8,zero,3083
 2030268:	0203030c 	andi	r8,zero,3084
 203026c:	0203032c 	andhi	r8,zero,3084
    case TCP_NODELAY:
      if (*(int*)optval) {
 2030270:	e0bffe17 	ldw	r2,-8(fp)
 2030274:	10800017 	ldw	r2,0(r2)
 2030278:	10000a26 	beq	r2,zero,20302a4 <lwip_setsockopt_internal+0x260>
        tcp_nagle_disable(sock->conn->pcb.tcp);
 203027c:	e0bffb17 	ldw	r2,-20(fp)
 2030280:	10800017 	ldw	r2,0(r2)
 2030284:	10800217 	ldw	r2,8(r2)
 2030288:	e0fffb17 	ldw	r3,-20(fp)
 203028c:	18c00017 	ldw	r3,0(r3)
 2030290:	18c00217 	ldw	r3,8(r3)
 2030294:	18c00883 	ldbu	r3,34(r3)
 2030298:	18c01014 	ori	r3,r3,64
 203029c:	10c00885 	stb	r3,34(r2)
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
 20302a0:	00002a06 	br	203034c <lwip_setsockopt_internal+0x308>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        tcp_nagle_disable(sock->conn->pcb.tcp);
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
 20302a4:	e0bffb17 	ldw	r2,-20(fp)
 20302a8:	10800017 	ldw	r2,0(r2)
 20302ac:	10800217 	ldw	r2,8(r2)
 20302b0:	e0fffb17 	ldw	r3,-20(fp)
 20302b4:	18c00017 	ldw	r3,0(r3)
 20302b8:	18c00217 	ldw	r3,8(r3)
 20302bc:	19000883 	ldbu	r4,34(r3)
 20302c0:	00ffefc4 	movi	r3,-65
 20302c4:	20c6703a 	and	r3,r4,r3
 20302c8:	10c00885 	stb	r3,34(r2)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
 20302cc:	00001f06 	br	203034c <lwip_setsockopt_internal+0x308>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
 20302d0:	e0bffb17 	ldw	r2,-20(fp)
 20302d4:	10800017 	ldw	r2,0(r2)
 20302d8:	10800217 	ldw	r2,8(r2)
 20302dc:	e0fffe17 	ldw	r3,-8(fp)
 20302e0:	18c00017 	ldw	r3,0(r3)
 20302e4:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
 20302e8:	00001806 	br	203034c <lwip_setsockopt_internal+0x308>

#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
      sock->conn->pcb.tcp->keep_idle = 1000*(u32_t)(*(int*)optval);
 20302ec:	e0bffb17 	ldw	r2,-20(fp)
 20302f0:	10800017 	ldw	r2,0(r2)
 20302f4:	10800217 	ldw	r2,8(r2)
 20302f8:	e0fffe17 	ldw	r3,-8(fp)
 20302fc:	18c00017 	ldw	r3,0(r3)
 2030300:	18c0fa24 	muli	r3,r3,1000
 2030304:	10c02515 	stw	r3,148(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPIDLE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
 2030308:	00001006 	br	203034c <lwip_setsockopt_internal+0x308>
    case TCP_KEEPINTVL:
      sock->conn->pcb.tcp->keep_intvl = 1000*(u32_t)(*(int*)optval);
 203030c:	e0bffb17 	ldw	r2,-20(fp)
 2030310:	10800017 	ldw	r2,0(r2)
 2030314:	10800217 	ldw	r2,8(r2)
 2030318:	e0fffe17 	ldw	r3,-8(fp)
 203031c:	18c00017 	ldw	r3,0(r3)
 2030320:	18c0fa24 	muli	r3,r3,1000
 2030324:	10c02615 	stw	r3,152(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPINTVL) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_intvl));
      break;
 2030328:	00000806 	br	203034c <lwip_setsockopt_internal+0x308>
    case TCP_KEEPCNT:
      sock->conn->pcb.tcp->keep_cnt = (u32_t)(*(int*)optval);
 203032c:	e0bffb17 	ldw	r2,-20(fp)
 2030330:	10800017 	ldw	r2,0(r2)
 2030334:	10800217 	ldw	r2,8(r2)
 2030338:	e0fffe17 	ldw	r3,-8(fp)
 203033c:	18c00017 	ldw	r3,0(r3)
 2030340:	10c02715 	stw	r3,156(r2)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
 2030344:	00000106 	br	203034c <lwip_setsockopt_internal+0x308>
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
 2030348:	0001883a 	nop
    }  /* switch (optname) */
    break;
 203034c:	0001883a 	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 2030350:	e0bffb17 	ldw	r2,-20(fp)
 2030354:	10800017 	ldw	r2,0(r2)
 2030358:	10800404 	addi	r2,r2,16
 203035c:	1009883a 	mov	r4,r2
 2030360:	2014f380 	call	2014f38 <sys_sem_signal>
}
 2030364:	0001883a 	nop
 2030368:	e037883a 	mov	sp,fp
 203036c:	dfc00117 	ldw	ra,4(sp)
 2030370:	df000017 	ldw	fp,0(sp)
 2030374:	dec00204 	addi	sp,sp,8
 2030378:	f800283a 	ret

0203037c <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
 203037c:	defff904 	addi	sp,sp,-28
 2030380:	dfc00615 	stw	ra,24(sp)
 2030384:	df000515 	stw	fp,20(sp)
 2030388:	df000504 	addi	fp,sp,20
 203038c:	e13ffd15 	stw	r4,-12(fp)
 2030390:	e17ffe15 	stw	r5,-8(fp)
 2030394:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 2030398:	e13ffd17 	ldw	r4,-12(fp)
 203039c:	202d2f80 	call	202d2f8 <get_socket>
 20303a0:	e0bffc15 	stw	r2,-16(fp)
#if LWIP_SO_RCVBUF
  u16_t buflen = 0;
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
 20303a4:	e0bffc17 	ldw	r2,-16(fp)
 20303a8:	1000021e 	bne	r2,zero,20303b4 <lwip_ioctl+0x38>
    return -1;
 20303ac:	00bfffc4 	movi	r2,-1
 20303b0:	00002606 	br	203044c <lwip_ioctl+0xd0>
  }

  switch (cmd) {
 20303b4:	e0fffe17 	ldw	r3,-8(fp)
 20303b8:	00a00134 	movhi	r2,32772
 20303bc:	10999f84 	addi	r2,r2,26238
 20303c0:	18801e1e 	bne	r3,r2,203043c <lwip_ioctl+0xc0>
    sock_set_errno(sock, 0);
    return 0;
#endif /* LWIP_SO_RCVBUF */

  case FIONBIO:
    val = 0;
 20303c4:	e03ffb05 	stb	zero,-20(fp)
    if (argp && *(u32_t*)argp) {
 20303c8:	e0bfff17 	ldw	r2,-4(fp)
 20303cc:	10000526 	beq	r2,zero,20303e4 <lwip_ioctl+0x68>
 20303d0:	e0bfff17 	ldw	r2,-4(fp)
 20303d4:	10800017 	ldw	r2,0(r2)
 20303d8:	10000226 	beq	r2,zero,20303e4 <lwip_ioctl+0x68>
      val = 1;
 20303dc:	00800044 	movi	r2,1
 20303e0:	e0bffb05 	stb	r2,-20(fp)
    }
    netconn_set_nonblocking(sock->conn, val);
 20303e4:	e0bffb03 	ldbu	r2,-20(fp)
 20303e8:	10000826 	beq	r2,zero,203040c <lwip_ioctl+0x90>
 20303ec:	e0bffc17 	ldw	r2,-16(fp)
 20303f0:	10800017 	ldw	r2,0(r2)
 20303f4:	e0fffc17 	ldw	r3,-16(fp)
 20303f8:	18c00017 	ldw	r3,0(r3)
 20303fc:	18c00903 	ldbu	r3,36(r3)
 2030400:	18c00094 	ori	r3,r3,2
 2030404:	10c00905 	stb	r3,36(r2)
 2030408:	00000806 	br	203042c <lwip_ioctl+0xb0>
 203040c:	e0bffc17 	ldw	r2,-16(fp)
 2030410:	10800017 	ldw	r2,0(r2)
 2030414:	e0fffc17 	ldw	r3,-16(fp)
 2030418:	18c00017 	ldw	r3,0(r3)
 203041c:	19000903 	ldbu	r4,36(r3)
 2030420:	00ffff44 	movi	r3,-3
 2030424:	20c6703a 	and	r3,r4,r3
 2030428:	10c00905 	stb	r3,36(r2)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
 203042c:	e0bffc17 	ldw	r2,-16(fp)
 2030430:	10000415 	stw	zero,16(r2)
    return 0;
 2030434:	0005883a 	mov	r2,zero
 2030438:	00000406 	br	203044c <lwip_ioctl+0xd0>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
 203043c:	e0bffc17 	ldw	r2,-16(fp)
 2030440:	00c01604 	movi	r3,88
 2030444:	10c00415 	stw	r3,16(r2)
    return -1;
 2030448:	00bfffc4 	movi	r2,-1
  } /* switch (cmd) */
}
 203044c:	e037883a 	mov	sp,fp
 2030450:	dfc00117 	ldw	ra,4(sp)
 2030454:	df000017 	ldw	fp,0(sp)
 2030458:	dec00204 	addi	sp,sp,8
 203045c:	f800283a 	ret

02030460 <lwip_fcntl>:
 * Currently only the commands F_GETFL and F_SETFL are implemented.
 * Only the flag O_NONBLOCK is implemented.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
 2030460:	defff904 	addi	sp,sp,-28
 2030464:	dfc00615 	stw	ra,24(sp)
 2030468:	df000515 	stw	fp,20(sp)
 203046c:	df000504 	addi	fp,sp,20
 2030470:	e13ffd15 	stw	r4,-12(fp)
 2030474:	e17ffe15 	stw	r5,-8(fp)
 2030478:	e1bfff15 	stw	r6,-4(fp)
  struct lwip_sock *sock = get_socket(s);
 203047c:	e13ffd17 	ldw	r4,-12(fp)
 2030480:	202d2f80 	call	202d2f8 <get_socket>
 2030484:	e0bffc15 	stw	r2,-16(fp)
  int ret = -1;
 2030488:	00bfffc4 	movi	r2,-1
 203048c:	e0bffb15 	stw	r2,-20(fp)

  if (!sock || !sock->conn) {
 2030490:	e0bffc17 	ldw	r2,-16(fp)
 2030494:	10000326 	beq	r2,zero,20304a4 <lwip_fcntl+0x44>
 2030498:	e0bffc17 	ldw	r2,-16(fp)
 203049c:	10800017 	ldw	r2,0(r2)
 20304a0:	1000021e 	bne	r2,zero,20304ac <lwip_fcntl+0x4c>
    return -1;
 20304a4:	00bfffc4 	movi	r2,-1
 20304a8:	00002906 	br	2030550 <lwip_fcntl+0xf0>
  }

  switch (cmd) {
 20304ac:	e0bffe17 	ldw	r2,-8(fp)
 20304b0:	10c000e0 	cmpeqi	r3,r2,3
 20304b4:	1800031e 	bne	r3,zero,20304c4 <lwip_fcntl+0x64>
 20304b8:	10800120 	cmpeqi	r2,r2,4
 20304bc:	10000a1e 	bne	r2,zero,20304e8 <lwip_fcntl+0x88>
      ret = 0;
    }
    break;
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
 20304c0:	00002206 	br	203054c <lwip_fcntl+0xec>
    return -1;
  }

  switch (cmd) {
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
 20304c4:	e0bffc17 	ldw	r2,-16(fp)
 20304c8:	10800017 	ldw	r2,0(r2)
 20304cc:	10800903 	ldbu	r2,36(r2)
 20304d0:	10803fcc 	andi	r2,r2,255
 20304d4:	1080008c 	andi	r2,r2,2
 20304d8:	1004c03a 	cmpne	r2,r2,zero
 20304dc:	10803fcc 	andi	r2,r2,255
 20304e0:	e0bffb15 	stw	r2,-20(fp)
    break;
 20304e4:	00001906 	br	203054c <lwip_fcntl+0xec>
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
 20304e8:	e0ffff17 	ldw	r3,-4(fp)
 20304ec:	00bfff84 	movi	r2,-2
 20304f0:	1884703a 	and	r2,r3,r2
 20304f4:	1000141e 	bne	r2,zero,2030548 <lwip_fcntl+0xe8>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
 20304f8:	e0bfff17 	ldw	r2,-4(fp)
 20304fc:	1080004c 	andi	r2,r2,1
 2030500:	10000826 	beq	r2,zero,2030524 <lwip_fcntl+0xc4>
 2030504:	e0bffc17 	ldw	r2,-16(fp)
 2030508:	10800017 	ldw	r2,0(r2)
 203050c:	e0fffc17 	ldw	r3,-16(fp)
 2030510:	18c00017 	ldw	r3,0(r3)
 2030514:	18c00903 	ldbu	r3,36(r3)
 2030518:	18c00094 	ori	r3,r3,2
 203051c:	10c00905 	stb	r3,36(r2)
 2030520:	00000806 	br	2030544 <lwip_fcntl+0xe4>
 2030524:	e0bffc17 	ldw	r2,-16(fp)
 2030528:	10800017 	ldw	r2,0(r2)
 203052c:	e0fffc17 	ldw	r3,-16(fp)
 2030530:	18c00017 	ldw	r3,0(r3)
 2030534:	19000903 	ldbu	r4,36(r3)
 2030538:	00ffff44 	movi	r3,-3
 203053c:	20c6703a 	and	r3,r4,r3
 2030540:	10c00905 	stb	r3,36(r2)
      ret = 0;
 2030544:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 2030548:	0001883a 	nop
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
  }
  return ret;
 203054c:	e0bffb17 	ldw	r2,-20(fp)
}
 2030550:	e037883a 	mov	sp,fp
 2030554:	dfc00117 	ldw	ra,4(sp)
 2030558:	df000017 	ldw	fp,0(sp)
 203055c:	dec00204 	addi	sp,sp,8
 2030560:	f800283a 	ret

02030564 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 2030564:	defffc04 	addi	sp,sp,-16
 2030568:	dfc00315 	stw	ra,12(sp)
 203056c:	df000215 	stw	fp,8(sp)
 2030570:	df000204 	addi	fp,sp,8
 2030574:	e13fff15 	stw	r4,-4(fp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 2030578:	d0a80e17 	ldw	r2,-24520(gp)
 203057c:	10000426 	beq	r2,zero,2030590 <tcpip_thread+0x2c>
    tcpip_init_done(tcpip_init_done_arg);
 2030580:	d0a80e17 	ldw	r2,-24520(gp)
 2030584:	d0e80f17 	ldw	r3,-24516(gp)
 2030588:	1809883a 	mov	r4,r3
 203058c:	103ee83a 	callr	r2
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
 2030590:	e17ffe04 	addi	r5,fp,-8
 2030594:	d1281004 	addi	r4,gp,-24512
 2030598:	20219a80 	call	20219a8 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
 203059c:	e0bffe17 	ldw	r2,-8(fp)
 20305a0:	10800017 	ldw	r2,0(r2)
 20305a4:	10c001a8 	cmpgeui	r3,r2,6
 20305a8:	18005c1e 	bne	r3,zero,203071c <tcpip_thread+0x1b8>
 20305ac:	100690ba 	slli	r3,r2,2
 20305b0:	008080f4 	movhi	r2,515
 20305b4:	10817104 	addi	r2,r2,1476
 20305b8:	1885883a 	add	r2,r3,r2
 20305bc:	10800017 	ldw	r2,0(r2)
 20305c0:	1000683a 	jmp	r2
 20305c4:	020305dc 	xori	r8,zero,3095
 20305c8:	02030600 	call	203060 <alt_exception_muldiv+0x203060>
 20305cc:	02030668 	cmpgeui	r8,zero,3097
 20305d0:	020306a4 	muli	r8,zero,3098
 20305d4:	020306d4 	movui	r8,3099
 20305d8:	02030700 	call	203070 <alt_exception_muldiv+0x203070>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
 20305dc:	e0bffe17 	ldw	r2,-8(fp)
 20305e0:	10800217 	ldw	r2,8(r2)
 20305e4:	10800017 	ldw	r2,0(r2)
 20305e8:	e0fffe17 	ldw	r3,-8(fp)
 20305ec:	18c00217 	ldw	r3,8(r3)
 20305f0:	18c00104 	addi	r3,r3,4
 20305f4:	1809883a 	mov	r4,r3
 20305f8:	103ee83a 	callr	r2
      break;
 20305fc:	00004806 	br	2030720 <tcpip_thread+0x1bc>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 2030600:	e0bffe17 	ldw	r2,-8(fp)
 2030604:	10800317 	ldw	r2,12(r2)
 2030608:	10800e43 	ldbu	r2,57(r2)
 203060c:	10803fcc 	andi	r2,r2,255
 2030610:	1080180c 	andi	r2,r2,96
 2030614:	10000826 	beq	r2,zero,2030638 <tcpip_thread+0xd4>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 2030618:	e0bffe17 	ldw	r2,-8(fp)
 203061c:	10c00217 	ldw	r3,8(r2)
 2030620:	e0bffe17 	ldw	r2,-8(fp)
 2030624:	10800317 	ldw	r2,12(r2)
 2030628:	100b883a 	mov	r5,r2
 203062c:	1809883a 	mov	r4,r3
 2030630:	20243bc0 	call	20243bc <ethernet_input>
 2030634:	00000706 	br	2030654 <tcpip_thread+0xf0>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
 2030638:	e0bffe17 	ldw	r2,-8(fp)
 203063c:	10c00217 	ldw	r3,8(r2)
 2030640:	e0bffe17 	ldw	r2,-8(fp)
 2030644:	10800317 	ldw	r2,12(r2)
 2030648:	100b883a 	mov	r5,r2
 203064c:	1809883a 	mov	r4,r3
 2030650:	2031e0c0 	call	2031e0c <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 2030654:	e0bffe17 	ldw	r2,-8(fp)
 2030658:	100b883a 	mov	r5,r2
 203065c:	01000284 	movi	r4,10
 2030660:	20346000 	call	2034600 <memp_free>
      break;
 2030664:	00002e06 	br	2030720 <tcpip_thread+0x1bc>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
 2030668:	e0bffe17 	ldw	r2,-8(fp)
 203066c:	10c00217 	ldw	r3,8(r2)
 2030670:	e0bffe17 	ldw	r2,-8(fp)
 2030674:	11000317 	ldw	r4,12(r2)
 2030678:	e0bffe17 	ldw	r2,-8(fp)
 203067c:	10800417 	ldw	r2,16(r2)
 2030680:	100d883a 	mov	r6,r2
 2030684:	200b883a 	mov	r5,r4
 2030688:	1809883a 	mov	r4,r3
 203068c:	20217380 	call	2021738 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 2030690:	e0bffe17 	ldw	r2,-8(fp)
 2030694:	100b883a 	mov	r5,r2
 2030698:	01000244 	movi	r4,9
 203069c:	20346000 	call	2034600 <memp_free>
      break;
 20306a0:	00001f06 	br	2030720 <tcpip_thread+0x1bc>
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
 20306a4:	e0bffe17 	ldw	r2,-8(fp)
 20306a8:	10c00317 	ldw	r3,12(r2)
 20306ac:	e0bffe17 	ldw	r2,-8(fp)
 20306b0:	10800417 	ldw	r2,16(r2)
 20306b4:	100b883a 	mov	r5,r2
 20306b8:	1809883a 	mov	r4,r3
 20306bc:	20218b40 	call	20218b4 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 20306c0:	e0bffe17 	ldw	r2,-8(fp)
 20306c4:	100b883a 	mov	r5,r2
 20306c8:	01000244 	movi	r4,9
 20306cc:	20346000 	call	2034600 <memp_free>
      break;
 20306d0:	00001306 	br	2030720 <tcpip_thread+0x1bc>
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 20306d4:	e0bffe17 	ldw	r2,-8(fp)
 20306d8:	10800217 	ldw	r2,8(r2)
 20306dc:	e0fffe17 	ldw	r3,-8(fp)
 20306e0:	18c00317 	ldw	r3,12(r3)
 20306e4:	1809883a 	mov	r4,r3
 20306e8:	103ee83a 	callr	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 20306ec:	e0bffe17 	ldw	r2,-8(fp)
 20306f0:	100b883a 	mov	r5,r2
 20306f4:	01000244 	movi	r4,9
 20306f8:	20346000 	call	2034600 <memp_free>
      break;
 20306fc:	00000806 	br	2030720 <tcpip_thread+0x1bc>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 2030700:	e0bffe17 	ldw	r2,-8(fp)
 2030704:	10800217 	ldw	r2,8(r2)
 2030708:	e0fffe17 	ldw	r3,-8(fp)
 203070c:	18c00317 	ldw	r3,12(r3)
 2030710:	1809883a 	mov	r4,r3
 2030714:	103ee83a 	callr	r2
      break;
 2030718:	00000106 	br	2030720 <tcpip_thread+0x1bc>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
 203071c:	0001883a 	nop
    }
  }
 2030720:	003f9b06 	br	2030590 <__alt_mem_mem_0+0xfd010590>

02030724 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 2030724:	defffb04 	addi	sp,sp,-20
 2030728:	dfc00415 	stw	ra,16(sp)
 203072c:	df000315 	stw	fp,12(sp)
 2030730:	df000304 	addi	fp,sp,12
 2030734:	e13ffe15 	stw	r4,-8(fp)
 2030738:	e17fff15 	stw	r5,-4(fp)
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 203073c:	d0a81017 	ldw	r2,-24512(gp)
 2030740:	1000021e 	bne	r2,zero,203074c <tcpip_input+0x28>
    return ERR_VAL;
 2030744:	00bffe84 	movi	r2,-6
 2030748:	00001d06 	br	20307c0 <tcpip_input+0x9c>
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 203074c:	01000284 	movi	r4,10
 2030750:	20344340 	call	2034434 <memp_malloc>
 2030754:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 2030758:	e0bffd17 	ldw	r2,-12(fp)
 203075c:	1000021e 	bne	r2,zero,2030768 <tcpip_input+0x44>
    return ERR_MEM;
 2030760:	00bfffc4 	movi	r2,-1
 2030764:	00001606 	br	20307c0 <tcpip_input+0x9c>
  }

  msg->type = TCPIP_MSG_INPKT;
 2030768:	e0bffd17 	ldw	r2,-12(fp)
 203076c:	00c00044 	movi	r3,1
 2030770:	10c00015 	stw	r3,0(r2)
  msg->msg.inp.p = p;
 2030774:	e0bffd17 	ldw	r2,-12(fp)
 2030778:	e0fffe17 	ldw	r3,-8(fp)
 203077c:	10c00215 	stw	r3,8(r2)
  msg->msg.inp.netif = inp;
 2030780:	e0bffd17 	ldw	r2,-12(fp)
 2030784:	e0ffff17 	ldw	r3,-4(fp)
 2030788:	10c00315 	stw	r3,12(r2)
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 203078c:	e17ffd17 	ldw	r5,-12(fp)
 2030790:	d1281004 	addi	r4,gp,-24512
 2030794:	20153980 	call	2015398 <sys_mbox_trypost>
 2030798:	10803fcc 	andi	r2,r2,255
 203079c:	1080201c 	xori	r2,r2,128
 20307a0:	10bfe004 	addi	r2,r2,-128
 20307a4:	10000526 	beq	r2,zero,20307bc <tcpip_input+0x98>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 20307a8:	e17ffd17 	ldw	r5,-12(fp)
 20307ac:	01000284 	movi	r4,10
 20307b0:	20346000 	call	2034600 <memp_free>
    return ERR_MEM;
 20307b4:	00bfffc4 	movi	r2,-1
 20307b8:	00000106 	br	20307c0 <tcpip_input+0x9c>
  }
  return ERR_OK;
 20307bc:	0005883a 	mov	r2,zero
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 20307c0:	e037883a 	mov	sp,fp
 20307c4:	dfc00117 	ldw	ra,4(sp)
 20307c8:	df000017 	ldw	fp,0(sp)
 20307cc:	dec00204 	addi	sp,sp,8
 20307d0:	f800283a 	ret

020307d4 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 20307d4:	defffa04 	addi	sp,sp,-24
 20307d8:	dfc00515 	stw	ra,20(sp)
 20307dc:	df000415 	stw	fp,16(sp)
 20307e0:	df000404 	addi	fp,sp,16
 20307e4:	e13ffd15 	stw	r4,-12(fp)
 20307e8:	e17ffe15 	stw	r5,-8(fp)
 20307ec:	3005883a 	mov	r2,r6
 20307f0:	e0bfff05 	stb	r2,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 20307f4:	d0a81017 	ldw	r2,-24512(gp)
 20307f8:	10002426 	beq	r2,zero,203088c <tcpip_callback_with_block+0xb8>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 20307fc:	01000244 	movi	r4,9
 2030800:	20344340 	call	2034434 <memp_malloc>
 2030804:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
 2030808:	e0bffc17 	ldw	r2,-16(fp)
 203080c:	1000021e 	bne	r2,zero,2030818 <tcpip_callback_with_block+0x44>
      return ERR_MEM;
 2030810:	00bfffc4 	movi	r2,-1
 2030814:	00001e06 	br	2030890 <tcpip_callback_with_block+0xbc>
    }

    msg->type = TCPIP_MSG_CALLBACK;
 2030818:	e0bffc17 	ldw	r2,-16(fp)
 203081c:	00c00104 	movi	r3,4
 2030820:	10c00015 	stw	r3,0(r2)
    msg->msg.cb.function = function;
 2030824:	e0bffc17 	ldw	r2,-16(fp)
 2030828:	e0fffd17 	ldw	r3,-12(fp)
 203082c:	10c00215 	stw	r3,8(r2)
    msg->msg.cb.ctx = ctx;
 2030830:	e0bffc17 	ldw	r2,-16(fp)
 2030834:	e0fffe17 	ldw	r3,-8(fp)
 2030838:	10c00315 	stw	r3,12(r2)
    if (block) {
 203083c:	e0bfff03 	ldbu	r2,-4(fp)
 2030840:	10000426 	beq	r2,zero,2030854 <tcpip_callback_with_block+0x80>
      sys_mbox_post(&mbox, msg);
 2030844:	e17ffc17 	ldw	r5,-16(fp)
 2030848:	d1281004 	addi	r4,gp,-24512
 203084c:	20153480 	call	2015348 <sys_mbox_post>
 2030850:	00000c06 	br	2030884 <tcpip_callback_with_block+0xb0>
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 2030854:	e17ffc17 	ldw	r5,-16(fp)
 2030858:	d1281004 	addi	r4,gp,-24512
 203085c:	20153980 	call	2015398 <sys_mbox_trypost>
 2030860:	10803fcc 	andi	r2,r2,255
 2030864:	1080201c 	xori	r2,r2,128
 2030868:	10bfe004 	addi	r2,r2,-128
 203086c:	10000526 	beq	r2,zero,2030884 <tcpip_callback_with_block+0xb0>
        memp_free(MEMP_TCPIP_MSG_API, msg);
 2030870:	e17ffc17 	ldw	r5,-16(fp)
 2030874:	01000244 	movi	r4,9
 2030878:	20346000 	call	2034600 <memp_free>
        return ERR_MEM;
 203087c:	00bfffc4 	movi	r2,-1
 2030880:	00000306 	br	2030890 <tcpip_callback_with_block+0xbc>
      }
    }
    return ERR_OK;
 2030884:	0005883a 	mov	r2,zero
 2030888:	00000106 	br	2030890 <tcpip_callback_with_block+0xbc>
  }
  return ERR_VAL;
 203088c:	00bffe84 	movi	r2,-6
}
 2030890:	e037883a 	mov	sp,fp
 2030894:	dfc00117 	ldw	ra,4(sp)
 2030898:	df000017 	ldw	fp,0(sp)
 203089c:	dec00204 	addi	sp,sp,8
 20308a0:	f800283a 	ret

020308a4 <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 20308a4:	defffa04 	addi	sp,sp,-24
 20308a8:	dfc00515 	stw	ra,20(sp)
 20308ac:	df000415 	stw	fp,16(sp)
 20308b0:	df000404 	addi	fp,sp,16
 20308b4:	e13ffd15 	stw	r4,-12(fp)
 20308b8:	e17ffe15 	stw	r5,-8(fp)
 20308bc:	e1bfff15 	stw	r6,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 20308c0:	d0a81017 	ldw	r2,-24512(gp)
 20308c4:	10001826 	beq	r2,zero,2030928 <tcpip_timeout+0x84>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 20308c8:	01000244 	movi	r4,9
 20308cc:	20344340 	call	2034434 <memp_malloc>
 20308d0:	e0bffc15 	stw	r2,-16(fp)
    if (msg == NULL) {
 20308d4:	e0bffc17 	ldw	r2,-16(fp)
 20308d8:	1000021e 	bne	r2,zero,20308e4 <tcpip_timeout+0x40>
      return ERR_MEM;
 20308dc:	00bfffc4 	movi	r2,-1
 20308e0:	00001206 	br	203092c <tcpip_timeout+0x88>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
 20308e4:	e0bffc17 	ldw	r2,-16(fp)
 20308e8:	00c00084 	movi	r3,2
 20308ec:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.msecs = msecs;
 20308f0:	e0bffc17 	ldw	r2,-16(fp)
 20308f4:	e0fffd17 	ldw	r3,-12(fp)
 20308f8:	10c00215 	stw	r3,8(r2)
    msg->msg.tmo.h = h;
 20308fc:	e0bffc17 	ldw	r2,-16(fp)
 2030900:	e0fffe17 	ldw	r3,-8(fp)
 2030904:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
 2030908:	e0bffc17 	ldw	r2,-16(fp)
 203090c:	e0ffff17 	ldw	r3,-4(fp)
 2030910:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
 2030914:	e17ffc17 	ldw	r5,-16(fp)
 2030918:	d1281004 	addi	r4,gp,-24512
 203091c:	20153480 	call	2015348 <sys_mbox_post>
    return ERR_OK;
 2030920:	0005883a 	mov	r2,zero
 2030924:	00000106 	br	203092c <tcpip_timeout+0x88>
  }
  return ERR_VAL;
 2030928:	00bffe84 	movi	r2,-6
}
 203092c:	e037883a 	mov	sp,fp
 2030930:	dfc00117 	ldw	ra,4(sp)
 2030934:	df000017 	ldw	fp,0(sp)
 2030938:	dec00204 	addi	sp,sp,8
 203093c:	f800283a 	ret

02030940 <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 2030940:	defffb04 	addi	sp,sp,-20
 2030944:	dfc00415 	stw	ra,16(sp)
 2030948:	df000315 	stw	fp,12(sp)
 203094c:	df000304 	addi	fp,sp,12
 2030950:	e13ffe15 	stw	r4,-8(fp)
 2030954:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 2030958:	d0a81017 	ldw	r2,-24512(gp)
 203095c:	10001526 	beq	r2,zero,20309b4 <tcpip_untimeout+0x74>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2030960:	01000244 	movi	r4,9
 2030964:	20344340 	call	2034434 <memp_malloc>
 2030968:	e0bffd15 	stw	r2,-12(fp)
    if (msg == NULL) {
 203096c:	e0bffd17 	ldw	r2,-12(fp)
 2030970:	1000021e 	bne	r2,zero,203097c <tcpip_untimeout+0x3c>
      return ERR_MEM;
 2030974:	00bfffc4 	movi	r2,-1
 2030978:	00000f06 	br	20309b8 <tcpip_untimeout+0x78>
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
 203097c:	e0bffd17 	ldw	r2,-12(fp)
 2030980:	00c000c4 	movi	r3,3
 2030984:	10c00015 	stw	r3,0(r2)
    msg->msg.tmo.h = h;
 2030988:	e0bffd17 	ldw	r2,-12(fp)
 203098c:	e0fffe17 	ldw	r3,-8(fp)
 2030990:	10c00315 	stw	r3,12(r2)
    msg->msg.tmo.arg = arg;
 2030994:	e0bffd17 	ldw	r2,-12(fp)
 2030998:	e0ffff17 	ldw	r3,-4(fp)
 203099c:	10c00415 	stw	r3,16(r2)
    sys_mbox_post(&mbox, msg);
 20309a0:	e17ffd17 	ldw	r5,-12(fp)
 20309a4:	d1281004 	addi	r4,gp,-24512
 20309a8:	20153480 	call	2015348 <sys_mbox_post>
    return ERR_OK;
 20309ac:	0005883a 	mov	r2,zero
 20309b0:	00000106 	br	20309b8 <tcpip_untimeout+0x78>
  }
  return ERR_VAL;
 20309b4:	00bffe84 	movi	r2,-6
}
 20309b8:	e037883a 	mov	sp,fp
 20309bc:	dfc00117 	ldw	ra,4(sp)
 20309c0:	df000017 	ldw	fp,0(sp)
 20309c4:	dec00204 	addi	sp,sp,8
 20309c8:	f800283a 	ret

020309cc <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 20309cc:	defff804 	addi	sp,sp,-32
 20309d0:	dfc00715 	stw	ra,28(sp)
 20309d4:	df000615 	stw	fp,24(sp)
 20309d8:	df000604 	addi	fp,sp,24
 20309dc:	e13fff15 	stw	r4,-4(fp)
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
 20309e0:	d0a81017 	ldw	r2,-24512(gp)
 20309e4:	10000f26 	beq	r2,zero,2030a24 <tcpip_apimsg+0x58>
    msg.type = TCPIP_MSG_API;
 20309e8:	e03ffa15 	stw	zero,-24(fp)
    msg.msg.apimsg = apimsg;
 20309ec:	e0bfff17 	ldw	r2,-4(fp)
 20309f0:	e0bffc15 	stw	r2,-16(fp)
    sys_mbox_post(&mbox, &msg);
 20309f4:	e17ffa04 	addi	r5,fp,-24
 20309f8:	d1281004 	addi	r4,gp,-24512
 20309fc:	20153480 	call	2015348 <sys_mbox_post>
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
 2030a00:	e0bfff17 	ldw	r2,-4(fp)
 2030a04:	10800117 	ldw	r2,4(r2)
 2030a08:	10800404 	addi	r2,r2,16
 2030a0c:	000b883a 	mov	r5,zero
 2030a10:	1009883a 	mov	r4,r2
 2030a14:	2014f800 	call	2014f80 <sys_arch_sem_wait>
    return apimsg->msg.err;
 2030a18:	e0bfff17 	ldw	r2,-4(fp)
 2030a1c:	10800203 	ldbu	r2,8(r2)
 2030a20:	00000106 	br	2030a28 <tcpip_apimsg+0x5c>
  }
  return ERR_VAL;
 2030a24:	00bffe84 	movi	r2,-6
}
 2030a28:	e037883a 	mov	sp,fp
 2030a2c:	dfc00117 	ldw	ra,4(sp)
 2030a30:	df000017 	ldw	fp,0(sp)
 2030a34:	dec00204 	addi	sp,sp,8
 2030a38:	f800283a 	ret

02030a3c <tcpip_callbackmsg_new>:
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 2030a3c:	defffb04 	addi	sp,sp,-20
 2030a40:	dfc00415 	stw	ra,16(sp)
 2030a44:	df000315 	stw	fp,12(sp)
 2030a48:	df000304 	addi	fp,sp,12
 2030a4c:	e13ffe15 	stw	r4,-8(fp)
 2030a50:	e17fff15 	stw	r5,-4(fp)
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2030a54:	01000244 	movi	r4,9
 2030a58:	20344340 	call	2034434 <memp_malloc>
 2030a5c:	e0bffd15 	stw	r2,-12(fp)
  if (msg == NULL) {
 2030a60:	e0bffd17 	ldw	r2,-12(fp)
 2030a64:	1000021e 	bne	r2,zero,2030a70 <tcpip_callbackmsg_new+0x34>
    return NULL;
 2030a68:	0005883a 	mov	r2,zero
 2030a6c:	00000a06 	br	2030a98 <tcpip_callbackmsg_new+0x5c>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 2030a70:	e0bffd17 	ldw	r2,-12(fp)
 2030a74:	00c00144 	movi	r3,5
 2030a78:	10c00015 	stw	r3,0(r2)
  msg->msg.cb.function = function;
 2030a7c:	e0bffd17 	ldw	r2,-12(fp)
 2030a80:	e0fffe17 	ldw	r3,-8(fp)
 2030a84:	10c00215 	stw	r3,8(r2)
  msg->msg.cb.ctx = ctx;
 2030a88:	e0bffd17 	ldw	r2,-12(fp)
 2030a8c:	e0ffff17 	ldw	r3,-4(fp)
 2030a90:	10c00315 	stw	r3,12(r2)
  return (struct tcpip_callback_msg*)msg;
 2030a94:	e0bffd17 	ldw	r2,-12(fp)
}
 2030a98:	e037883a 	mov	sp,fp
 2030a9c:	dfc00117 	ldw	ra,4(sp)
 2030aa0:	df000017 	ldw	fp,0(sp)
 2030aa4:	dec00204 	addi	sp,sp,8
 2030aa8:	f800283a 	ret

02030aac <tcpip_callbackmsg_delete>:
 * Free a callback message allocated by tcpip_callbackmsg_new().
 *
 * @param msg the message to free
 */
void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
 2030aac:	defffd04 	addi	sp,sp,-12
 2030ab0:	dfc00215 	stw	ra,8(sp)
 2030ab4:	df000115 	stw	fp,4(sp)
 2030ab8:	df000104 	addi	fp,sp,4
 2030abc:	e13fff15 	stw	r4,-4(fp)
  memp_free(MEMP_TCPIP_MSG_API, msg);
 2030ac0:	e17fff17 	ldw	r5,-4(fp)
 2030ac4:	01000244 	movi	r4,9
 2030ac8:	20346000 	call	2034600 <memp_free>
}
 2030acc:	0001883a 	nop
 2030ad0:	e037883a 	mov	sp,fp
 2030ad4:	dfc00117 	ldw	ra,4(sp)
 2030ad8:	df000017 	ldw	fp,0(sp)
 2030adc:	dec00204 	addi	sp,sp,8
 2030ae0:	f800283a 	ret

02030ae4 <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
 2030ae4:	defffd04 	addi	sp,sp,-12
 2030ae8:	dfc00215 	stw	ra,8(sp)
 2030aec:	df000115 	stw	fp,4(sp)
 2030af0:	df000104 	addi	fp,sp,4
 2030af4:	e13fff15 	stw	r4,-4(fp)
  if (!sys_mbox_valid(&mbox)) {
 2030af8:	d0a81017 	ldw	r2,-24512(gp)
 2030afc:	1000021e 	bne	r2,zero,2030b08 <tcpip_trycallback+0x24>
    return ERR_VAL;
 2030b00:	00bffe84 	movi	r2,-6
 2030b04:	00000306 	br	2030b14 <tcpip_trycallback+0x30>
  }
  return sys_mbox_trypost(&mbox, msg);
 2030b08:	e17fff17 	ldw	r5,-4(fp)
 2030b0c:	d1281004 	addi	r4,gp,-24512
 2030b10:	20153980 	call	2015398 <sys_mbox_trypost>
}
 2030b14:	e037883a 	mov	sp,fp
 2030b18:	dfc00117 	ldw	ra,4(sp)
 2030b1c:	df000017 	ldw	fp,0(sp)
 2030b20:	dec00204 	addi	sp,sp,8
 2030b24:	f800283a 	ret

02030b28 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 2030b28:	defffb04 	addi	sp,sp,-20
 2030b2c:	dfc00415 	stw	ra,16(sp)
 2030b30:	df000315 	stw	fp,12(sp)
 2030b34:	df000304 	addi	fp,sp,12
 2030b38:	e13ffe15 	stw	r4,-8(fp)
 2030b3c:	e17fff15 	stw	r5,-4(fp)
  lwip_init();
 2030b40:	2030c500 	call	2030c50 <lwip_init>

  tcpip_init_done = initfunc;
 2030b44:	e0bffe17 	ldw	r2,-8(fp)
 2030b48:	d0a80e15 	stw	r2,-24520(gp)
  tcpip_init_done_arg = arg;
 2030b4c:	e0bfff17 	ldw	r2,-4(fp)
 2030b50:	d0a80f15 	stw	r2,-24516(gp)
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 2030b54:	01440004 	movi	r5,4096
 2030b58:	d1281004 	addi	r4,gp,-24512
 2030b5c:	20152080 	call	2015208 <sys_mbox_new>
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 2030b60:	008000c4 	movi	r2,3
 2030b64:	d8800015 	stw	r2,0(sp)
 2030b68:	01c80004 	movi	r7,8192
 2030b6c:	000d883a 	mov	r6,zero
 2030b70:	014080f4 	movhi	r5,515
 2030b74:	29415904 	addi	r5,r5,1380
 2030b78:	01008134 	movhi	r4,516
 2030b7c:	210d7b04 	addi	r4,r4,13804
 2030b80:	20155600 	call	2015560 <sys_thread_new>
}
 2030b84:	0001883a 	nop
 2030b88:	e037883a 	mov	sp,fp
 2030b8c:	dfc00117 	ldw	ra,4(sp)
 2030b90:	df000017 	ldw	fp,0(sp)
 2030b94:	dec00204 	addi	sp,sp,8
 2030b98:	f800283a 	ret

02030b9c <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
 2030b9c:	defffc04 	addi	sp,sp,-16
 2030ba0:	dfc00315 	stw	ra,12(sp)
 2030ba4:	df000215 	stw	fp,8(sp)
 2030ba8:	df000204 	addi	fp,sp,8
 2030bac:	e13fff15 	stw	r4,-4(fp)
  struct pbuf *q = (struct pbuf *)p;
 2030bb0:	e0bfff17 	ldw	r2,-4(fp)
 2030bb4:	e0bffe15 	stw	r2,-8(fp)
  pbuf_free(q);
 2030bb8:	e13ffe17 	ldw	r4,-8(fp)
 2030bbc:	201ab680 	call	201ab68 <pbuf_free>
}
 2030bc0:	0001883a 	nop
 2030bc4:	e037883a 	mov	sp,fp
 2030bc8:	dfc00117 	ldw	ra,4(sp)
 2030bcc:	df000017 	ldw	fp,0(sp)
 2030bd0:	dec00204 	addi	sp,sp,8
 2030bd4:	f800283a 	ret

02030bd8 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
 2030bd8:	defffd04 	addi	sp,sp,-12
 2030bdc:	dfc00215 	stw	ra,8(sp)
 2030be0:	df000115 	stw	fp,4(sp)
 2030be4:	df000104 	addi	fp,sp,4
 2030be8:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
 2030bec:	000d883a 	mov	r6,zero
 2030bf0:	e17fff17 	ldw	r5,-4(fp)
 2030bf4:	010080f4 	movhi	r4,515
 2030bf8:	2102e704 	addi	r4,r4,2972
 2030bfc:	20307d40 	call	20307d4 <tcpip_callback_with_block>
}
 2030c00:	e037883a 	mov	sp,fp
 2030c04:	dfc00117 	ldw	ra,4(sp)
 2030c08:	df000017 	ldw	fp,0(sp)
 2030c0c:	dec00204 	addi	sp,sp,8
 2030c10:	f800283a 	ret

02030c14 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
 2030c14:	defffd04 	addi	sp,sp,-12
 2030c18:	dfc00215 	stw	ra,8(sp)
 2030c1c:	df000115 	stw	fp,4(sp)
 2030c20:	df000104 	addi	fp,sp,4
 2030c24:	e13fff15 	stw	r4,-4(fp)
  return tcpip_callback_with_block(mem_free, m, 0);
 2030c28:	000d883a 	mov	r6,zero
 2030c2c:	e17fff17 	ldw	r5,-4(fp)
 2030c30:	010080b4 	movhi	r4,514
 2030c34:	2124a804 	addi	r4,r4,-28000
 2030c38:	20307d40 	call	20307d4 <tcpip_callback_with_block>
}
 2030c3c:	e037883a 	mov	sp,fp
 2030c40:	dfc00117 	ldw	ra,4(sp)
 2030c44:	df000017 	ldw	fp,0(sp)
 2030c48:	dec00204 	addi	sp,sp,8
 2030c4c:	f800283a 	ret

02030c50 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 2030c50:	defffe04 	addi	sp,sp,-8
 2030c54:	dfc00115 	stw	ra,4(sp)
 2030c58:	df000015 	stw	fp,0(sp)
 2030c5c:	d839883a 	mov	fp,sp
  /* Modules initialization */
  stats_init();
 2030c60:	201b9300 	call	201b930 <stats_init>
#if !NO_SYS
  sys_init();
 2030c64:	2014d880 	call	2014d88 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 2030c68:	20191e80 	call	20191e8 <mem_init>
  memp_init();
 2030c6c:	20342700 	call	2034270 <memp_init>
  pbuf_init();
  netif_init();
 2030c70:	2019a5c0 	call	2019a5c <netif_init>
#if LWIP_SOCKET
  lwip_socket_init();
 2030c74:	202d2d80 	call	202d2d8 <lwip_socket_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 2030c78:	2021abc0 	call	2021abc <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 2030c7c:	201b9500 	call	201b950 <tcp_init>
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 2030c80:	20216c00 	call	20216c0 <sys_timeouts_init>
#endif /* LWIP_TIMERS */
}
 2030c84:	0001883a 	nop
 2030c88:	e037883a 	mov	sp,fp
 2030c8c:	dfc00117 	ldw	ra,4(sp)
 2030c90:	df000017 	ldw	fp,0(sp)
 2030c94:	dec00204 	addi	sp,sp,8
 2030c98:	f800283a 	ret

02030c9c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 2030c9c:	defff304 	addi	sp,sp,-52
 2030ca0:	dfc00c15 	stw	ra,48(sp)
 2030ca4:	df000b15 	stw	fp,44(sp)
 2030ca8:	df000b04 	addi	fp,sp,44
 2030cac:	e13ffe15 	stw	r4,-8(fp)
 2030cb0:	e17fff15 	stw	r5,-4(fp)
#endif /* LWIP_DEBUG */
  struct icmp_echo_hdr *iecho;
  struct ip_hdr *iphdr;
  s16_t hlen;

  ICMP_STATS_INC(icmp.recv);
 2030cb4:	008085f4 	movhi	r2,535
 2030cb8:	10a8bc04 	addi	r2,r2,-23824
 2030cbc:	10803117 	ldw	r2,196(r2)
 2030cc0:	10c00044 	addi	r3,r2,1
 2030cc4:	008085f4 	movhi	r2,535
 2030cc8:	10a8bc04 	addi	r2,r2,-23824
 2030ccc:	10c03115 	stw	r3,196(r2)
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
 2030cd0:	e0bffe17 	ldw	r2,-8(fp)
 2030cd4:	10800117 	ldw	r2,4(r2)
 2030cd8:	e0bff815 	stw	r2,-32(fp)
  hlen = IPH_HL(iphdr) * 4;
 2030cdc:	e0bff817 	ldw	r2,-32(fp)
 2030ce0:	10800003 	ldbu	r2,0(r2)
 2030ce4:	10803fcc 	andi	r2,r2,255
 2030ce8:	108003cc 	andi	r2,r2,15
 2030cec:	1085883a 	add	r2,r2,r2
 2030cf0:	1085883a 	add	r2,r2,r2
 2030cf4:	e0bffa0d 	sth	r2,-24(fp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 2030cf8:	e0bffa0b 	ldhu	r2,-24(fp)
 2030cfc:	0085c83a 	sub	r2,zero,r2
 2030d00:	10bfffcc 	andi	r2,r2,65535
 2030d04:	10a0001c 	xori	r2,r2,32768
 2030d08:	10a00004 	addi	r2,r2,-32768
 2030d0c:	100b883a 	mov	r5,r2
 2030d10:	e13ffe17 	ldw	r4,-8(fp)
 2030d14:	201a9b80 	call	201a9b8 <pbuf_header>
 2030d18:	10803fcc 	andi	r2,r2,255
 2030d1c:	10013c1e 	bne	r2,zero,2031210 <icmp_input+0x574>
 2030d20:	e0bffe17 	ldw	r2,-8(fp)
 2030d24:	1080020b 	ldhu	r2,8(r2)
 2030d28:	10bfffcc 	andi	r2,r2,65535
 2030d2c:	10800130 	cmpltui	r2,r2,4
 2030d30:	1001371e 	bne	r2,zero,2031210 <icmp_input+0x574>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 2030d34:	e0bffe17 	ldw	r2,-8(fp)
 2030d38:	10800117 	ldw	r2,4(r2)
 2030d3c:	10800003 	ldbu	r2,0(r2)
 2030d40:	e0bffa85 	stb	r2,-22(fp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 2030d44:	e0bffa83 	ldbu	r2,-22(fp)
 2030d48:	10012a26 	beq	r2,zero,20311f4 <icmp_input+0x558>
 2030d4c:	10800220 	cmpeqi	r2,r2,8
 2030d50:	10011926 	beq	r2,zero,20311b8 <icmp_input+0x51c>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
 2030d54:	00800044 	movi	r2,1
 2030d58:	e0bff915 	stw	r2,-28(fp)
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 2030d5c:	d0a81417 	ldw	r2,-24496(gp)
 2030d60:	10803c0c 	andi	r2,r2,240
 2030d64:	10803818 	cmpnei	r2,r2,224
 2030d68:	1000011e 	bne	r2,zero,2030d70 <icmp_input+0xd4>
        accepted = 0;
 2030d6c:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 2030d70:	d0a81417 	ldw	r2,-24496(gp)
 2030d74:	e17fff17 	ldw	r5,-4(fp)
 2030d78:	1009883a 	mov	r4,r2
 2030d7c:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2030d80:	10803fcc 	andi	r2,r2,255
 2030d84:	10000126 	beq	r2,zero,2030d8c <icmp_input+0xf0>
        accepted = 0;
 2030d88:	e03ff915 	stw	zero,-28(fp)
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
 2030d8c:	e0bff917 	ldw	r2,-28(fp)
 2030d90:	10000a1e 	bne	r2,zero,2030dbc <icmp_input+0x120>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
 2030d94:	008085f4 	movhi	r2,535
 2030d98:	10a8bc04 	addi	r2,r2,-23824
 2030d9c:	10803a17 	ldw	r2,232(r2)
 2030da0:	10c00044 	addi	r3,r2,1
 2030da4:	008085f4 	movhi	r2,535
 2030da8:	10a8bc04 	addi	r2,r2,-23824
 2030dac:	10c03a15 	stw	r3,232(r2)
        pbuf_free(p);
 2030db0:	e13ffe17 	ldw	r4,-8(fp)
 2030db4:	201ab680 	call	201ab68 <pbuf_free>
        return;
 2030db8:	00013206 	br	2031284 <icmp_input+0x5e8>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 2030dbc:	e0bffe17 	ldw	r2,-8(fp)
 2030dc0:	1080020b 	ldhu	r2,8(r2)
 2030dc4:	10bfffcc 	andi	r2,r2,65535
 2030dc8:	10800228 	cmpgeui	r2,r2,8
 2030dcc:	10010f26 	beq	r2,zero,203120c <icmp_input+0x570>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 2030dd0:	e13ffe17 	ldw	r4,-8(fp)
 2030dd4:	2031bb80 	call	2031bb8 <inet_chksum_pbuf>
 2030dd8:	10bfffcc 	andi	r2,r2,65535
 2030ddc:	10000a26 	beq	r2,zero,2030e08 <icmp_input+0x16c>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
 2030de0:	e13ffe17 	ldw	r4,-8(fp)
 2030de4:	201ab680 	call	201ab68 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
 2030de8:	008085f4 	movhi	r2,535
 2030dec:	10a8bc04 	addi	r2,r2,-23824
 2030df0:	10803417 	ldw	r2,208(r2)
 2030df4:	10c00044 	addi	r3,r2,1
 2030df8:	008085f4 	movhi	r2,535
 2030dfc:	10a8bc04 	addi	r2,r2,-23824
 2030e00:	10c03415 	stw	r3,208(r2)
      snmp_inc_icmpinerrors();
      return;
 2030e04:	00011f06 	br	2031284 <icmp_input+0x5e8>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 2030e08:	01400904 	movi	r5,36
 2030e0c:	e13ffe17 	ldw	r4,-8(fp)
 2030e10:	201a9b80 	call	201a9b8 <pbuf_header>
 2030e14:	10803fcc 	andi	r2,r2,255
 2030e18:	10002926 	beq	r2,zero,2030ec0 <icmp_input+0x224>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 2030e1c:	e0bffa0f 	ldh	r2,-24(fp)
 2030e20:	100b883a 	mov	r5,r2
 2030e24:	e13ffe17 	ldw	r4,-8(fp)
 2030e28:	201a9b80 	call	201a9b8 <pbuf_header>
 2030e2c:	10803fcc 	andi	r2,r2,255
 2030e30:	1001011e 	bne	r2,zero,2031238 <icmp_input+0x59c>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 2030e34:	e0bffe17 	ldw	r2,-8(fp)
 2030e38:	1080020b 	ldhu	r2,8(r2)
 2030e3c:	10bfffcc 	andi	r2,r2,65535
 2030e40:	000d883a 	mov	r6,zero
 2030e44:	100b883a 	mov	r5,r2
 2030e48:	01000084 	movi	r4,2
 2030e4c:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2030e50:	e0bffb15 	stw	r2,-20(fp)
      if (r == NULL) {
 2030e54:	e0bffb17 	ldw	r2,-20(fp)
 2030e58:	1000f926 	beq	r2,zero,2031240 <icmp_input+0x5a4>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 2030e5c:	e17ffe17 	ldw	r5,-8(fp)
 2030e60:	e13ffb17 	ldw	r4,-20(fp)
 2030e64:	201af100 	call	201af10 <pbuf_copy>
 2030e68:	10803fcc 	andi	r2,r2,255
 2030e6c:	1080201c 	xori	r2,r2,128
 2030e70:	10bfe004 	addi	r2,r2,-128
 2030e74:	1000f41e 	bne	r2,zero,2031248 <icmp_input+0x5ac>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 2030e78:	e0bffb17 	ldw	r2,-20(fp)
 2030e7c:	10800117 	ldw	r2,4(r2)
 2030e80:	e0bff815 	stw	r2,-32(fp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 2030e84:	e0bffa0b 	ldhu	r2,-24(fp)
 2030e88:	0085c83a 	sub	r2,zero,r2
 2030e8c:	10bfffcc 	andi	r2,r2,65535
 2030e90:	10a0001c 	xori	r2,r2,32768
 2030e94:	10a00004 	addi	r2,r2,-32768
 2030e98:	100b883a 	mov	r5,r2
 2030e9c:	e13ffb17 	ldw	r4,-20(fp)
 2030ea0:	201a9b80 	call	201a9b8 <pbuf_header>
 2030ea4:	10803fcc 	andi	r2,r2,255
 2030ea8:	1000e91e 	bne	r2,zero,2031250 <icmp_input+0x5b4>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 2030eac:	e13ffe17 	ldw	r4,-8(fp)
 2030eb0:	201ab680 	call	201ab68 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
 2030eb4:	e0bffb17 	ldw	r2,-20(fp)
 2030eb8:	e0bffe15 	stw	r2,-8(fp)
 2030ebc:	00000506 	br	2030ed4 <icmp_input+0x238>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 2030ec0:	017ff704 	movi	r5,-36
 2030ec4:	e13ffe17 	ldw	r4,-8(fp)
 2030ec8:	201a9b80 	call	201a9b8 <pbuf_header>
 2030ecc:	10803fcc 	andi	r2,r2,255
 2030ed0:	1000e11e 	bne	r2,zero,2031258 <icmp_input+0x5bc>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 2030ed4:	e0bffe17 	ldw	r2,-8(fp)
 2030ed8:	10800117 	ldw	r2,4(r2)
 2030edc:	e0bffc15 	stw	r2,-16(fp)
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 2030ee0:	d0e81417 	ldw	r3,-24496(gp)
 2030ee4:	e0bff817 	ldw	r2,-32(fp)
 2030ee8:	19803fcc 	andi	r6,r3,255
 2030eec:	11000303 	ldbu	r4,12(r2)
 2030ef0:	2008703a 	and	r4,r4,zero
 2030ef4:	200b883a 	mov	r5,r4
 2030ef8:	3009883a 	mov	r4,r6
 2030efc:	2908b03a 	or	r4,r5,r4
 2030f00:	11000305 	stb	r4,12(r2)
 2030f04:	1808d23a 	srli	r4,r3,8
 2030f08:	21803fcc 	andi	r6,r4,255
 2030f0c:	11000343 	ldbu	r4,13(r2)
 2030f10:	2008703a 	and	r4,r4,zero
 2030f14:	200b883a 	mov	r5,r4
 2030f18:	3009883a 	mov	r4,r6
 2030f1c:	2908b03a 	or	r4,r5,r4
 2030f20:	11000345 	stb	r4,13(r2)
 2030f24:	1808d43a 	srli	r4,r3,16
 2030f28:	21803fcc 	andi	r6,r4,255
 2030f2c:	11000383 	ldbu	r4,14(r2)
 2030f30:	2008703a 	and	r4,r4,zero
 2030f34:	200b883a 	mov	r5,r4
 2030f38:	3009883a 	mov	r4,r6
 2030f3c:	2908b03a 	or	r4,r5,r4
 2030f40:	11000385 	stb	r4,14(r2)
 2030f44:	180ad63a 	srli	r5,r3,24
 2030f48:	10c003c3 	ldbu	r3,15(r2)
 2030f4c:	1806703a 	and	r3,r3,zero
 2030f50:	1809883a 	mov	r4,r3
 2030f54:	2807883a 	mov	r3,r5
 2030f58:	20c6b03a 	or	r3,r4,r3
 2030f5c:	10c003c5 	stb	r3,15(r2)
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 2030f60:	d0e81217 	ldw	r3,-24504(gp)
 2030f64:	e0bff817 	ldw	r2,-32(fp)
 2030f68:	19803fcc 	andi	r6,r3,255
 2030f6c:	11000403 	ldbu	r4,16(r2)
 2030f70:	2008703a 	and	r4,r4,zero
 2030f74:	200b883a 	mov	r5,r4
 2030f78:	3009883a 	mov	r4,r6
 2030f7c:	2908b03a 	or	r4,r5,r4
 2030f80:	11000405 	stb	r4,16(r2)
 2030f84:	1808d23a 	srli	r4,r3,8
 2030f88:	21803fcc 	andi	r6,r4,255
 2030f8c:	11000443 	ldbu	r4,17(r2)
 2030f90:	2008703a 	and	r4,r4,zero
 2030f94:	200b883a 	mov	r5,r4
 2030f98:	3009883a 	mov	r4,r6
 2030f9c:	2908b03a 	or	r4,r5,r4
 2030fa0:	11000445 	stb	r4,17(r2)
 2030fa4:	1808d43a 	srli	r4,r3,16
 2030fa8:	21803fcc 	andi	r6,r4,255
 2030fac:	11000483 	ldbu	r4,18(r2)
 2030fb0:	2008703a 	and	r4,r4,zero
 2030fb4:	200b883a 	mov	r5,r4
 2030fb8:	3009883a 	mov	r4,r6
 2030fbc:	2908b03a 	or	r4,r5,r4
 2030fc0:	11000485 	stb	r4,18(r2)
 2030fc4:	180ad63a 	srli	r5,r3,24
 2030fc8:	10c004c3 	ldbu	r3,19(r2)
 2030fcc:	1806703a 	and	r3,r3,zero
 2030fd0:	1809883a 	mov	r4,r3
 2030fd4:	2807883a 	mov	r3,r5
 2030fd8:	20c6b03a 	or	r3,r4,r3
 2030fdc:	10c004c5 	stb	r3,19(r2)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 2030fe0:	e0bffc17 	ldw	r2,-16(fp)
 2030fe4:	10000005 	stb	zero,0(r2)
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 2030fe8:	e0bffc17 	ldw	r2,-16(fp)
 2030fec:	10c00083 	ldbu	r3,2(r2)
 2030ff0:	108000c3 	ldbu	r2,3(r2)
 2030ff4:	1004923a 	slli	r2,r2,8
 2030ff8:	10c4b03a 	or	r2,r2,r3
 2030ffc:	10bfffcc 	andi	r2,r2,65535
 2031000:	10bffdf0 	cmpltui	r2,r2,65527
 2031004:	10001a1e 	bne	r2,zero,2031070 <icmp_input+0x3d4>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 2031008:	e0bffc17 	ldw	r2,-16(fp)
 203100c:	10c00083 	ldbu	r3,2(r2)
 2031010:	108000c3 	ldbu	r2,3(r2)
 2031014:	1004923a 	slli	r2,r2,8
 2031018:	10c4b03a 	or	r2,r2,r3
 203101c:	10800244 	addi	r2,r2,9
 2031020:	100d883a 	mov	r6,r2
 2031024:	e0bffc17 	ldw	r2,-16(fp)
 2031028:	30ffffcc 	andi	r3,r6,65535
 203102c:	19403fcc 	andi	r5,r3,255
 2031030:	10c00083 	ldbu	r3,2(r2)
 2031034:	1806703a 	and	r3,r3,zero
 2031038:	1809883a 	mov	r4,r3
 203103c:	2807883a 	mov	r3,r5
 2031040:	20c6b03a 	or	r3,r4,r3
 2031044:	10c00085 	stb	r3,2(r2)
 2031048:	30ffffcc 	andi	r3,r6,65535
 203104c:	1806d23a 	srli	r3,r3,8
 2031050:	197fffcc 	andi	r5,r3,65535
 2031054:	10c000c3 	ldbu	r3,3(r2)
 2031058:	1806703a 	and	r3,r3,zero
 203105c:	1809883a 	mov	r4,r3
 2031060:	2807883a 	mov	r3,r5
 2031064:	20c6b03a 	or	r3,r4,r3
 2031068:	10c000c5 	stb	r3,3(r2)
 203106c:	00001906 	br	20310d4 <icmp_input+0x438>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 2031070:	e0bffc17 	ldw	r2,-16(fp)
 2031074:	10c00083 	ldbu	r3,2(r2)
 2031078:	108000c3 	ldbu	r2,3(r2)
 203107c:	1004923a 	slli	r2,r2,8
 2031080:	10c4b03a 	or	r2,r2,r3
 2031084:	10800204 	addi	r2,r2,8
 2031088:	100d883a 	mov	r6,r2
 203108c:	e0bffc17 	ldw	r2,-16(fp)
 2031090:	30ffffcc 	andi	r3,r6,65535
 2031094:	19403fcc 	andi	r5,r3,255
 2031098:	10c00083 	ldbu	r3,2(r2)
 203109c:	1806703a 	and	r3,r3,zero
 20310a0:	1809883a 	mov	r4,r3
 20310a4:	2807883a 	mov	r3,r5
 20310a8:	20c6b03a 	or	r3,r4,r3
 20310ac:	10c00085 	stb	r3,2(r2)
 20310b0:	30ffffcc 	andi	r3,r6,65535
 20310b4:	1806d23a 	srli	r3,r3,8
 20310b8:	197fffcc 	andi	r5,r3,65535
 20310bc:	10c000c3 	ldbu	r3,3(r2)
 20310c0:	1806703a 	and	r3,r3,zero
 20310c4:	1809883a 	mov	r4,r3
 20310c8:	2807883a 	mov	r3,r5
 20310cc:	20c6b03a 	or	r3,r4,r3
 20310d0:	10c000c5 	stb	r3,3(r2)
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 20310d4:	e0bff817 	ldw	r2,-32(fp)
 20310d8:	00c01004 	movi	r3,64
 20310dc:	10c00205 	stb	r3,8(r2)
    IPH_CHKSUM_SET(iphdr, 0);
 20310e0:	e0bff817 	ldw	r2,-32(fp)
 20310e4:	10c00283 	ldbu	r3,10(r2)
 20310e8:	1806703a 	and	r3,r3,zero
 20310ec:	10c00285 	stb	r3,10(r2)
 20310f0:	10c002c3 	ldbu	r3,11(r2)
 20310f4:	1806703a 	and	r3,r3,zero
 20310f8:	10c002c5 	stb	r3,11(r2)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 20310fc:	01400504 	movi	r5,20
 2031100:	e13ff817 	ldw	r4,-32(fp)
 2031104:	2031b740 	call	2031b74 <inet_chksum>
 2031108:	100d883a 	mov	r6,r2
 203110c:	e0bff817 	ldw	r2,-32(fp)
 2031110:	30ffffcc 	andi	r3,r6,65535
 2031114:	19403fcc 	andi	r5,r3,255
 2031118:	10c00283 	ldbu	r3,10(r2)
 203111c:	1806703a 	and	r3,r3,zero
 2031120:	1809883a 	mov	r4,r3
 2031124:	2807883a 	mov	r3,r5
 2031128:	20c6b03a 	or	r3,r4,r3
 203112c:	10c00285 	stb	r3,10(r2)
 2031130:	30ffffcc 	andi	r3,r6,65535
 2031134:	1806d23a 	srli	r3,r3,8
 2031138:	197fffcc 	andi	r5,r3,65535
 203113c:	10c002c3 	ldbu	r3,11(r2)
 2031140:	1806703a 	and	r3,r3,zero
 2031144:	1809883a 	mov	r4,r3
 2031148:	2807883a 	mov	r3,r5
 203114c:	20c6b03a 	or	r3,r4,r3
 2031150:	10c002c5 	stb	r3,11(r2)
#endif /* CHECKSUM_GEN_IP */

    ICMP_STATS_INC(icmp.xmit);
 2031154:	008085f4 	movhi	r2,535
 2031158:	10a8bc04 	addi	r2,r2,-23824
 203115c:	10803017 	ldw	r2,192(r2)
 2031160:	10c00044 	addi	r3,r2,1
 2031164:	008085f4 	movhi	r2,535
 2031168:	10a8bc04 	addi	r2,r2,-23824
 203116c:	10c03015 	stw	r3,192(r2)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 2031170:	e0bffa0f 	ldh	r2,-24(fp)
 2031174:	100b883a 	mov	r5,r2
 2031178:	e13ffe17 	ldw	r4,-8(fp)
 203117c:	201a9b80 	call	201a9b8 <pbuf_header>
 2031180:	10803fcc 	andi	r2,r2,255
 2031184:	10001d1e 	bne	r2,zero,20311fc <icmp_input+0x560>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 2031188:	e0bfff17 	ldw	r2,-4(fp)
 203118c:	d8800215 	stw	r2,8(sp)
 2031190:	00800044 	movi	r2,1
 2031194:	d8800115 	stw	r2,4(sp)
 2031198:	d8000015 	stw	zero,0(sp)
 203119c:	01c01004 	movi	r7,64
 20311a0:	000d883a 	mov	r6,zero
 20311a4:	d1681404 	addi	r5,gp,-24496
 20311a8:	e13ffe17 	ldw	r4,-8(fp)
 20311ac:	20323480 	call	2032348 <ip_output_if>
 20311b0:	e0bffd05 	stb	r2,-12(fp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 20311b4:	00001106 	br	20311fc <icmp_input+0x560>
  default:
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
 20311b8:	008085f4 	movhi	r2,535
 20311bc:	10a8bc04 	addi	r2,r2,-23824
 20311c0:	10803817 	ldw	r2,224(r2)
 20311c4:	10c00044 	addi	r3,r2,1
 20311c8:	008085f4 	movhi	r2,535
 20311cc:	10a8bc04 	addi	r2,r2,-23824
 20311d0:	10c03815 	stw	r3,224(r2)
    ICMP_STATS_INC(icmp.drop);
 20311d4:	008085f4 	movhi	r2,535
 20311d8:	10a8bc04 	addi	r2,r2,-23824
 20311dc:	10803317 	ldw	r2,204(r2)
 20311e0:	10c00044 	addi	r3,r2,1
 20311e4:	008085f4 	movhi	r2,535
 20311e8:	10a8bc04 	addi	r2,r2,-23824
 20311ec:	10c03315 	stw	r3,204(r2)
 20311f0:	00000306 	br	2031200 <icmp_input+0x564>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
 20311f4:	0001883a 	nop
 20311f8:	00000106 	br	2031200 <icmp_input+0x564>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 20311fc:	0001883a 	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 2031200:	e13ffe17 	ldw	r4,-8(fp)
 2031204:	201ab680 	call	201ab68 <pbuf_free>
  return;
 2031208:	00001e06 	br	2031284 <icmp_input+0x5e8>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
 203120c:	0001883a 	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 2031210:	e13ffe17 	ldw	r4,-8(fp)
 2031214:	201ab680 	call	201ab68 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
 2031218:	008085f4 	movhi	r2,535
 203121c:	10a8bc04 	addi	r2,r2,-23824
 2031220:	10803517 	ldw	r2,212(r2)
 2031224:	10c00044 	addi	r3,r2,1
 2031228:	008085f4 	movhi	r2,535
 203122c:	10a8bc04 	addi	r2,r2,-23824
 2031230:	10c03515 	stw	r3,212(r2)
  snmp_inc_icmpinerrors();
  return;
 2031234:	00001306 	br	2031284 <icmp_input+0x5e8>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
 2031238:	0001883a 	nop
 203123c:	00000706 	br	203125c <icmp_input+0x5c0>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
 2031240:	0001883a 	nop
 2031244:	00000506 	br	203125c <icmp_input+0x5c0>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
 2031248:	0001883a 	nop
 203124c:	00000306 	br	203125c <icmp_input+0x5c0>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 2031250:	0001883a 	nop
 2031254:	00000106 	br	203125c <icmp_input+0x5c0>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 2031258:	0001883a 	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 203125c:	e13ffe17 	ldw	r4,-8(fp)
 2031260:	201ab680 	call	201ab68 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
 2031264:	008085f4 	movhi	r2,535
 2031268:	10a8bc04 	addi	r2,r2,-23824
 203126c:	10803a17 	ldw	r2,232(r2)
 2031270:	10c00044 	addi	r3,r2,1
 2031274:	008085f4 	movhi	r2,535
 2031278:	10a8bc04 	addi	r2,r2,-23824
 203127c:	10c03a15 	stw	r3,232(r2)
  snmp_inc_icmpinerrors();
  return;
 2031280:	0001883a 	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 2031284:	e037883a 	mov	sp,fp
 2031288:	dfc00117 	ldw	ra,4(sp)
 203128c:	df000017 	ldw	fp,0(sp)
 2031290:	dec00204 	addi	sp,sp,8
 2031294:	f800283a 	ret

02031298 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 2031298:	defffc04 	addi	sp,sp,-16
 203129c:	dfc00315 	stw	ra,12(sp)
 20312a0:	df000215 	stw	fp,8(sp)
 20312a4:	df000204 	addi	fp,sp,8
 20312a8:	e13ffe15 	stw	r4,-8(fp)
 20312ac:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_DUR, t);
 20312b0:	e0bfff17 	ldw	r2,-4(fp)
 20312b4:	10803fcc 	andi	r2,r2,255
 20312b8:	100d883a 	mov	r6,r2
 20312bc:	014000c4 	movi	r5,3
 20312c0:	e13ffe17 	ldw	r4,-8(fp)
 20312c4:	20313280 	call	2031328 <icmp_send_response>
}
 20312c8:	0001883a 	nop
 20312cc:	e037883a 	mov	sp,fp
 20312d0:	dfc00117 	ldw	ra,4(sp)
 20312d4:	df000017 	ldw	fp,0(sp)
 20312d8:	dec00204 	addi	sp,sp,8
 20312dc:	f800283a 	ret

020312e0 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 20312e0:	defffc04 	addi	sp,sp,-16
 20312e4:	dfc00315 	stw	ra,12(sp)
 20312e8:	df000215 	stw	fp,8(sp)
 20312ec:	df000204 	addi	fp,sp,8
 20312f0:	e13ffe15 	stw	r4,-8(fp)
 20312f4:	e17fff15 	stw	r5,-4(fp)
  icmp_send_response(p, ICMP_TE, t);
 20312f8:	e0bfff17 	ldw	r2,-4(fp)
 20312fc:	10803fcc 	andi	r2,r2,255
 2031300:	100d883a 	mov	r6,r2
 2031304:	014002c4 	movi	r5,11
 2031308:	e13ffe17 	ldw	r4,-8(fp)
 203130c:	20313280 	call	2031328 <icmp_send_response>
}
 2031310:	0001883a 	nop
 2031314:	e037883a 	mov	sp,fp
 2031318:	dfc00117 	ldw	ra,4(sp)
 203131c:	df000017 	ldw	fp,0(sp)
 2031320:	dec00204 	addi	sp,sp,8
 2031324:	f800283a 	ret

02031328 <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 2031328:	defff504 	addi	sp,sp,-44
 203132c:	dfc00a15 	stw	ra,40(sp)
 2031330:	df000915 	stw	fp,36(sp)
 2031334:	df000904 	addi	fp,sp,36
 2031338:	e13ffd15 	stw	r4,-12(fp)
 203133c:	2807883a 	mov	r3,r5
 2031340:	3005883a 	mov	r2,r6
 2031344:	e0fffe05 	stb	r3,-8(fp)
 2031348:	e0bfff05 	stb	r2,-4(fp)
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 203134c:	000d883a 	mov	r6,zero
 2031350:	01400904 	movi	r5,36
 2031354:	01000044 	movi	r4,1
 2031358:	201a3ac0 	call	201a3ac <pbuf_alloc>
 203135c:	e0bff915 	stw	r2,-28(fp)
                 PBUF_RAM);
  if (q == NULL) {
 2031360:	e0bff917 	ldw	r2,-28(fp)
 2031364:	10006226 	beq	r2,zero,20314f0 <icmp_send_response+0x1c8>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 2031368:	e0bffd17 	ldw	r2,-12(fp)
 203136c:	10800117 	ldw	r2,4(r2)
 2031370:	e0bffa15 	stw	r2,-24(fp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 2031374:	e0bff917 	ldw	r2,-28(fp)
 2031378:	10800117 	ldw	r2,4(r2)
 203137c:	e0bffb15 	stw	r2,-20(fp)
  icmphdr->type = type;
 2031380:	e0bffb17 	ldw	r2,-20(fp)
 2031384:	e0fffe03 	ldbu	r3,-8(fp)
 2031388:	10c00005 	stb	r3,0(r2)
  icmphdr->code = code;
 203138c:	e0bffb17 	ldw	r2,-20(fp)
 2031390:	e0ffff03 	ldbu	r3,-4(fp)
 2031394:	10c00045 	stb	r3,1(r2)
  icmphdr->id = 0;
 2031398:	e0bffb17 	ldw	r2,-20(fp)
 203139c:	10c00103 	ldbu	r3,4(r2)
 20313a0:	1806703a 	and	r3,r3,zero
 20313a4:	10c00105 	stb	r3,4(r2)
 20313a8:	10c00143 	ldbu	r3,5(r2)
 20313ac:	1806703a 	and	r3,r3,zero
 20313b0:	10c00145 	stb	r3,5(r2)
  icmphdr->seqno = 0;
 20313b4:	e0bffb17 	ldw	r2,-20(fp)
 20313b8:	10c00183 	ldbu	r3,6(r2)
 20313bc:	1806703a 	and	r3,r3,zero
 20313c0:	10c00185 	stb	r3,6(r2)
 20313c4:	10c001c3 	ldbu	r3,7(r2)
 20313c8:	1806703a 	and	r3,r3,zero
 20313cc:	10c001c5 	stb	r3,7(r2)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 20313d0:	e0bff917 	ldw	r2,-28(fp)
 20313d4:	10800117 	ldw	r2,4(r2)
 20313d8:	10c00204 	addi	r3,r2,8
 20313dc:	e0bffd17 	ldw	r2,-12(fp)
 20313e0:	10800117 	ldw	r2,4(r2)
 20313e4:	01800704 	movi	r6,28
 20313e8:	100b883a 	mov	r5,r2
 20313ec:	1809883a 	mov	r4,r3
 20313f0:	20060240 	call	2006024 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 20313f4:	e0bffb17 	ldw	r2,-20(fp)
 20313f8:	10c00083 	ldbu	r3,2(r2)
 20313fc:	1806703a 	and	r3,r3,zero
 2031400:	10c00085 	stb	r3,2(r2)
 2031404:	10c000c3 	ldbu	r3,3(r2)
 2031408:	1806703a 	and	r3,r3,zero
 203140c:	10c000c5 	stb	r3,3(r2)
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 2031410:	e0bff917 	ldw	r2,-28(fp)
 2031414:	1080028b 	ldhu	r2,10(r2)
 2031418:	10bfffcc 	andi	r2,r2,65535
 203141c:	100b883a 	mov	r5,r2
 2031420:	e13ffb17 	ldw	r4,-20(fp)
 2031424:	2031b740 	call	2031b74 <inet_chksum>
 2031428:	100d883a 	mov	r6,r2
 203142c:	e0bffb17 	ldw	r2,-20(fp)
 2031430:	30ffffcc 	andi	r3,r6,65535
 2031434:	19403fcc 	andi	r5,r3,255
 2031438:	10c00083 	ldbu	r3,2(r2)
 203143c:	1806703a 	and	r3,r3,zero
 2031440:	1809883a 	mov	r4,r3
 2031444:	2807883a 	mov	r3,r5
 2031448:	20c6b03a 	or	r3,r4,r3
 203144c:	10c00085 	stb	r3,2(r2)
 2031450:	30ffffcc 	andi	r3,r6,65535
 2031454:	1806d23a 	srli	r3,r3,8
 2031458:	197fffcc 	andi	r5,r3,65535
 203145c:	10c000c3 	ldbu	r3,3(r2)
 2031460:	1806703a 	and	r3,r3,zero
 2031464:	1809883a 	mov	r4,r3
 2031468:	2807883a 	mov	r3,r5
 203146c:	20c6b03a 	or	r3,r4,r3
 2031470:	10c000c5 	stb	r3,3(r2)
  ICMP_STATS_INC(icmp.xmit);
 2031474:	008085f4 	movhi	r2,535
 2031478:	10a8bc04 	addi	r2,r2,-23824
 203147c:	10803017 	ldw	r2,192(r2)
 2031480:	10c00044 	addi	r3,r2,1
 2031484:	008085f4 	movhi	r2,535
 2031488:	10a8bc04 	addi	r2,r2,-23824
 203148c:	10c03015 	stw	r3,192(r2)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 2031490:	e0bffa17 	ldw	r2,-24(fp)
 2031494:	10c00303 	ldbu	r3,12(r2)
 2031498:	11000343 	ldbu	r4,13(r2)
 203149c:	2008923a 	slli	r4,r4,8
 20314a0:	20c6b03a 	or	r3,r4,r3
 20314a4:	11000383 	ldbu	r4,14(r2)
 20314a8:	2008943a 	slli	r4,r4,16
 20314ac:	20c6b03a 	or	r3,r4,r3
 20314b0:	108003c3 	ldbu	r2,15(r2)
 20314b4:	1004963a 	slli	r2,r2,24
 20314b8:	10c4b03a 	or	r2,r2,r3
 20314bc:	e0bffc15 	stw	r2,-16(fp)
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 20314c0:	e0fffc04 	addi	r3,fp,-16
 20314c4:	00800044 	movi	r2,1
 20314c8:	d8800115 	stw	r2,4(sp)
 20314cc:	d8000015 	stw	zero,0(sp)
 20314d0:	01c01004 	movi	r7,64
 20314d4:	180d883a 	mov	r6,r3
 20314d8:	000b883a 	mov	r5,zero
 20314dc:	e13ff917 	ldw	r4,-28(fp)
 20314e0:	20329940 	call	2032994 <ip_output>
  pbuf_free(q);
 20314e4:	e13ff917 	ldw	r4,-28(fp)
 20314e8:	201ab680 	call	201ab68 <pbuf_free>
 20314ec:	00000106 	br	20314f4 <icmp_send_response+0x1cc>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
 20314f0:	0001883a 	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
 20314f4:	e037883a 	mov	sp,fp
 20314f8:	dfc00117 	ldw	ra,4(sp)
 20314fc:	df000017 	ldw	fp,0(sp)
 2031500:	dec00204 	addi	sp,sp,8
 2031504:	f800283a 	ret

02031508 <lwip_standard_chksum>:
 * by Curt McDowell, Broadcom Corp. December 8th, 2005
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 2031508:	defff604 	addi	sp,sp,-40
 203150c:	df000915 	stw	fp,36(sp)
 2031510:	df000904 	addi	fp,sp,36
 2031514:	e13ffe15 	stw	r4,-8(fp)
 2031518:	e17fff15 	stw	r5,-4(fp)
  u8_t *pb = (u8_t *)dataptr;
 203151c:	e0bffe17 	ldw	r2,-8(fp)
 2031520:	e0bff715 	stw	r2,-36(fp)
  u16_t *ps, t = 0;
 2031524:	e03ffd0d 	sth	zero,-12(fp)
  u32_t *pl;
  u32_t sum = 0, tmp;
 2031528:	e03ffa15 	stw	zero,-24(fp)
  /* starts at odd byte address? */
  int odd = ((mem_ptr_t)pb & 1);
 203152c:	e0bff717 	ldw	r2,-36(fp)
 2031530:	1080004c 	andi	r2,r2,1
 2031534:	e0bffc15 	stw	r2,-16(fp)

  if (odd && len > 0) {
 2031538:	e0bffc17 	ldw	r2,-16(fp)
 203153c:	10000c26 	beq	r2,zero,2031570 <lwip_standard_chksum+0x68>
 2031540:	e0bfff17 	ldw	r2,-4(fp)
 2031544:	00800a0e 	bge	zero,r2,2031570 <lwip_standard_chksum+0x68>
    ((u8_t *)&t)[1] = *pb++;
 2031548:	e0bffd04 	addi	r2,fp,-12
 203154c:	10800044 	addi	r2,r2,1
 2031550:	e0fff717 	ldw	r3,-36(fp)
 2031554:	19000044 	addi	r4,r3,1
 2031558:	e13ff715 	stw	r4,-36(fp)
 203155c:	18c00003 	ldbu	r3,0(r3)
 2031560:	10c00005 	stb	r3,0(r2)
    len--;
 2031564:	e0bfff17 	ldw	r2,-4(fp)
 2031568:	10bfffc4 	addi	r2,r2,-1
 203156c:	e0bfff15 	stw	r2,-4(fp)
  }

  ps = (u16_t *)pb;
 2031570:	e0bff717 	ldw	r2,-36(fp)
 2031574:	e0bff815 	stw	r2,-32(fp)

  if (((mem_ptr_t)ps & 3) && len > 1) {
 2031578:	e0bff817 	ldw	r2,-32(fp)
 203157c:	108000cc 	andi	r2,r2,3
 2031580:	10000e26 	beq	r2,zero,20315bc <lwip_standard_chksum+0xb4>
 2031584:	e0bfff17 	ldw	r2,-4(fp)
 2031588:	10800090 	cmplti	r2,r2,2
 203158c:	10000b1e 	bne	r2,zero,20315bc <lwip_standard_chksum+0xb4>
    sum += *ps++;
 2031590:	e0bff817 	ldw	r2,-32(fp)
 2031594:	10c00084 	addi	r3,r2,2
 2031598:	e0fff815 	stw	r3,-32(fp)
 203159c:	1080000b 	ldhu	r2,0(r2)
 20315a0:	10bfffcc 	andi	r2,r2,65535
 20315a4:	e0fffa17 	ldw	r3,-24(fp)
 20315a8:	1885883a 	add	r2,r3,r2
 20315ac:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 20315b0:	e0bfff17 	ldw	r2,-4(fp)
 20315b4:	10bfff84 	addi	r2,r2,-2
 20315b8:	e0bfff15 	stw	r2,-4(fp)
  }

  pl = (u32_t *)ps;
 20315bc:	e0bff817 	ldw	r2,-32(fp)
 20315c0:	e0bff915 	stw	r2,-28(fp)

  while (len > 7)  {
 20315c4:	00001d06 	br	203163c <lwip_standard_chksum+0x134>
    tmp = sum + *pl++;          /* ping */
 20315c8:	e0bff917 	ldw	r2,-28(fp)
 20315cc:	10c00104 	addi	r3,r2,4
 20315d0:	e0fff915 	stw	r3,-28(fp)
 20315d4:	10c00017 	ldw	r3,0(r2)
 20315d8:	e0bffa17 	ldw	r2,-24(fp)
 20315dc:	1885883a 	add	r2,r3,r2
 20315e0:	e0bffb15 	stw	r2,-20(fp)
    if (tmp < sum) {
 20315e4:	e0fffb17 	ldw	r3,-20(fp)
 20315e8:	e0bffa17 	ldw	r2,-24(fp)
 20315ec:	1880032e 	bgeu	r3,r2,20315fc <lwip_standard_chksum+0xf4>
      tmp++;                    /* add back carry */
 20315f0:	e0bffb17 	ldw	r2,-20(fp)
 20315f4:	10800044 	addi	r2,r2,1
 20315f8:	e0bffb15 	stw	r2,-20(fp)
    }

    sum = tmp + *pl++;          /* pong */
 20315fc:	e0bff917 	ldw	r2,-28(fp)
 2031600:	10c00104 	addi	r3,r2,4
 2031604:	e0fff915 	stw	r3,-28(fp)
 2031608:	10c00017 	ldw	r3,0(r2)
 203160c:	e0bffb17 	ldw	r2,-20(fp)
 2031610:	1885883a 	add	r2,r3,r2
 2031614:	e0bffa15 	stw	r2,-24(fp)
    if (sum < tmp) {
 2031618:	e0fffa17 	ldw	r3,-24(fp)
 203161c:	e0bffb17 	ldw	r2,-20(fp)
 2031620:	1880032e 	bgeu	r3,r2,2031630 <lwip_standard_chksum+0x128>
      sum++;                    /* add back carry */
 2031624:	e0bffa17 	ldw	r2,-24(fp)
 2031628:	10800044 	addi	r2,r2,1
 203162c:	e0bffa15 	stw	r2,-24(fp)
    }

    len -= 8;
 2031630:	e0bfff17 	ldw	r2,-4(fp)
 2031634:	10bffe04 	addi	r2,r2,-8
 2031638:	e0bfff15 	stw	r2,-4(fp)
    len -= 2;
  }

  pl = (u32_t *)ps;

  while (len > 7)  {
 203163c:	e0bfff17 	ldw	r2,-4(fp)
 2031640:	10800208 	cmpgei	r2,r2,8
 2031644:	103fe01e 	bne	r2,zero,20315c8 <__alt_mem_mem_0+0xfd0115c8>

    len -= 8;
  }

  /* make room in upper bits */
  sum = FOLD_U32T(sum);
 2031648:	e0bffa17 	ldw	r2,-24(fp)
 203164c:	1006d43a 	srli	r3,r2,16
 2031650:	e0bffa17 	ldw	r2,-24(fp)
 2031654:	10bfffcc 	andi	r2,r2,65535
 2031658:	1885883a 	add	r2,r3,r2
 203165c:	e0bffa15 	stw	r2,-24(fp)

  ps = (u16_t *)pl;
 2031660:	e0bff917 	ldw	r2,-28(fp)
 2031664:	e0bff815 	stw	r2,-32(fp)

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 2031668:	00000b06 	br	2031698 <lwip_standard_chksum+0x190>
    sum += *ps++;
 203166c:	e0bff817 	ldw	r2,-32(fp)
 2031670:	10c00084 	addi	r3,r2,2
 2031674:	e0fff815 	stw	r3,-32(fp)
 2031678:	1080000b 	ldhu	r2,0(r2)
 203167c:	10bfffcc 	andi	r2,r2,65535
 2031680:	e0fffa17 	ldw	r3,-24(fp)
 2031684:	1885883a 	add	r2,r3,r2
 2031688:	e0bffa15 	stw	r2,-24(fp)
    len -= 2;
 203168c:	e0bfff17 	ldw	r2,-4(fp)
 2031690:	10bfff84 	addi	r2,r2,-2
 2031694:	e0bfff15 	stw	r2,-4(fp)
  sum = FOLD_U32T(sum);

  ps = (u16_t *)pl;

  /* 16-bit aligned word remaining? */
  while (len > 1) {
 2031698:	e0bfff17 	ldw	r2,-4(fp)
 203169c:	10800088 	cmpgei	r2,r2,2
 20316a0:	103ff21e 	bne	r2,zero,203166c <__alt_mem_mem_0+0xfd01166c>
    sum += *ps++;
    len -= 2;
  }

  /* dangling tail byte remaining? */
  if (len > 0) {                /* include odd byte */
 20316a4:	e0bfff17 	ldw	r2,-4(fp)
 20316a8:	0080040e 	bge	zero,r2,20316bc <lwip_standard_chksum+0x1b4>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 20316ac:	e0bffd04 	addi	r2,fp,-12
 20316b0:	e0fff817 	ldw	r3,-32(fp)
 20316b4:	18c00003 	ldbu	r3,0(r3)
 20316b8:	10c00005 	stb	r3,0(r2)
  }

  sum += t;                     /* add end bytes */
 20316bc:	e0bffd0b 	ldhu	r2,-12(fp)
 20316c0:	10bfffcc 	andi	r2,r2,65535
 20316c4:	e0fffa17 	ldw	r3,-24(fp)
 20316c8:	1885883a 	add	r2,r3,r2
 20316cc:	e0bffa15 	stw	r2,-24(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 20316d0:	e0bffa17 	ldw	r2,-24(fp)
 20316d4:	1006d43a 	srli	r3,r2,16
 20316d8:	e0bffa17 	ldw	r2,-24(fp)
 20316dc:	10bfffcc 	andi	r2,r2,65535
 20316e0:	1885883a 	add	r2,r3,r2
 20316e4:	e0bffa15 	stw	r2,-24(fp)
  sum = FOLD_U32T(sum);
 20316e8:	e0bffa17 	ldw	r2,-24(fp)
 20316ec:	1006d43a 	srli	r3,r2,16
 20316f0:	e0bffa17 	ldw	r2,-24(fp)
 20316f4:	10bfffcc 	andi	r2,r2,65535
 20316f8:	1885883a 	add	r2,r3,r2
 20316fc:	e0bffa15 	stw	r2,-24(fp)

  if (odd) {
 2031700:	e0bffc17 	ldw	r2,-16(fp)
 2031704:	10000826 	beq	r2,zero,2031728 <lwip_standard_chksum+0x220>
    sum = SWAP_BYTES_IN_WORD(sum);
 2031708:	e0bffa17 	ldw	r2,-24(fp)
 203170c:	10bfc00c 	andi	r2,r2,65280
 2031710:	1006d23a 	srli	r3,r2,8
 2031714:	e0bffa17 	ldw	r2,-24(fp)
 2031718:	1004923a 	slli	r2,r2,8
 203171c:	10bfffcc 	andi	r2,r2,65535
 2031720:	1884b03a 	or	r2,r3,r2
 2031724:	e0bffa15 	stw	r2,-24(fp)
  }

  return (u16_t)sum;
 2031728:	e0bffa17 	ldw	r2,-24(fp)
}
 203172c:	e037883a 	mov	sp,fp
 2031730:	df000017 	ldw	fp,0(sp)
 2031734:	dec00104 	addi	sp,sp,4
 2031738:	f800283a 	ret

0203173c <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 203173c:	defff504 	addi	sp,sp,-44
 2031740:	dfc00a15 	stw	ra,40(sp)
 2031744:	df000915 	stw	fp,36(sp)
 2031748:	df000904 	addi	fp,sp,36
 203174c:	e13ffb15 	stw	r4,-20(fp)
 2031750:	e17ffc15 	stw	r5,-16(fp)
 2031754:	e1bffd15 	stw	r6,-12(fp)
 2031758:	3807883a 	mov	r3,r7
 203175c:	e0800217 	ldw	r2,8(fp)
 2031760:	e0fffe05 	stb	r3,-8(fp)
 2031764:	e0bfff0d 	sth	r2,-4(fp)
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 2031768:	e03ff715 	stw	zero,-36(fp)
  swapped = 0;
 203176c:	e03ff905 	stb	zero,-28(fp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 2031770:	e0bffb17 	ldw	r2,-20(fp)
 2031774:	e0bff815 	stw	r2,-32(fp)
 2031778:	00002606 	br	2031814 <inet_chksum_pseudo+0xd8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 203177c:	e0bff817 	ldw	r2,-32(fp)
 2031780:	10c00117 	ldw	r3,4(r2)
 2031784:	e0bff817 	ldw	r2,-32(fp)
 2031788:	1080028b 	ldhu	r2,10(r2)
 203178c:	10bfffcc 	andi	r2,r2,65535
 2031790:	100b883a 	mov	r5,r2
 2031794:	1809883a 	mov	r4,r3
 2031798:	20315080 	call	2031508 <lwip_standard_chksum>
 203179c:	10bfffcc 	andi	r2,r2,65535
 20317a0:	e0fff717 	ldw	r3,-36(fp)
 20317a4:	1885883a 	add	r2,r3,r2
 20317a8:	e0bff715 	stw	r2,-36(fp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 20317ac:	e0bff717 	ldw	r2,-36(fp)
 20317b0:	1006d43a 	srli	r3,r2,16
 20317b4:	e0bff717 	ldw	r2,-36(fp)
 20317b8:	10bfffcc 	andi	r2,r2,65535
 20317bc:	1885883a 	add	r2,r3,r2
 20317c0:	e0bff715 	stw	r2,-36(fp)
    if (q->len % 2 != 0) {
 20317c4:	e0bff817 	ldw	r2,-32(fp)
 20317c8:	1080028b 	ldhu	r2,10(r2)
 20317cc:	1080004c 	andi	r2,r2,1
 20317d0:	10bfffcc 	andi	r2,r2,65535
 20317d4:	10000c26 	beq	r2,zero,2031808 <inet_chksum_pseudo+0xcc>
      swapped = 1 - swapped;
 20317d8:	e0bff903 	ldbu	r2,-28(fp)
 20317dc:	00c00044 	movi	r3,1
 20317e0:	1885c83a 	sub	r2,r3,r2
 20317e4:	e0bff905 	stb	r2,-28(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 20317e8:	e0bff717 	ldw	r2,-36(fp)
 20317ec:	10bfc00c 	andi	r2,r2,65280
 20317f0:	1006d23a 	srli	r3,r2,8
 20317f4:	e0bff717 	ldw	r2,-36(fp)
 20317f8:	1004923a 	slli	r2,r2,8
 20317fc:	10bfffcc 	andi	r2,r2,65535
 2031800:	1884b03a 	or	r2,r3,r2
 2031804:	e0bff715 	stw	r2,-36(fp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 2031808:	e0bff817 	ldw	r2,-32(fp)
 203180c:	10800017 	ldw	r2,0(r2)
 2031810:	e0bff815 	stw	r2,-32(fp)
 2031814:	e0bff817 	ldw	r2,-32(fp)
 2031818:	103fd81e 	bne	r2,zero,203177c <__alt_mem_mem_0+0xfd01177c>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 203181c:	e0bff903 	ldbu	r2,-28(fp)
 2031820:	10000826 	beq	r2,zero,2031844 <inet_chksum_pseudo+0x108>
    acc = SWAP_BYTES_IN_WORD(acc);
 2031824:	e0bff717 	ldw	r2,-36(fp)
 2031828:	10bfc00c 	andi	r2,r2,65280
 203182c:	1006d23a 	srli	r3,r2,8
 2031830:	e0bff717 	ldw	r2,-36(fp)
 2031834:	1004923a 	slli	r2,r2,8
 2031838:	10bfffcc 	andi	r2,r2,65535
 203183c:	1884b03a 	or	r2,r3,r2
 2031840:	e0bff715 	stw	r2,-36(fp)
  }
  addr = ip4_addr_get_u32(src);
 2031844:	e0bffc17 	ldw	r2,-16(fp)
 2031848:	10800017 	ldw	r2,0(r2)
 203184c:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
 2031850:	e0bffa17 	ldw	r2,-24(fp)
 2031854:	10bfffcc 	andi	r2,r2,65535
 2031858:	e0fff717 	ldw	r3,-36(fp)
 203185c:	1885883a 	add	r2,r3,r2
 2031860:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
 2031864:	e0bffa17 	ldw	r2,-24(fp)
 2031868:	1004d43a 	srli	r2,r2,16
 203186c:	e0fff717 	ldw	r3,-36(fp)
 2031870:	1885883a 	add	r2,r3,r2
 2031874:	e0bff715 	stw	r2,-36(fp)
  addr = ip4_addr_get_u32(dest);
 2031878:	e0bffd17 	ldw	r2,-12(fp)
 203187c:	10800017 	ldw	r2,0(r2)
 2031880:	e0bffa15 	stw	r2,-24(fp)
  acc += (addr & 0xffffUL);
 2031884:	e0bffa17 	ldw	r2,-24(fp)
 2031888:	10bfffcc 	andi	r2,r2,65535
 203188c:	e0fff717 	ldw	r3,-36(fp)
 2031890:	1885883a 	add	r2,r3,r2
 2031894:	e0bff715 	stw	r2,-36(fp)
  acc += ((addr >> 16) & 0xffffUL);
 2031898:	e0bffa17 	ldw	r2,-24(fp)
 203189c:	1004d43a 	srli	r2,r2,16
 20318a0:	e0fff717 	ldw	r3,-36(fp)
 20318a4:	1885883a 	add	r2,r3,r2
 20318a8:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons((u16_t)proto);
 20318ac:	e0bffe03 	ldbu	r2,-8(fp)
 20318b0:	1004923a 	slli	r2,r2,8
 20318b4:	1007883a 	mov	r3,r2
 20318b8:	e0bff717 	ldw	r2,-36(fp)
 20318bc:	10c5883a 	add	r2,r2,r3
 20318c0:	e0bff715 	stw	r2,-36(fp)
  acc += (u32_t)htons(proto_len);
 20318c4:	e0bfff0b 	ldhu	r2,-4(fp)
 20318c8:	1004d23a 	srli	r2,r2,8
 20318cc:	10ffffcc 	andi	r3,r2,65535
 20318d0:	e0bfff0b 	ldhu	r2,-4(fp)
 20318d4:	1004923a 	slli	r2,r2,8
 20318d8:	10bfffcc 	andi	r2,r2,65535
 20318dc:	1884b03a 	or	r2,r3,r2
 20318e0:	1007883a 	mov	r3,r2
 20318e4:	e0bff717 	ldw	r2,-36(fp)
 20318e8:	10c5883a 	add	r2,r2,r3
 20318ec:	e0bff715 	stw	r2,-36(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 20318f0:	e0bff717 	ldw	r2,-36(fp)
 20318f4:	1006d43a 	srli	r3,r2,16
 20318f8:	e0bff717 	ldw	r2,-36(fp)
 20318fc:	10bfffcc 	andi	r2,r2,65535
 2031900:	1885883a 	add	r2,r3,r2
 2031904:	e0bff715 	stw	r2,-36(fp)
  acc = FOLD_U32T(acc);
 2031908:	e0bff717 	ldw	r2,-36(fp)
 203190c:	1006d43a 	srli	r3,r2,16
 2031910:	e0bff717 	ldw	r2,-36(fp)
 2031914:	10bfffcc 	andi	r2,r2,65535
 2031918:	1885883a 	add	r2,r3,r2
 203191c:	e0bff715 	stw	r2,-36(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 2031920:	e0bff717 	ldw	r2,-36(fp)
 2031924:	0084303a 	nor	r2,zero,r2
}
 2031928:	e037883a 	mov	sp,fp
 203192c:	dfc00117 	ldw	ra,4(sp)
 2031930:	df000017 	ldw	fp,0(sp)
 2031934:	dec00204 	addi	sp,sp,8
 2031938:	f800283a 	ret

0203193c <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
 203193c:	defff404 	addi	sp,sp,-48
 2031940:	dfc00b15 	stw	ra,44(sp)
 2031944:	df000a15 	stw	fp,40(sp)
 2031948:	df000a04 	addi	fp,sp,40
 203194c:	e13ffa15 	stw	r4,-24(fp)
 2031950:	e17ffb15 	stw	r5,-20(fp)
 2031954:	e1bffc15 	stw	r6,-16(fp)
 2031958:	3809883a 	mov	r4,r7
 203195c:	e0c00217 	ldw	r3,8(fp)
 2031960:	e0800317 	ldw	r2,12(fp)
 2031964:	e13ffd05 	stb	r4,-12(fp)
 2031968:	e0fffe0d 	sth	r3,-8(fp)
 203196c:	e0bfff0d 	sth	r2,-4(fp)
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
 2031970:	e03ff615 	stw	zero,-40(fp)
  swapped = 0;
 2031974:	e03ff805 	stb	zero,-32(fp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 2031978:	e0bffa17 	ldw	r2,-24(fp)
 203197c:	e0bff715 	stw	r2,-36(fp)
 2031980:	00003006 	br	2031a44 <inet_chksum_pseudo_partial+0x108>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
 2031984:	e0bff717 	ldw	r2,-36(fp)
 2031988:	1080028b 	ldhu	r2,10(r2)
 203198c:	e0bff88d 	sth	r2,-30(fp)
    if (chklen > chksum_len) {
 2031990:	e0bff88b 	ldhu	r2,-30(fp)
 2031994:	e0ffff0b 	ldhu	r3,-4(fp)
 2031998:	1880022e 	bgeu	r3,r2,20319a4 <inet_chksum_pseudo_partial+0x68>
      chklen = chksum_len;
 203199c:	e0bfff0b 	ldhu	r2,-4(fp)
 20319a0:	e0bff88d 	sth	r2,-30(fp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 20319a4:	e0bff717 	ldw	r2,-36(fp)
 20319a8:	10800117 	ldw	r2,4(r2)
 20319ac:	e0fff88b 	ldhu	r3,-30(fp)
 20319b0:	180b883a 	mov	r5,r3
 20319b4:	1009883a 	mov	r4,r2
 20319b8:	20315080 	call	2031508 <lwip_standard_chksum>
 20319bc:	10bfffcc 	andi	r2,r2,65535
 20319c0:	e0fff617 	ldw	r3,-40(fp)
 20319c4:	1885883a 	add	r2,r3,r2
 20319c8:	e0bff615 	stw	r2,-40(fp)
    chksum_len -= chklen;
 20319cc:	e0ffff0b 	ldhu	r3,-4(fp)
 20319d0:	e0bff88b 	ldhu	r2,-30(fp)
 20319d4:	1885c83a 	sub	r2,r3,r2
 20319d8:	e0bfff0d 	sth	r2,-4(fp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 20319dc:	e0bff617 	ldw	r2,-40(fp)
 20319e0:	1006d43a 	srli	r3,r2,16
 20319e4:	e0bff617 	ldw	r2,-40(fp)
 20319e8:	10bfffcc 	andi	r2,r2,65535
 20319ec:	1885883a 	add	r2,r3,r2
 20319f0:	e0bff615 	stw	r2,-40(fp)
    if (q->len % 2 != 0) {
 20319f4:	e0bff717 	ldw	r2,-36(fp)
 20319f8:	1080028b 	ldhu	r2,10(r2)
 20319fc:	1080004c 	andi	r2,r2,1
 2031a00:	10bfffcc 	andi	r2,r2,65535
 2031a04:	10000c26 	beq	r2,zero,2031a38 <inet_chksum_pseudo_partial+0xfc>
      swapped = 1 - swapped;
 2031a08:	e0bff803 	ldbu	r2,-32(fp)
 2031a0c:	00c00044 	movi	r3,1
 2031a10:	1885c83a 	sub	r2,r3,r2
 2031a14:	e0bff805 	stb	r2,-32(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 2031a18:	e0bff617 	ldw	r2,-40(fp)
 2031a1c:	10bfc00c 	andi	r2,r2,65280
 2031a20:	1006d23a 	srli	r3,r2,8
 2031a24:	e0bff617 	ldw	r2,-40(fp)
 2031a28:	1004923a 	slli	r2,r2,8
 2031a2c:	10bfffcc 	andi	r2,r2,65535
 2031a30:	1884b03a 	or	r2,r3,r2
 2031a34:	e0bff615 	stw	r2,-40(fp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 2031a38:	e0bff717 	ldw	r2,-36(fp)
 2031a3c:	10800017 	ldw	r2,0(r2)
 2031a40:	e0bff715 	stw	r2,-36(fp)
 2031a44:	e0bff717 	ldw	r2,-36(fp)
 2031a48:	10000226 	beq	r2,zero,2031a54 <inet_chksum_pseudo_partial+0x118>
 2031a4c:	e0bfff0b 	ldhu	r2,-4(fp)
 2031a50:	103fcc1e 	bne	r2,zero,2031984 <__alt_mem_mem_0+0xfd011984>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 2031a54:	e0bff803 	ldbu	r2,-32(fp)
 2031a58:	10000826 	beq	r2,zero,2031a7c <inet_chksum_pseudo_partial+0x140>
    acc = SWAP_BYTES_IN_WORD(acc);
 2031a5c:	e0bff617 	ldw	r2,-40(fp)
 2031a60:	10bfc00c 	andi	r2,r2,65280
 2031a64:	1006d23a 	srli	r3,r2,8
 2031a68:	e0bff617 	ldw	r2,-40(fp)
 2031a6c:	1004923a 	slli	r2,r2,8
 2031a70:	10bfffcc 	andi	r2,r2,65535
 2031a74:	1884b03a 	or	r2,r3,r2
 2031a78:	e0bff615 	stw	r2,-40(fp)
  }
  addr = ip4_addr_get_u32(src);
 2031a7c:	e0bffb17 	ldw	r2,-20(fp)
 2031a80:	10800017 	ldw	r2,0(r2)
 2031a84:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
 2031a88:	e0bff917 	ldw	r2,-28(fp)
 2031a8c:	10bfffcc 	andi	r2,r2,65535
 2031a90:	e0fff617 	ldw	r3,-40(fp)
 2031a94:	1885883a 	add	r2,r3,r2
 2031a98:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
 2031a9c:	e0bff917 	ldw	r2,-28(fp)
 2031aa0:	1004d43a 	srli	r2,r2,16
 2031aa4:	e0fff617 	ldw	r3,-40(fp)
 2031aa8:	1885883a 	add	r2,r3,r2
 2031aac:	e0bff615 	stw	r2,-40(fp)
  addr = ip4_addr_get_u32(dest);
 2031ab0:	e0bffc17 	ldw	r2,-16(fp)
 2031ab4:	10800017 	ldw	r2,0(r2)
 2031ab8:	e0bff915 	stw	r2,-28(fp)
  acc += (addr & 0xffffUL);
 2031abc:	e0bff917 	ldw	r2,-28(fp)
 2031ac0:	10bfffcc 	andi	r2,r2,65535
 2031ac4:	e0fff617 	ldw	r3,-40(fp)
 2031ac8:	1885883a 	add	r2,r3,r2
 2031acc:	e0bff615 	stw	r2,-40(fp)
  acc += ((addr >> 16) & 0xffffUL);
 2031ad0:	e0bff917 	ldw	r2,-28(fp)
 2031ad4:	1004d43a 	srli	r2,r2,16
 2031ad8:	e0fff617 	ldw	r3,-40(fp)
 2031adc:	1885883a 	add	r2,r3,r2
 2031ae0:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons((u16_t)proto);
 2031ae4:	e0bffd03 	ldbu	r2,-12(fp)
 2031ae8:	1004923a 	slli	r2,r2,8
 2031aec:	1007883a 	mov	r3,r2
 2031af0:	e0bff617 	ldw	r2,-40(fp)
 2031af4:	10c5883a 	add	r2,r2,r3
 2031af8:	e0bff615 	stw	r2,-40(fp)
  acc += (u32_t)htons(proto_len);
 2031afc:	e0bffe0b 	ldhu	r2,-8(fp)
 2031b00:	1004d23a 	srli	r2,r2,8
 2031b04:	10ffffcc 	andi	r3,r2,65535
 2031b08:	e0bffe0b 	ldhu	r2,-8(fp)
 2031b0c:	1004923a 	slli	r2,r2,8
 2031b10:	10bfffcc 	andi	r2,r2,65535
 2031b14:	1884b03a 	or	r2,r3,r2
 2031b18:	1007883a 	mov	r3,r2
 2031b1c:	e0bff617 	ldw	r2,-40(fp)
 2031b20:	10c5883a 	add	r2,r2,r3
 2031b24:	e0bff615 	stw	r2,-40(fp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 2031b28:	e0bff617 	ldw	r2,-40(fp)
 2031b2c:	1006d43a 	srli	r3,r2,16
 2031b30:	e0bff617 	ldw	r2,-40(fp)
 2031b34:	10bfffcc 	andi	r2,r2,65535
 2031b38:	1885883a 	add	r2,r3,r2
 2031b3c:	e0bff615 	stw	r2,-40(fp)
  acc = FOLD_U32T(acc);
 2031b40:	e0bff617 	ldw	r2,-40(fp)
 2031b44:	1006d43a 	srli	r3,r2,16
 2031b48:	e0bff617 	ldw	r2,-40(fp)
 2031b4c:	10bfffcc 	andi	r2,r2,65535
 2031b50:	1885883a 	add	r2,r3,r2
 2031b54:	e0bff615 	stw	r2,-40(fp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 2031b58:	e0bff617 	ldw	r2,-40(fp)
 2031b5c:	0084303a 	nor	r2,zero,r2
}
 2031b60:	e037883a 	mov	sp,fp
 2031b64:	dfc00117 	ldw	ra,4(sp)
 2031b68:	df000017 	ldw	fp,0(sp)
 2031b6c:	dec00204 	addi	sp,sp,8
 2031b70:	f800283a 	ret

02031b74 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 2031b74:	defffc04 	addi	sp,sp,-16
 2031b78:	dfc00315 	stw	ra,12(sp)
 2031b7c:	df000215 	stw	fp,8(sp)
 2031b80:	df000204 	addi	fp,sp,8
 2031b84:	e13ffe15 	stw	r4,-8(fp)
 2031b88:	2805883a 	mov	r2,r5
 2031b8c:	e0bfff0d 	sth	r2,-4(fp)
  return ~LWIP_CHKSUM(dataptr, len);
 2031b90:	e0bfff0b 	ldhu	r2,-4(fp)
 2031b94:	100b883a 	mov	r5,r2
 2031b98:	e13ffe17 	ldw	r4,-8(fp)
 2031b9c:	20315080 	call	2031508 <lwip_standard_chksum>
 2031ba0:	0084303a 	nor	r2,zero,r2
}
 2031ba4:	e037883a 	mov	sp,fp
 2031ba8:	dfc00117 	ldw	ra,4(sp)
 2031bac:	df000017 	ldw	fp,0(sp)
 2031bb0:	dec00204 	addi	sp,sp,8
 2031bb4:	f800283a 	ret

02031bb8 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 2031bb8:	defffa04 	addi	sp,sp,-24
 2031bbc:	dfc00515 	stw	ra,20(sp)
 2031bc0:	df000415 	stw	fp,16(sp)
 2031bc4:	df000404 	addi	fp,sp,16
 2031bc8:	e13fff15 	stw	r4,-4(fp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 2031bcc:	e03ffc15 	stw	zero,-16(fp)
  swapped = 0;
 2031bd0:	e03ffe05 	stb	zero,-8(fp)
  for(q = p; q != NULL; q = q->next) {
 2031bd4:	e0bfff17 	ldw	r2,-4(fp)
 2031bd8:	e0bffd15 	stw	r2,-12(fp)
 2031bdc:	00002606 	br	2031c78 <inet_chksum_pbuf+0xc0>
    acc += LWIP_CHKSUM(q->payload, q->len);
 2031be0:	e0bffd17 	ldw	r2,-12(fp)
 2031be4:	10c00117 	ldw	r3,4(r2)
 2031be8:	e0bffd17 	ldw	r2,-12(fp)
 2031bec:	1080028b 	ldhu	r2,10(r2)
 2031bf0:	10bfffcc 	andi	r2,r2,65535
 2031bf4:	100b883a 	mov	r5,r2
 2031bf8:	1809883a 	mov	r4,r3
 2031bfc:	20315080 	call	2031508 <lwip_standard_chksum>
 2031c00:	10bfffcc 	andi	r2,r2,65535
 2031c04:	e0fffc17 	ldw	r3,-16(fp)
 2031c08:	1885883a 	add	r2,r3,r2
 2031c0c:	e0bffc15 	stw	r2,-16(fp)
    acc = FOLD_U32T(acc);
 2031c10:	e0bffc17 	ldw	r2,-16(fp)
 2031c14:	1006d43a 	srli	r3,r2,16
 2031c18:	e0bffc17 	ldw	r2,-16(fp)
 2031c1c:	10bfffcc 	andi	r2,r2,65535
 2031c20:	1885883a 	add	r2,r3,r2
 2031c24:	e0bffc15 	stw	r2,-16(fp)
    if (q->len % 2 != 0) {
 2031c28:	e0bffd17 	ldw	r2,-12(fp)
 2031c2c:	1080028b 	ldhu	r2,10(r2)
 2031c30:	1080004c 	andi	r2,r2,1
 2031c34:	10bfffcc 	andi	r2,r2,65535
 2031c38:	10000c26 	beq	r2,zero,2031c6c <inet_chksum_pbuf+0xb4>
      swapped = 1 - swapped;
 2031c3c:	e0bffe03 	ldbu	r2,-8(fp)
 2031c40:	00c00044 	movi	r3,1
 2031c44:	1885c83a 	sub	r2,r3,r2
 2031c48:	e0bffe05 	stb	r2,-8(fp)
      acc = SWAP_BYTES_IN_WORD(acc);
 2031c4c:	e0bffc17 	ldw	r2,-16(fp)
 2031c50:	10bfc00c 	andi	r2,r2,65280
 2031c54:	1006d23a 	srli	r3,r2,8
 2031c58:	e0bffc17 	ldw	r2,-16(fp)
 2031c5c:	1004923a 	slli	r2,r2,8
 2031c60:	10bfffcc 	andi	r2,r2,65535
 2031c64:	1884b03a 	or	r2,r3,r2
 2031c68:	e0bffc15 	stw	r2,-16(fp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 2031c6c:	e0bffd17 	ldw	r2,-12(fp)
 2031c70:	10800017 	ldw	r2,0(r2)
 2031c74:	e0bffd15 	stw	r2,-12(fp)
 2031c78:	e0bffd17 	ldw	r2,-12(fp)
 2031c7c:	103fd81e 	bne	r2,zero,2031be0 <__alt_mem_mem_0+0xfd011be0>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 2031c80:	e0bffe03 	ldbu	r2,-8(fp)
 2031c84:	10000826 	beq	r2,zero,2031ca8 <inet_chksum_pbuf+0xf0>
    acc = SWAP_BYTES_IN_WORD(acc);
 2031c88:	e0bffc17 	ldw	r2,-16(fp)
 2031c8c:	10bfc00c 	andi	r2,r2,65280
 2031c90:	1006d23a 	srli	r3,r2,8
 2031c94:	e0bffc17 	ldw	r2,-16(fp)
 2031c98:	1004923a 	slli	r2,r2,8
 2031c9c:	10bfffcc 	andi	r2,r2,65535
 2031ca0:	1884b03a 	or	r2,r3,r2
 2031ca4:	e0bffc15 	stw	r2,-16(fp)
  }
  return (u16_t)~(acc & 0xffffUL);
 2031ca8:	e0bffc17 	ldw	r2,-16(fp)
 2031cac:	0084303a 	nor	r2,zero,r2
}
 2031cb0:	e037883a 	mov	sp,fp
 2031cb4:	dfc00117 	ldw	ra,4(sp)
 2031cb8:	df000017 	ldw	fp,0(sp)
 2031cbc:	dec00204 	addi	sp,sp,8
 2031cc0:	f800283a 	ret

02031cc4 <lwip_chksum_copy>:
 * For architectures with big caches, data might still be in cache when
 * generating the checksum after copying.
 */
u16_t
lwip_chksum_copy(void *dst, const void *src, u16_t len)
{
 2031cc4:	defffb04 	addi	sp,sp,-20
 2031cc8:	dfc00415 	stw	ra,16(sp)
 2031ccc:	df000315 	stw	fp,12(sp)
 2031cd0:	df000304 	addi	fp,sp,12
 2031cd4:	e13ffd15 	stw	r4,-12(fp)
 2031cd8:	e17ffe15 	stw	r5,-8(fp)
 2031cdc:	3005883a 	mov	r2,r6
 2031ce0:	e0bfff0d 	sth	r2,-4(fp)
  MEMCPY(dst, src, len);
 2031ce4:	e0bfff0b 	ldhu	r2,-4(fp)
 2031ce8:	100d883a 	mov	r6,r2
 2031cec:	e17ffe17 	ldw	r5,-8(fp)
 2031cf0:	e13ffd17 	ldw	r4,-12(fp)
 2031cf4:	20060240 	call	2006024 <memcpy>
  return LWIP_CHKSUM(dst, len);
 2031cf8:	e0bfff0b 	ldhu	r2,-4(fp)
 2031cfc:	100b883a 	mov	r5,r2
 2031d00:	e13ffd17 	ldw	r4,-12(fp)
 2031d04:	20315080 	call	2031508 <lwip_standard_chksum>
}
 2031d08:	e037883a 	mov	sp,fp
 2031d0c:	dfc00117 	ldw	ra,4(sp)
 2031d10:	df000017 	ldw	fp,0(sp)
 2031d14:	dec00204 	addi	sp,sp,8
 2031d18:	f800283a 	ret

02031d1c <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *src, ip_addr_t *dest)
{
 2031d1c:	defffc04 	addi	sp,sp,-16
 2031d20:	df000315 	stw	fp,12(sp)
 2031d24:	df000304 	addi	fp,sp,12
 2031d28:	e13ffe15 	stw	r4,-8(fp)
 2031d2c:	e17fff15 	stw	r5,-4(fp)
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 2031d30:	d0a7f317 	ldw	r2,-24628(gp)
 2031d34:	e0bffd15 	stw	r2,-12(fp)
 2031d38:	00001d06 	br	2031db0 <ip_route+0x94>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 2031d3c:	e0bffd17 	ldw	r2,-12(fp)
 2031d40:	10800e43 	ldbu	r2,57(r2)
 2031d44:	10803fcc 	andi	r2,r2,255
 2031d48:	1080004c 	andi	r2,r2,1
 2031d4c:	10001526 	beq	r2,zero,2031da4 <ip_route+0x88>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 2031d50:	e0bfff17 	ldw	r2,-4(fp)
 2031d54:	10c00017 	ldw	r3,0(r2)
 2031d58:	e0bffd17 	ldw	r2,-12(fp)
 2031d5c:	10800117 	ldw	r2,4(r2)
 2031d60:	1886f03a 	xor	r3,r3,r2
 2031d64:	e0bffd17 	ldw	r2,-12(fp)
 2031d68:	10800217 	ldw	r2,8(r2)
 2031d6c:	1884703a 	and	r2,r3,r2
 2031d70:	10000c1e 	bne	r2,zero,2031da4 <ip_route+0x88>
        if (!src || !src->addr || ip_addr_cmp(src, &(netif->ip_addr))) {
 2031d74:	e0bffe17 	ldw	r2,-8(fp)
 2031d78:	10000826 	beq	r2,zero,2031d9c <ip_route+0x80>
 2031d7c:	e0bffe17 	ldw	r2,-8(fp)
 2031d80:	10800017 	ldw	r2,0(r2)
 2031d84:	10000526 	beq	r2,zero,2031d9c <ip_route+0x80>
 2031d88:	e0bffe17 	ldw	r2,-8(fp)
 2031d8c:	10c00017 	ldw	r3,0(r2)
 2031d90:	e0bffd17 	ldw	r2,-12(fp)
 2031d94:	10800117 	ldw	r2,4(r2)
 2031d98:	1880021e 	bne	r3,r2,2031da4 <ip_route+0x88>
        /* return netif on which to forward IP packet */
        return netif;
 2031d9c:	e0bffd17 	ldw	r2,-12(fp)
 2031da0:	00001606 	br	2031dfc <ip_route+0xe0>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 2031da4:	e0bffd17 	ldw	r2,-12(fp)
 2031da8:	10800017 	ldw	r2,0(r2)
 2031dac:	e0bffd15 	stw	r2,-12(fp)
 2031db0:	e0bffd17 	ldw	r2,-12(fp)
 2031db4:	103fe11e 	bne	r2,zero,2031d3c <__alt_mem_mem_0+0xfd011d3c>
        return netif;
      }
    }
  }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 2031db8:	d0a7f417 	ldw	r2,-24624(gp)
 2031dbc:	10000526 	beq	r2,zero,2031dd4 <ip_route+0xb8>
 2031dc0:	d0a7f417 	ldw	r2,-24624(gp)
 2031dc4:	10800e43 	ldbu	r2,57(r2)
 2031dc8:	10803fcc 	andi	r2,r2,255
 2031dcc:	1080004c 	andi	r2,r2,1
 2031dd0:	1000091e 	bne	r2,zero,2031df8 <ip_route+0xdc>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 2031dd4:	008085f4 	movhi	r2,535
 2031dd8:	10a8bc04 	addi	r2,r2,-23824
 2031ddc:	10802b17 	ldw	r2,172(r2)
 2031de0:	10c00044 	addi	r3,r2,1
 2031de4:	008085f4 	movhi	r2,535
 2031de8:	10a8bc04 	addi	r2,r2,-23824
 2031dec:	10c02b15 	stw	r3,172(r2)
    snmp_inc_ipoutnoroutes();
    return NULL;
 2031df0:	0005883a 	mov	r2,zero
 2031df4:	00000106 	br	2031dfc <ip_route+0xe0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
 2031df8:	d0a7f417 	ldw	r2,-24624(gp)
}
 2031dfc:	e037883a 	mov	sp,fp
 2031e00:	df000017 	ldw	fp,0(sp)
 2031e04:	dec00104 	addi	sp,sp,4
 2031e08:	f800283a 	ret

02031e0c <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 2031e0c:	defff604 	addi	sp,sp,-40
 2031e10:	dfc00915 	stw	ra,36(sp)
 2031e14:	df000815 	stw	fp,32(sp)
 2031e18:	df000804 	addi	fp,sp,32
 2031e1c:	e13ffe15 	stw	r4,-8(fp)
 2031e20:	e17fff15 	stw	r5,-4(fp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
 2031e24:	00800044 	movi	r2,1
 2031e28:	e0bffa15 	stw	r2,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  IP_STATS_INC(ip.recv);
 2031e2c:	008085f4 	movhi	r2,535
 2031e30:	10a8bc04 	addi	r2,r2,-23824
 2031e34:	10802517 	ldw	r2,148(r2)
 2031e38:	10c00044 	addi	r3,r2,1
 2031e3c:	008085f4 	movhi	r2,535
 2031e40:	10a8bc04 	addi	r2,r2,-23824
 2031e44:	10c02515 	stw	r3,148(r2)
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 2031e48:	e0bffe17 	ldw	r2,-8(fp)
 2031e4c:	10800117 	ldw	r2,4(r2)
 2031e50:	e0bff815 	stw	r2,-32(fp)
  if (IPH_V(iphdr) != 4) {
 2031e54:	e0bff817 	ldw	r2,-32(fp)
 2031e58:	10800003 	ldbu	r2,0(r2)
 2031e5c:	10803fcc 	andi	r2,r2,255
 2031e60:	1004d13a 	srli	r2,r2,4
 2031e64:	10803fcc 	andi	r2,r2,255
 2031e68:	10800120 	cmpeqi	r2,r2,4
 2031e6c:	1000121e 	bne	r2,zero,2031eb8 <ip_input+0xac>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 2031e70:	e13ffe17 	ldw	r4,-8(fp)
 2031e74:	201ab680 	call	201ab68 <pbuf_free>
    IP_STATS_INC(ip.err);
 2031e78:	008085f4 	movhi	r2,535
 2031e7c:	10a8bc04 	addi	r2,r2,-23824
 2031e80:	10802e17 	ldw	r2,184(r2)
 2031e84:	10c00044 	addi	r3,r2,1
 2031e88:	008085f4 	movhi	r2,535
 2031e8c:	10a8bc04 	addi	r2,r2,-23824
 2031e90:	10c02e15 	stw	r3,184(r2)
    IP_STATS_INC(ip.drop);
 2031e94:	008085f4 	movhi	r2,535
 2031e98:	10a8bc04 	addi	r2,r2,-23824
 2031e9c:	10802717 	ldw	r2,156(r2)
 2031ea0:	10c00044 	addi	r3,r2,1
 2031ea4:	008085f4 	movhi	r2,535
 2031ea8:	10a8bc04 	addi	r2,r2,-23824
 2031eac:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 2031eb0:	0005883a 	mov	r2,zero
 2031eb4:	00011f06 	br	2032334 <ip_input+0x528>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 2031eb8:	e0bff817 	ldw	r2,-32(fp)
 2031ebc:	10800003 	ldbu	r2,0(r2)
 2031ec0:	10803fcc 	andi	r2,r2,255
 2031ec4:	108003cc 	andi	r2,r2,15
 2031ec8:	e0bffc0d 	sth	r2,-16(fp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
 2031ecc:	e0bffc0b 	ldhu	r2,-16(fp)
 2031ed0:	1085883a 	add	r2,r2,r2
 2031ed4:	1085883a 	add	r2,r2,r2
 2031ed8:	e0bffc0d 	sth	r2,-16(fp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 2031edc:	e0bff817 	ldw	r2,-32(fp)
 2031ee0:	10c00083 	ldbu	r3,2(r2)
 2031ee4:	108000c3 	ldbu	r2,3(r2)
 2031ee8:	1004923a 	slli	r2,r2,8
 2031eec:	10c4b03a 	or	r2,r2,r3
 2031ef0:	10bfffcc 	andi	r2,r2,65535
 2031ef4:	1004d23a 	srli	r2,r2,8
 2031ef8:	1009883a 	mov	r4,r2
 2031efc:	e0bff817 	ldw	r2,-32(fp)
 2031f00:	10c00083 	ldbu	r3,2(r2)
 2031f04:	108000c3 	ldbu	r2,3(r2)
 2031f08:	1004923a 	slli	r2,r2,8
 2031f0c:	10c4b03a 	or	r2,r2,r3
 2031f10:	10bfffcc 	andi	r2,r2,65535
 2031f14:	1004923a 	slli	r2,r2,8
 2031f18:	2084b03a 	or	r2,r4,r2
 2031f1c:	e0bffc8d 	sth	r2,-14(fp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 2031f20:	e0bffe17 	ldw	r2,-8(fp)
 2031f24:	1080028b 	ldhu	r2,10(r2)
 2031f28:	10ffffcc 	andi	r3,r2,65535
 2031f2c:	e0bffc0b 	ldhu	r2,-16(fp)
 2031f30:	18800536 	bltu	r3,r2,2031f48 <ip_input+0x13c>
 2031f34:	e0bffe17 	ldw	r2,-8(fp)
 2031f38:	1080020b 	ldhu	r2,8(r2)
 2031f3c:	10ffffcc 	andi	r3,r2,65535
 2031f40:	e0bffc8b 	ldhu	r2,-14(fp)
 2031f44:	1880122e 	bgeu	r3,r2,2031f90 <ip_input+0x184>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
 2031f48:	e13ffe17 	ldw	r4,-8(fp)
 2031f4c:	201ab680 	call	201ab68 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
 2031f50:	008085f4 	movhi	r2,535
 2031f54:	10a8bc04 	addi	r2,r2,-23824
 2031f58:	10802917 	ldw	r2,164(r2)
 2031f5c:	10c00044 	addi	r3,r2,1
 2031f60:	008085f4 	movhi	r2,535
 2031f64:	10a8bc04 	addi	r2,r2,-23824
 2031f68:	10c02915 	stw	r3,164(r2)
    IP_STATS_INC(ip.drop);
 2031f6c:	008085f4 	movhi	r2,535
 2031f70:	10a8bc04 	addi	r2,r2,-23824
 2031f74:	10802717 	ldw	r2,156(r2)
 2031f78:	10c00044 	addi	r3,r2,1
 2031f7c:	008085f4 	movhi	r2,535
 2031f80:	10a8bc04 	addi	r2,r2,-23824
 2031f84:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipindiscards();
    return ERR_OK;
 2031f88:	0005883a 	mov	r2,zero
 2031f8c:	0000e906 	br	2032334 <ip_input+0x528>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
 2031f90:	e0bffc0b 	ldhu	r2,-16(fp)
 2031f94:	100b883a 	mov	r5,r2
 2031f98:	e13ff817 	ldw	r4,-32(fp)
 2031f9c:	2031b740 	call	2031b74 <inet_chksum>
 2031fa0:	10bfffcc 	andi	r2,r2,65535
 2031fa4:	10001226 	beq	r2,zero,2031ff0 <ip_input+0x1e4>

    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
 2031fa8:	e13ffe17 	ldw	r4,-8(fp)
 2031fac:	201ab680 	call	201ab68 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
 2031fb0:	008085f4 	movhi	r2,535
 2031fb4:	10a8bc04 	addi	r2,r2,-23824
 2031fb8:	10802817 	ldw	r2,160(r2)
 2031fbc:	10c00044 	addi	r3,r2,1
 2031fc0:	008085f4 	movhi	r2,535
 2031fc4:	10a8bc04 	addi	r2,r2,-23824
 2031fc8:	10c02815 	stw	r3,160(r2)
    IP_STATS_INC(ip.drop);
 2031fcc:	008085f4 	movhi	r2,535
 2031fd0:	10a8bc04 	addi	r2,r2,-23824
 2031fd4:	10802717 	ldw	r2,156(r2)
 2031fd8:	10c00044 	addi	r3,r2,1
 2031fdc:	008085f4 	movhi	r2,535
 2031fe0:	10a8bc04 	addi	r2,r2,-23824
 2031fe4:	10c02715 	stw	r3,156(r2)
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
 2031fe8:	0005883a 	mov	r2,zero
 2031fec:	0000d106 	br	2032334 <ip_input+0x528>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 2031ff0:	e0bffc8b 	ldhu	r2,-14(fp)
 2031ff4:	100b883a 	mov	r5,r2
 2031ff8:	e13ffe17 	ldw	r4,-8(fp)
 2031ffc:	201a8580 	call	201a858 <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 2032000:	e0bff817 	ldw	r2,-32(fp)
 2032004:	10c00403 	ldbu	r3,16(r2)
 2032008:	11000443 	ldbu	r4,17(r2)
 203200c:	2008923a 	slli	r4,r4,8
 2032010:	20c6b03a 	or	r3,r4,r3
 2032014:	11000483 	ldbu	r4,18(r2)
 2032018:	2008943a 	slli	r4,r4,16
 203201c:	20c6b03a 	or	r3,r4,r3
 2032020:	108004c3 	ldbu	r2,19(r2)
 2032024:	1004963a 	slli	r2,r2,24
 2032028:	10c4b03a 	or	r2,r2,r3
 203202c:	d0a81415 	stw	r2,-24496(gp)
  ip_addr_copy(current_iphdr_src, iphdr->src);
 2032030:	e0bff817 	ldw	r2,-32(fp)
 2032034:	10c00303 	ldbu	r3,12(r2)
 2032038:	11000343 	ldbu	r4,13(r2)
 203203c:	2008923a 	slli	r4,r4,8
 2032040:	20c6b03a 	or	r3,r4,r3
 2032044:	11000383 	ldbu	r4,14(r2)
 2032048:	2008943a 	slli	r4,r4,16
 203204c:	20c6b03a 	or	r3,r4,r3
 2032050:	108003c3 	ldbu	r2,15(r2)
 2032054:	1004963a 	slli	r2,r2,24
 2032058:	10c4b03a 	or	r2,r2,r3
 203205c:	d0a81215 	stw	r2,-24504(gp)
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 2032060:	00800044 	movi	r2,1
 2032064:	e0bffb15 	stw	r2,-20(fp)
    netif = inp;
 2032068:	e0bfff17 	ldw	r2,-4(fp)
 203206c:	e0bff915 	stw	r2,-28(fp)
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 2032070:	e0bff917 	ldw	r2,-28(fp)
 2032074:	10800e43 	ldbu	r2,57(r2)
 2032078:	10803fcc 	andi	r2,r2,255
 203207c:	1080004c 	andi	r2,r2,1
 2032080:	10001026 	beq	r2,zero,20320c4 <ip_input+0x2b8>
 2032084:	e0bff917 	ldw	r2,-28(fp)
 2032088:	10800104 	addi	r2,r2,4
 203208c:	10000d26 	beq	r2,zero,20320c4 <ip_input+0x2b8>
 2032090:	e0bff917 	ldw	r2,-28(fp)
 2032094:	10800117 	ldw	r2,4(r2)
 2032098:	10000a26 	beq	r2,zero,20320c4 <ip_input+0x2b8>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 203209c:	d0e81417 	ldw	r3,-24496(gp)
 20320a0:	e0bff917 	ldw	r2,-28(fp)
 20320a4:	10800117 	ldw	r2,4(r2)
 20320a8:	18801726 	beq	r3,r2,2032108 <ip_input+0x2fc>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 20320ac:	d0a81417 	ldw	r2,-24496(gp)
 20320b0:	e17ff917 	ldw	r5,-28(fp)
 20320b4:	1009883a 	mov	r4,r2
 20320b8:	20189240 	call	2018924 <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 20320bc:	10803fcc 	andi	r2,r2,255
 20320c0:	1000111e 	bne	r2,zero,2032108 <ip_input+0x2fc>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 20320c4:	e0bffb17 	ldw	r2,-20(fp)
 20320c8:	10000426 	beq	r2,zero,20320dc <ip_input+0x2d0>
        first = 0;
 20320cc:	e03ffb15 	stw	zero,-20(fp)
        netif = netif_list;
 20320d0:	d0a7f317 	ldw	r2,-24628(gp)
 20320d4:	e0bff915 	stw	r2,-28(fp)
 20320d8:	00000306 	br	20320e8 <ip_input+0x2dc>
      } else {
        netif = netif->next;
 20320dc:	e0bff917 	ldw	r2,-28(fp)
 20320e0:	10800017 	ldw	r2,0(r2)
 20320e4:	e0bff915 	stw	r2,-28(fp)
      }
      if (netif == inp) {
 20320e8:	e0fff917 	ldw	r3,-28(fp)
 20320ec:	e0bfff17 	ldw	r2,-4(fp)
 20320f0:	1880031e 	bne	r3,r2,2032100 <ip_input+0x2f4>
        netif = netif->next;
 20320f4:	e0bff917 	ldw	r2,-28(fp)
 20320f8:	10800017 	ldw	r2,0(r2)
 20320fc:	e0bff915 	stw	r2,-28(fp)
      }
    } while(netif != NULL);
 2032100:	e0bff917 	ldw	r2,-28(fp)
 2032104:	103fda1e 	bne	r2,zero,2032070 <__alt_mem_mem_0+0xfd012070>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
 2032108:	e0bff917 	ldw	r2,-28(fp)
 203210c:	1000141e 	bne	r2,zero,2032160 <ip_input+0x354>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 2032110:	e0bff817 	ldw	r2,-32(fp)
 2032114:	10800243 	ldbu	r2,9(r2)
 2032118:	10803fcc 	andi	r2,r2,255
 203211c:	10800458 	cmpnei	r2,r2,17
 2032120:	10000f1e 	bne	r2,zero,2032160 <ip_input+0x354>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
 2032124:	e0bffc0b 	ldhu	r2,-16(fp)
 2032128:	e0fff817 	ldw	r3,-32(fp)
 203212c:	1885883a 	add	r2,r3,r2
 2032130:	e0bffd15 	stw	r2,-12(fp)
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 2032134:	e0bffd17 	ldw	r2,-12(fp)
 2032138:	10c00083 	ldbu	r3,2(r2)
 203213c:	108000c3 	ldbu	r2,3(r2)
 2032140:	1004923a 	slli	r2,r2,8
 2032144:	10c4b03a 	or	r2,r2,r3
 2032148:	10bfffcc 	andi	r2,r2,65535
 203214c:	10910018 	cmpnei	r2,r2,17408
 2032150:	1000031e 	bne	r2,zero,2032160 <ip_input+0x354>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
 2032154:	e0bfff17 	ldw	r2,-4(fp)
 2032158:	e0bff915 	stw	r2,-28(fp)
        check_ip_src = 0;
 203215c:	e03ffa15 	stw	zero,-24(fp)
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 2032160:	e0bffa17 	ldw	r2,-24(fp)
 2032164:	10001726 	beq	r2,zero,20321c4 <ip_input+0x3b8>
 2032168:	d0a81217 	ldw	r2,-24504(gp)
 203216c:	10001526 	beq	r2,zero,20321c4 <ip_input+0x3b8>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 2032170:	d0a81217 	ldw	r2,-24504(gp)
 2032174:	e17fff17 	ldw	r5,-4(fp)
 2032178:	1009883a 	mov	r4,r2
 203217c:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2032180:	10803fcc 	andi	r2,r2,255
 2032184:	1000041e 	bne	r2,zero,2032198 <ip_input+0x38c>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 2032188:	d0a81217 	ldw	r2,-24504(gp)
 203218c:	10803c0c 	andi	r2,r2,240
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 2032190:	10803818 	cmpnei	r2,r2,224
 2032194:	10000b1e 	bne	r2,zero,20321c4 <ip_input+0x3b8>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 2032198:	e13ffe17 	ldw	r4,-8(fp)
 203219c:	201ab680 	call	201ab68 <pbuf_free>
      IP_STATS_INC(ip.drop);
 20321a0:	008085f4 	movhi	r2,535
 20321a4:	10a8bc04 	addi	r2,r2,-23824
 20321a8:	10802717 	ldw	r2,156(r2)
 20321ac:	10c00044 	addi	r3,r2,1
 20321b0:	008085f4 	movhi	r2,535
 20321b4:	10a8bc04 	addi	r2,r2,-23824
 20321b8:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 20321bc:	0005883a 	mov	r2,zero
 20321c0:	00005c06 	br	2032334 <ip_input+0x528>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 20321c4:	e0bff917 	ldw	r2,-28(fp)
 20321c8:	1000041e 	bne	r2,zero,20321dc <ip_input+0x3d0>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 20321cc:	e13ffe17 	ldw	r4,-8(fp)
 20321d0:	201ab680 	call	201ab68 <pbuf_free>
    return ERR_OK;
 20321d4:	0005883a 	mov	r2,zero
 20321d8:	00005606 	br	2032334 <ip_input+0x528>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 20321dc:	e0bff817 	ldw	r2,-32(fp)
 20321e0:	10c00183 	ldbu	r3,6(r2)
 20321e4:	108001c3 	ldbu	r2,7(r2)
 20321e8:	1004923a 	slli	r2,r2,8
 20321ec:	10c4b03a 	or	r2,r2,r3
 20321f0:	10bfffcc 	andi	r2,r2,65535
 20321f4:	10bfcfcc 	andi	r2,r2,65343
 20321f8:	10000a26 	beq	r2,zero,2032224 <ip_input+0x418>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 20321fc:	e13ffe17 	ldw	r4,-8(fp)
 2032200:	203371c0 	call	203371c <ip_reass>
 2032204:	e0bffe15 	stw	r2,-8(fp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 2032208:	e0bffe17 	ldw	r2,-8(fp)
 203220c:	1000021e 	bne	r2,zero,2032218 <ip_input+0x40c>
      return ERR_OK;
 2032210:	0005883a 	mov	r2,zero
 2032214:	00004706 	br	2032334 <ip_input+0x528>
    }
    iphdr = (struct ip_hdr *)p->payload;
 2032218:	e0bffe17 	ldw	r2,-8(fp)
 203221c:	10800117 	ldw	r2,4(r2)
 2032220:	e0bff815 	stw	r2,-32(fp)
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 2032224:	e0bfff17 	ldw	r2,-4(fp)
 2032228:	d0a81315 	stw	r2,-24500(gp)
  current_header = iphdr;
 203222c:	e0bff817 	ldw	r2,-32(fp)
 2032230:	d0a81515 	stw	r2,-24492(gp)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 2032234:	e17fff17 	ldw	r5,-4(fp)
 2032238:	e13ffe17 	ldw	r4,-8(fp)
 203223c:	20346e80 	call	20346e8 <raw_input>
 2032240:	10803fcc 	andi	r2,r2,255
 2032244:	1000361e 	bne	r2,zero,2032320 <ip_input+0x514>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 2032248:	e0bff817 	ldw	r2,-32(fp)
 203224c:	10800243 	ldbu	r2,9(r2)
 2032250:	10803fcc 	andi	r2,r2,255
 2032254:	10c001a0 	cmpeqi	r3,r2,6
 2032258:	1800091e 	bne	r3,zero,2032280 <ip_input+0x474>
 203225c:	10c00460 	cmpeqi	r3,r2,17
 2032260:	1800031e 	bne	r3,zero,2032270 <ip_input+0x464>
 2032264:	10800060 	cmpeqi	r2,r2,1
 2032268:	1000091e 	bne	r2,zero,2032290 <ip_input+0x484>
 203226c:	00000c06 	br	20322a0 <ip_input+0x494>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 2032270:	e17fff17 	ldw	r5,-4(fp)
 2032274:	e13ffe17 	ldw	r4,-8(fp)
 2032278:	2021b780 	call	2021b78 <udp_input>
      break;
 203227c:	00002806 	br	2032320 <ip_input+0x514>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 2032280:	e17fff17 	ldw	r5,-4(fp)
 2032284:	e13ffe17 	ldw	r4,-8(fp)
 2032288:	2034bd40 	call	2034bd4 <tcp_input>
      break;
 203228c:	00002406 	br	2032320 <ip_input+0x514>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 2032290:	e17fff17 	ldw	r5,-4(fp)
 2032294:	e13ffe17 	ldw	r4,-8(fp)
 2032298:	2030c9c0 	call	2030c9c <icmp_input>
      break;
 203229c:	00002006 	br	2032320 <ip_input+0x514>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 20322a0:	d0a81417 	ldw	r2,-24496(gp)
 20322a4:	e17fff17 	ldw	r5,-4(fp)
 20322a8:	1009883a 	mov	r4,r2
 20322ac:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 20322b0:	10803fcc 	andi	r2,r2,255
 20322b4:	10000a1e 	bne	r2,zero,20322e0 <ip_input+0x4d4>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 20322b8:	d0a81417 	ldw	r2,-24496(gp)
 20322bc:	10803c0c 	andi	r2,r2,240
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 20322c0:	10803820 	cmpeqi	r2,r2,224
 20322c4:	1000061e 	bne	r2,zero,20322e0 <ip_input+0x4d4>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 20322c8:	e0bffe17 	ldw	r2,-8(fp)
 20322cc:	e0fff817 	ldw	r3,-32(fp)
 20322d0:	10c00115 	stw	r3,4(r2)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 20322d4:	01400084 	movi	r5,2
 20322d8:	e13ffe17 	ldw	r4,-8(fp)
 20322dc:	20312980 	call	2031298 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 20322e0:	e13ffe17 	ldw	r4,-8(fp)
 20322e4:	201ab680 	call	201ab68 <pbuf_free>

      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", IPH_PROTO(iphdr)));

      IP_STATS_INC(ip.proterr);
 20322e8:	008085f4 	movhi	r2,535
 20322ec:	10a8bc04 	addi	r2,r2,-23824
 20322f0:	10802c17 	ldw	r2,176(r2)
 20322f4:	10c00044 	addi	r3,r2,1
 20322f8:	008085f4 	movhi	r2,535
 20322fc:	10a8bc04 	addi	r2,r2,-23824
 2032300:	10c02c15 	stw	r3,176(r2)
      IP_STATS_INC(ip.drop);
 2032304:	008085f4 	movhi	r2,535
 2032308:	10a8bc04 	addi	r2,r2,-23824
 203230c:	10802717 	ldw	r2,156(r2)
 2032310:	10c00044 	addi	r3,r2,1
 2032314:	008085f4 	movhi	r2,535
 2032318:	10a8bc04 	addi	r2,r2,-23824
 203231c:	10c02715 	stw	r3,156(r2)
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 2032320:	d0281315 	stw	zero,-24500(gp)
  current_header = NULL;
 2032324:	d0281515 	stw	zero,-24492(gp)
  ip_addr_set_any(&current_iphdr_src);
 2032328:	d0281215 	stw	zero,-24504(gp)
  ip_addr_set_any(&current_iphdr_dest);
 203232c:	d0281415 	stw	zero,-24496(gp)

  return ERR_OK;
 2032330:	0005883a 	mov	r2,zero
}
 2032334:	e037883a 	mov	sp,fp
 2032338:	dfc00117 	ldw	ra,4(sp)
 203233c:	df000017 	ldw	fp,0(sp)
 2032340:	dec00204 	addi	sp,sp,8
 2032344:	f800283a 	ret

02032348 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 2032348:	defff404 	addi	sp,sp,-48
 203234c:	dfc00b15 	stw	ra,44(sp)
 2032350:	df000a15 	stw	fp,40(sp)
 2032354:	df000a04 	addi	fp,sp,40
 2032358:	e13ffa15 	stw	r4,-24(fp)
 203235c:	e17ffb15 	stw	r5,-20(fp)
 2032360:	e1bffc15 	stw	r6,-16(fp)
 2032364:	3809883a 	mov	r4,r7
 2032368:	e0c00217 	ldw	r3,8(fp)
 203236c:	e0800317 	ldw	r2,12(fp)
 2032370:	e13ffd05 	stb	r4,-12(fp)
 2032374:	e0fffe05 	stb	r3,-8(fp)
 2032378:	e0bfff05 	stb	r2,-4(fp)
{
#endif /* IP_OPTIONS_SEND */
  struct ip_hdr *iphdr;
  ip_addr_t dest_addr;
#if CHECKSUM_GEN_IP_INLINE
  u32_t chk_sum = 0;
 203237c:	e03ff615 	stw	zero,-40(fp)
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 2032380:	e0bffc17 	ldw	r2,-16(fp)
 2032384:	10015026 	beq	r2,zero,20328c8 <ip_output_if+0x580>
    u16_t ip_hlen = IP_HLEN;
 2032388:	00800504 	movi	r2,20
 203238c:	e0bff70d 	sth	r2,-36(fp)
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 2032390:	01400504 	movi	r5,20
 2032394:	e13ffa17 	ldw	r4,-24(fp)
 2032398:	201a9b80 	call	201a9b8 <pbuf_header>
 203239c:	10803fcc 	andi	r2,r2,255
 20323a0:	10000926 	beq	r2,zero,20323c8 <ip_output_if+0x80>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
 20323a4:	008085f4 	movhi	r2,535
 20323a8:	10a8bc04 	addi	r2,r2,-23824
 20323ac:	10802e17 	ldw	r2,184(r2)
 20323b0:	10c00044 	addi	r3,r2,1
 20323b4:	008085f4 	movhi	r2,535
 20323b8:	10a8bc04 	addi	r2,r2,-23824
 20323bc:	10c02e15 	stw	r3,184(r2)
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 20323c0:	00bfff84 	movi	r2,-2
 20323c4:	00016e06 	br	2032980 <ip_output_if+0x638>
    }

    iphdr = (struct ip_hdr *)p->payload;
 20323c8:	e0bffa17 	ldw	r2,-24(fp)
 20323cc:	10800117 	ldw	r2,4(r2)
 20323d0:	e0bff815 	stw	r2,-32(fp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 20323d4:	e0bff817 	ldw	r2,-32(fp)
 20323d8:	e0fffd03 	ldbu	r3,-12(fp)
 20323dc:	10c00205 	stb	r3,8(r2)
    IPH_PROTO_SET(iphdr, proto);
 20323e0:	e0bff817 	ldw	r2,-32(fp)
 20323e4:	e0ffff03 	ldbu	r3,-4(fp)
 20323e8:	10c00245 	stb	r3,9(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 20323ec:	e0bfff03 	ldbu	r2,-4(fp)
 20323f0:	1006923a 	slli	r3,r2,8
 20323f4:	e0bffd03 	ldbu	r2,-12(fp)
 20323f8:	1884b03a 	or	r2,r3,r2
 20323fc:	1007883a 	mov	r3,r2
 2032400:	e0bff617 	ldw	r2,-40(fp)
 2032404:	10c5883a 	add	r2,r2,r3
 2032408:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 203240c:	e0bffc17 	ldw	r2,-16(fp)
 2032410:	10c00017 	ldw	r3,0(r2)
 2032414:	e0bff817 	ldw	r2,-32(fp)
 2032418:	19803fcc 	andi	r6,r3,255
 203241c:	11000403 	ldbu	r4,16(r2)
 2032420:	2008703a 	and	r4,r4,zero
 2032424:	200b883a 	mov	r5,r4
 2032428:	3009883a 	mov	r4,r6
 203242c:	2908b03a 	or	r4,r5,r4
 2032430:	11000405 	stb	r4,16(r2)
 2032434:	1808d23a 	srli	r4,r3,8
 2032438:	21803fcc 	andi	r6,r4,255
 203243c:	11000443 	ldbu	r4,17(r2)
 2032440:	2008703a 	and	r4,r4,zero
 2032444:	200b883a 	mov	r5,r4
 2032448:	3009883a 	mov	r4,r6
 203244c:	2908b03a 	or	r4,r5,r4
 2032450:	11000445 	stb	r4,17(r2)
 2032454:	1808d43a 	srli	r4,r3,16
 2032458:	21803fcc 	andi	r6,r4,255
 203245c:	11000483 	ldbu	r4,18(r2)
 2032460:	2008703a 	and	r4,r4,zero
 2032464:	200b883a 	mov	r5,r4
 2032468:	3009883a 	mov	r4,r6
 203246c:	2908b03a 	or	r4,r5,r4
 2032470:	11000485 	stb	r4,18(r2)
 2032474:	180ad63a 	srli	r5,r3,24
 2032478:	10c004c3 	ldbu	r3,19(r2)
 203247c:	1806703a 	and	r3,r3,zero
 2032480:	1809883a 	mov	r4,r3
 2032484:	2807883a 	mov	r3,r5
 2032488:	20c6b03a 	or	r3,r4,r3
 203248c:	10c004c5 	stb	r3,19(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
 2032490:	e0bff817 	ldw	r2,-32(fp)
 2032494:	10c00403 	ldbu	r3,16(r2)
 2032498:	11000443 	ldbu	r4,17(r2)
 203249c:	2008923a 	slli	r4,r4,8
 20324a0:	20c6b03a 	or	r3,r4,r3
 20324a4:	11000483 	ldbu	r4,18(r2)
 20324a8:	2008943a 	slli	r4,r4,16
 20324ac:	20c6b03a 	or	r3,r4,r3
 20324b0:	108004c3 	ldbu	r2,19(r2)
 20324b4:	1004963a 	slli	r2,r2,24
 20324b8:	10c4b03a 	or	r2,r2,r3
 20324bc:	10bfffcc 	andi	r2,r2,65535
 20324c0:	e0fff617 	ldw	r3,-40(fp)
 20324c4:	1885883a 	add	r2,r3,r2
 20324c8:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
 20324cc:	e0bff817 	ldw	r2,-32(fp)
 20324d0:	10c00403 	ldbu	r3,16(r2)
 20324d4:	11000443 	ldbu	r4,17(r2)
 20324d8:	2008923a 	slli	r4,r4,8
 20324dc:	20c6b03a 	or	r3,r4,r3
 20324e0:	11000483 	ldbu	r4,18(r2)
 20324e4:	2008943a 	slli	r4,r4,16
 20324e8:	20c6b03a 	or	r3,r4,r3
 20324ec:	108004c3 	ldbu	r2,19(r2)
 20324f0:	1004963a 	slli	r2,r2,24
 20324f4:	10c4b03a 	or	r2,r2,r3
 20324f8:	1004d43a 	srli	r2,r2,16
 20324fc:	e0fff617 	ldw	r3,-40(fp)
 2032500:	1885883a 	add	r2,r3,r2
 2032504:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 2032508:	e0bff70b 	ldhu	r2,-36(fp)
 203250c:	1004d0ba 	srli	r2,r2,2
 2032510:	10801014 	ori	r2,r2,64
 2032514:	1007883a 	mov	r3,r2
 2032518:	e0bff817 	ldw	r2,-32(fp)
 203251c:	10c00005 	stb	r3,0(r2)
    IPH_TOS_SET(iphdr, tos);
 2032520:	e0bff817 	ldw	r2,-32(fp)
 2032524:	e0fffe03 	ldbu	r3,-8(fp)
 2032528:	10c00045 	stb	r3,1(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 203252c:	e0bffe03 	ldbu	r2,-8(fp)
 2032530:	1006923a 	slli	r3,r2,8
 2032534:	e0bff817 	ldw	r2,-32(fp)
 2032538:	10800003 	ldbu	r2,0(r2)
 203253c:	10803fcc 	andi	r2,r2,255
 2032540:	1884b03a 	or	r2,r3,r2
 2032544:	1007883a 	mov	r3,r2
 2032548:	e0bff617 	ldw	r2,-40(fp)
 203254c:	10c5883a 	add	r2,r2,r3
 2032550:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 2032554:	e0bffa17 	ldw	r2,-24(fp)
 2032558:	1080020b 	ldhu	r2,8(r2)
 203255c:	10bfffcc 	andi	r2,r2,65535
 2032560:	1004d23a 	srli	r2,r2,8
 2032564:	1007883a 	mov	r3,r2
 2032568:	e0bffa17 	ldw	r2,-24(fp)
 203256c:	1080020b 	ldhu	r2,8(r2)
 2032570:	10bfffcc 	andi	r2,r2,65535
 2032574:	1004923a 	slli	r2,r2,8
 2032578:	1884b03a 	or	r2,r3,r2
 203257c:	100d883a 	mov	r6,r2
 2032580:	e0bff817 	ldw	r2,-32(fp)
 2032584:	30ffffcc 	andi	r3,r6,65535
 2032588:	19403fcc 	andi	r5,r3,255
 203258c:	10c00083 	ldbu	r3,2(r2)
 2032590:	1806703a 	and	r3,r3,zero
 2032594:	1809883a 	mov	r4,r3
 2032598:	2807883a 	mov	r3,r5
 203259c:	20c6b03a 	or	r3,r4,r3
 20325a0:	10c00085 	stb	r3,2(r2)
 20325a4:	30ffffcc 	andi	r3,r6,65535
 20325a8:	1806d23a 	srli	r3,r3,8
 20325ac:	197fffcc 	andi	r5,r3,65535
 20325b0:	10c000c3 	ldbu	r3,3(r2)
 20325b4:	1806703a 	and	r3,r3,zero
 20325b8:	1809883a 	mov	r4,r3
 20325bc:	2807883a 	mov	r3,r5
 20325c0:	20c6b03a 	or	r3,r4,r3
 20325c4:	10c000c5 	stb	r3,3(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
 20325c8:	e0bff817 	ldw	r2,-32(fp)
 20325cc:	10c00083 	ldbu	r3,2(r2)
 20325d0:	108000c3 	ldbu	r2,3(r2)
 20325d4:	1004923a 	slli	r2,r2,8
 20325d8:	10c4b03a 	or	r2,r2,r3
 20325dc:	10bfffcc 	andi	r2,r2,65535
 20325e0:	e0fff617 	ldw	r3,-40(fp)
 20325e4:	1885883a 	add	r2,r3,r2
 20325e8:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 20325ec:	e0bff817 	ldw	r2,-32(fp)
 20325f0:	10c00183 	ldbu	r3,6(r2)
 20325f4:	1806703a 	and	r3,r3,zero
 20325f8:	10c00185 	stb	r3,6(r2)
 20325fc:	10c001c3 	ldbu	r3,7(r2)
 2032600:	1806703a 	and	r3,r3,zero
 2032604:	10c001c5 	stb	r3,7(r2)
    IPH_ID_SET(iphdr, htons(ip_id));
 2032608:	d0a8110b 	ldhu	r2,-24508(gp)
 203260c:	10bfffcc 	andi	r2,r2,65535
 2032610:	1004d23a 	srli	r2,r2,8
 2032614:	1007883a 	mov	r3,r2
 2032618:	d0a8110b 	ldhu	r2,-24508(gp)
 203261c:	10bfffcc 	andi	r2,r2,65535
 2032620:	1004923a 	slli	r2,r2,8
 2032624:	1884b03a 	or	r2,r3,r2
 2032628:	100d883a 	mov	r6,r2
 203262c:	e0bff817 	ldw	r2,-32(fp)
 2032630:	30ffffcc 	andi	r3,r6,65535
 2032634:	19403fcc 	andi	r5,r3,255
 2032638:	10c00103 	ldbu	r3,4(r2)
 203263c:	1806703a 	and	r3,r3,zero
 2032640:	1809883a 	mov	r4,r3
 2032644:	2807883a 	mov	r3,r5
 2032648:	20c6b03a 	or	r3,r4,r3
 203264c:	10c00105 	stb	r3,4(r2)
 2032650:	30ffffcc 	andi	r3,r6,65535
 2032654:	1806d23a 	srli	r3,r3,8
 2032658:	197fffcc 	andi	r5,r3,65535
 203265c:	10c00143 	ldbu	r3,5(r2)
 2032660:	1806703a 	and	r3,r3,zero
 2032664:	1809883a 	mov	r4,r3
 2032668:	2807883a 	mov	r3,r5
 203266c:	20c6b03a 	or	r3,r4,r3
 2032670:	10c00145 	stb	r3,5(r2)
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
 2032674:	e0bff817 	ldw	r2,-32(fp)
 2032678:	10c00103 	ldbu	r3,4(r2)
 203267c:	10800143 	ldbu	r2,5(r2)
 2032680:	1004923a 	slli	r2,r2,8
 2032684:	10c4b03a 	or	r2,r2,r3
 2032688:	10bfffcc 	andi	r2,r2,65535
 203268c:	e0fff617 	ldw	r3,-40(fp)
 2032690:	1885883a 	add	r2,r3,r2
 2032694:	e0bff615 	stw	r2,-40(fp)
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 2032698:	d0a8110b 	ldhu	r2,-24508(gp)
 203269c:	10800044 	addi	r2,r2,1
 20326a0:	d0a8110d 	sth	r2,-24508(gp)

    if (ip_addr_isany(src)) {
 20326a4:	e0bffb17 	ldw	r2,-20(fp)
 20326a8:	10000326 	beq	r2,zero,20326b8 <ip_output_if+0x370>
 20326ac:	e0bffb17 	ldw	r2,-20(fp)
 20326b0:	10800017 	ldw	r2,0(r2)
 20326b4:	1000221e 	bne	r2,zero,2032740 <ip_output_if+0x3f8>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 20326b8:	e0800417 	ldw	r2,16(fp)
 20326bc:	10c00117 	ldw	r3,4(r2)
 20326c0:	e0bff817 	ldw	r2,-32(fp)
 20326c4:	19803fcc 	andi	r6,r3,255
 20326c8:	11000303 	ldbu	r4,12(r2)
 20326cc:	2008703a 	and	r4,r4,zero
 20326d0:	200b883a 	mov	r5,r4
 20326d4:	3009883a 	mov	r4,r6
 20326d8:	2908b03a 	or	r4,r5,r4
 20326dc:	11000305 	stb	r4,12(r2)
 20326e0:	1808d23a 	srli	r4,r3,8
 20326e4:	21803fcc 	andi	r6,r4,255
 20326e8:	11000343 	ldbu	r4,13(r2)
 20326ec:	2008703a 	and	r4,r4,zero
 20326f0:	200b883a 	mov	r5,r4
 20326f4:	3009883a 	mov	r4,r6
 20326f8:	2908b03a 	or	r4,r5,r4
 20326fc:	11000345 	stb	r4,13(r2)
 2032700:	1808d43a 	srli	r4,r3,16
 2032704:	21803fcc 	andi	r6,r4,255
 2032708:	11000383 	ldbu	r4,14(r2)
 203270c:	2008703a 	and	r4,r4,zero
 2032710:	200b883a 	mov	r5,r4
 2032714:	3009883a 	mov	r4,r6
 2032718:	2908b03a 	or	r4,r5,r4
 203271c:	11000385 	stb	r4,14(r2)
 2032720:	180ad63a 	srli	r5,r3,24
 2032724:	10c003c3 	ldbu	r3,15(r2)
 2032728:	1806703a 	and	r3,r3,zero
 203272c:	1809883a 	mov	r4,r3
 2032730:	2807883a 	mov	r3,r5
 2032734:	20c6b03a 	or	r3,r4,r3
 2032738:	10c003c5 	stb	r3,15(r2)
 203273c:	00002106 	br	20327c4 <ip_output_if+0x47c>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
 2032740:	e0bffb17 	ldw	r2,-20(fp)
 2032744:	10c00017 	ldw	r3,0(r2)
 2032748:	e0bff817 	ldw	r2,-32(fp)
 203274c:	19803fcc 	andi	r6,r3,255
 2032750:	11000303 	ldbu	r4,12(r2)
 2032754:	2008703a 	and	r4,r4,zero
 2032758:	200b883a 	mov	r5,r4
 203275c:	3009883a 	mov	r4,r6
 2032760:	2908b03a 	or	r4,r5,r4
 2032764:	11000305 	stb	r4,12(r2)
 2032768:	1808d23a 	srli	r4,r3,8
 203276c:	21803fcc 	andi	r6,r4,255
 2032770:	11000343 	ldbu	r4,13(r2)
 2032774:	2008703a 	and	r4,r4,zero
 2032778:	200b883a 	mov	r5,r4
 203277c:	3009883a 	mov	r4,r6
 2032780:	2908b03a 	or	r4,r5,r4
 2032784:	11000345 	stb	r4,13(r2)
 2032788:	1808d43a 	srli	r4,r3,16
 203278c:	21803fcc 	andi	r6,r4,255
 2032790:	11000383 	ldbu	r4,14(r2)
 2032794:	2008703a 	and	r4,r4,zero
 2032798:	200b883a 	mov	r5,r4
 203279c:	3009883a 	mov	r4,r6
 20327a0:	2908b03a 	or	r4,r5,r4
 20327a4:	11000385 	stb	r4,14(r2)
 20327a8:	180ad63a 	srli	r5,r3,24
 20327ac:	10c003c3 	ldbu	r3,15(r2)
 20327b0:	1806703a 	and	r3,r3,zero
 20327b4:	1809883a 	mov	r4,r3
 20327b8:	2807883a 	mov	r3,r5
 20327bc:	20c6b03a 	or	r3,r4,r3
 20327c0:	10c003c5 	stb	r3,15(r2)
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
 20327c4:	e0bff817 	ldw	r2,-32(fp)
 20327c8:	10c00303 	ldbu	r3,12(r2)
 20327cc:	11000343 	ldbu	r4,13(r2)
 20327d0:	2008923a 	slli	r4,r4,8
 20327d4:	20c6b03a 	or	r3,r4,r3
 20327d8:	11000383 	ldbu	r4,14(r2)
 20327dc:	2008943a 	slli	r4,r4,16
 20327e0:	20c6b03a 	or	r3,r4,r3
 20327e4:	108003c3 	ldbu	r2,15(r2)
 20327e8:	1004963a 	slli	r2,r2,24
 20327ec:	10c4b03a 	or	r2,r2,r3
 20327f0:	10bfffcc 	andi	r2,r2,65535
 20327f4:	e0fff617 	ldw	r3,-40(fp)
 20327f8:	1885883a 	add	r2,r3,r2
 20327fc:	e0bff615 	stw	r2,-40(fp)
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 2032800:	e0bff817 	ldw	r2,-32(fp)
 2032804:	10c00303 	ldbu	r3,12(r2)
 2032808:	11000343 	ldbu	r4,13(r2)
 203280c:	2008923a 	slli	r4,r4,8
 2032810:	20c6b03a 	or	r3,r4,r3
 2032814:	11000383 	ldbu	r4,14(r2)
 2032818:	2008943a 	slli	r4,r4,16
 203281c:	20c6b03a 	or	r3,r4,r3
 2032820:	108003c3 	ldbu	r2,15(r2)
 2032824:	1004963a 	slli	r2,r2,24
 2032828:	10c4b03a 	or	r2,r2,r3
 203282c:	1004d43a 	srli	r2,r2,16
 2032830:	e0fff617 	ldw	r3,-40(fp)
 2032834:	1885883a 	add	r2,r3,r2
 2032838:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 203283c:	e0bff617 	ldw	r2,-40(fp)
 2032840:	1006d43a 	srli	r3,r2,16
 2032844:	e0bff617 	ldw	r2,-40(fp)
 2032848:	10bfffcc 	andi	r2,r2,65535
 203284c:	1885883a 	add	r2,r3,r2
 2032850:	e0bff615 	stw	r2,-40(fp)
    chk_sum = (chk_sum >> 16) + chk_sum;
 2032854:	e0bff617 	ldw	r2,-40(fp)
 2032858:	1004d43a 	srli	r2,r2,16
 203285c:	e0fff617 	ldw	r3,-40(fp)
 2032860:	1885883a 	add	r2,r3,r2
 2032864:	e0bff615 	stw	r2,-40(fp)
    chk_sum = ~chk_sum;
 2032868:	e0bff617 	ldw	r2,-40(fp)
 203286c:	0084303a 	nor	r2,zero,r2
 2032870:	e0bff615 	stw	r2,-40(fp)
    iphdr->_chksum = chk_sum; /* network order */
 2032874:	e0bff617 	ldw	r2,-40(fp)
 2032878:	100d883a 	mov	r6,r2
 203287c:	e0bff817 	ldw	r2,-32(fp)
 2032880:	30ffffcc 	andi	r3,r6,65535
 2032884:	19403fcc 	andi	r5,r3,255
 2032888:	10c00283 	ldbu	r3,10(r2)
 203288c:	1806703a 	and	r3,r3,zero
 2032890:	1809883a 	mov	r4,r3
 2032894:	2807883a 	mov	r3,r5
 2032898:	20c6b03a 	or	r3,r4,r3
 203289c:	10c00285 	stb	r3,10(r2)
 20328a0:	30ffffcc 	andi	r3,r6,65535
 20328a4:	1806d23a 	srli	r3,r3,8
 20328a8:	197fffcc 	andi	r5,r3,65535
 20328ac:	10c002c3 	ldbu	r3,11(r2)
 20328b0:	1806703a 	and	r3,r3,zero
 20328b4:	1809883a 	mov	r4,r3
 20328b8:	2807883a 	mov	r3,r5
 20328bc:	20c6b03a 	or	r3,r4,r3
 20328c0:	10c002c5 	stb	r3,11(r2)
 20328c4:	00001106 	br	203290c <ip_output_if+0x5c4>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
 20328c8:	e0bffa17 	ldw	r2,-24(fp)
 20328cc:	10800117 	ldw	r2,4(r2)
 20328d0:	e0bff815 	stw	r2,-32(fp)
    ip_addr_copy(dest_addr, iphdr->dest);
 20328d4:	e0bff817 	ldw	r2,-32(fp)
 20328d8:	10c00403 	ldbu	r3,16(r2)
 20328dc:	11000443 	ldbu	r4,17(r2)
 20328e0:	2008923a 	slli	r4,r4,8
 20328e4:	20c6b03a 	or	r3,r4,r3
 20328e8:	11000483 	ldbu	r4,18(r2)
 20328ec:	2008943a 	slli	r4,r4,16
 20328f0:	20c6b03a 	or	r3,r4,r3
 20328f4:	108004c3 	ldbu	r2,19(r2)
 20328f8:	1004963a 	slli	r2,r2,24
 20328fc:	10c4b03a 	or	r2,r2,r3
 2032900:	e0bff915 	stw	r2,-28(fp)
    dest = &dest_addr;
 2032904:	e0bff904 	addi	r2,fp,-28
 2032908:	e0bffc15 	stw	r2,-16(fp)
  }

  IP_STATS_INC(ip.xmit);
 203290c:	008085f4 	movhi	r2,535
 2032910:	10a8bc04 	addi	r2,r2,-23824
 2032914:	10802417 	ldw	r2,144(r2)
 2032918:	10c00044 	addi	r3,r2,1
 203291c:	008085f4 	movhi	r2,535
 2032920:	10a8bc04 	addi	r2,r2,-23824
 2032924:	10c02415 	stw	r3,144(r2)
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 2032928:	e0800417 	ldw	r2,16(fp)
 203292c:	10800c0b 	ldhu	r2,48(r2)
 2032930:	10bfffcc 	andi	r2,r2,65535
 2032934:	10000c26 	beq	r2,zero,2032968 <ip_output_if+0x620>
 2032938:	e0bffa17 	ldw	r2,-24(fp)
 203293c:	1100020b 	ldhu	r4,8(r2)
 2032940:	e0800417 	ldw	r2,16(fp)
 2032944:	10c00c0b 	ldhu	r3,48(r2)
 2032948:	20bfffcc 	andi	r2,r4,65535
 203294c:	18ffffcc 	andi	r3,r3,65535
 2032950:	1880052e 	bgeu	r3,r2,2032968 <ip_output_if+0x620>
    return ip_frag(p, netif, dest);
 2032954:	e1bffc17 	ldw	r6,-16(fp)
 2032958:	e1400417 	ldw	r5,16(fp)
 203295c:	e13ffa17 	ldw	r4,-24(fp)
 2032960:	2033de40 	call	2033de4 <ip_frag>
 2032964:	00000606 	br	2032980 <ip_output_if+0x638>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 2032968:	e0800417 	ldw	r2,16(fp)
 203296c:	10800517 	ldw	r2,20(r2)
 2032970:	e1bffc17 	ldw	r6,-16(fp)
 2032974:	e17ffa17 	ldw	r5,-24(fp)
 2032978:	e1000417 	ldw	r4,16(fp)
 203297c:	103ee83a 	callr	r2
}
 2032980:	e037883a 	mov	sp,fp
 2032984:	dfc00117 	ldw	ra,4(sp)
 2032988:	df000017 	ldw	fp,0(sp)
 203298c:	dec00204 	addi	sp,sp,8
 2032990:	f800283a 	ret

02032994 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 2032994:	defff404 	addi	sp,sp,-48
 2032998:	dfc00b15 	stw	ra,44(sp)
 203299c:	df000a15 	stw	fp,40(sp)
 20329a0:	df000a04 	addi	fp,sp,40
 20329a4:	e13ffa15 	stw	r4,-24(fp)
 20329a8:	e17ffb15 	stw	r5,-20(fp)
 20329ac:	e1bffc15 	stw	r6,-16(fp)
 20329b0:	3809883a 	mov	r4,r7
 20329b4:	e0c00217 	ldw	r3,8(fp)
 20329b8:	e0800317 	ldw	r2,12(fp)
 20329bc:	e13ffd05 	stb	r4,-12(fp)
 20329c0:	e0fffe05 	stb	r3,-8(fp)
 20329c4:	e0bfff05 	stb	r2,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
 20329c8:	e17ffc17 	ldw	r5,-16(fp)
 20329cc:	e13ffb17 	ldw	r4,-20(fp)
 20329d0:	2031d1c0 	call	2031d1c <ip_route>
 20329d4:	e0bff915 	stw	r2,-28(fp)
 20329d8:	e0bff917 	ldw	r2,-28(fp)
 20329dc:	1000091e 	bne	r2,zero,2032a04 <ip_output+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 20329e0:	008085f4 	movhi	r2,535
 20329e4:	10a8bc04 	addi	r2,r2,-23824
 20329e8:	10802b17 	ldw	r2,172(r2)
 20329ec:	10c00044 	addi	r3,r2,1
 20329f0:	008085f4 	movhi	r2,535
 20329f4:	10a8bc04 	addi	r2,r2,-23824
 20329f8:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 20329fc:	00bfff04 	movi	r2,-4
 2032a00:	00000c06 	br	2032a34 <ip_output+0xa0>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 2032a04:	e17ffd03 	ldbu	r5,-12(fp)
 2032a08:	e0bffe03 	ldbu	r2,-8(fp)
 2032a0c:	e0ffff03 	ldbu	r3,-4(fp)
 2032a10:	e13ff917 	ldw	r4,-28(fp)
 2032a14:	d9000215 	stw	r4,8(sp)
 2032a18:	d8c00115 	stw	r3,4(sp)
 2032a1c:	d8800015 	stw	r2,0(sp)
 2032a20:	280f883a 	mov	r7,r5
 2032a24:	e1bffc17 	ldw	r6,-16(fp)
 2032a28:	e17ffb17 	ldw	r5,-20(fp)
 2032a2c:	e13ffa17 	ldw	r4,-24(fp)
 2032a30:	20323480 	call	2032348 <ip_output_if>
}
 2032a34:	e037883a 	mov	sp,fp
 2032a38:	dfc00117 	ldw	ra,4(sp)
 2032a3c:	df000017 	ldw	fp,0(sp)
 2032a40:	dec00204 	addi	sp,sp,8
 2032a44:	f800283a 	ret

02032a48 <ip_output_hinted>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output_hinted(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto, u8_t *addr_hint)
{
 2032a48:	defff304 	addi	sp,sp,-52
 2032a4c:	dfc00c15 	stw	ra,48(sp)
 2032a50:	df000b15 	stw	fp,44(sp)
 2032a54:	df000b04 	addi	fp,sp,44
 2032a58:	e13ffa15 	stw	r4,-24(fp)
 2032a5c:	e17ffb15 	stw	r5,-20(fp)
 2032a60:	e1bffc15 	stw	r6,-16(fp)
 2032a64:	3809883a 	mov	r4,r7
 2032a68:	e0c00217 	ldw	r3,8(fp)
 2032a6c:	e0800317 	ldw	r2,12(fp)
 2032a70:	e13ffd05 	stb	r4,-12(fp)
 2032a74:	e0fffe05 	stb	r3,-8(fp)
 2032a78:	e0bfff05 	stb	r2,-4(fp)

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(src, dest)) == NULL) {
 2032a7c:	e17ffc17 	ldw	r5,-16(fp)
 2032a80:	e13ffb17 	ldw	r4,-20(fp)
 2032a84:	2031d1c0 	call	2031d1c <ip_route>
 2032a88:	e0bff815 	stw	r2,-32(fp)
 2032a8c:	e0bff817 	ldw	r2,-32(fp)
 2032a90:	1000091e 	bne	r2,zero,2032ab8 <ip_output_hinted+0x70>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
 2032a94:	008085f4 	movhi	r2,535
 2032a98:	10a8bc04 	addi	r2,r2,-23824
 2032a9c:	10802b17 	ldw	r2,172(r2)
 2032aa0:	10c00044 	addi	r3,r2,1
 2032aa4:	008085f4 	movhi	r2,535
 2032aa8:	10a8bc04 	addi	r2,r2,-23824
 2032aac:	10c02b15 	stw	r3,172(r2)
    return ERR_RTE;
 2032ab0:	00bfff04 	movi	r2,-4
 2032ab4:	00001306 	br	2032b04 <ip_output_hinted+0xbc>
  }


  NETIF_SET_HWADDRHINT(netif, addr_hint);
 2032ab8:	e0bff817 	ldw	r2,-32(fp)
 2032abc:	e0c00417 	ldw	r3,16(fp)
 2032ac0:	10c01015 	stw	r3,64(r2)
  err = ip_output_if(p, src, dest, ttl, tos, proto, netif);
 2032ac4:	e17ffd03 	ldbu	r5,-12(fp)
 2032ac8:	e0bffe03 	ldbu	r2,-8(fp)
 2032acc:	e0ffff03 	ldbu	r3,-4(fp)
 2032ad0:	e13ff817 	ldw	r4,-32(fp)
 2032ad4:	d9000215 	stw	r4,8(sp)
 2032ad8:	d8c00115 	stw	r3,4(sp)
 2032adc:	d8800015 	stw	r2,0(sp)
 2032ae0:	280f883a 	mov	r7,r5
 2032ae4:	e1bffc17 	ldw	r6,-16(fp)
 2032ae8:	e17ffb17 	ldw	r5,-20(fp)
 2032aec:	e13ffa17 	ldw	r4,-24(fp)
 2032af0:	20323480 	call	2032348 <ip_output_if>
 2032af4:	e0bff905 	stb	r2,-28(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
 2032af8:	e0bff817 	ldw	r2,-32(fp)
 2032afc:	10001015 	stw	zero,64(r2)

  return err;
 2032b00:	e0bff903 	ldbu	r2,-28(fp)
}
 2032b04:	e037883a 	mov	sp,fp
 2032b08:	dfc00117 	ldw	ra,4(sp)
 2032b0c:	df000017 	ldw	fp,0(sp)
 2032b10:	dec00204 	addi	sp,sp,8
 2032b14:	f800283a 	ret

02032b18 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 2032b18:	defffb04 	addi	sp,sp,-20
 2032b1c:	dfc00415 	stw	ra,16(sp)
 2032b20:	df000315 	stw	fp,12(sp)
 2032b24:	df000304 	addi	fp,sp,12
  struct ip_reassdata *r, *prev = NULL;
 2032b28:	e03ffe15 	stw	zero,-8(fp)

  r = reassdatagrams;
 2032b2c:	d0a81617 	ldw	r2,-24488(gp)
 2032b30:	e0bffd15 	stw	r2,-12(fp)
  while (r != NULL) {
 2032b34:	00001806 	br	2032b98 <ip_reass_tmr+0x80>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 2032b38:	e0bffd17 	ldw	r2,-12(fp)
 2032b3c:	108007c3 	ldbu	r2,31(r2)
 2032b40:	10803fcc 	andi	r2,r2,255
 2032b44:	10000c26 	beq	r2,zero,2032b78 <ip_reass_tmr+0x60>
      r->timer--;
 2032b48:	e0bffd17 	ldw	r2,-12(fp)
 2032b4c:	108007c3 	ldbu	r2,31(r2)
 2032b50:	10bfffc4 	addi	r2,r2,-1
 2032b54:	1007883a 	mov	r3,r2
 2032b58:	e0bffd17 	ldw	r2,-12(fp)
 2032b5c:	10c007c5 	stb	r3,31(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
 2032b60:	e0bffd17 	ldw	r2,-12(fp)
 2032b64:	e0bffe15 	stw	r2,-8(fp)
      r = r->next;
 2032b68:	e0bffd17 	ldw	r2,-12(fp)
 2032b6c:	10800017 	ldw	r2,0(r2)
 2032b70:	e0bffd15 	stw	r2,-12(fp)
 2032b74:	00000806 	br	2032b98 <ip_reass_tmr+0x80>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
 2032b78:	e0bffd17 	ldw	r2,-12(fp)
 2032b7c:	e0bfff15 	stw	r2,-4(fp)
      /* get the next pointer before freeing */
      r = r->next;
 2032b80:	e0bffd17 	ldw	r2,-12(fp)
 2032b84:	10800017 	ldw	r2,0(r2)
 2032b88:	e0bffd15 	stw	r2,-12(fp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 2032b8c:	e17ffe17 	ldw	r5,-8(fp)
 2032b90:	e13fff17 	ldw	r4,-4(fp)
 2032b94:	2032bb80 	call	2032bb8 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 2032b98:	e0bffd17 	ldw	r2,-12(fp)
 2032b9c:	103fe61e 	bne	r2,zero,2032b38 <__alt_mem_mem_0+0xfd012b38>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
 2032ba0:	0001883a 	nop
 2032ba4:	e037883a 	mov	sp,fp
 2032ba8:	dfc00117 	ldw	ra,4(sp)
 2032bac:	df000017 	ldw	fp,0(sp)
 2032bb0:	dec00204 	addi	sp,sp,8
 2032bb4:	f800283a 	ret

02032bb8 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 2032bb8:	defff704 	addi	sp,sp,-36
 2032bbc:	dfc00815 	stw	ra,32(sp)
 2032bc0:	df000715 	stw	fp,28(sp)
 2032bc4:	df000704 	addi	fp,sp,28
 2032bc8:	e13ffe15 	stw	r4,-8(fp)
 2032bcc:	e17fff15 	stw	r5,-4(fp)
  u16_t pbufs_freed = 0;
 2032bd0:	e03ff90d 	sth	zero,-28(fp)
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 2032bd4:	e0bffe17 	ldw	r2,-8(fp)
 2032bd8:	10800117 	ldw	r2,4(r2)
 2032bdc:	10800117 	ldw	r2,4(r2)
 2032be0:	e0bffb15 	stw	r2,-20(fp)
  if (iprh->start == 0) {
 2032be4:	e0bffb17 	ldw	r2,-20(fp)
 2032be8:	10c00103 	ldbu	r3,4(r2)
 2032bec:	10800143 	ldbu	r2,5(r2)
 2032bf0:	1004923a 	slli	r2,r2,8
 2032bf4:	10c4b03a 	or	r2,r2,r3
 2032bf8:	10bfffcc 	andi	r2,r2,65535
 2032bfc:	1000251e 	bne	r2,zero,2032c94 <ip_reass_free_complete_datagram+0xdc>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
 2032c00:	e0bffe17 	ldw	r2,-8(fp)
 2032c04:	10800117 	ldw	r2,4(r2)
 2032c08:	e0bffa15 	stw	r2,-24(fp)
    ipr->p = iprh->next_pbuf;
 2032c0c:	e0bffb17 	ldw	r2,-20(fp)
 2032c10:	10c00003 	ldbu	r3,0(r2)
 2032c14:	11000043 	ldbu	r4,1(r2)
 2032c18:	2008923a 	slli	r4,r4,8
 2032c1c:	20c6b03a 	or	r3,r4,r3
 2032c20:	11000083 	ldbu	r4,2(r2)
 2032c24:	2008943a 	slli	r4,r4,16
 2032c28:	20c6b03a 	or	r3,r4,r3
 2032c2c:	108000c3 	ldbu	r2,3(r2)
 2032c30:	1004963a 	slli	r2,r2,24
 2032c34:	10c4b03a 	or	r2,r2,r3
 2032c38:	1007883a 	mov	r3,r2
 2032c3c:	e0bffe17 	ldw	r2,-8(fp)
 2032c40:	10c00115 	stw	r3,4(r2)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 2032c44:	e0bffa17 	ldw	r2,-24(fp)
 2032c48:	10c00117 	ldw	r3,4(r2)
 2032c4c:	e0bffe17 	ldw	r2,-8(fp)
 2032c50:	10800204 	addi	r2,r2,8
 2032c54:	01800504 	movi	r6,20
 2032c58:	100b883a 	mov	r5,r2
 2032c5c:	1809883a 	mov	r4,r3
 2032c60:	20060240 	call	2006024 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 2032c64:	01400044 	movi	r5,1
 2032c68:	e13ffa17 	ldw	r4,-24(fp)
 2032c6c:	20312e00 	call	20312e0 <icmp_time_exceeded>
    clen = pbuf_clen(p);
 2032c70:	e13ffa17 	ldw	r4,-24(fp)
 2032c74:	201acac0 	call	201acac <pbuf_clen>
 2032c78:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 2032c7c:	e0fffc03 	ldbu	r3,-16(fp)
 2032c80:	e0bff90b 	ldhu	r2,-28(fp)
 2032c84:	1885883a 	add	r2,r3,r2
 2032c88:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(p);
 2032c8c:	e13ffa17 	ldw	r4,-24(fp)
 2032c90:	201ab680 	call	201ab68 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 2032c94:	e0bffe17 	ldw	r2,-8(fp)
 2032c98:	10800117 	ldw	r2,4(r2)
 2032c9c:	e0bffa15 	stw	r2,-24(fp)
  while (p != NULL) {
 2032ca0:	00001a06 	br	2032d0c <ip_reass_free_complete_datagram+0x154>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
 2032ca4:	e0bffa17 	ldw	r2,-24(fp)
 2032ca8:	10800117 	ldw	r2,4(r2)
 2032cac:	e0bffb15 	stw	r2,-20(fp)
    pcur = p;
 2032cb0:	e0bffa17 	ldw	r2,-24(fp)
 2032cb4:	e0bffd15 	stw	r2,-12(fp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 2032cb8:	e0bffb17 	ldw	r2,-20(fp)
 2032cbc:	10c00003 	ldbu	r3,0(r2)
 2032cc0:	11000043 	ldbu	r4,1(r2)
 2032cc4:	2008923a 	slli	r4,r4,8
 2032cc8:	20c6b03a 	or	r3,r4,r3
 2032ccc:	11000083 	ldbu	r4,2(r2)
 2032cd0:	2008943a 	slli	r4,r4,16
 2032cd4:	20c6b03a 	or	r3,r4,r3
 2032cd8:	108000c3 	ldbu	r2,3(r2)
 2032cdc:	1004963a 	slli	r2,r2,24
 2032ce0:	10c4b03a 	or	r2,r2,r3
 2032ce4:	e0bffa15 	stw	r2,-24(fp)
    clen = pbuf_clen(pcur);
 2032ce8:	e13ffd17 	ldw	r4,-12(fp)
 2032cec:	201acac0 	call	201acac <pbuf_clen>
 2032cf0:	e0bffc05 	stb	r2,-16(fp)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 2032cf4:	e0fffc03 	ldbu	r3,-16(fp)
 2032cf8:	e0bff90b 	ldhu	r2,-28(fp)
 2032cfc:	1885883a 	add	r2,r3,r2
 2032d00:	e0bff90d 	sth	r2,-28(fp)
    pbuf_free(pcur);
 2032d04:	e13ffd17 	ldw	r4,-12(fp)
 2032d08:	201ab680 	call	201ab68 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 2032d0c:	e0bffa17 	ldw	r2,-24(fp)
 2032d10:	103fe41e 	bne	r2,zero,2032ca4 <__alt_mem_mem_0+0xfd012ca4>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 2032d14:	e17fff17 	ldw	r5,-4(fp)
 2032d18:	e13ffe17 	ldw	r4,-8(fp)
 2032d1c:	2032fb40 	call	2032fb4 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 2032d20:	d0e8170b 	ldhu	r3,-24484(gp)
 2032d24:	e0bff90b 	ldhu	r2,-28(fp)
 2032d28:	1885c83a 	sub	r2,r3,r2
 2032d2c:	d0a8170d 	sth	r2,-24484(gp)

  return pbufs_freed;
 2032d30:	e0bff90b 	ldhu	r2,-28(fp)
}
 2032d34:	e037883a 	mov	sp,fp
 2032d38:	dfc00117 	ldw	ra,4(sp)
 2032d3c:	df000017 	ldw	fp,0(sp)
 2032d40:	dec00204 	addi	sp,sp,8
 2032d44:	f800283a 	ret

02032d48 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 2032d48:	defff604 	addi	sp,sp,-40
 2032d4c:	dfc00915 	stw	ra,36(sp)
 2032d50:	df000815 	stw	fp,32(sp)
 2032d54:	df000804 	addi	fp,sp,32
 2032d58:	e13ffe15 	stw	r4,-8(fp)
 2032d5c:	e17fff15 	stw	r5,-4(fp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 2032d60:	e03ffb15 	stw	zero,-20(fp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 2032d64:	e03ff915 	stw	zero,-28(fp)
    prev = NULL;
 2032d68:	e03ffa15 	stw	zero,-24(fp)
    other_datagrams = 0;
 2032d6c:	e03ffc15 	stw	zero,-16(fp)
    r = reassdatagrams;
 2032d70:	d0a81617 	ldw	r2,-24488(gp)
 2032d74:	e0bff815 	stw	r2,-32(fp)
    while (r != NULL) {
 2032d78:	00003f06 	br	2032e78 <ip_reass_remove_oldest_datagram+0x130>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 2032d7c:	e0bff817 	ldw	r2,-32(fp)
 2032d80:	10c00517 	ldw	r3,20(r2)
 2032d84:	e0bffe17 	ldw	r2,-8(fp)
 2032d88:	11000303 	ldbu	r4,12(r2)
 2032d8c:	11400343 	ldbu	r5,13(r2)
 2032d90:	280a923a 	slli	r5,r5,8
 2032d94:	2908b03a 	or	r4,r5,r4
 2032d98:	11400383 	ldbu	r5,14(r2)
 2032d9c:	280a943a 	slli	r5,r5,16
 2032da0:	2908b03a 	or	r4,r5,r4
 2032da4:	108003c3 	ldbu	r2,15(r2)
 2032da8:	1004963a 	slli	r2,r2,24
 2032dac:	1104b03a 	or	r2,r2,r4
 2032db0:	1880181e 	bne	r3,r2,2032e14 <ip_reass_remove_oldest_datagram+0xcc>
 2032db4:	e0bff817 	ldw	r2,-32(fp)
 2032db8:	10c00617 	ldw	r3,24(r2)
 2032dbc:	e0bffe17 	ldw	r2,-8(fp)
 2032dc0:	11000403 	ldbu	r4,16(r2)
 2032dc4:	11400443 	ldbu	r5,17(r2)
 2032dc8:	280a923a 	slli	r5,r5,8
 2032dcc:	2908b03a 	or	r4,r5,r4
 2032dd0:	11400483 	ldbu	r5,18(r2)
 2032dd4:	280a943a 	slli	r5,r5,16
 2032dd8:	2908b03a 	or	r4,r5,r4
 2032ddc:	108004c3 	ldbu	r2,19(r2)
 2032de0:	1004963a 	slli	r2,r2,24
 2032de4:	1104b03a 	or	r2,r2,r4
 2032de8:	18800a1e 	bne	r3,r2,2032e14 <ip_reass_remove_oldest_datagram+0xcc>
 2032dec:	e0bff817 	ldw	r2,-32(fp)
 2032df0:	1100030b 	ldhu	r4,12(r2)
 2032df4:	e0bffe17 	ldw	r2,-8(fp)
 2032df8:	10c00103 	ldbu	r3,4(r2)
 2032dfc:	10800143 	ldbu	r2,5(r2)
 2032e00:	1004923a 	slli	r2,r2,8
 2032e04:	10c4b03a 	or	r2,r2,r3
 2032e08:	20ffffcc 	andi	r3,r4,65535
 2032e0c:	10bfffcc 	andi	r2,r2,65535
 2032e10:	18801126 	beq	r3,r2,2032e58 <ip_reass_remove_oldest_datagram+0x110>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 2032e14:	e0bffc17 	ldw	r2,-16(fp)
 2032e18:	10800044 	addi	r2,r2,1
 2032e1c:	e0bffc15 	stw	r2,-16(fp)
        if (oldest == NULL) {
 2032e20:	e0bff917 	ldw	r2,-28(fp)
 2032e24:	1000031e 	bne	r2,zero,2032e34 <ip_reass_remove_oldest_datagram+0xec>
          oldest = r;
 2032e28:	e0bff817 	ldw	r2,-32(fp)
 2032e2c:	e0bff915 	stw	r2,-28(fp)
 2032e30:	00000906 	br	2032e58 <ip_reass_remove_oldest_datagram+0x110>
        } else if (r->timer <= oldest->timer) {
 2032e34:	e0bff817 	ldw	r2,-32(fp)
 2032e38:	110007c3 	ldbu	r4,31(r2)
 2032e3c:	e0bff917 	ldw	r2,-28(fp)
 2032e40:	10c007c3 	ldbu	r3,31(r2)
 2032e44:	20803fcc 	andi	r2,r4,255
 2032e48:	18c03fcc 	andi	r3,r3,255
 2032e4c:	18800236 	bltu	r3,r2,2032e58 <ip_reass_remove_oldest_datagram+0x110>
          /* older than the previous oldest */
          oldest = r;
 2032e50:	e0bff817 	ldw	r2,-32(fp)
 2032e54:	e0bff915 	stw	r2,-28(fp)
        }
      }
      if (r->next != NULL) {
 2032e58:	e0bff817 	ldw	r2,-32(fp)
 2032e5c:	10800017 	ldw	r2,0(r2)
 2032e60:	10000226 	beq	r2,zero,2032e6c <ip_reass_remove_oldest_datagram+0x124>
        prev = r;
 2032e64:	e0bff817 	ldw	r2,-32(fp)
 2032e68:	e0bffa15 	stw	r2,-24(fp)
      }
      r = r->next;
 2032e6c:	e0bff817 	ldw	r2,-32(fp)
 2032e70:	10800017 	ldw	r2,0(r2)
 2032e74:	e0bff815 	stw	r2,-32(fp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
 2032e78:	e0bff817 	ldw	r2,-32(fp)
 2032e7c:	103fbf1e 	bne	r2,zero,2032d7c <__alt_mem_mem_0+0xfd012d7c>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 2032e80:	e0bff917 	ldw	r2,-28(fp)
 2032e84:	10000826 	beq	r2,zero,2032ea8 <ip_reass_remove_oldest_datagram+0x160>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 2032e88:	e17ffa17 	ldw	r5,-24(fp)
 2032e8c:	e13ff917 	ldw	r4,-28(fp)
 2032e90:	2032bb80 	call	2032bb8 <ip_reass_free_complete_datagram>
 2032e94:	e0bffd15 	stw	r2,-12(fp)
      pbufs_freed += pbufs_freed_current;
 2032e98:	e0fffb17 	ldw	r3,-20(fp)
 2032e9c:	e0bffd17 	ldw	r2,-12(fp)
 2032ea0:	1885883a 	add	r2,r3,r2
 2032ea4:	e0bffb15 	stw	r2,-20(fp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 2032ea8:	e0fffb17 	ldw	r3,-20(fp)
 2032eac:	e0bfff17 	ldw	r2,-4(fp)
 2032eb0:	1880030e 	bge	r3,r2,2032ec0 <ip_reass_remove_oldest_datagram+0x178>
 2032eb4:	e0bffc17 	ldw	r2,-16(fp)
 2032eb8:	10800088 	cmpgei	r2,r2,2
 2032ebc:	103fa91e 	bne	r2,zero,2032d64 <__alt_mem_mem_0+0xfd012d64>
  return pbufs_freed;
 2032ec0:	e0bffb17 	ldw	r2,-20(fp)
}
 2032ec4:	e037883a 	mov	sp,fp
 2032ec8:	dfc00117 	ldw	ra,4(sp)
 2032ecc:	df000017 	ldw	fp,0(sp)
 2032ed0:	dec00204 	addi	sp,sp,8
 2032ed4:	f800283a 	ret

02032ed8 <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 2032ed8:	defffb04 	addi	sp,sp,-20
 2032edc:	dfc00415 	stw	ra,16(sp)
 2032ee0:	df000315 	stw	fp,12(sp)
 2032ee4:	df000304 	addi	fp,sp,12
 2032ee8:	e13ffe15 	stw	r4,-8(fp)
 2032eec:	e17fff15 	stw	r5,-4(fp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 2032ef0:	01000144 	movi	r4,5
 2032ef4:	20344340 	call	2034434 <memp_malloc>
 2032ef8:	e0bffd15 	stw	r2,-12(fp)
  if (ipr == NULL) {
 2032efc:	e0bffd17 	ldw	r2,-12(fp)
 2032f00:	1000141e 	bne	r2,zero,2032f54 <ip_reass_enqueue_new_datagram+0x7c>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 2032f04:	e17fff17 	ldw	r5,-4(fp)
 2032f08:	e13ffe17 	ldw	r4,-8(fp)
 2032f0c:	2032d480 	call	2032d48 <ip_reass_remove_oldest_datagram>
 2032f10:	1007883a 	mov	r3,r2
 2032f14:	e0bfff17 	ldw	r2,-4(fp)
 2032f18:	18800316 	blt	r3,r2,2032f28 <ip_reass_enqueue_new_datagram+0x50>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 2032f1c:	01000144 	movi	r4,5
 2032f20:	20344340 	call	2034434 <memp_malloc>
 2032f24:	e0bffd15 	stw	r2,-12(fp)
    }
    if (ipr == NULL)
 2032f28:	e0bffd17 	ldw	r2,-12(fp)
 2032f2c:	1000091e 	bne	r2,zero,2032f54 <ip_reass_enqueue_new_datagram+0x7c>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
 2032f30:	008085f4 	movhi	r2,535
 2032f34:	10a8bc04 	addi	r2,r2,-23824
 2032f38:	10801e17 	ldw	r2,120(r2)
 2032f3c:	10c00044 	addi	r3,r2,1
 2032f40:	008085f4 	movhi	r2,535
 2032f44:	10a8bc04 	addi	r2,r2,-23824
 2032f48:	10c01e15 	stw	r3,120(r2)
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
 2032f4c:	0005883a 	mov	r2,zero
 2032f50:	00001306 	br	2032fa0 <ip_reass_enqueue_new_datagram+0xc8>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 2032f54:	01800804 	movi	r6,32
 2032f58:	000b883a 	mov	r5,zero
 2032f5c:	e13ffd17 	ldw	r4,-12(fp)
 2032f60:	200616c0 	call	200616c <memset>
  ipr->timer = IP_REASS_MAXAGE;
 2032f64:	e0bffd17 	ldw	r2,-12(fp)
 2032f68:	00c000c4 	movi	r3,3
 2032f6c:	10c007c5 	stb	r3,31(r2)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 2032f70:	d0e81617 	ldw	r3,-24488(gp)
 2032f74:	e0bffd17 	ldw	r2,-12(fp)
 2032f78:	10c00015 	stw	r3,0(r2)
  reassdatagrams = ipr;
 2032f7c:	e0bffd17 	ldw	r2,-12(fp)
 2032f80:	d0a81615 	stw	r2,-24488(gp)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 2032f84:	e0bffd17 	ldw	r2,-12(fp)
 2032f88:	10800204 	addi	r2,r2,8
 2032f8c:	01800504 	movi	r6,20
 2032f90:	e17ffe17 	ldw	r5,-8(fp)
 2032f94:	1009883a 	mov	r4,r2
 2032f98:	20060240 	call	2006024 <memcpy>
  return ipr;
 2032f9c:	e0bffd17 	ldw	r2,-12(fp)
}
 2032fa0:	e037883a 	mov	sp,fp
 2032fa4:	dfc00117 	ldw	ra,4(sp)
 2032fa8:	df000017 	ldw	fp,0(sp)
 2032fac:	dec00204 	addi	sp,sp,8
 2032fb0:	f800283a 	ret

02032fb4 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 2032fb4:	defffc04 	addi	sp,sp,-16
 2032fb8:	dfc00315 	stw	ra,12(sp)
 2032fbc:	df000215 	stw	fp,8(sp)
 2032fc0:	df000204 	addi	fp,sp,8
 2032fc4:	e13ffe15 	stw	r4,-8(fp)
 2032fc8:	e17fff15 	stw	r5,-4(fp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 2032fcc:	d0e81617 	ldw	r3,-24488(gp)
 2032fd0:	e0bffe17 	ldw	r2,-8(fp)
 2032fd4:	1880041e 	bne	r3,r2,2032fe8 <ip_reass_dequeue_datagram+0x34>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 2032fd8:	e0bffe17 	ldw	r2,-8(fp)
 2032fdc:	10800017 	ldw	r2,0(r2)
 2032fe0:	d0a81615 	stw	r2,-24488(gp)
 2032fe4:	00000406 	br	2032ff8 <ip_reass_dequeue_datagram+0x44>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 2032fe8:	e0bffe17 	ldw	r2,-8(fp)
 2032fec:	10c00017 	ldw	r3,0(r2)
 2032ff0:	e0bfff17 	ldw	r2,-4(fp)
 2032ff4:	10c00015 	stw	r3,0(r2)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 2032ff8:	e17ffe17 	ldw	r5,-8(fp)
 2032ffc:	01000144 	movi	r4,5
 2033000:	20346000 	call	2034600 <memp_free>
}
 2033004:	0001883a 	nop
 2033008:	e037883a 	mov	sp,fp
 203300c:	dfc00117 	ldw	ra,4(sp)
 2033010:	df000017 	ldw	fp,0(sp)
 2033014:	dec00204 	addi	sp,sp,8
 2033018:	f800283a 	ret

0203301c <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
 203301c:	defff504 	addi	sp,sp,-44
 2033020:	dfc00a15 	stw	ra,40(sp)
 2033024:	df000915 	stw	fp,36(sp)
 2033028:	df000904 	addi	fp,sp,36
 203302c:	e13ffe15 	stw	r4,-8(fp)
 2033030:	e17fff15 	stw	r5,-4(fp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
 2033034:	e03ff715 	stw	zero,-36(fp)
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
 2033038:	00800044 	movi	r2,1
 203303c:	e0bff915 	stw	r2,-28(fp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 2033040:	e0bfff17 	ldw	r2,-4(fp)
 2033044:	10800117 	ldw	r2,4(r2)
 2033048:	e0bffa15 	stw	r2,-24(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 203304c:	e0bffa17 	ldw	r2,-24(fp)
 2033050:	10c00083 	ldbu	r3,2(r2)
 2033054:	108000c3 	ldbu	r2,3(r2)
 2033058:	1004923a 	slli	r2,r2,8
 203305c:	10c4b03a 	or	r2,r2,r3
 2033060:	10bfffcc 	andi	r2,r2,65535
 2033064:	1004d23a 	srli	r2,r2,8
 2033068:	1009883a 	mov	r4,r2
 203306c:	e0bffa17 	ldw	r2,-24(fp)
 2033070:	10c00083 	ldbu	r3,2(r2)
 2033074:	108000c3 	ldbu	r2,3(r2)
 2033078:	1004923a 	slli	r2,r2,8
 203307c:	10c4b03a 	or	r2,r2,r3
 2033080:	10bfffcc 	andi	r2,r2,65535
 2033084:	1004923a 	slli	r2,r2,8
 2033088:	2084b03a 	or	r2,r4,r2
 203308c:	1007883a 	mov	r3,r2
 2033090:	e0bffa17 	ldw	r2,-24(fp)
 2033094:	10800003 	ldbu	r2,0(r2)
 2033098:	10803fcc 	andi	r2,r2,255
 203309c:	108003cc 	andi	r2,r2,15
 20330a0:	1085883a 	add	r2,r2,r2
 20330a4:	1085883a 	add	r2,r2,r2
 20330a8:	1885c83a 	sub	r2,r3,r2
 20330ac:	e0bffb0d 	sth	r2,-20(fp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 20330b0:	e0bffa17 	ldw	r2,-24(fp)
 20330b4:	10c00183 	ldbu	r3,6(r2)
 20330b8:	108001c3 	ldbu	r2,7(r2)
 20330bc:	1004923a 	slli	r2,r2,8
 20330c0:	10c4b03a 	or	r2,r2,r3
 20330c4:	10bfffcc 	andi	r2,r2,65535
 20330c8:	1004d23a 	srli	r2,r2,8
 20330cc:	10ffffcc 	andi	r3,r2,65535
 20330d0:	e0bffa17 	ldw	r2,-24(fp)
 20330d4:	11000183 	ldbu	r4,6(r2)
 20330d8:	108001c3 	ldbu	r2,7(r2)
 20330dc:	1004923a 	slli	r2,r2,8
 20330e0:	1104b03a 	or	r2,r2,r4
 20330e4:	10bfffcc 	andi	r2,r2,65535
 20330e8:	1004923a 	slli	r2,r2,8
 20330ec:	10bfffcc 	andi	r2,r2,65535
 20330f0:	1884b03a 	or	r2,r3,r2
 20330f4:	1087ffcc 	andi	r2,r2,8191
 20330f8:	100490fa 	slli	r2,r2,3
 20330fc:	e0bffb8d 	sth	r2,-18(fp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 2033100:	e0bfff17 	ldw	r2,-4(fp)
 2033104:	10800117 	ldw	r2,4(r2)
 2033108:	e0bffc15 	stw	r2,-16(fp)
  iprh->next_pbuf = NULL;
 203310c:	e0bffc17 	ldw	r2,-16(fp)
 2033110:	10c00003 	ldbu	r3,0(r2)
 2033114:	1806703a 	and	r3,r3,zero
 2033118:	10c00005 	stb	r3,0(r2)
 203311c:	10c00043 	ldbu	r3,1(r2)
 2033120:	1806703a 	and	r3,r3,zero
 2033124:	10c00045 	stb	r3,1(r2)
 2033128:	10c00083 	ldbu	r3,2(r2)
 203312c:	1806703a 	and	r3,r3,zero
 2033130:	10c00085 	stb	r3,2(r2)
 2033134:	10c000c3 	ldbu	r3,3(r2)
 2033138:	1806703a 	and	r3,r3,zero
 203313c:	10c000c5 	stb	r3,3(r2)
  iprh->start = offset;
 2033140:	e0bffc17 	ldw	r2,-16(fp)
 2033144:	e0fffb8b 	ldhu	r3,-18(fp)
 2033148:	19403fcc 	andi	r5,r3,255
 203314c:	10c00103 	ldbu	r3,4(r2)
 2033150:	1806703a 	and	r3,r3,zero
 2033154:	1809883a 	mov	r4,r3
 2033158:	2807883a 	mov	r3,r5
 203315c:	20c6b03a 	or	r3,r4,r3
 2033160:	10c00105 	stb	r3,4(r2)
 2033164:	e0fffb8b 	ldhu	r3,-18(fp)
 2033168:	1806d23a 	srli	r3,r3,8
 203316c:	197fffcc 	andi	r5,r3,65535
 2033170:	10c00143 	ldbu	r3,5(r2)
 2033174:	1806703a 	and	r3,r3,zero
 2033178:	1809883a 	mov	r4,r3
 203317c:	2807883a 	mov	r3,r5
 2033180:	20c6b03a 	or	r3,r4,r3
 2033184:	10c00145 	stb	r3,5(r2)
  iprh->end = offset + len;
 2033188:	e0fffb8b 	ldhu	r3,-18(fp)
 203318c:	e0bffb0b 	ldhu	r2,-20(fp)
 2033190:	1885883a 	add	r2,r3,r2
 2033194:	100d883a 	mov	r6,r2
 2033198:	e0bffc17 	ldw	r2,-16(fp)
 203319c:	30ffffcc 	andi	r3,r6,65535
 20331a0:	19403fcc 	andi	r5,r3,255
 20331a4:	10c00183 	ldbu	r3,6(r2)
 20331a8:	1806703a 	and	r3,r3,zero
 20331ac:	1809883a 	mov	r4,r3
 20331b0:	2807883a 	mov	r3,r5
 20331b4:	20c6b03a 	or	r3,r4,r3
 20331b8:	10c00185 	stb	r3,6(r2)
 20331bc:	30ffffcc 	andi	r3,r6,65535
 20331c0:	1806d23a 	srli	r3,r3,8
 20331c4:	197fffcc 	andi	r5,r3,65535
 20331c8:	10c001c3 	ldbu	r3,7(r2)
 20331cc:	1806703a 	and	r3,r3,zero
 20331d0:	1809883a 	mov	r4,r3
 20331d4:	2807883a 	mov	r3,r5
 20331d8:	20c6b03a 	or	r3,r4,r3
 20331dc:	10c001c5 	stb	r3,7(r2)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 20331e0:	e0bffe17 	ldw	r2,-8(fp)
 20331e4:	10800117 	ldw	r2,4(r2)
 20331e8:	e0bff815 	stw	r2,-32(fp)
 20331ec:	0000b606 	br	20334c8 <ip_reass_chain_frag_into_datagram_and_validate+0x4ac>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 20331f0:	e0bff817 	ldw	r2,-32(fp)
 20331f4:	10800117 	ldw	r2,4(r2)
 20331f8:	e0bffd15 	stw	r2,-12(fp)
    if (iprh->start < iprh_tmp->start) {
 20331fc:	e0bffc17 	ldw	r2,-16(fp)
 2033200:	10c00103 	ldbu	r3,4(r2)
 2033204:	10800143 	ldbu	r2,5(r2)
 2033208:	1004923a 	slli	r2,r2,8
 203320c:	10c4b03a 	or	r2,r2,r3
 2033210:	1009883a 	mov	r4,r2
 2033214:	e0bffd17 	ldw	r2,-12(fp)
 2033218:	10c00103 	ldbu	r3,4(r2)
 203321c:	10800143 	ldbu	r2,5(r2)
 2033220:	1004923a 	slli	r2,r2,8
 2033224:	10c4b03a 	or	r2,r2,r3
 2033228:	20ffffcc 	andi	r3,r4,65535
 203322c:	10bfffcc 	andi	r2,r2,65535
 2033230:	18806a2e 	bgeu	r3,r2,20333dc <ip_reass_chain_frag_into_datagram_and_validate+0x3c0>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 2033234:	e0bffc17 	ldw	r2,-16(fp)
 2033238:	e0fff817 	ldw	r3,-32(fp)
 203323c:	19403fcc 	andi	r5,r3,255
 2033240:	10c00003 	ldbu	r3,0(r2)
 2033244:	1806703a 	and	r3,r3,zero
 2033248:	1809883a 	mov	r4,r3
 203324c:	2807883a 	mov	r3,r5
 2033250:	20c6b03a 	or	r3,r4,r3
 2033254:	10c00005 	stb	r3,0(r2)
 2033258:	e0fff817 	ldw	r3,-32(fp)
 203325c:	1806d23a 	srli	r3,r3,8
 2033260:	19403fcc 	andi	r5,r3,255
 2033264:	10c00043 	ldbu	r3,1(r2)
 2033268:	1806703a 	and	r3,r3,zero
 203326c:	1809883a 	mov	r4,r3
 2033270:	2807883a 	mov	r3,r5
 2033274:	20c6b03a 	or	r3,r4,r3
 2033278:	10c00045 	stb	r3,1(r2)
 203327c:	e0fff817 	ldw	r3,-32(fp)
 2033280:	1806d43a 	srli	r3,r3,16
 2033284:	19403fcc 	andi	r5,r3,255
 2033288:	10c00083 	ldbu	r3,2(r2)
 203328c:	1806703a 	and	r3,r3,zero
 2033290:	1809883a 	mov	r4,r3
 2033294:	2807883a 	mov	r3,r5
 2033298:	20c6b03a 	or	r3,r4,r3
 203329c:	10c00085 	stb	r3,2(r2)
 20332a0:	e0fff817 	ldw	r3,-32(fp)
 20332a4:	180ad63a 	srli	r5,r3,24
 20332a8:	10c000c3 	ldbu	r3,3(r2)
 20332ac:	1806703a 	and	r3,r3,zero
 20332b0:	1809883a 	mov	r4,r3
 20332b4:	2807883a 	mov	r3,r5
 20332b8:	20c6b03a 	or	r3,r4,r3
 20332bc:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev != NULL) {
 20332c0:	e0bff717 	ldw	r2,-36(fp)
 20332c4:	10004126 	beq	r2,zero,20333cc <ip_reass_chain_frag_into_datagram_and_validate+0x3b0>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 20332c8:	e0bffc17 	ldw	r2,-16(fp)
 20332cc:	10c00103 	ldbu	r3,4(r2)
 20332d0:	10800143 	ldbu	r2,5(r2)
 20332d4:	1004923a 	slli	r2,r2,8
 20332d8:	10c4b03a 	or	r2,r2,r3
 20332dc:	1009883a 	mov	r4,r2
 20332e0:	e0bff717 	ldw	r2,-36(fp)
 20332e4:	10c00183 	ldbu	r3,6(r2)
 20332e8:	108001c3 	ldbu	r2,7(r2)
 20332ec:	1004923a 	slli	r2,r2,8
 20332f0:	10c4b03a 	or	r2,r2,r3
 20332f4:	20ffffcc 	andi	r3,r4,65535
 20332f8:	10bfffcc 	andi	r2,r2,65535
 20332fc:	1880f936 	bltu	r3,r2,20336e4 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
 2033300:	e0bffc17 	ldw	r2,-16(fp)
 2033304:	10c00183 	ldbu	r3,6(r2)
 2033308:	108001c3 	ldbu	r2,7(r2)
 203330c:	1004923a 	slli	r2,r2,8
 2033310:	10c4b03a 	or	r2,r2,r3
 2033314:	1009883a 	mov	r4,r2
 2033318:	e0bffd17 	ldw	r2,-12(fp)
 203331c:	10c00103 	ldbu	r3,4(r2)
 2033320:	10800143 	ldbu	r2,5(r2)
 2033324:	1004923a 	slli	r2,r2,8
 2033328:	10c4b03a 	or	r2,r2,r3
 203332c:	1007883a 	mov	r3,r2
 2033330:	20bfffcc 	andi	r2,r4,65535
 2033334:	18ffffcc 	andi	r3,r3,65535
 2033338:	1880ea36 	bltu	r3,r2,20336e4 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 203333c:	e0bff717 	ldw	r2,-36(fp)
 2033340:	e0ffff17 	ldw	r3,-4(fp)
 2033344:	19403fcc 	andi	r5,r3,255
 2033348:	10c00003 	ldbu	r3,0(r2)
 203334c:	1806703a 	and	r3,r3,zero
 2033350:	1809883a 	mov	r4,r3
 2033354:	2807883a 	mov	r3,r5
 2033358:	20c6b03a 	or	r3,r4,r3
 203335c:	10c00005 	stb	r3,0(r2)
 2033360:	e0ffff17 	ldw	r3,-4(fp)
 2033364:	1806d23a 	srli	r3,r3,8
 2033368:	19403fcc 	andi	r5,r3,255
 203336c:	10c00043 	ldbu	r3,1(r2)
 2033370:	1806703a 	and	r3,r3,zero
 2033374:	1809883a 	mov	r4,r3
 2033378:	2807883a 	mov	r3,r5
 203337c:	20c6b03a 	or	r3,r4,r3
 2033380:	10c00045 	stb	r3,1(r2)
 2033384:	e0ffff17 	ldw	r3,-4(fp)
 2033388:	1806d43a 	srli	r3,r3,16
 203338c:	19403fcc 	andi	r5,r3,255
 2033390:	10c00083 	ldbu	r3,2(r2)
 2033394:	1806703a 	and	r3,r3,zero
 2033398:	1809883a 	mov	r4,r3
 203339c:	2807883a 	mov	r3,r5
 20333a0:	20c6b03a 	or	r3,r4,r3
 20333a4:	10c00085 	stb	r3,2(r2)
 20333a8:	e0ffff17 	ldw	r3,-4(fp)
 20333ac:	180ad63a 	srli	r5,r3,24
 20333b0:	10c000c3 	ldbu	r3,3(r2)
 20333b4:	1806703a 	and	r3,r3,zero
 20333b8:	1809883a 	mov	r4,r3
 20333bc:	2807883a 	mov	r3,r5
 20333c0:	20c6b03a 	or	r3,r4,r3
 20333c4:	10c000c5 	stb	r3,3(r2)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 20333c8:	00004106 	br	20334d0 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 20333cc:	e0bffe17 	ldw	r2,-8(fp)
 20333d0:	e0ffff17 	ldw	r3,-4(fp)
 20333d4:	10c00115 	stw	r3,4(r2)
      }
      break;
 20333d8:	00003d06 	br	20334d0 <ip_reass_chain_frag_into_datagram_and_validate+0x4b4>
    } else if(iprh->start == iprh_tmp->start) {
 20333dc:	e0bffc17 	ldw	r2,-16(fp)
 20333e0:	10c00103 	ldbu	r3,4(r2)
 20333e4:	10800143 	ldbu	r2,5(r2)
 20333e8:	1004923a 	slli	r2,r2,8
 20333ec:	10c4b03a 	or	r2,r2,r3
 20333f0:	1009883a 	mov	r4,r2
 20333f4:	e0bffd17 	ldw	r2,-12(fp)
 20333f8:	10c00103 	ldbu	r3,4(r2)
 20333fc:	10800143 	ldbu	r2,5(r2)
 2033400:	1004923a 	slli	r2,r2,8
 2033404:	10c4b03a 	or	r2,r2,r3
 2033408:	20ffffcc 	andi	r3,r4,65535
 203340c:	10bfffcc 	andi	r2,r2,65535
 2033410:	1880b126 	beq	r3,r2,20336d8 <ip_reass_chain_frag_into_datagram_and_validate+0x6bc>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 2033414:	e0bffc17 	ldw	r2,-16(fp)
 2033418:	10c00103 	ldbu	r3,4(r2)
 203341c:	10800143 	ldbu	r2,5(r2)
 2033420:	1004923a 	slli	r2,r2,8
 2033424:	10c4b03a 	or	r2,r2,r3
 2033428:	1009883a 	mov	r4,r2
 203342c:	e0bffd17 	ldw	r2,-12(fp)
 2033430:	10c00183 	ldbu	r3,6(r2)
 2033434:	108001c3 	ldbu	r2,7(r2)
 2033438:	1004923a 	slli	r2,r2,8
 203343c:	10c4b03a 	or	r2,r2,r3
 2033440:	20ffffcc 	andi	r3,r4,65535
 2033444:	10bfffcc 	andi	r2,r2,65535
 2033448:	1880a536 	bltu	r3,r2,20336e0 <ip_reass_chain_frag_into_datagram_and_validate+0x6c4>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 203344c:	e0bff717 	ldw	r2,-36(fp)
 2033450:	10000f26 	beq	r2,zero,2033490 <ip_reass_chain_frag_into_datagram_and_validate+0x474>
        if (iprh_prev->end != iprh_tmp->start) {
 2033454:	e0bff717 	ldw	r2,-36(fp)
 2033458:	10c00183 	ldbu	r3,6(r2)
 203345c:	108001c3 	ldbu	r2,7(r2)
 2033460:	1004923a 	slli	r2,r2,8
 2033464:	10c4b03a 	or	r2,r2,r3
 2033468:	1009883a 	mov	r4,r2
 203346c:	e0bffd17 	ldw	r2,-12(fp)
 2033470:	10c00103 	ldbu	r3,4(r2)
 2033474:	10800143 	ldbu	r2,5(r2)
 2033478:	1004923a 	slli	r2,r2,8
 203347c:	10c4b03a 	or	r2,r2,r3
 2033480:	20ffffcc 	andi	r3,r4,65535
 2033484:	10bfffcc 	andi	r2,r2,65535
 2033488:	18800126 	beq	r3,r2,2033490 <ip_reass_chain_frag_into_datagram_and_validate+0x474>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 203348c:	e03ff915 	stw	zero,-28(fp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 2033490:	e0bffd17 	ldw	r2,-12(fp)
 2033494:	10c00003 	ldbu	r3,0(r2)
 2033498:	11000043 	ldbu	r4,1(r2)
 203349c:	2008923a 	slli	r4,r4,8
 20334a0:	20c6b03a 	or	r3,r4,r3
 20334a4:	11000083 	ldbu	r4,2(r2)
 20334a8:	2008943a 	slli	r4,r4,16
 20334ac:	20c6b03a 	or	r3,r4,r3
 20334b0:	108000c3 	ldbu	r2,3(r2)
 20334b4:	1004963a 	slli	r2,r2,24
 20334b8:	10c4b03a 	or	r2,r2,r3
 20334bc:	e0bff815 	stw	r2,-32(fp)
    iprh_prev = iprh_tmp;
 20334c0:	e0bffd17 	ldw	r2,-12(fp)
 20334c4:	e0bff715 	stw	r2,-36(fp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 20334c8:	e0bff817 	ldw	r2,-32(fp)
 20334cc:	103f481e 	bne	r2,zero,20331f0 <__alt_mem_mem_0+0xfd0131f0>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 20334d0:	e0bff817 	ldw	r2,-32(fp)
 20334d4:	1000381e 	bne	r2,zero,20335b8 <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
    if (iprh_prev != NULL) {
 20334d8:	e0bff717 	ldw	r2,-36(fp)
 20334dc:	10003326 	beq	r2,zero,20335ac <ip_reass_chain_frag_into_datagram_and_validate+0x590>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 20334e0:	e0bff717 	ldw	r2,-36(fp)
 20334e4:	e0ffff17 	ldw	r3,-4(fp)
 20334e8:	19403fcc 	andi	r5,r3,255
 20334ec:	10c00003 	ldbu	r3,0(r2)
 20334f0:	1806703a 	and	r3,r3,zero
 20334f4:	1809883a 	mov	r4,r3
 20334f8:	2807883a 	mov	r3,r5
 20334fc:	20c6b03a 	or	r3,r4,r3
 2033500:	10c00005 	stb	r3,0(r2)
 2033504:	e0ffff17 	ldw	r3,-4(fp)
 2033508:	1806d23a 	srli	r3,r3,8
 203350c:	19403fcc 	andi	r5,r3,255
 2033510:	10c00043 	ldbu	r3,1(r2)
 2033514:	1806703a 	and	r3,r3,zero
 2033518:	1809883a 	mov	r4,r3
 203351c:	2807883a 	mov	r3,r5
 2033520:	20c6b03a 	or	r3,r4,r3
 2033524:	10c00045 	stb	r3,1(r2)
 2033528:	e0ffff17 	ldw	r3,-4(fp)
 203352c:	1806d43a 	srli	r3,r3,16
 2033530:	19403fcc 	andi	r5,r3,255
 2033534:	10c00083 	ldbu	r3,2(r2)
 2033538:	1806703a 	and	r3,r3,zero
 203353c:	1809883a 	mov	r4,r3
 2033540:	2807883a 	mov	r3,r5
 2033544:	20c6b03a 	or	r3,r4,r3
 2033548:	10c00085 	stb	r3,2(r2)
 203354c:	e0ffff17 	ldw	r3,-4(fp)
 2033550:	180ad63a 	srli	r5,r3,24
 2033554:	10c000c3 	ldbu	r3,3(r2)
 2033558:	1806703a 	and	r3,r3,zero
 203355c:	1809883a 	mov	r4,r3
 2033560:	2807883a 	mov	r3,r5
 2033564:	20c6b03a 	or	r3,r4,r3
 2033568:	10c000c5 	stb	r3,3(r2)
      if (iprh_prev->end != iprh->start) {
 203356c:	e0bff717 	ldw	r2,-36(fp)
 2033570:	10c00183 	ldbu	r3,6(r2)
 2033574:	108001c3 	ldbu	r2,7(r2)
 2033578:	1004923a 	slli	r2,r2,8
 203357c:	10c4b03a 	or	r2,r2,r3
 2033580:	1009883a 	mov	r4,r2
 2033584:	e0bffc17 	ldw	r2,-16(fp)
 2033588:	10c00103 	ldbu	r3,4(r2)
 203358c:	10800143 	ldbu	r2,5(r2)
 2033590:	1004923a 	slli	r2,r2,8
 2033594:	10c4b03a 	or	r2,r2,r3
 2033598:	20ffffcc 	andi	r3,r4,65535
 203359c:	10bfffcc 	andi	r2,r2,65535
 20335a0:	18800526 	beq	r3,r2,20335b8 <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
        valid = 0;
 20335a4:	e03ff915 	stw	zero,-28(fp)
 20335a8:	00000306 	br	20335b8 <ip_reass_chain_frag_into_datagram_and_validate+0x59c>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 20335ac:	e0bffe17 	ldw	r2,-8(fp)
 20335b0:	e0ffff17 	ldw	r3,-4(fp)
 20335b4:	10c00115 	stw	r3,4(r2)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 20335b8:	e0bffe17 	ldw	r2,-8(fp)
 20335bc:	10800783 	ldbu	r2,30(r2)
 20335c0:	10803fcc 	andi	r2,r2,255
 20335c4:	1080004c 	andi	r2,r2,1
 20335c8:	10004126 	beq	r2,zero,20336d0 <ip_reass_chain_frag_into_datagram_and_validate+0x6b4>
    /* and had no wholes so far */
    if (valid) {
 20335cc:	e0bff917 	ldw	r2,-28(fp)
 20335d0:	10003d26 	beq	r2,zero,20336c8 <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 20335d4:	e0bffe17 	ldw	r2,-8(fp)
 20335d8:	10800117 	ldw	r2,4(r2)
 20335dc:	10800117 	ldw	r2,4(r2)
 20335e0:	10c00103 	ldbu	r3,4(r2)
 20335e4:	10800143 	ldbu	r2,5(r2)
 20335e8:	1004923a 	slli	r2,r2,8
 20335ec:	10c4b03a 	or	r2,r2,r3
 20335f0:	10bfffcc 	andi	r2,r2,65535
 20335f4:	10000226 	beq	r2,zero,2033600 <ip_reass_chain_frag_into_datagram_and_validate+0x5e4>
        valid = 0;
 20335f8:	e03ff915 	stw	zero,-28(fp)
 20335fc:	00003206 	br	20336c8 <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
 2033600:	e0bffc17 	ldw	r2,-16(fp)
 2033604:	e0bff715 	stw	r2,-36(fp)
        q = iprh->next_pbuf;
 2033608:	e0bffc17 	ldw	r2,-16(fp)
 203360c:	10c00003 	ldbu	r3,0(r2)
 2033610:	11000043 	ldbu	r4,1(r2)
 2033614:	2008923a 	slli	r4,r4,8
 2033618:	20c6b03a 	or	r3,r4,r3
 203361c:	11000083 	ldbu	r4,2(r2)
 2033620:	2008943a 	slli	r4,r4,16
 2033624:	20c6b03a 	or	r3,r4,r3
 2033628:	108000c3 	ldbu	r2,3(r2)
 203362c:	1004963a 	slli	r2,r2,24
 2033630:	10c4b03a 	or	r2,r2,r3
 2033634:	e0bff815 	stw	r2,-32(fp)
        while (q != NULL) {
 2033638:	00002106 	br	20336c0 <ip_reass_chain_frag_into_datagram_and_validate+0x6a4>
          iprh = (struct ip_reass_helper*)q->payload;
 203363c:	e0bff817 	ldw	r2,-32(fp)
 2033640:	10800117 	ldw	r2,4(r2)
 2033644:	e0bffc15 	stw	r2,-16(fp)
          if (iprh_prev->end != iprh->start) {
 2033648:	e0bff717 	ldw	r2,-36(fp)
 203364c:	10c00183 	ldbu	r3,6(r2)
 2033650:	108001c3 	ldbu	r2,7(r2)
 2033654:	1004923a 	slli	r2,r2,8
 2033658:	10c4b03a 	or	r2,r2,r3
 203365c:	1009883a 	mov	r4,r2
 2033660:	e0bffc17 	ldw	r2,-16(fp)
 2033664:	10c00103 	ldbu	r3,4(r2)
 2033668:	10800143 	ldbu	r2,5(r2)
 203366c:	1004923a 	slli	r2,r2,8
 2033670:	10c4b03a 	or	r2,r2,r3
 2033674:	20ffffcc 	andi	r3,r4,65535
 2033678:	10bfffcc 	andi	r2,r2,65535
 203367c:	18800226 	beq	r3,r2,2033688 <ip_reass_chain_frag_into_datagram_and_validate+0x66c>
            valid = 0;
 2033680:	e03ff915 	stw	zero,-28(fp)
            break;
 2033684:	00001006 	br	20336c8 <ip_reass_chain_frag_into_datagram_and_validate+0x6ac>
          }
          iprh_prev = iprh;
 2033688:	e0bffc17 	ldw	r2,-16(fp)
 203368c:	e0bff715 	stw	r2,-36(fp)
          q = iprh->next_pbuf;
 2033690:	e0bffc17 	ldw	r2,-16(fp)
 2033694:	10c00003 	ldbu	r3,0(r2)
 2033698:	11000043 	ldbu	r4,1(r2)
 203369c:	2008923a 	slli	r4,r4,8
 20336a0:	20c6b03a 	or	r3,r4,r3
 20336a4:	11000083 	ldbu	r4,2(r2)
 20336a8:	2008943a 	slli	r4,r4,16
 20336ac:	20c6b03a 	or	r3,r4,r3
 20336b0:	108000c3 	ldbu	r2,3(r2)
 20336b4:	1004963a 	slli	r2,r2,24
 20336b8:	10c4b03a 	or	r2,r2,r3
 20336bc:	e0bff815 	stw	r2,-32(fp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 20336c0:	e0bff817 	ldw	r2,-32(fp)
 20336c4:	103fdd1e 	bne	r2,zero,203363c <__alt_mem_mem_0+0xfd01363c>
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
 20336c8:	e0bff917 	ldw	r2,-28(fp)
 20336cc:	00000e06 	br	2033708 <ip_reass_chain_frag_into_datagram_and_validate+0x6ec>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
 20336d0:	0005883a 	mov	r2,zero
 20336d4:	00000c06 	br	2033708 <ip_reass_chain_frag_into_datagram_and_validate+0x6ec>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
 20336d8:	0001883a 	nop
 20336dc:	00000106 	br	20336e4 <ip_reass_chain_frag_into_datagram_and_validate+0x6c8>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
 20336e0:	0001883a 	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 20336e4:	e13fff17 	ldw	r4,-4(fp)
 20336e8:	201acac0 	call	201acac <pbuf_clen>
 20336ec:	d0e8170b 	ldhu	r3,-24484(gp)
 20336f0:	10803fcc 	andi	r2,r2,255
 20336f4:	1885c83a 	sub	r2,r3,r2
 20336f8:	d0a8170d 	sth	r2,-24484(gp)
  pbuf_free(new_p);
 20336fc:	e13fff17 	ldw	r4,-4(fp)
 2033700:	201ab680 	call	201ab68 <pbuf_free>
  return 0;
 2033704:	0005883a 	mov	r2,zero
#endif /* IP_REASS_CHECK_OVERLAP */
}
 2033708:	e037883a 	mov	sp,fp
 203370c:	dfc00117 	ldw	ra,4(sp)
 2033710:	df000017 	ldw	fp,0(sp)
 2033714:	dec00204 	addi	sp,sp,8
 2033718:	f800283a 	ret

0203371c <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 203371c:	defff604 	addi	sp,sp,-40
 2033720:	dfc00915 	stw	ra,36(sp)
 2033724:	df000815 	stw	fp,32(sp)
 2033728:	df000804 	addi	fp,sp,32
 203372c:	e13fff15 	stw	r4,-4(fp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
 2033730:	e03ffa15 	stw	zero,-24(fp)

  IPFRAG_STATS_INC(ip_frag.recv);
 2033734:	008085f4 	movhi	r2,535
 2033738:	10a8bc04 	addi	r2,r2,-23824
 203373c:	10801917 	ldw	r2,100(r2)
 2033740:	10c00044 	addi	r3,r2,1
 2033744:	008085f4 	movhi	r2,535
 2033748:	10a8bc04 	addi	r2,r2,-23824
 203374c:	10c01915 	stw	r3,100(r2)
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 2033750:	e0bfff17 	ldw	r2,-4(fp)
 2033754:	10800117 	ldw	r2,4(r2)
 2033758:	e0bffb15 	stw	r2,-20(fp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 203375c:	e0bffb17 	ldw	r2,-20(fp)
 2033760:	10800003 	ldbu	r2,0(r2)
 2033764:	10803fcc 	andi	r2,r2,255
 2033768:	108003cc 	andi	r2,r2,15
 203376c:	1085883a 	add	r2,r2,r2
 2033770:	1085883a 	add	r2,r2,r2
 2033774:	10800520 	cmpeqi	r2,r2,20
 2033778:	1000081e 	bne	r2,zero,203379c <ip_reass+0x80>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
 203377c:	008085f4 	movhi	r2,535
 2033780:	10a8bc04 	addi	r2,r2,-23824
 2033784:	10802217 	ldw	r2,136(r2)
 2033788:	10c00044 	addi	r3,r2,1
 203378c:	008085f4 	movhi	r2,535
 2033790:	10a8bc04 	addi	r2,r2,-23824
 2033794:	10c02215 	stw	r3,136(r2)
    goto nullreturn;
 2033798:	00015406 	br	2033cec <ip_reass+0x5d0>
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 203379c:	e0bffb17 	ldw	r2,-20(fp)
 20337a0:	10c00183 	ldbu	r3,6(r2)
 20337a4:	108001c3 	ldbu	r2,7(r2)
 20337a8:	1004923a 	slli	r2,r2,8
 20337ac:	10c4b03a 	or	r2,r2,r3
 20337b0:	10bfffcc 	andi	r2,r2,65535
 20337b4:	1004d23a 	srli	r2,r2,8
 20337b8:	10ffffcc 	andi	r3,r2,65535
 20337bc:	e0bffb17 	ldw	r2,-20(fp)
 20337c0:	11000183 	ldbu	r4,6(r2)
 20337c4:	108001c3 	ldbu	r2,7(r2)
 20337c8:	1004923a 	slli	r2,r2,8
 20337cc:	1104b03a 	or	r2,r2,r4
 20337d0:	10bfffcc 	andi	r2,r2,65535
 20337d4:	1004923a 	slli	r2,r2,8
 20337d8:	10bfffcc 	andi	r2,r2,65535
 20337dc:	1884b03a 	or	r2,r3,r2
 20337e0:	1087ffcc 	andi	r2,r2,8191
 20337e4:	100490fa 	slli	r2,r2,3
 20337e8:	e0bffc0d 	sth	r2,-16(fp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 20337ec:	e0bffb17 	ldw	r2,-20(fp)
 20337f0:	10c00083 	ldbu	r3,2(r2)
 20337f4:	108000c3 	ldbu	r2,3(r2)
 20337f8:	1004923a 	slli	r2,r2,8
 20337fc:	10c4b03a 	or	r2,r2,r3
 2033800:	10bfffcc 	andi	r2,r2,65535
 2033804:	1004d23a 	srli	r2,r2,8
 2033808:	1009883a 	mov	r4,r2
 203380c:	e0bffb17 	ldw	r2,-20(fp)
 2033810:	10c00083 	ldbu	r3,2(r2)
 2033814:	108000c3 	ldbu	r2,3(r2)
 2033818:	1004923a 	slli	r2,r2,8
 203381c:	10c4b03a 	or	r2,r2,r3
 2033820:	10bfffcc 	andi	r2,r2,65535
 2033824:	1004923a 	slli	r2,r2,8
 2033828:	2084b03a 	or	r2,r4,r2
 203382c:	1007883a 	mov	r3,r2
 2033830:	e0bffb17 	ldw	r2,-20(fp)
 2033834:	10800003 	ldbu	r2,0(r2)
 2033838:	10803fcc 	andi	r2,r2,255
 203383c:	108003cc 	andi	r2,r2,15
 2033840:	1085883a 	add	r2,r2,r2
 2033844:	1085883a 	add	r2,r2,r2
 2033848:	1885c83a 	sub	r2,r3,r2
 203384c:	e0bffc8d 	sth	r2,-14(fp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 2033850:	e13fff17 	ldw	r4,-4(fp)
 2033854:	201acac0 	call	201acac <pbuf_clen>
 2033858:	e0bffd05 	stb	r2,-12(fp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 203385c:	d0a8170b 	ldhu	r2,-24484(gp)
 2033860:	10ffffcc 	andi	r3,r2,65535
 2033864:	e0bffd03 	ldbu	r2,-12(fp)
 2033868:	1885883a 	add	r2,r3,r2
 203386c:	108002d0 	cmplti	r2,r2,11
 2033870:	1000131e 	bne	r2,zero,20338c0 <ip_reass+0x1a4>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 2033874:	e0bffd03 	ldbu	r2,-12(fp)
 2033878:	100b883a 	mov	r5,r2
 203387c:	e13ffb17 	ldw	r4,-20(fp)
 2033880:	2032d480 	call	2032d48 <ip_reass_remove_oldest_datagram>
 2033884:	10000626 	beq	r2,zero,20338a0 <ip_reass+0x184>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 2033888:	d0a8170b 	ldhu	r2,-24484(gp)
 203388c:	10ffffcc 	andi	r3,r2,65535
 2033890:	e0bffd03 	ldbu	r2,-12(fp)
 2033894:	1885883a 	add	r2,r3,r2

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 2033898:	108002d0 	cmplti	r2,r2,11
 203389c:	1000081e 	bne	r2,zero,20338c0 <ip_reass+0x1a4>
#endif /* IP_REASS_FREE_OLDEST */
    {
      /* No datagram could be freed and still too many pbufs enqueued */
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
 20338a0:	008085f4 	movhi	r2,535
 20338a4:	10a8bc04 	addi	r2,r2,-23824
 20338a8:	10801e17 	ldw	r2,120(r2)
 20338ac:	10c00044 	addi	r3,r2,1
 20338b0:	008085f4 	movhi	r2,535
 20338b4:	10a8bc04 	addi	r2,r2,-23824
 20338b8:	10c01e15 	stw	r3,120(r2)
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
 20338bc:	00010b06 	br	2033cec <ip_reass+0x5d0>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 20338c0:	d0a81617 	ldw	r2,-24488(gp)
 20338c4:	e0bff915 	stw	r2,-28(fp)
 20338c8:	00003306 	br	2033998 <ip_reass+0x27c>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 20338cc:	e0bff917 	ldw	r2,-28(fp)
 20338d0:	10c00517 	ldw	r3,20(r2)
 20338d4:	e0bffb17 	ldw	r2,-20(fp)
 20338d8:	11000303 	ldbu	r4,12(r2)
 20338dc:	11400343 	ldbu	r5,13(r2)
 20338e0:	280a923a 	slli	r5,r5,8
 20338e4:	2908b03a 	or	r4,r5,r4
 20338e8:	11400383 	ldbu	r5,14(r2)
 20338ec:	280a943a 	slli	r5,r5,16
 20338f0:	2908b03a 	or	r4,r5,r4
 20338f4:	108003c3 	ldbu	r2,15(r2)
 20338f8:	1004963a 	slli	r2,r2,24
 20338fc:	1104b03a 	or	r2,r2,r4
 2033900:	1880201e 	bne	r3,r2,2033984 <ip_reass+0x268>
 2033904:	e0bff917 	ldw	r2,-28(fp)
 2033908:	10c00617 	ldw	r3,24(r2)
 203390c:	e0bffb17 	ldw	r2,-20(fp)
 2033910:	11000403 	ldbu	r4,16(r2)
 2033914:	11400443 	ldbu	r5,17(r2)
 2033918:	280a923a 	slli	r5,r5,8
 203391c:	2908b03a 	or	r4,r5,r4
 2033920:	11400483 	ldbu	r5,18(r2)
 2033924:	280a943a 	slli	r5,r5,16
 2033928:	2908b03a 	or	r4,r5,r4
 203392c:	108004c3 	ldbu	r2,19(r2)
 2033930:	1004963a 	slli	r2,r2,24
 2033934:	1104b03a 	or	r2,r2,r4
 2033938:	1880121e 	bne	r3,r2,2033984 <ip_reass+0x268>
 203393c:	e0bff917 	ldw	r2,-28(fp)
 2033940:	1100030b 	ldhu	r4,12(r2)
 2033944:	e0bffb17 	ldw	r2,-20(fp)
 2033948:	10c00103 	ldbu	r3,4(r2)
 203394c:	10800143 	ldbu	r2,5(r2)
 2033950:	1004923a 	slli	r2,r2,8
 2033954:	10c4b03a 	or	r2,r2,r3
 2033958:	20ffffcc 	andi	r3,r4,65535
 203395c:	10bfffcc 	andi	r2,r2,65535
 2033960:	1880081e 	bne	r3,r2,2033984 <ip_reass+0x268>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
 2033964:	008085f4 	movhi	r2,535
 2033968:	10a8bc04 	addi	r2,r2,-23824
 203396c:	10802317 	ldw	r2,140(r2)
 2033970:	10c00044 	addi	r3,r2,1
 2033974:	008085f4 	movhi	r2,535
 2033978:	10a8bc04 	addi	r2,r2,-23824
 203397c:	10c02315 	stw	r3,140(r2)
      break;
 2033980:	00000706 	br	20339a0 <ip_reass+0x284>
    }
    ipr_prev = ipr;
 2033984:	e0bff917 	ldw	r2,-28(fp)
 2033988:	e0bffa15 	stw	r2,-24(fp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 203398c:	e0bff917 	ldw	r2,-28(fp)
 2033990:	10800017 	ldw	r2,0(r2)
 2033994:	e0bff915 	stw	r2,-28(fp)
 2033998:	e0bff917 	ldw	r2,-28(fp)
 203399c:	103fcb1e 	bne	r2,zero,20338cc <__alt_mem_mem_0+0xfd0138cc>
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
 20339a0:	e0bff917 	ldw	r2,-28(fp)
 20339a4:	1000081e 	bne	r2,zero,20339c8 <ip_reass+0x2ac>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 20339a8:	e0bffd03 	ldbu	r2,-12(fp)
 20339ac:	100b883a 	mov	r5,r2
 20339b0:	e13ffb17 	ldw	r4,-20(fp)
 20339b4:	2032ed80 	call	2032ed8 <ip_reass_enqueue_new_datagram>
 20339b8:	e0bff915 	stw	r2,-28(fp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
 20339bc:	e0bff917 	ldw	r2,-28(fp)
 20339c0:	1000271e 	bne	r2,zero,2033a60 <ip_reass+0x344>
      goto nullreturn;
 20339c4:	0000c906 	br	2033cec <ip_reass+0x5d0>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 20339c8:	e0bffb17 	ldw	r2,-20(fp)
 20339cc:	10c00183 	ldbu	r3,6(r2)
 20339d0:	108001c3 	ldbu	r2,7(r2)
 20339d4:	1004923a 	slli	r2,r2,8
 20339d8:	10c4b03a 	or	r2,r2,r3
 20339dc:	10bfffcc 	andi	r2,r2,65535
 20339e0:	1004d23a 	srli	r2,r2,8
 20339e4:	10ffffcc 	andi	r3,r2,65535
 20339e8:	e0bffb17 	ldw	r2,-20(fp)
 20339ec:	11000183 	ldbu	r4,6(r2)
 20339f0:	108001c3 	ldbu	r2,7(r2)
 20339f4:	1004923a 	slli	r2,r2,8
 20339f8:	1104b03a 	or	r2,r2,r4
 20339fc:	10bfffcc 	andi	r2,r2,65535
 2033a00:	1004923a 	slli	r2,r2,8
 2033a04:	10bfffcc 	andi	r2,r2,65535
 2033a08:	1884b03a 	or	r2,r3,r2
 2033a0c:	1087ffcc 	andi	r2,r2,8191
 2033a10:	1000131e 	bne	r2,zero,2033a60 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 2033a14:	e0bff917 	ldw	r2,-28(fp)
 2033a18:	1080038b 	ldhu	r2,14(r2)
 2033a1c:	10bfffcc 	andi	r2,r2,65535
 2033a20:	1004d23a 	srli	r2,r2,8
 2033a24:	10ffffcc 	andi	r3,r2,65535
 2033a28:	e0bff917 	ldw	r2,-28(fp)
 2033a2c:	1080038b 	ldhu	r2,14(r2)
 2033a30:	10bfffcc 	andi	r2,r2,65535
 2033a34:	1004923a 	slli	r2,r2,8
 2033a38:	10bfffcc 	andi	r2,r2,65535
 2033a3c:	1884b03a 	or	r2,r3,r2
 2033a40:	1087ffcc 	andi	r2,r2,8191
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 2033a44:	10000626 	beq	r2,zero,2033a60 <ip_reass+0x344>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 2033a48:	e0bff917 	ldw	r2,-28(fp)
 2033a4c:	10800204 	addi	r2,r2,8
 2033a50:	01800504 	movi	r6,20
 2033a54:	e17ffb17 	ldw	r5,-20(fp)
 2033a58:	1009883a 	mov	r4,r2
 2033a5c:	20060240 	call	2006024 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 2033a60:	e0fffd03 	ldbu	r3,-12(fp)
 2033a64:	d0a8170b 	ldhu	r2,-24484(gp)
 2033a68:	1885883a 	add	r2,r3,r2
 2033a6c:	d0a8170d 	sth	r2,-24484(gp)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 2033a70:	e0bffb17 	ldw	r2,-20(fp)
 2033a74:	10c00183 	ldbu	r3,6(r2)
 2033a78:	108001c3 	ldbu	r2,7(r2)
 2033a7c:	1004923a 	slli	r2,r2,8
 2033a80:	10c4b03a 	or	r2,r2,r3
 2033a84:	10bfffcc 	andi	r2,r2,65535
 2033a88:	1080080c 	andi	r2,r2,32
 2033a8c:	10000c1e 	bne	r2,zero,2033ac0 <ip_reass+0x3a4>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 2033a90:	e0bff917 	ldw	r2,-28(fp)
 2033a94:	10800783 	ldbu	r2,30(r2)
 2033a98:	10800054 	ori	r2,r2,1
 2033a9c:	1007883a 	mov	r3,r2
 2033aa0:	e0bff917 	ldw	r2,-28(fp)
 2033aa4:	10c00785 	stb	r3,30(r2)
    ipr->datagram_len = offset + len;
 2033aa8:	e0fffc0b 	ldhu	r3,-16(fp)
 2033aac:	e0bffc8b 	ldhu	r2,-14(fp)
 2033ab0:	1885883a 	add	r2,r3,r2
 2033ab4:	1007883a 	mov	r3,r2
 2033ab8:	e0bff917 	ldw	r2,-28(fp)
 2033abc:	10c0070d 	sth	r3,28(r2)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
 2033ac0:	e17fff17 	ldw	r5,-4(fp)
 2033ac4:	e13ff917 	ldw	r4,-28(fp)
 2033ac8:	203301c0 	call	203301c <ip_reass_chain_frag_into_datagram_and_validate>
 2033acc:	10008526 	beq	r2,zero,2033ce4 <ip_reass+0x5c8>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 2033ad0:	e0bff917 	ldw	r2,-28(fp)
 2033ad4:	1080070b 	ldhu	r2,28(r2)
 2033ad8:	10800504 	addi	r2,r2,20
 2033adc:	1007883a 	mov	r3,r2
 2033ae0:	e0bff917 	ldw	r2,-28(fp)
 2033ae4:	10c0070d 	sth	r3,28(r2)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 2033ae8:	e0bff917 	ldw	r2,-28(fp)
 2033aec:	10800117 	ldw	r2,4(r2)
 2033af0:	10800117 	ldw	r2,4(r2)
 2033af4:	10c00003 	ldbu	r3,0(r2)
 2033af8:	11000043 	ldbu	r4,1(r2)
 2033afc:	2008923a 	slli	r4,r4,8
 2033b00:	20c6b03a 	or	r3,r4,r3
 2033b04:	11000083 	ldbu	r4,2(r2)
 2033b08:	2008943a 	slli	r4,r4,16
 2033b0c:	20c6b03a 	or	r3,r4,r3
 2033b10:	108000c3 	ldbu	r2,3(r2)
 2033b14:	1004963a 	slli	r2,r2,24
 2033b18:	10c4b03a 	or	r2,r2,r3
 2033b1c:	e0bff815 	stw	r2,-32(fp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
 2033b20:	e0bff917 	ldw	r2,-28(fp)
 2033b24:	10800117 	ldw	r2,4(r2)
 2033b28:	10800117 	ldw	r2,4(r2)
 2033b2c:	e0bffb15 	stw	r2,-20(fp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 2033b30:	e0bff917 	ldw	r2,-28(fp)
 2033b34:	10800204 	addi	r2,r2,8
 2033b38:	01800504 	movi	r6,20
 2033b3c:	100b883a 	mov	r5,r2
 2033b40:	e13ffb17 	ldw	r4,-20(fp)
 2033b44:	20060240 	call	2006024 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 2033b48:	e0bff917 	ldw	r2,-28(fp)
 2033b4c:	1080070b 	ldhu	r2,28(r2)
 2033b50:	10bfffcc 	andi	r2,r2,65535
 2033b54:	1004d23a 	srli	r2,r2,8
 2033b58:	1007883a 	mov	r3,r2
 2033b5c:	e0bff917 	ldw	r2,-28(fp)
 2033b60:	1080070b 	ldhu	r2,28(r2)
 2033b64:	10bfffcc 	andi	r2,r2,65535
 2033b68:	1004923a 	slli	r2,r2,8
 2033b6c:	1884b03a 	or	r2,r3,r2
 2033b70:	100d883a 	mov	r6,r2
 2033b74:	e0bffb17 	ldw	r2,-20(fp)
 2033b78:	30ffffcc 	andi	r3,r6,65535
 2033b7c:	19403fcc 	andi	r5,r3,255
 2033b80:	10c00083 	ldbu	r3,2(r2)
 2033b84:	1806703a 	and	r3,r3,zero
 2033b88:	1809883a 	mov	r4,r3
 2033b8c:	2807883a 	mov	r3,r5
 2033b90:	20c6b03a 	or	r3,r4,r3
 2033b94:	10c00085 	stb	r3,2(r2)
 2033b98:	30ffffcc 	andi	r3,r6,65535
 2033b9c:	1806d23a 	srli	r3,r3,8
 2033ba0:	197fffcc 	andi	r5,r3,65535
 2033ba4:	10c000c3 	ldbu	r3,3(r2)
 2033ba8:	1806703a 	and	r3,r3,zero
 2033bac:	1809883a 	mov	r4,r3
 2033bb0:	2807883a 	mov	r3,r5
 2033bb4:	20c6b03a 	or	r3,r4,r3
 2033bb8:	10c000c5 	stb	r3,3(r2)
    IPH_OFFSET_SET(fraghdr, 0);
 2033bbc:	e0bffb17 	ldw	r2,-20(fp)
 2033bc0:	10c00183 	ldbu	r3,6(r2)
 2033bc4:	1806703a 	and	r3,r3,zero
 2033bc8:	10c00185 	stb	r3,6(r2)
 2033bcc:	10c001c3 	ldbu	r3,7(r2)
 2033bd0:	1806703a 	and	r3,r3,zero
 2033bd4:	10c001c5 	stb	r3,7(r2)
    IPH_CHKSUM_SET(fraghdr, 0);
 2033bd8:	e0bffb17 	ldw	r2,-20(fp)
 2033bdc:	10c00283 	ldbu	r3,10(r2)
 2033be0:	1806703a 	and	r3,r3,zero
 2033be4:	10c00285 	stb	r3,10(r2)
 2033be8:	10c002c3 	ldbu	r3,11(r2)
 2033bec:	1806703a 	and	r3,r3,zero
 2033bf0:	10c002c5 	stb	r3,11(r2)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 2033bf4:	01400504 	movi	r5,20
 2033bf8:	e13ffb17 	ldw	r4,-20(fp)
 2033bfc:	2031b740 	call	2031b74 <inet_chksum>
 2033c00:	100d883a 	mov	r6,r2
 2033c04:	e0bffb17 	ldw	r2,-20(fp)
 2033c08:	30ffffcc 	andi	r3,r6,65535
 2033c0c:	19403fcc 	andi	r5,r3,255
 2033c10:	10c00283 	ldbu	r3,10(r2)
 2033c14:	1806703a 	and	r3,r3,zero
 2033c18:	1809883a 	mov	r4,r3
 2033c1c:	2807883a 	mov	r3,r5
 2033c20:	20c6b03a 	or	r3,r4,r3
 2033c24:	10c00285 	stb	r3,10(r2)
 2033c28:	30ffffcc 	andi	r3,r6,65535
 2033c2c:	1806d23a 	srli	r3,r3,8
 2033c30:	197fffcc 	andi	r5,r3,65535
 2033c34:	10c002c3 	ldbu	r3,11(r2)
 2033c38:	1806703a 	and	r3,r3,zero
 2033c3c:	1809883a 	mov	r4,r3
 2033c40:	2807883a 	mov	r3,r5
 2033c44:	20c6b03a 	or	r3,r4,r3
 2033c48:	10c002c5 	stb	r3,11(r2)

    p = ipr->p;
 2033c4c:	e0bff917 	ldw	r2,-28(fp)
 2033c50:	10800117 	ldw	r2,4(r2)
 2033c54:	e0bfff15 	stw	r2,-4(fp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 2033c58:	00001506 	br	2033cb0 <ip_reass+0x594>
      iprh = (struct ip_reass_helper*)r->payload;
 2033c5c:	e0bff817 	ldw	r2,-32(fp)
 2033c60:	10800117 	ldw	r2,4(r2)
 2033c64:	e0bffe15 	stw	r2,-8(fp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 2033c68:	017ffb04 	movi	r5,-20
 2033c6c:	e13ff817 	ldw	r4,-32(fp)
 2033c70:	201a9b80 	call	201a9b8 <pbuf_header>
      pbuf_cat(p, r);
 2033c74:	e17ff817 	ldw	r5,-32(fp)
 2033c78:	e13fff17 	ldw	r4,-4(fp)
 2033c7c:	201ad5c0 	call	201ad5c <pbuf_cat>
      r = iprh->next_pbuf;
 2033c80:	e0bffe17 	ldw	r2,-8(fp)
 2033c84:	10c00003 	ldbu	r3,0(r2)
 2033c88:	11000043 	ldbu	r4,1(r2)
 2033c8c:	2008923a 	slli	r4,r4,8
 2033c90:	20c6b03a 	or	r3,r4,r3
 2033c94:	11000083 	ldbu	r4,2(r2)
 2033c98:	2008943a 	slli	r4,r4,16
 2033c9c:	20c6b03a 	or	r3,r4,r3
 2033ca0:	108000c3 	ldbu	r2,3(r2)
 2033ca4:	1004963a 	slli	r2,r2,24
 2033ca8:	10c4b03a 	or	r2,r2,r3
 2033cac:	e0bff815 	stw	r2,-32(fp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 2033cb0:	e0bff817 	ldw	r2,-32(fp)
 2033cb4:	103fe91e 	bne	r2,zero,2033c5c <__alt_mem_mem_0+0xfd013c5c>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 2033cb8:	e17ffa17 	ldw	r5,-24(fp)
 2033cbc:	e13ff917 	ldw	r4,-28(fp)
 2033cc0:	2032fb40 	call	2032fb4 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 2033cc4:	e13fff17 	ldw	r4,-4(fp)
 2033cc8:	201acac0 	call	201acac <pbuf_clen>
 2033ccc:	d0e8170b 	ldhu	r3,-24484(gp)
 2033cd0:	10803fcc 	andi	r2,r2,255
 2033cd4:	1885c83a 	sub	r2,r3,r2
 2033cd8:	d0a8170d 	sth	r2,-24484(gp)

    /* Return the pbuf chain */
    return p;
 2033cdc:	e0bfff17 	ldw	r2,-4(fp)
 2033ce0:	00000c06 	br	2033d14 <ip_reass+0x5f8>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 2033ce4:	0005883a 	mov	r2,zero
 2033ce8:	00000a06 	br	2033d14 <ip_reass+0x5f8>

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
 2033cec:	008085f4 	movhi	r2,535
 2033cf0:	10a8bc04 	addi	r2,r2,-23824
 2033cf4:	10801b17 	ldw	r2,108(r2)
 2033cf8:	10c00044 	addi	r3,r2,1
 2033cfc:	008085f4 	movhi	r2,535
 2033d00:	10a8bc04 	addi	r2,r2,-23824
 2033d04:	10c01b15 	stw	r3,108(r2)
  pbuf_free(p);
 2033d08:	e13fff17 	ldw	r4,-4(fp)
 2033d0c:	201ab680 	call	201ab68 <pbuf_free>
  return NULL;
 2033d10:	0005883a 	mov	r2,zero
}
 2033d14:	e037883a 	mov	sp,fp
 2033d18:	dfc00117 	ldw	ra,4(sp)
 2033d1c:	df000017 	ldw	fp,0(sp)
 2033d20:	dec00204 	addi	sp,sp,8
 2033d24:	f800283a 	ret

02033d28 <ip_frag_alloc_pbuf_custom_ref>:

#if !LWIP_NETIF_TX_SINGLE_PBUF
/** Allocate a new struct pbuf_custom_ref */
static struct pbuf_custom_ref*
ip_frag_alloc_pbuf_custom_ref(void)
{
 2033d28:	defffe04 	addi	sp,sp,-8
 2033d2c:	dfc00115 	stw	ra,4(sp)
 2033d30:	df000015 	stw	fp,0(sp)
 2033d34:	d839883a 	mov	fp,sp
  return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
 2033d38:	01000184 	movi	r4,6
 2033d3c:	20344340 	call	2034434 <memp_malloc>
}
 2033d40:	e037883a 	mov	sp,fp
 2033d44:	dfc00117 	ldw	ra,4(sp)
 2033d48:	df000017 	ldw	fp,0(sp)
 2033d4c:	dec00204 	addi	sp,sp,8
 2033d50:	f800283a 	ret

02033d54 <ip_frag_free_pbuf_custom_ref>:

/** Free a struct pbuf_custom_ref */
static void
ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
{
 2033d54:	defffd04 	addi	sp,sp,-12
 2033d58:	dfc00215 	stw	ra,8(sp)
 2033d5c:	df000115 	stw	fp,4(sp)
 2033d60:	df000104 	addi	fp,sp,4
 2033d64:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("p != NULL", p != NULL);
  memp_free(MEMP_FRAG_PBUF, p);
 2033d68:	e17fff17 	ldw	r5,-4(fp)
 2033d6c:	01000184 	movi	r4,6
 2033d70:	20346000 	call	2034600 <memp_free>
}
 2033d74:	0001883a 	nop
 2033d78:	e037883a 	mov	sp,fp
 2033d7c:	dfc00117 	ldw	ra,4(sp)
 2033d80:	df000017 	ldw	fp,0(sp)
 2033d84:	dec00204 	addi	sp,sp,8
 2033d88:	f800283a 	ret

02033d8c <ipfrag_free_pbuf_custom>:

/** Free-callback function to free a 'struct pbuf_custom_ref', called by
 * pbuf_free. */
static void
ipfrag_free_pbuf_custom(struct pbuf *p)
{
 2033d8c:	defffc04 	addi	sp,sp,-16
 2033d90:	dfc00315 	stw	ra,12(sp)
 2033d94:	df000215 	stw	fp,8(sp)
 2033d98:	df000204 	addi	fp,sp,8
 2033d9c:	e13fff15 	stw	r4,-4(fp)
  struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
 2033da0:	e0bfff17 	ldw	r2,-4(fp)
 2033da4:	e0bffe15 	stw	r2,-8(fp)
  LWIP_ASSERT("pcr != NULL", pcr != NULL);
  LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
  if (pcr->original != NULL) {
 2033da8:	e0bffe17 	ldw	r2,-8(fp)
 2033dac:	10800517 	ldw	r2,20(r2)
 2033db0:	10000426 	beq	r2,zero,2033dc4 <ipfrag_free_pbuf_custom+0x38>
    pbuf_free(pcr->original);
 2033db4:	e0bffe17 	ldw	r2,-8(fp)
 2033db8:	10800517 	ldw	r2,20(r2)
 2033dbc:	1009883a 	mov	r4,r2
 2033dc0:	201ab680 	call	201ab68 <pbuf_free>
  }
  ip_frag_free_pbuf_custom_ref(pcr);
 2033dc4:	e13ffe17 	ldw	r4,-8(fp)
 2033dc8:	2033d540 	call	2033d54 <ip_frag_free_pbuf_custom_ref>
}
 2033dcc:	0001883a 	nop
 2033dd0:	e037883a 	mov	sp,fp
 2033dd4:	dfc00117 	ldw	ra,4(sp)
 2033dd8:	df000017 	ldw	fp,0(sp)
 2033ddc:	dec00204 	addi	sp,sp,8
 2033de0:	f800283a 	ret

02033de4 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 2033de4:	deffee04 	addi	sp,sp,-72
 2033de8:	dfc01115 	stw	ra,68(sp)
 2033dec:	df001015 	stw	fp,64(sp)
 2033df0:	df001004 	addi	fp,sp,64
 2033df4:	e13ffd15 	stw	r4,-12(fp)
 2033df8:	e17ffe15 	stw	r5,-8(fp)
 2033dfc:	e1bfff15 	stw	r6,-4(fp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 2033e00:	e0bffe17 	ldw	r2,-8(fp)
 2033e04:	10800c0b 	ldhu	r2,48(r2)
 2033e08:	e0bff50d 	sth	r2,-44(fp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
 2033e0c:	00800504 	movi	r2,20
 2033e10:	e0bff30d 	sth	r2,-52(fp)
  u16_t tmp;
#if !IP_FRAG_USES_STATIC_BUF && !LWIP_NETIF_TX_SINGLE_PBUF
  u16_t newpbuflen = 0;
 2033e14:	e03ff40d 	sth	zero,-48(fp)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
#else /* IP_FRAG_USES_STATIC_BUF */
  original_iphdr = (struct ip_hdr *)p->payload;
 2033e18:	e0bffd17 	ldw	r2,-12(fp)
 2033e1c:	10800117 	ldw	r2,4(r2)
 2033e20:	e0bff615 	stw	r2,-40(fp)
  iphdr = original_iphdr;
 2033e24:	e0bff617 	ldw	r2,-40(fp)
 2033e28:	e0bff715 	stw	r2,-36(fp)
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 2033e2c:	e0bff717 	ldw	r2,-36(fp)
 2033e30:	10c00183 	ldbu	r3,6(r2)
 2033e34:	108001c3 	ldbu	r2,7(r2)
 2033e38:	1004923a 	slli	r2,r2,8
 2033e3c:	10c4b03a 	or	r2,r2,r3
 2033e40:	10bfffcc 	andi	r2,r2,65535
 2033e44:	1004d23a 	srli	r2,r2,8
 2033e48:	1009883a 	mov	r4,r2
 2033e4c:	e0bff717 	ldw	r2,-36(fp)
 2033e50:	10c00183 	ldbu	r3,6(r2)
 2033e54:	108001c3 	ldbu	r2,7(r2)
 2033e58:	1004923a 	slli	r2,r2,8
 2033e5c:	10c4b03a 	or	r2,r2,r3
 2033e60:	10bfffcc 	andi	r2,r2,65535
 2033e64:	1004923a 	slli	r2,r2,8
 2033e68:	2084b03a 	or	r2,r4,r2
 2033e6c:	e0bff38d 	sth	r2,-50(fp)
  ofo = tmp & IP_OFFMASK;
 2033e70:	e0bff38b 	ldhu	r2,-50(fp)
 2033e74:	1087ffcc 	andi	r2,r2,8191
 2033e78:	e0bff28d 	sth	r2,-54(fp)
  omf = tmp & IP_MF;
 2033e7c:	e0bff38b 	ldhu	r2,-50(fp)
 2033e80:	1088000c 	andi	r2,r2,8192
 2033e84:	e0bff80d 	sth	r2,-32(fp)

  left = p->tot_len - IP_HLEN;
 2033e88:	e0bffd17 	ldw	r2,-12(fp)
 2033e8c:	1080020b 	ldhu	r2,8(r2)
 2033e90:	10bffb04 	addi	r2,r2,-20
 2033e94:	e0bff20d 	sth	r2,-56(fp)

  nfb = (mtu - IP_HLEN) / 8;
 2033e98:	e0bff50b 	ldhu	r2,-44(fp)
 2033e9c:	10bffb04 	addi	r2,r2,-20
 2033ea0:	1000010e 	bge	r2,zero,2033ea8 <ip_frag+0xc4>
 2033ea4:	108001c4 	addi	r2,r2,7
 2033ea8:	1005d0fa 	srai	r2,r2,3
 2033eac:	e0bff88d 	sth	r2,-30(fp)

  while (left) {
 2033eb0:	0000e706 	br	2034250 <ip_frag+0x46c>
    last = (left <= mtu - IP_HLEN);
 2033eb4:	e0bff20b 	ldhu	r2,-56(fp)
 2033eb8:	e0fff50b 	ldhu	r3,-44(fp)
 2033ebc:	18fffb04 	addi	r3,r3,-20
 2033ec0:	1884403a 	cmpge	r2,r3,r2
 2033ec4:	10803fcc 	andi	r2,r2,255
 2033ec8:	e0bff90d 	sth	r2,-28(fp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 2033ecc:	e0bff28b 	ldhu	r2,-54(fp)
 2033ed0:	1087ffcc 	andi	r2,r2,8191
 2033ed4:	1007883a 	mov	r3,r2
 2033ed8:	e0bff80b 	ldhu	r2,-32(fp)
 2033edc:	1884b03a 	or	r2,r3,r2
 2033ee0:	e0bff38d 	sth	r2,-50(fp)
    if (!last) {
 2033ee4:	e0bff90b 	ldhu	r2,-28(fp)
 2033ee8:	1000031e 	bne	r2,zero,2033ef8 <ip_frag+0x114>
      tmp = tmp | IP_MF;
 2033eec:	e0bff38b 	ldhu	r2,-50(fp)
 2033ef0:	10880014 	ori	r2,r2,8192
 2033ef4:	e0bff38d 	sth	r2,-50(fp)
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 2033ef8:	e0bff90b 	ldhu	r2,-28(fp)
 2033efc:	1000031e 	bne	r2,zero,2033f0c <ip_frag+0x128>
 2033f00:	e0bff88b 	ldhu	r2,-30(fp)
 2033f04:	100490fa 	slli	r2,r2,3
 2033f08:	00000106 	br	2033f10 <ip_frag+0x12c>
 2033f0c:	e0bff20b 	ldhu	r2,-56(fp)
 2033f10:	e0bff98d 	sth	r2,-26(fp)
    /* When not using a static buffer, create a chain of pbufs.
     * The first will be a PBUF_RAM holding the link and IP header.
     * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
     * but limited to the size of an mtu.
     */
    rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
 2033f14:	000d883a 	mov	r6,zero
 2033f18:	01400504 	movi	r5,20
 2033f1c:	01000084 	movi	r4,2
 2033f20:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2033f24:	e0bffa15 	stw	r2,-24(fp)
    if (rambuf == NULL) {
 2033f28:	e0bffa17 	ldw	r2,-24(fp)
 2033f2c:	1000021e 	bne	r2,zero,2033f38 <ip_frag+0x154>
      return ERR_MEM;
 2033f30:	00bfffc4 	movi	r2,-1
 2033f34:	0000c906 	br	203425c <ip_frag+0x478>
    }
    LWIP_ASSERT("this needs a pbuf in one piece!",
                (p->len >= (IP_HLEN)));
    SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
 2033f38:	e0bffa17 	ldw	r2,-24(fp)
 2033f3c:	10800117 	ldw	r2,4(r2)
 2033f40:	01800504 	movi	r6,20
 2033f44:	e17ff617 	ldw	r5,-40(fp)
 2033f48:	1009883a 	mov	r4,r2
 2033f4c:	20060240 	call	2006024 <memcpy>
    iphdr = (struct ip_hdr *)rambuf->payload;
 2033f50:	e0bffa17 	ldw	r2,-24(fp)
 2033f54:	10800117 	ldw	r2,4(r2)
 2033f58:	e0bff715 	stw	r2,-36(fp)

    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
 2033f5c:	e0bffd17 	ldw	r2,-12(fp)
 2033f60:	10c00117 	ldw	r3,4(r2)
 2033f64:	e0bff30b 	ldhu	r2,-52(fp)
 2033f68:	1887883a 	add	r3,r3,r2
 2033f6c:	e0bffd17 	ldw	r2,-12(fp)
 2033f70:	10c00115 	stw	r3,4(r2)
    p->len -= poff;
 2033f74:	e0bffd17 	ldw	r2,-12(fp)
 2033f78:	10c0028b 	ldhu	r3,10(r2)
 2033f7c:	e0bff30b 	ldhu	r2,-52(fp)
 2033f80:	1885c83a 	sub	r2,r3,r2
 2033f84:	1007883a 	mov	r3,r2
 2033f88:	e0bffd17 	ldw	r2,-12(fp)
 2033f8c:	10c0028d 	sth	r3,10(r2)

    left_to_copy = cop;
 2033f90:	e0bff98b 	ldhu	r2,-26(fp)
 2033f94:	e0bff48d 	sth	r2,-46(fp)
    while (left_to_copy) {
 2033f98:	00004006 	br	203409c <ip_frag+0x2b8>
      struct pbuf_custom_ref *pcr;
      newpbuflen = (left_to_copy < p->len) ? left_to_copy : p->len;
 2033f9c:	e0bffd17 	ldw	r2,-12(fp)
 2033fa0:	1080028b 	ldhu	r2,10(r2)
 2033fa4:	e17ff48b 	ldhu	r5,-46(fp)
 2033fa8:	10ffffcc 	andi	r3,r2,65535
 2033fac:	293fffcc 	andi	r4,r5,65535
 2033fb0:	20c0012e 	bgeu	r4,r3,2033fb8 <ip_frag+0x1d4>
 2033fb4:	2805883a 	mov	r2,r5
 2033fb8:	e0bff40d 	sth	r2,-48(fp)
      /* Is this pbuf already empty? */
      if (!newpbuflen) {
 2033fbc:	e0bff40b 	ldhu	r2,-48(fp)
 2033fc0:	1000041e 	bne	r2,zero,2033fd4 <ip_frag+0x1f0>
        p = p->next;
 2033fc4:	e0bffd17 	ldw	r2,-12(fp)
 2033fc8:	10800017 	ldw	r2,0(r2)
 2033fcc:	e0bffd15 	stw	r2,-12(fp)
        continue;
 2033fd0:	00003206 	br	203409c <ip_frag+0x2b8>
      }
      pcr = ip_frag_alloc_pbuf_custom_ref();
 2033fd4:	2033d280 	call	2033d28 <ip_frag_alloc_pbuf_custom_ref>
 2033fd8:	e0bffb15 	stw	r2,-20(fp)
      if (pcr == NULL) {
 2033fdc:	e0bffb17 	ldw	r2,-20(fp)
 2033fe0:	1000041e 	bne	r2,zero,2033ff4 <ip_frag+0x210>
        pbuf_free(rambuf);
 2033fe4:	e13ffa17 	ldw	r4,-24(fp)
 2033fe8:	201ab680 	call	201ab68 <pbuf_free>
        return ERR_MEM;
 2033fec:	00bfffc4 	movi	r2,-1
 2033ff0:	00009a06 	br	203425c <ip_frag+0x478>
      }
      /* Mirror this pbuf, although we might not need all of it. */
      newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc, p->payload, newpbuflen);
 2033ff4:	e13ff40b 	ldhu	r4,-48(fp)
 2033ff8:	e17ffb17 	ldw	r5,-20(fp)
 2033ffc:	e0bffd17 	ldw	r2,-12(fp)
 2034000:	10800117 	ldw	r2,4(r2)
 2034004:	e0fff40b 	ldhu	r3,-48(fp)
 2034008:	d8c00115 	stw	r3,4(sp)
 203400c:	d8800015 	stw	r2,0(sp)
 2034010:	280f883a 	mov	r7,r5
 2034014:	01800084 	movi	r6,2
 2034018:	200b883a 	mov	r5,r4
 203401c:	010000c4 	movi	r4,3
 2034020:	201a7180 	call	201a718 <pbuf_alloced_custom>
 2034024:	e0bffc15 	stw	r2,-16(fp)
      if (newpbuf == NULL) {
 2034028:	e0bffc17 	ldw	r2,-16(fp)
 203402c:	1000061e 	bne	r2,zero,2034048 <ip_frag+0x264>
        ip_frag_free_pbuf_custom_ref(pcr);
 2034030:	e13ffb17 	ldw	r4,-20(fp)
 2034034:	2033d540 	call	2033d54 <ip_frag_free_pbuf_custom_ref>
        pbuf_free(rambuf);
 2034038:	e13ffa17 	ldw	r4,-24(fp)
 203403c:	201ab680 	call	201ab68 <pbuf_free>
        return ERR_MEM;
 2034040:	00bfffc4 	movi	r2,-1
 2034044:	00008506 	br	203425c <ip_frag+0x478>
      }
      pbuf_ref(p);
 2034048:	e13ffd17 	ldw	r4,-12(fp)
 203404c:	201acf80 	call	201acf8 <pbuf_ref>
      pcr->original = p;
 2034050:	e0bffb17 	ldw	r2,-20(fp)
 2034054:	e0fffd17 	ldw	r3,-12(fp)
 2034058:	10c00515 	stw	r3,20(r2)
      pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
 203405c:	e0fffb17 	ldw	r3,-20(fp)
 2034060:	008080f4 	movhi	r2,515
 2034064:	108f6304 	addi	r2,r2,15756
 2034068:	18800415 	stw	r2,16(r3)

      /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
       * so that it is removed when pbuf_dechain is later called on rambuf.
       */
      pbuf_cat(rambuf, newpbuf);
 203406c:	e17ffc17 	ldw	r5,-16(fp)
 2034070:	e13ffa17 	ldw	r4,-24(fp)
 2034074:	201ad5c0 	call	201ad5c <pbuf_cat>
      left_to_copy -= newpbuflen;
 2034078:	e0fff48b 	ldhu	r3,-46(fp)
 203407c:	e0bff40b 	ldhu	r2,-48(fp)
 2034080:	1885c83a 	sub	r2,r3,r2
 2034084:	e0bff48d 	sth	r2,-46(fp)
      if (left_to_copy) {
 2034088:	e0bff48b 	ldhu	r2,-46(fp)
 203408c:	10000326 	beq	r2,zero,203409c <ip_frag+0x2b8>
        p = p->next;
 2034090:	e0bffd17 	ldw	r2,-12(fp)
 2034094:	10800017 	ldw	r2,0(r2)
 2034098:	e0bffd15 	stw	r2,-12(fp)
    /* Can just adjust p directly for needed offset. */
    p->payload = (u8_t *)p->payload + poff;
    p->len -= poff;

    left_to_copy = cop;
    while (left_to_copy) {
 203409c:	e0bff48b 	ldhu	r2,-46(fp)
 20340a0:	103fbe1e 	bne	r2,zero,2033f9c <__alt_mem_mem_0+0xfd013f9c>
      left_to_copy -= newpbuflen;
      if (left_to_copy) {
        p = p->next;
      }
    }
    poff = newpbuflen;
 20340a4:	e0bff40b 	ldhu	r2,-48(fp)
 20340a8:	e0bff30d 	sth	r2,-52(fp)
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 20340ac:	e0bff38b 	ldhu	r2,-50(fp)
 20340b0:	1004d23a 	srli	r2,r2,8
 20340b4:	1007883a 	mov	r3,r2
 20340b8:	e0bff38b 	ldhu	r2,-50(fp)
 20340bc:	1004923a 	slli	r2,r2,8
 20340c0:	1884b03a 	or	r2,r3,r2
 20340c4:	100d883a 	mov	r6,r2
 20340c8:	e0bff717 	ldw	r2,-36(fp)
 20340cc:	30ffffcc 	andi	r3,r6,65535
 20340d0:	19403fcc 	andi	r5,r3,255
 20340d4:	10c00183 	ldbu	r3,6(r2)
 20340d8:	1806703a 	and	r3,r3,zero
 20340dc:	1809883a 	mov	r4,r3
 20340e0:	2807883a 	mov	r3,r5
 20340e4:	20c6b03a 	or	r3,r4,r3
 20340e8:	10c00185 	stb	r3,6(r2)
 20340ec:	30ffffcc 	andi	r3,r6,65535
 20340f0:	1806d23a 	srli	r3,r3,8
 20340f4:	197fffcc 	andi	r5,r3,65535
 20340f8:	10c001c3 	ldbu	r3,7(r2)
 20340fc:	1806703a 	and	r3,r3,zero
 2034100:	1809883a 	mov	r4,r3
 2034104:	2807883a 	mov	r3,r5
 2034108:	20c6b03a 	or	r3,r4,r3
 203410c:	10c001c5 	stb	r3,7(r2)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 2034110:	e0bff98b 	ldhu	r2,-26(fp)
 2034114:	10800504 	addi	r2,r2,20
 2034118:	10bfc00c 	andi	r2,r2,65280
 203411c:	1005d23a 	srai	r2,r2,8
 2034120:	1007883a 	mov	r3,r2
 2034124:	e0bff98b 	ldhu	r2,-26(fp)
 2034128:	10800504 	addi	r2,r2,20
 203412c:	1004923a 	slli	r2,r2,8
 2034130:	1884b03a 	or	r2,r3,r2
 2034134:	100d883a 	mov	r6,r2
 2034138:	e0bff717 	ldw	r2,-36(fp)
 203413c:	30ffffcc 	andi	r3,r6,65535
 2034140:	19403fcc 	andi	r5,r3,255
 2034144:	10c00083 	ldbu	r3,2(r2)
 2034148:	1806703a 	and	r3,r3,zero
 203414c:	1809883a 	mov	r4,r3
 2034150:	2807883a 	mov	r3,r5
 2034154:	20c6b03a 	or	r3,r4,r3
 2034158:	10c00085 	stb	r3,2(r2)
 203415c:	30ffffcc 	andi	r3,r6,65535
 2034160:	1806d23a 	srli	r3,r3,8
 2034164:	197fffcc 	andi	r5,r3,65535
 2034168:	10c000c3 	ldbu	r3,3(r2)
 203416c:	1806703a 	and	r3,r3,zero
 2034170:	1809883a 	mov	r4,r3
 2034174:	2807883a 	mov	r3,r5
 2034178:	20c6b03a 	or	r3,r4,r3
 203417c:	10c000c5 	stb	r3,3(r2)
    IPH_CHKSUM_SET(iphdr, 0);
 2034180:	e0bff717 	ldw	r2,-36(fp)
 2034184:	10c00283 	ldbu	r3,10(r2)
 2034188:	1806703a 	and	r3,r3,zero
 203418c:	10c00285 	stb	r3,10(r2)
 2034190:	10c002c3 	ldbu	r3,11(r2)
 2034194:	1806703a 	and	r3,r3,zero
 2034198:	10c002c5 	stb	r3,11(r2)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 203419c:	01400504 	movi	r5,20
 20341a0:	e13ff717 	ldw	r4,-36(fp)
 20341a4:	2031b740 	call	2031b74 <inet_chksum>
 20341a8:	100d883a 	mov	r6,r2
 20341ac:	e0bff717 	ldw	r2,-36(fp)
 20341b0:	30ffffcc 	andi	r3,r6,65535
 20341b4:	19403fcc 	andi	r5,r3,255
 20341b8:	10c00283 	ldbu	r3,10(r2)
 20341bc:	1806703a 	and	r3,r3,zero
 20341c0:	1809883a 	mov	r4,r3
 20341c4:	2807883a 	mov	r3,r5
 20341c8:	20c6b03a 	or	r3,r4,r3
 20341cc:	10c00285 	stb	r3,10(r2)
 20341d0:	30ffffcc 	andi	r3,r6,65535
 20341d4:	1806d23a 	srli	r3,r3,8
 20341d8:	197fffcc 	andi	r5,r3,65535
 20341dc:	10c002c3 	ldbu	r3,11(r2)
 20341e0:	1806703a 	and	r3,r3,zero
 20341e4:	1809883a 	mov	r4,r3
 20341e8:	2807883a 	mov	r3,r5
 20341ec:	20c6b03a 	or	r3,r4,r3
 20341f0:	10c002c5 	stb	r3,11(r2)
    }
#else /* IP_FRAG_USES_STATIC_BUF */
    /* No need for separate header pbuf - we allowed room for it in rambuf
     * when allocated.
     */
    netif->output(netif, rambuf, dest);
 20341f4:	e0bffe17 	ldw	r2,-8(fp)
 20341f8:	10800517 	ldw	r2,20(r2)
 20341fc:	e1bfff17 	ldw	r6,-4(fp)
 2034200:	e17ffa17 	ldw	r5,-24(fp)
 2034204:	e13ffe17 	ldw	r4,-8(fp)
 2034208:	103ee83a 	callr	r2
    IPFRAG_STATS_INC(ip_frag.xmit);
 203420c:	008085f4 	movhi	r2,535
 2034210:	10a8bc04 	addi	r2,r2,-23824
 2034214:	10801817 	ldw	r2,96(r2)
 2034218:	10c00044 	addi	r3,r2,1
 203421c:	008085f4 	movhi	r2,535
 2034220:	10a8bc04 	addi	r2,r2,-23824
 2034224:	10c01815 	stw	r3,96(r2)
     * recreate it next time round the loop. If we're lucky the hardware
     * will have already sent the packet, the free will really free, and
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
 2034228:	e13ffa17 	ldw	r4,-24(fp)
 203422c:	201ab680 	call	201ab68 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 2034230:	e0fff20b 	ldhu	r3,-56(fp)
 2034234:	e0bff98b 	ldhu	r2,-26(fp)
 2034238:	1885c83a 	sub	r2,r3,r2
 203423c:	e0bff20d 	sth	r2,-56(fp)
    ofo += nfb;
 2034240:	e0fff28b 	ldhu	r3,-54(fp)
 2034244:	e0bff88b 	ldhu	r2,-30(fp)
 2034248:	1885883a 	add	r2,r3,r2
 203424c:	e0bff28d 	sth	r2,-54(fp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 2034250:	e0bff20b 	ldhu	r2,-56(fp)
 2034254:	103f171e 	bne	r2,zero,2033eb4 <__alt_mem_mem_0+0xfd013eb4>
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 2034258:	0005883a 	mov	r2,zero
}
 203425c:	e037883a 	mov	sp,fp
 2034260:	dfc00117 	ldw	ra,4(sp)
 2034264:	df000017 	ldw	fp,0(sp)
 2034268:	dec00204 	addi	sp,sp,8
 203426c:	f800283a 	ret

02034270 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 2034270:	defffd04 	addi	sp,sp,-12
 2034274:	df000215 	stw	fp,8(sp)
 2034278:	df000204 	addi	fp,sp,8
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 203427c:	e03fff0d 	sth	zero,-4(fp)
 2034280:	00002606 	br	203431c <memp_init+0xac>
    MEMP_STATS_AVAIL(used, i, 0);
 2034284:	e0ffff0b 	ldhu	r3,-4(fp)
 2034288:	008085f4 	movhi	r2,535
 203428c:	10a8bc04 	addi	r2,r2,-23824
 2034290:	18c00584 	addi	r3,r3,22
 2034294:	1806913a 	slli	r3,r3,4
 2034298:	10c5883a 	add	r2,r2,r3
 203429c:	10800084 	addi	r2,r2,2
 20342a0:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(max, i, 0);
 20342a4:	e0ffff0b 	ldhu	r3,-4(fp)
 20342a8:	008085f4 	movhi	r2,535
 20342ac:	10a8bc04 	addi	r2,r2,-23824
 20342b0:	1806913a 	slli	r3,r3,4
 20342b4:	10c5883a 	add	r2,r2,r3
 20342b8:	10805904 	addi	r2,r2,356
 20342bc:	1000000d 	sth	zero,0(r2)
    MEMP_STATS_AVAIL(err, i, 0);
 20342c0:	e0ffff0b 	ldhu	r3,-4(fp)
 20342c4:	008085f4 	movhi	r2,535
 20342c8:	10a8bc04 	addi	r2,r2,-23824
 20342cc:	1806913a 	slli	r3,r3,4
 20342d0:	10c5883a 	add	r2,r2,r3
 20342d4:	10805a04 	addi	r2,r2,360
 20342d8:	10000015 	stw	zero,0(r2)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
 20342dc:	e13fff0b 	ldhu	r4,-4(fp)
 20342e0:	e0ffff0b 	ldhu	r3,-4(fp)
 20342e4:	00808134 	movhi	r2,516
 20342e8:	108d8684 	addi	r2,r2,13850
 20342ec:	18c7883a 	add	r3,r3,r3
 20342f0:	10c5883a 	add	r2,r2,r3
 20342f4:	10c0000b 	ldhu	r3,0(r2)
 20342f8:	008085f4 	movhi	r2,535
 20342fc:	10a8bc04 	addi	r2,r2,-23824
 2034300:	21000584 	addi	r4,r4,22
 2034304:	2008913a 	slli	r4,r4,4
 2034308:	1105883a 	add	r2,r2,r4
 203430c:	10c0000d 	sth	r3,0(r2)
memp_init(void)
{
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
 2034310:	e0bfff0b 	ldhu	r2,-4(fp)
 2034314:	10800044 	addi	r2,r2,1
 2034318:	e0bfff0d 	sth	r2,-4(fp)
 203431c:	e0bfff0b 	ldhu	r2,-4(fp)
 2034320:	108003f0 	cmpltui	r2,r2,15
 2034324:	103fd71e 	bne	r2,zero,2034284 <__alt_mem_mem_0+0xfd014284>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 2034328:	00808574 	movhi	r2,533
 203432c:	10a02f04 	addi	r2,r2,-32580
 2034330:	10c000c4 	addi	r3,r2,3
 2034334:	00bfff04 	movi	r2,-4
 2034338:	1884703a 	and	r2,r3,r2
 203433c:	e0bffe15 	stw	r2,-8(fp)
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 2034340:	e03fff0d 	sth	zero,-4(fp)
 2034344:	00003306 	br	2034414 <memp_init+0x1a4>
    memp_tab[i] = NULL;
 2034348:	e0ffff0b 	ldhu	r3,-4(fp)
 203434c:	00808574 	movhi	r2,533
 2034350:	10a02004 	addi	r2,r2,-32640
 2034354:	18c7883a 	add	r3,r3,r3
 2034358:	18c7883a 	add	r3,r3,r3
 203435c:	10c5883a 	add	r2,r2,r3
 2034360:	10000015 	stw	zero,0(r2)
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 2034364:	e03fff8d 	sth	zero,-2(fp)
 2034368:	00001e06 	br	20343e4 <memp_init+0x174>
      memp->next = memp_tab[i];
 203436c:	e0ffff0b 	ldhu	r3,-4(fp)
 2034370:	00808574 	movhi	r2,533
 2034374:	10a02004 	addi	r2,r2,-32640
 2034378:	18c7883a 	add	r3,r3,r3
 203437c:	18c7883a 	add	r3,r3,r3
 2034380:	10c5883a 	add	r2,r2,r3
 2034384:	10c00017 	ldw	r3,0(r2)
 2034388:	e0bffe17 	ldw	r2,-8(fp)
 203438c:	10c00015 	stw	r3,0(r2)
      memp_tab[i] = memp;
 2034390:	e0ffff0b 	ldhu	r3,-4(fp)
 2034394:	00808574 	movhi	r2,533
 2034398:	10a02004 	addi	r2,r2,-32640
 203439c:	18c7883a 	add	r3,r3,r3
 20343a0:	18c7883a 	add	r3,r3,r3
 20343a4:	10c5883a 	add	r2,r2,r3
 20343a8:	e0fffe17 	ldw	r3,-8(fp)
 20343ac:	10c00015 	stw	r3,0(r2)
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 20343b0:	e0ffff0b 	ldhu	r3,-4(fp)
 20343b4:	00808134 	movhi	r2,516
 20343b8:	108d7f04 	addi	r2,r2,13820
 20343bc:	18c7883a 	add	r3,r3,r3
 20343c0:	10c5883a 	add	r2,r2,r3
 20343c4:	1080000b 	ldhu	r2,0(r2)
 20343c8:	10bfffcc 	andi	r2,r2,65535
 20343cc:	e0fffe17 	ldw	r3,-8(fp)
 20343d0:	1885883a 	add	r2,r3,r2
 20343d4:	e0bffe15 	stw	r2,-8(fp)
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 20343d8:	e0bfff8b 	ldhu	r2,-2(fp)
 20343dc:	10800044 	addi	r2,r2,1
 20343e0:	e0bfff8d 	sth	r2,-2(fp)
 20343e4:	e0ffff0b 	ldhu	r3,-4(fp)
 20343e8:	00808134 	movhi	r2,516
 20343ec:	108d8684 	addi	r2,r2,13850
 20343f0:	18c7883a 	add	r3,r3,r3
 20343f4:	10c5883a 	add	r2,r2,r3
 20343f8:	1080000b 	ldhu	r2,0(r2)
 20343fc:	10bfffcc 	andi	r2,r2,65535
 2034400:	e0ffff8b 	ldhu	r3,-2(fp)
 2034404:	18bfd936 	bltu	r3,r2,203436c <__alt_mem_mem_0+0xfd01436c>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 2034408:	e0bfff0b 	ldhu	r2,-4(fp)
 203440c:	10800044 	addi	r2,r2,1
 2034410:	e0bfff0d 	sth	r2,-4(fp)
 2034414:	e0bfff0b 	ldhu	r2,-4(fp)
 2034418:	108003f0 	cmpltui	r2,r2,15
 203441c:	103fca1e 	bne	r2,zero,2034348 <__alt_mem_mem_0+0xfd014348>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
 2034420:	0001883a 	nop
 2034424:	e037883a 	mov	sp,fp
 2034428:	df000017 	ldw	fp,0(sp)
 203442c:	dec00104 	addi	sp,sp,4
 2034430:	f800283a 	ret

02034434 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 2034434:	defffc04 	addi	sp,sp,-16
 2034438:	dfc00315 	stw	ra,12(sp)
 203443c:	df000215 	stw	fp,8(sp)
 2034440:	df000204 	addi	fp,sp,8
 2034444:	e13fff15 	stw	r4,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 2034448:	e0bfff17 	ldw	r2,-4(fp)
 203444c:	108003f0 	cmpltui	r2,r2,15
 2034450:	1000091e 	bne	r2,zero,2034478 <memp_malloc+0x44>
 2034454:	01c08134 	movhi	r7,516
 2034458:	39cd8e04 	addi	r7,r7,13880
 203445c:	01806384 	movi	r6,398
 2034460:	01408134 	movhi	r5,516
 2034464:	294d9404 	addi	r5,r5,13904
 2034468:	01008134 	movhi	r4,516
 203446c:	210d9c04 	addi	r4,r4,13936
 2034470:	2000bb00 	call	2000bb0 <printf>
 2034474:	003fff06 	br	2034474 <__alt_mem_mem_0+0xfd014474>

  SYS_ARCH_PROTECT(old_level);
 2034478:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203447c:	10000126 	beq	r2,zero,2034484 <memp_malloc+0x50>
 2034480:	2010f300 	call	2010f30 <vTaskEnterCritical>
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 2034484:	00808574 	movhi	r2,533
 2034488:	10a02004 	addi	r2,r2,-32640
 203448c:	e0ffff17 	ldw	r3,-4(fp)
 2034490:	18c7883a 	add	r3,r3,r3
 2034494:	18c7883a 	add	r3,r3,r3
 2034498:	10c5883a 	add	r2,r2,r3
 203449c:	10800017 	ldw	r2,0(r2)
 20344a0:	e0bffe15 	stw	r2,-8(fp)
  
  if (memp != NULL) {
 20344a4:	e0bffe17 	ldw	r2,-8(fp)
 20344a8:	10003d26 	beq	r2,zero,20345a0 <memp_malloc+0x16c>
    memp_tab[type] = memp->next;
 20344ac:	e0bffe17 	ldw	r2,-8(fp)
 20344b0:	11000017 	ldw	r4,0(r2)
 20344b4:	00808574 	movhi	r2,533
 20344b8:	10a02004 	addi	r2,r2,-32640
 20344bc:	e0ffff17 	ldw	r3,-4(fp)
 20344c0:	18c7883a 	add	r3,r3,r3
 20344c4:	18c7883a 	add	r3,r3,r3
 20344c8:	10c5883a 	add	r2,r2,r3
 20344cc:	11000015 	stw	r4,0(r2)
#if MEMP_OVERFLOW_CHECK
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
 20344d0:	008085f4 	movhi	r2,535
 20344d4:	10a8bc04 	addi	r2,r2,-23824
 20344d8:	e0ffff17 	ldw	r3,-4(fp)
 20344dc:	18c00584 	addi	r3,r3,22
 20344e0:	1806913a 	slli	r3,r3,4
 20344e4:	10c5883a 	add	r2,r2,r3
 20344e8:	10800084 	addi	r2,r2,2
 20344ec:	1080000b 	ldhu	r2,0(r2)
 20344f0:	10800044 	addi	r2,r2,1
 20344f4:	1009883a 	mov	r4,r2
 20344f8:	008085f4 	movhi	r2,535
 20344fc:	10a8bc04 	addi	r2,r2,-23824
 2034500:	e0ffff17 	ldw	r3,-4(fp)
 2034504:	18c00584 	addi	r3,r3,22
 2034508:	1806913a 	slli	r3,r3,4
 203450c:	10c5883a 	add	r2,r2,r3
 2034510:	10800084 	addi	r2,r2,2
 2034514:	1100000d 	sth	r4,0(r2)
 2034518:	008085f4 	movhi	r2,535
 203451c:	10a8bc04 	addi	r2,r2,-23824
 2034520:	e0ffff17 	ldw	r3,-4(fp)
 2034524:	1806913a 	slli	r3,r3,4
 2034528:	10c5883a 	add	r2,r2,r3
 203452c:	10805904 	addi	r2,r2,356
 2034530:	1100000b 	ldhu	r4,0(r2)
 2034534:	008085f4 	movhi	r2,535
 2034538:	10a8bc04 	addi	r2,r2,-23824
 203453c:	e0ffff17 	ldw	r3,-4(fp)
 2034540:	18c00584 	addi	r3,r3,22
 2034544:	1806913a 	slli	r3,r3,4
 2034548:	10c5883a 	add	r2,r2,r3
 203454c:	10800084 	addi	r2,r2,2
 2034550:	1080000b 	ldhu	r2,0(r2)
 2034554:	20ffffcc 	andi	r3,r4,65535
 2034558:	10bfffcc 	andi	r2,r2,65535
 203455c:	18801f2e 	bgeu	r3,r2,20345dc <memp_malloc+0x1a8>
 2034560:	008085f4 	movhi	r2,535
 2034564:	10a8bc04 	addi	r2,r2,-23824
 2034568:	e0ffff17 	ldw	r3,-4(fp)
 203456c:	18c00584 	addi	r3,r3,22
 2034570:	1806913a 	slli	r3,r3,4
 2034574:	10c5883a 	add	r2,r2,r3
 2034578:	10800084 	addi	r2,r2,2
 203457c:	10c0000b 	ldhu	r3,0(r2)
 2034580:	008085f4 	movhi	r2,535
 2034584:	10a8bc04 	addi	r2,r2,-23824
 2034588:	e13fff17 	ldw	r4,-4(fp)
 203458c:	2008913a 	slli	r4,r4,4
 2034590:	1105883a 	add	r2,r2,r4
 2034594:	10805904 	addi	r2,r2,356
 2034598:	10c0000d 	sth	r3,0(r2)
 203459c:	00000f06 	br	20345dc <memp_malloc+0x1a8>
    LWIP_ASSERT("memp_malloc: memp properly aligned",
                ((mem_ptr_t)memp % MEM_ALIGNMENT) == 0);
    memp = (struct memp*)(void *)((u8_t*)memp + MEMP_SIZE);
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
 20345a0:	008085f4 	movhi	r2,535
 20345a4:	10a8bc04 	addi	r2,r2,-23824
 20345a8:	e0ffff17 	ldw	r3,-4(fp)
 20345ac:	1806913a 	slli	r3,r3,4
 20345b0:	10c5883a 	add	r2,r2,r3
 20345b4:	10805a04 	addi	r2,r2,360
 20345b8:	10800017 	ldw	r2,0(r2)
 20345bc:	10c00044 	addi	r3,r2,1
 20345c0:	008085f4 	movhi	r2,535
 20345c4:	10a8bc04 	addi	r2,r2,-23824
 20345c8:	e13fff17 	ldw	r4,-4(fp)
 20345cc:	2008913a 	slli	r4,r4,4
 20345d0:	1105883a 	add	r2,r2,r4
 20345d4:	10805a04 	addi	r2,r2,360
 20345d8:	10c00015 	stw	r3,0(r2)
  }

  SYS_ARCH_UNPROTECT(old_level);
 20345dc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20345e0:	10000126 	beq	r2,zero,20345e8 <memp_malloc+0x1b4>
 20345e4:	2010f780 	call	2010f78 <vTaskExitCritical>

  return memp;
 20345e8:	e0bffe17 	ldw	r2,-8(fp)
}
 20345ec:	e037883a 	mov	sp,fp
 20345f0:	dfc00117 	ldw	ra,4(sp)
 20345f4:	df000017 	ldw	fp,0(sp)
 20345f8:	dec00204 	addi	sp,sp,8
 20345fc:	f800283a 	ret

02034600 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 2034600:	defffb04 	addi	sp,sp,-20
 2034604:	dfc00415 	stw	ra,16(sp)
 2034608:	df000315 	stw	fp,12(sp)
 203460c:	df000304 	addi	fp,sp,12
 2034610:	e13ffe15 	stw	r4,-8(fp)
 2034614:	e17fff15 	stw	r5,-4(fp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 2034618:	e0bfff17 	ldw	r2,-4(fp)
 203461c:	10002c26 	beq	r2,zero,20346d0 <memp_free+0xd0>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
 2034620:	e0bfff17 	ldw	r2,-4(fp)
 2034624:	e0bffd15 	stw	r2,-12(fp)

  SYS_ARCH_PROTECT(old_level);
 2034628:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203462c:	10000126 	beq	r2,zero,2034634 <memp_free+0x34>
 2034630:	2010f300 	call	2010f30 <vTaskEnterCritical>
  memp_overflow_check_element_overflow(memp, type);
  memp_overflow_check_element_underflow(memp, type);
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
 2034634:	008085f4 	movhi	r2,535
 2034638:	10a8bc04 	addi	r2,r2,-23824
 203463c:	e0fffe17 	ldw	r3,-8(fp)
 2034640:	18c00584 	addi	r3,r3,22
 2034644:	1806913a 	slli	r3,r3,4
 2034648:	10c5883a 	add	r2,r2,r3
 203464c:	10800084 	addi	r2,r2,2
 2034650:	1080000b 	ldhu	r2,0(r2)
 2034654:	10bfffc4 	addi	r2,r2,-1
 2034658:	1009883a 	mov	r4,r2
 203465c:	008085f4 	movhi	r2,535
 2034660:	10a8bc04 	addi	r2,r2,-23824
 2034664:	e0fffe17 	ldw	r3,-8(fp)
 2034668:	18c00584 	addi	r3,r3,22
 203466c:	1806913a 	slli	r3,r3,4
 2034670:	10c5883a 	add	r2,r2,r3
 2034674:	10800084 	addi	r2,r2,2
 2034678:	1100000d 	sth	r4,0(r2)
  
  memp->next = memp_tab[type]; 
 203467c:	00808574 	movhi	r2,533
 2034680:	10a02004 	addi	r2,r2,-32640
 2034684:	e0fffe17 	ldw	r3,-8(fp)
 2034688:	18c7883a 	add	r3,r3,r3
 203468c:	18c7883a 	add	r3,r3,r3
 2034690:	10c5883a 	add	r2,r2,r3
 2034694:	10c00017 	ldw	r3,0(r2)
 2034698:	e0bffd17 	ldw	r2,-12(fp)
 203469c:	10c00015 	stw	r3,0(r2)
  memp_tab[type] = memp;
 20346a0:	00808574 	movhi	r2,533
 20346a4:	10a02004 	addi	r2,r2,-32640
 20346a8:	e0fffe17 	ldw	r3,-8(fp)
 20346ac:	18c7883a 	add	r3,r3,r3
 20346b0:	18c7883a 	add	r3,r3,r3
 20346b4:	10c5883a 	add	r2,r2,r3
 20346b8:	e0fffd17 	ldw	r3,-12(fp)
 20346bc:	10c00015 	stw	r3,0(r2)

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 20346c0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20346c4:	10000326 	beq	r2,zero,20346d4 <memp_free+0xd4>
 20346c8:	2010f780 	call	2010f78 <vTaskExitCritical>
 20346cc:	00000106 	br	20346d4 <memp_free+0xd4>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
 20346d0:	0001883a 	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 20346d4:	e037883a 	mov	sp,fp
 20346d8:	dfc00117 	ldw	ra,4(sp)
 20346dc:	df000017 	ldw	fp,0(sp)
 20346e0:	dec00204 	addi	sp,sp,8
 20346e4:	f800283a 	ret

020346e8 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 20346e8:	defff704 	addi	sp,sp,-36
 20346ec:	dfc00815 	stw	ra,32(sp)
 20346f0:	df000715 	stw	fp,28(sp)
 20346f4:	df000704 	addi	fp,sp,28
 20346f8:	e13ffe15 	stw	r4,-8(fp)
 20346fc:	e17fff15 	stw	r5,-4(fp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
 2034700:	e03ffb05 	stb	zero,-20(fp)

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
 2034704:	e0bffe17 	ldw	r2,-8(fp)
 2034708:	10800117 	ldw	r2,4(r2)
 203470c:	e0bffc15 	stw	r2,-16(fp)
  proto = IPH_PROTO(iphdr);
 2034710:	e0bffc17 	ldw	r2,-16(fp)
 2034714:	10800243 	ldbu	r2,9(r2)
 2034718:	10803fcc 	andi	r2,r2,255
 203471c:	e0bffd0d 	sth	r2,-12(fp)

  prev = NULL;
 2034720:	e03ffa15 	stw	zero,-24(fp)
  pcb = raw_pcbs;
 2034724:	d0a81817 	ldw	r2,-24480(gp)
 2034728:	e0bff915 	stw	r2,-28(fp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 203472c:	00002f06 	br	20347ec <raw_input+0x104>
    if ((pcb->protocol == proto) &&
 2034730:	e0bff917 	ldw	r2,-28(fp)
 2034734:	10800403 	ldbu	r2,16(r2)
 2034738:	10c03fcc 	andi	r3,r2,255
 203473c:	e0bffd0f 	ldh	r2,-12(fp)
 2034740:	1880251e 	bne	r3,r2,20347d8 <raw_input+0xf0>
        (ip_addr_isany(&pcb->local_ip) ||
 2034744:	e0bff917 	ldw	r2,-28(fp)
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
 2034748:	10000726 	beq	r2,zero,2034768 <raw_input+0x80>
        (ip_addr_isany(&pcb->local_ip) ||
 203474c:	e0bff917 	ldw	r2,-28(fp)
 2034750:	10800017 	ldw	r2,0(r2)
 2034754:	10000426 	beq	r2,zero,2034768 <raw_input+0x80>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 2034758:	e0bff917 	ldw	r2,-28(fp)
 203475c:	10c00017 	ldw	r3,0(r2)
 2034760:	d0a81417 	ldw	r2,-24496(gp)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
 2034764:	18801c1e 	bne	r3,r2,20347d8 <raw_input+0xf0>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 2034768:	e0bff917 	ldw	r2,-28(fp)
 203476c:	10800517 	ldw	r2,20(r2)
 2034770:	10001926 	beq	r2,zero,20347d8 <raw_input+0xf0>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 2034774:	e0bff917 	ldw	r2,-28(fp)
 2034778:	10800517 	ldw	r2,20(r2)
 203477c:	e0fff917 	ldw	r3,-28(fp)
 2034780:	18c00617 	ldw	r3,24(r3)
 2034784:	d1e81204 	addi	r7,gp,-24504
 2034788:	e1bffe17 	ldw	r6,-8(fp)
 203478c:	e17ff917 	ldw	r5,-28(fp)
 2034790:	1809883a 	mov	r4,r3
 2034794:	103ee83a 	callr	r2
 2034798:	10803fcc 	andi	r2,r2,255
 203479c:	10000e26 	beq	r2,zero,20347d8 <raw_input+0xf0>
            /* receive function ate the packet */
            p = NULL;
 20347a0:	e03ffe15 	stw	zero,-8(fp)
            eaten = 1;
 20347a4:	00800044 	movi	r2,1
 20347a8:	e0bffb05 	stb	r2,-20(fp)
            if (prev != NULL) {
 20347ac:	e0bffa17 	ldw	r2,-24(fp)
 20347b0:	10000926 	beq	r2,zero,20347d8 <raw_input+0xf0>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 20347b4:	e0bff917 	ldw	r2,-28(fp)
 20347b8:	10c00317 	ldw	r3,12(r2)
 20347bc:	e0bffa17 	ldw	r2,-24(fp)
 20347c0:	10c00315 	stw	r3,12(r2)
              pcb->next = raw_pcbs;
 20347c4:	d0e81817 	ldw	r3,-24480(gp)
 20347c8:	e0bff917 	ldw	r2,-28(fp)
 20347cc:	10c00315 	stw	r3,12(r2)
              raw_pcbs = pcb;
 20347d0:	e0bff917 	ldw	r2,-28(fp)
 20347d4:	d0a81815 	stw	r2,-24480(gp)
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
 20347d8:	e0bff917 	ldw	r2,-28(fp)
 20347dc:	e0bffa15 	stw	r2,-24(fp)
    pcb = pcb->next;
 20347e0:	e0bff917 	ldw	r2,-28(fp)
 20347e4:	10800317 	ldw	r2,12(r2)
 20347e8:	e0bff915 	stw	r2,-28(fp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 20347ec:	e0bffb03 	ldbu	r2,-20(fp)
 20347f0:	1000021e 	bne	r2,zero,20347fc <raw_input+0x114>
 20347f4:	e0bff917 	ldw	r2,-28(fp)
 20347f8:	103fcd1e 	bne	r2,zero,2034730 <__alt_mem_mem_0+0xfd014730>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
 20347fc:	e0bffb03 	ldbu	r2,-20(fp)
}
 2034800:	e037883a 	mov	sp,fp
 2034804:	dfc00117 	ldw	ra,4(sp)
 2034808:	df000017 	ldw	fp,0(sp)
 203480c:	dec00204 	addi	sp,sp,8
 2034810:	f800283a 	ret

02034814 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
 2034814:	defffd04 	addi	sp,sp,-12
 2034818:	df000215 	stw	fp,8(sp)
 203481c:	df000204 	addi	fp,sp,8
 2034820:	e13ffe15 	stw	r4,-8(fp)
 2034824:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->local_ip, ipaddr);
 2034828:	e0bfff17 	ldw	r2,-4(fp)
 203482c:	10000326 	beq	r2,zero,203483c <raw_bind+0x28>
 2034830:	e0bfff17 	ldw	r2,-4(fp)
 2034834:	10800017 	ldw	r2,0(r2)
 2034838:	00000106 	br	2034840 <raw_bind+0x2c>
 203483c:	0005883a 	mov	r2,zero
 2034840:	e0fffe17 	ldw	r3,-8(fp)
 2034844:	18800015 	stw	r2,0(r3)
  return ERR_OK;
 2034848:	0005883a 	mov	r2,zero
}
 203484c:	e037883a 	mov	sp,fp
 2034850:	df000017 	ldw	fp,0(sp)
 2034854:	dec00104 	addi	sp,sp,4
 2034858:	f800283a 	ret

0203485c <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
 203485c:	defffd04 	addi	sp,sp,-12
 2034860:	df000215 	stw	fp,8(sp)
 2034864:	df000204 	addi	fp,sp,8
 2034868:	e13ffe15 	stw	r4,-8(fp)
 203486c:	e17fff15 	stw	r5,-4(fp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
 2034870:	e0bfff17 	ldw	r2,-4(fp)
 2034874:	10000326 	beq	r2,zero,2034884 <raw_connect+0x28>
 2034878:	e0bfff17 	ldw	r2,-4(fp)
 203487c:	10800017 	ldw	r2,0(r2)
 2034880:	00000106 	br	2034888 <raw_connect+0x2c>
 2034884:	0005883a 	mov	r2,zero
 2034888:	e0fffe17 	ldw	r3,-8(fp)
 203488c:	18800115 	stw	r2,4(r3)
  return ERR_OK;
 2034890:	0005883a 	mov	r2,zero
}
 2034894:	e037883a 	mov	sp,fp
 2034898:	df000017 	ldw	fp,0(sp)
 203489c:	dec00104 	addi	sp,sp,4
 20348a0:	f800283a 	ret

020348a4 <raw_recv>:
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
 20348a4:	defffc04 	addi	sp,sp,-16
 20348a8:	df000315 	stw	fp,12(sp)
 20348ac:	df000304 	addi	fp,sp,12
 20348b0:	e13ffd15 	stw	r4,-12(fp)
 20348b4:	e17ffe15 	stw	r5,-8(fp)
 20348b8:	e1bfff15 	stw	r6,-4(fp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
 20348bc:	e0bffd17 	ldw	r2,-12(fp)
 20348c0:	e0fffe17 	ldw	r3,-8(fp)
 20348c4:	10c00515 	stw	r3,20(r2)
  pcb->recv_arg = recv_arg;
 20348c8:	e0bffd17 	ldw	r2,-12(fp)
 20348cc:	e0ffff17 	ldw	r3,-4(fp)
 20348d0:	10c00615 	stw	r3,24(r2)
}
 20348d4:	0001883a 	nop
 20348d8:	e037883a 	mov	sp,fp
 20348dc:	df000017 	ldw	fp,0(sp)
 20348e0:	dec00104 	addi	sp,sp,4
 20348e4:	f800283a 	ret

020348e8 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
 20348e8:	defff404 	addi	sp,sp,-48
 20348ec:	dfc00b15 	stw	ra,44(sp)
 20348f0:	df000a15 	stw	fp,40(sp)
 20348f4:	df000a04 	addi	fp,sp,40
 20348f8:	e13ffd15 	stw	r4,-12(fp)
 20348fc:	e17ffe15 	stw	r5,-8(fp)
 2034900:	e1bfff15 	stw	r6,-4(fp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 2034904:	01400504 	movi	r5,20
 2034908:	e13ffe17 	ldw	r4,-8(fp)
 203490c:	201a9b80 	call	201a9b8 <pbuf_header>
 2034910:	10803fcc 	andi	r2,r2,255
 2034914:	10001126 	beq	r2,zero,203495c <raw_sendto+0x74>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 2034918:	000d883a 	mov	r6,zero
 203491c:	000b883a 	mov	r5,zero
 2034920:	01000044 	movi	r4,1
 2034924:	201a3ac0 	call	201a3ac <pbuf_alloc>
 2034928:	e0bffa15 	stw	r2,-24(fp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 203492c:	e0bffa17 	ldw	r2,-24(fp)
 2034930:	1000021e 	bne	r2,zero,203493c <raw_sendto+0x54>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 2034934:	00bfffc4 	movi	r2,-1
 2034938:	00004806 	br	2034a5c <raw_sendto+0x174>
    }
    if (p->tot_len != 0) {
 203493c:	e0bffe17 	ldw	r2,-8(fp)
 2034940:	1080020b 	ldhu	r2,8(r2)
 2034944:	10bfffcc 	andi	r2,r2,65535
 2034948:	10000d26 	beq	r2,zero,2034980 <raw_sendto+0x98>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
 203494c:	e17ffe17 	ldw	r5,-8(fp)
 2034950:	e13ffa17 	ldw	r4,-24(fp)
 2034954:	201ae300 	call	201ae30 <pbuf_chain>
 2034958:	00000906 	br	2034980 <raw_sendto+0x98>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
 203495c:	e0bffe17 	ldw	r2,-8(fp)
 2034960:	e0bffa15 	stw	r2,-24(fp)
    if(pbuf_header(q, -IP_HLEN)) {
 2034964:	017ffb04 	movi	r5,-20
 2034968:	e13ffa17 	ldw	r4,-24(fp)
 203496c:	201a9b80 	call	201a9b8 <pbuf_header>
 2034970:	10803fcc 	andi	r2,r2,255
 2034974:	10000226 	beq	r2,zero,2034980 <raw_sendto+0x98>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
 2034978:	00bfffc4 	movi	r2,-1
 203497c:	00003706 	br	2034a5c <raw_sendto+0x174>
    }
  }

  if ((netif = ip_route((struct ip_pcb*)pcb, ipaddr)) == NULL) {
 2034980:	e17fff17 	ldw	r5,-4(fp)
 2034984:	e13ffd17 	ldw	r4,-12(fp)
 2034988:	2031d1c0 	call	2031d1c <ip_route>
 203498c:	e0bffb15 	stw	r2,-20(fp)
 2034990:	e0bffb17 	ldw	r2,-20(fp)
 2034994:	1000071e 	bne	r2,zero,20349b4 <raw_sendto+0xcc>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
 2034998:	e0fffa17 	ldw	r3,-24(fp)
 203499c:	e0bffe17 	ldw	r2,-8(fp)
 20349a0:	18800226 	beq	r3,r2,20349ac <raw_sendto+0xc4>
      pbuf_free(q);
 20349a4:	e13ffa17 	ldw	r4,-24(fp)
 20349a8:	201ab680 	call	201ab68 <pbuf_free>
    }
    return ERR_RTE;
 20349ac:	00bfff04 	movi	r2,-4
 20349b0:	00002a06 	br	2034a5c <raw_sendto+0x174>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
 20349b4:	e0bffd17 	ldw	r2,-12(fp)
 20349b8:	10000326 	beq	r2,zero,20349c8 <raw_sendto+0xe0>
 20349bc:	e0bffd17 	ldw	r2,-12(fp)
 20349c0:	10800017 	ldw	r2,0(r2)
 20349c4:	1000041e 	bne	r2,zero,20349d8 <raw_sendto+0xf0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 20349c8:	e0bffb17 	ldw	r2,-20(fp)
 20349cc:	10800104 	addi	r2,r2,4
 20349d0:	e0bff915 	stw	r2,-28(fp)
 20349d4:	00000206 	br	20349e0 <raw_sendto+0xf8>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 20349d8:	e0bffd17 	ldw	r2,-12(fp)
 20349dc:	e0bff915 	stw	r2,-28(fp)
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
 20349e0:	e0bffd17 	ldw	r2,-12(fp)
 20349e4:	10c002c4 	addi	r3,r2,11
 20349e8:	e0bffb17 	ldw	r2,-20(fp)
 20349ec:	10c01015 	stw	r3,64(r2)
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 20349f0:	e0bffd17 	ldw	r2,-12(fp)
 20349f4:	10800283 	ldbu	r2,10(r2)
 20349f8:	11403fcc 	andi	r5,r2,255
 20349fc:	e0bffd17 	ldw	r2,-12(fp)
 2034a00:	10800243 	ldbu	r2,9(r2)
 2034a04:	10803fcc 	andi	r2,r2,255
 2034a08:	e0fffd17 	ldw	r3,-12(fp)
 2034a0c:	18c00403 	ldbu	r3,16(r3)
 2034a10:	18c03fcc 	andi	r3,r3,255
 2034a14:	e13ffb17 	ldw	r4,-20(fp)
 2034a18:	d9000215 	stw	r4,8(sp)
 2034a1c:	d8c00115 	stw	r3,4(sp)
 2034a20:	d8800015 	stw	r2,0(sp)
 2034a24:	280f883a 	mov	r7,r5
 2034a28:	e1bfff17 	ldw	r6,-4(fp)
 2034a2c:	e17ff917 	ldw	r5,-28(fp)
 2034a30:	e13ffa17 	ldw	r4,-24(fp)
 2034a34:	20323480 	call	2032348 <ip_output_if>
 2034a38:	e0bffc05 	stb	r2,-16(fp)
  NETIF_SET_HWADDRHINT(netif, NULL);
 2034a3c:	e0bffb17 	ldw	r2,-20(fp)
 2034a40:	10001015 	stw	zero,64(r2)

  /* did we chain a header earlier? */
  if (q != p) {
 2034a44:	e0fffa17 	ldw	r3,-24(fp)
 2034a48:	e0bffe17 	ldw	r2,-8(fp)
 2034a4c:	18800226 	beq	r3,r2,2034a58 <raw_sendto+0x170>
    /* free the header */
    pbuf_free(q);
 2034a50:	e13ffa17 	ldw	r4,-24(fp)
 2034a54:	201ab680 	call	201ab68 <pbuf_free>
  }
  return err;
 2034a58:	e0bffc03 	ldbu	r2,-16(fp)
}
 2034a5c:	e037883a 	mov	sp,fp
 2034a60:	dfc00117 	ldw	ra,4(sp)
 2034a64:	df000017 	ldw	fp,0(sp)
 2034a68:	dec00204 	addi	sp,sp,8
 2034a6c:	f800283a 	ret

02034a70 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
 2034a70:	defffc04 	addi	sp,sp,-16
 2034a74:	dfc00315 	stw	ra,12(sp)
 2034a78:	df000215 	stw	fp,8(sp)
 2034a7c:	df000204 	addi	fp,sp,8
 2034a80:	e13ffe15 	stw	r4,-8(fp)
 2034a84:	e17fff15 	stw	r5,-4(fp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
 2034a88:	e0bffe17 	ldw	r2,-8(fp)
 2034a8c:	10800104 	addi	r2,r2,4
 2034a90:	100d883a 	mov	r6,r2
 2034a94:	e17fff17 	ldw	r5,-4(fp)
 2034a98:	e13ffe17 	ldw	r4,-8(fp)
 2034a9c:	20348e80 	call	20348e8 <raw_sendto>
}
 2034aa0:	e037883a 	mov	sp,fp
 2034aa4:	dfc00117 	ldw	ra,4(sp)
 2034aa8:	df000017 	ldw	fp,0(sp)
 2034aac:	dec00204 	addi	sp,sp,8
 2034ab0:	f800283a 	ret

02034ab4 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 2034ab4:	defffc04 	addi	sp,sp,-16
 2034ab8:	dfc00315 	stw	ra,12(sp)
 2034abc:	df000215 	stw	fp,8(sp)
 2034ac0:	df000204 	addi	fp,sp,8
 2034ac4:	e13fff15 	stw	r4,-4(fp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 2034ac8:	d0e81817 	ldw	r3,-24480(gp)
 2034acc:	e0bfff17 	ldw	r2,-4(fp)
 2034ad0:	1880041e 	bne	r3,r2,2034ae4 <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 2034ad4:	d0a81817 	ldw	r2,-24480(gp)
 2034ad8:	10800317 	ldw	r2,12(r2)
 2034adc:	d0a81815 	stw	r2,-24480(gp)
 2034ae0:	00001306 	br	2034b30 <raw_remove+0x7c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 2034ae4:	d0a81817 	ldw	r2,-24480(gp)
 2034ae8:	e0bffe15 	stw	r2,-8(fp)
 2034aec:	00000e06 	br	2034b28 <raw_remove+0x74>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 2034af0:	e0bffe17 	ldw	r2,-8(fp)
 2034af4:	10800317 	ldw	r2,12(r2)
 2034af8:	10000826 	beq	r2,zero,2034b1c <raw_remove+0x68>
 2034afc:	e0bffe17 	ldw	r2,-8(fp)
 2034b00:	10c00317 	ldw	r3,12(r2)
 2034b04:	e0bfff17 	ldw	r2,-4(fp)
 2034b08:	1880041e 	bne	r3,r2,2034b1c <raw_remove+0x68>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 2034b0c:	e0bfff17 	ldw	r2,-4(fp)
 2034b10:	10c00317 	ldw	r3,12(r2)
 2034b14:	e0bffe17 	ldw	r2,-8(fp)
 2034b18:	10c00315 	stw	r3,12(r2)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 2034b1c:	e0bffe17 	ldw	r2,-8(fp)
 2034b20:	10800317 	ldw	r2,12(r2)
 2034b24:	e0bffe15 	stw	r2,-8(fp)
 2034b28:	e0bffe17 	ldw	r2,-8(fp)
 2034b2c:	103ff01e 	bne	r2,zero,2034af0 <__alt_mem_mem_0+0xfd014af0>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 2034b30:	e17fff17 	ldw	r5,-4(fp)
 2034b34:	0009883a 	mov	r4,zero
 2034b38:	20346000 	call	2034600 <memp_free>
}
 2034b3c:	0001883a 	nop
 2034b40:	e037883a 	mov	sp,fp
 2034b44:	dfc00117 	ldw	ra,4(sp)
 2034b48:	df000017 	ldw	fp,0(sp)
 2034b4c:	dec00204 	addi	sp,sp,8
 2034b50:	f800283a 	ret

02034b54 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 2034b54:	defffc04 	addi	sp,sp,-16
 2034b58:	dfc00315 	stw	ra,12(sp)
 2034b5c:	df000215 	stw	fp,8(sp)
 2034b60:	df000204 	addi	fp,sp,8
 2034b64:	2005883a 	mov	r2,r4
 2034b68:	e0bfff05 	stb	r2,-4(fp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 2034b6c:	0009883a 	mov	r4,zero
 2034b70:	20344340 	call	2034434 <memp_malloc>
 2034b74:	e0bffe15 	stw	r2,-8(fp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 2034b78:	e0bffe17 	ldw	r2,-8(fp)
 2034b7c:	10000f26 	beq	r2,zero,2034bbc <raw_new+0x68>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 2034b80:	01800704 	movi	r6,28
 2034b84:	000b883a 	mov	r5,zero
 2034b88:	e13ffe17 	ldw	r4,-8(fp)
 2034b8c:	200616c0 	call	200616c <memset>
    pcb->protocol = proto;
 2034b90:	e0bffe17 	ldw	r2,-8(fp)
 2034b94:	e0ffff03 	ldbu	r3,-4(fp)
 2034b98:	10c00405 	stb	r3,16(r2)
    pcb->ttl = RAW_TTL;
 2034b9c:	e0bffe17 	ldw	r2,-8(fp)
 2034ba0:	00c01004 	movi	r3,64
 2034ba4:	10c00285 	stb	r3,10(r2)
    pcb->next = raw_pcbs;
 2034ba8:	d0e81817 	ldw	r3,-24480(gp)
 2034bac:	e0bffe17 	ldw	r2,-8(fp)
 2034bb0:	10c00315 	stw	r3,12(r2)
    raw_pcbs = pcb;
 2034bb4:	e0bffe17 	ldw	r2,-8(fp)
 2034bb8:	d0a81815 	stw	r2,-24480(gp)
  }
  return pcb;
 2034bbc:	e0bffe17 	ldw	r2,-8(fp)
}
 2034bc0:	e037883a 	mov	sp,fp
 2034bc4:	dfc00117 	ldw	ra,4(sp)
 2034bc8:	df000017 	ldw	fp,0(sp)
 2034bcc:	dec00204 	addi	sp,sp,8
 2034bd0:	f800283a 	ret

02034bd4 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 2034bd4:	defff404 	addi	sp,sp,-48
 2034bd8:	dfc00b15 	stw	ra,44(sp)
 2034bdc:	df000a15 	stw	fp,40(sp)
 2034be0:	df000a04 	addi	fp,sp,40
 2034be4:	e13ffe15 	stw	r4,-8(fp)
 2034be8:	e17fff15 	stw	r5,-4(fp)
  struct tcp_pcb *pcb, *prev;
  struct tcp_pcb_listen *lpcb;
#if SO_REUSE
  struct tcp_pcb *lpcb_prev = NULL;
 2034bec:	e03ffb15 	stw	zero,-20(fp)
  struct tcp_pcb_listen *lpcb_any = NULL;
 2034bf0:	e03ffc15 	stw	zero,-16(fp)
  u8_t hdrlen;
  err_t err;

  PERF_START;

  TCP_STATS_INC(tcp.recv);
 2034bf4:	008085f4 	movhi	r2,535
 2034bf8:	10a8bc04 	addi	r2,r2,-23824
 2034bfc:	10804917 	ldw	r2,292(r2)
 2034c00:	10c00044 	addi	r3,r2,1
 2034c04:	008085f4 	movhi	r2,535
 2034c08:	10a8bc04 	addi	r2,r2,-23824
 2034c0c:	10c04915 	stw	r3,292(r2)
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 2034c10:	e0bffe17 	ldw	r2,-8(fp)
 2034c14:	10800117 	ldw	r2,4(r2)
 2034c18:	d0a81a15 	stw	r2,-24472(gp)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 2034c1c:	e0bffe17 	ldw	r2,-8(fp)
 2034c20:	10c00117 	ldw	r3,4(r2)
 2034c24:	d0a81a17 	ldw	r2,-24472(gp)
 2034c28:	10800003 	ldbu	r2,0(r2)
 2034c2c:	10803fcc 	andi	r2,r2,255
 2034c30:	108003cc 	andi	r2,r2,15
 2034c34:	1085883a 	add	r2,r2,r2
 2034c38:	1085883a 	add	r2,r2,r2
 2034c3c:	1885883a 	add	r2,r3,r2
 2034c40:	d0a81915 	stw	r2,-24476(gp)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 2034c44:	d0a81a17 	ldw	r2,-24472(gp)
 2034c48:	10800003 	ldbu	r2,0(r2)
 2034c4c:	10803fcc 	andi	r2,r2,255
 2034c50:	108003cc 	andi	r2,r2,15
 2034c54:	1085883a 	add	r2,r2,r2
 2034c58:	1085883a 	add	r2,r2,r2
 2034c5c:	0085c83a 	sub	r2,zero,r2
 2034c60:	10bfffcc 	andi	r2,r2,65535
 2034c64:	10a0001c 	xori	r2,r2,32768
 2034c68:	10a00004 	addi	r2,r2,-32768
 2034c6c:	100b883a 	mov	r5,r2
 2034c70:	e13ffe17 	ldw	r4,-8(fp)
 2034c74:	201a9b80 	call	201a9b8 <pbuf_header>
 2034c78:	10803fcc 	andi	r2,r2,255
 2034c7c:	1000051e 	bne	r2,zero,2034c94 <tcp_input+0xc0>
 2034c80:	e0bffe17 	ldw	r2,-8(fp)
 2034c84:	1080020b 	ldhu	r2,8(r2)
 2034c88:	10bfffcc 	andi	r2,r2,65535
 2034c8c:	10800528 	cmpgeui	r2,r2,20
 2034c90:	1000081e 	bne	r2,zero,2034cb4 <tcp_input+0xe0>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
 2034c94:	008085f4 	movhi	r2,535
 2034c98:	10a8bc04 	addi	r2,r2,-23824
 2034c9c:	10804d17 	ldw	r2,308(r2)
 2034ca0:	10c00044 	addi	r3,r2,1
 2034ca4:	008085f4 	movhi	r2,535
 2034ca8:	10a8bc04 	addi	r2,r2,-23824
 2034cac:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 2034cb0:	00035706 	br	2035a10 <tcp_input+0xe3c>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 2034cb4:	d0a81417 	ldw	r2,-24496(gp)
 2034cb8:	e17fff17 	ldw	r5,-4(fp)
 2034cbc:	1009883a 	mov	r4,r2
 2034cc0:	20189240 	call	2018924 <ip4_addr_isbroadcast>
 2034cc4:	10803fcc 	andi	r2,r2,255
 2034cc8:	1000041e 	bne	r2,zero,2034cdc <tcp_input+0x108>
      ip_addr_ismulticast(&current_iphdr_dest)) {
 2034ccc:	d0a81417 	ldw	r2,-24496(gp)
 2034cd0:	10803c0c 	andi	r2,r2,240
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 2034cd4:	10803818 	cmpnei	r2,r2,224
 2034cd8:	1000081e 	bne	r2,zero,2034cfc <tcp_input+0x128>
      ip_addr_ismulticast(&current_iphdr_dest)) {
    TCP_STATS_INC(tcp.proterr);
 2034cdc:	008085f4 	movhi	r2,535
 2034ce0:	10a8bc04 	addi	r2,r2,-23824
 2034ce4:	10805017 	ldw	r2,320(r2)
 2034ce8:	10c00044 	addi	r3,r2,1
 2034cec:	008085f4 	movhi	r2,535
 2034cf0:	10a8bc04 	addi	r2,r2,-23824
 2034cf4:	10c05015 	stw	r3,320(r2)
    goto dropped;
 2034cf8:	00034506 	br	2035a10 <tcp_input+0xe3c>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len) != 0) {
 2034cfc:	e0bffe17 	ldw	r2,-8(fp)
 2034d00:	1080020b 	ldhu	r2,8(r2)
    goto dropped;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
 2034d04:	10bfffcc 	andi	r2,r2,65535
 2034d08:	d8800015 	stw	r2,0(sp)
 2034d0c:	01c00184 	movi	r7,6
 2034d10:	d1a81404 	addi	r6,gp,-24496
 2034d14:	d1681204 	addi	r5,gp,-24504
 2034d18:	e13ffe17 	ldw	r4,-8(fp)
 2034d1c:	203173c0 	call	203173c <inet_chksum_pseudo>
 2034d20:	10bfffcc 	andi	r2,r2,65535
 2034d24:	10000826 	beq	r2,zero,2034d48 <tcp_input+0x174>
        inet_chksum_pseudo(p, ip_current_src_addr(), ip_current_dest_addr(),
      IP_PROTO_TCP, p->tot_len)));
#if TCP_DEBUG
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
 2034d28:	008085f4 	movhi	r2,535
 2034d2c:	10a8bc04 	addi	r2,r2,-23824
 2034d30:	10804c17 	ldw	r2,304(r2)
 2034d34:	10c00044 	addi	r3,r2,1
 2034d38:	008085f4 	movhi	r2,535
 2034d3c:	10a8bc04 	addi	r2,r2,-23824
 2034d40:	10c04c15 	stw	r3,304(r2)
    goto dropped;
 2034d44:	00033206 	br	2035a10 <tcp_input+0xe3c>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 2034d48:	d0a81917 	ldw	r2,-24476(gp)
 2034d4c:	10c00303 	ldbu	r3,12(r2)
 2034d50:	10800343 	ldbu	r2,13(r2)
 2034d54:	1004923a 	slli	r2,r2,8
 2034d58:	10c4b03a 	or	r2,r2,r3
 2034d5c:	10bfffcc 	andi	r2,r2,65535
 2034d60:	1004d23a 	srli	r2,r2,8
 2034d64:	10ffffcc 	andi	r3,r2,65535
 2034d68:	d0a81917 	ldw	r2,-24476(gp)
 2034d6c:	11000303 	ldbu	r4,12(r2)
 2034d70:	10800343 	ldbu	r2,13(r2)
 2034d74:	1004923a 	slli	r2,r2,8
 2034d78:	1104b03a 	or	r2,r2,r4
 2034d7c:	10bfffcc 	andi	r2,r2,65535
 2034d80:	1004923a 	slli	r2,r2,8
 2034d84:	10bfffcc 	andi	r2,r2,65535
 2034d88:	1884b03a 	or	r2,r3,r2
 2034d8c:	1005d33a 	srai	r2,r2,12
 2034d90:	e0bffd45 	stb	r2,-11(fp)
  if(pbuf_header(p, -(hdrlen * 4))){
 2034d94:	e0bffd43 	ldbu	r2,-11(fp)
 2034d98:	10bfff24 	muli	r2,r2,-4
 2034d9c:	10bfffcc 	andi	r2,r2,65535
 2034da0:	10a0001c 	xori	r2,r2,32768
 2034da4:	10a00004 	addi	r2,r2,-32768
 2034da8:	100b883a 	mov	r5,r2
 2034dac:	e13ffe17 	ldw	r4,-8(fp)
 2034db0:	201a9b80 	call	201a9b8 <pbuf_header>
 2034db4:	10803fcc 	andi	r2,r2,255
 2034db8:	10000826 	beq	r2,zero,2034ddc <tcp_input+0x208>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
 2034dbc:	008085f4 	movhi	r2,535
 2034dc0:	10a8bc04 	addi	r2,r2,-23824
 2034dc4:	10804d17 	ldw	r2,308(r2)
 2034dc8:	10c00044 	addi	r3,r2,1
 2034dcc:	008085f4 	movhi	r2,535
 2034dd0:	10a8bc04 	addi	r2,r2,-23824
 2034dd4:	10c04d15 	stw	r3,308(r2)
    goto dropped;
 2034dd8:	00030d06 	br	2035a10 <tcp_input+0xe3c>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 2034ddc:	d0a81917 	ldw	r2,-24476(gp)
 2034de0:	d0e81917 	ldw	r3,-24476(gp)
 2034de4:	19000003 	ldbu	r4,0(r3)
 2034de8:	18c00043 	ldbu	r3,1(r3)
 2034dec:	1806923a 	slli	r3,r3,8
 2034df0:	1906b03a 	or	r3,r3,r4
 2034df4:	18ffffcc 	andi	r3,r3,65535
 2034df8:	1806d23a 	srli	r3,r3,8
 2034dfc:	180b883a 	mov	r5,r3
 2034e00:	d0e81917 	ldw	r3,-24476(gp)
 2034e04:	19000003 	ldbu	r4,0(r3)
 2034e08:	18c00043 	ldbu	r3,1(r3)
 2034e0c:	1806923a 	slli	r3,r3,8
 2034e10:	1906b03a 	or	r3,r3,r4
 2034e14:	18ffffcc 	andi	r3,r3,65535
 2034e18:	1806923a 	slli	r3,r3,8
 2034e1c:	28c6b03a 	or	r3,r5,r3
 2034e20:	180d883a 	mov	r6,r3
 2034e24:	30ffffcc 	andi	r3,r6,65535
 2034e28:	19403fcc 	andi	r5,r3,255
 2034e2c:	10c00003 	ldbu	r3,0(r2)
 2034e30:	1806703a 	and	r3,r3,zero
 2034e34:	1809883a 	mov	r4,r3
 2034e38:	2807883a 	mov	r3,r5
 2034e3c:	20c6b03a 	or	r3,r4,r3
 2034e40:	10c00005 	stb	r3,0(r2)
 2034e44:	30ffffcc 	andi	r3,r6,65535
 2034e48:	1806d23a 	srli	r3,r3,8
 2034e4c:	197fffcc 	andi	r5,r3,65535
 2034e50:	10c00043 	ldbu	r3,1(r2)
 2034e54:	1806703a 	and	r3,r3,zero
 2034e58:	1809883a 	mov	r4,r3
 2034e5c:	2807883a 	mov	r3,r5
 2034e60:	20c6b03a 	or	r3,r4,r3
 2034e64:	10c00045 	stb	r3,1(r2)
  tcphdr->dest = ntohs(tcphdr->dest);
 2034e68:	d0a81917 	ldw	r2,-24476(gp)
 2034e6c:	d0e81917 	ldw	r3,-24476(gp)
 2034e70:	19000083 	ldbu	r4,2(r3)
 2034e74:	18c000c3 	ldbu	r3,3(r3)
 2034e78:	1806923a 	slli	r3,r3,8
 2034e7c:	1906b03a 	or	r3,r3,r4
 2034e80:	18ffffcc 	andi	r3,r3,65535
 2034e84:	1806d23a 	srli	r3,r3,8
 2034e88:	180b883a 	mov	r5,r3
 2034e8c:	d0e81917 	ldw	r3,-24476(gp)
 2034e90:	19000083 	ldbu	r4,2(r3)
 2034e94:	18c000c3 	ldbu	r3,3(r3)
 2034e98:	1806923a 	slli	r3,r3,8
 2034e9c:	1906b03a 	or	r3,r3,r4
 2034ea0:	18ffffcc 	andi	r3,r3,65535
 2034ea4:	1806923a 	slli	r3,r3,8
 2034ea8:	28c6b03a 	or	r3,r5,r3
 2034eac:	180d883a 	mov	r6,r3
 2034eb0:	30ffffcc 	andi	r3,r6,65535
 2034eb4:	19403fcc 	andi	r5,r3,255
 2034eb8:	10c00083 	ldbu	r3,2(r2)
 2034ebc:	1806703a 	and	r3,r3,zero
 2034ec0:	1809883a 	mov	r4,r3
 2034ec4:	2807883a 	mov	r3,r5
 2034ec8:	20c6b03a 	or	r3,r4,r3
 2034ecc:	10c00085 	stb	r3,2(r2)
 2034ed0:	30ffffcc 	andi	r3,r6,65535
 2034ed4:	1806d23a 	srli	r3,r3,8
 2034ed8:	197fffcc 	andi	r5,r3,65535
 2034edc:	10c000c3 	ldbu	r3,3(r2)
 2034ee0:	1806703a 	and	r3,r3,zero
 2034ee4:	1809883a 	mov	r4,r3
 2034ee8:	2807883a 	mov	r3,r5
 2034eec:	20c6b03a 	or	r3,r4,r3
 2034ef0:	10c000c5 	stb	r3,3(r2)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 2034ef4:	d0a81917 	ldw	r2,-24476(gp)
 2034ef8:	d0e81917 	ldw	r3,-24476(gp)
 2034efc:	19000103 	ldbu	r4,4(r3)
 2034f00:	19400143 	ldbu	r5,5(r3)
 2034f04:	280a923a 	slli	r5,r5,8
 2034f08:	2908b03a 	or	r4,r5,r4
 2034f0c:	19400183 	ldbu	r5,6(r3)
 2034f10:	280a943a 	slli	r5,r5,16
 2034f14:	2908b03a 	or	r4,r5,r4
 2034f18:	18c001c3 	ldbu	r3,7(r3)
 2034f1c:	1806963a 	slli	r3,r3,24
 2034f20:	1906b03a 	or	r3,r3,r4
 2034f24:	1808d63a 	srli	r4,r3,24
 2034f28:	d0e81917 	ldw	r3,-24476(gp)
 2034f2c:	19400103 	ldbu	r5,4(r3)
 2034f30:	19800143 	ldbu	r6,5(r3)
 2034f34:	300c923a 	slli	r6,r6,8
 2034f38:	314ab03a 	or	r5,r6,r5
 2034f3c:	19800183 	ldbu	r6,6(r3)
 2034f40:	300c943a 	slli	r6,r6,16
 2034f44:	314ab03a 	or	r5,r6,r5
 2034f48:	18c001c3 	ldbu	r3,7(r3)
 2034f4c:	1806963a 	slli	r3,r3,24
 2034f50:	1946b03a 	or	r3,r3,r5
 2034f54:	1806d23a 	srli	r3,r3,8
 2034f58:	18ffc00c 	andi	r3,r3,65280
 2034f5c:	20c8b03a 	or	r4,r4,r3
 2034f60:	d0e81917 	ldw	r3,-24476(gp)
 2034f64:	19400103 	ldbu	r5,4(r3)
 2034f68:	19800143 	ldbu	r6,5(r3)
 2034f6c:	300c923a 	slli	r6,r6,8
 2034f70:	314ab03a 	or	r5,r6,r5
 2034f74:	19800183 	ldbu	r6,6(r3)
 2034f78:	300c943a 	slli	r6,r6,16
 2034f7c:	314ab03a 	or	r5,r6,r5
 2034f80:	18c001c3 	ldbu	r3,7(r3)
 2034f84:	1806963a 	slli	r3,r3,24
 2034f88:	1946b03a 	or	r3,r3,r5
 2034f8c:	18ffc00c 	andi	r3,r3,65280
 2034f90:	1806923a 	slli	r3,r3,8
 2034f94:	20c8b03a 	or	r4,r4,r3
 2034f98:	d0e81917 	ldw	r3,-24476(gp)
 2034f9c:	19400103 	ldbu	r5,4(r3)
 2034fa0:	19800143 	ldbu	r6,5(r3)
 2034fa4:	300c923a 	slli	r6,r6,8
 2034fa8:	314ab03a 	or	r5,r6,r5
 2034fac:	19800183 	ldbu	r6,6(r3)
 2034fb0:	300c943a 	slli	r6,r6,16
 2034fb4:	314ab03a 	or	r5,r6,r5
 2034fb8:	18c001c3 	ldbu	r3,7(r3)
 2034fbc:	1806963a 	slli	r3,r3,24
 2034fc0:	1946b03a 	or	r3,r3,r5
 2034fc4:	1806963a 	slli	r3,r3,24
 2034fc8:	20c6b03a 	or	r3,r4,r3
 2034fcc:	19803fcc 	andi	r6,r3,255
 2034fd0:	11000103 	ldbu	r4,4(r2)
 2034fd4:	2008703a 	and	r4,r4,zero
 2034fd8:	200b883a 	mov	r5,r4
 2034fdc:	3009883a 	mov	r4,r6
 2034fe0:	2908b03a 	or	r4,r5,r4
 2034fe4:	11000105 	stb	r4,4(r2)
 2034fe8:	1808d23a 	srli	r4,r3,8
 2034fec:	21803fcc 	andi	r6,r4,255
 2034ff0:	11000143 	ldbu	r4,5(r2)
 2034ff4:	2008703a 	and	r4,r4,zero
 2034ff8:	200b883a 	mov	r5,r4
 2034ffc:	3009883a 	mov	r4,r6
 2035000:	2908b03a 	or	r4,r5,r4
 2035004:	11000145 	stb	r4,5(r2)
 2035008:	1808d43a 	srli	r4,r3,16
 203500c:	21803fcc 	andi	r6,r4,255
 2035010:	11000183 	ldbu	r4,6(r2)
 2035014:	2008703a 	and	r4,r4,zero
 2035018:	200b883a 	mov	r5,r4
 203501c:	3009883a 	mov	r4,r6
 2035020:	2908b03a 	or	r4,r5,r4
 2035024:	11000185 	stb	r4,6(r2)
 2035028:	180ad63a 	srli	r5,r3,24
 203502c:	10c001c3 	ldbu	r3,7(r2)
 2035030:	1806703a 	and	r3,r3,zero
 2035034:	1809883a 	mov	r4,r3
 2035038:	2807883a 	mov	r3,r5
 203503c:	20c6b03a 	or	r3,r4,r3
 2035040:	10c001c5 	stb	r3,7(r2)
 2035044:	10c00103 	ldbu	r3,4(r2)
 2035048:	11000143 	ldbu	r4,5(r2)
 203504c:	2008923a 	slli	r4,r4,8
 2035050:	20c6b03a 	or	r3,r4,r3
 2035054:	11000183 	ldbu	r4,6(r2)
 2035058:	2008943a 	slli	r4,r4,16
 203505c:	20c6b03a 	or	r3,r4,r3
 2035060:	108001c3 	ldbu	r2,7(r2)
 2035064:	1004963a 	slli	r2,r2,24
 2035068:	10c4b03a 	or	r2,r2,r3
 203506c:	d0a81b15 	stw	r2,-24468(gp)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 2035070:	d0a81917 	ldw	r2,-24476(gp)
 2035074:	d0e81917 	ldw	r3,-24476(gp)
 2035078:	19000203 	ldbu	r4,8(r3)
 203507c:	19400243 	ldbu	r5,9(r3)
 2035080:	280a923a 	slli	r5,r5,8
 2035084:	2908b03a 	or	r4,r5,r4
 2035088:	19400283 	ldbu	r5,10(r3)
 203508c:	280a943a 	slli	r5,r5,16
 2035090:	2908b03a 	or	r4,r5,r4
 2035094:	18c002c3 	ldbu	r3,11(r3)
 2035098:	1806963a 	slli	r3,r3,24
 203509c:	1906b03a 	or	r3,r3,r4
 20350a0:	1808d63a 	srli	r4,r3,24
 20350a4:	d0e81917 	ldw	r3,-24476(gp)
 20350a8:	19400203 	ldbu	r5,8(r3)
 20350ac:	19800243 	ldbu	r6,9(r3)
 20350b0:	300c923a 	slli	r6,r6,8
 20350b4:	314ab03a 	or	r5,r6,r5
 20350b8:	19800283 	ldbu	r6,10(r3)
 20350bc:	300c943a 	slli	r6,r6,16
 20350c0:	314ab03a 	or	r5,r6,r5
 20350c4:	18c002c3 	ldbu	r3,11(r3)
 20350c8:	1806963a 	slli	r3,r3,24
 20350cc:	1946b03a 	or	r3,r3,r5
 20350d0:	1806d23a 	srli	r3,r3,8
 20350d4:	18ffc00c 	andi	r3,r3,65280
 20350d8:	20c8b03a 	or	r4,r4,r3
 20350dc:	d0e81917 	ldw	r3,-24476(gp)
 20350e0:	19400203 	ldbu	r5,8(r3)
 20350e4:	19800243 	ldbu	r6,9(r3)
 20350e8:	300c923a 	slli	r6,r6,8
 20350ec:	314ab03a 	or	r5,r6,r5
 20350f0:	19800283 	ldbu	r6,10(r3)
 20350f4:	300c943a 	slli	r6,r6,16
 20350f8:	314ab03a 	or	r5,r6,r5
 20350fc:	18c002c3 	ldbu	r3,11(r3)
 2035100:	1806963a 	slli	r3,r3,24
 2035104:	1946b03a 	or	r3,r3,r5
 2035108:	18ffc00c 	andi	r3,r3,65280
 203510c:	1806923a 	slli	r3,r3,8
 2035110:	20c8b03a 	or	r4,r4,r3
 2035114:	d0e81917 	ldw	r3,-24476(gp)
 2035118:	19400203 	ldbu	r5,8(r3)
 203511c:	19800243 	ldbu	r6,9(r3)
 2035120:	300c923a 	slli	r6,r6,8
 2035124:	314ab03a 	or	r5,r6,r5
 2035128:	19800283 	ldbu	r6,10(r3)
 203512c:	300c943a 	slli	r6,r6,16
 2035130:	314ab03a 	or	r5,r6,r5
 2035134:	18c002c3 	ldbu	r3,11(r3)
 2035138:	1806963a 	slli	r3,r3,24
 203513c:	1946b03a 	or	r3,r3,r5
 2035140:	1806963a 	slli	r3,r3,24
 2035144:	20c6b03a 	or	r3,r4,r3
 2035148:	19803fcc 	andi	r6,r3,255
 203514c:	11000203 	ldbu	r4,8(r2)
 2035150:	2008703a 	and	r4,r4,zero
 2035154:	200b883a 	mov	r5,r4
 2035158:	3009883a 	mov	r4,r6
 203515c:	2908b03a 	or	r4,r5,r4
 2035160:	11000205 	stb	r4,8(r2)
 2035164:	1808d23a 	srli	r4,r3,8
 2035168:	21803fcc 	andi	r6,r4,255
 203516c:	11000243 	ldbu	r4,9(r2)
 2035170:	2008703a 	and	r4,r4,zero
 2035174:	200b883a 	mov	r5,r4
 2035178:	3009883a 	mov	r4,r6
 203517c:	2908b03a 	or	r4,r5,r4
 2035180:	11000245 	stb	r4,9(r2)
 2035184:	1808d43a 	srli	r4,r3,16
 2035188:	21803fcc 	andi	r6,r4,255
 203518c:	11000283 	ldbu	r4,10(r2)
 2035190:	2008703a 	and	r4,r4,zero
 2035194:	200b883a 	mov	r5,r4
 2035198:	3009883a 	mov	r4,r6
 203519c:	2908b03a 	or	r4,r5,r4
 20351a0:	11000285 	stb	r4,10(r2)
 20351a4:	180ad63a 	srli	r5,r3,24
 20351a8:	10c002c3 	ldbu	r3,11(r2)
 20351ac:	1806703a 	and	r3,r3,zero
 20351b0:	1809883a 	mov	r4,r3
 20351b4:	2807883a 	mov	r3,r5
 20351b8:	20c6b03a 	or	r3,r4,r3
 20351bc:	10c002c5 	stb	r3,11(r2)
 20351c0:	10c00203 	ldbu	r3,8(r2)
 20351c4:	11000243 	ldbu	r4,9(r2)
 20351c8:	2008923a 	slli	r4,r4,8
 20351cc:	20c6b03a 	or	r3,r4,r3
 20351d0:	11000283 	ldbu	r4,10(r2)
 20351d4:	2008943a 	slli	r4,r4,16
 20351d8:	20c6b03a 	or	r3,r4,r3
 20351dc:	108002c3 	ldbu	r2,11(r2)
 20351e0:	1004963a 	slli	r2,r2,24
 20351e4:	10c4b03a 	or	r2,r2,r3
 20351e8:	d0a81c15 	stw	r2,-24464(gp)
  tcphdr->wnd = ntohs(tcphdr->wnd);
 20351ec:	d0a81917 	ldw	r2,-24476(gp)
 20351f0:	d0e81917 	ldw	r3,-24476(gp)
 20351f4:	19000383 	ldbu	r4,14(r3)
 20351f8:	18c003c3 	ldbu	r3,15(r3)
 20351fc:	1806923a 	slli	r3,r3,8
 2035200:	1906b03a 	or	r3,r3,r4
 2035204:	18ffffcc 	andi	r3,r3,65535
 2035208:	1806d23a 	srli	r3,r3,8
 203520c:	180b883a 	mov	r5,r3
 2035210:	d0e81917 	ldw	r3,-24476(gp)
 2035214:	19000383 	ldbu	r4,14(r3)
 2035218:	18c003c3 	ldbu	r3,15(r3)
 203521c:	1806923a 	slli	r3,r3,8
 2035220:	1906b03a 	or	r3,r3,r4
 2035224:	18ffffcc 	andi	r3,r3,65535
 2035228:	1806923a 	slli	r3,r3,8
 203522c:	28c6b03a 	or	r3,r5,r3
 2035230:	180d883a 	mov	r6,r3
 2035234:	30ffffcc 	andi	r3,r6,65535
 2035238:	19403fcc 	andi	r5,r3,255
 203523c:	10c00383 	ldbu	r3,14(r2)
 2035240:	1806703a 	and	r3,r3,zero
 2035244:	1809883a 	mov	r4,r3
 2035248:	2807883a 	mov	r3,r5
 203524c:	20c6b03a 	or	r3,r4,r3
 2035250:	10c00385 	stb	r3,14(r2)
 2035254:	30ffffcc 	andi	r3,r6,65535
 2035258:	1806d23a 	srli	r3,r3,8
 203525c:	197fffcc 	andi	r5,r3,65535
 2035260:	10c003c3 	ldbu	r3,15(r2)
 2035264:	1806703a 	and	r3,r3,zero
 2035268:	1809883a 	mov	r4,r3
 203526c:	2807883a 	mov	r3,r5
 2035270:	20c6b03a 	or	r3,r4,r3
 2035274:	10c003c5 	stb	r3,15(r2)

  flags = TCPH_FLAGS(tcphdr);
 2035278:	d0a81917 	ldw	r2,-24476(gp)
 203527c:	10c00303 	ldbu	r3,12(r2)
 2035280:	10800343 	ldbu	r2,13(r2)
 2035284:	1004923a 	slli	r2,r2,8
 2035288:	10c4b03a 	or	r2,r2,r3
 203528c:	10bfffcc 	andi	r2,r2,65535
 2035290:	1004d23a 	srli	r2,r2,8
 2035294:	1009883a 	mov	r4,r2
 2035298:	d0a81917 	ldw	r2,-24476(gp)
 203529c:	10c00303 	ldbu	r3,12(r2)
 20352a0:	10800343 	ldbu	r2,13(r2)
 20352a4:	1004923a 	slli	r2,r2,8
 20352a8:	10c4b03a 	or	r2,r2,r3
 20352ac:	10bfffcc 	andi	r2,r2,65535
 20352b0:	1004923a 	slli	r2,r2,8
 20352b4:	2084b03a 	or	r2,r4,r2
 20352b8:	10800fcc 	andi	r2,r2,63
 20352bc:	d0a81d05 	stb	r2,-24460(gp)
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 20352c0:	e0bffe17 	ldw	r2,-8(fp)
 20352c4:	10c0020b 	ldhu	r3,8(r2)
 20352c8:	d0a81d03 	ldbu	r2,-24460(gp)
 20352cc:	10803fcc 	andi	r2,r2,255
 20352d0:	108000cc 	andi	r2,r2,3
 20352d4:	1004c03a 	cmpne	r2,r2,zero
 20352d8:	10803fcc 	andi	r2,r2,255
 20352dc:	1885883a 	add	r2,r3,r2
 20352e0:	d0a81d8d 	sth	r2,-24458(gp)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
 20352e4:	e03ff915 	stw	zero,-28(fp)

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 20352e8:	d0a7f717 	ldw	r2,-24612(gp)
 20352ec:	e0bff815 	stw	r2,-32(fp)
 20352f0:	00002d06 	br	20353a8 <tcp_input+0x7d4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 20352f4:	e0bff817 	ldw	r2,-32(fp)
 20352f8:	1100080b 	ldhu	r4,32(r2)
 20352fc:	d0a81917 	ldw	r2,-24476(gp)
 2035300:	10c00003 	ldbu	r3,0(r2)
 2035304:	10800043 	ldbu	r2,1(r2)
 2035308:	1004923a 	slli	r2,r2,8
 203530c:	10c4b03a 	or	r2,r2,r3
 2035310:	20ffffcc 	andi	r3,r4,65535
 2035314:	10bfffcc 	andi	r2,r2,65535
 2035318:	18801e1e 	bne	r3,r2,2035394 <tcp_input+0x7c0>
       pcb->local_port == tcphdr->dest &&
 203531c:	e0bff817 	ldw	r2,-32(fp)
 2035320:	1100078b 	ldhu	r4,30(r2)
 2035324:	d0a81917 	ldw	r2,-24476(gp)
 2035328:	10c00083 	ldbu	r3,2(r2)
 203532c:	108000c3 	ldbu	r2,3(r2)
 2035330:	1004923a 	slli	r2,r2,8
 2035334:	10c4b03a 	or	r2,r2,r3
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 2035338:	20ffffcc 	andi	r3,r4,65535
 203533c:	10bfffcc 	andi	r2,r2,65535
 2035340:	1880141e 	bne	r3,r2,2035394 <tcp_input+0x7c0>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 2035344:	e0bff817 	ldw	r2,-32(fp)
 2035348:	10c00117 	ldw	r3,4(r2)
 203534c:	d0a81217 	ldw	r2,-24504(gp)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
 2035350:	1880101e 	bne	r3,r2,2035394 <tcp_input+0x7c0>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 2035354:	e0bff817 	ldw	r2,-32(fp)
 2035358:	10c00017 	ldw	r3,0(r2)
 203535c:	d0a81417 	ldw	r2,-24496(gp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 2035360:	18800c1e 	bne	r3,r2,2035394 <tcp_input+0x7c0>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
 2035364:	e0bff917 	ldw	r2,-28(fp)
 2035368:	10001226 	beq	r2,zero,20353b4 <tcp_input+0x7e0>
        prev->next = pcb->next;
 203536c:	e0bff817 	ldw	r2,-32(fp)
 2035370:	10c00317 	ldw	r3,12(r2)
 2035374:	e0bff917 	ldw	r2,-28(fp)
 2035378:	10c00315 	stw	r3,12(r2)
        pcb->next = tcp_active_pcbs;
 203537c:	d0e7f717 	ldw	r3,-24612(gp)
 2035380:	e0bff817 	ldw	r2,-32(fp)
 2035384:	10c00315 	stw	r3,12(r2)
        tcp_active_pcbs = pcb;
 2035388:	e0bff817 	ldw	r2,-32(fp)
 203538c:	d0a7f715 	stw	r2,-24612(gp)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 2035390:	00000806 	br	20353b4 <tcp_input+0x7e0>
    }
    prev = pcb;
 2035394:	e0bff817 	ldw	r2,-32(fp)
 2035398:	e0bff915 	stw	r2,-28(fp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 203539c:	e0bff817 	ldw	r2,-32(fp)
 20353a0:	10800317 	ldw	r2,12(r2)
 20353a4:	e0bff815 	stw	r2,-32(fp)
 20353a8:	e0bff817 	ldw	r2,-32(fp)
 20353ac:	103fd11e 	bne	r2,zero,20352f4 <__alt_mem_mem_0+0xfd0152f4>
 20353b0:	00000106 	br	20353b8 <tcp_input+0x7e4>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
 20353b4:	0001883a 	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
 20353b8:	e0bff817 	ldw	r2,-32(fp)
 20353bc:	1000651e 	bne	r2,zero,2035554 <tcp_input+0x980>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 20353c0:	d0a7fc17 	ldw	r2,-24592(gp)
 20353c4:	e0bff815 	stw	r2,-32(fp)
 20353c8:	00002406 	br	203545c <tcp_input+0x888>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 20353cc:	e0bff817 	ldw	r2,-32(fp)
 20353d0:	1100080b 	ldhu	r4,32(r2)
 20353d4:	d0a81917 	ldw	r2,-24476(gp)
 20353d8:	10c00003 	ldbu	r3,0(r2)
 20353dc:	10800043 	ldbu	r2,1(r2)
 20353e0:	1004923a 	slli	r2,r2,8
 20353e4:	10c4b03a 	or	r2,r2,r3
 20353e8:	20ffffcc 	andi	r3,r4,65535
 20353ec:	10bfffcc 	andi	r2,r2,65535
 20353f0:	1880171e 	bne	r3,r2,2035450 <tcp_input+0x87c>
         pcb->local_port == tcphdr->dest &&
 20353f4:	e0bff817 	ldw	r2,-32(fp)
 20353f8:	1100078b 	ldhu	r4,30(r2)
 20353fc:	d0a81917 	ldw	r2,-24476(gp)
 2035400:	10c00083 	ldbu	r3,2(r2)
 2035404:	108000c3 	ldbu	r2,3(r2)
 2035408:	1004923a 	slli	r2,r2,8
 203540c:	10c4b03a 	or	r2,r2,r3
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 2035410:	20ffffcc 	andi	r3,r4,65535
 2035414:	10bfffcc 	andi	r2,r2,65535
 2035418:	18800d1e 	bne	r3,r2,2035450 <tcp_input+0x87c>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 203541c:	e0bff817 	ldw	r2,-32(fp)
 2035420:	10c00117 	ldw	r3,4(r2)
 2035424:	d0a81217 	ldw	r2,-24504(gp)
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
 2035428:	1880091e 	bne	r3,r2,2035450 <tcp_input+0x87c>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
 203542c:	e0bff817 	ldw	r2,-32(fp)
 2035430:	10c00017 	ldw	r3,0(r2)
 2035434:	d0a81417 	ldw	r2,-24496(gp)
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 2035438:	1880051e 	bne	r3,r2,2035450 <tcp_input+0x87c>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
 203543c:	e13ff817 	ldw	r4,-32(fp)
 2035440:	2035d380 	call	2035d38 <tcp_timewait_input>
        pbuf_free(p);
 2035444:	e13ffe17 	ldw	r4,-8(fp)
 2035448:	201ab680 	call	201ab68 <pbuf_free>
        return;
 203544c:	00017b06 	br	2035a3c <tcp_input+0xe68>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 2035450:	e0bff817 	ldw	r2,-32(fp)
 2035454:	10800317 	ldw	r2,12(r2)
 2035458:	e0bff815 	stw	r2,-32(fp)
 203545c:	e0bff817 	ldw	r2,-32(fp)
 2035460:	103fda1e 	bne	r2,zero,20353cc <__alt_mem_mem_0+0xfd0153cc>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
 2035464:	e03ff915 	stw	zero,-28(fp)
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2035468:	d0a7f917 	ldw	r2,-24604(gp)
 203546c:	e0bffa15 	stw	r2,-24(fp)
 2035470:	00001c06 	br	20354e4 <tcp_input+0x910>
      if (lpcb->local_port == tcphdr->dest) {
 2035474:	e0bffa17 	ldw	r2,-24(fp)
 2035478:	1100078b 	ldhu	r4,30(r2)
 203547c:	d0a81917 	ldw	r2,-24476(gp)
 2035480:	10c00083 	ldbu	r3,2(r2)
 2035484:	108000c3 	ldbu	r2,3(r2)
 2035488:	1004923a 	slli	r2,r2,8
 203548c:	10c4b03a 	or	r2,r2,r3
 2035490:	20ffffcc 	andi	r3,r4,65535
 2035494:	10bfffcc 	andi	r2,r2,65535
 2035498:	18800d1e 	bne	r3,r2,20354d0 <tcp_input+0x8fc>
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
 203549c:	e0bffa17 	ldw	r2,-24(fp)
 20354a0:	10c00017 	ldw	r3,0(r2)
 20354a4:	d0a81417 	ldw	r2,-24496(gp)
 20354a8:	18801126 	beq	r3,r2,20354f0 <tcp_input+0x91c>
          /* found an exact match */
          break;
        } else if(ip_addr_isany(&(lpcb->local_ip))) {
 20354ac:	e0bffa17 	ldw	r2,-24(fp)
 20354b0:	10000326 	beq	r2,zero,20354c0 <tcp_input+0x8ec>
 20354b4:	e0bffa17 	ldw	r2,-24(fp)
 20354b8:	10800017 	ldw	r2,0(r2)
 20354bc:	1000041e 	bne	r2,zero,20354d0 <tcp_input+0x8fc>
          /* found an ANY-match */
          lpcb_any = lpcb;
 20354c0:	e0bffa17 	ldw	r2,-24(fp)
 20354c4:	e0bffc15 	stw	r2,-16(fp)
          lpcb_prev = prev;
 20354c8:	e0bff917 	ldw	r2,-28(fp)
 20354cc:	e0bffb15 	stw	r2,-20(fp)
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
 20354d0:	e0bffa17 	ldw	r2,-24(fp)
 20354d4:	e0bff915 	stw	r2,-28(fp)
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 20354d8:	e0bffa17 	ldw	r2,-24(fp)
 20354dc:	10800317 	ldw	r2,12(r2)
 20354e0:	e0bffa15 	stw	r2,-24(fp)
 20354e4:	e0bffa17 	ldw	r2,-24(fp)
 20354e8:	103fe21e 	bne	r2,zero,2035474 <__alt_mem_mem_0+0xfd015474>
 20354ec:	00000106 	br	20354f4 <tcp_input+0x920>
      if (lpcb->local_port == tcphdr->dest) {
#if SO_REUSE
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest)) {
          /* found an exact match */
          break;
 20354f0:	0001883a 	nop
      }
      prev = (struct tcp_pcb *)lpcb;
    }
#if SO_REUSE
    /* first try specific local IP */
    if (lpcb == NULL) {
 20354f4:	e0bffa17 	ldw	r2,-24(fp)
 20354f8:	1000041e 	bne	r2,zero,203550c <tcp_input+0x938>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
 20354fc:	e0bffc17 	ldw	r2,-16(fp)
 2035500:	e0bffa15 	stw	r2,-24(fp)
      prev = lpcb_prev;
 2035504:	e0bffb17 	ldw	r2,-20(fp)
 2035508:	e0bff915 	stw	r2,-28(fp)
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
 203550c:	e0bffa17 	ldw	r2,-24(fp)
 2035510:	10001026 	beq	r2,zero,2035554 <tcp_input+0x980>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 2035514:	e0bff917 	ldw	r2,-28(fp)
 2035518:	10000926 	beq	r2,zero,2035540 <tcp_input+0x96c>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 203551c:	e0bffa17 	ldw	r2,-24(fp)
 2035520:	10c00317 	ldw	r3,12(r2)
 2035524:	e0bff917 	ldw	r2,-28(fp)
 2035528:	10c00315 	stw	r3,12(r2)
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 203552c:	d0e7f917 	ldw	r3,-24604(gp)
 2035530:	e0bffa17 	ldw	r2,-24(fp)
 2035534:	10c00315 	stw	r3,12(r2)
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 2035538:	e0bffa17 	ldw	r2,-24(fp)
 203553c:	d0a7f915 	stw	r2,-24604(gp)
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
 2035540:	e13ffa17 	ldw	r4,-24(fp)
 2035544:	2035a500 	call	2035a50 <tcp_listen_input>
      pbuf_free(p);
 2035548:	e13ffe17 	ldw	r4,-8(fp)
 203554c:	201ab680 	call	201ab68 <pbuf_free>
      return;
 2035550:	00013a06 	br	2035a3c <tcp_input+0xe68>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
 2035554:	e0bff817 	ldw	r2,-32(fp)
 2035558:	1000f226 	beq	r2,zero,2035924 <tcp_input+0xd50>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 203555c:	008085b4 	movhi	r2,534
 2035560:	10888b04 	addi	r2,r2,8748
 2035564:	10000015 	stw	zero,0(r2)
    inseg.len = p->tot_len;
 2035568:	e0bffe17 	ldw	r2,-8(fp)
 203556c:	10c0020b 	ldhu	r3,8(r2)
 2035570:	008085b4 	movhi	r2,534
 2035574:	10888b04 	addi	r2,r2,8748
 2035578:	10c0020d 	sth	r3,8(r2)
    inseg.p = p;
 203557c:	008085b4 	movhi	r2,534
 2035580:	10888b04 	addi	r2,r2,8748
 2035584:	e0fffe17 	ldw	r3,-8(fp)
 2035588:	10c00115 	stw	r3,4(r2)
    inseg.tcphdr = tcphdr;
 203558c:	d0e81917 	ldw	r3,-24476(gp)
 2035590:	008085b4 	movhi	r2,534
 2035594:	10888b04 	addi	r2,r2,8748
 2035598:	10c00415 	stw	r3,16(r2)

    recv_data = NULL;
 203559c:	d0281f15 	stw	zero,-24452(gp)
    recv_flags = 0;
 20355a0:	d0281e05 	stb	zero,-24456(gp)

    if (flags & TCP_PSH) {
 20355a4:	d0a81d03 	ldbu	r2,-24460(gp)
 20355a8:	10803fcc 	andi	r2,r2,255
 20355ac:	1080020c 	andi	r2,r2,8
 20355b0:	10000626 	beq	r2,zero,20355cc <tcp_input+0x9f8>
      p->flags |= PBUF_FLAG_PUSH;
 20355b4:	e0bffe17 	ldw	r2,-8(fp)
 20355b8:	10800343 	ldbu	r2,13(r2)
 20355bc:	10800054 	ori	r2,r2,1
 20355c0:	1007883a 	mov	r3,r2
 20355c4:	e0bffe17 	ldw	r2,-8(fp)
 20355c8:	10c00345 	stb	r3,13(r2)
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 20355cc:	e0bff817 	ldw	r2,-32(fp)
 20355d0:	10801f17 	ldw	r2,124(r2)
 20355d4:	10001526 	beq	r2,zero,203562c <tcp_input+0xa58>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 20355d8:	e13ff817 	ldw	r4,-32(fp)
 20355dc:	201d28c0 	call	201d28c <tcp_process_refused_data>
 20355e0:	10803fcc 	andi	r2,r2,255
 20355e4:	1080201c 	xori	r2,r2,128
 20355e8:	10bfe004 	addi	r2,r2,-128
 20355ec:	10bffda0 	cmpeqi	r2,r2,-10
 20355f0:	1000061e 	bne	r2,zero,203560c <tcp_input+0xa38>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 20355f4:	e0bff817 	ldw	r2,-32(fp)
 20355f8:	10801f17 	ldw	r2,124(r2)
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 20355fc:	10000b26 	beq	r2,zero,203562c <tcp_input+0xa58>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 2035600:	d0a81d8b 	ldhu	r2,-24458(gp)
 2035604:	10bfffcc 	andi	r2,r2,65535
 2035608:	10000826 	beq	r2,zero,203562c <tcp_input+0xa58>
        /* pcb has been aborted or refused data is still refused and the new
           segment contains data */
        TCP_STATS_INC(tcp.drop);
 203560c:	008085f4 	movhi	r2,535
 2035610:	10a8bc04 	addi	r2,r2,-23824
 2035614:	10804b17 	ldw	r2,300(r2)
 2035618:	10c00044 	addi	r3,r2,1
 203561c:	008085f4 	movhi	r2,535
 2035620:	10a8bc04 	addi	r2,r2,-23824
 2035624:	10c04b15 	stw	r3,300(r2)
        snmp_inc_tcpinerrs();
        goto aborted;
 2035628:	0000af06 	br	20358e8 <tcp_input+0xd14>
      }
    }
    tcp_input_pcb = pcb;
 203562c:	e0bff817 	ldw	r2,-32(fp)
 2035630:	d0a82015 	stw	r2,-24448(gp)
    err = tcp_process(pcb);
 2035634:	e13ff817 	ldw	r4,-32(fp)
 2035638:	2035e740 	call	2035e74 <tcp_process>
 203563c:	e0bffd05 	stb	r2,-12(fp)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
 2035640:	e0bffd07 	ldb	r2,-12(fp)
 2035644:	10bffda0 	cmpeqi	r2,r2,-10
 2035648:	1000a71e 	bne	r2,zero,20358e8 <tcp_input+0xd14>
      if (recv_flags & TF_RESET) {
 203564c:	d0a81e03 	ldbu	r2,-24456(gp)
 2035650:	10803fcc 	andi	r2,r2,255
 2035654:	1080020c 	andi	r2,r2,8
 2035658:	10001126 	beq	r2,zero,20356a0 <tcp_input+0xacc>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 203565c:	e0bff817 	ldw	r2,-32(fp)
 2035660:	10802417 	ldw	r2,144(r2)
 2035664:	10000726 	beq	r2,zero,2035684 <tcp_input+0xab0>
 2035668:	e0bff817 	ldw	r2,-32(fp)
 203566c:	10802417 	ldw	r2,144(r2)
 2035670:	e0fff817 	ldw	r3,-32(fp)
 2035674:	18c00417 	ldw	r3,16(r3)
 2035678:	017ffd44 	movi	r5,-11
 203567c:	1809883a 	mov	r4,r3
 2035680:	103ee83a 	callr	r2
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 2035684:	e17ff817 	ldw	r5,-32(fp)
 2035688:	d127f704 	addi	r4,gp,-24612
 203568c:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 2035690:	e17ff817 	ldw	r5,-32(fp)
 2035694:	01000084 	movi	r4,2
 2035698:	20346000 	call	2034600 <memp_free>
 203569c:	00009206 	br	20358e8 <tcp_input+0xd14>
      } else if (recv_flags & TF_CLOSED) {
 20356a0:	d0a81e03 	ldbu	r2,-24456(gp)
 20356a4:	10803fcc 	andi	r2,r2,255
 20356a8:	1080040c 	andi	r2,r2,16
 20356ac:	10001626 	beq	r2,zero,2035708 <tcp_input+0xb34>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
 20356b0:	e0bff817 	ldw	r2,-32(fp)
 20356b4:	10800883 	ldbu	r2,34(r2)
 20356b8:	10803fcc 	andi	r2,r2,255
 20356bc:	1080040c 	andi	r2,r2,16
 20356c0:	10000a1e 	bne	r2,zero,20356ec <tcp_input+0xb18>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 20356c4:	e0bff817 	ldw	r2,-32(fp)
 20356c8:	10802417 	ldw	r2,144(r2)
 20356cc:	10000726 	beq	r2,zero,20356ec <tcp_input+0xb18>
 20356d0:	e0bff817 	ldw	r2,-32(fp)
 20356d4:	10802417 	ldw	r2,144(r2)
 20356d8:	e0fff817 	ldw	r3,-32(fp)
 20356dc:	18c00417 	ldw	r3,16(r3)
 20356e0:	017ffd04 	movi	r5,-12
 20356e4:	1809883a 	mov	r4,r3
 20356e8:	103ee83a 	callr	r2
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 20356ec:	e17ff817 	ldw	r5,-32(fp)
 20356f0:	d127f704 	addi	r4,gp,-24612
 20356f4:	201dbfc0 	call	201dbfc <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 20356f8:	e17ff817 	ldw	r5,-32(fp)
 20356fc:	01000084 	movi	r4,2
 2035700:	20346000 	call	2034600 <memp_free>
 2035704:	00007806 	br	20358e8 <tcp_input+0xd14>
      } else {
        err = ERR_OK;
 2035708:	e03ffd05 	stb	zero,-12(fp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 203570c:	e0bff817 	ldw	r2,-32(fp)
 2035710:	10801a0b 	ldhu	r2,104(r2)
 2035714:	10bfffcc 	andi	r2,r2,65535
 2035718:	10001326 	beq	r2,zero,2035768 <tcp_input+0xb94>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 203571c:	e0bff817 	ldw	r2,-32(fp)
 2035720:	10802017 	ldw	r2,128(r2)
 2035724:	10000c26 	beq	r2,zero,2035758 <tcp_input+0xb84>
 2035728:	e0bff817 	ldw	r2,-32(fp)
 203572c:	10802017 	ldw	r2,128(r2)
 2035730:	e0fff817 	ldw	r3,-32(fp)
 2035734:	19000417 	ldw	r4,16(r3)
 2035738:	e0fff817 	ldw	r3,-32(fp)
 203573c:	18c01a0b 	ldhu	r3,104(r3)
 2035740:	18ffffcc 	andi	r3,r3,65535
 2035744:	180d883a 	mov	r6,r3
 2035748:	e17ff817 	ldw	r5,-32(fp)
 203574c:	103ee83a 	callr	r2
 2035750:	e0bffd05 	stb	r2,-12(fp)
 2035754:	00000106 	br	203575c <tcp_input+0xb88>
 2035758:	e03ffd05 	stb	zero,-12(fp)
          if (err == ERR_ABRT) {
 203575c:	e0bffd07 	ldb	r2,-12(fp)
 2035760:	10bffd98 	cmpnei	r2,r2,-10
 2035764:	10005b26 	beq	r2,zero,20358d4 <tcp_input+0xd00>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
 2035768:	d0a81f17 	ldw	r2,-24452(gp)
 203576c:	10002926 	beq	r2,zero,2035814 <tcp_input+0xc40>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
 2035770:	e0bff817 	ldw	r2,-32(fp)
 2035774:	10800883 	ldbu	r2,34(r2)
 2035778:	10803fcc 	andi	r2,r2,255
 203577c:	1080040c 	andi	r2,r2,16
 2035780:	10000626 	beq	r2,zero,203579c <tcp_input+0xbc8>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 2035784:	d0a81f17 	ldw	r2,-24452(gp)
 2035788:	1009883a 	mov	r4,r2
 203578c:	201ab680 	call	201ab68 <pbuf_free>
            tcp_abort(pcb);
 2035790:	e13ff817 	ldw	r4,-32(fp)
 2035794:	201bfb40 	call	201bfb4 <tcp_abort>
            goto aborted;
 2035798:	00005306 	br	20358e8 <tcp_input+0xd14>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 203579c:	e0bff817 	ldw	r2,-32(fp)
 20357a0:	10802117 	ldw	r2,132(r2)
 20357a4:	10000c26 	beq	r2,zero,20357d8 <tcp_input+0xc04>
 20357a8:	e0bff817 	ldw	r2,-32(fp)
 20357ac:	10802117 	ldw	r2,132(r2)
 20357b0:	e0fff817 	ldw	r3,-32(fp)
 20357b4:	18c00417 	ldw	r3,16(r3)
 20357b8:	d1281f17 	ldw	r4,-24452(gp)
 20357bc:	000f883a 	mov	r7,zero
 20357c0:	200d883a 	mov	r6,r4
 20357c4:	e17ff817 	ldw	r5,-32(fp)
 20357c8:	1809883a 	mov	r4,r3
 20357cc:	103ee83a 	callr	r2
 20357d0:	e0bffd05 	stb	r2,-12(fp)
 20357d4:	00000706 	br	20357f4 <tcp_input+0xc20>
 20357d8:	d0a81f17 	ldw	r2,-24452(gp)
 20357dc:	000f883a 	mov	r7,zero
 20357e0:	100d883a 	mov	r6,r2
 20357e4:	e17ff817 	ldw	r5,-32(fp)
 20357e8:	0009883a 	mov	r4,zero
 20357ec:	201d52c0 	call	201d52c <tcp_recv_null>
 20357f0:	e0bffd05 	stb	r2,-12(fp)
          if (err == ERR_ABRT) {
 20357f4:	e0bffd07 	ldb	r2,-12(fp)
 20357f8:	10bffd98 	cmpnei	r2,r2,-10
 20357fc:	10003726 	beq	r2,zero,20358dc <tcp_input+0xd08>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 2035800:	e0bffd07 	ldb	r2,-12(fp)
 2035804:	10000326 	beq	r2,zero,2035814 <tcp_input+0xc40>
            pcb->refused_data = recv_data;
 2035808:	d0e81f17 	ldw	r3,-24452(gp)
 203580c:	e0bff817 	ldw	r2,-32(fp)
 2035810:	10c01f15 	stw	r3,124(r2)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 2035814:	d0a81e03 	ldbu	r2,-24456(gp)
 2035818:	10803fcc 	andi	r2,r2,255
 203581c:	1080080c 	andi	r2,r2,32
 2035820:	10002826 	beq	r2,zero,20358c4 <tcp_input+0xcf0>
          if (pcb->refused_data != NULL) {
 2035824:	e0bff817 	ldw	r2,-32(fp)
 2035828:	10801f17 	ldw	r2,124(r2)
 203582c:	10000826 	beq	r2,zero,2035850 <tcp_input+0xc7c>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 2035830:	e0bff817 	ldw	r2,-32(fp)
 2035834:	10801f17 	ldw	r2,124(r2)
 2035838:	e0fff817 	ldw	r3,-32(fp)
 203583c:	18c01f17 	ldw	r3,124(r3)
 2035840:	18c00343 	ldbu	r3,13(r3)
 2035844:	18c00814 	ori	r3,r3,32
 2035848:	10c00345 	stb	r3,13(r2)
 203584c:	00001d06 	br	20358c4 <tcp_input+0xcf0>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 2035850:	e0bff817 	ldw	r2,-32(fp)
 2035854:	10800c0b 	ldhu	r2,48(r2)
 2035858:	10bfffcc 	andi	r2,r2,65535
 203585c:	10880020 	cmpeqi	r2,r2,8192
 2035860:	1000061e 	bne	r2,zero,203587c <tcp_input+0xca8>
              pcb->rcv_wnd++;
 2035864:	e0bff817 	ldw	r2,-32(fp)
 2035868:	10800c0b 	ldhu	r2,48(r2)
 203586c:	10800044 	addi	r2,r2,1
 2035870:	1007883a 	mov	r3,r2
 2035874:	e0bff817 	ldw	r2,-32(fp)
 2035878:	10c00c0d 	sth	r3,48(r2)
            }
            TCP_EVENT_CLOSED(pcb, err);
 203587c:	e0bff817 	ldw	r2,-32(fp)
 2035880:	10802117 	ldw	r2,132(r2)
 2035884:	10000b26 	beq	r2,zero,20358b4 <tcp_input+0xce0>
 2035888:	e0bff817 	ldw	r2,-32(fp)
 203588c:	10802117 	ldw	r2,132(r2)
 2035890:	e0fff817 	ldw	r3,-32(fp)
 2035894:	18c00417 	ldw	r3,16(r3)
 2035898:	000f883a 	mov	r7,zero
 203589c:	000d883a 	mov	r6,zero
 20358a0:	e17ff817 	ldw	r5,-32(fp)
 20358a4:	1809883a 	mov	r4,r3
 20358a8:	103ee83a 	callr	r2
 20358ac:	e0bffd05 	stb	r2,-12(fp)
 20358b0:	00000106 	br	20358b8 <tcp_input+0xce4>
 20358b4:	e03ffd05 	stb	zero,-12(fp)
            if (err == ERR_ABRT) {
 20358b8:	e0bffd07 	ldb	r2,-12(fp)
 20358bc:	10bffd98 	cmpnei	r2,r2,-10
 20358c0:	10000826 	beq	r2,zero,20358e4 <tcp_input+0xd10>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 20358c4:	d0282015 	stw	zero,-24448(gp)
        /* Try to send something out. */
        tcp_output(pcb);
 20358c8:	e13ff817 	ldw	r4,-32(fp)
 20358cc:	201f7800 	call	201f780 <tcp_output>
 20358d0:	00000506 	br	20358e8 <tcp_input+0xd14>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
 20358d4:	0001883a 	nop
 20358d8:	00000306 	br	20358e8 <tcp_input+0xd14>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
 20358dc:	0001883a 	nop
 20358e0:	00000106 	br	20358e8 <tcp_input+0xd14>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
 20358e4:	0001883a 	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 20358e8:	d0282015 	stw	zero,-24448(gp)
    recv_data = NULL;
 20358ec:	d0281f15 	stw	zero,-24452(gp)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 20358f0:	008085b4 	movhi	r2,534
 20358f4:	10888b04 	addi	r2,r2,8748
 20358f8:	10800117 	ldw	r2,4(r2)
 20358fc:	10004e26 	beq	r2,zero,2035a38 <tcp_input+0xe64>
    {
      pbuf_free(inseg.p);
 2035900:	008085b4 	movhi	r2,534
 2035904:	10888b04 	addi	r2,r2,8748
 2035908:	10800117 	ldw	r2,4(r2)
 203590c:	1009883a 	mov	r4,r2
 2035910:	201ab680 	call	201ab68 <pbuf_free>
      inseg.p = NULL;
 2035914:	008085b4 	movhi	r2,534
 2035918:	10888b04 	addi	r2,r2,8748
 203591c:	10000115 	stw	zero,4(r2)
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2035920:	00004506 	br	2035a38 <tcp_input+0xe64>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 2035924:	d0a81917 	ldw	r2,-24476(gp)
 2035928:	10c00303 	ldbu	r3,12(r2)
 203592c:	10800343 	ldbu	r2,13(r2)
 2035930:	1004923a 	slli	r2,r2,8
 2035934:	10c4b03a 	or	r2,r2,r3
 2035938:	10bfffcc 	andi	r2,r2,65535
 203593c:	1004d23a 	srli	r2,r2,8
 2035940:	10ffffcc 	andi	r3,r2,65535
 2035944:	d0a81917 	ldw	r2,-24476(gp)
 2035948:	11000303 	ldbu	r4,12(r2)
 203594c:	10800343 	ldbu	r2,13(r2)
 2035950:	1004923a 	slli	r2,r2,8
 2035954:	1104b03a 	or	r2,r2,r4
 2035958:	10bfffcc 	andi	r2,r2,65535
 203595c:	1004923a 	slli	r2,r2,8
 2035960:	10bfffcc 	andi	r2,r2,65535
 2035964:	1884b03a 	or	r2,r3,r2
 2035968:	1080010c 	andi	r2,r2,4
 203596c:	1000251e 	bne	r2,zero,2035a04 <tcp_input+0xe30>
      TCP_STATS_INC(tcp.proterr);
 2035970:	008085f4 	movhi	r2,535
 2035974:	10a8bc04 	addi	r2,r2,-23824
 2035978:	10805017 	ldw	r2,320(r2)
 203597c:	10c00044 	addi	r3,r2,1
 2035980:	008085f4 	movhi	r2,535
 2035984:	10a8bc04 	addi	r2,r2,-23824
 2035988:	10c05015 	stw	r3,320(r2)
      TCP_STATS_INC(tcp.drop);
 203598c:	008085f4 	movhi	r2,535
 2035990:	10a8bc04 	addi	r2,r2,-23824
 2035994:	10804b17 	ldw	r2,300(r2)
 2035998:	10c00044 	addi	r3,r2,1
 203599c:	008085f4 	movhi	r2,535
 20359a0:	10a8bc04 	addi	r2,r2,-23824
 20359a4:	10c04b15 	stw	r3,300(r2)
      tcp_rst(ackno, seqno + tcplen,
 20359a8:	d2281c17 	ldw	r8,-24464(gp)
 20359ac:	d0a81d8b 	ldhu	r2,-24458(gp)
 20359b0:	10ffffcc 	andi	r3,r2,65535
 20359b4:	d0a81b17 	ldw	r2,-24468(gp)
 20359b8:	188b883a 	add	r5,r3,r2
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 20359bc:	d0a81917 	ldw	r2,-24476(gp)
 20359c0:	10c00083 	ldbu	r3,2(r2)
 20359c4:	108000c3 	ldbu	r2,3(r2)
 20359c8:	1004923a 	slli	r2,r2,8
 20359cc:	10c4b03a 	or	r2,r2,r3
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 20359d0:	10ffffcc 	andi	r3,r2,65535
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 20359d4:	d0a81917 	ldw	r2,-24476(gp)
 20359d8:	11000003 	ldbu	r4,0(r2)
 20359dc:	10800043 	ldbu	r2,1(r2)
 20359e0:	1004923a 	slli	r2,r2,8
 20359e4:	1104b03a 	or	r2,r2,r4
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 20359e8:	10bfffcc 	andi	r2,r2,65535
 20359ec:	d8800115 	stw	r2,4(sp)
 20359f0:	d8c00015 	stw	r3,0(sp)
 20359f4:	d1e81204 	addi	r7,gp,-24504
 20359f8:	d1a81404 	addi	r6,gp,-24496
 20359fc:	4009883a 	mov	r4,r8
 2035a00:	202082c0 	call	202082c <tcp_rst>
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
 2035a04:	e13ffe17 	ldw	r4,-8(fp)
 2035a08:	201ab680 	call	201ab68 <pbuf_free>
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2035a0c:	00000a06 	br	2035a38 <tcp_input+0xe64>
dropped:
  TCP_STATS_INC(tcp.drop);
 2035a10:	008085f4 	movhi	r2,535
 2035a14:	10a8bc04 	addi	r2,r2,-23824
 2035a18:	10804b17 	ldw	r2,300(r2)
 2035a1c:	10c00044 	addi	r3,r2,1
 2035a20:	008085f4 	movhi	r2,535
 2035a24:	10a8bc04 	addi	r2,r2,-23824
 2035a28:	10c04b15 	stw	r3,300(r2)
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 2035a2c:	e13ffe17 	ldw	r4,-8(fp)
 2035a30:	201ab680 	call	201ab68 <pbuf_free>
 2035a34:	00000106 	br	2035a3c <tcp_input+0xe68>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
 2035a38:	0001883a 	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 2035a3c:	e037883a 	mov	sp,fp
 2035a40:	dfc00117 	ldw	ra,4(sp)
 2035a44:	df000017 	ldw	fp,0(sp)
 2035a48:	dec00204 	addi	sp,sp,8
 2035a4c:	f800283a 	ret

02035a50 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
 2035a50:	defff904 	addi	sp,sp,-28
 2035a54:	dfc00615 	stw	ra,24(sp)
 2035a58:	df000515 	stw	fp,20(sp)
 2035a5c:	df000504 	addi	fp,sp,20
 2035a60:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
 2035a64:	d0a81d03 	ldbu	r2,-24460(gp)
 2035a68:	10803fcc 	andi	r2,r2,255
 2035a6c:	1080010c 	andi	r2,r2,4
 2035a70:	10000226 	beq	r2,zero,2035a7c <tcp_listen_input+0x2c>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
 2035a74:	0005883a 	mov	r2,zero
 2035a78:	0000aa06 	br	2035d24 <tcp_listen_input+0x2d4>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 2035a7c:	d0a81d03 	ldbu	r2,-24460(gp)
 2035a80:	10803fcc 	andi	r2,r2,255
 2035a84:	1080040c 	andi	r2,r2,16
 2035a88:	10001826 	beq	r2,zero,2035aec <tcp_listen_input+0x9c>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 2035a8c:	d2281c17 	ldw	r8,-24464(gp)
 2035a90:	d0a81d8b 	ldhu	r2,-24458(gp)
 2035a94:	10ffffcc 	andi	r3,r2,65535
 2035a98:	d0a81b17 	ldw	r2,-24468(gp)
 2035a9c:	188b883a 	add	r5,r3,r2
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2035aa0:	d0a81917 	ldw	r2,-24476(gp)
 2035aa4:	10c00083 	ldbu	r3,2(r2)
 2035aa8:	108000c3 	ldbu	r2,3(r2)
 2035aac:	1004923a 	slli	r2,r2,8
 2035ab0:	10c4b03a 	or	r2,r2,r3
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 2035ab4:	10ffffcc 	andi	r3,r2,65535
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
 2035ab8:	d0a81917 	ldw	r2,-24476(gp)
 2035abc:	11000003 	ldbu	r4,0(r2)
 2035ac0:	10800043 	ldbu	r2,1(r2)
 2035ac4:	1004923a 	slli	r2,r2,8
 2035ac8:	1104b03a 	or	r2,r2,r4
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 2035acc:	10bfffcc 	andi	r2,r2,65535
 2035ad0:	d8800115 	stw	r2,4(sp)
 2035ad4:	d8c00015 	stw	r3,0(sp)
 2035ad8:	d1e81204 	addi	r7,gp,-24504
 2035adc:	d1a81404 	addi	r6,gp,-24496
 2035ae0:	4009883a 	mov	r4,r8
 2035ae4:	202082c0 	call	202082c <tcp_rst>
 2035ae8:	00008d06 	br	2035d20 <tcp_listen_input+0x2d0>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 2035aec:	d0a81d03 	ldbu	r2,-24460(gp)
 2035af0:	10803fcc 	andi	r2,r2,255
 2035af4:	1080008c 	andi	r2,r2,2
 2035af8:	10008926 	beq	r2,zero,2035d20 <tcp_listen_input+0x2d0>
    LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
 2035afc:	e0bfff17 	ldw	r2,-4(fp)
 2035b00:	10c00843 	ldbu	r3,33(r2)
 2035b04:	e0bfff17 	ldw	r2,-4(fp)
 2035b08:	10800803 	ldbu	r2,32(r2)
 2035b0c:	18c03fcc 	andi	r3,r3,255
 2035b10:	10803fcc 	andi	r2,r2,255
 2035b14:	18800236 	bltu	r3,r2,2035b20 <tcp_listen_input+0xd0>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
 2035b18:	00bffd84 	movi	r2,-10
 2035b1c:	00008106 	br	2035d24 <tcp_listen_input+0x2d4>
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 2035b20:	e0bfff17 	ldw	r2,-4(fp)
 2035b24:	10800703 	ldbu	r2,28(r2)
 2035b28:	10803fcc 	andi	r2,r2,255
 2035b2c:	1009883a 	mov	r4,r2
 2035b30:	201d7140 	call	201d714 <tcp_alloc>
 2035b34:	e0bffd15 	stw	r2,-12(fp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 2035b38:	e0bffd17 	ldw	r2,-12(fp)
 2035b3c:	1000091e 	bne	r2,zero,2035b64 <tcp_listen_input+0x114>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
 2035b40:	008085f4 	movhi	r2,535
 2035b44:	10a8bc04 	addi	r2,r2,-23824
 2035b48:	10804e17 	ldw	r2,312(r2)
 2035b4c:	10c00044 	addi	r3,r2,1
 2035b50:	008085f4 	movhi	r2,535
 2035b54:	10a8bc04 	addi	r2,r2,-23824
 2035b58:	10c04e15 	stw	r3,312(r2)
      return ERR_MEM;
 2035b5c:	00bfffc4 	movi	r2,-1
 2035b60:	00007006 	br	2035d24 <tcp_listen_input+0x2d4>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
 2035b64:	e0bfff17 	ldw	r2,-4(fp)
 2035b68:	10800843 	ldbu	r2,33(r2)
 2035b6c:	10800044 	addi	r2,r2,1
 2035b70:	1007883a 	mov	r3,r2
 2035b74:	e0bfff17 	ldw	r2,-4(fp)
 2035b78:	10c00845 	stb	r3,33(r2)
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 2035b7c:	d0e81417 	ldw	r3,-24496(gp)
 2035b80:	e0bffd17 	ldw	r2,-12(fp)
 2035b84:	10c00015 	stw	r3,0(r2)
    npcb->local_port = pcb->local_port;
 2035b88:	e0bfff17 	ldw	r2,-4(fp)
 2035b8c:	10c0078b 	ldhu	r3,30(r2)
 2035b90:	e0bffd17 	ldw	r2,-12(fp)
 2035b94:	10c0078d 	sth	r3,30(r2)
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 2035b98:	d0e81217 	ldw	r3,-24504(gp)
 2035b9c:	e0bffd17 	ldw	r2,-12(fp)
 2035ba0:	10c00115 	stw	r3,4(r2)
    npcb->remote_port = tcphdr->src;
 2035ba4:	d0a81917 	ldw	r2,-24476(gp)
 2035ba8:	10c00003 	ldbu	r3,0(r2)
 2035bac:	10800043 	ldbu	r2,1(r2)
 2035bb0:	1004923a 	slli	r2,r2,8
 2035bb4:	10c4b03a 	or	r2,r2,r3
 2035bb8:	1007883a 	mov	r3,r2
 2035bbc:	e0bffd17 	ldw	r2,-12(fp)
 2035bc0:	10c0080d 	sth	r3,32(r2)
    npcb->state = SYN_RCVD;
 2035bc4:	e0bffd17 	ldw	r2,-12(fp)
 2035bc8:	00c000c4 	movi	r3,3
 2035bcc:	10c00615 	stw	r3,24(r2)
    npcb->rcv_nxt = seqno + 1;
 2035bd0:	d0a81b17 	ldw	r2,-24468(gp)
 2035bd4:	10c00044 	addi	r3,r2,1
 2035bd8:	e0bffd17 	ldw	r2,-12(fp)
 2035bdc:	10c00b15 	stw	r3,44(r2)
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 2035be0:	e0bffd17 	ldw	r2,-12(fp)
 2035be4:	10c00b17 	ldw	r3,44(r2)
 2035be8:	e0bffd17 	ldw	r2,-12(fp)
 2035bec:	10c00d15 	stw	r3,52(r2)
    npcb->snd_wnd = tcphdr->wnd;
 2035bf0:	d0a81917 	ldw	r2,-24476(gp)
 2035bf4:	10c00383 	ldbu	r3,14(r2)
 2035bf8:	108003c3 	ldbu	r2,15(r2)
 2035bfc:	1004923a 	slli	r2,r2,8
 2035c00:	10c4b03a 	or	r2,r2,r3
 2035c04:	1007883a 	mov	r3,r2
 2035c08:	e0bffd17 	ldw	r2,-12(fp)
 2035c0c:	10c0190d 	sth	r3,100(r2)
    npcb->snd_wnd_max = tcphdr->wnd;
 2035c10:	d0a81917 	ldw	r2,-24476(gp)
 2035c14:	10c00383 	ldbu	r3,14(r2)
 2035c18:	108003c3 	ldbu	r2,15(r2)
 2035c1c:	1004923a 	slli	r2,r2,8
 2035c20:	10c4b03a 	or	r2,r2,r3
 2035c24:	1007883a 	mov	r3,r2
 2035c28:	e0bffd17 	ldw	r2,-12(fp)
 2035c2c:	10c0198d 	sth	r3,102(r2)
    npcb->ssthresh = npcb->snd_wnd;
 2035c30:	e0bffd17 	ldw	r2,-12(fp)
 2035c34:	10c0190b 	ldhu	r3,100(r2)
 2035c38:	e0bffd17 	ldw	r2,-12(fp)
 2035c3c:	10c0148d 	sth	r3,82(r2)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 2035c40:	d0a81b17 	ldw	r2,-24468(gp)
 2035c44:	10ffffc4 	addi	r3,r2,-1
 2035c48:	e0bffd17 	ldw	r2,-12(fp)
 2035c4c:	10c01615 	stw	r3,88(r2)
    npcb->callback_arg = pcb->callback_arg;
 2035c50:	e0bfff17 	ldw	r2,-4(fp)
 2035c54:	10c00417 	ldw	r3,16(r2)
 2035c58:	e0bffd17 	ldw	r2,-12(fp)
 2035c5c:	10c00415 	stw	r3,16(r2)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 2035c60:	e0bfff17 	ldw	r2,-4(fp)
 2035c64:	10c00517 	ldw	r3,20(r2)
 2035c68:	e0bffd17 	ldw	r2,-12(fp)
 2035c6c:	10c00515 	stw	r3,20(r2)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 2035c70:	e0bfff17 	ldw	r2,-4(fp)
 2035c74:	10c00203 	ldbu	r3,8(r2)
 2035c78:	00bfe304 	movi	r2,-116
 2035c7c:	1884703a 	and	r2,r3,r2
 2035c80:	1007883a 	mov	r3,r2
 2035c84:	e0bffd17 	ldw	r2,-12(fp)
 2035c88:	10c00205 	stb	r3,8(r2)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 2035c8c:	d0e7f717 	ldw	r3,-24612(gp)
 2035c90:	e0bffd17 	ldw	r2,-12(fp)
 2035c94:	10c00315 	stw	r3,12(r2)
 2035c98:	e0bffd17 	ldw	r2,-12(fp)
 2035c9c:	d0a7f715 	stw	r2,-24612(gp)
 2035ca0:	20215540 	call	2021554 <tcp_timer_needed>
 2035ca4:	00800044 	movi	r2,1
 2035ca8:	d0a7f685 	stb	r2,-24614(gp)

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 2035cac:	e13ffd17 	ldw	r4,-12(fp)
 2035cb0:	2038bbc0 	call	2038bbc <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->local_ip), &(npcb->remote_ip));
 2035cb4:	e0bffd17 	ldw	r2,-12(fp)
 2035cb8:	10800e8b 	ldhu	r2,58(r2)
 2035cbc:	10ffffcc 	andi	r3,r2,65535
 2035cc0:	e13ffd17 	ldw	r4,-12(fp)
 2035cc4:	e0bffd17 	ldw	r2,-12(fp)
 2035cc8:	10800104 	addi	r2,r2,4
 2035ccc:	100d883a 	mov	r6,r2
 2035cd0:	200b883a 	mov	r5,r4
 2035cd4:	1809883a 	mov	r4,r3
 2035cd8:	201dd380 	call	201dd38 <tcp_eff_send_mss>
 2035cdc:	1007883a 	mov	r3,r2
 2035ce0:	e0bffd17 	ldw	r2,-12(fp)
 2035ce4:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 2035ce8:	01400484 	movi	r5,18
 2035cec:	e13ffd17 	ldw	r4,-12(fp)
 2035cf0:	201f2fc0 	call	201f2fc <tcp_enqueue_flags>
 2035cf4:	e0bffe05 	stb	r2,-8(fp)
    if (rc != ERR_OK) {
 2035cf8:	e0bffe07 	ldb	r2,-8(fp)
 2035cfc:	10000526 	beq	r2,zero,2035d14 <tcp_listen_input+0x2c4>
      tcp_abandon(npcb, 0);
 2035d00:	000b883a 	mov	r5,zero
 2035d04:	e13ffd17 	ldw	r4,-12(fp)
 2035d08:	201be540 	call	201be54 <tcp_abandon>
      return rc;
 2035d0c:	e0bffe03 	ldbu	r2,-8(fp)
 2035d10:	00000406 	br	2035d24 <tcp_listen_input+0x2d4>
    }
    return tcp_output(npcb);
 2035d14:	e13ffd17 	ldw	r4,-12(fp)
 2035d18:	201f7800 	call	201f780 <tcp_output>
 2035d1c:	00000106 	br	2035d24 <tcp_listen_input+0x2d4>
  }
  return ERR_OK;
 2035d20:	0005883a 	mov	r2,zero
}
 2035d24:	e037883a 	mov	sp,fp
 2035d28:	dfc00117 	ldw	ra,4(sp)
 2035d2c:	df000017 	ldw	fp,0(sp)
 2035d30:	dec00204 	addi	sp,sp,8
 2035d34:	f800283a 	ret

02035d38 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
 2035d38:	defffb04 	addi	sp,sp,-20
 2035d3c:	dfc00415 	stw	ra,16(sp)
 2035d40:	df000315 	stw	fp,12(sp)
 2035d44:	df000304 	addi	fp,sp,12
 2035d48:	e13fff15 	stw	r4,-4(fp)
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 2035d4c:	d0a81d03 	ldbu	r2,-24460(gp)
 2035d50:	10803fcc 	andi	r2,r2,255
 2035d54:	1080010c 	andi	r2,r2,4
 2035d58:	10000226 	beq	r2,zero,2035d64 <tcp_timewait_input+0x2c>
    return ERR_OK;
 2035d5c:	0005883a 	mov	r2,zero
 2035d60:	00003f06 	br	2035e60 <tcp_timewait_input+0x128>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 2035d64:	d0a81d03 	ldbu	r2,-24460(gp)
 2035d68:	10803fcc 	andi	r2,r2,255
 2035d6c:	1080008c 	andi	r2,r2,2
 2035d70:	10002726 	beq	r2,zero,2035e10 <tcp_timewait_input+0xd8>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 2035d74:	d0e81b17 	ldw	r3,-24468(gp)
 2035d78:	e0bfff17 	ldw	r2,-4(fp)
 2035d7c:	10800b17 	ldw	r2,44(r2)
 2035d80:	1885c83a 	sub	r2,r3,r2
 2035d84:	10002916 	blt	r2,zero,2035e2c <tcp_timewait_input+0xf4>
 2035d88:	d0e81b17 	ldw	r3,-24468(gp)
 2035d8c:	e0bfff17 	ldw	r2,-4(fp)
 2035d90:	11000b17 	ldw	r4,44(r2)
 2035d94:	e0bfff17 	ldw	r2,-4(fp)
 2035d98:	10800c0b 	ldhu	r2,48(r2)
 2035d9c:	10bfffcc 	andi	r2,r2,65535
 2035da0:	2085883a 	add	r2,r4,r2
 2035da4:	1885c83a 	sub	r2,r3,r2
 2035da8:	00802016 	blt	zero,r2,2035e2c <tcp_timewait_input+0xf4>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 2035dac:	d2281c17 	ldw	r8,-24464(gp)
 2035db0:	d0a81d8b 	ldhu	r2,-24458(gp)
 2035db4:	10ffffcc 	andi	r3,r2,65535
 2035db8:	d0a81b17 	ldw	r2,-24468(gp)
 2035dbc:	188b883a 	add	r5,r3,r2
        tcphdr->dest, tcphdr->src);
 2035dc0:	d0a81917 	ldw	r2,-24476(gp)
 2035dc4:	10c00083 	ldbu	r3,2(r2)
 2035dc8:	108000c3 	ldbu	r2,3(r2)
 2035dcc:	1004923a 	slli	r2,r2,8
 2035dd0:	10c4b03a 	or	r2,r2,r3
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 2035dd4:	10ffffcc 	andi	r3,r2,65535
        tcphdr->dest, tcphdr->src);
 2035dd8:	d0a81917 	ldw	r2,-24476(gp)
 2035ddc:	11000003 	ldbu	r4,0(r2)
 2035de0:	10800043 	ldbu	r2,1(r2)
 2035de4:	1004923a 	slli	r2,r2,8
 2035de8:	1104b03a 	or	r2,r2,r4
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 2035dec:	10bfffcc 	andi	r2,r2,65535
 2035df0:	d8800115 	stw	r2,4(sp)
 2035df4:	d8c00015 	stw	r3,0(sp)
 2035df8:	d1e81204 	addi	r7,gp,-24504
 2035dfc:	d1a81404 	addi	r6,gp,-24496
 2035e00:	4009883a 	mov	r4,r8
 2035e04:	202082c0 	call	202082c <tcp_rst>
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
 2035e08:	0005883a 	mov	r2,zero
 2035e0c:	00001406 	br	2035e60 <tcp_timewait_input+0x128>
    }
  } else if (flags & TCP_FIN) {
 2035e10:	d0a81d03 	ldbu	r2,-24460(gp)
 2035e14:	10803fcc 	andi	r2,r2,255
 2035e18:	1080004c 	andi	r2,r2,1
 2035e1c:	10000326 	beq	r2,zero,2035e2c <tcp_timewait_input+0xf4>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 2035e20:	d0e7f817 	ldw	r3,-24608(gp)
 2035e24:	e0bfff17 	ldw	r2,-4(fp)
 2035e28:	10c00a15 	stw	r3,40(r2)
  }

  if ((tcplen > 0))  {
 2035e2c:	d0a81d8b 	ldhu	r2,-24458(gp)
 2035e30:	10bfffcc 	andi	r2,r2,65535
 2035e34:	10000926 	beq	r2,zero,2035e5c <tcp_timewait_input+0x124>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 2035e38:	e0bfff17 	ldw	r2,-4(fp)
 2035e3c:	10800883 	ldbu	r2,34(r2)
 2035e40:	10800094 	ori	r2,r2,2
 2035e44:	1007883a 	mov	r3,r2
 2035e48:	e0bfff17 	ldw	r2,-4(fp)
 2035e4c:	10c00885 	stb	r3,34(r2)
    return tcp_output(pcb);
 2035e50:	e13fff17 	ldw	r4,-4(fp)
 2035e54:	201f7800 	call	201f780 <tcp_output>
 2035e58:	00000106 	br	2035e60 <tcp_timewait_input+0x128>
  }
  return ERR_OK;
 2035e5c:	0005883a 	mov	r2,zero
}
 2035e60:	e037883a 	mov	sp,fp
 2035e64:	dfc00117 	ldw	ra,4(sp)
 2035e68:	df000017 	ldw	fp,0(sp)
 2035e6c:	dec00204 	addi	sp,sp,8
 2035e70:	f800283a 	ret

02035e74 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
 2035e74:	defff804 	addi	sp,sp,-32
 2035e78:	dfc00715 	stw	ra,28(sp)
 2035e7c:	df000615 	stw	fp,24(sp)
 2035e80:	df000604 	addi	fp,sp,24
 2035e84:	e13fff15 	stw	r4,-4(fp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
 2035e88:	e03ffc05 	stb	zero,-16(fp)
  err_t err;

  err = ERR_OK;
 2035e8c:	e03ffc45 	stb	zero,-15(fp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 2035e90:	d0a81d03 	ldbu	r2,-24460(gp)
 2035e94:	10803fcc 	andi	r2,r2,255
 2035e98:	1080010c 	andi	r2,r2,4
 2035e9c:	10002b26 	beq	r2,zero,2035f4c <tcp_process+0xd8>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 2035ea0:	e0bfff17 	ldw	r2,-4(fp)
 2035ea4:	10800617 	ldw	r2,24(r2)
 2035ea8:	10800098 	cmpnei	r2,r2,2
 2035eac:	1000071e 	bne	r2,zero,2035ecc <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
 2035eb0:	e0bfff17 	ldw	r2,-4(fp)
 2035eb4:	10c01517 	ldw	r3,84(r2)
 2035eb8:	d0a81c17 	ldw	r2,-24464(gp)
 2035ebc:	1880131e 	bne	r3,r2,2035f0c <tcp_process+0x98>
        acceptable = 1;
 2035ec0:	00800044 	movi	r2,1
 2035ec4:	e0bffc05 	stb	r2,-16(fp)
 2035ec8:	00001006 	br	2035f0c <tcp_process+0x98>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 2035ecc:	d0e81b17 	ldw	r3,-24468(gp)
 2035ed0:	e0bfff17 	ldw	r2,-4(fp)
 2035ed4:	10800b17 	ldw	r2,44(r2)
 2035ed8:	1885c83a 	sub	r2,r3,r2
 2035edc:	10000b16 	blt	r2,zero,2035f0c <tcp_process+0x98>
 2035ee0:	d0e81b17 	ldw	r3,-24468(gp)
 2035ee4:	e0bfff17 	ldw	r2,-4(fp)
 2035ee8:	11000b17 	ldw	r4,44(r2)
 2035eec:	e0bfff17 	ldw	r2,-4(fp)
 2035ef0:	10800c0b 	ldhu	r2,48(r2)
 2035ef4:	10bfffcc 	andi	r2,r2,65535
 2035ef8:	2085883a 	add	r2,r4,r2
 2035efc:	1885c83a 	sub	r2,r3,r2
 2035f00:	00800216 	blt	zero,r2,2035f0c <tcp_process+0x98>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
 2035f04:	00800044 	movi	r2,1
 2035f08:	e0bffc05 	stb	r2,-16(fp)
      }
    }

    if (acceptable) {
 2035f0c:	e0bffc03 	ldbu	r2,-16(fp)
 2035f10:	10000c26 	beq	r2,zero,2035f44 <tcp_process+0xd0>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 2035f14:	d0a81e03 	ldbu	r2,-24456(gp)
 2035f18:	10800214 	ori	r2,r2,8
 2035f1c:	d0a81e05 	stb	r2,-24456(gp)
      pcb->flags &= ~TF_ACK_DELAY;
 2035f20:	e0bfff17 	ldw	r2,-4(fp)
 2035f24:	10c00883 	ldbu	r3,34(r2)
 2035f28:	00bfff84 	movi	r2,-2
 2035f2c:	1884703a 	and	r2,r3,r2
 2035f30:	1007883a 	mov	r3,r2
 2035f34:	e0bfff17 	ldw	r2,-4(fp)
 2035f38:	10c00885 	stb	r3,34(r2)
      return ERR_RST;
 2035f3c:	00bffd44 	movi	r2,-11
 2035f40:	00027406 	br	2036914 <tcp_process+0xaa0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
 2035f44:	0005883a 	mov	r2,zero
 2035f48:	00027206 	br	2036914 <tcp_process+0xaa0>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 2035f4c:	d0a81d03 	ldbu	r2,-24460(gp)
 2035f50:	10803fcc 	andi	r2,r2,255
 2035f54:	1080008c 	andi	r2,r2,2
 2035f58:	10001026 	beq	r2,zero,2035f9c <tcp_process+0x128>
 2035f5c:	e0bfff17 	ldw	r2,-4(fp)
 2035f60:	10800617 	ldw	r2,24(r2)
 2035f64:	108000a0 	cmpeqi	r2,r2,2
 2035f68:	10000c1e 	bne	r2,zero,2035f9c <tcp_process+0x128>
 2035f6c:	e0bfff17 	ldw	r2,-4(fp)
 2035f70:	10800617 	ldw	r2,24(r2)
 2035f74:	108000e0 	cmpeqi	r2,r2,3
 2035f78:	1000081e 	bne	r2,zero,2035f9c <tcp_process+0x128>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
 2035f7c:	e0bfff17 	ldw	r2,-4(fp)
 2035f80:	10800883 	ldbu	r2,34(r2)
 2035f84:	10800094 	ori	r2,r2,2
 2035f88:	1007883a 	mov	r3,r2
 2035f8c:	e0bfff17 	ldw	r2,-4(fp)
 2035f90:	10c00885 	stb	r3,34(r2)
    return ERR_OK;
 2035f94:	0005883a 	mov	r2,zero
 2035f98:	00025e06 	br	2036914 <tcp_process+0xaa0>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 2035f9c:	e0bfff17 	ldw	r2,-4(fp)
 2035fa0:	10800883 	ldbu	r2,34(r2)
 2035fa4:	10803fcc 	andi	r2,r2,255
 2035fa8:	1080040c 	andi	r2,r2,16
 2035fac:	1000031e 	bne	r2,zero,2035fbc <tcp_process+0x148>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 2035fb0:	d0e7f817 	ldw	r3,-24608(gp)
 2035fb4:	e0bfff17 	ldw	r2,-4(fp)
 2035fb8:	10c00a15 	stw	r3,40(r2)
  }
  pcb->keep_cnt_sent = 0;
 2035fbc:	e0bfff17 	ldw	r2,-4(fp)
 2035fc0:	10002885 	stb	zero,162(r2)

  tcp_parseopt(pcb);
 2035fc4:	e13fff17 	ldw	r4,-4(fp)
 2035fc8:	2038bbc0 	call	2038bbc <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 2035fcc:	e0bfff17 	ldw	r2,-4(fp)
 2035fd0:	10800617 	ldw	r2,24(r2)
 2035fd4:	10c002a8 	cmpgeui	r3,r2,10
 2035fd8:	18023e1e 	bne	r3,zero,20368d4 <tcp_process+0xa60>
 2035fdc:	100690ba 	slli	r3,r2,2
 2035fe0:	008080f4 	movhi	r2,515
 2035fe4:	1097fd04 	addi	r2,r2,24564
 2035fe8:	1885883a 	add	r2,r3,r2
 2035fec:	10800017 	ldw	r2,0(r2)
 2035ff0:	1000683a 	jmp	r2
 2035ff4:	020368d4 	movui	r8,3491
 2035ff8:	020368d4 	movui	r8,3491
 2035ffc:	0203601c 	xori	r8,zero,3456
 2036000:	0203639c 	xori	r8,zero,3470
 2036004:	0203657c 	xorhi	r8,zero,3477
 2036008:	020365bc 	xorhi	r8,zero,3478
 203600c:	02036704 	movi	r8,3484
 2036010:	0203657c 	xorhi	r8,zero,3477
 2036014:	020367d4 	movui	r8,3487
 2036018:	0203689c 	xori	r8,zero,3490
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 203601c:	d0a81d03 	ldbu	r2,-24460(gp)
 2036020:	10803fcc 	andi	r2,r2,255
 2036024:	1080040c 	andi	r2,r2,16
 2036028:	1000c026 	beq	r2,zero,203632c <tcp_process+0x4b8>
 203602c:	d0a81d03 	ldbu	r2,-24460(gp)
 2036030:	10803fcc 	andi	r2,r2,255
 2036034:	1080008c 	andi	r2,r2,2
 2036038:	1000bc26 	beq	r2,zero,203632c <tcp_process+0x4b8>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 203603c:	e0bfff17 	ldw	r2,-4(fp)
 2036040:	10801d17 	ldw	r2,116(r2)
 2036044:	10800417 	ldw	r2,16(r2)
 2036048:	10c00103 	ldbu	r3,4(r2)
 203604c:	11000143 	ldbu	r4,5(r2)
 2036050:	2008923a 	slli	r4,r4,8
 2036054:	20c6b03a 	or	r3,r4,r3
 2036058:	11000183 	ldbu	r4,6(r2)
 203605c:	2008943a 	slli	r4,r4,16
 2036060:	20c6b03a 	or	r3,r4,r3
 2036064:	108001c3 	ldbu	r2,7(r2)
 2036068:	1004963a 	slli	r2,r2,24
 203606c:	10c4b03a 	or	r2,r2,r3
 2036070:	1006d63a 	srli	r3,r2,24
 2036074:	e0bfff17 	ldw	r2,-4(fp)
 2036078:	10801d17 	ldw	r2,116(r2)
 203607c:	10800417 	ldw	r2,16(r2)
 2036080:	11000103 	ldbu	r4,4(r2)
 2036084:	11400143 	ldbu	r5,5(r2)
 2036088:	280a923a 	slli	r5,r5,8
 203608c:	2908b03a 	or	r4,r5,r4
 2036090:	11400183 	ldbu	r5,6(r2)
 2036094:	280a943a 	slli	r5,r5,16
 2036098:	2908b03a 	or	r4,r5,r4
 203609c:	108001c3 	ldbu	r2,7(r2)
 20360a0:	1004963a 	slli	r2,r2,24
 20360a4:	1104b03a 	or	r2,r2,r4
 20360a8:	1004d23a 	srli	r2,r2,8
 20360ac:	10bfc00c 	andi	r2,r2,65280
 20360b0:	1886b03a 	or	r3,r3,r2
 20360b4:	e0bfff17 	ldw	r2,-4(fp)
 20360b8:	10801d17 	ldw	r2,116(r2)
 20360bc:	10800417 	ldw	r2,16(r2)
 20360c0:	11000103 	ldbu	r4,4(r2)
 20360c4:	11400143 	ldbu	r5,5(r2)
 20360c8:	280a923a 	slli	r5,r5,8
 20360cc:	2908b03a 	or	r4,r5,r4
 20360d0:	11400183 	ldbu	r5,6(r2)
 20360d4:	280a943a 	slli	r5,r5,16
 20360d8:	2908b03a 	or	r4,r5,r4
 20360dc:	108001c3 	ldbu	r2,7(r2)
 20360e0:	1004963a 	slli	r2,r2,24
 20360e4:	1104b03a 	or	r2,r2,r4
 20360e8:	10bfc00c 	andi	r2,r2,65280
 20360ec:	1004923a 	slli	r2,r2,8
 20360f0:	1886b03a 	or	r3,r3,r2
 20360f4:	e0bfff17 	ldw	r2,-4(fp)
 20360f8:	10801d17 	ldw	r2,116(r2)
 20360fc:	10800417 	ldw	r2,16(r2)
 2036100:	11000103 	ldbu	r4,4(r2)
 2036104:	11400143 	ldbu	r5,5(r2)
 2036108:	280a923a 	slli	r5,r5,8
 203610c:	2908b03a 	or	r4,r5,r4
 2036110:	11400183 	ldbu	r5,6(r2)
 2036114:	280a943a 	slli	r5,r5,16
 2036118:	2908b03a 	or	r4,r5,r4
 203611c:	108001c3 	ldbu	r2,7(r2)
 2036120:	1004963a 	slli	r2,r2,24
 2036124:	1104b03a 	or	r2,r2,r4
 2036128:	1004963a 	slli	r2,r2,24
 203612c:	1884b03a 	or	r2,r3,r2
 2036130:	10c00044 	addi	r3,r2,1
 2036134:	d0a81c17 	ldw	r2,-24464(gp)
 2036138:	18807c1e 	bne	r3,r2,203632c <tcp_process+0x4b8>
      pcb->snd_buf++;
 203613c:	e0bfff17 	ldw	r2,-4(fp)
 2036140:	10801a8b 	ldhu	r2,106(r2)
 2036144:	10800044 	addi	r2,r2,1
 2036148:	1007883a 	mov	r3,r2
 203614c:	e0bfff17 	ldw	r2,-4(fp)
 2036150:	10c01a8d 	sth	r3,106(r2)
      pcb->rcv_nxt = seqno + 1;
 2036154:	d0a81b17 	ldw	r2,-24468(gp)
 2036158:	10c00044 	addi	r3,r2,1
 203615c:	e0bfff17 	ldw	r2,-4(fp)
 2036160:	10c00b15 	stw	r3,44(r2)
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 2036164:	e0bfff17 	ldw	r2,-4(fp)
 2036168:	10c00b17 	ldw	r3,44(r2)
 203616c:	e0bfff17 	ldw	r2,-4(fp)
 2036170:	10c00d15 	stw	r3,52(r2)
      pcb->lastack = ackno;
 2036174:	d0e81c17 	ldw	r3,-24464(gp)
 2036178:	e0bfff17 	ldw	r2,-4(fp)
 203617c:	10c01315 	stw	r3,76(r2)
      pcb->snd_wnd = tcphdr->wnd;
 2036180:	d0a81917 	ldw	r2,-24476(gp)
 2036184:	10c00383 	ldbu	r3,14(r2)
 2036188:	108003c3 	ldbu	r2,15(r2)
 203618c:	1004923a 	slli	r2,r2,8
 2036190:	10c4b03a 	or	r2,r2,r3
 2036194:	1007883a 	mov	r3,r2
 2036198:	e0bfff17 	ldw	r2,-4(fp)
 203619c:	10c0190d 	sth	r3,100(r2)
      pcb->snd_wnd_max = tcphdr->wnd;
 20361a0:	d0a81917 	ldw	r2,-24476(gp)
 20361a4:	10c00383 	ldbu	r3,14(r2)
 20361a8:	108003c3 	ldbu	r2,15(r2)
 20361ac:	1004923a 	slli	r2,r2,8
 20361b0:	10c4b03a 	or	r2,r2,r3
 20361b4:	1007883a 	mov	r3,r2
 20361b8:	e0bfff17 	ldw	r2,-4(fp)
 20361bc:	10c0198d 	sth	r3,102(r2)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 20361c0:	d0a81b17 	ldw	r2,-24468(gp)
 20361c4:	10ffffc4 	addi	r3,r2,-1
 20361c8:	e0bfff17 	ldw	r2,-4(fp)
 20361cc:	10c01615 	stw	r3,88(r2)
      pcb->state = ESTABLISHED;
 20361d0:	e0bfff17 	ldw	r2,-4(fp)
 20361d4:	00c00104 	movi	r3,4
 20361d8:	10c00615 	stw	r3,24(r2)

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->local_ip), &(pcb->remote_ip));
 20361dc:	e0bfff17 	ldw	r2,-4(fp)
 20361e0:	10800e8b 	ldhu	r2,58(r2)
 20361e4:	10ffffcc 	andi	r3,r2,65535
 20361e8:	e13fff17 	ldw	r4,-4(fp)
 20361ec:	e0bfff17 	ldw	r2,-4(fp)
 20361f0:	10800104 	addi	r2,r2,4
 20361f4:	100d883a 	mov	r6,r2
 20361f8:	200b883a 	mov	r5,r4
 20361fc:	1809883a 	mov	r4,r3
 2036200:	201dd380 	call	201dd38 <tcp_eff_send_mss>
 2036204:	1007883a 	mov	r3,r2
 2036208:	e0bfff17 	ldw	r2,-4(fp)
 203620c:	10c00e8d 	sth	r3,58(r2)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 2036210:	e0bfff17 	ldw	r2,-4(fp)
 2036214:	10800e8b 	ldhu	r2,58(r2)
 2036218:	108002a4 	muli	r2,r2,10
 203621c:	1007883a 	mov	r3,r2
 2036220:	e0bfff17 	ldw	r2,-4(fp)
 2036224:	10c0148d 	sth	r3,82(r2)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 2036228:	e0bfff17 	ldw	r2,-4(fp)
 203622c:	1080140b 	ldhu	r2,80(r2)
 2036230:	10bfffcc 	andi	r2,r2,65535
 2036234:	10800058 	cmpnei	r2,r2,1
 2036238:	1000041e 	bne	r2,zero,203624c <tcp_process+0x3d8>
 203623c:	e0bfff17 	ldw	r2,-4(fp)
 2036240:	10800e8b 	ldhu	r2,58(r2)
 2036244:	1085883a 	add	r2,r2,r2
 2036248:	00000206 	br	2036254 <tcp_process+0x3e0>
 203624c:	e0bfff17 	ldw	r2,-4(fp)
 2036250:	10800e8b 	ldhu	r2,58(r2)
 2036254:	e0ffff17 	ldw	r3,-4(fp)
 2036258:	1880140d 	sth	r2,80(r3)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 203625c:	e0bfff17 	ldw	r2,-4(fp)
 2036260:	10801b0b 	ldhu	r2,108(r2)
 2036264:	10bfffc4 	addi	r2,r2,-1
 2036268:	1007883a 	mov	r3,r2
 203626c:	e0bfff17 	ldw	r2,-4(fp)
 2036270:	10c01b0d 	sth	r3,108(r2)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 2036274:	e0bfff17 	ldw	r2,-4(fp)
 2036278:	10801d17 	ldw	r2,116(r2)
 203627c:	e0bffd15 	stw	r2,-12(fp)
      pcb->unacked = rseg->next;
 2036280:	e0bffd17 	ldw	r2,-12(fp)
 2036284:	10c00017 	ldw	r3,0(r2)
 2036288:	e0bfff17 	ldw	r2,-4(fp)
 203628c:	10c01d15 	stw	r3,116(r2)
      tcp_seg_free(rseg);
 2036290:	e13ffd17 	ldw	r4,-12(fp)
 2036294:	201d4300 	call	201d430 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 2036298:	e0bfff17 	ldw	r2,-4(fp)
 203629c:	10801d17 	ldw	r2,116(r2)
 20362a0:	1000041e 	bne	r2,zero,20362b4 <tcp_process+0x440>
        pcb->rtime = -1;
 20362a4:	e0bfff17 	ldw	r2,-4(fp)
 20362a8:	00ffffc4 	movi	r3,-1
 20362ac:	10c00e0d 	sth	r3,56(r2)
 20362b0:	00000406 	br	20362c4 <tcp_process+0x450>
      else {
        pcb->rtime = 0;
 20362b4:	e0bfff17 	ldw	r2,-4(fp)
 20362b8:	10000e0d 	sth	zero,56(r2)
        pcb->nrtx = 0;
 20362bc:	e0bfff17 	ldw	r2,-4(fp)
 20362c0:	10001285 	stb	zero,74(r2)
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 20362c4:	e0bfff17 	ldw	r2,-4(fp)
 20362c8:	10802217 	ldw	r2,136(r2)
 20362cc:	10000a26 	beq	r2,zero,20362f8 <tcp_process+0x484>
 20362d0:	e0bfff17 	ldw	r2,-4(fp)
 20362d4:	10802217 	ldw	r2,136(r2)
 20362d8:	e0ffff17 	ldw	r3,-4(fp)
 20362dc:	18c00417 	ldw	r3,16(r3)
 20362e0:	000d883a 	mov	r6,zero
 20362e4:	e17fff17 	ldw	r5,-4(fp)
 20362e8:	1809883a 	mov	r4,r3
 20362ec:	103ee83a 	callr	r2
 20362f0:	e0bffc45 	stb	r2,-15(fp)
 20362f4:	00000106 	br	20362fc <tcp_process+0x488>
 20362f8:	e03ffc45 	stb	zero,-15(fp)
      if (err == ERR_ABRT) {
 20362fc:	e0bffc47 	ldb	r2,-15(fp)
 2036300:	10bffd98 	cmpnei	r2,r2,-10
 2036304:	1000021e 	bne	r2,zero,2036310 <tcp_process+0x49c>
        return ERR_ABRT;
 2036308:	00bffd84 	movi	r2,-10
 203630c:	00018106 	br	2036914 <tcp_process+0xaa0>
      }
      tcp_ack_now(pcb);
 2036310:	e0bfff17 	ldw	r2,-4(fp)
 2036314:	10800883 	ldbu	r2,34(r2)
 2036318:	10800094 	ori	r2,r2,2
 203631c:	1007883a 	mov	r3,r2
 2036320:	e0bfff17 	ldw	r2,-4(fp)
 2036324:	10c00885 	stb	r3,34(r2)
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
 2036328:	00016c06 	br	20368dc <tcp_process+0xa68>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 203632c:	d0a81d03 	ldbu	r2,-24460(gp)
 2036330:	10803fcc 	andi	r2,r2,255
 2036334:	1080040c 	andi	r2,r2,16
 2036338:	10016826 	beq	r2,zero,20368dc <tcp_process+0xa68>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 203633c:	d2281c17 	ldw	r8,-24464(gp)
 2036340:	d0a81d8b 	ldhu	r2,-24458(gp)
 2036344:	10ffffcc 	andi	r3,r2,65535
 2036348:	d0a81b17 	ldw	r2,-24468(gp)
 203634c:	188b883a 	add	r5,r3,r2
        tcphdr->dest, tcphdr->src);
 2036350:	d0a81917 	ldw	r2,-24476(gp)
 2036354:	10c00083 	ldbu	r3,2(r2)
 2036358:	108000c3 	ldbu	r2,3(r2)
 203635c:	1004923a 	slli	r2,r2,8
 2036360:	10c4b03a 	or	r2,r2,r3
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 2036364:	10ffffcc 	andi	r3,r2,65535
        tcphdr->dest, tcphdr->src);
 2036368:	d0a81917 	ldw	r2,-24476(gp)
 203636c:	11000003 	ldbu	r4,0(r2)
 2036370:	10800043 	ldbu	r2,1(r2)
 2036374:	1004923a 	slli	r2,r2,8
 2036378:	1104b03a 	or	r2,r2,r4
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 203637c:	10bfffcc 	andi	r2,r2,65535
 2036380:	d8800115 	stw	r2,4(sp)
 2036384:	d8c00015 	stw	r3,0(sp)
 2036388:	d1e81204 	addi	r7,gp,-24504
 203638c:	d1a81404 	addi	r6,gp,-24496
 2036390:	4009883a 	mov	r4,r8
 2036394:	202082c0 	call	202082c <tcp_rst>
        tcphdr->dest, tcphdr->src);
    }
    break;
 2036398:	00015006 	br	20368dc <tcp_process+0xa68>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 203639c:	d0a81d03 	ldbu	r2,-24460(gp)
 20363a0:	10803fcc 	andi	r2,r2,255
 20363a4:	1080040c 	andi	r2,r2,16
 20363a8:	10006626 	beq	r2,zero,2036544 <tcp_process+0x6d0>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 20363ac:	d0e81c17 	ldw	r3,-24464(gp)
 20363b0:	e0bfff17 	ldw	r2,-4(fp)
 20363b4:	10801317 	ldw	r2,76(r2)
 20363b8:	1885c83a 	sub	r2,r3,r2
 20363bc:	10bfffc4 	addi	r2,r2,-1
 20363c0:	10004816 	blt	r2,zero,20364e4 <tcp_process+0x670>
 20363c4:	d0e81c17 	ldw	r3,-24464(gp)
 20363c8:	e0bfff17 	ldw	r2,-4(fp)
 20363cc:	10801517 	ldw	r2,84(r2)
 20363d0:	1885c83a 	sub	r2,r3,r2
 20363d4:	00804316 	blt	zero,r2,20364e4 <tcp_process+0x670>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 20363d8:	e0bfff17 	ldw	r2,-4(fp)
 20363dc:	00c00104 	movi	r3,4
 20363e0:	10c00615 	stw	r3,24(r2)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 20363e4:	e0bfff17 	ldw	r2,-4(fp)
 20363e8:	10800517 	ldw	r2,20(r2)
 20363ec:	10000a26 	beq	r2,zero,2036418 <tcp_process+0x5a4>
 20363f0:	e0bfff17 	ldw	r2,-4(fp)
 20363f4:	10800517 	ldw	r2,20(r2)
 20363f8:	e0ffff17 	ldw	r3,-4(fp)
 20363fc:	18c00417 	ldw	r3,16(r3)
 2036400:	000d883a 	mov	r6,zero
 2036404:	e17fff17 	ldw	r5,-4(fp)
 2036408:	1809883a 	mov	r4,r3
 203640c:	103ee83a 	callr	r2
 2036410:	e0bffc45 	stb	r2,-15(fp)
 2036414:	00000206 	br	2036420 <tcp_process+0x5ac>
 2036418:	00bffc84 	movi	r2,-14
 203641c:	e0bffc45 	stb	r2,-15(fp)
        if (err != ERR_OK) {
 2036420:	e0bffc47 	ldb	r2,-15(fp)
 2036424:	10000726 	beq	r2,zero,2036444 <tcp_process+0x5d0>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
 2036428:	e0bffc47 	ldb	r2,-15(fp)
 203642c:	10bffda0 	cmpeqi	r2,r2,-10
 2036430:	1000021e 	bne	r2,zero,203643c <tcp_process+0x5c8>
            tcp_abort(pcb);
 2036434:	e13fff17 	ldw	r4,-4(fp)
 2036438:	201bfb40 	call	201bfb4 <tcp_abort>
          }
          return ERR_ABRT;
 203643c:	00bffd84 	movi	r2,-10
 2036440:	00013406 	br	2036914 <tcp_process+0xaa0>
        }
        old_cwnd = pcb->cwnd;
 2036444:	e0bfff17 	ldw	r2,-4(fp)
 2036448:	1080140b 	ldhu	r2,80(r2)
 203644c:	e0bffe0d 	sth	r2,-8(fp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 2036450:	e13fff17 	ldw	r4,-4(fp)
 2036454:	2036bc80 	call	2036bc8 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 2036458:	e0bfff17 	ldw	r2,-4(fp)
 203645c:	10801a0b 	ldhu	r2,104(r2)
 2036460:	10bfffcc 	andi	r2,r2,65535
 2036464:	10000626 	beq	r2,zero,2036480 <tcp_process+0x60c>
          pcb->acked--;
 2036468:	e0bfff17 	ldw	r2,-4(fp)
 203646c:	10801a0b 	ldhu	r2,104(r2)
 2036470:	10bfffc4 	addi	r2,r2,-1
 2036474:	1007883a 	mov	r3,r2
 2036478:	e0bfff17 	ldw	r2,-4(fp)
 203647c:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 2036480:	e0bffe0b 	ldhu	r2,-8(fp)
 2036484:	10800058 	cmpnei	r2,r2,1
 2036488:	1000041e 	bne	r2,zero,203649c <tcp_process+0x628>
 203648c:	e0bfff17 	ldw	r2,-4(fp)
 2036490:	10800e8b 	ldhu	r2,58(r2)
 2036494:	1085883a 	add	r2,r2,r2
 2036498:	00000206 	br	20364a4 <tcp_process+0x630>
 203649c:	e0bfff17 	ldw	r2,-4(fp)
 20364a0:	10800e8b 	ldhu	r2,58(r2)
 20364a4:	e0ffff17 	ldw	r3,-4(fp)
 20364a8:	1880140d 	sth	r2,80(r3)

        if (recv_flags & TF_GOT_FIN) {
 20364ac:	d0a81e03 	ldbu	r2,-24456(gp)
 20364b0:	10803fcc 	andi	r2,r2,255
 20364b4:	1080080c 	andi	r2,r2,32
 20364b8:	10002e26 	beq	r2,zero,2036574 <tcp_process+0x700>
          tcp_ack_now(pcb);
 20364bc:	e0bfff17 	ldw	r2,-4(fp)
 20364c0:	10800883 	ldbu	r2,34(r2)
 20364c4:	10800094 	ori	r2,r2,2
 20364c8:	1007883a 	mov	r3,r2
 20364cc:	e0bfff17 	ldw	r2,-4(fp)
 20364d0:	10c00885 	stb	r3,34(r2)
          pcb->state = CLOSE_WAIT;
 20364d4:	e0bfff17 	ldw	r2,-4(fp)
 20364d8:	00c001c4 	movi	r3,7
 20364dc:	10c00615 	stw	r3,24(r2)
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 20364e0:	00002406 	br	2036574 <tcp_process+0x700>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 20364e4:	d2281c17 	ldw	r8,-24464(gp)
 20364e8:	d0a81d8b 	ldhu	r2,-24458(gp)
 20364ec:	10ffffcc 	andi	r3,r2,65535
 20364f0:	d0a81b17 	ldw	r2,-24468(gp)
 20364f4:	188b883a 	add	r5,r3,r2
                tcphdr->dest, tcphdr->src);
 20364f8:	d0a81917 	ldw	r2,-24476(gp)
 20364fc:	10c00083 	ldbu	r3,2(r2)
 2036500:	108000c3 	ldbu	r2,3(r2)
 2036504:	1004923a 	slli	r2,r2,8
 2036508:	10c4b03a 	or	r2,r2,r3
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 203650c:	10ffffcc 	andi	r3,r2,65535
                tcphdr->dest, tcphdr->src);
 2036510:	d0a81917 	ldw	r2,-24476(gp)
 2036514:	11000003 	ldbu	r4,0(r2)
 2036518:	10800043 	ldbu	r2,1(r2)
 203651c:	1004923a 	slli	r2,r2,8
 2036520:	1104b03a 	or	r2,r2,r4
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 2036524:	10bfffcc 	andi	r2,r2,65535
 2036528:	d8800115 	stw	r2,4(sp)
 203652c:	d8c00015 	stw	r3,0(sp)
 2036530:	d1e81204 	addi	r7,gp,-24504
 2036534:	d1a81404 	addi	r6,gp,-24496
 2036538:	4009883a 	mov	r4,r8
 203653c:	202082c0 	call	202082c <tcp_rst>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 2036540:	0000e806 	br	20368e4 <tcp_process+0xa70>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 2036544:	d0a81d03 	ldbu	r2,-24460(gp)
 2036548:	10803fcc 	andi	r2,r2,255
 203654c:	1080008c 	andi	r2,r2,2
 2036550:	1000e426 	beq	r2,zero,20368e4 <tcp_process+0xa70>
 2036554:	e0bfff17 	ldw	r2,-4(fp)
 2036558:	10800b17 	ldw	r2,44(r2)
 203655c:	10ffffc4 	addi	r3,r2,-1
 2036560:	d0a81b17 	ldw	r2,-24468(gp)
 2036564:	1880df1e 	bne	r3,r2,20368e4 <tcp_process+0xa70>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 2036568:	e13fff17 	ldw	r4,-4(fp)
 203656c:	2020cac0 	call	2020cac <tcp_rexmit>
    }
    break;
 2036570:	0000dc06 	br	20368e4 <tcp_process+0xa70>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 2036574:	0001883a 	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 2036578:	0000da06 	br	20368e4 <tcp_process+0xa70>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 203657c:	e13fff17 	ldw	r4,-4(fp)
 2036580:	2036bc80 	call	2036bc8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 2036584:	d0a81e03 	ldbu	r2,-24456(gp)
 2036588:	10803fcc 	andi	r2,r2,255
 203658c:	1080080c 	andi	r2,r2,32
 2036590:	1000d626 	beq	r2,zero,20368ec <tcp_process+0xa78>
      tcp_ack_now(pcb);
 2036594:	e0bfff17 	ldw	r2,-4(fp)
 2036598:	10800883 	ldbu	r2,34(r2)
 203659c:	10800094 	ori	r2,r2,2
 20365a0:	1007883a 	mov	r3,r2
 20365a4:	e0bfff17 	ldw	r2,-4(fp)
 20365a8:	10c00885 	stb	r3,34(r2)
      pcb->state = CLOSE_WAIT;
 20365ac:	e0bfff17 	ldw	r2,-4(fp)
 20365b0:	00c001c4 	movi	r3,7
 20365b4:	10c00615 	stw	r3,24(r2)
    }
    break;
 20365b8:	0000cc06 	br	20368ec <tcp_process+0xa78>
  case FIN_WAIT_1:
    tcp_receive(pcb);
 20365bc:	e13fff17 	ldw	r4,-4(fp)
 20365c0:	2036bc80 	call	2036bc8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 20365c4:	d0a81e03 	ldbu	r2,-24456(gp)
 20365c8:	10803fcc 	andi	r2,r2,255
 20365cc:	1080080c 	andi	r2,r2,32
 20365d0:	10004026 	beq	r2,zero,20366d4 <tcp_process+0x860>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 20365d4:	d0a81d03 	ldbu	r2,-24460(gp)
 20365d8:	10803fcc 	andi	r2,r2,255
 20365dc:	1080040c 	andi	r2,r2,16
 20365e0:	10003226 	beq	r2,zero,20366ac <tcp_process+0x838>
 20365e4:	e0bfff17 	ldw	r2,-4(fp)
 20365e8:	10c01517 	ldw	r3,84(r2)
 20365ec:	d0a81c17 	ldw	r2,-24464(gp)
 20365f0:	18802e1e 	bne	r3,r2,20366ac <tcp_process+0x838>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 20365f4:	e0bfff17 	ldw	r2,-4(fp)
 20365f8:	10800883 	ldbu	r2,34(r2)
 20365fc:	10800094 	ori	r2,r2,2
 2036600:	1007883a 	mov	r3,r2
 2036604:	e0bfff17 	ldw	r2,-4(fp)
 2036608:	10c00885 	stb	r3,34(r2)
        tcp_pcb_purge(pcb);
 203660c:	e13fff17 	ldw	r4,-4(fp)
 2036610:	201da8c0 	call	201da8c <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 2036614:	d0e7f717 	ldw	r3,-24612(gp)
 2036618:	e0bfff17 	ldw	r2,-4(fp)
 203661c:	1880041e 	bne	r3,r2,2036630 <tcp_process+0x7bc>
 2036620:	d0a7f717 	ldw	r2,-24612(gp)
 2036624:	10800317 	ldw	r2,12(r2)
 2036628:	d0a7f715 	stw	r2,-24612(gp)
 203662c:	00001106 	br	2036674 <tcp_process+0x800>
 2036630:	d0a7f717 	ldw	r2,-24612(gp)
 2036634:	d0a7fa15 	stw	r2,-24600(gp)
 2036638:	00000c06 	br	203666c <tcp_process+0x7f8>
 203663c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036640:	10c00317 	ldw	r3,12(r2)
 2036644:	e0bfff17 	ldw	r2,-4(fp)
 2036648:	1880051e 	bne	r3,r2,2036660 <tcp_process+0x7ec>
 203664c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036650:	e0ffff17 	ldw	r3,-4(fp)
 2036654:	18c00317 	ldw	r3,12(r3)
 2036658:	10c00315 	stw	r3,12(r2)
 203665c:	00000506 	br	2036674 <tcp_process+0x800>
 2036660:	d0a7fa17 	ldw	r2,-24600(gp)
 2036664:	10800317 	ldw	r2,12(r2)
 2036668:	d0a7fa15 	stw	r2,-24600(gp)
 203666c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036670:	103ff21e 	bne	r2,zero,203663c <__alt_mem_mem_0+0xfd01663c>
 2036674:	e0bfff17 	ldw	r2,-4(fp)
 2036678:	10000315 	stw	zero,12(r2)
 203667c:	00800044 	movi	r2,1
 2036680:	d0a7f685 	stb	r2,-24614(gp)
        pcb->state = TIME_WAIT;
 2036684:	e0bfff17 	ldw	r2,-4(fp)
 2036688:	00c00284 	movi	r3,10
 203668c:	10c00615 	stw	r3,24(r2)
        TCP_REG(&tcp_tw_pcbs, pcb);
 2036690:	d0e7fc17 	ldw	r3,-24592(gp)
 2036694:	e0bfff17 	ldw	r2,-4(fp)
 2036698:	10c00315 	stw	r3,12(r2)
 203669c:	e0bfff17 	ldw	r2,-4(fp)
 20366a0:	d0a7fc15 	stw	r2,-24592(gp)
 20366a4:	20215540 	call	2021554 <tcp_timer_needed>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 20366a8:	00009206 	br	20368f4 <tcp_process+0xa80>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 20366ac:	e0bfff17 	ldw	r2,-4(fp)
 20366b0:	10800883 	ldbu	r2,34(r2)
 20366b4:	10800094 	ori	r2,r2,2
 20366b8:	1007883a 	mov	r3,r2
 20366bc:	e0bfff17 	ldw	r2,-4(fp)
 20366c0:	10c00885 	stb	r3,34(r2)
        pcb->state = CLOSING;
 20366c4:	e0bfff17 	ldw	r2,-4(fp)
 20366c8:	00c00204 	movi	r3,8
 20366cc:	10c00615 	stw	r3,24(r2)
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 20366d0:	00008806 	br	20368f4 <tcp_process+0xa80>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 20366d4:	d0a81d03 	ldbu	r2,-24460(gp)
 20366d8:	10803fcc 	andi	r2,r2,255
 20366dc:	1080040c 	andi	r2,r2,16
 20366e0:	10008426 	beq	r2,zero,20368f4 <tcp_process+0xa80>
 20366e4:	e0bfff17 	ldw	r2,-4(fp)
 20366e8:	10c01517 	ldw	r3,84(r2)
 20366ec:	d0a81c17 	ldw	r2,-24464(gp)
 20366f0:	1880801e 	bne	r3,r2,20368f4 <tcp_process+0xa80>
      pcb->state = FIN_WAIT_2;
 20366f4:	e0bfff17 	ldw	r2,-4(fp)
 20366f8:	00c00184 	movi	r3,6
 20366fc:	10c00615 	stw	r3,24(r2)
    }
    break;
 2036700:	00007c06 	br	20368f4 <tcp_process+0xa80>
  case FIN_WAIT_2:
    tcp_receive(pcb);
 2036704:	e13fff17 	ldw	r4,-4(fp)
 2036708:	2036bc80 	call	2036bc8 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 203670c:	d0a81e03 	ldbu	r2,-24456(gp)
 2036710:	10803fcc 	andi	r2,r2,255
 2036714:	1080080c 	andi	r2,r2,32
 2036718:	10007826 	beq	r2,zero,20368fc <tcp_process+0xa88>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 203671c:	e0bfff17 	ldw	r2,-4(fp)
 2036720:	10800883 	ldbu	r2,34(r2)
 2036724:	10800094 	ori	r2,r2,2
 2036728:	1007883a 	mov	r3,r2
 203672c:	e0bfff17 	ldw	r2,-4(fp)
 2036730:	10c00885 	stb	r3,34(r2)
      tcp_pcb_purge(pcb);
 2036734:	e13fff17 	ldw	r4,-4(fp)
 2036738:	201da8c0 	call	201da8c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 203673c:	d0e7f717 	ldw	r3,-24612(gp)
 2036740:	e0bfff17 	ldw	r2,-4(fp)
 2036744:	1880041e 	bne	r3,r2,2036758 <tcp_process+0x8e4>
 2036748:	d0a7f717 	ldw	r2,-24612(gp)
 203674c:	10800317 	ldw	r2,12(r2)
 2036750:	d0a7f715 	stw	r2,-24612(gp)
 2036754:	00001106 	br	203679c <tcp_process+0x928>
 2036758:	d0a7f717 	ldw	r2,-24612(gp)
 203675c:	d0a7fa15 	stw	r2,-24600(gp)
 2036760:	00000c06 	br	2036794 <tcp_process+0x920>
 2036764:	d0a7fa17 	ldw	r2,-24600(gp)
 2036768:	10c00317 	ldw	r3,12(r2)
 203676c:	e0bfff17 	ldw	r2,-4(fp)
 2036770:	1880051e 	bne	r3,r2,2036788 <tcp_process+0x914>
 2036774:	d0a7fa17 	ldw	r2,-24600(gp)
 2036778:	e0ffff17 	ldw	r3,-4(fp)
 203677c:	18c00317 	ldw	r3,12(r3)
 2036780:	10c00315 	stw	r3,12(r2)
 2036784:	00000506 	br	203679c <tcp_process+0x928>
 2036788:	d0a7fa17 	ldw	r2,-24600(gp)
 203678c:	10800317 	ldw	r2,12(r2)
 2036790:	d0a7fa15 	stw	r2,-24600(gp)
 2036794:	d0a7fa17 	ldw	r2,-24600(gp)
 2036798:	103ff21e 	bne	r2,zero,2036764 <__alt_mem_mem_0+0xfd016764>
 203679c:	e0bfff17 	ldw	r2,-4(fp)
 20367a0:	10000315 	stw	zero,12(r2)
 20367a4:	00800044 	movi	r2,1
 20367a8:	d0a7f685 	stb	r2,-24614(gp)
      pcb->state = TIME_WAIT;
 20367ac:	e0bfff17 	ldw	r2,-4(fp)
 20367b0:	00c00284 	movi	r3,10
 20367b4:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
 20367b8:	d0e7fc17 	ldw	r3,-24592(gp)
 20367bc:	e0bfff17 	ldw	r2,-4(fp)
 20367c0:	10c00315 	stw	r3,12(r2)
 20367c4:	e0bfff17 	ldw	r2,-4(fp)
 20367c8:	d0a7fc15 	stw	r2,-24592(gp)
 20367cc:	20215540 	call	2021554 <tcp_timer_needed>
    }
    break;
 20367d0:	00004a06 	br	20368fc <tcp_process+0xa88>
  case CLOSING:
    tcp_receive(pcb);
 20367d4:	e13fff17 	ldw	r4,-4(fp)
 20367d8:	2036bc80 	call	2036bc8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 20367dc:	d0a81d03 	ldbu	r2,-24460(gp)
 20367e0:	10803fcc 	andi	r2,r2,255
 20367e4:	1080040c 	andi	r2,r2,16
 20367e8:	10004626 	beq	r2,zero,2036904 <tcp_process+0xa90>
 20367ec:	e0bfff17 	ldw	r2,-4(fp)
 20367f0:	10c01517 	ldw	r3,84(r2)
 20367f4:	d0a81c17 	ldw	r2,-24464(gp)
 20367f8:	1880421e 	bne	r3,r2,2036904 <tcp_process+0xa90>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 20367fc:	e13fff17 	ldw	r4,-4(fp)
 2036800:	201da8c0 	call	201da8c <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 2036804:	d0e7f717 	ldw	r3,-24612(gp)
 2036808:	e0bfff17 	ldw	r2,-4(fp)
 203680c:	1880041e 	bne	r3,r2,2036820 <tcp_process+0x9ac>
 2036810:	d0a7f717 	ldw	r2,-24612(gp)
 2036814:	10800317 	ldw	r2,12(r2)
 2036818:	d0a7f715 	stw	r2,-24612(gp)
 203681c:	00001106 	br	2036864 <tcp_process+0x9f0>
 2036820:	d0a7f717 	ldw	r2,-24612(gp)
 2036824:	d0a7fa15 	stw	r2,-24600(gp)
 2036828:	00000c06 	br	203685c <tcp_process+0x9e8>
 203682c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036830:	10c00317 	ldw	r3,12(r2)
 2036834:	e0bfff17 	ldw	r2,-4(fp)
 2036838:	1880051e 	bne	r3,r2,2036850 <tcp_process+0x9dc>
 203683c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036840:	e0ffff17 	ldw	r3,-4(fp)
 2036844:	18c00317 	ldw	r3,12(r3)
 2036848:	10c00315 	stw	r3,12(r2)
 203684c:	00000506 	br	2036864 <tcp_process+0x9f0>
 2036850:	d0a7fa17 	ldw	r2,-24600(gp)
 2036854:	10800317 	ldw	r2,12(r2)
 2036858:	d0a7fa15 	stw	r2,-24600(gp)
 203685c:	d0a7fa17 	ldw	r2,-24600(gp)
 2036860:	103ff21e 	bne	r2,zero,203682c <__alt_mem_mem_0+0xfd01682c>
 2036864:	e0bfff17 	ldw	r2,-4(fp)
 2036868:	10000315 	stw	zero,12(r2)
 203686c:	00800044 	movi	r2,1
 2036870:	d0a7f685 	stb	r2,-24614(gp)
      pcb->state = TIME_WAIT;
 2036874:	e0bfff17 	ldw	r2,-4(fp)
 2036878:	00c00284 	movi	r3,10
 203687c:	10c00615 	stw	r3,24(r2)
      TCP_REG(&tcp_tw_pcbs, pcb);
 2036880:	d0e7fc17 	ldw	r3,-24592(gp)
 2036884:	e0bfff17 	ldw	r2,-4(fp)
 2036888:	10c00315 	stw	r3,12(r2)
 203688c:	e0bfff17 	ldw	r2,-4(fp)
 2036890:	d0a7fc15 	stw	r2,-24592(gp)
 2036894:	20215540 	call	2021554 <tcp_timer_needed>
    }
    break;
 2036898:	00001a06 	br	2036904 <tcp_process+0xa90>
  case LAST_ACK:
    tcp_receive(pcb);
 203689c:	e13fff17 	ldw	r4,-4(fp)
 20368a0:	2036bc80 	call	2036bc8 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 20368a4:	d0a81d03 	ldbu	r2,-24460(gp)
 20368a8:	10803fcc 	andi	r2,r2,255
 20368ac:	1080040c 	andi	r2,r2,16
 20368b0:	10001626 	beq	r2,zero,203690c <tcp_process+0xa98>
 20368b4:	e0bfff17 	ldw	r2,-4(fp)
 20368b8:	10c01517 	ldw	r3,84(r2)
 20368bc:	d0a81c17 	ldw	r2,-24464(gp)
 20368c0:	1880121e 	bne	r3,r2,203690c <tcp_process+0xa98>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 20368c4:	d0a81e03 	ldbu	r2,-24456(gp)
 20368c8:	10800414 	ori	r2,r2,16
 20368cc:	d0a81e05 	stb	r2,-24456(gp)
    }
    break;
 20368d0:	00000e06 	br	203690c <tcp_process+0xa98>
  default:
    break;
 20368d4:	0001883a 	nop
 20368d8:	00000d06 	br	2036910 <tcp_process+0xa9c>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
 20368dc:	0001883a 	nop
 20368e0:	00000b06 	br	2036910 <tcp_process+0xa9c>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
 20368e4:	0001883a 	nop
 20368e8:	00000906 	br	2036910 <tcp_process+0xa9c>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
 20368ec:	0001883a 	nop
 20368f0:	00000706 	br	2036910 <tcp_process+0xa9c>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
 20368f4:	0001883a 	nop
 20368f8:	00000506 	br	2036910 <tcp_process+0xa9c>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 20368fc:	0001883a 	nop
 2036900:	00000306 	br	2036910 <tcp_process+0xa9c>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
 2036904:	0001883a 	nop
 2036908:	00000106 	br	2036910 <tcp_process+0xa9c>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
 203690c:	0001883a 	nop
  default:
    break;
  }
  return ERR_OK;
 2036910:	0005883a 	mov	r2,zero
}
 2036914:	e037883a 	mov	sp,fp
 2036918:	dfc00117 	ldw	ra,4(sp)
 203691c:	df000017 	ldw	fp,0(sp)
 2036920:	dec00204 	addi	sp,sp,8
 2036924:	f800283a 	ret

02036928 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
 2036928:	defffb04 	addi	sp,sp,-20
 203692c:	dfc00415 	stw	ra,16(sp)
 2036930:	df000315 	stw	fp,12(sp)
 2036934:	df000304 	addi	fp,sp,12
 2036938:	e13ffe15 	stw	r4,-8(fp)
 203693c:	e17fff15 	stw	r5,-4(fp)
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 2036940:	e0bffe17 	ldw	r2,-8(fp)
 2036944:	10800417 	ldw	r2,16(r2)
 2036948:	10c00303 	ldbu	r3,12(r2)
 203694c:	10800343 	ldbu	r2,13(r2)
 2036950:	1004923a 	slli	r2,r2,8
 2036954:	10c4b03a 	or	r2,r2,r3
 2036958:	10bfffcc 	andi	r2,r2,65535
 203695c:	1004d23a 	srli	r2,r2,8
 2036960:	10ffffcc 	andi	r3,r2,65535
 2036964:	e0bffe17 	ldw	r2,-8(fp)
 2036968:	10800417 	ldw	r2,16(r2)
 203696c:	11000303 	ldbu	r4,12(r2)
 2036970:	10800343 	ldbu	r2,13(r2)
 2036974:	1004923a 	slli	r2,r2,8
 2036978:	1104b03a 	or	r2,r2,r4
 203697c:	10bfffcc 	andi	r2,r2,65535
 2036980:	1004923a 	slli	r2,r2,8
 2036984:	10bfffcc 	andi	r2,r2,65535
 2036988:	1884b03a 	or	r2,r3,r2
 203698c:	1080004c 	andi	r2,r2,1
 2036990:	10003b26 	beq	r2,zero,2036a80 <tcp_oos_insert_segment+0x158>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
 2036994:	e13fff17 	ldw	r4,-4(fp)
 2036998:	201d3dc0 	call	201d3dc <tcp_segs_free>
    next = NULL;
 203699c:	e03fff15 	stw	zero,-4(fp)
 20369a0:	00008006 	br	2036ba4 <tcp_oos_insert_segment+0x27c>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 20369a4:	e0bfff17 	ldw	r2,-4(fp)
 20369a8:	10800417 	ldw	r2,16(r2)
 20369ac:	10c00303 	ldbu	r3,12(r2)
 20369b0:	10800343 	ldbu	r2,13(r2)
 20369b4:	1004923a 	slli	r2,r2,8
 20369b8:	10c4b03a 	or	r2,r2,r3
 20369bc:	10bfffcc 	andi	r2,r2,65535
 20369c0:	1004d23a 	srli	r2,r2,8
 20369c4:	10ffffcc 	andi	r3,r2,65535
 20369c8:	e0bfff17 	ldw	r2,-4(fp)
 20369cc:	10800417 	ldw	r2,16(r2)
 20369d0:	11000303 	ldbu	r4,12(r2)
 20369d4:	10800343 	ldbu	r2,13(r2)
 20369d8:	1004923a 	slli	r2,r2,8
 20369dc:	1104b03a 	or	r2,r2,r4
 20369e0:	10bfffcc 	andi	r2,r2,65535
 20369e4:	1004923a 	slli	r2,r2,8
 20369e8:	10bfffcc 	andi	r2,r2,65535
 20369ec:	1884b03a 	or	r2,r3,r2
 20369f0:	1080004c 	andi	r2,r2,1
 20369f4:	10001b26 	beq	r2,zero,2036a64 <tcp_oos_insert_segment+0x13c>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
 20369f8:	e0bffe17 	ldw	r2,-8(fp)
 20369fc:	10800417 	ldw	r2,16(r2)
 2036a00:	e0fffe17 	ldw	r3,-8(fp)
 2036a04:	18c00417 	ldw	r3,16(r3)
 2036a08:	19000303 	ldbu	r4,12(r3)
 2036a0c:	18c00343 	ldbu	r3,13(r3)
 2036a10:	1806923a 	slli	r3,r3,8
 2036a14:	1906b03a 	or	r3,r3,r4
 2036a18:	18c04014 	ori	r3,r3,256
 2036a1c:	180d883a 	mov	r6,r3
 2036a20:	30ffffcc 	andi	r3,r6,65535
 2036a24:	19403fcc 	andi	r5,r3,255
 2036a28:	10c00303 	ldbu	r3,12(r2)
 2036a2c:	1806703a 	and	r3,r3,zero
 2036a30:	1809883a 	mov	r4,r3
 2036a34:	2807883a 	mov	r3,r5
 2036a38:	20c6b03a 	or	r3,r4,r3
 2036a3c:	10c00305 	stb	r3,12(r2)
 2036a40:	30ffffcc 	andi	r3,r6,65535
 2036a44:	1806d23a 	srli	r3,r3,8
 2036a48:	197fffcc 	andi	r5,r3,65535
 2036a4c:	10c00343 	ldbu	r3,13(r2)
 2036a50:	1806703a 	and	r3,r3,zero
 2036a54:	1809883a 	mov	r4,r3
 2036a58:	2807883a 	mov	r3,r5
 2036a5c:	20c6b03a 	or	r3,r4,r3
 2036a60:	10c00345 	stb	r3,13(r2)
      }
      old_seg = next;
 2036a64:	e0bfff17 	ldw	r2,-4(fp)
 2036a68:	e0bffd15 	stw	r2,-12(fp)
      next = next->next;
 2036a6c:	e0bfff17 	ldw	r2,-4(fp)
 2036a70:	10800017 	ldw	r2,0(r2)
 2036a74:	e0bfff15 	stw	r2,-4(fp)
      tcp_seg_free(old_seg);
 2036a78:	e13ffd17 	ldw	r4,-12(fp)
 2036a7c:	201d4300 	call	201d430 <tcp_seg_free>
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 2036a80:	e0bfff17 	ldw	r2,-4(fp)
 2036a84:	10001826 	beq	r2,zero,2036ae8 <tcp_oos_insert_segment+0x1c0>
           TCP_SEQ_GEQ((seqno + cseg->len),
 2036a88:	e0bffe17 	ldw	r2,-8(fp)
 2036a8c:	1080020b 	ldhu	r2,8(r2)
 2036a90:	10ffffcc 	andi	r3,r2,65535
 2036a94:	d0a81b17 	ldw	r2,-24468(gp)
 2036a98:	1887883a 	add	r3,r3,r2
 2036a9c:	e0bfff17 	ldw	r2,-4(fp)
 2036aa0:	10800417 	ldw	r2,16(r2)
 2036aa4:	11000103 	ldbu	r4,4(r2)
 2036aa8:	11400143 	ldbu	r5,5(r2)
 2036aac:	280a923a 	slli	r5,r5,8
 2036ab0:	2908b03a 	or	r4,r5,r4
 2036ab4:	11400183 	ldbu	r5,6(r2)
 2036ab8:	280a943a 	slli	r5,r5,16
 2036abc:	2908b03a 	or	r4,r5,r4
 2036ac0:	108001c3 	ldbu	r2,7(r2)
 2036ac4:	1004963a 	slli	r2,r2,24
 2036ac8:	1104b03a 	or	r2,r2,r4
 2036acc:	1009883a 	mov	r4,r2
 2036ad0:	e0bfff17 	ldw	r2,-4(fp)
 2036ad4:	1080020b 	ldhu	r2,8(r2)
 2036ad8:	10bfffcc 	andi	r2,r2,65535
 2036adc:	2085883a 	add	r2,r4,r2
 2036ae0:	1885c83a 	sub	r2,r3,r2
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
 2036ae4:	103faf0e 	bge	r2,zero,20369a4 <__alt_mem_mem_0+0xfd0169a4>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 2036ae8:	e0bfff17 	ldw	r2,-4(fp)
 2036aec:	10002d26 	beq	r2,zero,2036ba4 <tcp_oos_insert_segment+0x27c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
 2036af0:	e0bffe17 	ldw	r2,-8(fp)
 2036af4:	1080020b 	ldhu	r2,8(r2)
 2036af8:	10ffffcc 	andi	r3,r2,65535
 2036afc:	d0a81b17 	ldw	r2,-24468(gp)
 2036b00:	1887883a 	add	r3,r3,r2
 2036b04:	e0bfff17 	ldw	r2,-4(fp)
 2036b08:	10800417 	ldw	r2,16(r2)
 2036b0c:	11000103 	ldbu	r4,4(r2)
 2036b10:	11400143 	ldbu	r5,5(r2)
 2036b14:	280a923a 	slli	r5,r5,8
 2036b18:	2908b03a 	or	r4,r5,r4
 2036b1c:	11400183 	ldbu	r5,6(r2)
 2036b20:	280a943a 	slli	r5,r5,16
 2036b24:	2908b03a 	or	r4,r5,r4
 2036b28:	108001c3 	ldbu	r2,7(r2)
 2036b2c:	1004963a 	slli	r2,r2,24
 2036b30:	1104b03a 	or	r2,r2,r4
 2036b34:	1885c83a 	sub	r2,r3,r2
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
 2036b38:	00801a0e 	bge	zero,r2,2036ba4 <tcp_oos_insert_segment+0x27c>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
 2036b3c:	e0bfff17 	ldw	r2,-4(fp)
 2036b40:	10800417 	ldw	r2,16(r2)
 2036b44:	10c00103 	ldbu	r3,4(r2)
 2036b48:	11000143 	ldbu	r4,5(r2)
 2036b4c:	2008923a 	slli	r4,r4,8
 2036b50:	20c6b03a 	or	r3,r4,r3
 2036b54:	11000183 	ldbu	r4,6(r2)
 2036b58:	2008943a 	slli	r4,r4,16
 2036b5c:	20c6b03a 	or	r3,r4,r3
 2036b60:	108001c3 	ldbu	r2,7(r2)
 2036b64:	1004963a 	slli	r2,r2,24
 2036b68:	10c4b03a 	or	r2,r2,r3
 2036b6c:	1007883a 	mov	r3,r2
 2036b70:	d0a81b17 	ldw	r2,-24468(gp)
 2036b74:	1885c83a 	sub	r2,r3,r2
 2036b78:	1007883a 	mov	r3,r2
 2036b7c:	e0bffe17 	ldw	r2,-8(fp)
 2036b80:	10c0020d 	sth	r3,8(r2)
      pbuf_realloc(cseg->p, cseg->len);
 2036b84:	e0bffe17 	ldw	r2,-8(fp)
 2036b88:	10c00117 	ldw	r3,4(r2)
 2036b8c:	e0bffe17 	ldw	r2,-8(fp)
 2036b90:	1080020b 	ldhu	r2,8(r2)
 2036b94:	10bfffcc 	andi	r2,r2,65535
 2036b98:	100b883a 	mov	r5,r2
 2036b9c:	1809883a 	mov	r4,r3
 2036ba0:	201a8580 	call	201a858 <pbuf_realloc>
    }
  }
  cseg->next = next;
 2036ba4:	e0bffe17 	ldw	r2,-8(fp)
 2036ba8:	e0ffff17 	ldw	r3,-4(fp)
 2036bac:	10c00015 	stw	r3,0(r2)
}
 2036bb0:	0001883a 	nop
 2036bb4:	e037883a 	mov	sp,fp
 2036bb8:	dfc00117 	ldw	ra,4(sp)
 2036bbc:	df000017 	ldw	fp,0(sp)
 2036bc0:	dec00204 	addi	sp,sp,8
 2036bc4:	f800283a 	ret

02036bc8 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 2036bc8:	defff204 	addi	sp,sp,-56
 2036bcc:	dfc00d15 	stw	ra,52(sp)
 2036bd0:	df000c15 	stw	fp,48(sp)
 2036bd4:	dc000b15 	stw	r16,44(sp)
 2036bd8:	df000c04 	addi	fp,sp,48
 2036bdc:	e13ffe15 	stw	r4,-8(fp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
 2036be0:	e03ff915 	stw	zero,-28(fp)
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
 2036be4:	d0a81d03 	ldbu	r2,-24460(gp)
 2036be8:	10803fcc 	andi	r2,r2,255
 2036bec:	1080040c 	andi	r2,r2,16
 2036bf0:	1002ab26 	beq	r2,zero,20376a0 <tcp_receive+0xad8>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 2036bf4:	e0bffe17 	ldw	r2,-8(fp)
 2036bf8:	1080190b 	ldhu	r2,100(r2)
 2036bfc:	10ffffcc 	andi	r3,r2,65535
 2036c00:	e0bffe17 	ldw	r2,-8(fp)
 2036c04:	10801717 	ldw	r2,92(r2)
 2036c08:	1885883a 	add	r2,r3,r2
 2036c0c:	e0bffa15 	stw	r2,-24(fp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 2036c10:	e0bffe17 	ldw	r2,-8(fp)
 2036c14:	10c01617 	ldw	r3,88(r2)
 2036c18:	d0a81b17 	ldw	r2,-24468(gp)
 2036c1c:	1885c83a 	sub	r2,r3,r2
 2036c20:	10001816 	blt	r2,zero,2036c84 <tcp_receive+0xbc>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 2036c24:	e0bffe17 	ldw	r2,-8(fp)
 2036c28:	10c01617 	ldw	r3,88(r2)
 2036c2c:	d0a81b17 	ldw	r2,-24468(gp)

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 2036c30:	1880051e 	bne	r3,r2,2036c48 <tcp_receive+0x80>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 2036c34:	e0bffe17 	ldw	r2,-8(fp)
 2036c38:	10c01717 	ldw	r3,92(r2)
 2036c3c:	d0a81c17 	ldw	r2,-24464(gp)
 2036c40:	1885c83a 	sub	r2,r3,r2
 2036c44:	10000f16 	blt	r2,zero,2036c84 <tcp_receive+0xbc>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 2036c48:	e0bffe17 	ldw	r2,-8(fp)
 2036c4c:	10c01717 	ldw	r3,92(r2)
 2036c50:	d0a81c17 	ldw	r2,-24464(gp)
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 2036c54:	18803f1e 	bne	r3,r2,2036d54 <tcp_receive+0x18c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 2036c58:	d0a81917 	ldw	r2,-24476(gp)
 2036c5c:	10c00383 	ldbu	r3,14(r2)
 2036c60:	108003c3 	ldbu	r2,15(r2)
 2036c64:	1004923a 	slli	r2,r2,8
 2036c68:	10c4b03a 	or	r2,r2,r3
 2036c6c:	1009883a 	mov	r4,r2
 2036c70:	e0bffe17 	ldw	r2,-8(fp)
 2036c74:	10c0190b 	ldhu	r3,100(r2)
 2036c78:	20bfffcc 	andi	r2,r4,65535
 2036c7c:	18ffffcc 	andi	r3,r3,65535
 2036c80:	1880342e 	bgeu	r3,r2,2036d54 <tcp_receive+0x18c>
      pcb->snd_wnd = tcphdr->wnd;
 2036c84:	d0a81917 	ldw	r2,-24476(gp)
 2036c88:	10c00383 	ldbu	r3,14(r2)
 2036c8c:	108003c3 	ldbu	r2,15(r2)
 2036c90:	1004923a 	slli	r2,r2,8
 2036c94:	10c4b03a 	or	r2,r2,r3
 2036c98:	1007883a 	mov	r3,r2
 2036c9c:	e0bffe17 	ldw	r2,-8(fp)
 2036ca0:	10c0190d 	sth	r3,100(r2)
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 2036ca4:	e0bffe17 	ldw	r2,-8(fp)
 2036ca8:	1100198b 	ldhu	r4,102(r2)
 2036cac:	d0a81917 	ldw	r2,-24476(gp)
 2036cb0:	10c00383 	ldbu	r3,14(r2)
 2036cb4:	108003c3 	ldbu	r2,15(r2)
 2036cb8:	1004923a 	slli	r2,r2,8
 2036cbc:	10c4b03a 	or	r2,r2,r3
 2036cc0:	20ffffcc 	andi	r3,r4,65535
 2036cc4:	10bfffcc 	andi	r2,r2,65535
 2036cc8:	1880082e 	bgeu	r3,r2,2036cec <tcp_receive+0x124>
        pcb->snd_wnd_max = tcphdr->wnd;
 2036ccc:	d0a81917 	ldw	r2,-24476(gp)
 2036cd0:	10c00383 	ldbu	r3,14(r2)
 2036cd4:	108003c3 	ldbu	r2,15(r2)
 2036cd8:	1004923a 	slli	r2,r2,8
 2036cdc:	10c4b03a 	or	r2,r2,r3
 2036ce0:	1007883a 	mov	r3,r2
 2036ce4:	e0bffe17 	ldw	r2,-8(fp)
 2036ce8:	10c0198d 	sth	r3,102(r2)
      }
      pcb->snd_wl1 = seqno;
 2036cec:	d0e81b17 	ldw	r3,-24468(gp)
 2036cf0:	e0bffe17 	ldw	r2,-8(fp)
 2036cf4:	10c01615 	stw	r3,88(r2)
      pcb->snd_wl2 = ackno;
 2036cf8:	d0e81c17 	ldw	r3,-24464(gp)
 2036cfc:	e0bffe17 	ldw	r2,-8(fp)
 2036d00:	10c01715 	stw	r3,92(r2)
      if (pcb->snd_wnd == 0) {
 2036d04:	e0bffe17 	ldw	r2,-8(fp)
 2036d08:	1080190b 	ldhu	r2,100(r2)
 2036d0c:	10bfffcc 	andi	r2,r2,65535
 2036d10:	10000a1e 	bne	r2,zero,2036d3c <tcp_receive+0x174>
        if (pcb->persist_backoff == 0) {
 2036d14:	e0bffe17 	ldw	r2,-8(fp)
 2036d18:	10802843 	ldbu	r2,161(r2)
 2036d1c:	10803fcc 	andi	r2,r2,255
 2036d20:	10000c1e 	bne	r2,zero,2036d54 <tcp_receive+0x18c>
          /* start persist timer */
          pcb->persist_cnt = 0;
 2036d24:	e0bffe17 	ldw	r2,-8(fp)
 2036d28:	10002805 	stb	zero,160(r2)
          pcb->persist_backoff = 1;
 2036d2c:	e0bffe17 	ldw	r2,-8(fp)
 2036d30:	00c00044 	movi	r3,1
 2036d34:	10c02845 	stb	r3,161(r2)
 2036d38:	00000606 	br	2036d54 <tcp_receive+0x18c>
        }
      } else if (pcb->persist_backoff > 0) {
 2036d3c:	e0bffe17 	ldw	r2,-8(fp)
 2036d40:	10802843 	ldbu	r2,161(r2)
 2036d44:	10803fcc 	andi	r2,r2,255
 2036d48:	10000226 	beq	r2,zero,2036d54 <tcp_receive+0x18c>
        /* stop persist timer */
          pcb->persist_backoff = 0;
 2036d4c:	e0bffe17 	ldw	r2,-8(fp)
 2036d50:	10002845 	stb	zero,161(r2)
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 2036d54:	d0e81c17 	ldw	r3,-24464(gp)
 2036d58:	e0bffe17 	ldw	r2,-8(fp)
 2036d5c:	10801317 	ldw	r2,76(r2)
 2036d60:	1885c83a 	sub	r2,r3,r2
 2036d64:	00804d16 	blt	zero,r2,2036e9c <tcp_receive+0x2d4>
      pcb->acked = 0;
 2036d68:	e0bffe17 	ldw	r2,-8(fp)
 2036d6c:	10001a0d 	sth	zero,104(r2)
      /* Clause 2 */
      if (tcplen == 0) {
 2036d70:	d0a81d8b 	ldhu	r2,-24458(gp)
 2036d74:	10bfffcc 	andi	r2,r2,65535
 2036d78:	1000431e 	bne	r2,zero,2036e88 <tcp_receive+0x2c0>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 2036d7c:	e0bffe17 	ldw	r2,-8(fp)
 2036d80:	10c01717 	ldw	r3,92(r2)
 2036d84:	e0bffe17 	ldw	r2,-8(fp)
 2036d88:	1080190b 	ldhu	r2,100(r2)
 2036d8c:	10bfffcc 	andi	r2,r2,65535
 2036d90:	1887883a 	add	r3,r3,r2
 2036d94:	e0bffa17 	ldw	r2,-24(fp)
 2036d98:	18803b1e 	bne	r3,r2,2036e88 <tcp_receive+0x2c0>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 2036d9c:	e0bffe17 	ldw	r2,-8(fp)
 2036da0:	10800e0b 	ldhu	r2,56(r2)
 2036da4:	10bfffcc 	andi	r2,r2,65535
 2036da8:	10a0001c 	xori	r2,r2,32768
 2036dac:	10a00004 	addi	r2,r2,-32768
 2036db0:	10003516 	blt	r2,zero,2036e88 <tcp_receive+0x2c0>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 2036db4:	e0bffe17 	ldw	r2,-8(fp)
 2036db8:	10c01317 	ldw	r3,76(r2)
 2036dbc:	d0a81c17 	ldw	r2,-24464(gp)
 2036dc0:	1880311e 	bne	r3,r2,2036e88 <tcp_receive+0x2c0>
              found_dupack = 1;
 2036dc4:	00800044 	movi	r2,1
 2036dc8:	e0bff915 	stw	r2,-28(fp)
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 2036dcc:	e0bffe17 	ldw	r2,-8(fp)
 2036dd0:	108012c3 	ldbu	r2,75(r2)
 2036dd4:	10800044 	addi	r2,r2,1
 2036dd8:	1009883a 	mov	r4,r2
 2036ddc:	e0bffe17 	ldw	r2,-8(fp)
 2036de0:	10c012c3 	ldbu	r3,75(r2)
 2036de4:	20803fcc 	andi	r2,r4,255
 2036de8:	18c03fcc 	andi	r3,r3,255
 2036dec:	1880062e 	bgeu	r3,r2,2036e08 <tcp_receive+0x240>
                ++pcb->dupacks;
 2036df0:	e0bffe17 	ldw	r2,-8(fp)
 2036df4:	108012c3 	ldbu	r2,75(r2)
 2036df8:	10800044 	addi	r2,r2,1
 2036dfc:	1007883a 	mov	r3,r2
 2036e00:	e0bffe17 	ldw	r2,-8(fp)
 2036e04:	10c012c5 	stb	r3,75(r2)
              }
              if (pcb->dupacks > 3) {
 2036e08:	e0bffe17 	ldw	r2,-8(fp)
 2036e0c:	108012c3 	ldbu	r2,75(r2)
 2036e10:	10803fcc 	andi	r2,r2,255
 2036e14:	10800130 	cmpltui	r2,r2,4
 2036e18:	1000141e 	bne	r2,zero,2036e6c <tcp_receive+0x2a4>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 2036e1c:	e0bffe17 	ldw	r2,-8(fp)
 2036e20:	10c0140b 	ldhu	r3,80(r2)
 2036e24:	e0bffe17 	ldw	r2,-8(fp)
 2036e28:	10800e8b 	ldhu	r2,58(r2)
 2036e2c:	1885883a 	add	r2,r3,r2
 2036e30:	1009883a 	mov	r4,r2
 2036e34:	e0bffe17 	ldw	r2,-8(fp)
 2036e38:	10c0140b 	ldhu	r3,80(r2)
 2036e3c:	20bfffcc 	andi	r2,r4,65535
 2036e40:	18ffffcc 	andi	r3,r3,65535
 2036e44:	1880102e 	bgeu	r3,r2,2036e88 <tcp_receive+0x2c0>
                  pcb->cwnd += pcb->mss;
 2036e48:	e0bffe17 	ldw	r2,-8(fp)
 2036e4c:	10c0140b 	ldhu	r3,80(r2)
 2036e50:	e0bffe17 	ldw	r2,-8(fp)
 2036e54:	10800e8b 	ldhu	r2,58(r2)
 2036e58:	1885883a 	add	r2,r3,r2
 2036e5c:	1007883a 	mov	r3,r2
 2036e60:	e0bffe17 	ldw	r2,-8(fp)
 2036e64:	10c0140d 	sth	r3,80(r2)
 2036e68:	00000706 	br	2036e88 <tcp_receive+0x2c0>
                }
              } else if (pcb->dupacks == 3) {
 2036e6c:	e0bffe17 	ldw	r2,-8(fp)
 2036e70:	108012c3 	ldbu	r2,75(r2)
 2036e74:	10803fcc 	andi	r2,r2,255
 2036e78:	108000d8 	cmpnei	r2,r2,3
 2036e7c:	1000021e 	bne	r2,zero,2036e88 <tcp_receive+0x2c0>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 2036e80:	e13ffe17 	ldw	r4,-8(fp)
 2036e84:	2020f540 	call	2020f54 <tcp_rexmit_fast>
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
 2036e88:	e0bff917 	ldw	r2,-28(fp)
 2036e8c:	10015a1e 	bne	r2,zero,20373f8 <tcp_receive+0x830>
        pcb->dupacks = 0;
 2036e90:	e0bffe17 	ldw	r2,-8(fp)
 2036e94:	100012c5 	stb	zero,75(r2)
 2036e98:	00015706 	br	20373f8 <tcp_receive+0x830>
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 2036e9c:	d0e81c17 	ldw	r3,-24464(gp)
 2036ea0:	e0bffe17 	ldw	r2,-8(fp)
 2036ea4:	10801317 	ldw	r2,76(r2)
 2036ea8:	1885c83a 	sub	r2,r3,r2
 2036eac:	10bfffc4 	addi	r2,r2,-1
 2036eb0:	10011416 	blt	r2,zero,2037304 <tcp_receive+0x73c>
 2036eb4:	d0e81c17 	ldw	r3,-24464(gp)
 2036eb8:	e0bffe17 	ldw	r2,-8(fp)
 2036ebc:	10801517 	ldw	r2,84(r2)
 2036ec0:	1885c83a 	sub	r2,r3,r2
 2036ec4:	00810f16 	blt	zero,r2,2037304 <tcp_receive+0x73c>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 2036ec8:	e0bffe17 	ldw	r2,-8(fp)
 2036ecc:	10800883 	ldbu	r2,34(r2)
 2036ed0:	10803fcc 	andi	r2,r2,255
 2036ed4:	1080010c 	andi	r2,r2,4
 2036ed8:	10000b26 	beq	r2,zero,2036f08 <tcp_receive+0x340>
        pcb->flags &= ~TF_INFR;
 2036edc:	e0bffe17 	ldw	r2,-8(fp)
 2036ee0:	10c00883 	ldbu	r3,34(r2)
 2036ee4:	00bffec4 	movi	r2,-5
 2036ee8:	1884703a 	and	r2,r3,r2
 2036eec:	1007883a 	mov	r3,r2
 2036ef0:	e0bffe17 	ldw	r2,-8(fp)
 2036ef4:	10c00885 	stb	r3,34(r2)
        pcb->cwnd = pcb->ssthresh;
 2036ef8:	e0bffe17 	ldw	r2,-8(fp)
 2036efc:	10c0148b 	ldhu	r3,82(r2)
 2036f00:	e0bffe17 	ldw	r2,-8(fp)
 2036f04:	10c0140d 	sth	r3,80(r2)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 2036f08:	e0bffe17 	ldw	r2,-8(fp)
 2036f0c:	10001285 	stb	zero,74(r2)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 2036f10:	e0bffe17 	ldw	r2,-8(fp)
 2036f14:	1080110b 	ldhu	r2,68(r2)
 2036f18:	10bfffcc 	andi	r2,r2,65535
 2036f1c:	10a0001c 	xori	r2,r2,32768
 2036f20:	10a00004 	addi	r2,r2,-32768
 2036f24:	1005d0fa 	srai	r2,r2,3
 2036f28:	1007883a 	mov	r3,r2
 2036f2c:	e0bffe17 	ldw	r2,-8(fp)
 2036f30:	1080118b 	ldhu	r2,70(r2)
 2036f34:	1885883a 	add	r2,r3,r2
 2036f38:	1007883a 	mov	r3,r2
 2036f3c:	e0bffe17 	ldw	r2,-8(fp)
 2036f40:	10c0120d 	sth	r3,72(r2)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 2036f44:	d0a81c17 	ldw	r2,-24464(gp)
 2036f48:	1007883a 	mov	r3,r2
 2036f4c:	e0bffe17 	ldw	r2,-8(fp)
 2036f50:	10801317 	ldw	r2,76(r2)
 2036f54:	1885c83a 	sub	r2,r3,r2
 2036f58:	1007883a 	mov	r3,r2
 2036f5c:	e0bffe17 	ldw	r2,-8(fp)
 2036f60:	10c01a0d 	sth	r3,104(r2)

      pcb->snd_buf += pcb->acked;
 2036f64:	e0bffe17 	ldw	r2,-8(fp)
 2036f68:	10c01a8b 	ldhu	r3,106(r2)
 2036f6c:	e0bffe17 	ldw	r2,-8(fp)
 2036f70:	10801a0b 	ldhu	r2,104(r2)
 2036f74:	1885883a 	add	r2,r3,r2
 2036f78:	1007883a 	mov	r3,r2
 2036f7c:	e0bffe17 	ldw	r2,-8(fp)
 2036f80:	10c01a8d 	sth	r3,106(r2)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 2036f84:	e0bffe17 	ldw	r2,-8(fp)
 2036f88:	100012c5 	stb	zero,75(r2)
      pcb->lastack = ackno;
 2036f8c:	d0e81c17 	ldw	r3,-24464(gp)
 2036f90:	e0bffe17 	ldw	r2,-8(fp)
 2036f94:	10c01315 	stw	r3,76(r2)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 2036f98:	e0bffe17 	ldw	r2,-8(fp)
 2036f9c:	10800617 	ldw	r2,24(r2)
 2036fa0:	10800130 	cmpltui	r2,r2,4
 2036fa4:	10006a1e 	bne	r2,zero,2037150 <tcp_receive+0x588>
        if (pcb->cwnd < pcb->ssthresh) {
 2036fa8:	e0bffe17 	ldw	r2,-8(fp)
 2036fac:	10c0140b 	ldhu	r3,80(r2)
 2036fb0:	e0bffe17 	ldw	r2,-8(fp)
 2036fb4:	1080148b 	ldhu	r2,82(r2)
 2036fb8:	18ffffcc 	andi	r3,r3,65535
 2036fbc:	10bfffcc 	andi	r2,r2,65535
 2036fc0:	1880142e 	bgeu	r3,r2,2037014 <tcp_receive+0x44c>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 2036fc4:	e0bffe17 	ldw	r2,-8(fp)
 2036fc8:	10c0140b 	ldhu	r3,80(r2)
 2036fcc:	e0bffe17 	ldw	r2,-8(fp)
 2036fd0:	10800e8b 	ldhu	r2,58(r2)
 2036fd4:	1885883a 	add	r2,r3,r2
 2036fd8:	1009883a 	mov	r4,r2
 2036fdc:	e0bffe17 	ldw	r2,-8(fp)
 2036fe0:	10c0140b 	ldhu	r3,80(r2)
 2036fe4:	20bfffcc 	andi	r2,r4,65535
 2036fe8:	18ffffcc 	andi	r3,r3,65535
 2036fec:	1880582e 	bgeu	r3,r2,2037150 <tcp_receive+0x588>
            pcb->cwnd += pcb->mss;
 2036ff0:	e0bffe17 	ldw	r2,-8(fp)
 2036ff4:	10c0140b 	ldhu	r3,80(r2)
 2036ff8:	e0bffe17 	ldw	r2,-8(fp)
 2036ffc:	10800e8b 	ldhu	r2,58(r2)
 2037000:	1885883a 	add	r2,r3,r2
 2037004:	1007883a 	mov	r3,r2
 2037008:	e0bffe17 	ldw	r2,-8(fp)
 203700c:	10c0140d 	sth	r3,80(r2)
 2037010:	00004f06 	br	2037150 <tcp_receive+0x588>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 2037014:	e0bffe17 	ldw	r2,-8(fp)
 2037018:	1400140b 	ldhu	r16,80(r2)
 203701c:	e0bffe17 	ldw	r2,-8(fp)
 2037020:	10800e8b 	ldhu	r2,58(r2)
 2037024:	10ffffcc 	andi	r3,r2,65535
 2037028:	e0bffe17 	ldw	r2,-8(fp)
 203702c:	10800e8b 	ldhu	r2,58(r2)
 2037030:	10bfffcc 	andi	r2,r2,65535
 2037034:	1887383a 	mul	r3,r3,r2
 2037038:	e0bffe17 	ldw	r2,-8(fp)
 203703c:	1080140b 	ldhu	r2,80(r2)
 2037040:	10bfffcc 	andi	r2,r2,65535
 2037044:	100b883a 	mov	r5,r2
 2037048:	1809883a 	mov	r4,r3
 203704c:	200abb00 	call	200abb0 <__divsi3>
 2037050:	8085883a 	add	r2,r16,r2
 2037054:	e0bffb0d 	sth	r2,-20(fp)
          if (new_cwnd > pcb->cwnd) {
 2037058:	e0bffe17 	ldw	r2,-8(fp)
 203705c:	1080140b 	ldhu	r2,80(r2)
 2037060:	10ffffcc 	andi	r3,r2,65535
 2037064:	e0bffb0b 	ldhu	r2,-20(fp)
 2037068:	1880392e 	bgeu	r3,r2,2037150 <tcp_receive+0x588>
            pcb->cwnd = new_cwnd;
 203706c:	e0bffe17 	ldw	r2,-8(fp)
 2037070:	e0fffb0b 	ldhu	r3,-20(fp)
 2037074:	10c0140d 	sth	r3,80(r2)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 2037078:	00003506 	br	2037150 <tcp_receive+0x588>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 203707c:	e0bffe17 	ldw	r2,-8(fp)
 2037080:	10801d17 	ldw	r2,116(r2)
 2037084:	e0bff415 	stw	r2,-48(fp)
        pcb->unacked = pcb->unacked->next;
 2037088:	e0bffe17 	ldw	r2,-8(fp)
 203708c:	10801d17 	ldw	r2,116(r2)
 2037090:	10c00017 	ldw	r3,0(r2)
 2037094:	e0bffe17 	ldw	r2,-8(fp)
 2037098:	10c01d15 	stw	r3,116(r2)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 203709c:	e0bffe17 	ldw	r2,-8(fp)
 20370a0:	10801a0b 	ldhu	r2,104(r2)
 20370a4:	10bfffcc 	andi	r2,r2,65535
 20370a8:	10001b26 	beq	r2,zero,2037118 <tcp_receive+0x550>
 20370ac:	e0bff417 	ldw	r2,-48(fp)
 20370b0:	10800417 	ldw	r2,16(r2)
 20370b4:	10c00303 	ldbu	r3,12(r2)
 20370b8:	10800343 	ldbu	r2,13(r2)
 20370bc:	1004923a 	slli	r2,r2,8
 20370c0:	10c4b03a 	or	r2,r2,r3
 20370c4:	10bfffcc 	andi	r2,r2,65535
 20370c8:	1004d23a 	srli	r2,r2,8
 20370cc:	10ffffcc 	andi	r3,r2,65535
 20370d0:	e0bff417 	ldw	r2,-48(fp)
 20370d4:	10800417 	ldw	r2,16(r2)
 20370d8:	11000303 	ldbu	r4,12(r2)
 20370dc:	10800343 	ldbu	r2,13(r2)
 20370e0:	1004923a 	slli	r2,r2,8
 20370e4:	1104b03a 	or	r2,r2,r4
 20370e8:	10bfffcc 	andi	r2,r2,65535
 20370ec:	1004923a 	slli	r2,r2,8
 20370f0:	10bfffcc 	andi	r2,r2,65535
 20370f4:	1884b03a 	or	r2,r3,r2
 20370f8:	1080004c 	andi	r2,r2,1
 20370fc:	10000626 	beq	r2,zero,2037118 <tcp_receive+0x550>
          pcb->acked--;
 2037100:	e0bffe17 	ldw	r2,-8(fp)
 2037104:	10801a0b 	ldhu	r2,104(r2)
 2037108:	10bfffc4 	addi	r2,r2,-1
 203710c:	1007883a 	mov	r3,r2
 2037110:	e0bffe17 	ldw	r2,-8(fp)
 2037114:	10c01a0d 	sth	r3,104(r2)
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 2037118:	e0bff417 	ldw	r2,-48(fp)
 203711c:	10800117 	ldw	r2,4(r2)
 2037120:	1009883a 	mov	r4,r2
 2037124:	201acac0 	call	201acac <pbuf_clen>
 2037128:	1009883a 	mov	r4,r2
 203712c:	e0bffe17 	ldw	r2,-8(fp)
 2037130:	10c01b0b 	ldhu	r3,108(r2)
 2037134:	20803fcc 	andi	r2,r4,255
 2037138:	1885c83a 	sub	r2,r3,r2
 203713c:	1007883a 	mov	r3,r2
 2037140:	e0bffe17 	ldw	r2,-8(fp)
 2037144:	10c01b0d 	sth	r3,108(r2)
        tcp_seg_free(next);
 2037148:	e13ff417 	ldw	r4,-48(fp)
 203714c:	201d4300 	call	201d430 <tcp_seg_free>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 2037150:	e0bffe17 	ldw	r2,-8(fp)
 2037154:	10801d17 	ldw	r2,116(r2)
 2037158:	10005e26 	beq	r2,zero,20372d4 <tcp_receive+0x70c>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 203715c:	e0bffe17 	ldw	r2,-8(fp)
 2037160:	10801d17 	ldw	r2,116(r2)
 2037164:	10800417 	ldw	r2,16(r2)
 2037168:	10c00103 	ldbu	r3,4(r2)
 203716c:	11000143 	ldbu	r4,5(r2)
 2037170:	2008923a 	slli	r4,r4,8
 2037174:	20c6b03a 	or	r3,r4,r3
 2037178:	11000183 	ldbu	r4,6(r2)
 203717c:	2008943a 	slli	r4,r4,16
 2037180:	20c6b03a 	or	r3,r4,r3
 2037184:	108001c3 	ldbu	r2,7(r2)
 2037188:	1004963a 	slli	r2,r2,24
 203718c:	10c4b03a 	or	r2,r2,r3
 2037190:	1006d63a 	srli	r3,r2,24
 2037194:	e0bffe17 	ldw	r2,-8(fp)
 2037198:	10801d17 	ldw	r2,116(r2)
 203719c:	10800417 	ldw	r2,16(r2)
 20371a0:	11000103 	ldbu	r4,4(r2)
 20371a4:	11400143 	ldbu	r5,5(r2)
 20371a8:	280a923a 	slli	r5,r5,8
 20371ac:	2908b03a 	or	r4,r5,r4
 20371b0:	11400183 	ldbu	r5,6(r2)
 20371b4:	280a943a 	slli	r5,r5,16
 20371b8:	2908b03a 	or	r4,r5,r4
 20371bc:	108001c3 	ldbu	r2,7(r2)
 20371c0:	1004963a 	slli	r2,r2,24
 20371c4:	1104b03a 	or	r2,r2,r4
 20371c8:	1004d23a 	srli	r2,r2,8
 20371cc:	10bfc00c 	andi	r2,r2,65280
 20371d0:	1886b03a 	or	r3,r3,r2
 20371d4:	e0bffe17 	ldw	r2,-8(fp)
 20371d8:	10801d17 	ldw	r2,116(r2)
 20371dc:	10800417 	ldw	r2,16(r2)
 20371e0:	11000103 	ldbu	r4,4(r2)
 20371e4:	11400143 	ldbu	r5,5(r2)
 20371e8:	280a923a 	slli	r5,r5,8
 20371ec:	2908b03a 	or	r4,r5,r4
 20371f0:	11400183 	ldbu	r5,6(r2)
 20371f4:	280a943a 	slli	r5,r5,16
 20371f8:	2908b03a 	or	r4,r5,r4
 20371fc:	108001c3 	ldbu	r2,7(r2)
 2037200:	1004963a 	slli	r2,r2,24
 2037204:	1104b03a 	or	r2,r2,r4
 2037208:	10bfc00c 	andi	r2,r2,65280
 203720c:	1004923a 	slli	r2,r2,8
 2037210:	1886b03a 	or	r3,r3,r2
 2037214:	e0bffe17 	ldw	r2,-8(fp)
 2037218:	10801d17 	ldw	r2,116(r2)
 203721c:	10800417 	ldw	r2,16(r2)
 2037220:	11000103 	ldbu	r4,4(r2)
 2037224:	11400143 	ldbu	r5,5(r2)
 2037228:	280a923a 	slli	r5,r5,8
 203722c:	2908b03a 	or	r4,r5,r4
 2037230:	11400183 	ldbu	r5,6(r2)
 2037234:	280a943a 	slli	r5,r5,16
 2037238:	2908b03a 	or	r4,r5,r4
 203723c:	108001c3 	ldbu	r2,7(r2)
 2037240:	1004963a 	slli	r2,r2,24
 2037244:	1104b03a 	or	r2,r2,r4
 2037248:	1004963a 	slli	r2,r2,24
 203724c:	1886b03a 	or	r3,r3,r2
 2037250:	e0bffe17 	ldw	r2,-8(fp)
 2037254:	10801d17 	ldw	r2,116(r2)
 2037258:	1080020b 	ldhu	r2,8(r2)
 203725c:	113fffcc 	andi	r4,r2,65535
 2037260:	e0bffe17 	ldw	r2,-8(fp)
 2037264:	10801d17 	ldw	r2,116(r2)
 2037268:	10800417 	ldw	r2,16(r2)
 203726c:	11400303 	ldbu	r5,12(r2)
 2037270:	10800343 	ldbu	r2,13(r2)
 2037274:	1004923a 	slli	r2,r2,8
 2037278:	1144b03a 	or	r2,r2,r5
 203727c:	10bfffcc 	andi	r2,r2,65535
 2037280:	1004d23a 	srli	r2,r2,8
 2037284:	117fffcc 	andi	r5,r2,65535
 2037288:	e0bffe17 	ldw	r2,-8(fp)
 203728c:	10801d17 	ldw	r2,116(r2)
 2037290:	10800417 	ldw	r2,16(r2)
 2037294:	11800303 	ldbu	r6,12(r2)
 2037298:	10800343 	ldbu	r2,13(r2)
 203729c:	1004923a 	slli	r2,r2,8
 20372a0:	1184b03a 	or	r2,r2,r6
 20372a4:	10bfffcc 	andi	r2,r2,65535
 20372a8:	1004923a 	slli	r2,r2,8
 20372ac:	10bfffcc 	andi	r2,r2,65535
 20372b0:	2884b03a 	or	r2,r5,r2
 20372b4:	108000cc 	andi	r2,r2,3
 20372b8:	1004c03a 	cmpne	r2,r2,zero
 20372bc:	10803fcc 	andi	r2,r2,255
 20372c0:	2085883a 	add	r2,r4,r2
 20372c4:	1887883a 	add	r3,r3,r2
 20372c8:	d0a81c17 	ldw	r2,-24464(gp)
 20372cc:	1885c83a 	sub	r2,r3,r2
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 20372d0:	00bf6a0e 	bge	zero,r2,203707c <__alt_mem_mem_0+0xfd01707c>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 20372d4:	e0bffe17 	ldw	r2,-8(fp)
 20372d8:	10801d17 	ldw	r2,116(r2)
 20372dc:	1000041e 	bne	r2,zero,20372f0 <tcp_receive+0x728>
        pcb->rtime = -1;
 20372e0:	e0bffe17 	ldw	r2,-8(fp)
 20372e4:	00ffffc4 	movi	r3,-1
 20372e8:	10c00e0d 	sth	r3,56(r2)
 20372ec:	00000206 	br	20372f8 <tcp_receive+0x730>
      else
        pcb->rtime = 0;
 20372f0:	e0bffe17 	ldw	r2,-8(fp)
 20372f4:	10000e0d 	sth	zero,56(r2)

      pcb->polltmr = 0;
 20372f8:	e0bffe17 	ldw	r2,-8(fp)
 20372fc:	100008c5 	stb	zero,35(r2)
 2037300:	00000206 	br	203730c <tcp_receive+0x744>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 2037304:	e0bffe17 	ldw	r2,-8(fp)
 2037308:	10001a0d 	sth	zero,104(r2)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 203730c:	00003a06 	br	20373f8 <tcp_receive+0x830>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 2037310:	e0bffe17 	ldw	r2,-8(fp)
 2037314:	10801c17 	ldw	r2,112(r2)
 2037318:	e0bff415 	stw	r2,-48(fp)
      pcb->unsent = pcb->unsent->next;
 203731c:	e0bffe17 	ldw	r2,-8(fp)
 2037320:	10801c17 	ldw	r2,112(r2)
 2037324:	10c00017 	ldw	r3,0(r2)
 2037328:	e0bffe17 	ldw	r2,-8(fp)
 203732c:	10c01c15 	stw	r3,112(r2)
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 2037330:	e0bffe17 	ldw	r2,-8(fp)
 2037334:	10801c17 	ldw	r2,112(r2)
 2037338:	1000021e 	bne	r2,zero,2037344 <tcp_receive+0x77c>
        pcb->unsent_oversize = 0;
 203733c:	e0bffe17 	ldw	r2,-8(fp)
 2037340:	10001b8d 	sth	zero,110(r2)
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 2037344:	e0bffe17 	ldw	r2,-8(fp)
 2037348:	10801a0b 	ldhu	r2,104(r2)
 203734c:	10bfffcc 	andi	r2,r2,65535
 2037350:	10001b26 	beq	r2,zero,20373c0 <tcp_receive+0x7f8>
 2037354:	e0bff417 	ldw	r2,-48(fp)
 2037358:	10800417 	ldw	r2,16(r2)
 203735c:	10c00303 	ldbu	r3,12(r2)
 2037360:	10800343 	ldbu	r2,13(r2)
 2037364:	1004923a 	slli	r2,r2,8
 2037368:	10c4b03a 	or	r2,r2,r3
 203736c:	10bfffcc 	andi	r2,r2,65535
 2037370:	1004d23a 	srli	r2,r2,8
 2037374:	10ffffcc 	andi	r3,r2,65535
 2037378:	e0bff417 	ldw	r2,-48(fp)
 203737c:	10800417 	ldw	r2,16(r2)
 2037380:	11000303 	ldbu	r4,12(r2)
 2037384:	10800343 	ldbu	r2,13(r2)
 2037388:	1004923a 	slli	r2,r2,8
 203738c:	1104b03a 	or	r2,r2,r4
 2037390:	10bfffcc 	andi	r2,r2,65535
 2037394:	1004923a 	slli	r2,r2,8
 2037398:	10bfffcc 	andi	r2,r2,65535
 203739c:	1884b03a 	or	r2,r3,r2
 20373a0:	1080004c 	andi	r2,r2,1
 20373a4:	10000626 	beq	r2,zero,20373c0 <tcp_receive+0x7f8>
        pcb->acked--;
 20373a8:	e0bffe17 	ldw	r2,-8(fp)
 20373ac:	10801a0b 	ldhu	r2,104(r2)
 20373b0:	10bfffc4 	addi	r2,r2,-1
 20373b4:	1007883a 	mov	r3,r2
 20373b8:	e0bffe17 	ldw	r2,-8(fp)
 20373bc:	10c01a0d 	sth	r3,104(r2)
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 20373c0:	e0bff417 	ldw	r2,-48(fp)
 20373c4:	10800117 	ldw	r2,4(r2)
 20373c8:	1009883a 	mov	r4,r2
 20373cc:	201acac0 	call	201acac <pbuf_clen>
 20373d0:	1009883a 	mov	r4,r2
 20373d4:	e0bffe17 	ldw	r2,-8(fp)
 20373d8:	10c01b0b 	ldhu	r3,108(r2)
 20373dc:	20803fcc 	andi	r2,r4,255
 20373e0:	1885c83a 	sub	r2,r3,r2
 20373e4:	1007883a 	mov	r3,r2
 20373e8:	e0bffe17 	ldw	r2,-8(fp)
 20373ec:	10c01b0d 	sth	r3,108(r2)
      tcp_seg_free(next);
 20373f0:	e13ff417 	ldw	r4,-48(fp)
 20373f4:	201d4300 	call	201d430 <tcp_seg_free>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 20373f8:	e0bffe17 	ldw	r2,-8(fp)
 20373fc:	10801c17 	ldw	r2,112(r2)
 2037400:	10006326 	beq	r2,zero,2037590 <tcp_receive+0x9c8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 2037404:	d0e81c17 	ldw	r3,-24464(gp)
 2037408:	e0bffe17 	ldw	r2,-8(fp)
 203740c:	10801c17 	ldw	r2,112(r2)
 2037410:	10800417 	ldw	r2,16(r2)
 2037414:	11000103 	ldbu	r4,4(r2)
 2037418:	11400143 	ldbu	r5,5(r2)
 203741c:	280a923a 	slli	r5,r5,8
 2037420:	2908b03a 	or	r4,r5,r4
 2037424:	11400183 	ldbu	r5,6(r2)
 2037428:	280a943a 	slli	r5,r5,16
 203742c:	2908b03a 	or	r4,r5,r4
 2037430:	108001c3 	ldbu	r2,7(r2)
 2037434:	1004963a 	slli	r2,r2,24
 2037438:	1104b03a 	or	r2,r2,r4
 203743c:	1008d63a 	srli	r4,r2,24
 2037440:	e0bffe17 	ldw	r2,-8(fp)
 2037444:	10801c17 	ldw	r2,112(r2)
 2037448:	10800417 	ldw	r2,16(r2)
 203744c:	11400103 	ldbu	r5,4(r2)
 2037450:	11800143 	ldbu	r6,5(r2)
 2037454:	300c923a 	slli	r6,r6,8
 2037458:	314ab03a 	or	r5,r6,r5
 203745c:	11800183 	ldbu	r6,6(r2)
 2037460:	300c943a 	slli	r6,r6,16
 2037464:	314ab03a 	or	r5,r6,r5
 2037468:	108001c3 	ldbu	r2,7(r2)
 203746c:	1004963a 	slli	r2,r2,24
 2037470:	1144b03a 	or	r2,r2,r5
 2037474:	1004d23a 	srli	r2,r2,8
 2037478:	10bfc00c 	andi	r2,r2,65280
 203747c:	2088b03a 	or	r4,r4,r2
 2037480:	e0bffe17 	ldw	r2,-8(fp)
 2037484:	10801c17 	ldw	r2,112(r2)
 2037488:	10800417 	ldw	r2,16(r2)
 203748c:	11400103 	ldbu	r5,4(r2)
 2037490:	11800143 	ldbu	r6,5(r2)
 2037494:	300c923a 	slli	r6,r6,8
 2037498:	314ab03a 	or	r5,r6,r5
 203749c:	11800183 	ldbu	r6,6(r2)
 20374a0:	300c943a 	slli	r6,r6,16
 20374a4:	314ab03a 	or	r5,r6,r5
 20374a8:	108001c3 	ldbu	r2,7(r2)
 20374ac:	1004963a 	slli	r2,r2,24
 20374b0:	1144b03a 	or	r2,r2,r5
 20374b4:	10bfc00c 	andi	r2,r2,65280
 20374b8:	1004923a 	slli	r2,r2,8
 20374bc:	2088b03a 	or	r4,r4,r2
 20374c0:	e0bffe17 	ldw	r2,-8(fp)
 20374c4:	10801c17 	ldw	r2,112(r2)
 20374c8:	10800417 	ldw	r2,16(r2)
 20374cc:	11400103 	ldbu	r5,4(r2)
 20374d0:	11800143 	ldbu	r6,5(r2)
 20374d4:	300c923a 	slli	r6,r6,8
 20374d8:	314ab03a 	or	r5,r6,r5
 20374dc:	11800183 	ldbu	r6,6(r2)
 20374e0:	300c943a 	slli	r6,r6,16
 20374e4:	314ab03a 	or	r5,r6,r5
 20374e8:	108001c3 	ldbu	r2,7(r2)
 20374ec:	1004963a 	slli	r2,r2,24
 20374f0:	1144b03a 	or	r2,r2,r5
 20374f4:	1004963a 	slli	r2,r2,24
 20374f8:	2088b03a 	or	r4,r4,r2
 20374fc:	e0bffe17 	ldw	r2,-8(fp)
 2037500:	10801c17 	ldw	r2,112(r2)
 2037504:	1080020b 	ldhu	r2,8(r2)
 2037508:	117fffcc 	andi	r5,r2,65535
 203750c:	e0bffe17 	ldw	r2,-8(fp)
 2037510:	10801c17 	ldw	r2,112(r2)
 2037514:	10800417 	ldw	r2,16(r2)
 2037518:	11800303 	ldbu	r6,12(r2)
 203751c:	10800343 	ldbu	r2,13(r2)
 2037520:	1004923a 	slli	r2,r2,8
 2037524:	1184b03a 	or	r2,r2,r6
 2037528:	10bfffcc 	andi	r2,r2,65535
 203752c:	1004d23a 	srli	r2,r2,8
 2037530:	11bfffcc 	andi	r6,r2,65535
 2037534:	e0bffe17 	ldw	r2,-8(fp)
 2037538:	10801c17 	ldw	r2,112(r2)
 203753c:	10800417 	ldw	r2,16(r2)
 2037540:	11c00303 	ldbu	r7,12(r2)
 2037544:	10800343 	ldbu	r2,13(r2)
 2037548:	1004923a 	slli	r2,r2,8
 203754c:	11c4b03a 	or	r2,r2,r7
 2037550:	10bfffcc 	andi	r2,r2,65535
 2037554:	1004923a 	slli	r2,r2,8
 2037558:	10bfffcc 	andi	r2,r2,65535
 203755c:	3084b03a 	or	r2,r6,r2
 2037560:	108000cc 	andi	r2,r2,3
 2037564:	1004c03a 	cmpne	r2,r2,zero
 2037568:	10803fcc 	andi	r2,r2,255
 203756c:	2885883a 	add	r2,r5,r2
 2037570:	2085883a 	add	r2,r4,r2
 2037574:	1885c83a 	sub	r2,r3,r2
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 2037578:	10000516 	blt	r2,zero,2037590 <tcp_receive+0x9c8>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 203757c:	d0e81c17 	ldw	r3,-24464(gp)
 2037580:	e0bffe17 	ldw	r2,-8(fp)
 2037584:	10801517 	ldw	r2,84(r2)
 2037588:	1885c83a 	sub	r2,r3,r2
 203758c:	00bf600e 	bge	zero,r2,2037310 <__alt_mem_mem_0+0xfd017310>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 2037590:	e0bffe17 	ldw	r2,-8(fp)
 2037594:	10800f17 	ldw	r2,60(r2)
 2037598:	10004126 	beq	r2,zero,20376a0 <tcp_receive+0xad8>
 203759c:	e0bffe17 	ldw	r2,-8(fp)
 20375a0:	10c01017 	ldw	r3,64(r2)
 20375a4:	d0a81c17 	ldw	r2,-24464(gp)
 20375a8:	1885c83a 	sub	r2,r3,r2
 20375ac:	10003c0e 	bge	r2,zero,20376a0 <tcp_receive+0xad8>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 20375b0:	d0a7f817 	ldw	r2,-24608(gp)
 20375b4:	1007883a 	mov	r3,r2
 20375b8:	e0bffe17 	ldw	r2,-8(fp)
 20375bc:	10800f17 	ldw	r2,60(r2)
 20375c0:	1885c83a 	sub	r2,r3,r2
 20375c4:	e0bff80d 	sth	r2,-32(fp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 20375c8:	e0bff80b 	ldhu	r2,-32(fp)
 20375cc:	e0fffe17 	ldw	r3,-8(fp)
 20375d0:	18c0110b 	ldhu	r3,68(r3)
 20375d4:	18ffffcc 	andi	r3,r3,65535
 20375d8:	18e0001c 	xori	r3,r3,32768
 20375dc:	18e00004 	addi	r3,r3,-32768
 20375e0:	1807d0fa 	srai	r3,r3,3
 20375e4:	10c5c83a 	sub	r2,r2,r3
 20375e8:	e0bff80d 	sth	r2,-32(fp)
      pcb->sa += m;
 20375ec:	e0bffe17 	ldw	r2,-8(fp)
 20375f0:	1080110b 	ldhu	r2,68(r2)
 20375f4:	1007883a 	mov	r3,r2
 20375f8:	e0bff80b 	ldhu	r2,-32(fp)
 20375fc:	1885883a 	add	r2,r3,r2
 2037600:	1007883a 	mov	r3,r2
 2037604:	e0bffe17 	ldw	r2,-8(fp)
 2037608:	10c0110d 	sth	r3,68(r2)
      if (m < 0) {
 203760c:	e0bff80f 	ldh	r2,-32(fp)
 2037610:	1000030e 	bge	r2,zero,2037620 <tcp_receive+0xa58>
        m = -m;
 2037614:	e0bff80b 	ldhu	r2,-32(fp)
 2037618:	0085c83a 	sub	r2,zero,r2
 203761c:	e0bff80d 	sth	r2,-32(fp)
      }
      m = m - (pcb->sv >> 2);
 2037620:	e0bff80b 	ldhu	r2,-32(fp)
 2037624:	e0fffe17 	ldw	r3,-8(fp)
 2037628:	18c0118b 	ldhu	r3,70(r3)
 203762c:	18ffffcc 	andi	r3,r3,65535
 2037630:	18e0001c 	xori	r3,r3,32768
 2037634:	18e00004 	addi	r3,r3,-32768
 2037638:	1807d0ba 	srai	r3,r3,2
 203763c:	10c5c83a 	sub	r2,r2,r3
 2037640:	e0bff80d 	sth	r2,-32(fp)
      pcb->sv += m;
 2037644:	e0bffe17 	ldw	r2,-8(fp)
 2037648:	1080118b 	ldhu	r2,70(r2)
 203764c:	1007883a 	mov	r3,r2
 2037650:	e0bff80b 	ldhu	r2,-32(fp)
 2037654:	1885883a 	add	r2,r3,r2
 2037658:	1007883a 	mov	r3,r2
 203765c:	e0bffe17 	ldw	r2,-8(fp)
 2037660:	10c0118d 	sth	r3,70(r2)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 2037664:	e0bffe17 	ldw	r2,-8(fp)
 2037668:	1080110b 	ldhu	r2,68(r2)
 203766c:	10bfffcc 	andi	r2,r2,65535
 2037670:	10a0001c 	xori	r2,r2,32768
 2037674:	10a00004 	addi	r2,r2,-32768
 2037678:	1005d0fa 	srai	r2,r2,3
 203767c:	1007883a 	mov	r3,r2
 2037680:	e0bffe17 	ldw	r2,-8(fp)
 2037684:	1080118b 	ldhu	r2,70(r2)
 2037688:	1885883a 	add	r2,r3,r2
 203768c:	1007883a 	mov	r3,r2
 2037690:	e0bffe17 	ldw	r2,-8(fp)
 2037694:	10c0120d 	sth	r3,72(r2)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 2037698:	e0bffe17 	ldw	r2,-8(fp)
 203769c:	10000f15 	stw	zero,60(r2)

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 20376a0:	d0a81d8b 	ldhu	r2,-24458(gp)
 20376a4:	10bfffcc 	andi	r2,r2,65535
 20376a8:	10052726 	beq	r2,zero,2038b48 <tcp_receive+0x1f80>
 20376ac:	e0bffe17 	ldw	r2,-8(fp)
 20376b0:	10800617 	ldw	r2,24(r2)
 20376b4:	108001e8 	cmpgeui	r2,r2,7
 20376b8:	1005231e 	bne	r2,zero,2038b48 <tcp_receive+0x1f80>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 20376bc:	e0bffe17 	ldw	r2,-8(fp)
 20376c0:	10c00b17 	ldw	r3,44(r2)
 20376c4:	d0a81b17 	ldw	r2,-24468(gp)
 20376c8:	1885c83a 	sub	r2,r3,r2
 20376cc:	10bfffc4 	addi	r2,r2,-1
 20376d0:	10007b16 	blt	r2,zero,20378c0 <tcp_receive+0xcf8>
 20376d4:	e0bffe17 	ldw	r2,-8(fp)
 20376d8:	10c00b17 	ldw	r3,44(r2)
 20376dc:	d0a81d8b 	ldhu	r2,-24458(gp)
 20376e0:	113fffcc 	andi	r4,r2,65535
 20376e4:	d0a81b17 	ldw	r2,-24468(gp)
 20376e8:	2085883a 	add	r2,r4,r2
 20376ec:	1885c83a 	sub	r2,r3,r2
 20376f0:	10800044 	addi	r2,r2,1
 20376f4:	00807216 	blt	zero,r2,20378c0 <tcp_receive+0xcf8>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 20376f8:	e0bffe17 	ldw	r2,-8(fp)
 20376fc:	10c00b17 	ldw	r3,44(r2)
 2037700:	d0a81b17 	ldw	r2,-24468(gp)
 2037704:	1885c83a 	sub	r2,r3,r2
 2037708:	e0bff715 	stw	r2,-36(fp)
      p = inseg.p;
 203770c:	008085b4 	movhi	r2,534
 2037710:	10888b04 	addi	r2,r2,8748
 2037714:	10800117 	ldw	r2,4(r2)
 2037718:	e0bff615 	stw	r2,-40(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
 203771c:	008085b4 	movhi	r2,534
 2037720:	10888b04 	addi	r2,r2,8748
 2037724:	10800117 	ldw	r2,4(r2)
 2037728:	1080028b 	ldhu	r2,10(r2)
 203772c:	10ffffcc 	andi	r3,r2,65535
 2037730:	e0bff717 	ldw	r2,-36(fp)
 2037734:	1880240e 	bge	r3,r2,20377c8 <tcp_receive+0xc00>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 2037738:	008085b4 	movhi	r2,534
 203773c:	10888b04 	addi	r2,r2,8748
 2037740:	10800117 	ldw	r2,4(r2)
 2037744:	1080020b 	ldhu	r2,8(r2)
 2037748:	e0fff717 	ldw	r3,-36(fp)
 203774c:	10c5c83a 	sub	r2,r2,r3
 2037750:	e0bffb8d 	sth	r2,-18(fp)
        while (p->len < off) {
 2037754:	00000e06 	br	2037790 <tcp_receive+0xbc8>
          off -= p->len;
 2037758:	e0bff617 	ldw	r2,-40(fp)
 203775c:	1080028b 	ldhu	r2,10(r2)
 2037760:	10bfffcc 	andi	r2,r2,65535
 2037764:	e0fff717 	ldw	r3,-36(fp)
 2037768:	1885c83a 	sub	r2,r3,r2
 203776c:	e0bff715 	stw	r2,-36(fp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 2037770:	e0bff617 	ldw	r2,-40(fp)
 2037774:	e0fffb8b 	ldhu	r3,-18(fp)
 2037778:	10c0020d 	sth	r3,8(r2)
          p->len = 0;
 203777c:	e0bff617 	ldw	r2,-40(fp)
 2037780:	1000028d 	sth	zero,10(r2)
          p = p->next;
 2037784:	e0bff617 	ldw	r2,-40(fp)
 2037788:	10800017 	ldw	r2,0(r2)
 203778c:	e0bff615 	stw	r2,-40(fp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 2037790:	e0bff617 	ldw	r2,-40(fp)
 2037794:	1080028b 	ldhu	r2,10(r2)
 2037798:	10ffffcc 	andi	r3,r2,65535
 203779c:	e0bff717 	ldw	r2,-36(fp)
 20377a0:	18bfed16 	blt	r3,r2,2037758 <__alt_mem_mem_0+0xfd017758>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 20377a4:	e0bff717 	ldw	r2,-36(fp)
 20377a8:	0085c83a 	sub	r2,zero,r2
 20377ac:	10bfffcc 	andi	r2,r2,65535
 20377b0:	10a0001c 	xori	r2,r2,32768
 20377b4:	10a00004 	addi	r2,r2,-32768
 20377b8:	100b883a 	mov	r5,r2
 20377bc:	e13ff617 	ldw	r4,-40(fp)
 20377c0:	201a9b80 	call	201a9b8 <pbuf_header>
 20377c4:	00000b06 	br	20377f4 <tcp_receive+0xc2c>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 20377c8:	008085b4 	movhi	r2,534
 20377cc:	10888b04 	addi	r2,r2,8748
 20377d0:	10800117 	ldw	r2,4(r2)
 20377d4:	e0fff717 	ldw	r3,-36(fp)
 20377d8:	00c7c83a 	sub	r3,zero,r3
 20377dc:	18ffffcc 	andi	r3,r3,65535
 20377e0:	18e0001c 	xori	r3,r3,32768
 20377e4:	18e00004 	addi	r3,r3,-32768
 20377e8:	180b883a 	mov	r5,r3
 20377ec:	1009883a 	mov	r4,r2
 20377f0:	201a9b80 	call	201a9b8 <pbuf_header>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 20377f4:	008085b4 	movhi	r2,534
 20377f8:	10888b04 	addi	r2,r2,8748
 20377fc:	1080020b 	ldhu	r2,8(r2)
 2037800:	d0e81b17 	ldw	r3,-24468(gp)
 2037804:	1809883a 	mov	r4,r3
 2037808:	e0fffe17 	ldw	r3,-8(fp)
 203780c:	18c00b17 	ldw	r3,44(r3)
 2037810:	20c7c83a 	sub	r3,r4,r3
 2037814:	10c5883a 	add	r2,r2,r3
 2037818:	1007883a 	mov	r3,r2
 203781c:	008085b4 	movhi	r2,534
 2037820:	10888b04 	addi	r2,r2,8748
 2037824:	10c0020d 	sth	r3,8(r2)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 2037828:	008085b4 	movhi	r2,534
 203782c:	10888b04 	addi	r2,r2,8748
 2037830:	10800417 	ldw	r2,16(r2)
 2037834:	e0fffe17 	ldw	r3,-8(fp)
 2037838:	18c00b17 	ldw	r3,44(r3)
 203783c:	d0e81b15 	stw	r3,-24468(gp)
 2037840:	d0e81b17 	ldw	r3,-24468(gp)
 2037844:	19803fcc 	andi	r6,r3,255
 2037848:	11000103 	ldbu	r4,4(r2)
 203784c:	2008703a 	and	r4,r4,zero
 2037850:	200b883a 	mov	r5,r4
 2037854:	3009883a 	mov	r4,r6
 2037858:	2908b03a 	or	r4,r5,r4
 203785c:	11000105 	stb	r4,4(r2)
 2037860:	1808d23a 	srli	r4,r3,8
 2037864:	21803fcc 	andi	r6,r4,255
 2037868:	11000143 	ldbu	r4,5(r2)
 203786c:	2008703a 	and	r4,r4,zero
 2037870:	200b883a 	mov	r5,r4
 2037874:	3009883a 	mov	r4,r6
 2037878:	2908b03a 	or	r4,r5,r4
 203787c:	11000145 	stb	r4,5(r2)
 2037880:	1808d43a 	srli	r4,r3,16
 2037884:	21803fcc 	andi	r6,r4,255
 2037888:	11000183 	ldbu	r4,6(r2)
 203788c:	2008703a 	and	r4,r4,zero
 2037890:	200b883a 	mov	r5,r4
 2037894:	3009883a 	mov	r4,r6
 2037898:	2908b03a 	or	r4,r5,r4
 203789c:	11000185 	stb	r4,6(r2)
 20378a0:	180ad63a 	srli	r5,r3,24
 20378a4:	10c001c3 	ldbu	r3,7(r2)
 20378a8:	1806703a 	and	r3,r3,zero
 20378ac:	1809883a 	mov	r4,r3
 20378b0:	2807883a 	mov	r3,r5
 20378b4:	20c6b03a 	or	r3,r4,r3
 20378b8:	10c001c5 	stb	r3,7(r2)
 20378bc:	00000b06 	br	20378ec <tcp_receive+0xd24>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 20378c0:	d0e81b17 	ldw	r3,-24468(gp)
 20378c4:	e0bffe17 	ldw	r2,-8(fp)
 20378c8:	10800b17 	ldw	r2,44(r2)
 20378cc:	1885c83a 	sub	r2,r3,r2
 20378d0:	1000060e 	bge	r2,zero,20378ec <tcp_receive+0xd24>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 20378d4:	e0bffe17 	ldw	r2,-8(fp)
 20378d8:	10800883 	ldbu	r2,34(r2)
 20378dc:	10800094 	ori	r2,r2,2
 20378e0:	1007883a 	mov	r3,r2
 20378e4:	e0bffe17 	ldw	r2,-8(fp)
 20378e8:	10c00885 	stb	r3,34(r2)
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 20378ec:	d0e81b17 	ldw	r3,-24468(gp)
 20378f0:	e0bffe17 	ldw	r2,-8(fp)
 20378f4:	10800b17 	ldw	r2,44(r2)
 20378f8:	1885c83a 	sub	r2,r3,r2
 20378fc:	10048e16 	blt	r2,zero,2038b38 <tcp_receive+0x1f70>
 2037900:	d0e81b17 	ldw	r3,-24468(gp)
 2037904:	e0bffe17 	ldw	r2,-8(fp)
 2037908:	11000b17 	ldw	r4,44(r2)
 203790c:	e0bffe17 	ldw	r2,-8(fp)
 2037910:	10800c0b 	ldhu	r2,48(r2)
 2037914:	10bfffcc 	andi	r2,r2,65535
 2037918:	2085883a 	add	r2,r4,r2
 203791c:	1885c83a 	sub	r2,r3,r2
 2037920:	10800044 	addi	r2,r2,1
 2037924:	00848416 	blt	zero,r2,2038b38 <tcp_receive+0x1f70>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 2037928:	e0bffe17 	ldw	r2,-8(fp)
 203792c:	10c00b17 	ldw	r3,44(r2)
 2037930:	d0a81b17 	ldw	r2,-24468(gp)
 2037934:	1882cd1e 	bne	r3,r2,203846c <tcp_receive+0x18a4>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 2037938:	008085b4 	movhi	r2,534
 203793c:	10888b04 	addi	r2,r2,8748
 2037940:	10c0020b 	ldhu	r3,8(r2)
 2037944:	008085b4 	movhi	r2,534
 2037948:	10888b04 	addi	r2,r2,8748
 203794c:	10800417 	ldw	r2,16(r2)
 2037950:	11000303 	ldbu	r4,12(r2)
 2037954:	10800343 	ldbu	r2,13(r2)
 2037958:	1004923a 	slli	r2,r2,8
 203795c:	1104b03a 	or	r2,r2,r4
 2037960:	10bfffcc 	andi	r2,r2,65535
 2037964:	1004d23a 	srli	r2,r2,8
 2037968:	113fffcc 	andi	r4,r2,65535
 203796c:	008085b4 	movhi	r2,534
 2037970:	10888b04 	addi	r2,r2,8748
 2037974:	10800417 	ldw	r2,16(r2)
 2037978:	11400303 	ldbu	r5,12(r2)
 203797c:	10800343 	ldbu	r2,13(r2)
 2037980:	1004923a 	slli	r2,r2,8
 2037984:	1144b03a 	or	r2,r2,r5
 2037988:	10bfffcc 	andi	r2,r2,65535
 203798c:	1004923a 	slli	r2,r2,8
 2037990:	10bfffcc 	andi	r2,r2,65535
 2037994:	2084b03a 	or	r2,r4,r2
 2037998:	108000cc 	andi	r2,r2,3
 203799c:	1004c03a 	cmpne	r2,r2,zero
 20379a0:	10803fcc 	andi	r2,r2,255
 20379a4:	1885883a 	add	r2,r3,r2
 20379a8:	d0a81d8d 	sth	r2,-24458(gp)

        if (tcplen > pcb->rcv_wnd) {
 20379ac:	e0bffe17 	ldw	r2,-8(fp)
 20379b0:	10c00c0b 	ldhu	r3,48(r2)
 20379b4:	d0a81d8b 	ldhu	r2,-24458(gp)
 20379b8:	18ffffcc 	andi	r3,r3,65535
 20379bc:	10bfffcc 	andi	r2,r2,65535
 20379c0:	1880992e 	bgeu	r3,r2,2037c28 <tcp_receive+0x1060>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 20379c4:	008085b4 	movhi	r2,534
 20379c8:	10888b04 	addi	r2,r2,8748
 20379cc:	10800417 	ldw	r2,16(r2)
 20379d0:	10c00303 	ldbu	r3,12(r2)
 20379d4:	10800343 	ldbu	r2,13(r2)
 20379d8:	1004923a 	slli	r2,r2,8
 20379dc:	10c4b03a 	or	r2,r2,r3
 20379e0:	10bfffcc 	andi	r2,r2,65535
 20379e4:	1004d23a 	srli	r2,r2,8
 20379e8:	10ffffcc 	andi	r3,r2,65535
 20379ec:	008085b4 	movhi	r2,534
 20379f0:	10888b04 	addi	r2,r2,8748
 20379f4:	10800417 	ldw	r2,16(r2)
 20379f8:	11000303 	ldbu	r4,12(r2)
 20379fc:	10800343 	ldbu	r2,13(r2)
 2037a00:	1004923a 	slli	r2,r2,8
 2037a04:	1104b03a 	or	r2,r2,r4
 2037a08:	10bfffcc 	andi	r2,r2,65535
 2037a0c:	1004923a 	slli	r2,r2,8
 2037a10:	10bfffcc 	andi	r2,r2,65535
 2037a14:	1884b03a 	or	r2,r3,r2
 2037a18:	1080004c 	andi	r2,r2,1
 2037a1c:	10003726 	beq	r2,zero,2037afc <tcp_receive+0xf34>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 2037a20:	008085b4 	movhi	r2,534
 2037a24:	10888b04 	addi	r2,r2,8748
 2037a28:	10800417 	ldw	r2,16(r2)
 2037a2c:	00c085b4 	movhi	r3,534
 2037a30:	18c88b04 	addi	r3,r3,8748
 2037a34:	18c00417 	ldw	r3,16(r3)
 2037a38:	19000303 	ldbu	r4,12(r3)
 2037a3c:	18c00343 	ldbu	r3,13(r3)
 2037a40:	1806923a 	slli	r3,r3,8
 2037a44:	1906b03a 	or	r3,r3,r4
 2037a48:	1809883a 	mov	r4,r3
 2037a4c:	00f03fc4 	movi	r3,-16129
 2037a50:	20c6703a 	and	r3,r4,r3
 2037a54:	180b883a 	mov	r5,r3
 2037a58:	00c085b4 	movhi	r3,534
 2037a5c:	18c88b04 	addi	r3,r3,8748
 2037a60:	18c00417 	ldw	r3,16(r3)
 2037a64:	19000303 	ldbu	r4,12(r3)
 2037a68:	18c00343 	ldbu	r3,13(r3)
 2037a6c:	1806923a 	slli	r3,r3,8
 2037a70:	1906b03a 	or	r3,r3,r4
 2037a74:	18ffffcc 	andi	r3,r3,65535
 2037a78:	1806d23a 	srli	r3,r3,8
 2037a7c:	180d883a 	mov	r6,r3
 2037a80:	00c085b4 	movhi	r3,534
 2037a84:	18c88b04 	addi	r3,r3,8748
 2037a88:	18c00417 	ldw	r3,16(r3)
 2037a8c:	19000303 	ldbu	r4,12(r3)
 2037a90:	18c00343 	ldbu	r3,13(r3)
 2037a94:	1806923a 	slli	r3,r3,8
 2037a98:	1906b03a 	or	r3,r3,r4
 2037a9c:	18ffffcc 	andi	r3,r3,65535
 2037aa0:	1806923a 	slli	r3,r3,8
 2037aa4:	30c6b03a 	or	r3,r6,r3
 2037aa8:	18c00f8c 	andi	r3,r3,62
 2037aac:	1806923a 	slli	r3,r3,8
 2037ab0:	28c6b03a 	or	r3,r5,r3
 2037ab4:	180d883a 	mov	r6,r3
 2037ab8:	30ffffcc 	andi	r3,r6,65535
 2037abc:	19403fcc 	andi	r5,r3,255
 2037ac0:	10c00303 	ldbu	r3,12(r2)
 2037ac4:	1806703a 	and	r3,r3,zero
 2037ac8:	1809883a 	mov	r4,r3
 2037acc:	2807883a 	mov	r3,r5
 2037ad0:	20c6b03a 	or	r3,r4,r3
 2037ad4:	10c00305 	stb	r3,12(r2)
 2037ad8:	30ffffcc 	andi	r3,r6,65535
 2037adc:	1806d23a 	srli	r3,r3,8
 2037ae0:	197fffcc 	andi	r5,r3,65535
 2037ae4:	10c00343 	ldbu	r3,13(r2)
 2037ae8:	1806703a 	and	r3,r3,zero
 2037aec:	1809883a 	mov	r4,r3
 2037af0:	2807883a 	mov	r3,r5
 2037af4:	20c6b03a 	or	r3,r4,r3
 2037af8:	10c00345 	stb	r3,13(r2)
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 2037afc:	e0bffe17 	ldw	r2,-8(fp)
 2037b00:	10c00c0b 	ldhu	r3,48(r2)
 2037b04:	008085b4 	movhi	r2,534
 2037b08:	10888b04 	addi	r2,r2,8748
 2037b0c:	10c0020d 	sth	r3,8(r2)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 2037b10:	008085b4 	movhi	r2,534
 2037b14:	10888b04 	addi	r2,r2,8748
 2037b18:	10800417 	ldw	r2,16(r2)
 2037b1c:	10c00303 	ldbu	r3,12(r2)
 2037b20:	10800343 	ldbu	r2,13(r2)
 2037b24:	1004923a 	slli	r2,r2,8
 2037b28:	10c4b03a 	or	r2,r2,r3
 2037b2c:	10bfffcc 	andi	r2,r2,65535
 2037b30:	1004d23a 	srli	r2,r2,8
 2037b34:	10ffffcc 	andi	r3,r2,65535
 2037b38:	008085b4 	movhi	r2,534
 2037b3c:	10888b04 	addi	r2,r2,8748
 2037b40:	10800417 	ldw	r2,16(r2)
 2037b44:	11000303 	ldbu	r4,12(r2)
 2037b48:	10800343 	ldbu	r2,13(r2)
 2037b4c:	1004923a 	slli	r2,r2,8
 2037b50:	1104b03a 	or	r2,r2,r4
 2037b54:	10bfffcc 	andi	r2,r2,65535
 2037b58:	1004923a 	slli	r2,r2,8
 2037b5c:	10bfffcc 	andi	r2,r2,65535
 2037b60:	1884b03a 	or	r2,r3,r2
 2037b64:	1080008c 	andi	r2,r2,2
 2037b68:	10000826 	beq	r2,zero,2037b8c <tcp_receive+0xfc4>
            inseg.len -= 1;
 2037b6c:	008085b4 	movhi	r2,534
 2037b70:	10888b04 	addi	r2,r2,8748
 2037b74:	1080020b 	ldhu	r2,8(r2)
 2037b78:	10bfffc4 	addi	r2,r2,-1
 2037b7c:	1007883a 	mov	r3,r2
 2037b80:	008085b4 	movhi	r2,534
 2037b84:	10888b04 	addi	r2,r2,8748
 2037b88:	10c0020d 	sth	r3,8(r2)
          }
          pbuf_realloc(inseg.p, inseg.len);
 2037b8c:	008085b4 	movhi	r2,534
 2037b90:	10888b04 	addi	r2,r2,8748
 2037b94:	10c00117 	ldw	r3,4(r2)
 2037b98:	008085b4 	movhi	r2,534
 2037b9c:	10888b04 	addi	r2,r2,8748
 2037ba0:	1080020b 	ldhu	r2,8(r2)
 2037ba4:	10bfffcc 	andi	r2,r2,65535
 2037ba8:	100b883a 	mov	r5,r2
 2037bac:	1809883a 	mov	r4,r3
 2037bb0:	201a8580 	call	201a858 <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 2037bb4:	008085b4 	movhi	r2,534
 2037bb8:	10888b04 	addi	r2,r2,8748
 2037bbc:	10c0020b 	ldhu	r3,8(r2)
 2037bc0:	008085b4 	movhi	r2,534
 2037bc4:	10888b04 	addi	r2,r2,8748
 2037bc8:	10800417 	ldw	r2,16(r2)
 2037bcc:	11000303 	ldbu	r4,12(r2)
 2037bd0:	10800343 	ldbu	r2,13(r2)
 2037bd4:	1004923a 	slli	r2,r2,8
 2037bd8:	1104b03a 	or	r2,r2,r4
 2037bdc:	10bfffcc 	andi	r2,r2,65535
 2037be0:	1004d23a 	srli	r2,r2,8
 2037be4:	113fffcc 	andi	r4,r2,65535
 2037be8:	008085b4 	movhi	r2,534
 2037bec:	10888b04 	addi	r2,r2,8748
 2037bf0:	10800417 	ldw	r2,16(r2)
 2037bf4:	11400303 	ldbu	r5,12(r2)
 2037bf8:	10800343 	ldbu	r2,13(r2)
 2037bfc:	1004923a 	slli	r2,r2,8
 2037c00:	1144b03a 	or	r2,r2,r5
 2037c04:	10bfffcc 	andi	r2,r2,65535
 2037c08:	1004923a 	slli	r2,r2,8
 2037c0c:	10bfffcc 	andi	r2,r2,65535
 2037c10:	2084b03a 	or	r2,r4,r2
 2037c14:	108000cc 	andi	r2,r2,3
 2037c18:	1004c03a 	cmpne	r2,r2,zero
 2037c1c:	10803fcc 	andi	r2,r2,255
 2037c20:	1885883a 	add	r2,r3,r2
 2037c24:	d0a81d8d 	sth	r2,-24458(gp)
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
 2037c28:	e0bffe17 	ldw	r2,-8(fp)
 2037c2c:	10801e17 	ldw	r2,120(r2)
 2037c30:	10012026 	beq	r2,zero,20380b4 <tcp_receive+0x14ec>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 2037c34:	008085b4 	movhi	r2,534
 2037c38:	10888b04 	addi	r2,r2,8748
 2037c3c:	10800417 	ldw	r2,16(r2)
 2037c40:	10c00303 	ldbu	r3,12(r2)
 2037c44:	10800343 	ldbu	r2,13(r2)
 2037c48:	1004923a 	slli	r2,r2,8
 2037c4c:	10c4b03a 	or	r2,r2,r3
 2037c50:	10bfffcc 	andi	r2,r2,65535
 2037c54:	1004d23a 	srli	r2,r2,8
 2037c58:	10ffffcc 	andi	r3,r2,65535
 2037c5c:	008085b4 	movhi	r2,534
 2037c60:	10888b04 	addi	r2,r2,8748
 2037c64:	10800417 	ldw	r2,16(r2)
 2037c68:	11000303 	ldbu	r4,12(r2)
 2037c6c:	10800343 	ldbu	r2,13(r2)
 2037c70:	1004923a 	slli	r2,r2,8
 2037c74:	1104b03a 	or	r2,r2,r4
 2037c78:	10bfffcc 	andi	r2,r2,65535
 2037c7c:	1004923a 	slli	r2,r2,8
 2037c80:	10bfffcc 	andi	r2,r2,65535
 2037c84:	1884b03a 	or	r2,r3,r2
 2037c88:	1080004c 	andi	r2,r2,1
 2037c8c:	10000f26 	beq	r2,zero,2037ccc <tcp_receive+0x1104>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 2037c90:	00000a06 	br	2037cbc <tcp_receive+0x10f4>
              struct tcp_seg *old_ooseq = pcb->ooseq;
 2037c94:	e0bffe17 	ldw	r2,-8(fp)
 2037c98:	10801e17 	ldw	r2,120(r2)
 2037c9c:	e0bffc15 	stw	r2,-16(fp)
              pcb->ooseq = pcb->ooseq->next;
 2037ca0:	e0bffe17 	ldw	r2,-8(fp)
 2037ca4:	10801e17 	ldw	r2,120(r2)
 2037ca8:	10c00017 	ldw	r3,0(r2)
 2037cac:	e0bffe17 	ldw	r2,-8(fp)
 2037cb0:	10c01e15 	stw	r3,120(r2)
              tcp_seg_free(old_ooseq);
 2037cb4:	e13ffc17 	ldw	r4,-16(fp)
 2037cb8:	201d4300 	call	201d430 <tcp_seg_free>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
 2037cbc:	e0bffe17 	ldw	r2,-8(fp)
 2037cc0:	10801e17 	ldw	r2,120(r2)
 2037cc4:	103ff31e 	bne	r2,zero,2037c94 <__alt_mem_mem_0+0xfd017c94>
 2037cc8:	0000fa06 	br	20380b4 <tcp_receive+0x14ec>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
 2037ccc:	e0bffe17 	ldw	r2,-8(fp)
 2037cd0:	10801e17 	ldw	r2,120(r2)
 2037cd4:	e0bff415 	stw	r2,-48(fp)
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2037cd8:	00006d06 	br	2037e90 <tcp_receive+0x12c8>
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 2037cdc:	e0bff417 	ldw	r2,-48(fp)
 2037ce0:	10800417 	ldw	r2,16(r2)
 2037ce4:	10c00303 	ldbu	r3,12(r2)
 2037ce8:	10800343 	ldbu	r2,13(r2)
 2037cec:	1004923a 	slli	r2,r2,8
 2037cf0:	10c4b03a 	or	r2,r2,r3
 2037cf4:	10bfffcc 	andi	r2,r2,65535
 2037cf8:	1004d23a 	srli	r2,r2,8
 2037cfc:	10ffffcc 	andi	r3,r2,65535
 2037d00:	e0bff417 	ldw	r2,-48(fp)
 2037d04:	10800417 	ldw	r2,16(r2)
 2037d08:	11000303 	ldbu	r4,12(r2)
 2037d0c:	10800343 	ldbu	r2,13(r2)
 2037d10:	1004923a 	slli	r2,r2,8
 2037d14:	1104b03a 	or	r2,r2,r4
 2037d18:	10bfffcc 	andi	r2,r2,65535
 2037d1c:	1004923a 	slli	r2,r2,8
 2037d20:	10bfffcc 	andi	r2,r2,65535
 2037d24:	1884b03a 	or	r2,r3,r2
 2037d28:	1080004c 	andi	r2,r2,1
 2037d2c:	10005126 	beq	r2,zero,2037e74 <tcp_receive+0x12ac>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
 2037d30:	008085b4 	movhi	r2,534
 2037d34:	10888b04 	addi	r2,r2,8748
 2037d38:	10800417 	ldw	r2,16(r2)
 2037d3c:	10c00303 	ldbu	r3,12(r2)
 2037d40:	10800343 	ldbu	r2,13(r2)
 2037d44:	1004923a 	slli	r2,r2,8
 2037d48:	10c4b03a 	or	r2,r2,r3
 2037d4c:	10bfffcc 	andi	r2,r2,65535
 2037d50:	1004d23a 	srli	r2,r2,8
 2037d54:	10ffffcc 	andi	r3,r2,65535
 2037d58:	008085b4 	movhi	r2,534
 2037d5c:	10888b04 	addi	r2,r2,8748
 2037d60:	10800417 	ldw	r2,16(r2)
 2037d64:	11000303 	ldbu	r4,12(r2)
 2037d68:	10800343 	ldbu	r2,13(r2)
 2037d6c:	1004923a 	slli	r2,r2,8
 2037d70:	1104b03a 	or	r2,r2,r4
 2037d74:	10bfffcc 	andi	r2,r2,65535
 2037d78:	1004923a 	slli	r2,r2,8
 2037d7c:	10bfffcc 	andi	r2,r2,65535
 2037d80:	1884b03a 	or	r2,r3,r2
 2037d84:	1080008c 	andi	r2,r2,2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
 2037d88:	10003a1e 	bne	r2,zero,2037e74 <tcp_receive+0x12ac>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
 2037d8c:	008085b4 	movhi	r2,534
 2037d90:	10888b04 	addi	r2,r2,8748
 2037d94:	10800417 	ldw	r2,16(r2)
 2037d98:	00c085b4 	movhi	r3,534
 2037d9c:	18c88b04 	addi	r3,r3,8748
 2037da0:	18c00417 	ldw	r3,16(r3)
 2037da4:	19000303 	ldbu	r4,12(r3)
 2037da8:	18c00343 	ldbu	r3,13(r3)
 2037dac:	1806923a 	slli	r3,r3,8
 2037db0:	1906b03a 	or	r3,r3,r4
 2037db4:	18c04014 	ori	r3,r3,256
 2037db8:	180d883a 	mov	r6,r3
 2037dbc:	30ffffcc 	andi	r3,r6,65535
 2037dc0:	19403fcc 	andi	r5,r3,255
 2037dc4:	10c00303 	ldbu	r3,12(r2)
 2037dc8:	1806703a 	and	r3,r3,zero
 2037dcc:	1809883a 	mov	r4,r3
 2037dd0:	2807883a 	mov	r3,r5
 2037dd4:	20c6b03a 	or	r3,r4,r3
 2037dd8:	10c00305 	stb	r3,12(r2)
 2037ddc:	30ffffcc 	andi	r3,r6,65535
 2037de0:	1806d23a 	srli	r3,r3,8
 2037de4:	197fffcc 	andi	r5,r3,65535
 2037de8:	10c00343 	ldbu	r3,13(r2)
 2037dec:	1806703a 	and	r3,r3,zero
 2037df0:	1809883a 	mov	r4,r3
 2037df4:	2807883a 	mov	r3,r5
 2037df8:	20c6b03a 	or	r3,r4,r3
 2037dfc:	10c00345 	stb	r3,13(r2)
                tcplen = TCP_TCPLEN(&inseg);
 2037e00:	008085b4 	movhi	r2,534
 2037e04:	10888b04 	addi	r2,r2,8748
 2037e08:	10c0020b 	ldhu	r3,8(r2)
 2037e0c:	008085b4 	movhi	r2,534
 2037e10:	10888b04 	addi	r2,r2,8748
 2037e14:	10800417 	ldw	r2,16(r2)
 2037e18:	11000303 	ldbu	r4,12(r2)
 2037e1c:	10800343 	ldbu	r2,13(r2)
 2037e20:	1004923a 	slli	r2,r2,8
 2037e24:	1104b03a 	or	r2,r2,r4
 2037e28:	10bfffcc 	andi	r2,r2,65535
 2037e2c:	1004d23a 	srli	r2,r2,8
 2037e30:	113fffcc 	andi	r4,r2,65535
 2037e34:	008085b4 	movhi	r2,534
 2037e38:	10888b04 	addi	r2,r2,8748
 2037e3c:	10800417 	ldw	r2,16(r2)
 2037e40:	11400303 	ldbu	r5,12(r2)
 2037e44:	10800343 	ldbu	r2,13(r2)
 2037e48:	1004923a 	slli	r2,r2,8
 2037e4c:	1144b03a 	or	r2,r2,r5
 2037e50:	10bfffcc 	andi	r2,r2,65535
 2037e54:	1004923a 	slli	r2,r2,8
 2037e58:	10bfffcc 	andi	r2,r2,65535
 2037e5c:	2084b03a 	or	r2,r4,r2
 2037e60:	108000cc 	andi	r2,r2,3
 2037e64:	1004c03a 	cmpne	r2,r2,zero
 2037e68:	10803fcc 	andi	r2,r2,255
 2037e6c:	1885883a 	add	r2,r3,r2
 2037e70:	d0a81d8d 	sth	r2,-24458(gp)
              }
              prev = next;
 2037e74:	e0bff417 	ldw	r2,-48(fp)
 2037e78:	e0bff515 	stw	r2,-44(fp)
              next = next->next;
 2037e7c:	e0bff417 	ldw	r2,-48(fp)
 2037e80:	10800017 	ldw	r2,0(r2)
 2037e84:	e0bff415 	stw	r2,-48(fp)
              tcp_seg_free(prev);
 2037e88:	e13ff517 	ldw	r4,-44(fp)
 2037e8c:	201d4300 	call	201d430 <tcp_seg_free>
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2037e90:	e0bff417 	ldw	r2,-48(fp)
 2037e94:	10001726 	beq	r2,zero,2037ef4 <tcp_receive+0x132c>
                   TCP_SEQ_GEQ(seqno + tcplen,
 2037e98:	d0a81d8b 	ldhu	r2,-24458(gp)
 2037e9c:	10ffffcc 	andi	r3,r2,65535
 2037ea0:	d0a81b17 	ldw	r2,-24468(gp)
 2037ea4:	1887883a 	add	r3,r3,r2
 2037ea8:	e0bff417 	ldw	r2,-48(fp)
 2037eac:	10800417 	ldw	r2,16(r2)
 2037eb0:	11000103 	ldbu	r4,4(r2)
 2037eb4:	11400143 	ldbu	r5,5(r2)
 2037eb8:	280a923a 	slli	r5,r5,8
 2037ebc:	2908b03a 	or	r4,r5,r4
 2037ec0:	11400183 	ldbu	r5,6(r2)
 2037ec4:	280a943a 	slli	r5,r5,16
 2037ec8:	2908b03a 	or	r4,r5,r4
 2037ecc:	108001c3 	ldbu	r2,7(r2)
 2037ed0:	1004963a 	slli	r2,r2,24
 2037ed4:	1104b03a 	or	r2,r2,r4
 2037ed8:	1009883a 	mov	r4,r2
 2037edc:	e0bff417 	ldw	r2,-48(fp)
 2037ee0:	1080020b 	ldhu	r2,8(r2)
 2037ee4:	10bfffcc 	andi	r2,r2,65535
 2037ee8:	2085883a 	add	r2,r4,r2
 2037eec:	1885c83a 	sub	r2,r3,r2
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
 2037ef0:	103f7a0e 	bge	r2,zero,2037cdc <__alt_mem_mem_0+0xfd017cdc>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 2037ef4:	e0bff417 	ldw	r2,-48(fp)
 2037ef8:	10006b26 	beq	r2,zero,20380a8 <tcp_receive+0x14e0>
                TCP_SEQ_GT(seqno + tcplen,
 2037efc:	d0a81d8b 	ldhu	r2,-24458(gp)
 2037f00:	10ffffcc 	andi	r3,r2,65535
 2037f04:	d0a81b17 	ldw	r2,-24468(gp)
 2037f08:	1887883a 	add	r3,r3,r2
 2037f0c:	e0bff417 	ldw	r2,-48(fp)
 2037f10:	10800417 	ldw	r2,16(r2)
 2037f14:	11000103 	ldbu	r4,4(r2)
 2037f18:	11400143 	ldbu	r5,5(r2)
 2037f1c:	280a923a 	slli	r5,r5,8
 2037f20:	2908b03a 	or	r4,r5,r4
 2037f24:	11400183 	ldbu	r5,6(r2)
 2037f28:	280a943a 	slli	r5,r5,16
 2037f2c:	2908b03a 	or	r4,r5,r4
 2037f30:	108001c3 	ldbu	r2,7(r2)
 2037f34:	1004963a 	slli	r2,r2,24
 2037f38:	1104b03a 	or	r2,r2,r4
 2037f3c:	1885c83a 	sub	r2,r3,r2
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
 2037f40:	0080590e 	bge	zero,r2,20380a8 <tcp_receive+0x14e0>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
 2037f44:	e0bff417 	ldw	r2,-48(fp)
 2037f48:	10800417 	ldw	r2,16(r2)
 2037f4c:	10c00103 	ldbu	r3,4(r2)
 2037f50:	11000143 	ldbu	r4,5(r2)
 2037f54:	2008923a 	slli	r4,r4,8
 2037f58:	20c6b03a 	or	r3,r4,r3
 2037f5c:	11000183 	ldbu	r4,6(r2)
 2037f60:	2008943a 	slli	r4,r4,16
 2037f64:	20c6b03a 	or	r3,r4,r3
 2037f68:	108001c3 	ldbu	r2,7(r2)
 2037f6c:	1004963a 	slli	r2,r2,24
 2037f70:	10c4b03a 	or	r2,r2,r3
 2037f74:	1007883a 	mov	r3,r2
 2037f78:	d0a81b17 	ldw	r2,-24468(gp)
 2037f7c:	1885c83a 	sub	r2,r3,r2
 2037f80:	1007883a 	mov	r3,r2
 2037f84:	008085b4 	movhi	r2,534
 2037f88:	10888b04 	addi	r2,r2,8748
 2037f8c:	10c0020d 	sth	r3,8(r2)
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 2037f90:	008085b4 	movhi	r2,534
 2037f94:	10888b04 	addi	r2,r2,8748
 2037f98:	10800417 	ldw	r2,16(r2)
 2037f9c:	10c00303 	ldbu	r3,12(r2)
 2037fa0:	10800343 	ldbu	r2,13(r2)
 2037fa4:	1004923a 	slli	r2,r2,8
 2037fa8:	10c4b03a 	or	r2,r2,r3
 2037fac:	10bfffcc 	andi	r2,r2,65535
 2037fb0:	1004d23a 	srli	r2,r2,8
 2037fb4:	10ffffcc 	andi	r3,r2,65535
 2037fb8:	008085b4 	movhi	r2,534
 2037fbc:	10888b04 	addi	r2,r2,8748
 2037fc0:	10800417 	ldw	r2,16(r2)
 2037fc4:	11000303 	ldbu	r4,12(r2)
 2037fc8:	10800343 	ldbu	r2,13(r2)
 2037fcc:	1004923a 	slli	r2,r2,8
 2037fd0:	1104b03a 	or	r2,r2,r4
 2037fd4:	10bfffcc 	andi	r2,r2,65535
 2037fd8:	1004923a 	slli	r2,r2,8
 2037fdc:	10bfffcc 	andi	r2,r2,65535
 2037fe0:	1884b03a 	or	r2,r3,r2
 2037fe4:	1080008c 	andi	r2,r2,2
 2037fe8:	10000826 	beq	r2,zero,203800c <tcp_receive+0x1444>
                inseg.len -= 1;
 2037fec:	008085b4 	movhi	r2,534
 2037ff0:	10888b04 	addi	r2,r2,8748
 2037ff4:	1080020b 	ldhu	r2,8(r2)
 2037ff8:	10bfffc4 	addi	r2,r2,-1
 2037ffc:	1007883a 	mov	r3,r2
 2038000:	008085b4 	movhi	r2,534
 2038004:	10888b04 	addi	r2,r2,8748
 2038008:	10c0020d 	sth	r3,8(r2)
              }
              pbuf_realloc(inseg.p, inseg.len);
 203800c:	008085b4 	movhi	r2,534
 2038010:	10888b04 	addi	r2,r2,8748
 2038014:	10c00117 	ldw	r3,4(r2)
 2038018:	008085b4 	movhi	r2,534
 203801c:	10888b04 	addi	r2,r2,8748
 2038020:	1080020b 	ldhu	r2,8(r2)
 2038024:	10bfffcc 	andi	r2,r2,65535
 2038028:	100b883a 	mov	r5,r2
 203802c:	1809883a 	mov	r4,r3
 2038030:	201a8580 	call	201a858 <pbuf_realloc>
              tcplen = TCP_TCPLEN(&inseg);
 2038034:	008085b4 	movhi	r2,534
 2038038:	10888b04 	addi	r2,r2,8748
 203803c:	10c0020b 	ldhu	r3,8(r2)
 2038040:	008085b4 	movhi	r2,534
 2038044:	10888b04 	addi	r2,r2,8748
 2038048:	10800417 	ldw	r2,16(r2)
 203804c:	11000303 	ldbu	r4,12(r2)
 2038050:	10800343 	ldbu	r2,13(r2)
 2038054:	1004923a 	slli	r2,r2,8
 2038058:	1104b03a 	or	r2,r2,r4
 203805c:	10bfffcc 	andi	r2,r2,65535
 2038060:	1004d23a 	srli	r2,r2,8
 2038064:	113fffcc 	andi	r4,r2,65535
 2038068:	008085b4 	movhi	r2,534
 203806c:	10888b04 	addi	r2,r2,8748
 2038070:	10800417 	ldw	r2,16(r2)
 2038074:	11400303 	ldbu	r5,12(r2)
 2038078:	10800343 	ldbu	r2,13(r2)
 203807c:	1004923a 	slli	r2,r2,8
 2038080:	1144b03a 	or	r2,r2,r5
 2038084:	10bfffcc 	andi	r2,r2,65535
 2038088:	1004923a 	slli	r2,r2,8
 203808c:	10bfffcc 	andi	r2,r2,65535
 2038090:	2084b03a 	or	r2,r4,r2
 2038094:	108000cc 	andi	r2,r2,3
 2038098:	1004c03a 	cmpne	r2,r2,zero
 203809c:	10803fcc 	andi	r2,r2,255
 20380a0:	1885883a 	add	r2,r3,r2
 20380a4:	d0a81d8d 	sth	r2,-24458(gp)
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
 20380a8:	e0bffe17 	ldw	r2,-8(fp)
 20380ac:	e0fff417 	ldw	r3,-48(fp)
 20380b0:	10c01e15 	stw	r3,120(r2)
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 20380b4:	d0a81d8b 	ldhu	r2,-24458(gp)
 20380b8:	10ffffcc 	andi	r3,r2,65535
 20380bc:	d0a81b17 	ldw	r2,-24468(gp)
 20380c0:	1887883a 	add	r3,r3,r2
 20380c4:	e0bffe17 	ldw	r2,-8(fp)
 20380c8:	10c00b15 	stw	r3,44(r2)

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 20380cc:	e0bffe17 	ldw	r2,-8(fp)
 20380d0:	10c00c0b 	ldhu	r3,48(r2)
 20380d4:	d0a81d8b 	ldhu	r2,-24458(gp)
 20380d8:	1885c83a 	sub	r2,r3,r2
 20380dc:	1007883a 	mov	r3,r2
 20380e0:	e0bffe17 	ldw	r2,-8(fp)
 20380e4:	10c00c0d 	sth	r3,48(r2)

        tcp_update_rcv_ann_wnd(pcb);
 20380e8:	e13ffe17 	ldw	r4,-8(fp)
 20380ec:	201c4540 	call	201c454 <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 20380f0:	008085b4 	movhi	r2,534
 20380f4:	10888b04 	addi	r2,r2,8748
 20380f8:	10800117 	ldw	r2,4(r2)
 20380fc:	1080020b 	ldhu	r2,8(r2)
 2038100:	10bfffcc 	andi	r2,r2,65535
 2038104:	10000726 	beq	r2,zero,2038124 <tcp_receive+0x155c>
          recv_data = inseg.p;
 2038108:	008085b4 	movhi	r2,534
 203810c:	10888b04 	addi	r2,r2,8748
 2038110:	10800117 	ldw	r2,4(r2)
 2038114:	d0a81f15 	stw	r2,-24452(gp)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 2038118:	008085b4 	movhi	r2,534
 203811c:	10888b04 	addi	r2,r2,8748
 2038120:	10000115 	stw	zero,4(r2)
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 2038124:	008085b4 	movhi	r2,534
 2038128:	10888b04 	addi	r2,r2,8748
 203812c:	10800417 	ldw	r2,16(r2)
 2038130:	10c00303 	ldbu	r3,12(r2)
 2038134:	10800343 	ldbu	r2,13(r2)
 2038138:	1004923a 	slli	r2,r2,8
 203813c:	10c4b03a 	or	r2,r2,r3
 2038140:	10bfffcc 	andi	r2,r2,65535
 2038144:	1004d23a 	srli	r2,r2,8
 2038148:	10ffffcc 	andi	r3,r2,65535
 203814c:	008085b4 	movhi	r2,534
 2038150:	10888b04 	addi	r2,r2,8748
 2038154:	10800417 	ldw	r2,16(r2)
 2038158:	11000303 	ldbu	r4,12(r2)
 203815c:	10800343 	ldbu	r2,13(r2)
 2038160:	1004923a 	slli	r2,r2,8
 2038164:	1104b03a 	or	r2,r2,r4
 2038168:	10bfffcc 	andi	r2,r2,65535
 203816c:	1004923a 	slli	r2,r2,8
 2038170:	10bfffcc 	andi	r2,r2,65535
 2038174:	1884b03a 	or	r2,r3,r2
 2038178:	1080004c 	andi	r2,r2,1
 203817c:	10008d26 	beq	r2,zero,20383b4 <tcp_receive+0x17ec>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 2038180:	d0a81e03 	ldbu	r2,-24456(gp)
 2038184:	10800814 	ori	r2,r2,32
 2038188:	d0a81e05 	stb	r2,-24456(gp)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 203818c:	00008906 	br	20383b4 <tcp_receive+0x17ec>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
 2038190:	e0bffe17 	ldw	r2,-8(fp)
 2038194:	10801e17 	ldw	r2,120(r2)
 2038198:	e0bffd15 	stw	r2,-12(fp)
          seqno = pcb->ooseq->tcphdr->seqno;
 203819c:	e0bffe17 	ldw	r2,-8(fp)
 20381a0:	10801e17 	ldw	r2,120(r2)
 20381a4:	10800417 	ldw	r2,16(r2)
 20381a8:	10c00103 	ldbu	r3,4(r2)
 20381ac:	11000143 	ldbu	r4,5(r2)
 20381b0:	2008923a 	slli	r4,r4,8
 20381b4:	20c6b03a 	or	r3,r4,r3
 20381b8:	11000183 	ldbu	r4,6(r2)
 20381bc:	2008943a 	slli	r4,r4,16
 20381c0:	20c6b03a 	or	r3,r4,r3
 20381c4:	108001c3 	ldbu	r2,7(r2)
 20381c8:	1004963a 	slli	r2,r2,24
 20381cc:	10c4b03a 	or	r2,r2,r3
 20381d0:	d0a81b15 	stw	r2,-24468(gp)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
 20381d4:	e0bffe17 	ldw	r2,-8(fp)
 20381d8:	10c00b17 	ldw	r3,44(r2)
 20381dc:	e0bffd17 	ldw	r2,-12(fp)
 20381e0:	1080020b 	ldhu	r2,8(r2)
 20381e4:	113fffcc 	andi	r4,r2,65535
 20381e8:	e0bffd17 	ldw	r2,-12(fp)
 20381ec:	10800417 	ldw	r2,16(r2)
 20381f0:	11400303 	ldbu	r5,12(r2)
 20381f4:	10800343 	ldbu	r2,13(r2)
 20381f8:	1004923a 	slli	r2,r2,8
 20381fc:	1144b03a 	or	r2,r2,r5
 2038200:	10bfffcc 	andi	r2,r2,65535
 2038204:	1004d23a 	srli	r2,r2,8
 2038208:	117fffcc 	andi	r5,r2,65535
 203820c:	e0bffd17 	ldw	r2,-12(fp)
 2038210:	10800417 	ldw	r2,16(r2)
 2038214:	11800303 	ldbu	r6,12(r2)
 2038218:	10800343 	ldbu	r2,13(r2)
 203821c:	1004923a 	slli	r2,r2,8
 2038220:	1184b03a 	or	r2,r2,r6
 2038224:	10bfffcc 	andi	r2,r2,65535
 2038228:	1004923a 	slli	r2,r2,8
 203822c:	10bfffcc 	andi	r2,r2,65535
 2038230:	2884b03a 	or	r2,r5,r2
 2038234:	108000cc 	andi	r2,r2,3
 2038238:	1004c03a 	cmpne	r2,r2,zero
 203823c:	10803fcc 	andi	r2,r2,255
 2038240:	2085883a 	add	r2,r4,r2
 2038244:	1887883a 	add	r3,r3,r2
 2038248:	e0bffe17 	ldw	r2,-8(fp)
 203824c:	10c00b15 	stw	r3,44(r2)
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
 2038250:	e0bffe17 	ldw	r2,-8(fp)
 2038254:	10c00c0b 	ldhu	r3,48(r2)
 2038258:	e0bffd17 	ldw	r2,-12(fp)
 203825c:	1100020b 	ldhu	r4,8(r2)
 2038260:	e0bffd17 	ldw	r2,-12(fp)
 2038264:	10800417 	ldw	r2,16(r2)
 2038268:	11400303 	ldbu	r5,12(r2)
 203826c:	10800343 	ldbu	r2,13(r2)
 2038270:	1004923a 	slli	r2,r2,8
 2038274:	1144b03a 	or	r2,r2,r5
 2038278:	10bfffcc 	andi	r2,r2,65535
 203827c:	1004d23a 	srli	r2,r2,8
 2038280:	117fffcc 	andi	r5,r2,65535
 2038284:	e0bffd17 	ldw	r2,-12(fp)
 2038288:	10800417 	ldw	r2,16(r2)
 203828c:	11800303 	ldbu	r6,12(r2)
 2038290:	10800343 	ldbu	r2,13(r2)
 2038294:	1004923a 	slli	r2,r2,8
 2038298:	1184b03a 	or	r2,r2,r6
 203829c:	10bfffcc 	andi	r2,r2,65535
 20382a0:	1004923a 	slli	r2,r2,8
 20382a4:	10bfffcc 	andi	r2,r2,65535
 20382a8:	2884b03a 	or	r2,r5,r2
 20382ac:	108000cc 	andi	r2,r2,3
 20382b0:	1004c03a 	cmpne	r2,r2,zero
 20382b4:	10803fcc 	andi	r2,r2,255
 20382b8:	2085883a 	add	r2,r4,r2
 20382bc:	1885c83a 	sub	r2,r3,r2
 20382c0:	1007883a 	mov	r3,r2
 20382c4:	e0bffe17 	ldw	r2,-8(fp)
 20382c8:	10c00c0d 	sth	r3,48(r2)

          tcp_update_rcv_ann_wnd(pcb);
 20382cc:	e13ffe17 	ldw	r4,-8(fp)
 20382d0:	201c4540 	call	201c454 <tcp_update_rcv_ann_wnd>

          if (cseg->p->tot_len > 0) {
 20382d4:	e0bffd17 	ldw	r2,-12(fp)
 20382d8:	10800117 	ldw	r2,4(r2)
 20382dc:	1080020b 	ldhu	r2,8(r2)
 20382e0:	10bfffcc 	andi	r2,r2,65535
 20382e4:	10000e26 	beq	r2,zero,2038320 <tcp_receive+0x1758>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
 20382e8:	d0a81f17 	ldw	r2,-24452(gp)
 20382ec:	10000726 	beq	r2,zero,203830c <tcp_receive+0x1744>
              pbuf_cat(recv_data, cseg->p);
 20382f0:	d0e81f17 	ldw	r3,-24452(gp)
 20382f4:	e0bffd17 	ldw	r2,-12(fp)
 20382f8:	10800117 	ldw	r2,4(r2)
 20382fc:	100b883a 	mov	r5,r2
 2038300:	1809883a 	mov	r4,r3
 2038304:	201ad5c0 	call	201ad5c <pbuf_cat>
 2038308:	00000306 	br	2038318 <tcp_receive+0x1750>
            } else {
              recv_data = cseg->p;
 203830c:	e0bffd17 	ldw	r2,-12(fp)
 2038310:	10800117 	ldw	r2,4(r2)
 2038314:	d0a81f15 	stw	r2,-24452(gp)
            }
            cseg->p = NULL;
 2038318:	e0bffd17 	ldw	r2,-12(fp)
 203831c:	10000115 	stw	zero,4(r2)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
 2038320:	e0bffd17 	ldw	r2,-12(fp)
 2038324:	10800417 	ldw	r2,16(r2)
 2038328:	10c00303 	ldbu	r3,12(r2)
 203832c:	10800343 	ldbu	r2,13(r2)
 2038330:	1004923a 	slli	r2,r2,8
 2038334:	10c4b03a 	or	r2,r2,r3
 2038338:	10bfffcc 	andi	r2,r2,65535
 203833c:	1004d23a 	srli	r2,r2,8
 2038340:	10ffffcc 	andi	r3,r2,65535
 2038344:	e0bffd17 	ldw	r2,-12(fp)
 2038348:	10800417 	ldw	r2,16(r2)
 203834c:	11000303 	ldbu	r4,12(r2)
 2038350:	10800343 	ldbu	r2,13(r2)
 2038354:	1004923a 	slli	r2,r2,8
 2038358:	1104b03a 	or	r2,r2,r4
 203835c:	10bfffcc 	andi	r2,r2,65535
 2038360:	1004923a 	slli	r2,r2,8
 2038364:	10bfffcc 	andi	r2,r2,65535
 2038368:	1884b03a 	or	r2,r3,r2
 203836c:	1080004c 	andi	r2,r2,1
 2038370:	10000a26 	beq	r2,zero,203839c <tcp_receive+0x17d4>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
 2038374:	d0a81e03 	ldbu	r2,-24456(gp)
 2038378:	10800814 	ori	r2,r2,32
 203837c:	d0a81e05 	stb	r2,-24456(gp)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
 2038380:	e0bffe17 	ldw	r2,-8(fp)
 2038384:	10800617 	ldw	r2,24(r2)
 2038388:	10800118 	cmpnei	r2,r2,4
 203838c:	1000031e 	bne	r2,zero,203839c <tcp_receive+0x17d4>
              pcb->state = CLOSE_WAIT;
 2038390:	e0bffe17 	ldw	r2,-8(fp)
 2038394:	00c001c4 	movi	r3,7
 2038398:	10c00615 	stw	r3,24(r2)
            } 
          }

          pcb->ooseq = cseg->next;
 203839c:	e0bffd17 	ldw	r2,-12(fp)
 20383a0:	10c00017 	ldw	r3,0(r2)
 20383a4:	e0bffe17 	ldw	r2,-8(fp)
 20383a8:	10c01e15 	stw	r3,120(r2)
          tcp_seg_free(cseg);
 20383ac:	e13ffd17 	ldw	r4,-12(fp)
 20383b0:	201d4300 	call	201d430 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 20383b4:	e0bffe17 	ldw	r2,-8(fp)
 20383b8:	10801e17 	ldw	r2,120(r2)
 20383bc:	10001126 	beq	r2,zero,2038404 <tcp_receive+0x183c>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
 20383c0:	e0bffe17 	ldw	r2,-8(fp)
 20383c4:	10801e17 	ldw	r2,120(r2)
 20383c8:	10800417 	ldw	r2,16(r2)
 20383cc:	10c00103 	ldbu	r3,4(r2)
 20383d0:	11000143 	ldbu	r4,5(r2)
 20383d4:	2008923a 	slli	r4,r4,8
 20383d8:	20c6b03a 	or	r3,r4,r3
 20383dc:	11000183 	ldbu	r4,6(r2)
 20383e0:	2008943a 	slli	r4,r4,16
 20383e4:	20c6b03a 	or	r3,r4,r3
 20383e8:	108001c3 	ldbu	r2,7(r2)
 20383ec:	1004963a 	slli	r2,r2,24
 20383f0:	10c4b03a 	or	r2,r2,r3
 20383f4:	1007883a 	mov	r3,r2
 20383f8:	e0bffe17 	ldw	r2,-8(fp)
 20383fc:	10800b17 	ldw	r2,44(r2)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
 2038400:	18bf6326 	beq	r3,r2,2038190 <__alt_mem_mem_0+0xfd018190>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 2038404:	e0bffe17 	ldw	r2,-8(fp)
 2038408:	10800883 	ldbu	r2,34(r2)
 203840c:	10803fcc 	andi	r2,r2,255
 2038410:	1080004c 	andi	r2,r2,1
 2038414:	10000e26 	beq	r2,zero,2038450 <tcp_receive+0x1888>
 2038418:	e0bffe17 	ldw	r2,-8(fp)
 203841c:	10c00883 	ldbu	r3,34(r2)
 2038420:	00bfff84 	movi	r2,-2
 2038424:	1884703a 	and	r2,r3,r2
 2038428:	1007883a 	mov	r3,r2
 203842c:	e0bffe17 	ldw	r2,-8(fp)
 2038430:	10c00885 	stb	r3,34(r2)
 2038434:	e0bffe17 	ldw	r2,-8(fp)
 2038438:	10800883 	ldbu	r2,34(r2)
 203843c:	10800094 	ori	r2,r2,2
 2038440:	1007883a 	mov	r3,r2
 2038444:	e0bffe17 	ldw	r2,-8(fp)
 2038448:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 203844c:	0001bd06 	br	2038b44 <tcp_receive+0x1f7c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 2038450:	e0bffe17 	ldw	r2,-8(fp)
 2038454:	10800883 	ldbu	r2,34(r2)
 2038458:	10800054 	ori	r2,r2,1
 203845c:	1007883a 	mov	r3,r2
 2038460:	e0bffe17 	ldw	r2,-8(fp)
 2038464:	10c00885 	stb	r3,34(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 2038468:	0001b606 	br	2038b44 <tcp_receive+0x1f7c>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 203846c:	e13ffe17 	ldw	r4,-8(fp)
 2038470:	201f5e40 	call	201f5e4 <tcp_send_empty_ack>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
 2038474:	e0bffe17 	ldw	r2,-8(fp)
 2038478:	10801e17 	ldw	r2,120(r2)
 203847c:	1000071e 	bne	r2,zero,203849c <tcp_receive+0x18d4>
          pcb->ooseq = tcp_seg_copy(&inseg);
 2038480:	010085b4 	movhi	r4,534
 2038484:	21088b04 	addi	r4,r4,8748
 2038488:	201d4c40 	call	201d4c4 <tcp_seg_copy>
 203848c:	1007883a 	mov	r3,r2
 2038490:	e0bffe17 	ldw	r2,-8(fp)
 2038494:	10c01e15 	stw	r3,120(r2)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 2038498:	0001aa06 	br	2038b44 <tcp_receive+0x1f7c>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
 203849c:	e03ff515 	stw	zero,-44(fp)
          for(next = pcb->ooseq; next != NULL; next = next->next) {
 20384a0:	e0bffe17 	ldw	r2,-8(fp)
 20384a4:	10801e17 	ldw	r2,120(r2)
 20384a8:	e0bff415 	stw	r2,-48(fp)
 20384ac:	00019306 	br	2038afc <tcp_receive+0x1f34>
            if (seqno == next->tcphdr->seqno) {
 20384b0:	e0bff417 	ldw	r2,-48(fp)
 20384b4:	10800417 	ldw	r2,16(r2)
 20384b8:	10c00103 	ldbu	r3,4(r2)
 20384bc:	11000143 	ldbu	r4,5(r2)
 20384c0:	2008923a 	slli	r4,r4,8
 20384c4:	20c6b03a 	or	r3,r4,r3
 20384c8:	11000183 	ldbu	r4,6(r2)
 20384cc:	2008943a 	slli	r4,r4,16
 20384d0:	20c6b03a 	or	r3,r4,r3
 20384d4:	108001c3 	ldbu	r2,7(r2)
 20384d8:	1004963a 	slli	r2,r2,24
 20384dc:	10c4b03a 	or	r2,r2,r3
 20384e0:	1007883a 	mov	r3,r2
 20384e4:	d0a81b17 	ldw	r2,-24468(gp)
 20384e8:	18801b1e 	bne	r3,r2,2038558 <tcp_receive+0x1990>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
 20384ec:	008085b4 	movhi	r2,534
 20384f0:	10888b04 	addi	r2,r2,8748
 20384f4:	1100020b 	ldhu	r4,8(r2)
 20384f8:	e0bff417 	ldw	r2,-48(fp)
 20384fc:	10c0020b 	ldhu	r3,8(r2)
 2038500:	20bfffcc 	andi	r2,r4,65535
 2038504:	18ffffcc 	andi	r3,r3,65535
 2038508:	18817f2e 	bgeu	r3,r2,2038b08 <tcp_receive+0x1f40>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
 203850c:	010085b4 	movhi	r4,534
 2038510:	21088b04 	addi	r4,r4,8748
 2038514:	201d4c40 	call	201d4c4 <tcp_seg_copy>
 2038518:	e0bffd15 	stw	r2,-12(fp)
                if (cseg != NULL) {
 203851c:	e0bffd17 	ldw	r2,-12(fp)
 2038520:	10017b26 	beq	r2,zero,2038b10 <tcp_receive+0x1f48>
                  if (prev != NULL) {
 2038524:	e0bff517 	ldw	r2,-44(fp)
 2038528:	10000426 	beq	r2,zero,203853c <tcp_receive+0x1974>
                    prev->next = cseg;
 203852c:	e0bff517 	ldw	r2,-44(fp)
 2038530:	e0fffd17 	ldw	r3,-12(fp)
 2038534:	10c00015 	stw	r3,0(r2)
 2038538:	00000306 	br	2038548 <tcp_receive+0x1980>
                  } else {
                    pcb->ooseq = cseg;
 203853c:	e0bffe17 	ldw	r2,-8(fp)
 2038540:	e0fffd17 	ldw	r3,-12(fp)
 2038544:	10c01e15 	stw	r3,120(r2)
                  }
                  tcp_oos_insert_segment(cseg, next);
 2038548:	e17ff417 	ldw	r5,-48(fp)
 203854c:	e13ffd17 	ldw	r4,-12(fp)
 2038550:	20369280 	call	2036928 <tcp_oos_insert_segment>
                }
                break;
 2038554:	00016e06 	br	2038b10 <tcp_receive+0x1f48>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
 2038558:	e0bff517 	ldw	r2,-44(fp)
 203855c:	10001c1e 	bne	r2,zero,20385d0 <tcp_receive+0x1a08>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
 2038560:	d0e81b17 	ldw	r3,-24468(gp)
 2038564:	e0bff417 	ldw	r2,-48(fp)
 2038568:	10800417 	ldw	r2,16(r2)
 203856c:	11000103 	ldbu	r4,4(r2)
 2038570:	11400143 	ldbu	r5,5(r2)
 2038574:	280a923a 	slli	r5,r5,8
 2038578:	2908b03a 	or	r4,r5,r4
 203857c:	11400183 	ldbu	r5,6(r2)
 2038580:	280a943a 	slli	r5,r5,16
 2038584:	2908b03a 	or	r4,r5,r4
 2038588:	108001c3 	ldbu	r2,7(r2)
 203858c:	1004963a 	slli	r2,r2,24
 2038590:	1104b03a 	or	r2,r2,r4
 2038594:	1885c83a 	sub	r2,r3,r2
 2038598:	1000680e 	bge	r2,zero,203873c <tcp_receive+0x1b74>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
 203859c:	010085b4 	movhi	r4,534
 20385a0:	21088b04 	addi	r4,r4,8748
 20385a4:	201d4c40 	call	201d4c4 <tcp_seg_copy>
 20385a8:	e0bffd15 	stw	r2,-12(fp)
                  if (cseg != NULL) {
 20385ac:	e0bffd17 	ldw	r2,-12(fp)
 20385b0:	10015926 	beq	r2,zero,2038b18 <tcp_receive+0x1f50>
                    pcb->ooseq = cseg;
 20385b4:	e0bffe17 	ldw	r2,-8(fp)
 20385b8:	e0fffd17 	ldw	r3,-12(fp)
 20385bc:	10c01e15 	stw	r3,120(r2)
                    tcp_oos_insert_segment(cseg, next);
 20385c0:	e17ff417 	ldw	r5,-48(fp)
 20385c4:	e13ffd17 	ldw	r4,-12(fp)
 20385c8:	20369280 	call	2036928 <tcp_oos_insert_segment>
                  }
                  break;
 20385cc:	00015206 	br	2038b18 <tcp_receive+0x1f50>
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
 20385d0:	d0e81b17 	ldw	r3,-24468(gp)
 20385d4:	e0bff517 	ldw	r2,-44(fp)
 20385d8:	10800417 	ldw	r2,16(r2)
 20385dc:	11000103 	ldbu	r4,4(r2)
 20385e0:	11400143 	ldbu	r5,5(r2)
 20385e4:	280a923a 	slli	r5,r5,8
 20385e8:	2908b03a 	or	r4,r5,r4
 20385ec:	11400183 	ldbu	r5,6(r2)
 20385f0:	280a943a 	slli	r5,r5,16
 20385f4:	2908b03a 	or	r4,r5,r4
 20385f8:	108001c3 	ldbu	r2,7(r2)
 20385fc:	1004963a 	slli	r2,r2,24
 2038600:	1104b03a 	or	r2,r2,r4
 2038604:	1885c83a 	sub	r2,r3,r2
 2038608:	10bfffc4 	addi	r2,r2,-1
 203860c:	10004b16 	blt	r2,zero,203873c <tcp_receive+0x1b74>
 2038610:	d0e81b17 	ldw	r3,-24468(gp)
 2038614:	e0bff417 	ldw	r2,-48(fp)
 2038618:	10800417 	ldw	r2,16(r2)
 203861c:	11000103 	ldbu	r4,4(r2)
 2038620:	11400143 	ldbu	r5,5(r2)
 2038624:	280a923a 	slli	r5,r5,8
 2038628:	2908b03a 	or	r4,r5,r4
 203862c:	11400183 	ldbu	r5,6(r2)
 2038630:	280a943a 	slli	r5,r5,16
 2038634:	2908b03a 	or	r4,r5,r4
 2038638:	108001c3 	ldbu	r2,7(r2)
 203863c:	1004963a 	slli	r2,r2,24
 2038640:	1104b03a 	or	r2,r2,r4
 2038644:	1885c83a 	sub	r2,r3,r2
 2038648:	10800044 	addi	r2,r2,1
 203864c:	00803b16 	blt	zero,r2,203873c <tcp_receive+0x1b74>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
 2038650:	010085b4 	movhi	r4,534
 2038654:	21088b04 	addi	r4,r4,8748
 2038658:	201d4c40 	call	201d4c4 <tcp_seg_copy>
 203865c:	e0bffd15 	stw	r2,-12(fp)
                  if (cseg != NULL) {
 2038660:	e0bffd17 	ldw	r2,-12(fp)
 2038664:	10012e26 	beq	r2,zero,2038b20 <tcp_receive+0x1f58>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
 2038668:	e0bff517 	ldw	r2,-44(fp)
 203866c:	10800417 	ldw	r2,16(r2)
 2038670:	10c00103 	ldbu	r3,4(r2)
 2038674:	11000143 	ldbu	r4,5(r2)
 2038678:	2008923a 	slli	r4,r4,8
 203867c:	20c6b03a 	or	r3,r4,r3
 2038680:	11000183 	ldbu	r4,6(r2)
 2038684:	2008943a 	slli	r4,r4,16
 2038688:	20c6b03a 	or	r3,r4,r3
 203868c:	108001c3 	ldbu	r2,7(r2)
 2038690:	1004963a 	slli	r2,r2,24
 2038694:	10c4b03a 	or	r2,r2,r3
 2038698:	1007883a 	mov	r3,r2
 203869c:	e0bff517 	ldw	r2,-44(fp)
 20386a0:	1080020b 	ldhu	r2,8(r2)
 20386a4:	10bfffcc 	andi	r2,r2,65535
 20386a8:	1887883a 	add	r3,r3,r2
 20386ac:	d0a81b17 	ldw	r2,-24468(gp)
 20386b0:	1885c83a 	sub	r2,r3,r2
 20386b4:	00801a0e 	bge	zero,r2,2038720 <tcp_receive+0x1b58>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
 20386b8:	d0a81b17 	ldw	r2,-24468(gp)
 20386bc:	100b883a 	mov	r5,r2
 20386c0:	e0bff517 	ldw	r2,-44(fp)
 20386c4:	10800417 	ldw	r2,16(r2)
 20386c8:	10c00103 	ldbu	r3,4(r2)
 20386cc:	11000143 	ldbu	r4,5(r2)
 20386d0:	2008923a 	slli	r4,r4,8
 20386d4:	20c6b03a 	or	r3,r4,r3
 20386d8:	11000183 	ldbu	r4,6(r2)
 20386dc:	2008943a 	slli	r4,r4,16
 20386e0:	20c6b03a 	or	r3,r4,r3
 20386e4:	108001c3 	ldbu	r2,7(r2)
 20386e8:	1004963a 	slli	r2,r2,24
 20386ec:	10c4b03a 	or	r2,r2,r3
 20386f0:	2885c83a 	sub	r2,r5,r2
 20386f4:	1007883a 	mov	r3,r2
 20386f8:	e0bff517 	ldw	r2,-44(fp)
 20386fc:	10c0020d 	sth	r3,8(r2)
                      pbuf_realloc(prev->p, prev->len);
 2038700:	e0bff517 	ldw	r2,-44(fp)
 2038704:	10c00117 	ldw	r3,4(r2)
 2038708:	e0bff517 	ldw	r2,-44(fp)
 203870c:	1080020b 	ldhu	r2,8(r2)
 2038710:	10bfffcc 	andi	r2,r2,65535
 2038714:	100b883a 	mov	r5,r2
 2038718:	1809883a 	mov	r4,r3
 203871c:	201a8580 	call	201a858 <pbuf_realloc>
                    }
                    prev->next = cseg;
 2038720:	e0bff517 	ldw	r2,-44(fp)
 2038724:	e0fffd17 	ldw	r3,-12(fp)
 2038728:	10c00015 	stw	r3,0(r2)
                    tcp_oos_insert_segment(cseg, next);
 203872c:	e17ff417 	ldw	r5,-48(fp)
 2038730:	e13ffd17 	ldw	r4,-12(fp)
 2038734:	20369280 	call	2036928 <tcp_oos_insert_segment>
                  }
                  break;
 2038738:	0000f906 	br	2038b20 <tcp_receive+0x1f58>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 203873c:	e0bff417 	ldw	r2,-48(fp)
 2038740:	10800017 	ldw	r2,0(r2)
 2038744:	1000e81e 	bne	r2,zero,2038ae8 <tcp_receive+0x1f20>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
 2038748:	d0e81b17 	ldw	r3,-24468(gp)
 203874c:	e0bff417 	ldw	r2,-48(fp)
 2038750:	10800417 	ldw	r2,16(r2)
 2038754:	11000103 	ldbu	r4,4(r2)
 2038758:	11400143 	ldbu	r5,5(r2)
 203875c:	280a923a 	slli	r5,r5,8
 2038760:	2908b03a 	or	r4,r5,r4
 2038764:	11400183 	ldbu	r5,6(r2)
 2038768:	280a943a 	slli	r5,r5,16
 203876c:	2908b03a 	or	r4,r5,r4
 2038770:	108001c3 	ldbu	r2,7(r2)
 2038774:	1004963a 	slli	r2,r2,24
 2038778:	1104b03a 	or	r2,r2,r4
 203877c:	1885c83a 	sub	r2,r3,r2
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
 2038780:	0080d90e 	bge	zero,r2,2038ae8 <tcp_receive+0x1f20>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
 2038784:	e0bff417 	ldw	r2,-48(fp)
 2038788:	10800417 	ldw	r2,16(r2)
 203878c:	10c00303 	ldbu	r3,12(r2)
 2038790:	10800343 	ldbu	r2,13(r2)
 2038794:	1004923a 	slli	r2,r2,8
 2038798:	10c4b03a 	or	r2,r2,r3
 203879c:	10bfffcc 	andi	r2,r2,65535
 20387a0:	1004d23a 	srli	r2,r2,8
 20387a4:	10ffffcc 	andi	r3,r2,65535
 20387a8:	e0bff417 	ldw	r2,-48(fp)
 20387ac:	10800417 	ldw	r2,16(r2)
 20387b0:	11000303 	ldbu	r4,12(r2)
 20387b4:	10800343 	ldbu	r2,13(r2)
 20387b8:	1004923a 	slli	r2,r2,8
 20387bc:	1104b03a 	or	r2,r2,r4
 20387c0:	10bfffcc 	andi	r2,r2,65535
 20387c4:	1004923a 	slli	r2,r2,8
 20387c8:	10bfffcc 	andi	r2,r2,65535
 20387cc:	1884b03a 	or	r2,r3,r2
 20387d0:	1080004c 	andi	r2,r2,1
 20387d4:	1000d41e 	bne	r2,zero,2038b28 <tcp_receive+0x1f60>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
 20387d8:	010085b4 	movhi	r4,534
 20387dc:	21088b04 	addi	r4,r4,8748
 20387e0:	201d4c40 	call	201d4c4 <tcp_seg_copy>
 20387e4:	1007883a 	mov	r3,r2
 20387e8:	e0bff417 	ldw	r2,-48(fp)
 20387ec:	10c00015 	stw	r3,0(r2)
                if (next->next != NULL) {
 20387f0:	e0bff417 	ldw	r2,-48(fp)
 20387f4:	10800017 	ldw	r2,0(r2)
 20387f8:	1000cd26 	beq	r2,zero,2038b30 <tcp_receive+0x1f68>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
 20387fc:	e0bff417 	ldw	r2,-48(fp)
 2038800:	10800417 	ldw	r2,16(r2)
 2038804:	10c00103 	ldbu	r3,4(r2)
 2038808:	11000143 	ldbu	r4,5(r2)
 203880c:	2008923a 	slli	r4,r4,8
 2038810:	20c6b03a 	or	r3,r4,r3
 2038814:	11000183 	ldbu	r4,6(r2)
 2038818:	2008943a 	slli	r4,r4,16
 203881c:	20c6b03a 	or	r3,r4,r3
 2038820:	108001c3 	ldbu	r2,7(r2)
 2038824:	1004963a 	slli	r2,r2,24
 2038828:	10c4b03a 	or	r2,r2,r3
 203882c:	1007883a 	mov	r3,r2
 2038830:	e0bff417 	ldw	r2,-48(fp)
 2038834:	1080020b 	ldhu	r2,8(r2)
 2038838:	10bfffcc 	andi	r2,r2,65535
 203883c:	1887883a 	add	r3,r3,r2
 2038840:	d0a81b17 	ldw	r2,-24468(gp)
 2038844:	1885c83a 	sub	r2,r3,r2
 2038848:	00801a0e 	bge	zero,r2,20388b4 <tcp_receive+0x1cec>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
 203884c:	d0a81b17 	ldw	r2,-24468(gp)
 2038850:	100b883a 	mov	r5,r2
 2038854:	e0bff417 	ldw	r2,-48(fp)
 2038858:	10800417 	ldw	r2,16(r2)
 203885c:	10c00103 	ldbu	r3,4(r2)
 2038860:	11000143 	ldbu	r4,5(r2)
 2038864:	2008923a 	slli	r4,r4,8
 2038868:	20c6b03a 	or	r3,r4,r3
 203886c:	11000183 	ldbu	r4,6(r2)
 2038870:	2008943a 	slli	r4,r4,16
 2038874:	20c6b03a 	or	r3,r4,r3
 2038878:	108001c3 	ldbu	r2,7(r2)
 203887c:	1004963a 	slli	r2,r2,24
 2038880:	10c4b03a 	or	r2,r2,r3
 2038884:	2885c83a 	sub	r2,r5,r2
 2038888:	1007883a 	mov	r3,r2
 203888c:	e0bff417 	ldw	r2,-48(fp)
 2038890:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->p, next->len);
 2038894:	e0bff417 	ldw	r2,-48(fp)
 2038898:	10c00117 	ldw	r3,4(r2)
 203889c:	e0bff417 	ldw	r2,-48(fp)
 20388a0:	1080020b 	ldhu	r2,8(r2)
 20388a4:	10bfffcc 	andi	r2,r2,65535
 20388a8:	100b883a 	mov	r5,r2
 20388ac:	1809883a 	mov	r4,r3
 20388b0:	201a8580 	call	201a858 <pbuf_realloc>
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
 20388b4:	d0a81d8b 	ldhu	r2,-24458(gp)
 20388b8:	10ffffcc 	andi	r3,r2,65535
 20388bc:	d0a81b17 	ldw	r2,-24468(gp)
 20388c0:	1885883a 	add	r2,r3,r2
 20388c4:	e0fffe17 	ldw	r3,-8(fp)
 20388c8:	19000b17 	ldw	r4,44(r3)
 20388cc:	e0fffe17 	ldw	r3,-8(fp)
 20388d0:	18c00c0b 	ldhu	r3,48(r3)
 20388d4:	18ffffcc 	andi	r3,r3,65535
 20388d8:	20c7883a 	add	r3,r4,r3
 20388dc:	1880942e 	bgeu	r3,r2,2038b30 <tcp_receive+0x1f68>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
 20388e0:	e0bff417 	ldw	r2,-48(fp)
 20388e4:	10800017 	ldw	r2,0(r2)
 20388e8:	10800417 	ldw	r2,16(r2)
 20388ec:	10c00303 	ldbu	r3,12(r2)
 20388f0:	10800343 	ldbu	r2,13(r2)
 20388f4:	1004923a 	slli	r2,r2,8
 20388f8:	10c4b03a 	or	r2,r2,r3
 20388fc:	10bfffcc 	andi	r2,r2,65535
 2038900:	1004d23a 	srli	r2,r2,8
 2038904:	10ffffcc 	andi	r3,r2,65535
 2038908:	e0bff417 	ldw	r2,-48(fp)
 203890c:	10800017 	ldw	r2,0(r2)
 2038910:	10800417 	ldw	r2,16(r2)
 2038914:	11000303 	ldbu	r4,12(r2)
 2038918:	10800343 	ldbu	r2,13(r2)
 203891c:	1004923a 	slli	r2,r2,8
 2038920:	1104b03a 	or	r2,r2,r4
 2038924:	10bfffcc 	andi	r2,r2,65535
 2038928:	1004923a 	slli	r2,r2,8
 203892c:	10bfffcc 	andi	r2,r2,65535
 2038930:	1884b03a 	or	r2,r3,r2
 2038934:	1080004c 	andi	r2,r2,1
 2038938:	10003726 	beq	r2,zero,2038a18 <tcp_receive+0x1e50>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
 203893c:	e0bff417 	ldw	r2,-48(fp)
 2038940:	10800017 	ldw	r2,0(r2)
 2038944:	10800417 	ldw	r2,16(r2)
 2038948:	e0fff417 	ldw	r3,-48(fp)
 203894c:	18c00017 	ldw	r3,0(r3)
 2038950:	18c00417 	ldw	r3,16(r3)
 2038954:	19000303 	ldbu	r4,12(r3)
 2038958:	18c00343 	ldbu	r3,13(r3)
 203895c:	1806923a 	slli	r3,r3,8
 2038960:	1906b03a 	or	r3,r3,r4
 2038964:	1809883a 	mov	r4,r3
 2038968:	00f03fc4 	movi	r3,-16129
 203896c:	20c6703a 	and	r3,r4,r3
 2038970:	180b883a 	mov	r5,r3
 2038974:	e0fff417 	ldw	r3,-48(fp)
 2038978:	18c00017 	ldw	r3,0(r3)
 203897c:	18c00417 	ldw	r3,16(r3)
 2038980:	19000303 	ldbu	r4,12(r3)
 2038984:	18c00343 	ldbu	r3,13(r3)
 2038988:	1806923a 	slli	r3,r3,8
 203898c:	1906b03a 	or	r3,r3,r4
 2038990:	18ffffcc 	andi	r3,r3,65535
 2038994:	1806d23a 	srli	r3,r3,8
 2038998:	180d883a 	mov	r6,r3
 203899c:	e0fff417 	ldw	r3,-48(fp)
 20389a0:	18c00017 	ldw	r3,0(r3)
 20389a4:	18c00417 	ldw	r3,16(r3)
 20389a8:	19000303 	ldbu	r4,12(r3)
 20389ac:	18c00343 	ldbu	r3,13(r3)
 20389b0:	1806923a 	slli	r3,r3,8
 20389b4:	1906b03a 	or	r3,r3,r4
 20389b8:	18ffffcc 	andi	r3,r3,65535
 20389bc:	1806923a 	slli	r3,r3,8
 20389c0:	30c6b03a 	or	r3,r6,r3
 20389c4:	18c00f8c 	andi	r3,r3,62
 20389c8:	1806923a 	slli	r3,r3,8
 20389cc:	28c6b03a 	or	r3,r5,r3
 20389d0:	180d883a 	mov	r6,r3
 20389d4:	30ffffcc 	andi	r3,r6,65535
 20389d8:	19403fcc 	andi	r5,r3,255
 20389dc:	10c00303 	ldbu	r3,12(r2)
 20389e0:	1806703a 	and	r3,r3,zero
 20389e4:	1809883a 	mov	r4,r3
 20389e8:	2807883a 	mov	r3,r5
 20389ec:	20c6b03a 	or	r3,r4,r3
 20389f0:	10c00305 	stb	r3,12(r2)
 20389f4:	30ffffcc 	andi	r3,r6,65535
 20389f8:	1806d23a 	srli	r3,r3,8
 20389fc:	197fffcc 	andi	r5,r3,65535
 2038a00:	10c00343 	ldbu	r3,13(r2)
 2038a04:	1806703a 	and	r3,r3,zero
 2038a08:	1809883a 	mov	r4,r3
 2038a0c:	2807883a 	mov	r3,r5
 2038a10:	20c6b03a 	or	r3,r4,r3
 2038a14:	10c00345 	stb	r3,13(r2)
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
 2038a18:	e0bff417 	ldw	r2,-48(fp)
 2038a1c:	10800017 	ldw	r2,0(r2)
 2038a20:	e0fffe17 	ldw	r3,-8(fp)
 2038a24:	18c00b17 	ldw	r3,44(r3)
 2038a28:	1809883a 	mov	r4,r3
 2038a2c:	e0fffe17 	ldw	r3,-8(fp)
 2038a30:	18c00c0b 	ldhu	r3,48(r3)
 2038a34:	20c7883a 	add	r3,r4,r3
 2038a38:	1809883a 	mov	r4,r3
 2038a3c:	d0e81b17 	ldw	r3,-24468(gp)
 2038a40:	20c7c83a 	sub	r3,r4,r3
 2038a44:	10c0020d 	sth	r3,8(r2)
                    pbuf_realloc(next->next->p, next->next->len);
 2038a48:	e0bff417 	ldw	r2,-48(fp)
 2038a4c:	10800017 	ldw	r2,0(r2)
 2038a50:	10c00117 	ldw	r3,4(r2)
 2038a54:	e0bff417 	ldw	r2,-48(fp)
 2038a58:	10800017 	ldw	r2,0(r2)
 2038a5c:	1080020b 	ldhu	r2,8(r2)
 2038a60:	10bfffcc 	andi	r2,r2,65535
 2038a64:	100b883a 	mov	r5,r2
 2038a68:	1809883a 	mov	r4,r3
 2038a6c:	201a8580 	call	201a858 <pbuf_realloc>
                    tcplen = TCP_TCPLEN(next->next);
 2038a70:	e0bff417 	ldw	r2,-48(fp)
 2038a74:	10800017 	ldw	r2,0(r2)
 2038a78:	10c0020b 	ldhu	r3,8(r2)
 2038a7c:	e0bff417 	ldw	r2,-48(fp)
 2038a80:	10800017 	ldw	r2,0(r2)
 2038a84:	10800417 	ldw	r2,16(r2)
 2038a88:	11000303 	ldbu	r4,12(r2)
 2038a8c:	10800343 	ldbu	r2,13(r2)
 2038a90:	1004923a 	slli	r2,r2,8
 2038a94:	1104b03a 	or	r2,r2,r4
 2038a98:	10bfffcc 	andi	r2,r2,65535
 2038a9c:	1004d23a 	srli	r2,r2,8
 2038aa0:	113fffcc 	andi	r4,r2,65535
 2038aa4:	e0bff417 	ldw	r2,-48(fp)
 2038aa8:	10800017 	ldw	r2,0(r2)
 2038aac:	10800417 	ldw	r2,16(r2)
 2038ab0:	11400303 	ldbu	r5,12(r2)
 2038ab4:	10800343 	ldbu	r2,13(r2)
 2038ab8:	1004923a 	slli	r2,r2,8
 2038abc:	1144b03a 	or	r2,r2,r5
 2038ac0:	10bfffcc 	andi	r2,r2,65535
 2038ac4:	1004923a 	slli	r2,r2,8
 2038ac8:	10bfffcc 	andi	r2,r2,65535
 2038acc:	2084b03a 	or	r2,r4,r2
 2038ad0:	108000cc 	andi	r2,r2,3
 2038ad4:	1004c03a 	cmpne	r2,r2,zero
 2038ad8:	10803fcc 	andi	r2,r2,255
 2038adc:	1885883a 	add	r2,r3,r2
 2038ae0:	d0a81d8d 	sth	r2,-24458(gp)
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 2038ae4:	00001206 	br	2038b30 <tcp_receive+0x1f68>
              }
            }
            prev = next;
 2038ae8:	e0bff417 	ldw	r2,-48(fp)
 2038aec:	e0bff515 	stw	r2,-44(fp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
 2038af0:	e0bff417 	ldw	r2,-48(fp)
 2038af4:	10800017 	ldw	r2,0(r2)
 2038af8:	e0bff415 	stw	r2,-48(fp)
 2038afc:	e0bff417 	ldw	r2,-48(fp)
 2038b00:	103e6b1e 	bne	r2,zero,20384b0 <__alt_mem_mem_0+0xfd0184b0>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 2038b04:	00000f06 	br	2038b44 <tcp_receive+0x1f7c>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
 2038b08:	0001883a 	nop
 2038b0c:	00000d06 	br	2038b44 <tcp_receive+0x1f7c>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
 2038b10:	0001883a 	nop
 2038b14:	00000b06 	br	2038b44 <tcp_receive+0x1f7c>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 2038b18:	0001883a 	nop
 2038b1c:	00000906 	br	2038b44 <tcp_receive+0x1f7c>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
 2038b20:	0001883a 	nop
 2038b24:	00000706 	br	2038b44 <tcp_receive+0x1f7c>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
 2038b28:	0001883a 	nop
 2038b2c:	00000506 	br	2038b44 <tcp_receive+0x1f7c>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
 2038b30:	0001883a 	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 2038b34:	00000306 	br	2038b44 <tcp_receive+0x1f7c>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
 2038b38:	e13ffe17 	ldw	r4,-8(fp)
 2038b3c:	201f5e40 	call	201f5e4 <tcp_send_empty_ack>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 2038b40:	00001706 	br	2038ba0 <tcp_receive+0x1fd8>
 2038b44:	00001606 	br	2038ba0 <tcp_receive+0x1fd8>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 2038b48:	d0e81b17 	ldw	r3,-24468(gp)
 2038b4c:	e0bffe17 	ldw	r2,-8(fp)
 2038b50:	10800b17 	ldw	r2,44(r2)
 2038b54:	1885c83a 	sub	r2,r3,r2
 2038b58:	10000a16 	blt	r2,zero,2038b84 <tcp_receive+0x1fbc>
 2038b5c:	d0e81b17 	ldw	r3,-24468(gp)
 2038b60:	e0bffe17 	ldw	r2,-8(fp)
 2038b64:	11000b17 	ldw	r4,44(r2)
 2038b68:	e0bffe17 	ldw	r2,-8(fp)
 2038b6c:	10800c0b 	ldhu	r2,48(r2)
 2038b70:	10bfffcc 	andi	r2,r2,65535
 2038b74:	2085883a 	add	r2,r4,r2
 2038b78:	1885c83a 	sub	r2,r3,r2
 2038b7c:	10800044 	addi	r2,r2,1
 2038b80:	0080070e 	bge	zero,r2,2038ba0 <tcp_receive+0x1fd8>
      tcp_ack_now(pcb);
 2038b84:	e0bffe17 	ldw	r2,-8(fp)
 2038b88:	10800883 	ldbu	r2,34(r2)
 2038b8c:	10800094 	ori	r2,r2,2
 2038b90:	1007883a 	mov	r3,r2
 2038b94:	e0bffe17 	ldw	r2,-8(fp)
 2038b98:	10c00885 	stb	r3,34(r2)
    }
  }
}
 2038b9c:	00000006 	br	2038ba0 <tcp_receive+0x1fd8>
 2038ba0:	0001883a 	nop
 2038ba4:	e6ffff04 	addi	sp,fp,-4
 2038ba8:	dfc00217 	ldw	ra,8(sp)
 2038bac:	df000117 	ldw	fp,4(sp)
 2038bb0:	dc000017 	ldw	r16,0(sp)
 2038bb4:	dec00304 	addi	sp,sp,12
 2038bb8:	f800283a 	ret

02038bbc <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
 2038bbc:	defffa04 	addi	sp,sp,-24
 2038bc0:	df000515 	stw	fp,20(sp)
 2038bc4:	df000504 	addi	fp,sp,20
 2038bc8:	e13fff15 	stw	r4,-4(fp)
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 2038bcc:	d0a81917 	ldw	r2,-24476(gp)
 2038bd0:	10800504 	addi	r2,r2,20
 2038bd4:	e0bffc15 	stw	r2,-16(fp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 2038bd8:	d0a81917 	ldw	r2,-24476(gp)
 2038bdc:	10c00303 	ldbu	r3,12(r2)
 2038be0:	10800343 	ldbu	r2,13(r2)
 2038be4:	1004923a 	slli	r2,r2,8
 2038be8:	10c4b03a 	or	r2,r2,r3
 2038bec:	10bfffcc 	andi	r2,r2,65535
 2038bf0:	1004d23a 	srli	r2,r2,8
 2038bf4:	10ffffcc 	andi	r3,r2,65535
 2038bf8:	d0a81917 	ldw	r2,-24476(gp)
 2038bfc:	11000303 	ldbu	r4,12(r2)
 2038c00:	10800343 	ldbu	r2,13(r2)
 2038c04:	1004923a 	slli	r2,r2,8
 2038c08:	1104b03a 	or	r2,r2,r4
 2038c0c:	10bfffcc 	andi	r2,r2,65535
 2038c10:	1004923a 	slli	r2,r2,8
 2038c14:	10bfffcc 	andi	r2,r2,65535
 2038c18:	1884b03a 	or	r2,r3,r2
 2038c1c:	1005d33a 	srai	r2,r2,12
 2038c20:	10800190 	cmplti	r2,r2,6
 2038c24:	10006b1e 	bne	r2,zero,2038dd4 <tcp_parseopt+0x218>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 2038c28:	d0a81917 	ldw	r2,-24476(gp)
 2038c2c:	10c00303 	ldbu	r3,12(r2)
 2038c30:	10800343 	ldbu	r2,13(r2)
 2038c34:	1004923a 	slli	r2,r2,8
 2038c38:	10c4b03a 	or	r2,r2,r3
 2038c3c:	10bfffcc 	andi	r2,r2,65535
 2038c40:	1004d23a 	srli	r2,r2,8
 2038c44:	10ffffcc 	andi	r3,r2,65535
 2038c48:	d0a81917 	ldw	r2,-24476(gp)
 2038c4c:	11000303 	ldbu	r4,12(r2)
 2038c50:	10800343 	ldbu	r2,13(r2)
 2038c54:	1004923a 	slli	r2,r2,8
 2038c58:	1104b03a 	or	r2,r2,r4
 2038c5c:	10bfffcc 	andi	r2,r2,65535
 2038c60:	1004923a 	slli	r2,r2,8
 2038c64:	10bfffcc 	andi	r2,r2,65535
 2038c68:	1884b03a 	or	r2,r3,r2
 2038c6c:	1005d33a 	srai	r2,r2,12
 2038c70:	10bffec4 	addi	r2,r2,-5
 2038c74:	1085883a 	add	r2,r2,r2
 2038c78:	1085883a 	add	r2,r2,r2
 2038c7c:	e0bffd0d 	sth	r2,-12(fp)
    for (c = 0; c < max_c; ) {
 2038c80:	e03ffb0d 	sth	zero,-20(fp)
 2038c84:	00004a06 	br	2038db0 <tcp_parseopt+0x1f4>
      opt = opts[c];
 2038c88:	e0bffb0b 	ldhu	r2,-20(fp)
 2038c8c:	e0fffc17 	ldw	r3,-16(fp)
 2038c90:	1885883a 	add	r2,r3,r2
 2038c94:	10800003 	ldbu	r2,0(r2)
 2038c98:	e0bffd85 	stb	r2,-10(fp)
      switch (opt) {
 2038c9c:	e0bffd83 	ldbu	r2,-10(fp)
 2038ca0:	10c00060 	cmpeqi	r3,r2,1
 2038ca4:	1800041e 	bne	r3,zero,2038cb8 <tcp_parseopt+0xfc>
 2038ca8:	10c000a0 	cmpeqi	r3,r2,2
 2038cac:	1800061e 	bne	r3,zero,2038cc8 <tcp_parseopt+0x10c>
 2038cb0:	10004326 	beq	r2,zero,2038dc0 <tcp_parseopt+0x204>
 2038cb4:	00002e06 	br	2038d70 <tcp_parseopt+0x1b4>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 2038cb8:	e0bffb0b 	ldhu	r2,-20(fp)
 2038cbc:	10800044 	addi	r2,r2,1
 2038cc0:	e0bffb0d 	sth	r2,-20(fp)
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
 2038cc4:	00003a06 	br	2038db0 <tcp_parseopt+0x1f4>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 2038cc8:	e0bffb0b 	ldhu	r2,-20(fp)
 2038ccc:	10800044 	addi	r2,r2,1
 2038cd0:	e0fffc17 	ldw	r3,-16(fp)
 2038cd4:	1885883a 	add	r2,r3,r2
 2038cd8:	10800003 	ldbu	r2,0(r2)
 2038cdc:	10803fcc 	andi	r2,r2,255
 2038ce0:	10800118 	cmpnei	r2,r2,4
 2038ce4:	1000381e 	bne	r2,zero,2038dc8 <tcp_parseopt+0x20c>
 2038ce8:	e0bffb0b 	ldhu	r2,-20(fp)
 2038cec:	10800104 	addi	r2,r2,4
 2038cf0:	e0fffd0b 	ldhu	r3,-12(fp)
 2038cf4:	18803416 	blt	r3,r2,2038dc8 <tcp_parseopt+0x20c>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 2038cf8:	e0bffb0b 	ldhu	r2,-20(fp)
 2038cfc:	10800084 	addi	r2,r2,2
 2038d00:	e0fffc17 	ldw	r3,-16(fp)
 2038d04:	1885883a 	add	r2,r3,r2
 2038d08:	10800003 	ldbu	r2,0(r2)
 2038d0c:	10803fcc 	andi	r2,r2,255
 2038d10:	1004923a 	slli	r2,r2,8
 2038d14:	1009883a 	mov	r4,r2
 2038d18:	e0bffb0b 	ldhu	r2,-20(fp)
 2038d1c:	108000c4 	addi	r2,r2,3
 2038d20:	e0fffc17 	ldw	r3,-16(fp)
 2038d24:	1885883a 	add	r2,r3,r2
 2038d28:	10800003 	ldbu	r2,0(r2)
 2038d2c:	10803fcc 	andi	r2,r2,255
 2038d30:	2084b03a 	or	r2,r4,r2
 2038d34:	e0bffe0d 	sth	r2,-8(fp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 2038d38:	e0bffe0b 	ldhu	r2,-8(fp)
 2038d3c:	10816d68 	cmpgeui	r2,r2,1461
 2038d40:	1000041e 	bne	r2,zero,2038d54 <tcp_parseopt+0x198>
 2038d44:	e0bffe0b 	ldhu	r2,-8(fp)
 2038d48:	10000226 	beq	r2,zero,2038d54 <tcp_parseopt+0x198>
 2038d4c:	e0bffe0b 	ldhu	r2,-8(fp)
 2038d50:	00000106 	br	2038d58 <tcp_parseopt+0x19c>
 2038d54:	00816d04 	movi	r2,1460
 2038d58:	e0ffff17 	ldw	r3,-4(fp)
 2038d5c:	18800e8d 	sth	r2,58(r3)
        /* Advance to next option */
        c += 0x04;
 2038d60:	e0bffb0b 	ldhu	r2,-20(fp)
 2038d64:	10800104 	addi	r2,r2,4
 2038d68:	e0bffb0d 	sth	r2,-20(fp)
        break;
 2038d6c:	00001006 	br	2038db0 <tcp_parseopt+0x1f4>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 2038d70:	e0bffb0b 	ldhu	r2,-20(fp)
 2038d74:	10800044 	addi	r2,r2,1
 2038d78:	e0fffc17 	ldw	r3,-16(fp)
 2038d7c:	1885883a 	add	r2,r3,r2
 2038d80:	10800003 	ldbu	r2,0(r2)
 2038d84:	10803fcc 	andi	r2,r2,255
 2038d88:	10001126 	beq	r2,zero,2038dd0 <tcp_parseopt+0x214>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 2038d8c:	e0bffb0b 	ldhu	r2,-20(fp)
 2038d90:	10800044 	addi	r2,r2,1
 2038d94:	e0fffc17 	ldw	r3,-16(fp)
 2038d98:	1885883a 	add	r2,r3,r2
 2038d9c:	10800003 	ldbu	r2,0(r2)
 2038da0:	10c03fcc 	andi	r3,r2,255
 2038da4:	e0bffb0b 	ldhu	r2,-20(fp)
 2038da8:	1885883a 	add	r2,r3,r2
 2038dac:	e0bffb0d 	sth	r2,-20(fp)
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 2038db0:	e0fffb0b 	ldhu	r3,-20(fp)
 2038db4:	e0bffd0b 	ldhu	r2,-12(fp)
 2038db8:	18bfb336 	bltu	r3,r2,2038c88 <__alt_mem_mem_0+0xfd018c88>
 2038dbc:	00000506 	br	2038dd4 <tcp_parseopt+0x218>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
 2038dc0:	0001883a 	nop
 2038dc4:	00000306 	br	2038dd4 <tcp_parseopt+0x218>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
 2038dc8:	0001883a 	nop
 2038dcc:	00000106 	br	2038dd4 <tcp_parseopt+0x218>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
 2038dd0:	0001883a 	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
 2038dd4:	e037883a 	mov	sp,fp
 2038dd8:	df000017 	ldw	fp,0(sp)
 2038ddc:	dec00104 	addi	sp,sp,4
 2038de0:	f800283a 	ret

02038de4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 2038de4:	defffa04 	addi	sp,sp,-24
 2038de8:	dfc00515 	stw	ra,20(sp)
 2038dec:	df000415 	stw	fp,16(sp)
 2038df0:	df000404 	addi	fp,sp,16
 2038df4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 2038df8:	008000c4 	movi	r2,3
 2038dfc:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 2038e00:	e0fffd17 	ldw	r3,-12(fp)
 2038e04:	008003f4 	movhi	r2,15
 2038e08:	10909004 	addi	r2,r2,16960
 2038e0c:	1885383a 	mul	r2,r3,r2
 2038e10:	100b883a 	mov	r5,r2
 2038e14:	01017db4 	movhi	r4,1526
 2038e18:	21384004 	addi	r4,r4,-7936
 2038e1c:	200aca80 	call	200aca8 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 2038e20:	100b883a 	mov	r5,r2
 2038e24:	01200034 	movhi	r4,32768
 2038e28:	213fffc4 	addi	r4,r4,-1
 2038e2c:	200aca80 	call	200aca8 <__udivsi3>
 2038e30:	100b883a 	mov	r5,r2
 2038e34:	e13fff17 	ldw	r4,-4(fp)
 2038e38:	200aca80 	call	200aca8 <__udivsi3>
 2038e3c:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 2038e40:	e0bffe17 	ldw	r2,-8(fp)
 2038e44:	10002a26 	beq	r2,zero,2038ef0 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 2038e48:	e03ffc15 	stw	zero,-16(fp)
 2038e4c:	00001706 	br	2038eac <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 2038e50:	00a00034 	movhi	r2,32768
 2038e54:	10bfffc4 	addi	r2,r2,-1
 2038e58:	10bfffc4 	addi	r2,r2,-1
 2038e5c:	103ffe1e 	bne	r2,zero,2038e58 <__alt_mem_mem_0+0xfd018e58>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 2038e60:	e0fffd17 	ldw	r3,-12(fp)
 2038e64:	008003f4 	movhi	r2,15
 2038e68:	10909004 	addi	r2,r2,16960
 2038e6c:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 2038e70:	100b883a 	mov	r5,r2
 2038e74:	01017db4 	movhi	r4,1526
 2038e78:	21384004 	addi	r4,r4,-7936
 2038e7c:	200aca80 	call	200aca8 <__udivsi3>
 2038e80:	100b883a 	mov	r5,r2
 2038e84:	01200034 	movhi	r4,32768
 2038e88:	213fffc4 	addi	r4,r4,-1
 2038e8c:	200aca80 	call	200aca8 <__udivsi3>
 2038e90:	1007883a 	mov	r3,r2
 2038e94:	e0bfff17 	ldw	r2,-4(fp)
 2038e98:	10c5c83a 	sub	r2,r2,r3
 2038e9c:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 2038ea0:	e0bffc17 	ldw	r2,-16(fp)
 2038ea4:	10800044 	addi	r2,r2,1
 2038ea8:	e0bffc15 	stw	r2,-16(fp)
 2038eac:	e0fffc17 	ldw	r3,-16(fp)
 2038eb0:	e0bffe17 	ldw	r2,-8(fp)
 2038eb4:	18bfe616 	blt	r3,r2,2038e50 <__alt_mem_mem_0+0xfd018e50>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 2038eb8:	e0fffd17 	ldw	r3,-12(fp)
 2038ebc:	008003f4 	movhi	r2,15
 2038ec0:	10909004 	addi	r2,r2,16960
 2038ec4:	1885383a 	mul	r2,r3,r2
 2038ec8:	100b883a 	mov	r5,r2
 2038ecc:	01017db4 	movhi	r4,1526
 2038ed0:	21384004 	addi	r4,r4,-7936
 2038ed4:	200aca80 	call	200aca8 <__udivsi3>
 2038ed8:	1007883a 	mov	r3,r2
 2038edc:	e0bfff17 	ldw	r2,-4(fp)
 2038ee0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 2038ee4:	10bfffc4 	addi	r2,r2,-1
 2038ee8:	103ffe1e 	bne	r2,zero,2038ee4 <__alt_mem_mem_0+0xfd018ee4>
 2038eec:	00000d06 	br	2038f24 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 2038ef0:	e0fffd17 	ldw	r3,-12(fp)
 2038ef4:	008003f4 	movhi	r2,15
 2038ef8:	10909004 	addi	r2,r2,16960
 2038efc:	1885383a 	mul	r2,r3,r2
 2038f00:	100b883a 	mov	r5,r2
 2038f04:	01017db4 	movhi	r4,1526
 2038f08:	21384004 	addi	r4,r4,-7936
 2038f0c:	200aca80 	call	200aca8 <__udivsi3>
 2038f10:	1007883a 	mov	r3,r2
 2038f14:	e0bfff17 	ldw	r2,-4(fp)
 2038f18:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 2038f1c:	10bfffc4 	addi	r2,r2,-1
 2038f20:	00bffe16 	blt	zero,r2,2038f1c <__alt_mem_mem_0+0xfd018f1c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 2038f24:	0005883a 	mov	r2,zero
}
 2038f28:	e037883a 	mov	sp,fp
 2038f2c:	dfc00117 	ldw	ra,4(sp)
 2038f30:	df000017 	ldw	fp,0(sp)
 2038f34:	dec00204 	addi	sp,sp,8
 2038f38:	f800283a 	ret

02038f3c <alt_icache_flush>:
 * alt_icache_flush() is called to flush the instruction cache for a memory
 * region of length "len" bytes, starting at address "start".
 */

void alt_icache_flush (void* start, alt_u32 len)
{
 2038f3c:	defffb04 	addi	sp,sp,-20
 2038f40:	df000415 	stw	fp,16(sp)
 2038f44:	df000404 	addi	fp,sp,16
 2038f48:	e13ffe15 	stw	r4,-8(fp)
 2038f4c:	e17fff15 	stw	r5,-4(fp)

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
 2038f50:	e0bfff17 	ldw	r2,-4(fp)
 2038f54:	10900070 	cmpltui	r2,r2,16385
 2038f58:	1000021e 	bne	r2,zero,2038f64 <alt_icache_flush+0x28>
  {
    len = NIOS2_ICACHE_SIZE;
 2038f5c:	00900004 	movi	r2,16384
 2038f60:	e0bfff15 	stw	r2,-4(fp)
  }

  end = ((char*) start) + len;
 2038f64:	e0fffe17 	ldw	r3,-8(fp)
 2038f68:	e0bfff17 	ldw	r2,-4(fp)
 2038f6c:	1885883a 	add	r2,r3,r2
 2038f70:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 2038f74:	e0bffe17 	ldw	r2,-8(fp)
 2038f78:	e0bffc15 	stw	r2,-16(fp)
 2038f7c:	00000506 	br	2038f94 <alt_icache_flush+0x58>
  { 
    __asm__ volatile ("flushi %0" :: "r" (i)); 
 2038f80:	e0bffc17 	ldw	r2,-16(fp)
 2038f84:	1000603a 	flushi	r2
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
 2038f88:	e0bffc17 	ldw	r2,-16(fp)
 2038f8c:	10800804 	addi	r2,r2,32
 2038f90:	e0bffc15 	stw	r2,-16(fp)
 2038f94:	e0fffc17 	ldw	r3,-16(fp)
 2038f98:	e0bffd17 	ldw	r2,-12(fp)
 2038f9c:	18bff836 	bltu	r3,r2,2038f80 <__alt_mem_mem_0+0xfd018f80>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
 2038fa0:	e0bffe17 	ldw	r2,-8(fp)
 2038fa4:	108007cc 	andi	r2,r2,31
 2038fa8:	10000226 	beq	r2,zero,2038fb4 <alt_icache_flush+0x78>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
 2038fac:	e0bffc17 	ldw	r2,-16(fp)
 2038fb0:	1000603a 	flushi	r2
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
 2038fb4:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
 2038fb8:	0001883a 	nop
 2038fbc:	e037883a 	mov	sp,fp
 2038fc0:	df000017 	ldw	fp,0(sp)
 2038fc4:	dec00104 	addi	sp,sp,4
 2038fc8:	f800283a 	ret

02038fcc <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
 2038fcc:	defff404 	addi	sp,sp,-48
 2038fd0:	dfc00b15 	stw	ra,44(sp)
 2038fd4:	df000a15 	stw	fp,40(sp)
 2038fd8:	df000a04 	addi	fp,sp,40
 2038fdc:	e13ffd15 	stw	r4,-12(fp)
 2038fe0:	2805883a 	mov	r2,r5
 2038fe4:	e1bfff15 	stw	r6,-4(fp)
 2038fe8:	e0bffe05 	stb	r2,-8(fp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
 2038fec:	e17fff17 	ldw	r5,-4(fp)
 2038ff0:	e13ffd17 	ldw	r4,-12(fp)
 2038ff4:	203ac580 	call	203ac58 <netconn_alloc>
 2038ff8:	e0bff615 	stw	r2,-40(fp)
  if (conn != NULL) {
 2038ffc:	e0bff617 	ldw	r2,-40(fp)
 2039000:	10001b26 	beq	r2,zero,2039070 <netconn_new_with_proto_and_callback+0xa4>
    msg.function = do_newconn;
 2039004:	00808134 	movhi	r2,516
 2039008:	10aafe04 	addi	r2,r2,-21512
 203900c:	e0bff715 	stw	r2,-36(fp)
    msg.msg.msg.n.proto = proto;
 2039010:	e0bffe03 	ldbu	r2,-8(fp)
 2039014:	e0bffa05 	stb	r2,-24(fp)
    msg.msg.conn = conn;
 2039018:	e0bff617 	ldw	r2,-40(fp)
 203901c:	e0bff815 	stw	r2,-32(fp)
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 2039020:	e0bff704 	addi	r2,fp,-36
 2039024:	1009883a 	mov	r4,r2
 2039028:	20309cc0 	call	20309cc <tcpip_apimsg>
 203902c:	10803fcc 	andi	r2,r2,255
 2039030:	1080201c 	xori	r2,r2,128
 2039034:	10bfe004 	addi	r2,r2,-128
 2039038:	10000d26 	beq	r2,zero,2039070 <netconn_new_with_proto_and_callback+0xa4>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
 203903c:	e0bff617 	ldw	r2,-40(fp)
 2039040:	10800404 	addi	r2,r2,16
 2039044:	1009883a 	mov	r4,r2
 2039048:	2014ee00 	call	2014ee0 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 203904c:	e0bff617 	ldw	r2,-40(fp)
 2039050:	10800504 	addi	r2,r2,20
 2039054:	1009883a 	mov	r4,r2
 2039058:	20152d80 	call	20152d8 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 203905c:	e17ff617 	ldw	r5,-40(fp)
 2039060:	01000204 	movi	r4,8
 2039064:	20346000 	call	2034600 <memp_free>
      return NULL;
 2039068:	0005883a 	mov	r2,zero
 203906c:	00000106 	br	2039074 <netconn_new_with_proto_and_callback+0xa8>
    }
  }
  return conn;
 2039070:	e0bff617 	ldw	r2,-40(fp)
}
 2039074:	e037883a 	mov	sp,fp
 2039078:	dfc00117 	ldw	ra,4(sp)
 203907c:	df000017 	ldw	fp,0(sp)
 2039080:	dec00204 	addi	sp,sp,8
 2039084:	f800283a 	ret

02039088 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
 2039088:	defff704 	addi	sp,sp,-36
 203908c:	dfc00815 	stw	ra,32(sp)
 2039090:	df000715 	stw	fp,28(sp)
 2039094:	df000704 	addi	fp,sp,28
 2039098:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 203909c:	e0bfff17 	ldw	r2,-4(fp)
 20390a0:	1000021e 	bne	r2,zero,20390ac <netconn_delete+0x24>
    return ERR_OK;
 20390a4:	0005883a 	mov	r2,zero
 20390a8:	00000a06 	br	20390d4 <netconn_delete+0x4c>
  }

  msg.function = do_delconn;
 20390ac:	00808134 	movhi	r2,516
 20390b0:	10ac7804 	addi	r2,r2,-20000
 20390b4:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
 20390b8:	e0bfff17 	ldw	r2,-4(fp)
 20390bc:	e0bffa15 	stw	r2,-24(fp)
  tcpip_apimsg(&msg);
 20390c0:	e13ff904 	addi	r4,fp,-28
 20390c4:	20309cc0 	call	20309cc <tcpip_apimsg>

  netconn_free(conn);
 20390c8:	e13fff17 	ldw	r4,-4(fp)
 20390cc:	203ad840 	call	203ad84 <netconn_free>

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
 20390d0:	0005883a 	mov	r2,zero
}
 20390d4:	e037883a 	mov	sp,fp
 20390d8:	dfc00117 	ldw	ra,4(sp)
 20390dc:	df000017 	ldw	fp,0(sp)
 20390e0:	dec00204 	addi	sp,sp,8
 20390e4:	f800283a 	ret

020390e8 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
 20390e8:	defff304 	addi	sp,sp,-52
 20390ec:	dfc00c15 	stw	ra,48(sp)
 20390f0:	df000b15 	stw	fp,44(sp)
 20390f4:	df000b04 	addi	fp,sp,44
 20390f8:	e13ffc15 	stw	r4,-16(fp)
 20390fc:	e17ffd15 	stw	r5,-12(fp)
 2039100:	e1bffe15 	stw	r6,-8(fp)
 2039104:	3805883a 	mov	r2,r7
 2039108:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 203910c:	e0bffc17 	ldw	r2,-16(fp)
 2039110:	1000091e 	bne	r2,zero,2039138 <netconn_getaddr+0x50>
 2039114:	01c08134 	movhi	r7,516
 2039118:	39cda804 	addi	r7,r7,13984
 203911c:	01802304 	movi	r6,140
 2039120:	01408134 	movhi	r5,516
 2039124:	294dae04 	addi	r5,r5,14008
 2039128:	01008134 	movhi	r4,516
 203912c:	210db604 	addi	r4,r4,14040
 2039130:	2000bb00 	call	2000bb0 <printf>
 2039134:	003fff06 	br	2039134 <__alt_mem_mem_0+0xfd019134>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 2039138:	e0bffd17 	ldw	r2,-12(fp)
 203913c:	1000091e 	bne	r2,zero,2039164 <netconn_getaddr+0x7c>
 2039140:	01c08134 	movhi	r7,516
 2039144:	39cda804 	addi	r7,r7,13984
 2039148:	01802344 	movi	r6,141
 203914c:	01408134 	movhi	r5,516
 2039150:	294dc204 	addi	r5,r5,14088
 2039154:	01008134 	movhi	r4,516
 2039158:	210db604 	addi	r4,r4,14040
 203915c:	2000bb00 	call	2000bb0 <printf>
 2039160:	003fff06 	br	2039160 <__alt_mem_mem_0+0xfd019160>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 2039164:	e0bffe17 	ldw	r2,-8(fp)
 2039168:	1000091e 	bne	r2,zero,2039190 <netconn_getaddr+0xa8>
 203916c:	01c08134 	movhi	r7,516
 2039170:	39cda804 	addi	r7,r7,13984
 2039174:	01802384 	movi	r6,142
 2039178:	01408134 	movhi	r5,516
 203917c:	294dca04 	addi	r5,r5,14120
 2039180:	01008134 	movhi	r4,516
 2039184:	210db604 	addi	r4,r4,14040
 2039188:	2000bb00 	call	2000bb0 <printf>
 203918c:	003fff06 	br	203918c <__alt_mem_mem_0+0xfd01918c>

  msg.function = do_getaddr;
 2039190:	00808134 	movhi	r2,516
 2039194:	10b0aa04 	addi	r2,r2,-15704
 2039198:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
 203919c:	e0bffc17 	ldw	r2,-16(fp)
 20391a0:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.ad.ipaddr = addr;
 20391a4:	e0bffd17 	ldw	r2,-12(fp)
 20391a8:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.ad.port = port;
 20391ac:	e0bffe17 	ldw	r2,-8(fp)
 20391b0:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.ad.local = local;
 20391b4:	e0bfff03 	ldbu	r2,-4(fp)
 20391b8:	e0bffb05 	stb	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 20391bc:	e0bff604 	addi	r2,fp,-40
 20391c0:	1009883a 	mov	r4,r2
 20391c4:	20309cc0 	call	20309cc <tcpip_apimsg>
 20391c8:	e0bff505 	stb	r2,-44(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 20391cc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20391d0:	10000126 	beq	r2,zero,20391d8 <netconn_getaddr+0xf0>
 20391d4:	2010f300 	call	2010f30 <vTaskEnterCritical>
 20391d8:	e0bffc17 	ldw	r2,-16(fp)
 20391dc:	10800303 	ldbu	r2,12(r2)
 20391e0:	10803fcc 	andi	r2,r2,255
 20391e4:	1080201c 	xori	r2,r2,128
 20391e8:	10bfe004 	addi	r2,r2,-128
 20391ec:	10bffdd0 	cmplti	r2,r2,-9
 20391f0:	1000031e 	bne	r2,zero,2039200 <netconn_getaddr+0x118>
 20391f4:	e0bffc17 	ldw	r2,-16(fp)
 20391f8:	e0fff503 	ldbu	r3,-44(fp)
 20391fc:	10c00305 	stb	r3,12(r2)
 2039200:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039204:	10000126 	beq	r2,zero,203920c <netconn_getaddr+0x124>
 2039208:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 203920c:	e0bff503 	ldbu	r2,-44(fp)
}
 2039210:	e037883a 	mov	sp,fp
 2039214:	dfc00117 	ldw	ra,4(sp)
 2039218:	df000017 	ldw	fp,0(sp)
 203921c:	dec00204 	addi	sp,sp,8
 2039220:	f800283a 	ret

02039224 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 2039224:	defff404 	addi	sp,sp,-48
 2039228:	dfc00b15 	stw	ra,44(sp)
 203922c:	df000a15 	stw	fp,40(sp)
 2039230:	df000a04 	addi	fp,sp,40
 2039234:	e13ffd15 	stw	r4,-12(fp)
 2039238:	e17ffe15 	stw	r5,-8(fp)
 203923c:	3005883a 	mov	r2,r6
 2039240:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 2039244:	e0bffd17 	ldw	r2,-12(fp)
 2039248:	1000091e 	bne	r2,zero,2039270 <netconn_bind+0x4c>
 203924c:	01c08134 	movhi	r7,516
 2039250:	39cda804 	addi	r7,r7,13984
 2039254:	01802ac4 	movi	r6,171
 2039258:	01408134 	movhi	r5,516
 203925c:	294dd204 	addi	r5,r5,14152
 2039260:	01008134 	movhi	r4,516
 2039264:	210db604 	addi	r4,r4,14040
 2039268:	2000bb00 	call	2000bb0 <printf>
 203926c:	003fff06 	br	203926c <__alt_mem_mem_0+0xfd01926c>

  msg.function = do_bind;
 2039270:	00808134 	movhi	r2,516
 2039274:	10aced04 	addi	r2,r2,-19532
 2039278:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
 203927c:	e0bffd17 	ldw	r2,-12(fp)
 2039280:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
 2039284:	e0bffe17 	ldw	r2,-8(fp)
 2039288:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
 203928c:	e0bfff0b 	ldhu	r2,-4(fp)
 2039290:	e0bffb0d 	sth	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 2039294:	e0bff704 	addi	r2,fp,-36
 2039298:	1009883a 	mov	r4,r2
 203929c:	20309cc0 	call	20309cc <tcpip_apimsg>
 20392a0:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 20392a4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20392a8:	10000126 	beq	r2,zero,20392b0 <netconn_bind+0x8c>
 20392ac:	2010f300 	call	2010f30 <vTaskEnterCritical>
 20392b0:	e0bffd17 	ldw	r2,-12(fp)
 20392b4:	10800303 	ldbu	r2,12(r2)
 20392b8:	10803fcc 	andi	r2,r2,255
 20392bc:	1080201c 	xori	r2,r2,128
 20392c0:	10bfe004 	addi	r2,r2,-128
 20392c4:	10bffdd0 	cmplti	r2,r2,-9
 20392c8:	1000031e 	bne	r2,zero,20392d8 <netconn_bind+0xb4>
 20392cc:	e0bffd17 	ldw	r2,-12(fp)
 20392d0:	e0fff603 	ldbu	r3,-40(fp)
 20392d4:	10c00305 	stb	r3,12(r2)
 20392d8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20392dc:	10000126 	beq	r2,zero,20392e4 <netconn_bind+0xc0>
 20392e0:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 20392e4:	e0bff603 	ldbu	r2,-40(fp)
}
 20392e8:	e037883a 	mov	sp,fp
 20392ec:	dfc00117 	ldw	ra,4(sp)
 20392f0:	df000017 	ldw	fp,0(sp)
 20392f4:	dec00204 	addi	sp,sp,8
 20392f8:	f800283a 	ret

020392fc <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 20392fc:	defff404 	addi	sp,sp,-48
 2039300:	dfc00b15 	stw	ra,44(sp)
 2039304:	df000a15 	stw	fp,40(sp)
 2039308:	df000a04 	addi	fp,sp,40
 203930c:	e13ffd15 	stw	r4,-12(fp)
 2039310:	e17ffe15 	stw	r5,-8(fp)
 2039314:	3005883a 	mov	r2,r6
 2039318:	e0bfff0d 	sth	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 203931c:	e0bffd17 	ldw	r2,-12(fp)
 2039320:	1000091e 	bne	r2,zero,2039348 <netconn_connect+0x4c>
 2039324:	01c08134 	movhi	r7,516
 2039328:	39cda804 	addi	r7,r7,13984
 203932c:	01803144 	movi	r6,197
 2039330:	01408134 	movhi	r5,516
 2039334:	294dd904 	addi	r5,r5,14180
 2039338:	01008134 	movhi	r4,516
 203933c:	210db604 	addi	r4,r4,14040
 2039340:	2000bb00 	call	2000bb0 <printf>
 2039344:	003fff06 	br	2039344 <__alt_mem_mem_0+0xfd019344>

  msg.function = do_connect;
 2039348:	00808134 	movhi	r2,516
 203934c:	10ad9e04 	addi	r2,r2,-18824
 2039350:	e0bff715 	stw	r2,-36(fp)
  msg.msg.conn = conn;
 2039354:	e0bffd17 	ldw	r2,-12(fp)
 2039358:	e0bff815 	stw	r2,-32(fp)
  msg.msg.msg.bc.ipaddr = addr;
 203935c:	e0bffe17 	ldw	r2,-8(fp)
 2039360:	e0bffa15 	stw	r2,-24(fp)
  msg.msg.msg.bc.port = port;
 2039364:	e0bfff0b 	ldhu	r2,-4(fp)
 2039368:	e0bffb0d 	sth	r2,-20(fp)
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
 203936c:	e0bff704 	addi	r2,fp,-36
 2039370:	1009883a 	mov	r4,r2
 2039374:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039378:	e0bff605 	stb	r2,-40(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 203937c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039380:	10000126 	beq	r2,zero,2039388 <netconn_connect+0x8c>
 2039384:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039388:	e0bffd17 	ldw	r2,-12(fp)
 203938c:	10800303 	ldbu	r2,12(r2)
 2039390:	10803fcc 	andi	r2,r2,255
 2039394:	1080201c 	xori	r2,r2,128
 2039398:	10bfe004 	addi	r2,r2,-128
 203939c:	10bffdd0 	cmplti	r2,r2,-9
 20393a0:	1000031e 	bne	r2,zero,20393b0 <netconn_connect+0xb4>
 20393a4:	e0bffd17 	ldw	r2,-12(fp)
 20393a8:	e0fff603 	ldbu	r3,-40(fp)
 20393ac:	10c00305 	stb	r3,12(r2)
 20393b0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20393b4:	10000126 	beq	r2,zero,20393bc <netconn_connect+0xc0>
 20393b8:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 20393bc:	e0bff603 	ldbu	r2,-40(fp)
}
 20393c0:	e037883a 	mov	sp,fp
 20393c4:	dfc00117 	ldw	ra,4(sp)
 20393c8:	df000017 	ldw	fp,0(sp)
 20393cc:	dec00204 	addi	sp,sp,8
 20393d0:	f800283a 	ret

020393d4 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
 20393d4:	defff604 	addi	sp,sp,-40
 20393d8:	dfc00915 	stw	ra,36(sp)
 20393dc:	df000815 	stw	fp,32(sp)
 20393e0:	df000804 	addi	fp,sp,32
 20393e4:	e13fff15 	stw	r4,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 20393e8:	e0bfff17 	ldw	r2,-4(fp)
 20393ec:	1000091e 	bne	r2,zero,2039414 <netconn_disconnect+0x40>
 20393f0:	01c08134 	movhi	r7,516
 20393f4:	39cda804 	addi	r7,r7,13984
 20393f8:	01803784 	movi	r6,222
 20393fc:	01408134 	movhi	r5,516
 2039400:	294de104 	addi	r5,r5,14212
 2039404:	01008134 	movhi	r4,516
 2039408:	210db604 	addi	r4,r4,14040
 203940c:	2000bb00 	call	2000bb0 <printf>
 2039410:	003fff06 	br	2039410 <__alt_mem_mem_0+0xfd019410>

  msg.function = do_disconnect;
 2039414:	00808134 	movhi	r2,516
 2039418:	10ae3104 	addi	r2,r2,-18236
 203941c:	e0bff915 	stw	r2,-28(fp)
  msg.msg.conn = conn;
 2039420:	e0bfff17 	ldw	r2,-4(fp)
 2039424:	e0bffa15 	stw	r2,-24(fp)
  err = TCPIP_APIMSG(&msg);
 2039428:	e0bff904 	addi	r2,fp,-28
 203942c:	1009883a 	mov	r4,r2
 2039430:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039434:	e0bff805 	stb	r2,-32(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 2039438:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203943c:	10000126 	beq	r2,zero,2039444 <netconn_disconnect+0x70>
 2039440:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039444:	e0bfff17 	ldw	r2,-4(fp)
 2039448:	10800303 	ldbu	r2,12(r2)
 203944c:	10803fcc 	andi	r2,r2,255
 2039450:	1080201c 	xori	r2,r2,128
 2039454:	10bfe004 	addi	r2,r2,-128
 2039458:	10bffdd0 	cmplti	r2,r2,-9
 203945c:	1000031e 	bne	r2,zero,203946c <netconn_disconnect+0x98>
 2039460:	e0bfff17 	ldw	r2,-4(fp)
 2039464:	e0fff803 	ldbu	r3,-32(fp)
 2039468:	10c00305 	stb	r3,12(r2)
 203946c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039470:	10000126 	beq	r2,zero,2039478 <netconn_disconnect+0xa4>
 2039474:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 2039478:	e0bff803 	ldbu	r2,-32(fp)
}
 203947c:	e037883a 	mov	sp,fp
 2039480:	dfc00117 	ldw	ra,4(sp)
 2039484:	df000017 	ldw	fp,0(sp)
 2039488:	dec00204 	addi	sp,sp,8
 203948c:	f800283a 	ret

02039490 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 2039490:	defff504 	addi	sp,sp,-44
 2039494:	dfc00a15 	stw	ra,40(sp)
 2039498:	df000915 	stw	fp,36(sp)
 203949c:	df000904 	addi	fp,sp,36
 20394a0:	e13ffe15 	stw	r4,-8(fp)
 20394a4:	2805883a 	mov	r2,r5
 20394a8:	e0bfff05 	stb	r2,-4(fp)
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 20394ac:	e0bffe17 	ldw	r2,-8(fp)
 20394b0:	1000091e 	bne	r2,zero,20394d8 <netconn_listen_with_backlog+0x48>
 20394b4:	01c08134 	movhi	r7,516
 20394b8:	39cda804 	addi	r7,r7,13984
 20394bc:	01803e84 	movi	r6,250
 20394c0:	01408134 	movhi	r5,516
 20394c4:	294dea04 	addi	r5,r5,14248
 20394c8:	01008134 	movhi	r4,516
 20394cc:	210db604 	addi	r4,r4,14040
 20394d0:	2000bb00 	call	2000bb0 <printf>
 20394d4:	003fff06 	br	20394d4 <__alt_mem_mem_0+0xfd0194d4>

  msg.function = do_listen;
 20394d8:	00808134 	movhi	r2,516
 20394dc:	10ae5204 	addi	r2,r2,-18104
 20394e0:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 20394e4:	e0bffe17 	ldw	r2,-8(fp)
 20394e8:	e0bff915 	stw	r2,-28(fp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
 20394ec:	e0bfff03 	ldbu	r2,-4(fp)
 20394f0:	e0bffb05 	stb	r2,-20(fp)
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 20394f4:	e0bff804 	addi	r2,fp,-32
 20394f8:	1009883a 	mov	r4,r2
 20394fc:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039500:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 2039504:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039508:	10000126 	beq	r2,zero,2039510 <netconn_listen_with_backlog+0x80>
 203950c:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039510:	e0bffe17 	ldw	r2,-8(fp)
 2039514:	10800303 	ldbu	r2,12(r2)
 2039518:	10803fcc 	andi	r2,r2,255
 203951c:	1080201c 	xori	r2,r2,128
 2039520:	10bfe004 	addi	r2,r2,-128
 2039524:	10bffdd0 	cmplti	r2,r2,-9
 2039528:	1000031e 	bne	r2,zero,2039538 <netconn_listen_with_backlog+0xa8>
 203952c:	e0bffe17 	ldw	r2,-8(fp)
 2039530:	e0fff703 	ldbu	r3,-36(fp)
 2039534:	10c00305 	stb	r3,12(r2)
 2039538:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203953c:	10000126 	beq	r2,zero,2039544 <netconn_listen_with_backlog+0xb4>
 2039540:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 2039544:	e0bff703 	ldbu	r2,-36(fp)
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 2039548:	e037883a 	mov	sp,fp
 203954c:	dfc00117 	ldw	ra,4(sp)
 2039550:	df000017 	ldw	fp,0(sp)
 2039554:	dec00204 	addi	sp,sp,8
 2039558:	f800283a 	ret

0203955c <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 203955c:	defff404 	addi	sp,sp,-48
 2039560:	dfc00b15 	stw	ra,44(sp)
 2039564:	df000a15 	stw	fp,40(sp)
 2039568:	df000a04 	addi	fp,sp,40
 203956c:	e13ffe15 	stw	r4,-8(fp)
 2039570:	e17fff15 	stw	r5,-4(fp)
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 2039574:	e0bfff17 	ldw	r2,-4(fp)
 2039578:	1000091e 	bne	r2,zero,20395a0 <netconn_accept+0x44>
 203957c:	01c08134 	movhi	r7,516
 2039580:	39cda804 	addi	r7,r7,13984
 2039584:	01804784 	movi	r6,286
 2039588:	01408134 	movhi	r5,516
 203958c:	294df204 	addi	r5,r5,14280
 2039590:	01008134 	movhi	r4,516
 2039594:	210db604 	addi	r4,r4,14040
 2039598:	2000bb00 	call	2000bb0 <printf>
 203959c:	003fff06 	br	203959c <__alt_mem_mem_0+0xfd01959c>
  *new_conn = NULL;
 20395a0:	e0bfff17 	ldw	r2,-4(fp)
 20395a4:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 20395a8:	e0bffe17 	ldw	r2,-8(fp)
 20395ac:	1000091e 	bne	r2,zero,20395d4 <netconn_accept+0x78>
 20395b0:	01c08134 	movhi	r7,516
 20395b4:	39cda804 	addi	r7,r7,13984
 20395b8:	01804804 	movi	r6,288
 20395bc:	01408134 	movhi	r5,516
 20395c0:	294dfa04 	addi	r5,r5,14312
 20395c4:	01008134 	movhi	r4,516
 20395c8:	210db604 	addi	r4,r4,14040
 20395cc:	2000bb00 	call	2000bb0 <printf>
 20395d0:	003fff06 	br	20395d0 <__alt_mem_mem_0+0xfd0195d0>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 20395d4:	e0bffe17 	ldw	r2,-8(fp)
 20395d8:	10800617 	ldw	r2,24(r2)
 20395dc:	1000091e 	bne	r2,zero,2039604 <netconn_accept+0xa8>
 20395e0:	01c08134 	movhi	r7,516
 20395e4:	39cda804 	addi	r7,r7,13984
 20395e8:	01804844 	movi	r6,289
 20395ec:	01408134 	movhi	r5,516
 20395f0:	294e0204 	addi	r5,r5,14344
 20395f4:	01008134 	movhi	r4,516
 20395f8:	210db604 	addi	r4,r4,14040
 20395fc:	2000bb00 	call	2000bb0 <printf>
 2039600:	003fff06 	br	2039600 <__alt_mem_mem_0+0xfd019600>

  err = conn->last_err;
 2039604:	e0bffe17 	ldw	r2,-8(fp)
 2039608:	10800303 	ldbu	r2,12(r2)
 203960c:	e0bff605 	stb	r2,-40(fp)
  if (ERR_IS_FATAL(err)) {
 2039610:	e0bff607 	ldb	r2,-40(fp)
 2039614:	10bffdc8 	cmpgei	r2,r2,-9
 2039618:	1000021e 	bne	r2,zero,2039624 <netconn_accept+0xc8>
    /* don't recv on fatal errors: this might block the application task
       waiting on acceptmbox forever! */
    return err;
 203961c:	e0bff603 	ldbu	r2,-40(fp)
 2039620:	00004706 	br	2039740 <netconn_accept+0x1e4>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 2039624:	e0bffe17 	ldw	r2,-8(fp)
 2039628:	10c00604 	addi	r3,r2,24
 203962c:	e0bffe17 	ldw	r2,-8(fp)
 2039630:	10800817 	ldw	r2,32(r2)
 2039634:	1009883a 	mov	r4,r2
 2039638:	e0bff704 	addi	r2,fp,-36
 203963c:	200d883a 	mov	r6,r4
 2039640:	100b883a 	mov	r5,r2
 2039644:	1809883a 	mov	r4,r3
 2039648:	20153f80 	call	20153f8 <sys_arch_mbox_fetch>
 203964c:	10bfffd8 	cmpnei	r2,r2,-1
 2039650:	1000121e 	bne	r2,zero,203969c <netconn_accept+0x140>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
 2039654:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039658:	10000126 	beq	r2,zero,2039660 <netconn_accept+0x104>
 203965c:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039660:	e0bffe17 	ldw	r2,-8(fp)
 2039664:	10800303 	ldbu	r2,12(r2)
 2039668:	10803fcc 	andi	r2,r2,255
 203966c:	1080201c 	xori	r2,r2,128
 2039670:	10bfe004 	addi	r2,r2,-128
 2039674:	10bffdd0 	cmplti	r2,r2,-9
 2039678:	1000031e 	bne	r2,zero,2039688 <netconn_accept+0x12c>
 203967c:	e0bffe17 	ldw	r2,-8(fp)
 2039680:	00ffff44 	movi	r3,-3
 2039684:	10c00305 	stb	r3,12(r2)
 2039688:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203968c:	10000126 	beq	r2,zero,2039694 <netconn_accept+0x138>
 2039690:	2010f780 	call	2010f78 <vTaskExitCritical>
    return ERR_TIMEOUT;
 2039694:	00bfff44 	movi	r2,-3
 2039698:	00002906 	br	2039740 <netconn_accept+0x1e4>
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 203969c:	e0bffe17 	ldw	r2,-8(fp)
 20396a0:	10800c17 	ldw	r2,48(r2)
 20396a4:	10000626 	beq	r2,zero,20396c0 <netconn_accept+0x164>
 20396a8:	e0bffe17 	ldw	r2,-8(fp)
 20396ac:	10800c17 	ldw	r2,48(r2)
 20396b0:	000d883a 	mov	r6,zero
 20396b4:	01400044 	movi	r5,1
 20396b8:	e13ffe17 	ldw	r4,-8(fp)
 20396bc:	103ee83a 	callr	r2

  if (newconn == NULL) {
 20396c0:	e0bff717 	ldw	r2,-36(fp)
 20396c4:	1000121e 	bne	r2,zero,2039710 <netconn_accept+0x1b4>
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 20396c8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 20396cc:	10000126 	beq	r2,zero,20396d4 <netconn_accept+0x178>
 20396d0:	2010f300 	call	2010f30 <vTaskEnterCritical>
 20396d4:	e0bffe17 	ldw	r2,-8(fp)
 20396d8:	10800303 	ldbu	r2,12(r2)
 20396dc:	10803fcc 	andi	r2,r2,255
 20396e0:	1080201c 	xori	r2,r2,128
 20396e4:	10bfe004 	addi	r2,r2,-128
 20396e8:	10bffdd0 	cmplti	r2,r2,-9
 20396ec:	1000031e 	bne	r2,zero,20396fc <netconn_accept+0x1a0>
 20396f0:	e0bffe17 	ldw	r2,-8(fp)
 20396f4:	00fffd84 	movi	r3,-10
 20396f8:	10c00305 	stb	r3,12(r2)
 20396fc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039700:	10000126 	beq	r2,zero,2039708 <netconn_accept+0x1ac>
 2039704:	2010f780 	call	2010f78 <vTaskExitCritical>
    return ERR_ABRT;
 2039708:	00bffd84 	movi	r2,-10
 203970c:	00000c06 	br	2039740 <netconn_accept+0x1e4>
  }
#if TCP_LISTEN_BACKLOG
  /* Let the stack know that we have accepted the connection. */
  msg.function = do_recv;
 2039710:	00808134 	movhi	r2,516
 2039714:	10af6304 	addi	r2,r2,-17012
 2039718:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 203971c:	e0bffe17 	ldw	r2,-8(fp)
 2039720:	e0bff915 	stw	r2,-28(fp)
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
 2039724:	e0bff804 	addi	r2,fp,-32
 2039728:	1009883a 	mov	r4,r2
 203972c:	20309cc0 	call	20309cc <tcpip_apimsg>
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 2039730:	e0fff717 	ldw	r3,-36(fp)
 2039734:	e0bfff17 	ldw	r2,-4(fp)
 2039738:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 203973c:	0005883a 	mov	r2,zero
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 2039740:	e037883a 	mov	sp,fp
 2039744:	dfc00117 	ldw	ra,4(sp)
 2039748:	df000017 	ldw	fp,0(sp)
 203974c:	dec00204 	addi	sp,sp,8
 2039750:	f800283a 	ret

02039754 <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 2039754:	defff404 	addi	sp,sp,-48
 2039758:	dfc00b15 	stw	ra,44(sp)
 203975c:	df000a15 	stw	fp,40(sp)
 2039760:	df000a04 	addi	fp,sp,40
 2039764:	e13ffe15 	stw	r4,-8(fp)
 2039768:	e17fff15 	stw	r5,-4(fp)
  void *buf = NULL;
 203976c:	e03ff715 	stw	zero,-36(fp)
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 2039770:	e0bfff17 	ldw	r2,-4(fp)
 2039774:	1000091e 	bne	r2,zero,203979c <netconn_recv_data+0x48>
 2039778:	01c08134 	movhi	r7,516
 203977c:	39cda804 	addi	r7,r7,13984
 2039780:	018057c4 	movi	r6,351
 2039784:	01408134 	movhi	r5,516
 2039788:	294e0b04 	addi	r5,r5,14380
 203978c:	01008134 	movhi	r4,516
 2039790:	210db604 	addi	r4,r4,14040
 2039794:	2000bb00 	call	2000bb0 <printf>
 2039798:	003fff06 	br	2039798 <__alt_mem_mem_0+0xfd019798>
  *new_buf = NULL;
 203979c:	e0bfff17 	ldw	r2,-4(fp)
 20397a0:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 20397a4:	e0bffe17 	ldw	r2,-8(fp)
 20397a8:	1000091e 	bne	r2,zero,20397d0 <netconn_recv_data+0x7c>
 20397ac:	01c08134 	movhi	r7,516
 20397b0:	39cda804 	addi	r7,r7,13984
 20397b4:	01805844 	movi	r6,353
 20397b8:	01408134 	movhi	r5,516
 20397bc:	294e1304 	addi	r5,r5,14412
 20397c0:	01008134 	movhi	r4,516
 20397c4:	210db604 	addi	r4,r4,14040
 20397c8:	2000bb00 	call	2000bb0 <printf>
 20397cc:	003fff06 	br	20397cc <__alt_mem_mem_0+0xfd0197cc>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 20397d0:	e0bffe17 	ldw	r2,-8(fp)
 20397d4:	10800517 	ldw	r2,20(r2)
 20397d8:	1000091e 	bne	r2,zero,2039800 <netconn_recv_data+0xac>
 20397dc:	01c08134 	movhi	r7,516
 20397e0:	39cda804 	addi	r7,r7,13984
 20397e4:	01805884 	movi	r6,354
 20397e8:	01408134 	movhi	r5,516
 20397ec:	294e1a04 	addi	r5,r5,14440
 20397f0:	01008134 	movhi	r4,516
 20397f4:	210db604 	addi	r4,r4,14040
 20397f8:	2000bb00 	call	2000bb0 <printf>
 20397fc:	003fff06 	br	20397fc <__alt_mem_mem_0+0xfd0197fc>

  err = conn->last_err;
 2039800:	e0bffe17 	ldw	r2,-8(fp)
 2039804:	10800303 	ldbu	r2,12(r2)
 2039808:	e0bff685 	stb	r2,-38(fp)
  if (ERR_IS_FATAL(err)) {
 203980c:	e0bff687 	ldb	r2,-38(fp)
 2039810:	10bffdc8 	cmpgei	r2,r2,-9
 2039814:	1000021e 	bne	r2,zero,2039820 <netconn_recv_data+0xcc>
    /* don't recv on fatal errors: this might block the application task
       waiting on recvmbox forever! */
    /* @todo: this does not allow us to fetch data that has been put into recvmbox
       before the fatal error occurred - is that a problem? */
    return err;
 2039818:	e0bff683 	ldbu	r2,-38(fp)
 203981c:	00006d06 	br	20399d4 <netconn_recv_data+0x280>
  }

#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
 2039820:	e0bffe17 	ldw	r2,-8(fp)
 2039824:	10c00504 	addi	r3,r2,20
 2039828:	e0bffe17 	ldw	r2,-8(fp)
 203982c:	10800817 	ldw	r2,32(r2)
 2039830:	1009883a 	mov	r4,r2
 2039834:	e0bff704 	addi	r2,fp,-36
 2039838:	200d883a 	mov	r6,r4
 203983c:	100b883a 	mov	r5,r2
 2039840:	1809883a 	mov	r4,r3
 2039844:	20153f80 	call	20153f8 <sys_arch_mbox_fetch>
 2039848:	10bfffd8 	cmpnei	r2,r2,-1
 203984c:	1000121e 	bne	r2,zero,2039898 <netconn_recv_data+0x144>
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
 2039850:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039854:	10000126 	beq	r2,zero,203985c <netconn_recv_data+0x108>
 2039858:	2010f300 	call	2010f30 <vTaskEnterCritical>
 203985c:	e0bffe17 	ldw	r2,-8(fp)
 2039860:	10800303 	ldbu	r2,12(r2)
 2039864:	10803fcc 	andi	r2,r2,255
 2039868:	1080201c 	xori	r2,r2,128
 203986c:	10bfe004 	addi	r2,r2,-128
 2039870:	10bffdd0 	cmplti	r2,r2,-9
 2039874:	1000031e 	bne	r2,zero,2039884 <netconn_recv_data+0x130>
 2039878:	e0bffe17 	ldw	r2,-8(fp)
 203987c:	00ffff44 	movi	r3,-3
 2039880:	10c00305 	stb	r3,12(r2)
 2039884:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039888:	10000126 	beq	r2,zero,2039890 <netconn_recv_data+0x13c>
 203988c:	2010f780 	call	2010f78 <vTaskExitCritical>
    return ERR_TIMEOUT;
 2039890:	00bfff44 	movi	r2,-3
 2039894:	00004f06 	br	20399d4 <netconn_recv_data+0x280>
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 2039898:	e0bffe17 	ldw	r2,-8(fp)
 203989c:	10800017 	ldw	r2,0(r2)
 20398a0:	10800418 	cmpnei	r2,r2,16
 20398a4:	1000391e 	bne	r2,zero,203998c <netconn_recv_data+0x238>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 20398a8:	e0bffe17 	ldw	r2,-8(fp)
 20398ac:	10800903 	ldbu	r2,36(r2)
 20398b0:	10803fcc 	andi	r2,r2,255
 20398b4:	1080020c 	andi	r2,r2,8
 20398b8:	10000226 	beq	r2,zero,20398c4 <netconn_recv_data+0x170>
 20398bc:	e0bff717 	ldw	r2,-36(fp)
 20398c0:	1000111e 	bne	r2,zero,2039908 <netconn_recv_data+0x1b4>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 20398c4:	00808134 	movhi	r2,516
 20398c8:	10af6304 	addi	r2,r2,-17012
 20398cc:	e0bff815 	stw	r2,-32(fp)
      msg.msg.conn = conn;
 20398d0:	e0bffe17 	ldw	r2,-8(fp)
 20398d4:	e0bff915 	stw	r2,-28(fp)
      if (buf != NULL) {
 20398d8:	e0bff717 	ldw	r2,-36(fp)
 20398dc:	10000526 	beq	r2,zero,20398f4 <netconn_recv_data+0x1a0>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 20398e0:	e0bff717 	ldw	r2,-36(fp)
 20398e4:	1080020b 	ldhu	r2,8(r2)
 20398e8:	10bfffcc 	andi	r2,r2,65535
 20398ec:	e0bffb15 	stw	r2,-20(fp)
 20398f0:	00000206 	br	20398fc <netconn_recv_data+0x1a8>
      } else {
        msg.msg.msg.r.len = 1;
 20398f4:	00800044 	movi	r2,1
 20398f8:	e0bffb15 	stw	r2,-20(fp)
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
 20398fc:	e0bff804 	addi	r2,fp,-32
 2039900:	1009883a 	mov	r4,r2
 2039904:	20309cc0 	call	20309cc <tcpip_apimsg>
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
 2039908:	e0bff717 	ldw	r2,-36(fp)
 203990c:	10001b1e 	bne	r2,zero,203997c <netconn_recv_data+0x228>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 2039910:	e0bffe17 	ldw	r2,-8(fp)
 2039914:	10800c17 	ldw	r2,48(r2)
 2039918:	10000626 	beq	r2,zero,2039934 <netconn_recv_data+0x1e0>
 203991c:	e0bffe17 	ldw	r2,-8(fp)
 2039920:	10800c17 	ldw	r2,48(r2)
 2039924:	000d883a 	mov	r6,zero
 2039928:	01400044 	movi	r5,1
 203992c:	e13ffe17 	ldw	r4,-8(fp)
 2039930:	103ee83a 	callr	r2
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
 2039934:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039938:	10000126 	beq	r2,zero,2039940 <netconn_recv_data+0x1ec>
 203993c:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039940:	e0bffe17 	ldw	r2,-8(fp)
 2039944:	10800303 	ldbu	r2,12(r2)
 2039948:	10803fcc 	andi	r2,r2,255
 203994c:	1080201c 	xori	r2,r2,128
 2039950:	10bfe004 	addi	r2,r2,-128
 2039954:	10bffdd0 	cmplti	r2,r2,-9
 2039958:	1000031e 	bne	r2,zero,2039968 <netconn_recv_data+0x214>
 203995c:	e0bffe17 	ldw	r2,-8(fp)
 2039960:	00fffd04 	movi	r3,-12
 2039964:	10c00305 	stb	r3,12(r2)
 2039968:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203996c:	10000126 	beq	r2,zero,2039974 <netconn_recv_data+0x220>
 2039970:	2010f780 	call	2010f78 <vTaskExitCritical>
      return ERR_CLSD;
 2039974:	00bffd04 	movi	r2,-12
 2039978:	00001606 	br	20399d4 <netconn_recv_data+0x280>
    }
    len = ((struct pbuf *)buf)->tot_len;
 203997c:	e0bff717 	ldw	r2,-36(fp)
 2039980:	1080020b 	ldhu	r2,8(r2)
 2039984:	e0bff60d 	sth	r2,-40(fp)
 2039988:	00000406 	br	203999c <netconn_recv_data+0x248>
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
    len = netbuf_len((struct netbuf *)buf);
 203998c:	e0bff717 	ldw	r2,-36(fp)
 2039990:	10800017 	ldw	r2,0(r2)
 2039994:	1080020b 	ldhu	r2,8(r2)
 2039998:	e0bff60d 	sth	r2,-40(fp)

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 203999c:	e0bffe17 	ldw	r2,-8(fp)
 20399a0:	10800c17 	ldw	r2,48(r2)
 20399a4:	10000726 	beq	r2,zero,20399c4 <netconn_recv_data+0x270>
 20399a8:	e0bffe17 	ldw	r2,-8(fp)
 20399ac:	10800c17 	ldw	r2,48(r2)
 20399b0:	e0fff60b 	ldhu	r3,-40(fp)
 20399b4:	180d883a 	mov	r6,r3
 20399b8:	01400044 	movi	r5,1
 20399bc:	e13ffe17 	ldw	r4,-8(fp)
 20399c0:	103ee83a 	callr	r2

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 20399c4:	e0fff717 	ldw	r3,-36(fp)
 20399c8:	e0bfff17 	ldw	r2,-4(fp)
 20399cc:	10c00015 	stw	r3,0(r2)
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 20399d0:	0005883a 	mov	r2,zero
}
 20399d4:	e037883a 	mov	sp,fp
 20399d8:	dfc00117 	ldw	ra,4(sp)
 20399dc:	df000017 	ldw	fp,0(sp)
 20399e0:	dec00204 	addi	sp,sp,8
 20399e4:	f800283a 	ret

020399e8 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
 20399e8:	defffc04 	addi	sp,sp,-16
 20399ec:	dfc00315 	stw	ra,12(sp)
 20399f0:	df000215 	stw	fp,8(sp)
 20399f4:	df000204 	addi	fp,sp,8
 20399f8:	e13ffe15 	stw	r4,-8(fp)
 20399fc:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 2039a00:	e0bffe17 	ldw	r2,-8(fp)
 2039a04:	10000426 	beq	r2,zero,2039a18 <netconn_recv_tcp_pbuf+0x30>
 2039a08:	e0bffe17 	ldw	r2,-8(fp)
 2039a0c:	10800017 	ldw	r2,0(r2)
 2039a10:	10800420 	cmpeqi	r2,r2,16
 2039a14:	1000091e 	bne	r2,zero,2039a3c <netconn_recv_tcp_pbuf+0x54>
 2039a18:	01c08134 	movhi	r7,516
 2039a1c:	39cda804 	addi	r7,r7,13984
 2039a20:	01806e04 	movi	r6,440
 2039a24:	01408134 	movhi	r5,516
 2039a28:	294e1304 	addi	r5,r5,14412
 2039a2c:	01008134 	movhi	r4,516
 2039a30:	210db604 	addi	r4,r4,14040
 2039a34:	2000bb00 	call	2000bb0 <printf>
 2039a38:	003fff06 	br	2039a38 <__alt_mem_mem_0+0xfd019a38>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
 2039a3c:	e17fff17 	ldw	r5,-4(fp)
 2039a40:	e13ffe17 	ldw	r4,-8(fp)
 2039a44:	20397540 	call	2039754 <netconn_recv_data>
}
 2039a48:	e037883a 	mov	sp,fp
 2039a4c:	dfc00117 	ldw	ra,4(sp)
 2039a50:	df000017 	ldw	fp,0(sp)
 2039a54:	dec00204 	addi	sp,sp,8
 2039a58:	f800283a 	ret

02039a5c <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 2039a5c:	defff904 	addi	sp,sp,-28
 2039a60:	dfc00615 	stw	ra,24(sp)
 2039a64:	df000515 	stw	fp,20(sp)
 2039a68:	df000504 	addi	fp,sp,20
 2039a6c:	e13ffe15 	stw	r4,-8(fp)
 2039a70:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  struct netbuf *buf = NULL;
 2039a74:	e03ffb15 	stw	zero,-20(fp)
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 2039a78:	e0bfff17 	ldw	r2,-4(fp)
 2039a7c:	1000091e 	bne	r2,zero,2039aa4 <netconn_recv+0x48>
 2039a80:	01c08134 	movhi	r7,516
 2039a84:	39cda804 	addi	r7,r7,13984
 2039a88:	01807344 	movi	r6,461
 2039a8c:	01408134 	movhi	r5,516
 2039a90:	294e0b04 	addi	r5,r5,14380
 2039a94:	01008134 	movhi	r4,516
 2039a98:	210db604 	addi	r4,r4,14040
 2039a9c:	2000bb00 	call	2000bb0 <printf>
 2039aa0:	003fff06 	br	2039aa0 <__alt_mem_mem_0+0xfd019aa0>
  *new_buf = NULL;
 2039aa4:	e0bfff17 	ldw	r2,-4(fp)
 2039aa8:	10000015 	stw	zero,0(r2)
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 2039aac:	e0bffe17 	ldw	r2,-8(fp)
 2039ab0:	1000091e 	bne	r2,zero,2039ad8 <netconn_recv+0x7c>
 2039ab4:	01c08134 	movhi	r7,516
 2039ab8:	39cda804 	addi	r7,r7,13984
 2039abc:	018073c4 	movi	r6,463
 2039ac0:	01408134 	movhi	r5,516
 2039ac4:	294e1304 	addi	r5,r5,14412
 2039ac8:	01008134 	movhi	r4,516
 2039acc:	210db604 	addi	r4,r4,14040
 2039ad0:	2000bb00 	call	2000bb0 <printf>
 2039ad4:	003fff06 	br	2039ad4 <__alt_mem_mem_0+0xfd019ad4>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 2039ad8:	e0bffe17 	ldw	r2,-8(fp)
 2039adc:	10800517 	ldw	r2,20(r2)
 2039ae0:	1000091e 	bne	r2,zero,2039b08 <netconn_recv+0xac>
 2039ae4:	01c08134 	movhi	r7,516
 2039ae8:	39cda804 	addi	r7,r7,13984
 2039aec:	01807404 	movi	r6,464
 2039af0:	01408134 	movhi	r5,516
 2039af4:	294e1a04 	addi	r5,r5,14440
 2039af8:	01008134 	movhi	r4,516
 2039afc:	210db604 	addi	r4,r4,14040
 2039b00:	2000bb00 	call	2000bb0 <printf>
 2039b04:	003fff06 	br	2039b04 <__alt_mem_mem_0+0xfd019b04>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 2039b08:	e0bffe17 	ldw	r2,-8(fp)
 2039b0c:	10800017 	ldw	r2,0(r2)
 2039b10:	10800418 	cmpnei	r2,r2,16
 2039b14:	1000331e 	bne	r2,zero,2039be4 <netconn_recv+0x188>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 2039b18:	e03ffd15 	stw	zero,-12(fp)
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 2039b1c:	010001c4 	movi	r4,7
 2039b20:	20344340 	call	2034434 <memp_malloc>
 2039b24:	e0bffb15 	stw	r2,-20(fp)
    if (buf == NULL) {
 2039b28:	e0bffb17 	ldw	r2,-20(fp)
 2039b2c:	1000121e 	bne	r2,zero,2039b78 <netconn_recv+0x11c>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
 2039b30:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039b34:	10000126 	beq	r2,zero,2039b3c <netconn_recv+0xe0>
 2039b38:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039b3c:	e0bffe17 	ldw	r2,-8(fp)
 2039b40:	10800303 	ldbu	r2,12(r2)
 2039b44:	10803fcc 	andi	r2,r2,255
 2039b48:	1080201c 	xori	r2,r2,128
 2039b4c:	10bfe004 	addi	r2,r2,-128
 2039b50:	10bffdd0 	cmplti	r2,r2,-9
 2039b54:	1000031e 	bne	r2,zero,2039b64 <netconn_recv+0x108>
 2039b58:	e0bffe17 	ldw	r2,-8(fp)
 2039b5c:	00ffffc4 	movi	r3,-1
 2039b60:	10c00305 	stb	r3,12(r2)
 2039b64:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039b68:	10000126 	beq	r2,zero,2039b70 <netconn_recv+0x114>
 2039b6c:	2010f780 	call	2010f78 <vTaskExitCritical>
      return ERR_MEM;
 2039b70:	00bfffc4 	movi	r2,-1
 2039b74:	00001e06 	br	2039bf0 <netconn_recv+0x194>
    }

    err = netconn_recv_data(conn, (void **)&p);
 2039b78:	e0bffd04 	addi	r2,fp,-12
 2039b7c:	100b883a 	mov	r5,r2
 2039b80:	e13ffe17 	ldw	r4,-8(fp)
 2039b84:	20397540 	call	2039754 <netconn_recv_data>
 2039b88:	e0bffc05 	stb	r2,-16(fp)
    if (err != ERR_OK) {
 2039b8c:	e0bffc07 	ldb	r2,-16(fp)
 2039b90:	10000526 	beq	r2,zero,2039ba8 <netconn_recv+0x14c>
      memp_free(MEMP_NETBUF, buf);
 2039b94:	e17ffb17 	ldw	r5,-20(fp)
 2039b98:	010001c4 	movi	r4,7
 2039b9c:	20346000 	call	2034600 <memp_free>
      return err;
 2039ba0:	e0bffc03 	ldbu	r2,-16(fp)
 2039ba4:	00001206 	br	2039bf0 <netconn_recv+0x194>
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 2039ba8:	e0fffd17 	ldw	r3,-12(fp)
 2039bac:	e0bffb17 	ldw	r2,-20(fp)
 2039bb0:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 2039bb4:	e0fffd17 	ldw	r3,-12(fp)
 2039bb8:	e0bffb17 	ldw	r2,-20(fp)
 2039bbc:	10c00115 	stw	r3,4(r2)
    buf->port = 0;
 2039bc0:	e0bffb17 	ldw	r2,-20(fp)
 2039bc4:	1000030d 	sth	zero,12(r2)
    ip_addr_set_any(&buf->addr);
 2039bc8:	e0bffb17 	ldw	r2,-20(fp)
 2039bcc:	10000215 	stw	zero,8(r2)
    *new_buf = buf;
 2039bd0:	e0bfff17 	ldw	r2,-4(fp)
 2039bd4:	e0fffb17 	ldw	r3,-20(fp)
 2039bd8:	10c00015 	stw	r3,0(r2)
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
 2039bdc:	0005883a 	mov	r2,zero
 2039be0:	00000306 	br	2039bf0 <netconn_recv+0x194>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
 2039be4:	e17fff17 	ldw	r5,-4(fp)
 2039be8:	e13ffe17 	ldw	r4,-8(fp)
 2039bec:	20397540 	call	2039754 <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 2039bf0:	e037883a 	mov	sp,fp
 2039bf4:	dfc00117 	ldw	ra,4(sp)
 2039bf8:	df000017 	ldw	fp,0(sp)
 2039bfc:	dec00204 	addi	sp,sp,8
 2039c00:	f800283a 	ret

02039c04 <netconn_recved>:
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
 2039c04:	defff604 	addi	sp,sp,-40
 2039c08:	dfc00915 	stw	ra,36(sp)
 2039c0c:	df000815 	stw	fp,32(sp)
 2039c10:	df000804 	addi	fp,sp,32
 2039c14:	e13ffe15 	stw	r4,-8(fp)
 2039c18:	e17fff15 	stw	r5,-4(fp)
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 2039c1c:	e0bffe17 	ldw	r2,-8(fp)
 2039c20:	10001226 	beq	r2,zero,2039c6c <netconn_recved+0x68>
 2039c24:	e0bffe17 	ldw	r2,-8(fp)
 2039c28:	10800017 	ldw	r2,0(r2)
 2039c2c:	10800418 	cmpnei	r2,r2,16
 2039c30:	10000e1e 	bne	r2,zero,2039c6c <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
 2039c34:	e0bffe17 	ldw	r2,-8(fp)
 2039c38:	10800903 	ldbu	r2,36(r2)
 2039c3c:	10803fcc 	andi	r2,r2,255
 2039c40:	1080020c 	andi	r2,r2,8
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 2039c44:	10000926 	beq	r2,zero,2039c6c <netconn_recved+0x68>
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
 2039c48:	00808134 	movhi	r2,516
 2039c4c:	10af6304 	addi	r2,r2,-17012
 2039c50:	e0bff815 	stw	r2,-32(fp)
    msg.msg.conn = conn;
 2039c54:	e0bffe17 	ldw	r2,-8(fp)
 2039c58:	e0bff915 	stw	r2,-28(fp)
    msg.msg.msg.r.len = length;
 2039c5c:	e0bfff17 	ldw	r2,-4(fp)
 2039c60:	e0bffb15 	stw	r2,-20(fp)
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
 2039c64:	e13ff804 	addi	r4,fp,-32
 2039c68:	20309cc0 	call	20309cc <tcpip_apimsg>
  }
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
 2039c6c:	0001883a 	nop
 2039c70:	e037883a 	mov	sp,fp
 2039c74:	dfc00117 	ldw	ra,4(sp)
 2039c78:	df000017 	ldw	fp,0(sp)
 2039c7c:	dec00204 	addi	sp,sp,8
 2039c80:	f800283a 	ret

02039c84 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
{
 2039c84:	defffa04 	addi	sp,sp,-24
 2039c88:	dfc00515 	stw	ra,20(sp)
 2039c8c:	df000415 	stw	fp,16(sp)
 2039c90:	df000404 	addi	fp,sp,16
 2039c94:	e13ffc15 	stw	r4,-16(fp)
 2039c98:	e17ffd15 	stw	r5,-12(fp)
 2039c9c:	e1bffe15 	stw	r6,-8(fp)
 2039ca0:	3805883a 	mov	r2,r7
 2039ca4:	e0bfff0d 	sth	r2,-4(fp)
  if (buf != NULL) {
 2039ca8:	e0bffd17 	ldw	r2,-12(fp)
 2039cac:	10000f26 	beq	r2,zero,2039cec <netconn_sendto+0x68>
    ip_addr_set(&buf->addr, addr);
 2039cb0:	e0bffe17 	ldw	r2,-8(fp)
 2039cb4:	10000326 	beq	r2,zero,2039cc4 <netconn_sendto+0x40>
 2039cb8:	e0bffe17 	ldw	r2,-8(fp)
 2039cbc:	10800017 	ldw	r2,0(r2)
 2039cc0:	00000106 	br	2039cc8 <netconn_sendto+0x44>
 2039cc4:	0005883a 	mov	r2,zero
 2039cc8:	e0fffd17 	ldw	r3,-12(fp)
 2039ccc:	18800215 	stw	r2,8(r3)
    buf->port = port;
 2039cd0:	e0bffd17 	ldw	r2,-12(fp)
 2039cd4:	e0ffff0b 	ldhu	r3,-4(fp)
 2039cd8:	10c0030d 	sth	r3,12(r2)
    return netconn_send(conn, buf);
 2039cdc:	e17ffd17 	ldw	r5,-12(fp)
 2039ce0:	e13ffc17 	ldw	r4,-16(fp)
 2039ce4:	2039d040 	call	2039d04 <netconn_send>
 2039ce8:	00000106 	br	2039cf0 <netconn_sendto+0x6c>
  }
  return ERR_VAL;
 2039cec:	00bffe84 	movi	r2,-6
}
 2039cf0:	e037883a 	mov	sp,fp
 2039cf4:	dfc00117 	ldw	ra,4(sp)
 2039cf8:	df000017 	ldw	fp,0(sp)
 2039cfc:	dec00204 	addi	sp,sp,8
 2039d00:	f800283a 	ret

02039d04 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
 2039d04:	defff504 	addi	sp,sp,-44
 2039d08:	dfc00a15 	stw	ra,40(sp)
 2039d0c:	df000915 	stw	fp,36(sp)
 2039d10:	df000904 	addi	fp,sp,36
 2039d14:	e13ffe15 	stw	r4,-8(fp)
 2039d18:	e17fff15 	stw	r5,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 2039d1c:	e0bffe17 	ldw	r2,-8(fp)
 2039d20:	1000091e 	bne	r2,zero,2039d48 <netconn_send+0x44>
 2039d24:	01c08134 	movhi	r7,516
 2039d28:	39cda804 	addi	r7,r7,13984
 2039d2c:	01808f04 	movi	r6,572
 2039d30:	01408134 	movhi	r5,516
 2039d34:	294e2304 	addi	r5,r5,14476
 2039d38:	01008134 	movhi	r4,516
 2039d3c:	210db604 	addi	r4,r4,14040
 2039d40:	2000bb00 	call	2000bb0 <printf>
 2039d44:	003fff06 	br	2039d44 <__alt_mem_mem_0+0xfd019d44>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
 2039d48:	00808134 	movhi	r2,516
 2039d4c:	10aed204 	addi	r2,r2,-17592
 2039d50:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 2039d54:	e0bffe17 	ldw	r2,-8(fp)
 2039d58:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.b = buf;
 2039d5c:	e0bfff17 	ldw	r2,-4(fp)
 2039d60:	e0bffb15 	stw	r2,-20(fp)
  err = TCPIP_APIMSG(&msg);
 2039d64:	e0bff804 	addi	r2,fp,-32
 2039d68:	1009883a 	mov	r4,r2
 2039d6c:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039d70:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 2039d74:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039d78:	10000126 	beq	r2,zero,2039d80 <netconn_send+0x7c>
 2039d7c:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039d80:	e0bffe17 	ldw	r2,-8(fp)
 2039d84:	10800303 	ldbu	r2,12(r2)
 2039d88:	10803fcc 	andi	r2,r2,255
 2039d8c:	1080201c 	xori	r2,r2,128
 2039d90:	10bfe004 	addi	r2,r2,-128
 2039d94:	10bffdd0 	cmplti	r2,r2,-9
 2039d98:	1000031e 	bne	r2,zero,2039da8 <netconn_send+0xa4>
 2039d9c:	e0bffe17 	ldw	r2,-8(fp)
 2039da0:	e0fff703 	ldbu	r3,-36(fp)
 2039da4:	10c00305 	stb	r3,12(r2)
 2039da8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039dac:	10000126 	beq	r2,zero,2039db4 <netconn_send+0xb0>
 2039db0:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 2039db4:	e0bff703 	ldbu	r2,-36(fp)
}
 2039db8:	e037883a 	mov	sp,fp
 2039dbc:	dfc00117 	ldw	ra,4(sp)
 2039dc0:	df000017 	ldw	fp,0(sp)
 2039dc4:	dec00204 	addi	sp,sp,8
 2039dc8:	f800283a 	ret

02039dcc <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 2039dcc:	defff304 	addi	sp,sp,-52
 2039dd0:	dfc00c15 	stw	ra,48(sp)
 2039dd4:	df000b15 	stw	fp,44(sp)
 2039dd8:	df000b04 	addi	fp,sp,44
 2039ddc:	e13ffc15 	stw	r4,-16(fp)
 2039de0:	e17ffd15 	stw	r5,-12(fp)
 2039de4:	e1bffe15 	stw	r6,-8(fp)
 2039de8:	3805883a 	mov	r2,r7
 2039dec:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 2039df0:	e0bffc17 	ldw	r2,-16(fp)
 2039df4:	1000091e 	bne	r2,zero,2039e1c <netconn_write_partly+0x50>
 2039df8:	01c08134 	movhi	r7,516
 2039dfc:	39cda804 	addi	r7,r7,13984
 2039e00:	01809744 	movi	r6,605
 2039e04:	01408134 	movhi	r5,516
 2039e08:	294e2a04 	addi	r5,r5,14504
 2039e0c:	01008134 	movhi	r4,516
 2039e10:	210db604 	addi	r4,r4,14040
 2039e14:	2000bb00 	call	2000bb0 <printf>
 2039e18:	003fff06 	br	2039e18 <__alt_mem_mem_0+0xfd019e18>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 2039e1c:	e0bffc17 	ldw	r2,-16(fp)
 2039e20:	10800017 	ldw	r2,0(r2)
 2039e24:	10800420 	cmpeqi	r2,r2,16
 2039e28:	1000091e 	bne	r2,zero,2039e50 <netconn_write_partly+0x84>
 2039e2c:	01c08134 	movhi	r7,516
 2039e30:	39cda804 	addi	r7,r7,13984
 2039e34:	01809784 	movi	r6,606
 2039e38:	01408134 	movhi	r5,516
 2039e3c:	294e3104 	addi	r5,r5,14532
 2039e40:	01008134 	movhi	r4,516
 2039e44:	210db604 	addi	r4,r4,14040
 2039e48:	2000bb00 	call	2000bb0 <printf>
 2039e4c:	003fff06 	br	2039e4c <__alt_mem_mem_0+0xfd019e4c>
  if (size == 0) {
 2039e50:	e0bffe17 	ldw	r2,-8(fp)
 2039e54:	1000021e 	bne	r2,zero,2039e60 <netconn_write_partly+0x94>
    return ERR_OK;
 2039e58:	0005883a 	mov	r2,zero
 2039e5c:	00003f06 	br	2039f5c <netconn_write_partly+0x190>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 2039e60:	e0bffc17 	ldw	r2,-16(fp)
 2039e64:	10800903 	ldbu	r2,36(r2)
 2039e68:	10803fcc 	andi	r2,r2,255
 2039e6c:	1080008c 	andi	r2,r2,2
 2039e70:	1000031e 	bne	r2,zero,2039e80 <netconn_write_partly+0xb4>
 2039e74:	e0bfff03 	ldbu	r2,-4(fp)
 2039e78:	1080010c 	andi	r2,r2,4
 2039e7c:	10000226 	beq	r2,zero,2039e88 <netconn_write_partly+0xbc>
 2039e80:	00800044 	movi	r2,1
 2039e84:	00000106 	br	2039e8c <netconn_write_partly+0xc0>
 2039e88:	0005883a 	mov	r2,zero
 2039e8c:	e0bff505 	stb	r2,-44(fp)
  if (dontblock && !bytes_written) {
 2039e90:	e0bff503 	ldbu	r2,-44(fp)
 2039e94:	10000426 	beq	r2,zero,2039ea8 <netconn_write_partly+0xdc>
 2039e98:	e0800217 	ldw	r2,8(fp)
 2039e9c:	1000021e 	bne	r2,zero,2039ea8 <netconn_write_partly+0xdc>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 2039ea0:	00bffe84 	movi	r2,-6
 2039ea4:	00002d06 	br	2039f5c <netconn_write_partly+0x190>
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 2039ea8:	00808134 	movhi	r2,516
 2039eac:	10b06504 	addi	r2,r2,-15980
 2039eb0:	e0bff615 	stw	r2,-40(fp)
  msg.msg.conn = conn;
 2039eb4:	e0bffc17 	ldw	r2,-16(fp)
 2039eb8:	e0bff715 	stw	r2,-36(fp)
  msg.msg.msg.w.dataptr = dataptr;
 2039ebc:	e0bffd17 	ldw	r2,-12(fp)
 2039ec0:	e0bff915 	stw	r2,-28(fp)
  msg.msg.msg.w.apiflags = apiflags;
 2039ec4:	e0bfff03 	ldbu	r2,-4(fp)
 2039ec8:	e0bffb05 	stb	r2,-20(fp)
  msg.msg.msg.w.len = size;
 2039ecc:	e0bffe17 	ldw	r2,-8(fp)
 2039ed0:	e0bffa15 	stw	r2,-24(fp)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 2039ed4:	e0bff604 	addi	r2,fp,-40
 2039ed8:	1009883a 	mov	r4,r2
 2039edc:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039ee0:	e0bff545 	stb	r2,-43(fp)
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 2039ee4:	e0bff547 	ldb	r2,-43(fp)
 2039ee8:	10000b1e 	bne	r2,zero,2039f18 <netconn_write_partly+0x14c>
 2039eec:	e0800217 	ldw	r2,8(fp)
 2039ef0:	10000926 	beq	r2,zero,2039f18 <netconn_write_partly+0x14c>
    if (dontblock
 2039ef4:	e0bff503 	ldbu	r2,-44(fp)
 2039ef8:	10000426 	beq	r2,zero,2039f0c <netconn_write_partly+0x140>
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
 2039efc:	e0fffa17 	ldw	r3,-24(fp)
 2039f00:	e0800217 	ldw	r2,8(fp)
 2039f04:	10c00015 	stw	r3,0(r2)
 2039f08:	00000306 	br	2039f18 <netconn_write_partly+0x14c>
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
 2039f0c:	e0800217 	ldw	r2,8(fp)
 2039f10:	e0fffe17 	ldw	r3,-8(fp)
 2039f14:	10c00015 	stw	r3,0(r2)
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
 2039f18:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039f1c:	10000126 	beq	r2,zero,2039f24 <netconn_write_partly+0x158>
 2039f20:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039f24:	e0bffc17 	ldw	r2,-16(fp)
 2039f28:	10800303 	ldbu	r2,12(r2)
 2039f2c:	10803fcc 	andi	r2,r2,255
 2039f30:	1080201c 	xori	r2,r2,128
 2039f34:	10bfe004 	addi	r2,r2,-128
 2039f38:	10bffdd0 	cmplti	r2,r2,-9
 2039f3c:	1000031e 	bne	r2,zero,2039f4c <netconn_write_partly+0x180>
 2039f40:	e0bffc17 	ldw	r2,-16(fp)
 2039f44:	e0fff543 	ldbu	r3,-43(fp)
 2039f48:	10c00305 	stb	r3,12(r2)
 2039f4c:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039f50:	10000126 	beq	r2,zero,2039f58 <netconn_write_partly+0x18c>
 2039f54:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 2039f58:	e0bff543 	ldbu	r2,-43(fp)
}
 2039f5c:	e037883a 	mov	sp,fp
 2039f60:	dfc00117 	ldw	ra,4(sp)
 2039f64:	df000017 	ldw	fp,0(sp)
 2039f68:	dec00204 	addi	sp,sp,8
 2039f6c:	f800283a 	ret

02039f70 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 2039f70:	defff504 	addi	sp,sp,-44
 2039f74:	dfc00a15 	stw	ra,40(sp)
 2039f78:	df000915 	stw	fp,36(sp)
 2039f7c:	df000904 	addi	fp,sp,36
 2039f80:	e13ffe15 	stw	r4,-8(fp)
 2039f84:	2805883a 	mov	r2,r5
 2039f88:	e0bfff05 	stb	r2,-4(fp)
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 2039f8c:	e0bffe17 	ldw	r2,-8(fp)
 2039f90:	1000091e 	bne	r2,zero,2039fb8 <netconn_close_shutdown+0x48>
 2039f94:	01c08134 	movhi	r7,516
 2039f98:	39cda804 	addi	r7,r7,13984
 2039f9c:	0180a704 	movi	r6,668
 2039fa0:	01408134 	movhi	r5,516
 2039fa4:	294e3a04 	addi	r5,r5,14568
 2039fa8:	01008134 	movhi	r4,516
 2039fac:	210db604 	addi	r4,r4,14040
 2039fb0:	2000bb00 	call	2000bb0 <printf>
 2039fb4:	003fff06 	br	2039fb4 <__alt_mem_mem_0+0xfd019fb4>

  msg.function = do_close;
 2039fb8:	00808134 	movhi	r2,516
 2039fbc:	10b12004 	addi	r2,r2,-15232
 2039fc0:	e0bff815 	stw	r2,-32(fp)
  msg.msg.conn = conn;
 2039fc4:	e0bffe17 	ldw	r2,-8(fp)
 2039fc8:	e0bff915 	stw	r2,-28(fp)
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
 2039fcc:	e0bfff03 	ldbu	r2,-4(fp)
 2039fd0:	e0bffb05 	stb	r2,-20(fp)
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 2039fd4:	e0bff804 	addi	r2,fp,-32
 2039fd8:	1009883a 	mov	r4,r2
 2039fdc:	20309cc0 	call	20309cc <tcpip_apimsg>
 2039fe0:	e0bff705 	stb	r2,-36(fp)

  NETCONN_SET_SAFE_ERR(conn, err);
 2039fe4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 2039fe8:	10000126 	beq	r2,zero,2039ff0 <netconn_close_shutdown+0x80>
 2039fec:	2010f300 	call	2010f30 <vTaskEnterCritical>
 2039ff0:	e0bffe17 	ldw	r2,-8(fp)
 2039ff4:	10800303 	ldbu	r2,12(r2)
 2039ff8:	10803fcc 	andi	r2,r2,255
 2039ffc:	1080201c 	xori	r2,r2,128
 203a000:	10bfe004 	addi	r2,r2,-128
 203a004:	10bffdd0 	cmplti	r2,r2,-9
 203a008:	1000031e 	bne	r2,zero,203a018 <netconn_close_shutdown+0xa8>
 203a00c:	e0bffe17 	ldw	r2,-8(fp)
 203a010:	e0fff703 	ldbu	r3,-36(fp)
 203a014:	10c00305 	stb	r3,12(r2)
 203a018:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203a01c:	10000126 	beq	r2,zero,203a024 <netconn_close_shutdown+0xb4>
 203a020:	2010f780 	call	2010f78 <vTaskExitCritical>
  return err;
 203a024:	e0bff703 	ldbu	r2,-36(fp)
}
 203a028:	e037883a 	mov	sp,fp
 203a02c:	dfc00117 	ldw	ra,4(sp)
 203a030:	df000017 	ldw	fp,0(sp)
 203a034:	dec00204 	addi	sp,sp,8
 203a038:	f800283a 	ret

0203a03c <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
 203a03c:	defffd04 	addi	sp,sp,-12
 203a040:	dfc00215 	stw	ra,8(sp)
 203a044:	df000115 	stw	fp,4(sp)
 203a048:	df000104 	addi	fp,sp,4
 203a04c:	e13fff15 	stw	r4,-4(fp)
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 203a050:	014000c4 	movi	r5,3
 203a054:	e13fff17 	ldw	r4,-4(fp)
 203a058:	2039f700 	call	2039f70 <netconn_close_shutdown>
}
 203a05c:	e037883a 	mov	sp,fp
 203a060:	dfc00117 	ldw	ra,4(sp)
 203a064:	df000017 	ldw	fp,0(sp)
 203a068:	dec00204 	addi	sp,sp,8
 203a06c:	f800283a 	ret

0203a070 <netconn_shutdown>:
 * @param conn the TCP netconn to shut down
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
 203a070:	defffb04 	addi	sp,sp,-20
 203a074:	dfc00415 	stw	ra,16(sp)
 203a078:	df000315 	stw	fp,12(sp)
 203a07c:	df000304 	addi	fp,sp,12
 203a080:	e13ffd15 	stw	r4,-12(fp)
 203a084:	2807883a 	mov	r3,r5
 203a088:	3005883a 	mov	r2,r6
 203a08c:	e0fffe05 	stb	r3,-8(fp)
 203a090:	e0bfff05 	stb	r2,-4(fp)
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
 203a094:	e0bffe03 	ldbu	r2,-8(fp)
 203a098:	1004c03a 	cmpne	r2,r2,zero
 203a09c:	1007883a 	mov	r3,r2
 203a0a0:	e0bfff03 	ldbu	r2,-4(fp)
 203a0a4:	10000226 	beq	r2,zero,203a0b0 <netconn_shutdown+0x40>
 203a0a8:	00800084 	movi	r2,2
 203a0ac:	00000106 	br	203a0b4 <netconn_shutdown+0x44>
 203a0b0:	0005883a 	mov	r2,zero
 203a0b4:	1884b03a 	or	r2,r3,r2
 203a0b8:	10803fcc 	andi	r2,r2,255
 203a0bc:	100b883a 	mov	r5,r2
 203a0c0:	e13ffd17 	ldw	r4,-12(fp)
 203a0c4:	2039f700 	call	2039f70 <netconn_close_shutdown>
}
 203a0c8:	e037883a 	mov	sp,fp
 203a0cc:	dfc00117 	ldw	ra,4(sp)
 203a0d0:	df000017 	ldw	fp,0(sp)
 203a0d4:	dec00204 	addi	sp,sp,8
 203a0d8:	f800283a 	ret

0203a0dc <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
 203a0dc:	defff604 	addi	sp,sp,-40
 203a0e0:	dfc00915 	stw	ra,36(sp)
 203a0e4:	df000815 	stw	fp,32(sp)
 203a0e8:	df000804 	addi	fp,sp,32
 203a0ec:	e13ffc15 	stw	r4,-16(fp)
 203a0f0:	e17ffd15 	stw	r5,-12(fp)
 203a0f4:	e1bffe15 	stw	r6,-8(fp)
 203a0f8:	e1ffff15 	stw	r7,-4(fp)
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
 203a0fc:	e0bffc17 	ldw	r2,-16(fp)
 203a100:	e0bff915 	stw	r2,-28(fp)

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 203a104:	e0bff917 	ldw	r2,-28(fp)
 203a108:	10004a26 	beq	r2,zero,203a234 <recv_raw+0x158>
 203a10c:	e0bff917 	ldw	r2,-28(fp)
 203a110:	10800517 	ldw	r2,20(r2)
 203a114:	10004726 	beq	r2,zero,203a234 <recv_raw+0x158>
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 203a118:	e0bffe17 	ldw	r2,-8(fp)
 203a11c:	1080020b 	ldhu	r2,8(r2)
 203a120:	10bfffcc 	andi	r2,r2,65535
 203a124:	000d883a 	mov	r6,zero
 203a128:	100b883a 	mov	r5,r2
 203a12c:	010000c4 	movi	r4,3
 203a130:	201a3ac0 	call	201a3ac <pbuf_alloc>
 203a134:	e0bff815 	stw	r2,-32(fp)
    if(q != NULL) {
 203a138:	e0bff817 	ldw	r2,-32(fp)
 203a13c:	10000a26 	beq	r2,zero,203a168 <recv_raw+0x8c>
      if (pbuf_copy(q, p) != ERR_OK) {
 203a140:	e17ffe17 	ldw	r5,-8(fp)
 203a144:	e13ff817 	ldw	r4,-32(fp)
 203a148:	201af100 	call	201af10 <pbuf_copy>
 203a14c:	10803fcc 	andi	r2,r2,255
 203a150:	1080201c 	xori	r2,r2,128
 203a154:	10bfe004 	addi	r2,r2,-128
 203a158:	10000326 	beq	r2,zero,203a168 <recv_raw+0x8c>
        pbuf_free(q);
 203a15c:	e13ff817 	ldw	r4,-32(fp)
 203a160:	201ab680 	call	201ab68 <pbuf_free>
        q = NULL;
 203a164:	e03ff815 	stw	zero,-32(fp)
      }
    }

    if (q != NULL) {
 203a168:	e0bff817 	ldw	r2,-32(fp)
 203a16c:	10003126 	beq	r2,zero,203a234 <recv_raw+0x158>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203a170:	010001c4 	movi	r4,7
 203a174:	20344340 	call	2034434 <memp_malloc>
 203a178:	e0bffa15 	stw	r2,-24(fp)
      if (buf == NULL) {
 203a17c:	e0bffa17 	ldw	r2,-24(fp)
 203a180:	1000041e 	bne	r2,zero,203a194 <recv_raw+0xb8>
        pbuf_free(q);
 203a184:	e13ff817 	ldw	r4,-32(fp)
 203a188:	201ab680 	call	201ab68 <pbuf_free>
        return 0;
 203a18c:	0005883a 	mov	r2,zero
 203a190:	00002906 	br	203a238 <recv_raw+0x15c>
      }

      buf->p = q;
 203a194:	e0bffa17 	ldw	r2,-24(fp)
 203a198:	e0fff817 	ldw	r3,-32(fp)
 203a19c:	10c00015 	stw	r3,0(r2)
      buf->ptr = q;
 203a1a0:	e0bffa17 	ldw	r2,-24(fp)
 203a1a4:	e0fff817 	ldw	r3,-32(fp)
 203a1a8:	10c00115 	stw	r3,4(r2)
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 203a1ac:	d0e81217 	ldw	r3,-24504(gp)
 203a1b0:	e0bffa17 	ldw	r2,-24(fp)
 203a1b4:	10c00215 	stw	r3,8(r2)
      buf->port = pcb->protocol;
 203a1b8:	e0bffd17 	ldw	r2,-12(fp)
 203a1bc:	10800403 	ldbu	r2,16(r2)
 203a1c0:	10c03fcc 	andi	r3,r2,255
 203a1c4:	e0bffa17 	ldw	r2,-24(fp)
 203a1c8:	10c0030d 	sth	r3,12(r2)

      len = q->tot_len;
 203a1cc:	e0bff817 	ldw	r2,-32(fp)
 203a1d0:	1080020b 	ldhu	r2,8(r2)
 203a1d4:	e0bffb0d 	sth	r2,-20(fp)
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 203a1d8:	e0bff917 	ldw	r2,-28(fp)
 203a1dc:	10800504 	addi	r2,r2,20
 203a1e0:	e17ffa17 	ldw	r5,-24(fp)
 203a1e4:	1009883a 	mov	r4,r2
 203a1e8:	20153980 	call	2015398 <sys_mbox_trypost>
 203a1ec:	10803fcc 	andi	r2,r2,255
 203a1f0:	1080201c 	xori	r2,r2,128
 203a1f4:	10bfe004 	addi	r2,r2,-128
 203a1f8:	10000426 	beq	r2,zero,203a20c <recv_raw+0x130>
        netbuf_delete(buf);
 203a1fc:	e13ffa17 	ldw	r4,-24(fp)
 203a200:	203c6240 	call	203c624 <netbuf_delete>
        return 0;
 203a204:	0005883a 	mov	r2,zero
 203a208:	00000b06 	br	203a238 <recv_raw+0x15c>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203a20c:	e0bff917 	ldw	r2,-28(fp)
 203a210:	10800c17 	ldw	r2,48(r2)
 203a214:	10000726 	beq	r2,zero,203a234 <recv_raw+0x158>
 203a218:	e0bff917 	ldw	r2,-28(fp)
 203a21c:	10800c17 	ldw	r2,48(r2)
 203a220:	e0fffb0b 	ldhu	r3,-20(fp)
 203a224:	180d883a 	mov	r6,r3
 203a228:	000b883a 	mov	r5,zero
 203a22c:	e13ff917 	ldw	r4,-28(fp)
 203a230:	103ee83a 	callr	r2
      }
    }
  }

  return 0; /* do not eat the packet */
 203a234:	0005883a 	mov	r2,zero
}
 203a238:	e037883a 	mov	sp,fp
 203a23c:	dfc00117 	ldw	ra,4(sp)
 203a240:	df000017 	ldw	fp,0(sp)
 203a244:	dec00204 	addi	sp,sp,8
 203a248:	f800283a 	ret

0203a24c <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
 203a24c:	defff604 	addi	sp,sp,-40
 203a250:	dfc00915 	stw	ra,36(sp)
 203a254:	df000815 	stw	fp,32(sp)
 203a258:	df000804 	addi	fp,sp,32
 203a25c:	e13ffb15 	stw	r4,-20(fp)
 203a260:	e17ffc15 	stw	r5,-16(fp)
 203a264:	e1bffd15 	stw	r6,-12(fp)
 203a268:	e1fffe15 	stw	r7,-8(fp)
 203a26c:	e0800217 	ldw	r2,8(fp)
 203a270:	e0bfff0d 	sth	r2,-4(fp)
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
 203a274:	e0bffb17 	ldw	r2,-20(fp)
 203a278:	e0bff815 	stw	r2,-32(fp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
 203a27c:	e0bff817 	ldw	r2,-32(fp)
 203a280:	10000326 	beq	r2,zero,203a290 <recv_udp+0x44>
 203a284:	e0bff817 	ldw	r2,-32(fp)
 203a288:	10800517 	ldw	r2,20(r2)
 203a28c:	1000031e 	bne	r2,zero,203a29c <recv_udp+0x50>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 203a290:	e13ffd17 	ldw	r4,-12(fp)
 203a294:	201ab680 	call	201ab68 <pbuf_free>
    return;
 203a298:	00003206 	br	203a364 <recv_udp+0x118>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203a29c:	010001c4 	movi	r4,7
 203a2a0:	20344340 	call	2034434 <memp_malloc>
 203a2a4:	e0bff915 	stw	r2,-28(fp)
  if (buf == NULL) {
 203a2a8:	e0bff917 	ldw	r2,-28(fp)
 203a2ac:	1000031e 	bne	r2,zero,203a2bc <recv_udp+0x70>
    pbuf_free(p);
 203a2b0:	e13ffd17 	ldw	r4,-12(fp)
 203a2b4:	201ab680 	call	201ab68 <pbuf_free>
    return;
 203a2b8:	00002a06 	br	203a364 <recv_udp+0x118>
  } else {
    buf->p = p;
 203a2bc:	e0bff917 	ldw	r2,-28(fp)
 203a2c0:	e0fffd17 	ldw	r3,-12(fp)
 203a2c4:	10c00015 	stw	r3,0(r2)
    buf->ptr = p;
 203a2c8:	e0bff917 	ldw	r2,-28(fp)
 203a2cc:	e0fffd17 	ldw	r3,-12(fp)
 203a2d0:	10c00115 	stw	r3,4(r2)
    ip_addr_set(&buf->addr, addr);
 203a2d4:	e0bffe17 	ldw	r2,-8(fp)
 203a2d8:	10000326 	beq	r2,zero,203a2e8 <recv_udp+0x9c>
 203a2dc:	e0bffe17 	ldw	r2,-8(fp)
 203a2e0:	10800017 	ldw	r2,0(r2)
 203a2e4:	00000106 	br	203a2ec <recv_udp+0xa0>
 203a2e8:	0005883a 	mov	r2,zero
 203a2ec:	e0fff917 	ldw	r3,-28(fp)
 203a2f0:	18800215 	stw	r2,8(r3)
    buf->port = port;
 203a2f4:	e0bff917 	ldw	r2,-28(fp)
 203a2f8:	e0ffff0b 	ldhu	r3,-4(fp)
 203a2fc:	10c0030d 	sth	r3,12(r2)
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 203a300:	e0bffd17 	ldw	r2,-12(fp)
 203a304:	1080020b 	ldhu	r2,8(r2)
 203a308:	e0bffa0d 	sth	r2,-24(fp)
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 203a30c:	e0bff817 	ldw	r2,-32(fp)
 203a310:	10800504 	addi	r2,r2,20
 203a314:	e17ff917 	ldw	r5,-28(fp)
 203a318:	1009883a 	mov	r4,r2
 203a31c:	20153980 	call	2015398 <sys_mbox_trypost>
 203a320:	10803fcc 	andi	r2,r2,255
 203a324:	1080201c 	xori	r2,r2,128
 203a328:	10bfe004 	addi	r2,r2,-128
 203a32c:	10000326 	beq	r2,zero,203a33c <recv_udp+0xf0>
    netbuf_delete(buf);
 203a330:	e13ff917 	ldw	r4,-28(fp)
 203a334:	203c6240 	call	203c624 <netbuf_delete>
    return;
 203a338:	00000a06 	br	203a364 <recv_udp+0x118>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203a33c:	e0bff817 	ldw	r2,-32(fp)
 203a340:	10800c17 	ldw	r2,48(r2)
 203a344:	10000726 	beq	r2,zero,203a364 <recv_udp+0x118>
 203a348:	e0bff817 	ldw	r2,-32(fp)
 203a34c:	10800c17 	ldw	r2,48(r2)
 203a350:	e0fffa0b 	ldhu	r3,-24(fp)
 203a354:	180d883a 	mov	r6,r3
 203a358:	000b883a 	mov	r5,zero
 203a35c:	e13ff817 	ldw	r4,-32(fp)
 203a360:	103ee83a 	callr	r2
  }
}
 203a364:	e037883a 	mov	sp,fp
 203a368:	dfc00117 	ldw	ra,4(sp)
 203a36c:	df000017 	ldw	fp,0(sp)
 203a370:	dec00204 	addi	sp,sp,8
 203a374:	f800283a 	ret

0203a378 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 203a378:	defff804 	addi	sp,sp,-32
 203a37c:	dfc00715 	stw	ra,28(sp)
 203a380:	df000615 	stw	fp,24(sp)
 203a384:	df000604 	addi	fp,sp,24
 203a388:	e13ffc15 	stw	r4,-16(fp)
 203a38c:	e17ffd15 	stw	r5,-12(fp)
 203a390:	e1bffe15 	stw	r6,-8(fp)
 203a394:	3805883a 	mov	r2,r7
 203a398:	e0bfff05 	stb	r2,-4(fp)
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
 203a39c:	e0bffc17 	ldw	r2,-16(fp)
 203a3a0:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 203a3a4:	e0bffb17 	ldw	r2,-20(fp)
 203a3a8:	1000021e 	bne	r2,zero,203a3b4 <recv_tcp+0x3c>
    return ERR_VAL;
 203a3ac:	00bffe84 	movi	r2,-6
 203a3b0:	00003c06 	br	203a4a4 <recv_tcp+0x12c>
  }

  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if (!sys_mbox_valid(&conn->recvmbox)) {
 203a3b4:	e0bffb17 	ldw	r2,-20(fp)
 203a3b8:	10800517 	ldw	r2,20(r2)
 203a3bc:	10000c1e 	bne	r2,zero,203a3f0 <recv_tcp+0x78>
    /* recvmbox already deleted */
    if (p != NULL) {
 203a3c0:	e0bffe17 	ldw	r2,-8(fp)
 203a3c4:	10000826 	beq	r2,zero,203a3e8 <recv_tcp+0x70>
      tcp_recved(pcb, p->tot_len);
 203a3c8:	e0bffe17 	ldw	r2,-8(fp)
 203a3cc:	1080020b 	ldhu	r2,8(r2)
 203a3d0:	10bfffcc 	andi	r2,r2,65535
 203a3d4:	100b883a 	mov	r5,r2
 203a3d8:	e13ffd17 	ldw	r4,-12(fp)
 203a3dc:	201c5440 	call	201c544 <tcp_recved>
      pbuf_free(p);
 203a3e0:	e13ffe17 	ldw	r4,-8(fp)
 203a3e4:	201ab680 	call	201ab68 <pbuf_free>
    }
    return ERR_OK;
 203a3e8:	0005883a 	mov	r2,zero
 203a3ec:	00002d06 	br	203a4a4 <recv_tcp+0x12c>
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
 203a3f0:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203a3f4:	10000126 	beq	r2,zero,203a3fc <recv_tcp+0x84>
 203a3f8:	2010f300 	call	2010f30 <vTaskEnterCritical>
 203a3fc:	e0bffb17 	ldw	r2,-20(fp)
 203a400:	10800303 	ldbu	r2,12(r2)
 203a404:	10803fcc 	andi	r2,r2,255
 203a408:	1080201c 	xori	r2,r2,128
 203a40c:	10bfe004 	addi	r2,r2,-128
 203a410:	10bffdd0 	cmplti	r2,r2,-9
 203a414:	1000031e 	bne	r2,zero,203a424 <recv_tcp+0xac>
 203a418:	e0bffb17 	ldw	r2,-20(fp)
 203a41c:	e0ffff03 	ldbu	r3,-4(fp)
 203a420:	10c00305 	stb	r3,12(r2)
 203a424:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203a428:	10000126 	beq	r2,zero,203a430 <recv_tcp+0xb8>
 203a42c:	2010f780 	call	2010f78 <vTaskExitCritical>

  if (p != NULL) {
 203a430:	e0bffe17 	ldw	r2,-8(fp)
 203a434:	10000426 	beq	r2,zero,203a448 <recv_tcp+0xd0>
    len = p->tot_len;
 203a438:	e0bffe17 	ldw	r2,-8(fp)
 203a43c:	1080020b 	ldhu	r2,8(r2)
 203a440:	e0bffa0d 	sth	r2,-24(fp)
 203a444:	00000106 	br	203a44c <recv_tcp+0xd4>
  } else {
    len = 0;
 203a448:	e03ffa0d 	sth	zero,-24(fp)
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 203a44c:	e0bffb17 	ldw	r2,-20(fp)
 203a450:	10800504 	addi	r2,r2,20
 203a454:	e17ffe17 	ldw	r5,-8(fp)
 203a458:	1009883a 	mov	r4,r2
 203a45c:	20153980 	call	2015398 <sys_mbox_trypost>
 203a460:	10803fcc 	andi	r2,r2,255
 203a464:	1080201c 	xori	r2,r2,128
 203a468:	10bfe004 	addi	r2,r2,-128
 203a46c:	10000226 	beq	r2,zero,203a478 <recv_tcp+0x100>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
 203a470:	00bfffc4 	movi	r2,-1
 203a474:	00000b06 	br	203a4a4 <recv_tcp+0x12c>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 203a478:	e0bffb17 	ldw	r2,-20(fp)
 203a47c:	10800c17 	ldw	r2,48(r2)
 203a480:	10000726 	beq	r2,zero,203a4a0 <recv_tcp+0x128>
 203a484:	e0bffb17 	ldw	r2,-20(fp)
 203a488:	10800c17 	ldw	r2,48(r2)
 203a48c:	e0fffa0b 	ldhu	r3,-24(fp)
 203a490:	180d883a 	mov	r6,r3
 203a494:	000b883a 	mov	r5,zero
 203a498:	e13ffb17 	ldw	r4,-20(fp)
 203a49c:	103ee83a 	callr	r2
  }

  return ERR_OK;
 203a4a0:	0005883a 	mov	r2,zero
}
 203a4a4:	e037883a 	mov	sp,fp
 203a4a8:	dfc00117 	ldw	ra,4(sp)
 203a4ac:	df000017 	ldw	fp,0(sp)
 203a4b0:	dec00204 	addi	sp,sp,8
 203a4b4:	f800283a 	ret

0203a4b8 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 203a4b8:	defffb04 	addi	sp,sp,-20
 203a4bc:	dfc00415 	stw	ra,16(sp)
 203a4c0:	df000315 	stw	fp,12(sp)
 203a4c4:	df000304 	addi	fp,sp,12
 203a4c8:	e13ffe15 	stw	r4,-8(fp)
 203a4cc:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 203a4d0:	e0bffe17 	ldw	r2,-8(fp)
 203a4d4:	e0bffd15 	stw	r2,-12(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
 203a4d8:	e0bffd17 	ldw	r2,-12(fp)
 203a4dc:	10800117 	ldw	r2,4(r2)
 203a4e0:	10800058 	cmpnei	r2,r2,1
 203a4e4:	1000031e 	bne	r2,zero,203a4f4 <poll_tcp+0x3c>
    do_writemore(conn);
 203a4e8:	e13ffd17 	ldw	r4,-12(fp)
 203a4ec:	203be880 	call	203be88 <do_writemore>
 203a4f0:	00000606 	br	203a50c <poll_tcp+0x54>
  } else if (conn->state == NETCONN_CLOSE) {
 203a4f4:	e0bffd17 	ldw	r2,-12(fp)
 203a4f8:	10800117 	ldw	r2,4(r2)
 203a4fc:	10800118 	cmpnei	r2,r2,4
 203a500:	1000021e 	bne	r2,zero,203a50c <poll_tcp+0x54>
    do_close_internal(conn);
 203a504:	e13ffd17 	ldw	r4,-12(fp)
 203a508:	203af500 	call	203af50 <do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 203a50c:	e0bffd17 	ldw	r2,-12(fp)
 203a510:	10800903 	ldbu	r2,36(r2)
 203a514:	10803fcc 	andi	r2,r2,255
 203a518:	1080040c 	andi	r2,r2,16
 203a51c:	10001f26 	beq	r2,zero,203a59c <poll_tcp+0xe4>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203a520:	e0bffd17 	ldw	r2,-12(fp)
 203a524:	10800217 	ldw	r2,8(r2)
 203a528:	10001c26 	beq	r2,zero,203a59c <poll_tcp+0xe4>
 203a52c:	e0bffd17 	ldw	r2,-12(fp)
 203a530:	10800217 	ldw	r2,8(r2)
 203a534:	10801a8b 	ldhu	r2,106(r2)
 203a538:	10bfffcc 	andi	r2,r2,65535
 203a53c:	10816d70 	cmpltui	r2,r2,1461
 203a540:	1000161e 	bne	r2,zero,203a59c <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 203a544:	e0bffd17 	ldw	r2,-12(fp)
 203a548:	10800217 	ldw	r2,8(r2)
 203a54c:	10801b0b 	ldhu	r2,108(r2)

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203a550:	10bfffcc 	andi	r2,r2,65535
 203a554:	10800128 	cmpgeui	r2,r2,4
 203a558:	1000101e 	bne	r2,zero,203a59c <poll_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 203a55c:	e0bffd17 	ldw	r2,-12(fp)
 203a560:	10c00903 	ldbu	r3,36(r2)
 203a564:	00bffbc4 	movi	r2,-17
 203a568:	1884703a 	and	r2,r3,r2
 203a56c:	1007883a 	mov	r3,r2
 203a570:	e0bffd17 	ldw	r2,-12(fp)
 203a574:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203a578:	e0bffd17 	ldw	r2,-12(fp)
 203a57c:	10800c17 	ldw	r2,48(r2)
 203a580:	10000626 	beq	r2,zero,203a59c <poll_tcp+0xe4>
 203a584:	e0bffd17 	ldw	r2,-12(fp)
 203a588:	10800c17 	ldw	r2,48(r2)
 203a58c:	000d883a 	mov	r6,zero
 203a590:	01400084 	movi	r5,2
 203a594:	e13ffd17 	ldw	r4,-12(fp)
 203a598:	103ee83a 	callr	r2
    }
  }

  return ERR_OK;
 203a59c:	0005883a 	mov	r2,zero
}
 203a5a0:	e037883a 	mov	sp,fp
 203a5a4:	dfc00117 	ldw	ra,4(sp)
 203a5a8:	df000017 	ldw	fp,0(sp)
 203a5ac:	dec00204 	addi	sp,sp,8
 203a5b0:	f800283a 	ret

0203a5b4 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 203a5b4:	defffa04 	addi	sp,sp,-24
 203a5b8:	dfc00515 	stw	ra,20(sp)
 203a5bc:	df000415 	stw	fp,16(sp)
 203a5c0:	df000404 	addi	fp,sp,16
 203a5c4:	e13ffd15 	stw	r4,-12(fp)
 203a5c8:	e17ffe15 	stw	r5,-8(fp)
 203a5cc:	3005883a 	mov	r2,r6
 203a5d0:	e0bfff0d 	sth	r2,-4(fp)
  struct netconn *conn = (struct netconn *)arg;
 203a5d4:	e0bffd17 	ldw	r2,-12(fp)
 203a5d8:	e0bffc15 	stw	r2,-16(fp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn) {
 203a5dc:	e0bffc17 	ldw	r2,-16(fp)
 203a5e0:	10002d26 	beq	r2,zero,203a698 <sent_tcp+0xe4>
  if (conn->state == NETCONN_WRITE) {
 203a5e4:	e0bffc17 	ldw	r2,-16(fp)
 203a5e8:	10800117 	ldw	r2,4(r2)
 203a5ec:	10800058 	cmpnei	r2,r2,1
 203a5f0:	1000031e 	bne	r2,zero,203a600 <sent_tcp+0x4c>
    do_writemore(conn);
 203a5f4:	e13ffc17 	ldw	r4,-16(fp)
 203a5f8:	203be880 	call	203be88 <do_writemore>
 203a5fc:	00000606 	br	203a618 <sent_tcp+0x64>
  } else if (conn->state == NETCONN_CLOSE) {
 203a600:	e0bffc17 	ldw	r2,-16(fp)
 203a604:	10800117 	ldw	r2,4(r2)
 203a608:	10800118 	cmpnei	r2,r2,4
 203a60c:	1000021e 	bne	r2,zero,203a618 <sent_tcp+0x64>
    do_close_internal(conn);
 203a610:	e13ffc17 	ldw	r4,-16(fp)
 203a614:	203af500 	call	203af50 <do_close_internal>
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203a618:	e0bffc17 	ldw	r2,-16(fp)
 203a61c:	10800217 	ldw	r2,8(r2)
 203a620:	10001d26 	beq	r2,zero,203a698 <sent_tcp+0xe4>
 203a624:	e0bffc17 	ldw	r2,-16(fp)
 203a628:	10800217 	ldw	r2,8(r2)
 203a62c:	10801a8b 	ldhu	r2,106(r2)
 203a630:	10bfffcc 	andi	r2,r2,65535
 203a634:	10816d70 	cmpltui	r2,r2,1461
 203a638:	1000171e 	bne	r2,zero,203a698 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
 203a63c:	e0bffc17 	ldw	r2,-16(fp)
 203a640:	10800217 	ldw	r2,8(r2)
 203a644:	10801b0b 	ldhu	r2,108(r2)
    do_close_internal(conn);
  }

    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 203a648:	10bfffcc 	andi	r2,r2,65535
 203a64c:	10800128 	cmpgeui	r2,r2,4
 203a650:	1000111e 	bne	r2,zero,203a698 <sent_tcp+0xe4>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 203a654:	e0bffc17 	ldw	r2,-16(fp)
 203a658:	10c00903 	ldbu	r3,36(r2)
 203a65c:	00bffbc4 	movi	r2,-17
 203a660:	1884703a 	and	r2,r3,r2
 203a664:	1007883a 	mov	r3,r2
 203a668:	e0bffc17 	ldw	r2,-16(fp)
 203a66c:	10c00905 	stb	r3,36(r2)
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 203a670:	e0bffc17 	ldw	r2,-16(fp)
 203a674:	10800c17 	ldw	r2,48(r2)
 203a678:	10000726 	beq	r2,zero,203a698 <sent_tcp+0xe4>
 203a67c:	e0bffc17 	ldw	r2,-16(fp)
 203a680:	10800c17 	ldw	r2,48(r2)
 203a684:	e0ffff0b 	ldhu	r3,-4(fp)
 203a688:	180d883a 	mov	r6,r3
 203a68c:	01400084 	movi	r5,2
 203a690:	e13ffc17 	ldw	r4,-16(fp)
 203a694:	103ee83a 	callr	r2
    }
  }
  
  return ERR_OK;
 203a698:	0005883a 	mov	r2,zero
}
 203a69c:	e037883a 	mov	sp,fp
 203a6a0:	dfc00117 	ldw	ra,4(sp)
 203a6a4:	df000017 	ldw	fp,0(sp)
 203a6a8:	dec00204 	addi	sp,sp,8
 203a6ac:	f800283a 	ret

0203a6b0 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
 203a6b0:	defff904 	addi	sp,sp,-28
 203a6b4:	dfc00615 	stw	ra,24(sp)
 203a6b8:	df000515 	stw	fp,20(sp)
 203a6bc:	df000504 	addi	fp,sp,20
 203a6c0:	e13ffe15 	stw	r4,-8(fp)
 203a6c4:	2805883a 	mov	r2,r5
 203a6c8:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
 203a6cc:	e0bffe17 	ldw	r2,-8(fp)
 203a6d0:	e0bffb15 	stw	r2,-20(fp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
 203a6d4:	e0bffb17 	ldw	r2,-20(fp)
 203a6d8:	10000215 	stw	zero,8(r2)

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
 203a6dc:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203a6e0:	10000126 	beq	r2,zero,203a6e8 <err_tcp+0x38>
 203a6e4:	2010f300 	call	2010f30 <vTaskEnterCritical>
  conn->last_err = err;
 203a6e8:	e0bffb17 	ldw	r2,-20(fp)
 203a6ec:	e0ffff03 	ldbu	r3,-4(fp)
 203a6f0:	10c00305 	stb	r3,12(r2)
  SYS_ARCH_UNPROTECT(lev);
 203a6f4:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203a6f8:	10000126 	beq	r2,zero,203a700 <err_tcp+0x50>
 203a6fc:	2010f780 	call	2010f78 <vTaskExitCritical>

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
 203a700:	e0bffb17 	ldw	r2,-20(fp)
 203a704:	10800117 	ldw	r2,4(r2)
 203a708:	e0bffc15 	stw	r2,-16(fp)
  conn->state = NETCONN_NONE;
 203a70c:	e0bffb17 	ldw	r2,-20(fp)
 203a710:	10000115 	stw	zero,4(r2)

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 203a714:	e0bffb17 	ldw	r2,-20(fp)
 203a718:	10800c17 	ldw	r2,48(r2)
 203a71c:	10000626 	beq	r2,zero,203a738 <err_tcp+0x88>
 203a720:	e0bffb17 	ldw	r2,-20(fp)
 203a724:	10800c17 	ldw	r2,48(r2)
 203a728:	000d883a 	mov	r6,zero
 203a72c:	01400104 	movi	r5,4
 203a730:	e13ffb17 	ldw	r4,-20(fp)
 203a734:	103ee83a 	callr	r2
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203a738:	e0bffb17 	ldw	r2,-20(fp)
 203a73c:	10800c17 	ldw	r2,48(r2)
 203a740:	10000626 	beq	r2,zero,203a75c <err_tcp+0xac>
 203a744:	e0bffb17 	ldw	r2,-20(fp)
 203a748:	10800c17 	ldw	r2,48(r2)
 203a74c:	000d883a 	mov	r6,zero
 203a750:	000b883a 	mov	r5,zero
 203a754:	e13ffb17 	ldw	r4,-20(fp)
 203a758:	103ee83a 	callr	r2
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203a75c:	e0bffb17 	ldw	r2,-20(fp)
 203a760:	10800c17 	ldw	r2,48(r2)
 203a764:	10000626 	beq	r2,zero,203a780 <err_tcp+0xd0>
 203a768:	e0bffb17 	ldw	r2,-20(fp)
 203a76c:	10800c17 	ldw	r2,48(r2)
 203a770:	000d883a 	mov	r6,zero
 203a774:	01400084 	movi	r5,2
 203a778:	e13ffb17 	ldw	r4,-20(fp)
 203a77c:	103ee83a 	callr	r2

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
 203a780:	e0bffb17 	ldw	r2,-20(fp)
 203a784:	10800517 	ldw	r2,20(r2)
 203a788:	10000526 	beq	r2,zero,203a7a0 <err_tcp+0xf0>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
 203a78c:	e0bffb17 	ldw	r2,-20(fp)
 203a790:	10800504 	addi	r2,r2,20
 203a794:	000b883a 	mov	r5,zero
 203a798:	1009883a 	mov	r4,r2
 203a79c:	20153980 	call	2015398 <sys_mbox_trypost>
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
 203a7a0:	e0bffb17 	ldw	r2,-20(fp)
 203a7a4:	10800617 	ldw	r2,24(r2)
 203a7a8:	10000526 	beq	r2,zero,203a7c0 <err_tcp+0x110>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 203a7ac:	e0bffb17 	ldw	r2,-20(fp)
 203a7b0:	10800604 	addi	r2,r2,24
 203a7b4:	000b883a 	mov	r5,zero
 203a7b8:	1009883a 	mov	r4,r2
 203a7bc:	20153980 	call	2015398 <sys_mbox_trypost>
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 203a7c0:	e0bffc17 	ldw	r2,-16(fp)
 203a7c4:	10800060 	cmpeqi	r2,r2,1
 203a7c8:	1000061e 	bne	r2,zero,203a7e4 <err_tcp+0x134>
 203a7cc:	e0bffc17 	ldw	r2,-16(fp)
 203a7d0:	10800120 	cmpeqi	r2,r2,4
 203a7d4:	1000031e 	bne	r2,zero,203a7e4 <err_tcp+0x134>
 203a7d8:	e0bffc17 	ldw	r2,-16(fp)
 203a7dc:	108000d8 	cmpnei	r2,r2,3
 203a7e0:	10001a1e 	bne	r2,zero,203a84c <err_tcp+0x19c>
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 203a7e4:	e0bffb17 	ldw	r2,-20(fp)
 203a7e8:	10800903 	ldbu	r2,36(r2)
 203a7ec:	10803fcc 	andi	r2,r2,255
 203a7f0:	1080010c 	andi	r2,r2,4
 203a7f4:	1004c03a 	cmpne	r2,r2,zero
 203a7f8:	10803fcc 	andi	r2,r2,255
 203a7fc:	e0bffd15 	stw	r2,-12(fp)
    SET_NONBLOCKING_CONNECT(conn, 0);
 203a800:	e0bffb17 	ldw	r2,-20(fp)
 203a804:	10c00903 	ldbu	r3,36(r2)
 203a808:	00bffec4 	movi	r2,-5
 203a80c:	1884703a 	and	r2,r3,r2
 203a810:	1007883a 	mov	r3,r2
 203a814:	e0bffb17 	ldw	r2,-20(fp)
 203a818:	10c00905 	stb	r3,36(r2)

    if (!was_nonblocking_connect) {
 203a81c:	e0bffd17 	ldw	r2,-12(fp)
 203a820:	10000a1e 	bne	r2,zero,203a84c <err_tcp+0x19c>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
 203a824:	e0bffb17 	ldw	r2,-20(fp)
 203a828:	10800b17 	ldw	r2,44(r2)
 203a82c:	e0ffff03 	ldbu	r3,-4(fp)
 203a830:	10c00105 	stb	r3,4(r2)
      conn->current_msg = NULL;
 203a834:	e0bffb17 	ldw	r2,-20(fp)
 203a838:	10000b15 	stw	zero,44(r2)
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 203a83c:	e0bffb17 	ldw	r2,-20(fp)
 203a840:	10800404 	addi	r2,r2,16
 203a844:	1009883a 	mov	r4,r2
 203a848:	2014f380 	call	2014f38 <sys_sem_signal>
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 203a84c:	0001883a 	nop
 203a850:	e037883a 	mov	sp,fp
 203a854:	dfc00117 	ldw	ra,4(sp)
 203a858:	df000017 	ldw	fp,0(sp)
 203a85c:	dec00204 	addi	sp,sp,8
 203a860:	f800283a 	ret

0203a864 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 203a864:	defffc04 	addi	sp,sp,-16
 203a868:	dfc00315 	stw	ra,12(sp)
 203a86c:	df000215 	stw	fp,8(sp)
 203a870:	df000204 	addi	fp,sp,8
 203a874:	e13fff15 	stw	r4,-4(fp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 203a878:	e0bfff17 	ldw	r2,-4(fp)
 203a87c:	10800217 	ldw	r2,8(r2)
 203a880:	e0bffe15 	stw	r2,-8(fp)
  tcp_arg(pcb, conn);
 203a884:	e17fff17 	ldw	r5,-4(fp)
 203a888:	e13ffe17 	ldw	r4,-8(fp)
 203a88c:	201d9400 	call	201d940 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 203a890:	01408134 	movhi	r5,516
 203a894:	2968de04 	addi	r5,r5,-23688
 203a898:	e13ffe17 	ldw	r4,-8(fp)
 203a89c:	201d9740 	call	201d974 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 203a8a0:	01408134 	movhi	r5,516
 203a8a4:	29696d04 	addi	r5,r5,-23116
 203a8a8:	e13ffe17 	ldw	r4,-8(fp)
 203a8ac:	201d9a80 	call	201d9a8 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
 203a8b0:	01800104 	movi	r6,4
 203a8b4:	01408134 	movhi	r5,516
 203a8b8:	29692e04 	addi	r5,r5,-23368
 203a8bc:	e13ffe17 	ldw	r4,-8(fp)
 203a8c0:	201da440 	call	201da44 <tcp_poll>
  tcp_err(pcb, err_tcp);
 203a8c4:	01408134 	movhi	r5,516
 203a8c8:	2969ac04 	addi	r5,r5,-22864
 203a8cc:	e13ffe17 	ldw	r4,-8(fp)
 203a8d0:	201d9dc0 	call	201d9dc <tcp_err>
}
 203a8d4:	0001883a 	nop
 203a8d8:	e037883a 	mov	sp,fp
 203a8dc:	dfc00117 	ldw	ra,4(sp)
 203a8e0:	df000017 	ldw	fp,0(sp)
 203a8e4:	dec00204 	addi	sp,sp,8
 203a8e8:	f800283a 	ret

0203a8ec <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 203a8ec:	defff804 	addi	sp,sp,-32
 203a8f0:	dfc00715 	stw	ra,28(sp)
 203a8f4:	df000615 	stw	fp,24(sp)
 203a8f8:	df000604 	addi	fp,sp,24
 203a8fc:	e13ffd15 	stw	r4,-12(fp)
 203a900:	e17ffe15 	stw	r5,-8(fp)
 203a904:	3005883a 	mov	r2,r6
 203a908:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
 203a90c:	e0bffd17 	ldw	r2,-12(fp)
 203a910:	e0bffa15 	stw	r2,-24(fp)

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 203a914:	e0bffa17 	ldw	r2,-24(fp)
 203a918:	10800617 	ldw	r2,24(r2)
 203a91c:	1000021e 	bne	r2,zero,203a928 <accept_function+0x3c>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
 203a920:	00bffe84 	movi	r2,-6
 203a924:	00004606 	br	203aa40 <accept_function+0x154>
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
 203a928:	e0bffa17 	ldw	r2,-24(fp)
 203a92c:	10c00017 	ldw	r3,0(r2)
 203a930:	e0bffa17 	ldw	r2,-24(fp)
 203a934:	10800c17 	ldw	r2,48(r2)
 203a938:	100b883a 	mov	r5,r2
 203a93c:	1809883a 	mov	r4,r3
 203a940:	203ac580 	call	203ac58 <netconn_alloc>
 203a944:	e0bffb15 	stw	r2,-20(fp)
  if (newconn == NULL) {
 203a948:	e0bffb17 	ldw	r2,-20(fp)
 203a94c:	1000021e 	bne	r2,zero,203a958 <accept_function+0x6c>
    return ERR_MEM;
 203a950:	00bfffc4 	movi	r2,-1
 203a954:	00003a06 	br	203aa40 <accept_function+0x154>
  }
  newconn->pcb.tcp = newpcb;
 203a958:	e0bffb17 	ldw	r2,-20(fp)
 203a95c:	e0fffe17 	ldw	r3,-8(fp)
 203a960:	10c00215 	stw	r3,8(r2)
  setup_tcp(newconn);
 203a964:	e13ffb17 	ldw	r4,-20(fp)
 203a968:	203a8640 	call	203a864 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
 203a96c:	e0bffb17 	ldw	r2,-20(fp)
 203a970:	e0ffff03 	ldbu	r3,-4(fp)
 203a974:	10c00305 	stb	r3,12(r2)

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 203a978:	e0bffa17 	ldw	r2,-24(fp)
 203a97c:	10800604 	addi	r2,r2,24
 203a980:	e17ffb17 	ldw	r5,-20(fp)
 203a984:	1009883a 	mov	r4,r2
 203a988:	20153980 	call	2015398 <sys_mbox_trypost>
 203a98c:	10803fcc 	andi	r2,r2,255
 203a990:	1080201c 	xori	r2,r2,128
 203a994:	10bfe004 	addi	r2,r2,-128
 203a998:	10001f26 	beq	r2,zero,203aa18 <accept_function+0x12c>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
 203a99c:	e0bffb17 	ldw	r2,-20(fp)
 203a9a0:	10800217 	ldw	r2,8(r2)
 203a9a4:	e0bffc15 	stw	r2,-16(fp)
    tcp_arg(pcb, NULL);
 203a9a8:	000b883a 	mov	r5,zero
 203a9ac:	e13ffc17 	ldw	r4,-16(fp)
 203a9b0:	201d9400 	call	201d940 <tcp_arg>
    tcp_recv(pcb, NULL);
 203a9b4:	000b883a 	mov	r5,zero
 203a9b8:	e13ffc17 	ldw	r4,-16(fp)
 203a9bc:	201d9740 	call	201d974 <tcp_recv>
    tcp_sent(pcb, NULL);
 203a9c0:	000b883a 	mov	r5,zero
 203a9c4:	e13ffc17 	ldw	r4,-16(fp)
 203a9c8:	201d9a80 	call	201d9a8 <tcp_sent>
    tcp_poll(pcb, NULL, 4);
 203a9cc:	01800104 	movi	r6,4
 203a9d0:	000b883a 	mov	r5,zero
 203a9d4:	e13ffc17 	ldw	r4,-16(fp)
 203a9d8:	201da440 	call	201da44 <tcp_poll>
    tcp_err(pcb, NULL);
 203a9dc:	000b883a 	mov	r5,zero
 203a9e0:	e13ffc17 	ldw	r4,-16(fp)
 203a9e4:	201d9dc0 	call	201d9dc <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
 203a9e8:	e0bffb17 	ldw	r2,-20(fp)
 203a9ec:	10000215 	stw	zero,8(r2)
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 203a9f0:	e0bffb17 	ldw	r2,-20(fp)
 203a9f4:	10800504 	addi	r2,r2,20
 203a9f8:	1009883a 	mov	r4,r2
 203a9fc:	20152d80 	call	20152d8 <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 203aa00:	e0bffb17 	ldw	r2,-20(fp)
 203aa04:	10000515 	stw	zero,20(r2)
    netconn_free(newconn);
 203aa08:	e13ffb17 	ldw	r4,-20(fp)
 203aa0c:	203ad840 	call	203ad84 <netconn_free>
    return ERR_MEM;
 203aa10:	00bfffc4 	movi	r2,-1
 203aa14:	00000a06 	br	203aa40 <accept_function+0x154>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203aa18:	e0bffa17 	ldw	r2,-24(fp)
 203aa1c:	10800c17 	ldw	r2,48(r2)
 203aa20:	10000626 	beq	r2,zero,203aa3c <accept_function+0x150>
 203aa24:	e0bffa17 	ldw	r2,-24(fp)
 203aa28:	10800c17 	ldw	r2,48(r2)
 203aa2c:	000d883a 	mov	r6,zero
 203aa30:	000b883a 	mov	r5,zero
 203aa34:	e13ffa17 	ldw	r4,-24(fp)
 203aa38:	103ee83a 	callr	r2
  }

  return ERR_OK;
 203aa3c:	0005883a 	mov	r2,zero
}
 203aa40:	e037883a 	mov	sp,fp
 203aa44:	dfc00117 	ldw	ra,4(sp)
 203aa48:	df000017 	ldw	fp,0(sp)
 203aa4c:	dec00204 	addi	sp,sp,8
 203aa50:	f800283a 	ret

0203aa54 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static void
pcb_new(struct api_msg_msg *msg)
{
 203aa54:	defffc04 	addi	sp,sp,-16
 203aa58:	dfc00315 	stw	ra,12(sp)
 203aa5c:	df000215 	stw	fp,8(sp)
 203aa60:	dc000115 	stw	r16,4(sp)
 203aa64:	df000204 	addi	fp,sp,8
 203aa68:	e13ffe15 	stw	r4,-8(fp)
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 203aa6c:	e0bffe17 	ldw	r2,-8(fp)
 203aa70:	10800017 	ldw	r2,0(r2)
 203aa74:	10800017 	ldw	r2,0(r2)
 203aa78:	10803c0c 	andi	r2,r2,240
 203aa7c:	10c00820 	cmpeqi	r3,r2,32
 203aa80:	1800201e 	bne	r3,zero,203ab04 <pcb_new+0xb0>
 203aa84:	10c01020 	cmpeqi	r3,r2,64
 203aa88:	1800031e 	bne	r3,zero,203aa98 <pcb_new+0x44>
 203aa8c:	10800420 	cmpeqi	r2,r2,16
 203aa90:	10003d1e 	bne	r2,zero,203ab88 <pcb_new+0x134>
 203aa94:	00004d06 	br	203abcc <pcb_new+0x178>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
 203aa98:	e0bffe17 	ldw	r2,-8(fp)
 203aa9c:	14000017 	ldw	r16,0(r2)
 203aaa0:	e0bffe17 	ldw	r2,-8(fp)
 203aaa4:	10800203 	ldbu	r2,8(r2)
 203aaa8:	10803fcc 	andi	r2,r2,255
 203aaac:	1009883a 	mov	r4,r2
 203aab0:	2034b540 	call	2034b54 <raw_new>
 203aab4:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.raw == NULL) {
 203aab8:	e0bffe17 	ldw	r2,-8(fp)
 203aabc:	10800017 	ldw	r2,0(r2)
 203aac0:	10800217 	ldw	r2,8(r2)
 203aac4:	1000041e 	bne	r2,zero,203aad8 <pcb_new+0x84>
      msg->err = ERR_MEM;
 203aac8:	e0bffe17 	ldw	r2,-8(fp)
 203aacc:	00ffffc4 	movi	r3,-1
 203aad0:	10c00105 	stb	r3,4(r2)
      break;
 203aad4:	00004106 	br	203abdc <pcb_new+0x188>
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
 203aad8:	e0bffe17 	ldw	r2,-8(fp)
 203aadc:	10800017 	ldw	r2,0(r2)
 203aae0:	10c00217 	ldw	r3,8(r2)
 203aae4:	e0bffe17 	ldw	r2,-8(fp)
 203aae8:	10800017 	ldw	r2,0(r2)
 203aaec:	100d883a 	mov	r6,r2
 203aaf0:	01408134 	movhi	r5,516
 203aaf4:	29683704 	addi	r5,r5,-24356
 203aaf8:	1809883a 	mov	r4,r3
 203aafc:	20348a40 	call	20348a4 <raw_recv>
    break;
 203ab00:	00003606 	br	203abdc <pcb_new+0x188>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
 203ab04:	e0bffe17 	ldw	r2,-8(fp)
 203ab08:	14000017 	ldw	r16,0(r2)
 203ab0c:	2022b1c0 	call	2022b1c <udp_new>
 203ab10:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.udp == NULL) {
 203ab14:	e0bffe17 	ldw	r2,-8(fp)
 203ab18:	10800017 	ldw	r2,0(r2)
 203ab1c:	10800217 	ldw	r2,8(r2)
 203ab20:	1000041e 	bne	r2,zero,203ab34 <pcb_new+0xe0>
      msg->err = ERR_MEM;
 203ab24:	e0bffe17 	ldw	r2,-8(fp)
 203ab28:	00ffffc4 	movi	r3,-1
 203ab2c:	10c00105 	stb	r3,4(r2)
      break;
 203ab30:	00002a06 	br	203abdc <pcb_new+0x188>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
 203ab34:	e0bffe17 	ldw	r2,-8(fp)
 203ab38:	10800017 	ldw	r2,0(r2)
 203ab3c:	10800017 	ldw	r2,0(r2)
 203ab40:	10800898 	cmpnei	r2,r2,34
 203ab44:	1000051e 	bne	r2,zero,203ab5c <pcb_new+0x108>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 203ab48:	e0bffe17 	ldw	r2,-8(fp)
 203ab4c:	10800017 	ldw	r2,0(r2)
 203ab50:	10800217 	ldw	r2,8(r2)
 203ab54:	00c00044 	movi	r3,1
 203ab58:	10c00405 	stb	r3,16(r2)
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 203ab5c:	e0bffe17 	ldw	r2,-8(fp)
 203ab60:	10800017 	ldw	r2,0(r2)
 203ab64:	10c00217 	ldw	r3,8(r2)
 203ab68:	e0bffe17 	ldw	r2,-8(fp)
 203ab6c:	10800017 	ldw	r2,0(r2)
 203ab70:	100d883a 	mov	r6,r2
 203ab74:	01408134 	movhi	r5,516
 203ab78:	29689304 	addi	r5,r5,-23988
 203ab7c:	1809883a 	mov	r4,r3
 203ab80:	2022a380 	call	2022a38 <udp_recv>
    break;
 203ab84:	00001506 	br	203abdc <pcb_new+0x188>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
 203ab88:	e0bffe17 	ldw	r2,-8(fp)
 203ab8c:	14000017 	ldw	r16,0(r2)
 203ab90:	201d9140 	call	201d914 <tcp_new>
 203ab94:	80800215 	stw	r2,8(r16)
    if(msg->conn->pcb.tcp == NULL) {
 203ab98:	e0bffe17 	ldw	r2,-8(fp)
 203ab9c:	10800017 	ldw	r2,0(r2)
 203aba0:	10800217 	ldw	r2,8(r2)
 203aba4:	1000041e 	bne	r2,zero,203abb8 <pcb_new+0x164>
      msg->err = ERR_MEM;
 203aba8:	e0bffe17 	ldw	r2,-8(fp)
 203abac:	00ffffc4 	movi	r3,-1
 203abb0:	10c00105 	stb	r3,4(r2)
      break;
 203abb4:	00000906 	br	203abdc <pcb_new+0x188>
    }
    setup_tcp(msg->conn);
 203abb8:	e0bffe17 	ldw	r2,-8(fp)
 203abbc:	10800017 	ldw	r2,0(r2)
 203abc0:	1009883a 	mov	r4,r2
 203abc4:	203a8640 	call	203a864 <setup_tcp>
    break;
 203abc8:	00000406 	br	203abdc <pcb_new+0x188>
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
 203abcc:	e0bffe17 	ldw	r2,-8(fp)
 203abd0:	00fffe84 	movi	r3,-6
 203abd4:	10c00105 	stb	r3,4(r2)
    break;
 203abd8:	0001883a 	nop
  }
}
 203abdc:	0001883a 	nop
 203abe0:	e6ffff04 	addi	sp,fp,-4
 203abe4:	dfc00217 	ldw	ra,8(sp)
 203abe8:	df000117 	ldw	fp,4(sp)
 203abec:	dc000017 	ldw	r16,0(sp)
 203abf0:	dec00304 	addi	sp,sp,12
 203abf4:	f800283a 	ret

0203abf8 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
 203abf8:	defffd04 	addi	sp,sp,-12
 203abfc:	dfc00215 	stw	ra,8(sp)
 203ac00:	df000115 	stw	fp,4(sp)
 203ac04:	df000104 	addi	fp,sp,4
 203ac08:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
 203ac0c:	e0bfff17 	ldw	r2,-4(fp)
 203ac10:	10000105 	stb	zero,4(r2)
  if(msg->conn->pcb.tcp == NULL) {
 203ac14:	e0bfff17 	ldw	r2,-4(fp)
 203ac18:	10800017 	ldw	r2,0(r2)
 203ac1c:	10800217 	ldw	r2,8(r2)
 203ac20:	1000021e 	bne	r2,zero,203ac2c <do_newconn+0x34>
    pcb_new(msg);
 203ac24:	e13fff17 	ldw	r4,-4(fp)
 203ac28:	203aa540 	call	203aa54 <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 203ac2c:	e0bfff17 	ldw	r2,-4(fp)
 203ac30:	10800017 	ldw	r2,0(r2)
 203ac34:	10800404 	addi	r2,r2,16
 203ac38:	1009883a 	mov	r4,r2
 203ac3c:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203ac40:	0001883a 	nop
 203ac44:	e037883a 	mov	sp,fp
 203ac48:	dfc00117 	ldw	ra,4(sp)
 203ac4c:	df000017 	ldw	fp,0(sp)
 203ac50:	dec00204 	addi	sp,sp,8
 203ac54:	f800283a 	ret

0203ac58 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 203ac58:	defffa04 	addi	sp,sp,-24
 203ac5c:	dfc00515 	stw	ra,20(sp)
 203ac60:	df000415 	stw	fp,16(sp)
 203ac64:	df000404 	addi	fp,sp,16
 203ac68:	e13ffe15 	stw	r4,-8(fp)
 203ac6c:	e17fff15 	stw	r5,-4(fp)
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 203ac70:	01000204 	movi	r4,8
 203ac74:	20344340 	call	2034434 <memp_malloc>
 203ac78:	e0bffc15 	stw	r2,-16(fp)
  if (conn == NULL) {
 203ac7c:	e0bffc17 	ldw	r2,-16(fp)
 203ac80:	1000021e 	bne	r2,zero,203ac8c <netconn_alloc+0x34>
    return NULL;
 203ac84:	0005883a 	mov	r2,zero
 203ac88:	00003906 	br	203ad70 <netconn_alloc+0x118>
  }

  conn->last_err = ERR_OK;
 203ac8c:	e0bffc17 	ldw	r2,-16(fp)
 203ac90:	10000305 	stb	zero,12(r2)
  conn->type = t;
 203ac94:	e0bffc17 	ldw	r2,-16(fp)
 203ac98:	e0fffe17 	ldw	r3,-8(fp)
 203ac9c:	10c00015 	stw	r3,0(r2)
  conn->pcb.tcp = NULL;
 203aca0:	e0bffc17 	ldw	r2,-16(fp)
 203aca4:	10000215 	stw	zero,8(r2)

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
 203aca8:	00840004 	movi	r2,4096
 203acac:	e0bffd15 	stw	r2,-12(fp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 203acb0:	e0bffc17 	ldw	r2,-16(fp)
 203acb4:	10800404 	addi	r2,r2,16
 203acb8:	000b883a 	mov	r5,zero
 203acbc:	1009883a 	mov	r4,r2
 203acc0:	2014dfc0 	call	2014dfc <sys_sem_new>
 203acc4:	10803fcc 	andi	r2,r2,255
 203acc8:	1080201c 	xori	r2,r2,128
 203accc:	10bfe004 	addi	r2,r2,-128
 203acd0:	1000221e 	bne	r2,zero,203ad5c <netconn_alloc+0x104>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 203acd4:	e0bffc17 	ldw	r2,-16(fp)
 203acd8:	10800504 	addi	r2,r2,20
 203acdc:	e17ffd17 	ldw	r5,-12(fp)
 203ace0:	1009883a 	mov	r4,r2
 203ace4:	20152080 	call	2015208 <sys_mbox_new>
 203ace8:	10803fcc 	andi	r2,r2,255
 203acec:	1080201c 	xori	r2,r2,128
 203acf0:	10bfe004 	addi	r2,r2,-128
 203acf4:	10000526 	beq	r2,zero,203ad0c <netconn_alloc+0xb4>
    sys_sem_free(&conn->op_completed);
 203acf8:	e0bffc17 	ldw	r2,-16(fp)
 203acfc:	10800404 	addi	r2,r2,16
 203ad00:	1009883a 	mov	r4,r2
 203ad04:	2014ee00 	call	2014ee0 <sys_sem_free>
    goto free_and_return;
 203ad08:	00001506 	br	203ad60 <netconn_alloc+0x108>
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
 203ad0c:	e0bffc17 	ldw	r2,-16(fp)
 203ad10:	10000615 	stw	zero,24(r2)
#endif
  conn->state        = NETCONN_NONE;
 203ad14:	e0bffc17 	ldw	r2,-16(fp)
 203ad18:	10000115 	stw	zero,4(r2)
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 203ad1c:	e0bffc17 	ldw	r2,-16(fp)
 203ad20:	00ffffc4 	movi	r3,-1
 203ad24:	10c00715 	stw	r3,28(r2)
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
 203ad28:	e0bffc17 	ldw	r2,-16(fp)
 203ad2c:	e0ffff17 	ldw	r3,-4(fp)
 203ad30:	10c00c15 	stw	r3,48(r2)
#if LWIP_TCP
  conn->current_msg  = NULL;
 203ad34:	e0bffc17 	ldw	r2,-16(fp)
 203ad38:	10000b15 	stw	zero,44(r2)
  conn->write_offset = 0;
 203ad3c:	e0bffc17 	ldw	r2,-16(fp)
 203ad40:	10000a15 	stw	zero,40(r2)
#endif /* LWIP_TCP */
#if LWIP_SO_SNDTIMEO
  conn->send_timeout = 0;
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
 203ad44:	e0bffc17 	ldw	r2,-16(fp)
 203ad48:	10000815 	stw	zero,32(r2)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
 203ad4c:	e0bffc17 	ldw	r2,-16(fp)
 203ad50:	10000905 	stb	zero,36(r2)
  return conn;
 203ad54:	e0bffc17 	ldw	r2,-16(fp)
 203ad58:	00000506 	br	203ad70 <netconn_alloc+0x118>
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
 203ad5c:	0001883a 	nop
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
 203ad60:	e17ffc17 	ldw	r5,-16(fp)
 203ad64:	01000204 	movi	r4,8
 203ad68:	20346000 	call	2034600 <memp_free>
  return NULL;
 203ad6c:	0005883a 	mov	r2,zero
}
 203ad70:	e037883a 	mov	sp,fp
 203ad74:	dfc00117 	ldw	ra,4(sp)
 203ad78:	df000017 	ldw	fp,0(sp)
 203ad7c:	dec00204 	addi	sp,sp,8
 203ad80:	f800283a 	ret

0203ad84 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 203ad84:	defffd04 	addi	sp,sp,-12
 203ad88:	dfc00215 	stw	ra,8(sp)
 203ad8c:	df000115 	stw	fp,4(sp)
 203ad90:	df000104 	addi	fp,sp,4
 203ad94:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
 203ad98:	e0bfff17 	ldw	r2,-4(fp)
 203ad9c:	10800404 	addi	r2,r2,16
 203ada0:	1009883a 	mov	r4,r2
 203ada4:	2014ee00 	call	2014ee0 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 203ada8:	e0bfff17 	ldw	r2,-4(fp)
 203adac:	10000415 	stw	zero,16(r2)

  memp_free(MEMP_NETCONN, conn);
 203adb0:	e17fff17 	ldw	r5,-4(fp)
 203adb4:	01000204 	movi	r4,8
 203adb8:	20346000 	call	2034600 <memp_free>
}
 203adbc:	0001883a 	nop
 203adc0:	e037883a 	mov	sp,fp
 203adc4:	dfc00117 	ldw	ra,4(sp)
 203adc8:	df000017 	ldw	fp,0(sp)
 203adcc:	dec00204 	addi	sp,sp,8
 203add0:	f800283a 	ret

0203add4 <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 203add4:	defffa04 	addi	sp,sp,-24
 203add8:	dfc00515 	stw	ra,20(sp)
 203addc:	df000415 	stw	fp,16(sp)
 203ade0:	df000404 	addi	fp,sp,16
 203ade4:	e13fff15 	stw	r4,-4(fp)
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 203ade8:	e0bfff17 	ldw	r2,-4(fp)
 203adec:	10800517 	ldw	r2,20(r2)
 203adf0:	10002826 	beq	r2,zero,203ae94 <netconn_drain+0xc0>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 203adf4:	00001906 	br	203ae5c <netconn_drain+0x88>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
 203adf8:	e0bfff17 	ldw	r2,-4(fp)
 203adfc:	10800017 	ldw	r2,0(r2)
 203ae00:	10800418 	cmpnei	r2,r2,16
 203ae04:	1000121e 	bne	r2,zero,203ae50 <netconn_drain+0x7c>
        if(mem != NULL) {
 203ae08:	e0bffe17 	ldw	r2,-8(fp)
 203ae0c:	10001326 	beq	r2,zero,203ae5c <netconn_drain+0x88>
          p = (struct pbuf*)mem;
 203ae10:	e0bffe17 	ldw	r2,-8(fp)
 203ae14:	e0bffc15 	stw	r2,-16(fp)
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
 203ae18:	e0bfff17 	ldw	r2,-4(fp)
 203ae1c:	10800217 	ldw	r2,8(r2)
 203ae20:	10000826 	beq	r2,zero,203ae44 <netconn_drain+0x70>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 203ae24:	e0bfff17 	ldw	r2,-4(fp)
 203ae28:	10c00217 	ldw	r3,8(r2)
 203ae2c:	e0bffc17 	ldw	r2,-16(fp)
 203ae30:	1080020b 	ldhu	r2,8(r2)
 203ae34:	10bfffcc 	andi	r2,r2,65535
 203ae38:	100b883a 	mov	r5,r2
 203ae3c:	1809883a 	mov	r4,r3
 203ae40:	201c5440 	call	201c544 <tcp_recved>
          }
          pbuf_free(p);
 203ae44:	e13ffc17 	ldw	r4,-16(fp)
 203ae48:	201ab680 	call	201ab68 <pbuf_free>
 203ae4c:	00000306 	br	203ae5c <netconn_drain+0x88>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
 203ae50:	e0bffe17 	ldw	r2,-8(fp)
 203ae54:	1009883a 	mov	r4,r2
 203ae58:	203c6240 	call	203c624 <netbuf_delete>

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 203ae5c:	e0bfff17 	ldw	r2,-4(fp)
 203ae60:	10800504 	addi	r2,r2,20
 203ae64:	e0fffe04 	addi	r3,fp,-8
 203ae68:	180b883a 	mov	r5,r3
 203ae6c:	1009883a 	mov	r4,r2
 203ae70:	20154f80 	call	20154f8 <sys_arch_mbox_tryfetch>
 203ae74:	10bfffd8 	cmpnei	r2,r2,-1
 203ae78:	103fdf1e 	bne	r2,zero,203adf8 <__alt_mem_mem_0+0xfd01adf8>
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(&conn->recvmbox);
 203ae7c:	e0bfff17 	ldw	r2,-4(fp)
 203ae80:	10800504 	addi	r2,r2,20
 203ae84:	1009883a 	mov	r4,r2
 203ae88:	20152d80 	call	20152d8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 203ae8c:	e0bfff17 	ldw	r2,-4(fp)
 203ae90:	10000515 	stw	zero,20(r2)
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
 203ae94:	e0bfff17 	ldw	r2,-4(fp)
 203ae98:	10800617 	ldw	r2,24(r2)
 203ae9c:	10002626 	beq	r2,zero,203af38 <netconn_drain+0x164>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 203aea0:	00001706 	br	203af00 <netconn_drain+0x12c>
      struct netconn *newconn = (struct netconn *)mem;
 203aea4:	e0bffe17 	ldw	r2,-8(fp)
 203aea8:	e0bffd15 	stw	r2,-12(fp)
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 203aeac:	e0bfff17 	ldw	r2,-4(fp)
 203aeb0:	10800217 	ldw	r2,8(r2)
 203aeb4:	10000526 	beq	r2,zero,203aecc <netconn_drain+0xf8>
        tcp_accepted(conn->pcb.tcp);
 203aeb8:	e0bfff17 	ldw	r2,-4(fp)
 203aebc:	10800217 	ldw	r2,8(r2)
 203aec0:	10c00843 	ldbu	r3,33(r2)
 203aec4:	18ffffc4 	addi	r3,r3,-1
 203aec8:	10c00845 	stb	r3,33(r2)
      }
      /* drain recvmbox */
      netconn_drain(newconn);
 203aecc:	e13ffd17 	ldw	r4,-12(fp)
 203aed0:	203add40 	call	203add4 <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
 203aed4:	e0bffd17 	ldw	r2,-12(fp)
 203aed8:	10800217 	ldw	r2,8(r2)
 203aedc:	10000626 	beq	r2,zero,203aef8 <netconn_drain+0x124>
        tcp_abort(newconn->pcb.tcp);
 203aee0:	e0bffd17 	ldw	r2,-12(fp)
 203aee4:	10800217 	ldw	r2,8(r2)
 203aee8:	1009883a 	mov	r4,r2
 203aeec:	201bfb40 	call	201bfb4 <tcp_abort>
        newconn->pcb.tcp = NULL;
 203aef0:	e0bffd17 	ldw	r2,-12(fp)
 203aef4:	10000215 	stw	zero,8(r2)
      }
      netconn_free(newconn);
 203aef8:	e13ffd17 	ldw	r4,-12(fp)
 203aefc:	203ad840 	call	203ad84 <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 203af00:	e0bfff17 	ldw	r2,-4(fp)
 203af04:	10800604 	addi	r2,r2,24
 203af08:	e0fffe04 	addi	r3,fp,-8
 203af0c:	180b883a 	mov	r5,r3
 203af10:	1009883a 	mov	r4,r2
 203af14:	20154f80 	call	20154f8 <sys_arch_mbox_tryfetch>
 203af18:	10bfffd8 	cmpnei	r2,r2,-1
 203af1c:	103fe11e 	bne	r2,zero,203aea4 <__alt_mem_mem_0+0xfd01aea4>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
 203af20:	e0bfff17 	ldw	r2,-4(fp)
 203af24:	10800604 	addi	r2,r2,24
 203af28:	1009883a 	mov	r4,r2
 203af2c:	20152d80 	call	20152d8 <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 203af30:	e0bfff17 	ldw	r2,-4(fp)
 203af34:	10000615 	stw	zero,24(r2)
  }
#endif /* LWIP_TCP */
}
 203af38:	0001883a 	nop
 203af3c:	e037883a 	mov	sp,fp
 203af40:	dfc00117 	ldw	ra,4(sp)
 203af44:	df000017 	ldw	fp,0(sp)
 203af48:	dec00204 	addi	sp,sp,8
 203af4c:	f800283a 	ret

0203af50 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
 203af50:	defffb04 	addi	sp,sp,-20
 203af54:	dfc00415 	stw	ra,16(sp)
 203af58:	df000315 	stw	fp,12(sp)
 203af5c:	df000304 	addi	fp,sp,12
 203af60:	e13fff15 	stw	r4,-4(fp)
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
 203af64:	e0bfff17 	ldw	r2,-4(fp)
 203af68:	10800b17 	ldw	r2,44(r2)
 203af6c:	10800203 	ldbu	r2,8(r2)
 203af70:	e0bffd45 	stb	r2,-11(fp)
  shut_rx = shut & NETCONN_SHUT_RD;
 203af74:	e0bffd43 	ldbu	r2,-11(fp)
 203af78:	1080004c 	andi	r2,r2,1
 203af7c:	e0bffd85 	stb	r2,-10(fp)
  shut_tx = shut & NETCONN_SHUT_WR;
 203af80:	e0bffd43 	ldbu	r2,-11(fp)
 203af84:	1080008c 	andi	r2,r2,2
 203af88:	e0bffdc5 	stb	r2,-9(fp)
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;
 203af8c:	e0bffd43 	ldbu	r2,-11(fp)
 203af90:	108000e0 	cmpeqi	r2,r2,3
 203af94:	e0bffe05 	stb	r2,-8(fp)

  /* Set back some callback pointers */
  if (close) {
 203af98:	e0bffe03 	ldbu	r2,-8(fp)
 203af9c:	10000526 	beq	r2,zero,203afb4 <do_close_internal+0x64>
    tcp_arg(conn->pcb.tcp, NULL);
 203afa0:	e0bfff17 	ldw	r2,-4(fp)
 203afa4:	10800217 	ldw	r2,8(r2)
 203afa8:	000b883a 	mov	r5,zero
 203afac:	1009883a 	mov	r4,r2
 203afb0:	201d9400 	call	201d940 <tcp_arg>
  }
  if (conn->pcb.tcp->state == LISTEN) {
 203afb4:	e0bfff17 	ldw	r2,-4(fp)
 203afb8:	10800217 	ldw	r2,8(r2)
 203afbc:	10800617 	ldw	r2,24(r2)
 203afc0:	10800058 	cmpnei	r2,r2,1
 203afc4:	1000061e 	bne	r2,zero,203afe0 <do_close_internal+0x90>
    tcp_accept(conn->pcb.tcp, NULL);
 203afc8:	e0bfff17 	ldw	r2,-4(fp)
 203afcc:	10800217 	ldw	r2,8(r2)
 203afd0:	000b883a 	mov	r5,zero
 203afd4:	1009883a 	mov	r4,r2
 203afd8:	201da100 	call	201da10 <tcp_accept>
 203afdc:	00002006 	br	203b060 <do_close_internal+0x110>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
 203afe0:	e0bffd83 	ldbu	r2,-10(fp)
 203afe4:	10000a26 	beq	r2,zero,203b010 <do_close_internal+0xc0>
      tcp_recv(conn->pcb.tcp, NULL);
 203afe8:	e0bfff17 	ldw	r2,-4(fp)
 203afec:	10800217 	ldw	r2,8(r2)
 203aff0:	000b883a 	mov	r5,zero
 203aff4:	1009883a 	mov	r4,r2
 203aff8:	201d9740 	call	201d974 <tcp_recv>
      tcp_accept(conn->pcb.tcp, NULL);
 203affc:	e0bfff17 	ldw	r2,-4(fp)
 203b000:	10800217 	ldw	r2,8(r2)
 203b004:	000b883a 	mov	r5,zero
 203b008:	1009883a 	mov	r4,r2
 203b00c:	201da100 	call	201da10 <tcp_accept>
    }
    if (shut_tx) {
 203b010:	e0bffdc3 	ldbu	r2,-9(fp)
 203b014:	10000526 	beq	r2,zero,203b02c <do_close_internal+0xdc>
      tcp_sent(conn->pcb.tcp, NULL);
 203b018:	e0bfff17 	ldw	r2,-4(fp)
 203b01c:	10800217 	ldw	r2,8(r2)
 203b020:	000b883a 	mov	r5,zero
 203b024:	1009883a 	mov	r4,r2
 203b028:	201d9a80 	call	201d9a8 <tcp_sent>
    }
    if (close) {
 203b02c:	e0bffe03 	ldbu	r2,-8(fp)
 203b030:	10000b26 	beq	r2,zero,203b060 <do_close_internal+0x110>
      tcp_poll(conn->pcb.tcp, NULL, 4);
 203b034:	e0bfff17 	ldw	r2,-4(fp)
 203b038:	10800217 	ldw	r2,8(r2)
 203b03c:	01800104 	movi	r6,4
 203b040:	000b883a 	mov	r5,zero
 203b044:	1009883a 	mov	r4,r2
 203b048:	201da440 	call	201da44 <tcp_poll>
      tcp_err(conn->pcb.tcp, NULL);
 203b04c:	e0bfff17 	ldw	r2,-4(fp)
 203b050:	10800217 	ldw	r2,8(r2)
 203b054:	000b883a 	mov	r5,zero
 203b058:	1009883a 	mov	r4,r2
 203b05c:	201d9dc0 	call	201d9dc <tcp_err>
    }
  }
  /* Try to close the connection */
  if (close) {
 203b060:	e0bffe03 	ldbu	r2,-8(fp)
 203b064:	10000626 	beq	r2,zero,203b080 <do_close_internal+0x130>
    err = tcp_close(conn->pcb.tcp);
 203b068:	e0bfff17 	ldw	r2,-4(fp)
 203b06c:	10800217 	ldw	r2,8(r2)
 203b070:	1009883a 	mov	r4,r2
 203b074:	201bd080 	call	201bd08 <tcp_close>
 203b078:	e0bffd05 	stb	r2,-12(fp)
 203b07c:	00000906 	br	203b0a4 <do_close_internal+0x154>
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
 203b080:	e0bfff17 	ldw	r2,-4(fp)
 203b084:	10800217 	ldw	r2,8(r2)
 203b088:	e0fffd83 	ldbu	r3,-10(fp)
 203b08c:	e13ffdc3 	ldbu	r4,-9(fp)
 203b090:	200d883a 	mov	r6,r4
 203b094:	180b883a 	mov	r5,r3
 203b098:	1009883a 	mov	r4,r2
 203b09c:	201bd640 	call	201bd64 <tcp_shutdown>
 203b0a0:	e0bffd05 	stb	r2,-12(fp)
  }
  if (err == ERR_OK) {
 203b0a4:	e0bffd07 	ldb	r2,-12(fp)
 203b0a8:	10002f1e 	bne	r2,zero,203b168 <do_close_internal+0x218>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 203b0ac:	e0bfff17 	ldw	r2,-4(fp)
 203b0b0:	10800b17 	ldw	r2,44(r2)
 203b0b4:	10000105 	stb	zero,4(r2)
    conn->current_msg = NULL;
 203b0b8:	e0bfff17 	ldw	r2,-4(fp)
 203b0bc:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
 203b0c0:	e0bfff17 	ldw	r2,-4(fp)
 203b0c4:	10000115 	stw	zero,4(r2)
    if (close) {
 203b0c8:	e0bffe03 	ldbu	r2,-8(fp)
 203b0cc:	10000b26 	beq	r2,zero,203b0fc <do_close_internal+0x1ac>
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
 203b0d0:	e0bfff17 	ldw	r2,-4(fp)
 203b0d4:	10000215 	stw	zero,8(r2)
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 203b0d8:	e0bfff17 	ldw	r2,-4(fp)
 203b0dc:	10800c17 	ldw	r2,48(r2)
 203b0e0:	10000626 	beq	r2,zero,203b0fc <do_close_internal+0x1ac>
 203b0e4:	e0bfff17 	ldw	r2,-4(fp)
 203b0e8:	10800c17 	ldw	r2,48(r2)
 203b0ec:	000d883a 	mov	r6,zero
 203b0f0:	01400104 	movi	r5,4
 203b0f4:	e13fff17 	ldw	r4,-4(fp)
 203b0f8:	103ee83a 	callr	r2
    }
    if (shut_rx) {
 203b0fc:	e0bffd83 	ldbu	r2,-10(fp)
 203b100:	10000926 	beq	r2,zero,203b128 <do_close_internal+0x1d8>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 203b104:	e0bfff17 	ldw	r2,-4(fp)
 203b108:	10800c17 	ldw	r2,48(r2)
 203b10c:	10000626 	beq	r2,zero,203b128 <do_close_internal+0x1d8>
 203b110:	e0bfff17 	ldw	r2,-4(fp)
 203b114:	10800c17 	ldw	r2,48(r2)
 203b118:	000d883a 	mov	r6,zero
 203b11c:	000b883a 	mov	r5,zero
 203b120:	e13fff17 	ldw	r4,-4(fp)
 203b124:	103ee83a 	callr	r2
    }
    if (shut_tx) {
 203b128:	e0bffdc3 	ldbu	r2,-9(fp)
 203b12c:	10000926 	beq	r2,zero,203b154 <do_close_internal+0x204>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203b130:	e0bfff17 	ldw	r2,-4(fp)
 203b134:	10800c17 	ldw	r2,48(r2)
 203b138:	10000626 	beq	r2,zero,203b154 <do_close_internal+0x204>
 203b13c:	e0bfff17 	ldw	r2,-4(fp)
 203b140:	10800c17 	ldw	r2,48(r2)
 203b144:	000d883a 	mov	r6,zero
 203b148:	01400084 	movi	r5,2
 203b14c:	e13fff17 	ldw	r4,-4(fp)
 203b150:	103ee83a 	callr	r2
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 203b154:	e0bfff17 	ldw	r2,-4(fp)
 203b158:	10800404 	addi	r2,r2,16
 203b15c:	1009883a 	mov	r4,r2
 203b160:	2014f380 	call	2014f38 <sys_sem_signal>
    tcp_arg(conn->pcb.tcp, conn);
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 203b164:	00001806 	br	203b1c8 <do_close_internal+0x278>
    sys_sem_signal(&conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
 203b168:	e0bfff17 	ldw	r2,-4(fp)
 203b16c:	10800217 	ldw	r2,8(r2)
 203b170:	01408134 	movhi	r5,516
 203b174:	29696d04 	addi	r5,r5,-23116
 203b178:	1009883a 	mov	r4,r2
 203b17c:	201d9a80 	call	201d9a8 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
 203b180:	e0bfff17 	ldw	r2,-4(fp)
 203b184:	10800217 	ldw	r2,8(r2)
 203b188:	01800104 	movi	r6,4
 203b18c:	01408134 	movhi	r5,516
 203b190:	29692e04 	addi	r5,r5,-23368
 203b194:	1009883a 	mov	r4,r2
 203b198:	201da440 	call	201da44 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
 203b19c:	e0bfff17 	ldw	r2,-4(fp)
 203b1a0:	10800217 	ldw	r2,8(r2)
 203b1a4:	01408134 	movhi	r5,516
 203b1a8:	2969ac04 	addi	r5,r5,-22864
 203b1ac:	1009883a 	mov	r4,r2
 203b1b0:	201d9dc0 	call	201d9dc <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
 203b1b4:	e0bfff17 	ldw	r2,-4(fp)
 203b1b8:	10800217 	ldw	r2,8(r2)
 203b1bc:	e17fff17 	ldw	r5,-4(fp)
 203b1c0:	1009883a 	mov	r4,r2
 203b1c4:	201d9400 	call	201d940 <tcp_arg>
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 203b1c8:	0001883a 	nop
 203b1cc:	e037883a 	mov	sp,fp
 203b1d0:	dfc00117 	ldw	ra,4(sp)
 203b1d4:	df000017 	ldw	fp,0(sp)
 203b1d8:	dec00204 	addi	sp,sp,8
 203b1dc:	f800283a 	ret

0203b1e0 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 203b1e0:	defffd04 	addi	sp,sp,-12
 203b1e4:	dfc00215 	stw	ra,8(sp)
 203b1e8:	df000115 	stw	fp,4(sp)
 203b1ec:	df000104 	addi	fp,sp,4
 203b1f0:	e13fff15 	stw	r4,-4(fp)
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 203b1f4:	e0bfff17 	ldw	r2,-4(fp)
 203b1f8:	10800017 	ldw	r2,0(r2)
 203b1fc:	10800117 	ldw	r2,4(r2)
 203b200:	10000e26 	beq	r2,zero,203b23c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
 203b204:	e0bfff17 	ldw	r2,-4(fp)
 203b208:	10800017 	ldw	r2,0(r2)
 203b20c:	10800117 	ldw	r2,4(r2)
 */
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 203b210:	108000a0 	cmpeqi	r2,r2,2
 203b214:	1000091e 	bne	r2,zero,203b23c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_LISTEN) &&
     (msg->conn->state != NETCONN_CONNECT)) {
 203b218:	e0bfff17 	ldw	r2,-4(fp)
 203b21c:	10800017 	ldw	r2,0(r2)
 203b220:	10800117 	ldw	r2,4(r2)
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     (msg->conn->state != NETCONN_LISTEN) &&
 203b224:	108000e0 	cmpeqi	r2,r2,3
 203b228:	1000041e 	bne	r2,zero,203b23c <do_delconn+0x5c>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
 203b22c:	e0bfff17 	ldw	r2,-4(fp)
 203b230:	00fffec4 	movi	r3,-5
 203b234:	10c00105 	stb	r3,4(r2)
 203b238:	00005006 	br	203b37c <do_delconn+0x19c>
  } else {
    LWIP_ASSERT("blocking connect in progress",
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
 203b23c:	e0bfff17 	ldw	r2,-4(fp)
 203b240:	10800017 	ldw	r2,0(r2)
 203b244:	1009883a 	mov	r4,r2
 203b248:	203add40 	call	203add4 <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
 203b24c:	e0bfff17 	ldw	r2,-4(fp)
 203b250:	10800017 	ldw	r2,0(r2)
 203b254:	10800217 	ldw	r2,8(r2)
 203b258:	10002e26 	beq	r2,zero,203b314 <do_delconn+0x134>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203b25c:	e0bfff17 	ldw	r2,-4(fp)
 203b260:	10800017 	ldw	r2,0(r2)
 203b264:	10800017 	ldw	r2,0(r2)
 203b268:	10803c0c 	andi	r2,r2,240
 203b26c:	10c00820 	cmpeqi	r3,r2,32
 203b270:	18000b1e 	bne	r3,zero,203b2a0 <do_delconn+0xc0>
 203b274:	10c01020 	cmpeqi	r3,r2,64
 203b278:	1800031e 	bne	r3,zero,203b288 <do_delconn+0xa8>
 203b27c:	10800420 	cmpeqi	r2,r2,16
 203b280:	1000111e 	bne	r2,zero,203b2c8 <do_delconn+0xe8>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
#endif /* LWIP_TCP */
      default:
        break;
 203b284:	00002006 	br	203b308 <do_delconn+0x128>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
 203b288:	e0bfff17 	ldw	r2,-4(fp)
 203b28c:	10800017 	ldw	r2,0(r2)
 203b290:	10800217 	ldw	r2,8(r2)
 203b294:	1009883a 	mov	r4,r2
 203b298:	2034ab40 	call	2034ab4 <raw_remove>
        break;
 203b29c:	00001a06 	br	203b308 <do_delconn+0x128>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
 203b2a0:	e0bfff17 	ldw	r2,-4(fp)
 203b2a4:	10800017 	ldw	r2,0(r2)
 203b2a8:	10800217 	ldw	r2,8(r2)
 203b2ac:	10000715 	stw	zero,28(r2)
        udp_remove(msg->conn->pcb.udp);
 203b2b0:	e0bfff17 	ldw	r2,-4(fp)
 203b2b4:	10800017 	ldw	r2,0(r2)
 203b2b8:	10800217 	ldw	r2,8(r2)
 203b2bc:	1009883a 	mov	r4,r2
 203b2c0:	2022a7c0 	call	2022a7c <udp_remove>
        break;
 203b2c4:	00001006 	br	203b308 <do_delconn+0x128>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 203b2c8:	e0bfff17 	ldw	r2,-4(fp)
 203b2cc:	10800017 	ldw	r2,0(r2)
 203b2d0:	00c00104 	movi	r3,4
 203b2d4:	10c00115 	stw	r3,4(r2)
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 203b2d8:	e0bfff17 	ldw	r2,-4(fp)
 203b2dc:	00c000c4 	movi	r3,3
 203b2e0:	10c00205 	stb	r3,8(r2)
        msg->conn->current_msg = msg;
 203b2e4:	e0bfff17 	ldw	r2,-4(fp)
 203b2e8:	10800017 	ldw	r2,0(r2)
 203b2ec:	e0ffff17 	ldw	r3,-4(fp)
 203b2f0:	10c00b15 	stw	r3,44(r2)
        do_close_internal(msg->conn);
 203b2f4:	e0bfff17 	ldw	r2,-4(fp)
 203b2f8:	10800017 	ldw	r2,0(r2)
 203b2fc:	1009883a 	mov	r4,r2
 203b300:	203af500 	call	203af50 <do_close_internal>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
 203b304:	00002606 	br	203b3a0 <do_delconn+0x1c0>
#endif /* LWIP_TCP */
      default:
        break;
      }
      msg->conn->pcb.tcp = NULL;
 203b308:	e0bfff17 	ldw	r2,-4(fp)
 203b30c:	10800017 	ldw	r2,0(r2)
 203b310:	10000215 	stw	zero,8(r2)
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 203b314:	e0bfff17 	ldw	r2,-4(fp)
 203b318:	10800017 	ldw	r2,0(r2)
 203b31c:	10800c17 	ldw	r2,48(r2)
 203b320:	10000926 	beq	r2,zero,203b348 <do_delconn+0x168>
 203b324:	e0bfff17 	ldw	r2,-4(fp)
 203b328:	10800017 	ldw	r2,0(r2)
 203b32c:	10800c17 	ldw	r2,48(r2)
 203b330:	e0ffff17 	ldw	r3,-4(fp)
 203b334:	18c00017 	ldw	r3,0(r3)
 203b338:	000d883a 	mov	r6,zero
 203b33c:	000b883a 	mov	r5,zero
 203b340:	1809883a 	mov	r4,r3
 203b344:	103ee83a 	callr	r2
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 203b348:	e0bfff17 	ldw	r2,-4(fp)
 203b34c:	10800017 	ldw	r2,0(r2)
 203b350:	10800c17 	ldw	r2,48(r2)
 203b354:	10000926 	beq	r2,zero,203b37c <do_delconn+0x19c>
 203b358:	e0bfff17 	ldw	r2,-4(fp)
 203b35c:	10800017 	ldw	r2,0(r2)
 203b360:	10800c17 	ldw	r2,48(r2)
 203b364:	e0ffff17 	ldw	r3,-4(fp)
 203b368:	18c00017 	ldw	r3,0(r3)
 203b36c:	000d883a 	mov	r6,zero
 203b370:	01400084 	movi	r5,2
 203b374:	1809883a 	mov	r4,r3
 203b378:	103ee83a 	callr	r2
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 203b37c:	e0bfff17 	ldw	r2,-4(fp)
 203b380:	10800017 	ldw	r2,0(r2)
 203b384:	10800417 	ldw	r2,16(r2)
 203b388:	10000526 	beq	r2,zero,203b3a0 <do_delconn+0x1c0>
    sys_sem_signal(&msg->conn->op_completed);
 203b38c:	e0bfff17 	ldw	r2,-4(fp)
 203b390:	10800017 	ldw	r2,0(r2)
 203b394:	10800404 	addi	r2,r2,16
 203b398:	1009883a 	mov	r4,r2
 203b39c:	2014f380 	call	2014f38 <sys_sem_signal>
  }
}
 203b3a0:	e037883a 	mov	sp,fp
 203b3a4:	dfc00117 	ldw	ra,4(sp)
 203b3a8:	df000017 	ldw	fp,0(sp)
 203b3ac:	dec00204 	addi	sp,sp,8
 203b3b0:	f800283a 	ret

0203b3b4 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
 203b3b4:	defffd04 	addi	sp,sp,-12
 203b3b8:	dfc00215 	stw	ra,8(sp)
 203b3bc:	df000115 	stw	fp,4(sp)
 203b3c0:	df000104 	addi	fp,sp,4
 203b3c4:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 203b3c8:	e0bfff17 	ldw	r2,-4(fp)
 203b3cc:	10800017 	ldw	r2,0(r2)
 203b3d0:	10800303 	ldbu	r2,12(r2)
 203b3d4:	10803fcc 	andi	r2,r2,255
 203b3d8:	1080201c 	xori	r2,r2,128
 203b3dc:	10bfe004 	addi	r2,r2,-128
 203b3e0:	10bffdc8 	cmpgei	r2,r2,-9
 203b3e4:	1000061e 	bne	r2,zero,203b400 <do_bind+0x4c>
    msg->err = msg->conn->last_err;
 203b3e8:	e0bfff17 	ldw	r2,-4(fp)
 203b3ec:	10800017 	ldw	r2,0(r2)
 203b3f0:	10c00303 	ldbu	r3,12(r2)
 203b3f4:	e0bfff17 	ldw	r2,-4(fp)
 203b3f8:	10c00105 	stb	r3,4(r2)
 203b3fc:	00003e06 	br	203b4f8 <do_bind+0x144>
  } else {
    msg->err = ERR_VAL;
 203b400:	e0bfff17 	ldw	r2,-4(fp)
 203b404:	00fffe84 	movi	r3,-6
 203b408:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 203b40c:	e0bfff17 	ldw	r2,-4(fp)
 203b410:	10800017 	ldw	r2,0(r2)
 203b414:	10800217 	ldw	r2,8(r2)
 203b418:	10003726 	beq	r2,zero,203b4f8 <do_bind+0x144>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203b41c:	e0bfff17 	ldw	r2,-4(fp)
 203b420:	10800017 	ldw	r2,0(r2)
 203b424:	10800017 	ldw	r2,0(r2)
 203b428:	10803c0c 	andi	r2,r2,240
 203b42c:	10c00820 	cmpeqi	r3,r2,32
 203b430:	1800111e 	bne	r3,zero,203b478 <do_bind+0xc4>
 203b434:	10c01020 	cmpeqi	r3,r2,64
 203b438:	1800031e 	bne	r3,zero,203b448 <do_bind+0x94>
 203b43c:	10800420 	cmpeqi	r2,r2,16
 203b440:	10001d1e 	bne	r2,zero,203b4b8 <do_bind+0x104>
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
 203b444:	00002c06 	br	203b4f8 <do_bind+0x144>
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 203b448:	e0bfff17 	ldw	r2,-4(fp)
 203b44c:	10800017 	ldw	r2,0(r2)
 203b450:	10c00217 	ldw	r3,8(r2)
 203b454:	e0bfff17 	ldw	r2,-4(fp)
 203b458:	10800217 	ldw	r2,8(r2)
 203b45c:	100b883a 	mov	r5,r2
 203b460:	1809883a 	mov	r4,r3
 203b464:	20348140 	call	2034814 <raw_bind>
 203b468:	1007883a 	mov	r3,r2
 203b46c:	e0bfff17 	ldw	r2,-4(fp)
 203b470:	10c00105 	stb	r3,4(r2)
        break;
 203b474:	00002006 	br	203b4f8 <do_bind+0x144>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 203b478:	e0bfff17 	ldw	r2,-4(fp)
 203b47c:	10800017 	ldw	r2,0(r2)
 203b480:	10c00217 	ldw	r3,8(r2)
 203b484:	e0bfff17 	ldw	r2,-4(fp)
 203b488:	11000217 	ldw	r4,8(r2)
 203b48c:	e0bfff17 	ldw	r2,-4(fp)
 203b490:	1080030b 	ldhu	r2,12(r2)
 203b494:	10bfffcc 	andi	r2,r2,65535
 203b498:	100d883a 	mov	r6,r2
 203b49c:	200b883a 	mov	r5,r4
 203b4a0:	1809883a 	mov	r4,r3
 203b4a4:	20227840 	call	2022784 <udp_bind>
 203b4a8:	1007883a 	mov	r3,r2
 203b4ac:	e0bfff17 	ldw	r2,-4(fp)
 203b4b0:	10c00105 	stb	r3,4(r2)
        break;
 203b4b4:	00001006 	br	203b4f8 <do_bind+0x144>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 203b4b8:	e0bfff17 	ldw	r2,-4(fp)
 203b4bc:	10800017 	ldw	r2,0(r2)
 203b4c0:	10c00217 	ldw	r3,8(r2)
 203b4c4:	e0bfff17 	ldw	r2,-4(fp)
 203b4c8:	11000217 	ldw	r4,8(r2)
 203b4cc:	e0bfff17 	ldw	r2,-4(fp)
 203b4d0:	1080030b 	ldhu	r2,12(r2)
 203b4d4:	10bfffcc 	andi	r2,r2,65535
 203b4d8:	100d883a 	mov	r6,r2
 203b4dc:	200b883a 	mov	r5,r4
 203b4e0:	1809883a 	mov	r4,r3
 203b4e4:	201bfec0 	call	201bfec <tcp_bind>
 203b4e8:	1007883a 	mov	r3,r2
 203b4ec:	e0bfff17 	ldw	r2,-4(fp)
 203b4f0:	10c00105 	stb	r3,4(r2)
        break;
 203b4f4:	0001883a 	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 203b4f8:	e0bfff17 	ldw	r2,-4(fp)
 203b4fc:	10800017 	ldw	r2,0(r2)
 203b500:	10800404 	addi	r2,r2,16
 203b504:	1009883a 	mov	r4,r2
 203b508:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203b50c:	0001883a 	nop
 203b510:	e037883a 	mov	sp,fp
 203b514:	dfc00117 	ldw	ra,4(sp)
 203b518:	df000017 	ldw	fp,0(sp)
 203b51c:	dec00204 	addi	sp,sp,8
 203b520:	f800283a 	ret

0203b524 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
 203b524:	defff904 	addi	sp,sp,-28
 203b528:	dfc00615 	stw	ra,24(sp)
 203b52c:	df000515 	stw	fp,20(sp)
 203b530:	df000504 	addi	fp,sp,20
 203b534:	e13ffd15 	stw	r4,-12(fp)
 203b538:	e17ffe15 	stw	r5,-8(fp)
 203b53c:	3005883a 	mov	r2,r6
 203b540:	e0bfff05 	stb	r2,-4(fp)
  struct netconn *conn;
  int was_blocking;

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
 203b544:	e0bffd17 	ldw	r2,-12(fp)
 203b548:	e0bffb15 	stw	r2,-20(fp)

  if (conn == NULL) {
 203b54c:	e0bffb17 	ldw	r2,-20(fp)
 203b550:	1000021e 	bne	r2,zero,203b55c <do_connected+0x38>
    return ERR_VAL;
 203b554:	00bffe84 	movi	r2,-6
 203b558:	00004206 	br	203b664 <do_connected+0x140>

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
 203b55c:	e0bffb17 	ldw	r2,-20(fp)
 203b560:	10800b17 	ldw	r2,44(r2)
 203b564:	10000426 	beq	r2,zero,203b578 <do_connected+0x54>
    conn->current_msg->err = err;
 203b568:	e0bffb17 	ldw	r2,-20(fp)
 203b56c:	10800b17 	ldw	r2,44(r2)
 203b570:	e0ffff03 	ldbu	r3,-4(fp)
 203b574:	10c00105 	stb	r3,4(r2)
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
 203b578:	e0bffb17 	ldw	r2,-20(fp)
 203b57c:	10800017 	ldw	r2,0(r2)
 203b580:	10800418 	cmpnei	r2,r2,16
 203b584:	1000041e 	bne	r2,zero,203b598 <do_connected+0x74>
 203b588:	e0bfff07 	ldb	r2,-4(fp)
 203b58c:	1000021e 	bne	r2,zero,203b598 <do_connected+0x74>
    setup_tcp(conn);
 203b590:	e13ffb17 	ldw	r4,-20(fp)
 203b594:	203a8640 	call	203a864 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 203b598:	e0bffb17 	ldw	r2,-20(fp)
 203b59c:	10800903 	ldbu	r2,36(r2)
 203b5a0:	10803fcc 	andi	r2,r2,255
 203b5a4:	1080010c 	andi	r2,r2,4
 203b5a8:	1005003a 	cmpeq	r2,r2,zero
 203b5ac:	10803fcc 	andi	r2,r2,255
 203b5b0:	e0bffc15 	stw	r2,-16(fp)
  SET_NONBLOCKING_CONNECT(conn, 0);
 203b5b4:	e0bffb17 	ldw	r2,-20(fp)
 203b5b8:	10c00903 	ldbu	r3,36(r2)
 203b5bc:	00bffec4 	movi	r2,-5
 203b5c0:	1884703a 	and	r2,r3,r2
 203b5c4:	1007883a 	mov	r3,r2
 203b5c8:	e0bffb17 	ldw	r2,-20(fp)
 203b5cc:	10c00905 	stb	r3,36(r2)
  conn->current_msg = NULL;
 203b5d0:	e0bffb17 	ldw	r2,-20(fp)
 203b5d4:	10000b15 	stw	zero,44(r2)
  conn->state = NETCONN_NONE;
 203b5d8:	e0bffb17 	ldw	r2,-20(fp)
 203b5dc:	10000115 	stw	zero,4(r2)
  if (!was_blocking) {
 203b5e0:	e0bffc17 	ldw	r2,-16(fp)
 203b5e4:	10000f1e 	bne	r2,zero,203b624 <do_connected+0x100>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 203b5e8:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203b5ec:	10000126 	beq	r2,zero,203b5f4 <do_connected+0xd0>
 203b5f0:	2010f300 	call	2010f30 <vTaskEnterCritical>
 203b5f4:	e0bffb17 	ldw	r2,-20(fp)
 203b5f8:	10800303 	ldbu	r2,12(r2)
 203b5fc:	10803fcc 	andi	r2,r2,255
 203b600:	1080201c 	xori	r2,r2,128
 203b604:	10bfe004 	addi	r2,r2,-128
 203b608:	10bffdd0 	cmplti	r2,r2,-9
 203b60c:	1000021e 	bne	r2,zero,203b618 <do_connected+0xf4>
 203b610:	e0bffb17 	ldw	r2,-20(fp)
 203b614:	10000305 	stb	zero,12(r2)
 203b618:	2010b680 	call	2010b68 <xTaskGetSchedulerState>
 203b61c:	10000126 	beq	r2,zero,203b624 <do_connected+0x100>
 203b620:	2010f780 	call	2010f78 <vTaskExitCritical>
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 203b624:	e0bffb17 	ldw	r2,-20(fp)
 203b628:	10800c17 	ldw	r2,48(r2)
 203b62c:	10000626 	beq	r2,zero,203b648 <do_connected+0x124>
 203b630:	e0bffb17 	ldw	r2,-20(fp)
 203b634:	10800c17 	ldw	r2,48(r2)
 203b638:	000d883a 	mov	r6,zero
 203b63c:	01400084 	movi	r5,2
 203b640:	e13ffb17 	ldw	r4,-20(fp)
 203b644:	103ee83a 	callr	r2

  if (was_blocking) {
 203b648:	e0bffc17 	ldw	r2,-16(fp)
 203b64c:	10000426 	beq	r2,zero,203b660 <do_connected+0x13c>
    sys_sem_signal(&conn->op_completed);
 203b650:	e0bffb17 	ldw	r2,-20(fp)
 203b654:	10800404 	addi	r2,r2,16
 203b658:	1009883a 	mov	r4,r2
 203b65c:	2014f380 	call	2014f38 <sys_sem_signal>
  }
  return ERR_OK;
 203b660:	0005883a 	mov	r2,zero
}
 203b664:	e037883a 	mov	sp,fp
 203b668:	dfc00117 	ldw	ra,4(sp)
 203b66c:	df000017 	ldw	fp,0(sp)
 203b670:	dec00204 	addi	sp,sp,8
 203b674:	f800283a 	ret

0203b678 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
 203b678:	defffc04 	addi	sp,sp,-16
 203b67c:	dfc00315 	stw	ra,12(sp)
 203b680:	df000215 	stw	fp,8(sp)
 203b684:	df000204 	addi	fp,sp,8
 203b688:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.tcp == NULL) {
 203b68c:	e0bfff17 	ldw	r2,-4(fp)
 203b690:	10800017 	ldw	r2,0(r2)
 203b694:	10800217 	ldw	r2,8(r2)
 203b698:	1000041e 	bne	r2,zero,203b6ac <do_connect+0x34>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
 203b69c:	e0bfff17 	ldw	r2,-4(fp)
 203b6a0:	00fffd04 	movi	r3,-12
 203b6a4:	10c00105 	stb	r3,4(r2)
 203b6a8:	00007c06 	br	203b89c <do_connect+0x224>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203b6ac:	e0bfff17 	ldw	r2,-4(fp)
 203b6b0:	10800017 	ldw	r2,0(r2)
 203b6b4:	10800017 	ldw	r2,0(r2)
 203b6b8:	10803c0c 	andi	r2,r2,240
 203b6bc:	10c00820 	cmpeqi	r3,r2,32
 203b6c0:	1800111e 	bne	r3,zero,203b708 <do_connect+0x90>
 203b6c4:	10c01020 	cmpeqi	r3,r2,64
 203b6c8:	1800031e 	bne	r3,zero,203b6d8 <do_connect+0x60>
 203b6cc:	10800420 	cmpeqi	r2,r2,16
 203b6d0:	10001d1e 	bne	r2,zero,203b748 <do_connect+0xd0>
 203b6d4:	00006706 	br	203b874 <do_connect+0x1fc>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 203b6d8:	e0bfff17 	ldw	r2,-4(fp)
 203b6dc:	10800017 	ldw	r2,0(r2)
 203b6e0:	10c00217 	ldw	r3,8(r2)
 203b6e4:	e0bfff17 	ldw	r2,-4(fp)
 203b6e8:	10800217 	ldw	r2,8(r2)
 203b6ec:	100b883a 	mov	r5,r2
 203b6f0:	1809883a 	mov	r4,r3
 203b6f4:	203485c0 	call	203485c <raw_connect>
 203b6f8:	1007883a 	mov	r3,r2
 203b6fc:	e0bfff17 	ldw	r2,-4(fp)
 203b700:	10c00105 	stb	r3,4(r2)
    break;
 203b704:	00006506 	br	203b89c <do_connect+0x224>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 203b708:	e0bfff17 	ldw	r2,-4(fp)
 203b70c:	10800017 	ldw	r2,0(r2)
 203b710:	10c00217 	ldw	r3,8(r2)
 203b714:	e0bfff17 	ldw	r2,-4(fp)
 203b718:	11000217 	ldw	r4,8(r2)
 203b71c:	e0bfff17 	ldw	r2,-4(fp)
 203b720:	1080030b 	ldhu	r2,12(r2)
 203b724:	10bfffcc 	andi	r2,r2,65535
 203b728:	100d883a 	mov	r6,r2
 203b72c:	200b883a 	mov	r5,r4
 203b730:	1809883a 	mov	r4,r3
 203b734:	20228e00 	call	20228e0 <udp_connect>
 203b738:	1007883a 	mov	r3,r2
 203b73c:	e0bfff17 	ldw	r2,-4(fp)
 203b740:	10c00105 	stb	r3,4(r2)
    break;
 203b744:	00005506 	br	203b89c <do_connect+0x224>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
 203b748:	e0bfff17 	ldw	r2,-4(fp)
 203b74c:	10800017 	ldw	r2,0(r2)
 203b750:	10800117 	ldw	r2,4(r2)
 203b754:	10000426 	beq	r2,zero,203b768 <do_connect+0xf0>
      msg->err = ERR_ISCONN;
 203b758:	e0bfff17 	ldw	r2,-4(fp)
 203b75c:	00fffdc4 	movi	r3,-9
 203b760:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 203b764:	00004c06 	br	203b898 <do_connect+0x220>
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
 203b768:	e0bfff17 	ldw	r2,-4(fp)
 203b76c:	10800017 	ldw	r2,0(r2)
 203b770:	1009883a 	mov	r4,r2
 203b774:	203a8640 	call	203a864 <setup_tcp>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
 203b778:	e0bfff17 	ldw	r2,-4(fp)
 203b77c:	10800017 	ldw	r2,0(r2)
 203b780:	10c00217 	ldw	r3,8(r2)
 203b784:	e0bfff17 	ldw	r2,-4(fp)
 203b788:	11000217 	ldw	r4,8(r2)
        msg->msg.bc.port, do_connected);
 203b78c:	e0bfff17 	ldw	r2,-4(fp)
 203b790:	1080030b 	ldhu	r2,12(r2)
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
 203b794:	10bfffcc 	andi	r2,r2,65535
 203b798:	01c08134 	movhi	r7,516
 203b79c:	39ed4904 	addi	r7,r7,-19164
 203b7a0:	100d883a 	mov	r6,r2
 203b7a4:	200b883a 	mov	r5,r4
 203b7a8:	1809883a 	mov	r4,r3
 203b7ac:	201c6c40 	call	201c6c4 <tcp_connect>
 203b7b0:	1007883a 	mov	r3,r2
 203b7b4:	e0bfff17 	ldw	r2,-4(fp)
 203b7b8:	10c00105 	stb	r3,4(r2)
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
 203b7bc:	e0bfff17 	ldw	r2,-4(fp)
 203b7c0:	10800103 	ldbu	r2,4(r2)
 203b7c4:	10803fcc 	andi	r2,r2,255
 203b7c8:	1080201c 	xori	r2,r2,128
 203b7cc:	10bfe004 	addi	r2,r2,-128
 203b7d0:	1000311e 	bne	r2,zero,203b898 <do_connect+0x220>
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 203b7d4:	e0bfff17 	ldw	r2,-4(fp)
 203b7d8:	10800017 	ldw	r2,0(r2)
 203b7dc:	10800903 	ldbu	r2,36(r2)
 203b7e0:	10803fcc 	andi	r2,r2,255
 203b7e4:	1080008c 	andi	r2,r2,2
 203b7e8:	1004c03a 	cmpne	r2,r2,zero
 203b7ec:	e0bffe05 	stb	r2,-8(fp)
        msg->conn->state = NETCONN_CONNECT;
 203b7f0:	e0bfff17 	ldw	r2,-4(fp)
 203b7f4:	10800017 	ldw	r2,0(r2)
 203b7f8:	00c000c4 	movi	r3,3
 203b7fc:	10c00115 	stw	r3,4(r2)
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 203b800:	e0bffe03 	ldbu	r2,-8(fp)
 203b804:	10000826 	beq	r2,zero,203b828 <do_connect+0x1b0>
 203b808:	e0bfff17 	ldw	r2,-4(fp)
 203b80c:	10800017 	ldw	r2,0(r2)
 203b810:	e0ffff17 	ldw	r3,-4(fp)
 203b814:	18c00017 	ldw	r3,0(r3)
 203b818:	18c00903 	ldbu	r3,36(r3)
 203b81c:	18c00114 	ori	r3,r3,4
 203b820:	10c00905 	stb	r3,36(r2)
 203b824:	00000806 	br	203b848 <do_connect+0x1d0>
 203b828:	e0bfff17 	ldw	r2,-4(fp)
 203b82c:	10800017 	ldw	r2,0(r2)
 203b830:	e0ffff17 	ldw	r3,-4(fp)
 203b834:	18c00017 	ldw	r3,0(r3)
 203b838:	19000903 	ldbu	r4,36(r3)
 203b83c:	00fffec4 	movi	r3,-5
 203b840:	20c6703a 	and	r3,r4,r3
 203b844:	10c00905 	stb	r3,36(r2)
        if (non_blocking) {
 203b848:	e0bffe03 	ldbu	r2,-8(fp)
 203b84c:	10000426 	beq	r2,zero,203b860 <do_connect+0x1e8>
          msg->err = ERR_INPROGRESS;
 203b850:	e0bfff17 	ldw	r2,-4(fp)
 203b854:	00fffec4 	movi	r3,-5
 203b858:	10c00105 	stb	r3,4(r2)
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 203b85c:	00000e06 	br	203b898 <do_connect+0x220>
        msg->conn->state = NETCONN_CONNECT;
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
        } else {
          msg->conn->current_msg = msg;
 203b860:	e0bfff17 	ldw	r2,-4(fp)
 203b864:	10800017 	ldw	r2,0(r2)
 203b868:	e0ffff17 	ldw	r3,-4(fp)
 203b86c:	10c00b15 	stw	r3,44(r2)
          /* sys_sem_signal() is called from do_connected (or err_tcp()),
          * when the connection is established! */
          return;
 203b870:	00000f06 	br	203b8b0 <do_connect+0x238>
      }
    }
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 203b874:	01c08134 	movhi	r7,516
 203b878:	39ce4104 	addi	r7,r7,14596
 203b87c:	01810144 	movi	r6,1029
 203b880:	01408134 	movhi	r5,516
 203b884:	294e4704 	addi	r5,r5,14620
 203b888:	01008134 	movhi	r4,516
 203b88c:	210e4d04 	addi	r4,r4,14644
 203b890:	2000bb00 	call	2000bb0 <printf>
 203b894:	003fff06 	br	203b894 <__alt_mem_mem_0+0xfd01b894>
          * when the connection is established! */
          return;
        }
      }
    }
    break;
 203b898:	0001883a 	nop
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 203b89c:	e0bfff17 	ldw	r2,-4(fp)
 203b8a0:	10800017 	ldw	r2,0(r2)
 203b8a4:	10800404 	addi	r2,r2,16
 203b8a8:	1009883a 	mov	r4,r2
 203b8ac:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203b8b0:	e037883a 	mov	sp,fp
 203b8b4:	dfc00117 	ldw	ra,4(sp)
 203b8b8:	df000017 	ldw	fp,0(sp)
 203b8bc:	dec00204 	addi	sp,sp,8
 203b8c0:	f800283a 	ret

0203b8c4 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
 203b8c4:	defffd04 	addi	sp,sp,-12
 203b8c8:	dfc00215 	stw	ra,8(sp)
 203b8cc:	df000115 	stw	fp,4(sp)
 203b8d0:	df000104 	addi	fp,sp,4
 203b8d4:	e13fff15 	stw	r4,-4(fp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 203b8d8:	e0bfff17 	ldw	r2,-4(fp)
 203b8dc:	10800017 	ldw	r2,0(r2)
 203b8e0:	10800017 	ldw	r2,0(r2)
 203b8e4:	10803c0c 	andi	r2,r2,240
 203b8e8:	10800818 	cmpnei	r2,r2,32
 203b8ec:	1000081e 	bne	r2,zero,203b910 <do_disconnect+0x4c>
    udp_disconnect(msg->conn->pcb.udp);
 203b8f0:	e0bfff17 	ldw	r2,-4(fp)
 203b8f4:	10800017 	ldw	r2,0(r2)
 203b8f8:	10800217 	ldw	r2,8(r2)
 203b8fc:	1009883a 	mov	r4,r2
 203b900:	20229e80 	call	20229e8 <udp_disconnect>
    msg->err = ERR_OK;
 203b904:	e0bfff17 	ldw	r2,-4(fp)
 203b908:	10000105 	stb	zero,4(r2)
 203b90c:	00000306 	br	203b91c <do_disconnect+0x58>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
 203b910:	e0bfff17 	ldw	r2,-4(fp)
 203b914:	00fffe84 	movi	r3,-6
 203b918:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 203b91c:	e0bfff17 	ldw	r2,-4(fp)
 203b920:	10800017 	ldw	r2,0(r2)
 203b924:	10800404 	addi	r2,r2,16
 203b928:	1009883a 	mov	r4,r2
 203b92c:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203b930:	0001883a 	nop
 203b934:	e037883a 	mov	sp,fp
 203b938:	dfc00117 	ldw	ra,4(sp)
 203b93c:	df000017 	ldw	fp,0(sp)
 203b940:	dec00204 	addi	sp,sp,8
 203b944:	f800283a 	ret

0203b948 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
 203b948:	defffc04 	addi	sp,sp,-16
 203b94c:	dfc00315 	stw	ra,12(sp)
 203b950:	df000215 	stw	fp,8(sp)
 203b954:	df000204 	addi	fp,sp,8
 203b958:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 203b95c:	e0bfff17 	ldw	r2,-4(fp)
 203b960:	10800017 	ldw	r2,0(r2)
 203b964:	10800303 	ldbu	r2,12(r2)
 203b968:	10803fcc 	andi	r2,r2,255
 203b96c:	1080201c 	xori	r2,r2,128
 203b970:	10bfe004 	addi	r2,r2,-128
 203b974:	10bffdc8 	cmpgei	r2,r2,-9
 203b978:	1000061e 	bne	r2,zero,203b994 <do_listen+0x4c>
    msg->err = msg->conn->last_err;
 203b97c:	e0bfff17 	ldw	r2,-4(fp)
 203b980:	10800017 	ldw	r2,0(r2)
 203b984:	10c00303 	ldbu	r3,12(r2)
 203b988:	e0bfff17 	ldw	r2,-4(fp)
 203b98c:	10c00105 	stb	r3,4(r2)
 203b990:	00006206 	br	203bb1c <do_listen+0x1d4>
  } else {
    msg->err = ERR_CONN;
 203b994:	e0bfff17 	ldw	r2,-4(fp)
 203b998:	00fffcc4 	movi	r3,-13
 203b99c:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 203b9a0:	e0bfff17 	ldw	r2,-4(fp)
 203b9a4:	10800017 	ldw	r2,0(r2)
 203b9a8:	10800217 	ldw	r2,8(r2)
 203b9ac:	10005b26 	beq	r2,zero,203bb1c <do_listen+0x1d4>
      if (msg->conn->type == NETCONN_TCP) {
 203b9b0:	e0bfff17 	ldw	r2,-4(fp)
 203b9b4:	10800017 	ldw	r2,0(r2)
 203b9b8:	10800017 	ldw	r2,0(r2)
 203b9bc:	10800418 	cmpnei	r2,r2,16
 203b9c0:	1000531e 	bne	r2,zero,203bb10 <do_listen+0x1c8>
        if (msg->conn->state == NETCONN_NONE) {
 203b9c4:	e0bfff17 	ldw	r2,-4(fp)
 203b9c8:	10800017 	ldw	r2,0(r2)
 203b9cc:	10800117 	ldw	r2,4(r2)
 203b9d0:	1000521e 	bne	r2,zero,203bb1c <do_listen+0x1d4>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
 203b9d4:	e0bfff17 	ldw	r2,-4(fp)
 203b9d8:	10800017 	ldw	r2,0(r2)
 203b9dc:	10c00217 	ldw	r3,8(r2)
 203b9e0:	e0bfff17 	ldw	r2,-4(fp)
 203b9e4:	10800203 	ldbu	r2,8(r2)
 203b9e8:	10803fcc 	andi	r2,r2,255
 203b9ec:	100b883a 	mov	r5,r2
 203b9f0:	1809883a 	mov	r4,r3
 203b9f4:	201c1ec0 	call	201c1ec <tcp_listen_with_backlog>
 203b9f8:	e0bffe15 	stw	r2,-8(fp)
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
 203b9fc:	e0bffe17 	ldw	r2,-8(fp)
 203ba00:	1000041e 	bne	r2,zero,203ba14 <do_listen+0xcc>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
 203ba04:	e0bfff17 	ldw	r2,-4(fp)
 203ba08:	00ffffc4 	movi	r3,-1
 203ba0c:	10c00105 	stb	r3,4(r2)
 203ba10:	00004206 	br	203bb1c <do_listen+0x1d4>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 203ba14:	e0bfff17 	ldw	r2,-4(fp)
 203ba18:	10800017 	ldw	r2,0(r2)
 203ba1c:	10800517 	ldw	r2,20(r2)
 203ba20:	10000826 	beq	r2,zero,203ba44 <do_listen+0xfc>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
 203ba24:	e0bfff17 	ldw	r2,-4(fp)
 203ba28:	10800017 	ldw	r2,0(r2)
 203ba2c:	10800504 	addi	r2,r2,20
 203ba30:	1009883a 	mov	r4,r2
 203ba34:	20152d80 	call	20152d8 <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 203ba38:	e0bfff17 	ldw	r2,-4(fp)
 203ba3c:	10800017 	ldw	r2,0(r2)
 203ba40:	10000515 	stw	zero,20(r2)
            }
            msg->err = ERR_OK;
 203ba44:	e0bfff17 	ldw	r2,-4(fp)
 203ba48:	10000105 	stb	zero,4(r2)
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 203ba4c:	e0bfff17 	ldw	r2,-4(fp)
 203ba50:	10800017 	ldw	r2,0(r2)
 203ba54:	10800617 	ldw	r2,24(r2)
 203ba58:	1000091e 	bne	r2,zero,203ba80 <do_listen+0x138>
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 203ba5c:	e0bfff17 	ldw	r2,-4(fp)
 203ba60:	10800017 	ldw	r2,0(r2)
 203ba64:	10800604 	addi	r2,r2,24
 203ba68:	01420004 	movi	r5,2048
 203ba6c:	1009883a 	mov	r4,r2
 203ba70:	20152080 	call	2015208 <sys_mbox_new>
 203ba74:	1007883a 	mov	r3,r2
 203ba78:	e0bfff17 	ldw	r2,-4(fp)
 203ba7c:	10c00105 	stb	r3,4(r2)
            }
            if (msg->err == ERR_OK) {
 203ba80:	e0bfff17 	ldw	r2,-4(fp)
 203ba84:	10800103 	ldbu	r2,4(r2)
 203ba88:	10803fcc 	andi	r2,r2,255
 203ba8c:	1080201c 	xori	r2,r2,128
 203ba90:	10bfe004 	addi	r2,r2,-128
 203ba94:	1000181e 	bne	r2,zero,203baf8 <do_listen+0x1b0>
              msg->conn->state = NETCONN_LISTEN;
 203ba98:	e0bfff17 	ldw	r2,-4(fp)
 203ba9c:	10800017 	ldw	r2,0(r2)
 203baa0:	00c00084 	movi	r3,2
 203baa4:	10c00115 	stw	r3,4(r2)
              msg->conn->pcb.tcp = lpcb;
 203baa8:	e0bfff17 	ldw	r2,-4(fp)
 203baac:	10800017 	ldw	r2,0(r2)
 203bab0:	e0fffe17 	ldw	r3,-8(fp)
 203bab4:	10c00215 	stw	r3,8(r2)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 203bab8:	e0bfff17 	ldw	r2,-4(fp)
 203babc:	10800017 	ldw	r2,0(r2)
 203bac0:	10c00217 	ldw	r3,8(r2)
 203bac4:	e0bfff17 	ldw	r2,-4(fp)
 203bac8:	10800017 	ldw	r2,0(r2)
 203bacc:	100b883a 	mov	r5,r2
 203bad0:	1809883a 	mov	r4,r3
 203bad4:	201d9400 	call	201d940 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 203bad8:	e0bfff17 	ldw	r2,-4(fp)
 203badc:	10800017 	ldw	r2,0(r2)
 203bae0:	10800217 	ldw	r2,8(r2)
 203bae4:	01408134 	movhi	r5,516
 203bae8:	296a3b04 	addi	r5,r5,-22292
 203baec:	1009883a 	mov	r4,r2
 203baf0:	201da100 	call	201da10 <tcp_accept>
 203baf4:	00000906 	br	203bb1c <do_listen+0x1d4>
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
 203baf8:	e13ffe17 	ldw	r4,-8(fp)
 203bafc:	201bd080 	call	201bd08 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 203bb00:	e0bfff17 	ldw	r2,-4(fp)
 203bb04:	10800017 	ldw	r2,0(r2)
 203bb08:	10000215 	stw	zero,8(r2)
 203bb0c:	00000306 	br	203bb1c <do_listen+0x1d4>
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
 203bb10:	e0bfff17 	ldw	r2,-4(fp)
 203bb14:	00fffc84 	movi	r3,-14
 203bb18:	10c00105 	stb	r3,4(r2)
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 203bb1c:	e0bfff17 	ldw	r2,-4(fp)
 203bb20:	10800017 	ldw	r2,0(r2)
 203bb24:	10800404 	addi	r2,r2,16
 203bb28:	1009883a 	mov	r4,r2
 203bb2c:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203bb30:	0001883a 	nop
 203bb34:	e037883a 	mov	sp,fp
 203bb38:	dfc00117 	ldw	ra,4(sp)
 203bb3c:	df000017 	ldw	fp,0(sp)
 203bb40:	dec00204 	addi	sp,sp,8
 203bb44:	f800283a 	ret

0203bb48 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
 203bb48:	defffb04 	addi	sp,sp,-20
 203bb4c:	dfc00415 	stw	ra,16(sp)
 203bb50:	df000315 	stw	fp,12(sp)
 203bb54:	df000304 	addi	fp,sp,12
 203bb58:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 203bb5c:	e0bfff17 	ldw	r2,-4(fp)
 203bb60:	10800017 	ldw	r2,0(r2)
 203bb64:	10800303 	ldbu	r2,12(r2)
 203bb68:	10803fcc 	andi	r2,r2,255
 203bb6c:	1080201c 	xori	r2,r2,128
 203bb70:	10bfe004 	addi	r2,r2,-128
 203bb74:	10bffdc8 	cmpgei	r2,r2,-9
 203bb78:	1000061e 	bne	r2,zero,203bb94 <do_send+0x4c>
    msg->err = msg->conn->last_err;
 203bb7c:	e0bfff17 	ldw	r2,-4(fp)
 203bb80:	10800017 	ldw	r2,0(r2)
 203bb84:	10c00303 	ldbu	r3,12(r2)
 203bb88:	e0bfff17 	ldw	r2,-4(fp)
 203bb8c:	10c00105 	stb	r3,4(r2)
 203bb90:	00007306 	br	203bd60 <do_send+0x218>
  } else {
    msg->err = ERR_CONN;
 203bb94:	e0bfff17 	ldw	r2,-4(fp)
 203bb98:	00fffcc4 	movi	r3,-13
 203bb9c:	10c00105 	stb	r3,4(r2)
    if (msg->conn->pcb.tcp != NULL) {
 203bba0:	e0bfff17 	ldw	r2,-4(fp)
 203bba4:	10800017 	ldw	r2,0(r2)
 203bba8:	10800217 	ldw	r2,8(r2)
 203bbac:	10006c26 	beq	r2,zero,203bd60 <do_send+0x218>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203bbb0:	e0bfff17 	ldw	r2,-4(fp)
 203bbb4:	10800017 	ldw	r2,0(r2)
 203bbb8:	10800017 	ldw	r2,0(r2)
 203bbbc:	10803c0c 	andi	r2,r2,240
 203bbc0:	10c00820 	cmpeqi	r3,r2,32
 203bbc4:	1800291e 	bne	r3,zero,203bc6c <do_send+0x124>
 203bbc8:	10801020 	cmpeqi	r2,r2,64
 203bbcc:	1000011e 	bne	r2,zero,203bbd4 <do_send+0x8c>
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
#endif /* LWIP_UDP */
      default:
        break;
 203bbd0:	00006306 	br	203bd60 <do_send+0x218>
    msg->err = ERR_CONN;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
 203bbd4:	e0bfff17 	ldw	r2,-4(fp)
 203bbd8:	10800217 	ldw	r2,8(r2)
 203bbdc:	10800204 	addi	r2,r2,8
 203bbe0:	10000426 	beq	r2,zero,203bbf4 <do_send+0xac>
 203bbe4:	e0bfff17 	ldw	r2,-4(fp)
 203bbe8:	10800217 	ldw	r2,8(r2)
 203bbec:	10800217 	ldw	r2,8(r2)
 203bbf0:	10000d1e 	bne	r2,zero,203bc28 <do_send+0xe0>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
 203bbf4:	e0bfff17 	ldw	r2,-4(fp)
 203bbf8:	10800017 	ldw	r2,0(r2)
 203bbfc:	10c00217 	ldw	r3,8(r2)
 203bc00:	e0bfff17 	ldw	r2,-4(fp)
 203bc04:	10800217 	ldw	r2,8(r2)
 203bc08:	10800017 	ldw	r2,0(r2)
 203bc0c:	100b883a 	mov	r5,r2
 203bc10:	1809883a 	mov	r4,r3
 203bc14:	2034a700 	call	2034a70 <raw_send>
 203bc18:	1007883a 	mov	r3,r2
 203bc1c:	e0bfff17 	ldw	r2,-4(fp)
 203bc20:	10c00105 	stb	r3,4(r2)
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
        }
        break;
 203bc24:	00004e06 	br	203bd60 <do_send+0x218>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
 203bc28:	e0bfff17 	ldw	r2,-4(fp)
 203bc2c:	10800017 	ldw	r2,0(r2)
 203bc30:	10c00217 	ldw	r3,8(r2)
 203bc34:	e0bfff17 	ldw	r2,-4(fp)
 203bc38:	10800217 	ldw	r2,8(r2)
 203bc3c:	11000017 	ldw	r4,0(r2)
 203bc40:	e0bfff17 	ldw	r2,-4(fp)
 203bc44:	10800217 	ldw	r2,8(r2)
 203bc48:	10800204 	addi	r2,r2,8
 203bc4c:	100d883a 	mov	r6,r2
 203bc50:	200b883a 	mov	r5,r4
 203bc54:	1809883a 	mov	r4,r3
 203bc58:	20348e80 	call	20348e8 <raw_sendto>
 203bc5c:	1007883a 	mov	r3,r2
 203bc60:	e0bfff17 	ldw	r2,-4(fp)
 203bc64:	10c00105 	stb	r3,4(r2)
        }
        break;
 203bc68:	00003d06 	br	203bd60 <do_send+0x218>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
 203bc6c:	e0bfff17 	ldw	r2,-4(fp)
 203bc70:	10800217 	ldw	r2,8(r2)
 203bc74:	10800204 	addi	r2,r2,8
 203bc78:	10000426 	beq	r2,zero,203bc8c <do_send+0x144>
 203bc7c:	e0bfff17 	ldw	r2,-4(fp)
 203bc80:	10800217 	ldw	r2,8(r2)
 203bc84:	10800217 	ldw	r2,8(r2)
 203bc88:	1000181e 	bne	r2,zero,203bcec <do_send+0x1a4>
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bc8c:	e0bfff17 	ldw	r2,-4(fp)
 203bc90:	10800017 	ldw	r2,0(r2)
 203bc94:	10c00217 	ldw	r3,8(r2)
 203bc98:	e0bfff17 	ldw	r2,-4(fp)
 203bc9c:	10800217 	ldw	r2,8(r2)
 203bca0:	11000017 	ldw	r4,0(r2)
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 203bca4:	e0bfff17 	ldw	r2,-4(fp)
 203bca8:	10800217 	ldw	r2,8(r2)
 203bcac:	10800383 	ldbu	r2,14(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bcb0:	10803fcc 	andi	r2,r2,255
 203bcb4:	1140008c 	andi	r5,r2,2
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 203bcb8:	e0bfff17 	ldw	r2,-4(fp)
 203bcbc:	10800217 	ldw	r2,8(r2)
 203bcc0:	1080040b 	ldhu	r2,16(r2)
#endif
#if LWIP_UDP
      case NETCONN_UDP:
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bcc4:	10bfffcc 	andi	r2,r2,65535
 203bcc8:	100f883a 	mov	r7,r2
 203bccc:	280d883a 	mov	r6,r5
 203bcd0:	200b883a 	mov	r5,r4
 203bcd4:	1809883a 	mov	r4,r3
 203bcd8:	202214c0 	call	202214c <udp_send_chksum>
 203bcdc:	1007883a 	mov	r3,r2
 203bce0:	e0bfff17 	ldw	r2,-4(fp)
 203bce4:	10c00105 	stb	r3,4(r2)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
 203bce8:	00001c06 	br	203bd5c <do_send+0x214>
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bcec:	e0bfff17 	ldw	r2,-4(fp)
 203bcf0:	10800017 	ldw	r2,0(r2)
 203bcf4:	11000217 	ldw	r4,8(r2)
 203bcf8:	e0bfff17 	ldw	r2,-4(fp)
 203bcfc:	10800217 	ldw	r2,8(r2)
 203bd00:	11400017 	ldw	r5,0(r2)
            &msg->msg.b->addr, msg->msg.b->port,
 203bd04:	e0bfff17 	ldw	r2,-4(fp)
 203bd08:	10800217 	ldw	r2,8(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bd0c:	11800204 	addi	r6,r2,8
            &msg->msg.b->addr, msg->msg.b->port,
 203bd10:	e0bfff17 	ldw	r2,-4(fp)
 203bd14:	10800217 	ldw	r2,8(r2)
 203bd18:	1080030b 	ldhu	r2,12(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bd1c:	11ffffcc 	andi	r7,r2,65535
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 203bd20:	e0bfff17 	ldw	r2,-4(fp)
 203bd24:	10800217 	ldw	r2,8(r2)
 203bd28:	10800383 	ldbu	r2,14(r2)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bd2c:	10803fcc 	andi	r2,r2,255
 203bd30:	1080008c 	andi	r2,r2,2
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
 203bd34:	e0ffff17 	ldw	r3,-4(fp)
 203bd38:	18c00217 	ldw	r3,8(r3)
 203bd3c:	18c0040b 	ldhu	r3,16(r3)
#if LWIP_CHECKSUM_ON_COPY
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        } else {
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
 203bd40:	18ffffcc 	andi	r3,r3,65535
 203bd44:	d8c00115 	stw	r3,4(sp)
 203bd48:	d8800015 	stw	r2,0(sp)
 203bd4c:	20222180 	call	2022218 <udp_sendto_chksum>
 203bd50:	1007883a 	mov	r3,r2
 203bd54:	e0bfff17 	ldw	r2,-4(fp)
 203bd58:	10c00105 	stb	r3,4(r2)
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
 203bd5c:	0001883a 	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 203bd60:	e0bfff17 	ldw	r2,-4(fp)
 203bd64:	10800017 	ldw	r2,0(r2)
 203bd68:	10800404 	addi	r2,r2,16
 203bd6c:	1009883a 	mov	r4,r2
 203bd70:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203bd74:	0001883a 	nop
 203bd78:	e037883a 	mov	sp,fp
 203bd7c:	dfc00117 	ldw	ra,4(sp)
 203bd80:	df000017 	ldw	fp,0(sp)
 203bd84:	dec00204 	addi	sp,sp,8
 203bd88:	f800283a 	ret

0203bd8c <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 203bd8c:	defffb04 	addi	sp,sp,-20
 203bd90:	dfc00415 	stw	ra,16(sp)
 203bd94:	df000315 	stw	fp,12(sp)
 203bd98:	df000304 	addi	fp,sp,12
 203bd9c:	e13fff15 	stw	r4,-4(fp)
  msg->err = ERR_OK;
 203bda0:	e0bfff17 	ldw	r2,-4(fp)
 203bda4:	10000105 	stb	zero,4(r2)
  if (msg->conn->pcb.tcp != NULL) {
 203bda8:	e0bfff17 	ldw	r2,-4(fp)
 203bdac:	10800017 	ldw	r2,0(r2)
 203bdb0:	10800217 	ldw	r2,8(r2)
 203bdb4:	10002926 	beq	r2,zero,203be5c <do_recv+0xd0>
    if (msg->conn->type == NETCONN_TCP) {
 203bdb8:	e0bfff17 	ldw	r2,-4(fp)
 203bdbc:	10800017 	ldw	r2,0(r2)
 203bdc0:	10800017 	ldw	r2,0(r2)
 203bdc4:	10800418 	cmpnei	r2,r2,16
 203bdc8:	1000241e 	bne	r2,zero,203be5c <do_recv+0xd0>
#if TCP_LISTEN_BACKLOG
      if (msg->conn->pcb.tcp->state == LISTEN) {
 203bdcc:	e0bfff17 	ldw	r2,-4(fp)
 203bdd0:	10800017 	ldw	r2,0(r2)
 203bdd4:	10800217 	ldw	r2,8(r2)
 203bdd8:	10800617 	ldw	r2,24(r2)
 203bddc:	10800058 	cmpnei	r2,r2,1
 203bde0:	1000071e 	bne	r2,zero,203be00 <do_recv+0x74>
        tcp_accepted(msg->conn->pcb.tcp);
 203bde4:	e0bfff17 	ldw	r2,-4(fp)
 203bde8:	10800017 	ldw	r2,0(r2)
 203bdec:	10800217 	ldw	r2,8(r2)
 203bdf0:	10c00843 	ldbu	r3,33(r2)
 203bdf4:	18ffffc4 	addi	r3,r3,-1
 203bdf8:	10c00845 	stb	r3,33(r2)
 203bdfc:	00001706 	br	203be5c <do_recv+0xd0>
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
 203be00:	e0bfff17 	ldw	r2,-4(fp)
 203be04:	10800217 	ldw	r2,8(r2)
 203be08:	e0bffd15 	stw	r2,-12(fp)
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
 203be0c:	e0bffd17 	ldw	r2,-12(fp)
 203be10:	00ffffd4 	movui	r3,65535
 203be14:	18800236 	bltu	r3,r2,203be20 <do_recv+0x94>
 203be18:	e0bffd17 	ldw	r2,-12(fp)
 203be1c:	00000106 	br	203be24 <do_recv+0x98>
 203be20:	00bfffc4 	movi	r2,-1
 203be24:	e0bffe0d 	sth	r2,-8(fp)
          tcp_recved(msg->conn->pcb.tcp, recved);
 203be28:	e0bfff17 	ldw	r2,-4(fp)
 203be2c:	10800017 	ldw	r2,0(r2)
 203be30:	10800217 	ldw	r2,8(r2)
 203be34:	e0fffe0b 	ldhu	r3,-8(fp)
 203be38:	180b883a 	mov	r5,r3
 203be3c:	1009883a 	mov	r4,r2
 203be40:	201c5440 	call	201c544 <tcp_recved>
          remaining -= recved;
 203be44:	e0bffe0b 	ldhu	r2,-8(fp)
 203be48:	e0fffd17 	ldw	r3,-12(fp)
 203be4c:	1885c83a 	sub	r2,r3,r2
 203be50:	e0bffd15 	stw	r2,-12(fp)
        }while(remaining != 0);
 203be54:	e0bffd17 	ldw	r2,-12(fp)
 203be58:	103fec1e 	bne	r2,zero,203be0c <__alt_mem_mem_0+0xfd01be0c>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 203be5c:	e0bfff17 	ldw	r2,-4(fp)
 203be60:	10800017 	ldw	r2,0(r2)
 203be64:	10800404 	addi	r2,r2,16
 203be68:	1009883a 	mov	r4,r2
 203be6c:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203be70:	0001883a 	nop
 203be74:	e037883a 	mov	sp,fp
 203be78:	dfc00117 	ldw	ra,4(sp)
 203be7c:	df000017 	ldw	fp,0(sp)
 203be80:	dec00204 	addi	sp,sp,8
 203be84:	f800283a 	ret

0203be88 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 203be88:	defff804 	addi	sp,sp,-32
 203be8c:	dfc00715 	stw	ra,28(sp)
 203be90:	df000615 	stw	fp,24(sp)
 203be94:	df000604 	addi	fp,sp,24
 203be98:	e13fff15 	stw	r4,-4(fp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
 203be9c:	e03ffb05 	stb	zero,-20(fp)
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 203bea0:	e0bfff17 	ldw	r2,-4(fp)
 203bea4:	10800903 	ldbu	r2,36(r2)
 203bea8:	10803fcc 	andi	r2,r2,255
 203beac:	1080008c 	andi	r2,r2,2
 203beb0:	1000061e 	bne	r2,zero,203becc <do_writemore+0x44>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
 203beb4:	e0bfff17 	ldw	r2,-4(fp)
 203beb8:	10800b17 	ldw	r2,44(r2)
 203bebc:	10800403 	ldbu	r2,16(r2)
 203bec0:	10803fcc 	andi	r2,r2,255
 203bec4:	1080010c 	andi	r2,r2,4
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 203bec8:	10000226 	beq	r2,zero,203bed4 <do_writemore+0x4c>
 203becc:	00800044 	movi	r2,1
 203bed0:	00000106 	br	203bed8 <do_writemore+0x50>
 203bed4:	0005883a 	mov	r2,zero
 203bed8:	e0bffb85 	stb	r2,-18(fp)
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;
 203bedc:	e0bfff17 	ldw	r2,-4(fp)
 203bee0:	10800b17 	ldw	r2,44(r2)
 203bee4:	10800403 	ldbu	r2,16(r2)
 203bee8:	e0bffb45 	stb	r2,-19(fp)
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 203beec:	e0bfff17 	ldw	r2,-4(fp)
 203bef0:	10800b17 	ldw	r2,44(r2)
 203bef4:	10c00217 	ldw	r3,8(r2)
 203bef8:	e0bfff17 	ldw	r2,-4(fp)
 203befc:	10800a17 	ldw	r2,40(r2)
 203bf00:	1885883a 	add	r2,r3,r2
 203bf04:	e0bffc15 	stw	r2,-16(fp)
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 203bf08:	e0bfff17 	ldw	r2,-4(fp)
 203bf0c:	10800b17 	ldw	r2,44(r2)
 203bf10:	10c00317 	ldw	r3,12(r2)
 203bf14:	e0bfff17 	ldw	r2,-4(fp)
 203bf18:	10800a17 	ldw	r2,40(r2)
 203bf1c:	1885c83a 	sub	r2,r3,r2
 203bf20:	e0bffd15 	stw	r2,-12(fp)
    if (diff > 0xffffUL) { /* max_u16_t */
 203bf24:	e0bffd17 	ldw	r2,-12(fp)
 203bf28:	00ffffd4 	movui	r3,65535
 203bf2c:	1880062e 	bgeu	r3,r2,203bf48 <do_writemore+0xc0>
      len = 0xffff;
 203bf30:	00bfffc4 	movi	r2,-1
 203bf34:	e0bffa8d 	sth	r2,-22(fp)
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
 203bf38:	e0bffb43 	ldbu	r2,-19(fp)
 203bf3c:	10800094 	ori	r2,r2,2
 203bf40:	e0bffb45 	stb	r2,-19(fp)
 203bf44:	00000206 	br	203bf50 <do_writemore+0xc8>
    } else {
      len = (u16_t)diff;
 203bf48:	e0bffd17 	ldw	r2,-12(fp)
 203bf4c:	e0bffa8d 	sth	r2,-22(fp)
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 203bf50:	e0bfff17 	ldw	r2,-4(fp)
 203bf54:	10800217 	ldw	r2,8(r2)
 203bf58:	10801a8b 	ldhu	r2,106(r2)
 203bf5c:	e0bffe0d 	sth	r2,-8(fp)
    if (available < len) {
 203bf60:	e0fffe0b 	ldhu	r3,-8(fp)
 203bf64:	e0bffa8b 	ldhu	r2,-22(fp)
 203bf68:	18800c2e 	bgeu	r3,r2,203bf9c <do_writemore+0x114>
      /* don't try to write more than sendbuf */
      len = available;
 203bf6c:	e0bffe0b 	ldhu	r2,-8(fp)
 203bf70:	e0bffa8d 	sth	r2,-22(fp)
      if (dontblock){ 
 203bf74:	e0bffb83 	ldbu	r2,-18(fp)
 203bf78:	10000526 	beq	r2,zero,203bf90 <do_writemore+0x108>
        if (!len) {
 203bf7c:	e0bffa8b 	ldhu	r2,-22(fp)
 203bf80:	1000061e 	bne	r2,zero,203bf9c <do_writemore+0x114>
          err = ERR_WOULDBLOCK;
 203bf84:	00bffe44 	movi	r2,-7
 203bf88:	e0bffa05 	stb	r2,-24(fp)
          goto err_mem;
 203bf8c:	00001206 	br	203bfd8 <do_writemore+0x150>
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
 203bf90:	e0bffb43 	ldbu	r2,-19(fp)
 203bf94:	10800094 	ori	r2,r2,2
 203bf98:	e0bffb45 	stb	r2,-19(fp)
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 203bf9c:	e0bfff17 	ldw	r2,-4(fp)
 203bfa0:	10800217 	ldw	r2,8(r2)
 203bfa4:	e0fffa8b 	ldhu	r3,-22(fp)
 203bfa8:	e13ffb43 	ldbu	r4,-19(fp)
 203bfac:	200f883a 	mov	r7,r4
 203bfb0:	180d883a 	mov	r6,r3
 203bfb4:	e17ffc17 	ldw	r5,-16(fp)
 203bfb8:	1009883a 	mov	r4,r2
 203bfbc:	201e9cc0 	call	201e9cc <tcp_write>
 203bfc0:	e0bffa05 	stb	r2,-24(fp)
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 203bfc4:	e0bffa07 	ldb	r2,-24(fp)
 203bfc8:	10000326 	beq	r2,zero,203bfd8 <do_writemore+0x150>
 203bfcc:	e0bffa07 	ldb	r2,-24(fp)
 203bfd0:	10bfffd8 	cmpnei	r2,r2,-1
 203bfd4:	10002e1e 	bne	r2,zero,203c090 <do_writemore+0x208>
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 203bfd8:	e0bffb83 	ldbu	r2,-18(fp)
 203bfdc:	10001626 	beq	r2,zero,203c038 <do_writemore+0x1b0>
 203bfe0:	e0fffa8b 	ldhu	r3,-22(fp)
 203bfe4:	e0bfff17 	ldw	r2,-4(fp)
 203bfe8:	10800b17 	ldw	r2,44(r2)
 203bfec:	10800317 	ldw	r2,12(r2)
 203bff0:	1880112e 	bgeu	r3,r2,203c038 <do_writemore+0x1b0>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 203bff4:	e0bfff17 	ldw	r2,-4(fp)
 203bff8:	10800c17 	ldw	r2,48(r2)
 203bffc:	10000726 	beq	r2,zero,203c01c <do_writemore+0x194>
 203c000:	e0bfff17 	ldw	r2,-4(fp)
 203c004:	10800c17 	ldw	r2,48(r2)
 203c008:	e0fffa8b 	ldhu	r3,-22(fp)
 203c00c:	180d883a 	mov	r6,r3
 203c010:	014000c4 	movi	r5,3
 203c014:	e13fff17 	ldw	r4,-4(fp)
 203c018:	103ee83a 	callr	r2
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 203c01c:	e0bfff17 	ldw	r2,-4(fp)
 203c020:	10800903 	ldbu	r2,36(r2)
 203c024:	10800414 	ori	r2,r2,16
 203c028:	1007883a 	mov	r3,r2
 203c02c:	e0bfff17 	ldw	r2,-4(fp)
 203c030:	10c00905 	stb	r3,36(r2)
 203c034:	00001606 	br	203c090 <do_writemore+0x208>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 203c038:	e0bfff17 	ldw	r2,-4(fp)
 203c03c:	10800217 	ldw	r2,8(r2)
 203c040:	10801a8b 	ldhu	r2,106(r2)
 203c044:	10bfffcc 	andi	r2,r2,65535
 203c048:	10816d70 	cmpltui	r2,r2,1461
 203c04c:	1000061e 	bne	r2,zero,203c068 <do_writemore+0x1e0>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
 203c050:	e0bfff17 	ldw	r2,-4(fp)
 203c054:	10800217 	ldw	r2,8(r2)
 203c058:	10801b0b 	ldhu	r2,108(r2)
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 203c05c:	10bfffcc 	andi	r2,r2,65535
 203c060:	10800130 	cmpltui	r2,r2,4
 203c064:	10000a1e 	bne	r2,zero,203c090 <do_writemore+0x208>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 203c068:	e0bfff17 	ldw	r2,-4(fp)
 203c06c:	10800c17 	ldw	r2,48(r2)
 203c070:	10000726 	beq	r2,zero,203c090 <do_writemore+0x208>
 203c074:	e0bfff17 	ldw	r2,-4(fp)
 203c078:	10800c17 	ldw	r2,48(r2)
 203c07c:	e0fffa8b 	ldhu	r3,-22(fp)
 203c080:	180d883a 	mov	r6,r3
 203c084:	014000c4 	movi	r5,3
 203c088:	e13fff17 	ldw	r4,-4(fp)
 203c08c:	103ee83a 	callr	r2
      }
    }

    if (err == ERR_OK) {
 203c090:	e0bffa07 	ldb	r2,-24(fp)
 203c094:	10001c1e 	bne	r2,zero,203c108 <do_writemore+0x280>
      conn->write_offset += len;
 203c098:	e0bfff17 	ldw	r2,-4(fp)
 203c09c:	10c00a17 	ldw	r3,40(r2)
 203c0a0:	e0bffa8b 	ldhu	r2,-22(fp)
 203c0a4:	1887883a 	add	r3,r3,r2
 203c0a8:	e0bfff17 	ldw	r2,-4(fp)
 203c0ac:	10c00a15 	stw	r3,40(r2)
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 203c0b0:	e0bfff17 	ldw	r2,-4(fp)
 203c0b4:	10c00a17 	ldw	r3,40(r2)
 203c0b8:	e0bfff17 	ldw	r2,-4(fp)
 203c0bc:	10800b17 	ldw	r2,44(r2)
 203c0c0:	10800317 	ldw	r2,12(r2)
 203c0c4:	18800226 	beq	r3,r2,203c0d0 <do_writemore+0x248>
 203c0c8:	e0bffb83 	ldbu	r2,-18(fp)
 203c0cc:	10000926 	beq	r2,zero,203c0f4 <do_writemore+0x26c>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
 203c0d0:	e0bfff17 	ldw	r2,-4(fp)
 203c0d4:	10800b17 	ldw	r2,44(r2)
 203c0d8:	e0ffff17 	ldw	r3,-4(fp)
 203c0dc:	18c00a17 	ldw	r3,40(r3)
 203c0e0:	10c00315 	stw	r3,12(r2)
        /* everything was written */
        write_finished = 1;
 203c0e4:	00800044 	movi	r2,1
 203c0e8:	e0bffb05 	stb	r2,-20(fp)
        conn->write_offset = 0;
 203c0ec:	e0bfff17 	ldw	r2,-4(fp)
 203c0f0:	10000a15 	stw	zero,40(r2)
      }
      tcp_output(conn->pcb.tcp);
 203c0f4:	e0bfff17 	ldw	r2,-4(fp)
 203c0f8:	10800217 	ldw	r2,8(r2)
 203c0fc:	1009883a 	mov	r4,r2
 203c100:	201f7800 	call	201f780 <tcp_output>
 203c104:	00000f06 	br	203c144 <do_writemore+0x2bc>
    } else if ((err == ERR_MEM) && !dontblock) {
 203c108:	e0bffa07 	ldb	r2,-24(fp)
 203c10c:	10bfffd8 	cmpnei	r2,r2,-1
 203c110:	1000071e 	bne	r2,zero,203c130 <do_writemore+0x2a8>
 203c114:	e0bffb83 	ldbu	r2,-18(fp)
 203c118:	1000051e 	bne	r2,zero,203c130 <do_writemore+0x2a8>
      /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
         we do NOT return to the application thread, since ERR_MEM is
         only a temporary error! */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      tcp_output(conn->pcb.tcp);
 203c11c:	e0bfff17 	ldw	r2,-4(fp)
 203c120:	10800217 	ldw	r2,8(r2)
 203c124:	1009883a 	mov	r4,r2
 203c128:	201f7800 	call	201f780 <tcp_output>
 203c12c:	00000506 	br	203c144 <do_writemore+0x2bc>
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
 203c130:	00800044 	movi	r2,1
 203c134:	e0bffb05 	stb	r2,-20(fp)
      conn->current_msg->msg.w.len = 0;
 203c138:	e0bfff17 	ldw	r2,-4(fp)
 203c13c:	10800b17 	ldw	r2,44(r2)
 203c140:	10000315 	stw	zero,12(r2)
    }
  }
  if (write_finished) {
 203c144:	e0bffb03 	ldbu	r2,-20(fp)
 203c148:	10000c26 	beq	r2,zero,203c17c <do_writemore+0x2f4>
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 203c14c:	e0bfff17 	ldw	r2,-4(fp)
 203c150:	10800b17 	ldw	r2,44(r2)
 203c154:	e0fffa03 	ldbu	r3,-24(fp)
 203c158:	10c00105 	stb	r3,4(r2)
    conn->current_msg = NULL;
 203c15c:	e0bfff17 	ldw	r2,-4(fp)
 203c160:	10000b15 	stw	zero,44(r2)
    conn->state = NETCONN_NONE;
 203c164:	e0bfff17 	ldw	r2,-4(fp)
 203c168:	10000115 	stw	zero,4(r2)
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 203c16c:	e0bfff17 	ldw	r2,-4(fp)
 203c170:	10800404 	addi	r2,r2,16
 203c174:	1009883a 	mov	r4,r2
 203c178:	2014f380 	call	2014f38 <sys_sem_signal>
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
 203c17c:	0005883a 	mov	r2,zero
}
 203c180:	e037883a 	mov	sp,fp
 203c184:	dfc00117 	ldw	ra,4(sp)
 203c188:	df000017 	ldw	fp,0(sp)
 203c18c:	dec00204 	addi	sp,sp,8
 203c190:	f800283a 	ret

0203c194 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
 203c194:	defffd04 	addi	sp,sp,-12
 203c198:	dfc00215 	stw	ra,8(sp)
 203c19c:	df000115 	stw	fp,4(sp)
 203c1a0:	df000104 	addi	fp,sp,4
 203c1a4:	e13fff15 	stw	r4,-4(fp)
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 203c1a8:	e0bfff17 	ldw	r2,-4(fp)
 203c1ac:	10800017 	ldw	r2,0(r2)
 203c1b0:	10800303 	ldbu	r2,12(r2)
 203c1b4:	10803fcc 	andi	r2,r2,255
 203c1b8:	1080201c 	xori	r2,r2,128
 203c1bc:	10bfe004 	addi	r2,r2,-128
 203c1c0:	10bffdc8 	cmpgei	r2,r2,-9
 203c1c4:	1000061e 	bne	r2,zero,203c1e0 <do_write+0x4c>
    msg->err = msg->conn->last_err;
 203c1c8:	e0bfff17 	ldw	r2,-4(fp)
 203c1cc:	10800017 	ldw	r2,0(r2)
 203c1d0:	10c00303 	ldbu	r3,12(r2)
 203c1d4:	e0bfff17 	ldw	r2,-4(fp)
 203c1d8:	10c00105 	stb	r3,4(r2)
 203c1dc:	00002806 	br	203c280 <do_write+0xec>
  } else {
    if (msg->conn->type == NETCONN_TCP) {
 203c1e0:	e0bfff17 	ldw	r2,-4(fp)
 203c1e4:	10800017 	ldw	r2,0(r2)
 203c1e8:	10800017 	ldw	r2,0(r2)
 203c1ec:	10800418 	cmpnei	r2,r2,16
 203c1f0:	1000201e 	bne	r2,zero,203c274 <do_write+0xe0>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
 203c1f4:	e0bfff17 	ldw	r2,-4(fp)
 203c1f8:	10800017 	ldw	r2,0(r2)
 203c1fc:	10800117 	ldw	r2,4(r2)
 203c200:	10000426 	beq	r2,zero,203c214 <do_write+0x80>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
 203c204:	e0bfff17 	ldw	r2,-4(fp)
 203c208:	00fffec4 	movi	r3,-5
 203c20c:	10c00105 	stb	r3,4(r2)
 203c210:	00001b06 	br	203c280 <do_write+0xec>
      } else if (msg->conn->pcb.tcp != NULL) {
 203c214:	e0bfff17 	ldw	r2,-4(fp)
 203c218:	10800017 	ldw	r2,0(r2)
 203c21c:	10800217 	ldw	r2,8(r2)
 203c220:	10001026 	beq	r2,zero,203c264 <do_write+0xd0>
        msg->conn->state = NETCONN_WRITE;
 203c224:	e0bfff17 	ldw	r2,-4(fp)
 203c228:	10800017 	ldw	r2,0(r2)
 203c22c:	00c00044 	movi	r3,1
 203c230:	10c00115 	stw	r3,4(r2)
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
 203c234:	e0bfff17 	ldw	r2,-4(fp)
 203c238:	10800017 	ldw	r2,0(r2)
 203c23c:	e0ffff17 	ldw	r3,-4(fp)
 203c240:	10c00b15 	stw	r3,44(r2)
        msg->conn->write_offset = 0;
 203c244:	e0bfff17 	ldw	r2,-4(fp)
 203c248:	10800017 	ldw	r2,0(r2)
 203c24c:	10000a15 	stw	zero,40(r2)
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
 203c250:	e0bfff17 	ldw	r2,-4(fp)
 203c254:	10800017 	ldw	r2,0(r2)
 203c258:	1009883a 	mov	r4,r2
 203c25c:	203be880 	call	203be88 <do_writemore>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
 203c260:	00000c06 	br	203c294 <do_write+0x100>
      } else {
        msg->err = ERR_CONN;
 203c264:	e0bfff17 	ldw	r2,-4(fp)
 203c268:	00fffcc4 	movi	r3,-13
 203c26c:	10c00105 	stb	r3,4(r2)
 203c270:	00000306 	br	203c280 <do_write+0xec>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
 203c274:	e0bfff17 	ldw	r2,-4(fp)
 203c278:	00fffe84 	movi	r3,-6
 203c27c:	10c00105 	stb	r3,4(r2)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
 203c280:	e0bfff17 	ldw	r2,-4(fp)
 203c284:	10800017 	ldw	r2,0(r2)
 203c288:	10800404 	addi	r2,r2,16
 203c28c:	1009883a 	mov	r4,r2
 203c290:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203c294:	e037883a 	mov	sp,fp
 203c298:	dfc00117 	ldw	ra,4(sp)
 203c29c:	df000017 	ldw	fp,0(sp)
 203c2a0:	dec00204 	addi	sp,sp,8
 203c2a4:	f800283a 	ret

0203c2a8 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
 203c2a8:	defffd04 	addi	sp,sp,-12
 203c2ac:	dfc00215 	stw	ra,8(sp)
 203c2b0:	df000115 	stw	fp,4(sp)
 203c2b4:	df000104 	addi	fp,sp,4
 203c2b8:	e13fff15 	stw	r4,-4(fp)
  if (msg->conn->pcb.ip != NULL) {
 203c2bc:	e0bfff17 	ldw	r2,-4(fp)
 203c2c0:	10800017 	ldw	r2,0(r2)
 203c2c4:	10800217 	ldw	r2,8(r2)
 203c2c8:	10005f26 	beq	r2,zero,203c448 <do_getaddr+0x1a0>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 203c2cc:	e0bfff17 	ldw	r2,-4(fp)
 203c2d0:	10800217 	ldw	r2,8(r2)
 203c2d4:	e0ffff17 	ldw	r3,-4(fp)
 203c2d8:	18c00403 	ldbu	r3,16(r3)
 203c2dc:	18c03fcc 	andi	r3,r3,255
 203c2e0:	18000626 	beq	r3,zero,203c2fc <do_getaddr+0x54>
 203c2e4:	e0ffff17 	ldw	r3,-4(fp)
 203c2e8:	18c00017 	ldw	r3,0(r3)
 203c2ec:	18c00217 	ldw	r3,8(r3)
 203c2f0:	18c00017 	ldw	r3,0(r3)
 203c2f4:	10c00015 	stw	r3,0(r2)
 203c2f8:	00000506 	br	203c310 <do_getaddr+0x68>
                             msg->conn->pcb.ip->remote_ip);
 203c2fc:	e0ffff17 	ldw	r3,-4(fp)
 203c300:	18c00017 	ldw	r3,0(r3)
 203c304:	18c00217 	ldw	r3,8(r3)
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.ip != NULL) {
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 203c308:	18c00117 	ldw	r3,4(r3)
 203c30c:	10c00015 	stw	r3,0(r2)
                             msg->conn->pcb.ip->remote_ip);

    msg->err = ERR_OK;
 203c310:	e0bfff17 	ldw	r2,-4(fp)
 203c314:	10000105 	stb	zero,4(r2)
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 203c318:	e0bfff17 	ldw	r2,-4(fp)
 203c31c:	10800017 	ldw	r2,0(r2)
 203c320:	10800017 	ldw	r2,0(r2)
 203c324:	10803c0c 	andi	r2,r2,240
 203c328:	10c00820 	cmpeqi	r3,r2,32
 203c32c:	1800161e 	bne	r3,zero,203c388 <do_getaddr+0xe0>
 203c330:	10c01020 	cmpeqi	r3,r2,64
 203c334:	1800031e 	bne	r3,zero,203c344 <do_getaddr+0x9c>
 203c338:	10800420 	cmpeqi	r2,r2,16
 203c33c:	1000311e 	bne	r2,zero,203c404 <do_getaddr+0x15c>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
      break;
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
 203c340:	00004406 	br	203c454 <do_getaddr+0x1ac>

    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
 203c344:	e0bfff17 	ldw	r2,-4(fp)
 203c348:	10800403 	ldbu	r2,16(r2)
 203c34c:	10803fcc 	andi	r2,r2,255
 203c350:	10000926 	beq	r2,zero,203c378 <do_getaddr+0xd0>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
 203c354:	e0bfff17 	ldw	r2,-4(fp)
 203c358:	10800317 	ldw	r2,12(r2)
 203c35c:	e0ffff17 	ldw	r3,-4(fp)
 203c360:	18c00017 	ldw	r3,0(r3)
 203c364:	18c00217 	ldw	r3,8(r3)
 203c368:	18c00403 	ldbu	r3,16(r3)
 203c36c:	18c03fcc 	andi	r3,r3,255
 203c370:	10c0000d 	sth	r3,0(r2)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
      }
      break;
 203c374:	00003706 	br	203c454 <do_getaddr+0x1ac>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
 203c378:	e0bfff17 	ldw	r2,-4(fp)
 203c37c:	00fffcc4 	movi	r3,-13
 203c380:	10c00105 	stb	r3,4(r2)
      }
      break;
 203c384:	00003306 	br	203c454 <do_getaddr+0x1ac>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
 203c388:	e0bfff17 	ldw	r2,-4(fp)
 203c38c:	10800403 	ldbu	r2,16(r2)
 203c390:	10803fcc 	andi	r2,r2,255
 203c394:	10000826 	beq	r2,zero,203c3b8 <do_getaddr+0x110>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
 203c398:	e0bfff17 	ldw	r2,-4(fp)
 203c39c:	10800317 	ldw	r2,12(r2)
 203c3a0:	e0ffff17 	ldw	r3,-4(fp)
 203c3a4:	18c00017 	ldw	r3,0(r3)
 203c3a8:	18c00217 	ldw	r3,8(r3)
 203c3ac:	18c0048b 	ldhu	r3,18(r3)
 203c3b0:	10c0000d 	sth	r3,0(r2)
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
 203c3b4:	00002706 	br	203c454 <do_getaddr+0x1ac>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
 203c3b8:	e0bfff17 	ldw	r2,-4(fp)
 203c3bc:	10800017 	ldw	r2,0(r2)
 203c3c0:	10800217 	ldw	r2,8(r2)
 203c3c4:	10800403 	ldbu	r2,16(r2)
 203c3c8:	10803fcc 	andi	r2,r2,255
 203c3cc:	1080010c 	andi	r2,r2,4
 203c3d0:	1000041e 	bne	r2,zero,203c3e4 <do_getaddr+0x13c>
          msg->err = ERR_CONN;
 203c3d4:	e0bfff17 	ldw	r2,-4(fp)
 203c3d8:	00fffcc4 	movi	r3,-13
 203c3dc:	10c00105 	stb	r3,4(r2)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
 203c3e0:	00001c06 	br	203c454 <do_getaddr+0x1ac>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 203c3e4:	e0bfff17 	ldw	r2,-4(fp)
 203c3e8:	10800317 	ldw	r2,12(r2)
 203c3ec:	e0ffff17 	ldw	r3,-4(fp)
 203c3f0:	18c00017 	ldw	r3,0(r3)
 203c3f4:	18c00217 	ldw	r3,8(r3)
 203c3f8:	18c0050b 	ldhu	r3,20(r3)
 203c3fc:	10c0000d 	sth	r3,0(r2)
        }
      }
      break;
 203c400:	00001406 	br	203c454 <do_getaddr+0x1ac>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
 203c404:	e0bfff17 	ldw	r2,-4(fp)
 203c408:	10c00317 	ldw	r3,12(r2)
 203c40c:	e0bfff17 	ldw	r2,-4(fp)
 203c410:	10800403 	ldbu	r2,16(r2)
 203c414:	10803fcc 	andi	r2,r2,255
 203c418:	10000526 	beq	r2,zero,203c430 <do_getaddr+0x188>
 203c41c:	e0bfff17 	ldw	r2,-4(fp)
 203c420:	10800017 	ldw	r2,0(r2)
 203c424:	10800217 	ldw	r2,8(r2)
 203c428:	1080078b 	ldhu	r2,30(r2)
 203c42c:	00000406 	br	203c440 <do_getaddr+0x198>
 203c430:	e0bfff17 	ldw	r2,-4(fp)
 203c434:	10800017 	ldw	r2,0(r2)
 203c438:	10800217 	ldw	r2,8(r2)
 203c43c:	1080080b 	ldhu	r2,32(r2)
 203c440:	1880000d 	sth	r2,0(r3)
      break;
 203c444:	00000306 	br	203c454 <do_getaddr+0x1ac>
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
    }
  } else {
    msg->err = ERR_CONN;
 203c448:	e0bfff17 	ldw	r2,-4(fp)
 203c44c:	00fffcc4 	movi	r3,-13
 203c450:	10c00105 	stb	r3,4(r2)
  }
  TCPIP_APIMSG_ACK(msg);
 203c454:	e0bfff17 	ldw	r2,-4(fp)
 203c458:	10800017 	ldw	r2,0(r2)
 203c45c:	10800404 	addi	r2,r2,16
 203c460:	1009883a 	mov	r4,r2
 203c464:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203c468:	0001883a 	nop
 203c46c:	e037883a 	mov	sp,fp
 203c470:	dfc00117 	ldw	ra,4(sp)
 203c474:	df000017 	ldw	fp,0(sp)
 203c478:	dec00204 	addi	sp,sp,8
 203c47c:	f800283a 	ret

0203c480 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
 203c480:	defffd04 	addi	sp,sp,-12
 203c484:	dfc00215 	stw	ra,8(sp)
 203c488:	df000115 	stw	fp,4(sp)
 203c48c:	df000104 	addi	fp,sp,4
 203c490:	e13fff15 	stw	r4,-4(fp)
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
 203c494:	e0bfff17 	ldw	r2,-4(fp)
 203c498:	10800017 	ldw	r2,0(r2)
 203c49c:	10800117 	ldw	r2,4(r2)
 203c4a0:	10000926 	beq	r2,zero,203c4c8 <do_close+0x48>
 203c4a4:	e0bfff17 	ldw	r2,-4(fp)
 203c4a8:	10800017 	ldw	r2,0(r2)
 203c4ac:	10800117 	ldw	r2,4(r2)
 203c4b0:	108000a0 	cmpeqi	r2,r2,2
 203c4b4:	1000041e 	bne	r2,zero,203c4c8 <do_close+0x48>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
 203c4b8:	e0bfff17 	ldw	r2,-4(fp)
 203c4bc:	00fffec4 	movi	r3,-5
 203c4c0:	10c00105 	stb	r3,4(r2)
 203c4c4:	00003006 	br	203c588 <do_close+0x108>
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
 203c4c8:	e0bfff17 	ldw	r2,-4(fp)
 203c4cc:	10800017 	ldw	r2,0(r2)
 203c4d0:	10800217 	ldw	r2,8(r2)
 203c4d4:	10002926 	beq	r2,zero,203c57c <do_close+0xfc>
 203c4d8:	e0bfff17 	ldw	r2,-4(fp)
 203c4dc:	10800017 	ldw	r2,0(r2)
 203c4e0:	10800017 	ldw	r2,0(r2)
 203c4e4:	10800418 	cmpnei	r2,r2,16
 203c4e8:	1000241e 	bne	r2,zero,203c57c <do_close+0xfc>
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 203c4ec:	e0bfff17 	ldw	r2,-4(fp)
 203c4f0:	10800203 	ldbu	r2,8(r2)
 203c4f4:	10803fcc 	andi	r2,r2,255
 203c4f8:	108000e0 	cmpeqi	r2,r2,3
 203c4fc:	1000091e 	bne	r2,zero,203c524 <do_close+0xa4>
 203c500:	e0bfff17 	ldw	r2,-4(fp)
 203c504:	10800017 	ldw	r2,0(r2)
 203c508:	10800117 	ldw	r2,4(r2)
 203c50c:	10800098 	cmpnei	r2,r2,2
 203c510:	1000041e 	bne	r2,zero,203c524 <do_close+0xa4>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
 203c514:	e0bfff17 	ldw	r2,-4(fp)
 203c518:	00fffcc4 	movi	r3,-13
 203c51c:	10c00105 	stb	r3,4(r2)
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 203c520:	00001906 	br	203c588 <do_close+0x108>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 203c524:	e0bfff17 	ldw	r2,-4(fp)
 203c528:	10800203 	ldbu	r2,8(r2)
 203c52c:	10803fcc 	andi	r2,r2,255
 203c530:	1080004c 	andi	r2,r2,1
 203c534:	10000426 	beq	r2,zero,203c548 <do_close+0xc8>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
 203c538:	e0bfff17 	ldw	r2,-4(fp)
 203c53c:	10800017 	ldw	r2,0(r2)
 203c540:	1009883a 	mov	r4,r2
 203c544:	203add40 	call	203add4 <netconn_drain>
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
 203c548:	e0bfff17 	ldw	r2,-4(fp)
 203c54c:	10800017 	ldw	r2,0(r2)
 203c550:	00c00104 	movi	r3,4
 203c554:	10c00115 	stw	r3,4(r2)
      msg->conn->current_msg = msg;
 203c558:	e0bfff17 	ldw	r2,-4(fp)
 203c55c:	10800017 	ldw	r2,0(r2)
 203c560:	e0ffff17 	ldw	r3,-4(fp)
 203c564:	10c00b15 	stw	r3,44(r2)
      do_close_internal(msg->conn);
 203c568:	e0bfff17 	ldw	r2,-4(fp)
 203c56c:	10800017 	ldw	r2,0(r2)
 203c570:	1009883a 	mov	r4,r2
 203c574:	203af500 	call	203af50 <do_close_internal>
      /* for tcp netconns, do_close_internal ACKs the message */
      return;
 203c578:	00000806 	br	203c59c <do_close+0x11c>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
 203c57c:	e0bfff17 	ldw	r2,-4(fp)
 203c580:	00fffe84 	movi	r3,-6
 203c584:	10c00105 	stb	r3,4(r2)
  }
  sys_sem_signal(&msg->conn->op_completed);
 203c588:	e0bfff17 	ldw	r2,-4(fp)
 203c58c:	10800017 	ldw	r2,0(r2)
 203c590:	10800404 	addi	r2,r2,16
 203c594:	1009883a 	mov	r4,r2
 203c598:	2014f380 	call	2014f38 <sys_sem_signal>
}
 203c59c:	e037883a 	mov	sp,fp
 203c5a0:	dfc00117 	ldw	ra,4(sp)
 203c5a4:	df000017 	ldw	fp,0(sp)
 203c5a8:	dec00204 	addi	sp,sp,8
 203c5ac:	f800283a 	ret

0203c5b0 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
 203c5b0:	defffd04 	addi	sp,sp,-12
 203c5b4:	dfc00215 	stw	ra,8(sp)
 203c5b8:	df000115 	stw	fp,4(sp)
 203c5bc:	df000104 	addi	fp,sp,4
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 203c5c0:	010001c4 	movi	r4,7
 203c5c4:	20344340 	call	2034434 <memp_malloc>
 203c5c8:	e0bfff15 	stw	r2,-4(fp)
  if (buf != NULL) {
 203c5cc:	e0bfff17 	ldw	r2,-4(fp)
 203c5d0:	10000e26 	beq	r2,zero,203c60c <netbuf_new+0x5c>
    buf->p = NULL;
 203c5d4:	e0bfff17 	ldw	r2,-4(fp)
 203c5d8:	10000015 	stw	zero,0(r2)
    buf->ptr = NULL;
 203c5dc:	e0bfff17 	ldw	r2,-4(fp)
 203c5e0:	10000115 	stw	zero,4(r2)
    ip_addr_set_any(&buf->addr);
 203c5e4:	e0bfff17 	ldw	r2,-4(fp)
 203c5e8:	10000215 	stw	zero,8(r2)
    buf->port = 0;
 203c5ec:	e0bfff17 	ldw	r2,-4(fp)
 203c5f0:	1000030d 	sth	zero,12(r2)
#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
#if LWIP_CHECKSUM_ON_COPY
    buf->flags = 0;
 203c5f4:	e0bfff17 	ldw	r2,-4(fp)
 203c5f8:	10000385 	stb	zero,14(r2)
#endif /* LWIP_CHECKSUM_ON_COPY */
    buf->toport_chksum = 0;
 203c5fc:	e0bfff17 	ldw	r2,-4(fp)
 203c600:	1000040d 	sth	zero,16(r2)
#if LWIP_NETBUF_RECVINFO
    ip_addr_set_any(&buf->toaddr);
#endif /* LWIP_NETBUF_RECVINFO */
#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
    return buf;
 203c604:	e0bfff17 	ldw	r2,-4(fp)
 203c608:	00000106 	br	203c610 <netbuf_new+0x60>
  } else {
    return NULL;
 203c60c:	0005883a 	mov	r2,zero
  }
}
 203c610:	e037883a 	mov	sp,fp
 203c614:	dfc00117 	ldw	ra,4(sp)
 203c618:	df000017 	ldw	fp,0(sp)
 203c61c:	dec00204 	addi	sp,sp,8
 203c620:	f800283a 	ret

0203c624 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 203c624:	defffd04 	addi	sp,sp,-12
 203c628:	dfc00215 	stw	ra,8(sp)
 203c62c:	df000115 	stw	fp,4(sp)
 203c630:	df000104 	addi	fp,sp,4
 203c634:	e13fff15 	stw	r4,-4(fp)
  if (buf != NULL) {
 203c638:	e0bfff17 	ldw	r2,-4(fp)
 203c63c:	10001026 	beq	r2,zero,203c680 <netbuf_delete+0x5c>
    if (buf->p != NULL) {
 203c640:	e0bfff17 	ldw	r2,-4(fp)
 203c644:	10800017 	ldw	r2,0(r2)
 203c648:	10000a26 	beq	r2,zero,203c674 <netbuf_delete+0x50>
      pbuf_free(buf->p);
 203c64c:	e0bfff17 	ldw	r2,-4(fp)
 203c650:	10800017 	ldw	r2,0(r2)
 203c654:	1009883a 	mov	r4,r2
 203c658:	201ab680 	call	201ab68 <pbuf_free>
      buf->p = buf->ptr = NULL;
 203c65c:	e0bfff17 	ldw	r2,-4(fp)
 203c660:	10000115 	stw	zero,4(r2)
 203c664:	e0bfff17 	ldw	r2,-4(fp)
 203c668:	10c00117 	ldw	r3,4(r2)
 203c66c:	e0bfff17 	ldw	r2,-4(fp)
 203c670:	10c00015 	stw	r3,0(r2)
    }
    memp_free(MEMP_NETBUF, buf);
 203c674:	e17fff17 	ldw	r5,-4(fp)
 203c678:	010001c4 	movi	r4,7
 203c67c:	20346000 	call	2034600 <memp_free>
  }
}
 203c680:	0001883a 	nop
 203c684:	e037883a 	mov	sp,fp
 203c688:	dfc00117 	ldw	ra,4(sp)
 203c68c:	df000017 	ldw	fp,0(sp)
 203c690:	dec00204 	addi	sp,sp,8
 203c694:	f800283a 	ret

0203c698 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
 203c698:	defffc04 	addi	sp,sp,-16
 203c69c:	dfc00315 	stw	ra,12(sp)
 203c6a0:	df000215 	stw	fp,8(sp)
 203c6a4:	df000204 	addi	fp,sp,8
 203c6a8:	e13ffe15 	stw	r4,-8(fp)
 203c6ac:	2805883a 	mov	r2,r5
 203c6b0:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
 203c6b4:	e0bffe17 	ldw	r2,-8(fp)
 203c6b8:	1000091e 	bne	r2,zero,203c6e0 <netbuf_alloc+0x48>
 203c6bc:	01c08134 	movhi	r7,516
 203c6c0:	39ce5904 	addi	r7,r7,14692
 203c6c4:	01801b44 	movi	r6,109
 203c6c8:	01408134 	movhi	r5,516
 203c6cc:	294e5f04 	addi	r5,r5,14716
 203c6d0:	01008134 	movhi	r4,516
 203c6d4:	210e6604 	addi	r4,r4,14744
 203c6d8:	2000bb00 	call	2000bb0 <printf>
 203c6dc:	003fff06 	br	203c6dc <__alt_mem_mem_0+0xfd01c6dc>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
 203c6e0:	e0bffe17 	ldw	r2,-8(fp)
 203c6e4:	10800017 	ldw	r2,0(r2)
 203c6e8:	10000426 	beq	r2,zero,203c6fc <netbuf_alloc+0x64>
    pbuf_free(buf->p);
 203c6ec:	e0bffe17 	ldw	r2,-8(fp)
 203c6f0:	10800017 	ldw	r2,0(r2)
 203c6f4:	1009883a 	mov	r4,r2
 203c6f8:	201ab680 	call	201ab68 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
 203c6fc:	e0bfff0b 	ldhu	r2,-4(fp)
 203c700:	000d883a 	mov	r6,zero
 203c704:	100b883a 	mov	r5,r2
 203c708:	0009883a 	mov	r4,zero
 203c70c:	201a3ac0 	call	201a3ac <pbuf_alloc>
 203c710:	1007883a 	mov	r3,r2
 203c714:	e0bffe17 	ldw	r2,-8(fp)
 203c718:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 203c71c:	e0bffe17 	ldw	r2,-8(fp)
 203c720:	10800017 	ldw	r2,0(r2)
 203c724:	1000021e 	bne	r2,zero,203c730 <netbuf_alloc+0x98>
     return NULL;
 203c728:	0005883a 	mov	r2,zero
 203c72c:	00000706 	br	203c74c <netbuf_alloc+0xb4>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
 203c730:	e0bffe17 	ldw	r2,-8(fp)
 203c734:	10c00017 	ldw	r3,0(r2)
 203c738:	e0bffe17 	ldw	r2,-8(fp)
 203c73c:	10c00115 	stw	r3,4(r2)
  return buf->p->payload;
 203c740:	e0bffe17 	ldw	r2,-8(fp)
 203c744:	10800017 	ldw	r2,0(r2)
 203c748:	10800117 	ldw	r2,4(r2)
}
 203c74c:	e037883a 	mov	sp,fp
 203c750:	dfc00117 	ldw	ra,4(sp)
 203c754:	df000017 	ldw	fp,0(sp)
 203c758:	dec00204 	addi	sp,sp,8
 203c75c:	f800283a 	ret

0203c760 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 203c760:	defffd04 	addi	sp,sp,-12
 203c764:	dfc00215 	stw	ra,8(sp)
 203c768:	df000115 	stw	fp,4(sp)
 203c76c:	df000104 	addi	fp,sp,4
 203c770:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 203c774:	e0bfff17 	ldw	r2,-4(fp)
 203c778:	1000091e 	bne	r2,zero,203c7a0 <netbuf_free+0x40>
 203c77c:	01c08134 	movhi	r7,516
 203c780:	39ce5904 	addi	r7,r7,14692
 203c784:	01802144 	movi	r6,133
 203c788:	01408134 	movhi	r5,516
 203c78c:	294e7204 	addi	r5,r5,14792
 203c790:	01008134 	movhi	r4,516
 203c794:	210e6604 	addi	r4,r4,14744
 203c798:	2000bb00 	call	2000bb0 <printf>
 203c79c:	003fff06 	br	203c79c <__alt_mem_mem_0+0xfd01c79c>
  if (buf->p != NULL) {
 203c7a0:	e0bfff17 	ldw	r2,-4(fp)
 203c7a4:	10800017 	ldw	r2,0(r2)
 203c7a8:	10000426 	beq	r2,zero,203c7bc <netbuf_free+0x5c>
    pbuf_free(buf->p);
 203c7ac:	e0bfff17 	ldw	r2,-4(fp)
 203c7b0:	10800017 	ldw	r2,0(r2)
 203c7b4:	1009883a 	mov	r4,r2
 203c7b8:	201ab680 	call	201ab68 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
 203c7bc:	e0bfff17 	ldw	r2,-4(fp)
 203c7c0:	10000115 	stw	zero,4(r2)
 203c7c4:	e0bfff17 	ldw	r2,-4(fp)
 203c7c8:	10c00117 	ldw	r3,4(r2)
 203c7cc:	e0bfff17 	ldw	r2,-4(fp)
 203c7d0:	10c00015 	stw	r3,0(r2)
}
 203c7d4:	0001883a 	nop
 203c7d8:	e037883a 	mov	sp,fp
 203c7dc:	dfc00117 	ldw	ra,4(sp)
 203c7e0:	df000017 	ldw	fp,0(sp)
 203c7e4:	dec00204 	addi	sp,sp,8
 203c7e8:	f800283a 	ret

0203c7ec <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 203c7ec:	defffb04 	addi	sp,sp,-20
 203c7f0:	dfc00415 	stw	ra,16(sp)
 203c7f4:	df000315 	stw	fp,12(sp)
 203c7f8:	df000304 	addi	fp,sp,12
 203c7fc:	e13ffd15 	stw	r4,-12(fp)
 203c800:	e17ffe15 	stw	r5,-8(fp)
 203c804:	3005883a 	mov	r2,r6
 203c808:	e0bfff0d 	sth	r2,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 203c80c:	e0bffd17 	ldw	r2,-12(fp)
 203c810:	1000091e 	bne	r2,zero,203c838 <netbuf_ref+0x4c>
 203c814:	01c08134 	movhi	r7,516
 203c818:	39ce5904 	addi	r7,r7,14692
 203c81c:	01802604 	movi	r6,152
 203c820:	01408134 	movhi	r5,516
 203c824:	294e7904 	addi	r5,r5,14820
 203c828:	01008134 	movhi	r4,516
 203c82c:	210e6604 	addi	r4,r4,14744
 203c830:	2000bb00 	call	2000bb0 <printf>
 203c834:	003fff06 	br	203c834 <__alt_mem_mem_0+0xfd01c834>
  if (buf->p != NULL) {
 203c838:	e0bffd17 	ldw	r2,-12(fp)
 203c83c:	10800017 	ldw	r2,0(r2)
 203c840:	10000426 	beq	r2,zero,203c854 <netbuf_ref+0x68>
    pbuf_free(buf->p);
 203c844:	e0bffd17 	ldw	r2,-12(fp)
 203c848:	10800017 	ldw	r2,0(r2)
 203c84c:	1009883a 	mov	r4,r2
 203c850:	201ab680 	call	201ab68 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 203c854:	01800084 	movi	r6,2
 203c858:	000b883a 	mov	r5,zero
 203c85c:	0009883a 	mov	r4,zero
 203c860:	201a3ac0 	call	201a3ac <pbuf_alloc>
 203c864:	1007883a 	mov	r3,r2
 203c868:	e0bffd17 	ldw	r2,-12(fp)
 203c86c:	10c00015 	stw	r3,0(r2)
  if (buf->p == NULL) {
 203c870:	e0bffd17 	ldw	r2,-12(fp)
 203c874:	10800017 	ldw	r2,0(r2)
 203c878:	1000041e 	bne	r2,zero,203c88c <netbuf_ref+0xa0>
    buf->ptr = NULL;
 203c87c:	e0bffd17 	ldw	r2,-12(fp)
 203c880:	10000115 	stw	zero,4(r2)
    return ERR_MEM;
 203c884:	00bfffc4 	movi	r2,-1
 203c888:	00001106 	br	203c8d0 <netbuf_ref+0xe4>
  }
  buf->p->payload = (void*)dataptr;
 203c88c:	e0bffd17 	ldw	r2,-12(fp)
 203c890:	10800017 	ldw	r2,0(r2)
 203c894:	e0fffe17 	ldw	r3,-8(fp)
 203c898:	10c00115 	stw	r3,4(r2)
  buf->p->len = buf->p->tot_len = size;
 203c89c:	e0bffd17 	ldw	r2,-12(fp)
 203c8a0:	10c00017 	ldw	r3,0(r2)
 203c8a4:	e0bffd17 	ldw	r2,-12(fp)
 203c8a8:	10800017 	ldw	r2,0(r2)
 203c8ac:	e13fff0b 	ldhu	r4,-4(fp)
 203c8b0:	1100020d 	sth	r4,8(r2)
 203c8b4:	1080020b 	ldhu	r2,8(r2)
 203c8b8:	1880028d 	sth	r2,10(r3)
  buf->ptr = buf->p;
 203c8bc:	e0bffd17 	ldw	r2,-12(fp)
 203c8c0:	10c00017 	ldw	r3,0(r2)
 203c8c4:	e0bffd17 	ldw	r2,-12(fp)
 203c8c8:	10c00115 	stw	r3,4(r2)
  return ERR_OK;
 203c8cc:	0005883a 	mov	r2,zero
}
 203c8d0:	e037883a 	mov	sp,fp
 203c8d4:	dfc00117 	ldw	ra,4(sp)
 203c8d8:	df000017 	ldw	fp,0(sp)
 203c8dc:	dec00204 	addi	sp,sp,8
 203c8e0:	f800283a 	ret

0203c8e4 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
 203c8e4:	defffc04 	addi	sp,sp,-16
 203c8e8:	dfc00315 	stw	ra,12(sp)
 203c8ec:	df000215 	stw	fp,8(sp)
 203c8f0:	df000204 	addi	fp,sp,8
 203c8f4:	e13ffe15 	stw	r4,-8(fp)
 203c8f8:	e17fff15 	stw	r5,-4(fp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
 203c8fc:	e0bffe17 	ldw	r2,-8(fp)
 203c900:	1000091e 	bne	r2,zero,203c928 <netbuf_chain+0x44>
 203c904:	01c08134 	movhi	r7,516
 203c908:	39ce5904 	addi	r7,r7,14692
 203c90c:	01802c04 	movi	r6,176
 203c910:	01408134 	movhi	r5,516
 203c914:	294e7f04 	addi	r5,r5,14844
 203c918:	01008134 	movhi	r4,516
 203c91c:	210e6604 	addi	r4,r4,14744
 203c920:	2000bb00 	call	2000bb0 <printf>
 203c924:	003fff06 	br	203c924 <__alt_mem_mem_0+0xfd01c924>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 203c928:	e0bfff17 	ldw	r2,-4(fp)
 203c92c:	1000091e 	bne	r2,zero,203c954 <netbuf_chain+0x70>
 203c930:	01c08134 	movhi	r7,516
 203c934:	39ce5904 	addi	r7,r7,14692
 203c938:	01802c44 	movi	r6,177
 203c93c:	01408134 	movhi	r5,516
 203c940:	294e8604 	addi	r5,r5,14872
 203c944:	01008134 	movhi	r4,516
 203c948:	210e6604 	addi	r4,r4,14744
 203c94c:	2000bb00 	call	2000bb0 <printf>
 203c950:	003fff06 	br	203c950 <__alt_mem_mem_0+0xfd01c950>
  pbuf_cat(head->p, tail->p);
 203c954:	e0bffe17 	ldw	r2,-8(fp)
 203c958:	10c00017 	ldw	r3,0(r2)
 203c95c:	e0bfff17 	ldw	r2,-4(fp)
 203c960:	10800017 	ldw	r2,0(r2)
 203c964:	100b883a 	mov	r5,r2
 203c968:	1809883a 	mov	r4,r3
 203c96c:	201ad5c0 	call	201ad5c <pbuf_cat>
  head->ptr = head->p;
 203c970:	e0bffe17 	ldw	r2,-8(fp)
 203c974:	10c00017 	ldw	r3,0(r2)
 203c978:	e0bffe17 	ldw	r2,-8(fp)
 203c97c:	10c00115 	stw	r3,4(r2)
  memp_free(MEMP_NETBUF, tail);
 203c980:	e17fff17 	ldw	r5,-4(fp)
 203c984:	010001c4 	movi	r4,7
 203c988:	20346000 	call	2034600 <memp_free>
}
 203c98c:	0001883a 	nop
 203c990:	e037883a 	mov	sp,fp
 203c994:	dfc00117 	ldw	ra,4(sp)
 203c998:	df000017 	ldw	fp,0(sp)
 203c99c:	dec00204 	addi	sp,sp,8
 203c9a0:	f800283a 	ret

0203c9a4 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 203c9a4:	defffb04 	addi	sp,sp,-20
 203c9a8:	dfc00415 	stw	ra,16(sp)
 203c9ac:	df000315 	stw	fp,12(sp)
 203c9b0:	df000304 	addi	fp,sp,12
 203c9b4:	e13ffd15 	stw	r4,-12(fp)
 203c9b8:	e17ffe15 	stw	r5,-8(fp)
 203c9bc:	e1bfff15 	stw	r6,-4(fp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 203c9c0:	e0bffd17 	ldw	r2,-12(fp)
 203c9c4:	1000091e 	bne	r2,zero,203c9ec <netbuf_data+0x48>
 203c9c8:	01c08134 	movhi	r7,516
 203c9cc:	39ce5904 	addi	r7,r7,14692
 203c9d0:	018030c4 	movi	r6,195
 203c9d4:	01408134 	movhi	r5,516
 203c9d8:	294e8d04 	addi	r5,r5,14900
 203c9dc:	01008134 	movhi	r4,516
 203c9e0:	210e6604 	addi	r4,r4,14744
 203c9e4:	2000bb00 	call	2000bb0 <printf>
 203c9e8:	003fff06 	br	203c9e8 <__alt_mem_mem_0+0xfd01c9e8>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 203c9ec:	e0bffe17 	ldw	r2,-8(fp)
 203c9f0:	1000091e 	bne	r2,zero,203ca18 <netbuf_data+0x74>
 203c9f4:	01c08134 	movhi	r7,516
 203c9f8:	39ce5904 	addi	r7,r7,14692
 203c9fc:	01803104 	movi	r6,196
 203ca00:	01408134 	movhi	r5,516
 203ca04:	294e9404 	addi	r5,r5,14928
 203ca08:	01008134 	movhi	r4,516
 203ca0c:	210e6604 	addi	r4,r4,14744
 203ca10:	2000bb00 	call	2000bb0 <printf>
 203ca14:	003fff06 	br	203ca14 <__alt_mem_mem_0+0xfd01ca14>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 203ca18:	e0bfff17 	ldw	r2,-4(fp)
 203ca1c:	1000091e 	bne	r2,zero,203ca44 <netbuf_data+0xa0>
 203ca20:	01c08134 	movhi	r7,516
 203ca24:	39ce5904 	addi	r7,r7,14692
 203ca28:	01803144 	movi	r6,197
 203ca2c:	01408134 	movhi	r5,516
 203ca30:	294e9c04 	addi	r5,r5,14960
 203ca34:	01008134 	movhi	r4,516
 203ca38:	210e6604 	addi	r4,r4,14744
 203ca3c:	2000bb00 	call	2000bb0 <printf>
 203ca40:	003fff06 	br	203ca40 <__alt_mem_mem_0+0xfd01ca40>

  if (buf->ptr == NULL) {
 203ca44:	e0bffd17 	ldw	r2,-12(fp)
 203ca48:	10800117 	ldw	r2,4(r2)
 203ca4c:	1000021e 	bne	r2,zero,203ca58 <netbuf_data+0xb4>
    return ERR_BUF;
 203ca50:	00bfff84 	movi	r2,-2
 203ca54:	00000b06 	br	203ca84 <netbuf_data+0xe0>
  }
  *dataptr = buf->ptr->payload;
 203ca58:	e0bffd17 	ldw	r2,-12(fp)
 203ca5c:	10800117 	ldw	r2,4(r2)
 203ca60:	10c00117 	ldw	r3,4(r2)
 203ca64:	e0bffe17 	ldw	r2,-8(fp)
 203ca68:	10c00015 	stw	r3,0(r2)
  *len = buf->ptr->len;
 203ca6c:	e0bffd17 	ldw	r2,-12(fp)
 203ca70:	10800117 	ldw	r2,4(r2)
 203ca74:	10c0028b 	ldhu	r3,10(r2)
 203ca78:	e0bfff17 	ldw	r2,-4(fp)
 203ca7c:	10c0000d 	sth	r3,0(r2)
  return ERR_OK;
 203ca80:	0005883a 	mov	r2,zero
}
 203ca84:	e037883a 	mov	sp,fp
 203ca88:	dfc00117 	ldw	ra,4(sp)
 203ca8c:	df000017 	ldw	fp,0(sp)
 203ca90:	dec00204 	addi	sp,sp,8
 203ca94:	f800283a 	ret

0203ca98 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
 203ca98:	defffd04 	addi	sp,sp,-12
 203ca9c:	dfc00215 	stw	ra,8(sp)
 203caa0:	df000115 	stw	fp,4(sp)
 203caa4:	df000104 	addi	fp,sp,4
 203caa8:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 203caac:	e0bfff17 	ldw	r2,-4(fp)
 203cab0:	1000091e 	bne	r2,zero,203cad8 <netbuf_next+0x40>
 203cab4:	01c08134 	movhi	r7,516
 203cab8:	39ce5904 	addi	r7,r7,14692
 203cabc:	01803704 	movi	r6,220
 203cac0:	01408134 	movhi	r5,516
 203cac4:	294e7204 	addi	r5,r5,14792
 203cac8:	01008134 	movhi	r4,516
 203cacc:	210e6604 	addi	r4,r4,14744
 203cad0:	2000bb00 	call	2000bb0 <printf>
 203cad4:	003fff06 	br	203cad4 <__alt_mem_mem_0+0xfd01cad4>
  if (buf->ptr->next == NULL) {
 203cad8:	e0bfff17 	ldw	r2,-4(fp)
 203cadc:	10800117 	ldw	r2,4(r2)
 203cae0:	10800017 	ldw	r2,0(r2)
 203cae4:	1000021e 	bne	r2,zero,203caf0 <netbuf_next+0x58>
    return -1;
 203cae8:	00bfffc4 	movi	r2,-1
 203caec:	00000c06 	br	203cb20 <netbuf_next+0x88>
  }
  buf->ptr = buf->ptr->next;
 203caf0:	e0bfff17 	ldw	r2,-4(fp)
 203caf4:	10800117 	ldw	r2,4(r2)
 203caf8:	10c00017 	ldw	r3,0(r2)
 203cafc:	e0bfff17 	ldw	r2,-4(fp)
 203cb00:	10c00115 	stw	r3,4(r2)
  if (buf->ptr->next == NULL) {
 203cb04:	e0bfff17 	ldw	r2,-4(fp)
 203cb08:	10800117 	ldw	r2,4(r2)
 203cb0c:	10800017 	ldw	r2,0(r2)
 203cb10:	1000021e 	bne	r2,zero,203cb1c <netbuf_next+0x84>
    return 1;
 203cb14:	00800044 	movi	r2,1
 203cb18:	00000106 	br	203cb20 <netbuf_next+0x88>
  }
  return 0;
 203cb1c:	0005883a 	mov	r2,zero
}
 203cb20:	e037883a 	mov	sp,fp
 203cb24:	dfc00117 	ldw	ra,4(sp)
 203cb28:	df000017 	ldw	fp,0(sp)
 203cb2c:	dec00204 	addi	sp,sp,8
 203cb30:	f800283a 	ret

0203cb34 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
 203cb34:	defffd04 	addi	sp,sp,-12
 203cb38:	dfc00215 	stw	ra,8(sp)
 203cb3c:	df000115 	stw	fp,4(sp)
 203cb40:	df000104 	addi	fp,sp,4
 203cb44:	e13fff15 	stw	r4,-4(fp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 203cb48:	e0bfff17 	ldw	r2,-4(fp)
 203cb4c:	1000091e 	bne	r2,zero,203cb74 <netbuf_first+0x40>
 203cb50:	01c08134 	movhi	r7,516
 203cb54:	39ce5904 	addi	r7,r7,14692
 203cb58:	01803c44 	movi	r6,241
 203cb5c:	01408134 	movhi	r5,516
 203cb60:	294e7204 	addi	r5,r5,14792
 203cb64:	01008134 	movhi	r4,516
 203cb68:	210e6604 	addi	r4,r4,14744
 203cb6c:	2000bb00 	call	2000bb0 <printf>
 203cb70:	003fff06 	br	203cb70 <__alt_mem_mem_0+0xfd01cb70>
  buf->ptr = buf->p;
 203cb74:	e0bfff17 	ldw	r2,-4(fp)
 203cb78:	10c00017 	ldw	r3,0(r2)
 203cb7c:	e0bfff17 	ldw	r2,-4(fp)
 203cb80:	10c00115 	stw	r3,4(r2)
}
 203cb84:	0001883a 	nop
 203cb88:	e037883a 	mov	sp,fp
 203cb8c:	dfc00117 	ldw	ra,4(sp)
 203cb90:	df000017 	ldw	fp,0(sp)
 203cb94:	dec00204 	addi	sp,sp,8
 203cb98:	f800283a 	ret

0203cb9c <atexit>:
 203cb9c:	200b883a 	mov	r5,r4
 203cba0:	000f883a 	mov	r7,zero
 203cba4:	000d883a 	mov	r6,zero
 203cba8:	0009883a 	mov	r4,zero
 203cbac:	203f2ec1 	jmpi	203f2ec <__register_exitproc>

0203cbb0 <exit>:
 203cbb0:	defffe04 	addi	sp,sp,-8
 203cbb4:	000b883a 	mov	r5,zero
 203cbb8:	dc000015 	stw	r16,0(sp)
 203cbbc:	dfc00115 	stw	ra,4(sp)
 203cbc0:	2021883a 	mov	r16,r4
 203cbc4:	203f4040 	call	203f404 <__call_exitprocs>
 203cbc8:	00808134 	movhi	r2,516
 203cbcc:	10963c04 	addi	r2,r2,22768
 203cbd0:	11000017 	ldw	r4,0(r2)
 203cbd4:	20800f17 	ldw	r2,60(r4)
 203cbd8:	10000126 	beq	r2,zero,203cbe0 <exit+0x30>
 203cbdc:	103ee83a 	callr	r2
 203cbe0:	8009883a 	mov	r4,r16
 203cbe4:	20409f00 	call	20409f0 <_exit>

0203cbe8 <malloc>:
 203cbe8:	00808134 	movhi	r2,516
 203cbec:	10963d04 	addi	r2,r2,22772
 203cbf0:	200b883a 	mov	r5,r4
 203cbf4:	11000017 	ldw	r4,0(r2)
 203cbf8:	20057341 	jmpi	2005734 <_malloc_r>

0203cbfc <free>:
 203cbfc:	00808134 	movhi	r2,516
 203cc00:	10963d04 	addi	r2,r2,22772
 203cc04:	200b883a 	mov	r5,r4
 203cc08:	11000017 	ldw	r4,0(r2)
 203cc0c:	20050041 	jmpi	2005004 <_free_r>

0203cc10 <memcmp>:
 203cc10:	01c000c4 	movi	r7,3
 203cc14:	3980192e 	bgeu	r7,r6,203cc7c <memcmp+0x6c>
 203cc18:	2144b03a 	or	r2,r4,r5
 203cc1c:	11c4703a 	and	r2,r2,r7
 203cc20:	10000f26 	beq	r2,zero,203cc60 <memcmp+0x50>
 203cc24:	20800003 	ldbu	r2,0(r4)
 203cc28:	28c00003 	ldbu	r3,0(r5)
 203cc2c:	10c0151e 	bne	r2,r3,203cc84 <memcmp+0x74>
 203cc30:	31bfff84 	addi	r6,r6,-2
 203cc34:	01ffffc4 	movi	r7,-1
 203cc38:	00000406 	br	203cc4c <memcmp+0x3c>
 203cc3c:	20800003 	ldbu	r2,0(r4)
 203cc40:	28c00003 	ldbu	r3,0(r5)
 203cc44:	31bfffc4 	addi	r6,r6,-1
 203cc48:	10c00e1e 	bne	r2,r3,203cc84 <memcmp+0x74>
 203cc4c:	21000044 	addi	r4,r4,1
 203cc50:	29400044 	addi	r5,r5,1
 203cc54:	31fff91e 	bne	r6,r7,203cc3c <__alt_mem_mem_0+0xfd01cc3c>
 203cc58:	0005883a 	mov	r2,zero
 203cc5c:	f800283a 	ret
 203cc60:	20c00017 	ldw	r3,0(r4)
 203cc64:	28800017 	ldw	r2,0(r5)
 203cc68:	18bfee1e 	bne	r3,r2,203cc24 <__alt_mem_mem_0+0xfd01cc24>
 203cc6c:	31bfff04 	addi	r6,r6,-4
 203cc70:	21000104 	addi	r4,r4,4
 203cc74:	29400104 	addi	r5,r5,4
 203cc78:	39bff936 	bltu	r7,r6,203cc60 <__alt_mem_mem_0+0xfd01cc60>
 203cc7c:	303fe91e 	bne	r6,zero,203cc24 <__alt_mem_mem_0+0xfd01cc24>
 203cc80:	003ff506 	br	203cc58 <__alt_mem_mem_0+0xfd01cc58>
 203cc84:	10c5c83a 	sub	r2,r2,r3
 203cc88:	f800283a 	ret

0203cc8c <_putc_r>:
 203cc8c:	defffc04 	addi	sp,sp,-16
 203cc90:	dc000215 	stw	r16,8(sp)
 203cc94:	dfc00315 	stw	ra,12(sp)
 203cc98:	2021883a 	mov	r16,r4
 203cc9c:	20000226 	beq	r4,zero,203cca8 <_putc_r+0x1c>
 203cca0:	20800e17 	ldw	r2,56(r4)
 203cca4:	10001b26 	beq	r2,zero,203cd14 <_putc_r+0x88>
 203cca8:	30800217 	ldw	r2,8(r6)
 203ccac:	10bfffc4 	addi	r2,r2,-1
 203ccb0:	30800215 	stw	r2,8(r6)
 203ccb4:	10000a16 	blt	r2,zero,203cce0 <_putc_r+0x54>
 203ccb8:	30800017 	ldw	r2,0(r6)
 203ccbc:	11400005 	stb	r5,0(r2)
 203ccc0:	30800017 	ldw	r2,0(r6)
 203ccc4:	10c00044 	addi	r3,r2,1
 203ccc8:	30c00015 	stw	r3,0(r6)
 203cccc:	10800003 	ldbu	r2,0(r2)
 203ccd0:	dfc00317 	ldw	ra,12(sp)
 203ccd4:	dc000217 	ldw	r16,8(sp)
 203ccd8:	dec00404 	addi	sp,sp,16
 203ccdc:	f800283a 	ret
 203cce0:	30c00617 	ldw	r3,24(r6)
 203cce4:	10c00616 	blt	r2,r3,203cd00 <_putc_r+0x74>
 203cce8:	30800017 	ldw	r2,0(r6)
 203ccec:	00c00284 	movi	r3,10
 203ccf0:	11400005 	stb	r5,0(r2)
 203ccf4:	30800017 	ldw	r2,0(r6)
 203ccf8:	11400003 	ldbu	r5,0(r2)
 203ccfc:	28fff11e 	bne	r5,r3,203ccc4 <__alt_mem_mem_0+0xfd01ccc4>
 203cd00:	8009883a 	mov	r4,r16
 203cd04:	dfc00317 	ldw	ra,12(sp)
 203cd08:	dc000217 	ldw	r16,8(sp)
 203cd0c:	dec00404 	addi	sp,sp,16
 203cd10:	2009dc01 	jmpi	2009dc0 <__swbuf_r>
 203cd14:	d9400015 	stw	r5,0(sp)
 203cd18:	d9800115 	stw	r6,4(sp)
 203cd1c:	2004e900 	call	2004e90 <__sinit>
 203cd20:	d9800117 	ldw	r6,4(sp)
 203cd24:	d9400017 	ldw	r5,0(sp)
 203cd28:	003fdf06 	br	203cca8 <__alt_mem_mem_0+0xfd01cca8>

0203cd2c <putc>:
 203cd2c:	00808134 	movhi	r2,516
 203cd30:	defffc04 	addi	sp,sp,-16
 203cd34:	10963d04 	addi	r2,r2,22772
 203cd38:	dc000115 	stw	r16,4(sp)
 203cd3c:	14000017 	ldw	r16,0(r2)
 203cd40:	dc400215 	stw	r17,8(sp)
 203cd44:	dfc00315 	stw	ra,12(sp)
 203cd48:	2023883a 	mov	r17,r4
 203cd4c:	80000226 	beq	r16,zero,203cd58 <putc+0x2c>
 203cd50:	80800e17 	ldw	r2,56(r16)
 203cd54:	10001a26 	beq	r2,zero,203cdc0 <putc+0x94>
 203cd58:	28800217 	ldw	r2,8(r5)
 203cd5c:	10bfffc4 	addi	r2,r2,-1
 203cd60:	28800215 	stw	r2,8(r5)
 203cd64:	10000b16 	blt	r2,zero,203cd94 <putc+0x68>
 203cd68:	28800017 	ldw	r2,0(r5)
 203cd6c:	14400005 	stb	r17,0(r2)
 203cd70:	28800017 	ldw	r2,0(r5)
 203cd74:	10c00044 	addi	r3,r2,1
 203cd78:	28c00015 	stw	r3,0(r5)
 203cd7c:	10800003 	ldbu	r2,0(r2)
 203cd80:	dfc00317 	ldw	ra,12(sp)
 203cd84:	dc400217 	ldw	r17,8(sp)
 203cd88:	dc000117 	ldw	r16,4(sp)
 203cd8c:	dec00404 	addi	sp,sp,16
 203cd90:	f800283a 	ret
 203cd94:	28c00617 	ldw	r3,24(r5)
 203cd98:	10c00e16 	blt	r2,r3,203cdd4 <putc+0xa8>
 203cd9c:	28800017 	ldw	r2,0(r5)
 203cda0:	01000284 	movi	r4,10
 203cda4:	14400005 	stb	r17,0(r2)
 203cda8:	28800017 	ldw	r2,0(r5)
 203cdac:	10c00003 	ldbu	r3,0(r2)
 203cdb0:	193ff01e 	bne	r3,r4,203cd74 <__alt_mem_mem_0+0xfd01cd74>
 203cdb4:	280d883a 	mov	r6,r5
 203cdb8:	180b883a 	mov	r5,r3
 203cdbc:	00000706 	br	203cddc <putc+0xb0>
 203cdc0:	8009883a 	mov	r4,r16
 203cdc4:	d9400015 	stw	r5,0(sp)
 203cdc8:	2004e900 	call	2004e90 <__sinit>
 203cdcc:	d9400017 	ldw	r5,0(sp)
 203cdd0:	003fe106 	br	203cd58 <__alt_mem_mem_0+0xfd01cd58>
 203cdd4:	280d883a 	mov	r6,r5
 203cdd8:	880b883a 	mov	r5,r17
 203cddc:	8009883a 	mov	r4,r16
 203cde0:	dfc00317 	ldw	ra,12(sp)
 203cde4:	dc400217 	ldw	r17,8(sp)
 203cde8:	dc000117 	ldw	r16,4(sp)
 203cdec:	dec00404 	addi	sp,sp,16
 203cdf0:	2009dc01 	jmpi	2009dc0 <__swbuf_r>

0203cdf4 <_puts_r>:
 203cdf4:	defff604 	addi	sp,sp,-40
 203cdf8:	dc000715 	stw	r16,28(sp)
 203cdfc:	2021883a 	mov	r16,r4
 203ce00:	2809883a 	mov	r4,r5
 203ce04:	dc400815 	stw	r17,32(sp)
 203ce08:	dfc00915 	stw	ra,36(sp)
 203ce0c:	2823883a 	mov	r17,r5
 203ce10:	20075700 	call	2007570 <strlen>
 203ce14:	10c00044 	addi	r3,r2,1
 203ce18:	d8800115 	stw	r2,4(sp)
 203ce1c:	00808134 	movhi	r2,516
 203ce20:	108ea304 	addi	r2,r2,14988
 203ce24:	d8800215 	stw	r2,8(sp)
 203ce28:	00800044 	movi	r2,1
 203ce2c:	d8800315 	stw	r2,12(sp)
 203ce30:	00800084 	movi	r2,2
 203ce34:	dc400015 	stw	r17,0(sp)
 203ce38:	d8c00615 	stw	r3,24(sp)
 203ce3c:	dec00415 	stw	sp,16(sp)
 203ce40:	d8800515 	stw	r2,20(sp)
 203ce44:	80000226 	beq	r16,zero,203ce50 <_puts_r+0x5c>
 203ce48:	80800e17 	ldw	r2,56(r16)
 203ce4c:	10001426 	beq	r2,zero,203cea0 <_puts_r+0xac>
 203ce50:	81400217 	ldw	r5,8(r16)
 203ce54:	2880030b 	ldhu	r2,12(r5)
 203ce58:	10c8000c 	andi	r3,r2,8192
 203ce5c:	1800061e 	bne	r3,zero,203ce78 <_puts_r+0x84>
 203ce60:	29001917 	ldw	r4,100(r5)
 203ce64:	00f7ffc4 	movi	r3,-8193
 203ce68:	10880014 	ori	r2,r2,8192
 203ce6c:	20c6703a 	and	r3,r4,r3
 203ce70:	2880030d 	sth	r2,12(r5)
 203ce74:	28c01915 	stw	r3,100(r5)
 203ce78:	d9800404 	addi	r6,sp,16
 203ce7c:	8009883a 	mov	r4,r16
 203ce80:	20091300 	call	2009130 <__sfvwrite_r>
 203ce84:	1000091e 	bne	r2,zero,203ceac <_puts_r+0xb8>
 203ce88:	00800284 	movi	r2,10
 203ce8c:	dfc00917 	ldw	ra,36(sp)
 203ce90:	dc400817 	ldw	r17,32(sp)
 203ce94:	dc000717 	ldw	r16,28(sp)
 203ce98:	dec00a04 	addi	sp,sp,40
 203ce9c:	f800283a 	ret
 203cea0:	8009883a 	mov	r4,r16
 203cea4:	2004e900 	call	2004e90 <__sinit>
 203cea8:	003fe906 	br	203ce50 <__alt_mem_mem_0+0xfd01ce50>
 203ceac:	00bfffc4 	movi	r2,-1
 203ceb0:	003ff606 	br	203ce8c <__alt_mem_mem_0+0xfd01ce8c>

0203ceb4 <puts>:
 203ceb4:	00808134 	movhi	r2,516
 203ceb8:	10963d04 	addi	r2,r2,22772
 203cebc:	200b883a 	mov	r5,r4
 203cec0:	11000017 	ldw	r4,0(r2)
 203cec4:	203cdf41 	jmpi	203cdf4 <_puts_r>

0203cec8 <_snprintf_r>:
 203cec8:	30003116 	blt	r6,zero,203cf90 <_snprintf_r+0xc8>
 203cecc:	deffe404 	addi	sp,sp,-112
 203ced0:	00c08204 	movi	r3,520
 203ced4:	dc001a15 	stw	r16,104(sp)
 203ced8:	3005883a 	mov	r2,r6
 203cedc:	dfc01b15 	stw	ra,108(sp)
 203cee0:	d8c0030d 	sth	r3,12(sp)
 203cee4:	d9400015 	stw	r5,0(sp)
 203cee8:	d9400415 	stw	r5,16(sp)
 203ceec:	380d883a 	mov	r6,r7
 203cef0:	2021883a 	mov	r16,r4
 203cef4:	10001026 	beq	r2,zero,203cf38 <_snprintf_r+0x70>
 203cef8:	10bfffc4 	addi	r2,r2,-1
 203cefc:	d8800215 	stw	r2,8(sp)
 203cf00:	d8800515 	stw	r2,20(sp)
 203cf04:	d9c01c04 	addi	r7,sp,112
 203cf08:	00bfffc4 	movi	r2,-1
 203cf0c:	d80b883a 	mov	r5,sp
 203cf10:	d880038d 	sth	r2,14(sp)
 203cf14:	203d1140 	call	203d114 <___svfprintf_internal_r>
 203cf18:	00ffffc4 	movi	r3,-1
 203cf1c:	10c01316 	blt	r2,r3,203cf6c <_snprintf_r+0xa4>
 203cf20:	d8c00017 	ldw	r3,0(sp)
 203cf24:	18000005 	stb	zero,0(r3)
 203cf28:	dfc01b17 	ldw	ra,108(sp)
 203cf2c:	dc001a17 	ldw	r16,104(sp)
 203cf30:	dec01c04 	addi	sp,sp,112
 203cf34:	f800283a 	ret
 203cf38:	00bfffc4 	movi	r2,-1
 203cf3c:	d9c01c04 	addi	r7,sp,112
 203cf40:	d80b883a 	mov	r5,sp
 203cf44:	d8000215 	stw	zero,8(sp)
 203cf48:	d8000515 	stw	zero,20(sp)
 203cf4c:	d880038d 	sth	r2,14(sp)
 203cf50:	203d1140 	call	203d114 <___svfprintf_internal_r>
 203cf54:	00ffffc4 	movi	r3,-1
 203cf58:	10c00716 	blt	r2,r3,203cf78 <_snprintf_r+0xb0>
 203cf5c:	dfc01b17 	ldw	ra,108(sp)
 203cf60:	dc001a17 	ldw	r16,104(sp)
 203cf64:	dec01c04 	addi	sp,sp,112
 203cf68:	f800283a 	ret
 203cf6c:	00c022c4 	movi	r3,139
 203cf70:	80c00015 	stw	r3,0(r16)
 203cf74:	003fea06 	br	203cf20 <__alt_mem_mem_0+0xfd01cf20>
 203cf78:	00c022c4 	movi	r3,139
 203cf7c:	80c00015 	stw	r3,0(r16)
 203cf80:	dfc01b17 	ldw	ra,108(sp)
 203cf84:	dc001a17 	ldw	r16,104(sp)
 203cf88:	dec01c04 	addi	sp,sp,112
 203cf8c:	f800283a 	ret
 203cf90:	008022c4 	movi	r2,139
 203cf94:	20800015 	stw	r2,0(r4)
 203cf98:	00bfffc4 	movi	r2,-1
 203cf9c:	f800283a 	ret

0203cfa0 <snprintf>:
 203cfa0:	deffe304 	addi	sp,sp,-116
 203cfa4:	dfc01b15 	stw	ra,108(sp)
 203cfa8:	dc001a15 	stw	r16,104(sp)
 203cfac:	d9c01c15 	stw	r7,112(sp)
 203cfb0:	00808134 	movhi	r2,516
 203cfb4:	10963d04 	addi	r2,r2,22772
 203cfb8:	14000017 	ldw	r16,0(r2)
 203cfbc:	28002d16 	blt	r5,zero,203d074 <snprintf+0xd4>
 203cfc0:	00808204 	movi	r2,520
 203cfc4:	d880030d 	sth	r2,12(sp)
 203cfc8:	d9000015 	stw	r4,0(sp)
 203cfcc:	d9000415 	stw	r4,16(sp)
 203cfd0:	28001126 	beq	r5,zero,203d018 <snprintf+0x78>
 203cfd4:	28bfffc4 	addi	r2,r5,-1
 203cfd8:	d8800215 	stw	r2,8(sp)
 203cfdc:	d8800515 	stw	r2,20(sp)
 203cfe0:	d9c01c04 	addi	r7,sp,112
 203cfe4:	00bfffc4 	movi	r2,-1
 203cfe8:	d80b883a 	mov	r5,sp
 203cfec:	8009883a 	mov	r4,r16
 203cff0:	d880038d 	sth	r2,14(sp)
 203cff4:	203d1140 	call	203d114 <___svfprintf_internal_r>
 203cff8:	00ffffc4 	movi	r3,-1
 203cffc:	10c01416 	blt	r2,r3,203d050 <snprintf+0xb0>
 203d000:	d8c00017 	ldw	r3,0(sp)
 203d004:	18000005 	stb	zero,0(r3)
 203d008:	dfc01b17 	ldw	ra,108(sp)
 203d00c:	dc001a17 	ldw	r16,104(sp)
 203d010:	dec01d04 	addi	sp,sp,116
 203d014:	f800283a 	ret
 203d018:	00bfffc4 	movi	r2,-1
 203d01c:	d9c01c04 	addi	r7,sp,112
 203d020:	d80b883a 	mov	r5,sp
 203d024:	8009883a 	mov	r4,r16
 203d028:	d8000215 	stw	zero,8(sp)
 203d02c:	d8000515 	stw	zero,20(sp)
 203d030:	d880038d 	sth	r2,14(sp)
 203d034:	203d1140 	call	203d114 <___svfprintf_internal_r>
 203d038:	00ffffc4 	movi	r3,-1
 203d03c:	10c00716 	blt	r2,r3,203d05c <snprintf+0xbc>
 203d040:	dfc01b17 	ldw	ra,108(sp)
 203d044:	dc001a17 	ldw	r16,104(sp)
 203d048:	dec01d04 	addi	sp,sp,116
 203d04c:	f800283a 	ret
 203d050:	00c022c4 	movi	r3,139
 203d054:	80c00015 	stw	r3,0(r16)
 203d058:	003fe906 	br	203d000 <__alt_mem_mem_0+0xfd01d000>
 203d05c:	00c022c4 	movi	r3,139
 203d060:	80c00015 	stw	r3,0(r16)
 203d064:	dfc01b17 	ldw	ra,108(sp)
 203d068:	dc001a17 	ldw	r16,104(sp)
 203d06c:	dec01d04 	addi	sp,sp,116
 203d070:	f800283a 	ret
 203d074:	008022c4 	movi	r2,139
 203d078:	80800015 	stw	r2,0(r16)
 203d07c:	00bfffc4 	movi	r2,-1
 203d080:	003fef06 	br	203d040 <__alt_mem_mem_0+0xfd01d040>

0203d084 <strcpy>:
 203d084:	2906b03a 	or	r3,r5,r4
 203d088:	18c000cc 	andi	r3,r3,3
 203d08c:	2005883a 	mov	r2,r4
 203d090:	1800161e 	bne	r3,zero,203d0ec <strcpy+0x68>
 203d094:	29c00017 	ldw	r7,0(r5)
 203d098:	02ffbff4 	movhi	r11,65279
 203d09c:	5affbfc4 	addi	r11,r11,-257
 203d0a0:	02a02074 	movhi	r10,32897
 203d0a4:	01c6303a 	nor	r3,zero,r7
 203d0a8:	3ac9883a 	add	r4,r7,r11
 203d0ac:	52a02004 	addi	r10,r10,-32640
 203d0b0:	20c6703a 	and	r3,r4,r3
 203d0b4:	1a86703a 	and	r3,r3,r10
 203d0b8:	18000c1e 	bne	r3,zero,203d0ec <strcpy+0x68>
 203d0bc:	1011883a 	mov	r8,r2
 203d0c0:	41c00015 	stw	r7,0(r8)
 203d0c4:	29400104 	addi	r5,r5,4
 203d0c8:	29c00017 	ldw	r7,0(r5)
 203d0cc:	41800104 	addi	r6,r8,4
 203d0d0:	3011883a 	mov	r8,r6
 203d0d4:	3ad3883a 	add	r9,r7,r11
 203d0d8:	01c6303a 	nor	r3,zero,r7
 203d0dc:	48c6703a 	and	r3,r9,r3
 203d0e0:	1a86703a 	and	r3,r3,r10
 203d0e4:	183ff626 	beq	r3,zero,203d0c0 <__alt_mem_mem_0+0xfd01d0c0>
 203d0e8:	00000106 	br	203d0f0 <strcpy+0x6c>
 203d0ec:	100d883a 	mov	r6,r2
 203d0f0:	28c00003 	ldbu	r3,0(r5)
 203d0f4:	31800044 	addi	r6,r6,1
 203d0f8:	29400044 	addi	r5,r5,1
 203d0fc:	30ffffc5 	stb	r3,-1(r6)
 203d100:	18c03fcc 	andi	r3,r3,255
 203d104:	18c0201c 	xori	r3,r3,128
 203d108:	18ffe004 	addi	r3,r3,-128
 203d10c:	183ff81e 	bne	r3,zero,203d0f0 <__alt_mem_mem_0+0xfd01d0f0>
 203d110:	f800283a 	ret

0203d114 <___svfprintf_internal_r>:
 203d114:	deffb704 	addi	sp,sp,-292
 203d118:	dfc04815 	stw	ra,288(sp)
 203d11c:	ddc04615 	stw	r23,280(sp)
 203d120:	d9402c15 	stw	r5,176(sp)
 203d124:	d9003915 	stw	r4,228(sp)
 203d128:	302f883a 	mov	r23,r6
 203d12c:	d9c02d15 	stw	r7,180(sp)
 203d130:	df004715 	stw	fp,284(sp)
 203d134:	dd804515 	stw	r22,276(sp)
 203d138:	dd404415 	stw	r21,272(sp)
 203d13c:	dd004315 	stw	r20,268(sp)
 203d140:	dcc04215 	stw	r19,264(sp)
 203d144:	dc804115 	stw	r18,260(sp)
 203d148:	dc404015 	stw	r17,256(sp)
 203d14c:	dc003f15 	stw	r16,252(sp)
 203d150:	20055480 	call	2005548 <_localeconv_r>
 203d154:	10800017 	ldw	r2,0(r2)
 203d158:	1009883a 	mov	r4,r2
 203d15c:	d8803415 	stw	r2,208(sp)
 203d160:	20075700 	call	2007570 <strlen>
 203d164:	d8c02c17 	ldw	r3,176(sp)
 203d168:	d8803815 	stw	r2,224(sp)
 203d16c:	1880030b 	ldhu	r2,12(r3)
 203d170:	1080200c 	andi	r2,r2,128
 203d174:	10000226 	beq	r2,zero,203d180 <___svfprintf_internal_r+0x6c>
 203d178:	18800417 	ldw	r2,16(r3)
 203d17c:	10067f26 	beq	r2,zero,203eb7c <___svfprintf_internal_r+0x1a68>
 203d180:	dcc03917 	ldw	r19,228(sp)
 203d184:	d8c00404 	addi	r3,sp,16
 203d188:	05408134 	movhi	r21,516
 203d18c:	d9001e04 	addi	r4,sp,120
 203d190:	ad4ea404 	addi	r21,r21,14992
 203d194:	d8c01e15 	stw	r3,120(sp)
 203d198:	d8002015 	stw	zero,128(sp)
 203d19c:	d8001f15 	stw	zero,124(sp)
 203d1a0:	d8003315 	stw	zero,204(sp)
 203d1a4:	d8003615 	stw	zero,216(sp)
 203d1a8:	d8003715 	stw	zero,220(sp)
 203d1ac:	1811883a 	mov	r8,r3
 203d1b0:	d8003a15 	stw	zero,232(sp)
 203d1b4:	d8003b15 	stw	zero,236(sp)
 203d1b8:	d8002f15 	stw	zero,188(sp)
 203d1bc:	d9002815 	stw	r4,160(sp)
 203d1c0:	b8800007 	ldb	r2,0(r23)
 203d1c4:	10026726 	beq	r2,zero,203db64 <___svfprintf_internal_r+0xa50>
 203d1c8:	00c00944 	movi	r3,37
 203d1cc:	b821883a 	mov	r16,r23
 203d1d0:	10c0021e 	bne	r2,r3,203d1dc <___svfprintf_internal_r+0xc8>
 203d1d4:	00001406 	br	203d228 <___svfprintf_internal_r+0x114>
 203d1d8:	10c00326 	beq	r2,r3,203d1e8 <___svfprintf_internal_r+0xd4>
 203d1dc:	84000044 	addi	r16,r16,1
 203d1e0:	80800007 	ldb	r2,0(r16)
 203d1e4:	103ffc1e 	bne	r2,zero,203d1d8 <__alt_mem_mem_0+0xfd01d1d8>
 203d1e8:	85e3c83a 	sub	r17,r16,r23
 203d1ec:	88000e26 	beq	r17,zero,203d228 <___svfprintf_internal_r+0x114>
 203d1f0:	d8c02017 	ldw	r3,128(sp)
 203d1f4:	d8801f17 	ldw	r2,124(sp)
 203d1f8:	45c00015 	stw	r23,0(r8)
 203d1fc:	1c47883a 	add	r3,r3,r17
 203d200:	10800044 	addi	r2,r2,1
 203d204:	d8c02015 	stw	r3,128(sp)
 203d208:	44400115 	stw	r17,4(r8)
 203d20c:	d8801f15 	stw	r2,124(sp)
 203d210:	00c001c4 	movi	r3,7
 203d214:	18809716 	blt	r3,r2,203d474 <___svfprintf_internal_r+0x360>
 203d218:	42000204 	addi	r8,r8,8
 203d21c:	d9402f17 	ldw	r5,188(sp)
 203d220:	2c4b883a 	add	r5,r5,r17
 203d224:	d9402f15 	stw	r5,188(sp)
 203d228:	80800007 	ldb	r2,0(r16)
 203d22c:	10009826 	beq	r2,zero,203d490 <___svfprintf_internal_r+0x37c>
 203d230:	84400047 	ldb	r17,1(r16)
 203d234:	00bfffc4 	movi	r2,-1
 203d238:	85c00044 	addi	r23,r16,1
 203d23c:	d8002785 	stb	zero,158(sp)
 203d240:	0007883a 	mov	r3,zero
 203d244:	000f883a 	mov	r7,zero
 203d248:	d8802915 	stw	r2,164(sp)
 203d24c:	d8003115 	stw	zero,196(sp)
 203d250:	0025883a 	mov	r18,zero
 203d254:	01401604 	movi	r5,88
 203d258:	01800244 	movi	r6,9
 203d25c:	02800a84 	movi	r10,42
 203d260:	02401b04 	movi	r9,108
 203d264:	bdc00044 	addi	r23,r23,1
 203d268:	88bff804 	addi	r2,r17,-32
 203d26c:	2882f036 	bltu	r5,r2,203de30 <___svfprintf_internal_r+0xd1c>
 203d270:	100490ba 	slli	r2,r2,2
 203d274:	01008134 	movhi	r4,516
 203d278:	2134a204 	addi	r4,r4,-11640
 203d27c:	1105883a 	add	r2,r2,r4
 203d280:	10800017 	ldw	r2,0(r2)
 203d284:	1000683a 	jmp	r2
 203d288:	0203dd98 	cmpnei	r8,zero,3958
 203d28c:	0203de30 	cmpltui	r8,zero,3960
 203d290:	0203de30 	cmpltui	r8,zero,3960
 203d294:	0203dd8c 	andi	r8,zero,3958
 203d298:	0203de30 	cmpltui	r8,zero,3960
 203d29c:	0203de30 	cmpltui	r8,zero,3960
 203d2a0:	0203de30 	cmpltui	r8,zero,3960
 203d2a4:	0203de30 	cmpltui	r8,zero,3960
 203d2a8:	0203de30 	cmpltui	r8,zero,3960
 203d2ac:	0203de30 	cmpltui	r8,zero,3960
 203d2b0:	0203d4ec 	andhi	r8,zero,3923
 203d2b4:	0203dcc8 	cmpgei	r8,zero,3955
 203d2b8:	0203de30 	cmpltui	r8,zero,3960
 203d2bc:	0203d3fc 	xorhi	r8,zero,3919
 203d2c0:	0203d514 	movui	r8,3924
 203d2c4:	0203de30 	cmpltui	r8,zero,3960
 203d2c8:	0203d588 	cmpgei	r8,zero,3926
 203d2cc:	0203d554 	movui	r8,3925
 203d2d0:	0203d554 	movui	r8,3925
 203d2d4:	0203d554 	movui	r8,3925
 203d2d8:	0203d554 	movui	r8,3925
 203d2dc:	0203d554 	movui	r8,3925
 203d2e0:	0203d554 	movui	r8,3925
 203d2e4:	0203d554 	movui	r8,3925
 203d2e8:	0203d554 	movui	r8,3925
 203d2ec:	0203d554 	movui	r8,3925
 203d2f0:	0203de30 	cmpltui	r8,zero,3960
 203d2f4:	0203de30 	cmpltui	r8,zero,3960
 203d2f8:	0203de30 	cmpltui	r8,zero,3960
 203d2fc:	0203de30 	cmpltui	r8,zero,3960
 203d300:	0203de30 	cmpltui	r8,zero,3960
 203d304:	0203de30 	cmpltui	r8,zero,3960
 203d308:	0203de30 	cmpltui	r8,zero,3960
 203d30c:	0203de30 	cmpltui	r8,zero,3960
 203d310:	0203de30 	cmpltui	r8,zero,3960
 203d314:	0203de30 	cmpltui	r8,zero,3960
 203d318:	0203d640 	call	203d64 <alt_exception_muldiv+0x203d64>
 203d31c:	0203d594 	movui	r8,3926
 203d320:	0203de30 	cmpltui	r8,zero,3960
 203d324:	0203d594 	movui	r8,3926
 203d328:	0203de30 	cmpltui	r8,zero,3960
 203d32c:	0203de30 	cmpltui	r8,zero,3960
 203d330:	0203de30 	cmpltui	r8,zero,3960
 203d334:	0203de30 	cmpltui	r8,zero,3960
 203d338:	0203d634 	movhi	r8,3928
 203d33c:	0203de30 	cmpltui	r8,zero,3960
 203d340:	0203de30 	cmpltui	r8,zero,3960
 203d344:	0203d6fc 	xorhi	r8,zero,3931
 203d348:	0203de30 	cmpltui	r8,zero,3960
 203d34c:	0203de30 	cmpltui	r8,zero,3960
 203d350:	0203de30 	cmpltui	r8,zero,3960
 203d354:	0203de30 	cmpltui	r8,zero,3960
 203d358:	0203de30 	cmpltui	r8,zero,3960
 203d35c:	0203db6c 	andhi	r8,zero,3949
 203d360:	0203de30 	cmpltui	r8,zero,3960
 203d364:	0203de30 	cmpltui	r8,zero,3960
 203d368:	0203dbcc 	andi	r8,zero,3951
 203d36c:	0203de30 	cmpltui	r8,zero,3960
 203d370:	0203de30 	cmpltui	r8,zero,3960
 203d374:	0203de30 	cmpltui	r8,zero,3960
 203d378:	0203de30 	cmpltui	r8,zero,3960
 203d37c:	0203de30 	cmpltui	r8,zero,3960
 203d380:	0203de30 	cmpltui	r8,zero,3960
 203d384:	0203de30 	cmpltui	r8,zero,3960
 203d388:	0203de30 	cmpltui	r8,zero,3960
 203d38c:	0203de30 	cmpltui	r8,zero,3960
 203d390:	0203de30 	cmpltui	r8,zero,3960
 203d394:	0203dc7c 	xorhi	r8,zero,3953
 203d398:	0203ddb8 	rdprs	r8,zero,3958
 203d39c:	0203d594 	movui	r8,3926
 203d3a0:	0203d594 	movui	r8,3926
 203d3a4:	0203d594 	movui	r8,3926
 203d3a8:	0203de0c 	andi	r8,zero,3960
 203d3ac:	0203ddb8 	rdprs	r8,zero,3958
 203d3b0:	0203de30 	cmpltui	r8,zero,3960
 203d3b4:	0203de30 	cmpltui	r8,zero,3960
 203d3b8:	0203ddc8 	cmpgei	r8,zero,3959
 203d3bc:	0203de30 	cmpltui	r8,zero,3960
 203d3c0:	0203ddd8 	cmpnei	r8,zero,3959
 203d3c4:	0203dcb8 	rdprs	r8,zero,3954
 203d3c8:	0203d408 	cmpgei	r8,zero,3920
 203d3cc:	0203dcd8 	cmpnei	r8,zero,3955
 203d3d0:	0203de30 	cmpltui	r8,zero,3960
 203d3d4:	0203dce4 	muli	r8,zero,3955
 203d3d8:	0203de30 	cmpltui	r8,zero,3960
 203d3dc:	0203dd40 	call	203dd4 <alt_exception_muldiv+0x203dd4>
 203d3e0:	0203de30 	cmpltui	r8,zero,3960
 203d3e4:	0203de30 	cmpltui	r8,zero,3960
 203d3e8:	0203dd50 	cmplti	r8,zero,3957
 203d3ec:	d9003117 	ldw	r4,196(sp)
 203d3f0:	d8802d15 	stw	r2,180(sp)
 203d3f4:	0109c83a 	sub	r4,zero,r4
 203d3f8:	d9003115 	stw	r4,196(sp)
 203d3fc:	94800114 	ori	r18,r18,4
 203d400:	bc400007 	ldb	r17,0(r23)
 203d404:	003f9706 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203d408:	00800c04 	movi	r2,48
 203d40c:	d9002d17 	ldw	r4,180(sp)
 203d410:	d9402917 	ldw	r5,164(sp)
 203d414:	d8802705 	stb	r2,156(sp)
 203d418:	00801e04 	movi	r2,120
 203d41c:	d8802745 	stb	r2,157(sp)
 203d420:	d8002785 	stb	zero,158(sp)
 203d424:	20c00104 	addi	r3,r4,4
 203d428:	25000017 	ldw	r20,0(r4)
 203d42c:	002d883a 	mov	r22,zero
 203d430:	90800094 	ori	r2,r18,2
 203d434:	28028616 	blt	r5,zero,203de50 <___svfprintf_internal_r+0xd3c>
 203d438:	00bfdfc4 	movi	r2,-129
 203d43c:	90a4703a 	and	r18,r18,r2
 203d440:	d8c02d15 	stw	r3,180(sp)
 203d444:	94800094 	ori	r18,r18,2
 203d448:	a002731e 	bne	r20,zero,203de18 <___svfprintf_internal_r+0xd04>
 203d44c:	00808134 	movhi	r2,516
 203d450:	1083ce04 	addi	r2,r2,3896
 203d454:	d8803a15 	stw	r2,232(sp)
 203d458:	04401e04 	movi	r17,120
 203d45c:	d8c02917 	ldw	r3,164(sp)
 203d460:	0039883a 	mov	fp,zero
 203d464:	1801d526 	beq	r3,zero,203dbbc <___svfprintf_internal_r+0xaa8>
 203d468:	0029883a 	mov	r20,zero
 203d46c:	002d883a 	mov	r22,zero
 203d470:	0001f106 	br	203dc38 <___svfprintf_internal_r+0xb24>
 203d474:	d9402c17 	ldw	r5,176(sp)
 203d478:	d9801e04 	addi	r6,sp,120
 203d47c:	9809883a 	mov	r4,r19
 203d480:	203f5840 	call	203f584 <__ssprint_r>
 203d484:	1000081e 	bne	r2,zero,203d4a8 <___svfprintf_internal_r+0x394>
 203d488:	da000404 	addi	r8,sp,16
 203d48c:	003f6306 	br	203d21c <__alt_mem_mem_0+0xfd01d21c>
 203d490:	d8802017 	ldw	r2,128(sp)
 203d494:	10000426 	beq	r2,zero,203d4a8 <___svfprintf_internal_r+0x394>
 203d498:	d9402c17 	ldw	r5,176(sp)
 203d49c:	d9003917 	ldw	r4,228(sp)
 203d4a0:	d9801e04 	addi	r6,sp,120
 203d4a4:	203f5840 	call	203f584 <__ssprint_r>
 203d4a8:	d8802c17 	ldw	r2,176(sp)
 203d4ac:	10c0030b 	ldhu	r3,12(r2)
 203d4b0:	d8802f17 	ldw	r2,188(sp)
 203d4b4:	18c0100c 	andi	r3,r3,64
 203d4b8:	1805f51e 	bne	r3,zero,203ec90 <___svfprintf_internal_r+0x1b7c>
 203d4bc:	dfc04817 	ldw	ra,288(sp)
 203d4c0:	df004717 	ldw	fp,284(sp)
 203d4c4:	ddc04617 	ldw	r23,280(sp)
 203d4c8:	dd804517 	ldw	r22,276(sp)
 203d4cc:	dd404417 	ldw	r21,272(sp)
 203d4d0:	dd004317 	ldw	r20,268(sp)
 203d4d4:	dcc04217 	ldw	r19,264(sp)
 203d4d8:	dc804117 	ldw	r18,260(sp)
 203d4dc:	dc404017 	ldw	r17,256(sp)
 203d4e0:	dc003f17 	ldw	r16,252(sp)
 203d4e4:	dec04904 	addi	sp,sp,292
 203d4e8:	f800283a 	ret
 203d4ec:	d8802d17 	ldw	r2,180(sp)
 203d4f0:	d9002d17 	ldw	r4,180(sp)
 203d4f4:	10800017 	ldw	r2,0(r2)
 203d4f8:	d8803115 	stw	r2,196(sp)
 203d4fc:	20800104 	addi	r2,r4,4
 203d500:	d9003117 	ldw	r4,196(sp)
 203d504:	203fb916 	blt	r4,zero,203d3ec <__alt_mem_mem_0+0xfd01d3ec>
 203d508:	d8802d15 	stw	r2,180(sp)
 203d50c:	bc400007 	ldb	r17,0(r23)
 203d510:	003f5406 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203d514:	bc400007 	ldb	r17,0(r23)
 203d518:	bac00044 	addi	r11,r23,1
 203d51c:	8a873926 	beq	r17,r10,203f204 <___svfprintf_internal_r+0x20f0>
 203d520:	88bff404 	addi	r2,r17,-48
 203d524:	0009883a 	mov	r4,zero
 203d528:	30868836 	bltu	r6,r2,203ef4c <___svfprintf_internal_r+0x1e38>
 203d52c:	5c400007 	ldb	r17,0(r11)
 203d530:	210002a4 	muli	r4,r4,10
 203d534:	5dc00044 	addi	r23,r11,1
 203d538:	b817883a 	mov	r11,r23
 203d53c:	2089883a 	add	r4,r4,r2
 203d540:	88bff404 	addi	r2,r17,-48
 203d544:	30bff92e 	bgeu	r6,r2,203d52c <__alt_mem_mem_0+0xfd01d52c>
 203d548:	2005d716 	blt	r4,zero,203eca8 <___svfprintf_internal_r+0x1b94>
 203d54c:	d9002915 	stw	r4,164(sp)
 203d550:	003f4506 	br	203d268 <__alt_mem_mem_0+0xfd01d268>
 203d554:	b809883a 	mov	r4,r23
 203d558:	d8003115 	stw	zero,196(sp)
 203d55c:	88bff404 	addi	r2,r17,-48
 203d560:	0017883a 	mov	r11,zero
 203d564:	24400007 	ldb	r17,0(r4)
 203d568:	5ac002a4 	muli	r11,r11,10
 203d56c:	bdc00044 	addi	r23,r23,1
 203d570:	b809883a 	mov	r4,r23
 203d574:	12d7883a 	add	r11,r2,r11
 203d578:	88bff404 	addi	r2,r17,-48
 203d57c:	30bff92e 	bgeu	r6,r2,203d564 <__alt_mem_mem_0+0xfd01d564>
 203d580:	dac03115 	stw	r11,196(sp)
 203d584:	003f3806 	br	203d268 <__alt_mem_mem_0+0xfd01d268>
 203d588:	94802014 	ori	r18,r18,128
 203d58c:	bc400007 	ldb	r17,0(r23)
 203d590:	003f3406 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203d594:	18c03fcc 	andi	r3,r3,255
 203d598:	1807471e 	bne	r3,zero,203f2b8 <___svfprintf_internal_r+0x21a4>
 203d59c:	9080020c 	andi	r2,r18,8
 203d5a0:	10047d26 	beq	r2,zero,203e798 <___svfprintf_internal_r+0x1684>
 203d5a4:	d8c02d17 	ldw	r3,180(sp)
 203d5a8:	d9002d17 	ldw	r4,180(sp)
 203d5ac:	d9402d17 	ldw	r5,180(sp)
 203d5b0:	18c00017 	ldw	r3,0(r3)
 203d5b4:	21000117 	ldw	r4,4(r4)
 203d5b8:	29400204 	addi	r5,r5,8
 203d5bc:	d8c03615 	stw	r3,216(sp)
 203d5c0:	d9003715 	stw	r4,220(sp)
 203d5c4:	d9402d15 	stw	r5,180(sp)
 203d5c8:	d9003617 	ldw	r4,216(sp)
 203d5cc:	d9403717 	ldw	r5,220(sp)
 203d5d0:	da003e15 	stw	r8,248(sp)
 203d5d4:	04000044 	movi	r16,1
 203d5d8:	20072900 	call	2007290 <__fpclassifyd>
 203d5dc:	da003e17 	ldw	r8,248(sp)
 203d5e0:	14044b1e 	bne	r2,r16,203e710 <___svfprintf_internal_r+0x15fc>
 203d5e4:	d9003617 	ldw	r4,216(sp)
 203d5e8:	d9403717 	ldw	r5,220(sp)
 203d5ec:	000d883a 	mov	r6,zero
 203d5f0:	000f883a 	mov	r7,zero
 203d5f4:	200c05c0 	call	200c05c <__ledf2>
 203d5f8:	da003e17 	ldw	r8,248(sp)
 203d5fc:	1005f316 	blt	r2,zero,203edcc <___svfprintf_internal_r+0x1cb8>
 203d600:	df002783 	ldbu	fp,158(sp)
 203d604:	008011c4 	movi	r2,71
 203d608:	1445590e 	bge	r2,r17,203eb70 <___svfprintf_internal_r+0x1a5c>
 203d60c:	04008134 	movhi	r16,516
 203d610:	8403c604 	addi	r16,r16,3864
 203d614:	00c000c4 	movi	r3,3
 203d618:	00bfdfc4 	movi	r2,-129
 203d61c:	d8c02a15 	stw	r3,168(sp)
 203d620:	90a4703a 	and	r18,r18,r2
 203d624:	d8c02e15 	stw	r3,184(sp)
 203d628:	d8002915 	stw	zero,164(sp)
 203d62c:	d8003215 	stw	zero,200(sp)
 203d630:	00006606 	br	203d7cc <___svfprintf_internal_r+0x6b8>
 203d634:	94800214 	ori	r18,r18,8
 203d638:	bc400007 	ldb	r17,0(r23)
 203d63c:	003f0906 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203d640:	18c03fcc 	andi	r3,r3,255
 203d644:	1807181e 	bne	r3,zero,203f2a8 <___svfprintf_internal_r+0x2194>
 203d648:	94800414 	ori	r18,r18,16
 203d64c:	9080080c 	andi	r2,r18,32
 203d650:	10039626 	beq	r2,zero,203e4ac <___svfprintf_internal_r+0x1398>
 203d654:	d9402d17 	ldw	r5,180(sp)
 203d658:	28800117 	ldw	r2,4(r5)
 203d65c:	2d000017 	ldw	r20,0(r5)
 203d660:	29400204 	addi	r5,r5,8
 203d664:	d9402d15 	stw	r5,180(sp)
 203d668:	102d883a 	mov	r22,r2
 203d66c:	10039816 	blt	r2,zero,203e4d0 <___svfprintf_internal_r+0x13bc>
 203d670:	d9402917 	ldw	r5,164(sp)
 203d674:	df002783 	ldbu	fp,158(sp)
 203d678:	2803ab16 	blt	r5,zero,203e528 <___svfprintf_internal_r+0x1414>
 203d67c:	00ffdfc4 	movi	r3,-129
 203d680:	a584b03a 	or	r2,r20,r22
 203d684:	90e4703a 	and	r18,r18,r3
 203d688:	10014a26 	beq	r2,zero,203dbb4 <___svfprintf_internal_r+0xaa0>
 203d68c:	b0034b26 	beq	r22,zero,203e3bc <___svfprintf_internal_r+0x12a8>
 203d690:	dc402a15 	stw	r17,168(sp)
 203d694:	dc001e04 	addi	r16,sp,120
 203d698:	b023883a 	mov	r17,r22
 203d69c:	402d883a 	mov	r22,r8
 203d6a0:	a009883a 	mov	r4,r20
 203d6a4:	880b883a 	mov	r5,r17
 203d6a8:	01800284 	movi	r6,10
 203d6ac:	000f883a 	mov	r7,zero
 203d6b0:	200a6780 	call	200a678 <__umoddi3>
 203d6b4:	10800c04 	addi	r2,r2,48
 203d6b8:	843fffc4 	addi	r16,r16,-1
 203d6bc:	a009883a 	mov	r4,r20
 203d6c0:	880b883a 	mov	r5,r17
 203d6c4:	80800005 	stb	r2,0(r16)
 203d6c8:	01800284 	movi	r6,10
 203d6cc:	000f883a 	mov	r7,zero
 203d6d0:	200a1000 	call	200a100 <__udivdi3>
 203d6d4:	1029883a 	mov	r20,r2
 203d6d8:	10c4b03a 	or	r2,r2,r3
 203d6dc:	1823883a 	mov	r17,r3
 203d6e0:	103fef1e 	bne	r2,zero,203d6a0 <__alt_mem_mem_0+0xfd01d6a0>
 203d6e4:	d8c02817 	ldw	r3,160(sp)
 203d6e8:	dc402a17 	ldw	r17,168(sp)
 203d6ec:	b011883a 	mov	r8,r22
 203d6f0:	1c07c83a 	sub	r3,r3,r16
 203d6f4:	d8c02e15 	stw	r3,184(sp)
 203d6f8:	00002e06 	br	203d7b4 <___svfprintf_internal_r+0x6a0>
 203d6fc:	18c03fcc 	andi	r3,r3,255
 203d700:	1806e71e 	bne	r3,zero,203f2a0 <___svfprintf_internal_r+0x218c>
 203d704:	94800414 	ori	r18,r18,16
 203d708:	9080080c 	andi	r2,r18,32
 203d70c:	1002d426 	beq	r2,zero,203e260 <___svfprintf_internal_r+0x114c>
 203d710:	d9402d17 	ldw	r5,180(sp)
 203d714:	d8c02917 	ldw	r3,164(sp)
 203d718:	d8002785 	stb	zero,158(sp)
 203d71c:	28800204 	addi	r2,r5,8
 203d720:	2d000017 	ldw	r20,0(r5)
 203d724:	2d800117 	ldw	r22,4(r5)
 203d728:	18041516 	blt	r3,zero,203e780 <___svfprintf_internal_r+0x166c>
 203d72c:	013fdfc4 	movi	r4,-129
 203d730:	a586b03a 	or	r3,r20,r22
 203d734:	d8802d15 	stw	r2,180(sp)
 203d738:	9124703a 	and	r18,r18,r4
 203d73c:	1802d51e 	bne	r3,zero,203e294 <___svfprintf_internal_r+0x1180>
 203d740:	d9402917 	ldw	r5,164(sp)
 203d744:	0039883a 	mov	fp,zero
 203d748:	2806be26 	beq	r5,zero,203f244 <___svfprintf_internal_r+0x2130>
 203d74c:	0029883a 	mov	r20,zero
 203d750:	002d883a 	mov	r22,zero
 203d754:	dc001e04 	addi	r16,sp,120
 203d758:	a006d0fa 	srli	r3,r20,3
 203d75c:	b008977a 	slli	r4,r22,29
 203d760:	b02cd0fa 	srli	r22,r22,3
 203d764:	a50001cc 	andi	r20,r20,7
 203d768:	a0800c04 	addi	r2,r20,48
 203d76c:	843fffc4 	addi	r16,r16,-1
 203d770:	20e8b03a 	or	r20,r4,r3
 203d774:	80800005 	stb	r2,0(r16)
 203d778:	a586b03a 	or	r3,r20,r22
 203d77c:	183ff61e 	bne	r3,zero,203d758 <__alt_mem_mem_0+0xfd01d758>
 203d780:	90c0004c 	andi	r3,r18,1
 203d784:	18013926 	beq	r3,zero,203dc6c <___svfprintf_internal_r+0xb58>
 203d788:	10803fcc 	andi	r2,r2,255
 203d78c:	1080201c 	xori	r2,r2,128
 203d790:	10bfe004 	addi	r2,r2,-128
 203d794:	00c00c04 	movi	r3,48
 203d798:	10c13426 	beq	r2,r3,203dc6c <___svfprintf_internal_r+0xb58>
 203d79c:	80ffffc5 	stb	r3,-1(r16)
 203d7a0:	d8c02817 	ldw	r3,160(sp)
 203d7a4:	80bfffc4 	addi	r2,r16,-1
 203d7a8:	1021883a 	mov	r16,r2
 203d7ac:	1887c83a 	sub	r3,r3,r2
 203d7b0:	d8c02e15 	stw	r3,184(sp)
 203d7b4:	d8802e17 	ldw	r2,184(sp)
 203d7b8:	d9002917 	ldw	r4,164(sp)
 203d7bc:	1100010e 	bge	r2,r4,203d7c4 <___svfprintf_internal_r+0x6b0>
 203d7c0:	2005883a 	mov	r2,r4
 203d7c4:	d8802a15 	stw	r2,168(sp)
 203d7c8:	d8003215 	stw	zero,200(sp)
 203d7cc:	e7003fcc 	andi	fp,fp,255
 203d7d0:	e700201c 	xori	fp,fp,128
 203d7d4:	e73fe004 	addi	fp,fp,-128
 203d7d8:	e0000326 	beq	fp,zero,203d7e8 <___svfprintf_internal_r+0x6d4>
 203d7dc:	d8c02a17 	ldw	r3,168(sp)
 203d7e0:	18c00044 	addi	r3,r3,1
 203d7e4:	d8c02a15 	stw	r3,168(sp)
 203d7e8:	90c0008c 	andi	r3,r18,2
 203d7ec:	d8c02b15 	stw	r3,172(sp)
 203d7f0:	18000326 	beq	r3,zero,203d800 <___svfprintf_internal_r+0x6ec>
 203d7f4:	d8c02a17 	ldw	r3,168(sp)
 203d7f8:	18c00084 	addi	r3,r3,2
 203d7fc:	d8c02a15 	stw	r3,168(sp)
 203d800:	90c0210c 	andi	r3,r18,132
 203d804:	d8c03015 	stw	r3,192(sp)
 203d808:	1801a11e 	bne	r3,zero,203de90 <___svfprintf_internal_r+0xd7c>
 203d80c:	d9003117 	ldw	r4,196(sp)
 203d810:	d8c02a17 	ldw	r3,168(sp)
 203d814:	20e9c83a 	sub	r20,r4,r3
 203d818:	05019d0e 	bge	zero,r20,203de90 <___svfprintf_internal_r+0xd7c>
 203d81c:	02400404 	movi	r9,16
 203d820:	d8c02017 	ldw	r3,128(sp)
 203d824:	d8801f17 	ldw	r2,124(sp)
 203d828:	4d051b0e 	bge	r9,r20,203ec98 <___svfprintf_internal_r+0x1b84>
 203d82c:	01408134 	movhi	r5,516
 203d830:	294ea804 	addi	r5,r5,15008
 203d834:	dc403c15 	stw	r17,240(sp)
 203d838:	d9403515 	stw	r5,212(sp)
 203d83c:	a023883a 	mov	r17,r20
 203d840:	482d883a 	mov	r22,r9
 203d844:	9029883a 	mov	r20,r18
 203d848:	070001c4 	movi	fp,7
 203d84c:	8025883a 	mov	r18,r16
 203d850:	dc002c17 	ldw	r16,176(sp)
 203d854:	00000306 	br	203d864 <___svfprintf_internal_r+0x750>
 203d858:	8c7ffc04 	addi	r17,r17,-16
 203d85c:	42000204 	addi	r8,r8,8
 203d860:	b440130e 	bge	r22,r17,203d8b0 <___svfprintf_internal_r+0x79c>
 203d864:	01008134 	movhi	r4,516
 203d868:	18c00404 	addi	r3,r3,16
 203d86c:	10800044 	addi	r2,r2,1
 203d870:	210ea804 	addi	r4,r4,15008
 203d874:	41000015 	stw	r4,0(r8)
 203d878:	45800115 	stw	r22,4(r8)
 203d87c:	d8c02015 	stw	r3,128(sp)
 203d880:	d8801f15 	stw	r2,124(sp)
 203d884:	e0bff40e 	bge	fp,r2,203d858 <__alt_mem_mem_0+0xfd01d858>
 203d888:	d9801e04 	addi	r6,sp,120
 203d88c:	800b883a 	mov	r5,r16
 203d890:	9809883a 	mov	r4,r19
 203d894:	203f5840 	call	203f584 <__ssprint_r>
 203d898:	103f031e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203d89c:	8c7ffc04 	addi	r17,r17,-16
 203d8a0:	d8c02017 	ldw	r3,128(sp)
 203d8a4:	d8801f17 	ldw	r2,124(sp)
 203d8a8:	da000404 	addi	r8,sp,16
 203d8ac:	b47fed16 	blt	r22,r17,203d864 <__alt_mem_mem_0+0xfd01d864>
 203d8b0:	9021883a 	mov	r16,r18
 203d8b4:	a025883a 	mov	r18,r20
 203d8b8:	8829883a 	mov	r20,r17
 203d8bc:	dc403c17 	ldw	r17,240(sp)
 203d8c0:	d9403517 	ldw	r5,212(sp)
 203d8c4:	a0c7883a 	add	r3,r20,r3
 203d8c8:	10800044 	addi	r2,r2,1
 203d8cc:	41400015 	stw	r5,0(r8)
 203d8d0:	45000115 	stw	r20,4(r8)
 203d8d4:	d8c02015 	stw	r3,128(sp)
 203d8d8:	d8801f15 	stw	r2,124(sp)
 203d8dc:	010001c4 	movi	r4,7
 203d8e0:	20829f16 	blt	r4,r2,203e360 <___svfprintf_internal_r+0x124c>
 203d8e4:	df002787 	ldb	fp,158(sp)
 203d8e8:	42000204 	addi	r8,r8,8
 203d8ec:	e0000c26 	beq	fp,zero,203d920 <___svfprintf_internal_r+0x80c>
 203d8f0:	d8801f17 	ldw	r2,124(sp)
 203d8f4:	d9002784 	addi	r4,sp,158
 203d8f8:	18c00044 	addi	r3,r3,1
 203d8fc:	10800044 	addi	r2,r2,1
 203d900:	41000015 	stw	r4,0(r8)
 203d904:	01000044 	movi	r4,1
 203d908:	41000115 	stw	r4,4(r8)
 203d90c:	d8c02015 	stw	r3,128(sp)
 203d910:	d8801f15 	stw	r2,124(sp)
 203d914:	010001c4 	movi	r4,7
 203d918:	20823816 	blt	r4,r2,203e1fc <___svfprintf_internal_r+0x10e8>
 203d91c:	42000204 	addi	r8,r8,8
 203d920:	d8802b17 	ldw	r2,172(sp)
 203d924:	10000c26 	beq	r2,zero,203d958 <___svfprintf_internal_r+0x844>
 203d928:	d8801f17 	ldw	r2,124(sp)
 203d92c:	d9002704 	addi	r4,sp,156
 203d930:	18c00084 	addi	r3,r3,2
 203d934:	10800044 	addi	r2,r2,1
 203d938:	41000015 	stw	r4,0(r8)
 203d93c:	01000084 	movi	r4,2
 203d940:	41000115 	stw	r4,4(r8)
 203d944:	d8c02015 	stw	r3,128(sp)
 203d948:	d8801f15 	stw	r2,124(sp)
 203d94c:	010001c4 	movi	r4,7
 203d950:	20823216 	blt	r4,r2,203e21c <___svfprintf_internal_r+0x1108>
 203d954:	42000204 	addi	r8,r8,8
 203d958:	d9003017 	ldw	r4,192(sp)
 203d95c:	00802004 	movi	r2,128
 203d960:	20819726 	beq	r4,r2,203dfc0 <___svfprintf_internal_r+0xeac>
 203d964:	d9402917 	ldw	r5,164(sp)
 203d968:	d8802e17 	ldw	r2,184(sp)
 203d96c:	28adc83a 	sub	r22,r5,r2
 203d970:	05802f0e 	bge	zero,r22,203da30 <___svfprintf_internal_r+0x91c>
 203d974:	07000404 	movi	fp,16
 203d978:	d8801f17 	ldw	r2,124(sp)
 203d97c:	e583c00e 	bge	fp,r22,203e880 <___svfprintf_internal_r+0x176c>
 203d980:	01408134 	movhi	r5,516
 203d984:	294ea404 	addi	r5,r5,14992
 203d988:	dc402915 	stw	r17,164(sp)
 203d98c:	d9402b15 	stw	r5,172(sp)
 203d990:	b023883a 	mov	r17,r22
 203d994:	050001c4 	movi	r20,7
 203d998:	902d883a 	mov	r22,r18
 203d99c:	8025883a 	mov	r18,r16
 203d9a0:	dc002c17 	ldw	r16,176(sp)
 203d9a4:	00000306 	br	203d9b4 <___svfprintf_internal_r+0x8a0>
 203d9a8:	8c7ffc04 	addi	r17,r17,-16
 203d9ac:	42000204 	addi	r8,r8,8
 203d9b0:	e440110e 	bge	fp,r17,203d9f8 <___svfprintf_internal_r+0x8e4>
 203d9b4:	18c00404 	addi	r3,r3,16
 203d9b8:	10800044 	addi	r2,r2,1
 203d9bc:	45400015 	stw	r21,0(r8)
 203d9c0:	47000115 	stw	fp,4(r8)
 203d9c4:	d8c02015 	stw	r3,128(sp)
 203d9c8:	d8801f15 	stw	r2,124(sp)
 203d9cc:	a0bff60e 	bge	r20,r2,203d9a8 <__alt_mem_mem_0+0xfd01d9a8>
 203d9d0:	d9801e04 	addi	r6,sp,120
 203d9d4:	800b883a 	mov	r5,r16
 203d9d8:	9809883a 	mov	r4,r19
 203d9dc:	203f5840 	call	203f584 <__ssprint_r>
 203d9e0:	103eb11e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203d9e4:	8c7ffc04 	addi	r17,r17,-16
 203d9e8:	d8c02017 	ldw	r3,128(sp)
 203d9ec:	d8801f17 	ldw	r2,124(sp)
 203d9f0:	da000404 	addi	r8,sp,16
 203d9f4:	e47fef16 	blt	fp,r17,203d9b4 <__alt_mem_mem_0+0xfd01d9b4>
 203d9f8:	9021883a 	mov	r16,r18
 203d9fc:	b025883a 	mov	r18,r22
 203da00:	882d883a 	mov	r22,r17
 203da04:	dc402917 	ldw	r17,164(sp)
 203da08:	d9002b17 	ldw	r4,172(sp)
 203da0c:	1d87883a 	add	r3,r3,r22
 203da10:	10800044 	addi	r2,r2,1
 203da14:	41000015 	stw	r4,0(r8)
 203da18:	45800115 	stw	r22,4(r8)
 203da1c:	d8c02015 	stw	r3,128(sp)
 203da20:	d8801f15 	stw	r2,124(sp)
 203da24:	010001c4 	movi	r4,7
 203da28:	2081ec16 	blt	r4,r2,203e1dc <___svfprintf_internal_r+0x10c8>
 203da2c:	42000204 	addi	r8,r8,8
 203da30:	9080400c 	andi	r2,r18,256
 203da34:	1001181e 	bne	r2,zero,203de98 <___svfprintf_internal_r+0xd84>
 203da38:	d9402e17 	ldw	r5,184(sp)
 203da3c:	d8801f17 	ldw	r2,124(sp)
 203da40:	44000015 	stw	r16,0(r8)
 203da44:	1947883a 	add	r3,r3,r5
 203da48:	10800044 	addi	r2,r2,1
 203da4c:	41400115 	stw	r5,4(r8)
 203da50:	d8c02015 	stw	r3,128(sp)
 203da54:	d8801f15 	stw	r2,124(sp)
 203da58:	010001c4 	movi	r4,7
 203da5c:	2081d116 	blt	r4,r2,203e1a4 <___svfprintf_internal_r+0x1090>
 203da60:	42000204 	addi	r8,r8,8
 203da64:	9480010c 	andi	r18,r18,4
 203da68:	90003226 	beq	r18,zero,203db34 <___svfprintf_internal_r+0xa20>
 203da6c:	d9403117 	ldw	r5,196(sp)
 203da70:	d8802a17 	ldw	r2,168(sp)
 203da74:	28a1c83a 	sub	r16,r5,r2
 203da78:	04002e0e 	bge	zero,r16,203db34 <___svfprintf_internal_r+0xa20>
 203da7c:	04400404 	movi	r17,16
 203da80:	d8801f17 	ldw	r2,124(sp)
 203da84:	8c04b90e 	bge	r17,r16,203ed6c <___svfprintf_internal_r+0x1c58>
 203da88:	01408134 	movhi	r5,516
 203da8c:	294ea804 	addi	r5,r5,15008
 203da90:	d9403515 	stw	r5,212(sp)
 203da94:	048001c4 	movi	r18,7
 203da98:	dd002c17 	ldw	r20,176(sp)
 203da9c:	00000306 	br	203daac <___svfprintf_internal_r+0x998>
 203daa0:	843ffc04 	addi	r16,r16,-16
 203daa4:	42000204 	addi	r8,r8,8
 203daa8:	8c00130e 	bge	r17,r16,203daf8 <___svfprintf_internal_r+0x9e4>
 203daac:	01008134 	movhi	r4,516
 203dab0:	18c00404 	addi	r3,r3,16
 203dab4:	10800044 	addi	r2,r2,1
 203dab8:	210ea804 	addi	r4,r4,15008
 203dabc:	41000015 	stw	r4,0(r8)
 203dac0:	44400115 	stw	r17,4(r8)
 203dac4:	d8c02015 	stw	r3,128(sp)
 203dac8:	d8801f15 	stw	r2,124(sp)
 203dacc:	90bff40e 	bge	r18,r2,203daa0 <__alt_mem_mem_0+0xfd01daa0>
 203dad0:	d9801e04 	addi	r6,sp,120
 203dad4:	a00b883a 	mov	r5,r20
 203dad8:	9809883a 	mov	r4,r19
 203dadc:	203f5840 	call	203f584 <__ssprint_r>
 203dae0:	103e711e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203dae4:	843ffc04 	addi	r16,r16,-16
 203dae8:	d8c02017 	ldw	r3,128(sp)
 203daec:	d8801f17 	ldw	r2,124(sp)
 203daf0:	da000404 	addi	r8,sp,16
 203daf4:	8c3fed16 	blt	r17,r16,203daac <__alt_mem_mem_0+0xfd01daac>
 203daf8:	d9403517 	ldw	r5,212(sp)
 203dafc:	1c07883a 	add	r3,r3,r16
 203db00:	10800044 	addi	r2,r2,1
 203db04:	41400015 	stw	r5,0(r8)
 203db08:	44000115 	stw	r16,4(r8)
 203db0c:	d8c02015 	stw	r3,128(sp)
 203db10:	d8801f15 	stw	r2,124(sp)
 203db14:	010001c4 	movi	r4,7
 203db18:	2080060e 	bge	r4,r2,203db34 <___svfprintf_internal_r+0xa20>
 203db1c:	d9402c17 	ldw	r5,176(sp)
 203db20:	d9801e04 	addi	r6,sp,120
 203db24:	9809883a 	mov	r4,r19
 203db28:	203f5840 	call	203f584 <__ssprint_r>
 203db2c:	103e5e1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203db30:	d8c02017 	ldw	r3,128(sp)
 203db34:	d8803117 	ldw	r2,196(sp)
 203db38:	d9002a17 	ldw	r4,168(sp)
 203db3c:	1100010e 	bge	r2,r4,203db44 <___svfprintf_internal_r+0xa30>
 203db40:	2005883a 	mov	r2,r4
 203db44:	d9402f17 	ldw	r5,188(sp)
 203db48:	288b883a 	add	r5,r5,r2
 203db4c:	d9402f15 	stw	r5,188(sp)
 203db50:	18019c1e 	bne	r3,zero,203e1c4 <___svfprintf_internal_r+0x10b0>
 203db54:	b8800007 	ldb	r2,0(r23)
 203db58:	d8001f15 	stw	zero,124(sp)
 203db5c:	da000404 	addi	r8,sp,16
 203db60:	103d991e 	bne	r2,zero,203d1c8 <__alt_mem_mem_0+0xfd01d1c8>
 203db64:	b821883a 	mov	r16,r23
 203db68:	003daf06 	br	203d228 <__alt_mem_mem_0+0xfd01d228>
 203db6c:	18c03fcc 	andi	r3,r3,255
 203db70:	1805c71e 	bne	r3,zero,203f290 <___svfprintf_internal_r+0x217c>
 203db74:	94800414 	ori	r18,r18,16
 203db78:	9080080c 	andi	r2,r18,32
 203db7c:	10020126 	beq	r2,zero,203e384 <___svfprintf_internal_r+0x1270>
 203db80:	d8802d17 	ldw	r2,180(sp)
 203db84:	d9002917 	ldw	r4,164(sp)
 203db88:	d8002785 	stb	zero,158(sp)
 203db8c:	10c00204 	addi	r3,r2,8
 203db90:	15000017 	ldw	r20,0(r2)
 203db94:	15800117 	ldw	r22,4(r2)
 203db98:	20038e16 	blt	r4,zero,203e9d4 <___svfprintf_internal_r+0x18c0>
 203db9c:	013fdfc4 	movi	r4,-129
 203dba0:	a584b03a 	or	r2,r20,r22
 203dba4:	d8c02d15 	stw	r3,180(sp)
 203dba8:	9124703a 	and	r18,r18,r4
 203dbac:	0039883a 	mov	fp,zero
 203dbb0:	103eb61e 	bne	r2,zero,203d68c <__alt_mem_mem_0+0xfd01d68c>
 203dbb4:	d8802917 	ldw	r2,164(sp)
 203dbb8:	1002c81e 	bne	r2,zero,203e6dc <___svfprintf_internal_r+0x15c8>
 203dbbc:	d8002915 	stw	zero,164(sp)
 203dbc0:	d8002e15 	stw	zero,184(sp)
 203dbc4:	dc001e04 	addi	r16,sp,120
 203dbc8:	003efa06 	br	203d7b4 <__alt_mem_mem_0+0xfd01d7b4>
 203dbcc:	18c03fcc 	andi	r3,r3,255
 203dbd0:	1805ad1e 	bne	r3,zero,203f288 <___svfprintf_internal_r+0x2174>
 203dbd4:	01408134 	movhi	r5,516
 203dbd8:	2943c904 	addi	r5,r5,3876
 203dbdc:	d9403a15 	stw	r5,232(sp)
 203dbe0:	9080080c 	andi	r2,r18,32
 203dbe4:	10006126 	beq	r2,zero,203dd6c <___svfprintf_internal_r+0xc58>
 203dbe8:	d8802d17 	ldw	r2,180(sp)
 203dbec:	15000017 	ldw	r20,0(r2)
 203dbf0:	15800117 	ldw	r22,4(r2)
 203dbf4:	10800204 	addi	r2,r2,8
 203dbf8:	d8802d15 	stw	r2,180(sp)
 203dbfc:	9080004c 	andi	r2,r18,1
 203dc00:	10018e26 	beq	r2,zero,203e23c <___svfprintf_internal_r+0x1128>
 203dc04:	a584b03a 	or	r2,r20,r22
 203dc08:	10030926 	beq	r2,zero,203e830 <___svfprintf_internal_r+0x171c>
 203dc0c:	d8c02917 	ldw	r3,164(sp)
 203dc10:	00800c04 	movi	r2,48
 203dc14:	d8802705 	stb	r2,156(sp)
 203dc18:	dc402745 	stb	r17,157(sp)
 203dc1c:	d8002785 	stb	zero,158(sp)
 203dc20:	90800094 	ori	r2,r18,2
 203dc24:	18048716 	blt	r3,zero,203ee44 <___svfprintf_internal_r+0x1d30>
 203dc28:	00bfdfc4 	movi	r2,-129
 203dc2c:	90a4703a 	and	r18,r18,r2
 203dc30:	94800094 	ori	r18,r18,2
 203dc34:	0039883a 	mov	fp,zero
 203dc38:	d9003a17 	ldw	r4,232(sp)
 203dc3c:	dc001e04 	addi	r16,sp,120
 203dc40:	a08003cc 	andi	r2,r20,15
 203dc44:	b006973a 	slli	r3,r22,28
 203dc48:	2085883a 	add	r2,r4,r2
 203dc4c:	a028d13a 	srli	r20,r20,4
 203dc50:	10800003 	ldbu	r2,0(r2)
 203dc54:	b02cd13a 	srli	r22,r22,4
 203dc58:	843fffc4 	addi	r16,r16,-1
 203dc5c:	1d28b03a 	or	r20,r3,r20
 203dc60:	80800005 	stb	r2,0(r16)
 203dc64:	a584b03a 	or	r2,r20,r22
 203dc68:	103ff51e 	bne	r2,zero,203dc40 <__alt_mem_mem_0+0xfd01dc40>
 203dc6c:	d8c02817 	ldw	r3,160(sp)
 203dc70:	1c07c83a 	sub	r3,r3,r16
 203dc74:	d8c02e15 	stw	r3,184(sp)
 203dc78:	003ece06 	br	203d7b4 <__alt_mem_mem_0+0xfd01d7b4>
 203dc7c:	d8c02d17 	ldw	r3,180(sp)
 203dc80:	d9002d17 	ldw	r4,180(sp)
 203dc84:	d8002785 	stb	zero,158(sp)
 203dc88:	18800017 	ldw	r2,0(r3)
 203dc8c:	21000104 	addi	r4,r4,4
 203dc90:	00c00044 	movi	r3,1
 203dc94:	d8c02a15 	stw	r3,168(sp)
 203dc98:	d8801405 	stb	r2,80(sp)
 203dc9c:	d9002d15 	stw	r4,180(sp)
 203dca0:	d8c02e15 	stw	r3,184(sp)
 203dca4:	d8002915 	stw	zero,164(sp)
 203dca8:	d8003215 	stw	zero,200(sp)
 203dcac:	dc001404 	addi	r16,sp,80
 203dcb0:	0039883a 	mov	fp,zero
 203dcb4:	003ecc06 	br	203d7e8 <__alt_mem_mem_0+0xfd01d7e8>
 203dcb8:	18c03fcc 	andi	r3,r3,255
 203dcbc:	183e9226 	beq	r3,zero,203d708 <__alt_mem_mem_0+0xfd01d708>
 203dcc0:	d9c02785 	stb	r7,158(sp)
 203dcc4:	003e9006 	br	203d708 <__alt_mem_mem_0+0xfd01d708>
 203dcc8:	00c00044 	movi	r3,1
 203dccc:	01c00ac4 	movi	r7,43
 203dcd0:	bc400007 	ldb	r17,0(r23)
 203dcd4:	003d6306 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203dcd8:	94800814 	ori	r18,r18,32
 203dcdc:	bc400007 	ldb	r17,0(r23)
 203dce0:	003d6006 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203dce4:	d8c02d17 	ldw	r3,180(sp)
 203dce8:	d8002785 	stb	zero,158(sp)
 203dcec:	1c000017 	ldw	r16,0(r3)
 203dcf0:	1d000104 	addi	r20,r3,4
 203dcf4:	80040f26 	beq	r16,zero,203ed34 <___svfprintf_internal_r+0x1c20>
 203dcf8:	d9002917 	ldw	r4,164(sp)
 203dcfc:	2003dc16 	blt	r4,zero,203ec70 <___svfprintf_internal_r+0x1b5c>
 203dd00:	200d883a 	mov	r6,r4
 203dd04:	000b883a 	mov	r5,zero
 203dd08:	8009883a 	mov	r4,r16
 203dd0c:	da003e15 	stw	r8,248(sp)
 203dd10:	2005f400 	call	2005f40 <memchr>
 203dd14:	da003e17 	ldw	r8,248(sp)
 203dd18:	10045826 	beq	r2,zero,203ee7c <___svfprintf_internal_r+0x1d68>
 203dd1c:	1405c83a 	sub	r2,r2,r16
 203dd20:	d8802e15 	stw	r2,184(sp)
 203dd24:	1003d816 	blt	r2,zero,203ec88 <___svfprintf_internal_r+0x1b74>
 203dd28:	df002783 	ldbu	fp,158(sp)
 203dd2c:	d8802a15 	stw	r2,168(sp)
 203dd30:	dd002d15 	stw	r20,180(sp)
 203dd34:	d8002915 	stw	zero,164(sp)
 203dd38:	d8003215 	stw	zero,200(sp)
 203dd3c:	003ea306 	br	203d7cc <__alt_mem_mem_0+0xfd01d7cc>
 203dd40:	18c03fcc 	andi	r3,r3,255
 203dd44:	183f8c26 	beq	r3,zero,203db78 <__alt_mem_mem_0+0xfd01db78>
 203dd48:	d9c02785 	stb	r7,158(sp)
 203dd4c:	003f8a06 	br	203db78 <__alt_mem_mem_0+0xfd01db78>
 203dd50:	18c03fcc 	andi	r3,r3,255
 203dd54:	1805631e 	bne	r3,zero,203f2e4 <___svfprintf_internal_r+0x21d0>
 203dd58:	01408134 	movhi	r5,516
 203dd5c:	2943ce04 	addi	r5,r5,3896
 203dd60:	d9403a15 	stw	r5,232(sp)
 203dd64:	9080080c 	andi	r2,r18,32
 203dd68:	103f9f1e 	bne	r2,zero,203dbe8 <__alt_mem_mem_0+0xfd01dbe8>
 203dd6c:	9080040c 	andi	r2,r18,16
 203dd70:	10029c26 	beq	r2,zero,203e7e4 <___svfprintf_internal_r+0x16d0>
 203dd74:	d8c02d17 	ldw	r3,180(sp)
 203dd78:	002d883a 	mov	r22,zero
 203dd7c:	1d000017 	ldw	r20,0(r3)
 203dd80:	18c00104 	addi	r3,r3,4
 203dd84:	d8c02d15 	stw	r3,180(sp)
 203dd88:	003f9c06 	br	203dbfc <__alt_mem_mem_0+0xfd01dbfc>
 203dd8c:	94800054 	ori	r18,r18,1
 203dd90:	bc400007 	ldb	r17,0(r23)
 203dd94:	003d3306 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203dd98:	38803fcc 	andi	r2,r7,255
 203dd9c:	1080201c 	xori	r2,r2,128
 203dda0:	10bfe004 	addi	r2,r2,-128
 203dda4:	1002971e 	bne	r2,zero,203e804 <___svfprintf_internal_r+0x16f0>
 203dda8:	00c00044 	movi	r3,1
 203ddac:	01c00804 	movi	r7,32
 203ddb0:	bc400007 	ldb	r17,0(r23)
 203ddb4:	003d2b06 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203ddb8:	18c03fcc 	andi	r3,r3,255
 203ddbc:	183e2326 	beq	r3,zero,203d64c <__alt_mem_mem_0+0xfd01d64c>
 203ddc0:	d9c02785 	stb	r7,158(sp)
 203ddc4:	003e2106 	br	203d64c <__alt_mem_mem_0+0xfd01d64c>
 203ddc8:	bc400007 	ldb	r17,0(r23)
 203ddcc:	8a430426 	beq	r17,r9,203e9e0 <___svfprintf_internal_r+0x18cc>
 203ddd0:	94800414 	ori	r18,r18,16
 203ddd4:	003d2306 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203ddd8:	18c03fcc 	andi	r3,r3,255
 203dddc:	18053f1e 	bne	r3,zero,203f2dc <___svfprintf_internal_r+0x21c8>
 203dde0:	9080080c 	andi	r2,r18,32
 203dde4:	10028926 	beq	r2,zero,203e80c <___svfprintf_internal_r+0x16f8>
 203dde8:	d9402d17 	ldw	r5,180(sp)
 203ddec:	d9002f17 	ldw	r4,188(sp)
 203ddf0:	28800017 	ldw	r2,0(r5)
 203ddf4:	2007d7fa 	srai	r3,r4,31
 203ddf8:	29400104 	addi	r5,r5,4
 203ddfc:	d9402d15 	stw	r5,180(sp)
 203de00:	11000015 	stw	r4,0(r2)
 203de04:	10c00115 	stw	r3,4(r2)
 203de08:	003ced06 	br	203d1c0 <__alt_mem_mem_0+0xfd01d1c0>
 203de0c:	94801014 	ori	r18,r18,64
 203de10:	bc400007 	ldb	r17,0(r23)
 203de14:	003d1306 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203de18:	01008134 	movhi	r4,516
 203de1c:	2103ce04 	addi	r4,r4,3896
 203de20:	0039883a 	mov	fp,zero
 203de24:	d9003a15 	stw	r4,232(sp)
 203de28:	04401e04 	movi	r17,120
 203de2c:	003f8206 	br	203dc38 <__alt_mem_mem_0+0xfd01dc38>
 203de30:	18c03fcc 	andi	r3,r3,255
 203de34:	1805221e 	bne	r3,zero,203f2c0 <___svfprintf_internal_r+0x21ac>
 203de38:	883d9526 	beq	r17,zero,203d490 <__alt_mem_mem_0+0xfd01d490>
 203de3c:	00c00044 	movi	r3,1
 203de40:	d8c02a15 	stw	r3,168(sp)
 203de44:	dc401405 	stb	r17,80(sp)
 203de48:	d8002785 	stb	zero,158(sp)
 203de4c:	003f9406 	br	203dca0 <__alt_mem_mem_0+0xfd01dca0>
 203de50:	01008134 	movhi	r4,516
 203de54:	2103ce04 	addi	r4,r4,3896
 203de58:	d9003a15 	stw	r4,232(sp)
 203de5c:	d8c02d15 	stw	r3,180(sp)
 203de60:	1025883a 	mov	r18,r2
 203de64:	04401e04 	movi	r17,120
 203de68:	a584b03a 	or	r2,r20,r22
 203de6c:	1000fa1e 	bne	r2,zero,203e258 <___svfprintf_internal_r+0x1144>
 203de70:	0039883a 	mov	fp,zero
 203de74:	00800084 	movi	r2,2
 203de78:	10803fcc 	andi	r2,r2,255
 203de7c:	00c00044 	movi	r3,1
 203de80:	10c21626 	beq	r2,r3,203e6dc <___svfprintf_internal_r+0x15c8>
 203de84:	00c00084 	movi	r3,2
 203de88:	10fe301e 	bne	r2,r3,203d74c <__alt_mem_mem_0+0xfd01d74c>
 203de8c:	003d7606 	br	203d468 <__alt_mem_mem_0+0xfd01d468>
 203de90:	d8c02017 	ldw	r3,128(sp)
 203de94:	003e9506 	br	203d8ec <__alt_mem_mem_0+0xfd01d8ec>
 203de98:	00801944 	movi	r2,101
 203de9c:	14407c0e 	bge	r2,r17,203e090 <___svfprintf_internal_r+0xf7c>
 203dea0:	d9003617 	ldw	r4,216(sp)
 203dea4:	d9403717 	ldw	r5,220(sp)
 203dea8:	000d883a 	mov	r6,zero
 203deac:	000f883a 	mov	r7,zero
 203deb0:	d8c03d15 	stw	r3,244(sp)
 203deb4:	da003e15 	stw	r8,248(sp)
 203deb8:	200bef80 	call	200bef8 <__eqdf2>
 203debc:	d8c03d17 	ldw	r3,244(sp)
 203dec0:	da003e17 	ldw	r8,248(sp)
 203dec4:	1000f51e 	bne	r2,zero,203e29c <___svfprintf_internal_r+0x1188>
 203dec8:	d8801f17 	ldw	r2,124(sp)
 203decc:	01008134 	movhi	r4,516
 203ded0:	2103d504 	addi	r4,r4,3924
 203ded4:	18c00044 	addi	r3,r3,1
 203ded8:	10800044 	addi	r2,r2,1
 203dedc:	41000015 	stw	r4,0(r8)
 203dee0:	01000044 	movi	r4,1
 203dee4:	41000115 	stw	r4,4(r8)
 203dee8:	d8c02015 	stw	r3,128(sp)
 203deec:	d8801f15 	stw	r2,124(sp)
 203def0:	010001c4 	movi	r4,7
 203def4:	20826616 	blt	r4,r2,203e890 <___svfprintf_internal_r+0x177c>
 203def8:	42000204 	addi	r8,r8,8
 203defc:	d8802617 	ldw	r2,152(sp)
 203df00:	d9403317 	ldw	r5,204(sp)
 203df04:	11400216 	blt	r2,r5,203df10 <___svfprintf_internal_r+0xdfc>
 203df08:	9080004c 	andi	r2,r18,1
 203df0c:	103ed526 	beq	r2,zero,203da64 <__alt_mem_mem_0+0xfd01da64>
 203df10:	d8803817 	ldw	r2,224(sp)
 203df14:	d9003417 	ldw	r4,208(sp)
 203df18:	d9403817 	ldw	r5,224(sp)
 203df1c:	1887883a 	add	r3,r3,r2
 203df20:	d8801f17 	ldw	r2,124(sp)
 203df24:	41000015 	stw	r4,0(r8)
 203df28:	41400115 	stw	r5,4(r8)
 203df2c:	10800044 	addi	r2,r2,1
 203df30:	d8c02015 	stw	r3,128(sp)
 203df34:	d8801f15 	stw	r2,124(sp)
 203df38:	010001c4 	movi	r4,7
 203df3c:	2082af16 	blt	r4,r2,203e9fc <___svfprintf_internal_r+0x18e8>
 203df40:	42000204 	addi	r8,r8,8
 203df44:	d8803317 	ldw	r2,204(sp)
 203df48:	143fffc4 	addi	r16,r2,-1
 203df4c:	043ec50e 	bge	zero,r16,203da64 <__alt_mem_mem_0+0xfd01da64>
 203df50:	04400404 	movi	r17,16
 203df54:	d8801f17 	ldw	r2,124(sp)
 203df58:	8c00860e 	bge	r17,r16,203e174 <___svfprintf_internal_r+0x1060>
 203df5c:	01408134 	movhi	r5,516
 203df60:	294ea404 	addi	r5,r5,14992
 203df64:	d9402b15 	stw	r5,172(sp)
 203df68:	058001c4 	movi	r22,7
 203df6c:	dd002c17 	ldw	r20,176(sp)
 203df70:	00000306 	br	203df80 <___svfprintf_internal_r+0xe6c>
 203df74:	42000204 	addi	r8,r8,8
 203df78:	843ffc04 	addi	r16,r16,-16
 203df7c:	8c00800e 	bge	r17,r16,203e180 <___svfprintf_internal_r+0x106c>
 203df80:	18c00404 	addi	r3,r3,16
 203df84:	10800044 	addi	r2,r2,1
 203df88:	45400015 	stw	r21,0(r8)
 203df8c:	44400115 	stw	r17,4(r8)
 203df90:	d8c02015 	stw	r3,128(sp)
 203df94:	d8801f15 	stw	r2,124(sp)
 203df98:	b0bff60e 	bge	r22,r2,203df74 <__alt_mem_mem_0+0xfd01df74>
 203df9c:	d9801e04 	addi	r6,sp,120
 203dfa0:	a00b883a 	mov	r5,r20
 203dfa4:	9809883a 	mov	r4,r19
 203dfa8:	203f5840 	call	203f584 <__ssprint_r>
 203dfac:	103d3e1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203dfb0:	d8c02017 	ldw	r3,128(sp)
 203dfb4:	d8801f17 	ldw	r2,124(sp)
 203dfb8:	da000404 	addi	r8,sp,16
 203dfbc:	003fee06 	br	203df78 <__alt_mem_mem_0+0xfd01df78>
 203dfc0:	d9403117 	ldw	r5,196(sp)
 203dfc4:	d8802a17 	ldw	r2,168(sp)
 203dfc8:	28adc83a 	sub	r22,r5,r2
 203dfcc:	05be650e 	bge	zero,r22,203d964 <__alt_mem_mem_0+0xfd01d964>
 203dfd0:	07000404 	movi	fp,16
 203dfd4:	d8801f17 	ldw	r2,124(sp)
 203dfd8:	e583a20e 	bge	fp,r22,203ee64 <___svfprintf_internal_r+0x1d50>
 203dfdc:	01408134 	movhi	r5,516
 203dfe0:	294ea404 	addi	r5,r5,14992
 203dfe4:	dc403015 	stw	r17,192(sp)
 203dfe8:	d9402b15 	stw	r5,172(sp)
 203dfec:	b023883a 	mov	r17,r22
 203dff0:	050001c4 	movi	r20,7
 203dff4:	902d883a 	mov	r22,r18
 203dff8:	8025883a 	mov	r18,r16
 203dffc:	dc002c17 	ldw	r16,176(sp)
 203e000:	00000306 	br	203e010 <___svfprintf_internal_r+0xefc>
 203e004:	8c7ffc04 	addi	r17,r17,-16
 203e008:	42000204 	addi	r8,r8,8
 203e00c:	e440110e 	bge	fp,r17,203e054 <___svfprintf_internal_r+0xf40>
 203e010:	18c00404 	addi	r3,r3,16
 203e014:	10800044 	addi	r2,r2,1
 203e018:	45400015 	stw	r21,0(r8)
 203e01c:	47000115 	stw	fp,4(r8)
 203e020:	d8c02015 	stw	r3,128(sp)
 203e024:	d8801f15 	stw	r2,124(sp)
 203e028:	a0bff60e 	bge	r20,r2,203e004 <__alt_mem_mem_0+0xfd01e004>
 203e02c:	d9801e04 	addi	r6,sp,120
 203e030:	800b883a 	mov	r5,r16
 203e034:	9809883a 	mov	r4,r19
 203e038:	203f5840 	call	203f584 <__ssprint_r>
 203e03c:	103d1a1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e040:	8c7ffc04 	addi	r17,r17,-16
 203e044:	d8c02017 	ldw	r3,128(sp)
 203e048:	d8801f17 	ldw	r2,124(sp)
 203e04c:	da000404 	addi	r8,sp,16
 203e050:	e47fef16 	blt	fp,r17,203e010 <__alt_mem_mem_0+0xfd01e010>
 203e054:	9021883a 	mov	r16,r18
 203e058:	b025883a 	mov	r18,r22
 203e05c:	882d883a 	mov	r22,r17
 203e060:	dc403017 	ldw	r17,192(sp)
 203e064:	d9002b17 	ldw	r4,172(sp)
 203e068:	1d87883a 	add	r3,r3,r22
 203e06c:	10800044 	addi	r2,r2,1
 203e070:	41000015 	stw	r4,0(r8)
 203e074:	45800115 	stw	r22,4(r8)
 203e078:	d8c02015 	stw	r3,128(sp)
 203e07c:	d8801f15 	stw	r2,124(sp)
 203e080:	010001c4 	movi	r4,7
 203e084:	20819a16 	blt	r4,r2,203e6f0 <___svfprintf_internal_r+0x15dc>
 203e088:	42000204 	addi	r8,r8,8
 203e08c:	003e3506 	br	203d964 <__alt_mem_mem_0+0xfd01d964>
 203e090:	d9403317 	ldw	r5,204(sp)
 203e094:	00800044 	movi	r2,1
 203e098:	18c00044 	addi	r3,r3,1
 203e09c:	1141710e 	bge	r2,r5,203e664 <___svfprintf_internal_r+0x1550>
 203e0a0:	dc401f17 	ldw	r17,124(sp)
 203e0a4:	00800044 	movi	r2,1
 203e0a8:	40800115 	stw	r2,4(r8)
 203e0ac:	8c400044 	addi	r17,r17,1
 203e0b0:	44000015 	stw	r16,0(r8)
 203e0b4:	d8c02015 	stw	r3,128(sp)
 203e0b8:	dc401f15 	stw	r17,124(sp)
 203e0bc:	008001c4 	movi	r2,7
 203e0c0:	14417416 	blt	r2,r17,203e694 <___svfprintf_internal_r+0x1580>
 203e0c4:	42000204 	addi	r8,r8,8
 203e0c8:	d8803817 	ldw	r2,224(sp)
 203e0cc:	d9003417 	ldw	r4,208(sp)
 203e0d0:	8c400044 	addi	r17,r17,1
 203e0d4:	10c7883a 	add	r3,r2,r3
 203e0d8:	40800115 	stw	r2,4(r8)
 203e0dc:	41000015 	stw	r4,0(r8)
 203e0e0:	d8c02015 	stw	r3,128(sp)
 203e0e4:	dc401f15 	stw	r17,124(sp)
 203e0e8:	008001c4 	movi	r2,7
 203e0ec:	14417216 	blt	r2,r17,203e6b8 <___svfprintf_internal_r+0x15a4>
 203e0f0:	45800204 	addi	r22,r8,8
 203e0f4:	d9003617 	ldw	r4,216(sp)
 203e0f8:	d9403717 	ldw	r5,220(sp)
 203e0fc:	000d883a 	mov	r6,zero
 203e100:	000f883a 	mov	r7,zero
 203e104:	d8c03d15 	stw	r3,244(sp)
 203e108:	200bef80 	call	200bef8 <__eqdf2>
 203e10c:	d8c03d17 	ldw	r3,244(sp)
 203e110:	1000b326 	beq	r2,zero,203e3e0 <___svfprintf_internal_r+0x12cc>
 203e114:	d9403317 	ldw	r5,204(sp)
 203e118:	84000044 	addi	r16,r16,1
 203e11c:	8c400044 	addi	r17,r17,1
 203e120:	28bfffc4 	addi	r2,r5,-1
 203e124:	1887883a 	add	r3,r3,r2
 203e128:	b0800115 	stw	r2,4(r22)
 203e12c:	b4000015 	stw	r16,0(r22)
 203e130:	d8c02015 	stw	r3,128(sp)
 203e134:	dc401f15 	stw	r17,124(sp)
 203e138:	008001c4 	movi	r2,7
 203e13c:	1440d216 	blt	r2,r17,203e488 <___svfprintf_internal_r+0x1374>
 203e140:	b5800204 	addi	r22,r22,8
 203e144:	d9003b17 	ldw	r4,236(sp)
 203e148:	df0022c4 	addi	fp,sp,139
 203e14c:	8c400044 	addi	r17,r17,1
 203e150:	20c7883a 	add	r3,r4,r3
 203e154:	b7000015 	stw	fp,0(r22)
 203e158:	b1000115 	stw	r4,4(r22)
 203e15c:	d8c02015 	stw	r3,128(sp)
 203e160:	dc401f15 	stw	r17,124(sp)
 203e164:	008001c4 	movi	r2,7
 203e168:	14400e16 	blt	r2,r17,203e1a4 <___svfprintf_internal_r+0x1090>
 203e16c:	b2000204 	addi	r8,r22,8
 203e170:	003e3c06 	br	203da64 <__alt_mem_mem_0+0xfd01da64>
 203e174:	01008134 	movhi	r4,516
 203e178:	210ea404 	addi	r4,r4,14992
 203e17c:	d9002b15 	stw	r4,172(sp)
 203e180:	d9002b17 	ldw	r4,172(sp)
 203e184:	1c07883a 	add	r3,r3,r16
 203e188:	44000115 	stw	r16,4(r8)
 203e18c:	41000015 	stw	r4,0(r8)
 203e190:	10800044 	addi	r2,r2,1
 203e194:	d8c02015 	stw	r3,128(sp)
 203e198:	d8801f15 	stw	r2,124(sp)
 203e19c:	010001c4 	movi	r4,7
 203e1a0:	20be2f0e 	bge	r4,r2,203da60 <__alt_mem_mem_0+0xfd01da60>
 203e1a4:	d9402c17 	ldw	r5,176(sp)
 203e1a8:	d9801e04 	addi	r6,sp,120
 203e1ac:	9809883a 	mov	r4,r19
 203e1b0:	203f5840 	call	203f584 <__ssprint_r>
 203e1b4:	103cbc1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e1b8:	d8c02017 	ldw	r3,128(sp)
 203e1bc:	da000404 	addi	r8,sp,16
 203e1c0:	003e2806 	br	203da64 <__alt_mem_mem_0+0xfd01da64>
 203e1c4:	d9402c17 	ldw	r5,176(sp)
 203e1c8:	d9801e04 	addi	r6,sp,120
 203e1cc:	9809883a 	mov	r4,r19
 203e1d0:	203f5840 	call	203f584 <__ssprint_r>
 203e1d4:	103e5f26 	beq	r2,zero,203db54 <__alt_mem_mem_0+0xfd01db54>
 203e1d8:	003cb306 	br	203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e1dc:	d9402c17 	ldw	r5,176(sp)
 203e1e0:	d9801e04 	addi	r6,sp,120
 203e1e4:	9809883a 	mov	r4,r19
 203e1e8:	203f5840 	call	203f584 <__ssprint_r>
 203e1ec:	103cae1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e1f0:	d8c02017 	ldw	r3,128(sp)
 203e1f4:	da000404 	addi	r8,sp,16
 203e1f8:	003e0d06 	br	203da30 <__alt_mem_mem_0+0xfd01da30>
 203e1fc:	d9402c17 	ldw	r5,176(sp)
 203e200:	d9801e04 	addi	r6,sp,120
 203e204:	9809883a 	mov	r4,r19
 203e208:	203f5840 	call	203f584 <__ssprint_r>
 203e20c:	103ca61e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e210:	d8c02017 	ldw	r3,128(sp)
 203e214:	da000404 	addi	r8,sp,16
 203e218:	003dc106 	br	203d920 <__alt_mem_mem_0+0xfd01d920>
 203e21c:	d9402c17 	ldw	r5,176(sp)
 203e220:	d9801e04 	addi	r6,sp,120
 203e224:	9809883a 	mov	r4,r19
 203e228:	203f5840 	call	203f584 <__ssprint_r>
 203e22c:	103c9e1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e230:	d8c02017 	ldw	r3,128(sp)
 203e234:	da000404 	addi	r8,sp,16
 203e238:	003dc706 	br	203d958 <__alt_mem_mem_0+0xfd01d958>
 203e23c:	d8802917 	ldw	r2,164(sp)
 203e240:	d8002785 	stb	zero,158(sp)
 203e244:	103f0816 	blt	r2,zero,203de68 <__alt_mem_mem_0+0xfd01de68>
 203e248:	00ffdfc4 	movi	r3,-129
 203e24c:	a584b03a 	or	r2,r20,r22
 203e250:	90e4703a 	and	r18,r18,r3
 203e254:	103c8126 	beq	r2,zero,203d45c <__alt_mem_mem_0+0xfd01d45c>
 203e258:	0039883a 	mov	fp,zero
 203e25c:	003e7606 	br	203dc38 <__alt_mem_mem_0+0xfd01dc38>
 203e260:	9080040c 	andi	r2,r18,16
 203e264:	10013d26 	beq	r2,zero,203e75c <___svfprintf_internal_r+0x1648>
 203e268:	d9002d17 	ldw	r4,180(sp)
 203e26c:	d9402917 	ldw	r5,164(sp)
 203e270:	d8002785 	stb	zero,158(sp)
 203e274:	20800104 	addi	r2,r4,4
 203e278:	25000017 	ldw	r20,0(r4)
 203e27c:	002d883a 	mov	r22,zero
 203e280:	28013f16 	blt	r5,zero,203e780 <___svfprintf_internal_r+0x166c>
 203e284:	00ffdfc4 	movi	r3,-129
 203e288:	d8802d15 	stw	r2,180(sp)
 203e28c:	90e4703a 	and	r18,r18,r3
 203e290:	a03d2b26 	beq	r20,zero,203d740 <__alt_mem_mem_0+0xfd01d740>
 203e294:	0039883a 	mov	fp,zero
 203e298:	003d2e06 	br	203d754 <__alt_mem_mem_0+0xfd01d754>
 203e29c:	dc402617 	ldw	r17,152(sp)
 203e2a0:	0441830e 	bge	zero,r17,203e8b0 <___svfprintf_internal_r+0x179c>
 203e2a4:	dc403217 	ldw	r17,200(sp)
 203e2a8:	d8803317 	ldw	r2,204(sp)
 203e2ac:	1440010e 	bge	r2,r17,203e2b4 <___svfprintf_internal_r+0x11a0>
 203e2b0:	1023883a 	mov	r17,r2
 203e2b4:	04400a0e 	bge	zero,r17,203e2e0 <___svfprintf_internal_r+0x11cc>
 203e2b8:	d8801f17 	ldw	r2,124(sp)
 203e2bc:	1c47883a 	add	r3,r3,r17
 203e2c0:	44000015 	stw	r16,0(r8)
 203e2c4:	10800044 	addi	r2,r2,1
 203e2c8:	44400115 	stw	r17,4(r8)
 203e2cc:	d8c02015 	stw	r3,128(sp)
 203e2d0:	d8801f15 	stw	r2,124(sp)
 203e2d4:	010001c4 	movi	r4,7
 203e2d8:	20827516 	blt	r4,r2,203ecb0 <___svfprintf_internal_r+0x1b9c>
 203e2dc:	42000204 	addi	r8,r8,8
 203e2e0:	88027b16 	blt	r17,zero,203ecd0 <___svfprintf_internal_r+0x1bbc>
 203e2e4:	d9003217 	ldw	r4,200(sp)
 203e2e8:	2463c83a 	sub	r17,r4,r17
 203e2ec:	0440990e 	bge	zero,r17,203e554 <___svfprintf_internal_r+0x1440>
 203e2f0:	05800404 	movi	r22,16
 203e2f4:	d8801f17 	ldw	r2,124(sp)
 203e2f8:	b441530e 	bge	r22,r17,203e848 <___svfprintf_internal_r+0x1734>
 203e2fc:	01008134 	movhi	r4,516
 203e300:	210ea404 	addi	r4,r4,14992
 203e304:	d9002b15 	stw	r4,172(sp)
 203e308:	070001c4 	movi	fp,7
 203e30c:	dd002c17 	ldw	r20,176(sp)
 203e310:	00000306 	br	203e320 <___svfprintf_internal_r+0x120c>
 203e314:	42000204 	addi	r8,r8,8
 203e318:	8c7ffc04 	addi	r17,r17,-16
 203e31c:	b4414d0e 	bge	r22,r17,203e854 <___svfprintf_internal_r+0x1740>
 203e320:	18c00404 	addi	r3,r3,16
 203e324:	10800044 	addi	r2,r2,1
 203e328:	45400015 	stw	r21,0(r8)
 203e32c:	45800115 	stw	r22,4(r8)
 203e330:	d8c02015 	stw	r3,128(sp)
 203e334:	d8801f15 	stw	r2,124(sp)
 203e338:	e0bff60e 	bge	fp,r2,203e314 <__alt_mem_mem_0+0xfd01e314>
 203e33c:	d9801e04 	addi	r6,sp,120
 203e340:	a00b883a 	mov	r5,r20
 203e344:	9809883a 	mov	r4,r19
 203e348:	203f5840 	call	203f584 <__ssprint_r>
 203e34c:	103c561e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e350:	d8c02017 	ldw	r3,128(sp)
 203e354:	d8801f17 	ldw	r2,124(sp)
 203e358:	da000404 	addi	r8,sp,16
 203e35c:	003fee06 	br	203e318 <__alt_mem_mem_0+0xfd01e318>
 203e360:	d9402c17 	ldw	r5,176(sp)
 203e364:	d9801e04 	addi	r6,sp,120
 203e368:	9809883a 	mov	r4,r19
 203e36c:	203f5840 	call	203f584 <__ssprint_r>
 203e370:	103c4d1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e374:	d8c02017 	ldw	r3,128(sp)
 203e378:	df002787 	ldb	fp,158(sp)
 203e37c:	da000404 	addi	r8,sp,16
 203e380:	003d5a06 	br	203d8ec <__alt_mem_mem_0+0xfd01d8ec>
 203e384:	9080040c 	andi	r2,r18,16
 203e388:	10005c26 	beq	r2,zero,203e4fc <___svfprintf_internal_r+0x13e8>
 203e38c:	d9402d17 	ldw	r5,180(sp)
 203e390:	d8c02917 	ldw	r3,164(sp)
 203e394:	d8002785 	stb	zero,158(sp)
 203e398:	28800104 	addi	r2,r5,4
 203e39c:	2d000017 	ldw	r20,0(r5)
 203e3a0:	002d883a 	mov	r22,zero
 203e3a4:	18005e16 	blt	r3,zero,203e520 <___svfprintf_internal_r+0x140c>
 203e3a8:	00ffdfc4 	movi	r3,-129
 203e3ac:	d8802d15 	stw	r2,180(sp)
 203e3b0:	90e4703a 	and	r18,r18,r3
 203e3b4:	0039883a 	mov	fp,zero
 203e3b8:	a03dfe26 	beq	r20,zero,203dbb4 <__alt_mem_mem_0+0xfd01dbb4>
 203e3bc:	00800244 	movi	r2,9
 203e3c0:	153cb336 	bltu	r2,r20,203d690 <__alt_mem_mem_0+0xfd01d690>
 203e3c4:	a5000c04 	addi	r20,r20,48
 203e3c8:	dc001dc4 	addi	r16,sp,119
 203e3cc:	dd001dc5 	stb	r20,119(sp)
 203e3d0:	d8c02817 	ldw	r3,160(sp)
 203e3d4:	1c07c83a 	sub	r3,r3,r16
 203e3d8:	d8c02e15 	stw	r3,184(sp)
 203e3dc:	003cf506 	br	203d7b4 <__alt_mem_mem_0+0xfd01d7b4>
 203e3e0:	d8803317 	ldw	r2,204(sp)
 203e3e4:	143fffc4 	addi	r16,r2,-1
 203e3e8:	043f560e 	bge	zero,r16,203e144 <__alt_mem_mem_0+0xfd01e144>
 203e3ec:	07000404 	movi	fp,16
 203e3f0:	e403530e 	bge	fp,r16,203f140 <___svfprintf_internal_r+0x202c>
 203e3f4:	01408134 	movhi	r5,516
 203e3f8:	294ea404 	addi	r5,r5,14992
 203e3fc:	d9402b15 	stw	r5,172(sp)
 203e400:	01c001c4 	movi	r7,7
 203e404:	dd002c17 	ldw	r20,176(sp)
 203e408:	00000306 	br	203e418 <___svfprintf_internal_r+0x1304>
 203e40c:	843ffc04 	addi	r16,r16,-16
 203e410:	b5800204 	addi	r22,r22,8
 203e414:	e400130e 	bge	fp,r16,203e464 <___svfprintf_internal_r+0x1350>
 203e418:	18c00404 	addi	r3,r3,16
 203e41c:	8c400044 	addi	r17,r17,1
 203e420:	b5400015 	stw	r21,0(r22)
 203e424:	b7000115 	stw	fp,4(r22)
 203e428:	d8c02015 	stw	r3,128(sp)
 203e42c:	dc401f15 	stw	r17,124(sp)
 203e430:	3c7ff60e 	bge	r7,r17,203e40c <__alt_mem_mem_0+0xfd01e40c>
 203e434:	d9801e04 	addi	r6,sp,120
 203e438:	a00b883a 	mov	r5,r20
 203e43c:	9809883a 	mov	r4,r19
 203e440:	d9c03d15 	stw	r7,244(sp)
 203e444:	203f5840 	call	203f584 <__ssprint_r>
 203e448:	d9c03d17 	ldw	r7,244(sp)
 203e44c:	103c161e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e450:	843ffc04 	addi	r16,r16,-16
 203e454:	d8c02017 	ldw	r3,128(sp)
 203e458:	dc401f17 	ldw	r17,124(sp)
 203e45c:	dd800404 	addi	r22,sp,16
 203e460:	e43fed16 	blt	fp,r16,203e418 <__alt_mem_mem_0+0xfd01e418>
 203e464:	d8802b17 	ldw	r2,172(sp)
 203e468:	1c07883a 	add	r3,r3,r16
 203e46c:	8c400044 	addi	r17,r17,1
 203e470:	b0800015 	stw	r2,0(r22)
 203e474:	b4000115 	stw	r16,4(r22)
 203e478:	d8c02015 	stw	r3,128(sp)
 203e47c:	dc401f15 	stw	r17,124(sp)
 203e480:	008001c4 	movi	r2,7
 203e484:	147f2e0e 	bge	r2,r17,203e140 <__alt_mem_mem_0+0xfd01e140>
 203e488:	d9402c17 	ldw	r5,176(sp)
 203e48c:	d9801e04 	addi	r6,sp,120
 203e490:	9809883a 	mov	r4,r19
 203e494:	203f5840 	call	203f584 <__ssprint_r>
 203e498:	103c031e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e49c:	d8c02017 	ldw	r3,128(sp)
 203e4a0:	dc401f17 	ldw	r17,124(sp)
 203e4a4:	dd800404 	addi	r22,sp,16
 203e4a8:	003f2606 	br	203e144 <__alt_mem_mem_0+0xfd01e144>
 203e4ac:	9080040c 	andi	r2,r18,16
 203e4b0:	1000c326 	beq	r2,zero,203e7c0 <___svfprintf_internal_r+0x16ac>
 203e4b4:	d8802d17 	ldw	r2,180(sp)
 203e4b8:	15000017 	ldw	r20,0(r2)
 203e4bc:	10800104 	addi	r2,r2,4
 203e4c0:	d8802d15 	stw	r2,180(sp)
 203e4c4:	a02dd7fa 	srai	r22,r20,31
 203e4c8:	b005883a 	mov	r2,r22
 203e4cc:	103c680e 	bge	r2,zero,203d670 <__alt_mem_mem_0+0xfd01d670>
 203e4d0:	0529c83a 	sub	r20,zero,r20
 203e4d4:	a004c03a 	cmpne	r2,r20,zero
 203e4d8:	05adc83a 	sub	r22,zero,r22
 203e4dc:	b0adc83a 	sub	r22,r22,r2
 203e4e0:	d8802917 	ldw	r2,164(sp)
 203e4e4:	07000b44 	movi	fp,45
 203e4e8:	df002785 	stb	fp,158(sp)
 203e4ec:	10022e16 	blt	r2,zero,203eda8 <___svfprintf_internal_r+0x1c94>
 203e4f0:	00bfdfc4 	movi	r2,-129
 203e4f4:	90a4703a 	and	r18,r18,r2
 203e4f8:	003c6406 	br	203d68c <__alt_mem_mem_0+0xfd01d68c>
 203e4fc:	9080100c 	andi	r2,r18,64
 203e500:	d8002785 	stb	zero,158(sp)
 203e504:	10012526 	beq	r2,zero,203e99c <___svfprintf_internal_r+0x1888>
 203e508:	d9002d17 	ldw	r4,180(sp)
 203e50c:	d9402917 	ldw	r5,164(sp)
 203e510:	002d883a 	mov	r22,zero
 203e514:	20800104 	addi	r2,r4,4
 203e518:	2500000b 	ldhu	r20,0(r4)
 203e51c:	283fa20e 	bge	r5,zero,203e3a8 <__alt_mem_mem_0+0xfd01e3a8>
 203e520:	d8802d15 	stw	r2,180(sp)
 203e524:	0039883a 	mov	fp,zero
 203e528:	a584b03a 	or	r2,r20,r22
 203e52c:	103c571e 	bne	r2,zero,203d68c <__alt_mem_mem_0+0xfd01d68c>
 203e530:	00800044 	movi	r2,1
 203e534:	003e5006 	br	203de78 <__alt_mem_mem_0+0xfd01de78>
 203e538:	d9402c17 	ldw	r5,176(sp)
 203e53c:	d9801e04 	addi	r6,sp,120
 203e540:	9809883a 	mov	r4,r19
 203e544:	203f5840 	call	203f584 <__ssprint_r>
 203e548:	103bd71e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e54c:	d8c02017 	ldw	r3,128(sp)
 203e550:	da000404 	addi	r8,sp,16
 203e554:	d9003217 	ldw	r4,200(sp)
 203e558:	d8802617 	ldw	r2,152(sp)
 203e55c:	d9403317 	ldw	r5,204(sp)
 203e560:	8123883a 	add	r17,r16,r4
 203e564:	11400216 	blt	r2,r5,203e570 <___svfprintf_internal_r+0x145c>
 203e568:	9100004c 	andi	r4,r18,1
 203e56c:	20000d26 	beq	r4,zero,203e5a4 <___svfprintf_internal_r+0x1490>
 203e570:	d9003817 	ldw	r4,224(sp)
 203e574:	d9403417 	ldw	r5,208(sp)
 203e578:	1907883a 	add	r3,r3,r4
 203e57c:	d9001f17 	ldw	r4,124(sp)
 203e580:	41400015 	stw	r5,0(r8)
 203e584:	d9403817 	ldw	r5,224(sp)
 203e588:	21000044 	addi	r4,r4,1
 203e58c:	d8c02015 	stw	r3,128(sp)
 203e590:	41400115 	stw	r5,4(r8)
 203e594:	d9001f15 	stw	r4,124(sp)
 203e598:	014001c4 	movi	r5,7
 203e59c:	2901dc16 	blt	r5,r4,203ed10 <___svfprintf_internal_r+0x1bfc>
 203e5a0:	42000204 	addi	r8,r8,8
 203e5a4:	d9003317 	ldw	r4,204(sp)
 203e5a8:	8121883a 	add	r16,r16,r4
 203e5ac:	2085c83a 	sub	r2,r4,r2
 203e5b0:	8461c83a 	sub	r16,r16,r17
 203e5b4:	1400010e 	bge	r2,r16,203e5bc <___svfprintf_internal_r+0x14a8>
 203e5b8:	1021883a 	mov	r16,r2
 203e5bc:	04000a0e 	bge	zero,r16,203e5e8 <___svfprintf_internal_r+0x14d4>
 203e5c0:	d9001f17 	ldw	r4,124(sp)
 203e5c4:	1c07883a 	add	r3,r3,r16
 203e5c8:	44400015 	stw	r17,0(r8)
 203e5cc:	21000044 	addi	r4,r4,1
 203e5d0:	44000115 	stw	r16,4(r8)
 203e5d4:	d8c02015 	stw	r3,128(sp)
 203e5d8:	d9001f15 	stw	r4,124(sp)
 203e5dc:	014001c4 	movi	r5,7
 203e5e0:	2901e616 	blt	r5,r4,203ed7c <___svfprintf_internal_r+0x1c68>
 203e5e4:	42000204 	addi	r8,r8,8
 203e5e8:	8001f616 	blt	r16,zero,203edc4 <___svfprintf_internal_r+0x1cb0>
 203e5ec:	1421c83a 	sub	r16,r2,r16
 203e5f0:	043d1c0e 	bge	zero,r16,203da64 <__alt_mem_mem_0+0xfd01da64>
 203e5f4:	04400404 	movi	r17,16
 203e5f8:	d8801f17 	ldw	r2,124(sp)
 203e5fc:	8c3edd0e 	bge	r17,r16,203e174 <__alt_mem_mem_0+0xfd01e174>
 203e600:	01408134 	movhi	r5,516
 203e604:	294ea404 	addi	r5,r5,14992
 203e608:	d9402b15 	stw	r5,172(sp)
 203e60c:	058001c4 	movi	r22,7
 203e610:	dd002c17 	ldw	r20,176(sp)
 203e614:	00000306 	br	203e624 <___svfprintf_internal_r+0x1510>
 203e618:	42000204 	addi	r8,r8,8
 203e61c:	843ffc04 	addi	r16,r16,-16
 203e620:	8c3ed70e 	bge	r17,r16,203e180 <__alt_mem_mem_0+0xfd01e180>
 203e624:	18c00404 	addi	r3,r3,16
 203e628:	10800044 	addi	r2,r2,1
 203e62c:	45400015 	stw	r21,0(r8)
 203e630:	44400115 	stw	r17,4(r8)
 203e634:	d8c02015 	stw	r3,128(sp)
 203e638:	d8801f15 	stw	r2,124(sp)
 203e63c:	b0bff60e 	bge	r22,r2,203e618 <__alt_mem_mem_0+0xfd01e618>
 203e640:	d9801e04 	addi	r6,sp,120
 203e644:	a00b883a 	mov	r5,r20
 203e648:	9809883a 	mov	r4,r19
 203e64c:	203f5840 	call	203f584 <__ssprint_r>
 203e650:	103b951e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e654:	d8c02017 	ldw	r3,128(sp)
 203e658:	d8801f17 	ldw	r2,124(sp)
 203e65c:	da000404 	addi	r8,sp,16
 203e660:	003fee06 	br	203e61c <__alt_mem_mem_0+0xfd01e61c>
 203e664:	9088703a 	and	r4,r18,r2
 203e668:	203e8d1e 	bne	r4,zero,203e0a0 <__alt_mem_mem_0+0xfd01e0a0>
 203e66c:	dc401f17 	ldw	r17,124(sp)
 203e670:	40800115 	stw	r2,4(r8)
 203e674:	44000015 	stw	r16,0(r8)
 203e678:	8c400044 	addi	r17,r17,1
 203e67c:	d8c02015 	stw	r3,128(sp)
 203e680:	dc401f15 	stw	r17,124(sp)
 203e684:	008001c4 	movi	r2,7
 203e688:	147f7f16 	blt	r2,r17,203e488 <__alt_mem_mem_0+0xfd01e488>
 203e68c:	45800204 	addi	r22,r8,8
 203e690:	003eac06 	br	203e144 <__alt_mem_mem_0+0xfd01e144>
 203e694:	d9402c17 	ldw	r5,176(sp)
 203e698:	d9801e04 	addi	r6,sp,120
 203e69c:	9809883a 	mov	r4,r19
 203e6a0:	203f5840 	call	203f584 <__ssprint_r>
 203e6a4:	103b801e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e6a8:	d8c02017 	ldw	r3,128(sp)
 203e6ac:	dc401f17 	ldw	r17,124(sp)
 203e6b0:	da000404 	addi	r8,sp,16
 203e6b4:	003e8406 	br	203e0c8 <__alt_mem_mem_0+0xfd01e0c8>
 203e6b8:	d9402c17 	ldw	r5,176(sp)
 203e6bc:	d9801e04 	addi	r6,sp,120
 203e6c0:	9809883a 	mov	r4,r19
 203e6c4:	203f5840 	call	203f584 <__ssprint_r>
 203e6c8:	103b771e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e6cc:	d8c02017 	ldw	r3,128(sp)
 203e6d0:	dc401f17 	ldw	r17,124(sp)
 203e6d4:	dd800404 	addi	r22,sp,16
 203e6d8:	003e8606 	br	203e0f4 <__alt_mem_mem_0+0xfd01e0f4>
 203e6dc:	0029883a 	mov	r20,zero
 203e6e0:	a5000c04 	addi	r20,r20,48
 203e6e4:	dc001dc4 	addi	r16,sp,119
 203e6e8:	dd001dc5 	stb	r20,119(sp)
 203e6ec:	003f3806 	br	203e3d0 <__alt_mem_mem_0+0xfd01e3d0>
 203e6f0:	d9402c17 	ldw	r5,176(sp)
 203e6f4:	d9801e04 	addi	r6,sp,120
 203e6f8:	9809883a 	mov	r4,r19
 203e6fc:	203f5840 	call	203f584 <__ssprint_r>
 203e700:	103b691e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e704:	d8c02017 	ldw	r3,128(sp)
 203e708:	da000404 	addi	r8,sp,16
 203e70c:	003c9506 	br	203d964 <__alt_mem_mem_0+0xfd01d964>
 203e710:	d9003617 	ldw	r4,216(sp)
 203e714:	d9403717 	ldw	r5,220(sp)
 203e718:	da003e15 	stw	r8,248(sp)
 203e71c:	20072900 	call	2007290 <__fpclassifyd>
 203e720:	da003e17 	ldw	r8,248(sp)
 203e724:	1000bd1e 	bne	r2,zero,203ea1c <___svfprintf_internal_r+0x1908>
 203e728:	008011c4 	movi	r2,71
 203e72c:	14411e0e 	bge	r2,r17,203eba8 <___svfprintf_internal_r+0x1a94>
 203e730:	04008134 	movhi	r16,516
 203e734:	8403c804 	addi	r16,r16,3872
 203e738:	00c000c4 	movi	r3,3
 203e73c:	00bfdfc4 	movi	r2,-129
 203e740:	d8c02a15 	stw	r3,168(sp)
 203e744:	90a4703a 	and	r18,r18,r2
 203e748:	df002783 	ldbu	fp,158(sp)
 203e74c:	d8c02e15 	stw	r3,184(sp)
 203e750:	d8002915 	stw	zero,164(sp)
 203e754:	d8003215 	stw	zero,200(sp)
 203e758:	003c1c06 	br	203d7cc <__alt_mem_mem_0+0xfd01d7cc>
 203e75c:	9080100c 	andi	r2,r18,64
 203e760:	d8002785 	stb	zero,158(sp)
 203e764:	10009426 	beq	r2,zero,203e9b8 <___svfprintf_internal_r+0x18a4>
 203e768:	d8c02d17 	ldw	r3,180(sp)
 203e76c:	d9002917 	ldw	r4,164(sp)
 203e770:	002d883a 	mov	r22,zero
 203e774:	18800104 	addi	r2,r3,4
 203e778:	1d00000b 	ldhu	r20,0(r3)
 203e77c:	203ec10e 	bge	r4,zero,203e284 <__alt_mem_mem_0+0xfd01e284>
 203e780:	a586b03a 	or	r3,r20,r22
 203e784:	d8802d15 	stw	r2,180(sp)
 203e788:	183ec21e 	bne	r3,zero,203e294 <__alt_mem_mem_0+0xfd01e294>
 203e78c:	0039883a 	mov	fp,zero
 203e790:	0005883a 	mov	r2,zero
 203e794:	003db806 	br	203de78 <__alt_mem_mem_0+0xfd01de78>
 203e798:	d8802d17 	ldw	r2,180(sp)
 203e79c:	d8c02d17 	ldw	r3,180(sp)
 203e7a0:	d9002d17 	ldw	r4,180(sp)
 203e7a4:	10800017 	ldw	r2,0(r2)
 203e7a8:	18c00117 	ldw	r3,4(r3)
 203e7ac:	21000204 	addi	r4,r4,8
 203e7b0:	d8803615 	stw	r2,216(sp)
 203e7b4:	d8c03715 	stw	r3,220(sp)
 203e7b8:	d9002d15 	stw	r4,180(sp)
 203e7bc:	003b8206 	br	203d5c8 <__alt_mem_mem_0+0xfd01d5c8>
 203e7c0:	9080100c 	andi	r2,r18,64
 203e7c4:	10010726 	beq	r2,zero,203ebe4 <___svfprintf_internal_r+0x1ad0>
 203e7c8:	d8c02d17 	ldw	r3,180(sp)
 203e7cc:	1d00000f 	ldh	r20,0(r3)
 203e7d0:	18c00104 	addi	r3,r3,4
 203e7d4:	d8c02d15 	stw	r3,180(sp)
 203e7d8:	a02dd7fa 	srai	r22,r20,31
 203e7dc:	b005883a 	mov	r2,r22
 203e7e0:	003ba206 	br	203d66c <__alt_mem_mem_0+0xfd01d66c>
 203e7e4:	9080100c 	andi	r2,r18,64
 203e7e8:	10010526 	beq	r2,zero,203ec00 <___svfprintf_internal_r+0x1aec>
 203e7ec:	d9002d17 	ldw	r4,180(sp)
 203e7f0:	002d883a 	mov	r22,zero
 203e7f4:	2500000b 	ldhu	r20,0(r4)
 203e7f8:	21000104 	addi	r4,r4,4
 203e7fc:	d9002d15 	stw	r4,180(sp)
 203e800:	003cfe06 	br	203dbfc <__alt_mem_mem_0+0xfd01dbfc>
 203e804:	bc400007 	ldb	r17,0(r23)
 203e808:	003a9606 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203e80c:	9080040c 	andi	r2,r18,16
 203e810:	10010126 	beq	r2,zero,203ec18 <___svfprintf_internal_r+0x1b04>
 203e814:	d9402d17 	ldw	r5,180(sp)
 203e818:	d8c02f17 	ldw	r3,188(sp)
 203e81c:	28800017 	ldw	r2,0(r5)
 203e820:	29400104 	addi	r5,r5,4
 203e824:	d9402d15 	stw	r5,180(sp)
 203e828:	10c00015 	stw	r3,0(r2)
 203e82c:	003a6406 	br	203d1c0 <__alt_mem_mem_0+0xfd01d1c0>
 203e830:	d9002917 	ldw	r4,164(sp)
 203e834:	d8002785 	stb	zero,158(sp)
 203e838:	203d8d16 	blt	r4,zero,203de70 <__alt_mem_mem_0+0xfd01de70>
 203e83c:	00bfdfc4 	movi	r2,-129
 203e840:	90a4703a 	and	r18,r18,r2
 203e844:	003b0506 	br	203d45c <__alt_mem_mem_0+0xfd01d45c>
 203e848:	01408134 	movhi	r5,516
 203e84c:	294ea404 	addi	r5,r5,14992
 203e850:	d9402b15 	stw	r5,172(sp)
 203e854:	d9402b17 	ldw	r5,172(sp)
 203e858:	1c47883a 	add	r3,r3,r17
 203e85c:	10800044 	addi	r2,r2,1
 203e860:	41400015 	stw	r5,0(r8)
 203e864:	44400115 	stw	r17,4(r8)
 203e868:	d8c02015 	stw	r3,128(sp)
 203e86c:	d8801f15 	stw	r2,124(sp)
 203e870:	010001c4 	movi	r4,7
 203e874:	20bf3016 	blt	r4,r2,203e538 <__alt_mem_mem_0+0xfd01e538>
 203e878:	42000204 	addi	r8,r8,8
 203e87c:	003f3506 	br	203e554 <__alt_mem_mem_0+0xfd01e554>
 203e880:	01008134 	movhi	r4,516
 203e884:	210ea404 	addi	r4,r4,14992
 203e888:	d9002b15 	stw	r4,172(sp)
 203e88c:	003c5e06 	br	203da08 <__alt_mem_mem_0+0xfd01da08>
 203e890:	d9402c17 	ldw	r5,176(sp)
 203e894:	d9801e04 	addi	r6,sp,120
 203e898:	9809883a 	mov	r4,r19
 203e89c:	203f5840 	call	203f584 <__ssprint_r>
 203e8a0:	103b011e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e8a4:	d8c02017 	ldw	r3,128(sp)
 203e8a8:	da000404 	addi	r8,sp,16
 203e8ac:	003d9306 	br	203defc <__alt_mem_mem_0+0xfd01defc>
 203e8b0:	d8801f17 	ldw	r2,124(sp)
 203e8b4:	01408134 	movhi	r5,516
 203e8b8:	01000044 	movi	r4,1
 203e8bc:	18c00044 	addi	r3,r3,1
 203e8c0:	10800044 	addi	r2,r2,1
 203e8c4:	2943d504 	addi	r5,r5,3924
 203e8c8:	41000115 	stw	r4,4(r8)
 203e8cc:	41400015 	stw	r5,0(r8)
 203e8d0:	d8c02015 	stw	r3,128(sp)
 203e8d4:	d8801f15 	stw	r2,124(sp)
 203e8d8:	010001c4 	movi	r4,7
 203e8dc:	2080b516 	blt	r4,r2,203ebb4 <___svfprintf_internal_r+0x1aa0>
 203e8e0:	42000204 	addi	r8,r8,8
 203e8e4:	8800041e 	bne	r17,zero,203e8f8 <___svfprintf_internal_r+0x17e4>
 203e8e8:	d8803317 	ldw	r2,204(sp)
 203e8ec:	1000021e 	bne	r2,zero,203e8f8 <___svfprintf_internal_r+0x17e4>
 203e8f0:	9080004c 	andi	r2,r18,1
 203e8f4:	103c5b26 	beq	r2,zero,203da64 <__alt_mem_mem_0+0xfd01da64>
 203e8f8:	d9003817 	ldw	r4,224(sp)
 203e8fc:	d8801f17 	ldw	r2,124(sp)
 203e900:	d9403417 	ldw	r5,208(sp)
 203e904:	20c7883a 	add	r3,r4,r3
 203e908:	10800044 	addi	r2,r2,1
 203e90c:	41000115 	stw	r4,4(r8)
 203e910:	41400015 	stw	r5,0(r8)
 203e914:	d8c02015 	stw	r3,128(sp)
 203e918:	d8801f15 	stw	r2,124(sp)
 203e91c:	010001c4 	movi	r4,7
 203e920:	20818016 	blt	r4,r2,203ef24 <___svfprintf_internal_r+0x1e10>
 203e924:	42000204 	addi	r8,r8,8
 203e928:	0463c83a 	sub	r17,zero,r17
 203e92c:	0440cb0e 	bge	zero,r17,203ec5c <___svfprintf_internal_r+0x1b48>
 203e930:	05800404 	movi	r22,16
 203e934:	b440e80e 	bge	r22,r17,203ecd8 <___svfprintf_internal_r+0x1bc4>
 203e938:	01408134 	movhi	r5,516
 203e93c:	294ea404 	addi	r5,r5,14992
 203e940:	d9402b15 	stw	r5,172(sp)
 203e944:	070001c4 	movi	fp,7
 203e948:	dd002c17 	ldw	r20,176(sp)
 203e94c:	00000306 	br	203e95c <___svfprintf_internal_r+0x1848>
 203e950:	42000204 	addi	r8,r8,8
 203e954:	8c7ffc04 	addi	r17,r17,-16
 203e958:	b440e20e 	bge	r22,r17,203ece4 <___svfprintf_internal_r+0x1bd0>
 203e95c:	18c00404 	addi	r3,r3,16
 203e960:	10800044 	addi	r2,r2,1
 203e964:	45400015 	stw	r21,0(r8)
 203e968:	45800115 	stw	r22,4(r8)
 203e96c:	d8c02015 	stw	r3,128(sp)
 203e970:	d8801f15 	stw	r2,124(sp)
 203e974:	e0bff60e 	bge	fp,r2,203e950 <__alt_mem_mem_0+0xfd01e950>
 203e978:	d9801e04 	addi	r6,sp,120
 203e97c:	a00b883a 	mov	r5,r20
 203e980:	9809883a 	mov	r4,r19
 203e984:	203f5840 	call	203f584 <__ssprint_r>
 203e988:	103ac71e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203e98c:	d8c02017 	ldw	r3,128(sp)
 203e990:	d8801f17 	ldw	r2,124(sp)
 203e994:	da000404 	addi	r8,sp,16
 203e998:	003fee06 	br	203e954 <__alt_mem_mem_0+0xfd01e954>
 203e99c:	d8c02d17 	ldw	r3,180(sp)
 203e9a0:	d9002917 	ldw	r4,164(sp)
 203e9a4:	002d883a 	mov	r22,zero
 203e9a8:	18800104 	addi	r2,r3,4
 203e9ac:	1d000017 	ldw	r20,0(r3)
 203e9b0:	203e7d0e 	bge	r4,zero,203e3a8 <__alt_mem_mem_0+0xfd01e3a8>
 203e9b4:	003eda06 	br	203e520 <__alt_mem_mem_0+0xfd01e520>
 203e9b8:	d9402d17 	ldw	r5,180(sp)
 203e9bc:	d8c02917 	ldw	r3,164(sp)
 203e9c0:	002d883a 	mov	r22,zero
 203e9c4:	28800104 	addi	r2,r5,4
 203e9c8:	2d000017 	ldw	r20,0(r5)
 203e9cc:	183e2d0e 	bge	r3,zero,203e284 <__alt_mem_mem_0+0xfd01e284>
 203e9d0:	003f6b06 	br	203e780 <__alt_mem_mem_0+0xfd01e780>
 203e9d4:	d8c02d15 	stw	r3,180(sp)
 203e9d8:	0039883a 	mov	fp,zero
 203e9dc:	003ed206 	br	203e528 <__alt_mem_mem_0+0xfd01e528>
 203e9e0:	bc400043 	ldbu	r17,1(r23)
 203e9e4:	94800814 	ori	r18,r18,32
 203e9e8:	bdc00044 	addi	r23,r23,1
 203e9ec:	8c403fcc 	andi	r17,r17,255
 203e9f0:	8c40201c 	xori	r17,r17,128
 203e9f4:	8c7fe004 	addi	r17,r17,-128
 203e9f8:	003a1a06 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203e9fc:	d9402c17 	ldw	r5,176(sp)
 203ea00:	d9801e04 	addi	r6,sp,120
 203ea04:	9809883a 	mov	r4,r19
 203ea08:	203f5840 	call	203f584 <__ssprint_r>
 203ea0c:	103aa61e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ea10:	d8c02017 	ldw	r3,128(sp)
 203ea14:	da000404 	addi	r8,sp,16
 203ea18:	003d4a06 	br	203df44 <__alt_mem_mem_0+0xfd01df44>
 203ea1c:	d9002917 	ldw	r4,164(sp)
 203ea20:	05bff7c4 	movi	r22,-33
 203ea24:	00bfffc4 	movi	r2,-1
 203ea28:	8dac703a 	and	r22,r17,r22
 203ea2c:	20806a26 	beq	r4,r2,203ebd8 <___svfprintf_internal_r+0x1ac4>
 203ea30:	008011c4 	movi	r2,71
 203ea34:	b0813726 	beq	r22,r2,203ef14 <___svfprintf_internal_r+0x1e00>
 203ea38:	d9003717 	ldw	r4,220(sp)
 203ea3c:	90c04014 	ori	r3,r18,256
 203ea40:	d8c02b15 	stw	r3,172(sp)
 203ea44:	20015d16 	blt	r4,zero,203efbc <___svfprintf_internal_r+0x1ea8>
 203ea48:	dd003717 	ldw	r20,220(sp)
 203ea4c:	d8002a05 	stb	zero,168(sp)
 203ea50:	00801984 	movi	r2,102
 203ea54:	88814026 	beq	r17,r2,203ef58 <___svfprintf_internal_r+0x1e44>
 203ea58:	00801184 	movi	r2,70
 203ea5c:	88817126 	beq	r17,r2,203f024 <___svfprintf_internal_r+0x1f10>
 203ea60:	00801144 	movi	r2,69
 203ea64:	b0816226 	beq	r22,r2,203eff0 <___svfprintf_internal_r+0x1edc>
 203ea68:	d8c02917 	ldw	r3,164(sp)
 203ea6c:	d8802104 	addi	r2,sp,132
 203ea70:	d8800315 	stw	r2,12(sp)
 203ea74:	d9403617 	ldw	r5,216(sp)
 203ea78:	d8802504 	addi	r2,sp,148
 203ea7c:	d8800215 	stw	r2,8(sp)
 203ea80:	d8802604 	addi	r2,sp,152
 203ea84:	d8c00015 	stw	r3,0(sp)
 203ea88:	d8800115 	stw	r2,4(sp)
 203ea8c:	01c00084 	movi	r7,2
 203ea90:	a00d883a 	mov	r6,r20
 203ea94:	9809883a 	mov	r4,r19
 203ea98:	d8c03d15 	stw	r3,244(sp)
 203ea9c:	da003e15 	stw	r8,248(sp)
 203eaa0:	20032100 	call	2003210 <_dtoa_r>
 203eaa4:	1021883a 	mov	r16,r2
 203eaa8:	008019c4 	movi	r2,103
 203eaac:	d8c03d17 	ldw	r3,244(sp)
 203eab0:	da003e17 	ldw	r8,248(sp)
 203eab4:	8880e726 	beq	r17,r2,203ee54 <___svfprintf_internal_r+0x1d40>
 203eab8:	008011c4 	movi	r2,71
 203eabc:	8880d426 	beq	r17,r2,203ee10 <___svfprintf_internal_r+0x1cfc>
 203eac0:	80f9883a 	add	fp,r16,r3
 203eac4:	d9003617 	ldw	r4,216(sp)
 203eac8:	000d883a 	mov	r6,zero
 203eacc:	000f883a 	mov	r7,zero
 203ead0:	a00b883a 	mov	r5,r20
 203ead4:	da003e15 	stw	r8,248(sp)
 203ead8:	200bef80 	call	200bef8 <__eqdf2>
 203eadc:	da003e17 	ldw	r8,248(sp)
 203eae0:	1000e426 	beq	r2,zero,203ee74 <___svfprintf_internal_r+0x1d60>
 203eae4:	d8802117 	ldw	r2,132(sp)
 203eae8:	1700062e 	bgeu	r2,fp,203eb04 <___svfprintf_internal_r+0x19f0>
 203eaec:	01000c04 	movi	r4,48
 203eaf0:	10c00044 	addi	r3,r2,1
 203eaf4:	d8c02115 	stw	r3,132(sp)
 203eaf8:	11000005 	stb	r4,0(r2)
 203eafc:	d8802117 	ldw	r2,132(sp)
 203eb00:	173ffb36 	bltu	r2,fp,203eaf0 <__alt_mem_mem_0+0xfd01eaf0>
 203eb04:	1405c83a 	sub	r2,r2,r16
 203eb08:	d8803315 	stw	r2,204(sp)
 203eb0c:	008011c4 	movi	r2,71
 203eb10:	b080c526 	beq	r22,r2,203ee28 <___svfprintf_internal_r+0x1d14>
 203eb14:	00801944 	movi	r2,101
 203eb18:	1441d90e 	bge	r2,r17,203f280 <___svfprintf_internal_r+0x216c>
 203eb1c:	d8c02617 	ldw	r3,152(sp)
 203eb20:	00801984 	movi	r2,102
 203eb24:	d8c03215 	stw	r3,200(sp)
 203eb28:	88813426 	beq	r17,r2,203effc <___svfprintf_internal_r+0x1ee8>
 203eb2c:	d8c03217 	ldw	r3,200(sp)
 203eb30:	d9003317 	ldw	r4,204(sp)
 203eb34:	19012516 	blt	r3,r4,203efcc <___svfprintf_internal_r+0x1eb8>
 203eb38:	9480004c 	andi	r18,r18,1
 203eb3c:	9001841e 	bne	r18,zero,203f150 <___svfprintf_internal_r+0x203c>
 203eb40:	1805883a 	mov	r2,r3
 203eb44:	1801cc16 	blt	r3,zero,203f278 <___svfprintf_internal_r+0x2164>
 203eb48:	d8c03217 	ldw	r3,200(sp)
 203eb4c:	044019c4 	movi	r17,103
 203eb50:	d8c02e15 	stw	r3,184(sp)
 203eb54:	df002a07 	ldb	fp,168(sp)
 203eb58:	e000a61e 	bne	fp,zero,203edf4 <___svfprintf_internal_r+0x1ce0>
 203eb5c:	df002783 	ldbu	fp,158(sp)
 203eb60:	d8802a15 	stw	r2,168(sp)
 203eb64:	dc802b17 	ldw	r18,172(sp)
 203eb68:	d8002915 	stw	zero,164(sp)
 203eb6c:	003b1706 	br	203d7cc <__alt_mem_mem_0+0xfd01d7cc>
 203eb70:	04008134 	movhi	r16,516
 203eb74:	8403c504 	addi	r16,r16,3860
 203eb78:	003aa606 	br	203d614 <__alt_mem_mem_0+0xfd01d614>
 203eb7c:	d9003917 	ldw	r4,228(sp)
 203eb80:	04001004 	movi	r16,64
 203eb84:	800b883a 	mov	r5,r16
 203eb88:	20057340 	call	2005734 <_malloc_r>
 203eb8c:	d9002c17 	ldw	r4,176(sp)
 203eb90:	20800015 	stw	r2,0(r4)
 203eb94:	20800415 	stw	r2,16(r4)
 203eb98:	1001cb26 	beq	r2,zero,203f2c8 <___svfprintf_internal_r+0x21b4>
 203eb9c:	d8802c17 	ldw	r2,176(sp)
 203eba0:	14000515 	stw	r16,20(r2)
 203eba4:	00397606 	br	203d180 <__alt_mem_mem_0+0xfd01d180>
 203eba8:	04008134 	movhi	r16,516
 203ebac:	8403c704 	addi	r16,r16,3868
 203ebb0:	003ee106 	br	203e738 <__alt_mem_mem_0+0xfd01e738>
 203ebb4:	d9402c17 	ldw	r5,176(sp)
 203ebb8:	d9801e04 	addi	r6,sp,120
 203ebbc:	9809883a 	mov	r4,r19
 203ebc0:	203f5840 	call	203f584 <__ssprint_r>
 203ebc4:	103a381e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ebc8:	dc402617 	ldw	r17,152(sp)
 203ebcc:	d8c02017 	ldw	r3,128(sp)
 203ebd0:	da000404 	addi	r8,sp,16
 203ebd4:	003f4306 	br	203e8e4 <__alt_mem_mem_0+0xfd01e8e4>
 203ebd8:	01400184 	movi	r5,6
 203ebdc:	d9402915 	stw	r5,164(sp)
 203ebe0:	003f9506 	br	203ea38 <__alt_mem_mem_0+0xfd01ea38>
 203ebe4:	d9002d17 	ldw	r4,180(sp)
 203ebe8:	25000017 	ldw	r20,0(r4)
 203ebec:	21000104 	addi	r4,r4,4
 203ebf0:	d9002d15 	stw	r4,180(sp)
 203ebf4:	a02dd7fa 	srai	r22,r20,31
 203ebf8:	b005883a 	mov	r2,r22
 203ebfc:	003a9b06 	br	203d66c <__alt_mem_mem_0+0xfd01d66c>
 203ec00:	d9402d17 	ldw	r5,180(sp)
 203ec04:	002d883a 	mov	r22,zero
 203ec08:	2d000017 	ldw	r20,0(r5)
 203ec0c:	29400104 	addi	r5,r5,4
 203ec10:	d9402d15 	stw	r5,180(sp)
 203ec14:	003bf906 	br	203dbfc <__alt_mem_mem_0+0xfd01dbfc>
 203ec18:	9480100c 	andi	r18,r18,64
 203ec1c:	90006e26 	beq	r18,zero,203edd8 <___svfprintf_internal_r+0x1cc4>
 203ec20:	d9002d17 	ldw	r4,180(sp)
 203ec24:	d9402f17 	ldw	r5,188(sp)
 203ec28:	20800017 	ldw	r2,0(r4)
 203ec2c:	21000104 	addi	r4,r4,4
 203ec30:	d9002d15 	stw	r4,180(sp)
 203ec34:	1140000d 	sth	r5,0(r2)
 203ec38:	00396106 	br	203d1c0 <__alt_mem_mem_0+0xfd01d1c0>
 203ec3c:	d9402c17 	ldw	r5,176(sp)
 203ec40:	d9801e04 	addi	r6,sp,120
 203ec44:	9809883a 	mov	r4,r19
 203ec48:	203f5840 	call	203f584 <__ssprint_r>
 203ec4c:	103a161e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ec50:	d8c02017 	ldw	r3,128(sp)
 203ec54:	d8801f17 	ldw	r2,124(sp)
 203ec58:	da000404 	addi	r8,sp,16
 203ec5c:	d9403317 	ldw	r5,204(sp)
 203ec60:	10800044 	addi	r2,r2,1
 203ec64:	44000015 	stw	r16,0(r8)
 203ec68:	28c7883a 	add	r3,r5,r3
 203ec6c:	003b7706 	br	203da4c <__alt_mem_mem_0+0xfd01da4c>
 203ec70:	8009883a 	mov	r4,r16
 203ec74:	da003e15 	stw	r8,248(sp)
 203ec78:	20075700 	call	2007570 <strlen>
 203ec7c:	d8802e15 	stw	r2,184(sp)
 203ec80:	da003e17 	ldw	r8,248(sp)
 203ec84:	103c280e 	bge	r2,zero,203dd28 <__alt_mem_mem_0+0xfd01dd28>
 203ec88:	0005883a 	mov	r2,zero
 203ec8c:	003c2606 	br	203dd28 <__alt_mem_mem_0+0xfd01dd28>
 203ec90:	00bfffc4 	movi	r2,-1
 203ec94:	003a0906 	br	203d4bc <__alt_mem_mem_0+0xfd01d4bc>
 203ec98:	01008134 	movhi	r4,516
 203ec9c:	210ea804 	addi	r4,r4,15008
 203eca0:	d9003515 	stw	r4,212(sp)
 203eca4:	003b0606 	br	203d8c0 <__alt_mem_mem_0+0xfd01d8c0>
 203eca8:	013fffc4 	movi	r4,-1
 203ecac:	003a2706 	br	203d54c <__alt_mem_mem_0+0xfd01d54c>
 203ecb0:	d9402c17 	ldw	r5,176(sp)
 203ecb4:	d9801e04 	addi	r6,sp,120
 203ecb8:	9809883a 	mov	r4,r19
 203ecbc:	203f5840 	call	203f584 <__ssprint_r>
 203ecc0:	1039f91e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ecc4:	d8c02017 	ldw	r3,128(sp)
 203ecc8:	da000404 	addi	r8,sp,16
 203eccc:	003d8406 	br	203e2e0 <__alt_mem_mem_0+0xfd01e2e0>
 203ecd0:	0023883a 	mov	r17,zero
 203ecd4:	003d8306 	br	203e2e4 <__alt_mem_mem_0+0xfd01e2e4>
 203ecd8:	01008134 	movhi	r4,516
 203ecdc:	210ea404 	addi	r4,r4,14992
 203ece0:	d9002b15 	stw	r4,172(sp)
 203ece4:	d9002b17 	ldw	r4,172(sp)
 203ece8:	1c47883a 	add	r3,r3,r17
 203ecec:	10800044 	addi	r2,r2,1
 203ecf0:	41000015 	stw	r4,0(r8)
 203ecf4:	44400115 	stw	r17,4(r8)
 203ecf8:	d8c02015 	stw	r3,128(sp)
 203ecfc:	d8801f15 	stw	r2,124(sp)
 203ed00:	010001c4 	movi	r4,7
 203ed04:	20bfcd16 	blt	r4,r2,203ec3c <__alt_mem_mem_0+0xfd01ec3c>
 203ed08:	42000204 	addi	r8,r8,8
 203ed0c:	003fd306 	br	203ec5c <__alt_mem_mem_0+0xfd01ec5c>
 203ed10:	d9402c17 	ldw	r5,176(sp)
 203ed14:	d9801e04 	addi	r6,sp,120
 203ed18:	9809883a 	mov	r4,r19
 203ed1c:	203f5840 	call	203f584 <__ssprint_r>
 203ed20:	1039e11e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ed24:	d8802617 	ldw	r2,152(sp)
 203ed28:	d8c02017 	ldw	r3,128(sp)
 203ed2c:	da000404 	addi	r8,sp,16
 203ed30:	003e1c06 	br	203e5a4 <__alt_mem_mem_0+0xfd01e5a4>
 203ed34:	d8802917 	ldw	r2,164(sp)
 203ed38:	00c00184 	movi	r3,6
 203ed3c:	1880012e 	bgeu	r3,r2,203ed44 <___svfprintf_internal_r+0x1c30>
 203ed40:	1805883a 	mov	r2,r3
 203ed44:	d8802e15 	stw	r2,184(sp)
 203ed48:	1000f316 	blt	r2,zero,203f118 <___svfprintf_internal_r+0x2004>
 203ed4c:	04008134 	movhi	r16,516
 203ed50:	d8802a15 	stw	r2,168(sp)
 203ed54:	dd002d15 	stw	r20,180(sp)
 203ed58:	d8002915 	stw	zero,164(sp)
 203ed5c:	d8003215 	stw	zero,200(sp)
 203ed60:	8403d304 	addi	r16,r16,3916
 203ed64:	0039883a 	mov	fp,zero
 203ed68:	003a9f06 	br	203d7e8 <__alt_mem_mem_0+0xfd01d7e8>
 203ed6c:	01008134 	movhi	r4,516
 203ed70:	210ea804 	addi	r4,r4,15008
 203ed74:	d9003515 	stw	r4,212(sp)
 203ed78:	003b5f06 	br	203daf8 <__alt_mem_mem_0+0xfd01daf8>
 203ed7c:	d9402c17 	ldw	r5,176(sp)
 203ed80:	d9801e04 	addi	r6,sp,120
 203ed84:	9809883a 	mov	r4,r19
 203ed88:	203f5840 	call	203f584 <__ssprint_r>
 203ed8c:	1039c61e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ed90:	d8802617 	ldw	r2,152(sp)
 203ed94:	d9403317 	ldw	r5,204(sp)
 203ed98:	d8c02017 	ldw	r3,128(sp)
 203ed9c:	da000404 	addi	r8,sp,16
 203eda0:	2885c83a 	sub	r2,r5,r2
 203eda4:	003e1006 	br	203e5e8 <__alt_mem_mem_0+0xfd01e5e8>
 203eda8:	00800044 	movi	r2,1
 203edac:	10803fcc 	andi	r2,r2,255
 203edb0:	00c00044 	movi	r3,1
 203edb4:	10fa3526 	beq	r2,r3,203d68c <__alt_mem_mem_0+0xfd01d68c>
 203edb8:	00c00084 	movi	r3,2
 203edbc:	10fb9e26 	beq	r2,r3,203dc38 <__alt_mem_mem_0+0xfd01dc38>
 203edc0:	003a6406 	br	203d754 <__alt_mem_mem_0+0xfd01d754>
 203edc4:	0021883a 	mov	r16,zero
 203edc8:	003e0806 	br	203e5ec <__alt_mem_mem_0+0xfd01e5ec>
 203edcc:	07000b44 	movi	fp,45
 203edd0:	df002785 	stb	fp,158(sp)
 203edd4:	003a0b06 	br	203d604 <__alt_mem_mem_0+0xfd01d604>
 203edd8:	d8c02d17 	ldw	r3,180(sp)
 203eddc:	d9002f17 	ldw	r4,188(sp)
 203ede0:	18800017 	ldw	r2,0(r3)
 203ede4:	18c00104 	addi	r3,r3,4
 203ede8:	d8c02d15 	stw	r3,180(sp)
 203edec:	11000015 	stw	r4,0(r2)
 203edf0:	0038f306 	br	203d1c0 <__alt_mem_mem_0+0xfd01d1c0>
 203edf4:	00c00b44 	movi	r3,45
 203edf8:	d8c02785 	stb	r3,158(sp)
 203edfc:	d8802a15 	stw	r2,168(sp)
 203ee00:	dc802b17 	ldw	r18,172(sp)
 203ee04:	d8002915 	stw	zero,164(sp)
 203ee08:	07000b44 	movi	fp,45
 203ee0c:	003a7306 	br	203d7dc <__alt_mem_mem_0+0xfd01d7dc>
 203ee10:	9080004c 	andi	r2,r18,1
 203ee14:	1000941e 	bne	r2,zero,203f068 <___svfprintf_internal_r+0x1f54>
 203ee18:	d8802117 	ldw	r2,132(sp)
 203ee1c:	1405c83a 	sub	r2,r2,r16
 203ee20:	d8803315 	stw	r2,204(sp)
 203ee24:	b441161e 	bne	r22,r17,203f280 <___svfprintf_internal_r+0x216c>
 203ee28:	dd802617 	ldw	r22,152(sp)
 203ee2c:	00bfff44 	movi	r2,-3
 203ee30:	b0801a16 	blt	r22,r2,203ee9c <___svfprintf_internal_r+0x1d88>
 203ee34:	d9402917 	ldw	r5,164(sp)
 203ee38:	2d801816 	blt	r5,r22,203ee9c <___svfprintf_internal_r+0x1d88>
 203ee3c:	dd803215 	stw	r22,200(sp)
 203ee40:	003f3a06 	br	203eb2c <__alt_mem_mem_0+0xfd01eb2c>
 203ee44:	1025883a 	mov	r18,r2
 203ee48:	0039883a 	mov	fp,zero
 203ee4c:	00800084 	movi	r2,2
 203ee50:	003fd606 	br	203edac <__alt_mem_mem_0+0xfd01edac>
 203ee54:	9080004c 	andi	r2,r18,1
 203ee58:	103f191e 	bne	r2,zero,203eac0 <__alt_mem_mem_0+0xfd01eac0>
 203ee5c:	d8802117 	ldw	r2,132(sp)
 203ee60:	003f2806 	br	203eb04 <__alt_mem_mem_0+0xfd01eb04>
 203ee64:	01008134 	movhi	r4,516
 203ee68:	210ea404 	addi	r4,r4,14992
 203ee6c:	d9002b15 	stw	r4,172(sp)
 203ee70:	003c7c06 	br	203e064 <__alt_mem_mem_0+0xfd01e064>
 203ee74:	e005883a 	mov	r2,fp
 203ee78:	003f2206 	br	203eb04 <__alt_mem_mem_0+0xfd01eb04>
 203ee7c:	d9402917 	ldw	r5,164(sp)
 203ee80:	df002783 	ldbu	fp,158(sp)
 203ee84:	dd002d15 	stw	r20,180(sp)
 203ee88:	d9402a15 	stw	r5,168(sp)
 203ee8c:	d9402e15 	stw	r5,184(sp)
 203ee90:	d8002915 	stw	zero,164(sp)
 203ee94:	d8003215 	stw	zero,200(sp)
 203ee98:	003a4c06 	br	203d7cc <__alt_mem_mem_0+0xfd01d7cc>
 203ee9c:	8c7fff84 	addi	r17,r17,-2
 203eea0:	b5bfffc4 	addi	r22,r22,-1
 203eea4:	dd802615 	stw	r22,152(sp)
 203eea8:	dc4022c5 	stb	r17,139(sp)
 203eeac:	b000c316 	blt	r22,zero,203f1bc <___svfprintf_internal_r+0x20a8>
 203eeb0:	00800ac4 	movi	r2,43
 203eeb4:	d8802305 	stb	r2,140(sp)
 203eeb8:	00800244 	movi	r2,9
 203eebc:	15806e16 	blt	r2,r22,203f078 <___svfprintf_internal_r+0x1f64>
 203eec0:	00800c04 	movi	r2,48
 203eec4:	b5800c04 	addi	r22,r22,48
 203eec8:	d8802345 	stb	r2,141(sp)
 203eecc:	dd802385 	stb	r22,142(sp)
 203eed0:	d88023c4 	addi	r2,sp,143
 203eed4:	df0022c4 	addi	fp,sp,139
 203eed8:	d8c03317 	ldw	r3,204(sp)
 203eedc:	1739c83a 	sub	fp,r2,fp
 203eee0:	d9003317 	ldw	r4,204(sp)
 203eee4:	e0c7883a 	add	r3,fp,r3
 203eee8:	df003b15 	stw	fp,236(sp)
 203eeec:	d8c02e15 	stw	r3,184(sp)
 203eef0:	00800044 	movi	r2,1
 203eef4:	1100b70e 	bge	r2,r4,203f1d4 <___svfprintf_internal_r+0x20c0>
 203eef8:	d8c02e17 	ldw	r3,184(sp)
 203eefc:	18c00044 	addi	r3,r3,1
 203ef00:	d8c02e15 	stw	r3,184(sp)
 203ef04:	1805883a 	mov	r2,r3
 203ef08:	1800b016 	blt	r3,zero,203f1cc <___svfprintf_internal_r+0x20b8>
 203ef0c:	d8003215 	stw	zero,200(sp)
 203ef10:	003f1006 	br	203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203ef14:	d8802917 	ldw	r2,164(sp)
 203ef18:	103ec71e 	bne	r2,zero,203ea38 <__alt_mem_mem_0+0xfd01ea38>
 203ef1c:	dc002915 	stw	r16,164(sp)
 203ef20:	003ec506 	br	203ea38 <__alt_mem_mem_0+0xfd01ea38>
 203ef24:	d9402c17 	ldw	r5,176(sp)
 203ef28:	d9801e04 	addi	r6,sp,120
 203ef2c:	9809883a 	mov	r4,r19
 203ef30:	203f5840 	call	203f584 <__ssprint_r>
 203ef34:	10395c1e 	bne	r2,zero,203d4a8 <__alt_mem_mem_0+0xfd01d4a8>
 203ef38:	dc402617 	ldw	r17,152(sp)
 203ef3c:	d8c02017 	ldw	r3,128(sp)
 203ef40:	d8801f17 	ldw	r2,124(sp)
 203ef44:	da000404 	addi	r8,sp,16
 203ef48:	003e7706 	br	203e928 <__alt_mem_mem_0+0xfd01e928>
 203ef4c:	582f883a 	mov	r23,r11
 203ef50:	d8002915 	stw	zero,164(sp)
 203ef54:	0038c406 	br	203d268 <__alt_mem_mem_0+0xfd01d268>
 203ef58:	d8c02917 	ldw	r3,164(sp)
 203ef5c:	d8802104 	addi	r2,sp,132
 203ef60:	d8800315 	stw	r2,12(sp)
 203ef64:	d9403617 	ldw	r5,216(sp)
 203ef68:	d8802504 	addi	r2,sp,148
 203ef6c:	d8800215 	stw	r2,8(sp)
 203ef70:	d8802604 	addi	r2,sp,152
 203ef74:	d8c00015 	stw	r3,0(sp)
 203ef78:	9809883a 	mov	r4,r19
 203ef7c:	d8800115 	stw	r2,4(sp)
 203ef80:	01c000c4 	movi	r7,3
 203ef84:	a00d883a 	mov	r6,r20
 203ef88:	da003e15 	stw	r8,248(sp)
 203ef8c:	20032100 	call	2003210 <_dtoa_r>
 203ef90:	d9002917 	ldw	r4,164(sp)
 203ef94:	da003e17 	ldw	r8,248(sp)
 203ef98:	1021883a 	mov	r16,r2
 203ef9c:	1139883a 	add	fp,r2,r4
 203efa0:	2007883a 	mov	r3,r4
 203efa4:	81000007 	ldb	r4,0(r16)
 203efa8:	00800c04 	movi	r2,48
 203efac:	20806f26 	beq	r4,r2,203f16c <___svfprintf_internal_r+0x2058>
 203efb0:	d8c02617 	ldw	r3,152(sp)
 203efb4:	e0f9883a 	add	fp,fp,r3
 203efb8:	003ec206 	br	203eac4 <__alt_mem_mem_0+0xfd01eac4>
 203efbc:	00c00b44 	movi	r3,45
 203efc0:	2520003c 	xorhi	r20,r4,32768
 203efc4:	d8c02a05 	stb	r3,168(sp)
 203efc8:	003ea106 	br	203ea50 <__alt_mem_mem_0+0xfd01ea50>
 203efcc:	d8c03217 	ldw	r3,200(sp)
 203efd0:	00c0890e 	bge	zero,r3,203f1f8 <___svfprintf_internal_r+0x20e4>
 203efd4:	00800044 	movi	r2,1
 203efd8:	d9003317 	ldw	r4,204(sp)
 203efdc:	1105883a 	add	r2,r2,r4
 203efe0:	d8802e15 	stw	r2,184(sp)
 203efe4:	10005f16 	blt	r2,zero,203f164 <___svfprintf_internal_r+0x2050>
 203efe8:	044019c4 	movi	r17,103
 203efec:	003ed906 	br	203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203eff0:	d9002917 	ldw	r4,164(sp)
 203eff4:	20c00044 	addi	r3,r4,1
 203eff8:	003e9c06 	br	203ea6c <__alt_mem_mem_0+0xfd01ea6c>
 203effc:	d9002917 	ldw	r4,164(sp)
 203f000:	00c0680e 	bge	zero,r3,203f1a4 <___svfprintf_internal_r+0x2090>
 203f004:	2000461e 	bne	r4,zero,203f120 <___svfprintf_internal_r+0x200c>
 203f008:	9480004c 	andi	r18,r18,1
 203f00c:	9000441e 	bne	r18,zero,203f120 <___svfprintf_internal_r+0x200c>
 203f010:	1805883a 	mov	r2,r3
 203f014:	1800a016 	blt	r3,zero,203f298 <___svfprintf_internal_r+0x2184>
 203f018:	d8c03217 	ldw	r3,200(sp)
 203f01c:	d8c02e15 	stw	r3,184(sp)
 203f020:	003ecc06 	br	203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203f024:	d9402917 	ldw	r5,164(sp)
 203f028:	d8802104 	addi	r2,sp,132
 203f02c:	d8800315 	stw	r2,12(sp)
 203f030:	d9400015 	stw	r5,0(sp)
 203f034:	d8802504 	addi	r2,sp,148
 203f038:	d9403617 	ldw	r5,216(sp)
 203f03c:	d8800215 	stw	r2,8(sp)
 203f040:	d8802604 	addi	r2,sp,152
 203f044:	d8800115 	stw	r2,4(sp)
 203f048:	01c000c4 	movi	r7,3
 203f04c:	a00d883a 	mov	r6,r20
 203f050:	9809883a 	mov	r4,r19
 203f054:	da003e15 	stw	r8,248(sp)
 203f058:	20032100 	call	2003210 <_dtoa_r>
 203f05c:	d8c02917 	ldw	r3,164(sp)
 203f060:	da003e17 	ldw	r8,248(sp)
 203f064:	1021883a 	mov	r16,r2
 203f068:	00801184 	movi	r2,70
 203f06c:	80f9883a 	add	fp,r16,r3
 203f070:	88bfcc26 	beq	r17,r2,203efa4 <__alt_mem_mem_0+0xfd01efa4>
 203f074:	003e9306 	br	203eac4 <__alt_mem_mem_0+0xfd01eac4>
 203f078:	df0022c4 	addi	fp,sp,139
 203f07c:	dc002915 	stw	r16,164(sp)
 203f080:	9829883a 	mov	r20,r19
 203f084:	e021883a 	mov	r16,fp
 203f088:	4027883a 	mov	r19,r8
 203f08c:	b009883a 	mov	r4,r22
 203f090:	01400284 	movi	r5,10
 203f094:	200ac340 	call	200ac34 <__modsi3>
 203f098:	10800c04 	addi	r2,r2,48
 203f09c:	843fffc4 	addi	r16,r16,-1
 203f0a0:	b009883a 	mov	r4,r22
 203f0a4:	01400284 	movi	r5,10
 203f0a8:	80800005 	stb	r2,0(r16)
 203f0ac:	200abb00 	call	200abb0 <__divsi3>
 203f0b0:	102d883a 	mov	r22,r2
 203f0b4:	00800244 	movi	r2,9
 203f0b8:	15bff416 	blt	r2,r22,203f08c <__alt_mem_mem_0+0xfd01f08c>
 203f0bc:	9811883a 	mov	r8,r19
 203f0c0:	b0800c04 	addi	r2,r22,48
 203f0c4:	a027883a 	mov	r19,r20
 203f0c8:	8029883a 	mov	r20,r16
 203f0cc:	a17fffc4 	addi	r5,r20,-1
 203f0d0:	a0bfffc5 	stb	r2,-1(r20)
 203f0d4:	dc002917 	ldw	r16,164(sp)
 203f0d8:	2f00752e 	bgeu	r5,fp,203f2b0 <___svfprintf_internal_r+0x219c>
 203f0dc:	d9c02384 	addi	r7,sp,142
 203f0e0:	3d0fc83a 	sub	r7,r7,r20
 203f0e4:	d9002344 	addi	r4,sp,141
 203f0e8:	e1cf883a 	add	r7,fp,r7
 203f0ec:	00000106 	br	203f0f4 <___svfprintf_internal_r+0x1fe0>
 203f0f0:	28800003 	ldbu	r2,0(r5)
 203f0f4:	20800005 	stb	r2,0(r4)
 203f0f8:	21000044 	addi	r4,r4,1
 203f0fc:	29400044 	addi	r5,r5,1
 203f100:	21fffb1e 	bne	r4,r7,203f0f0 <__alt_mem_mem_0+0xfd01f0f0>
 203f104:	d8802304 	addi	r2,sp,140
 203f108:	1505c83a 	sub	r2,r2,r20
 203f10c:	d8c02344 	addi	r3,sp,141
 203f110:	1885883a 	add	r2,r3,r2
 203f114:	003f7006 	br	203eed8 <__alt_mem_mem_0+0xfd01eed8>
 203f118:	0005883a 	mov	r2,zero
 203f11c:	003f0b06 	br	203ed4c <__alt_mem_mem_0+0xfd01ed4c>
 203f120:	d9002917 	ldw	r4,164(sp)
 203f124:	d8c03217 	ldw	r3,200(sp)
 203f128:	20800044 	addi	r2,r4,1
 203f12c:	1885883a 	add	r2,r3,r2
 203f130:	d8802e15 	stw	r2,184(sp)
 203f134:	103e870e 	bge	r2,zero,203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203f138:	0005883a 	mov	r2,zero
 203f13c:	003e8506 	br	203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203f140:	01008134 	movhi	r4,516
 203f144:	210ea404 	addi	r4,r4,14992
 203f148:	d9002b15 	stw	r4,172(sp)
 203f14c:	003cc506 	br	203e464 <__alt_mem_mem_0+0xfd01e464>
 203f150:	d8c03217 	ldw	r3,200(sp)
 203f154:	18c00044 	addi	r3,r3,1
 203f158:	d8c02e15 	stw	r3,184(sp)
 203f15c:	1805883a 	mov	r2,r3
 203f160:	183fa10e 	bge	r3,zero,203efe8 <__alt_mem_mem_0+0xfd01efe8>
 203f164:	0005883a 	mov	r2,zero
 203f168:	003f9f06 	br	203efe8 <__alt_mem_mem_0+0xfd01efe8>
 203f16c:	d9003617 	ldw	r4,216(sp)
 203f170:	000d883a 	mov	r6,zero
 203f174:	000f883a 	mov	r7,zero
 203f178:	a00b883a 	mov	r5,r20
 203f17c:	d8c03d15 	stw	r3,244(sp)
 203f180:	da003e15 	stw	r8,248(sp)
 203f184:	200bef80 	call	200bef8 <__eqdf2>
 203f188:	d8c03d17 	ldw	r3,244(sp)
 203f18c:	da003e17 	ldw	r8,248(sp)
 203f190:	103f8726 	beq	r2,zero,203efb0 <__alt_mem_mem_0+0xfd01efb0>
 203f194:	00800044 	movi	r2,1
 203f198:	10c7c83a 	sub	r3,r2,r3
 203f19c:	d8c02615 	stw	r3,152(sp)
 203f1a0:	003f8406 	br	203efb4 <__alt_mem_mem_0+0xfd01efb4>
 203f1a4:	20000e1e 	bne	r4,zero,203f1e0 <___svfprintf_internal_r+0x20cc>
 203f1a8:	9480004c 	andi	r18,r18,1
 203f1ac:	90000c1e 	bne	r18,zero,203f1e0 <___svfprintf_internal_r+0x20cc>
 203f1b0:	00800044 	movi	r2,1
 203f1b4:	d8802e15 	stw	r2,184(sp)
 203f1b8:	003e6606 	br	203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203f1bc:	00800b44 	movi	r2,45
 203f1c0:	05adc83a 	sub	r22,zero,r22
 203f1c4:	d8802305 	stb	r2,140(sp)
 203f1c8:	003f3b06 	br	203eeb8 <__alt_mem_mem_0+0xfd01eeb8>
 203f1cc:	0005883a 	mov	r2,zero
 203f1d0:	003f4e06 	br	203ef0c <__alt_mem_mem_0+0xfd01ef0c>
 203f1d4:	90a4703a 	and	r18,r18,r2
 203f1d8:	903f4a26 	beq	r18,zero,203ef04 <__alt_mem_mem_0+0xfd01ef04>
 203f1dc:	003f4606 	br	203eef8 <__alt_mem_mem_0+0xfd01eef8>
 203f1e0:	d8c02917 	ldw	r3,164(sp)
 203f1e4:	18c00084 	addi	r3,r3,2
 203f1e8:	d8c02e15 	stw	r3,184(sp)
 203f1ec:	1805883a 	mov	r2,r3
 203f1f0:	183e580e 	bge	r3,zero,203eb54 <__alt_mem_mem_0+0xfd01eb54>
 203f1f4:	003fd006 	br	203f138 <__alt_mem_mem_0+0xfd01f138>
 203f1f8:	00800084 	movi	r2,2
 203f1fc:	10c5c83a 	sub	r2,r2,r3
 203f200:	003f7506 	br	203efd8 <__alt_mem_mem_0+0xfd01efd8>
 203f204:	d8802d17 	ldw	r2,180(sp)
 203f208:	d9002d17 	ldw	r4,180(sp)
 203f20c:	bc400043 	ldbu	r17,1(r23)
 203f210:	10800017 	ldw	r2,0(r2)
 203f214:	582f883a 	mov	r23,r11
 203f218:	d8802915 	stw	r2,164(sp)
 203f21c:	20800104 	addi	r2,r4,4
 203f220:	d9002917 	ldw	r4,164(sp)
 203f224:	d8802d15 	stw	r2,180(sp)
 203f228:	203df00e 	bge	r4,zero,203e9ec <__alt_mem_mem_0+0xfd01e9ec>
 203f22c:	8c403fcc 	andi	r17,r17,255
 203f230:	00bfffc4 	movi	r2,-1
 203f234:	8c40201c 	xori	r17,r17,128
 203f238:	d8802915 	stw	r2,164(sp)
 203f23c:	8c7fe004 	addi	r17,r17,-128
 203f240:	00380806 	br	203d264 <__alt_mem_mem_0+0xfd01d264>
 203f244:	9080004c 	andi	r2,r18,1
 203f248:	0039883a 	mov	fp,zero
 203f24c:	10000726 	beq	r2,zero,203f26c <___svfprintf_internal_r+0x2158>
 203f250:	d8c02817 	ldw	r3,160(sp)
 203f254:	dc001dc4 	addi	r16,sp,119
 203f258:	00800c04 	movi	r2,48
 203f25c:	1c07c83a 	sub	r3,r3,r16
 203f260:	d8801dc5 	stb	r2,119(sp)
 203f264:	d8c02e15 	stw	r3,184(sp)
 203f268:	00395206 	br	203d7b4 <__alt_mem_mem_0+0xfd01d7b4>
 203f26c:	d8002e15 	stw	zero,184(sp)
 203f270:	dc001e04 	addi	r16,sp,120
 203f274:	00394f06 	br	203d7b4 <__alt_mem_mem_0+0xfd01d7b4>
 203f278:	0005883a 	mov	r2,zero
 203f27c:	003e3206 	br	203eb48 <__alt_mem_mem_0+0xfd01eb48>
 203f280:	dd802617 	ldw	r22,152(sp)
 203f284:	003f0606 	br	203eea0 <__alt_mem_mem_0+0xfd01eea0>
 203f288:	d9c02785 	stb	r7,158(sp)
 203f28c:	003a5106 	br	203dbd4 <__alt_mem_mem_0+0xfd01dbd4>
 203f290:	d9c02785 	stb	r7,158(sp)
 203f294:	003a3706 	br	203db74 <__alt_mem_mem_0+0xfd01db74>
 203f298:	0005883a 	mov	r2,zero
 203f29c:	003f5e06 	br	203f018 <__alt_mem_mem_0+0xfd01f018>
 203f2a0:	d9c02785 	stb	r7,158(sp)
 203f2a4:	00391706 	br	203d704 <__alt_mem_mem_0+0xfd01d704>
 203f2a8:	d9c02785 	stb	r7,158(sp)
 203f2ac:	0038e606 	br	203d648 <__alt_mem_mem_0+0xfd01d648>
 203f2b0:	d8802344 	addi	r2,sp,141
 203f2b4:	003f0806 	br	203eed8 <__alt_mem_mem_0+0xfd01eed8>
 203f2b8:	d9c02785 	stb	r7,158(sp)
 203f2bc:	0038b706 	br	203d59c <__alt_mem_mem_0+0xfd01d59c>
 203f2c0:	d9c02785 	stb	r7,158(sp)
 203f2c4:	003adc06 	br	203de38 <__alt_mem_mem_0+0xfd01de38>
 203f2c8:	d9403917 	ldw	r5,228(sp)
 203f2cc:	00800304 	movi	r2,12
 203f2d0:	28800015 	stw	r2,0(r5)
 203f2d4:	00bfffc4 	movi	r2,-1
 203f2d8:	00387806 	br	203d4bc <__alt_mem_mem_0+0xfd01d4bc>
 203f2dc:	d9c02785 	stb	r7,158(sp)
 203f2e0:	003abf06 	br	203dde0 <__alt_mem_mem_0+0xfd01dde0>
 203f2e4:	d9c02785 	stb	r7,158(sp)
 203f2e8:	003a9b06 	br	203dd58 <__alt_mem_mem_0+0xfd01dd58>

0203f2ec <__register_exitproc>:
 203f2ec:	defffa04 	addi	sp,sp,-24
 203f2f0:	dc000315 	stw	r16,12(sp)
 203f2f4:	04008134 	movhi	r16,516
 203f2f8:	84163c04 	addi	r16,r16,22768
 203f2fc:	80c00017 	ldw	r3,0(r16)
 203f300:	dc400415 	stw	r17,16(sp)
 203f304:	dfc00515 	stw	ra,20(sp)
 203f308:	18805217 	ldw	r2,328(r3)
 203f30c:	2023883a 	mov	r17,r4
 203f310:	10003726 	beq	r2,zero,203f3f0 <__register_exitproc+0x104>
 203f314:	10c00117 	ldw	r3,4(r2)
 203f318:	010007c4 	movi	r4,31
 203f31c:	20c00e16 	blt	r4,r3,203f358 <__register_exitproc+0x6c>
 203f320:	1a000044 	addi	r8,r3,1
 203f324:	8800221e 	bne	r17,zero,203f3b0 <__register_exitproc+0xc4>
 203f328:	18c00084 	addi	r3,r3,2
 203f32c:	18c7883a 	add	r3,r3,r3
 203f330:	18c7883a 	add	r3,r3,r3
 203f334:	12000115 	stw	r8,4(r2)
 203f338:	10c7883a 	add	r3,r2,r3
 203f33c:	19400015 	stw	r5,0(r3)
 203f340:	0005883a 	mov	r2,zero
 203f344:	dfc00517 	ldw	ra,20(sp)
 203f348:	dc400417 	ldw	r17,16(sp)
 203f34c:	dc000317 	ldw	r16,12(sp)
 203f350:	dec00604 	addi	sp,sp,24
 203f354:	f800283a 	ret
 203f358:	00808134 	movhi	r2,516
 203f35c:	10b2fa04 	addi	r2,r2,-13336
 203f360:	10002626 	beq	r2,zero,203f3fc <__register_exitproc+0x110>
 203f364:	01006404 	movi	r4,400
 203f368:	d9400015 	stw	r5,0(sp)
 203f36c:	d9800115 	stw	r6,4(sp)
 203f370:	d9c00215 	stw	r7,8(sp)
 203f374:	203cbe80 	call	203cbe8 <malloc>
 203f378:	d9400017 	ldw	r5,0(sp)
 203f37c:	d9800117 	ldw	r6,4(sp)
 203f380:	d9c00217 	ldw	r7,8(sp)
 203f384:	10001d26 	beq	r2,zero,203f3fc <__register_exitproc+0x110>
 203f388:	81000017 	ldw	r4,0(r16)
 203f38c:	10000115 	stw	zero,4(r2)
 203f390:	02000044 	movi	r8,1
 203f394:	22405217 	ldw	r9,328(r4)
 203f398:	0007883a 	mov	r3,zero
 203f39c:	12400015 	stw	r9,0(r2)
 203f3a0:	20805215 	stw	r2,328(r4)
 203f3a4:	10006215 	stw	zero,392(r2)
 203f3a8:	10006315 	stw	zero,396(r2)
 203f3ac:	883fde26 	beq	r17,zero,203f328 <__alt_mem_mem_0+0xfd01f328>
 203f3b0:	18c9883a 	add	r4,r3,r3
 203f3b4:	2109883a 	add	r4,r4,r4
 203f3b8:	1109883a 	add	r4,r2,r4
 203f3bc:	21802215 	stw	r6,136(r4)
 203f3c0:	01800044 	movi	r6,1
 203f3c4:	12406217 	ldw	r9,392(r2)
 203f3c8:	30cc983a 	sll	r6,r6,r3
 203f3cc:	4992b03a 	or	r9,r9,r6
 203f3d0:	12406215 	stw	r9,392(r2)
 203f3d4:	21c04215 	stw	r7,264(r4)
 203f3d8:	01000084 	movi	r4,2
 203f3dc:	893fd21e 	bne	r17,r4,203f328 <__alt_mem_mem_0+0xfd01f328>
 203f3e0:	11006317 	ldw	r4,396(r2)
 203f3e4:	218cb03a 	or	r6,r4,r6
 203f3e8:	11806315 	stw	r6,396(r2)
 203f3ec:	003fce06 	br	203f328 <__alt_mem_mem_0+0xfd01f328>
 203f3f0:	18805304 	addi	r2,r3,332
 203f3f4:	18805215 	stw	r2,328(r3)
 203f3f8:	003fc606 	br	203f314 <__alt_mem_mem_0+0xfd01f314>
 203f3fc:	00bfffc4 	movi	r2,-1
 203f400:	003fd006 	br	203f344 <__alt_mem_mem_0+0xfd01f344>

0203f404 <__call_exitprocs>:
 203f404:	defff504 	addi	sp,sp,-44
 203f408:	df000915 	stw	fp,36(sp)
 203f40c:	dd400615 	stw	r21,24(sp)
 203f410:	dc800315 	stw	r18,12(sp)
 203f414:	dfc00a15 	stw	ra,40(sp)
 203f418:	ddc00815 	stw	r23,32(sp)
 203f41c:	dd800715 	stw	r22,28(sp)
 203f420:	dd000515 	stw	r20,20(sp)
 203f424:	dcc00415 	stw	r19,16(sp)
 203f428:	dc400215 	stw	r17,8(sp)
 203f42c:	dc000115 	stw	r16,4(sp)
 203f430:	d9000015 	stw	r4,0(sp)
 203f434:	2839883a 	mov	fp,r5
 203f438:	04800044 	movi	r18,1
 203f43c:	057fffc4 	movi	r21,-1
 203f440:	00808134 	movhi	r2,516
 203f444:	10963c04 	addi	r2,r2,22768
 203f448:	12000017 	ldw	r8,0(r2)
 203f44c:	45005217 	ldw	r20,328(r8)
 203f450:	44c05204 	addi	r19,r8,328
 203f454:	a0001c26 	beq	r20,zero,203f4c8 <__call_exitprocs+0xc4>
 203f458:	a0800117 	ldw	r2,4(r20)
 203f45c:	15ffffc4 	addi	r23,r2,-1
 203f460:	b8000d16 	blt	r23,zero,203f498 <__call_exitprocs+0x94>
 203f464:	14000044 	addi	r16,r2,1
 203f468:	8421883a 	add	r16,r16,r16
 203f46c:	8421883a 	add	r16,r16,r16
 203f470:	84402004 	addi	r17,r16,128
 203f474:	a463883a 	add	r17,r20,r17
 203f478:	a421883a 	add	r16,r20,r16
 203f47c:	e0001e26 	beq	fp,zero,203f4f8 <__call_exitprocs+0xf4>
 203f480:	80804017 	ldw	r2,256(r16)
 203f484:	e0801c26 	beq	fp,r2,203f4f8 <__call_exitprocs+0xf4>
 203f488:	bdffffc4 	addi	r23,r23,-1
 203f48c:	843fff04 	addi	r16,r16,-4
 203f490:	8c7fff04 	addi	r17,r17,-4
 203f494:	bd7ff91e 	bne	r23,r21,203f47c <__alt_mem_mem_0+0xfd01f47c>
 203f498:	00808134 	movhi	r2,516
 203f49c:	10b2ff04 	addi	r2,r2,-13316
 203f4a0:	10000926 	beq	r2,zero,203f4c8 <__call_exitprocs+0xc4>
 203f4a4:	a0800117 	ldw	r2,4(r20)
 203f4a8:	1000301e 	bne	r2,zero,203f56c <__call_exitprocs+0x168>
 203f4ac:	a0800017 	ldw	r2,0(r20)
 203f4b0:	10003226 	beq	r2,zero,203f57c <__call_exitprocs+0x178>
 203f4b4:	a009883a 	mov	r4,r20
 203f4b8:	98800015 	stw	r2,0(r19)
 203f4bc:	203cbfc0 	call	203cbfc <free>
 203f4c0:	9d000017 	ldw	r20,0(r19)
 203f4c4:	a03fe41e 	bne	r20,zero,203f458 <__alt_mem_mem_0+0xfd01f458>
 203f4c8:	dfc00a17 	ldw	ra,40(sp)
 203f4cc:	df000917 	ldw	fp,36(sp)
 203f4d0:	ddc00817 	ldw	r23,32(sp)
 203f4d4:	dd800717 	ldw	r22,28(sp)
 203f4d8:	dd400617 	ldw	r21,24(sp)
 203f4dc:	dd000517 	ldw	r20,20(sp)
 203f4e0:	dcc00417 	ldw	r19,16(sp)
 203f4e4:	dc800317 	ldw	r18,12(sp)
 203f4e8:	dc400217 	ldw	r17,8(sp)
 203f4ec:	dc000117 	ldw	r16,4(sp)
 203f4f0:	dec00b04 	addi	sp,sp,44
 203f4f4:	f800283a 	ret
 203f4f8:	a0800117 	ldw	r2,4(r20)
 203f4fc:	80c00017 	ldw	r3,0(r16)
 203f500:	10bfffc4 	addi	r2,r2,-1
 203f504:	15c01426 	beq	r2,r23,203f558 <__call_exitprocs+0x154>
 203f508:	80000015 	stw	zero,0(r16)
 203f50c:	183fde26 	beq	r3,zero,203f488 <__alt_mem_mem_0+0xfd01f488>
 203f510:	95c8983a 	sll	r4,r18,r23
 203f514:	a0806217 	ldw	r2,392(r20)
 203f518:	a5800117 	ldw	r22,4(r20)
 203f51c:	2084703a 	and	r2,r4,r2
 203f520:	10000b26 	beq	r2,zero,203f550 <__call_exitprocs+0x14c>
 203f524:	a0806317 	ldw	r2,396(r20)
 203f528:	2088703a 	and	r4,r4,r2
 203f52c:	20000c1e 	bne	r4,zero,203f560 <__call_exitprocs+0x15c>
 203f530:	89400017 	ldw	r5,0(r17)
 203f534:	d9000017 	ldw	r4,0(sp)
 203f538:	183ee83a 	callr	r3
 203f53c:	a0800117 	ldw	r2,4(r20)
 203f540:	15bfbf1e 	bne	r2,r22,203f440 <__alt_mem_mem_0+0xfd01f440>
 203f544:	98800017 	ldw	r2,0(r19)
 203f548:	153fcf26 	beq	r2,r20,203f488 <__alt_mem_mem_0+0xfd01f488>
 203f54c:	003fbc06 	br	203f440 <__alt_mem_mem_0+0xfd01f440>
 203f550:	183ee83a 	callr	r3
 203f554:	003ff906 	br	203f53c <__alt_mem_mem_0+0xfd01f53c>
 203f558:	a5c00115 	stw	r23,4(r20)
 203f55c:	003feb06 	br	203f50c <__alt_mem_mem_0+0xfd01f50c>
 203f560:	89000017 	ldw	r4,0(r17)
 203f564:	183ee83a 	callr	r3
 203f568:	003ff406 	br	203f53c <__alt_mem_mem_0+0xfd01f53c>
 203f56c:	a0800017 	ldw	r2,0(r20)
 203f570:	a027883a 	mov	r19,r20
 203f574:	1029883a 	mov	r20,r2
 203f578:	003fb606 	br	203f454 <__alt_mem_mem_0+0xfd01f454>
 203f57c:	0005883a 	mov	r2,zero
 203f580:	003ffb06 	br	203f570 <__alt_mem_mem_0+0xfd01f570>

0203f584 <__ssprint_r>:
 203f584:	30800217 	ldw	r2,8(r6)
 203f588:	defff604 	addi	sp,sp,-40
 203f58c:	dc800215 	stw	r18,8(sp)
 203f590:	dfc00915 	stw	ra,36(sp)
 203f594:	df000815 	stw	fp,32(sp)
 203f598:	ddc00715 	stw	r23,28(sp)
 203f59c:	dd800615 	stw	r22,24(sp)
 203f5a0:	dd400515 	stw	r21,20(sp)
 203f5a4:	dd000415 	stw	r20,16(sp)
 203f5a8:	dcc00315 	stw	r19,12(sp)
 203f5ac:	dc400115 	stw	r17,4(sp)
 203f5b0:	dc000015 	stw	r16,0(sp)
 203f5b4:	3025883a 	mov	r18,r6
 203f5b8:	10005826 	beq	r2,zero,203f71c <__ssprint_r+0x198>
 203f5bc:	2027883a 	mov	r19,r4
 203f5c0:	35c00017 	ldw	r23,0(r6)
 203f5c4:	29000017 	ldw	r4,0(r5)
 203f5c8:	28800217 	ldw	r2,8(r5)
 203f5cc:	2823883a 	mov	r17,r5
 203f5d0:	0039883a 	mov	fp,zero
 203f5d4:	0021883a 	mov	r16,zero
 203f5d8:	80003926 	beq	r16,zero,203f6c0 <__ssprint_r+0x13c>
 203f5dc:	102b883a 	mov	r21,r2
 203f5e0:	102d883a 	mov	r22,r2
 203f5e4:	80803a36 	bltu	r16,r2,203f6d0 <__ssprint_r+0x14c>
 203f5e8:	88c0030b 	ldhu	r3,12(r17)
 203f5ec:	1881200c 	andi	r2,r3,1152
 203f5f0:	10002626 	beq	r2,zero,203f68c <__ssprint_r+0x108>
 203f5f4:	88800517 	ldw	r2,20(r17)
 203f5f8:	89400417 	ldw	r5,16(r17)
 203f5fc:	81800044 	addi	r6,r16,1
 203f600:	108f883a 	add	r7,r2,r2
 203f604:	3885883a 	add	r2,r7,r2
 203f608:	100ed7fa 	srli	r7,r2,31
 203f60c:	216dc83a 	sub	r22,r4,r5
 203f610:	3589883a 	add	r4,r6,r22
 203f614:	3885883a 	add	r2,r7,r2
 203f618:	102bd07a 	srai	r21,r2,1
 203f61c:	a80d883a 	mov	r6,r21
 203f620:	a900022e 	bgeu	r21,r4,203f62c <__ssprint_r+0xa8>
 203f624:	202b883a 	mov	r21,r4
 203f628:	200d883a 	mov	r6,r4
 203f62c:	18c1000c 	andi	r3,r3,1024
 203f630:	18002a26 	beq	r3,zero,203f6dc <__ssprint_r+0x158>
 203f634:	300b883a 	mov	r5,r6
 203f638:	9809883a 	mov	r4,r19
 203f63c:	20057340 	call	2005734 <_malloc_r>
 203f640:	1029883a 	mov	r20,r2
 203f644:	10002c26 	beq	r2,zero,203f6f8 <__ssprint_r+0x174>
 203f648:	89400417 	ldw	r5,16(r17)
 203f64c:	b00d883a 	mov	r6,r22
 203f650:	1009883a 	mov	r4,r2
 203f654:	20060240 	call	2006024 <memcpy>
 203f658:	8880030b 	ldhu	r2,12(r17)
 203f65c:	00fedfc4 	movi	r3,-1153
 203f660:	10c4703a 	and	r2,r2,r3
 203f664:	10802014 	ori	r2,r2,128
 203f668:	8880030d 	sth	r2,12(r17)
 203f66c:	a589883a 	add	r4,r20,r22
 203f670:	adadc83a 	sub	r22,r21,r22
 203f674:	8d400515 	stw	r21,20(r17)
 203f678:	8d800215 	stw	r22,8(r17)
 203f67c:	8d000415 	stw	r20,16(r17)
 203f680:	89000015 	stw	r4,0(r17)
 203f684:	802b883a 	mov	r21,r16
 203f688:	802d883a 	mov	r22,r16
 203f68c:	b00d883a 	mov	r6,r22
 203f690:	e00b883a 	mov	r5,fp
 203f694:	20096a00 	call	20096a0 <memmove>
 203f698:	88800217 	ldw	r2,8(r17)
 203f69c:	89000017 	ldw	r4,0(r17)
 203f6a0:	90c00217 	ldw	r3,8(r18)
 203f6a4:	1545c83a 	sub	r2,r2,r21
 203f6a8:	2589883a 	add	r4,r4,r22
 203f6ac:	88800215 	stw	r2,8(r17)
 203f6b0:	89000015 	stw	r4,0(r17)
 203f6b4:	1c21c83a 	sub	r16,r3,r16
 203f6b8:	94000215 	stw	r16,8(r18)
 203f6bc:	80001726 	beq	r16,zero,203f71c <__ssprint_r+0x198>
 203f6c0:	bf000017 	ldw	fp,0(r23)
 203f6c4:	bc000117 	ldw	r16,4(r23)
 203f6c8:	bdc00204 	addi	r23,r23,8
 203f6cc:	003fc206 	br	203f5d8 <__alt_mem_mem_0+0xfd01f5d8>
 203f6d0:	802b883a 	mov	r21,r16
 203f6d4:	802d883a 	mov	r22,r16
 203f6d8:	003fec06 	br	203f68c <__alt_mem_mem_0+0xfd01f68c>
 203f6dc:	9809883a 	mov	r4,r19
 203f6e0:	200985c0 	call	200985c <_realloc_r>
 203f6e4:	1029883a 	mov	r20,r2
 203f6e8:	103fe01e 	bne	r2,zero,203f66c <__alt_mem_mem_0+0xfd01f66c>
 203f6ec:	89400417 	ldw	r5,16(r17)
 203f6f0:	9809883a 	mov	r4,r19
 203f6f4:	20050040 	call	2005004 <_free_r>
 203f6f8:	88c0030b 	ldhu	r3,12(r17)
 203f6fc:	00800304 	movi	r2,12
 203f700:	98800015 	stw	r2,0(r19)
 203f704:	18c01014 	ori	r3,r3,64
 203f708:	88c0030d 	sth	r3,12(r17)
 203f70c:	00bfffc4 	movi	r2,-1
 203f710:	90000215 	stw	zero,8(r18)
 203f714:	90000115 	stw	zero,4(r18)
 203f718:	00000206 	br	203f724 <__ssprint_r+0x1a0>
 203f71c:	90000115 	stw	zero,4(r18)
 203f720:	0005883a 	mov	r2,zero
 203f724:	dfc00917 	ldw	ra,36(sp)
 203f728:	df000817 	ldw	fp,32(sp)
 203f72c:	ddc00717 	ldw	r23,28(sp)
 203f730:	dd800617 	ldw	r22,24(sp)
 203f734:	dd400517 	ldw	r21,20(sp)
 203f738:	dd000417 	ldw	r20,16(sp)
 203f73c:	dcc00317 	ldw	r19,12(sp)
 203f740:	dc800217 	ldw	r18,8(sp)
 203f744:	dc400117 	ldw	r17,4(sp)
 203f748:	dc000017 	ldw	r16,0(sp)
 203f74c:	dec00a04 	addi	sp,sp,40
 203f750:	f800283a 	ret

0203f754 <___svfiprintf_internal_r>:
 203f754:	2880030b 	ldhu	r2,12(r5)
 203f758:	deffc804 	addi	sp,sp,-224
 203f75c:	dcc03115 	stw	r19,196(sp)
 203f760:	dfc03715 	stw	ra,220(sp)
 203f764:	df003615 	stw	fp,216(sp)
 203f768:	ddc03515 	stw	r23,212(sp)
 203f76c:	dd803415 	stw	r22,208(sp)
 203f770:	dd403315 	stw	r21,204(sp)
 203f774:	dd003215 	stw	r20,200(sp)
 203f778:	dc803015 	stw	r18,192(sp)
 203f77c:	dc402f15 	stw	r17,188(sp)
 203f780:	dc002e15 	stw	r16,184(sp)
 203f784:	d9402715 	stw	r5,156(sp)
 203f788:	d9002a15 	stw	r4,168(sp)
 203f78c:	1080200c 	andi	r2,r2,128
 203f790:	d9c02315 	stw	r7,140(sp)
 203f794:	3027883a 	mov	r19,r6
 203f798:	10000226 	beq	r2,zero,203f7a4 <___svfiprintf_internal_r+0x50>
 203f79c:	28800417 	ldw	r2,16(r5)
 203f7a0:	10041d26 	beq	r2,zero,2040818 <___svfiprintf_internal_r+0x10c4>
 203f7a4:	dac01a04 	addi	r11,sp,104
 203f7a8:	dac01e15 	stw	r11,120(sp)
 203f7ac:	d8801e17 	ldw	r2,120(sp)
 203f7b0:	dac019c4 	addi	r11,sp,103
 203f7b4:	dd402a17 	ldw	r21,168(sp)
 203f7b8:	ddc02717 	ldw	r23,156(sp)
 203f7bc:	05808134 	movhi	r22,516
 203f7c0:	05008134 	movhi	r20,516
 203f7c4:	dac01f15 	stw	r11,124(sp)
 203f7c8:	12d7c83a 	sub	r11,r2,r11
 203f7cc:	b58eb004 	addi	r22,r22,15040
 203f7d0:	a50eac04 	addi	r20,r20,15024
 203f7d4:	dec01a15 	stw	sp,104(sp)
 203f7d8:	d8001c15 	stw	zero,112(sp)
 203f7dc:	d8001b15 	stw	zero,108(sp)
 203f7e0:	d811883a 	mov	r8,sp
 203f7e4:	d8002915 	stw	zero,164(sp)
 203f7e8:	d8002515 	stw	zero,148(sp)
 203f7ec:	dac02b15 	stw	r11,172(sp)
 203f7f0:	98800007 	ldb	r2,0(r19)
 203f7f4:	1002dd26 	beq	r2,zero,204036c <___svfiprintf_internal_r+0xc18>
 203f7f8:	00c00944 	movi	r3,37
 203f7fc:	9823883a 	mov	r17,r19
 203f800:	10c0021e 	bne	r2,r3,203f80c <___svfiprintf_internal_r+0xb8>
 203f804:	00001406 	br	203f858 <___svfiprintf_internal_r+0x104>
 203f808:	10c00326 	beq	r2,r3,203f818 <___svfiprintf_internal_r+0xc4>
 203f80c:	8c400044 	addi	r17,r17,1
 203f810:	88800007 	ldb	r2,0(r17)
 203f814:	103ffc1e 	bne	r2,zero,203f808 <__alt_mem_mem_0+0xfd01f808>
 203f818:	8ce1c83a 	sub	r16,r17,r19
 203f81c:	80000e26 	beq	r16,zero,203f858 <___svfiprintf_internal_r+0x104>
 203f820:	d8c01c17 	ldw	r3,112(sp)
 203f824:	d8801b17 	ldw	r2,108(sp)
 203f828:	44c00015 	stw	r19,0(r8)
 203f82c:	1c07883a 	add	r3,r3,r16
 203f830:	10800044 	addi	r2,r2,1
 203f834:	d8c01c15 	stw	r3,112(sp)
 203f838:	44000115 	stw	r16,4(r8)
 203f83c:	d8801b15 	stw	r2,108(sp)
 203f840:	00c001c4 	movi	r3,7
 203f844:	18831e16 	blt	r3,r2,20404c0 <___svfiprintf_internal_r+0xd6c>
 203f848:	42000204 	addi	r8,r8,8
 203f84c:	dac02517 	ldw	r11,148(sp)
 203f850:	5c17883a 	add	r11,r11,r16
 203f854:	dac02515 	stw	r11,148(sp)
 203f858:	88800007 	ldb	r2,0(r17)
 203f85c:	1002c526 	beq	r2,zero,2040374 <___svfiprintf_internal_r+0xc20>
 203f860:	88c00047 	ldb	r3,1(r17)
 203f864:	8cc00044 	addi	r19,r17,1
 203f868:	d8001d85 	stb	zero,118(sp)
 203f86c:	0009883a 	mov	r4,zero
 203f870:	000f883a 	mov	r7,zero
 203f874:	043fffc4 	movi	r16,-1
 203f878:	d8002415 	stw	zero,144(sp)
 203f87c:	0025883a 	mov	r18,zero
 203f880:	01401604 	movi	r5,88
 203f884:	01800244 	movi	r6,9
 203f888:	02800a84 	movi	r10,42
 203f88c:	02401b04 	movi	r9,108
 203f890:	9cc00044 	addi	r19,r19,1
 203f894:	18bff804 	addi	r2,r3,-32
 203f898:	2881dd36 	bltu	r5,r2,2040010 <___svfiprintf_internal_r+0x8bc>
 203f89c:	100490ba 	slli	r2,r2,2
 203f8a0:	02c08134 	movhi	r11,516
 203f8a4:	5afe2d04 	addi	r11,r11,-1868
 203f8a8:	12c5883a 	add	r2,r2,r11
 203f8ac:	10800017 	ldw	r2,0(r2)
 203f8b0:	1000683a 	jmp	r2
 203f8b4:	0203fab0 	cmpltui	r8,zero,4074
 203f8b8:	02040010 	cmplti	r8,zero,4096
 203f8bc:	02040010 	cmplti	r8,zero,4096
 203f8c0:	0203faa4 	muli	r8,zero,4074
 203f8c4:	02040010 	cmplti	r8,zero,4096
 203f8c8:	02040010 	cmplti	r8,zero,4096
 203f8cc:	02040010 	cmplti	r8,zero,4096
 203f8d0:	02040010 	cmplti	r8,zero,4096
 203f8d4:	02040010 	cmplti	r8,zero,4096
 203f8d8:	02040010 	cmplti	r8,zero,4096
 203f8dc:	0203fa18 	cmpnei	r8,zero,4072
 203f8e0:	0203fbf4 	movhi	r8,4079
 203f8e4:	02040010 	cmplti	r8,zero,4096
 203f8e8:	0203fa44 	movi	r8,4073
 203f8ec:	02040044 	movi	r8,4097
 203f8f0:	02040010 	cmplti	r8,zero,4096
 203f8f4:	02040038 	rdprs	r8,zero,4096
 203f8f8:	0203ffd8 	cmpnei	r8,zero,4095
 203f8fc:	0203ffd8 	cmpnei	r8,zero,4095
 203f900:	0203ffd8 	cmpnei	r8,zero,4095
 203f904:	0203ffd8 	cmpnei	r8,zero,4095
 203f908:	0203ffd8 	cmpnei	r8,zero,4095
 203f90c:	0203ffd8 	cmpnei	r8,zero,4095
 203f910:	0203ffd8 	cmpnei	r8,zero,4095
 203f914:	0203ffd8 	cmpnei	r8,zero,4095
 203f918:	0203ffd8 	cmpnei	r8,zero,4095
 203f91c:	02040010 	cmplti	r8,zero,4096
 203f920:	02040010 	cmplti	r8,zero,4096
 203f924:	02040010 	cmplti	r8,zero,4096
 203f928:	02040010 	cmplti	r8,zero,4096
 203f92c:	02040010 	cmplti	r8,zero,4096
 203f930:	02040010 	cmplti	r8,zero,4096
 203f934:	02040010 	cmplti	r8,zero,4096
 203f938:	02040010 	cmplti	r8,zero,4096
 203f93c:	02040010 	cmplti	r8,zero,4096
 203f940:	02040010 	cmplti	r8,zero,4096
 203f944:	0203ff74 	movhi	r8,4093
 203f948:	02040010 	cmplti	r8,zero,4096
 203f94c:	02040010 	cmplti	r8,zero,4096
 203f950:	02040010 	cmplti	r8,zero,4096
 203f954:	02040010 	cmplti	r8,zero,4096
 203f958:	02040010 	cmplti	r8,zero,4096
 203f95c:	02040010 	cmplti	r8,zero,4096
 203f960:	02040010 	cmplti	r8,zero,4096
 203f964:	02040010 	cmplti	r8,zero,4096
 203f968:	02040010 	cmplti	r8,zero,4096
 203f96c:	02040010 	cmplti	r8,zero,4096
 203f970:	020400ec 	andhi	r8,zero,4099
 203f974:	02040010 	cmplti	r8,zero,4096
 203f978:	02040010 	cmplti	r8,zero,4096
 203f97c:	02040010 	cmplti	r8,zero,4096
 203f980:	02040010 	cmplti	r8,zero,4096
 203f984:	02040010 	cmplti	r8,zero,4096
 203f988:	02040084 	movi	r8,4098
 203f98c:	02040010 	cmplti	r8,zero,4096
 203f990:	02040010 	cmplti	r8,zero,4096
 203f994:	0203fdb8 	rdprs	r8,zero,4086
 203f998:	02040010 	cmplti	r8,zero,4096
 203f99c:	02040010 	cmplti	r8,zero,4096
 203f9a0:	02040010 	cmplti	r8,zero,4096
 203f9a4:	02040010 	cmplti	r8,zero,4096
 203f9a8:	02040010 	cmplti	r8,zero,4096
 203f9ac:	02040010 	cmplti	r8,zero,4096
 203f9b0:	02040010 	cmplti	r8,zero,4096
 203f9b4:	02040010 	cmplti	r8,zero,4096
 203f9b8:	02040010 	cmplti	r8,zero,4096
 203f9bc:	02040010 	cmplti	r8,zero,4096
 203f9c0:	0203fca8 	cmpgeui	r8,zero,4082
 203f9c4:	0203fe54 	movui	r8,4089
 203f9c8:	02040010 	cmplti	r8,zero,4096
 203f9cc:	02040010 	cmplti	r8,zero,4096
 203f9d0:	02040010 	cmplti	r8,zero,4096
 203f9d4:	0203fe48 	cmpgei	r8,zero,4089
 203f9d8:	0203fe54 	movui	r8,4089
 203f9dc:	02040010 	cmplti	r8,zero,4096
 203f9e0:	02040010 	cmplti	r8,zero,4096
 203f9e4:	0203fe38 	rdprs	r8,zero,4088
 203f9e8:	02040010 	cmplti	r8,zero,4096
 203f9ec:	0203fdfc 	xorhi	r8,zero,4087
 203f9f0:	0203fc04 	movi	r8,4080
 203f9f4:	0203fa50 	cmplti	r8,zero,4073
 203f9f8:	0203ff68 	cmpgeui	r8,zero,4093
 203f9fc:	02040010 	cmplti	r8,zero,4096
 203fa00:	0203ff1c 	xori	r8,zero,4092
 203fa04:	02040010 	cmplti	r8,zero,4096
 203fa08:	0203fb74 	movhi	r8,4077
 203fa0c:	02040010 	cmplti	r8,zero,4096
 203fa10:	02040010 	cmplti	r8,zero,4096
 203fa14:	0203fad0 	cmplti	r8,zero,4075
 203fa18:	dac02317 	ldw	r11,140(sp)
 203fa1c:	5ac00017 	ldw	r11,0(r11)
 203fa20:	dac02415 	stw	r11,144(sp)
 203fa24:	dac02317 	ldw	r11,140(sp)
 203fa28:	58800104 	addi	r2,r11,4
 203fa2c:	dac02417 	ldw	r11,144(sp)
 203fa30:	5802e90e 	bge	r11,zero,20405d8 <___svfiprintf_internal_r+0xe84>
 203fa34:	dac02417 	ldw	r11,144(sp)
 203fa38:	d8802315 	stw	r2,140(sp)
 203fa3c:	02d7c83a 	sub	r11,zero,r11
 203fa40:	dac02415 	stw	r11,144(sp)
 203fa44:	94800114 	ori	r18,r18,4
 203fa48:	98c00007 	ldb	r3,0(r19)
 203fa4c:	003f9006 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fa50:	00800c04 	movi	r2,48
 203fa54:	dac02317 	ldw	r11,140(sp)
 203fa58:	d8801d05 	stb	r2,116(sp)
 203fa5c:	00801e04 	movi	r2,120
 203fa60:	d8801d45 	stb	r2,117(sp)
 203fa64:	d8001d85 	stb	zero,118(sp)
 203fa68:	58c00104 	addi	r3,r11,4
 203fa6c:	5f000017 	ldw	fp,0(r11)
 203fa70:	0013883a 	mov	r9,zero
 203fa74:	90800094 	ori	r2,r18,2
 203fa78:	80032b16 	blt	r16,zero,2040728 <___svfiprintf_internal_r+0xfd4>
 203fa7c:	00bfdfc4 	movi	r2,-129
 203fa80:	90a4703a 	and	r18,r18,r2
 203fa84:	d8c02315 	stw	r3,140(sp)
 203fa88:	94800094 	ori	r18,r18,2
 203fa8c:	e002dc26 	beq	fp,zero,2040600 <___svfiprintf_internal_r+0xeac>
 203fa90:	01008134 	movhi	r4,516
 203fa94:	2103ce04 	addi	r4,r4,3896
 203fa98:	0015883a 	mov	r10,zero
 203fa9c:	d9002915 	stw	r4,164(sp)
 203faa0:	00002306 	br	203fb30 <___svfiprintf_internal_r+0x3dc>
 203faa4:	94800054 	ori	r18,r18,1
 203faa8:	98c00007 	ldb	r3,0(r19)
 203faac:	003f7806 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fab0:	38803fcc 	andi	r2,r7,255
 203fab4:	1080201c 	xori	r2,r2,128
 203fab8:	10bfe004 	addi	r2,r2,-128
 203fabc:	1002f31e 	bne	r2,zero,204068c <___svfiprintf_internal_r+0xf38>
 203fac0:	01000044 	movi	r4,1
 203fac4:	01c00804 	movi	r7,32
 203fac8:	98c00007 	ldb	r3,0(r19)
 203facc:	003f7006 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fad0:	21003fcc 	andi	r4,r4,255
 203fad4:	2003aa1e 	bne	r4,zero,2040980 <___svfiprintf_internal_r+0x122c>
 203fad8:	00808134 	movhi	r2,516
 203fadc:	1083ce04 	addi	r2,r2,3896
 203fae0:	d8802915 	stw	r2,164(sp)
 203fae4:	9080080c 	andi	r2,r18,32
 203fae8:	1000ba26 	beq	r2,zero,203fdd4 <___svfiprintf_internal_r+0x680>
 203faec:	dac02317 	ldw	r11,140(sp)
 203faf0:	5f000017 	ldw	fp,0(r11)
 203faf4:	5a400117 	ldw	r9,4(r11)
 203faf8:	5ac00204 	addi	r11,r11,8
 203fafc:	dac02315 	stw	r11,140(sp)
 203fb00:	9080004c 	andi	r2,r18,1
 203fb04:	10029026 	beq	r2,zero,2040548 <___svfiprintf_internal_r+0xdf4>
 203fb08:	e244b03a 	or	r2,fp,r9
 203fb0c:	1002d41e 	bne	r2,zero,2040660 <___svfiprintf_internal_r+0xf0c>
 203fb10:	d8001d85 	stb	zero,118(sp)
 203fb14:	80030b16 	blt	r16,zero,2040744 <___svfiprintf_internal_r+0xff0>
 203fb18:	00bfdfc4 	movi	r2,-129
 203fb1c:	90a4703a 	and	r18,r18,r2
 203fb20:	0015883a 	mov	r10,zero
 203fb24:	80002426 	beq	r16,zero,203fbb8 <___svfiprintf_internal_r+0x464>
 203fb28:	0039883a 	mov	fp,zero
 203fb2c:	0013883a 	mov	r9,zero
 203fb30:	d9002917 	ldw	r4,164(sp)
 203fb34:	dc401a04 	addi	r17,sp,104
 203fb38:	e08003cc 	andi	r2,fp,15
 203fb3c:	4806973a 	slli	r3,r9,28
 203fb40:	2085883a 	add	r2,r4,r2
 203fb44:	e038d13a 	srli	fp,fp,4
 203fb48:	10800003 	ldbu	r2,0(r2)
 203fb4c:	4812d13a 	srli	r9,r9,4
 203fb50:	8c7fffc4 	addi	r17,r17,-1
 203fb54:	1f38b03a 	or	fp,r3,fp
 203fb58:	88800005 	stb	r2,0(r17)
 203fb5c:	e244b03a 	or	r2,fp,r9
 203fb60:	103ff51e 	bne	r2,zero,203fb38 <__alt_mem_mem_0+0xfd01fb38>
 203fb64:	dac01e17 	ldw	r11,120(sp)
 203fb68:	5c57c83a 	sub	r11,r11,r17
 203fb6c:	dac02115 	stw	r11,132(sp)
 203fb70:	00001406 	br	203fbc4 <___svfiprintf_internal_r+0x470>
 203fb74:	21003fcc 	andi	r4,r4,255
 203fb78:	2003741e 	bne	r4,zero,204094c <___svfiprintf_internal_r+0x11f8>
 203fb7c:	9080080c 	andi	r2,r18,32
 203fb80:	10014526 	beq	r2,zero,2040098 <___svfiprintf_internal_r+0x944>
 203fb84:	dac02317 	ldw	r11,140(sp)
 203fb88:	d8001d85 	stb	zero,118(sp)
 203fb8c:	58c00204 	addi	r3,r11,8
 203fb90:	5f000017 	ldw	fp,0(r11)
 203fb94:	5a400117 	ldw	r9,4(r11)
 203fb98:	8002d916 	blt	r16,zero,2040700 <___svfiprintf_internal_r+0xfac>
 203fb9c:	013fdfc4 	movi	r4,-129
 203fba0:	e244b03a 	or	r2,fp,r9
 203fba4:	d8c02315 	stw	r3,140(sp)
 203fba8:	9124703a 	and	r18,r18,r4
 203fbac:	0015883a 	mov	r10,zero
 203fbb0:	1000b91e 	bne	r2,zero,203fe98 <___svfiprintf_internal_r+0x744>
 203fbb4:	8002e61e 	bne	r16,zero,2040750 <___svfiprintf_internal_r+0xffc>
 203fbb8:	0021883a 	mov	r16,zero
 203fbbc:	d8002115 	stw	zero,132(sp)
 203fbc0:	dc401a04 	addi	r17,sp,104
 203fbc4:	d8c02117 	ldw	r3,132(sp)
 203fbc8:	dc002015 	stw	r16,128(sp)
 203fbcc:	80c0010e 	bge	r16,r3,203fbd4 <___svfiprintf_internal_r+0x480>
 203fbd0:	d8c02015 	stw	r3,128(sp)
 203fbd4:	52803fcc 	andi	r10,r10,255
 203fbd8:	5280201c 	xori	r10,r10,128
 203fbdc:	52bfe004 	addi	r10,r10,-128
 203fbe0:	50003c26 	beq	r10,zero,203fcd4 <___svfiprintf_internal_r+0x580>
 203fbe4:	dac02017 	ldw	r11,128(sp)
 203fbe8:	5ac00044 	addi	r11,r11,1
 203fbec:	dac02015 	stw	r11,128(sp)
 203fbf0:	00003806 	br	203fcd4 <___svfiprintf_internal_r+0x580>
 203fbf4:	01000044 	movi	r4,1
 203fbf8:	01c00ac4 	movi	r7,43
 203fbfc:	98c00007 	ldb	r3,0(r19)
 203fc00:	003f2306 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fc04:	21003fcc 	andi	r4,r4,255
 203fc08:	2003481e 	bne	r4,zero,204092c <___svfiprintf_internal_r+0x11d8>
 203fc0c:	9080080c 	andi	r2,r18,32
 203fc10:	10013b26 	beq	r2,zero,2040100 <___svfiprintf_internal_r+0x9ac>
 203fc14:	dac02317 	ldw	r11,140(sp)
 203fc18:	d8001d85 	stb	zero,118(sp)
 203fc1c:	58800204 	addi	r2,r11,8
 203fc20:	5f000017 	ldw	fp,0(r11)
 203fc24:	5a400117 	ldw	r9,4(r11)
 203fc28:	8002a816 	blt	r16,zero,20406cc <___svfiprintf_internal_r+0xf78>
 203fc2c:	013fdfc4 	movi	r4,-129
 203fc30:	e246b03a 	or	r3,fp,r9
 203fc34:	d8802315 	stw	r2,140(sp)
 203fc38:	9124703a 	and	r18,r18,r4
 203fc3c:	18013c26 	beq	r3,zero,2040130 <___svfiprintf_internal_r+0x9dc>
 203fc40:	0015883a 	mov	r10,zero
 203fc44:	dc401a04 	addi	r17,sp,104
 203fc48:	e006d0fa 	srli	r3,fp,3
 203fc4c:	4808977a 	slli	r4,r9,29
 203fc50:	4812d0fa 	srli	r9,r9,3
 203fc54:	e70001cc 	andi	fp,fp,7
 203fc58:	e0800c04 	addi	r2,fp,48
 203fc5c:	8c7fffc4 	addi	r17,r17,-1
 203fc60:	20f8b03a 	or	fp,r4,r3
 203fc64:	88800005 	stb	r2,0(r17)
 203fc68:	e246b03a 	or	r3,fp,r9
 203fc6c:	183ff61e 	bne	r3,zero,203fc48 <__alt_mem_mem_0+0xfd01fc48>
 203fc70:	90c0004c 	andi	r3,r18,1
 203fc74:	1800a526 	beq	r3,zero,203ff0c <___svfiprintf_internal_r+0x7b8>
 203fc78:	10803fcc 	andi	r2,r2,255
 203fc7c:	1080201c 	xori	r2,r2,128
 203fc80:	10bfe004 	addi	r2,r2,-128
 203fc84:	00c00c04 	movi	r3,48
 203fc88:	10ffb626 	beq	r2,r3,203fb64 <__alt_mem_mem_0+0xfd01fb64>
 203fc8c:	88ffffc5 	stb	r3,-1(r17)
 203fc90:	d8c01e17 	ldw	r3,120(sp)
 203fc94:	88bfffc4 	addi	r2,r17,-1
 203fc98:	1023883a 	mov	r17,r2
 203fc9c:	1887c83a 	sub	r3,r3,r2
 203fca0:	d8c02115 	stw	r3,132(sp)
 203fca4:	003fc706 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 203fca8:	dac02317 	ldw	r11,140(sp)
 203fcac:	00c00044 	movi	r3,1
 203fcb0:	d8c02015 	stw	r3,128(sp)
 203fcb4:	58800017 	ldw	r2,0(r11)
 203fcb8:	5ac00104 	addi	r11,r11,4
 203fcbc:	d8001d85 	stb	zero,118(sp)
 203fcc0:	d8801005 	stb	r2,64(sp)
 203fcc4:	dac02315 	stw	r11,140(sp)
 203fcc8:	d8c02115 	stw	r3,132(sp)
 203fccc:	dc401004 	addi	r17,sp,64
 203fcd0:	0021883a 	mov	r16,zero
 203fcd4:	90c0008c 	andi	r3,r18,2
 203fcd8:	d8c02215 	stw	r3,136(sp)
 203fcdc:	18000326 	beq	r3,zero,203fcec <___svfiprintf_internal_r+0x598>
 203fce0:	dac02017 	ldw	r11,128(sp)
 203fce4:	5ac00084 	addi	r11,r11,2
 203fce8:	dac02015 	stw	r11,128(sp)
 203fcec:	90c0210c 	andi	r3,r18,132
 203fcf0:	d8c02615 	stw	r3,152(sp)
 203fcf4:	1801131e 	bne	r3,zero,2040144 <___svfiprintf_internal_r+0x9f0>
 203fcf8:	dac02417 	ldw	r11,144(sp)
 203fcfc:	d8c02017 	ldw	r3,128(sp)
 203fd00:	58f9c83a 	sub	fp,r11,r3
 203fd04:	07010f0e 	bge	zero,fp,2040144 <___svfiprintf_internal_r+0x9f0>
 203fd08:	02400404 	movi	r9,16
 203fd0c:	d8c01c17 	ldw	r3,112(sp)
 203fd10:	d8801b17 	ldw	r2,108(sp)
 203fd14:	4f02d60e 	bge	r9,fp,2040870 <___svfiprintf_internal_r+0x111c>
 203fd18:	01408134 	movhi	r5,516
 203fd1c:	294eb004 	addi	r5,r5,15040
 203fd20:	d9402815 	stw	r5,160(sp)
 203fd24:	028001c4 	movi	r10,7
 203fd28:	00000306 	br	203fd38 <___svfiprintf_internal_r+0x5e4>
 203fd2c:	e73ffc04 	addi	fp,fp,-16
 203fd30:	42000204 	addi	r8,r8,8
 203fd34:	4f00150e 	bge	r9,fp,203fd8c <___svfiprintf_internal_r+0x638>
 203fd38:	18c00404 	addi	r3,r3,16
 203fd3c:	10800044 	addi	r2,r2,1
 203fd40:	45800015 	stw	r22,0(r8)
 203fd44:	42400115 	stw	r9,4(r8)
 203fd48:	d8c01c15 	stw	r3,112(sp)
 203fd4c:	d8801b15 	stw	r2,108(sp)
 203fd50:	50bff60e 	bge	r10,r2,203fd2c <__alt_mem_mem_0+0xfd01fd2c>
 203fd54:	d9801a04 	addi	r6,sp,104
 203fd58:	b80b883a 	mov	r5,r23
 203fd5c:	a809883a 	mov	r4,r21
 203fd60:	da402c15 	stw	r9,176(sp)
 203fd64:	da802d15 	stw	r10,180(sp)
 203fd68:	203f5840 	call	203f584 <__ssprint_r>
 203fd6c:	da402c17 	ldw	r9,176(sp)
 203fd70:	da802d17 	ldw	r10,180(sp)
 203fd74:	1001851e 	bne	r2,zero,204038c <___svfiprintf_internal_r+0xc38>
 203fd78:	e73ffc04 	addi	fp,fp,-16
 203fd7c:	d8c01c17 	ldw	r3,112(sp)
 203fd80:	d8801b17 	ldw	r2,108(sp)
 203fd84:	d811883a 	mov	r8,sp
 203fd88:	4f3feb16 	blt	r9,fp,203fd38 <__alt_mem_mem_0+0xfd01fd38>
 203fd8c:	dac02817 	ldw	r11,160(sp)
 203fd90:	e0c7883a 	add	r3,fp,r3
 203fd94:	10800044 	addi	r2,r2,1
 203fd98:	42c00015 	stw	r11,0(r8)
 203fd9c:	47000115 	stw	fp,4(r8)
 203fda0:	d8c01c15 	stw	r3,112(sp)
 203fda4:	d8801b15 	stw	r2,108(sp)
 203fda8:	010001c4 	movi	r4,7
 203fdac:	2081ee16 	blt	r4,r2,2040568 <___svfiprintf_internal_r+0xe14>
 203fdb0:	42000204 	addi	r8,r8,8
 203fdb4:	0000e506 	br	204014c <___svfiprintf_internal_r+0x9f8>
 203fdb8:	21003fcc 	andi	r4,r4,255
 203fdbc:	2002dd1e 	bne	r4,zero,2040934 <___svfiprintf_internal_r+0x11e0>
 203fdc0:	00808134 	movhi	r2,516
 203fdc4:	1083c904 	addi	r2,r2,3876
 203fdc8:	d8802915 	stw	r2,164(sp)
 203fdcc:	9080080c 	andi	r2,r18,32
 203fdd0:	103f461e 	bne	r2,zero,203faec <__alt_mem_mem_0+0xfd01faec>
 203fdd4:	9080040c 	andi	r2,r18,16
 203fdd8:	10022e1e 	bne	r2,zero,2040694 <___svfiprintf_internal_r+0xf40>
 203fddc:	9080100c 	andi	r2,r18,64
 203fde0:	dac02317 	ldw	r11,140(sp)
 203fde4:	10027326 	beq	r2,zero,20407b4 <___svfiprintf_internal_r+0x1060>
 203fde8:	5f00000b 	ldhu	fp,0(r11)
 203fdec:	5ac00104 	addi	r11,r11,4
 203fdf0:	0013883a 	mov	r9,zero
 203fdf4:	dac02315 	stw	r11,140(sp)
 203fdf8:	003f4106 	br	203fb00 <__alt_mem_mem_0+0xfd01fb00>
 203fdfc:	21003fcc 	andi	r4,r4,255
 203fe00:	2002e11e 	bne	r4,zero,2040988 <___svfiprintf_internal_r+0x1234>
 203fe04:	9080080c 	andi	r2,r18,32
 203fe08:	1002011e 	bne	r2,zero,2040610 <___svfiprintf_internal_r+0xebc>
 203fe0c:	9080040c 	andi	r2,r18,16
 203fe10:	10023e1e 	bne	r2,zero,204070c <___svfiprintf_internal_r+0xfb8>
 203fe14:	9480100c 	andi	r18,r18,64
 203fe18:	90023c26 	beq	r18,zero,204070c <___svfiprintf_internal_r+0xfb8>
 203fe1c:	dac02317 	ldw	r11,140(sp)
 203fe20:	58800017 	ldw	r2,0(r11)
 203fe24:	5ac00104 	addi	r11,r11,4
 203fe28:	dac02315 	stw	r11,140(sp)
 203fe2c:	dac02517 	ldw	r11,148(sp)
 203fe30:	12c0000d 	sth	r11,0(r2)
 203fe34:	003e6e06 	br	203f7f0 <__alt_mem_mem_0+0xfd01f7f0>
 203fe38:	98c00007 	ldb	r3,0(r19)
 203fe3c:	1a422926 	beq	r3,r9,20406e4 <___svfiprintf_internal_r+0xf90>
 203fe40:	94800414 	ori	r18,r18,16
 203fe44:	003e9206 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fe48:	94801014 	ori	r18,r18,64
 203fe4c:	98c00007 	ldb	r3,0(r19)
 203fe50:	003e8f06 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203fe54:	21003fcc 	andi	r4,r4,255
 203fe58:	2002c71e 	bne	r4,zero,2040978 <___svfiprintf_internal_r+0x1224>
 203fe5c:	9080080c 	andi	r2,r18,32
 203fe60:	10004926 	beq	r2,zero,203ff88 <___svfiprintf_internal_r+0x834>
 203fe64:	dac02317 	ldw	r11,140(sp)
 203fe68:	58800117 	ldw	r2,4(r11)
 203fe6c:	5f000017 	ldw	fp,0(r11)
 203fe70:	5ac00204 	addi	r11,r11,8
 203fe74:	dac02315 	stw	r11,140(sp)
 203fe78:	1013883a 	mov	r9,r2
 203fe7c:	10004b16 	blt	r2,zero,203ffac <___svfiprintf_internal_r+0x858>
 203fe80:	da801d83 	ldbu	r10,118(sp)
 203fe84:	8001cb16 	blt	r16,zero,20405b4 <___svfiprintf_internal_r+0xe60>
 203fe88:	00ffdfc4 	movi	r3,-129
 203fe8c:	e244b03a 	or	r2,fp,r9
 203fe90:	90e4703a 	and	r18,r18,r3
 203fe94:	103f4726 	beq	r2,zero,203fbb4 <__alt_mem_mem_0+0xfd01fbb4>
 203fe98:	48008c26 	beq	r9,zero,20400cc <___svfiprintf_internal_r+0x978>
 203fe9c:	dc802015 	stw	r18,128(sp)
 203fea0:	dc002115 	stw	r16,132(sp)
 203fea4:	dc401a04 	addi	r17,sp,104
 203fea8:	e021883a 	mov	r16,fp
 203feac:	da002215 	stw	r8,136(sp)
 203feb0:	5039883a 	mov	fp,r10
 203feb4:	4825883a 	mov	r18,r9
 203feb8:	8009883a 	mov	r4,r16
 203febc:	900b883a 	mov	r5,r18
 203fec0:	01800284 	movi	r6,10
 203fec4:	000f883a 	mov	r7,zero
 203fec8:	200a6780 	call	200a678 <__umoddi3>
 203fecc:	10800c04 	addi	r2,r2,48
 203fed0:	8c7fffc4 	addi	r17,r17,-1
 203fed4:	8009883a 	mov	r4,r16
 203fed8:	900b883a 	mov	r5,r18
 203fedc:	88800005 	stb	r2,0(r17)
 203fee0:	01800284 	movi	r6,10
 203fee4:	000f883a 	mov	r7,zero
 203fee8:	200a1000 	call	200a100 <__udivdi3>
 203feec:	1021883a 	mov	r16,r2
 203fef0:	10c4b03a 	or	r2,r2,r3
 203fef4:	1825883a 	mov	r18,r3
 203fef8:	103fef1e 	bne	r2,zero,203feb8 <__alt_mem_mem_0+0xfd01feb8>
 203fefc:	dc802017 	ldw	r18,128(sp)
 203ff00:	dc002117 	ldw	r16,132(sp)
 203ff04:	da002217 	ldw	r8,136(sp)
 203ff08:	e015883a 	mov	r10,fp
 203ff0c:	d8c01e17 	ldw	r3,120(sp)
 203ff10:	1c47c83a 	sub	r3,r3,r17
 203ff14:	d8c02115 	stw	r3,132(sp)
 203ff18:	003f2a06 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 203ff1c:	dac02317 	ldw	r11,140(sp)
 203ff20:	d8001d85 	stb	zero,118(sp)
 203ff24:	5c400017 	ldw	r17,0(r11)
 203ff28:	5f000104 	addi	fp,r11,4
 203ff2c:	88022f26 	beq	r17,zero,20407ec <___svfiprintf_internal_r+0x1098>
 203ff30:	80022516 	blt	r16,zero,20407c8 <___svfiprintf_internal_r+0x1074>
 203ff34:	800d883a 	mov	r6,r16
 203ff38:	000b883a 	mov	r5,zero
 203ff3c:	8809883a 	mov	r4,r17
 203ff40:	da002c15 	stw	r8,176(sp)
 203ff44:	2005f400 	call	2005f40 <memchr>
 203ff48:	da002c17 	ldw	r8,176(sp)
 203ff4c:	10026426 	beq	r2,zero,20408e0 <___svfiprintf_internal_r+0x118c>
 203ff50:	1445c83a 	sub	r2,r2,r17
 203ff54:	d8802115 	stw	r2,132(sp)
 203ff58:	da801d83 	ldbu	r10,118(sp)
 203ff5c:	df002315 	stw	fp,140(sp)
 203ff60:	0021883a 	mov	r16,zero
 203ff64:	003f1706 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 203ff68:	94800814 	ori	r18,r18,32
 203ff6c:	98c00007 	ldb	r3,0(r19)
 203ff70:	003e4706 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 203ff74:	21003fcc 	andi	r4,r4,255
 203ff78:	2002701e 	bne	r4,zero,204093c <___svfiprintf_internal_r+0x11e8>
 203ff7c:	94800414 	ori	r18,r18,16
 203ff80:	9080080c 	andi	r2,r18,32
 203ff84:	103fb71e 	bne	r2,zero,203fe64 <__alt_mem_mem_0+0xfd01fe64>
 203ff88:	9080040c 	andi	r2,r18,16
 203ff8c:	1001ab26 	beq	r2,zero,204063c <___svfiprintf_internal_r+0xee8>
 203ff90:	dac02317 	ldw	r11,140(sp)
 203ff94:	5f000017 	ldw	fp,0(r11)
 203ff98:	5ac00104 	addi	r11,r11,4
 203ff9c:	dac02315 	stw	r11,140(sp)
 203ffa0:	e013d7fa 	srai	r9,fp,31
 203ffa4:	4805883a 	mov	r2,r9
 203ffa8:	103fb50e 	bge	r2,zero,203fe80 <__alt_mem_mem_0+0xfd01fe80>
 203ffac:	0739c83a 	sub	fp,zero,fp
 203ffb0:	02800b44 	movi	r10,45
 203ffb4:	e004c03a 	cmpne	r2,fp,zero
 203ffb8:	0253c83a 	sub	r9,zero,r9
 203ffbc:	da801d85 	stb	r10,118(sp)
 203ffc0:	4893c83a 	sub	r9,r9,r2
 203ffc4:	80023016 	blt	r16,zero,2040888 <___svfiprintf_internal_r+0x1134>
 203ffc8:	00bfdfc4 	movi	r2,-129
 203ffcc:	90a4703a 	and	r18,r18,r2
 203ffd0:	483fb21e 	bne	r9,zero,203fe9c <__alt_mem_mem_0+0xfd01fe9c>
 203ffd4:	00003d06 	br	20400cc <___svfiprintf_internal_r+0x978>
 203ffd8:	9817883a 	mov	r11,r19
 203ffdc:	d8002415 	stw	zero,144(sp)
 203ffe0:	18bff404 	addi	r2,r3,-48
 203ffe4:	0019883a 	mov	r12,zero
 203ffe8:	58c00007 	ldb	r3,0(r11)
 203ffec:	630002a4 	muli	r12,r12,10
 203fff0:	9cc00044 	addi	r19,r19,1
 203fff4:	9817883a 	mov	r11,r19
 203fff8:	1319883a 	add	r12,r2,r12
 203fffc:	18bff404 	addi	r2,r3,-48
 2040000:	30bff92e 	bgeu	r6,r2,203ffe8 <__alt_mem_mem_0+0xfd01ffe8>
 2040004:	db002415 	stw	r12,144(sp)
 2040008:	18bff804 	addi	r2,r3,-32
 204000c:	28be232e 	bgeu	r5,r2,203f89c <__alt_mem_mem_0+0xfd01f89c>
 2040010:	21003fcc 	andi	r4,r4,255
 2040014:	20024b1e 	bne	r4,zero,2040944 <___svfiprintf_internal_r+0x11f0>
 2040018:	1800d626 	beq	r3,zero,2040374 <___svfiprintf_internal_r+0xc20>
 204001c:	02c00044 	movi	r11,1
 2040020:	dac02015 	stw	r11,128(sp)
 2040024:	d8c01005 	stb	r3,64(sp)
 2040028:	d8001d85 	stb	zero,118(sp)
 204002c:	dac02115 	stw	r11,132(sp)
 2040030:	dc401004 	addi	r17,sp,64
 2040034:	003f2606 	br	203fcd0 <__alt_mem_mem_0+0xfd01fcd0>
 2040038:	94802014 	ori	r18,r18,128
 204003c:	98c00007 	ldb	r3,0(r19)
 2040040:	003e1306 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 2040044:	98c00007 	ldb	r3,0(r19)
 2040048:	9ac00044 	addi	r11,r19,1
 204004c:	1a822b26 	beq	r3,r10,20408fc <___svfiprintf_internal_r+0x11a8>
 2040050:	18bff404 	addi	r2,r3,-48
 2040054:	0021883a 	mov	r16,zero
 2040058:	30821e36 	bltu	r6,r2,20408d4 <___svfiprintf_internal_r+0x1180>
 204005c:	58c00007 	ldb	r3,0(r11)
 2040060:	840002a4 	muli	r16,r16,10
 2040064:	5cc00044 	addi	r19,r11,1
 2040068:	9817883a 	mov	r11,r19
 204006c:	80a1883a 	add	r16,r16,r2
 2040070:	18bff404 	addi	r2,r3,-48
 2040074:	30bff92e 	bgeu	r6,r2,204005c <__alt_mem_mem_0+0xfd02005c>
 2040078:	803e060e 	bge	r16,zero,203f894 <__alt_mem_mem_0+0xfd01f894>
 204007c:	043fffc4 	movi	r16,-1
 2040080:	003e0406 	br	203f894 <__alt_mem_mem_0+0xfd01f894>
 2040084:	21003fcc 	andi	r4,r4,255
 2040088:	2002371e 	bne	r4,zero,2040968 <___svfiprintf_internal_r+0x1214>
 204008c:	94800414 	ori	r18,r18,16
 2040090:	9080080c 	andi	r2,r18,32
 2040094:	103ebb1e 	bne	r2,zero,203fb84 <__alt_mem_mem_0+0xfd01fb84>
 2040098:	9080040c 	andi	r2,r18,16
 204009c:	10013b26 	beq	r2,zero,204058c <___svfiprintf_internal_r+0xe38>
 20400a0:	dac02317 	ldw	r11,140(sp)
 20400a4:	d8001d85 	stb	zero,118(sp)
 20400a8:	0013883a 	mov	r9,zero
 20400ac:	58800104 	addi	r2,r11,4
 20400b0:	5f000017 	ldw	fp,0(r11)
 20400b4:	80013d16 	blt	r16,zero,20405ac <___svfiprintf_internal_r+0xe58>
 20400b8:	00ffdfc4 	movi	r3,-129
 20400bc:	d8802315 	stw	r2,140(sp)
 20400c0:	90e4703a 	and	r18,r18,r3
 20400c4:	0015883a 	mov	r10,zero
 20400c8:	e03eba26 	beq	fp,zero,203fbb4 <__alt_mem_mem_0+0xfd01fbb4>
 20400cc:	00800244 	movi	r2,9
 20400d0:	173f7236 	bltu	r2,fp,203fe9c <__alt_mem_mem_0+0xfd01fe9c>
 20400d4:	dac02b17 	ldw	r11,172(sp)
 20400d8:	e7000c04 	addi	fp,fp,48
 20400dc:	df0019c5 	stb	fp,103(sp)
 20400e0:	dac02115 	stw	r11,132(sp)
 20400e4:	dc4019c4 	addi	r17,sp,103
 20400e8:	003eb606 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 20400ec:	21003fcc 	andi	r4,r4,255
 20400f0:	20021f1e 	bne	r4,zero,2040970 <___svfiprintf_internal_r+0x121c>
 20400f4:	94800414 	ori	r18,r18,16
 20400f8:	9080080c 	andi	r2,r18,32
 20400fc:	103ec51e 	bne	r2,zero,203fc14 <__alt_mem_mem_0+0xfd01fc14>
 2040100:	9080040c 	andi	r2,r18,16
 2040104:	10016926 	beq	r2,zero,20406ac <___svfiprintf_internal_r+0xf58>
 2040108:	dac02317 	ldw	r11,140(sp)
 204010c:	d8001d85 	stb	zero,118(sp)
 2040110:	0013883a 	mov	r9,zero
 2040114:	58800104 	addi	r2,r11,4
 2040118:	5f000017 	ldw	fp,0(r11)
 204011c:	80016b16 	blt	r16,zero,20406cc <___svfiprintf_internal_r+0xf78>
 2040120:	00ffdfc4 	movi	r3,-129
 2040124:	d8802315 	stw	r2,140(sp)
 2040128:	90e4703a 	and	r18,r18,r3
 204012c:	e03ec41e 	bne	fp,zero,203fc40 <__alt_mem_mem_0+0xfd01fc40>
 2040130:	0015883a 	mov	r10,zero
 2040134:	8001c226 	beq	r16,zero,2040840 <___svfiprintf_internal_r+0x10ec>
 2040138:	0039883a 	mov	fp,zero
 204013c:	0013883a 	mov	r9,zero
 2040140:	003ec006 	br	203fc44 <__alt_mem_mem_0+0xfd01fc44>
 2040144:	d8c01c17 	ldw	r3,112(sp)
 2040148:	d8801b17 	ldw	r2,108(sp)
 204014c:	d9001d87 	ldb	r4,118(sp)
 2040150:	20000b26 	beq	r4,zero,2040180 <___svfiprintf_internal_r+0xa2c>
 2040154:	d9001d84 	addi	r4,sp,118
 2040158:	18c00044 	addi	r3,r3,1
 204015c:	10800044 	addi	r2,r2,1
 2040160:	41000015 	stw	r4,0(r8)
 2040164:	01000044 	movi	r4,1
 2040168:	41000115 	stw	r4,4(r8)
 204016c:	d8c01c15 	stw	r3,112(sp)
 2040170:	d8801b15 	stw	r2,108(sp)
 2040174:	010001c4 	movi	r4,7
 2040178:	2080e116 	blt	r4,r2,2040500 <___svfiprintf_internal_r+0xdac>
 204017c:	42000204 	addi	r8,r8,8
 2040180:	dac02217 	ldw	r11,136(sp)
 2040184:	58000b26 	beq	r11,zero,20401b4 <___svfiprintf_internal_r+0xa60>
 2040188:	d9001d04 	addi	r4,sp,116
 204018c:	18c00084 	addi	r3,r3,2
 2040190:	10800044 	addi	r2,r2,1
 2040194:	41000015 	stw	r4,0(r8)
 2040198:	01000084 	movi	r4,2
 204019c:	41000115 	stw	r4,4(r8)
 20401a0:	d8c01c15 	stw	r3,112(sp)
 20401a4:	d8801b15 	stw	r2,108(sp)
 20401a8:	010001c4 	movi	r4,7
 20401ac:	2080dd16 	blt	r4,r2,2040524 <___svfiprintf_internal_r+0xdd0>
 20401b0:	42000204 	addi	r8,r8,8
 20401b4:	dac02617 	ldw	r11,152(sp)
 20401b8:	01002004 	movi	r4,128
 20401bc:	59008426 	beq	r11,r4,20403d0 <___svfiprintf_internal_r+0xc7c>
 20401c0:	dac02117 	ldw	r11,132(sp)
 20401c4:	82e1c83a 	sub	r16,r16,r11
 20401c8:	0400270e 	bge	zero,r16,2040268 <___svfiprintf_internal_r+0xb14>
 20401cc:	01c00404 	movi	r7,16
 20401d0:	3c016a0e 	bge	r7,r16,204077c <___svfiprintf_internal_r+0x1028>
 20401d4:	01408134 	movhi	r5,516
 20401d8:	294eac04 	addi	r5,r5,15024
 20401dc:	d9402215 	stw	r5,136(sp)
 20401e0:	070001c4 	movi	fp,7
 20401e4:	00000306 	br	20401f4 <___svfiprintf_internal_r+0xaa0>
 20401e8:	843ffc04 	addi	r16,r16,-16
 20401ec:	42000204 	addi	r8,r8,8
 20401f0:	3c00130e 	bge	r7,r16,2040240 <___svfiprintf_internal_r+0xaec>
 20401f4:	18c00404 	addi	r3,r3,16
 20401f8:	10800044 	addi	r2,r2,1
 20401fc:	45000015 	stw	r20,0(r8)
 2040200:	41c00115 	stw	r7,4(r8)
 2040204:	d8c01c15 	stw	r3,112(sp)
 2040208:	d8801b15 	stw	r2,108(sp)
 204020c:	e0bff60e 	bge	fp,r2,20401e8 <__alt_mem_mem_0+0xfd0201e8>
 2040210:	d9801a04 	addi	r6,sp,104
 2040214:	b80b883a 	mov	r5,r23
 2040218:	a809883a 	mov	r4,r21
 204021c:	d9c02c15 	stw	r7,176(sp)
 2040220:	203f5840 	call	203f584 <__ssprint_r>
 2040224:	d9c02c17 	ldw	r7,176(sp)
 2040228:	1000581e 	bne	r2,zero,204038c <___svfiprintf_internal_r+0xc38>
 204022c:	843ffc04 	addi	r16,r16,-16
 2040230:	d8c01c17 	ldw	r3,112(sp)
 2040234:	d8801b17 	ldw	r2,108(sp)
 2040238:	d811883a 	mov	r8,sp
 204023c:	3c3fed16 	blt	r7,r16,20401f4 <__alt_mem_mem_0+0xfd0201f4>
 2040240:	dac02217 	ldw	r11,136(sp)
 2040244:	1c07883a 	add	r3,r3,r16
 2040248:	10800044 	addi	r2,r2,1
 204024c:	42c00015 	stw	r11,0(r8)
 2040250:	44000115 	stw	r16,4(r8)
 2040254:	d8c01c15 	stw	r3,112(sp)
 2040258:	d8801b15 	stw	r2,108(sp)
 204025c:	010001c4 	movi	r4,7
 2040260:	20809e16 	blt	r4,r2,20404dc <___svfiprintf_internal_r+0xd88>
 2040264:	42000204 	addi	r8,r8,8
 2040268:	dac02117 	ldw	r11,132(sp)
 204026c:	10800044 	addi	r2,r2,1
 2040270:	44400015 	stw	r17,0(r8)
 2040274:	58c7883a 	add	r3,r11,r3
 2040278:	42c00115 	stw	r11,4(r8)
 204027c:	d8c01c15 	stw	r3,112(sp)
 2040280:	d8801b15 	stw	r2,108(sp)
 2040284:	010001c4 	movi	r4,7
 2040288:	20807f16 	blt	r4,r2,2040488 <___svfiprintf_internal_r+0xd34>
 204028c:	42000204 	addi	r8,r8,8
 2040290:	9480010c 	andi	r18,r18,4
 2040294:	90002926 	beq	r18,zero,204033c <___svfiprintf_internal_r+0xbe8>
 2040298:	dac02417 	ldw	r11,144(sp)
 204029c:	d8802017 	ldw	r2,128(sp)
 20402a0:	58a1c83a 	sub	r16,r11,r2
 20402a4:	0400250e 	bge	zero,r16,204033c <___svfiprintf_internal_r+0xbe8>
 20402a8:	04400404 	movi	r17,16
 20402ac:	d8801b17 	ldw	r2,108(sp)
 20402b0:	8c017c0e 	bge	r17,r16,20408a4 <___svfiprintf_internal_r+0x1150>
 20402b4:	01408134 	movhi	r5,516
 20402b8:	294eb004 	addi	r5,r5,15040
 20402bc:	d9402815 	stw	r5,160(sp)
 20402c0:	048001c4 	movi	r18,7
 20402c4:	00000306 	br	20402d4 <___svfiprintf_internal_r+0xb80>
 20402c8:	843ffc04 	addi	r16,r16,-16
 20402cc:	42000204 	addi	r8,r8,8
 20402d0:	8c00110e 	bge	r17,r16,2040318 <___svfiprintf_internal_r+0xbc4>
 20402d4:	18c00404 	addi	r3,r3,16
 20402d8:	10800044 	addi	r2,r2,1
 20402dc:	45800015 	stw	r22,0(r8)
 20402e0:	44400115 	stw	r17,4(r8)
 20402e4:	d8c01c15 	stw	r3,112(sp)
 20402e8:	d8801b15 	stw	r2,108(sp)
 20402ec:	90bff60e 	bge	r18,r2,20402c8 <__alt_mem_mem_0+0xfd0202c8>
 20402f0:	d9801a04 	addi	r6,sp,104
 20402f4:	b80b883a 	mov	r5,r23
 20402f8:	a809883a 	mov	r4,r21
 20402fc:	203f5840 	call	203f584 <__ssprint_r>
 2040300:	1000221e 	bne	r2,zero,204038c <___svfiprintf_internal_r+0xc38>
 2040304:	843ffc04 	addi	r16,r16,-16
 2040308:	d8c01c17 	ldw	r3,112(sp)
 204030c:	d8801b17 	ldw	r2,108(sp)
 2040310:	d811883a 	mov	r8,sp
 2040314:	8c3fef16 	blt	r17,r16,20402d4 <__alt_mem_mem_0+0xfd0202d4>
 2040318:	dac02817 	ldw	r11,160(sp)
 204031c:	1c07883a 	add	r3,r3,r16
 2040320:	10800044 	addi	r2,r2,1
 2040324:	42c00015 	stw	r11,0(r8)
 2040328:	44000115 	stw	r16,4(r8)
 204032c:	d8c01c15 	stw	r3,112(sp)
 2040330:	d8801b15 	stw	r2,108(sp)
 2040334:	010001c4 	movi	r4,7
 2040338:	2080aa16 	blt	r4,r2,20405e4 <___svfiprintf_internal_r+0xe90>
 204033c:	d8802417 	ldw	r2,144(sp)
 2040340:	dac02017 	ldw	r11,128(sp)
 2040344:	12c0010e 	bge	r2,r11,204034c <___svfiprintf_internal_r+0xbf8>
 2040348:	5805883a 	mov	r2,r11
 204034c:	dac02517 	ldw	r11,148(sp)
 2040350:	5897883a 	add	r11,r11,r2
 2040354:	dac02515 	stw	r11,148(sp)
 2040358:	1800531e 	bne	r3,zero,20404a8 <___svfiprintf_internal_r+0xd54>
 204035c:	98800007 	ldb	r2,0(r19)
 2040360:	d8001b15 	stw	zero,108(sp)
 2040364:	d811883a 	mov	r8,sp
 2040368:	103d231e 	bne	r2,zero,203f7f8 <__alt_mem_mem_0+0xfd01f7f8>
 204036c:	9823883a 	mov	r17,r19
 2040370:	003d3906 	br	203f858 <__alt_mem_mem_0+0xfd01f858>
 2040374:	d8801c17 	ldw	r2,112(sp)
 2040378:	10000426 	beq	r2,zero,204038c <___svfiprintf_internal_r+0xc38>
 204037c:	d9402717 	ldw	r5,156(sp)
 2040380:	d9002a17 	ldw	r4,168(sp)
 2040384:	d9801a04 	addi	r6,sp,104
 2040388:	203f5840 	call	203f584 <__ssprint_r>
 204038c:	dac02717 	ldw	r11,156(sp)
 2040390:	d8802517 	ldw	r2,148(sp)
 2040394:	58c0030b 	ldhu	r3,12(r11)
 2040398:	18c0100c 	andi	r3,r3,64
 204039c:	1801381e 	bne	r3,zero,2040880 <___svfiprintf_internal_r+0x112c>
 20403a0:	dfc03717 	ldw	ra,220(sp)
 20403a4:	df003617 	ldw	fp,216(sp)
 20403a8:	ddc03517 	ldw	r23,212(sp)
 20403ac:	dd803417 	ldw	r22,208(sp)
 20403b0:	dd403317 	ldw	r21,204(sp)
 20403b4:	dd003217 	ldw	r20,200(sp)
 20403b8:	dcc03117 	ldw	r19,196(sp)
 20403bc:	dc803017 	ldw	r18,192(sp)
 20403c0:	dc402f17 	ldw	r17,188(sp)
 20403c4:	dc002e17 	ldw	r16,184(sp)
 20403c8:	dec03804 	addi	sp,sp,224
 20403cc:	f800283a 	ret
 20403d0:	dac02417 	ldw	r11,144(sp)
 20403d4:	d9002017 	ldw	r4,128(sp)
 20403d8:	5939c83a 	sub	fp,r11,r4
 20403dc:	073f780e 	bge	zero,fp,20401c0 <__alt_mem_mem_0+0xfd0201c0>
 20403e0:	02400404 	movi	r9,16
 20403e4:	4f01370e 	bge	r9,fp,20408c4 <___svfiprintf_internal_r+0x1170>
 20403e8:	02c08134 	movhi	r11,516
 20403ec:	5aceac04 	addi	r11,r11,15024
 20403f0:	dac02215 	stw	r11,136(sp)
 20403f4:	028001c4 	movi	r10,7
 20403f8:	00000306 	br	2040408 <___svfiprintf_internal_r+0xcb4>
 20403fc:	e73ffc04 	addi	fp,fp,-16
 2040400:	42000204 	addi	r8,r8,8
 2040404:	4f00150e 	bge	r9,fp,204045c <___svfiprintf_internal_r+0xd08>
 2040408:	18c00404 	addi	r3,r3,16
 204040c:	10800044 	addi	r2,r2,1
 2040410:	45000015 	stw	r20,0(r8)
 2040414:	42400115 	stw	r9,4(r8)
 2040418:	d8c01c15 	stw	r3,112(sp)
 204041c:	d8801b15 	stw	r2,108(sp)
 2040420:	50bff60e 	bge	r10,r2,20403fc <__alt_mem_mem_0+0xfd0203fc>
 2040424:	d9801a04 	addi	r6,sp,104
 2040428:	b80b883a 	mov	r5,r23
 204042c:	a809883a 	mov	r4,r21
 2040430:	da402c15 	stw	r9,176(sp)
 2040434:	da802d15 	stw	r10,180(sp)
 2040438:	203f5840 	call	203f584 <__ssprint_r>
 204043c:	da402c17 	ldw	r9,176(sp)
 2040440:	da802d17 	ldw	r10,180(sp)
 2040444:	103fd11e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 2040448:	e73ffc04 	addi	fp,fp,-16
 204044c:	d8c01c17 	ldw	r3,112(sp)
 2040450:	d8801b17 	ldw	r2,108(sp)
 2040454:	d811883a 	mov	r8,sp
 2040458:	4f3feb16 	blt	r9,fp,2040408 <__alt_mem_mem_0+0xfd020408>
 204045c:	dac02217 	ldw	r11,136(sp)
 2040460:	1f07883a 	add	r3,r3,fp
 2040464:	10800044 	addi	r2,r2,1
 2040468:	42c00015 	stw	r11,0(r8)
 204046c:	47000115 	stw	fp,4(r8)
 2040470:	d8c01c15 	stw	r3,112(sp)
 2040474:	d8801b15 	stw	r2,108(sp)
 2040478:	010001c4 	movi	r4,7
 204047c:	2080b616 	blt	r4,r2,2040758 <___svfiprintf_internal_r+0x1004>
 2040480:	42000204 	addi	r8,r8,8
 2040484:	003f4e06 	br	20401c0 <__alt_mem_mem_0+0xfd0201c0>
 2040488:	d9801a04 	addi	r6,sp,104
 204048c:	b80b883a 	mov	r5,r23
 2040490:	a809883a 	mov	r4,r21
 2040494:	203f5840 	call	203f584 <__ssprint_r>
 2040498:	103fbc1e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 204049c:	d8c01c17 	ldw	r3,112(sp)
 20404a0:	d811883a 	mov	r8,sp
 20404a4:	003f7a06 	br	2040290 <__alt_mem_mem_0+0xfd020290>
 20404a8:	d9801a04 	addi	r6,sp,104
 20404ac:	b80b883a 	mov	r5,r23
 20404b0:	a809883a 	mov	r4,r21
 20404b4:	203f5840 	call	203f584 <__ssprint_r>
 20404b8:	103fa826 	beq	r2,zero,204035c <__alt_mem_mem_0+0xfd02035c>
 20404bc:	003fb306 	br	204038c <__alt_mem_mem_0+0xfd02038c>
 20404c0:	d9801a04 	addi	r6,sp,104
 20404c4:	b80b883a 	mov	r5,r23
 20404c8:	a809883a 	mov	r4,r21
 20404cc:	203f5840 	call	203f584 <__ssprint_r>
 20404d0:	103fae1e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 20404d4:	d811883a 	mov	r8,sp
 20404d8:	003cdc06 	br	203f84c <__alt_mem_mem_0+0xfd01f84c>
 20404dc:	d9801a04 	addi	r6,sp,104
 20404e0:	b80b883a 	mov	r5,r23
 20404e4:	a809883a 	mov	r4,r21
 20404e8:	203f5840 	call	203f584 <__ssprint_r>
 20404ec:	103fa71e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 20404f0:	d8c01c17 	ldw	r3,112(sp)
 20404f4:	d8801b17 	ldw	r2,108(sp)
 20404f8:	d811883a 	mov	r8,sp
 20404fc:	003f5a06 	br	2040268 <__alt_mem_mem_0+0xfd020268>
 2040500:	d9801a04 	addi	r6,sp,104
 2040504:	b80b883a 	mov	r5,r23
 2040508:	a809883a 	mov	r4,r21
 204050c:	203f5840 	call	203f584 <__ssprint_r>
 2040510:	103f9e1e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 2040514:	d8c01c17 	ldw	r3,112(sp)
 2040518:	d8801b17 	ldw	r2,108(sp)
 204051c:	d811883a 	mov	r8,sp
 2040520:	003f1706 	br	2040180 <__alt_mem_mem_0+0xfd020180>
 2040524:	d9801a04 	addi	r6,sp,104
 2040528:	b80b883a 	mov	r5,r23
 204052c:	a809883a 	mov	r4,r21
 2040530:	203f5840 	call	203f584 <__ssprint_r>
 2040534:	103f951e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 2040538:	d8c01c17 	ldw	r3,112(sp)
 204053c:	d8801b17 	ldw	r2,108(sp)
 2040540:	d811883a 	mov	r8,sp
 2040544:	003f1b06 	br	20401b4 <__alt_mem_mem_0+0xfd0201b4>
 2040548:	d8001d85 	stb	zero,118(sp)
 204054c:	80007b16 	blt	r16,zero,204073c <___svfiprintf_internal_r+0xfe8>
 2040550:	00ffdfc4 	movi	r3,-129
 2040554:	e244b03a 	or	r2,fp,r9
 2040558:	90e4703a 	and	r18,r18,r3
 204055c:	103d7026 	beq	r2,zero,203fb20 <__alt_mem_mem_0+0xfd01fb20>
 2040560:	0015883a 	mov	r10,zero
 2040564:	003d7206 	br	203fb30 <__alt_mem_mem_0+0xfd01fb30>
 2040568:	d9801a04 	addi	r6,sp,104
 204056c:	b80b883a 	mov	r5,r23
 2040570:	a809883a 	mov	r4,r21
 2040574:	203f5840 	call	203f584 <__ssprint_r>
 2040578:	103f841e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 204057c:	d8c01c17 	ldw	r3,112(sp)
 2040580:	d8801b17 	ldw	r2,108(sp)
 2040584:	d811883a 	mov	r8,sp
 2040588:	003ef006 	br	204014c <__alt_mem_mem_0+0xfd02014c>
 204058c:	9080100c 	andi	r2,r18,64
 2040590:	d8001d85 	stb	zero,118(sp)
 2040594:	dac02317 	ldw	r11,140(sp)
 2040598:	10008126 	beq	r2,zero,20407a0 <___svfiprintf_internal_r+0x104c>
 204059c:	58800104 	addi	r2,r11,4
 20405a0:	5f00000b 	ldhu	fp,0(r11)
 20405a4:	0013883a 	mov	r9,zero
 20405a8:	803ec30e 	bge	r16,zero,20400b8 <__alt_mem_mem_0+0xfd0200b8>
 20405ac:	d8802315 	stw	r2,140(sp)
 20405b0:	0015883a 	mov	r10,zero
 20405b4:	e244b03a 	or	r2,fp,r9
 20405b8:	103e371e 	bne	r2,zero,203fe98 <__alt_mem_mem_0+0xfd01fe98>
 20405bc:	00800044 	movi	r2,1
 20405c0:	10803fcc 	andi	r2,r2,255
 20405c4:	00c00044 	movi	r3,1
 20405c8:	10c06126 	beq	r2,r3,2040750 <___svfiprintf_internal_r+0xffc>
 20405cc:	00c00084 	movi	r3,2
 20405d0:	10fd5526 	beq	r2,r3,203fb28 <__alt_mem_mem_0+0xfd01fb28>
 20405d4:	003ed806 	br	2040138 <__alt_mem_mem_0+0xfd020138>
 20405d8:	d8802315 	stw	r2,140(sp)
 20405dc:	98c00007 	ldb	r3,0(r19)
 20405e0:	003cab06 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 20405e4:	d9801a04 	addi	r6,sp,104
 20405e8:	b80b883a 	mov	r5,r23
 20405ec:	a809883a 	mov	r4,r21
 20405f0:	203f5840 	call	203f584 <__ssprint_r>
 20405f4:	103f651e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 20405f8:	d8c01c17 	ldw	r3,112(sp)
 20405fc:	003f4f06 	br	204033c <__alt_mem_mem_0+0xfd02033c>
 2040600:	00808134 	movhi	r2,516
 2040604:	1083ce04 	addi	r2,r2,3896
 2040608:	d8802915 	stw	r2,164(sp)
 204060c:	003d4406 	br	203fb20 <__alt_mem_mem_0+0xfd01fb20>
 2040610:	dac02317 	ldw	r11,140(sp)
 2040614:	58800017 	ldw	r2,0(r11)
 2040618:	dac02517 	ldw	r11,148(sp)
 204061c:	5807d7fa 	srai	r3,r11,31
 2040620:	dac02317 	ldw	r11,140(sp)
 2040624:	10c00115 	stw	r3,4(r2)
 2040628:	5ac00104 	addi	r11,r11,4
 204062c:	dac02315 	stw	r11,140(sp)
 2040630:	dac02517 	ldw	r11,148(sp)
 2040634:	12c00015 	stw	r11,0(r2)
 2040638:	003c6d06 	br	203f7f0 <__alt_mem_mem_0+0xfd01f7f0>
 204063c:	9080100c 	andi	r2,r18,64
 2040640:	dac02317 	ldw	r11,140(sp)
 2040644:	103e5326 	beq	r2,zero,203ff94 <__alt_mem_mem_0+0xfd01ff94>
 2040648:	5f00000f 	ldh	fp,0(r11)
 204064c:	5ac00104 	addi	r11,r11,4
 2040650:	dac02315 	stw	r11,140(sp)
 2040654:	e013d7fa 	srai	r9,fp,31
 2040658:	4805883a 	mov	r2,r9
 204065c:	003e0706 	br	203fe7c <__alt_mem_mem_0+0xfd01fe7c>
 2040660:	00800c04 	movi	r2,48
 2040664:	d8801d05 	stb	r2,116(sp)
 2040668:	d8c01d45 	stb	r3,117(sp)
 204066c:	d8001d85 	stb	zero,118(sp)
 2040670:	90800094 	ori	r2,r18,2
 2040674:	80008f16 	blt	r16,zero,20408b4 <___svfiprintf_internal_r+0x1160>
 2040678:	00bfdfc4 	movi	r2,-129
 204067c:	90a4703a 	and	r18,r18,r2
 2040680:	94800094 	ori	r18,r18,2
 2040684:	0015883a 	mov	r10,zero
 2040688:	003d2906 	br	203fb30 <__alt_mem_mem_0+0xfd01fb30>
 204068c:	98c00007 	ldb	r3,0(r19)
 2040690:	003c7f06 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 2040694:	dac02317 	ldw	r11,140(sp)
 2040698:	0013883a 	mov	r9,zero
 204069c:	5f000017 	ldw	fp,0(r11)
 20406a0:	5ac00104 	addi	r11,r11,4
 20406a4:	dac02315 	stw	r11,140(sp)
 20406a8:	003d1506 	br	203fb00 <__alt_mem_mem_0+0xfd01fb00>
 20406ac:	9080100c 	andi	r2,r18,64
 20406b0:	d8001d85 	stb	zero,118(sp)
 20406b4:	dac02317 	ldw	r11,140(sp)
 20406b8:	10003426 	beq	r2,zero,204078c <___svfiprintf_internal_r+0x1038>
 20406bc:	58800104 	addi	r2,r11,4
 20406c0:	5f00000b 	ldhu	fp,0(r11)
 20406c4:	0013883a 	mov	r9,zero
 20406c8:	803e950e 	bge	r16,zero,2040120 <__alt_mem_mem_0+0xfd020120>
 20406cc:	e246b03a 	or	r3,fp,r9
 20406d0:	d8802315 	stw	r2,140(sp)
 20406d4:	183d5a1e 	bne	r3,zero,203fc40 <__alt_mem_mem_0+0xfd01fc40>
 20406d8:	0015883a 	mov	r10,zero
 20406dc:	0005883a 	mov	r2,zero
 20406e0:	003fb706 	br	20405c0 <__alt_mem_mem_0+0xfd0205c0>
 20406e4:	98c00043 	ldbu	r3,1(r19)
 20406e8:	94800814 	ori	r18,r18,32
 20406ec:	9cc00044 	addi	r19,r19,1
 20406f0:	18c03fcc 	andi	r3,r3,255
 20406f4:	18c0201c 	xori	r3,r3,128
 20406f8:	18ffe004 	addi	r3,r3,-128
 20406fc:	003c6406 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 2040700:	d8c02315 	stw	r3,140(sp)
 2040704:	0015883a 	mov	r10,zero
 2040708:	003faa06 	br	20405b4 <__alt_mem_mem_0+0xfd0205b4>
 204070c:	dac02317 	ldw	r11,140(sp)
 2040710:	58800017 	ldw	r2,0(r11)
 2040714:	5ac00104 	addi	r11,r11,4
 2040718:	dac02315 	stw	r11,140(sp)
 204071c:	dac02517 	ldw	r11,148(sp)
 2040720:	12c00015 	stw	r11,0(r2)
 2040724:	003c3206 	br	203f7f0 <__alt_mem_mem_0+0xfd01f7f0>
 2040728:	01008134 	movhi	r4,516
 204072c:	2103ce04 	addi	r4,r4,3896
 2040730:	d9002915 	stw	r4,164(sp)
 2040734:	d8c02315 	stw	r3,140(sp)
 2040738:	1025883a 	mov	r18,r2
 204073c:	e244b03a 	or	r2,fp,r9
 2040740:	103f871e 	bne	r2,zero,2040560 <__alt_mem_mem_0+0xfd020560>
 2040744:	0015883a 	mov	r10,zero
 2040748:	00800084 	movi	r2,2
 204074c:	003f9c06 	br	20405c0 <__alt_mem_mem_0+0xfd0205c0>
 2040750:	0039883a 	mov	fp,zero
 2040754:	003e5f06 	br	20400d4 <__alt_mem_mem_0+0xfd0200d4>
 2040758:	d9801a04 	addi	r6,sp,104
 204075c:	b80b883a 	mov	r5,r23
 2040760:	a809883a 	mov	r4,r21
 2040764:	203f5840 	call	203f584 <__ssprint_r>
 2040768:	103f081e 	bne	r2,zero,204038c <__alt_mem_mem_0+0xfd02038c>
 204076c:	d8c01c17 	ldw	r3,112(sp)
 2040770:	d8801b17 	ldw	r2,108(sp)
 2040774:	d811883a 	mov	r8,sp
 2040778:	003e9106 	br	20401c0 <__alt_mem_mem_0+0xfd0201c0>
 204077c:	01008134 	movhi	r4,516
 2040780:	210eac04 	addi	r4,r4,15024
 2040784:	d9002215 	stw	r4,136(sp)
 2040788:	003ead06 	br	2040240 <__alt_mem_mem_0+0xfd020240>
 204078c:	58800104 	addi	r2,r11,4
 2040790:	5f000017 	ldw	fp,0(r11)
 2040794:	0013883a 	mov	r9,zero
 2040798:	803e610e 	bge	r16,zero,2040120 <__alt_mem_mem_0+0xfd020120>
 204079c:	003fcb06 	br	20406cc <__alt_mem_mem_0+0xfd0206cc>
 20407a0:	58800104 	addi	r2,r11,4
 20407a4:	5f000017 	ldw	fp,0(r11)
 20407a8:	0013883a 	mov	r9,zero
 20407ac:	803e420e 	bge	r16,zero,20400b8 <__alt_mem_mem_0+0xfd0200b8>
 20407b0:	003f7e06 	br	20405ac <__alt_mem_mem_0+0xfd0205ac>
 20407b4:	5f000017 	ldw	fp,0(r11)
 20407b8:	5ac00104 	addi	r11,r11,4
 20407bc:	0013883a 	mov	r9,zero
 20407c0:	dac02315 	stw	r11,140(sp)
 20407c4:	003cce06 	br	203fb00 <__alt_mem_mem_0+0xfd01fb00>
 20407c8:	8809883a 	mov	r4,r17
 20407cc:	da002c15 	stw	r8,176(sp)
 20407d0:	20075700 	call	2007570 <strlen>
 20407d4:	d8802115 	stw	r2,132(sp)
 20407d8:	da801d83 	ldbu	r10,118(sp)
 20407dc:	df002315 	stw	fp,140(sp)
 20407e0:	0021883a 	mov	r16,zero
 20407e4:	da002c17 	ldw	r8,176(sp)
 20407e8:	003cf606 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 20407ec:	00800184 	movi	r2,6
 20407f0:	1400012e 	bgeu	r2,r16,20407f8 <___svfiprintf_internal_r+0x10a4>
 20407f4:	1021883a 	mov	r16,r2
 20407f8:	dc002115 	stw	r16,132(sp)
 20407fc:	8005883a 	mov	r2,r16
 2040800:	80003c16 	blt	r16,zero,20408f4 <___svfiprintf_internal_r+0x11a0>
 2040804:	04408134 	movhi	r17,516
 2040808:	d8802015 	stw	r2,128(sp)
 204080c:	df002315 	stw	fp,140(sp)
 2040810:	8c43d304 	addi	r17,r17,3916
 2040814:	003d2e06 	br	203fcd0 <__alt_mem_mem_0+0xfd01fcd0>
 2040818:	04001004 	movi	r16,64
 204081c:	800b883a 	mov	r5,r16
 2040820:	20057340 	call	2005734 <_malloc_r>
 2040824:	dac02717 	ldw	r11,156(sp)
 2040828:	58800015 	stw	r2,0(r11)
 204082c:	58800415 	stw	r2,16(r11)
 2040830:	10004826 	beq	r2,zero,2040954 <___svfiprintf_internal_r+0x1200>
 2040834:	dac02717 	ldw	r11,156(sp)
 2040838:	5c000515 	stw	r16,20(r11)
 204083c:	003bd906 	br	203f7a4 <__alt_mem_mem_0+0xfd01f7a4>
 2040840:	9080004c 	andi	r2,r18,1
 2040844:	0015883a 	mov	r10,zero
 2040848:	10000626 	beq	r2,zero,2040864 <___svfiprintf_internal_r+0x1110>
 204084c:	dac02b17 	ldw	r11,172(sp)
 2040850:	00800c04 	movi	r2,48
 2040854:	d88019c5 	stb	r2,103(sp)
 2040858:	dac02115 	stw	r11,132(sp)
 204085c:	dc4019c4 	addi	r17,sp,103
 2040860:	003cd806 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 2040864:	d8002115 	stw	zero,132(sp)
 2040868:	dc401a04 	addi	r17,sp,104
 204086c:	003cd506 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 2040870:	01008134 	movhi	r4,516
 2040874:	210eb004 	addi	r4,r4,15040
 2040878:	d9002815 	stw	r4,160(sp)
 204087c:	003d4306 	br	203fd8c <__alt_mem_mem_0+0xfd01fd8c>
 2040880:	00bfffc4 	movi	r2,-1
 2040884:	003ec606 	br	20403a0 <__alt_mem_mem_0+0xfd0203a0>
 2040888:	00800044 	movi	r2,1
 204088c:	10803fcc 	andi	r2,r2,255
 2040890:	00c00044 	movi	r3,1
 2040894:	10fd8026 	beq	r2,r3,203fe98 <__alt_mem_mem_0+0xfd01fe98>
 2040898:	00c00084 	movi	r3,2
 204089c:	10fca426 	beq	r2,r3,203fb30 <__alt_mem_mem_0+0xfd01fb30>
 20408a0:	003ce806 	br	203fc44 <__alt_mem_mem_0+0xfd01fc44>
 20408a4:	01008134 	movhi	r4,516
 20408a8:	210eb004 	addi	r4,r4,15040
 20408ac:	d9002815 	stw	r4,160(sp)
 20408b0:	003e9906 	br	2040318 <__alt_mem_mem_0+0xfd020318>
 20408b4:	1025883a 	mov	r18,r2
 20408b8:	0015883a 	mov	r10,zero
 20408bc:	00800084 	movi	r2,2
 20408c0:	003ff206 	br	204088c <__alt_mem_mem_0+0xfd02088c>
 20408c4:	01408134 	movhi	r5,516
 20408c8:	294eac04 	addi	r5,r5,15024
 20408cc:	d9402215 	stw	r5,136(sp)
 20408d0:	003ee206 	br	204045c <__alt_mem_mem_0+0xfd02045c>
 20408d4:	5827883a 	mov	r19,r11
 20408d8:	0021883a 	mov	r16,zero
 20408dc:	003bed06 	br	203f894 <__alt_mem_mem_0+0xfd01f894>
 20408e0:	dc002115 	stw	r16,132(sp)
 20408e4:	da801d83 	ldbu	r10,118(sp)
 20408e8:	df002315 	stw	fp,140(sp)
 20408ec:	0021883a 	mov	r16,zero
 20408f0:	003cb406 	br	203fbc4 <__alt_mem_mem_0+0xfd01fbc4>
 20408f4:	0005883a 	mov	r2,zero
 20408f8:	003fc206 	br	2040804 <__alt_mem_mem_0+0xfd020804>
 20408fc:	d8802317 	ldw	r2,140(sp)
 2040900:	98c00043 	ldbu	r3,1(r19)
 2040904:	5827883a 	mov	r19,r11
 2040908:	14000017 	ldw	r16,0(r2)
 204090c:	10800104 	addi	r2,r2,4
 2040910:	d8802315 	stw	r2,140(sp)
 2040914:	803f760e 	bge	r16,zero,20406f0 <__alt_mem_mem_0+0xfd0206f0>
 2040918:	18c03fcc 	andi	r3,r3,255
 204091c:	18c0201c 	xori	r3,r3,128
 2040920:	043fffc4 	movi	r16,-1
 2040924:	18ffe004 	addi	r3,r3,-128
 2040928:	003bd906 	br	203f890 <__alt_mem_mem_0+0xfd01f890>
 204092c:	d9c01d85 	stb	r7,118(sp)
 2040930:	003cb606 	br	203fc0c <__alt_mem_mem_0+0xfd01fc0c>
 2040934:	d9c01d85 	stb	r7,118(sp)
 2040938:	003d2106 	br	203fdc0 <__alt_mem_mem_0+0xfd01fdc0>
 204093c:	d9c01d85 	stb	r7,118(sp)
 2040940:	003d8e06 	br	203ff7c <__alt_mem_mem_0+0xfd01ff7c>
 2040944:	d9c01d85 	stb	r7,118(sp)
 2040948:	003db306 	br	2040018 <__alt_mem_mem_0+0xfd020018>
 204094c:	d9c01d85 	stb	r7,118(sp)
 2040950:	003c8a06 	br	203fb7c <__alt_mem_mem_0+0xfd01fb7c>
 2040954:	dac02a17 	ldw	r11,168(sp)
 2040958:	00800304 	movi	r2,12
 204095c:	58800015 	stw	r2,0(r11)
 2040960:	00bfffc4 	movi	r2,-1
 2040964:	003e8e06 	br	20403a0 <__alt_mem_mem_0+0xfd0203a0>
 2040968:	d9c01d85 	stb	r7,118(sp)
 204096c:	003dc706 	br	204008c <__alt_mem_mem_0+0xfd02008c>
 2040970:	d9c01d85 	stb	r7,118(sp)
 2040974:	003ddf06 	br	20400f4 <__alt_mem_mem_0+0xfd0200f4>
 2040978:	d9c01d85 	stb	r7,118(sp)
 204097c:	003d3706 	br	203fe5c <__alt_mem_mem_0+0xfd01fe5c>
 2040980:	d9c01d85 	stb	r7,118(sp)
 2040984:	003c5406 	br	203fad8 <__alt_mem_mem_0+0xfd01fad8>
 2040988:	d9c01d85 	stb	r7,118(sp)
 204098c:	003d1d06 	br	203fe04 <__alt_mem_mem_0+0xfd01fe04>

02040990 <__muldi3>:
 2040990:	223fffcc 	andi	r8,r4,65535
 2040994:	2006d43a 	srli	r3,r4,16
 2040998:	32bfffcc 	andi	r10,r6,65535
 204099c:	3012d43a 	srli	r9,r6,16
 20409a0:	4297383a 	mul	r11,r8,r10
 20409a4:	1a95383a 	mul	r10,r3,r10
 20409a8:	4251383a 	mul	r8,r8,r9
 20409ac:	5804d43a 	srli	r2,r11,16
 20409b0:	4291883a 	add	r8,r8,r10
 20409b4:	1205883a 	add	r2,r2,r8
 20409b8:	1a51383a 	mul	r8,r3,r9
 20409bc:	1280022e 	bgeu	r2,r10,20409c8 <__muldi3+0x38>
 20409c0:	00c00074 	movhi	r3,1
 20409c4:	40d1883a 	add	r8,r8,r3
 20409c8:	1006d43a 	srli	r3,r2,16
 20409cc:	21cf383a 	mul	r7,r4,r7
 20409d0:	314b383a 	mul	r5,r6,r5
 20409d4:	1004943a 	slli	r2,r2,16
 20409d8:	1a11883a 	add	r8,r3,r8
 20409dc:	5affffcc 	andi	r11,r11,65535
 20409e0:	3947883a 	add	r3,r7,r5
 20409e4:	12c5883a 	add	r2,r2,r11
 20409e8:	1a07883a 	add	r3,r3,r8
 20409ec:	f800283a 	ret

020409f0 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 20409f0:	defffd04 	addi	sp,sp,-12
 20409f4:	df000215 	stw	fp,8(sp)
 20409f8:	df000204 	addi	fp,sp,8
 20409fc:	e13fff15 	stw	r4,-4(fp)
 2040a00:	e0bfff17 	ldw	r2,-4(fp)
 2040a04:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 2040a08:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 2040a0c:	10000226 	beq	r2,zero,2040a18 <_exit+0x28>
    ALT_SIM_FAIL();
 2040a10:	002af070 	cmpltui	zero,zero,43969
 2040a14:	00000106 	br	2040a1c <_exit+0x2c>
  } else {
    ALT_SIM_PASS();
 2040a18:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 2040a1c:	003fff06 	br	2040a1c <__alt_mem_mem_0+0xfd020a1c>
